<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:36:24 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>RXGEN(1) AFS Command Reference RXGEN(1)</p>

<p style="margin-top: 1em">NAME <br>
rxgen - Stub generator for the Rx remote procedure call
package</p>

<p style="margin-top: 1em">SYNOPSIS <br>
rxgen [-h | -c | -C | -S | -r] [-dkpR] <br>
[-I dir] [-P prefix] [-o outfile] [infile]</p>

<p style="margin-top: 1em">rxgen -s transport [-o outfile]
[infile]</p>

<p style="margin-top: 1em">rxgen -l [-o outfile]
[infile]</p>

<p style="margin-top: 1em">rxgen -m [-o outfile]
[infile]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
rxgen is a tool that generates C code to implement the Rx
RPC protocol; it takes as input a description of an
application interface similar to C and produces a number of
server <br>
and/or client stub routines to be linked with RPC-based
programs. These stubs allow programs to invoke remote
procedures through local procedure calls. rxgen is an
extension of <br>
Sun&rsquo;s rpcgen (version 3.9) and retains full rpcgen
functionality (at least as of that version). Please refer to
rpcgen(1) for more details on the Sun&rsquo;s RPC specific
flags, and <br>
to the RPC programming guide regarding the RPC language
along with useful examples.</p>

<p style="margin-top: 1em">OPTIONS <br>
rxgen operates in several different modes. The generated
output files can be produced individually (using one of -h,
-c, -C, or -S) or collectively. All output files are <br>
created when the default is used (i.e., no options), or the
output is limited to the server stubs (-C and -S) when the
-r flag is used. The following describes the types of <br>
generated output files (for simplicity, filename refers to
the main output filename):</p>

<p style="margin-top: 1em">-h Generate C data definitions
(a header file) from standard RPCL definitions (default
extension: filename.h).</p>

<p style="margin-top: 1em">-c Compile the XDR routines
required to serialize the protocol described by RPCL.
Generate XDR routines for all declarations (default
extension: filename.xdr.c).</p>

<p style="margin-top: 1em">-C Generate all the client-side
stub routines (default extension: filename.cs.c). Calling a
routine in this file will cause the arguments to be packed
up and sent via Rx (or <br>
R).</p>

<p style="margin-top: 1em">-S Generate all the server-side
stub routines (default extension: filename.ss.c). Arguments
are unpacked, and the corresponding server routine is
called.</p>

<p style="margin-top: 1em">-r Generate the two default
extension files produced by the -C and -S options.</p>

<p style="margin-top: 1em">The following options can be
used on any combination of rxgen calls:</p>

<p style="margin-top: 1em">-R Generate code for the older
protocol, as opposed to Rx, which is the default.</p>

<p style="margin-top: 1em">-k Must be specified when the
generated code is intended to be used by the kernel; special
&quot;includes&quot; and other specifics are produced when
the target output is for the kernel.</p>

<p style="margin-top: 1em">-p Package combination flag:
when multiple packages are included within a single
specification file, a single Execute Request routine will be
used for all of them as a result of <br>
this flag. The default is to generate individual Execute
Request stubs for each package.</p>

<p style="margin-top: 1em">-I dir <br>
Similar to the -I flag in the C compiler (cc). This flag is
passed to the pre-processor (cpp) so that directory dir is
searched before the standard lookup list for #include <br>
files. As expected, multiple -I flags can be used
simultaneously.</p>

<p style="margin-top: 1em">-P prefix <br>
The prefix string following this switch is prepended to all
generated output files; useful when multiple runs want to
produce different versions of the same interface (say, <br>
kernel and non-kernel versions).</p>

<p style="margin-top: 1em">-d Debugging mode; only needed
when rxgen is to be debugged (say, via dbx).</p>

<p style="margin-top: 1em">-o outfile <br>
Specify the name of the output file. If none is specified,
the standard output is used (-c, -h, -C, and -S modes only).
Note that if an output file is specified in a multi- <br>
output file option (such as the default, or with option -r),
then the outfile replaces the name generated by default
(which is based on the configuration&rsquo;s main file
name).</p>

<p style="margin-top: 1em">The -s, -l, and -m options are
present only for rpcgen support. See rpcgen(1) for
information on their use.</p>

<p style="margin-top: 1em">rxgen SYNTAX SUMMARY <br>
Specification file:</p>

<p style="margin-top: 1em">&lt;Package description
option&gt; | <br>
&lt;Prefix description option&gt; | <br>
&lt;StartingOpcode description option&gt; | <br>
&lt;SplitPrefix description option&gt; | <br>
&lt;Procedure description option&gt; | <br>
&lt;RPCL language description option&gt;</p>

<p style="margin-top: 1em">&lt;Package description
option&gt;:</p>

<p style="margin-top: 1em">&quot;package&quot;
&lt;Package_ident&gt;</p>

<p style="margin-top: 1em">&lt;Prefix description
option&gt;:</p>

<p style="margin-top: 1em">&quot;prefix&quot;
&lt;Prefix_ident&gt;</p>

<p style="margin-top: 1em">&lt;StartingOpcode description
option&gt;:</p>

<p style="margin-top: 1em">&quot;startingopcode&quot;
&lt;constant&gt;</p>

<p style="margin-top: 1em">&lt;SplitPrefix description
option&gt;:</p>

<p style="margin-top: 1em">&quot;splitprefix&quot;
&lt;split options&gt; &quot;;&quot;</p>

<p style="margin-top: 1em">&lt;Split options&gt;:</p>

<p style="margin-top: 1em">&quot;IN =&quot;
&lt;Start_prefix_ident&gt; &quot;|&quot; <br>
&quot;OUT =&quot; &lt;End_prefix_ident&gt; &quot;|&quot;
<br>
&lt;Split options&gt;</p>

<p style="margin-top: 1em">&lt;Procedure description
option&gt;:</p>

<p style="margin-top: 1em">[&quot;proc&quot;]
[&lt;Procedure_ident&gt;] [&lt;ServerStub_ident&gt;] <br>
&lt;Argument list&gt; [&quot;split&quot; |
&quot;multi&quot;] <br>
[&quot;=&quot; &lt;Opcode_ident&gt;] &quot;;&quot;</p>

<p style="margin-top: 1em">&lt;Argument list&gt;:</p>

<p style="margin-top: 1em">&quot;(&quot; &lt;Argument
definition&gt; &lt;Comma_joined argument&gt;
&quot;)&quot;</p>

<p style="margin-top: 1em">&lt;Argument definition&gt;:</p>

<p style="margin-top: 1em">&lt;Direction option&gt;
&lt;Standard RPCL type decl&gt; &lt;Arg_ident&gt; <br>
[&quot;&lt;&quot; &lt;Max_size&gt; &quot;&gt;&quot; |
&quot;[&quot; &lt;Max_size&gt; &quot;]&quot;] | NULL</p>

<p style="margin-top: 1em">&lt;Comma_joined
argument&gt;:</p>

<p style="margin-top: 1em">&quot;,&quot; &lt;Argument
definition&gt; | NULL</p>

<p style="margin-top: 1em">&lt;Direction option&gt;:</p>

<p style="margin-top: 1em">&quot;IN&quot; | &quot;OUT&quot;
| &quot;INOUT&quot; | NULL</p>

<p style="margin-top: 1em">&lt;Max_size&gt;:</p>

<p style="margin-top: 1em">&lt;constant&gt; | NULL</p>

<p style="margin-top: 1em">&lt;Package_ident&gt;: <br>
&lt;Prefix_ident&gt;: <br>
&lt;String_ident&gt;: <br>
&lt;Start_prefix_ident&gt;: <br>
&lt;End_prefix_ident&gt;: <br>
&lt;Procedure_ident&gt;: <br>
&lt;ServerStub_ident&gt;: <br>
&lt;Arg_ident&gt;: <br>
&lt;Opcode_ident&gt;:</p>

<p style="margin-top: 1em">&lt;identifier&gt;</p>

<p style="margin-top: 1em">&lt;RPCL language description
option&gt;: <br>
&lt;Standard RPCL type decl&gt;:</p>

<p style="margin-top: 1em">Sun&rsquo;s RPCL language syntax
(see rpcgen(1))</p>

<p style="margin-top: 1em">rxgen COMMANDS <br>
Comments and Preprocessing <br>
The input interface may contain preprocessor directives
which are passed through the C preprocessor (i.e.
&quot;cpp&quot;). Since the preprocessor runs on all input
files before they are <br>
actually interpreted by rxgen, all cpp directives (#include,
#ifdefs, #defines, etc.) are legal and welcomed within an
rxgen input file. Of course, none of these preprocessor <br>
directives will be included in any of the generated files.
To facilitate distinctions between the different types of
output files, rxgen defines certain special cpp symbols for
<br>
use by the rxgen programmer. These are RPC_HDR (defined when
compiling into header, filename.h, files), RPC_XDR (defined
when compiling into xdr, filename.xdr.c, files), <br>
RPC_CLIENT (defined when compiling into client stubs,
filename.cs.c, files), and RPC_SERVER (defined when
compiling into server stubs, filename.ss.c, files).</p>

<p style="margin-top: 1em">In addition, rxgen does a little
preprocessing of its own. Any line beginning with
&quot;%&quot; is passed directly into the output file,
uninterpreted by rxgen. For a more heavy en <br>
masse dumping of uninterpreted code, it would be advised to
include all such code in an &quot;#include&quot; file and
pass it in preceded by &quot;%&quot;. The input interface
may also contain any <br>
C-style comments which are, of course, ignored.
Interpretation is token-based, thus special line-orientation
of separate statements is not necessary. rxgen also provides
a quite <br>
rich and helpful set of error reports, identifying them by
exact line location and error type. Also, rxgen will
automatically generate #include lines for standard include
files, <br>
such as rx/xdr.h and rx/rx.h, along with the generated
header file from this interface.</p>

<p style="margin-top: 1em">Prefixing stub procedures <br>
The package statement tells rxgen the name of the interface
package. It is used for prefixing the naming of all
generated stub routines and the execute request procedure.
For <br>
example:</p>

<p style="margin-top: 1em">package AFS_</p>

<p style="margin-top: 1em">causes the execute request
procedure to be named AFS_ExecuteRequest (Warning: in the
older version an additional &quot;_&quot; was appended after
the package name to the ExecuteRequest <br>
name; thus make sure you don&rsquo;t have an ExecuteRequest
interface routine) and a given stub routine, say Fetch, to
be actually named AFS_Fetch. Multiple package statements
<br>
(current maximum size is 10) per configuration are permitted
and are useful when multiple sets of interfaces are
implemented (see the example at the end). Note that in such
<br>
cases, use of the -p flag results in the generation of just
one ExecuteRequest procedure which recognizes the multiple
interfaces and whose name is prefixed by the first package
<br>
statement. In the default case, independent ExecuteRequest
procedures will be created for each packaged group of remote
procedure calls.</p>

<p style="margin-top: 1em">The prefix statement supplies a
name to prepend to all calls to remote procedure names in
the ExecuteRequest stub routine. It is useful when the
server makes RPC calls to other <br>
servers (say, for debugging purposes). For example:</p>

<p style="margin-top: 1em">prefix S</p>

<p style="margin-top: 1em">causes the name &quot;S&quot; to
be prepended to the name of all routines called from the
server stubs. The server can then call the original name and
get the client stubs.</p>

<p style="margin-top: 1em">rxgen procedure declaration <br>
The proc statement is the most common (and meaningful) in
the rxgen interface. Its syntax description is:</p>

<p style="margin-top: 1em">[proc] [&lt;proc_name&gt;]
[&lt;server_stub&gt;] (&lt;arg&gt;, ..., &lt;arg&gt;) <br>
[split | multi] [= &lt;opcode&gt;] ;</p>

<p style="margin-top: 1em">where:</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;proc&quot;
is an optional prefix of the procedure statement. This is
just a stylistic item and not a required procedure
delimiter.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&lt;proc_name&gt; is the name of the procedure. Note that
even the name of the procedure is optional. This only makes
sense when the name of the given procedure is identical to
the <br>
name of the last package statement (i.e., &quot;package
RCallBack&quot; and the declaration of the
&quot;RCallBack&quot; procedure).</p>

<p style="margin-top: 1em">&Acirc;&middot;
&lt;server_stub&gt;, if present, causes the ExecuteRequest
procedure to call that stub instead of the automatically
generated stub when a call with that opcode is decoded.</p>

<p style="margin-top: 1em">&Acirc;&middot; &lt;opcode&gt;
is a constant or symbol that is the opcode for that
procedure. One might use the preprocessor features (i.e.,
#define), the const RPC-language feature, or the old <br>
good constants as opcodes. Some further
evaluation/processing of opcodes is done. Particularly,
checks for duplicate and non-existent opcodes are performed,
along with checks <br>
for &quot;holes&quot; (i.e., gaps in consecutive opcodes) in
the opcode sequences. For example, we use the fact that when
&quot;holes&quot; in opcodes exist, the ExecuteRequest
procedure uses the <br>
case statement rather than the faster (and smaller,
codewise) indexed array method.</p>

<p style="margin-top: 1em">Also, rxgen defines (i.e.,
appends to the header file) three valuable macros for each
package group: &lt;package-name&gt;LOWEST_OPCODE,
&lt;package-name&gt;HIGHEST_OPCODE, and <br>
&lt;package-name&gt;NUMBER_OPCODES. These may be useful to
the rxgen programmer. Also, notice that the opcode statement
is an optional feature, and can be omitted. In such cases,
<br>
automatic opcode numbers are generated sequentially,
starting from 0.</p>

<p style="margin-top: 1em">One can change the initial
opcode number by using the startingopcode (for lack of a
better name) rxgen command. Its syntax is:</p>

<p style="margin-top: 1em">startingopcode
&lt;constant&gt;</p>

<p style="margin-top: 1em">where &lt;constant&gt; must be
reasonable! Note that one can not mix procedures, some with
opcodes and some without, nor allow opcodes after the
specification of the startingopcode <br>
statement. rxgen will complain in all such cases.</p>

<p style="margin-top: 1em">&Acirc;&middot; The argument
entry represents a given parameter of the procedure. Its
syntax is:</p>

<p style="margin-top: 1em">[IN | INOUT | OUT |
&lt;null&gt;] &lt;type_decl&gt; &lt;arg_name&gt; <br>
[&lt;max&gt;|&lt;&gt;|[max]|[]]</p>

<p style="margin-top: 1em">If the type is an indirect type
(i.e., is followed by *), it is assumed that the pointer
should be followed one level and the data pointed to is to
be transmitted. This should <br>
normally be used for all structures/arrays and out
parameters. A noticeable exception is when explicit
array/structure maximum size is given; since no
array-of-pointer <br>
declarations are allowed one should use typedefs to achieve
the similar effect. The parameters could be input parameters
(preceded by IN), output parameters (preceded by OUT), <br>
or input/output parameters (preceded by INOUT). If not
specified, then the direction of the previous parameter in
the procedure is used. (Note: the first parameter must be
<br>
preceded by the directional primitive!)</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;split&quot; is a hack to handle stub routines that do
things such as file transfers or any other operation that
has to exchange information (e.g., length of a file) before
the call <br>
returns its output parameters. Because of the particular
handshake that is involved when doing remote file transfer,
we currently break all such calls into two client-side <br>
stub routines. The first (with the default prefix of
&quot;Begin&quot;) is used to pass all IN and INOUT
parameters to the server side. The second (with the default
prefix of &quot;End&quot;) is <br>
used to get back the INOUT and OUT parameters from the
server. Between the two calls, the user is supposed to do
the appropriate calls for the file transfer. For example,
the <br>
following procedure declaration in package AFS_</p>

<p style="margin-top: 1em">Fetch (IN a, b,INOUT c, OUT d)
split = FETCHOPCODE;</p>

<p style="margin-top: 1em">will roughly generate the two
independent client stub routines:</p>

<p style="margin-top: 1em">BeginAFS_Fetch (IN a, b, c)</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">EndAFS_Fetch(OUT c, d)</p>

<p style="margin-top: 1em">The splitprefix statement is
used to change the default prefix names used by the two
client-side stub generated routines when dealing with file
transfer-related procedure <br>
calls. For example:</p>

<p style="margin-top: 1em">splitprefix IN=Before_
OUT=After_</p>

<p style="margin-top: 1em">will cause the naming of the two
client stubs for a file transfer-related routine, say
Fetch(), to be Before_AFS_Fetch() and After_AFS_Fetch(),
respectively.</p>

<p style="margin-top: 1em">&Acirc;&middot; The
&quot;multi&quot; option is nearly identical to the
&quot;split&quot; feature described above. The only
significant visible difference is that along with the two
client stubs, the standard <br>
client stub is also generated. Since the intention is to
handle the multi-Rx calls, we need the whole standard
procedure stub in the cases where no multi-Rx call of the
<br>
procedure is performed. A side effect of the
&quot;multi&quot; option is the generation of a special
macro (i.e., &quot;multi_&lt;Procedure-name&gt;&quot; which
passes back as arguments the &quot;Begin&quot; and <br>
&quot;End&quot; stubs in the header output file. This macro
is used directly by the Rx code when a multi-Rx call of this
procedure is performed.</p>

<p style="margin-top: 1em">OBSOLETE rxgen FEATURES <br>
Although the following rxgen commands are still in effect,
they will soon be removed since there are better
alternatives. DO NOT USE THEM!</p>

<p style="margin-top: 1em">The special statement is a
temporary hack used to handle certain inefficiencies of
standard xdr routines to handle some user-customized
declarations. In particular, this applies <br>
to a string pointer specified as part of a declaration. For
example,</p>

<p style="margin-top: 1em">special struct BBS SeqBody;</p>

<p style="margin-top: 1em">tells rxgen that the entry
&quot;SeqBody&quot; in the user-defined BBS xdr routine is a
string (note that more than one string can be
&quot;special&quot; per structure -- multiple ones are
separated <br>
by commas); it will thus allocate and de-allocate space
properly in the server-generated stubs that contain this
structure as an IN or INOUT parameter.</p>

<p style="margin-top: 1em">A better alternative to special
is the customized statement, which is simply the
&quot;customized&quot; token followed by the regular
declaration of a struct based on the RPCL rules. In <br>
this case, the declaration will be included in the generated
header file (-h option) but no xdr routine will be generated
for this structure -- the user will supply this. All <br>
pointer entries in this structure will be remembered so when
the structure is used as an IN or INOUT in the server stub,
no core leaks will occur. For example, consider</p>

<p style="margin-top: 1em">customized struct CBS { <br>
long Seqlen; <br>
char *SeqBody; <br>
}</p>

<p style="margin-top: 1em">The &quot;xdr_CBS&quot; routine
would be provided by the user where during the DECODE xdr
opcode, appropriate space for the &quot;SeqBody&quot; string
is allocated. Similarly, that space is freed <br>
during the FREE xdr opcode.</p>

<p style="margin-top: 1em">Note: Old style &quot;Array
parameter specifications&quot; are not supported any
more.</p>

<p style="margin-top: 1em">EXAMPLES <br>
In case there are some requirements not available by the
current RPC language, one can customize some XDR routines by
leaving those data types undefined. For every data type that
<br>
is undefined, it will be assumed that a routine exists with
the name &quot;xdr_&quot; prepended to it. A selected set of
rxgen features is presented below, but for a more
comprehensive <br>
one (unions, complex examples, etc) please refer to the
rpcgen Programming Guide and eXternal Data Representation:
Sun Technical Notes.</p>

<p style="margin-top: 1em">Typedefs <br>
The RPC typedef statement is identical to the C typedef
(i.e. &quot;typedef &lt;declaration&gt;&quot;). By default,
most user declarations (i.e. structs, unions, etc) are
automatically <br>
typedef&rsquo;ed by rxgen. Since it makes parsing simpler,
its usage is recommended by rxgen scripts.</p>

<p style="margin-top: 1em">Strings <br>
The C &quot;char *&quot; string convention is kind of
ambiguous, since it is usually intended to mean a
null-terminated string of characters, but it could also
represent a pointer to a <br>
single character, a pointer to an array of characters, etc.
In the RPC language, a null-terminated string is
unambiguously called a &quot;string&quot;. Examples,</p>

<p style="margin-top: 1em">string bigname&lt;&gt;; <br>
string name&lt;MAXNAMELEN&gt;; <br>
typedef string volname&lt;MAXVOLNAME&gt;;</p>

<p style="margin-top: 1em">Notice that the maximum size of
string can be arbitrary (like &quot;bigname&quot; above) or,
preferably, or specified in angle brackets (i.e.
&quot;name&quot; and &quot;volname&quot; above). In
practice, one <br>
should always use only bounded strings in interfaces. A
sample calling proc using the declarations above would
be:</p>

<p style="margin-top: 1em">GetEntryByName (IN volname name,
<br>
OUT struct vldbentry *entry) = VL_GETENTRYBYNAME;</p>

<p style="margin-top: 1em">or, of course,</p>

<p style="margin-top: 1em">GetEntryByName (IN string
volname&lt;MAXVOLNAME&gt;, <br>
OUT struct vldbentry *entry) = VL_GETENTRYBYNAME;</p>

<p style="margin-top: 1em">It is very important for the
user to understand when the string parameters should be
allocated and/or freed by the his/her client and/or server
programs. A short analysis on <br>
string parameters handling follows (note that a similar
method is used for the handling of variable length arrays as
it will be shown later on):</p>

<p style="margin-top: 1em">&Acirc;&middot; In the client
side: IN and INOUT string parameters are the
programmer&rsquo;s responsibility and should be allocated
(static or via malloc) before calling the rpc and freed (if
<br>
malloc was used) after the rpc&rsquo;s return in the
user&rsquo;s client program; of course, for INOUT
parameters, the returned string can&rsquo;t be bigger than
the malloced input string.</p>

<p style="margin-top: 1em">OUT string parameters are
automatically malloced (based on the length of the returned
string and not the maxsize) by the rxgen client stubs (in
filename.cs.c) and must be freed <br>
by the client program; admittedly, this could be somewhat
confusing since the user needs to free something that he/she
didn&rsquo;t allocate.}</p>

<p style="margin-top: 1em">&Acirc;&middot; In the server
side: IN and INOUT string parameters are automatically
malloced (based on the size of incoming strings) by the
rxgen server stubs (in filename.ss.c) before they <br>
are passed to the user&rsquo;s server procedure; that space
is automatically freed just before the rxgen server stub
returns; therefore the user need not do anything special for
IN <br>
and INOUT string parameters.</p>

<p style="margin-top: 1em">OUT string parameters must be
malloced by the user&rsquo;s server procedure (i.e. null
pointer is passed to it by the rxgen server stub) and it is
automatically freed at the end of <br>
the rxgen server stub. Like in the client side, the OUT
parameters are somewhat unorthodox (i.e. the server routine
must malloc a string without ever freeing it itself; this
<br>
is done by the rxgen server stub).</p>

<p style="margin-top: 1em">Note that for INOUT and OUT
string parameters, in both the client and server sides their
arguments must be char of pointers (i.e. char **).</p>

<p style="margin-top: 1em">Pointers <br>
Pointer declarations in RPC are also exactly as they are in
C (i.e. &quot;struct single_vldbentry *vldblist;&quot;). Of
course, one can&rsquo;t send pointers over the network, but
one can use <br>
XDR pointers for sending recursive data types such as lists
and trees (an example of a linked list will be demonstrated
shortly).</p>

<p style="margin-top: 1em">Arrays <br>
Fixed arrays are just like standard C array declarations
(i.e. &quot;struct UpdateEntry entries[20]&quot;) without
any side effect problems in rxgen. Since variable-length
arrays have no <br>
explicit syntax in C, the angle-brackets are used for it and
the array declarations are actually compiled into
&quot;struct&quot;s. For example, declarations such as:</p>

<p style="margin-top: 1em">const MAXBULKSIZE = 10000; <br>
const MAXENTRIES = 100; <br>
opaque bulk&lt;MAXBULKSIZE&gt;; /* At most 10000 items */
<br>
int hosts&lt;&gt;; /* any number of items */ <br>
typedef vldbentry blkentries&lt;100&gt;; /* Preferable array
decl */</p>

<p style="margin-top: 1em">are compiled into the following
structs:</p>

<p style="margin-top: 1em">struct { <br>
u_int bulk_len; /* no of items */ <br>
char *bulk_val; /* pointer to array */ <br>
} bulk;</p>

<p style="margin-top: 1em">for the &quot;bulk&quot; array,
and similarly for the &quot;blkentries&lt;100&gt;&quot;
array,</p>

<p style="margin-top: 1em">struct { <br>
u_int blkentries_len; /* no of items in array */ <br>
vldbentry *blkentries_val; /* pointer to array */ <br>
} blkentries;</p>

<p style="margin-top: 1em">Therefore the user should be
aware of the &quot;magically&quot; generated structure
entries such as the number of items in the array
(&lt;array_name&gt;_len) and the pointer to the array <br>
(&lt;array_name&gt;_val) since some of the entries will have
to be filled in from the client/server programs. A sample
proc would be:</p>

<p style="margin-top: 1em">typedef vldbentry
blkentries&lt;MAXENTRIES&gt;; <br>
proc GetBlk (OUT blkentries *vlentries) = VL_GETBLK;</p>

<p style="margin-top: 1em">or, more directly,</p>

<p style="margin-top: 1em">GetBlk(OUT vldbentry
vlentries&lt;MAXENTRIES&gt;) = VL_GETBLK;</p>

<p style="margin-top: 1em">Note that although the latest
method is preferable since one does not have to first use
the typedef statement (and admittedly, programmers prefer
avoiding typedefs), one should <br>
realize that rxgen does the structure expansion and the xdr
creation implicitly; therefore the user should be aware of
the &quot;vldbentries_val&quot; and
&quot;vldbentries_len&quot; fields as <br>
before (see following examples).</p>

<p style="margin-top: 1em">Array example I (least
desirable)</p>

<p style="margin-top: 1em">Procedure declaration in the
interface configuration:</p>

<p style="margin-top: 1em">proc ListAttributes (IN
vldblistbyattributes *attributes, <br>
INOUT blkentries *vldbentries) = VL_LISTATTRIBUTES;</p>

<p style="margin-top: 1em">Sample CLIENT code:</p>

<p style="margin-top: 1em">blkentries entries, *pnt; <br>
entries.blkentries_len = 10; /* max # returned entries */
<br>
entries.blkentries_val = (vldbentry *)malloc(LEN); <br>
/* It must be set */</p>

<p style="margin-top: 1em">code =
VL_ListAttributes(&amp;attributes, &amp;entries); <br>
if (!code) { <br>
pnt = entries.blkentries_val; <br>
for (i=0; i &lt; entries.blkentries_len; i++, pnt++) <br>
display_vldbentry(pnt); <br>
/* Make sure you free the allocated space */ <br>
free((char *)entries.blkentries_val); <br>
}</p>

<p style="margin-top: 1em">Sample SERVER code:</p>

<p style="margin-top: 1em">VL_ListAttributes(attributes,
entries) <br>
{ <br>
vldbentry *singleentry = entries-&gt;blkentries_val; <br>
entries-&gt;blkentries_len = 0;</p>

<p style="margin-top: 1em">while
(copy_to_vldbentry(&amp;vlentry, singleentry)) <br>
singleentry++, vldbentries-&gt;entries_len++; <br>
}</p>

<p style="margin-top: 1em">Although this method for
variable-size arrays works fine, there are some major
drawbacks. The array parameter (i.e. vldbentries above) must
be declared as INOUT since we need to <br>
pass the max length of the expected returned array; more
importantly, a big (depending on the value of
&quot;_len&quot;) chunk of junk code is going to be
transferred to the server as <br>
result of the IN(out) side-effect of the array. It&rsquo;s
an easy and convenient method if the returned array size can
be predicted from the start and when the size is quite high.
<br>
This method is included as an example of erroneous use (and
abuse) of rxgen and should not be used.</p>

<p style="margin-top: 1em">Array example II (Desirable
method)</p>

<p style="margin-top: 1em">Procedure declaration in the
interface configuration (using Example I above):</p>

<p style="margin-top: 1em">proc ListAttributes (IN
vldblistbyattributes *attributes, <br>
OUT blkentries *vldbentries) = VL_LISTATTRIBUTES;</p>

<p style="margin-top: 1em">Sample CLIENT code:</p>

<p style="margin-top: 1em">blkentries entries, *pnt;</p>

<p style="margin-top: 1em">code =
VL_ListAttributes(&amp;attributes, &amp;entries); <br>
if (!code) { <br>
pnt = entries.blkentries_val; <br>
for (i=0; i &lt; entries.blkentries_len; i++, pnt++) <br>
display_vldbentry(pnt); <br>
/* Make sure you free the allocated space (by rxgen) */ <br>
free((char *)entries.blkentries_val); <br>
}</p>

<p style="margin-top: 1em">Sample SERVER code:</p>

<p style="margin-top: 1em">VL_ListAttributes(attributes,
entries) <br>
{ <br>
vldbentry *singleentry; <br>
entries-&gt;blkentries_len = 0; <br>
singleentry = entries-&gt;blkentries_val <br>
= (vldbentry *)malloc(MAXENTRIES * sizeof(vldbentry));</p>

<p style="margin-top: 1em">while
(copy_to_vldbentry(&amp;vlentry, singleentry)) <br>
singleentry++, vldbentries-&gt;entries_len++; <br>
}</p>

<p style="margin-top: 1em">This is the best (and simplest)
way of using variable-size arrays as an output parameter. It
is the responsibility of the server-side stub to malloc()
the adequate space which <br>
is automatically freed by the rxgen stub; the client side
should free the space allocated by the rxgen-calling
stub.</p>

<p style="margin-top: 1em">Array example III (Linked
Lists)</p>

<p style="margin-top: 1em">Considering the following 3
declarations (could have applied some optimizations) in the
configuration file:</p>

<p style="margin-top: 1em">typedef struct single_vldbentry
*vldblist; <br>
struct single_vldbentry { <br>
vldbentry vlentry; <br>
vldblist next_vldb; <br>
};</p>

<p style="margin-top: 1em">struct vldb_list { <br>
vldblist node; <br>
};</p>

<p style="margin-top: 1em">and the rxgen procedure
declaration:</p>

<p style="margin-top: 1em">LinkedList (IN
vldblistbyattributes *attributes, <br>
OUT vldb_list *linkedentries) = VL_LINKEDLIST;</p>

<p style="margin-top: 1em">Sample CLIENT code:</p>

<p style="margin-top: 1em">vldb_list linkedvldbs; <br>
vldblist vllist, vllist1;</p>

<p style="margin-top: 1em">bzero(&amp;linkedvldbs,
sizeof(vldb_list)); <br>
code = VL_LinkedList(&amp;attributes, &amp;nentries,
&amp;linkedvldbs); <br>
if (!code) { <br>
printf(&quot;We got %d vldb entries0, nentries); <br>
for (vllist = linkedvldbs.node; vllist; vllist = vllist1) {
<br>
vllist1 = vllist-&gt;next_vldb; <br>
display_entry(&amp;vllist-&gt;vlentry); <br>
free((char *)vllist); <br>
} <br>
}</p>

<p style="margin-top: 1em">Sample SERVER code:</p>

<p style="margin-top: 1em">VL_LinkedList(rxcall,
attributes, nentries, linkedvldbs); <br>
{ <br>
vldblist vllist, *vllistptr = &amp;linkedvldbs-&gt;node;
<br>
while (...) { <br>
vllist = *vllistptr <br>
= (single_vldbentry *)malloc (sizeof (single_vldbentry));
<br>
copy_to_vldbentry(&amp;tentry, &amp;vllist-&gt;vlentry);
<br>
nentries++; <br>
vllistptr = &amp;vllist-&gt;next_vldb; <br>
}; <br>
*vllistptr = NULL; <br>
}</p>

<p style="margin-top: 1em">Using a linked list offers many
advantages: Nothing is passed to the server (the parameter
is OUT), no additional overhead is involved, and the caller
doesn&rsquo;t have to explicitly <br>
prepare for an arbitrary return size. A drawback is that the
caller has the responsibility of malloc() (on the server)
and free (on the client) of each entry (to avoid unwanted
<br>
core-leaks). Another drawback is that since it&rsquo;s a
recursive call, the C stack will grow linearly with respect
to the number of nodes in the list (so it&rsquo;s wise to
increase the <br>
Rx LWP stack if huge amounts of data are expected back --
default stack size is 4K). The advantages should outweigh
the disadvantages here.</p>

<p style="margin-top: 1em">It&rsquo;s important to pay
attention to the comments of the three array examples above
particularly when they&rsquo;re references to when the user
should allocate/free space for the <br>
variable length arrays. The mechanism is very similar to the
handling of strings thus you might need to review the
strings section above; note that the linked lists are
handled <br>
somewhat differently...</p>

<p style="margin-top: 1em">Miscellaneous examples <br>
Below is an abbreviated version of a random interface file
which shows some of the common cases.</p>

<p style="margin-top: 1em">/* Declaration of all structures
used by the R.xg script interface */</p>

<p style="margin-top: 1em">struct AFSFid { <br>
unsigned long Volume; <br>
unsigned long Vnode; <br>
unsigned long Unique; <br>
};</p>

<p style="margin-top: 1em">typedef long ViceDataType;</p>

<p style="margin-top: 1em">/* Note that TEST would be
equivalent to &quot;HEADER&quot; only during the <br>
processing of the header, *.h, file */</p>

<p style="margin-top: 1em">#ifdef RPC_HDR <br>
#define TEST &quot;HEADER&quot; <br>
#else <br>
#define TEST &quot;REST&quot; <br>
#endif</p>

<p style="margin-top: 1em">/* This is the standard *.xg
specification file */</p>

<p style="margin-top: 1em">package AFS_ <br>
splitprefix IN=BEFORE_ OUT=AFTER_; <br>
Prefix Test</p>

<p style="margin-top: 1em">proc Remove(IN struct AFSFid
*Did, IN string volname&lt;64&gt;, <br>
OUT struct AFSStatus *Status) = AFS_REMOVE;</p>

<p style="margin-top: 1em">DisconnectFS AUX_disconnectFS()
= AFS_DISCONNECTFS;</p>

<p style="margin-top: 1em">proc GetVolumeInfo(IN string
Vid, <br>
OUT struct VolumeInfo *Info) = AFS_GETVOLUMEINFO;</p>

<p style="margin-top: 1em">/* You could have more than an
interface per configuration */</p>

<p style="margin-top: 1em">package VOTE_</p>

<p style="margin-top: 1em">/* Using the &quot;multi&quot;
feature; thus VOTE_Beacon can be called as an <br>
multi-Rx call or as a regular call */</p>

<p style="margin-top: 1em">Beacon (IN long state, long
voteStart, <br>
net_version *version, net_tid *tid) <br>
multi = VOTE_BEACON;</p>

<p style="margin-top: 1em">package DISK_</p>

<p style="margin-top: 1em">/* Using the &quot;split&quot;
feature */</p>

<p style="margin-top: 1em">SendFile (IN long file, long
offset, <br>
long length, net_version *version) <br>
split = DISK_SENDFILE;</p>

<p style="margin-top: 1em">Output of an actual interface
configuration <br>
We&rsquo;ll demonstrate some of the actual output generated
by rxgen by following an abbreviated actual interface
configuration.</p>

<p style="margin-top: 1em">Configuration file</p>

<p style="margin-top: 1em">Contents of the interface
configuration file (vldbint.xg):</p>

<p style="margin-top: 1em">package VL_ <br>
#include &quot;vl_opcodes.h&quot; /* The opcodes are
included here */ <br>
%#include &quot;vl_opcodes.h&quot; /* directly to other
places */</p>

<p style="margin-top: 1em">/* Current limitations on
parameters that affect other packages <br>
(i.e. volume) */</p>

<p style="margin-top: 1em">const MAXNAMELEN = 65; <br>
const MAXNSERVERS = 8; <br>
const MAXTYPES = 3;</p>

<p style="margin-top: 1em">/* External (visible)
representation of an individual vldb entry */</p>

<p style="margin-top: 1em">struct vldbentry { <br>
char name[MAXNAMELEN]; <br>
long volumeType; <br>
long nServers; <br>
long serverNumber[MAXNSERVERS]; <br>
long serverPartition[MAXNSERVERS]; <br>
long serverFlags[MAXNSERVERS]; <br>
u_long volumeId[MAXTYPES]; <br>
long flags; <br>
};</p>

<p style="margin-top: 1em">typedef struct single_vldbentry
*vldblist; <br>
struct single_vldbentry { <br>
vldbentry VldbEntry; <br>
vldblist next_vldb; <br>
};</p>

<p style="margin-top: 1em">struct vldb_list { <br>
vldblist node; <br>
};</p>

<p style="margin-top: 1em">/* vldb interface calls */</p>

<p style="margin-top: 1em">CreateEntry (IN long Volid, <br>
vldbentry *newentry) = VLCREATEENTRY;</p>

<p style="margin-top: 1em">GetEntryByName (IN string
volumename&lt;MAXNAMELEN&gt;, <br>
OUT vldbentry *entry) = VLGETENTRYBYNAME;</p>

<p style="margin-top: 1em">GetNewVolumeId (IN long
bumpcount, <br>
OUT long *newvolumid) = VLGETNEWVOLUMEID;</p>

<p style="margin-top: 1em">ReplaceEntry (IN long Volid,
<br>
long voltype, <br>
vldbentry *newentry, <br>
long ReleaseType) multi = VLREPLACEENTRY;</p>

<p style="margin-top: 1em">ListAttributes (IN
VldbListByAttributes *attributes, <br>
OUT long *nentries, <br>
OUT vldbentry bulkentries&lt;MAXVLDBLEN&gt;) <br>
= VLLISTATTRIBUTES;</p>

<p style="margin-top: 1em">LinkedList (IN
VldbListByAttributes *attributes, <br>
OUT long *nentries, <br>
OUT vldb_list *linkedentries) = VLLINKEDLIST;</p>

<p style="margin-top: 1em">We&rsquo;ll concentrate only on
the Rx generated code since the R generated code (-R option)
will soon be obsolete. For a detailed description on the
Rx-related calls inside the <br>
generated stubs (i.e., rx_NewCall(), rx_EndCall()), along
with details on what happens inside certain calls (like
xdrrx_create()) please refer to the Rx documentation. Typing
<br>
&quot;rxgen vldbint.xg&quot; will result in the creation of
four files: vldbint.h, vldbint.xdr.c, vldbint.cs.c and
vldbint.ss.c. A closer look at these files follows.</p>

<p style="margin-top: 1em">Header file (vldbint.h)</p>

<p style="margin-top: 1em">/* Machine generated file -- Do
NOT edit */</p>

<p style="margin-top: 1em">#include
&quot;vl_opcodes.h&quot; /* directly to other places */ <br>
#define MAXNAMELEN 65 <br>
#define MAXNSERVERS 8 <br>
#define MAXTYPES 3</p>

<p style="margin-top: 1em">struct vldbentry { <br>
char name[MAXNAMELEN]; <br>
long volumeType; <br>
long nServers; <br>
long serverNumber[MAXNSERVERS]; <br>
long serverPartition[MAXNSERVERS]; <br>
long serverFlags[MAXNSERVERS]; <br>
u_long volumeId[MAXTYPES]; <br>
long flags; <br>
}; <br>
typedef struct vldbentry vldbentry; <br>
bool_t xdr_vldbentry();</p>

<p style="margin-top: 1em">typedef struct single_vldbentry
*vldblist; <br>
bool_t xdr_vldblist();</p>

<p style="margin-top: 1em">struct single_vldbentry { <br>
vldbentry VldbEntry; <br>
vldblist next_vldb; <br>
}; <br>
typedef struct single_vldbentry single_vldbentry; <br>
bool_t xdr_single_vldbentry();</p>

<p style="margin-top: 1em">struct vldb_list { <br>
vldblist node; <br>
}; <br>
typedef struct vldb_list vldb_list; <br>
bool_t xdr_vldb_list();</p>

<p style="margin-top: 1em">#include &lt;rx/rx_multi.h&gt;
<br>
#define multi_VL_ReplaceEntry(Volid, voltype, newentry,
ReleaseType) multi_Body(StartVL_ReplaceEntry(multi_call,
Volid, voltype, <br>
newentry, ReleaseType), EndVL_ReplaceEntry(multi_call))</p>

<p style="margin-top: 1em">typedef struct bulkentries {
<br>
u_int bulkentries_len; <br>
vldbentry *bulkentries_val; <br>
} bulkentries; <br>
bool_t xdr_bulkentries();</p>

<p style="margin-top: 1em">/* Opcode-related useful stats
for package: VL_ */ <br>
#define VL_LOWEST_OPCODE 501 <br>
#define VL_HIGHEST_OPCODE 506 <br>
#define VL_NUMBER_OPCODES 6</p>

<p style="margin-top: 1em">Notice that all structures are
automatically typedef&rsquo;ed and all &quot;const&quot;s
are converted to &quot;#define&quot;s. Some data structures,
such as bulkentries, are taken from procedure params <br>
(from ListAttributes proc). Thus, this should be kept in
mind when creating stubs piecemeal with rxgen (i.e., using
the -c, -h, -C, or -S flags). Also, one of the side effects
<br>
of the &quot;multi&quot; option (in &quot;ReplaceEntry&quot;
proc) is the generation of the
&quot;multi_VL_ReplaceEntry&quot; above.</p>

<p style="margin-top: 1em">XDR routines for structures
(vldbint.xdr.c)</p>

<p style="margin-top: 1em">/* Machine generated file -- Do
NOT edit */</p>

<p style="margin-top: 1em">#include &lt;rx/xdr.h&gt; <br>
#include &quot;vldbint.h&quot;</p>

<p style="margin-top: 1em">#include
&quot;vl_opcodes.h&quot; /* directly to other places */</p>

<p style="margin-top: 1em">bool_t <br>
xdr_vldbentry(xdrs, objp) <br>
XDR *xdrs; <br>
vldbentry *objp; <br>
{ <br>
if (!xdr_vector(xdrs, (char *)objp-&gt;name, MAXNAMELEN,
<br>
sizeof(char), xdr_char)) <br>
return (FALSE); <br>
if (!xdr_long(xdrs, &amp;objp-&gt;volumeType)) <br>
return (FALSE); <br>
if (!xdr_long(xdrs, &amp;objp-&gt;nServers)) <br>
return (FALSE); <br>
if (!xdr_vector(xdrs, (char *)objp-&gt;serverNumber,
MAXNSERVERS, <br>
sizeof(long), xdr_long)) <br>
return (FALSE); <br>
if (!xdr_vector(xdrs, (char *)objp-&gt;serverPartition, <br>
MAXNSERVERS, sizeof(long), xdr_long)) <br>
return (FALSE); <br>
if (!xdr_vector(xdrs, (char *)objp-&gt;serverFlags,
MAXNSERVERS, <br>
sizeof(long), xdr_long)) <br>
return (FALSE); <br>
if (!xdr_vector(xdrs, (char *)objp-&gt;volumeId, MAXTYPES,
<br>
sizeof(u_long), xdr_u_long)) <br>
return (FALSE); <br>
if (!xdr_long(xdrs, &amp;objp-&gt;flags)) <br>
return (FALSE); <br>
return (TRUE); <br>
}</p>

<p style="margin-top: 1em">bool_t <br>
xdr_vldblist(xdrs, objp) <br>
XDR *xdrs; <br>
vldblist *objp; <br>
{ <br>
if (!xdr_pointer(xdrs, (char **)objp, <br>
sizeof(struct single_vldbentry), <br>
xdr_single_vldbentry)) <br>
return (FALSE); <br>
return (TRUE); <br>
}</p>

<p style="margin-top: 1em">bool_t <br>
xdr_single_vldbentry(xdrs, objp) <br>
XDR *xdrs; <br>
single_vldbentry *objp; <br>
{ <br>
if (!xdr_vldbentry(xdrs, &amp;objp-&gt;VldbEntry)) <br>
return (FALSE); <br>
if (!xdr_vldblist(xdrs, &amp;objp-&gt;next_vldb)) <br>
return (FALSE); <br>
return (TRUE); <br>
}</p>

<p style="margin-top: 1em">bool_t <br>
xdr_vldb_list(xdrs, objp) <br>
XDR *xdrs; <br>
vldb_list *objp; <br>
{ <br>
if (!xdr_vldblist(xdrs, &amp;objp-&gt;node)) <br>
return (FALSE); <br>
return (TRUE); <br>
}</p>

<p style="margin-top: 1em">bool_t <br>
xdr_bulkentries(xdrs, objp) <br>
XDR *xdrs; <br>
bulkentries *objp; <br>
{ <br>
if (!xdr_array(xdrs, (char **)&amp;objp-&gt;bulkentries_val,
<br>
(u_int *)&amp;objp-&gt;bulkentries_len, MAXVLDBLEN, <br>
sizeof(vldbentry), xdr_vldbentry)) <br>
return (FALSE); <br>
return (TRUE); <br>
}</p>

<p style="margin-top: 1em">Note that the xdr_bulkentries()
is automatically generated as a side effect of a procedure
parameter declaration. Thus, if identical multiple type
parameter declarations are <br>
used, then multiply-defined xdr_* stubs will be created! We
felt this was a better alternative to having the rxgen
programmer deal with types such as bulkentries_1, <br>
bulkentries_2...</p>

<p style="margin-top: 1em">Client-Side stub routines
(vldbint.cs.c)</p>

<p style="margin-top: 1em">/* Machine generated file -- Do
NOT edit */</p>

<p style="margin-top: 1em">#include &lt;rx/xdr.h&gt; <br>
#include &lt;rx/rx.h&gt; <br>
#include &lt;afs/rxgen_consts.h&gt; <br>
#include &quot;vldbint.h&quot;</p>

<p style="margin-top: 1em">#include
&quot;vl_opcodes.h&quot; /* directly to other places */</p>

<p style="margin-top: 1em">int VL_CreateEntry(z_conn,
Volid, newentry) <br>
register struct rx_connection *z_conn; <br>
long Volid; <br>
vldbentry * newentry; <br>
{ <br>
struct rx_call *z_call = rx_NewCall(z_conn); <br>
static int z_op = 501; <br>
int z_result; <br>
XDR z_xdrs;</p>

<p style="margin-top: 1em">xdrrx_create(&amp;z_xdrs,
z_call, XDR_ENCODE);</p>

<p style="margin-top: 1em">/* Marshal the arguments */ <br>
if ((!xdr_int(&amp;z_xdrs, &amp;z_op)) <br>
|| (!xdr_long(&amp;z_xdrs, &amp;Volid)) <br>
|| (!xdr_vldbentry(&amp;z_xdrs, newentry))) { <br>
z_result = RXGEN_CC_MARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result = RXGEN_SUCCESS; <br>
fail: <br>
return rx_EndCall(z_call, z_result); <br>
}</p>

<p style="margin-top: 1em">int VL_GetEntryByName(z_conn,
volumename, entry) <br>
register struct rx_connection *z_conn; <br>
char * volumename; <br>
vldbentry * entry; <br>
{ <br>
struct rx_call *z_call = rx_NewCall(z_conn); <br>
static int z_op = 504; <br>
int z_result; <br>
XDR z_xdrs;</p>

<p style="margin-top: 1em">xdrrx_create(&amp;z_xdrs,
z_call, XDR_ENCODE);</p>

<p style="margin-top: 1em">/* Marshal the arguments */ <br>
if ((!xdr_int(&amp;z_xdrs, &amp;z_op)) <br>
|| (!xdr_string(&amp;z_xdrs, &amp;volumename, 65))) { <br>
z_result = RXGEN_CC_MARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">/* Un-marshal the reply
arguments */ <br>
z_xdrs.x_op = XDR_DECODE; <br>
if ((!xdr_vldbentry(&amp;z_xdrs, entry))) { <br>
z_result = RXGEN_CC_UNMARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result = RXGEN_SUCCESS; <br>
fail: <br>
return rx_EndCall(z_call, z_result); <br>
}</p>

<p style="margin-top: 1em">int VL_GetNewVolumeId(z_conn,
bumpcount, newvolumid) <br>
register struct rx_connection *z_conn; <br>
long bumpcount; <br>
long * newvolumid; <br>
{ <br>
struct rx_call *z_call = rx_NewCall(z_conn); <br>
static int z_op = 505; <br>
int z_result; <br>
XDR z_xdrs;</p>

<p style="margin-top: 1em">xdrrx_create(&amp;z_xdrs,
z_call, XDR_ENCODE);</p>

<p style="margin-top: 1em">/* Marshal the arguments */ <br>
if ((!xdr_int(&amp;z_xdrs, &amp;z_op)) <br>
|| (!xdr_long(&amp;z_xdrs, &amp;bumpcount))) { <br>
z_result = RXGEN_CC_MARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">/* Un-marshal the reply
arguments */ <br>
z_xdrs.x_op = XDR_DECODE; <br>
if ((!xdr_long(&amp;z_xdrs, newvolumid))) { <br>
z_result = RXGEN_CC_UNMARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result = RXGEN_SUCCESS; <br>
fail: <br>
return rx_EndCall(z_call, z_result); <br>
}</p>

<p style="margin-top: 1em">int VL_ReplaceEntry(z_conn,
Volid, voltype, newentry, ReleaseType) <br>
register struct rx_connection *z_conn; <br>
long Volid, voltype, ReleaseType; <br>
vldbentry * newentry; <br>
{ <br>
struct rx_call *z_call = rx_NewCall(z_conn); <br>
static int z_op = 506; <br>
int z_result; <br>
XDR z_xdrs;</p>

<p style="margin-top: 1em">xdrrx_create(&amp;z_xdrs,
z_call, XDR_ENCODE);</p>

<p style="margin-top: 1em">/* Marshal the arguments */ <br>
if ((!xdr_int(&amp;z_xdrs, &amp;z_op)) <br>
|| (!xdr_long(&amp;z_xdrs, &amp;Volid)) <br>
|| (!xdr_long(&amp;z_xdrs, &amp;voltype)) <br>
|| (!xdr_vldbentry(&amp;z_xdrs, newentry)) <br>
|| (!xdr_long(&amp;z_xdrs, &amp;ReleaseType))) { <br>
z_result = RXGEN_CC_MARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result = RXGEN_SUCCESS; <br>
fail: <br>
return rx_EndCall(z_call, z_result); <br>
}</p>

<p style="margin-top: 1em">int StartVL_ReplaceEntry(z_call,
Volid, voltype, newentry, ReleaseType) <br>
register struct rx_call *z_call; <br>
long Volid, voltype, ReleaseType; <br>
vldbentry * newentry; <br>
{ <br>
static int z_op = 506; <br>
int z_result; <br>
XDR z_xdrs;</p>

<p style="margin-top: 1em">xdrrx_create(&amp;z_xdrs,
z_call, XDR_ENCODE);</p>

<p style="margin-top: 1em">/* Marshal the arguments */ <br>
if ((!xdr_int(&amp;z_xdrs, &amp;z_op)) <br>
|| (!xdr_long(&amp;z_xdrs, &amp;Volid)) <br>
|| (!xdr_long(&amp;z_xdrs, &amp;voltype)) <br>
|| (!xdr_vldbentry(&amp;z_xdrs, newentry)) <br>
|| (!xdr_long(&amp;z_xdrs, &amp;ReleaseType))) { <br>
z_result = RXGEN_CC_MARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result = RXGEN_SUCCESS; <br>
fail: <br>
return z_result; <br>
}</p>

<p style="margin-top: 1em">int EndVL_ReplaceEntry(z_call)
<br>
register struct rx_call *z_call; <br>
{ <br>
int z_result; <br>
XDR z_xdrs;</p>

<p style="margin-top: 1em">z_result = RXGEN_SUCCESS; <br>
fail: <br>
return z_result; <br>
}</p>

<p style="margin-top: 1em">int VL_ListAttributes(z_conn,
attributes, nentries, bulkentries_1) <br>
register struct rx_connection *z_conn; <br>
VldbListByAttributes * attributes; <br>
long * nentries; <br>
bulkentries * bulkentries_1; <br>
{ <br>
struct rx_call *z_call = rx_NewCall(z_conn); <br>
static int z_op = 511; <br>
int z_result; <br>
XDR z_xdrs;</p>

<p style="margin-top: 1em">xdrrx_create(&amp;z_xdrs,
z_call, XDR_ENCODE);</p>

<p style="margin-top: 1em">/* Marshal the arguments */ <br>
if ((!xdr_int(&amp;z_xdrs, &amp;z_op)) <br>
|| (!xdr_VldbListByAttributes(&amp;z_xdrs, attributes))) {
<br>
z_result = RXGEN_CC_MARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">/* Un-marshal the reply
arguments */ <br>
z_xdrs.x_op = XDR_DECODE; <br>
if ((!xdr_long(&amp;z_xdrs, nentries)) <br>
|| (!xdr_bulkentries(&amp;z_xdrs, bulkentries_1))) { <br>
z_result = RXGEN_CC_UNMARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result = RXGEN_SUCCESS; <br>
fail: <br>
return rx_EndCall(z_call, z_result); <br>
}</p>

<p style="margin-top: 1em">int VL_LinkedList(z_conn,
attributes, nentries, linkedentries) <br>
register struct rx_connection *z_conn; <br>
VldbListByAttributes * attributes; <br>
long * nentries; <br>
vldb_list * linkedentries; <br>
{ <br>
struct rx_call *z_call = rx_NewCall(z_conn); <br>
static int z_op = 512; <br>
int z_result; <br>
XDR z_xdrs;</p>

<p style="margin-top: 1em">xdrrx_create(&amp;z_xdrs,
z_call, XDR_ENCODE);</p>

<p style="margin-top: 1em">/* Marshal the arguments */ <br>
if ((!xdr_int(&amp;z_xdrs, &amp;z_op)) <br>
|| (!xdr_VldbListByAttributes(&amp;z_xdrs, attributes))) {
<br>
z_result = RXGEN_CC_MARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">/* Un-marshal the reply
arguments */ <br>
z_xdrs.x_op = XDR_DECODE; <br>
if ((!xdr_long(&amp;z_xdrs, nentries)) <br>
|| (!xdr_vldb_list(&amp;z_xdrs, linkedentries))) { <br>
z_result = RXGEN_CC_UNMARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result = RXGEN_SUCCESS; <br>
fail: <br>
return rx_EndCall(z_call, z_result); <br>
}</p>

<p style="margin-top: 1em">Notice the side effect of the
&quot;multi&quot; feature (three different modules for
&quot;ReplaceEntry&quot; proc).</p>

<p style="margin-top: 1em">Server-Side stub routines
(vldbint.ss.c)</p>

<p style="margin-top: 1em">/* Machine generated file -- Do
NOT edit */</p>

<p style="margin-top: 1em">#include &lt;rx/xdr.h&gt; <br>
#include &lt;rx/rx.h&gt; <br>
#include &lt;afs/rxgen_consts.h&gt; <br>
#include &quot;vldbint.h&quot;</p>

<p style="margin-top: 1em">#include
&quot;vl_opcodes.h&quot; /* directly to other places */</p>

<p style="margin-top: 1em">long _VL_CreateEntry(z_call,
z_xdrs) <br>
struct rx_call *z_call; <br>
XDR *z_xdrs; <br>
{ <br>
long z_result; <br>
long Volid; <br>
vldbentry newentry;</p>

<p style="margin-top: 1em">if ((!xdr_long(z_xdrs,
&amp;Volid)) <br>
|| (!xdr_vldbentry(z_xdrs, &amp;newentry))) { <br>
z_result = RXGEN_SS_UNMARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result =
VL_CreateEntry(z_call, Volid, &amp;newentry); <br>
fail: <br>
return z_result; <br>
}</p>

<p style="margin-top: 1em">long _VL_GetEntryByName(z_call,
z_xdrs) <br>
struct rx_call *z_call; <br>
XDR *z_xdrs; <br>
{ <br>
long z_result; <br>
char *volumename = (char *)0; <br>
vldbentry entry;</p>

<p style="margin-top: 1em">if ((!xdr_string(z_xdrs,
&amp;volumename, 65))) { <br>
z_result = RXGEN_SS_UNMARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result =
VL_GetEntryByName(z_call, &amp;volumename, &amp;entry); <br>
z_xdrs-&gt;x_op = XDR_ENCODE; <br>
if ((!xdr_vldbentry(z_xdrs, &amp;entry))) <br>
z_result = RXGEN_SS_MARSHAL; <br>
fail: <br>
z_xdrs-&gt;x_op = XDR_FREE; <br>
if (!xdr_string(z_xdrs, &amp;volumename, 65)) goto fail1;
<br>
return z_result; <br>
fail1: <br>
return RXGEN_SS_XDRFREE; <br>
}</p>

<p style="margin-top: 1em">long _VL_GetNewVolumeId(z_call,
z_xdrs) <br>
struct rx_call *z_call; <br>
XDR *z_xdrs; <br>
{ <br>
long z_result; <br>
long bumpcount; <br>
long newvolumid;</p>

<p style="margin-top: 1em">if ((!xdr_long(z_xdrs,
&amp;bumpcount))) { <br>
z_result = RXGEN_SS_UNMARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result =
VL_GetNewVolumeId(z_call, bumpcount, &amp;newvolumid); <br>
z_xdrs-&gt;x_op = XDR_ENCODE; <br>
if ((!xdr_long(z_xdrs, &amp;newvolumid))) <br>
z_result = RXGEN_SS_MARSHAL; <br>
fail: <br>
return z_result; <br>
}</p>

<p style="margin-top: 1em">long _VL_ReplaceEntry(z_call,
z_xdrs) <br>
struct rx_call *z_call; <br>
XDR *z_xdrs; <br>
{ <br>
long z_result; <br>
long Volid, voltype, ReleaseType; <br>
vldbentry newentry;</p>

<p style="margin-top: 1em">if ((!xdr_long(z_xdrs,
&amp;Volid)) <br>
|| (!xdr_long(z_xdrs, &amp;voltype)) <br>
|| (!xdr_vldbentry(z_xdrs, &amp;newentry)) <br>
|| (!xdr_long(z_xdrs, &amp;ReleaseType))) { <br>
z_result = RXGEN_SS_UNMARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result =
VL_ReplaceEntry(z_call, Volid, voltype, &amp;newentry, <br>
ReleaseType); <br>
fail: <br>
return z_result; <br>
}</p>

<p style="margin-top: 1em">long _VL_ListAttributes(z_call,
z_xdrs) <br>
struct rx_call *z_call; <br>
XDR *z_xdrs; <br>
{ <br>
long z_result; <br>
VldbListByAttributes attributes; <br>
long nentries; <br>
bulkentries bulkentries_1;</p>

<p style="margin-top: 1em">if
((!xdr_VldbListByAttributes(z_xdrs, &amp;attributes))) {
<br>
z_result = RXGEN_SS_UNMARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result =
VL_ListAttributes(z_call, &amp;attributes, &amp;nentries,
<br>
&amp;bulkentries_1); <br>
z_xdrs-&gt;x_op = XDR_ENCODE; <br>
if ((!xdr_long(z_xdrs, &amp;nentries)) <br>
|| (!xdr_bulkentries(z_xdrs, &amp;bulkentries_1))) <br>
z_result = RXGEN_SS_MARSHAL; <br>
fail: <br>
z_xdrs-&gt;x_op = XDR_FREE; <br>
if (!xdr_bulkentries(z_xdrs, &amp;bulkentries_1)) goto
fail1; <br>
return z_result; <br>
fail1: <br>
return RXGEN_SS_XDRFREE; <br>
}</p>

<p style="margin-top: 1em">long _VL_LinkedList(z_call,
z_xdrs) <br>
struct rx_call *z_call; <br>
XDR *z_xdrs; <br>
{ <br>
long z_result; <br>
VldbListByAttributes attributes; <br>
long nentries; <br>
vldb_list linkedentries;</p>

<p style="margin-top: 1em">if
((!xdr_VldbListByAttributes(z_xdrs, &amp;attributes))) {
<br>
z_result = RXGEN_SS_UNMARSHAL; <br>
goto fail; <br>
}</p>

<p style="margin-top: 1em">z_result = VL_LinkedList(z_call,
&amp;attributes, &amp;nentries, <br>
&amp;linkedentries); <br>
z_xdrs-&gt;x_op = XDR_ENCODE; <br>
if ((!xdr_long(z_xdrs, &amp;nentries)) <br>
|| (!xdr_vldb_list(z_xdrs, &amp;linkedentries))) <br>
z_result = RXGEN_SS_MARSHAL; <br>
fail: <br>
return z_result; <br>
}</p>

<p style="margin-top: 1em">long _VL_CreateEntry(); <br>
long _VL_GetEntryByName(); <br>
long _VL_GetNewVolumeId(); <br>
long _VL_ReplaceEntry(); <br>
long _VL_ListAttributes(); <br>
long _VL_LinkedList();</p>

<p style="margin-top: 1em">static long
(*StubProcsArray0[])() = {_VL_CreateEntry, <br>
_VL_GetEntryByName, _VL_GetNewVolumeId, _VL_ReplaceEntry,
<br>
_VL_ListAttributes, _VL_LinkedList};</p>

<p style="margin-top: 1em">VL_ExecuteRequest(z_call) <br>
register struct rx_call *z_call; <br>
{ <br>
int op; <br>
XDR z_xdrs; <br>
long z_result;</p>

<p style="margin-top: 1em">xdrrx_create(&amp;z_xdrs,
z_call, XDR_DECODE); <br>
if (!xdr_int(&amp;z_xdrs, &amp;op)) <br>
z_result = RXGEN_DECODE; <br>
else if (op &lt; VL_LOWEST_OPCODE || op &gt;
VL_HIGHEST_OPCODE) <br>
z_result = RXGEN_OPCODE; <br>
else <br>
z_result = (*StubProcsArray0[op - VL_LOWEST_OPCODE]) <br>
(z_call, &amp;z_xdrs); <br>
return z_result; <br>
}</p>

<p style="margin-top: 1em">If there were gaps in the
procedures&rsquo; opcode sequence the code for
VL_ExecuteRequest() routine would be have been drastically
different (it would have been a case statement for <br>
each procedure).</p>

<p style="margin-top: 1em">NOTES <br>
rxgen is implemented from Sun&rsquo;s rpcgen utility. All of
the standard rpcgen&rsquo;s functionality is fully
maintained. Note that some active rpcgen options that
don&rsquo;t apply to rxgen&rsquo;s <br>
purpose aren&rsquo;t referenced here (i.e., -s, -l, -m
options) and the interested reader should refer to rpcgen(1)
for details.</p>

<p style="margin-top: 1em">When the &quot;%#include
&lt;include file&quot;&gt; feature is used make sure that
you don&rsquo;t have any rxgen language features (i.e.
%#defines) since you&rsquo;ll get syntax errors during <br>
compilations..</p>

<p style="margin-top: 1em">Since this is an ongoing project
many of the above may change/disappear without a major
warning.</p>

<p style="margin-top: 1em">SEE ALSO <br>
Rxgen Syntax Summary: Summary description of rxgen&rsquo;s
grammar.</p>

<p style="margin-top: 1em">Rpcgen Programming Guide:
Sun&rsquo;s RPC protocol compiler. rxgen was implemented as
an extension to that compiler.</p>

<p style="margin-top: 1em">External Data Representation:
Sun Technical Notes: Detailed examples in using XDR.</p>

<p style="margin-top: 1em">RPCL Syntax Summary: Summary of
Sun&rsquo;s Remote Procedure Call Language.</p>

<p style="margin-top: 1em">Rx: An extended Remote Procedure
Call Protocol.</p>

<p style="margin-top: 1em">rgen: An earlier version of a
similar stub generator used for the R RPC protocol.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
IBM Corporation 2000. &lt;http://www.ibm.com/&gt; All Rights
Reserved.</p>

<p style="margin-top: 1em">This documentation is covered by
the IBM Public License Version 1.0. It was converted from
the original TeX rxgen manual to POD by Russ Allbery.</p>

<p style="margin-top: 1em">OpenAFS 2017-02-14 RXGEN(1)</p>
<hr>
</body>
</html>
