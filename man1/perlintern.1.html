<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:56 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLINTERN(1) Perl Programmers Reference Guide
PERLINTERN(1)</p>

<p style="margin-top: 1em">NAME <br>
perlintern - autogenerated documentation of purely internal
Perl functions</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This file is the autogenerated documentation of functions in
the Perl interpreter that are documented using Perl&rsquo;s
internal documentation format but are not marked as part of
the <br>
Perl API. In other words, they are not for use in
extensions!</p>

<p style="margin-top: 1em">Compile-time scope hooks <br>
BhkENTRY <br>
Return an entry from the BHK structure. which is a
preprocessor token indicating which entry to return. If the
appropriate flag is not set this will return NULL. The type
<br>
of the return value depends on which entry you ask for.</p>

<p style="margin-top: 1em">NOTE: this function is
experimental and may change or be removed without
notice.</p>

<p style="margin-top: 1em">void * BhkENTRY(BHK *hk,
which)</p>

<p style="margin-top: 1em">BhkFLAGS <br>
Return the BHK&rsquo;s flags.</p>

<p style="margin-top: 1em">NOTE: this function is
experimental and may change or be removed without
notice.</p>

<p style="margin-top: 1em">U32 BhkFLAGS(BHK *hk)</p>

<p style="margin-top: 1em">CALL_BLOCK_HOOKS <br>
Call all the registered block hooks for type which. which is
a preprocessing token; the type of arg depends on which.</p>

<p style="margin-top: 1em">NOTE: this function is
experimental and may change or be removed without
notice.</p>

<p style="margin-top: 1em">void CALL_BLOCK_HOOKS(which,
arg)</p>

<p style="margin-top: 1em">CV reference counts and
CvOUTSIDE <br>
CvWEAKOUTSIDE <br>
Each CV has a pointer, &quot;CvOUTSIDE()&quot;, to its
lexically enclosing CV (if any). Because pointers to
anonymous sub prototypes are stored in &quot;&amp;&quot; pad
slots, it is a possible <br>
to get a circular reference, with the parent pointing to the
child and vice-versa. To avoid the ensuing memory leak, we
do not increment the reference count of the CV <br>
pointed to by &quot;CvOUTSIDE&quot; in the one specific
instance that the parent has a &quot;&amp;&quot; pad slot
pointing back to us. In this case, we set the
&quot;CvWEAKOUTSIDE&quot; flag in the child. <br>
This allows us to determine under what circumstances we
should decrement the refcount of the parent when freeing the
child.</p>

<p style="margin-top: 1em">There is a further complication
with non-closure anonymous subs (i.e. those that do not
refer to any lexicals outside that sub). In this case, the
anonymous prototype is <br>
shared rather than being cloned. This has the consequence
that the parent may be freed while there are still active
children, eg</p>

<p style="margin-top: 1em">BEGIN { $a = sub { eval
&rsquo;$x&rsquo; } }</p>

<p style="margin-top: 1em">In this case, the BEGIN is freed
immediately after execution since there are no active
references to it: the anon sub prototype has
&quot;CvWEAKOUTSIDE&quot; set since it&rsquo;s not a <br>
closure, and $a points to the same CV, so it doesn&rsquo;t
contribute to BEGIN&rsquo;s refcount either. When $a is
executed, the &quot;eval &rsquo;$x&rsquo;&quot; causes the
chain of &quot;CvOUTSIDE&quot;s to be <br>
followed, and the freed BEGIN is accessed.</p>

<p style="margin-top: 1em">To avoid this, whenever a CV and
its associated pad is freed, any &quot;&amp;&quot; entries
in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon <br>
sub is still positive, then that child&rsquo;s
&quot;CvOUTSIDE&quot; is set to point to its grandparent.
This will only occur in the single specific case of a
non-closure anon prototype <br>
having one or more active references (such as $a above).</p>

<p style="margin-top: 1em">One other thing to consider is
that a CV may be merely undefined rather than freed, eg
&quot;undef &amp;foo&quot;. In this case, its refcount may
not have reached zero, but we still <br>
delete its pad and its &quot;CvROOT&quot; etc. Since various
children may still have their &quot;CvOUTSIDE&quot; pointing
at this undefined CV, we keep its own &quot;CvOUTSIDE&quot;
for the time <br>
being, so that the chain of lexical scopes is unbroken. For
example, the following should print 123:</p>

<p style="margin-top: 1em">my $x = 123; <br>
sub tmp { sub { eval &rsquo;$x&rsquo; } } <br>
my $a = tmp(); <br>
undef &amp;tmp; <br>
print $a-&gt;();</p>

<p style="margin-top: 1em">bool CvWEAKOUTSIDE(CV *cv)</p>

<p style="margin-top: 1em">Embedding Functions <br>
cv_dump dump the contents of a CV</p>

<p style="margin-top: 1em">void cv_dump(CV *cv, const char
*title)</p>

<p style="margin-top: 1em">do_dump_pad <br>
Dump the contents of a padlist</p>

<p style="margin-top: 1em">void do_dump_pad(I32 level,
PerlIO *file, <br>
PADLIST *padlist, int full)</p>

<p style="margin-top: 1em">intro_my <br>
&quot;Introduce&quot; my variables to visible status.</p>

<p style="margin-top: 1em">U32 intro_my()</p>

<p style="margin-top: 1em">padlist_dup <br>
Duplicates a pad.</p>

<p style="margin-top: 1em">AV * padlist_dup(AV *srcpad,
CLONE_PARAMS *param)</p>

<p style="margin-top: 1em">pad_alloc_name <br>
Allocates a place in the currently-compiling pad (via
&quot;pad_alloc&quot; in perlapi) and then stores a name for
that entry. namesv is adopted and becomes the name entry; it
<br>
must already contain the name string and be sufficiently
upgraded. typestash and ourstash and the
&quot;padadd_STATE&quot; flag get added to namesv. None of
the other processing <br>
of &quot;pad_add_name_pvn&quot; in perlapi is done. Returns
the offset of the allocated pad slot.</p>

<p style="margin-top: 1em">PADOFFSET pad_alloc_name(SV
*namesv, U32 flags, <br>
HV *typestash, HV *ourstash)</p>

<p style="margin-top: 1em">pad_block_start <br>
Update the pad compilation state variables on entry to a new
block</p>

<p style="margin-top: 1em">void pad_block_start(int
full)</p>

<p style="margin-top: 1em">pad_check_dup <br>
Check for duplicate declarations: report any of:</p>

<p style="margin-top: 1em">* a my in the current scope with
the same name; <br>
* an our (anywhere in the pad) with the same name and the
<br>
same stash as C&lt;ourstash&gt;</p>

<p style="margin-top: 1em">&quot;is_our&quot; indicates
that the name to check is an &rsquo;our&rsquo;
declaration.</p>

<p style="margin-top: 1em">void pad_check_dup(SV *name, U32
flags, <br>
const HV *ourstash)</p>

<p style="margin-top: 1em">pad_findlex <br>
Find a named lexical anywhere in a chain of nested pads. Add
fake entries in the inner pads if it&rsquo;s found in an
outer one.</p>

<p style="margin-top: 1em">Returns the offset in the bottom
pad of the lex or the fake lex. cv is the CV in which to
start the search, and seq is the current cop_seq to match
against. If warn is <br>
true, print appropriate warnings. The out_* vars return
values, and so are pointers to where the returned values
should be stored. out_capture, if non-null, requests <br>
that the innermost instance of the lexical is captured;
out_name_sv is set to the innermost matched namesv or fake
namesv; out_flags returns the flags normally associated <br>
with the IVX field of a fake namesv.</p>

<p style="margin-top: 1em">Note that pad_findlex() is
recursive; it recurses up the chain of CVs, then comes back
down, adding fake entries as it goes. It has to be this way
because fake namesvs in <br>
anon protoypes have to store in xlow the index into the
parent pad.</p>

<p style="margin-top: 1em">PADOFFSET pad_findlex(const char
*namepv, <br>
STRLEN namelen, U32 flags, <br>
const CV* cv, U32 seq, int warn, <br>
SV** out_capture, <br>
SV** out_name_sv, int *out_flags)</p>

<p style="margin-top: 1em">pad_fixup_inner_anons <br>
For any anon CVs in the pad, change CvOUTSIDE of that CV
from old_cv to new_cv if necessary. Needed when a
newly-compiled CV has to be moved to a pre-existing CV
struct.</p>

<p style="margin-top: 1em">void
pad_fixup_inner_anons(PADLIST *padlist, <br>
CV *old_cv, CV *new_cv)</p>

<p style="margin-top: 1em">pad_free <br>
Free the SV at offset po in the current pad.</p>

<p style="margin-top: 1em">void pad_free(PADOFFSET po)</p>

<p style="margin-top: 1em">pad_leavemy <br>
Cleanup at end of scope during compilation: set the max seq
number for lexicals in this scope and warn of any lexicals
that never got introduced.</p>

<p style="margin-top: 1em">void pad_leavemy()</p>

<p style="margin-top: 1em">pad_push <br>
Push a new pad frame onto the padlist, unless there&rsquo;s
already a pad at this depth, in which case don&rsquo;t
bother creating a new one. Then give the new pad an @_ in
slot <br>
zero.</p>

<p style="margin-top: 1em">void pad_push(PADLIST *padlist,
int depth)</p>

<p style="margin-top: 1em">pad_reset <br>
Mark all the current temporaries for reuse</p>

<p style="margin-top: 1em">void pad_reset()</p>

<p style="margin-top: 1em">pad_swipe <br>
Abandon the tmp in the current pad at offset po and replace
with a new one.</p>

<p style="margin-top: 1em">void pad_swipe(PADOFFSET po,
bool refadjust)</p>

<p style="margin-top: 1em">Functions in file op.c <br>
core_prototype <br>
This function assigns the prototype of the named core
function to &quot;sv&quot;, or to a new mortal SV if
&quot;sv&quot; is NULL. It returns the modified
&quot;sv&quot;, or NULL if the core function <br>
has no prototype. &quot;code&quot; is a code as returned by
&quot;keyword()&quot;. It must be negative and unequal to
-KEY_CORE.</p>

<p style="margin-top: 1em">SV * core_prototype(SV *sv,
const char *name, <br>
const int code, <br>
int * const opnum)</p>

<p style="margin-top: 1em">Functions in file pp_ctl.c <br>
docatch Check for the cases 0 or 3 of cur_env.je_ret, only
used inside an eval context.</p>

<p style="margin-top: 1em">0 is used as continue inside
eval,</p>

<p style="margin-top: 1em">3 is used for a die caught by an
inner eval - continue inner loop</p>

<p style="margin-top: 1em">See cop.h: je_mustcatch, when
set at any runlevel to TRUE, means eval ops must establish a
local jmpenv to handle exception traps.</p>

<p style="margin-top: 1em">OP* docatch(OP *o)</p>

<p style="margin-top: 1em">GV Functions <br>
gv_try_downgrade <br>
If the typeglob &quot;gv&quot; can be expressed more
succinctly, by having something other than a real GV in its
place in the stash, replace it with the optimised form.
Basic <br>
requirements for this are that &quot;gv&quot; is a real
typeglob, is sufficiently ordinary, and is only referenced
from its package. This function is meant to be used when a
GV <br>
has been looked up in part to see what was there, causing
upgrading, but based on what was found it turns out that the
real GV isn&rsquo;t required after all.</p>

<p style="margin-top: 1em">If &quot;gv&quot; is a
completely empty typeglob, it is deleted from the stash.</p>

<p style="margin-top: 1em">If &quot;gv&quot; is a typeglob
containing only a sufficiently-ordinary constant sub, the
typeglob is replaced with a scalar-reference placeholder
that more compactly represents <br>
the same thing.</p>

<p style="margin-top: 1em">NOTE: this function is
experimental and may change or be removed without
notice.</p>

<p style="margin-top: 1em">void gv_try_downgrade(GV*
gv)</p>

<p style="margin-top: 1em">Hash Manipulation Functions <br>
hv_ename_add <br>
Adds a name to a stash&rsquo;s internal list of effective
names. See &quot;hv_ename_delete&quot;.</p>

<p style="margin-top: 1em">This is called when a stash is
assigned to a new location in the symbol table.</p>

<p style="margin-top: 1em">void hv_ename_add(HV *hv, const
char *name, U32 len, <br>
U32 flags)</p>

<p style="margin-top: 1em">hv_ename_delete <br>
Removes a name from a stash&rsquo;s internal list of
effective names. If this is the name returned by
&quot;HvENAME&quot;, then another name in the list will take
its place (&quot;HvENAME&quot; <br>
will use it).</p>

<p style="margin-top: 1em">This is called when a stash is
deleted from the symbol table.</p>

<p style="margin-top: 1em">void hv_ename_delete(HV *hv,
const char *name, <br>
U32 len, U32 flags)</p>

<p style="margin-top: 1em">refcounted_he_chain_2hv <br>
Generates and returns a &quot;HV *&quot; representing the
content of a &quot;refcounted_he&quot; chain. flags is
currently unused and must be zero.</p>

<p style="margin-top: 1em">HV * refcounted_he_chain_2hv(
<br>
const struct refcounted_he *c, U32 flags <br>
)</p>

<p style="margin-top: 1em">refcounted_he_fetch_pv <br>
Like &quot;refcounted_he_fetch_pvn&quot;, but takes a
nul-terminated string instead of a string/length pair.</p>

<p style="margin-top: 1em">SV * refcounted_he_fetch_pv(
<br>
const struct refcounted_he *chain, <br>
const char *key, U32 hash, U32 flags <br>
)</p>

<p style="margin-top: 1em">refcounted_he_fetch_pvn <br>
Search along a &quot;refcounted_he&quot; chain for an entry
with the key specified by keypv and keylen. If flags has the
&quot;REFCOUNTED_HE_KEY_UTF8&quot; bit set, the key octets
are <br>
interpreted as UTF-8, otherwise they are interpreted as
Latin-1. hash is a precomputed hash of the key string, or
zero if it has not been precomputed. Returns a mortal <br>
scalar representing the value associated with the key, or
&amp;PL_sv_placeholder if there is no value associated with
the key.</p>

<p style="margin-top: 1em">SV * refcounted_he_fetch_pvn(
<br>
const struct refcounted_he *chain, <br>
const char *keypv, STRLEN keylen, U32 hash, <br>
U32 flags <br>
)</p>

<p style="margin-top: 1em">refcounted_he_fetch_pvs <br>
Like &quot;refcounted_he_fetch_pvn&quot;, but takes a
literal string instead of a string/length pair, and no
precomputed hash.</p>

<p style="margin-top: 1em">SV * refcounted_he_fetch_pvs(
<br>
const struct refcounted_he *chain, <br>
const char *key, U32 flags <br>
)</p>

<p style="margin-top: 1em">refcounted_he_fetch_sv <br>
Like &quot;refcounted_he_fetch_pvn&quot;, but takes a Perl
scalar instead of a string/length pair.</p>

<p style="margin-top: 1em">SV * refcounted_he_fetch_sv(
<br>
const struct refcounted_he *chain, SV *key, <br>
U32 hash, U32 flags <br>
)</p>

<p style="margin-top: 1em">refcounted_he_free <br>
Decrements the reference count of a
&quot;refcounted_he&quot; by one. If the reference count
reaches zero the structure&rsquo;s memory is freed, which
(recursively) causes a reduction <br>
of its parent &quot;refcounted_he&quot;&rsquo;s reference
count. It is safe to pass a null pointer to this function:
no action occurs in this case.</p>

<p style="margin-top: 1em">void refcounted_he_free(struct
refcounted_he *he)</p>

<p style="margin-top: 1em">refcounted_he_inc <br>
Increment the reference count of a
&quot;refcounted_he&quot;. The pointer to the
&quot;refcounted_he&quot; is also returned. It is safe to
pass a null pointer to this function: no action <br>
occurs and a null pointer is returned.</p>

<p style="margin-top: 1em">struct refcounted_he *
refcounted_he_inc( <br>
struct refcounted_he *he <br>
)</p>

<p style="margin-top: 1em">refcounted_he_new_pv <br>
Like &quot;refcounted_he_new_pvn&quot;, but takes a
nul-terminated string instead of a string/length pair.</p>

<p style="margin-top: 1em">struct refcounted_he *
refcounted_he_new_pv( <br>
struct refcounted_he *parent, <br>
const char *key, U32 hash, <br>
SV *value, U32 flags <br>
)</p>

<p style="margin-top: 1em">refcounted_he_new_pvn <br>
Creates a new &quot;refcounted_he&quot;. This consists of a
single key/value pair and a reference to an existing
&quot;refcounted_he&quot; chain (which may be empty), and
thus forms a <br>
longer chain. When using the longer chain, the new key/value
pair takes precedence over any entry for the same key
further along the chain.</p>

<p style="margin-top: 1em">The new key is specified by
keypv and keylen. If flags has the
&quot;REFCOUNTED_HE_KEY_UTF8&quot; bit set, the key octets
are interpreted as UTF-8, otherwise they are interpreted
<br>
as Latin-1. hash is a precomputed hash of the key string, or
zero if it has not been precomputed.</p>

<p style="margin-top: 1em">value is the scalar value to
store for this key. value is copied by this function, which
thus does not take ownership of any reference to it, and
later changes to the <br>
scalar will not be reflected in the value visible in the
&quot;refcounted_he&quot;. Complex types of scalar will not
be stored with referential integrity, but will be coerced to
<br>
strings. value may be either null or &amp;PL_sv_placeholder
to indicate that no value is to be associated with the key;
this, as with any non-null value, takes precedence <br>
over the existence of a value for the key further along the
chain.</p>

<p style="margin-top: 1em">parent points to the rest of the
&quot;refcounted_he&quot; chain to be attached to the new
&quot;refcounted_he&quot;. This function takes ownership of
one reference to parent, and returns <br>
one reference to the new &quot;refcounted_he&quot;.</p>

<p style="margin-top: 1em">struct refcounted_he *
refcounted_he_new_pvn( <br>
struct refcounted_he *parent, <br>
const char *keypv, <br>
STRLEN keylen, U32 hash, <br>
SV *value, U32 flags <br>
)</p>

<p style="margin-top: 1em">refcounted_he_new_pvs <br>
Like &quot;refcounted_he_new_pvn&quot;, but takes a literal
string instead of a string/length pair, and no precomputed
hash.</p>

<p style="margin-top: 1em">struct refcounted_he *
refcounted_he_new_pvs( <br>
struct refcounted_he *parent, <br>
const char *key, SV *value, <br>
U32 flags <br>
)</p>

<p style="margin-top: 1em">refcounted_he_new_sv <br>
Like &quot;refcounted_he_new_pvn&quot;, but takes a Perl
scalar instead of a string/length pair.</p>

<p style="margin-top: 1em">struct refcounted_he *
refcounted_he_new_sv( <br>
struct refcounted_he *parent, <br>
SV *key, U32 hash, SV *value, <br>
U32 flags <br>
)</p>

<p style="margin-top: 1em">IO Functions <br>
start_glob <br>
Function called by &quot;do_readline&quot; to spawn a glob
(or do the glob inside perl on VMS). This code used to be
inline, but now perl uses &quot;File::Glob&quot; this glob
starter is <br>
only used by miniperl during the build process. Moving it
away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl
up.</p>

<p style="margin-top: 1em">NOTE: this function is
experimental and may change or be removed without
notice.</p>

<p style="margin-top: 1em">PerlIO* start_glob(SV *tmpglob,
IO *io)</p>

<p style="margin-top: 1em">Magical Functions <br>
magic_clearhint <br>
Triggered by a delete from %^H, records the key to
&quot;PL_compiling.cop_hints_hash&quot;.</p>

<p style="margin-top: 1em">int magic_clearhint(SV* sv,
MAGIC* mg)</p>

<p style="margin-top: 1em">magic_clearhints <br>
Triggered by clearing %^H, resets
&quot;PL_compiling.cop_hints_hash&quot;.</p>

<p style="margin-top: 1em">int magic_clearhints(SV* sv,
MAGIC* mg)</p>

<p style="margin-top: 1em">magic_methcall <br>
Invoke a magic method (like FETCH).</p>

<p style="margin-top: 1em">&quot;sv&quot; and
&quot;mg&quot; are the tied thingy and the tie magic.</p>

<p style="margin-top: 1em">&quot;meth&quot; is the name of
the method to call.</p>

<p style="margin-top: 1em">&quot;argc&quot; is the number
of args (in addition to $self) to pass to the method.</p>

<p style="margin-top: 1em">The &quot;flags&quot; can
be:</p>

<p style="margin-top: 1em">G_DISCARD invoke method with
G_DISCARD flag and don&rsquo;t <br>
return a value <br>
G_UNDEF_FILL fill the stack with argc pointers to <br>
PL_sv_undef</p>

<p style="margin-top: 1em">The arguments themselves are any
values following the &quot;flags&quot; argument.</p>

<p style="margin-top: 1em">Returns the SV (if any) returned
by the method, or NULL on failure.</p>

<p style="margin-top: 1em">SV* magic_methcall(SV *sv, const
MAGIC *mg, <br>
const char *meth, U32 flags, <br>
U32 argc, ...)</p>

<p style="margin-top: 1em">magic_sethint <br>
Triggered by a store to %^H, records the key/value pair to
&quot;PL_compiling.cop_hints_hash&quot;. It is assumed that
hints aren&rsquo;t storing anything that would need a deep
copy. <br>
Maybe we should warn if we find a reference.</p>

<p style="margin-top: 1em">int magic_sethint(SV* sv, MAGIC*
mg)</p>

<p style="margin-top: 1em">mg_localize <br>
Copy some of the magic from an existing SV to new localized
version of that SV. Container magic (eg %ENV, $1, tie) gets
copied, value magic doesn&rsquo;t (eg taint, pos).</p>

<p style="margin-top: 1em">If setmagic is false then no set
magic will be called on the new (empty) SV. This typically
means that assignment will soon follow (e.g. &rsquo;local $x
= $y&rsquo;), and that will <br>
handle the magic.</p>

<p style="margin-top: 1em">void mg_localize(SV* sv, SV*
nsv, bool setmagic)</p>

<p style="margin-top: 1em">MRO Functions <br>
mro_get_linear_isa_dfs <br>
Returns the Depth-First Search linearization of @ISA the
given stash. The return value is a read-only AV*.
&quot;level&quot; should be 0 (it is used internally in this
function&rsquo;s <br>
recursion).</p>

<p style="margin-top: 1em">You are responsible for
&quot;SvREFCNT_inc()&quot; on the return value if you plan
to store it anywhere semi-permanently (otherwise it might be
deleted out from under you the next <br>
time the cache is invalidated).</p>

<p style="margin-top: 1em">AV* mro_get_linear_isa_dfs(HV*
stash, U32 level)</p>

<p style="margin-top: 1em">mro_isa_changed_in <br>
Takes the necessary steps (cache invalidations, mostly) when
the @ISA of the given package has changed. Invoked by the
&quot;setisa&quot; magic, should not need to invoke <br>
directly.</p>

<p style="margin-top: 1em">void mro_isa_changed_in(HV*
stash)</p>

<p style="margin-top: 1em">mro_package_moved <br>
Call this function to signal to a stash that it has been
assigned to another spot in the stash hierarchy.
&quot;stash&quot; is the stash that has been assigned.
&quot;oldstash&quot; is the <br>
stash it replaces, if any. &quot;gv&quot; is the glob that
is actually being assigned to.</p>

<p style="margin-top: 1em">This can also be called with a
null first argument to indicate that &quot;oldstash&quot;
has been deleted.</p>

<p style="margin-top: 1em">This function invalidates isa
caches on the old stash, on all subpackages nested inside
it, and on the subclasses of all those, including
non-existent packages that have <br>
corresponding entries in &quot;stash&quot;.</p>

<p style="margin-top: 1em">It also sets the effective names
(&quot;HvENAME&quot;) on all the stashes as appropriate.</p>

<p style="margin-top: 1em">If the &quot;gv&quot; is present
and is not in the symbol table, then this function simply
returns. This checked will be skipped if &quot;flags &amp;
1&quot;.</p>

<p style="margin-top: 1em">void mro_package_moved(HV *
const stash, <br>
HV * const oldstash, <br>
const GV * const gv, <br>
U32 flags)</p>

<p style="margin-top: 1em">Optree Manipulation Functions
<br>
finalize_optree <br>
This function finalizes the optree. Should be called
directly after the complete optree is built. It does some
additional checking which can&rsquo;t be done in the normal
<br>
ck_xxx functions and makes the tree thread-safe.</p>

<p style="margin-top: 1em">void finalize_optree(OP* o)</p>

<p style="margin-top: 1em">Pad Data Structures <br>
CX_CURPAD_SAVE <br>
Save the current pad in the given context block
structure.</p>

<p style="margin-top: 1em">void CX_CURPAD_SAVE(struct
context)</p>

<p style="margin-top: 1em">CX_CURPAD_SV <br>
Access the SV at offset po in the saved current pad in the
given context block structure (can be used as an
lvalue).</p>

<p style="margin-top: 1em">SV * CX_CURPAD_SV(struct
context, PADOFFSET po)</p>

<p style="margin-top: 1em">PAD_BASE_SV <br>
Get the value from slot &quot;po&quot; in the base (DEPTH=1)
pad of a padlist</p>

<p style="margin-top: 1em">SV * PAD_BASE_SV(PADLIST
padlist, PADOFFSET po)</p>

<p style="margin-top: 1em">PAD_CLONE_VARS <br>
Clone the state variables associated with running and
compiling pads.</p>

<p style="margin-top: 1em">void
PAD_CLONE_VARS(PerlInterpreter *proto_perl, <br>
CLONE_PARAMS* param)</p>

<p style="margin-top: 1em">PAD_COMPNAME_FLAGS <br>
Return the flags for the current compiling pad name at
offset &quot;po&quot;. Assumes a valid slot entry.</p>

<p style="margin-top: 1em">U32 PAD_COMPNAME_FLAGS(PADOFFSET
po)</p>

<p style="margin-top: 1em">PAD_COMPNAME_GEN <br>
The generation number of the name at offset &quot;po&quot;
in the current compiling pad (lvalue). Note that
&quot;SvUVX&quot; is hijacked for this purpose.</p>

<p style="margin-top: 1em">STRLEN
PAD_COMPNAME_GEN(PADOFFSET po)</p>

<p style="margin-top: 1em">PAD_COMPNAME_GEN_set <br>
Sets the generation number of the name at offset
&quot;po&quot; in the current ling pad (lvalue) to
&quot;gen&quot;. Note that &quot;SvUV_set&quot; is hijacked
for this purpose.</p>

<p style="margin-top: 1em">STRLEN
PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)</p>

<p style="margin-top: 1em">PAD_COMPNAME_OURSTASH <br>
Return the stash associated with an &quot;our&quot;
variable. Assumes the slot entry is a valid &quot;our&quot;
lexical.</p>

<p style="margin-top: 1em">HV *
PAD_COMPNAME_OURSTASH(PADOFFSET po)</p>

<p style="margin-top: 1em">PAD_COMPNAME_PV <br>
Return the name of the current compiling pad name at offset
&quot;po&quot;. Assumes a valid slot entry.</p>

<p style="margin-top: 1em">char * PAD_COMPNAME_PV(PADOFFSET
po)</p>

<p style="margin-top: 1em">PAD_COMPNAME_TYPE <br>
Return the type (stash) of the current compiling pad name at
offset &quot;po&quot;. Must be a valid name. Returns null if
not typed.</p>

<p style="margin-top: 1em">HV * PAD_COMPNAME_TYPE(PADOFFSET
po)</p>

<p style="margin-top: 1em">pad_peg When PERL_MAD is
enabled, this is a small no-op function that gets called at
the start of each pad-related function. It can be
breakpointed to track all pad operations. <br>
The parameter is a string indicating the type of pad
operation being performed.</p>

<p style="margin-top: 1em">NOTE: this function is
experimental and may change or be removed without
notice.</p>

<p style="margin-top: 1em">void pad_peg(const char *s)</p>

<p style="margin-top: 1em">PAD_RESTORE_LOCAL <br>
Restore the old pad saved into the local variable opad by
PAD_SAVE_LOCAL()</p>

<p style="margin-top: 1em">void PAD_RESTORE_LOCAL(PAD
*opad)</p>

<p style="margin-top: 1em">PAD_SAVE_LOCAL <br>
Save the current pad to the local variable opad, then make
the current pad equal to npad</p>

<p style="margin-top: 1em">void PAD_SAVE_LOCAL(PAD *opad,
PAD *npad)</p>

<p style="margin-top: 1em">PAD_SAVE_SETNULLPAD <br>
Save the current pad then set it to null.</p>

<p style="margin-top: 1em">void PAD_SAVE_SETNULLPAD()</p>

<p style="margin-top: 1em">PAD_SETSV <br>
Set the slot at offset &quot;po&quot; in the current pad to
&quot;sv&quot;</p>

<p style="margin-top: 1em">SV * PAD_SETSV(PADOFFSET po, SV*
sv)</p>

<p style="margin-top: 1em">PAD_SET_CUR <br>
Set the current pad to be pad &quot;n&quot; in the padlist,
saving the previous current pad. NB currently this macro
expands to a string too long for some compilers, so
it&rsquo;s best <br>
to replace it with</p>

<p style="margin-top: 1em">SAVECOMPPAD(); <br>
PAD_SET_CUR_NOSAVE(padlist,n);</p>

<p style="margin-top: 1em">void PAD_SET_CUR(PADLIST
padlist, I32 n)</p>

<p style="margin-top: 1em">PAD_SET_CUR_NOSAVE <br>
like PAD_SET_CUR, but without the save</p>

<p style="margin-top: 1em">void PAD_SET_CUR_NOSAVE(PADLIST
padlist, I32 n)</p>

<p style="margin-top: 1em">PAD_SV Get the value at offset
&quot;po&quot; in the current pad</p>

<p style="margin-top: 1em">void PAD_SV(PADOFFSET po)</p>

<p style="margin-top: 1em">PAD_SVl Lightweight and lvalue
version of &quot;PAD_SV&quot;. Get or set the value at
offset &quot;po&quot; in the current pad. Unlike
&quot;PAD_SV&quot;, does not print diagnostics with -DX. For
internal <br>
use only.</p>

<p style="margin-top: 1em">SV * PAD_SVl(PADOFFSET po)</p>

<p style="margin-top: 1em">SAVECLEARSV <br>
Clear the pointed to pad value on scope exit. (i.e. the
runtime action of &rsquo;my&rsquo;)</p>

<p style="margin-top: 1em">void SAVECLEARSV(SV **svp)</p>

<p style="margin-top: 1em">SAVECOMPPAD <br>
save PL_comppad and PL_curpad</p>

<p style="margin-top: 1em">void SAVECOMPPAD()</p>

<p style="margin-top: 1em">SAVEPADSV <br>
Save a pad slot (used to restore after an iteration)</p>

<p style="margin-top: 1em">XXX DAPM it would make more
sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET
po)</p>

<p style="margin-top: 1em">Per-Interpreter Variables <br>
PL_DBsingle <br>
When Perl is run in debugging mode, with the -d switch, this
SV is a boolean which indicates whether subs are being
single-stepped. Single-stepping is automatically <br>
turned on after every step. This is the C variable which
corresponds to Perl&rsquo;s $DB::single variable. See
&quot;PL_DBsub&quot;.</p>

<p style="margin-top: 1em">SV * PL_DBsingle</p>

<p style="margin-top: 1em">PL_DBsub <br>
When Perl is run in debugging mode, with the -d switch, this
GV contains the SV which holds the name of the sub being
debugged. This is the C variable which corresponds <br>
to Perl&rsquo;s $DB::sub variable. See
&quot;PL_DBsingle&quot;.</p>

<p style="margin-top: 1em">GV * PL_DBsub</p>

<p style="margin-top: 1em">PL_DBtrace <br>
Trace variable used when Perl is run in debugging mode, with
the -d switch. This is the C variable which corresponds to
Perl&rsquo;s $DB::trace variable. See
&quot;PL_DBsingle&quot;.</p>

<p style="margin-top: 1em">SV * PL_DBtrace</p>

<p style="margin-top: 1em">PL_dowarn <br>
The C variable which corresponds to Perl&rsquo;s $^W warning
variable.</p>

<p style="margin-top: 1em">bool PL_dowarn</p>

<p style="margin-top: 1em">PL_last_in_gv <br>
The GV which was last used for a filehandle input operation.
(&quot;&lt;FH&gt;&quot;)</p>

<p style="margin-top: 1em">GV* PL_last_in_gv</p>

<p style="margin-top: 1em">PL_ofsgv <br>
The glob containing the output field separator -
&quot;*,&quot; in Perl space.</p>

<p style="margin-top: 1em">GV* PL_ofsgv</p>

<p style="margin-top: 1em">PL_rs The input record separator
- $/ in Perl space.</p>

<p style="margin-top: 1em">SV* PL_rs</p>

<p style="margin-top: 1em">Stack Manipulation Macros <br>
djSP Declare Just &quot;SP&quot;. This is actually identical
to &quot;dSP&quot;, and declares a local copy of
perl&rsquo;s stack pointer, available via the &quot;SP&quot;
macro. See &quot;SP&quot;. (Available for <br>
backward source code compatibility with the old (Perl 5.005)
thread model.)</p>

<p style="margin-top: 1em">djSP;</p>

<p style="margin-top: 1em">LVRET True if this op will be
the return value of an lvalue subroutine</p>

<p style="margin-top: 1em">SV Manipulation Functions <br>
sv_add_arena <br>
Given a chunk of memory, link it to the head of the list of
arenas, and split it into a list of free SVs.</p>

<p style="margin-top: 1em">void sv_add_arena(char *const
ptr, const U32 size, <br>
const U32 flags)</p>

<p style="margin-top: 1em">sv_clean_all <br>
Decrement the refcnt of each remaining SV, possibly
triggering a cleanup. This function may have to be called
multiple times to free SVs which are in complex self- <br>
referential hierarchies.</p>

<p style="margin-top: 1em">I32 sv_clean_all()</p>

<p style="margin-top: 1em">sv_clean_objs <br>
Attempt to destroy all objects not yet freed.</p>

<p style="margin-top: 1em">void sv_clean_objs()</p>

<p style="margin-top: 1em">sv_free_arenas <br>
Deallocate the memory used by all arenas. Note that all the
individual SV heads and bodies within the arenas must
already have been freed.</p>

<p style="margin-top: 1em">void sv_free_arenas()</p>

<p style="margin-top: 1em">SV-Body Allocation <br>
sv_2num Return an SV with the numeric value of the source
SV, doing any necessary reference or overload conversion.
You must use the &quot;SvNUM(sv)&quot; macro to access this
function.</p>

<p style="margin-top: 1em">NOTE: this function is
experimental and may change or be removed without
notice.</p>

<p style="margin-top: 1em">SV* sv_2num(SV *const sv)</p>

<p style="margin-top: 1em">sv_ref Returns a SV describing
what the SV passed in is a reference to.</p>

<p style="margin-top: 1em">SV* sv_ref(SV *dst, const SV
*const sv, <br>
const int ob)</p>

<p style="margin-top: 1em">Unicode Support <br>
find_uninit_var <br>
Find the name of the undefined variable (if any) that caused
the operator to issue a &quot;Use of uninitialized
value&quot; warning. If match is true, only return a name if
its <br>
value matches uninit_sv. So roughly speaking, if a unary
operator (such as OP_COS) generates a warning, then
following the direct child of the op may yield an OP_PADSV
<br>
or OP_GV that gives the name of the undefined variable. On
the other hand, with OP_ADD there are two branches to
follow, so we only print the variable name if we get an <br>
exact match.</p>

<p style="margin-top: 1em">The name is returned as a mortal
SV.</p>

<p style="margin-top: 1em">Assumes that PL_op is the op
that originally triggered the error, and that
PL_comppad/PL_curpad points to the currently executing
pad.</p>

<p style="margin-top: 1em">NOTE: this function is
experimental and may change or be removed without
notice.</p>

<p style="margin-top: 1em">SV* find_uninit_var(const OP
*const obase, <br>
const SV *const uninit_sv, <br>
bool top)</p>

<p style="margin-top: 1em">report_uninit <br>
Print appropriate &quot;Use of uninitialized variable&quot;
warning.</p>

<p style="margin-top: 1em">void report_uninit(const SV
*uninit_sv)</p>

<p style="margin-top: 1em">Undocumented functions <br>
The following functions are currently undocumented. If you
use one of them, you may wish to consider creating and
submitting documentation for it.</p>

<p style="margin-top: 1em">_add_range_to_invlist <br>
_core_swash_init <br>
_invlist_array_init <br>
_invlist_contents <br>
_invlist_intersection <br>
_invlist_intersection_maybe_complement_2nd <br>
_invlist_invert <br>
_invlist_invert_prop <br>
_invlist_populate_swatch <br>
_invlist_subtract <br>
_invlist_union <br>
_invlist_union_maybe_complement_2nd <br>
_is_utf8__perl_idstart <br>
_new_invlist <br>
_swash_inversion_hash <br>
_swash_to_invlist <br>
_to_fold_latin1 <br>
_to_upper_title_latin1 <br>
aassign_common_vars <br>
add_cp_to_invlist <br>
addmad <br>
allocmy <br>
amagic_is_enabled <br>
append_madprops <br>
apply <br>
av_reify <br>
bind_match <br>
block_end <br>
block_start <br>
boot_core_PerlIO <br>
boot_core_UNIVERSAL <br>
boot_core_mro <br>
cando <br>
check_utf8_print <br>
ck_entersub_args_core <br>
convert <br>
coresub_op <br>
create_eval_scope <br>
cv_ckproto_len_flags <br>
cvgv_set <br>
cvstash_set <br>
deb_stack_all <br>
delete_eval_scope <br>
die_unwind <br>
do_aexec <br>
do_aexec5 <br>
do_eof <br>
do_exec <br>
do_exec3 <br>
do_execfree <br>
do_ipcctl <br>
do_ipcget <br>
do_msgrcv <br>
do_msgsnd <br>
do_ncmp <br>
do_op_xmldump <br>
do_pmop_xmldump <br>
do_print <br>
do_readline <br>
do_seek <br>
do_semop <br>
do_shmio <br>
do_sysseek <br>
do_tell <br>
do_trans <br>
do_vecget <br>
do_vecset <br>
do_vop <br>
dofile <br>
dump_all_perl <br>
dump_packsubs_perl <br>
dump_sub_perl <br>
dump_sv_child <br>
emulate_cop_io <br>
feature_is_enabled <br>
find_rundefsv2 <br>
find_script <br>
free_tied_hv_pool <br>
get_db_sub <br>
get_debug_opts <br>
get_hash_seed <br>
get_invlist_iter_addr <br>
get_invlist_len_addr <br>
get_invlist_version_id_addr <br>
get_invlist_zero_addr <br>
get_no_modify <br>
get_opargs <br>
get_re_arg <br>
getenv_len <br>
hfree_next_entry <br>
hv_backreferences_p <br>
hv_kill_backrefs <br>
hv_undef_flags <br>
init_argv_symbols <br>
init_dbargs <br>
init_debugger <br>
invert <br>
invlist_array <br>
invlist_clone <br>
invlist_iterinit <br>
invlist_len <br>
invlist_max <br>
invlist_set_len <br>
invlist_trim <br>
io_close <br>
is_utf8_X_L <br>
is_utf8_X_LV <br>
is_utf8_X_LVT <br>
is_utf8_X_LV_LVT_V <br>
is_utf8_X_T <br>
is_utf8_X_V <br>
is_utf8_X_begin <br>
is_utf8_X_extend <br>
is_utf8_X_non_hangul <br>
is_utf8_X_prepend <br>
jmaybe <br>
keyword <br>
keyword_plugin_standard <br>
list <br>
localize <br>
mad_free <br>
madlex <br>
madparse <br>
magic_clear_all_env <br>
magic_clearenv <br>
magic_clearisa <br>
magic_clearpack <br>
magic_clearsig <br>
magic_existspack <br>
magic_freearylen_p <br>
magic_freeovrld <br>
magic_get <br>
magic_getarylen <br>
magic_getdefelem <br>
magic_getnkeys <br>
magic_getpack <br>
magic_getpos <br>
magic_getsig <br>
magic_getsubstr <br>
magic_gettaint <br>
magic_getuvar <br>
magic_getvec <br>
magic_killbackrefs <br>
magic_len <br>
magic_nextpack <br>
magic_regdata_cnt <br>
magic_regdatum_get <br>
magic_regdatum_set <br>
magic_scalarpack <br>
magic_set <br>
magic_set_all_env <br>
magic_setamagic <br>
magic_setarylen <br>
magic_setcollxfrm <br>
magic_setdbline <br>
magic_setdefelem <br>
magic_setenv <br>
magic_setisa <br>
magic_setmglob <br>
magic_setnkeys <br>
magic_setpack <br>
magic_setpos <br>
magic_setregexp <br>
magic_setsig <br>
magic_setsubstr <br>
magic_settaint <br>
magic_setutf8 <br>
magic_setuvar <br>
magic_setvec <br>
magic_setvstring <br>
magic_sizepack <br>
magic_wipepack <br>
malloc_good_size <br>
malloced_size <br>
mem_collxfrm <br>
mode_from_discipline <br>
more_bodies <br>
mro_meta_dup <br>
mro_meta_init <br>
munge_qwlist_to_paren_list <br>
my_attrs <br>
my_betoh16 <br>
my_betoh32 <br>
my_betoh64 <br>
my_betohi <br>
my_betohl <br>
my_betohs <br>
my_clearenv <br>
my_htobe16 <br>
my_htobe32 <br>
my_htobe64 <br>
my_htobei <br>
my_htobel <br>
my_htobes <br>
my_htole16 <br>
my_htole32 <br>
my_htole64 <br>
my_htolei <br>
my_htolel <br>
my_htoles <br>
my_letoh16 <br>
my_letoh32 <br>
my_letoh64 <br>
my_letohi <br>
my_letohl <br>
my_letohs <br>
my_lstat_flags <br>
my_stat_flags <br>
my_swabn <br>
my_unexec <br>
newATTRSUB_flags <br>
newGP <br>
newMADPROP <br>
newMADsv <br>
newTOKEN <br>
newXS_len_flags <br>
new_warnings_bitfield <br>
nextargv <br>
oopsAV <br>
oopsHV <br>
op_clear <br>
op_const_sv <br>
op_getmad <br>
op_getmad_weak <br>
op_integerize <br>
op_lvalue_flags <br>
op_refcnt_dec <br>
op_refcnt_inc <br>
op_std_init <br>
op_xmldump <br>
package <br>
package_version <br>
parse_unicode_opts <br>
parser_free <br>
peep <br>
pending_Slabs_to_ro <br>
pmop_xmldump <br>
pmruntime <br>
populate_isa <br>
prepend_madprops <br>
qerror <br>
reg_named_buff <br>
reg_named_buff_iter <br>
reg_numbered_buff_fetch <br>
reg_numbered_buff_length <br>
reg_numbered_buff_store <br>
reg_qr_package <br>
reg_temp_copy <br>
regcurly <br>
regprop <br>
report_evil_fh <br>
report_redefined_cv <br>
report_wrongway_fh <br>
rpeep <br>
rsignal_restore <br>
rsignal_save <br>
rxres_save <br>
same_dirent <br>
sawparens <br>
scalar <br>
scalarvoid <br>
set_regclass_bit <br>
sighandler <br>
softref2xv <br>
sub_crush_depth <br>
sv_add_backref <br>
sv_catxmlpv <br>
sv_catxmlpvn <br>
sv_catxmlsv <br>
sv_compile_2op_is_broken <br>
sv_del_backref <br>
sv_free2 <br>
sv_kill_backrefs <br>
sv_sethek <br>
sv_setsv_cow <br>
sv_unglob <br>
sv_xmlpeek <br>
tied_method <br>
token_free <br>
token_getmad <br>
translate_substr_offsets <br>
try_amagic_bin <br>
try_amagic_un <br>
unshare_hek <br>
utilize <br>
varname <br>
vivify_defelem <br>
vivify_ref <br>
wait4pid <br>
was_lvalue_sub <br>
watch <br>
write_to_stderr <br>
xmldump_all <br>
xmldump_all_perl <br>
xmldump_eval <br>
xmldump_form <br>
xmldump_indent <br>
xmldump_packsubs <br>
xmldump_packsubs_perl <br>
xmldump_sub <br>
xmldump_sub_perl <br>
xmldump_vindent <br>
xs_apiversion_bootcheck <br>
xs_version_bootcheck <br>
yyerror <br>
yyerror_pv <br>
yyerror_pvn <br>
yylex <br>
yyparse <br>
yyunlex</p>

<p style="margin-top: 1em">AUTHORS <br>
The autodocumentation system was originally added to the
Perl core by Benjamin Stuhl. Documentation is by whoever was
kind enough to document their functions.</p>

<p style="margin-top: 1em">SEE ALSO <br>
perlguts, perlapi</p>

<p style="margin-top: 1em">perl v5.16.3 2016-11-06
PERLINTERN(1)</p>
<hr>
</body>
</html>
