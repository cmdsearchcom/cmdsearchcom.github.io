<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>SQLT-GRAPH(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">SQLT-GRAPH(1)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">SQLT-GRAPH(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
sqlt-graph - Automatically create a graph from a database schema
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  ./sqlt-graph -d|--db|-f|--from=db_parser [options] schema.sql
  Options:
    -l|--layout        Layout schema for GraphViz
                       (&quot;dot,&quot; &quot;neato,&quot; &quot;twopi&quot;; default &quot;dot&quot;)
    -n|--node-shape    Shape of the nodes (&quot;record,&quot; &quot;plaintext,&quot;
                       &quot;ellipse,&quot; &quot;circle,&quot; &quot;egg,&quot; &quot;triangle,&quot; &quot;box,&quot;
                       &quot;diamond,&quot; &quot;trapezium,&quot; &quot;parallelogram,&quot; &quot;house,&quot;
                       &quot;hexagon,&quot; &quot;octagon,&quot; default &quot;record&quot;)
    -o|--output        Output file name (default STDOUT)
    -t|--output-type   Output file type (&quot;canon&quot;, &quot;text,&quot; &quot;ps,&quot; &quot;hpgl,&quot;
                       &quot;pcl,&quot; &quot;mif,&quot; &quot;pic,&quot; &quot;gd,&quot; &quot;gd2,&quot; &quot;gif,&quot; &quot;jpeg,&quot;
                       &quot;png,&quot; &quot;wbmp,&quot; &quot;cmap,&quot; &quot;ismap,&quot; &quot;imap,&quot; &quot;vrml,&quot;
                       &quot;vtx,&quot; &quot;mp,&quot; &quot;fig,&quot; &quot;svg,&quot; &quot;plain,&quot; default &quot;png&quot;)
    -c|--color         Add colors
    --cluster          Cluster tables
    --no-fields        Don't show field names
    --height           Image height (in inches, default &quot;11&quot;,
                       set to &quot;0&quot; to undefine)
    --width            Image width (in inches, default &quot;8.5&quot;,
                       set to &quot;0&quot; to undefine)
    --fontsize         custom font size for node and edge labels
    --fontname         name of custom font (or full path to font file) for
                       node, edge, and graph labels
    --nodeattr         attribute name and value (in key=val syntax) for
                       nodes; this option may be repeated to specify
                       multiple node attributes
    --edgeattr         same as --nodeattr, but for edge attributes
    --graphattr        same as --nodeattr, but for graph attributes
    --natural-join     Perform natural joins
    --natural-join-pk  Perform natural joins from primary keys only
    --show-datatypes   Show datatype of each field
    --show-sizes       Show column sizes for VARCHAR and CHAR fields
    --show-constraints Show list of constraints for each field
    -s|--skip          Fields to skip in natural joins
    --skip-tables      Comma-separated list of table names to exclude
    --skip-tables-like Comma-separated list of regexen to exclude tables
    --debug            Print debugging information
    --trace            Print parser trace info
</pre>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This script will create a graph of your schema. Only the database driver
  argument (for SQL::Translator) is required. If no output file name is given,
  then image will be printed to STDOUT, so you should redirect the output into a
  file.
<div class="Pp"></div>
The default action is to assume the presence of foreign key relationships
  defined via &quot;REFERNCES&quot; or &quot;FOREIGN KEY&quot; constraints on
  the tables. If you are parsing the schema of a file that does not have these,
  you will find the natural join options helpful. With natural joins, like-named
  fields will be considered foreign keys. This can prove too permissive,
  however, as you probably don't want a field called &quot;name&quot; to be
  considered a foreign key, so you could include it in the &quot;skip&quot;
  option, and all fields called &quot;name&quot; will be excluded from natural
  joins. A more efficient method, however, might be to simply deduce the foreign
  keys from primary keys to other fields named the same in other tables. Use the
  &quot;natural-join-pk&quot; option to achieve this.
<div class="Pp"></div>
If the schema defines foreign keys, then the graph produced will be directed
  showing the direction of the relationship. If the foreign keys are intuited
  via natural joins, the graph will be undirected.
<div class="Pp"></div>
Clustering of tables allows you to group and box tables according to function or
  domain or whatever criteria you choose. The syntax for clustering tables is:
<div class="Pp"></div>
<pre>
  cluster1=table1,table2;cluster2=table3,table4
</pre>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Ken Youens-Clark &lt;kclark@cpan.org&gt;.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perl, SQL::Translator.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-02-11</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
