<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:30 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERF-REPORT(1) perf Manual PERF-REPORT(1)</p>

<p style="margin-top: 1em">NAME <br>
perf-report - Read perf.data (created by perf record) and
display the profile</p>

<p style="margin-top: 1em">SYNOPSIS <br>
perf report [-i &lt;file&gt; | --input=file]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This command displays the performance counter profile
information recorded via perf record.</p>

<p style="margin-top: 1em">OPTIONS <br>
-i, --input= <br>
Input file name. (default: perf.data unless stdin is a
fifo)</p>

<p style="margin-top: 1em">-v, --verbose <br>
Be more verbose. (show symbol address, etc)</p>

<p style="margin-top: 1em">-n, --show-nr-samples <br>
Show the number of samples for each symbol</p>

<p style="margin-top: 1em">--show-cpu-utilization <br>
Show sample percentage for different cpu modes.</p>

<p style="margin-top: 1em">-T, --threads <br>
Show per-thread event counters. The input data file should
be recorded with -s option.</p>

<p style="margin-top: 1em">-c, --comms= <br>
Only consider symbols in these comms. CSV that understands
file://filename entries. This option will affect the
percentage of the overhead column. See --percentage for more
<br>
info.</p>

<p style="margin-top: 1em">--pid= <br>
Only show events for given process ID (comma separated
list).</p>

<p style="margin-top: 1em">--tid= <br>
Only show events for given thread ID (comma separated
list).</p>

<p style="margin-top: 1em">-d, --dsos= <br>
Only consider symbols in these dsos. CSV that understands
file://filename entries. This option will affect the
percentage of the overhead column. See --percentage for more
<br>
info.</p>

<p style="margin-top: 1em">-S, --symbols= <br>
Only consider these symbols. CSV that understands
file://filename entries. This option will affect the
percentage of the overhead column. See --percentage for more
info.</p>

<p style="margin-top: 1em">--symbol-filter= <br>
Only show symbols that match (partially) with this
filter.</p>

<p style="margin-top: 1em">-U, --hide-unresolved <br>
Only display entries resolved to a symbol.</p>

<p style="margin-top: 1em">-s, --sort= <br>
Sort histogram entries by given key(s) - multiple keys can
be specified in CSV format. Following sort keys are
available: pid, comm, dso, symbol, parent, cpu, socket, <br>
srcline, weight, local_weight.</p>

<p style="margin-top: 1em">Each key has following
meaning:</p>

<p style="margin-top: 1em">&Acirc;&middot; comm: command
(name) of the task which can be read via
/proc/&lt;pid&gt;/comm</p>

<p style="margin-top: 1em">&Acirc;&middot; pid: command and
tid of the task</p>

<p style="margin-top: 1em">&Acirc;&middot; dso: name of
library or module executed at the time of sample</p>

<p style="margin-top: 1em">&Acirc;&middot; symbol: name of
function executed at the time of sample</p>

<p style="margin-top: 1em">&Acirc;&middot; parent: name of
function matched to the parent regex filter. Unmatched
entries are displayed as &quot;[other]&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; cpu: cpu number
the task ran at the time of sample</p>

<p style="margin-top: 1em">&Acirc;&middot; socket:
processor socket number the task ran at the time of
sample</p>

<p style="margin-top: 1em">&Acirc;&middot; srcline:
filename and line number executed at the time of sample. The
DWARF debugging info must be provided.</p>

<p style="margin-top: 1em">&Acirc;&middot; srcfile: file
name of the source file of the same. Requires dwarf
information.</p>

<p style="margin-top: 1em">&Acirc;&middot; weight: Event
specific weight, e.g. memory latency or transaction abort
cost. This is the global weight.</p>

<p style="margin-top: 1em">&Acirc;&middot; local_weight:
Local weight version of the weight above.</p>

<p style="margin-top: 1em">&Acirc;&middot; transaction:
Transaction abort flags.</p>

<p style="margin-top: 1em">&Acirc;&middot; overhead:
Overhead percentage of sample</p>

<p style="margin-top: 1em">&Acirc;&middot; overhead_sys:
Overhead percentage of sample running in system mode</p>

<p style="margin-top: 1em">&Acirc;&middot; overhead_us:
Overhead percentage of sample running in user mode</p>

<p style="margin-top: 1em">&Acirc;&middot;
overhead_guest_sys: Overhead percentage of sample running in
system mode on guest machine</p>

<p style="margin-top: 1em">&Acirc;&middot;
overhead_guest_us: Overhead percentage of sample running in
user mode on guest machine</p>

<p style="margin-top: 1em">&Acirc;&middot; sample: Number
of sample</p>

<p style="margin-top: 1em">&Acirc;&middot; period: Raw
number of event count of sample</p>

<p style="margin-top: 1em">By default, comm, dso and symbol
keys are used. <br>
(i.e. --sort comm,dso,symbol)</p>

<p style="margin-top: 1em">If --branch-stack option is
used, following sort keys are also <br>
available: <br>
dso_from, dso_to, symbol_from, symbol_to, mispredict.</p>

<p style="margin-top: 1em">&Acirc;&middot; dso_from: name
of library or module branched from</p>

<p style="margin-top: 1em">&Acirc;&middot; dso_to: name of
library or module branched to</p>

<p style="margin-top: 1em">&Acirc;&middot; symbol_from:
name of function branched from</p>

<p style="margin-top: 1em">&Acirc;&middot; symbol_to: name
of function branched to</p>

<p style="margin-top: 1em">&Acirc;&middot; mispredict:
&quot;N&quot; for predicted branch, &quot;Y&quot; for
mispredicted branch</p>

<p style="margin-top: 1em">&Acirc;&middot; in_tx: branch in
TSX transaction</p>

<p style="margin-top: 1em">&Acirc;&middot; abort: TSX
transaction abort.</p>

<p style="margin-top: 1em">&Acirc;&middot; cycles: Cycles
in basic block</p>

<p style="margin-top: 1em">And default sort keys are
changed to comm, dso_from, symbol_from, dso_to <br>
and symbol_to, see &rsquo;--branch-stack&rsquo;.</p>

<p style="margin-top: 1em">If the --mem-mode option is
used, the following sort keys are also available <br>
(incompatible with --branch-stack): <br>
symbol_daddr, dso_daddr, locked, tlb, mem, snoop,
dcacheline.</p>

<p style="margin-top: 1em">&Acirc;&middot; symbol_daddr:
name of data symbol being executed on at the time of
sample</p>

<p style="margin-top: 1em">&Acirc;&middot; dso_daddr: name
of library or module containing the data being executed on
at the time of the sample</p>

<p style="margin-top: 1em">&Acirc;&middot; locked: whether
the bus was locked at the time of the sample</p>

<p style="margin-top: 1em">&Acirc;&middot; tlb: type of tlb
access for the data at the time of the sample</p>

<p style="margin-top: 1em">&Acirc;&middot; mem: type of
memory access for the data at the time of the sample</p>

<p style="margin-top: 1em">&Acirc;&middot; snoop: type of
snoop (if any) for the data at the time of the sample</p>

<p style="margin-top: 1em">&Acirc;&middot; dcacheline: the
cacheline the data address is on at the time of the
sample</p>

<p style="margin-top: 1em">And the default sort keys are
changed to local_weight, mem, sym, dso, <br>
symbol_daddr, dso_daddr, snoop, tlb, locked, see
&rsquo;--mem-mode&rsquo;.</p>

<p style="margin-top: 1em">If the data file has tracepoint
event(s), following (dynamic) sort keys <br>
are also available: <br>
trace, trace_fields, [&lt;event&gt;.]&lt;field&gt;[/raw]</p>

<p style="margin-top: 1em">&Acirc;&middot; trace: pretty
printed trace output in a single column</p>

<p style="margin-top: 1em">&Acirc;&middot; trace_fields:
fields in tracepoints in separate columns</p>

<p style="margin-top: 1em">&Acirc;&middot; &lt;field
name&gt;: optional event and field name for a specific
field</p>

<p style="margin-top: 1em">The last form consists of event
and field names. If event name is <br>
omitted, it searches all events for matching field name. The
matched <br>
field will be shown only for the event has the field. The
event name <br>
supports substring match so user doesn&rsquo;t need to
specify full subsystem <br>
and event name everytime. For example,
&rsquo;sched:sched_switch&rsquo; event can <br>
be shortened to &rsquo;switch&rsquo; as long as it&rsquo;s
not ambiguous. Also event can <br>
be specified by its index (starting from 1) preceded by the
&rsquo;%&rsquo;. <br>
So &rsquo;%1&rsquo; is the first event, &rsquo;%2&rsquo; is
the second, and so on.</p>

<p style="margin-top: 1em">The field name can have
&rsquo;/raw&rsquo; suffix which disables pretty printing
<br>
and shows raw field value like hex numbers. The --raw-trace
option <br>
has the same effect for all dynamic sort keys.</p>

<p style="margin-top: 1em">The default sort keys are
changed to &rsquo;trace&rsquo; if all events in the data
<br>
file are tracepoint.</p>

<p style="margin-top: 1em">-F, --fields= <br>
Specify output field - multiple keys can be specified in CSV
format. Following fields are available: overhead,
overhead_sys, overhead_us, overhead_children, sample and
<br>
period. Also it can contain any sort key(s).</p>

<p style="margin-top: 1em">By default, every sort keys not
specified in -F will be appended <br>
automatically.</p>

<p style="margin-top: 1em">-p, --parent=&lt;regex&gt; <br>
A regex filter to identify parent. The parent is a caller of
this function and searched through the callchain, thus it
requires callchain information recorded. The pattern is <br>
in the exteneded regex format and defaults to
&quot;^sys_|^do_page_fault&quot;, see --sort parent.</p>

<p style="margin-top: 1em">-x, --exclude-other <br>
Only display entries with parent-match.</p>

<p style="margin-top: 1em">-w,
--column-widths=&lt;width[,width...]&gt; <br>
Force each column width to the provided list, for large
terminal readability. 0 means no limit (default
behavior).</p>

<p style="margin-top: 1em">-t, --field-separator= <br>
Use a special separator character and don&acirc;t pad with
spaces, replacing all occurrences of this separator in
symbol names (and other output) with a . character, that
thus <br>
it&acirc;s the only non valid separator.</p>

<p style="margin-top: 1em">-D, --dump-raw-trace <br>
Dump raw trace in ASCII.</p>

<p style="margin-top: 1em">-g,
--call-graph=&lt;print_type,threshold[,print_limit],order,sort_key[,branch],value&gt;
<br>
Display call chains using type, min percent threshold, print
limit, call order, sort key, optional branch and value. Note
that ordering of parameters is not fixed so any <br>
parement can be given in an arbitraty order. One exception
is the print_limit which should be preceded by
threshold.</p>

<p style="margin-top: 1em">print_type can be either: <br>
- flat: single column, linear exposure of call chains. <br>
- graph: use a graph tree, displaying absolute overhead
rates. (default) <br>
- fractal: like graph, but displays relative rates. Each
branch of <br>
the tree is considered as a new profiled object. <br>
- folded: call chains are displayed in a line, separated by
semicolons <br>
- none: disable call chain display.</p>

<p style="margin-top: 1em">threshold is a percentage value
which specifies a minimum percent to be <br>
included in the output call graph. Default is 0.5 (%).</p>

<p style="margin-top: 1em">print_limit is only applied when
stdio interface is used. It&rsquo;s to limit <br>
number of call graph entries in a single hist entry. Note
that it needs <br>
to be given after threshold (but not necessarily
consecutive). <br>
Default is 0 (unlimited).</p>

<p style="margin-top: 1em">order can be either: <br>
- callee: callee based call graph. <br>
- caller: inverted caller based call graph. <br>
Default is &rsquo;caller&rsquo; when --children is used,
otherwise &rsquo;callee&rsquo;.</p>

<p style="margin-top: 1em">sort_key can be: <br>
- function: compare on functions (default) <br>
- address: compare on individual code addresses</p>

<p style="margin-top: 1em">branch can be: <br>
- branch: include last branch information in callgraph when
available. <br>
Usually more convenient to use --branch-history for
this.</p>

<p style="margin-top: 1em">value can be: <br>
- percent: diplay overhead percent (default) <br>
- period: display event period <br>
- count: display event count</p>

<p style="margin-top: 1em">--children <br>
Accumulate callchain of children to parent entry so that
then can show up in the output. The output will have a new
&quot;Children&quot; column and will be sorted on the data.
It <br>
requires callchains are recorded. See the &acirc;overhead
calculation&acirc; section for more details.</p>

<p style="margin-top: 1em">--max-stack <br>
Set the stack depth limit when parsing the callchain,
anything beyond the specified depth will be ignored. This is
a trade-off between information loss and faster processing
<br>
especially for workloads that can have a very long callchain
stack. Note that when using the --itrace option the
synthesized callchain size will override this value if the
<br>
synthesized callchain size is bigger.</p>

<p style="margin-top: 1em">Default: 127</p>

<p style="margin-top: 1em">-G, --inverted <br>
alias for inverted caller based call graph.</p>

<p style="margin-top: 1em">--ignore-callees=&lt;regex&gt;
<br>
Ignore callees of the function(s) matching the given regex.
This has the effect of collecting the callers of each such
function into one place in the call-graph tree.</p>

<p style="margin-top: 1em">--pretty=&lt;key&gt; <br>
Pretty printing style. key: normal, raw</p>

<p style="margin-top: 1em">--stdio <br>
Use the stdio interface.</p>

<p style="margin-top: 1em">--tui <br>
Use the TUI interface, that is integrated with annotate and
allows zooming into DSOs or threads, among other features.
Use of --tui requires a tty, if one is not present, as <br>
when piping to other commands, the stdio interface is
used.</p>

<p style="margin-top: 1em">--gtk <br>
Use the GTK2 interface.</p>

<p style="margin-top: 1em">-k, --vmlinux=&lt;file&gt; <br>
vmlinux pathname</p>

<p style="margin-top: 1em">--kallsyms=&lt;file&gt; <br>
kallsyms pathname</p>

<p style="margin-top: 1em">-m, --modules <br>
Load module symbols. WARNING: This should only be used with
-k and a LIVE kernel.</p>

<p style="margin-top: 1em">-f, --force <br>
Don&acirc;t complain, do it.</p>

<p style="margin-top: 1em">--symfs=&lt;directory&gt; <br>
Look for files with symbols relative to this directory.</p>

<p style="margin-top: 1em">-C, --cpu <br>
Only report samples for the list of CPUs provided. Multiple
CPUs can be provided as a comma-separated list with no
space: 0,1. Ranges of CPUs are specified with -: 0-2. <br>
Default is to report samples on all CPUs.</p>

<p style="margin-top: 1em">-M, --disassembler-style= <br>
Set disassembler style for objdump.</p>

<p style="margin-top: 1em">--source <br>
Interleave source code with assembly code. Enabled by
default, disable with --no-source.</p>

<p style="margin-top: 1em">--asm-raw <br>
Show raw instruction encoding of assembly instructions.</p>

<p style="margin-top: 1em">--show-total-period <br>
Show a column with the sum of periods.</p>

<p style="margin-top: 1em">-I, --show-info <br>
Display extended information about the perf.data file. This
adds information which may be very large and thus may
clutter the display. It currently includes: cpu and numa
<br>
topology of the host system.</p>

<p style="margin-top: 1em">-b, --branch-stack <br>
Use the addresses of sampled taken branches instead of the
instruction address to build the histograms. To generate
meaningful output, the perf.data file must have been <br>
obtained using perf record -b or perf record --branch-filter
xxx where xxx is a branch filter option. perf report is able
to auto-detect whether a perf.data file contains <br>
branch stacks and it will automatically switch to the branch
view mode, unless --no-branch-stack is used.</p>

<p style="margin-top: 1em">--branch-history <br>
Add the addresses of sampled taken branches to the
callstack. This allows to examine the path the program took
to each sample. The data collection must have used -b (or
-j) <br>
and -g.</p>

<p style="margin-top: 1em">--objdump=&lt;path&gt; <br>
Path to objdump binary.</p>

<p style="margin-top: 1em">--group <br>
Show event group information together.</p>

<p style="margin-top: 1em">--demangle <br>
Demangle symbol names to human readable form. It&acirc;s
enabled by default, disable with --no-demangle.</p>

<p style="margin-top: 1em">--demangle-kernel <br>
Demangle kernel symbol names to human readable form (for C++
kernels).</p>

<p style="margin-top: 1em">--mem-mode <br>
Use the data addresses of samples in addition to instruction
addresses to build the histograms. To generate meaningful
output, the perf.data file must have been obtained <br>
using perf record -d -W and using a special event -e
cpu/mem-loads/ or -e cpu/mem-stores/. See perf mem for
simpler access.</p>

<p style="margin-top: 1em">--percent-limit <br>
Do not show entries which have an overhead under that
percent. (Default: 0). Note that this option also sets the
percent limit (threshold) of callchains. However the default
<br>
value of callchain threshold is different than the default
value of hist entries. Please see the --call-graph option
for details.</p>

<p style="margin-top: 1em">--percentage <br>
Determine how to display the overhead percentage of filtered
entries. Filters can be applied by --comms, --dsos and/or
--symbols options and Zoom operations on the TUI <br>
(thread, dso, etc).</p>

<p style="margin-top: 1em">&quot;relative&quot; means
it&rsquo;s relative to filtered entries only so that the
<br>
sum of shown entries will be always 100%.
&quot;absolute&quot; means it retains <br>
the original value before and after the filter is
applied.</p>

<p style="margin-top: 1em">--header <br>
Show header information in the perf.data file. This includes
various information like hostname, OS and perf version,
cpu/mem info, perf command line, event list and so on. <br>
Currently only --stdio output supports this feature.</p>

<p style="margin-top: 1em">--header-only <br>
Show only perf.data header (forces --stdio).</p>

<p style="margin-top: 1em">--itrace <br>
Options for decoding instruction tracing data. The options
are:</p>

<p style="margin-top: 1em">i synthesize instructions events
<br>
b synthesize branches events <br>
c synthesize branches events (calls only) <br>
r synthesize branches events (returns only) <br>
x synthesize transactions events <br>
e synthesize error events <br>
d create a debug log <br>
g synthesize a call chain (use with i or x) <br>
l synthesize last branch entries (use with i or x)</p>

<p style="margin-top: 1em">The default is all events i.e.
the same as --itrace=ibxe</p>

<p style="margin-top: 1em">In addition, the period (default
100000) for instructions events <br>
can be specified in units of:</p>

<p style="margin-top: 1em">i instructions <br>
t ticks <br>
ms milliseconds <br>
us microseconds <br>
ns nanoseconds (default)</p>

<p style="margin-top: 1em">Also the call chain size
(default 16, max. 1024) for instructions or <br>
transactions events can be specified.</p>

<p style="margin-top: 1em">Also the number of last branch
entries (default 64, max. 1024) for <br>
instructions or transactions events can be specified.</p>

<p style="margin-top: 1em">To disable decoding entirely,
use --no-itrace.</p>

<p style="margin-top: 1em">--full-source-path <br>
Show the full path for source files for srcline output.</p>

<p style="margin-top: 1em">--show-ref-call-graph <br>
When multiple events are sampled, it may not be needed to
collect callgraphs for all of them. The sample sites are
usually nearby, and it&acirc;s enough to collect the
callgraphs <br>
on a reference event. So user can use
&quot;call-graph=no&quot; event modifier to disable
callgraph for other events to reduce the overhead. However,
perf report cannot show callgraphs <br>
for the event which disable the callgraph. This option
extends the perf report to show reference callgraphs, which
collected by reference event, in no callgraph event.</p>

<p style="margin-top: 1em">--socket-filter <br>
Only report the samples on the processor socket that match
with this filter</p>

<p style="margin-top: 1em">--raw-trace <br>
When displaying traceevent output, do not use print fmt or
plugins.</p>

<p style="margin-top: 1em">--hierarchy <br>
Enable hierarchical output.</p>

<p style="margin-top: 1em">OVERHEAD CALCULATION <br>
The overhead can be shown in two columns as Children and
Self when perf collects callchains. The self overhead is
simply calculated by adding all period values of the entry -
<br>
usually a function (symbol). This is the value that perf
shows traditionally and sum of all the self overhead values
should be 100%.</p>

<p style="margin-top: 1em">The children overhead is
calculated by adding all period values of the child
functions so that it can show the total overhead of the
higher level functions even if they don&acirc;t <br>
directly execute much. Children here means functions that
are called from another (parent) function.</p>

<p style="margin-top: 1em">It might be confusing that the
sum of all the children overhead values exceeds 100% since
each of them is already an accumulation of self overhead of
its child functions. But <br>
with this enabled, users can find which function has the
most overhead even if samples are spread over the
children.</p>

<p style="margin-top: 1em">Consider the following example;
there are three functions like below.</p>

<p style="margin-top: 1em">.ft C <br>
void foo(void) { <br>
/* do something */ <br>
}</p>

<p style="margin-top: 1em">void bar(void) { <br>
/* do something */ <br>
foo(); <br>
}</p>

<p style="margin-top: 1em">int main(void) { <br>
bar() <br>
return 0; <br>
} <br>
.ft</p>

<p style="margin-top: 1em">In this case foo is a child of
bar, and bar is an immediate child of main so foo also is a
child of main. In other words, main is a parent of foo and
bar, and bar is a parent of <br>
foo.</p>

<p style="margin-top: 1em">Suppose all samples are recorded
in foo and bar only. When it&acirc;s recorded with
callchains the output will show something like below in the
usual (self-overhead-only) output of <br>
perf report:</p>

<p style="margin-top: 1em">.ft C <br>
Overhead Symbol <br>
........ ..................... <br>
60.00% foo <br>
| <br>
--- foo <br>
bar <br>
main <br>
__libc_start_main</p>

<p style="margin-top: 1em">40.00% bar <br>
| <br>
--- bar <br>
main <br>
__libc_start_main <br>
.ft</p>

<p style="margin-top: 1em">When the --children option is
enabled, the self overhead values of child functions (i.e.
foo and bar) are added to the parents to calculate the
children overhead. In this case <br>
the report could be displayed as:</p>

<p style="margin-top: 1em">.ft C <br>
Children Self Symbol <br>
........ ........ .................... <br>
100.00% 0.00% __libc_start_main <br>
| <br>
--- __libc_start_main</p>

<p style="margin-top: 1em">100.00% 0.00% main <br>
| <br>
--- main <br>
__libc_start_main</p>

<p style="margin-top: 1em">100.00% 40.00% bar <br>
| <br>
--- bar <br>
main <br>
__libc_start_main</p>

<p style="margin-top: 1em">60.00% 60.00% foo <br>
| <br>
--- foo <br>
bar <br>
main <br>
__libc_start_main <br>
.ft</p>

<p style="margin-top: 1em">In the above output, the self
overhead of foo (60%) was add to the children overhead of
bar, main and __libc_start_main. Likewise, the self overhead
of bar (40%) was added to the <br>
children overhead of main and __libc_start_main.</p>

<p style="margin-top: 1em">So __libc_start_main and main
are shown first since they have same (100%) children
overhead (even though they have zero self overhead) and they
are the parents of foo and bar.</p>

<p style="margin-top: 1em">Since v3.16 the children
overhead is shown by default and the output is sorted by its
values. The children overhead is disabled by specifying
--no-children option on the command <br>
line or by adding report.children = false or top.children =
false in the perf config file.</p>

<p style="margin-top: 1em">SEE ALSO <br>
perf-stat(1), perf-annotate(1)</p>

<p style="margin-top: 1em">perf 07/04/2017
PERF-REPORT(1)</p>
<hr>
</body>
</html>
