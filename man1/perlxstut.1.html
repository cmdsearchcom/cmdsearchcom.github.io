<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:16 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLXSTUT(1) Perl Programmers Reference Guide
PERLXSTUT(1)</p>

<p style="margin-top: 1em">NAME <br>
perlxstut - Tutorial for writing XSUBs</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This tutorial will educate the reader on the steps involved
in creating a Perl extension. The reader is assumed to have
access to perlguts, perlapi and perlxs.</p>

<p style="margin-top: 1em">This tutorial starts with very
simple examples and becomes more complex, with each new
example adding new features. Certain concepts may not be
completely explained until later <br>
in the tutorial in order to slowly ease the reader into
building extensions.</p>

<p style="margin-top: 1em">This tutorial was written from a
Unix point of view. Where I know them to be otherwise
different for other platforms (e.g. Win32), I will list
them. If you find something that <br>
was missed, please let me know.</p>

<p style="margin-top: 1em">SPECIAL NOTES <br>
make <br>
This tutorial assumes that the make program that Perl is
configured to use is called &quot;make&quot;. Instead of
running &quot;make&quot; in the examples that follow, you
may have to substitute <br>
whatever make program Perl has been configured to use.
Running perl -V:make should tell you what it is.</p>

<p style="margin-top: 1em">Version caveat <br>
When writing a Perl extension for general consumption, one
should expect that the extension will be used with versions
of Perl different from the version available on your <br>
machine. Since you are reading this document, the version of
Perl on your machine is probably 5.005 or later, but the
users of your extension may have more ancient versions.</p>

<p style="margin-top: 1em">To understand what kinds of
incompatibilities one may expect, and in the rare case that
the version of Perl on your machine is older than this
document, see the section on <br>
&quot;Troubleshooting these Examples&quot; for more
information.</p>

<p style="margin-top: 1em">If your extension uses some
features of Perl which are not available on older releases
of Perl, your users would appreciate an early meaningful
warning. You would probably put <br>
this information into the README file, but nowadays
installation of extensions may be performed automatically,
guided by CPAN.pm module or other tools.</p>

<p style="margin-top: 1em">In MakeMaker-based
installations, Makefile.PL provides the earliest opportunity
to perform version checks. One can put something like this
in Makefile.PL for this purpose:</p>

<p style="margin-top: 1em">eval { require 5.007 } <br>
or die &lt;&lt;EOD; <br>
############ <br>
### This module uses frobnication framework which is not
available before <br>
### version 5.007 of Perl. Upgrade your Perl before
installing Kara::Mba. <br>
############ <br>
EOD</p>

<p style="margin-top: 1em">Dynamic Loading versus Static
Loading <br>
It is commonly thought that if a system does not have the
capability to dynamically load a library, you cannot build
XSUBs. This is incorrect. You can build them, but you must
<br>
link the XSUBs subroutines with the rest of Perl, creating a
new executable. This situation is similar to Perl 4.</p>

<p style="margin-top: 1em">This tutorial can still be used
on such a system. The XSUB build mechanism will check the
system and build a dynamically-loadable library if possible,
or else a static library <br>
and then, optionally, a new statically-linked executable
with that static library linked in.</p>

<p style="margin-top: 1em">Should you wish to build a
statically-linked executable on a system which can
dynamically load libraries, you may, in all the following
examples, where the command &quot;&quot;make&quot;&quot;
with <br>
no arguments is executed, run the command &quot;&quot;make
perl&quot;&quot; instead.</p>

<p style="margin-top: 1em">If you have generated such a
statically-linked executable by choice, then instead of
saying &quot;&quot;make test&quot;&quot;, you should say
&quot;&quot;make test_static&quot;&quot;. On systems that
cannot build <br>
dynamically-loadable libraries at all, simply saying
&quot;&quot;make test&quot;&quot; is sufficient.</p>

<p style="margin-top: 1em">TUTORIAL <br>
Now let&rsquo;s go on with the show!</p>

<p style="margin-top: 1em">EXAMPLE 1 <br>
Our first extension will be very simple. When we call the
routine in the extension, it will print out a well-known
message and return.</p>

<p style="margin-top: 1em">Run &quot;&quot;h2xs -A -n
Mytest&quot;&quot;. This creates a directory named Mytest,
possibly under ext/ if that directory exists in the current
working directory. Several files will be created <br>
under the Mytest dir, including MANIFEST, Makefile.PL,
lib/Mytest.pm, Mytest.xs, t/Mytest.t, and Changes.</p>

<p style="margin-top: 1em">The MANIFEST file contains the
names of all the files just created in the Mytest
directory.</p>

<p style="margin-top: 1em">The file Makefile.PL should look
something like this:</p>

<p style="margin-top: 1em">use ExtUtils::MakeMaker; <br>
# See lib/ExtUtils/MakeMaker.pm for details of how to
influence <br>
# the contents of the Makefile that is written. <br>
WriteMakefile( <br>
NAME =&gt; &rsquo;Mytest&rsquo;, <br>
VERSION_FROM =&gt; &rsquo;Mytest.pm&rsquo;, # finds $VERSION
<br>
LIBS =&gt; [&rsquo;&rsquo;], # e.g., &rsquo;-lm&rsquo; <br>
DEFINE =&gt; &rsquo;&rsquo;, # e.g.,
&rsquo;-DHAVE_SOMETHING&rsquo; <br>
INC =&gt; &rsquo;&rsquo;, # e.g.,
&rsquo;-I/usr/include/other&rsquo; <br>
);</p>

<p style="margin-top: 1em">The file Mytest.pm should start
with something like this:</p>

<p style="margin-top: 1em">package Mytest;</p>

<p style="margin-top: 1em">use 5.008008; <br>
use strict; <br>
use warnings;</p>

<p style="margin-top: 1em">require Exporter;</p>

<p style="margin-top: 1em">our @ISA = qw(Exporter); <br>
our %EXPORT_TAGS = ( &rsquo;all&rsquo; =&gt; [ qw(</p>

<p style="margin-top: 1em">) ] );</p>

<p style="margin-top: 1em">our @EXPORT_OK = ( @{
$EXPORT_TAGS{&rsquo;all&rsquo;} } );</p>

<p style="margin-top: 1em">our @EXPORT = qw(</p>

<p style="margin-top: 1em">);</p>

<p style="margin-top: 1em">our $VERSION =
&rsquo;0.01&rsquo;;</p>

<p style="margin-top: 1em">require XSLoader; <br>
XSLoader::load(&rsquo;Mytest&rsquo;, $VERSION);</p>

<p style="margin-top: 1em"># Preloaded methods go here.</p>

<p style="margin-top: 1em">1; <br>
__END__ <br>
# Below is the stub of documentation for your module. You
better edit it!</p>

<p style="margin-top: 1em">The rest of the .pm file
contains sample code for providing documentation for the
extension.</p>

<p style="margin-top: 1em">Finally, the Mytest.xs file
should look something like this:</p>

<p style="margin-top: 1em">#include &quot;EXTERN.h&quot;
<br>
#include &quot;perl.h&quot; <br>
#include &quot;XSUB.h&quot;</p>

<p style="margin-top: 1em">#include
&quot;ppport.h&quot;</p>

<p style="margin-top: 1em">MODULE = Mytest PACKAGE =
Mytest</p>

<p style="margin-top: 1em">Let&rsquo;s edit the .xs file by
adding this to the end of the file:</p>

<p style="margin-top: 1em">void <br>
hello() <br>
CODE: <br>
printf(&quot;Hello, world!0);</p>

<p style="margin-top: 1em">It is okay for the lines
starting at the &quot;CODE:&quot; line to not be indented.
However, for readability purposes, it is suggested that you
indent CODE: one level and the lines <br>
following one more level.</p>

<p style="margin-top: 1em">Now we&rsquo;ll run
&quot;&quot;perl Makefile.PL&quot;&quot;. This will create a
real Makefile, which make needs. Its output looks something
like:</p>

<p style="margin-top: 1em">% perl Makefile.PL <br>
Checking if your kit is complete... <br>
Looks good <br>
Writing Makefile for Mytest <br>
%</p>

<p style="margin-top: 1em">Now, running make will produce
output that looks something like this (some long lines have
been shortened for clarity and some extraneous lines have
been deleted):</p>

<p style="margin-top: 1em">% make <br>
cp lib/Mytest.pm blib/lib/Mytest.pm <br>
perl xsubpp -typemap typemap Mytest.xs &gt; Mytest.xsc
&amp;&amp; mv Mytest.xsc Mytest.c <br>
Please specify prototyping behavior for Mytest.xs (see
perlxs manual) <br>
cc -c Mytest.c <br>
Running Mkbootstrap for Mytest () <br>
chmod 644 Mytest.bs <br>
rm -f blib/arch/auto/Mytest/Mytest.so <br>
cc -shared -L/usr/local/lib Mytest.o -o
blib/arch/auto/Mytest/Mytest.so <br>
chmod 755 blib/arch/auto/Mytest/Mytest.so <br>
cp Mytest.bs blib/arch/auto/Mytest/Mytest.bs <br>
chmod 644 blib/arch/auto/Mytest/Mytest.bs <br>
Manifying blib/man3/Mytest.3pm <br>
%</p>

<p style="margin-top: 1em">You can safely ignore the line
about &quot;prototyping behavior&quot; - it is explained in
&quot;The PROTOTYPES: Keyword&quot; in perlxs.</p>

<p style="margin-top: 1em">Perl has its own special way of
easily writing test scripts, but for this example only,
we&rsquo;ll create our own test script. Create a file called
hello that looks like this:</p>

<p style="margin-top: 1em">#! /opt/perl5/bin/perl</p>

<p style="margin-top: 1em">use ExtUtils::testlib;</p>

<p style="margin-top: 1em">use Mytest;</p>

<p style="margin-top: 1em">Mytest::hello();</p>

<p style="margin-top: 1em">Now we make the script
executable (&quot;chmod +x hello&quot;), run the script and
we should see the following output:</p>

<p style="margin-top: 1em">% ./hello <br>
Hello, world! <br>
%</p>

<p style="margin-top: 1em">EXAMPLE 2 <br>
Now let&rsquo;s add to our extension a subroutine that will
take a single numeric argument as input and return 1 if the
number is even or 0 if the number is odd.</p>

<p style="margin-top: 1em">Add the following to the end of
Mytest.xs:</p>

<p style="margin-top: 1em">int <br>
is_even(input) <br>
int input <br>
CODE: <br>
RETVAL = (input % 2 == 0); <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">There does not need to be
whitespace at the start of the &quot;&quot;int
input&quot;&quot; line, but it is useful for improving
readability. Placing a semi-colon at the end of that line is
also <br>
optional. Any amount and kind of whitespace may be placed
between the &quot;&quot;int&quot;&quot; and
&quot;&quot;input&quot;&quot;.</p>

<p style="margin-top: 1em">Now re-run make to rebuild our
new shared library.</p>

<p style="margin-top: 1em">Now perform the same steps as
before, generating a Makefile from the Makefile.PL file, and
running make.</p>

<p style="margin-top: 1em">In order to test that our
extension works, we now need to look at the file Mytest.t.
This file is set up to imitate the same kind of testing
structure that Perl itself has. <br>
Within the test script, you perform a number of tests to
confirm the behavior of the extension, printing
&quot;ok&quot; when the test is correct, &quot;not ok&quot;
when it is not.</p>

<p style="margin-top: 1em">use Test::More tests =&gt; 4;
<br>
BEGIN { use_ok(&rsquo;Mytest&rsquo;) };</p>

<p style="margin-top: 1em">#########################</p>

<p style="margin-top: 1em"># Insert your test code below,
the Test::More module is use()ed here so read <br>
# its man page ( perldoc Test::More ) for help writing this
test script.</p>

<p style="margin-top: 1em">is(&amp;Mytest::is_even(0), 1);
<br>
is(&amp;Mytest::is_even(1), 0); <br>
is(&amp;Mytest::is_even(2), 1);</p>

<p style="margin-top: 1em">We will be calling the test
script through the command &quot;&quot;make
test&quot;&quot;. You should see output that looks something
like this:</p>

<p style="margin-top: 1em">%make test <br>
PERL_DL_NONLAZY=1 /usr/bin/perl
&quot;-MExtUtils::Command::MM&quot; &quot;-e&quot;
&quot;test_harness(0, &rsquo;blib/lib&rsquo;,
&rsquo;blib/arch&rsquo;)&quot; t/*.t <br>
t/Mytest....ok <br>
All tests successful. <br>
Files=1, Tests=4, 0 wallclock secs ( 0.03 cusr + 0.00 csys =
0.03 CPU) <br>
%</p>

<p style="margin-top: 1em">What has gone on? <br>
The program h2xs is the starting point for creating
extensions. In later examples we&rsquo;ll see how we can use
h2xs to read header files and generate templates to connect
to C <br>
routines.</p>

<p style="margin-top: 1em">h2xs creates a number of files
in the extension directory. The file Makefile.PL is a perl
script which will generate a true Makefile to build the
extension. We&rsquo;ll take a closer <br>
look at it later.</p>

<p style="margin-top: 1em">The .pm and .xs files contain
the meat of the extension. The .xs file holds the C routines
that make up the extension. The .pm file contains routines
that tell Perl how to load <br>
your extension.</p>

<p style="margin-top: 1em">Generating the Makefile and
running &quot;make&quot; created a directory called blib
(which stands for &quot;build library&quot;) in the current
working directory. This directory will contain the <br>
shared library that we will build. Once we have tested it,
we can install it into its final location.</p>

<p style="margin-top: 1em">Invoking the test script via
&quot;&quot;make test&quot;&quot; did something very
important. It invoked perl with all those &quot;-I&quot;
arguments so that it could find the various files that are
part of <br>
the extension. It is very important that while you are still
testing extensions that you use &quot;&quot;make
test&quot;&quot;. If you try to run the test script all by
itself, you will get a <br>
fatal error. Another reason it is important to use
&quot;&quot;make test&quot;&quot; to run your test script is
that if you are testing an upgrade to an already-existing
version, using &quot;&quot;make <br>
test&quot;&quot; ensures that you will test your new
extension, not the already-existing version.</p>

<p style="margin-top: 1em">When Perl sees a &quot;use
extension;&quot;, it searches for a file with the same name
as the &quot;use&quot;&rsquo;d extension that has a .pm
suffix. If that file cannot be found, Perl dies with a fatal
<br>
error. The default search path is contained in the @INC
array.</p>

<p style="margin-top: 1em">In our case, Mytest.pm tells
perl that it will need the Exporter and Dynamic Loader
extensions. It then sets the @ISA and @EXPORT arrays and the
$VERSION scalar; finally it <br>
tells perl to bootstrap the module. Perl will call its
dynamic loader routine (if there is one) and load the shared
library.</p>

<p style="margin-top: 1em">The two arrays @ISA and @EXPORT
are very important. The @ISA array contains a list of other
packages in which to search for methods (or subroutines)
that do not exist in the <br>
current package. This is usually only important for
object-oriented extensions (which we will talk about much
later), and so usually doesn&rsquo;t need to be
modified.</p>

<p style="margin-top: 1em">The @EXPORT array tells Perl
which of the extension&rsquo;s variables and subroutines
should be placed into the calling package&rsquo;s namespace.
Because you don&rsquo;t know if the user has <br>
already used your variable and subroutine names, it&rsquo;s
vitally important to carefully select what to export. Do not
export method or variable names by default without a good
<br>
reason.</p>

<p style="margin-top: 1em">As a general rule, if the module
is trying to be object-oriented then don&rsquo;t export
anything. If it&rsquo;s just a collection of functions and
variables, then you can export them via <br>
another array, called @EXPORT_OK. This array does not
automatically place its subroutine and variable names into
the namespace unless the user specifically requests that
this be <br>
done.</p>

<p style="margin-top: 1em">See perlmod for more
information.</p>

<p style="margin-top: 1em">The $VERSION variable is used to
ensure that the .pm file and the shared library are &quot;in
sync&quot; with each other. Any time you make changes to the
.pm or .xs files, you should <br>
increment the value of this variable.</p>

<p style="margin-top: 1em">Writing good test scripts <br>
The importance of writing good test scripts cannot be
over-emphasized. You should closely follow the &quot;ok/not
ok&quot; style that Perl itself uses, so that it is very
easy and <br>
unambiguous to determine the outcome of each test case. When
you find and fix a bug, make sure you add a test case for
it.</p>

<p style="margin-top: 1em">By running &quot;&quot;make
test&quot;&quot;, you ensure that your Mytest.t script runs
and uses the correct version of your extension. If you have
many test cases, save your test files in the &quot;t&quot;
<br>
directory and use the suffix &quot;.t&quot;. When you run
&quot;&quot;make test&quot;&quot;, all of these test files
will be executed.</p>

<p style="margin-top: 1em">EXAMPLE 3 <br>
Our third extension will take one argument as its input,
round off that value, and set the argument to the rounded
value.</p>

<p style="margin-top: 1em">Add the following to the end of
Mytest.xs:</p>

<p style="margin-top: 1em">void <br>
round(arg) <br>
double arg <br>
CODE: <br>
if (arg &gt; 0.0) { <br>
arg = floor(arg + 0.5); <br>
} else if (arg &lt; 0.0) { <br>
arg = ceil(arg - 0.5); <br>
} else { <br>
arg = 0.0; <br>
} <br>
OUTPUT: <br>
arg</p>

<p style="margin-top: 1em">Edit the Makefile.PL file so
that the corresponding line looks like this:</p>

<p style="margin-top: 1em">&rsquo;LIBS&rsquo; =&gt;
[&rsquo;-lm&rsquo;], # e.g., &rsquo;-lm&rsquo;</p>

<p style="margin-top: 1em">Generate the Makefile and run
make. Change the test number in Mytest.t to &quot;9&quot;
and add the following tests:</p>

<p style="margin-top: 1em">$i = -1.5;
&amp;Mytest::round($i); is( $i, -2.0 ); <br>
$i = -1.1; &amp;Mytest::round($i); is( $i, -1.0 ); <br>
$i = 0.0; &amp;Mytest::round($i); is( $i, 0.0 ); <br>
$i = 0.5; &amp;Mytest::round($i); is( $i, 1.0 ); <br>
$i = 1.2; &amp;Mytest::round($i); is( $i, 1.0 );</p>

<p style="margin-top: 1em">Running &quot;&quot;make
test&quot;&quot; should now print out that all nine tests
are okay.</p>

<p style="margin-top: 1em">Notice that in these new test
cases, the argument passed to round was a scalar variable.
You might be wondering if you can round a constant or
literal. To see what happens, <br>
temporarily add the following line to Mytest.t:</p>

<p style="margin-top: 1em">&amp;Mytest::round(3);</p>

<p style="margin-top: 1em">Run &quot;&quot;make
test&quot;&quot; and notice that Perl dies with a fatal
error. Perl won&rsquo;t let you change the value of
constants!</p>

<p style="margin-top: 1em">What&rsquo;s new here? <br>
&Acirc;&middot; We&rsquo;ve made some changes to
Makefile.PL. In this case, we&rsquo;ve specified an extra
library to be linked into the extension&rsquo;s shared
library, the math library libm in this case. <br>
We&rsquo;ll talk later about how to write XSUBs that can
call every routine in a library.</p>

<p style="margin-top: 1em">&Acirc;&middot; The value of the
function is not being passed back as the function&rsquo;s
return value, but by changing the value of the variable that
was passed into the function. You might <br>
have guessed that when you saw that the return value of
round is of type &quot;void&quot;.</p>

<p style="margin-top: 1em">Input and Output Parameters <br>
You specify the parameters that will be passed into the XSUB
on the line(s) after you declare the function&rsquo;s return
value and name. Each input parameter line starts with <br>
optional whitespace, and may have an optional terminating
semicolon.</p>

<p style="margin-top: 1em">The list of output parameters
occurs at the very end of the function, just after the
OUTPUT: directive. The use of RETVAL tells Perl that you
wish to send this value back as the <br>
return value of the XSUB function. In Example 3, we wanted
the &quot;return value&quot; placed in the original variable
which we passed in, so we listed it (and not RETVAL) in the
OUTPUT: <br>
section.</p>

<p style="margin-top: 1em">The XSUBPP Program <br>
The xsubpp program takes the XS code in the .xs file and
translates it into C code, placing it in a file whose suffix
is .c. The C code created makes heavy use of the C <br>
functions within Perl.</p>

<p style="margin-top: 1em">The TYPEMAP file <br>
The xsubpp program uses rules to convert from Perl&rsquo;s
data types (scalar, array, etc.) to C&rsquo;s data types
(int, char, etc.). These rules are stored in the typemap
file <br>
($PERLLIB/ExtUtils/typemap). There&rsquo;s a brief
discussion below, but all the nitty-gritty details can be
found in perlxstypemap. If you have a new-enough version of
perl (5.16 <br>
and up) or an upgraded XS compiler
(&quot;ExtUtils::ParseXS&quot; 3.13_01 or better), then you
can inline typemaps in your XS instead of writing separate
files. Either way, this typemap <br>
thing is split into three parts:</p>

<p style="margin-top: 1em">The first section maps various C
data types to a name, which corresponds somewhat with the
various Perl types. The second section contains C code which
xsubpp uses to handle <br>
input parameters. The third section contains C code which
xsubpp uses to handle output parameters.</p>

<p style="margin-top: 1em">Let&rsquo;s take a look at a
portion of the .c file created for our extension. The file
name is Mytest.c:</p>

<p style="margin-top: 1em">XS(XS_Mytest_round) <br>
{ <br>
dXSARGS; <br>
if (items != 1) <br>
Perl_croak(aTHX_ &quot;Usage: Mytest::round(arg)&quot;);
<br>
PERL_UNUSED_VAR(cv); /* -W */ <br>
{ <br>
double arg = (double)SvNV(ST(0)); /* XXXXX */ <br>
if (arg &gt; 0.0) { <br>
arg = floor(arg + 0.5); <br>
} else if (arg &lt; 0.0) { <br>
arg = ceil(arg - 0.5); <br>
} else { <br>
arg = 0.0; <br>
} <br>
sv_setnv(ST(0), (double)arg); /* XXXXX */ <br>
SvSETMAGIC(ST(0)); <br>
} <br>
XSRETURN_EMPTY; <br>
}</p>

<p style="margin-top: 1em">Notice the two lines commented
with &quot;XXXXX&quot;. If you check the first part of the
typemap file (or section), you&rsquo;ll see that doubles are
of type T_DOUBLE. In the INPUT part of <br>
the typemap, an argument that is T_DOUBLE is assigned to the
variable arg by calling the routine SvNV on something, then
casting it to double, then assigned to the variable arg.
<br>
Similarly, in the OUTPUT section, once arg has its final
value, it is passed to the sv_setnv function to be passed
back to the calling subroutine. These two functions are <br>
explained in perlguts; we&rsquo;ll talk more later about
what that &quot;ST(0)&quot; means in the section on the
argument stack.</p>

<p style="margin-top: 1em">Warning about Output Arguments
<br>
In general, it&rsquo;s not a good idea to write extensions
that modify their input parameters, as in Example 3.
Instead, you should probably return multiple values in an
array and let <br>
the caller handle them (we&rsquo;ll do this in a later
example). However, in order to better accommodate calling
pre-existing C routines, which often do modify their input
parameters, <br>
this behavior is tolerated.</p>

<p style="margin-top: 1em">EXAMPLE 4 <br>
In this example, we&rsquo;ll now begin to write XSUBs that
will interact with pre-defined C libraries. To begin with,
we will build a small library of our own, then let h2xs
write our <br>
.pm and .xs files for us.</p>

<p style="margin-top: 1em">Create a new directory called
Mytest2 at the same level as the directory Mytest. In the
Mytest2 directory, create another directory called mylib,
and cd into that directory.</p>

<p style="margin-top: 1em">Here we&rsquo;ll create some
files that will generate a test library. These will include
a C source file and a header file. We&rsquo;ll also create a
Makefile.PL in this directory. Then <br>
we&rsquo;ll make sure that running make at the Mytest2 level
will automatically run this Makefile.PL file and the
resulting Makefile.</p>

<p style="margin-top: 1em">In the mylib directory, create a
file mylib.h that looks like this:</p>

<p style="margin-top: 1em">#define TESTVAL 4</p>

<p style="margin-top: 1em">extern double foo(int, long,
const char*);</p>

<p style="margin-top: 1em">Also create a file mylib.c that
looks like this:</p>

<p style="margin-top: 1em">#include &lt;stdlib.h&gt; <br>
#include &quot;./mylib.h&quot;</p>

<p style="margin-top: 1em">double <br>
foo(int a, long b, const char *c) <br>
{ <br>
return (a + b + atof(c) + TESTVAL); <br>
}</p>

<p style="margin-top: 1em">And finally create a file
Makefile.PL that looks like this:</p>

<p style="margin-top: 1em">use ExtUtils::MakeMaker; <br>
$Verbose = 1; <br>
WriteMakefile( <br>
NAME =&gt; &rsquo;Mytest2::mylib&rsquo;, <br>
SKIP =&gt; [qw(all static static_lib dynamic dynamic_lib)],
<br>
clean =&gt; {&rsquo;FILES&rsquo; =&gt;
&rsquo;libmylib$(LIB_EXT)&rsquo;}, <br>
);</p>

<p style="margin-top: 1em">sub MY::top_targets { <br>
&rsquo; <br>
all :: static</p>

<p style="margin-top: 1em">pure_all :: static</p>

<p style="margin-top: 1em">static :: libmylib$(LIB_EXT)</p>

<p style="margin-top: 1em">libmylib$(LIB_EXT): $(O_FILES)
<br>
$(AR) cr libmylib$(LIB_EXT) $(O_FILES) <br>
$(RANLIB) libmylib$(LIB_EXT)</p>

<p style="margin-top: 1em">&rsquo;; <br>
}</p>

<p style="margin-top: 1em">Make sure you use a tab and not
spaces on the lines beginning with &quot;$(AR)&quot; and
&quot;$(RANLIB)&quot;. Make will not function properly if
you use spaces. It has also been reported that <br>
the &quot;cr&quot; argument to $(AR) is unnecessary on Win32
systems.</p>

<p style="margin-top: 1em">We will now create the main
top-level Mytest2 files. Change to the directory above
Mytest2 and run the following command:</p>

<p style="margin-top: 1em">% h2xs -O -n Mytest2
./Mytest2/mylib/mylib.h</p>

<p style="margin-top: 1em">This will print out a warning
about overwriting Mytest2, but that&rsquo;s okay. Our files
are stored in Mytest2/mylib, and will be untouched.</p>

<p style="margin-top: 1em">The normal Makefile.PL that h2xs
generates doesn&rsquo;t know about the mylib directory. We
need to tell it that there is a subdirectory and that we
will be generating a library in <br>
it. Let&rsquo;s add the argument MYEXTLIB to the
WriteMakefile call so that it looks like this:</p>

<p style="margin-top: 1em">WriteMakefile( <br>
&rsquo;NAME&rsquo; =&gt; &rsquo;Mytest2&rsquo;, <br>
&rsquo;VERSION_FROM&rsquo; =&gt; &rsquo;Mytest2.pm&rsquo;, #
finds $VERSION <br>
&rsquo;LIBS&rsquo; =&gt; [&rsquo;&rsquo;], # e.g.,
&rsquo;-lm&rsquo; <br>
&rsquo;DEFINE&rsquo; =&gt; &rsquo;&rsquo;, # e.g.,
&rsquo;-DHAVE_SOMETHING&rsquo; <br>
&rsquo;INC&rsquo; =&gt; &rsquo;&rsquo;, # e.g.,
&rsquo;-I/usr/include/other&rsquo; <br>
&rsquo;MYEXTLIB&rsquo; =&gt;
&rsquo;mylib/libmylib$(LIB_EXT)&rsquo;, <br>
);</p>

<p style="margin-top: 1em">and then at the end add a
subroutine (which will override the pre-existing
subroutine). Remember to use a tab character to indent the
line beginning with &quot;cd&quot;!</p>

<p style="margin-top: 1em">sub MY::postamble { <br>
&rsquo; <br>
$(MYEXTLIB): mylib/Makefile <br>
cd mylib &amp;&amp; $(MAKE) $(PASSTHRU) <br>
&rsquo;; <br>
}</p>

<p style="margin-top: 1em">Let&rsquo;s also fix the
MANIFEST file so that it accurately reflects the contents of
our extension. The single line that says &quot;mylib&quot;
should be replaced by the following three lines:</p>

<p style="margin-top: 1em">mylib/Makefile.PL <br>
mylib/mylib.c <br>
mylib/mylib.h</p>

<p style="margin-top: 1em">To keep our namespace nice and
unpolluted, edit the .pm file and change the variable
@EXPORT to @EXPORT_OK. Finally, in the .xs file, edit the
#include line to read:</p>

<p style="margin-top: 1em">#include
&quot;mylib/mylib.h&quot;</p>

<p style="margin-top: 1em">And also add the following
function definition to the end of the .xs file:</p>

<p style="margin-top: 1em">double <br>
foo(a,b,c) <br>
int a <br>
long b <br>
const char * c <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">Now we also need to create a
typemap because the default Perl doesn&rsquo;t currently
support the &quot;const char *&quot; type. Include a new
TYPEMAP section in your XS code before the above <br>
function:</p>

<p style="margin-top: 1em">TYPEMAP: &lt;&lt;END; <br>
const char * T_PV <br>
END</p>

<p style="margin-top: 1em">Now run perl on the top-level
Makefile.PL. Notice that it also created a Makefile in the
mylib directory. Run make and watch that it does cd into the
mylib directory and run <br>
make in there as well.</p>

<p style="margin-top: 1em">Now edit the Mytest2.t script
and change the number of tests to &quot;4&quot;, and add the
following lines to the end of the script:</p>

<p style="margin-top: 1em">is( &amp;Mytest2::foo(1, 2,
&quot;Hello, world!&quot;), 7 ); <br>
is( &amp;Mytest2::foo(1, 2, &quot;0.0&quot;), 7 ); <br>
ok( abs(&amp;Mytest2::foo(0, 0, &quot;-3.4&quot;) - 0.6)
&lt;= 0.01 );</p>

<p style="margin-top: 1em">(When dealing with
floating-point comparisons, it is best to not check for
equality, but rather that the difference between the
expected and actual result is below a certain <br>
amount (called epsilon) which is 0.01 in this case)</p>

<p style="margin-top: 1em">Run &quot;&quot;make
test&quot;&quot; and all should be well. There are some
warnings on missing tests for the Mytest2::mylib extension,
but you can ignore them.</p>

<p style="margin-top: 1em">What has happened here? <br>
Unlike previous examples, we&rsquo;ve now run h2xs on a real
include file. This has caused some extra goodies to appear
in both the .pm and .xs files.</p>

<p style="margin-top: 1em">&Acirc;&middot; In the .xs file,
there&rsquo;s now a #include directive with the absolute
path to the mylib.h header file. We changed this to a
relative path so that we could move the extension <br>
directory if we wanted to.</p>

<p style="margin-top: 1em">&Acirc;&middot; There&rsquo;s
now some new C code that&rsquo;s been added to the .xs file.
The purpose of the &quot;constant&quot; routine is to make
the values that are #define&rsquo;d in the header file
accessible <br>
by the Perl script (by calling either &quot;TESTVAL&quot; or
&amp;Mytest2::TESTVAL). There&rsquo;s also some XS code to
allow calls to the &quot;constant&quot; routine.</p>

<p style="margin-top: 1em">&Acirc;&middot; The .pm file
originally exported the name &quot;TESTVAL&quot; in the
@EXPORT array. This could lead to name clashes. A good rule
of thumb is that if the #define is only going to be <br>
used by the C routines themselves, and not by the user, they
should be removed from the @EXPORT array. Alternately, if
you don&rsquo;t mind using the &quot;fully qualified
name&quot; of a <br>
variable, you could move most or all of the items from the
@EXPORT array into the @EXPORT_OK array.</p>

<p style="margin-top: 1em">&Acirc;&middot; If our include
file had contained #include directives, these would not have
been processed by h2xs. There is no good solution to this
right now.</p>

<p style="margin-top: 1em">&Acirc;&middot; We&rsquo;ve also
told Perl about the library that we built in the mylib
subdirectory. That required only the addition of the
&quot;MYEXTLIB&quot; variable to the WriteMakefile call and
the <br>
replacement of the postamble subroutine to cd into the
subdirectory and run make. The Makefile.PL for the library
is a bit more complicated, but not excessively so. Again
<br>
we replaced the postamble subroutine to insert our own code.
This code simply specified that the library to be created
here was a static archive library (as opposed to a <br>
dynamically loadable library) and provided the commands to
build it.</p>

<p style="margin-top: 1em">Anatomy of .xs file <br>
The .xs file of &quot;EXAMPLE 4&quot; contained some new
elements. To understand the meaning of these elements, pay
attention to the line which reads</p>

<p style="margin-top: 1em">MODULE = Mytest2 PACKAGE =
Mytest2</p>

<p style="margin-top: 1em">Anything before this line is
plain C code which describes which headers to include, and
defines some convenience functions. No translations are
performed on this part, apart <br>
from having embedded POD documentation skipped over (see
perlpod) it goes into the generated output C file as is.</p>

<p style="margin-top: 1em">Anything after this line is the
description of XSUB functions. These descriptions are
translated by xsubpp into C code which implements these
functions using Perl calling <br>
conventions, and which makes these functions visible from
Perl interpreter.</p>

<p style="margin-top: 1em">Pay a special attention to the
function &quot;constant&quot;. This name appears twice in
the generated .xs file: once in the first part, as a static
C function, then another time in the <br>
second part, when an XSUB interface to this static C
function is defined.</p>

<p style="margin-top: 1em">This is quite typical for .xs
files: usually the .xs file provides an interface to an
existing C function. Then this C function is defined
somewhere (either in an external <br>
library, or in the first part of .xs file), and a Perl
interface to this function (i.e. &quot;Perl glue&quot;) is
described in the second part of .xs file. The situation in
&quot;EXAMPLE 1&quot;, <br>
&quot;EXAMPLE 2&quot;, and &quot;EXAMPLE 3&quot;, when all
the work is done inside the &quot;Perl glue&quot;, is
somewhat of an exception rather than the rule.</p>

<p style="margin-top: 1em">Getting the fat out of XSUBs
<br>
In &quot;EXAMPLE 4&quot; the second part of .xs file
contained the following description of an XSUB:</p>

<p style="margin-top: 1em">double <br>
foo(a,b,c) <br>
int a <br>
long b <br>
const char * c <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">Note that in contrast with
&quot;EXAMPLE 1&quot;, &quot;EXAMPLE 2&quot; and
&quot;EXAMPLE 3&quot;, this description does not contain the
actual code for what is done during a call to Perl function
foo(). To <br>
understand what is going on here, one can add a CODE section
to this XSUB:</p>

<p style="margin-top: 1em">double <br>
foo(a,b,c) <br>
int a <br>
long b <br>
const char * c <br>
CODE: <br>
RETVAL = foo(a,b,c); <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">However, these two XSUBs provide
almost identical generated C code: xsubpp compiler is smart
enough to figure out the &quot;CODE:&quot; section from the
first two lines of the description <br>
of XSUB. What about &quot;OUTPUT:&quot; section? In fact,
that is absolutely the same! The &quot;OUTPUT:&quot; section
can be removed as well, as far as &quot;CODE:&quot; section
or &quot;PPCODE:&quot; section is <br>
not specified: xsubpp can see that it needs to generate a
function call section, and will autogenerate the OUTPUT
section too. Thus one can shortcut the XSUB to become:</p>

<p style="margin-top: 1em">double <br>
foo(a,b,c) <br>
int a <br>
long b <br>
const char * c</p>

<p style="margin-top: 1em">Can we do the same with an
XSUB</p>

<p style="margin-top: 1em">int <br>
is_even(input) <br>
int input <br>
CODE: <br>
RETVAL = (input % 2 == 0); <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">of &quot;EXAMPLE 2&quot;? To do
this, one needs to define a C function &quot;int is_even(int
input)&quot;. As we saw in &quot;Anatomy of .xs file&quot;,
a proper place for this definition is in the first <br>
part of .xs file. In fact a C function</p>

<p style="margin-top: 1em">int <br>
is_even(int arg) <br>
{ <br>
return (arg % 2 == 0); <br>
}</p>

<p style="margin-top: 1em">is probably overkill for this.
Something as simple as a &quot;#define&quot; will do
too:</p>

<p style="margin-top: 1em">#define is_even(arg) ((arg) % 2
== 0)</p>

<p style="margin-top: 1em">After having this in the first
part of .xs file, the &quot;Perl glue&quot; part becomes as
simple as</p>

<p style="margin-top: 1em">int <br>
is_even(input) <br>
int input</p>

<p style="margin-top: 1em">This technique of separation of
the glue part from the workhorse part has obvious tradeoffs:
if you want to change a Perl interface, you need to change
two places in your code. <br>
However, it removes a lot of clutter, and makes the
workhorse part independent from idiosyncrasies of Perl
calling convention. (In fact, there is nothing Perl-specific
in the <br>
above description, a different version of xsubpp might have
translated this to TCL glue or Python glue as well.)</p>

<p style="margin-top: 1em">More about XSUB arguments <br>
With the completion of Example 4, we now have an easy way to
simulate some real-life libraries whose interfaces may not
be the cleanest in the world. We shall now continue with
<br>
a discussion of the arguments passed to the xsubpp
compiler.</p>

<p style="margin-top: 1em">When you specify arguments to
routines in the .xs file, you are really passing three
pieces of information for each argument listed. The first
piece is the order of that <br>
argument relative to the others (first, second, etc). The
second is the type of argument, and consists of the type
declaration of the argument (e.g., int, char*, etc). The
<br>
third piece is the calling convention for the argument in
the call to the library function.</p>

<p style="margin-top: 1em">While Perl passes arguments to
functions by reference, C passes arguments by value; to
implement a C function which modifies data of one of the
&quot;arguments&quot;, the actual argument <br>
of this C function would be a pointer to the data. Thus two
C functions with declarations</p>

<p style="margin-top: 1em">int string_length(char *s); <br>
int upper_case_char(char *cp);</p>

<p style="margin-top: 1em">may have completely different
semantics: the first one may inspect an array of chars
pointed by s, and the second one may immediately dereference
&quot;cp&quot; and manipulate *cp only <br>
(using the return value as, say, a success indicator). From
Perl one would use these functions in a completely different
manner.</p>

<p style="margin-top: 1em">One conveys this info to xsubpp
by replacing &quot;*&quot; before the argument by
&quot;&amp;&quot;. &quot;&amp;&quot; means that the argument
should be passed to a library function by its address. The
above two <br>
function may be XSUB-ified as</p>

<p style="margin-top: 1em">int <br>
string_length(s) <br>
char * s</p>

<p style="margin-top: 1em">int <br>
upper_case_char(cp) <br>
char &amp;cp</p>

<p style="margin-top: 1em">For example, consider:</p>

<p style="margin-top: 1em">int <br>
foo(a,b) <br>
char &amp;a <br>
char * b</p>

<p style="margin-top: 1em">The first Perl argument to this
function would be treated as a char and assigned to the
variable a, and its address would be passed into the
function foo. The second Perl <br>
argument would be treated as a string pointer and assigned
to the variable b. The value of b would be passed into the
function foo. The actual call to the function foo that <br>
xsubpp generates would look like this:</p>

<p style="margin-top: 1em">foo(&amp;a, b);</p>

<p style="margin-top: 1em">xsubpp will parse the following
function argument lists identically:</p>

<p style="margin-top: 1em">char &amp;a <br>
char&amp;a <br>
char &amp; a</p>

<p style="margin-top: 1em">However, to help ease
understanding, it is suggested that you place a
&quot;&amp;&quot; next to the variable name and away from
the variable type), and place a &quot;*&quot; near the
variable type, but <br>
away from the variable name (as in the call to foo above).
By doing so, it is easy to understand exactly what will be
passed to the C function; it will be whatever is in the <br>
&quot;last column&quot;.</p>

<p style="margin-top: 1em">You should take great pains to
try to pass the function the type of variable it wants, when
possible. It will save you a lot of trouble in the long
run.</p>

<p style="margin-top: 1em">The Argument Stack <br>
If we look at any of the C code generated by any of the
examples except example 1, you will notice a number of
references to ST(n), where n is usually 0. &quot;ST&quot; is
actually a <br>
macro that points to the n&rsquo;th argument on the argument
stack. ST(0) is thus the first argument on the stack and
therefore the first argument passed to the XSUB, ST(1) is
the <br>
second argument, and so on.</p>

<p style="margin-top: 1em">When you list the arguments to
the XSUB in the .xs file, that tells xsubpp which argument
corresponds to which of the argument stack (i.e., the first
one listed is the first <br>
argument, and so on). You invite disaster if you do not list
them in the same order as the function expects them.</p>

<p style="margin-top: 1em">The actual values on the
argument stack are pointers to the values passed in. When an
argument is listed as being an OUTPUT value, its
corresponding value on the stack (i.e., <br>
ST(0) if it was the first argument) is changed. You can
verify this by looking at the C code generated for Example
3. The code for the round() XSUB routine contains lines that
<br>
look like this:</p>

<p style="margin-top: 1em">double arg =
(double)SvNV(ST(0)); <br>
/* Round the contents of the variable arg */ <br>
sv_setnv(ST(0), (double)arg);</p>

<p style="margin-top: 1em">The arg variable is initially
set by taking the value from ST(0), then is stored back into
ST(0) at the end of the routine.</p>

<p style="margin-top: 1em">XSUBs are also allowed to return
lists, not just scalars. This must be done by manipulating
stack values ST(0), ST(1), etc, in a subtly different way.
See perlxs for details.</p>

<p style="margin-top: 1em">XSUBs are also allowed to avoid
automatic conversion of Perl function arguments to C
function arguments. See perlxs for details. Some people
prefer manual conversion by <br>
inspecting ST(i) even in the cases when automatic conversion
will do, arguing that this makes the logic of an XSUB call
clearer. Compare with &quot;Getting the fat out of
XSUBs&quot; for <br>
a similar tradeoff of a complete separation of &quot;Perl
glue&quot; and &quot;workhorse&quot; parts of an XSUB.</p>

<p style="margin-top: 1em">While experts may argue about
these idioms, a novice to Perl guts may prefer a way which
is as little Perl-guts-specific as possible, meaning
automatic conversion and automatic <br>
call generation, as in &quot;Getting the fat out of
XSUBs&quot;. This approach has the additional benefit of
protecting the XSUB writer from future changes to the Perl
API.</p>

<p style="margin-top: 1em">Extending your Extension <br>
Sometimes you might want to provide some extra methods or
subroutines to assist in making the interface between Perl
and your extension simpler or easier to understand. These
<br>
routines should live in the .pm file. Whether they are
automatically loaded when the extension itself is loaded or
only loaded when called depends on where in the .pm file the
<br>
subroutine definition is placed. You can also consult
AutoLoader for an alternate way to store and load your extra
subroutines.</p>

<p style="margin-top: 1em">Documenting your Extension <br>
There is absolutely no excuse for not documenting your
extension. Documentation belongs in the .pm file. This file
will be fed to pod2man, and the embedded documentation will
<br>
be converted to the manpage format, then placed in the blib
directory. It will be copied to Perl&rsquo;s manpage
directory when the extension is installed.</p>

<p style="margin-top: 1em">You may intersperse
documentation and Perl code within the .pm file. In fact, if
you want to use method autoloading, you must do this, as the
comment inside the .pm file <br>
explains.</p>

<p style="margin-top: 1em">See perlpod for more information
about the pod format.</p>

<p style="margin-top: 1em">Installing your Extension <br>
Once your extension is complete and passes all its tests,
installing it is quite simple: you simply run &quot;make
install&quot;. You will either need to have write permission
into the <br>
directories where Perl is installed, or ask your system
administrator to run the make for you.</p>

<p style="margin-top: 1em">Alternately, you can specify the
exact directory to place the extension&rsquo;s files by
placing a &quot;PREFIX=/destination/directory&quot; after
the make install. (or in between the make and <br>
install if you have a brain-dead version of make). This can
be very useful if you are building an extension that will
eventually be distributed to multiple systems. You can <br>
then just archive the files in the destination directory and
distribute them to your destination systems.</p>

<p style="margin-top: 1em">EXAMPLE 5 <br>
In this example, we&rsquo;ll do some more work with the
argument stack. The previous examples have all returned only
a single value. We&rsquo;ll now create an extension that
returns an <br>
array.</p>

<p style="margin-top: 1em">This extension is very
Unix-oriented (struct statfs and the statfs system call). If
you are not running on a Unix system, you can substitute for
statfs any other function that <br>
returns multiple values, you can hard-code values to be
returned to the caller (although this will be a bit harder
to test the error case), or you can simply not do this
example. <br>
If you change the XSUB, be sure to fix the test cases to
match the changes.</p>

<p style="margin-top: 1em">Return to the Mytest directory
and add the following code to the end of Mytest.xs:</p>

<p style="margin-top: 1em">void <br>
statfs(path) <br>
char * path <br>
INIT: <br>
int i; <br>
struct statfs buf;</p>

<p style="margin-top: 1em">PPCODE: <br>
i = statfs(path, &amp;buf); <br>
if (i == 0) { <br>
XPUSHs(sv_2mortal(newSVnv(buf.f_bavail))); <br>
XPUSHs(sv_2mortal(newSVnv(buf.f_bfree))); <br>
XPUSHs(sv_2mortal(newSVnv(buf.f_blocks))); <br>
XPUSHs(sv_2mortal(newSVnv(buf.f_bsize))); <br>
XPUSHs(sv_2mortal(newSVnv(buf.f_ffree))); <br>
XPUSHs(sv_2mortal(newSVnv(buf.f_files))); <br>
XPUSHs(sv_2mortal(newSVnv(buf.f_type))); <br>
} else { <br>
XPUSHs(sv_2mortal(newSVnv(errno))); <br>
}</p>

<p style="margin-top: 1em">You&rsquo;ll also need to add
the following code to the top of the .xs file, just after
the include of &quot;XSUB.h&quot;:</p>

<p style="margin-top: 1em">#include &lt;sys/vfs.h&gt;</p>

<p style="margin-top: 1em">Also add the following code
segment to Mytest.t while incrementing the &quot;9&quot;
tests to &quot;11&quot;:</p>

<p style="margin-top: 1em">@a =
&amp;Mytest::statfs(&quot;/blech&quot;); <br>
ok( scalar(@a) == 1 &amp;&amp; $a[0] == 2 ); <br>
@a = &amp;Mytest::statfs(&quot;/&quot;); <br>
is( scalar(@a), 7 );</p>

<p style="margin-top: 1em">New Things in this Example <br>
This example added quite a few new concepts. We&rsquo;ll
take them one at a time.</p>

<p style="margin-top: 1em">&Acirc;&middot; The INIT:
directive contains code that will be placed immediately
after the argument stack is decoded. C does not allow
variable declarations at arbitrary locations inside a <br>
function, so this is usually the best way to declare local
variables needed by the XSUB. (Alternatively, one could put
the whole &quot;PPCODE:&quot; section into braces, and put
these <br>
declarations on top.)</p>

<p style="margin-top: 1em">&Acirc;&middot; This routine
also returns a different number of arguments depending on
the success or failure of the call to statfs. If there is an
error, the error number is returned as a <br>
single-element array. If the call is successful, then a
7-element array is returned. Since only one argument is
passed into this function, we need room on the stack to hold
<br>
the 7 values which may be returned.</p>

<p style="margin-top: 1em">We do this by using the PPCODE:
directive, rather than the CODE: directive. This tells
xsubpp that we will be managing the return values that will
be put on the argument <br>
stack by ourselves.</p>

<p style="margin-top: 1em">&Acirc;&middot; When we want to
place values to be returned to the caller onto the stack, we
use the series of macros that begin with &quot;XPUSH&quot;.
There are five different versions, for placing <br>
integers, unsigned integers, doubles, strings, and Perl
scalars on the stack. In our example, we placed a Perl
scalar onto the stack. (In fact this is the only macro which
<br>
can be used to return multiple values.)</p>

<p style="margin-top: 1em">The XPUSH* macros will
automatically extend the return stack to prevent it from
being overrun. You push values onto the stack in the order
you want them seen by the calling <br>
program.</p>

<p style="margin-top: 1em">&Acirc;&middot; The values
pushed onto the return stack of the XSUB are actually mortal
SV&rsquo;s. They are made mortal so that once the values are
copied by the calling program, the SV&rsquo;s that <br>
held the returned values can be deallocated. If they were
not mortal, then they would continue to exist after the XSUB
routine returned, but would not be accessible. This <br>
is a memory leak.</p>

<p style="margin-top: 1em">&Acirc;&middot; If we were
interested in performance, not in code compactness, in the
success branch we would not use &quot;XPUSHs&quot; macros,
but &quot;PUSHs&quot; macros, and would pre-extend the stack
<br>
before pushing the return values:</p>

<p style="margin-top: 1em">EXTEND(SP, 7);</p>

<p style="margin-top: 1em">The tradeoff is that one needs
to calculate the number of return values in advance (though
overextending the stack will not typically hurt anything but
memory consumption).</p>

<p style="margin-top: 1em">Similarly, in the failure branch
we could use &quot;PUSHs&quot; without extending the stack:
the Perl function reference comes to an XSUB on the stack,
thus the stack is always large <br>
enough to take one return value.</p>

<p style="margin-top: 1em">EXAMPLE 6 <br>
In this example, we will accept a reference to an array as
an input parameter, and return a reference to an array of
hashes. This will demonstrate manipulation of complex Perl
<br>
data types from an XSUB.</p>

<p style="margin-top: 1em">This extension is somewhat
contrived. It is based on the code in the previous example.
It calls the statfs function multiple times, accepting a
reference to an array of <br>
filenames as input, and returning a reference to an array of
hashes containing the data for each of the filesystems.</p>

<p style="margin-top: 1em">Return to the Mytest directory
and add the following code to the end of Mytest.xs:</p>

<p style="margin-top: 1em">SV * <br>
multi_statfs(paths) <br>
SV * paths <br>
INIT: <br>
AV * results; <br>
I32 numpaths = 0; <br>
int i, n; <br>
struct statfs buf;</p>

<p style="margin-top: 1em">SvGETMAGIC(paths); <br>
if ((!SvROK(paths)) <br>
|| (SvTYPE(SvRV(paths)) != SVt_PVAV) <br>
|| ((numpaths = av_len((AV *)SvRV(paths))) &lt; 0)) <br>
{ <br>
XSRETURN_UNDEF; <br>
} <br>
results = (AV *)sv_2mortal((SV *)newAV()); <br>
CODE: <br>
for (n = 0; n &lt;= numpaths; n++) { <br>
HV * rh; <br>
STRLEN l; <br>
char * fn = SvPV(*av_fetch((AV *)SvRV(paths), n, 0), l);</p>

<p style="margin-top: 1em">i = statfs(fn, &amp;buf); <br>
if (i != 0) { <br>
av_push(results, newSVnv(errno)); <br>
continue; <br>
}</p>

<p style="margin-top: 1em">rh = (HV *)sv_2mortal((SV
*)newHV());</p>

<p style="margin-top: 1em">hv_store(rh,
&quot;f_bavail&quot;, 8, newSVnv(buf.f_bavail), 0); <br>
hv_store(rh, &quot;f_bfree&quot;, 7, newSVnv(buf.f_bfree),
0); <br>
hv_store(rh, &quot;f_blocks&quot;, 8, newSVnv(buf.f_blocks),
0); <br>
hv_store(rh, &quot;f_bsize&quot;, 7, newSVnv(buf.f_bsize),
0); <br>
hv_store(rh, &quot;f_ffree&quot;, 7, newSVnv(buf.f_ffree),
0); <br>
hv_store(rh, &quot;f_files&quot;, 7, newSVnv(buf.f_files),
0); <br>
hv_store(rh, &quot;f_type&quot;, 6, newSVnv(buf.f_type),
0);</p>

<p style="margin-top: 1em">av_push(results, newRV((SV
*)rh)); <br>
} <br>
RETVAL = newRV((SV *)results); <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">And add the following code to
Mytest.t, while incrementing the &quot;11&quot; tests to
&quot;13&quot;:</p>

<p style="margin-top: 1em">$results =
Mytest::multi_statfs([ &rsquo;/&rsquo;, &rsquo;/blech&rsquo;
]); <br>
ok( ref $results-&gt;[0] ); <br>
ok( ! ref $results-&gt;[1] );</p>

<p style="margin-top: 1em">New Things in this Example <br>
There are a number of new concepts introduced here,
described below:</p>

<p style="margin-top: 1em">&Acirc;&middot; This function
does not use a typemap. Instead, we declare it as accepting
one SV* (scalar) parameter, and returning an SV* value, and
we take care of populating these <br>
scalars within the code. Because we are only returning one
value, we don&rsquo;t need a &quot;PPCODE:&quot; directive -
instead, we use &quot;CODE:&quot; and &quot;OUTPUT:&quot;
directives.</p>

<p style="margin-top: 1em">&Acirc;&middot; When dealing
with references, it is important to handle them with
caution. The &quot;INIT:&quot; block first calls
SvGETMAGIC(paths), in case paths is a tied variable. Then it
checks <br>
that &quot;SvROK&quot; returns true, which indicates that
paths is a valid reference. (Simply checking
&quot;SvROK&quot; won&rsquo;t trigger FETCH on a tied
variable.) It then verifies that the <br>
object referenced by paths is an array, using
&quot;SvRV&quot; to dereference paths, and
&quot;SvTYPE&quot; to discover its type. As an added test,
it checks that the array referenced by paths <br>
is non-empty, using the &quot;av_len&quot; function (which
returns -1 if the array is empty). The XSRETURN_UNDEF macro
is used to abort the XSUB and return the undefined value
<br>
whenever all three of these conditions are not met.</p>

<p style="margin-top: 1em">&Acirc;&middot; We manipulate
several arrays in this XSUB. Note that an array is
represented internally by an AV* pointer. The functions and
macros for manipulating arrays are similar to <br>
the functions in Perl: &quot;av_len&quot; returns the
highest index in an AV*, much like $#array;
&quot;av_fetch&quot; fetches a single scalar value from an
array, given its index; &quot;av_push&quot; <br>
pushes a scalar value onto the end of the array,
automatically extending the array as necessary.</p>

<p style="margin-top: 1em">Specifically, we read pathnames
one at a time from the input array, and store the results in
an output array (results) in the same order. If statfs
fails, the element pushed <br>
onto the return array is the value of errno after the
failure. If statfs succeeds, though, the value pushed onto
the return array is a reference to a hash containing some of
<br>
the information in the statfs structure.</p>

<p style="margin-top: 1em">As with the return stack, it
would be possible (and a small performance win) to
pre-extend the return array before pushing data into it,
since we know how many elements we <br>
will return:</p>

<p style="margin-top: 1em">av_extend(results,
numpaths);</p>

<p style="margin-top: 1em">&Acirc;&middot; We are
performing only one hash operation in this function, which
is storing a new scalar under a key using
&quot;hv_store&quot;. A hash is represented by an HV*
pointer. Like <br>
arrays, the functions for manipulating hashes from an XSUB
mirror the functionality available from Perl. See perlguts
and perlapi for details.</p>

<p style="margin-top: 1em">&Acirc;&middot; To create a
reference, we use the &quot;newRV&quot; function. Note that
you can cast an AV* or an HV* to type SV* in this case (and
many others). This allows you to take references <br>
to arrays, hashes and scalars with the same function.
Conversely, the &quot;SvRV&quot; function always returns an
SV*, which may need to be cast to the appropriate type if it
is <br>
something other than a scalar (check with
&quot;SvTYPE&quot;).</p>

<p style="margin-top: 1em">&Acirc;&middot; At this point,
xsubpp is doing very little work - the differences between
Mytest.xs and Mytest.c are minimal.</p>

<p style="margin-top: 1em">EXAMPLE 7 (Coming Soon) <br>
XPUSH args AND set RETVAL AND assign return value to
array</p>

<p style="margin-top: 1em">EXAMPLE 8 (Coming Soon) <br>
Setting $!</p>

<p style="margin-top: 1em">EXAMPLE 9 Passing open files to
XSes <br>
You would think passing files to an XS is difficult, with
all the typeglobs and stuff. Well, it isn&rsquo;t.</p>

<p style="margin-top: 1em">Suppose that for some strange
reason we need a wrapper around the standard C library
function &quot;fputs()&quot;. This is all we need:</p>

<p style="margin-top: 1em">#define PERLIO_NOT_STDIO 0 <br>
#include &quot;EXTERN.h&quot; <br>
#include &quot;perl.h&quot; <br>
#include &quot;XSUB.h&quot;</p>

<p style="margin-top: 1em">#include &lt;stdio.h&gt;</p>

<p style="margin-top: 1em">int <br>
fputs(s, stream) <br>
char * s <br>
FILE * stream</p>

<p style="margin-top: 1em">The real work is done in the
standard typemap.</p>

<p style="margin-top: 1em">But you loose all the fine stuff
done by the perlio layers. This calls the stdio function
&quot;fputs()&quot;, which knows nothing about them.</p>

<p style="margin-top: 1em">The standard typemap offers
three variants of PerlIO *: &quot;InputStream&quot; (T_IN),
&quot;InOutStream&quot; (T_INOUT) and
&quot;OutputStream&quot; (T_OUT). A bare &quot;PerlIO
*&quot; is considered a T_INOUT. If it <br>
matters in your code (see below for why it might) #define or
typedef one of the specific names and use that as the
argument or result type in your XS file.</p>

<p style="margin-top: 1em">The standard typemap does not
contain PerlIO * before perl 5.7, but it has the three
stream variants. Using a PerlIO * directly is not backwards
compatible unless you provide <br>
your own typemap.</p>

<p style="margin-top: 1em">For streams coming from perl the
main difference is that &quot;OutputStream&quot; will get
the output PerlIO * - which may make a difference on a
socket. Like in our example...</p>

<p style="margin-top: 1em">For streams being handed to perl
a new file handle is created (i.e. a reference to a new
glob) and associated with the PerlIO * provided. If the
read/write state of the PerlIO * <br>
is not correct then you may get errors or warnings from when
the file handle is used. So if you opened the PerlIO * as
&quot;w&quot; it should really be an
&quot;OutputStream&quot; if open as &quot;r&quot; <br>
it should be an &quot;InputStream&quot;.</p>

<p style="margin-top: 1em">Now, suppose you want to use
perlio layers in your XS. We&rsquo;ll use the perlio
&quot;PerlIO_puts()&quot; function as an example.</p>

<p style="margin-top: 1em">In the C part of the XS file
(above the first MODULE line) you have</p>

<p style="margin-top: 1em">#define OutputStream PerlIO *
<br>
or <br>
typedef PerlIO * OutputStream;</p>

<p style="margin-top: 1em">And this is the XS code:</p>

<p style="margin-top: 1em">int <br>
perlioputs(s, stream) <br>
char * s <br>
OutputStream stream <br>
CODE: <br>
RETVAL = PerlIO_puts(stream, s); <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">We have to use a
&quot;CODE&quot; section because &quot;PerlIO_puts()&quot;
has the arguments reversed compared to &quot;fputs()&quot;,
and we want to keep the arguments the same.</p>

<p style="margin-top: 1em">Wanting to explore this
thoroughly, we want to use the stdio &quot;fputs()&quot; on
a PerlIO *. This means we have to ask the perlio system for
a stdio &quot;FILE *&quot;:</p>

<p style="margin-top: 1em">int <br>
perliofputs(s, stream) <br>
char * s <br>
OutputStream stream <br>
PREINIT: <br>
FILE *fp = PerlIO_findFILE(stream); <br>
CODE: <br>
if (fp != (FILE*) 0) { <br>
RETVAL = fputs(s, fp); <br>
} else { <br>
RETVAL = -1; <br>
} <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">Note:
&quot;PerlIO_findFILE()&quot; will search the layers for a
stdio layer. If it can&rsquo;t find one, it will call
&quot;PerlIO_exportFILE()&quot; to generate a new stdio
&quot;FILE&quot;. Please only call <br>
&quot;PerlIO_exportFILE()&quot; if you want a new
&quot;FILE&quot;. It will generate one on each call and push
a new stdio layer. So don&rsquo;t call it repeatedly on the
same file. &quot;PerlIO_findFILE()&quot; <br>
will retrieve the stdio layer once it has been generated by
&quot;PerlIO_exportFILE()&quot;.</p>

<p style="margin-top: 1em">This applies to the perlio
system only. For versions before 5.7,
&quot;PerlIO_exportFILE()&quot; is equivalent to
&quot;PerlIO_findFILE()&quot;.</p>

<p style="margin-top: 1em">Troubleshooting these Examples
<br>
As mentioned at the top of this document, if you are having
problems with these example extensions, you might see if any
of these help you.</p>

<p style="margin-top: 1em">&Acirc;&middot; In versions of
5.002 prior to the gamma version, the test script in Example
1 will not function properly. You need to change the
&quot;use lib&quot; line to read:</p>

<p style="margin-top: 1em">use lib
&rsquo;./blib&rsquo;;</p>

<p style="margin-top: 1em">&Acirc;&middot; In versions of
5.002 prior to version 5.002b1h, the test.pl file was not
automatically created by h2xs. This means that you cannot
say &quot;make test&quot; to run the test script. <br>
You will need to add the following line before the &quot;use
extension&quot; statement:</p>

<p style="margin-top: 1em">use lib
&rsquo;./blib&rsquo;;</p>

<p style="margin-top: 1em">&Acirc;&middot; In versions
5.000 and 5.001, instead of using the above line, you will
need to use the following line:</p>

<p style="margin-top: 1em">BEGIN { unshift(@INC,
&quot;./blib&quot;) }</p>

<p style="margin-top: 1em">&Acirc;&middot; This document
assumes that the executable named &quot;perl&quot; is Perl
version 5. Some systems may have installed Perl version 5 as
&quot;perl5&quot;.</p>

<p style="margin-top: 1em">See also <br>
For more information, consult perlguts, perlapi, perlxs,
perlmod, and perlpod.</p>

<p style="margin-top: 1em">Author <br>
Jeff Okamoto &lt;okamoto@corp.hp.com&gt;</p>

<p style="margin-top: 1em">Reviewed and assisted by Dean
Roehrich, Ilya Zakharevich, Andreas Koenig, and Tim
Bunce.</p>

<p style="margin-top: 1em">PerlIO material contributed by
Lupe Christoph, with some clarification by Nick
Ing-Simmons.</p>

<p style="margin-top: 1em">Changes for h2xs as of Perl
5.8.x by Renee Baecker</p>

<p style="margin-top: 1em">Last Changed <br>
2012-01-20</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLXSTUT(1)</p>
<hr>
</body>
</html>
