<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:58:35 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>CIRCUS(1) Circus CIRCUS(1)</p>

<p style="margin-top: 1em">NAME <br>
circus - Circus Documentation [image]</p>

<p style="margin-top: 1em">Circus is a Python program which
can be used to monitor and control processes and
sockets.</p>

<p style="margin-top: 1em">Circus can be driven via a
command-line interface, a web interface or programmatically
through its python API.</p>

<p style="margin-top: 1em">To install it and try its
features check out the examples, or read the rest of this
page for a quick introduction.</p>

<p style="margin-top: 1em">RUNNING A CIRCUS DAEMON <br>
Circus provides a command-line script call circusd that can
be used to manage processes organized in one or more
watchers.</p>

<p style="margin-top: 1em">Circus&rsquo; command-line tool
is configurable using an ini-style configuration file.</p>

<p style="margin-top: 1em">Here&rsquo;s a very minimal
example:</p>

<p style="margin-top: 1em">[watcher:program] <br>
cmd = python myprogram.py <br>
numprocesses = 5</p>

<p style="margin-top: 1em">[watcher:anotherprogram] <br>
cmd = another_program <br>
numprocesses = 2</p>

<p style="margin-top: 1em">The file is then passed to
circusd:</p>

<p style="margin-top: 1em">$ circusd example.ini</p>

<p style="margin-top: 1em">Besides processes, Circus can
also bind sockets. Since every process managed by Circus is
a child of the main Circus daemon, that means any program
that&rsquo;s controlled by Circus <br>
can use those sockets.</p>

<p style="margin-top: 1em">Running a socket is as simple as
adding a socket section in the config file:</p>

<p style="margin-top: 1em">[socket:mysocket] <br>
host = localhost <br>
port = 8080</p>

<p style="margin-top: 1em">To learn more about sockets, see
sockets.</p>

<p style="margin-top: 1em">To understand why it&rsquo;s a
killer feature, read whycircussockets.</p>

<p style="margin-top: 1em">CONTROLLING CIRCUS <br>
Circus provides two command-line tools to manage your
running daemon:</p>

<p style="margin-top: 1em">&Acirc;&middot; circusctl, a
management console you can use to perform actions such as
adding or removing workers</p>

<p style="margin-top: 1em">&Acirc;&middot; circus-top, a
top-like console you can use to display the memory and cpu
usage of your running Circus.</p>

<p style="margin-top: 1em">To learn more about these, see
cli</p>

<p style="margin-top: 1em">Circus also offers a web
dashboard that can connect to a running Circus daemon and
let you monitor and interact with it.</p>

<p style="margin-top: 1em">To learn more about this
feature, see circushttpd</p>

<p style="margin-top: 1em">What now ? <br>
If you are a developer and want to leverage Circus in your
own project, write plugins or hooks, go to fordevs.</p>

<p style="margin-top: 1em">If you are an ops and want to
manage your processes using Circus, go to forops.</p>

<p style="margin-top: 1em">Contributions and Feedback <br>
More on contributing: contribs.</p>

<p style="margin-top: 1em">Useful Links:</p>

<p style="margin-top: 1em">&Acirc;&middot; There&rsquo;s a
mailing-list for any feedback or question:
http://tech.groups.yahoo.com/group/circus-dev/</p>

<p style="margin-top: 1em">&Acirc;&middot; The repository
and issue tracker are on GitHub :
https://github.com/circus-tent/circus</p>

<p style="margin-top: 1em">&Acirc;&middot; Join us on the
IRC : Freenode, channel #circus-tent</p>

<p style="margin-top: 1em">Documentation index <br>
Installing Circus <br>
Circus is a Python package which is published on PyPI - the
Python Package Index.</p>

<p style="margin-top: 1em">The simplest way to install it
is to use pip, a tool for installing and managing Python
packages:</p>

<p style="margin-top: 1em">$ pip install circus</p>

<p style="margin-top: 1em">Or download the archive on PyPI,
extract and install it manually with:</p>

<p style="margin-top: 1em">$ python setup.py install</p>

<p style="margin-top: 1em">If you want to try out Circus,
see the examples.</p>

<p style="margin-top: 1em">If you are using debian or any
debian based distribution, you also can use the ppa to
install circus, it&rsquo;s at
https://launchpad.net/~roman-imankulov/+archive/circus</p>

<p style="margin-top: 1em">zc.buildout <br>
We provide a zc.buildout configuration, you can use it by
simply running the bootstrap script, then calling
buildout:</p>

<p style="margin-top: 1em">$ python bootstrap.py <br>
$ bin/buildout</p>

<p style="margin-top: 1em">More on Requirements <br>
Circus works with:</p>

<p style="margin-top: 1em">&Acirc;&middot; Python 2.6, 2.7,
3.2 or 3.3</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">zeromq &gt;= 2.1.10</p>

<p style="margin-top: 1em">&Acirc;&middot; The version of
zeromq supported is ultimately determined by what version of
pyzmq is installed by pip during circus installation.</p>

<p style="margin-top: 1em">&Acirc;&middot; Their current
release supports 2.x (limited), 3.x, and 4.x ZeroMQ
versions.</p>

<p style="margin-top: 1em">&Acirc;&middot; Note: If you are
using PyPy instead of CPython, make sure to read their
installation docs as ZeroMQ version support is not the same
on PyPy.</p>

<p style="margin-top: 1em">When you install circus, the
latest versions of the Python dependencies will be pulled
out for you.</p>

<p style="margin-top: 1em">You can also install them
manually using the pip-requirements.txt file we provide:</p>

<p style="margin-top: 1em">$ pip install -r
pip-requirements.txt</p>

<p style="margin-top: 1em">If you want to run the Web
console you will need to install circus-web:</p>

<p style="margin-top: 1em">$ pip install circus-web</p>

<p style="margin-top: 1em">Tutorial <br>
Step-by-step tutorial <br>
The examples directory in the Circus repository contains
many examples to get you started, but here&rsquo;s a full
tutorial that gives you an overview of the features.</p>

<p style="margin-top: 1em">We&rsquo;re going to supervise a
WSGI application.</p>

<p style="margin-top: 1em">Installation <br>
Circus is tested on Mac OS X and Linux with the latest
Python 2.6, 2.7, 3.2 and 3.3. To run a full Circus, you will
also need libzmq, libevent &amp; virtualenv.</p>

<p style="margin-top: 1em">On Debian-based systems:</p>

<p style="margin-top: 1em">$ sudo apt-get install
libzmq-dev libevent-dev python-dev python-virtualenv</p>

<p style="margin-top: 1em">Create a virtualenv and install
circus, circus-web and chaussette in it</p>

<p style="margin-top: 1em">$ virtualenv /tmp/circus <br>
$ cd /tmp/circus <br>
$ bin/pip install circus <br>
$ bin/pip install circus-web <br>
$ bin/pip install chaussette</p>

<p style="margin-top: 1em">Once this is done, you&rsquo;ll
find a plethora of commands in the local bin dir.</p>

<p style="margin-top: 1em">Usage <br>
Chaussette comes with a default Hello world app, try to run
it:</p>

<p style="margin-top: 1em">$ bin/chaussette</p>

<p style="margin-top: 1em">You should be able to visit
http://localhost:8080 and see hello world.</p>

<p style="margin-top: 1em">Stop Chaussette and add a
circus.ini file in the directory containing:</p>

<p style="margin-top: 1em">[circus] <br>
statsd = 1 <br>
httpd = 1</p>

<p style="margin-top: 1em">[watcher:webapp] <br>
cmd = bin/chaussette --fd $(circus.sockets.web) <br>
numprocesses = 3 <br>
use_sockets = True</p>

<p style="margin-top: 1em">[socket:web] <br>
host = 127.0.0.1 <br>
port = 9999</p>

<p style="margin-top: 1em">This config file tells Circus to
bind a socket on port 9999 and run 3 chaussettes workers
against it. It also activates the Circus web dashboard and
the statistics module.</p>

<p style="margin-top: 1em">Save it &amp; run it using
circusd:</p>

<p style="margin-top: 1em">$ bin/circusd --daemon
circus.ini</p>

<p style="margin-top: 1em">Now visit http://127.0.0.1:9999,
you should see the hello world app. The difference now is
that the socket is managed by Circus and there are several
web workers that are accept&acirc; <br>
ing connections against it.</p>

<p style="margin-top: 1em">NOTE: <br>
The load balancing is operated by the operating system so
you&rsquo;re getting the same speed as any other pre-fork
web server like Apache or NGinx. Circus does not interfer
with <br>
the data that goes through.</p>

<p style="margin-top: 1em">You can also visit
http://localhost:8080/ and enjoy the Circus web
dashboard.</p>

<p style="margin-top: 1em">Interaction <br>
Let&rsquo;s use the circusctl shell while the system is
running:</p>

<p style="margin-top: 1em">$ bin/circusctl <br>
circusctl 0.7.1 <br>
circusd-stats: active <br>
circushttpd: active <br>
webapp: active <br>
(circusctl)</p>

<p style="margin-top: 1em">You get into an interactive
shell. Type help to get all commands:</p>

<p style="margin-top: 1em">(circusctl) help</p>

<p style="margin-top: 1em">Documented commands (type help
&lt;topic&gt;): <br>
======================================== <br>
add get list numprocesses quit rm start stop <br>
decr globaloptions listen numwatchers reload set stats <br>
dstats incr listsockets options restart signal status</p>

<p style="margin-top: 1em">Undocumented commands: <br>
====================== <br>
EOF help</p>

<p style="margin-top: 1em">Let&rsquo;s try basic things.
Let&rsquo;s list the web workers processes and add a new
one:</p>

<p style="margin-top: 1em">(circusctl) list webapp <br>
13712,13713,13714 <br>
(circusctl) incr webapp <br>
4 <br>
(circusctl) list webapp <br>
13712,13713,13714,13973</p>

<p style="margin-top: 1em">Congrats, you&rsquo;ve
interacted with your Circus! Get off the shell with Ctrl+D
and now run circus-top:</p>

<p style="margin-top: 1em">$ bin/circus-top</p>

<p style="margin-top: 1em">This is a top-like command to
watch all your processes&rsquo; memory and CPU usage in real
time.</p>

<p style="margin-top: 1em">Hit Ctrl+C and now let&rsquo;s
quit Circus completely via circus-ctl:</p>

<p style="margin-top: 1em">$ bin/circusctl quit <br>
ok</p>

<p style="margin-top: 1em">Next steps <br>
You can plug your own WSGI application instead of
Chaussette&rsquo;s hello world simply by pointing the
application callable.</p>

<p style="margin-top: 1em">Chaussette also comes with many
backends like Gevent or Meinheld.</p>

<p style="margin-top: 1em">Read
https://chaussette.readthedocs.org/ for all options.</p>

<p style="margin-top: 1em">Why should I use Circus instead
of X ? <br>
1. Circus simplifies your web stack process management</p>

<p style="margin-top: 1em">Circus knows how to manage
processes and sockets, so you don&rsquo;t have to delegate
web workers management to a WGSI server.</p>

<p style="margin-top: 1em">See whycircussockets</p>

<p style="margin-top: 1em">2. Circus provides pub/sub and
poll notifications via ZeroMQ <br>
Circus has a pub/sub channel you can subscribe to. This
channel receives all events happening in Circus. For
example, you can be notified when a process is flapping, or
build <br>
a client that triggers a warning when some processes are
eating all the CPU or RAM.</p>

<p style="margin-top: 1em">These events are sent via a
ZeroMQ channel, which makes it different from the stdin
stream Supervisord uses:</p>

<p style="margin-top: 1em">&Acirc;&middot; Circus sends
events in a fire-and-forget fashion, so there&rsquo;s no
need to manually loop through all listeners and maintain
their states.</p>

<p style="margin-top: 1em">&Acirc;&middot; Subscribers can
be located on a remote host.</p>

<p style="margin-top: 1em">Circus also provides ways to get
status updates via one-time polls on a req/rep channel. This
means you can get your information without having to
subscribe to a stream. The <br>
cli command provided by Circus uses this channel.</p>

<p style="margin-top: 1em">See examples.</p>

<p style="margin-top: 1em">3. Circus is (Python) developer
friendly <br>
While Circus can be driven entirely by a config file and the
circusctl / circusd commands, it is easy to reuse all or
part of the system to build your own custom process <br>
watcher in Python.</p>

<p style="margin-top: 1em">Every layer of the system is
isolated, so you can reuse independently:</p>

<p style="margin-top: 1em">&Acirc;&middot; the process
wrapper (Process)</p>

<p style="margin-top: 1em">&Acirc;&middot; the processes
manager (Watcher)</p>

<p style="margin-top: 1em">&Acirc;&middot; the global
manager that runs several processes managers (Arbiter)</p>

<p style="margin-top: 1em">&Acirc;&middot; and so
on&acirc;&brvbar;</p>

<p style="margin-top: 1em">4. Circus scales <br>
One of the use cases of Circus is to manage thousands of
processes without adding overhead -- we&rsquo;re dedicated
to focusing on this.</p>

<p style="margin-top: 1em">Coming from Supervisor <br>
Supervisor is a very popular solution in the Python world
and we&rsquo;re often asked how Circus compares with it.</p>

<p style="margin-top: 1em">If you are coming from
Supervisor, this page tries to give an overview of how the
tools differ.</p>

<p style="margin-top: 1em">Differences overview <br>
Supervisor &amp; Circus have the same goals - they both
manage processes and provide a command-line script &acirc;
respectively supervisord and circusd &acirc; that reads a
configuration file, <br>
forks new processes and keep them alive.</p>

<p style="margin-top: 1em">Circus has an extra feature: the
ability to bind sockets and let the processes it manages use
them. This &quot;pre-fork&quot; model is used by many web
servers out there, like Apache or <br>
Unicorn. Having this option in Circus can simplify a web app
stack: all processes and sockets are managed by a single
tool.</p>

<p style="margin-top: 1em">Both projects provide a way to
control a running daemon via another script. respectively
supervisorctl and circusctl. They also both have events and
a way to subscribe to them. <br>
The main difference is the underlying technology: Supervisor
uses XML-RPC for interacting with the daemon, while Circus
uses ZeroMQ.</p>

<p style="margin-top: 1em">Circus &amp; Supervisor both
have a web interface to display what&rsquo;s going on.
Circus&rsquo; is more advanced because you can follow in
real time what&rsquo;s going on and interact with the
dae&acirc; <br>
mon. It uses web sockets and is developed in a separate
project (circus-web.)</p>

<p style="margin-top: 1em">There are many other subtle
differences in the core design, we might list here one
day&acirc;&brvbar; In the meantime, you can learn more about
circus internals in design.</p>

<p style="margin-top: 1em">Configuration <br>
Both systems use an ini-like file as a configuration.</p>

<p style="margin-top: 1em">&Acirc;&middot; Supervisor
documentation</p>

<p style="margin-top: 1em">&Acirc;&middot; Circus
documentation</p>

<p style="margin-top: 1em">Here&rsquo;s a small example of
running an application with Supervisor. In this case, the
application will be started and restarted in case it
crashes</p>

<p style="margin-top: 1em">[program:example] <br>
command=npm start <br>
directory=/home/www/my-server/ <br>
user=www-data <br>
autostart=true <br>
autorestart=true <br>
redirect_stderr=True</p>

<p style="margin-top: 1em">In Circus, the same
configuration is done by:</p>

<p style="margin-top: 1em">[watcher:example] <br>
cmd=npm start <br>
working_dir=/home/www/my-server/ <br>
user=www-data <br>
stderr_stream.class=StdoutStream</p>

<p style="margin-top: 1em">Notice that the stderr
redirection is slightly different in Circus. The tool does
not have a tail feature like in Supervisor, but will let you
hook any piece of code to deal with <br>
the incoming stream. You can create your own stream hook (as
a Class) and do whatever you want with the incoming stream.
Circus provides some built-in stream classes like
Stdout&acirc; <br>
Stream, FileStream, WatchedFileStream, or
TimedRotatingFileStream.</p>

<p style="margin-top: 1em">Circus for Ops <br>
WARNING: <br>
By default, Circus doesn&rsquo;t secure its messages when
sending information through ZeroMQ. Before running Circus in
a production environment, make sure to read the Security
page.</p>

<p style="margin-top: 1em">The first step to manage a
Circus daemon is to write its configuration file. See
configuration. If you are deploying a web stack, have a look
at sockets.</p>

<p style="margin-top: 1em">Circus can be deployed using
Python 2.6, 2.7, 3.2 or 3.3 - most deployments out there are
done in 2.7. To learn how to deploy Circus, check out
deployment.</p>

<p style="margin-top: 1em">To manage a Circus daemon, you
should get familiar with the list of commands you can use in
circusctl. Notice that you can have the same help online
when you run circusctl as a <br>
shell.</p>

<p style="margin-top: 1em">We also provide circus-top, see
cli and a nice web dashboard. see circushttpd.</p>

<p style="margin-top: 1em">Last, to get the most out of
Circus, make sure to check out how to use plugins and hooks.
See plugins and hooks.</p>

<p style="margin-top: 1em">Ops documentation index <br>
Configuration <br>
Circus can be configured using an ini-style configuration
file.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[circus] <br>
check_delay = 5 <br>
endpoint = tcp://127.0.0.1:5555 <br>
pubsub_endpoint = tcp://127.0.0.1:5556 <br>
include = more.config.ini <br>
umask = 002</p>

<p style="margin-top: 1em">[watcher:myprogram] <br>
cmd = python <br>
args = -u myprogram.py $(circus.wid) $(CIRCUS.ENV.VAR) <br>
warmup_delay = 0 <br>
numprocesses = 5</p>

<p style="margin-top: 1em"># hook <br>
hooks.before_start = my.hooks.control_redis</p>

<p style="margin-top: 1em"># will push in test.log the
stream every 300 ms <br>
stdout_stream.class = FileStream <br>
stdout_stream.filename = test.log</p>

<p style="margin-top: 1em"># optionally rotate the log file
when it reaches 1 gb <br>
# and save 5 copied of rotated files <br>
stdout_stream.max_bytes = 1073741824 <br>
stdout_stream.backup_count = 5</p>

<p style="margin-top: 1em">[env:myprogram] <br>
PATH = $PATH:/bin <br>
CAKE = lie</p>

<p style="margin-top: 1em">[plugin:statsd] <br>
use = circus.plugins.statsd.StatsdEmitter <br>
host = localhost <br>
port = 8125 <br>
sample_rate = 1.0 <br>
application_name = example</p>

<p style="margin-top: 1em">[socket:web] <br>
host = localhost <br>
port = 8080</p>

<p style="margin-top: 1em">circus - single section <br>
endpoint <br>
The ZMQ socket used to manage Circus via circusctl.
(default: tcp://127.0.0.1:5555)</p>

<p style="margin-top: 1em">endpoint_owner <br>
If set to a system username and the endpoint is an ipc
socket like ipc://var/run/circusd.sock, then ownership of
the socket file will be changed to that user at <br>
startup. For more details, see security. (default: None)</p>

<p style="margin-top: 1em">pubsub_endpoint <br>
The ZMQ PUB/SUB socket receiving publications of events.
(default: tcp://127.0.0.1:5556)</p>

<p style="margin-top: 1em">papa_endpoint <br>
If using papa, you can specify the endpoint, such as
ipc://var/run/circusd.sock. (default:
tcp://127.0.0.1:20202)</p>

<p style="margin-top: 1em">statsd If set to True, Circus
runs the circusd-stats daemon. (default: False)</p>

<p style="margin-top: 1em">stats_endpoint <br>
The ZMQ PUB/SUB socket receiving publications of stats.
(default: tcp://127.0.0.1:5557)</p>

<p style="margin-top: 1em">statsd_close_outputs <br>
If True sends the circusd-stats stdout/stderr to /dev/null.
(default: False)</p>

<p style="margin-top: 1em">check_delay <br>
The polling interval in seconds for the ZMQ socket.
(default: 5)</p>

<p style="margin-top: 1em">include <br>
List of config files to include. You can use wildcards (*)
to include particular schemes for your files. The paths are
absolute or relative to the config file. <br>
(default: None)</p>

<p style="margin-top: 1em">include_dir <br>
List of config directories. All files matching *.ini under
each directory will be included. The paths are absolute or
relative to the config file. (default: None)</p>

<p style="margin-top: 1em">stream_backend <br>
Defines the type of backend to use for the streaming.
Possible values are thread or gevent. (default: thread)</p>

<p style="margin-top: 1em">warmup_delay <br>
The interval in seconds between two watchers start. Must be
an int. (default: 0)</p>

<p style="margin-top: 1em">httpd If set to True, Circus
runs the circushttpd daemon. (default: False)</p>

<p style="margin-top: 1em">httpd_host <br>
The host ran by the circushttpd daemon. (default:
localhost)</p>

<p style="margin-top: 1em">httpd_port <br>
The port ran by the circushttpd daemon. (default: 8080)</p>

<p style="margin-top: 1em">httpd_close_outputs <br>
If True, sends the circushttpd stdout/stderr to /dev/null.
(default: False)</p>

<p style="margin-top: 1em">debug If set to True, all Circus
stout/stderr daemons are redirected to circusd stdout/stderr
(default: False)</p>

<p style="margin-top: 1em">debug_gc <br>
If set to True, circusd outputs additional log info from the
garbage collector. This can be useful in tracking down
memory leaks. (default: False)</p>

<p style="margin-top: 1em">pidfile <br>
The file that must be used to keep the daemon pid.</p>

<p style="margin-top: 1em">umask Value for umask. If not
set, circusd will not attempt to modify umask.</p>

<p style="margin-top: 1em">loglevel <br>
The loglevel that we want to see (default: INFO)</p>

<p style="margin-top: 1em">logoutput <br>
The logoutput file where we want to log (default: - to log
on stdout). You can log to a remote syslog by using the
following syntax: syslog://host:port?facility where <br>
host is your syslog server, port is optional and facility is
the syslog facility to use. If you wish to log to a local
syslog you can use syslog:///path/to/sys&acirc; <br>
log/socket?facility instead.</p>

<p style="margin-top: 1em">loggerconfig <br>
A path to an INI, JSON or YAML file to configure standard
Python logging for the Arbiter. The special value
&quot;default&quot; uses the builtin logging configuration
based on <br>
the optional loglevel and logoutput options.</p>

<p style="margin-top: 1em">Example YAML Configuration
File</p>

<p style="margin-top: 1em">version: 1 <br>
disable_existing_loggers: false <br>
formatters: <br>
simple: <br>
format: &rsquo;%(asctime)s - %(name)s - [%(levelname)s]
%(message)s&rsquo; <br>
handlers: <br>
logfile: <br>
class: logging.FileHandler <br>
filename: logoutput.txt <br>
level: DEBUG <br>
formatter: simple <br>
loggers: <br>
circus: <br>
level: DEBUG <br>
handlers: [logfile] <br>
propagate: no <br>
root: <br>
level: DEBUG <br>
handlers: [logfile]</p>

<p style="margin-top: 1em">watcher:NAME - as many sections
as you want <br>
NAME The name of the watcher. This name is used in
circusctl</p>

<p style="margin-top: 1em">cmd The executable program to
run.</p>

<p style="margin-top: 1em">args Command-line arguments to
pass to the program. You can use the python format syntax
here to build the parameters. Environment variables are
available, as well as the <br>
worker id and the environment variables that you passed, if
any, with the &quot;env&quot; parameter. See Formatting the
commands and arguments with dynamic variables for more <br>
information on this.</p>

<p style="margin-top: 1em">shell If True, the processes are
run in the shell (default: False)</p>

<p style="margin-top: 1em">shell_args <br>
Command-line arguments to pass to the shell command when
shell is True. Works only for *nix system (default:
None)</p>

<p style="margin-top: 1em">working_dir <br>
The working dir for the processes (default: None)</p>

<p style="margin-top: 1em">uid The user id or name the
command should run with. (The current uid is the
default).</p>

<p style="margin-top: 1em">gid The group id or name the
command should run with. (The current gid is the
default).</p>

<p style="margin-top: 1em">copy_env <br>
If set to true, the local environment variables will be
copied and passed to the workers when spawning them.
(Default: False)</p>

<p style="margin-top: 1em">copy_path <br>
If set to true, sys.path is passed in the subprocess environ
using PYTHONPATH. copy_env has to be true. (Default:
False)</p>

<p style="margin-top: 1em">warmup_delay <br>
The delay (in seconds) between running processes.</p>

<p style="margin-top: 1em">autostart <br>
If set to false, the watcher will not be started
automatically when the arbiter starts. The watcher can be
started explicitly (example: circusctrl start myprogram).
<br>
(Default: True)</p>

<p style="margin-top: 1em">numprocesses <br>
The number of processes to run for this watcher.</p>

<p style="margin-top: 1em">rlimit_LIMIT <br>
Set resource limit LIMIT for the watched processes. The
config name should match the RLIMIT_* constants (not case
sensitive) listed in the Python resource module refer&acirc;
<br>
ence. For example, the config line &rsquo;rlimit_nofile =
500&rsquo; sets the maximum number of open files to 500. To
set a limit value to RLIM_INFINITY, do not set a value, like
<br>
this config line: &rsquo;rlimit_nofile = &rsquo;.</p>

<p style="margin-top: 1em">stderr_stream.class <br>
A fully qualified Python class name that will be
instanciated, and will receive the stderr stream of all
processes in its __call__() method.</p>

<p style="margin-top: 1em">Circus provides some stream
classes you can use without prefix:</p>

<p style="margin-top: 1em">&Acirc;&middot; FileStream:
writes in a file and can do automatic log rotation</p>

<p style="margin-top: 1em">&Acirc;&middot;
WatchedFileStream: writes in a file and relies on external
log rotation</p>

<p style="margin-top: 1em">&Acirc;&middot;
TimedRotatingFileStream: writes in a file and can do rotate
at certain timed intervals.</p>

<p style="margin-top: 1em">&Acirc;&middot; QueueStream:
write in a memory Queue</p>

<p style="margin-top: 1em">&Acirc;&middot; StdoutStream:
writes in the stdout</p>

<p style="margin-top: 1em">&Acirc;&middot;
FancyStdoutStream: writes colored output with time prefixes
in the stdout</p>

<p style="margin-top: 1em">stderr_stream.* <br>
All options starting with stderr_stream. other than class
will be passed the constructor when creating an instance of
the class defined in stderr_stream.class.</p>

<p style="margin-top: 1em">stdout_stream.class <br>
A fully qualified Python class name that will be
instanciated, and will receive the stdout stream of all
processes in its __call__() method.</p>

<p style="margin-top: 1em">Circus provides some stream
classes you can use without prefix:</p>

<p style="margin-top: 1em">&Acirc;&middot; FileStream:
writes in a file and can do automatic log rotation</p>

<p style="margin-top: 1em">&Acirc;&middot;
WatchedFileStream: writes in a file and relies on external
log rotation</p>

<p style="margin-top: 1em">&Acirc;&middot;
TimedRotatingFileStream: writes in a file and can do rotate
at certain timed intervals.</p>

<p style="margin-top: 1em">&Acirc;&middot; QueueStream:
write in a memory Queue</p>

<p style="margin-top: 1em">&Acirc;&middot; StdoutStream:
writes in the stdout</p>

<p style="margin-top: 1em">&Acirc;&middot;
FancyStdoutStream: writes colored output with time prefixes
in the stdout</p>

<p style="margin-top: 1em">stdout_stream.* <br>
All options starting with stdout_stream. other than class
will be passed the constructor when creating an instance of
the class defined in stdout_stream.class.</p>

<p style="margin-top: 1em">close_child_stdout <br>
If set to True, the stdout stream of each process will be
sent to /dev/null after the fork. Defaults to False.</p>

<p style="margin-top: 1em">close_child_stderr <br>
If set to True, the stderr stream of each process will be
sent to /dev/null after the fork. Defaults to False.</p>

<p style="margin-top: 1em">send_hup <br>
If True, a process reload will be done by sending the SIGHUP
signal. Defaults to False.</p>

<p style="margin-top: 1em">stop_signal <br>
The signal to send when stopping the process. Can be
specified as a number or a signal name. Signal names are
case-insensitive and can include &rsquo;SIG&rsquo; or not.
So valid <br>
examples include quit, INT, SIGTERM and 3. Defaults to
SIGTERM.</p>

<p style="margin-top: 1em">stop_children <br>
When sending the stop_signal, send it to the children as
well. Defaults to False.</p>

<p style="margin-top: 1em">max_retry <br>
The number of times we attempt to start a process, before we
abandon and stop the whole watcher. Defaults to 5. Set to -1
to disable max_retry and retry indefinitely.</p>

<p style="margin-top: 1em">graceful_timeout <br>
The number of seconds to wait for a process to terminate
gracefully before killing it.</p>

<p style="margin-top: 1em">When stopping a process, we
first send it a stop_signal. A worker may catch this signal
to perform clean up operations before exiting. If the worker
is still active <br>
after graceful_timeout seconds, we send it a SIGKILL signal.
It is not possible to catch SIGKILL signals so the worker
will stop.</p>

<p style="margin-top: 1em">Defaults to 30s.</p>

<p style="margin-top: 1em">priority <br>
Integer that defines a priority for the watcher. When the
Arbiter do some operations on all watchers, it will sort
them with this field, from the bigger number to the <br>
smallest. Defaults to 0.</p>

<p style="margin-top: 1em">singleton <br>
If set to True, this watcher will have at the most one
process. Defaults to False.</p>

<p style="margin-top: 1em">use_sockets <br>
If set to True, this watcher will be able to access defined
sockets via their file descriptors. If False, all parent fds
are closed when the child process is forked. <br>
Defaults to False.</p>

<p style="margin-top: 1em">max_age <br>
If set then the process will be restarted sometime after
max_age seconds. This is useful when processes deal with
pool of connectors: restarting processes improves the <br>
load balancing. Defaults to being disabled.</p>

<p style="margin-top: 1em">max_age_variance <br>
If max_age is set then the process will live between max_age
and max_age + random(0, max_age_variance) seconds. This
avoids restarting all processes for a watcher at <br>
once. Defaults to 30 seconds.</p>

<p style="margin-top: 1em">on_demand <br>
If set to True, the processes will be started only after the
first connection to one of the configured sockets (see
below). If a restart is needed, it will be only <br>
triggered at the next socket event.</p>

<p style="margin-top: 1em">hooks.* <br>
Available hooks: before_start, after_start, before_spawn,
after_spawn, before_stop, after_stop, before_signal,
after_signal, extended_stats</p>

<p style="margin-top: 1em">Define callback functions that
hook into the watcher startup/shutdown process.</p>

<p style="margin-top: 1em">If the hook returns False and if
the hook is one of before_start, before_spawn, after_start
or after_spawn, the startup will be aborted.</p>

<p style="margin-top: 1em">If the hook is before_signal and
returns False, then the corresponding signal will not be
sent (except SIGKILL which is always sent)</p>

<p style="margin-top: 1em">Notice that a hook that fails
during the stopping process will not abort it.</p>

<p style="margin-top: 1em">The callback definition can be
followed by a boolean flag separated by a comma. When the
flag is set to true, any error occuring in the hook will be
ignored. If set to <br>
false (the default), the hook will return False.</p>

<p style="margin-top: 1em">More on hooks.</p>

<p style="margin-top: 1em">virtualenv <br>
When provided, points to the root of a Virtualenv directory.
The watcher will scan the local site-packages and loads its
content into the execution environment. Must be <br>
used with copy_env set to True. Defaults to None.</p>

<p style="margin-top: 1em">virtualenv_py_ver <br>
Specifies the python version of the virtualenv (e.g
&quot;3.3&quot;). It&rsquo;s usefull if circus run with
another python version (e.g &quot;2.7&quot;) The watcher
will scan the local <br>
site-packages of the specified python version and load its
content into the execution environment. Must be used with
virtualenv. Defaults to None.</p>

<p style="margin-top: 1em">respawn <br>
If set to False, the processes handled by a watcher will not
be respawned automatically. The processes can be manually
respawned with the start command. (default: True)</p>

<p style="margin-top: 1em">use_papa <br>
Set to true to use the papa.</p>

<p style="margin-top: 1em">socket:NAME - as many sections
as you want <br>
host The host of the socket. Defaults to
&rsquo;localhost&rsquo;</p>

<p style="margin-top: 1em">port The port. Defaults to
8080.</p>

<p style="margin-top: 1em">family The socket family. Can be
&rsquo;AF_UNIX&rsquo;, &rsquo;AF_INET&rsquo; or
&rsquo;AF_INET6&rsquo;. Defaults to
&rsquo;AF_INET&rsquo;.</p>

<p style="margin-top: 1em">type The socket type. Can be
&rsquo;SOCK_STREAM&rsquo;, &rsquo;SOCK_DGRAM&rsquo;,
&rsquo;SOCK_RAW&rsquo;, &rsquo;SOCK_RDM&rsquo; or
&rsquo;SOCK_SEQPACKET&rsquo;. Defaults to
&rsquo;SOCK_STREAM&rsquo;.</p>

<p style="margin-top: 1em">interface <br>
When provided a network interface name like
&rsquo;eth0&rsquo;, binds the socket to that particular
device so that only packets received from that particular
interface are pro&acirc; <br>
cessed by the socket. This can be used for example to limit
which device to bind when binding on IN_ADDR_ANY (0.0.0.0)
or IN_ADDR_BROADCAST (255.255.255.255). Note <br>
that this only works for some socket types, particularly
AF_INET sockets.</p>

<p style="margin-top: 1em">path When provided a path to a
file that will be used as a unix socket file. If a path is
provided, family is forced to AF_UNIX and host and port are
ignored.</p>

<p style="margin-top: 1em">umask When provided, sets the
umask that will be used to create an AF_UNIX socket. For
example, umask=000 will produce a socket with permission
777.</p>

<p style="margin-top: 1em">replace <br>
When creating Unix sockets (&rsquo;AF_UNIX&rsquo;), an
existing file may indicate a problem so the default is to
fail. Specify True to simply remove the old file if you are
sure <br>
that the socket is managed only by Circus.</p>

<p style="margin-top: 1em">so_reuseport <br>
If set to True and SO_REUSEPORT is available on target
platform, circus will create and bind new SO_REUSEPORT
socket(s) for every worker it starts which is a user of <br>
this socket(s).</p>

<p style="margin-top: 1em">use_papa <br>
Set to true to use the papa.</p>

<p style="margin-top: 1em">Once a socket is created, the
${circus.sockets.NAME} string can be used in the command
(cmd or args) of a watcher. Circus will replace it by the FD
value. The watcher must also <br>
have use_sockets set to True otherwise the socket will have
been closed and you will get errors when the watcher tries
to use it.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[watcher:webworker] <br>
cmd = chaussette --fd $(circus.sockets.webapp)
chaussette.util.bench_app <br>
use_sockets = True</p>

<p style="margin-top: 1em">[socket:webapp] <br>
host = 127.0.0.1 <br>
port = 8888</p>

<p style="margin-top: 1em">plugin:NAME - as many sections
as you want <br>
use The fully qualified name that points to the plugin
class.</p>

<p style="margin-top: 1em">anything else <br>
Every other key found in the section is passed to the plugin
constructor in the config mapping.</p>

<p style="margin-top: 1em">You can use all the watcher
options, since a plugin is started like a watcher.</p>

<p style="margin-top: 1em">Circus comes with a few
pre-shipped plugins but you can also extend them easily by
developing your own.</p>

<p style="margin-top: 1em">env or env[:WATCHERS] - as many
sections as you want <br>
anything <br>
The name of an environment variable to assign value to. bash
style environment substitutions are supported. for example,
append /bin to PATH &rsquo;PATH = $PATH:/bin&rsquo;</p>

<p style="margin-top: 1em">Section responsible for
delivering environment variable to run processes.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[watcher:worker1] <br>
cmd = ping 127.0.0.1</p>

<p style="margin-top: 1em">[watcher:worker2] <br>
cmd = ping 127.0.0.1</p>

<p style="margin-top: 1em">[env] <br>
CAKE = lie</p>

<p style="margin-top: 1em">The variable CAKE will
propagated to all watchers defined in config file.</p>

<p style="margin-top: 1em">WATCHERS can be a comma
separated list of watcher sections to apply this environment
to. if multiple env sections match a watcher, they will be
combine in the order they appear <br>
in the configuration file. later entries will take
precedence.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[watcher:worker1] <br>
cmd = ping 127.0.0.1</p>

<p style="margin-top: 1em">[watcher:worker2] <br>
cmd = ping 127.0.0.1</p>

<p style="margin-top: 1em">[env:worker1,worker2] <br>
PATH = /bin</p>

<p style="margin-top: 1em">[env:worker1] <br>
PATH = $PATH</p>

<p style="margin-top: 1em">[env:worker2] <br>
CAKE = lie</p>

<p style="margin-top: 1em">worker1 will be run with PATH =
$PATH (expanded from the environment circusd was run in)
worker2 will be run with PATH = /bin and CAKE = lie</p>

<p style="margin-top: 1em">It&rsquo;s possible to use
wildcards as well.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[watcher:worker1] <br>
cmd = ping 127.0.0.1</p>

<p style="margin-top: 1em">[watcher:worker2] <br>
cmd = ping 127.0.0.1</p>

<p style="margin-top: 1em">[env:worker*] <br>
PATH = /bin</p>

<p style="margin-top: 1em">Both worker1 and worker2 will be
run with PATH = /bin</p>

<p style="margin-top: 1em">Using environment variables <br>
When writing your configuration file, you can use
environment variables defined in the env section or in
os.environ itself.</p>

<p style="margin-top: 1em">You just have to use the
circus.env. prefix.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[watcher:worker1] <br>
cmd = $(circus.env.shell)</p>

<p style="margin-top: 1em">[watcher:worker2] <br>
baz = $(circus.env.user) <br>
bar = $(circus.env.yeah) <br>
sup = $(circus.env.oh)</p>

<p style="margin-top: 1em">[socket:socket1] <br>
port = $(circus.env.port)</p>

<p style="margin-top: 1em">[plugin:plugin1] <br>
use = some.path <br>
parameter1 = $(circus.env.plugin_param)</p>

<p style="margin-top: 1em">[env] <br>
yeah = boo</p>

<p style="margin-top: 1em">[env:worker2] <br>
oh = ok</p>

<p style="margin-top: 1em">If a variable is defined in
several places, the most specialized value has precedence: a
variable defined in env:XXX will override a variable defined
in env, which will override <br>
a variable defined in os.environ.</p>

<p style="margin-top: 1em">environment substitutions can be
used in any section of the configuration in any section
variable.</p>

<p style="margin-top: 1em">Formatting the commands and
arguments with dynamic variables <br>
As you may have seen, it is possible to pass some
information that are computed dynamically when running the
processes. Among other things, you can get the worker id
(WID) and <br>
all the options that are passed to the Process.
Additionally, it is possible to access the options passed to
the Watcher which instanciated the process.</p>

<p style="margin-top: 1em">NOTE: <br>
The worker id is different from the process id. It&rsquo;s a
unique value, starting at 1, which is only unique for the
watcher.</p>

<p style="margin-top: 1em">For instance, if you want to
access some variables that are contained in the environment,
you would need to do it with a setting like this:</p>

<p style="margin-top: 1em">cmd = &quot;make-me-a-coffee
--sugar $(CIRCUS.ENV.SUGAR_AMOUNT)&quot;</p>

<p style="margin-top: 1em">This works with both cmd and
args.</p>

<p style="margin-top: 1em">Important:</p>

<p style="margin-top: 1em">&Acirc;&middot; All variables
are prefixed with circus.</p>

<p style="margin-top: 1em">&Acirc;&middot; The replacement
is case insensitive.</p>

<p style="margin-top: 1em">Stream configuration <br>
Simple stream class like QueueStream and StdoutStream
don&rsquo;t have specific attributes but some other stream
class may have some:</p>

<p style="margin-top: 1em">FileStream <br>
filename <br>
The file path where log will be written.</p>

<p style="margin-top: 1em">time_format <br>
The strftime format that will be used to prefix each time
with a timestamp. By default they will be not prefixed.</p>

<p style="margin-top: 1em">i.e: %Y-%m-%d %H:%M:%S</p>

<p style="margin-top: 1em">max_bytes <br>
The max size of the log file before a new file is started.
If not provided, the file is not rolled over.</p>

<p style="margin-top: 1em">backup_count <br>
The number of log files that will be kept By default
backup_count is null.</p>

<p style="margin-top: 1em">NOTE: <br>
Rollover occurs whenever the current log file is nearly
max_bytes in length. If backup_count is &gt;= 1, the system
will successively create new files with the same pathname as
<br>
the base file, but with extensions &quot;.1&quot;,
&quot;.2&quot; etc. appended to it. For example, with a
backup_count of 5 and a base file name of
&quot;app.log&quot;, you would get &quot;app.log&quot;, <br>
&quot;app.log.1&quot;, &quot;app.log.2&quot;, ... through to
&quot;app.log.5&quot;. The file being written to is always
&quot;app.log&quot; - when it gets filled up, it is closed
and renamed to &quot;app.log.1&quot;, and if <br>
files &quot;app.log.1&quot;, &quot;app.log.2&quot; etc.
exist, then they are renamed to &quot;app.log.2&quot;,
&quot;app.log.3&quot; etc. respectively.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[watcher:myprogram] <br>
cmd = python -m myapp.server</p>

<p style="margin-top: 1em">stdout_stream.class = FileStream
<br>
stdout_stream.filename = test.log <br>
stdout_stream.time_format = %Y-%m-%d %H:%M:%S <br>
stdout_stream.max_bytes = 1073741824 <br>
stdout_stream.backup_count = 5</p>

<p style="margin-top: 1em">WatchedFileStream <br>
filename <br>
The file path where log will be written.</p>

<p style="margin-top: 1em">time_format <br>
The strftime format that will be used to prefix each time
with a timestamp. By default they will be not prefixed.</p>

<p style="margin-top: 1em">i.e: %Y-%m-%d %H:%M:%S</p>

<p style="margin-top: 1em">NOTE: <br>
WatchedFileStream relies on an external log rotation tool to
ensure that log files don&rsquo;t become too big. The output
file will be monitored and if it is ever deleted or moved
<br>
by the external log rotation tool, then the output file
handle will be automatically reloaded.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[watcher:myprogram] <br>
cmd = python -m myapp.server</p>

<p style="margin-top: 1em">stdout_stream.class =
WatchedFileStream <br>
stdout_stream.filename = test.log <br>
stdout_stream.time_format = %Y-%m-%d %H:%M:%S</p>

<p style="margin-top: 1em">TimedRotatingFileStream <br>
filename <br>
The file path where log will be written.</p>

<p style="margin-top: 1em">backup_count <br>
The number of log files that will be kept By default
backup_count is null.</p>

<p style="margin-top: 1em">time_format <br>
The strftime format that will be used to prefix each time
with a timestamp. By default they will be not prefixed.</p>

<p style="margin-top: 1em">i.e: %Y-%m-%d %H:%M:%S</p>

<p style="margin-top: 1em">rotate_when <br>
The type of interval. The list of possible values is below.
Note that they are not case sensitive.</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;Value &acirc; Type of interval &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;&rsquo;S&rsquo; &acirc; Seconds &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;&rsquo;M&rsquo; &acirc; Minutes &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;&rsquo;H&rsquo; &acirc; Hours &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;&rsquo;D&rsquo; &acirc; Days &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;&rsquo;W0&rsquo;-&rsquo;W6&rsquo; &acirc; Weekday
(0=Monday) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;&rsquo;midnight&rsquo; &acirc; Roll over at midnight
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">rotate_interval <br>
The rollover interval.</p>

<p style="margin-top: 1em">NOTE: <br>
TimedRotatingFileStream rotates logfiles at certain timed
intervals. Rollover interval is determined by a combination
of rotate_when and rotate_interval.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[watcher:myprogram] <br>
cmd = python -m myapp.server</p>

<p style="margin-top: 1em">stdout_stream.class =
TimedRotatingFileStream <br>
stdout_stream.filename = test.log <br>
stdout_stream.time_format = %Y-%m-%d %H:%M:%S <br>
stdout_stream.utc = True <br>
stdout_stream.rotate_when = H <br>
stdout_stream.rotate_interval = 1</p>

<p style="margin-top: 1em">FancyStdoutStream <br>
color</p>

<p style="margin-top: 1em">The name of an ascii color:</p>

<p style="margin-top: 1em">&Acirc;&middot; red</p>

<p style="margin-top: 1em">&Acirc;&middot; green</p>

<p style="margin-top: 1em">&Acirc;&middot; yellow</p>

<p style="margin-top: 1em">&Acirc;&middot; blue</p>

<p style="margin-top: 1em">&Acirc;&middot; magenta</p>

<p style="margin-top: 1em">&Acirc;&middot; cyan</p>

<p style="margin-top: 1em">&Acirc;&middot; white</p>

<p style="margin-top: 1em">time_format <br>
The strftime format that each line will be prefixed
with.</p>

<p style="margin-top: 1em">Default to: %Y-%m-%d
%H:%M:%S</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[watcher:myprogram] <br>
cmd = python -m myapp.server <br>
stdout_stream.class = FancyStdoutStream <br>
stdout_stream.color = green <br>
stdout_stream.time_format = %Y/%m/%d | %H:%M:%S</p>

<p style="margin-top: 1em">Commands <br>
At the epicenter of circus lives the command systems.
circusctl is just a zeromq client, and if needed you can
drive programmaticaly the Circus system by writing your own
zmq <br>
client.</p>

<p style="margin-top: 1em">All messages are JSON
mappings.</p>

<p style="margin-top: 1em">For each command below, we
provide a usage example with circusctl but also the input /
output zmq messages.</p>

<p style="margin-top: 1em">circus-ctl commands <br>
&Acirc;&middot; add: commands/add</p>

<p style="margin-top: 1em">&Acirc;&middot; decr:
commands/decr</p>

<p style="margin-top: 1em">&Acirc;&middot; dstats:
commands/dstats</p>

<p style="margin-top: 1em">&Acirc;&middot; get:
commands/get</p>

<p style="margin-top: 1em">&Acirc;&middot; globaloptions:
commands/globaloptions</p>

<p style="margin-top: 1em">&Acirc;&middot; incr:
commands/incr</p>

<p style="margin-top: 1em">&Acirc;&middot; ipython:
commands/ipython</p>

<p style="margin-top: 1em">&Acirc;&middot; list:
commands/list</p>

<p style="margin-top: 1em">&Acirc;&middot; listen:
commands/listen</p>

<p style="margin-top: 1em">&Acirc;&middot; listsockets:
commands/listsockets</p>

<p style="margin-top: 1em">&Acirc;&middot; numprocesses:
commands/numprocesses</p>

<p style="margin-top: 1em">&Acirc;&middot; numwatchers:
commands/numwatchers</p>

<p style="margin-top: 1em">&Acirc;&middot; options:
commands/options</p>

<p style="margin-top: 1em">&Acirc;&middot; quit:
commands/quit</p>

<p style="margin-top: 1em">&Acirc;&middot; reload:
commands/reload</p>

<p style="margin-top: 1em">&Acirc;&middot; reloadconfig:
commands/reloadconfig</p>

<p style="margin-top: 1em">&Acirc;&middot; restart:
commands/restart</p>

<p style="margin-top: 1em">&Acirc;&middot; rm:
commands/rm</p>

<p style="margin-top: 1em">&Acirc;&middot; set:
commands/set</p>

<p style="margin-top: 1em">&Acirc;&middot; signal:
commands/signal</p>

<p style="margin-top: 1em">&Acirc;&middot; start:
commands/start</p>

<p style="margin-top: 1em">&Acirc;&middot; stats:
commands/stats</p>

<p style="margin-top: 1em">&Acirc;&middot; status:
commands/status</p>

<p style="margin-top: 1em">&Acirc;&middot; stop:
commands/stop</p>

<p style="margin-top: 1em">Add a watcher <br>
This command add a watcher dynamically to a arbiter.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;add&quot;, <br>
&quot;properties&quot;: { <br>
&quot;cmd&quot;: &quot;/path/to/commandline --option&quot;
<br>
&quot;name&quot;: &quot;nameofwatcher&quot; <br>
&quot;args&quot;: [], <br>
&quot;options&quot;: {}, <br>
&quot;start&quot;: false <br>
} <br>
}</p>

<p style="margin-top: 1em">A message contains 2
properties:</p>

<p style="margin-top: 1em">&Acirc;&middot; cmd: Full
command line to execute in a process</p>

<p style="margin-top: 1em">&Acirc;&middot; args: array,
arguments passed to the command (optional)</p>

<p style="margin-top: 1em">&Acirc;&middot; name: name of
watcher</p>

<p style="margin-top: 1em">&Acirc;&middot; options: options
of a watcher</p>

<p style="margin-top: 1em">&Acirc;&middot; start: start the
watcher after the creation</p>

<p style="margin-top: 1em">The response return a status
&quot;ok&quot;.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl add [--start] &lt;name&gt; &lt;cmd&gt;</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name of the watcher to
create</p>

<p style="margin-top: 1em">&Acirc;&middot; &lt;cmd&gt;:
full command line to execute in a process</p>

<p style="margin-top: 1em">&Acirc;&middot; --start: start
the watcher immediately</p>

<p style="margin-top: 1em">Decrement the number of
processes in a watcher <br>
This comment decrement the number of processes in a watcher
by &lt;nbprocess&gt;, 1 being the default.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;decr&quot;, <br>
&quot;propeties&quot;: { <br>
&quot;name&quot;: &quot;&lt;watchername&gt;&quot; <br>
&quot;nb&quot;: &lt;nbprocess&gt; <br>
&quot;waiting&quot;: False <br>
} <br>
}</p>

<p style="margin-top: 1em">The response return the number
of processes in the &rsquo;numprocesses&lsquo; property:</p>

<p style="margin-top: 1em">{ &quot;status&quot;:
&quot;ok&quot;, &quot;numprocesses&quot;: &lt;n&gt;,
&quot;time&quot;, &quot;timestamp&quot; }</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl decr &lt;name&gt; [&lt;nb&gt;] [--waiting]</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name of the watcher</p>

<p style="margin-top: 1em">&Acirc;&middot; &lt;nb&gt;: the
number of processes to remove.</p>

<p style="margin-top: 1em">Get circusd stats <br>
You can get at any time some statistics about circusd with
the dstat command.</p>

<p style="margin-top: 1em">ZMQ Message <br>
To get the circusd stats, simply run:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;dstats&quot; <br>
}</p>

<p style="margin-top: 1em">The response returns a mapping
the property &quot;infos&quot; containing some process
informations:</p>

<p style="margin-top: 1em">{ <br>
&quot;info&quot;: { <br>
&quot;children&quot;: [], <br>
&quot;cmdline&quot;: &quot;python&quot;, <br>
&quot;cpu&quot;: 0.1, <br>
&quot;ctime&quot;: &quot;0:00.41&quot;, <br>
&quot;mem&quot;: 0.1, <br>
&quot;mem_info1&quot;: &quot;3M&quot;, <br>
&quot;mem_info2&quot;: &quot;2G&quot;, <br>
&quot;nice&quot;: 0, <br>
&quot;pid&quot;: 47864, <br>
&quot;username&quot;: &quot;root&quot; <br>
}, <br>
&quot;status&quot;: &quot;ok&quot;, <br>
&quot;time&quot;: 1332265655.897085 <br>
}</p>

<p style="margin-top: 1em">Command Line <br>
$ circusctl dstats</p>

<p style="margin-top: 1em">Get the value of specific
watcher options <br>
This command can be used to query the current value of one
or more watcher options.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;get&quot;, <br>
&quot;properties&quot;: { <br>
&quot;keys&quot;: [&quot;key1, &quot;key2&quot;] <br>
&quot;name&quot;: &quot;nameofwatcher&quot; <br>
} <br>
}</p>

<p style="margin-top: 1em">A request message contains two
properties:</p>

<p style="margin-top: 1em">&Acirc;&middot; keys: list, The
option keys for which you want to get the values</p>

<p style="margin-top: 1em">&Acirc;&middot; name: name of
watcher</p>

<p style="margin-top: 1em">The response object has a
property options which is a dictionary of option names and
values.</p>

<p style="margin-top: 1em">eg:</p>

<p style="margin-top: 1em">{ <br>
&quot;status&quot;: &quot;ok&quot;, <br>
&quot;options&quot;: { <br>
&quot;graceful_timeout&quot;: 300, <br>
&quot;send_hup&quot;: True, <br>
}, <br>
time&rsquo;: 1332202594.754644 <br>
}</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl get &lt;name&gt; &lt;key1&gt; &lt;key2&gt;</p>

<p style="margin-top: 1em">Get the arbiter options <br>
This command return the arbiter options</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;globaloptions&quot;, <br>
&quot;properties&quot;: { <br>
&quot;key1&quot;: &quot;val1&quot;, <br>
.. <br>
} <br>
}</p>

<p style="margin-top: 1em">A message contains 2
properties:</p>

<p style="margin-top: 1em">&Acirc;&middot; keys: list, The
option keys for which you want to get the values</p>

<p style="margin-top: 1em">The response return an object
with a property &quot;options&quot; containing the list of
key/value returned by circus.</p>

<p style="margin-top: 1em">eg:</p>

<p style="margin-top: 1em">{ <br>
&quot;status&quot;: &quot;ok&quot;, <br>
&quot;options&quot;: { <br>
&quot;check_delay&quot;: 1, <br>
... <br>
}, <br>
time&rsquo;: 1332202594.754644 <br>
}</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl globaloptions</p>

<p style="margin-top: 1em">Options <br>
Options Keys are:</p>

<p style="margin-top: 1em">&Acirc;&middot; endpoint: the
controller ZMQ endpoint</p>

<p style="margin-top: 1em">&Acirc;&middot; pubsub_endpoint:
the pubsub endpoint</p>

<p style="margin-top: 1em">&Acirc;&middot; check_delay: the
delay between two controller points</p>

<p style="margin-top: 1em">&Acirc;&middot;
multicast_endpoint: the multicast endpoint for circusd
cluster auto-discovery</p>

<p style="margin-top: 1em">Increment the number of
processes in a watcher <br>
This comment increment the number of processes in a watcher
by &lt;nbprocess&gt;, 1 being the default</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;incr&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &quot;&lt;watchername&gt;&quot;, <br>
&quot;nb&quot;: &lt;nbprocess&gt;, <br>
&quot;waiting&quot;: False <br>
} <br>
}</p>

<p style="margin-top: 1em">The response return the number
of processes in the &rsquo;numprocesses&lsquo; property:</p>

<p style="margin-top: 1em">{ &quot;status&quot;:
&quot;ok&quot;, &quot;numprocesses&quot;: &lt;n&gt;,
&quot;time&quot;, &quot;timestamp&quot; }</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl incr &lt;name&gt; [&lt;nb&gt;] [--waiting]</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name of the watcher.</p>

<p style="margin-top: 1em">&Acirc;&middot; &lt;nb&gt;: the
number of processes to add.</p>

<p style="margin-top: 1em">Create shell into circusd
process <br>
This command is only useful if you have the ipython package
installed.</p>

<p style="margin-top: 1em">Command Line <br>
$ circusctl ipython</p>

<p style="margin-top: 1em">Get list of watchers or
processes in a watcher <br>
ZMQ Message <br>
To get the list of all the watchers:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;list&quot;, <br>
}</p>

<p style="margin-top: 1em">To get the list of active
processes in a watcher:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;list&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &quot;nameofwatcher&quot;, <br>
} <br>
}</p>

<p style="margin-top: 1em">The response return the list
asked. the mapping returned can either be
&rsquo;watchers&rsquo; or &rsquo;pids&rsquo; depending the
request.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl list [&lt;name&gt;]</p>

<p style="margin-top: 1em">Subscribe to a watcher event
<br>
ZMQ <br>
At any moment you can subscribe to a circus event. Circus
provides a PUB/SUB feed on which any clients can subscribe.
The subscriber endpoint URI is set in the circus.ini
config&acirc; <br>
uration file.</p>

<p style="margin-top: 1em">Events are pubsub topics:</p>

<p style="margin-top: 1em">&Acirc;&middot;
watcher.&lt;watchername&gt;.reap: when a process is
reaped</p>

<p style="margin-top: 1em">&Acirc;&middot;
watcher.&lt;watchername&gt;.spawn: when a process is
spawned</p>

<p style="margin-top: 1em">&Acirc;&middot;
watcher.&lt;watchername&gt;.kill: when a process is
killed</p>

<p style="margin-top: 1em">&Acirc;&middot;
watcher.&lt;watchername&gt;.updated: when watcher
configuration is updated</p>

<p style="margin-top: 1em">&Acirc;&middot;
watcher.&lt;watchername&gt;.stop: when a watcher is
stopped</p>

<p style="margin-top: 1em">&Acirc;&middot;
watcher.&lt;watchername&gt;.start: when a watcher is
started</p>

<p style="margin-top: 1em">All events messages are in a
json struct.</p>

<p style="margin-top: 1em">Command line <br>
The client has been updated to provide a simple way to
listen on the events:</p>

<p style="margin-top: 1em">circusctl listen [&lt;topic&gt;,
...]</p>

<p style="margin-top: 1em">Example of result: <br>
$ circusctl listen tcp://127.0.0.1:5556 <br>
watcher.refuge.spawn: {u&rsquo;process_id&rsquo;: 6,
u&rsquo;process_pid&rsquo;: 72976, <br>
u&rsquo;time&rsquo;: 1331681080.985104} <br>
watcher.refuge.spawn: {u&rsquo;process_id&rsquo;: 7,
u&rsquo;process_pid&rsquo;: 72995, <br>
u&rsquo;time&rsquo;: 1331681086.208542} <br>
watcher.refuge.spawn: {u&rsquo;process_id&rsquo;: 8,
u&rsquo;process_pid&rsquo;: 73014, <br>
u&rsquo;time&rsquo;: 1331681091.427005}</p>

<p style="margin-top: 1em">Get the list of sockets <br>
ZMQ Message <br>
To get the list of sockets:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;listsockets&quot;, <br>
}</p>

<p style="margin-top: 1em">The response return a list of
json mappings with keys for fd, name, host and port.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl listsockets</p>

<p style="margin-top: 1em">Get the number of processes <br>
Get the number of processes in a watcher or in a arbiter</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;numprocesses&quot;, <br>
&quot;propeties&quot;: { <br>
&quot;name&quot;: &quot;&lt;watchername&gt;&quot; <br>
}</p>

<p style="margin-top: 1em">}</p>

<p style="margin-top: 1em">The response return the number
of processes in the &rsquo;numprocesses&lsquo; property:</p>

<p style="margin-top: 1em">{ &quot;status&quot;:
&quot;ok&quot;, &quot;numprocesses&quot;: &lt;n&gt;,
&quot;time&quot;, &quot;timestamp&quot; }</p>

<p style="margin-top: 1em">If the property name isn&rsquo;t
specified, the sum of all processes managed is returned.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl numprocesses [&lt;name&gt;]</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name of the watcher</p>

<p style="margin-top: 1em">Get the number of watchers <br>
Get the number of watchers in a arbiter</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;numwatchers&quot;, <br>
}</p>

<p style="margin-top: 1em">The response return the number
of watchers in the &rsquo;numwatchers&lsquo; property:</p>

<p style="margin-top: 1em">{ &quot;status&quot;:
&quot;ok&quot;, &quot;numwatchers&quot;: &lt;n&gt;,
&quot;time&quot;, &quot;timestamp&quot; }</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl numwatchers</p>

<p style="margin-top: 1em">Get the value of all options for
a watcher <br>
This command returns all option values for a given
watcher.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;options&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &quot;nameofwatcher&quot;, <br>
} <br>
}</p>

<p style="margin-top: 1em">A message contains 1
property:</p>

<p style="margin-top: 1em">&Acirc;&middot; name: name of
watcher</p>

<p style="margin-top: 1em">The response object has a
property options which is a dictionary of option names and
values.</p>

<p style="margin-top: 1em">eg:</p>

<p style="margin-top: 1em">{ <br>
&quot;status&quot;: &quot;ok&quot;, <br>
&quot;options&quot;: { <br>
&quot;graceful_timeout&quot;: 300, <br>
&quot;send_hup&quot;: True, <br>
... <br>
}, <br>
time&rsquo;: 1332202594.754644 <br>
}</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl options &lt;name&gt;</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name of the watcher</p>

<p style="margin-top: 1em">Options Keys are:</p>

<p style="margin-top: 1em">&Acirc;&middot; numprocesses:
integer, number of processes</p>

<p style="margin-top: 1em">&Acirc;&middot; warmup_delay:
integer or number, delay to wait between process spawning in
seconds</p>

<p style="margin-top: 1em">&Acirc;&middot; working_dir:
string, directory where the process will be executed</p>

<p style="margin-top: 1em">&Acirc;&middot; uid: string or
integer, user ID used to launch the process</p>

<p style="margin-top: 1em">&Acirc;&middot; gid: string or
integer, group ID used to launch the process</p>

<p style="margin-top: 1em">&Acirc;&middot; send_hup:
boolean, if TRU the signal HUP will be used on reload</p>

<p style="margin-top: 1em">&Acirc;&middot; shell: boolean,
will run the command in the shell environment if true</p>

<p style="margin-top: 1em">&Acirc;&middot; cmd: string, The
command line used to launch the process</p>

<p style="margin-top: 1em">&Acirc;&middot; env: object,
define the environnement in which the process will be
launch</p>

<p style="margin-top: 1em">&Acirc;&middot; retry_in:
integer or number, time in seconds we wait before we retry
to launch the process if the maximum number of attempts has
been reach.</p>

<p style="margin-top: 1em">&Acirc;&middot; max_retry:
integer, The maximum of retries loops</p>

<p style="margin-top: 1em">&Acirc;&middot;
graceful_timeout: integer or number, time we wait before we
definitely kill a process.</p>

<p style="margin-top: 1em">&Acirc;&middot; priority: used
to sort watchers in the arbiter</p>

<p style="margin-top: 1em">&Acirc;&middot; singleton: if
True, a singleton watcher.</p>

<p style="margin-top: 1em">&Acirc;&middot; max_age: time a
process can live before being restarted</p>

<p style="margin-top: 1em">&Acirc;&middot;
max_age_variance: variable additional time to live, avoids
stampeding herd.</p>

<p style="margin-top: 1em">Quit the arbiter immediately
<br>
When the arbiter receive this command, the arbiter exit.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;quit&quot;, <br>
&quot;waiting&quot;: False <br>
}</p>

<p style="margin-top: 1em">The response return the status
&quot;ok&quot;.</p>

<p style="margin-top: 1em">If waiting is False (default),
the call will return immediately after calling stop_signal
on each process.</p>

<p style="margin-top: 1em">If waiting is True, the call
will return only when the stop process is completely ended.
Because of the graceful_timeout option, it can take some
time.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl quit [--waiting]</p>

<p style="margin-top: 1em">Reload the arbiter or a watcher
<br>
This command reloads all the process in a watcher or all
watchers. This will happen in one of 3 ways:</p>

<p style="margin-top: 1em">&Acirc;&middot; If graceful is
false, a simple restart occurs.</p>

<p style="margin-top: 1em">&Acirc;&middot; If send_hup is
true for the watcher, a HUP signal is sent to each
process.</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">Otherwise:</p>

<p style="margin-top: 1em">&Acirc;&middot; If sequential is
false, the arbiter will attempt to spawn numprocesses new
processes. If the new processes are spawned successfully,
the result is that all of the old <br>
processes are stopped, since by default the oldest processes
are stopped when the actual number of processes for a
watcher is greater than numprocesses.</p>

<p style="margin-top: 1em">&Acirc;&middot; If sequential is
true, the arbiter will restart each process in a sequential
way (with a warmup_delay pause between each step)</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;reload&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &rsquo;&lt;name&gt;&quot;, <br>
&quot;graceful&quot;: true, <br>
&quot;sequential&quot;: false, <br>
&quot;waiting&quot;: False <br>
} <br>
}</p>

<p style="margin-top: 1em">The response return the status
&quot;ok&quot;. If the property graceful is set to true the
processes will be exited gracefully.</p>

<p style="margin-top: 1em">If the property name is present,
then the reload will be applied to the watcher.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl reload [&lt;name&gt;] [--terminate] [--waiting]
<br>
[--sequential]</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name of the watcher</p>

<p style="margin-top: 1em">&Acirc;&middot; --terminate;
quit the node immediately</p>

<p style="margin-top: 1em">Reload the configuration file
<br>
This command reloads the configuration file, so changes in
the configuration file will be reflected in the
configuration of circus.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;reloadconfig&quot;, <br>
&quot;waiting&quot;: False <br>
}</p>

<p style="margin-top: 1em">The response return the status
&quot;ok&quot;. If the property graceful is set to true the
processes will be exited gracefully.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl reloadconfig [--waiting]</p>

<p style="margin-top: 1em">Restart the arbiter or a watcher
<br>
This command restart all the process in a watcher or all
watchers. This funtion simply stop a watcher then restart
it.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;restart&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &quot;&lt;name&gt;&quot;, <br>
&quot;waiting&quot;: False, <br>
&quot;match&quot;: &quot;[simple|glob|regex]&quot; <br>
} <br>
}</p>

<p style="margin-top: 1em">The response return the status
&quot;ok&quot;.</p>

<p style="margin-top: 1em">If the property name is present,
then the reload will be applied to the watcher.</p>

<p style="margin-top: 1em">If waiting is False (default),
the call will return immediately after calling stop_signal
on each process.</p>

<p style="margin-top: 1em">If waiting is True, the call
will return only when the restart process is completely
ended. Because of the graceful_timeout option, it can take
some time.</p>

<p style="margin-top: 1em">The match parameter can have the
value simple for string compare, glob for wildcard matching
(default) or regex for regex matching.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl restart [name] [--waiting]
[--match=simple|glob|regex]</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name or pattern of the
watcher(s)</p>

<p style="margin-top: 1em">&Acirc;&middot; &lt;match&gt;:
watcher match method</p>

<p style="margin-top: 1em">Remove a watcher <br>
This command removes a watcher dynamically from the arbiter.
The watchers are gracefully stopped by default.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;rm&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &quot;&lt;nameofwatcher&gt;&quot;, <br>
&quot;nostop&quot;: False, <br>
&quot;waiting&quot;: False <br>
} <br>
}</p>

<p style="margin-top: 1em">The response return a status
&quot;ok&quot;.</p>

<p style="margin-top: 1em">If nostop is True (default:
False), the processes for the watcher will not be stopped -
instead the watcher will just be forgotten by circus and the
watcher processes will be <br>
responsible for stopping themselves. If nostop is not
specified or is False, then the watcher processes will be
stopped gracefully.</p>

<p style="margin-top: 1em">If waiting is False (default),
the call will return immediately after starting to remove
and stop the corresponding watcher.</p>

<p style="margin-top: 1em">If waiting is True, the call
will return only when the remove and stop process is
completely ended. Because of the graceful_timeout option, it
can take some time.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl rm &lt;name&gt; [--waiting] [--nostop]</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name of the watcher to
remove</p>

<p style="margin-top: 1em">&Acirc;&middot; nostop: do not
stop the watcher processes, just remove the watcher</p>

<p style="margin-top: 1em">Set a watcher option <br>
ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;set&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &quot;nameofwatcher&quot;, <br>
&quot;options&quot;: { <br>
&quot;key1&quot;: &quot;val1&quot;, <br>
.. <br>
} <br>
&quot;waiting&quot;: False <br>
} <br>
}</p>

<p style="margin-top: 1em">The response return the status
&quot;ok&quot;. See the command Options for a list of key to
set.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl set &lt;name&gt; &lt;key1&gt; &lt;value1&gt;
&lt;key2&gt; &lt;value2&gt; --waiting</p>

<p style="margin-top: 1em">Send a signal <br>
This command allows you to send a signal to all processes in
a watcher, a specific process in a watcher or its
children.</p>

<p style="margin-top: 1em">ZMQ Message <br>
To send a signal to all the processes for a watcher:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;signal&quot;, <br>
&quot;property&quot;: { <br>
&quot;name&quot;: &lt;name&gt;, <br>
&quot;signum&quot;: &lt;signum&gt; <br>
}</p>

<p style="margin-top: 1em">To send a signal to a
process:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;signal&quot;, <br>
&quot;property&quot;: { <br>
&quot;name&quot;: &lt;name&gt;, <br>
&quot;pid&quot;: &lt;processid&gt;, <br>
&quot;signum&quot;: &lt;signum&gt; <br>
}</p>

<p style="margin-top: 1em">An optional property
&quot;children&quot; can be used to send the signal to all
the children rather than the process itself:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;signal&quot;, <br>
&quot;property&quot;: { <br>
&quot;name&quot;: &lt;name&gt;, <br>
&quot;pid&quot;: &lt;processid&gt;, <br>
&quot;signum&quot;: &lt;signum&gt;, <br>
&quot;children&quot;: True <br>
}</p>

<p style="margin-top: 1em">To send a signal to a process
child:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;signal&quot;, <br>
&quot;property&quot;: { <br>
&quot;name&quot;: &lt;name&gt;, <br>
&quot;pid&quot;: &lt;processid&gt;, <br>
&quot;signum&quot;: &lt;signum&gt;, <br>
&quot;child_pid&quot;: &lt;childpid&gt;, <br>
}</p>

<p style="margin-top: 1em">It is also possible to send a
signal to all the children of the watcher:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;signal&quot;, <br>
&quot;property&quot;: { <br>
&quot;name&quot;: &lt;name&gt;, <br>
&quot;signum&quot;: &lt;signum&gt;, <br>
&quot;children&quot;: True <br>
}</p>

<p style="margin-top: 1em">Lastly, you can send a signal to
the process and its children, with the recursive option:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;signal&quot;, <br>
&quot;property&quot;: { <br>
&quot;name&quot;: &lt;name&gt;, <br>
&quot;signum&quot;: &lt;signum&gt;, <br>
&quot;recursive&quot;: True <br>
}</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl signal &lt;name&gt; [&lt;pid&gt;] [--children]
<br>
[--recursive] &lt;signum&gt;</p>

<p style="margin-top: 1em">Options: <br>
&Acirc;&middot; &lt;name&gt;: the name of the watcher</p>

<p style="margin-top: 1em">&Acirc;&middot; &lt;pid&gt;:
integer, the process id.</p>

<p style="margin-top: 1em">&Acirc;&middot; &lt;signum&gt;:
the signal number (or name) to send.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&lt;childpid&gt;: the pid of a child, if any</p>

<p style="margin-top: 1em">&Acirc;&middot;
&lt;children&gt;: boolean, send the signal to all the
children</p>

<p style="margin-top: 1em">&Acirc;&middot;
&lt;recursive&gt;: boolean, send the signal to the process
and its children</p>

<p style="margin-top: 1em">Start the arbiter or a watcher
<br>
This command starts all the processes in a watcher or all
watchers.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;start&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &rsquo;&lt;name&gt;&quot;, <br>
&quot;waiting&quot;: False, <br>
&quot;match&quot;: &quot;[simple|glob|regex]&quot; <br>
} <br>
}</p>

<p style="margin-top: 1em">The response return the status
&quot;ok&quot;.</p>

<p style="margin-top: 1em">If the property name is present,
the watcher will be started.</p>

<p style="margin-top: 1em">If waiting is False (default),
the call will return immediately after calling start on each
process.</p>

<p style="margin-top: 1em">If waiting is True, the call
will return only when the start process is completely ended.
Because of the graceful_timeout option, it can take some
time.</p>

<p style="margin-top: 1em">The match parameter can have the
value simple for string compare, glob for wildcard matching
(default) or regex for regex matching.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl restart [name] [--waiting]
[--match=simple|glob|regex]</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name or pattern of the
watcher(s)</p>

<p style="margin-top: 1em">&Acirc;&middot; &lt;match&gt;:
watcher match method</p>

<p style="margin-top: 1em">Get process infos <br>
You can get at any time some statistics about your processes
with the stat command.</p>

<p style="margin-top: 1em">ZMQ Message <br>
To get stats for all watchers:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;stats&quot; <br>
}</p>

<p style="margin-top: 1em">To get stats for a watcher:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;stats&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &lt;name&gt; <br>
} <br>
}</p>

<p style="margin-top: 1em">To get stats for a process:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;stats&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &lt;name&gt;, <br>
&quot;process&quot;: &lt;processid&gt; <br>
} <br>
}</p>

<p style="margin-top: 1em">Stats can be extended with the
extended_stats hook but extended stats need to be
requested:</p>

<p style="margin-top: 1em">{ <br>
&quot;command&quot;: &quot;stats&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &lt;name&gt;, <br>
&quot;process&quot;: &lt;processid&gt;, <br>
&quot;extended&quot;: True <br>
} <br>
}</p>

<p style="margin-top: 1em">The response retun an object per
process with the property &quot;info&quot; containing some
process informations:</p>

<p style="margin-top: 1em">{ <br>
&quot;info&quot;: { <br>
&quot;children&quot;: [], <br>
&quot;cmdline&quot;: &quot;python&quot;, <br>
&quot;cpu&quot;: 0.1, <br>
&quot;ctime&quot;: &quot;0:00.41&quot;, <br>
&quot;mem&quot;: 0.1, <br>
&quot;mem_info1&quot;: &quot;3M&quot;, <br>
&quot;mem_info2&quot;: &quot;2G&quot;, <br>
&quot;nice&quot;: 0, <br>
&quot;pid&quot;: 47864, <br>
&quot;username&quot;: &quot;root&quot; <br>
}, <br>
&quot;process&quot;: 5, <br>
&quot;status&quot;: &quot;ok&quot;, <br>
&quot;time&quot;: 1332265655.897085 <br>
}</p>

<p style="margin-top: 1em">Command Line <br>
$ circusctl stats [--extended] [&lt;watchername&gt;]
[&lt;processid&gt;]</p>

<p style="margin-top: 1em">Get the status of a watcher or
all watchers <br>
This command start get the status of a watcher or all
watchers.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;status&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &rsquo;&lt;name&gt;&quot;, <br>
} <br>
}</p>

<p style="margin-top: 1em">The response return the status
&quot;active&quot; or &quot;stopped&quot; or the status /
watchers.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl status [&lt;name&gt;]</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name of the watcher</p>

<p style="margin-top: 1em">Example <br>
$ circusctl status dummy <br>
active <br>
$ circusctl status <br>
dummy: active <br>
dummy2: active <br>
refuge: active</p>

<p style="margin-top: 1em">Stop watchers <br>
This command stops a given watcher or all watchers.</p>

<p style="margin-top: 1em">ZMQ Message <br>
{ <br>
&quot;command&quot;: &quot;stop&quot;, <br>
&quot;properties&quot;: { <br>
&quot;name&quot;: &quot;&lt;name&gt;&quot;, <br>
&quot;waiting&quot;: False, <br>
&quot;match&quot;: &quot;[simple|glob|regex]&quot; <br>
} <br>
}</p>

<p style="margin-top: 1em">The response returns the status
&quot;ok&quot;.</p>

<p style="margin-top: 1em">If the name property is present,
then the stop will be applied to the watcher corresponding
to that name. Otherwise, all watchers will get stopped.</p>

<p style="margin-top: 1em">If waiting is False (default),
the call will return immediatly after calling stop_signal on
each process.</p>

<p style="margin-top: 1em">If waiting is True, the call
will return only when the stop process is completly ended.
Because of the graceful_timeout option, it can take some
time.</p>

<p style="margin-top: 1em">The match parameter can have the
value simple for string compare, glob for wildcard matching
(default) or regex for regex matching.</p>

<p style="margin-top: 1em">Command line <br>
$ circusctl stop [name] [--waiting]
[--match=simple|glob|regex]</p>

<p style="margin-top: 1em">Options <br>
&Acirc;&middot; &lt;name&gt;: name or pattern of the
watcher(s)</p>

<p style="margin-top: 1em">&Acirc;&middot; &lt;match&gt;:
watcher match method</p>

<p style="margin-top: 1em">CLI tools <br>
circus-top <br>
circus-top is a top-like console you can run to watch live
your running Circus system. It will display the CPU, Memory
usage and socket hits if you have some.</p>

<p style="margin-top: 1em">Example of output:</p>


<p style="margin-top: 1em">-----------------------------------------------------------------------
<br>
circusd-stats <br>
PID CPU (%) MEMORY (%) <br>
14252 0.8 0.4 <br>
0.8 (avg) 0.4 (sum)</p>

<p style="margin-top: 1em">dummy <br>
PID CPU (%) MEMORY (%) <br>
14257 78.6 0.1 <br>
14256 76.6 0.1 <br>
14258 74.3 0.1 <br>
14260 71.4 0.1 <br>
14259 70.7 0.1 <br>
74.32 (avg) 0.5 (sum)</p>


<p style="margin-top: 1em">----------------------------------------------------------------------</p>

<p style="margin-top: 1em">circus-top is a read-only
console. If you want to interact with the system, use
circusctl.</p>

<p style="margin-top: 1em">circusctl <br>
circusctl can be used to run any command listed in commands
. For example, you can get a list of all the watchers, you
can do</p>

<p style="margin-top: 1em">$ circusctl list</p>

<p style="margin-top: 1em">Besides supporting a handful of
options you can also specify the endpoint circusctl should
use using the CIRCUSCTL_ENDPOINT environment variable.</p>

<p style="margin-top: 1em">The Web Console <br>
Circus comes with a Web Console that can be used to manage
the system.</p>

<p style="margin-top: 1em">The Web Console lets you:</p>

<p style="margin-top: 1em">&Acirc;&middot; Connect to any
running Circus system</p>

<p style="margin-top: 1em">&Acirc;&middot; Watch the
processes CPU and Memory usage in real-time</p>

<p style="margin-top: 1em">&Acirc;&middot; Add or kill
processes</p>

<p style="margin-top: 1em">&Acirc;&middot; Add new
watchers</p>

<p style="margin-top: 1em">NOTE: <br>
The real-time CPU &amp; Memory usage feature uses the stats
socket. If you want to activate it, make sure the Circus
system you&rsquo;ll connect to has the stats enpoint enabled
in its <br>
configuration:</p>

<p style="margin-top: 1em">[circus] <br>
statsd = True</p>

<p style="margin-top: 1em">By default, this option is not
activated.</p>

<p style="margin-top: 1em">The web console is its own
package, you need to install:</p>

<p style="margin-top: 1em">$ pip install circus-web</p>

<p style="margin-top: 1em">To enable the console, add a few
options in the Circus ini file:</p>

<p style="margin-top: 1em">[circus] <br>
httpd = True <br>
httpd_host = localhost <br>
httpd_port = 8080</p>

<p style="margin-top: 1em">httpd_host and httpd_port are
optional, and default to localhost and 8080.</p>

<p style="margin-top: 1em">If you want to run the web app
on its own, just run the circushttpd script:</p>

<p style="margin-top: 1em">$ circushttpd <br>
Bottle server starting up... <br>
Listening on http://localhost:8080/ <br>
Hit Ctrl-C to quit.</p>

<p style="margin-top: 1em">By default the script will run
the Web Console on port 8080, but the --port option can be
used to change it.</p>

<p style="margin-top: 1em">Using the console <br>
Once the script is running, you can open a browser and visit
http://localhost:8080. You should get this screen:
[image]</p>

<p style="margin-top: 1em">The Web Console is ready to be
connected to a Circus system, given its endpoint. By default
the endpoint is tcp://127.0.0.1:5555.</p>

<p style="margin-top: 1em">Once you hit Connect, the web
application will connect to the Circus system.</p>

<p style="margin-top: 1em">With the Web Console logged in,
you should get a list of watchers, and a real-time status of
the two Circus processes (circusd and circusd-stats).</p>

<p style="margin-top: 1em">You can click on the status of
each watcher to toggle it from Active (green) to Inactive
(red). This change is effective immediatly and let you start
&amp; stop watchers.</p>

<p style="margin-top: 1em">If you click on the watcher
name, you will get a web page for that particular watcher,
with its processes:</p>

<p style="margin-top: 1em">On this screen, you can add or
remove processes, and kill existing ones.</p>

<p style="margin-top: 1em">Last but not least, you can add
a brand new watcher by clicking on the Add Watcher link in
the left menu: .SS Running behind Nginx</p>

<p style="margin-top: 1em">Nginx can act as a proxy and
security layer in front of circus-web.</p>

<p style="margin-top: 1em">NOTE: <br>
To receive real-time status updates and graphs in
circus-web, you must provide a Nginx proxy solution that has
websocket support</p>

<p style="margin-top: 1em">Nginx &gt;= 1.3.13 <br>
As of Nginx&gt;=1.3.13 websocket support is built-in, so
there is no need to combine Nginx with Varnish or HAProxy.
An example Nginx config with websocket support:</p>

<p style="margin-top: 1em">upstream circusweb_server { <br>
server 127.0.0.1:8080; <br>
}</p>

<p style="margin-top: 1em">server { <br>
listen 80; <br>
server_name _;</p>

<p style="margin-top: 1em">location / { <br>
proxy_pass http://circusweb_server; <br>
proxy_http_version 1.1; <br>
proxy_set_header Upgrade $http_upgrade; <br>
proxy_set_header Connection &quot;upgrade&quot;; <br>
proxy_set_header Host $host; <br>
proxy_set_header X-Real-IP $remote_addr; <br>
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
<br>
proxy_set_header X-Forwarded-Proto http; <br>
proxy_redirect off; <br>
}</p>

<p style="margin-top: 1em">location
~/media/ng|.jpg|.css|.js|.ico)$ { <br>
alias /path_to_site-packages/circusweb/media/; <br>
} <br>
}</p>

<p style="margin-top: 1em">Nginx &lt; 1.3.13 <br>
Nginx versions &lt; 1.3.13 do not have websocket support
built-in.</p>

<p style="margin-top: 1em">To provide websocket support for
circus-web when using Nginx &lt; 1.3.13, you can combine
Nginx with Varnish or HAProxy. That is, Nginx in front of
circus-web, with Varnish or <br>
HAProxy in front of Nginx.</p>

<p style="margin-top: 1em">The example below shows the
combined Nginix and Varnish configuration required to proxy
circus-web and provide websocket support.</p>

<p style="margin-top: 1em">Nginx configuration:</p>

<p style="margin-top: 1em">upstream circusweb_server { <br>
server 127.0.0.1:8080; <br>
}</p>

<p style="margin-top: 1em">server { <br>
listen 8001; <br>
server_name _;</p>

<p style="margin-top: 1em">location / { <br>
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
<br>
proxy_set_header Host $http_host; <br>
proxy_redirect off; <br>
proxy_pass http://circusweb_server; <br>
}</p>

<p style="margin-top: 1em">location
~/media/ng|.jpg|.css|.js|.ico)$ { <br>
alias /path_to_site-packages/circusweb/media/; <br>
} <br>
}</p>

<p style="margin-top: 1em">If you want more Nginx
configuration options, see
http://wiki.nginx.org/HttpProxyModule.</p>

<p style="margin-top: 1em">Varnish configuration:</p>

<p style="margin-top: 1em">backend default { <br>
.host = &quot;127.0.0.1&quot;; <br>
.port = &quot;8001&quot;; <br>
}</p>

<p style="margin-top: 1em">backend socket { <br>
.host = &quot;127.0.0.1&quot;; <br>
.port = &quot;8080&quot;; <br>
.connect_timeout = 1s; <br>
.first_byte_timeout = 2s; <br>
.between_bytes_timeout = 60s; <br>
}</p>

<p style="margin-top: 1em">sub vcl_pipe { <br>
if (req.http.upgrade) { <br>
set bereq.http.upgrade = req.http.upgrade; <br>
} <br>
}</p>

<p style="margin-top: 1em">sub vcl_recv { <br>
if (req.http.Upgrade ~ &quot;(?i)websocket&quot;) { <br>
set req.backend = socket; <br>
return (pipe); <br>
} <br>
}</p>

<p style="margin-top: 1em">In the Varnish configuration
example above two backends are defined. One serving the web
console and one serving the socket connections. Web console
requests are bound to port <br>
8001. The Nginx &rsquo;server&rsquo; directive should be
configured to listen on port 8001.</p>

<p style="margin-top: 1em">Websocket connections are
upgraded and piped directly to the circushttpd process
listening on port 8080 by Varnish. i.e. bypassing the Nginx
proxy.</p>

<p style="margin-top: 1em">Ubuntu <br>
Since the version 13.10 (Saucy), Ubuntu includes Nginx with
websocket support in its own repositories. For older
versions, you can install Nginx&gt;=1.3.13 from the official
Nginx <br>
stable PPA, as so:</p>

<p style="margin-top: 1em">sudo apt-get install
python-software-properties <br>
sudo add-apt-repository ppa:nginx/stable <br>
sudo apt-get update <br>
sudo apt-get install nginx <br>
nginx -v</p>

<p style="margin-top: 1em">Password-protect circushttpd
<br>
As explained in the Security page, running circushttpd is
pretty unsafe. We don&rsquo;t provide any security in Circus
itself, but you can protect your console at the NGinx level,
by <br>
using http://wiki.nginx.org/HttpAuthBasicModule</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">location / { <br>
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
<br>
proxy_set_header Host $http_host; <br>
proxy_set_header X-Forwarded-Host: $http_host; <br>
proxy_set_header X-Forwarded-Proto: $scheme; <br>
proxy_redirect off; <br>
proxy_pass http://127.0.0.1:8080; <br>
auth_basic &quot;Restricted&quot;; <br>
auth_basic_user_file /path/to/htpasswd; <br>
}</p>

<p style="margin-top: 1em">The htpasswd file contains users
and their passwords, and a password prompt will pop when you
access the console.</p>

<p style="margin-top: 1em">You can use Apache&rsquo;s
htpasswd script to edit it, or the Python script they
provide at:
http://trac.edgewall.org/browser/trunk/contrib/htpasswd.py</p>

<p style="margin-top: 1em">However, there&rsquo;s no native
support for the combined use of HTTP Authentication and
WebSockets (the server will throw HTTP 401 error codes). A
workaround is to disable such <br>
authentication for the socket.io server.</p>

<p style="margin-top: 1em">Example (needs to be added
before the previous rule):</p>

<p style="margin-top: 1em">location /socket.io { <br>
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
<br>
proxy_set_header Host $http_host; <br>
proxy_set_header X-Forwarded-Host: $http_host; <br>
proxy_set_header X-Forwarded-Proto: $scheme; <br>
proxy_redirect off; <br>
proxy_pass http://127.0.0.1:8080; <br>
}</p>

<p style="margin-top: 1em">Of course that&rsquo;s just one
way to protect your web console, you could use many other
techniques.</p>

<p style="margin-top: 1em">Extending the web console <br>
We picked bottle to build the webconsole, mainly because
it&rsquo;s a really tiny framework that doesn&rsquo;t do
much. By having a look at the code of the web console,
you&rsquo;ll eventually <br>
find out that it&rsquo;s really simple to understand.</p>

<p style="margin-top: 1em">Here is how it&rsquo;s
split:</p>

<p style="margin-top: 1em">&Acirc;&middot; The
circushttpd.py file contains the &quot;views&quot;
definitions and some code to handle the socket connection
(via socketio).</p>

<p style="margin-top: 1em">&Acirc;&middot; the
controller.py contains a single class which is in charge of
doing the communication with the circus controller. It
allows to have a nicer high level API when defining the <br>
web server.</p>

<p style="margin-top: 1em">If you want to add a feature in
the web console you can reuse the code that&rsquo;s
existing. A few tools are at your disposal to ease the
process:</p>

<p style="margin-top: 1em">&Acirc;&middot; There is a
render_template function, which takes the named arguments
you pass to it and pass them to the template renderer and
return the resulting HTML. It also passes some <br>
additional variables, such as the session, the circus
version and the client if defined.</p>

<p style="margin-top: 1em">&Acirc;&middot; If you want to
run commands and doa redirection depending the result of it,
you can use the run_command function, which takes a callable
as a first argument, a message in case <br>
of success and a redirection url.</p>

<p style="margin-top: 1em">The StatsNamespace class is
responsible for managing the websocket communication on the
server side. Its documentation should help you to understand
what it does.</p>

<p style="margin-top: 1em">Working with sockets <br>
Circus can bind network sockets and manage them as it does
for processes.</p>

<p style="margin-top: 1em">The main idea is that a child
process that&rsquo;s created by Circus to run one of the
watcher&rsquo;s command can inherit from all the opened file
descriptors.</p>

<p style="margin-top: 1em">That&rsquo;s how Apache or
Unicorn works, and many other tools out there.</p>

<p style="margin-top: 1em">Goal <br>
The goal of having sockets managed by Circus is to be able
to manage network applications in Circus exactly like other
applications.</p>

<p style="margin-top: 1em">For example, if you use Circus
with Chaussette -- a WGSI server, you can get a very fast
web server running and manage &quot;Web Workers&quot; in
Circus as you would do for any other <br>
process.</p>

<p style="margin-top: 1em">Splitting the socket managment
from the network application itself offers a lot of
opportunities to scale and manage your stack.</p>

<p style="margin-top: 1em">Design <br>
The gist of the feature is done by binding the socket and
start listening to it in circusd:</p>

<p style="margin-top: 1em">import socket</p>

<p style="margin-top: 1em">sock = socket.socket(FAMILY,
TYPE) <br>
sock.bind((HOST, PORT)) <br>
sock.listen(BACKLOG) <br>
fd = sock.fileno()</p>

<p style="margin-top: 1em">Circus then keeps track of all
the opened fds, and let the processes it runs as children
have access to them if they want.</p>

<p style="margin-top: 1em">If you create a small Python
network script that you intend to run in Circus, it could
look like this:</p>

<p style="margin-top: 1em">import socket <br>
import sys</p>

<p style="margin-top: 1em">fd = int(sys.argv[1]) # getting
the FD from circus <br>
sock = socket.fromfd(fd, FAMILY, TYPE)</p>

<p style="margin-top: 1em"># dealing with one request at a
time <br>
while True: <br>
conn, addr = sock.accept() <br>
request = conn.recv(1024) <br>
.. do something .. <br>
conn.sendall(response) <br>
conn.close()</p>

<p style="margin-top: 1em">Then Circus could run like
this:</p>

<p style="margin-top: 1em">[circus] <br>
check_delay = 5 <br>
endpoint = tcp://127.0.0.1:5555 <br>
pubsub_endpoint = tcp://127.0.0.1:5556 <br>
stats_endpoint = tcp://127.0.0.1:5557</p>

<p style="margin-top: 1em">[watcher:dummy] <br>
cmd = mycoolscript $(circus.sockets.foo) <br>
use_sockets = True <br>
warmup_delay = 0 <br>
numprocesses = 5</p>

<p style="margin-top: 1em">[socket:foo] <br>
host = 127.0.0.1 <br>
port = 8888</p>

<p style="margin-top: 1em">$(circus.sockets.foo) will be
replaced by the FD value once the socket is created and
bound on the 8888 port.</p>

<p style="margin-top: 1em">NOTE: <br>
Starting at Circus 0.8 there&rsquo;s an alternate syntax to
avoid some conflicts with some config parsers. You can
write:</p>

<p style="margin-top: 1em">((circus.sockets.foo))</p>

<p style="margin-top: 1em">Real-world example <br>
Chaussette is the perfect Circus companion if you want to
run your WSGI application.</p>

<p style="margin-top: 1em">Once it&rsquo;s installed,
running 5 meinheld workers can be done by creating a socket
and calling the chaussette command in a worker, like
this:</p>

<p style="margin-top: 1em">[circus] <br>
endpoint = tcp://127.0.0.1:5555 <br>
pubsub_endpoint = tcp://127.0.0.1:5556 <br>
stats_endpoint = tcp://127.0.0.1:5557</p>

<p style="margin-top: 1em">[watcher:web] <br>
cmd = chaussette --fd $(circus.sockets.web) --backend
meinheld mycool.app <br>
use_sockets = True <br>
numprocesses = 5</p>

<p style="margin-top: 1em">[socket:web] <br>
host = 0.0.0.0 <br>
port = 8000</p>

<p style="margin-top: 1em">We did not publish benchmarks
yet, but a Web cluster managed by Circus with a Gevent or
Meinheld backend is as fast as any pre-fork WSGI server out
there.</p>

<p style="margin-top: 1em">Using built-in plugins <br>
Circus comes with a few built-in plugins. This section
presents these plugins and their configuration options.</p>

<p style="margin-top: 1em">Statsd <br>
use set to
&rsquo;circus.plugins.statsd.StatsdEmitter&rsquo;</p>

<p style="margin-top: 1em">application_name <br>
the name used to identify the bucket prefix to emit the
stats to (it will be prefixed with circus. and suffixed with
.watcher)</p>

<p style="margin-top: 1em">host the host to post the statds
data to</p>

<p style="margin-top: 1em">port the port the statsd daemon
listens on</p>

<p style="margin-top: 1em">sample_rate <br>
if you prefer a different sample rate than 1, you can set it
here</p>

<p style="margin-top: 1em">FullStats <br>
An extension on the Statsd plugin that is also publishing
the process stats. As such it has the same configuration
options as Statsd and the following.</p>

<p style="margin-top: 1em">use set to
circus.plugins.statsd.FullStats</p>

<p style="margin-top: 1em">loop_rate <br>
the frequency the plugin should ask for the stats in
seconds. Default: 60.</p>

<p style="margin-top: 1em">RedisObserver <br>
This services observers a redis process for you, publishes
the information to statsd and offers to restart the watcher
when it doesn&rsquo;t react in a given timeout. This plugin
<br>
requires redis-py to run.</p>

<p style="margin-top: 1em">It has the same configuration as
statsd and adds the following:</p>

<p style="margin-top: 1em">use set to
circus.plugins.redis_observer.RedisObserver</p>

<p style="margin-top: 1em">loop_rate <br>
the frequency the plugin should ask for the stats in
seconds. Default: 60.</p>

<p style="margin-top: 1em">redis_url <br>
the database to check for as a redis url. Default:
&quot;redis://localhost:6379/0&quot;</p>

<p style="margin-top: 1em">timeout <br>
the timeout in seconds the request can take before it is
considered down. Defaults to 5.</p>

<p style="margin-top: 1em">restart_on_timeout <br>
the name of the process to restart when the request timed
out. No restart triggered when not given. Default: None.</p>

<p style="margin-top: 1em">HttpObserver <br>
This services observers a http process for you by pinging a
certain website regularly. Similar to the redis observer it
offers to restart the watcher on an error. It requires <br>
tornado to run.</p>

<p style="margin-top: 1em">It has the same configuration as
statsd and adds the following:</p>

<p style="margin-top: 1em">use set to
circus.plugins.http_observer.HttpObserver</p>

<p style="margin-top: 1em">loop_rate <br>
the frequency the plugin should ask for the stats in
seconds. Default: 60.</p>

<p style="margin-top: 1em">check_url <br>
the url to check for. Default: http://localhost/</p>

<p style="margin-top: 1em">timeout <br>
the timeout in seconds the request can take before it is
considered down. Defaults to 10.</p>

<p style="margin-top: 1em">restart_on_error <br>
the name of the process to restart when the request timed
out or returned any other kind of error. No restart
triggered when not given. Default: None.</p>

<p style="margin-top: 1em">ResourceWatcher <br>
This services watches the resources of the given process and
triggers a restart when they exceed certain limitations too
often in a row.</p>

<p style="margin-top: 1em">It has the same configuration as
statsd and adds the following:</p>

<p style="margin-top: 1em">use set to
circus.plugins.resource_watcher.ResourceWatcher</p>

<p style="margin-top: 1em">loop_rate <br>
the frequency the plugin should ask for the stats in
seconds. Default: 60.</p>

<p style="margin-top: 1em">watcher <br>
the watcher this resource watcher should be looking after.
(previously called service but service is now
deprecated)</p>

<p style="margin-top: 1em">max_cpu <br>
The maximum cpu one process is allowed to consume (in %).
Default: 90</p>

<p style="margin-top: 1em">min_cpu <br>
The minimum cpu one process should consume (in %). Default:
None (no minimum) You can set the min_cpu to 0 (zero), in
this case if one process consume exactly 0% cpu, <br>
it will trigger an exceeded limit.</p>

<p style="margin-top: 1em">max_mem <br>
The amount of memory one process of this watcher is allowed
to consume. Default: 90. If no unit is specified, the value
is in %. Example: 50 If a unit is specified, <br>
the value is in bytes. Supported units are B, K, M, G, T, P,
E, Z, Y. Example: 250M</p>

<p style="margin-top: 1em">min_mem <br>
The minimum memory one process of this watcher should
consume. Default: None (no minimum). If no unit is
specified, the value is in %. Example: 50 If a unit is
speci&acirc; <br>
fied, the value is in bytes. Supported units are B, K, M, G,
T, P, E, Z, Y. Example: 250M</p>

<p style="margin-top: 1em">health_threshold <br>
The health is the average of cpu and memory (in %) the
watchers processes are allowed to consume (in %). Default:
75</p>

<p style="margin-top: 1em">max_count <br>
How often these limits (each one is counted separately) are
allowed to be exceeded before a restart will be triggered.
Default: 3</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">[circus] <br>
; ...</p>

<p style="margin-top: 1em">[watcher:program] <br>
cmd = sleep 120</p>

<p style="margin-top: 1em">[plugin:myplugin] <br>
use = circus.plugins.resource_watcher.ResourceWatcher <br>
watcher = program <br>
min_cpu = 10 <br>
max_cpu = 70 <br>
min_mem = 0 <br>
max_mem = 20</p>

<p style="margin-top: 1em">Watchdog <br>
Plugin that binds an udp socket and wait for watchdog
messages. For &quot;watchdoged&quot; processes, the watchdog
will kill them if they don&rsquo;t send a heartbeat in a
certain period of <br>
time materialized by loop_rate * max_count. (circus will
automatically restart the missing processes in the
watcher)</p>

<p style="margin-top: 1em">Each monitored process should
send udp message at least at the loop_rate. The udp message
format is a line of text, decoded using msg_regex parameter.
The heartbeat message <br>
MUST at least contain the pid of the process sending the
message.</p>

<p style="margin-top: 1em">The list of monitored watchers
are determined by the parameter watchers_regex in the
configuration.</p>

<p style="margin-top: 1em">Configuration parameters:</p>

<p style="margin-top: 1em">use set to
circus.plugins.watchdog.WatchDog</p>

<p style="margin-top: 1em">loop_rate <br>
watchdog loop rate in seconds. At each loop, WatchDog will
looks for &quot;dead&quot; processes.</p>

<p style="margin-top: 1em">watchers_regex <br>
regex for matching watcher names that should be monitored by
the watchdog (default: .* all watchers are monitored)</p>

<p style="margin-top: 1em">msg_regex <br>
regex for decoding the received heartbeat message in udp
(default: ^(?P&lt;pid&gt;.*);(?P&lt;timestamp&gt;.*)$) the
default format is a simple text message: pid;timestamp</p>

<p style="margin-top: 1em">max_count <br>
max number of passed loop without receiving any heartbeat
before restarting process (default: 3)</p>

<p style="margin-top: 1em">ip ip the watchdog will bind on
(default: 127.0.0.1)</p>

<p style="margin-top: 1em">port port the watchdog will bind
on (default: 1664)</p>

<p style="margin-top: 1em">Flapping <br>
When a worker restarts too often, we say that it is
flapping. This plugin keeps track of worker restarts and
stops the corresponding watcher in case it is flapping. This
<br>
plugin may be used to automatically stop workers that get
constantly restarted because they&rsquo;re not working
properly.</p>

<p style="margin-top: 1em">use set to
circus.plugins.flapping.Flapping</p>

<p style="margin-top: 1em">attempts <br>
the number of times a process can restart, within window
seconds, before we consider it flapping (default: 2)</p>

<p style="margin-top: 1em">window the time window in
seconds to test for flapping. If the process restarts more
than attempts times within this time window, we consider it
a flapping process. <br>
(default: 1)</p>

<p style="margin-top: 1em">retry_in <br>
time in seconds to wait until we try to start again a
process that has been flapping. (default: 7)</p>

<p style="margin-top: 1em">max_retry <br>
the number of times we attempt to start a process that has
been flapping, before we abandon and stop the whole watcher.
(default: 5) Set to -1 to disable max_retry and <br>
retry indefinitely.</p>

<p style="margin-top: 1em">active define if the plugin is
active or not (default: True). If the global flag is set to
False, the plugin is not started.</p>

<p style="margin-top: 1em">Options can be overriden in the
watcher section using a flapping. prefix. For instance, here
is how you would configure a specific max_retry value for
nginx:</p>

<p style="margin-top: 1em">[watcher:nginx] <br>
cmd = /path/to/nginx <br>
flapping.max_retry = 2</p>

<p style="margin-top: 1em">[watcher:myscript] <br>
cmd = ./my_script.py</p>

<p style="margin-top: 1em">; ... other watchers</p>

<p style="margin-top: 1em">[plugin:flapping] <br>
use = circus.plugins.flapping.Flapping <br>
max_retry = 5</p>

<p style="margin-top: 1em">CommandReloader <br>
This plugin will restart watchers when their command file is
modified. It works by checking the modification time and the
path of the file pointed by the cmd option every <br>
loop_rate seconds. This may be useful while developing
worker processes or even for hot code upgrade in
production.</p>

<p style="margin-top: 1em">use set to
circus.plugins.command_reloader.CommandReloader</p>

<p style="margin-top: 1em">loop_rate <br>
the frequency the plugin should check for modification in
seconds. Default: 1.</p>

<p style="margin-top: 1em">Deployment <br>
Although the Circus daemon can be managed with the circusd
command, it&rsquo;s easier to have it start on boot. If your
system supports Upstart, you can create this Upstart script
in <br>
/etc/init/circus.conf.</p>

<p style="margin-top: 1em">start on filesystem and
net-device-up IFACE=lo <br>
stop on runlevel [016]</p>

<p style="margin-top: 1em">respawn <br>
exec /usr/local/bin/circusd /etc/circus/circusd.ini</p>

<p style="margin-top: 1em">This assumes that circusd.ini is
located at /etc/circus/circusd.ini. After rebooting, you can
control circusd with the service command:</p>

<p style="margin-top: 1em"># service circus
start/stop/restart</p>

<p style="margin-top: 1em">If your system supports systemd,
you can create this systemd unit file under
/etc/systemd/system/circus.service.</p>

<p style="margin-top: 1em">[Unit] <br>
Description=Circus process manager <br>
After=syslog.target network.target nss-lookup.target</p>

<p style="margin-top: 1em">[Service] <br>
Type=simple <br>
ExecReload=/usr/bin/circusctl reload <br>
ExecStart=/usr/bin/circusd /etc/circus/circus.ini <br>
Restart=always <br>
RestartSec=5</p>

<p style="margin-top: 1em">[Install] <br>
WantedBy=default.target</p>

<p style="margin-top: 1em">A reboot isn&rsquo;t required if
you run the daemon-reload command below:</p>

<p style="margin-top: 1em"># systemctl --system
daemon-reload</p>

<p style="margin-top: 1em">Then circus can be managed
via:</p>

<p style="margin-top: 1em"># systemctl
start/stop/status/reload circus</p>

<p style="margin-top: 1em">Recipes <br>
This section will contain recipes to deploy Circus. Until
then you can look at Pete&rsquo;s Puppet recipe or at
Remy&rsquo;s Chef recipe</p>

<p style="margin-top: 1em">Papa Process Kernel <br>
One problem common to process managers is that you cannot
restart the process manager without restarting all of the
processes it manages. This makes it difficult to deploy a
new <br>
version of Circus or new versions of any of the libraries on
which it depends.</p>

<p style="margin-top: 1em">If you are on a Unix-type
system, Circus can use the Papa process kernel. When used,
Papa will create a long-lived daemon that will serve as the
host for any processes and sock&acirc; <br>
ets you create with it. If circus is shutdown, Papa will
maintain everything it is hosting.</p>

<p style="margin-top: 1em">Setup <br>
Start by installing the papa and setproctitle modules:</p>

<p style="margin-top: 1em">pip install papa <br>
pip install setproctitle</p>

<p style="margin-top: 1em">The setproctitle module is
optional. It will be used if present to rename the Papa
daemon for top and ps to something like &quot;papa daemon
from circusd&quot;. If you do not install the <br>
setproctitle module, that title will be the command line of
the process that launched it. Very confusing.</p>

<p style="margin-top: 1em">Once Papa is installed, add
use_papa=true to your critical processes and sockets.
Generally you want to house all of the processes of your
stack in Papa, and none of the Circus <br>
support processes such as the flapping and stats
plugins.</p>

<p style="margin-top: 1em">[circus] <br>
loglevel = info</p>

<p style="margin-top: 1em">[watcher:nginx] <br>
cmd = /usr/local/nginx/sbin/nginx -p
/Users/scottmax/Source/service-framework/Common/conf/nginx
-c
/Users/scottmax/Source/service-framework/Common/conf/nginx/nginx.conf
<br>
warmup_delay = 3 <br>
graceful_timeout = 10 <br>
max_retry = 5 <br>
singleton = true <br>
send_hup = true <br>
stop_signal = QUIT <br>
stdout_stream.class = FileStream <br>
stdout_stream.filename = /var/logs/web-server.log <br>
stdout_stream.max_bytes = 10000000 <br>
stdout_stream.backup_count = 10 <br>
stderr_stream.class = FileStream <br>
stderr_stream.filename = /var/logs/web-server-error.log <br>
stderr_stream.max_bytes = 1000000 <br>
stderr_stream.backup_count = 10 <br>
active = true <br>
use_papa = true</p>

<p style="margin-top: 1em">[watcher:logger] <br>
cmd = /my_service/env/bin/python logger.py run <br>
working_dir = /my_service <br>
graceful_timeout = 10 <br>
singleton = true <br>
stop_signal = INT <br>
stdout_stream.class = FileStream <br>
stdout_stream.filename = /var/logs/logger.log <br>
stdout_stream.max_bytes = 10000000 <br>
stdout_stream.backup_count = 10 <br>
stderr_stream.class = FileStream <br>
stderr_stream.filename = /var/logs/logger.log <br>
stderr_stream.max_bytes = 1000000 <br>
stderr_stream.backup_count = 10 <br>
priority = 50 <br>
use_papa = true</p>

<p style="margin-top: 1em">[watcher:web_app] <br>
cmd = /my_service/env/bin/uwsgi --ini uwsgi-live.ini
--socket fd://$(circus.sockets.web) --stats
127.0.0.1:809$(circus.wid) <br>
working_dir = /my_service/web_app <br>
graceful_timeout=10 <br>
stop_signal = QUIT <br>
use_sockets = True <br>
stdout_stream.class = FileStream <br>
stdout_stream.filename = /var/logs/web_app.log <br>
stdout_stream.max_bytes = 10000000 <br>
stdout_stream.backup_count = 10 <br>
stderr_stream.class = FileStream <br>
stderr_stream.filename = /var/logs/web_app.log <br>
stderr_stream.max_bytes = 1000000 <br>
stderr_stream.backup_count = 10 <br>
hooks.after_spawn =
examples.uwsgi_lossless_reload.children_started <br>
hooks.before_signal =
examples.uwsgi_lossless_reload.clean_stop <br>
hooks.extended_stats =
examples.uwsgi_lossless_reload.extended_stats <br>
priority = 40 <br>
use_papa = true</p>

<p style="margin-top: 1em">[socket:web] <br>
path = /my_service/sock/uwsgi <br>
use_papa = true</p>

<p style="margin-top: 1em">[plugin:flapping] <br>
use = circus.plugins.flapping.Flapping <br>
window = 10 <br>
priority = 1000</p>

<p style="margin-top: 1em">NOTE: <br>
If the Papa processes use any sockets, those sockets must
also use papa.</p>

<p style="margin-top: 1em">Design Goal <br>
Papa is designed to be very minimalist in features and
requirements. It does:</p>

<p style="margin-top: 1em">&Acirc;&middot; Start and stop
sockets</p>

<p style="margin-top: 1em">&Acirc;&middot; Provide a
key/value store</p>

<p style="margin-top: 1em">&Acirc;&middot; Start processes
and return stdout, stderr and the exit code</p>

<p style="margin-top: 1em">It does not:</p>

<p style="margin-top: 1em">&Acirc;&middot; Restart
processes</p>

<p style="margin-top: 1em">&Acirc;&middot; Provide a way to
stop processes</p>

<p style="margin-top: 1em">&Acirc;&middot; Provide any
information about processes other than whether or not they
are still running</p>

<p style="margin-top: 1em">Papa requires no third-party
libraries so it can run on just the standard Python library.
It can make use of the setproctitle package but that is only
used for making the title <br>
prettier for ps and top and is not essential.</p>

<p style="margin-top: 1em">The functionality has been kept
to a minimum so that you should never need to restart the
Papa daemon. As much of the functionality has been pushed to
the client library as pos&acirc; <br>
sible. That way you should be able to deploy a new copy of
Papa for new client features without needing to restart the
Papa daemon. Papa is meant to be a pillar of stability in
<br>
a changing sea of 3rd party libraries.</p>

<p style="margin-top: 1em">Operation <br>
Most things remain unchanged whether you use Papa or not.
You can still start and stop processes. You can still get
status and stats for processes. The main thing that changes
is <br>
that when you do circusctl quit, all of the Papa processes
are left running. When you start circusd back up, those
processes are recovered.</p>

<p style="margin-top: 1em">NOTE: <br>
When processes are recovered, before_start and before_spawn
hooks are skipped.</p>

<p style="margin-top: 1em">Logging <br>
While Circus is shut down, Papa will store up to 2M of
output per process. Then it will start dumping the oldest
data. When you restart Circus, this cached output will be
quickly <br>
retrieved and sent to the output streams. Papa requires that
receipt of output be acknowledged, so you should not lose
any output during a shutdown.</p>

<p style="margin-top: 1em">Not only that, but Papa saves
the timestamp of the output. Circus has been enhanced to
take advantage of timestamp data if present. So if you are
writing the output to log files <br>
or somewhere, your timestamps should all be correct.</p>

<p style="margin-top: 1em">Problems <br>
If you use the incr or decr command to change the process
count for a watcher, this will be reset to the level
specified in the INI file when circusd is restarted.</p>

<p style="margin-top: 1em">Also, I have experienced
problems with the combination of copy_env and virtualenv.
You may note that the INI sample above circumvents this
issue with explicit paths.</p>

<p style="margin-top: 1em">Telnet Interface <br>
Papa has a basic command-line interface that you can access
through telnet:</p>

<p style="margin-top: 1em">telnet localhost 20202 <br>
help</p>

<p style="margin-top: 1em">Circus for developers <br>
Using Circus as a library <br>
Circus provides high-level classes and functions that will
let you manage processes in your own applications.</p>

<p style="margin-top: 1em">For example, if you want to run
four processes forever, you could write:</p>

<p style="margin-top: 1em">from circus import
get_arbiter</p>

<p style="margin-top: 1em">myprogram = {&quot;cmd&quot;:
&quot;python myprogram.py&quot;, &quot;numprocesses&quot;:
4}</p>

<p style="margin-top: 1em">arbiter =
get_arbiter([myprogram]) <br>
try: <br>
arbiter.start() <br>
finally: <br>
arbiter.stop()</p>

<p style="margin-top: 1em">This snippet will run four
instances of myprogram and watch them for you, restarting
them if they die unexpectedly.</p>

<p style="margin-top: 1em">To learn more about this, see
library</p>

<p style="margin-top: 1em">Extending Circus <br>
It&rsquo;s easy to extend Circus to create a more complex
system, by listening to all the circusd events via its
pub/sub channel, and driving it via commands.</p>

<p style="margin-top: 1em">That&rsquo;s how the flapping
feature works for instance: it listens to all the processes
dying, measures how often it happens, and stops the
incriminated watchers after too many <br>
restarts attempts.</p>

<p style="margin-top: 1em">Circus comes with a plugin
system to help you write such extensions, and a few built-in
plugins you can reuse. See plugins.</p>

<p style="margin-top: 1em">You can also have a more subtile
startup and shutdown behavior by using the hooks system that
will let you run arbitrary code before and after some
processes are started or <br>
stopped. See hooks.</p>

<p style="margin-top: 1em">Last but not least, you can also
add new commands. See addingcmds.</p>

<p style="margin-top: 1em">Developers Documentation Index
<br>
Circus Library <br>
The Circus package is composed of a high-level get_arbiter()
function and many classes. In most cases, using the
high-level function should be enough, as it creates
everything <br>
that is needed for Circus to run.</p>

<p style="margin-top: 1em">You can subclass Circus&rsquo;
classes if you need more granularity than what is offered by
the configuration.</p>

<p style="margin-top: 1em">The get_arbiter function <br>
get_arbiter() is just a convenience on top of the various
circus classes. It creates a arbiter (class Arbiter)
instance with the provided options, which in turn runs a
single <br>
Watcher with a single Process.</p>

<p style="margin-top: 1em">circus.get_arbiter()</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">from circus import
get_arbiter</p>

<p style="margin-top: 1em">arbiter =
get_arbiter([{&quot;cmd&quot;: &quot;myprogram&quot;,
&quot;numprocesses&quot;: 3}]) <br>
try: <br>
arbiter.start() <br>
finally: <br>
arbiter.stop()</p>

<p style="margin-top: 1em">Classes <br>
Circus provides a series of classes you can use to implement
your own process manager:</p>

<p style="margin-top: 1em">&Acirc;&middot; Process: wraps a
running process and provides a few helpers on top of it.</p>

<p style="margin-top: 1em">&Acirc;&middot; Watcher: run
several instances of Process against the same command.
Manage the death and life of processes.</p>

<p style="margin-top: 1em">&Acirc;&middot; Arbiter: manages
several Watcher.</p>

<p style="margin-top: 1em">class
circus.process.Process(name, wid, cmd, args=None,
working_dir=None, shell=False, uid=None, gid=None, env=None,
rlimits=None, executable=None, use_fds=False, watcher=None,
<br>
spawn=True, pipe_stdout=True, pipe_stderr=True,
close_child_stdout=False, close_child_stderr=False) <br>
Wraps a process.</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">&Acirc;&middot; wid: the process
unique identifier. This value will be used to replace the
$WID string in the command line if present.</p>

<p style="margin-top: 1em">&Acirc;&middot; cmd: the command
to run. May contain any of the variables available that are
being passed to this class. They will be replaced using the
python format syntax.</p>

<p style="margin-top: 1em">&Acirc;&middot; args: the
arguments for the command to run. Can be a list or a string.
If args is a string, it&rsquo;s splitted using
shlex.split(). Defaults to None.</p>

<p style="margin-top: 1em">&Acirc;&middot; executable: When
executable is given, the first item in the args sequence
obtained from cmd is still treated by most programs as the
command name, which can then be dif&acirc; <br>
ferent from the actual executable name. It becomes the
display name for the executing program in utilities such as
ps.</p>

<p style="margin-top: 1em">&Acirc;&middot; working_dir: the
working directory to run the command in. If not provided,
will default to the current working directory.</p>

<p style="margin-top: 1em">&Acirc;&middot; shell: if True,
will run the command in the shell environment. False by
default. warning: this is a security hazard.</p>

<p style="margin-top: 1em">&Acirc;&middot; uid: if given,
is the user id or name the command should run with. The
current uid is the default.</p>

<p style="margin-top: 1em">&Acirc;&middot; gid: if given,
is the group id or name the command should run with. The
current gid is the default.</p>

<p style="margin-top: 1em">&Acirc;&middot; env: a mapping
containing the environment variables the command will run
with. Optional.</p>

<p style="margin-top: 1em">&Acirc;&middot; rlimits: a
mapping containing rlimit names and values that will be set
before the command runs.</p>

<p style="margin-top: 1em">&Acirc;&middot; use_fds: if
True, will not close the fds in the subprocess. Must be be
set to True on Windows if stdout or stderr are redirected.
default: False.</p>

<p style="margin-top: 1em">&Acirc;&middot; pipe_stdout: if
True, will open a PIPE on stdout. default: True.</p>

<p style="margin-top: 1em">&Acirc;&middot; pipe_stderr: if
True, will open a PIPE on stderr. default: True.</p>

<p style="margin-top: 1em">&Acirc;&middot;
close_child_stdout: If True, redirects the child
process&rsquo; stdout to /dev/null after the fork. default:
False.</p>

<p style="margin-top: 1em">&Acirc;&middot;
close_child_stderr: If True, redirects the child
process&rsquo; stdout to /dev/null after the fork. default:
False.</p>

<p style="margin-top: 1em">age() Return the age of the
process in seconds.</p>

<p style="margin-top: 1em">children() <br>
Return a list of children pids.</p>

<p style="margin-top: 1em">info() Return process info.</p>

<p style="margin-top: 1em">The info returned is a mapping
with these keys:</p>

<p style="margin-top: 1em">&Acirc;&middot; mem_info1:
Resident Set Size Memory in bytes (RSS)</p>

<p style="margin-top: 1em">&Acirc;&middot; mem_info2:
Virtual Memory Size in bytes (VMS).</p>

<p style="margin-top: 1em">&Acirc;&middot; cpu: % of cpu
usage.</p>

<p style="margin-top: 1em">&Acirc;&middot; mem: % of memory
usage.</p>

<p style="margin-top: 1em">&Acirc;&middot; ctime: process
CPU (user + system) time in seconds.</p>

<p style="margin-top: 1em">&Acirc;&middot; pid: process
id.</p>

<p style="margin-top: 1em">&Acirc;&middot; username: user
name that owns the process.</p>

<p style="margin-top: 1em">&Acirc;&middot; nice: process
niceness (between -20 and 20)</p>

<p style="margin-top: 1em">&Acirc;&middot; cmdline: the
command line the process was run with.</p>

<p style="margin-top: 1em">is_child(pid) <br>
Return True is the given pid is a child of that process.</p>

<p style="margin-top: 1em">pid Return the pid</p>

<p style="margin-top: 1em">send_signal(*args, **kw) <br>
Sends a signal sig to the process.</p>

<p style="margin-top: 1em">send_signal_child(*args, **kw)
<br>
Send signal signum to child pid.</p>

<p style="margin-top: 1em">send_signal_children(*args,
**kw) <br>
Send signal signum to all children.</p>

<p style="margin-top: 1em">status Return the process status
as a constant</p>

<p style="margin-top: 1em">&Acirc;&middot; RUNNING</p>

<p style="margin-top: 1em">&Acirc;&middot;
DEAD_OR_ZOMBIE</p>

<p style="margin-top: 1em">&Acirc;&middot; UNEXISTING</p>

<p style="margin-top: 1em">&Acirc;&middot; OTHER</p>

<p style="margin-top: 1em">stderr Return the stdout
stream</p>

<p style="margin-top: 1em">stdout Return the stdout
stream</p>

<p style="margin-top: 1em">stop(*args, **kw) <br>
Stop the process and close stdout/stderr</p>

<p style="margin-top: 1em">If the corresponding process is
still here (normally it&rsquo;s already killed by the
watcher), a SIGTERM is sent, then a SIGKILL after 1
second.</p>

<p style="margin-top: 1em">The shutdown process (SIGTERM
then SIGKILL) is normally taken by the watcher. So if the
process is still there here, it&rsquo;s a kind of bad
behavior because the grace&acirc; <br>
ful timeout won&rsquo;t be respected here.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">&gt;&gt;&gt; from circus.process
import Process <br>
&gt;&gt;&gt; process = Process(&rsquo;Top&rsquo;,
&rsquo;top&rsquo;, shell=True) <br>
&gt;&gt;&gt; process.age() <br>
3.0107998847961426 <br>
&gt;&gt;&gt; process.info() <br>
&rsquo;Top: 6812 N/A tarek Zombie N/A N/A N/A N/A N/A&rsquo;
<br>
&gt;&gt;&gt; process.status <br>
1 <br>
&gt;&gt;&gt; process.stop() <br>
&gt;&gt;&gt; process.status <br>
2 <br>
&gt;&gt;&gt; process.info() <br>
&rsquo;No such process (stopped?)&rsquo;</p>

<p style="margin-top: 1em">class
circus.watcher.Watcher(name, cmd, args=None, numprocesses=1,
warmup_delay=0.0, working_dir=None, shell=False,
shell_args=None, uid=None, max_retry=5, gid=None, <br>
send_hup=False, stop_signal=15, stop_children=False,
env=None, graceful_timeout=30.0, prereload_fn=None,
rlimits=None, executable=None, stdout_stream=None,
stderr_stream=None, <br>
priority=0, loop=None, singleton=False, use_sockets=False,
copy_env=False, copy_path=False, max_age=0,
max_age_variance=30, hooks=None, respawn=True,
autostart=True, <br>
on_demand=False, virtualenv=None, close_child_stdout=False,
close_child_stderr=False, virtualenv_py_ver=None,
use_papa=False, **options) <br>
Class managing a list of processes for a given command.</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">&Acirc;&middot; name: name given
to the watcher. Used to uniquely identify it.</p>

<p style="margin-top: 1em">&Acirc;&middot; cmd: the command
to run. May contain $WID, which will be replaced by wid.</p>

<p style="margin-top: 1em">&Acirc;&middot; args: the
arguments for the command to run. Can be a list or a string.
If args is a string, it&rsquo;s splitted using
shlex.split(). Defaults to None.</p>

<p style="margin-top: 1em">&Acirc;&middot; numprocesses:
Number of processes to run.</p>

<p style="margin-top: 1em">&Acirc;&middot; working_dir: the
working directory to run the command in. If not provided,
will default to the current working directory.</p>

<p style="margin-top: 1em">&Acirc;&middot; shell: if True,
will run the command in the shell environment. False by
default. warning: this is a security hazard.</p>

<p style="margin-top: 1em">&Acirc;&middot; uid: if given,
is the user id or name the command should run with. The
current uid is the default.</p>

<p style="margin-top: 1em">&Acirc;&middot; gid: if given,
is the group id or name the command should run with. The
current gid is the default.</p>

<p style="margin-top: 1em">&Acirc;&middot; send_hup: if
True, a process reload will be done by sending the SIGHUP
signal. Defaults to False.</p>

<p style="margin-top: 1em">&Acirc;&middot; stop_signal: the
signal to send when stopping the process. Defaults to
SIGTERM.</p>

<p style="margin-top: 1em">&Acirc;&middot; stop_children:
send the stop_signal to the children too. Defaults to
False.</p>

<p style="margin-top: 1em">&Acirc;&middot; env: a mapping
containing the environment variables the command will run
with. Optional.</p>

<p style="margin-top: 1em">&Acirc;&middot; rlimits: a
mapping containing rlimit names and values that will be set
before the command runs.</p>

<p style="margin-top: 1em">&Acirc;&middot; stdout_stream: a
mapping that defines the stream for the process stdout.
Defaults to None.</p>

<p style="margin-top: 1em">Optional. When provided,
stdout_stream is a mapping containing up to three keys:</p>

<p style="margin-top: 1em">&Acirc;&middot; class: the
stream class. Defaults to circus.stream.FileStream</p>

<p style="margin-top: 1em">&Acirc;&middot; filename: the
filename, if using a FileStream</p>

<p style="margin-top: 1em">&Acirc;&middot; max_bytes:
maximum file size, after which a new output file is opened.
defaults to 0 which means no maximum size (only applicable
with FileStream).</p>

<p style="margin-top: 1em">&Acirc;&middot; backup_count:
how many backups to retain when rotating files according to
the max_bytes parameter. defaults to 0 which means no
backups are made (only applicable with <br>
FileStream)</p>

<p style="margin-top: 1em">This mapping will be used to
create a stream callable of the specified class. Each entry
received by the callable is a mapping containing:</p>

<p style="margin-top: 1em">&Acirc;&middot; pid - the
process pid</p>

<p style="margin-top: 1em">&Acirc;&middot; name - the
stream name (stderr or stdout)</p>

<p style="margin-top: 1em">&Acirc;&middot; data - the
data</p>

<p style="margin-top: 1em">This is not supported on
Windows.</p>

<p style="margin-top: 1em">&Acirc;&middot; stderr_stream: a
mapping that defines the stream for the process stderr.
Defaults to None.</p>

<p style="margin-top: 1em">Optional. When provided,
stderr_stream is a mapping containing up to three keys: -
class: the stream class. Defaults to
circus.stream.FileStream - filename: the file&acirc; <br>
name, if using a FileStream - max_bytes: maximum file size,
after which a new output file is <br>
opened. defaults to 0 which means no maximum size (only
applicable with FileStream)</p>

<p style="margin-top: 1em">&Acirc;&middot; backup_count:
how many backups to retain when rotating files according to
the max_bytes parameter. defaults to 0 which means no
backups are made (only applicable with <br>
FileStream).</p>

<p style="margin-top: 1em">This mapping will be used to
create a stream callable of the specified class.</p>

<p style="margin-top: 1em">Each entry received by the
callable is a mapping containing:</p>

<p style="margin-top: 1em">&Acirc;&middot; pid - the
process pid</p>

<p style="margin-top: 1em">&Acirc;&middot; name - the
stream name (stderr or stdout)</p>

<p style="margin-top: 1em">&Acirc;&middot; data - the
data</p>

<p style="margin-top: 1em">This is not supported on
Windows.</p>

<p style="margin-top: 1em">&Acirc;&middot; priority --
integer that defines a priority for the watcher. When the
Arbiter do some operations on all watchers, it will sort
them with this field, from the bigger num&acirc; <br>
ber to the smallest. (default: 0)</p>

<p style="margin-top: 1em">&Acirc;&middot; singleton -- If
True, this watcher has a single process. (default:False)</p>

<p style="margin-top: 1em">&Acirc;&middot; use_sockets --
If True, the processes will inherit the file descriptors,
thus can reuse the sockets opened by circusd. (default:
False)</p>

<p style="margin-top: 1em">&Acirc;&middot; on_demand -- If
True, the processes will be started only at the first
connection to the socket (default: False)</p>

<p style="margin-top: 1em">&Acirc;&middot; copy_env -- If
True, the environment in which circus is running run will be
reproduced for the workers. This defaults to True on Windows
as you cannot run any executable <br>
without the SYSTEMROOT variable. (default: False)</p>

<p style="margin-top: 1em">&Acirc;&middot; copy_path -- If
True, circusd sys.path is sent to the process through
PYTHONPATH. You must activate copy_env for copy_path to
work. (default: False)</p>

<p style="margin-top: 1em">&Acirc;&middot; max_age: If set
after around max_age seconds, the process is replaced with a
new one. (default: 0, Disabled)</p>

<p style="margin-top: 1em">&Acirc;&middot;
max_age_variance: The maximum number of seconds that can be
added to max_age. This extra value is to avoid restarting
all processes at the same time. A process will <br>
live between max_age and max_age + max_age_variance
seconds.</p>

<p style="margin-top: 1em">&Acirc;&middot; hooks: callback
functions for hooking into the watcher startup and shutdown
process. hooks is a dict where each key is the hook name and
each value is a 2-tuple with the <br>
name of the callable or the callabled itself and a boolean
flag indicating if an exception occuring in the hook should
not be ignored. Possible values for the hook <br>
name: before_start, after_start, before_spawn, after_spawn,
before_stop, after_stop., before_signal, after_signal or
extended_stats.</p>

<p style="margin-top: 1em">&Acirc;&middot; options -- extra
options for the worker. All options found in the
configuration file for instance, are passed in this mapping
-- this can be used by plugins for <br>
watcher-specific options.</p>

<p style="margin-top: 1em">&Acirc;&middot; respawn -- If
set to False, the processes handled by a watcher will not be
respawned automatically. (default: True)</p>

<p style="margin-top: 1em">&Acirc;&middot; virtualenv --
The root directory of a virtualenv. If provided, the watcher
will load the environment for its execution. (default:
None)</p>

<p style="margin-top: 1em">&Acirc;&middot;
close_child_stdout: If True, closes the stdout after the
fork. default: False.</p>

<p style="margin-top: 1em">&Acirc;&middot;
close_child_stderr: If True, closes the stderr after the
fork. default: False.</p>

<p style="margin-top: 1em">&Acirc;&middot; use_papa: If
True, use the papa process kernel for this process. default:
False.</p>

<p style="margin-top: 1em">kill_process(*args, **kwargs)
<br>
Kill process (stop_signal, graceful_timeout then
SIGKILL)</p>

<p style="margin-top: 1em">kill_processes(*args, **kwargs)
<br>
Kill all processes (stop_signal, graceful_timeout then
SIGKILL)</p>

<p style="margin-top: 1em">manage_processes(*args,
**kwargs) <br>
Manage processes.</p>

<p style="margin-top: 1em">notify_event(topic, msg) <br>
Publish a message on the event publisher channel</p>


<p style="margin-top: 1em">reap_and_manage_processes(*args,
**kwargs) <br>
Reap &amp; manage processes.</p>

<p style="margin-top: 1em">reap_processes(*args, **kw) <br>
Reap all the processes for this watcher.</p>

<p style="margin-top: 1em">send_signal_child(*args, **kw)
<br>
Send signal to a child.</p>


<p style="margin-top: 1em">spawn_process(recovery_wid=None)
<br>
Spawn process.</p>

<p style="margin-top: 1em">Return True if ok, False if the
watcher must be stopped</p>

<p style="margin-top: 1em">spawn_processes(*args, **kwargs)
<br>
Spawn processes.</p>

<p style="margin-top: 1em">class
circus.arbiter.Arbiter(watchers, endpoint, pubsub_endpoint,
check_delay=1.0, prereload_fn=None, context=None, loop=None,
statsd=False, stats_endpoint=None, <br>
statsd_close_outputs=False, multicast_endpoint=None,
plugins=None, sockets=None, warmup_delay=0, httpd=False,
httpd_host=&rsquo;localhost&rsquo;, httpd_port=8080,
httpd_close_outputs=False, <br>
debug=False, debug_gc=False, ssh_server=None,
proc_name=&rsquo;circusd&rsquo;, pidfile=None,
loglevel=None, logoutput=None, loggerconfig=None,
fqdn_prefix=None, umask=None, end&acirc; <br>
point_owner=None, papa_endpoint=None) <br>
Class used to control a list of watchers.</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">&Acirc;&middot; watchers -- a
list of Watcher objects</p>

<p style="margin-top: 1em">&Acirc;&middot; endpoint -- the
controller ZMQ endpoint</p>

<p style="margin-top: 1em">&Acirc;&middot; pubsub_endpoint
-- the pubsub endpoint</p>

<p style="margin-top: 1em">&Acirc;&middot; statsd -- If
True, a circusd-stats process is run (default: False)</p>

<p style="margin-top: 1em">&Acirc;&middot; stats_endpoint
-- the stats endpoint.</p>

<p style="margin-top: 1em">&Acirc;&middot;
statsd_close_outputs -- if True sends the circusd-stats
stdout/stderr to /dev/null (default: False)</p>

<p style="margin-top: 1em">&Acirc;&middot;
multicast_endpoint -- the multicast endpoint for circusd
cluster auto-discovery (default: udp://237.219.251.97:12027)
Multicast addr should be between 224.0.0.0 to <br>
239.255.255.255 and the same for the all cluster.</p>

<p style="margin-top: 1em">&Acirc;&middot; check_delay --
the delay between two controller points (default: 1 s)</p>

<p style="margin-top: 1em">&Acirc;&middot; prereload_fn --
callable that will be executed on each reload (default:
None)</p>

<p style="margin-top: 1em">&Acirc;&middot; context -- if
provided, the zmq context to reuse. (default: None)</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">loop: if provided, a
zmq.eventloop.ioloop.IOLoop instance <br>
to reuse. (default: None)</p>

<p style="margin-top: 1em">&Acirc;&middot; plugins -- a
list of plugins. Each item is a mapping with:</p>

<p style="margin-top: 1em">&Acirc;&middot; use -- Fully
qualified name that points to the plugin class</p>

<p style="margin-top: 1em">&Acirc;&middot; every other
value is passed to the plugin in the config option</p>

<p style="margin-top: 1em">&Acirc;&middot; sockets -- a
mapping of sockets. Each key is the socket name, and each
value a CircusSocket class. (default: None)</p>

<p style="margin-top: 1em">&Acirc;&middot; warmup_delay --
a delay in seconds between two watchers startup. (default:
0)</p>

<p style="margin-top: 1em">&Acirc;&middot; httpd -- If
True, a circushttpd process is run (default: False)</p>

<p style="margin-top: 1em">&Acirc;&middot; httpd_host --
the circushttpd host (default: localhost)</p>

<p style="margin-top: 1em">&Acirc;&middot; httpd_port --
the circushttpd port (default: 8080)</p>

<p style="margin-top: 1em">&Acirc;&middot;
httpd_close_outputs -- if True, sends circushttpd
stdout/stderr to /dev/null. (default: False)</p>

<p style="margin-top: 1em">&Acirc;&middot; debug -- if
True, adds a lot of debug info in the stdout (default:
False)</p>

<p style="margin-top: 1em">&Acirc;&middot; debug_gc -- if
True, does gc.set_debug(gc.DEBUG_LEAK) (default: False) to
circusd to analyze problems (default: False)</p>

<p style="margin-top: 1em">&Acirc;&middot; proc_name -- the
arbiter process name</p>

<p style="margin-top: 1em">&Acirc;&middot;</p>

<p style="margin-top: 1em">fqdn_prefix -- a prefix for the
unique identifier of the circus <br>
instance on the cluster.</p>

<p style="margin-top: 1em">&Acirc;&middot; endpoint_owner
-- unix user to chown the endpoint to if using ipc.</p>

<p style="margin-top: 1em">&Acirc;&middot; papa_endpoint --
the papa process kernel endpoint</p>

<p style="margin-top: 1em">add_watcher(*args, **kwargs)
<br>
Adds a watcher.</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">&Acirc;&middot; name: name of
the watcher to add</p>

<p style="margin-top: 1em">&Acirc;&middot; cmd: command to
run.</p>

<p style="margin-top: 1em">&Acirc;&middot; all other
options defined in the Watcher constructor.</p>

<p style="margin-top: 1em">get_watcher(name) <br>
Return the watcher name.</p>

<p style="margin-top: 1em">numprocesses() <br>
Return the number of processes running across all
watchers.</p>

<p style="margin-top: 1em">numwatchers() <br>
Return the number of watchers.</p>

<p style="margin-top: 1em">reload(*args, **kwargs) <br>
Reloads everything.</p>

<p style="margin-top: 1em">Run the prereload_fn() callable
if any, then gracefuly reload all watchers.</p>

<p style="margin-top: 1em">start(*args, **kwargs) <br>
Starts all the watchers.</p>

<p style="margin-top: 1em">If the ioloop has been provided
during __init__() call, starts all watchers as a standard
coroutine</p>

<p style="margin-top: 1em">If the ioloop hasn&rsquo;t been
provided during __init__() call (default), starts all
watchers and the eventloop (and blocks here). In this mode
the method MUST NOT yield <br>
anything because it&rsquo;s called as a standard method.</p>

<p style="margin-top: 1em">Parameters <br>
cb -- Callback called after all the watchers have been
started, when the loop hasn&rsquo;t been provided.</p>

<p style="margin-top: 1em">Writing plugins <br>
Circus comes with a plugin system which lets you interact
with circusd.</p>

<p style="margin-top: 1em">NOTE: <br>
We might add circusd-stats support to plugins later on.</p>

<p style="margin-top: 1em">A Plugin is composed of two
parts:</p>

<p style="margin-top: 1em">&Acirc;&middot; a ZMQ subscriber
to all events published by circusd</p>

<p style="margin-top: 1em">&Acirc;&middot; a ZMQ client to
send commands to circusd</p>

<p style="margin-top: 1em">Each plugin is run as a separate
process under a custom watcher.</p>

<p style="margin-top: 1em">A few examples of some plugins
you could create with this system:</p>

<p style="margin-top: 1em">&Acirc;&middot; a notification
system that sends e-mail alerts when a watcher is
flapping</p>

<p style="margin-top: 1em">&Acirc;&middot; a logger</p>

<p style="margin-top: 1em">&Acirc;&middot; a tool that adds
or removes processes depending on the load</p>

<p style="margin-top: 1em">&Acirc;&middot; etc.</p>

<p style="margin-top: 1em">Circus itself comes with a few
built-in plugins.</p>

<p style="margin-top: 1em">The CircusPlugin class <br>
Circus provides a base class to help you implement plugins:
circus.plugins.CircusPlugin</p>

<p style="margin-top: 1em">class
circus.plugins.CircusPlugin(endpoint, pubsub_endpoint,
check_delay, ssh_server=None, **config) <br>
Base class to write plugins.</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">&Acirc;&middot; context -- the
ZMQ context to use</p>

<p style="margin-top: 1em">&Acirc;&middot; endpoint -- the
circusd ZMQ endpoint</p>

<p style="margin-top: 1em">&Acirc;&middot; pubsub_endpoint
-- the circusd ZMQ pub/sub endpoint</p>

<p style="margin-top: 1em">&Acirc;&middot; check_delay --
the configured check delay</p>

<p style="margin-top: 1em">&Acirc;&middot; config -- free
config mapping</p>

<p style="margin-top: 1em">call(command, **props) <br>
Sends the command to circusd</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">&Acirc;&middot; command -- the
command to call</p>

<p style="margin-top: 1em">&Acirc;&middot; props -- keyword
arguments to add to the call</p>

<p style="margin-top: 1em">Returns the JSON mapping sent
back by circusd</p>

<p style="margin-top: 1em">cast(command, **props) <br>
Fire-and-forget a command to circusd</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">&Acirc;&middot; command -- the
command to call</p>

<p style="margin-top: 1em">&Acirc;&middot; props -- keyword
arguments to add to the call</p>

<p style="margin-top: 1em">handle_init() <br>
Called right before a plugin is started - in the thread
context.</p>

<p style="margin-top: 1em">handle_recv(data) <br>
Receives every event published by circusd</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">&Acirc;&middot; data -- a tuple
containing the topic and the message.</p>

<p style="margin-top: 1em">handle_stop() <br>
Called right before the plugin is stopped by Circus.</p>

<p style="margin-top: 1em">When initialized by Circus, this
class creates its own event loop that receives all circusd
events and pass them to handle_recv(). The data received is
a tuple containing the <br>
topic and the data itself.</p>

<p style="margin-top: 1em">handle_recv() must be
implemented by the plugin.</p>

<p style="margin-top: 1em">The call() and cast() methods
can be used to interact with circusd if you are building a
Plugin that actively interacts with the daemon.</p>

<p style="margin-top: 1em">handle_init() and handle_stop()
are just convenience methods you can use to initialize and
clean up your code. handle_init() is called within the
thread that just started. han&acirc; <br>
dle_stop() is called in the main thread just before the
thread is stopped and joined.</p>

<p style="margin-top: 1em">Writing a plugin <br>
Let&rsquo;s write a plugin that logs in a file every event
happening in circusd. It takes one argument which is the
filename.</p>

<p style="margin-top: 1em">The plugin may look like
this:</p>

<p style="margin-top: 1em">from circus.plugins import
CircusPlugin</p>

<p style="margin-top: 1em">class Logger(CircusPlugin):</p>

<p style="margin-top: 1em">name = &rsquo;logger&rsquo;</p>

<p style="margin-top: 1em">def __init__(self, *args,
**config): <br>
super(Logger, self).__init__(*args, **config) <br>
self.filename = config.get(&rsquo;filename&rsquo;) <br>
self.file = None</p>

<p style="margin-top: 1em">def handle_init(self): <br>
self.file = open(self.filename, &rsquo;a+&rsquo;,
buffering=1)</p>

<p style="margin-top: 1em">def handle_stop(self): <br>
self.file.close()</p>

<p style="margin-top: 1em">def handle_recv(self, data):
<br>
watcher_name, action, msg = self.split_data(data) <br>
msg_dict = self.load_message(msg) <br>
self.file.write(&rsquo;%s %s::%r0 % (action, watcher_name,
msg_dict))</p>

<p style="margin-top: 1em">That&rsquo;s it ! This class can
be saved in any package/module, as long as it can be seen by
Python.</p>

<p style="margin-top: 1em">For example, Logger may be found
in a plugins module within a myproject package.</p>

<p style="margin-top: 1em">Async requests <br>
In case you want to make any asynchronous operations (like a
Tornado call or using periodicCall) make sure you are using
the right loop. The loop you always want to be using is <br>
self.loop as it gets set up by the base class. The default
loop often isn&rsquo;t the same and therefore code might not
get executed as expected.</p>

<p style="margin-top: 1em">Trying a plugin <br>
You can run a plugin through the command line with the
circus-plugin command, by specifying the plugin fully
qualified name:</p>

<p style="margin-top: 1em">$ circus-plugin --endpoint
tcp://127.0.0.1:5555 --pubsub tcp://127.0.0.1:5556 --config
filename:circus-events.log myproject.plugins.Logger <br>
[INFO] Loading the plugin... <br>
[INFO] Endpoint: &rsquo;tcp://127.0.0.1:5555&rsquo; <br>
[INFO] Pub/sub: &rsquo;tcp://127.0.0.1:5556&rsquo; <br>
[INFO] Starting</p>

<p style="margin-top: 1em">Another way to run a plugin is
to let Circus handle its initialization. This is done by
adding a [plugin:NAME] section in the configuration file,
where NAME is a unique name for <br>
your plugin:</p>

<p style="margin-top: 1em">[plugin:logger] <br>
use = myproject.plugins.Logger <br>
filename = /var/myproject/circus.log</p>

<p style="margin-top: 1em">use is mandatory and points to
the fully qualified name of the plugin.</p>

<p style="margin-top: 1em">When Circus starts, it creates a
watcher with one process that runs the pointed class, and
pass any other variable contained in the section to the
plugin constructor via the con&acirc; <br>
fig mapping.</p>

<p style="margin-top: 1em">You can also programmatically
add plugins when you create a circus.arbiter.Arbiter class
or use circus.get_arbiter(), see library.</p>

<p style="margin-top: 1em">Performances <br>
Since every plugin is loaded in its own process, it should
not impact the overall performances of the system as long as
the work done by the plugin is not doing too many calls to
<br>
the circusd process.</p>

<p style="margin-top: 1em">Hooks <br>
Circus provides hooks that can be used to trigger actions
upon watcher events. Available hooks are:</p>

<p style="margin-top: 1em">&Acirc;&middot; before_start:
called before the watcher is started. If the hook returns
False the startup is aborted.</p>

<p style="margin-top: 1em">&Acirc;&middot; after_start:
called after the watcher is started. If the hook returns
False the watcher is immediately stopped and the startup is
aborted.</p>

<p style="margin-top: 1em">&Acirc;&middot; before_spawn:
called before the watcher spawns a new process. If the hook
returns False the watcher is immediately stopped and the
startup is aborted.</p>

<p style="margin-top: 1em">&Acirc;&middot; after_spawn:
called after the watcher spawns a new process. If the hook
returns False the watcher is immediately stopped and the
startup is aborted.</p>

<p style="margin-top: 1em">&Acirc;&middot; before_stop:
called before the watcher is stopped. The hook result is
ignored.</p>

<p style="margin-top: 1em">&Acirc;&middot; after_stop:
called after the watcher is stopped. The hook result is
ignored.</p>

<p style="margin-top: 1em">&Acirc;&middot; before_signal:
called before a signal is sent to a watcher&rsquo;s process.
If the hook returns False the signal is not sent (except
SIGKILL which is always sent)</p>

<p style="margin-top: 1em">&Acirc;&middot; after_signal:
called after a signal is sent to a watcher&rsquo;s
process.</p>

<p style="margin-top: 1em">&Acirc;&middot; extended_stats:
called when stats are requested with extended=True. Used for
adding process-specific stats to the regular stats
output.</p>

<p style="margin-top: 1em">Example <br>
A typical use case is to control that all the conditions are
met for a process to start. Let&rsquo;s say you have a
watcher that runs Redis and a watcher that runs a Python
script <br>
that works with Redis. With Circus you can order the startup
by using the priority option:</p>

<p style="margin-top: 1em">[watcher:queue-worker] <br>
cmd = python -u worker.py <br>
priority = 1</p>

<p style="margin-top: 1em">[watcher:redis] <br>
cmd = redis-server <br>
priority = 2</p>

<p style="margin-top: 1em">With this setup, Circus will
start Redis first and then it will start the queue worker.
But Circus does not really control that Redis is up and
running. It just starts the <br>
process it was asked to start. What we miss here is a way to
control that Redis is started and fully functional. A
function that controls this could be:</p>

<p style="margin-top: 1em">import redis <br>
import time</p>

<p style="margin-top: 1em">def check_redis(*args, **kw):
<br>
time.sleep(.5) # give it a chance to start <br>
r = redis.StrictRedis(host=&rsquo;localhost&rsquo;,
port=6379, db=0) <br>
r.set(&rsquo;foo&rsquo;, &rsquo;bar&rsquo;) <br>
return r.get(&rsquo;foo&rsquo;) == &rsquo;bar&rsquo;</p>

<p style="margin-top: 1em">This function can be plugged
into Circus as an before_start hook:</p>

<p style="margin-top: 1em">[watcher:queue-worker] <br>
cmd = python -u worker.py <br>
hooks.before_start = mycoolapp.myplugins.check_redis <br>
priority = 1</p>

<p style="margin-top: 1em">[watcher:redis] <br>
cmd = redis-server <br>
priority = 2</p>

<p style="margin-top: 1em">Once Circus has started the
redis watcher, it will start the queue-worker watcher, since
it follows the priority ordering. Just before starting the
second watcher, it will run <br>
the check_redis function, and in case it returns False will
abort the watcher starting process.</p>

<p style="margin-top: 1em">Hook signature <br>
A hook must follow this signature:</p>

<p style="margin-top: 1em">def hook(watcher, arbiter,
hook_name, **kwargs): <br>
... <br>
# If you don&rsquo;t return True, the hook can change <br>
# the behavior of circus (depending on the hook) <br>
return True</p>

<p style="margin-top: 1em">Where watcher is the Watcher
class instance, arbiter the Arbiter one, hook_name the hook
name and kwargs some additional optional parameters
(depending on the hook type).</p>

<p style="margin-top: 1em">The after_spawn hook adds the
pid parameters:</p>

<p style="margin-top: 1em">def after_spawn(watcher,
arbiter, hook_name, pid, **kwargs): <br>
... <br>
# If you don&rsquo;t return True, circus will kill the
process <br>
return True</p>

<p style="margin-top: 1em">Where pid is the PID of the
corresponding process.</p>

<p style="margin-top: 1em">Likewise, before_signal and
after_signal hooks add pid and signum:</p>

<p style="margin-top: 1em">def before_signal_hook(watcher,
arbiter, hook_name, pid, signum, **kwargs): <br>
... <br>
# If you don&rsquo;t return True, circus won&rsquo;t send
the signum signal <br>
# (SIGKILL is always sent) <br>
return True</p>

<p style="margin-top: 1em">Where pid is the PID of the
corresponding process and signum is the corresponding
signal.</p>

<p style="margin-top: 1em">You can ignore those but being
able to use the watcher and/or arbiter data and methods can
be useful in some hooks.</p>

<p style="margin-top: 1em">Note that hooks are called with
named arguments. So use the hook signature without changing
argument names.</p>

<p style="margin-top: 1em">The extended_stats hook has its
own additional parameters in kwargs:</p>

<p style="margin-top: 1em">def extended_stats_hook(watcher,
arbiter, hook_name, pid, stats, **kwargs): <br>
...</p>

<p style="margin-top: 1em">Where pid is the PID of the
corresponding process and stats the regular stats to be
returned. Add your own stats into stats. An example is in
examples/uwsgi_lossless_reload.py.</p>

<p style="margin-top: 1em">As a last example, here is a
super hook which can deal with all kind of signals:</p>

<p style="margin-top: 1em">def super_hook(watcher, arbiter,
hook_name, **kwargs): <br>
pid = None <br>
signum = None <br>
if hook_name in (&rsquo;before_signal&rsquo;,
&rsquo;after_signal&rsquo;): <br>
pid = kwargs[&rsquo;pid&rsquo;] <br>
signum = kwargs[&rsquo;signum&rsquo;] <br>
... <br>
return True</p>

<p style="margin-top: 1em">Hook events <br>
Everytime a hook is run, its result is notified as an event
in Circus.</p>

<p style="margin-top: 1em">There are two events related to
hooks:</p>

<p style="margin-top: 1em">&Acirc;&middot; hook_success: a
hook was successfully called. The event keys are name the
name if the event, and time: the date of the events.</p>

<p style="margin-top: 1em">&Acirc;&middot; hook_failure: a
hook has failed. The event keys are name the name if the
event, time: the date of the events and error: the exception
that occurred in the event, if any.</p>

<p style="margin-top: 1em">Adding new commands <br>
We tried to make adding new commands as simple as
possible.</p>

<p style="margin-top: 1em">You need to do three things:</p>

<p style="margin-top: 1em">1. create a your_command.py file
under circus/commands/.</p>

<p style="margin-top: 1em">2. Implement a single class in
there, with predefined methods</p>

<p style="margin-top: 1em">3. Add the new command in
circus/commands/__init__.py.</p>

<p style="margin-top: 1em">Let&rsquo;s say we want to add a
command which returns the number of watchers currently in
use, we would do something like this (extensively commented
to allow you to follow more eas&acirc; <br>
ily):</p>

<p style="margin-top: 1em">from circus.commands.base import
Command <br>
from circus.exc import ArgumentError, MessageError <br>
class NumWatchers(Command): <br>
&quot;&quot;&quot;It is a good practice to describe what the
class does here.</p>

<p style="margin-top: 1em">Have a look at other commands to
see how we are used to format <br>
this text. It will be automatically included in the
documentation, <br>
so don&rsquo;t be affraid of being exhaustive, that&rsquo;s
what it is made <br>
for. <br>
&quot;&quot;&quot; <br>
# all the commands inherit from
&lsquo;circus.commands.base.Command&lsquo;</p>

<p style="margin-top: 1em"># you need to specify a name so
we find back the command somehow <br>
name = &quot;numwatchers&quot;</p>

<p style="margin-top: 1em"># Set waiting to True or False
to define your default behavior <br>
# - If waiting is True, the command is run synchronously,
and the client may get <br>
# back results. <br>
# - If waiting is False, the command is run asynchronously
on the server and the client immediately <br>
# gets back an &rsquo;ok&rsquo; response <br>
# <br>
# By default, commands are set to waiting = False <br>
waiting = True</p>

<p style="margin-top: 1em"># options <br>
options = [(&rsquo;&rsquo;, &rsquo;optname&rsquo;,
default_value, &rsquo;description&rsquo;)]</p>

<p style="margin-top: 1em">properties = [&rsquo;foo&rsquo;,
&rsquo;bar&rsquo;] <br>
# properties list the command arguments that are mandatory.
If they are <br>
# not provided, then an error will be thrown</p>

<p style="margin-top: 1em">def execute(self, arbiter,
props): <br>
# the execute method is the core of the command: put here
all the <br>
# logic of the command and return a dict containing the
values you <br>
# want to return, if any <br>
return {&quot;numwatchers&quot;: arbiter.numwatchers()}</p>

<p style="margin-top: 1em">def console_msg(self, msg): <br>
# msg is what is returned by the execute method. <br>
# this method is used to format the response for a console
(it is <br>
# used for instance by circusctl to print its messages) <br>
return &quot;a string that will be displayed&quot;</p>

<p style="margin-top: 1em">def message(self, *args,
**opts): <br>
# message handles console input. <br>
# this method is used to map console arguments to the
command <br>
# options. (its is used for instance when calling the
command via <br>
# circusctl) <br>
# NotImplementedError will be thrown if the function is
missing <br>
numArgs = 1 <br>
if not len(args) == numArgs: <br>
raise ArgumentError(&rsquo;Invalid number of
arguments.&rsquo;) <br>
else: <br>
opts[&rsquo;optname&rsquo;] = args[0] <br>
return self.make_message(**opts)</p>

<p style="margin-top: 1em">def validate(self, props): <br>
# this method is used to validate that the arguments passed
to the <br>
# command are correct. An ArgumentError should be thrown in
case <br>
# there is an error in the passed arguments (for instance if
they <br>
# do not match together. <br>
# In case there is a problem wrt their content, a
MessageError <br>
# should be thrown. This method can modify the content of
the props <br>
# dict, it will be passed to execute afterwards.</p>

<p style="margin-top: 1em">Use cases examples <br>
This chapter presents a few use cases, to give you an idea
on how to use Circus in your environment.</p>

<p style="margin-top: 1em">Running a WSGI application <br>
Running a WSGI application with Circus is quite interesting
because you can watch &amp; manage your web workers using
circus-top, circusctl or the Web interface.</p>

<p style="margin-top: 1em">This is made possible by using
Circus sockets. See whycircussockets.</p>

<p style="margin-top: 1em">Let&rsquo;s take an example with
a minimal Pyramid application:</p>

<p style="margin-top: 1em">from pyramid.config import
Configurator <br>
from pyramid.response import Response</p>

<p style="margin-top: 1em">def hello_world(request): <br>
return Response(&rsquo;Hello %(name)s!&rsquo; %
request.matchdict)</p>

<p style="margin-top: 1em">config = Configurator() <br>
config.add_route(&rsquo;hello&rsquo;,
&rsquo;/hello/{name}&rsquo;) <br>
config.add_view(hello_world, route_name=&rsquo;hello&rsquo;)
<br>
application = config.make_wsgi_app()</p>

<p style="margin-top: 1em">Save this script into an app.py
file, then install those projects:</p>

<p style="margin-top: 1em">$ pip install Pyramid <br>
$ pip install chaussette</p>

<p style="margin-top: 1em">Next, make sure you can run your
Pyramid application using the chaussette console script:</p>

<p style="margin-top: 1em">$ chaussette app.application
<br>
Application is &lt;pyramid.router.Router object at
0x10a4d4bd0&gt; <br>
Serving on localhost:8080 <br>
Using &lt;class
&rsquo;chaussette.backend._waitress.Server&rsquo;&gt; as a
backend</p>

<p style="margin-top: 1em">And check that you can reach it
by visiting http://localhost:8080/hello/tarek</p>

<p style="margin-top: 1em">Now that your application is up
and running, let&rsquo;s create a Circus configuration
file:</p>

<p style="margin-top: 1em">[circus] <br>
check_delay = 5 <br>
endpoint = tcp://127.0.0.1:5555 <br>
pubsub_endpoint = tcp://127.0.0.1:5556 <br>
stats_endpoint = tcp://127.0.0.1:5557</p>

<p style="margin-top: 1em">[watcher:webworker] <br>
cmd = chaussette --fd $(circus.sockets.webapp)
app.application <br>
use_sockets = True <br>
numprocesses = 3</p>

<p style="margin-top: 1em">[socket:webapp] <br>
host = 127.0.0.1 <br>
port = 8080</p>

<p style="margin-top: 1em">This file tells Circus to bind a
socket on port 8080 and run chaussette workers on that
socket -- by passing its fd.</p>

<p style="margin-top: 1em">Save it to server.ini and try to
run it using circusd</p>

<p style="margin-top: 1em">$ circusd server.ini <br>
[INFO] Starting master on pid 8971 <br>
[INFO] sockets started <br>
[INFO] circusd-stats started <br>
[INFO] webapp started <br>
[INFO] Arbiter now waiting for commands</p>

<p style="margin-top: 1em">Make sure you still get the app
on http://localhost:8080/hello/tarek.</p>

<p style="margin-top: 1em">Congrats ! you have a WSGI
application running 3 workers.</p>

<p style="margin-top: 1em">You can run the circushttpd or
the cli, and enjoy Circus management.</p>

<p style="margin-top: 1em">Running a Django application
<br>
Running a Django application is done exactly like running a
WSGI application. Use the PYTHONPATH to import the directory
the project is in, the directory that contains the
direc&acirc; <br>
tory that has settings.py in it (with Django 1.4+ this
directory has manage.py in it) :</p>

<p style="margin-top: 1em">[socket:dwebapp] <br>
host = 127.0.0.1 <br>
port = 8080</p>

<p style="margin-top: 1em">[watcher:dwebworker] <br>
cmd = chaussette --fd $(circus.sockets.dwebapp)
dproject.wsgi.application <br>
use_sockets = True <br>
numprocesses = 2</p>

<p style="margin-top: 1em">[env:dwebworker] <br>
PYTHONPATH = /path/to/parent-of-dproject</p>

<p style="margin-top: 1em">If you need to pass the
DJANGO_SETTINGS_MODULE for a backend worker for example, you
can pass that also though the env configation option:</p>

<p style="margin-top: 1em">[watcher:dbackend] <br>
cmd = /path/to/script.py <br>
numprocesses=3</p>

<p style="margin-top: 1em">[env:dbackend] <br>
PYTHONPATH = /path/to/parent-of-dproject <br>
DJANGO_SETTINGS_MODULE=dproject.settings</p>

<p style="margin-top: 1em">See
http://chaussette.readthedocs.org for more about
chaussette.</p>

<p style="margin-top: 1em">Design decisions <br>
Overall architecture <br>
[image]</p>

<p style="margin-top: 1em">Circus is composed of a main
process called circusd which takes care of running all the
processes. Each process managed by Circus is a child process
of circusd.</p>

<p style="margin-top: 1em">Processes are organized in
groups called watchers. A watcher is basically a command
circusd runs on your system, and for each command you can
configure how many processes you <br>
want to run.</p>

<p style="margin-top: 1em">The concept of watcher is useful
when you want to manage all the processes running the same
command -- like restart them, etc.</p>

<p style="margin-top: 1em">circusd binds two ZeroMQ
sockets:</p>

<p style="margin-top: 1em">&Acirc;&middot; REQ/REP -- a
socket used to control circusd using json-based
commands.</p>

<p style="margin-top: 1em">&Acirc;&middot; PUB/SUB -- a
socket where circusd publishes events, like when a process
is started or stopped.</p>

<p style="margin-top: 1em">NOTE: <br>
Despite its name, ZeroMQ is not a queue management system.
Think of it as an inter-process communication (IPC)
library.</p>

<p style="margin-top: 1em">Another process called
circusd-stats is run by circusd when the option is
activated. circusd-stats&rsquo;s job is to publish
CPU/Memory usage statistics in a dedicated PUB/SUB
channel.</p>

<p style="margin-top: 1em">This specialized channel is used
by circus-top and circus-httpd to display a live stream of
the activity.</p>

<p style="margin-top: 1em">circus-top is a console script
that mimics top to display all the CPU and Memory usage of
the processes managed by Circus.</p>

<p style="margin-top: 1em">circus-httpd is the web
managment interface that will let you interact with Circus.
It displays a live stream using web sockets and the
circusd-stats channel, but also let you <br>
interact with circusd via its REQ/REP channel.</p>

<p style="margin-top: 1em">Last but not least, circusctl is
a command-line tool that let you drive circusd via its
REQ/REP channel.</p>

<p style="margin-top: 1em">You can also have plugins that
subscribe to circusd&rsquo;s PUB/SUB channel and let you
send commands to the REQ/REP channel like circusctl
would.</p>

<p style="margin-top: 1em">Security <br>
Circus is built on the top of the ZeroMQ library and comes
with no security at all in its protocols. However, you can
run a Circus system on a server and set up an SSH tunnel to
<br>
access it from another machine.</p>

<p style="margin-top: 1em">This section explains what
Circus does on your system when you run it, and ends up
describing how to use an SSH tunnel.</p>

<p style="margin-top: 1em">You can also read
http://www.zeromq.org/area:faq#toc5</p>

<p style="margin-top: 1em">TCP ports <br>
By default, Circus opens the following TCP ports on the
local host:</p>

<p style="margin-top: 1em">&Acirc;&middot; 5555 -- the port
used to control circus via circusctl</p>

<p style="margin-top: 1em">&Acirc;&middot; 5556 -- the port
used for the Publisher/Subscriber channel.</p>

<p style="margin-top: 1em">&Acirc;&middot; 5557 -- the port
used for the statistics channel -- if activated.</p>

<p style="margin-top: 1em">&Acirc;&middot; 8080 -- the port
used by the Web UI -- if activated.</p>

<p style="margin-top: 1em">These ports allow client apps to
interact with your Circus system, and depending on how your
infrastructure is organized, you may want to protect these
ports via firewalls or <br>
configure Circus to run using IPC ports.</p>

<p style="margin-top: 1em">Here&rsquo;s an example of
running Circus using only IPC entry points:</p>

<p style="margin-top: 1em">[circus] <br>
check_delay = 5 <br>
endpoint = ipc:///var/circus/endpoint <br>
pubsub_endpoint = ipc:///var/circus/pubsub <br>
stats_endpoint = ipc:///var/circus/stats</p>

<p style="margin-top: 1em">When Configured using IPC, the
commands must be run from the same box, but no one can
access them from outside, unlike using TCP. The commands
must also be run as a user that has <br>
write access to the ipc socket paths. You can modify the
owner of the endpoint using the endpoint_owner config
option. This allows you to run circusd as the root user, but
allow <br>
non-root processes to send commands to circusd. Note that
when using endpoint_owner, in order to prevent non-root
processes from being able to start arbitrary processes that
run <br>
with greater privileges, the add command will enforce that
new Watchers must run as the endpoint_owner user. Watcher
definitions in the local config files will not be restricted
<br>
this way.</p>

<p style="margin-top: 1em">Of course, if you activate the
Web UI, the 8080 port will still be open.</p>

<p style="margin-top: 1em">circushttpd <br>
When you run circushttpd manually, or when you use the httpd
option in the ini file like this:</p>

<p style="margin-top: 1em">[circus] <br>
check_delay = 5 <br>
endpoint = ipc:///var/circus/endpoint <br>
pubsub_endpoint = ipc:///var/circus/pubsub <br>
stats_endpoint = ipc:///var/circus/stats <br>
httpd = 1</p>

<p style="margin-top: 1em">The web application will run on
port 8080 and will let anyone accessing the web page manage
the circusd daemon.</p>

<p style="margin-top: 1em">That includes creating new
watchers that can run any command on your system !</p>

<p style="margin-top: 1em">Do not make it publicly
available</p>

<p style="margin-top: 1em">If you want to protect the
access to the web panel, you can serve it behind Nginx or
Apache or any proxy-capable web server, that can take care
of the security.</p>

<p style="margin-top: 1em">User and Group Permissions <br>
By default, all processes started with Circus will be
running with the same user and group as circusd. Depending
on the privileges the user has on the system, you may not
have <br>
access to all the features Circus provides.</p>

<p style="margin-top: 1em">For instance, some statistics
features on a running processes require extended privileges.
Typically, if the CPU usage numbers you get using the stats
command are N/A, it means <br>
your user can&rsquo;t access the proc files. This will be
the case by default under Mac OS X.</p>

<p style="margin-top: 1em">You may run circusd as root to
fix this, and set the uid and gid values for each watcher to
get all the features.</p>

<p style="margin-top: 1em">But beware that running circusd
as root exposes you to potential privilege escalation bugs.
While we&rsquo;re doing our best to avoid any bugs, running
as root and facing a bug that <br>
performs unwanted actions on your system may be
dangerous.</p>

<p style="margin-top: 1em">The best way to prevent this is
to make sure that the system running Circus is completely
isolated (like a VM) or to run the whole system under a
controlled user.</p>

<p style="margin-top: 1em">SSH tunneling <br>
Clients can connect to a circusd instance by creating an SSH
tunnel. To do so, pass the command line option --ssh
followed by user@address, where user is the user on the
remote <br>
server and address is the server&rsquo;s address as seen by
the client. The SSH protocol will require credentials to
complete the login.</p>

<p style="margin-top: 1em">If circusd as seen by the SSH
server is not at the default endpoint address localhost:5555
then specify the circusd address using the option
--endpoint</p>

<p style="margin-top: 1em">Secured setup example <br>
Setting up a secured Circus server can be done by:</p>

<p style="margin-top: 1em">&Acirc;&middot; Running an SSH
Server</p>

<p style="margin-top: 1em">&Acirc;&middot; Running Apache
or Nginx on the 80 port, and doing a reverse-proxy on the
8080 port.</p>

<p style="margin-top: 1em">&Acirc;&middot; Blocking the
8080 port from outside access.</p>

<p style="margin-top: 1em">&Acirc;&middot; Running all ZMQ
Circusd ports using IPC files instead of TCP ports, and
tunneling all calls via SSH. <br>
[image]</p>

<p style="margin-top: 1em">Contributing to Circus <br>
Circus has been started at Mozilla but its goal is not to
stay only there. We&rsquo;re trying to build a tool
that&rsquo;s useful for others, and easily extensible.</p>

<p style="margin-top: 1em">We really are open to any
contributions, in the form of code, documentation,
discussions, feature proposal etc.</p>

<p style="margin-top: 1em">You can start a topic in our
mailing list :
http://tech.groups.yahoo.com/group/circus-dev/</p>

<p style="margin-top: 1em">Or add an issue in our bug
tracker</p>

<p style="margin-top: 1em">Fixing typos and enhancing the
documentation <br>
It&rsquo;s totally possible that your eyes are bleeding
while reading this half-english half-french documentation,
don&rsquo;t hesitate to contribute any rephrasing /
enhancement on the form <br>
in the documentation. You probably don&rsquo;t even need to
understand how Circus works under the hood to do that.</p>

<p style="margin-top: 1em">Adding new features <br>
New features are of course very much appreciated. If you
have the need and the time to work on new features, adding
them to Circus shouldn&rsquo;t be that complicated. We tried
very <br>
hard to have a clean and understandable API, hope it serves
the purpose.</p>

<p style="margin-top: 1em">You will need to add
documentation and tests alongside with the code of the new
feature. Otherwise we&rsquo;ll not be able to accept the
patch.</p>

<p style="margin-top: 1em">How to submit your changes <br>
We&rsquo;re using git as a DVCS. The best way to propose
changes is to create a branch on your side (via git checkout
-b branchname) and commit your changes there. Once you have
some&acirc; <br>
thing ready for prime-time, issue a pull request against
this branch.</p>

<p style="margin-top: 1em">We are following this model to
allow to have low coupling between the features you are
proposing. For instance, we can accept one pull request
while still being in discussion for <br>
another one.</p>

<p style="margin-top: 1em">Before proposing your changes,
double check that they are not breaking anything! You can
use the tox command to ensure this, it will run the
testsuite under the different sup&acirc; <br>
ported python versions.</p>

<p style="margin-top: 1em">Please use :
http://issue2pr.herokuapp.com/ to reference a commit to an
existing circus issue, if any.</p>

<p style="margin-top: 1em">Avoiding merge commits <br>
Avoiding merge commits allows to have a clean and readable
history. To do so, instead of doing &quot;git pull&quot; and
letting git handling the merges for you, using git pull
--rebase <br>
will put your changes after the changes that are commited in
the branch, or when working on master.</p>

<p style="margin-top: 1em">That is, for us core developers,
it&rsquo;s not possible anymore to use the handy github
green button on pull requests if developers didn&rsquo;t
rebased their work themselves or if we wait <br>
too much time between the request and the actual merge.
Instead, the flow looks like this:</p>

<p style="margin-top: 1em">git remote add name repo-url
<br>
git fetch name <br>
git checkout feature-branch <br>
git rebase master</p>

<p style="margin-top: 1em"># check that everything is
working properly and then merge on master <br>
git checkout master <br>
git merge feature-branch</p>

<p style="margin-top: 1em">Discussing <br>
If you find yourself in need of any help while looking at
the code of Circus, you can go and find us on irc at
#circus-tent on irc.freenode.org (or if you don&rsquo;t have
any IRC <br>
client, use the webchat)</p>

<p style="margin-top: 1em">You can also start a thread in
our mailing list -
http://tech.groups.yahoo.com/group/circus-dev</p>

<p style="margin-top: 1em">Frequently Asked Questions <br>
Here is a list of frequently asked questions about
Circus:</p>

<p style="margin-top: 1em">How does Circus stack compare to
a classical stack? <br>
In a classical WSGI stack, you have a server like Gunicorn
that serves on a port or an unix socket and is usually
deployed behind a web server like Nginx: [image]</p>

<p style="margin-top: 1em">Clients call Nginx, which
reverse proxies all the calls to Gunicorn.</p>

<p style="margin-top: 1em">If you want to make sure the
Gunicorn process stays up and running, you have to use a
program like Supervisord or upstart.</p>

<p style="margin-top: 1em">Gunicorn in turn watches for its
processes (&quot;workers&quot;).</p>

<p style="margin-top: 1em">In other words you are using two
levels of process managment. One that you manage and control
(supervisord), and a second one that you have to manage in a
different UI, with a <br>
different philosophy and less control over what&rsquo;s
going on (the wsgi server&rsquo;s one)</p>

<p style="margin-top: 1em">This is true for Gunicorn and
most multi-processes WSGI servers out there I know about.
uWsgi is a bit different as it offers plethoras of
options.</p>

<p style="margin-top: 1em">But if you want to add a Redis
server in your stack, you will end up with managing your
stack processes in two different places.</p>

<p style="margin-top: 1em">Circus&rsquo; approach on this
is to manage processes and sockets.</p>

<p style="margin-top: 1em">A Circus stack can look like
this: [image]</p>

<p style="margin-top: 1em">So, like Gunicorn, Circus is
able to bind a socket that will be proxied by Nginx. Circus
don&rsquo;t deal with the requests but simply binds the
socket. It&rsquo;s then up to a web worker <br>
process to accept connections on the socket and do the
work.</p>

<p style="margin-top: 1em">It provides equivalent features
than Supervisord but will also let you manage all processes
at the same level, wether they are web workers or Redis or
whatever. Adding a new web <br>
worker is done exactly like adding a new Redis process.</p>

<p style="margin-top: 1em">Benches <br>
We did a few benches to compare Circus &amp; Chaussette with
Gunicorn. To summarize, Circus is not adding any overhead
and you can pick up many different backends for your web
work&acirc; <br>
ers.</p>

<p style="margin-top: 1em">See:</p>

<p style="margin-top: 1em">&Acirc;&middot;
http://blog.ziade.org/2012/06/28/wgsi-web-servers-bench</p>

<p style="margin-top: 1em">&Acirc;&middot;
http://blog.ziade.org/2012/07/03/wsgi-web-servers-bench-part-2</p>

<p style="margin-top: 1em">How to troubleshoot Circus? <br>
By default, circusd keeps its logging to stdout rather
sparse. This lack of output can make things hard to
troubleshoot when processes seem to be having trouble
starting.</p>

<p style="margin-top: 1em">To increase the logging circusd
provides, try increasing the log level. To see the available
log levels just use the --help flag.</p>

<p style="margin-top: 1em">$ circus --log-level debug
test.ini</p>

<p style="margin-top: 1em">One word of warning. If a
process is flapping and the debug log level is turned on,
you will see messages for each start attempt. It might be
helpful to configure the app that is <br>
flapping to use a warmup_delay to slow down the messages to
a manageable pace.</p>

<p style="margin-top: 1em">[watcher:webapp] <br>
cmd = python -m myapp.wsgi <br>
warmup_delay = 5</p>

<p style="margin-top: 1em">By default, stdout and stderr
are captured by the circusd process. If you are testing your
config and want to see the output in line with the circusd
output, you can configure <br>
your watcher to use the StdoutStream class.</p>

<p style="margin-top: 1em">[watcher:webapp] <br>
cmd = python -m myapp.wsgi <br>
stdout_stream.class = StdoutStream <br>
stderr_stream.class = StdoutStream</p>

<p style="margin-top: 1em">If your application is producing
a traceback or error when it is trying to start up you
should be able to see it in the output.</p>

<p style="margin-top: 1em">Changelog history <br>
0.12.1 - 2015-08-05 <br>
&Acirc;&middot; Fix error when restarting a watcher with an
output stream - #913</p>

<p style="margin-top: 1em">&Acirc;&middot; Minor doc
tweaks</p>

<p style="margin-top: 1em">0.12 - 2015-06-02 <br>
This release brings Python 3.4, Tornado 4 and Windows
support, among several exciting features and fixes.</p>

<p style="margin-top: 1em">The Windows support is still
experimental, and does not handle streams.</p>

<p style="margin-top: 1em">Major changes:</p>

<p style="margin-top: 1em">&Acirc;&middot; Compatibility
with Python 3.4 - #768</p>

<p style="margin-top: 1em">&Acirc;&middot; Experimental
Windows support - #788</p>

<p style="margin-top: 1em">&Acirc;&middot; Compatibility
with Tornado 4 - #872</p>

<p style="margin-top: 1em">&Acirc;&middot; Revamped Debian
packaging - #896 - #903</p>

<p style="margin-top: 1em">&Acirc;&middot; Add support for
Papa process kernel - #850</p>

<p style="margin-top: 1em">&Acirc;&middot; Add globing and
regex matching for starting, stopping and restarting
watchers - #829 - #902</p>

<p style="margin-top: 1em">More changes:</p>

<p style="margin-top: 1em">&Acirc;&middot; Optimization of
the shutdown - #784 - #842</p>

<p style="margin-top: 1em">&Acirc;&middot; Add possibility
to specify virtualenv version for the watchers - #805</p>

<p style="margin-top: 1em">&Acirc;&middot; Add --nostop
option to the rmwatcher command - #777</p>

<p style="margin-top: 1em">&Acirc;&middot; Add a callback
to Arbiter.start - #840</p>

<p style="margin-top: 1em">&Acirc;&middot; Fix reloading
watchers with uppercase letters - #823</p>

<p style="margin-top: 1em">&Acirc;&middot; Remove leaking
socket in stats daemon - #843</p>

<p style="margin-top: 1em">&Acirc;&middot; Fix multicast on
SunOS - #876</p>

<p style="margin-top: 1em">&Acirc;&middot; Close output
streams when stopping a watcher - #885</p>

<p style="margin-top: 1em">&Acirc;&middot; Fix signal
sending to grandchildren with --recursive - #888</p>

<p style="margin-top: 1em">0.11.1 - 2014-05-22 <br>
&Acirc;&middot; Fixed a regression that broke Circus on 2.6
- #782</p>

<p style="margin-top: 1em">0.11 - 2014-05-21 <br>
This release is not introducing a lot of features, and
focused on making Circus more robust &amp; stable.</p>

<p style="margin-top: 1em">Major changes/fixes:</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure we
cannot execute two conflictings commands on the arbiter
simultanously.</p>

<p style="margin-top: 1em">&Acirc;&middot; we have 2 new
streams class: TimedRotatingFileStream,
WatchedFileStream</p>

<p style="margin-top: 1em">&Acirc;&middot; we have one new
hook: after_spawn hook</p>

<p style="margin-top: 1em">&Acirc;&middot; CircusPlugin is
easier to use</p>

<p style="margin-top: 1em">&Acirc;&middot; fix
autostart=False watchers during start (regression)</p>

<p style="margin-top: 1em">More changes:</p>

<p style="margin-top: 1em">&Acirc;&middot; circus messages
can be routed to syslog now - #748</p>

<p style="margin-top: 1em">&Acirc;&middot; endpoint_owner
option added so we can define which user owns ipc socket
files created by circus.</p>

<p style="margin-top: 1em">&Acirc;&middot; Started Windows
support (just circusctl for now)</p>

<p style="margin-top: 1em">&Acirc;&middot; fixed a lot of
leaks in the tests</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow case
sensitive environment variables</p>

<p style="margin-top: 1em">&Acirc;&middot; The resource
plugin now accepts absolute memory values - #609</p>

<p style="margin-top: 1em">&Acirc;&middot; Add support to
the add command for the &rsquo;singleton&rsquo; option -
#767</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow sending
arbitrary signals to child procs via resource watcher -
#756</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow
INI/JSON/YAML configuration for logging</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure
we&rsquo;re compatible with psutil 2.x and 3.x</p>

<p style="margin-top: 1em">&Acirc;&middot; Added more
metrics to the statsd provider - #698</p>

<p style="margin-top: 1em">&Acirc;&middot; Fixed multicast
discovery - #731</p>

<p style="margin-top: 1em">&Acirc;&middot; Make start,
restart and reload more uniform - #673</p>

<p style="margin-top: 1em">&Acirc;&middot; Correctly
initialize all use groups - #635</p>

<p style="margin-top: 1em">&Acirc;&middot; improved tests
stability</p>

<p style="margin-top: 1em">&Acirc;&middot; many, many more
things....</p>

<p style="margin-top: 1em">0.10 - 2013-11-04 <br>
Major changes:</p>

<p style="margin-top: 1em">&Acirc;&middot; Now Python 3.2
&amp; 3.3 compatible - #586</p>

<p style="margin-top: 1em">&Acirc;&middot; Moved the core
to a fully async model - #569</p>

<p style="margin-top: 1em">&Acirc;&middot; Improved
documentation - #622</p>

<p style="margin-top: 1em">More changes:</p>

<p style="margin-top: 1em">&Acirc;&middot; Added
stop_signal &amp; stop_children - #594</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure the
watchdog plugin closes the sockets - #588</p>

<p style="margin-top: 1em">&Acirc;&middot; Switched to ZMQ
JSON parser</p>

<p style="margin-top: 1em">&Acirc;&middot; IN not supported
on all platforms - #573</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow global
environment substitutions in any config section - #560</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow dashes in
sections names - #546</p>

<p style="margin-top: 1em">&Acirc;&middot; Now variables
are expanded everywhere in the config - #554</p>

<p style="margin-top: 1em">&Acirc;&middot; Added the
CommandReloader plugin</p>

<p style="margin-top: 1em">&Acirc;&middot; Added
before_signal &amp; after_signal hooks</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow flapping
plugin to retry indefinitely</p>

<p style="margin-top: 1em">&Acirc;&middot; Don&rsquo;t
respawn procs when the watcher is stopping - #529 - #536</p>

<p style="margin-top: 1em">&Acirc;&middot; Added a unique
id for each client message - #517</p>

<p style="margin-top: 1em">&Acirc;&middot; worker ids are
now &quot;slots&quot; -</p>

<p style="margin-top: 1em">&Acirc;&middot; Fixed the
graceful shutdown behavior - #515</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure we can
add watchers even if the arbiter is not started - #503</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure make
sure we pop expired process - #510</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure the
set command can set several hooks</p>

<p style="margin-top: 1em">&Acirc;&middot; Correctly
support ipv6 sockets - #507</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow custom
options for stdout_stream and stderr_stream - #495</p>

<p style="margin-top: 1em">&Acirc;&middot; Added
time_format for FileStream - #493</p>

<p style="margin-top: 1em">&Acirc;&middot; Added new socket
config option to bind to a specific interface by name</p>

<p style="margin-top: 1em">0.9.3 - 2013-09-04 <br>
&Acirc;&middot; Make sure we can add watchers even if the
arbiter is not started</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure we pop
expired process</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure the
set command can set one or several hooks</p>

<p style="margin-top: 1em">&Acirc;&middot; Correctly
support ipv6 sockets and improvments of CircusSockets</p>

<p style="margin-top: 1em">&Acirc;&middot; Give path
default value to prevent UnboundLocalError</p>

<p style="margin-top: 1em">&Acirc;&middot; Added a test for
multicast_endpoint existence in Controller
initialization</p>

<p style="margin-top: 1em">&Acirc;&middot; Not converting
every string of digits to ints anymore</p>

<p style="margin-top: 1em">&Acirc;&middot; Add tests</p>

<p style="margin-top: 1em">&Acirc;&middot; No need for
special cases when converting stdout_stream options</p>

<p style="margin-top: 1em">&Acirc;&middot; also accept
umask as an argument for consistency</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow custom
options for stdout_stream and stderr_stream.</p>

<p style="margin-top: 1em">&Acirc;&middot; Add new socket
config option to bind to a specific interface by name</p>

<p style="margin-top: 1em">&Acirc;&middot; Add time_format
for FileStream + tests</p>

<p style="margin-top: 1em">&Acirc;&middot; Update
circus.upstart</p>

<p style="margin-top: 1em">0.9.2 - 2013-07-17 <br>
&Acirc;&middot; When a PYTHONPATH is defined in a config
file, it&rsquo;s loaded in sys.path so hooks can be located
there - #477, #481</p>

<p style="margin-top: 1em">&Acirc;&middot; Use a single
argument for add_callback so it works with PyZMQ &lt; 13.1.x
- see #478</p>

<p style="margin-top: 1em">0.9 - 2013-07-16 <br>
&Acirc;&middot; added [env] sections wildcards</p>

<p style="margin-top: 1em">&Acirc;&middot; added global
[env] secrtion</p>

<p style="margin-top: 1em">&Acirc;&middot; fixed hidden
exception when circus-web is not installed - #424</p>

<p style="margin-top: 1em">&Acirc;&middot; make sure
incr/decr commands really us the nb option - #421</p>

<p style="margin-top: 1em">&Acirc;&middot; Fix watcher
virtualenv site-packages not in PYTHONPATH</p>

<p style="margin-top: 1em">&Acirc;&middot; make sure we
dont try to remove more processes than 0 - #429</p>

<p style="margin-top: 1em">&Acirc;&middot; updated
bootstrap.py - #436</p>

<p style="margin-top: 1em">&Acirc;&middot; fixed
multiplatform separator in pythonpath virtualenv watcher</p>

<p style="margin-top: 1em">&Acirc;&middot; refactored
socket close function</p>

<p style="margin-top: 1em">&Acirc;&middot; Ensure env
sections are applied to all watchers - #437</p>

<p style="margin-top: 1em">&Acirc;&middot; added the
reloadconfig command</p>

<p style="margin-top: 1em">&Acirc;&middot; added
circus.green and removed gevent from the core - #441,
#452</p>

<p style="margin-top: 1em">&Acirc;&middot; silenced
spurious stdout &amp; warnings in the tests - #438</p>

<p style="margin-top: 1em">&Acirc;&middot; $(circus.env.*)
can be used for all options in the config now</p>

<p style="margin-top: 1em">&Acirc;&middot; added a
before_spawn hook</p>

<p style="margin-top: 1em">&Acirc;&middot; correct the path
of circusd in systemd service file - #450</p>

<p style="margin-top: 1em">&Acirc;&middot; make sure we can
change hooks and set streams via CLI - #455</p>

<p style="margin-top: 1em">&Acirc;&middot; improved doc</p>

<p style="margin-top: 1em">&Acirc;&middot; added a
spawn_count stat in watcher</p>

<p style="margin-top: 1em">&Acirc;&middot; added min_cpu
and min_mem parameters in ResourceWatcher plugin</p>

<p style="margin-top: 1em">&Acirc;&middot; added the FQDN
information to the arbiter.</p>

<p style="margin-top: 1em">0.8.1 - 2013-05-28 <br>
&Acirc;&middot; circusd-stats was choking on unix sockets -
#415</p>

<p style="margin-top: 1em">&Acirc;&middot; circusd-stats
&amp; circushttpd child processes stdout/stderr are now left
open by default. Python &lt;= 2.7.5 would choke in the
logging module in case the 2/3 fds were closed - #415</p>

<p style="margin-top: 1em">&Acirc;&middot; Now redirecting
to /dev/null in the child process instead of closing.
#417</p>

<p style="margin-top: 1em">0.8 - 2013-05-24 <br>
&Acirc;&middot; Integrated log handlers into zmq io
loop.</p>

<p style="margin-top: 1em">&Acirc;&middot; Make redirector
restartable and subsequently more robust.</p>

<p style="margin-top: 1em">&Acirc;&middot; Uses
zmq.green.eventloop when gevent is detected</p>

<p style="margin-top: 1em">&Acirc;&middot; Added support
for CIRCUSCTL_ENDPOINT environment variable to circusctl -
#396</p>

<p style="margin-top: 1em">&Acirc;&middot; util: fix bug in
to_uid function - #397</p>

<p style="margin-top: 1em">&Acirc;&middot; Remove handler
on ioloop error - #398.</p>

<p style="margin-top: 1em">&Acirc;&middot; Improved test
coverage</p>

<p style="margin-top: 1em">&Acirc;&middot; Deprecated the
&rsquo;service&rsquo; option for the ResourceWatcher plugin
- #404</p>

<p style="margin-top: 1em">&Acirc;&middot; removed
psutil.error usage</p>

<p style="margin-top: 1em">&Acirc;&middot; Added UDP
discovery in circusd - #407</p>

<p style="margin-top: 1em">&Acirc;&middot; Now allowing
globs at arbitrary directory levels - #388</p>

<p style="margin-top: 1em">&Acirc;&middot; Added the
&rsquo;statd&rsquo; configuration option - #408</p>

<p style="margin-top: 1em">&Acirc;&middot; Add pidfile,
logoutput and loglevel option to circus configuration file -
#379</p>

<p style="margin-top: 1em">&Acirc;&middot; Added a tutorial
in the docs.</p>

<p style="margin-top: 1em">&Acirc;&middot; make sure
we&rsquo;re merging all sections when using include -
#414</p>

<p style="margin-top: 1em">&Acirc;&middot; added
pipe_stdout, pipe_stderr, close_child_stderr &amp;
close_child_stdout options to the Process class</p>

<p style="margin-top: 1em">&Acirc;&middot; added
close_child_stderr &amp; close_child_stdout options to the
watcher</p>

<p style="margin-top: 1em">0.7.1 - 2013-05-02 <br>
&Acirc;&middot; Fixed the respawn option - #382</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure we use
an int for the timeout - #380</p>

<p style="margin-top: 1em">&Acirc;&middot; display the unix
sockets as well - #381</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure it
works with the latest pyzmq</p>

<p style="margin-top: 1em">&Acirc;&middot; introduced a
second syntax for the fd notation</p>

<p style="margin-top: 1em">0.7 - 2013-04-08 <br>
&Acirc;&middot; Fix get_arbiter example to use a dict for
the watchers argument. #304</p>

<p style="margin-top: 1em">&Acirc;&middot; Add some
troubleshooting documentation #323</p>

<p style="margin-top: 1em">&Acirc;&middot; Add python
buildout support</p>

<p style="margin-top: 1em">&Acirc;&middot; Removed the
gevent and the thread redirectors. now using the ioloop -
fixes #346. Relates #340</p>

<p style="margin-top: 1em">&Acirc;&middot; circus.web is
now its own project</p>

<p style="margin-top: 1em">&Acirc;&middot; removed the
pyzmq patching</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow the
watcher to be configured but not started #283</p>

<p style="margin-top: 1em">&Acirc;&middot; Add an option to
load a virtualenv site dir</p>

<p style="margin-top: 1em">&Acirc;&middot; added on_demand
watchers</p>

<p style="margin-top: 1em">&Acirc;&middot; added doc about
nginx+websockets #371</p>

<p style="margin-top: 1em">&Acirc;&middot; now properly
parsing the options list of each command #369</p>

<p style="margin-top: 1em">&Acirc;&middot; Fixed
circusd-stats events handling #372</p>

<p style="margin-top: 1em">&Acirc;&middot; fixed the
overflow issue in circus-top #378</p>

<p style="margin-top: 1em">&Acirc;&middot; many more
things...</p>

<p style="margin-top: 1em">0.6 - 2012-12-18 <br>
&Acirc;&middot; Patching protocols name for sockets -
#248</p>

<p style="margin-top: 1em">&Acirc;&middot; Don&rsquo;t
autoscale graphs. #240</p>

<p style="margin-top: 1em">&Acirc;&middot; circusctl: add
per command help, from docstrings #217</p>

<p style="margin-top: 1em">&Acirc;&middot; Added workers
hooks</p>

<p style="margin-top: 1em">&Acirc;&middot; Added Debian
package - #227</p>

<p style="margin-top: 1em">&Acirc;&middot; Added Redis,
HTTP Observer, Full stats &amp; Resource plugins</p>

<p style="margin-top: 1em">&Acirc;&middot; Now processes
can have titles</p>

<p style="margin-top: 1em">&Acirc;&middot; Added
autocompletion</p>

<p style="margin-top: 1em">&Acirc;&middot; Added
process/watcher age in the webui</p>

<p style="margin-top: 1em">&Acirc;&middot; Added SSH tunnel
support</p>

<p style="margin-top: 1em">&Acirc;&middot; Now using
pyzmq.green</p>

<p style="margin-top: 1em">&Acirc;&middot; Added upstart
script &amp; Varnish doc</p>

<p style="margin-top: 1em">&Acirc;&middot; Added
environment variables &amp; sections</p>

<p style="margin-top: 1em">&Acirc;&middot; Added unix
sockets support</p>

<p style="margin-top: 1em">&Acirc;&middot; Added the
respawn option to have single-run watchers</p>

<p style="margin-top: 1em">&Acirc;&middot; Now using tox in
the tests</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow socket
substitution in args</p>

<p style="margin-top: 1em">&Acirc;&middot; New doc
theme</p>

<p style="margin-top: 1em">&Acirc;&middot; New rotation
options for streams: max_bytes/backup_count</p>

<p style="margin-top: 1em">0.5.2 - 2012-07-26 <br>
&Acirc;&middot; now patching the thread module from the
stdlib to avoid some Python bugs - #203</p>

<p style="margin-top: 1em">&Acirc;&middot; better looking
circusctl help screen</p>

<p style="margin-top: 1em">&Acirc;&middot; uses pustil
get_nice() when available (nice was deprecated) - #208</p>

<p style="margin-top: 1em">&Acirc;&middot; added max_age
support - #221</p>

<p style="margin-top: 1em">&Acirc;&middot; only call
listen() on SOCK_STREAM or SOCK_SEQPACKET sockets</p>

<p style="margin-top: 1em">&Acirc;&middot; make sure the
controller empties the plugins list in update_watchers() -
#220</p>

<p style="margin-top: 1em">&Acirc;&middot; added
--log-level and --log-output to circushttpd</p>

<p style="margin-top: 1em">&Acirc;&middot; fix the process
killing via the web UI - #219</p>

<p style="margin-top: 1em">&Acirc;&middot; now circus is
zc.buildout compatible for scripts.</p>

<p style="margin-top: 1em">&Acirc;&middot; cleanup the
websocket when the client disconnect - #225</p>

<p style="margin-top: 1em">&Acirc;&middot; fixed the
default value for the endpoint - #199</p>

<p style="margin-top: 1em">&Acirc;&middot; splitted
circushttpd in logical modules</p>

<p style="margin-top: 1em">0.5.1 - 2012-07-11 <br>
&Acirc;&middot; Fixed a bunch of typos in the
documentation</p>

<p style="margin-top: 1em">&Acirc;&middot; Added the debug
option</p>

<p style="margin-top: 1em">&Acirc;&middot; Package
web-requirements.txt properly</p>

<p style="margin-top: 1em">&Acirc;&middot; Added a errno
error code in the messages - fixes #111</p>

<p style="margin-top: 1em">0.5 - 2012-07-06 <br>
&Acirc;&middot; added socket support</p>

<p style="margin-top: 1em">&Acirc;&middot; added a
listsocket command</p>

<p style="margin-top: 1em">&Acirc;&middot; sockets have
stats too !</p>

<p style="margin-top: 1em">&Acirc;&middot; fixed a lot of
small bugs</p>

<p style="margin-top: 1em">&Acirc;&middot; removed the wid
- now using pid everywhere</p>

<p style="margin-top: 1em">&Acirc;&middot; faster tests</p>

<p style="margin-top: 1em">&Acirc;&middot; changed the
variables syntax</p>

<p style="margin-top: 1em">&Acirc;&middot; use
pyzmq&rsquo;s ioloop in more places</p>

<p style="margin-top: 1em">&Acirc;&middot; now using iowait
for all select() calls</p>

<p style="margin-top: 1em">&Acirc;&middot; incr/decr
commands now have an nbprocess parameter</p>

<p style="margin-top: 1em">&Acirc;&middot; Add a
reproduce_env option to watchers</p>

<p style="margin-top: 1em">&Acirc;&middot; Add a new
UNEXISTING status to the processes</p>

<p style="margin-top: 1em">&Acirc;&middot; Added the global
httpd option to run circushttpd as a watcher</p>

<p style="margin-top: 1em">0.4 - 2012-06-12 <br>
&Acirc;&middot; Added a plugin system</p>

<p style="margin-top: 1em">&Acirc;&middot; Added a
&quot;singleton&quot; option for watchers</p>

<p style="margin-top: 1em">&Acirc;&middot; Fixed circus-top
screen flickering</p>

<p style="margin-top: 1em">&Acirc;&middot; Removed threads
from circus.stats in favor of zmq periodic callbacks</p>

<p style="margin-top: 1em">&Acirc;&middot; Enhanced the
documentation</p>

<p style="margin-top: 1em">&Acirc;&middot; Circus client
now have a send_message api</p>

<p style="margin-top: 1em">&Acirc;&middot; The flapping
feature is now a plugin</p>

<p style="margin-top: 1em">&Acirc;&middot; Every command
line tool have a --version option</p>

<p style="margin-top: 1em">&Acirc;&middot; Added a statsd
plugin (sends the events from circus to statsd)</p>

<p style="margin-top: 1em">&Acirc;&middot; The web UI now
uses websockets (via socketio) to get the stats</p>

<p style="margin-top: 1em">&Acirc;&middot; The web UI now
uses sessions for &quot;flash messages&quot; in the web
ui</p>

<p style="margin-top: 1em">0.3.4 - 2012-05-30 <br>
&Acirc;&middot; Fixed a race condition that prevented the
controller to cleanly reap finished processes.</p>

<p style="margin-top: 1em">&Acirc;&middot; Now
check_flapping can be controlled in the configuration. And
activated/deactivated per watcher.</p>

<p style="margin-top: 1em">0.3.3 - 2012-05-29 <br>
&Acirc;&middot; Fixed the regression on the uid handling</p>

<p style="margin-top: 1em">0.3.2 - 2012-05-24 <br>
&Acirc;&middot; allows optional args property to add_watcher
command.</p>

<p style="margin-top: 1em">&Acirc;&middot; added
circushttpd, circus-top and circusd-stats</p>

<p style="margin-top: 1em">&Acirc;&middot; allowing
Arbiter.add_watcher() to set all Watcher option</p>

<p style="margin-top: 1em">&Acirc;&middot; make sure the
redirectors are re-created on restarts</p>

<p style="margin-top: 1em">0.3.1 - 2012-04-18 <br>
&Acirc;&middot; fix: make sure watcher&rsquo; defaults
aren&rsquo;t overrided</p>

<p style="margin-top: 1em">&Acirc;&middot; added a
StdoutStream class.</p>

<p style="margin-top: 1em">0.3 - 2012-04-18 <br>
&Acirc;&middot; added the streaming feature</p>

<p style="margin-top: 1em">&Acirc;&middot; now displaying
coverage in the Sphinx doc</p>

<p style="margin-top: 1em">&Acirc;&middot; fixed the way
the processes are killed (no more SIGQUIT)</p>

<p style="margin-top: 1em">&Acirc;&middot; the
configuration has been factored out</p>

<p style="margin-top: 1em">&Acirc;&middot; setproctitle
support</p>

<p style="margin-top: 1em">0.2 - 2012-04-04 <br>
&Acirc;&middot; Removed the show name. replaced by
watcher.</p>

<p style="margin-top: 1em">&Acirc;&middot; Added support
for setting process rlimit.</p>

<p style="margin-top: 1em">&Acirc;&middot; Added support
for include dirs in the config file.</p>

<p style="margin-top: 1em">&Acirc;&middot; Fixed a couple
of leaking file descriptors.</p>

<p style="margin-top: 1em">&Acirc;&middot; Fixed a core
dump in the flapping</p>

<p style="margin-top: 1em">&Acirc;&middot; Doc
improvments</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure
circusd errors properly when another circusd is running on
the same socket.</p>

<p style="margin-top: 1em">&Acirc;&middot; get_arbiter now
accepts several watchers.</p>

<p style="margin-top: 1em">&Acirc;&middot; Fixed the cmd vs
args vs executable in the process init.</p>

<p style="margin-top: 1em">&Acirc;&middot; Fixed --start on
circusctl add</p>

<p style="margin-top: 1em">0.1 - 2012-03-20 <br>
&Acirc;&middot; initial release</p>

<p style="margin-top: 1em">man pages <br>
circusd man page <br>
Synopsis <br>
circusd [options] [config]</p>

<p style="margin-top: 1em">Description <br>
circusd is the main process of the Circus architecture. It
takes care of running all the processes. Each process
managed by Circus is a child process of circusd.</p>

<p style="margin-top: 1em">Arguments <br>
config configuration file</p>

<p style="margin-top: 1em">Options <br>
-h, --help <br>
Show the help message and exit</p>

<p style="margin-top: 1em">--log-level LEVEL <br>
Specify the log level. LEVEL can be info, debug, critical,
warning or error.</p>

<p style="margin-top: 1em">--log-output LOGOUTPUT <br>
The location where the logs will be written. The default
behavior is to write to stdout (you can force it by passing
&rsquo;-&rsquo; to this option). Takes a filename
otherwise.</p>

<p style="margin-top: 1em">--logger-config LOGGERCONFIG
<br>
The location where a standard Python logger configuration
INI, JSON or YAML file can be found. This can be used to
override the default logging configuration for the <br>
arbiter.</p>

<p style="margin-top: 1em">--daemon <br>
Start circusd in the background.</p>

<p style="margin-top: 1em">--pidfile PIDFILE <br>
The location of the PID file.</p>

<p style="margin-top: 1em">--version <br>
Displays Circus version and exits.</p>

<p style="margin-top: 1em">See also <br>
circus (1), circusctl (1), circusd-stats (1), circus-plugin
(1), circus-top (1).</p>

<p style="margin-top: 1em">Full Documentation is available
at http://circus.readthedocs.org</p>

<p style="margin-top: 1em">circusctl man page <br>
Synopsis <br>
circusctl [options] command [args]</p>

<p style="margin-top: 1em">Description <br>
circusctl is front end to control the Circus daemon. It is
designed to help the administrator control the functionning
of the Circud circusd daemon.</p>

<p style="margin-top: 1em">Commands <br>
add Add a watcher</p>

<p style="margin-top: 1em">decr Decrement the number of
processes in a watcher</p>

<p style="margin-top: 1em">dstats Get circusd stats</p>

<p style="margin-top: 1em">get Get the value of specific
watcher options</p>

<p style="margin-top: 1em">globaloptions <br>
Get the arbiter options</p>

<p style="margin-top: 1em">incr Increment the number of
processes in a watcher</p>

<p style="margin-top: 1em">ipython <br>
Create shell into circusd process</p>

<p style="margin-top: 1em">list Get list of watchers or
processes in a watcher</p>

<p style="margin-top: 1em">listen Subscribe to a watcher
event</p>

<p style="margin-top: 1em">listsockets <br>
Get the list of sockets</p>

<p style="margin-top: 1em">numprocesses <br>
Get the number of processes</p>

<p style="margin-top: 1em">numwatchers <br>
Get the number of watchers</p>

<p style="margin-top: 1em">options <br>
Get the value of all options for a watcher</p>

<p style="margin-top: 1em">quit Quit the arbiter
immediately</p>

<p style="margin-top: 1em">reload Reload the arbiter or a
watcher</p>

<p style="margin-top: 1em">reloadconfig <br>
Reload the configuration file</p>

<p style="margin-top: 1em">restart <br>
Restart the arbiter or a watcher</p>

<p style="margin-top: 1em">rm Remove a watcher</p>

<p style="margin-top: 1em">set Set a watcher option</p>

<p style="margin-top: 1em">signal Send a signal</p>

<p style="margin-top: 1em">start Start the arbiter or a
watcher</p>

<p style="margin-top: 1em">stats Get process infos</p>

<p style="margin-top: 1em">status Get the status of a
watcher or all watchers</p>

<p style="margin-top: 1em">stop Stop watchers</p>

<p style="margin-top: 1em">Options <br>
--endpoint ENDPOINT <br>
connection endpoint</p>

<p style="margin-top: 1em">-h, --help <br>
Show the help message and exit</p>

<p style="margin-top: 1em">--json output to JSON</p>

<p style="margin-top: 1em">--prettify <br>
prettify output</p>

<p style="margin-top: 1em">--ssh SSH <br>
SSH Server in the format user@host:port</p>

<p style="margin-top: 1em">--ssh_keyfile SSH_KEYFILE <br>
path to the keyfile to authorise the user</p>

<p style="margin-top: 1em">--timeout TIMEOUT <br>
connection timeout</p>

<p style="margin-top: 1em">--version <br>
Displays Circus version and exits.</p>

<p style="margin-top: 1em">See Also <br>
circus (1), circusd (1), circusd-stats (1), circus-plugin
(1), circus-top (1).</p>

<p style="margin-top: 1em">Full Documentation is available
at http://circus.readthedocs.org</p>

<p style="margin-top: 1em">circus-plugin man page <br>
Synopsis <br>
circus-plugin [options] [plugin]</p>

<p style="margin-top: 1em">Description <br>
circus-plugin allows to launch a plugin from a running
Circus daemon.</p>

<p style="margin-top: 1em">Arguments <br>
plugin Fully qualified name of the plugin class.</p>

<p style="margin-top: 1em">Options <br>
--endpoint ENDPOINT <br>
Connection endpoint.</p>

<p style="margin-top: 1em">--pubsub PUBSUB <br>
The circusd ZeroMQ pub/sub socket to connect to.</p>

<p style="margin-top: 1em">--config CONFIG <br>
The plugin configuration file.</p>

<p style="margin-top: 1em">--check-delay CHECK_DELAY <br>
Check delay.</p>

<p style="margin-top: 1em">--log-level LEVEL <br>
Specify the log level. LEVEL can be info, debug, critical,
warning or error.</p>

<p style="margin-top: 1em">--log-output LOGOUTPUT <br>
The location where the logs will be written. The default
behavior is to write to stdout (you can force it by passing
&rsquo;-&rsquo; to this option). Takes a filename
otherwise.</p>

<p style="margin-top: 1em">--ssh SSH <br>
SSH Server in the format user@host:port.</p>

<p style="margin-top: 1em">-h, --help <br>
Show the help message and exit.</p>

<p style="margin-top: 1em">--version <br>
Displays Circus version and exits.</p>

<p style="margin-top: 1em">See also <br>
circus (1), circusd (1), circusctl (1), circusd-stats (1),
circus-top (1).</p>

<p style="margin-top: 1em">Full Documentation is available
at http://circus.readthedocs.org</p>

<p style="margin-top: 1em">circus-top man page <br>
Synopsis <br>
circus-top [options]</p>

<p style="margin-top: 1em">Description <br>
circus-top is a top-like command to display the Circus
daemon and processes managed by circus.</p>

<p style="margin-top: 1em">Options <br>
--endpoint ENDPOINT <br>
Connection endpoint.</p>

<p style="margin-top: 1em">--ssh SSH <br>
SSH Server in the format user@host:port.</p>

<p style="margin-top: 1em">--process-timeout
PROCESS_TIMEOUT <br>
After this delay of inactivity, a process will be
removed.</p>

<p style="margin-top: 1em">-h, --help <br>
Show the help message and exit.</p>

<p style="margin-top: 1em">--version <br>
Displays Circus version and exits.</p>

<p style="margin-top: 1em">See also <br>
circus (1), circusctl (1), circusd (1), circusd-stats (1),
circus-plugin (1).</p>

<p style="margin-top: 1em">Full Documentation is available
at http://circus.readthedocs.org</p>

<p style="margin-top: 1em">circusd-stats man page <br>
Synopsis <br>
circusd-stats [options]</p>

<p style="margin-top: 1em">Description <br>
circusd-stats runs the stats aggregator for Circus.</p>

<p style="margin-top: 1em">Options <br>
--endpoint ENDPOINT <br>
Connection endpoint.</p>

<p style="margin-top: 1em">--pubsub PUBSUB <br>
The circusd ZeroMQ pub/sub socket to connect to.</p>

<p style="margin-top: 1em">--statspoint STATSPOINT <br>
The ZeroMQ pub/sub socket to send data to.</p>

<p style="margin-top: 1em">--log-level LEVEL <br>
Specify the log level. LEVEL can be info, debug, critical,
warning or error.</p>

<p style="margin-top: 1em">--log-output LOGOUTPUT <br>
The location where the logs will be written. The default
behavior is to write to stdout (you can force it by passing
&rsquo;-&rsquo; to this option). Takes a filename
otherwise.</p>

<p style="margin-top: 1em">--ssh SSH <br>
SSH Server in the format user@host:port.</p>

<p style="margin-top: 1em">-h, --help <br>
Show the help message and exit.</p>

<p style="margin-top: 1em">--version <br>
Displays Circus version and exits.</p>

<p style="margin-top: 1em">See also <br>
circus (1), circusd (1), circusctl (1), circus-plugin (1),
circus-top (1).</p>

<p style="margin-top: 1em">Full Documentation is available
at http://circus.readthedocs.org</p>

<p style="margin-top: 1em">Glossary: Circus-specific terms
<br>
arbiter <br>
The arbiter is responsible for managing all the watchers
within circus, ensuring all processes run correctly.</p>

<p style="margin-top: 1em">controller <br>
A controller contains the set of actions that can be
performed on the arbiter.</p>

<p style="margin-top: 1em">flapping <br>
The flapping detection subscribes to events and detects when
some processes are constantly restarting.</p>

<p style="margin-top: 1em">pub/sub <br>
Circus has a pubsub that receives events from the watchers
and dispatches them to all subscribers.</p>

<p style="margin-top: 1em">remote controller <br>
The remote controller allows you to communicate with the
controller via ZMQ to control Circus.</p>

<p style="margin-top: 1em">watcher, watchers <br>
A watcher is the program you tell Circus to run. A single
Circus instance can run one or more watchers.</p>

<p style="margin-top: 1em">worker, workers, process,
processes <br>
A process is an independent OS process instance of your
program. A single watcher can run one or more processes. We
also call them workers.</p>

<p style="margin-top: 1em">Copyright <br>
Circus was initiated by Tarek Ziade and is licenced under
APLv2</p>

<p style="margin-top: 1em">Benoit Chesneau was an early
contributor and did many things, like most of the
circus.commands work.</p>

<p style="margin-top: 1em">Licence <br>
Copyright 2012 - Mozilla Foundation <br>
Copyright 2012 - Benoit Chesneau</p>

<p style="margin-top: 1em">Licensed under the Apache
License, Version 2.0 (the &quot;License&quot;); <br>
you may not use this file except in compliance with the
License. <br>
You may obtain a copy of the License at</p>


<p style="margin-top: 1em">http://www.apache.org/licenses/LICENSE-2.0</p>

<p style="margin-top: 1em">Unless required by applicable
law or agreed to in writing, software <br>
distributed under the License is distributed on an &quot;AS
IS&quot; BASIS, <br>
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
or implied. <br>
See the License for the specific language governing
permissions and <br>
limitations under the License.</p>

<p style="margin-top: 1em">Contributors <br>
See the full list at
https://github.com/circus-tent/circus/blob/master/CONTRIBUTORS.txt</p>

<p style="margin-top: 1em">AUTHOR <br>
Mozilla Foundation, Benoit Chesneau</p>

<p style="margin-top: 1em">0.12.1 November 30, 2015
CIRCUS(1)</p>
<hr>
</body>
</html>
