<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>GABBI(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GABBI(1)</td>
    <td class="head-vol">Gabbi</td>
    <td class="head-rtitle">GABBI(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
gabbi - Gabbi Documentation
<div style="height: 1.00em;">&#x00A0;</div>
Gabbi tests are expressed in YAML as a series of HTTP requests with their
  expected response:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
tests:
   - name: retrieve root
     GET: /
     status: 200
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This will trigger a <b>GET</b> request to <b>/</b> on the configured host. The
  test will pass if the response's status code is <b>200</b>.
<h1 class="Sh" title="Sh" id="TEST_STRUCTURE"><a class="selflink" href="#TEST_STRUCTURE">TEST
  STRUCTURE</a></h1>
The top-level <b>tests</b> category contains an ordered sequence of test
  declarations, each describing the expected response to a given request:
<h2 class="Ss" title="Ss" id="Metadata"><a class="selflink" href="#Metadata">Metadata</a></h2>
<table class="tbl">
  <colgroup>
    <col style="width: 13.00ex;"/>
    <col style="width: 342.00ex;"/>
    <col style="width: 23.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>Key</td>
    <td>Description</td>
    <td>Notes</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>name</b></td>
    <td>The test's name. Must be unique within a file.</td>
    <td><b>required</b></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>desc</b></td>
    <td>An arbitrary string describing the test.</td>
    <td></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>verbose</b></td>
    <td>If <b>True</b> or <b>all</b> (synonymous), prints a representation of
      the current request and response to <b>stdout</b>, including both headers
      and body. If set to <b>headers</b> or <b>body</b>, only the corresponding
      part of the request and response will be printed. If the output is a TTY,
      colors will be used. See <b>VerboseHttp</b> for details.</td>
    <td>defaults to <b>False</b></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>skip</b></td>
    <td>A string message which if set will cause the test to be skipped with the
      provided message.</td>
    <td>defaults to <b>False</b></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>xfail</b></td>
    <td>Determines whether to expect this test to fail. Note that the test will
      be run anyway.</td>
    <td></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
Note: When tests are generated dynamically, the <b>TestCase</b> name will
  include the respective test's <b>name</b>, lowercased with spaces transformed
  to <b>_</b>. In at least some test runners this will allow you to select and
  filter on test name.
<h2 class="Ss" title="Ss" id="Request_Parameters"><a class="selflink" href="#Request_Parameters">Request
  Parameters</a></h2>
<table class="tbl">
  <colgroup>
    <col style="width: 22.00ex;"/>
    <col style="width: 268.00ex;"/>
    <col style="width: 23.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>Key</td>
    <td>Description</td>
    <td>Notes</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>any uppercase string</td>
    <td>Any such key is considered an HTTP method, with the corresponding value
      expressing the URL. This is a shortcut combining <b>method</b> and
      <b>url</b> into a single statement: 0.0 3.5 GET: /index 168u 168u
      corresponds to: 0.0 3.5 method: GET url: /index 168u 168u</td>
    <td></td>
  </tr>
</table>
<table class="tbl">
  <colgroup>
    <col style="width: 22.00ex;"/>
    <col style="width: 268.00ex;"/>
    <col style="width: 23.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>method</b></td>
    <td>The HTTP request method.</td>
    <td>defaults to <b>GET</b></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>url</b></td>
    <td>The URL to request. This can either be a full path (e.g.
      &quot;/index&quot;) or a fully qualified URL (i.e. including host and
      scheme, e.g. &quot; <i>http://example.org/index</i>&quot;) &#x2014; see
      host for details.</td>
    <td><b>required</b></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>request_headers</b></td>
    <td>A dictionary of key-value pairs representing request header names and
      values. These will be added to the constructed request.</td>
    <td></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>query_parameters</b></td>
    <td>A dictionary of query parameters that will be added to the <b>url</b> as
      query string. If that URL already contains a set of query parameters,
      those wil be extended. See example for a demonstration of how the data is
      structured.</td>
    <td></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>data</b></td>
    <td>A representation to pass as the body of a request. Note that
      <b>content-type</b> in <b>request_headers</b> should also be set &#x2014;
      see <i>Data</i> for details.</td>
    <td></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>redirects</b></td>
    <td>If <b>True</b>, redirects will automatically be followed.</td>
    <td>defaults to <b>False</b></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ssl</b></td>
    <td>Determines whether the request uses SSL (i.e. HTTPS). Note that the
      <b>url</b>'s scheme takes precedence if present &#x2014; see host for
      details.</td>
    <td>defaults to <b>False</b></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<h2 class="Ss" title="Ss" id="Response_Expectations"><a class="selflink" href="#Response_Expectations">Response
  Expectations</a></h2>
<table class="tbl">
  <colgroup>
    <col style="width: 32.00ex;"/>
    <col style="width: 343.00ex;"/>
    <col style="width: 21.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>Key</td>
    <td>Description</td>
    <td>Notes</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>status</b></td>
    <td>The expected response status code. Multiple acceptable response codes
      may be provided, separated by <b>||</b> (e.g. <b>302 || 301</b> &#x2014;
      note, however, that this indicates ambiguity, which is generally
      undesirable).</td>
    <td>defaults to <b>200</b></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>response_headers</b></td>
    <td>A dictionary of key-value pairs representing expected response header
      names and values. If a header's value is wrapped in <b>/.../</b>, it will
      be treated as a regular expression.</td>
    <td></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>response_forbidden_headers</b></td>
    <td>A list of headers which must <i>not</i> be present.</td>
    <td></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>response_strings</b></td>
    <td>A list of string fragments expected to be present in the response
      body.</td>
    <td></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>response_json_paths</b></td>
    <td>A dictionary of JSONPath rules paired with expected matches. Using this
      rule requires that the content being sent from the server is JSON (i.e. a
      content type of <b>application/json</b> or containing <b>+json</b>) If the
      value is wrapped in <b>/.../</b> the result of the JSONPath query will be
      compared against the value as a regular expression.</td>
    <td></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>poll</b></td>
    <td>A dictionary of two keys: 0.0 &#x2022; 2 <b>count</b>: An integer
      stating the number of times to attempt this test before giving up.
      &#x2022; 2 <b>delay</b>: A floating point number of seconds to delay
      between attempts. 168u This makes it possible to poll for a resource
      created via an asynchronous request. Use with caution.</td>
    <td></td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
Note that many of these items allow <i>substitutions</i>.
<div style="height: 1.00em;">&#x00A0;</div>
Default values for a file's <b>tests</b> may be provided via the top-level
  <b>defaults</b> category. These take precedence over the global defaults
  (explained below).
<div style="height: 1.00em;">&#x00A0;</div>
For examples see <i>the gabbi tests</i>, example and the <i>gabbi-demo</i>
  tutorial.
<h1 class="Sh" title="Sh" id="FIXTURES"><a class="selflink" href="#FIXTURES">FIXTURES</a></h1>
The top-level <b>fixtures</b> category contains a sequence of named fixtures.
<h1 class="Sh" title="Sh" id="RESPONSE_HANDLERS"><a class="selflink" href="#RESPONSE_HANDLERS">RESPONSE
  HANDLERS</a></h1>
<b>response_*</b> keys are examples of Response Handlers. Custom handlers may be
  created by test authors for specific use cases. See handlers for more
  information.
<h1 class="Sh" title="Sh" id="SUBSTITUTION"><a class="selflink" href="#SUBSTITUTION">SUBSTITUTION</a></h1>
There are a number of magical variables that can be used to make reference to
  the state of a current test or the one just prior. These are replaced with
  real values during test processing. They are processed in the order given.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>$SCHEME</b>: The current scheme/protocol (usually
      <b>http</b> or <b>https</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>$NETLOC</b>: The host and potentially port of the
      request.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>$ENVIRON['&lt;environment variable&gt;']</b>: The name
      of an environment variable. Its value will replace the magical variable.
      If the string value of the environment variable is <b>&quot;True&quot;</b>
      or <b>&quot;False&quot;</b> then the resulting value will be the
      corresponding boolean, not a string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>$COOKIE</b>: All the cookies set by any
      <b>Set-Cookie</b> headers in the prior response, including only the cookie
      key and value pairs and no metadata (e.g. <b>expires</b> or
      <b>domain</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>$LAST_URL</b>: The URL defined in the prior request,
      after substitutions have been made.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>$LOCATION</b>: The location header returned in the prior
      response.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>$HEADERS['&lt;header&gt;']</b>: The value of any header
      from the prior response.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>$RESPONSE['&lt;json path&gt;']</b>: A JSONPath query
      into the prior response. See jsonpath for more on formatting.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Where a single-quote character, <b>'</b>, is shown above you may also use a
  double-quote character, <b>&quot;</b>, but in any given expression the same
  character must be used at both ends.
<div style="height: 1.00em;">&#x00A0;</div>
All of these variables may be used in all of the following fields:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>url</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>query_parameters</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>data</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>request_headers</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>response_strings</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>response_json_paths</b> (on the value side of the key
      value pair)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>response_headers</b> (on the value side of the key value
      pair)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>response_forbidden_headers</b></dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
With these variables it ought to be possible to traverse an API without any
  explicit statements about the URLs being used. If you need a replacement on a
  field that is not currently supported please raise an issue or provide a
  patch.
<div style="height: 1.00em;">&#x00A0;</div>
As all of these features needed to be tested in the development of gabbi itself,
  <i>the gabbi tests</i> are a good source of examples on how to use the
  functionality. See also example for a collection of examples and the
  <i>gabbi-demo</i> tutorial.
<h1 class="Sh" title="Sh" id="DATA"><a class="selflink" href="#DATA">DATA</a></h1>
The <b>data</b> key has some special handing to allow for a bit more flexibility
  when doing a <b>POST</b> or <b>PUT</b>. If the value is not a string (that is,
  it is a sequence or structure) it is treated as a data structure which is
  turned into a JSON string. If the value is a string that begins with
  <b>&lt;@</b> then the rest of the string is treated as the name of a file to
  be loaded from the same directory as the YAML file. If the value is an
  undecorated string, that's the value.
<div style="height: 1.00em;">&#x00A0;</div>
When reading from a file care should be taken to ensure that a reasonable
  content-type is set for the data as this will control if any encoding is done
  of the resulting string value. If it is text, json, xml or javascript it will
  be encoded to UTF-8.
<div style="height: 1.00em;">&#x00A0;</div>
To run gabbi tests with a test harness they must be generated in some fashion
  and then run. This is accomplished by a test loader. Initially gabbi only
  supported those test harnesses that supported the <b>load_tests</b> protocol
  in UnitTest. It now possible to also build and run tests with <i>pytest</i>
  with some limitations described below.
<div style="height: 1.00em;">&#x00A0;</div>
<b>NOTE:</b>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">It is also possible to run gabbi tests from
  the command line. See runner.</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>WARNING:</b>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">If test are being run with a runner that
  supports concurrency (such as <b>testrepository</b>) it is critical that the
  test runner is informed of how to group the tests into their respective
  suites. The usual way to do this is to use a regular expression that groups
  based on the name of the yaml files. For example, when using
  <b>testrepository</b> the <b>.testr.conf</b> file needs an entry similar to
  the following:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
group_regex=gabbi\.suitemaker\.(test_[^_]+_[^_]+)
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<h1 class="Sh" title="Sh" id="UNITTEST_STYLE_LOADER"><a class="selflink" href="#UNITTEST_STYLE_LOADER">UNITTEST
  STYLE LOADER</a></h1>
To run the tests with a <b>load_tests</b> style loader a test file containing a
  <b>load_tests</b> method is required. That will look a bit like:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
&quot;&quot;&quot;A sample test module.&quot;&quot;&quot;
<div class="Pp"></div>
# For pathname munging
import os
<div class="Pp"></div>
# The module that build_tests comes from.
from gabbi import driver
<div class="Pp"></div>
# We need access to the WSGI application that hosts our service
from myapp import wsgiapp
<div class="Pp"></div>
<div class="Pp"></div>
# We're using fixtures in the YAML files, we need to know where to
# load them from.
from myapp.test import fixtures
<div class="Pp"></div>
# By convention the YAML files are put in a directory named
# &quot;gabbits&quot; that is in the same directory as the Python test file.
TESTS_DIR = 'gabbits'
<div class="Pp"></div>
<div class="Pp"></div>
def load_tests(loader, tests, pattern):
    &quot;&quot;&quot;Provide a TestSuite to the discovery process.&quot;&quot;&quot;
    test_dir = os.path.join(os.path.dirname(__file__), TESTS_DIR)
    # Pass &quot;require_ssl=True&quot; as an argument to force all tests
    # to use SSL in requests.
    return driver.build_tests(test_dir, loader,
                              intercept=wsgiapp.app,
                              fixture_module=fixtures)
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
For details on the arguments available when building tests see
  <b>build_tests()</b>.
<div style="height: 1.00em;">&#x00A0;</div>
Once the test loader has been created, it needs to be run. There are <i>many</i>
  options. Which is appropriate depends very much on your environment. Here are
  some examples using <b>unittest</b> or <b>testtools</b> that require minimal
  knowledge to get started.
<div style="height: 1.00em;">&#x00A0;</div>
By file:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
python -m testtools.run -v test/test_loader.py
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
By module:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
python -m testttols.run -v test.test_loader
<div class="Pp"></div>
python -m unittest -v test.test_loader
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Using test discovery to locate all tests in a directory tree:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
python -m testtools.run discover
<div class="Pp"></div>
python -m unittest discover test
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
See the <i>source distribution</i> and <i>the tutorial repo</i> for more
  advanced options, including using <b>testrepository</b> and <b>subunit</b>.
<h1 class="Sh" title="Sh" id="PYTEST"><a class="selflink" href="#PYTEST">PYTEST</a></h1>
Since pytest does not support the <b>load_tests</b> system, a different way of
  generating tests is required. A test file must be created that calls
  <b>py_test_generator()</b> and yields the generated tests. That will look a
  bit like this:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
&quot;&quot;&quot;A sample pytest module.&quot;&quot;&quot;
<div class="Pp"></div>
# For pathname munging
import os
<div class="Pp"></div>
# The module that build_tests comes from.
from gabbi import driver
<div class="Pp"></div>
# We need access to the WSGI application that hosts our service
from myapp import wsgiapp
<div class="Pp"></div>
# We're using fixtures in the YAML files, we need to know where to
# load them from.
from myapp.test import fixtures
<div class="Pp"></div>
# By convention the YAML files are put in a directory named
# &quot;gabbits&quot; that is in the same directory as the Python test file.
TESTS_DIR = 'gabbits'
<div class="Pp"></div>
<div class="Pp"></div>
def test_gabbits():
    test_dir = os.path.join(os.path.dirname(__file__), TESTS_DIR)
    # Pass &quot;require_ssl=True&quot; as an argument to force all tests
    # to use SSL in requests.
    test_generator = driver.py_test_generator(
        test_dir, intercept=wsgiapp.app,
        fixture_module=fixtures)
<div class="Pp"></div>
    for test in test_generator:
        yield test
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This can then be run with the usual pytest commands. For example:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
py.test -svx pytest-example.py
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>WARNING:</b>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">In <b>pytest&gt;=3.0</b> yield tests are
  deprecated and using them will cause pytest to produce a warning. If you wish
  to ignore and hide these warnings add the <b>--disable-pytest-warnings</b>
  parameter to the invocation of <b>py.test</b> or use a version of pytest
  earlier than version <b>3.0</b>. A new way of creating gabbi tests that works
  more effectively with modern pytest is being developed.</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
What follows is a commented example of some tests in a single file demonstrating
  many of the format features. See loader for the Python needed to integrate
  with a testing harness.
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
<div class="Pp"></div>
# Fixtures can be used to set any necessary configuration, such as a
# persistence layer, and establish sample data. They operate per
# file. They are context managers, each one wrapping the next in the
# sequence.
<div class="Pp"></div>
fixtures:
    - ConfigFixture
    - SampleDataFixture
<div class="Pp"></div>
# There is an included fixture named &quot;SkipAllFixture&quot; which can be
# used to declare that all the tests in the given file are to be
# skipped.
<div class="Pp"></div>
# Each test file can specify a set of defaults that will be used for
# every request. This is useful for always specifying a particular
# header or always requiring SSL. These values will be used on every
# test in the file unless overriden. Lists and dicts are merged one
# level deep, except for &quot;data&quot; which is copied verbatim whether it
# is a string, list or dict (it can be all three).
<div class="Pp"></div>
defaults:
    ssl: True
    request_headers:
        x-my-token: zoom
<div class="Pp"></div>
# The tests themselves are a list under a &quot;tests&quot; key. It's useful
# to use plenty of whitespace to help readability.
<div class="Pp"></div>
tests:
<div class="Pp"></div>
# Each request *must* have a name which is unique to the file. When it
# becomes a TestCase the name will be lowercased and spaces will
# become &quot;_&quot;. Use that generated name when limiting test runs.
<div class="Pp"></div>
    - name: a test for root
      desc: Some explanatory text that could be used by other tooling
<div class="Pp"></div>
# The URL can either be relative to a host specified elsewhere or
# be a fully qualified &quot;http&quot; or &quot;https&quot; URL. *You* are responsible
# for url-encoding the URL.
<div class="Pp"></div>
      url: /
<div class="Pp"></div>
# If no status or method are provided they default to &quot;200&quot; and
# &quot;GET&quot;.
<div class="Pp"></div>
# A single test can override settings in defaults (set above).
<div class="Pp"></div>
    - name: root without ssl redirects
      ssl: False
      url: /
      status: 302
<div class="Pp"></div>
# When evaluating response headers it is possible to use a regular
# expression to not have to test the whole value.
<div class="Pp"></div>
      response_headers:
          location: /https/
<div class="Pp"></div>
# By default redirects will not be followed. This can be changed.
<div class="Pp"></div>
    - name: follow root without ssl redirect
      ssl: False
      redirects: True
      url: /
      status: 200 # This is the response code after the redirect.
<div class="Pp"></div>
# URLs can express query parameters in two ways: either in the url
# value directly, or as query_parameters. If both are used then
# query_parameters are appended. In this example the resulting URL
# will be equivalient to
# /foo?section=news&amp;article=1&amp;article=2&amp;date=yesterday
# but not necessarily in that order.
<div class="Pp"></div>
    - name: create a url with parameters
      url: /foo?section=news
      query_parameters:
          article:
              - 1
              - 2
          date: yesterday
<div class="Pp"></div>
# Request headers can be used to declare media-type choices and
# experiment with authorization handling (amongst other things).
# Response headers allow evaluating headers in the response. These
# two together form the core value of gabbi.
<div class="Pp"></div>
    - name: test accept
      url: /resource
      request_headers:
          accept: application/json
      response_headers:
          content-type: /application/json/
<div class="Pp"></div>
# If a header must not be present in a response at all that can be
# expressed in a test as follows.
<div class="Pp"></div>
    - name: test forbidden headers
      url: /resource
      response_forbidden_headers:
          - x-special-header
<div class="Pp"></div>
# All of the above requests have defaulted to a &quot;GET&quot; method. When
# using &quot;POST&quot;, &quot;PUT&quot; or &quot;PATCH&quot;, the &quot;data&quot; key provides the
# request body.
<div class="Pp"></div>
    - name: post some text
      url: /text_repo
      method: POST
      request_headers:
          content-type: text/plain
      data: &quot;I'm storing this&quot;
      status: 201
<div class="Pp"></div>
# If the data is not a string, it will be transformed into JSON.
# You must supply an appropriate content-type request header.
<div class="Pp"></div>
    - name: post some json
      url: /json_repo
      method: POST
      request_headers:
          content-type: application/json
      data:
          name: smith
          abode: castle
      status: 201
<div class="Pp"></div>
# If the data is a string prepended with &quot;&lt;@&quot; the value will be
# treated as the name of a file in the same directory as the YAML
# file. Again, you must supply an appropriate content-type. If the
# content-type is one of several &quot;text-like&quot; types, the content will
# be assumed to be UTF-8 encoded.
<div class="Pp"></div>
    - name: post an image
      url: /image_repo
      method: POST
      request_headers:
          content-type: image/png
      data: &lt;@kittens.png
<div class="Pp"></div>
# A single request can be marked to be skipped.
<div class="Pp"></div>
    - name: patch an image
      skip: patching images not yet implemented
      url: /image_repo/12d96fb8-e78c-11e4-8c03-685b35afa334
      method: PATCH
<div class="Pp"></div>
# Or a single request can be marked that it is expected to fail.
<div class="Pp"></div>
    - name: check allow headers
      desc: the framework doesn't do allow yet
      xfail: True
      url: /post_only_url
      method: PUT
      status: 405
      response_headers:
          allow: POST
<div class="Pp"></div>
# The body of a response can be evaluated with response handlers.
# The most simple checks for a set of strings anywhere in the
# response. Note that the strings are members of a list.
<div class="Pp"></div>
    - name: check for css file
      url: /blog/posts/12
      response_strings:
          - normalize.css
<div class="Pp"></div>
# For JSON responses, JSONPath rules can be used.
<div class="Pp"></div>
    - name: post some json get back json
      url: /json_repo
      method: POST
      request_headers:
          content-type: application/json
      data:
          name: smith
          abode: castle
      status: 201
      response_json_paths:
          $.name: smith
          $.abode: castle
<div class="Pp"></div>
# Requests run in sequence. One test can make reference to the test
# immediately prior using some special variables.
# &quot;$LOCATION&quot; contains the &quot;location&quot; header in the previous
# response.
# &quot;$HEADERS&quot; is a pseudo dictionary containing all the headers of
# the previous response.
# &quot;$ENVIRON&quot; is a pseudo dictionary providing access to the current
# environment.
# &quot;$RESPONSE&quot; provides access to the JSON in the prior response, via
# JSONPath. See http://jsonpath-rw.readthedocs.io/ for
# jsonpath-rw formatting.
# $SCHEME and $NETLOC provide access to the current protocol and
# location (host and port).
<div class="Pp"></div>
    - name: get the thing we just posted
      url: $LOCATION
      request_headers:
          x-magic-exchange: $HEADERS['x-magic-exchange']
          x-token: $ENVIRON['OS_TOKEN']
      response_json_paths:
          $.name: $RESPONSE['$.name']
          $.abode: $RESPONSE['$.abode']
      response_headers:
          content-location: /$SCHEME://$NETLOC/
<div class="Pp"></div>
# For APIs where resource creation is asynchronous it can be
# necessary to poll for the resulting resource. First we create the
# resource in one test. The next test uses the &quot;poll&quot; key to loop
# with a delay for a set number of times.
<div class="Pp"></div>
    - name: create asynch
      url: /async_creator
      method: POST
      request_headers:
          content-type: application/json
      data:
          name: jones
          abode: bungalow
      status: 202
<div class="Pp"></div>
    - name: poll for created resource
      url: $LOCATION
      poll:
          count: 10 # try up to ten times
          delay: .5 # wait .5 seconds between each try
      response_json_paths:
          $.name: $RESPONSE['$.name']
          $.abode: $RESPONSE['$.abode']
<div class="Pp"></div>
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Gabbi supports JSONPath both for validating JSON response bodies and within
  substitutions.
<div style="height: 1.00em;">&#x00A0;</div>
JSONPath expressions are provided by <i>jsonpath_rw</i>, with
  <i>jsonpath_rw_ext</i> custom extensions to address common requirements:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Sorting via <b>sorted</b> and <b>[/property]</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">Filtering via <b>[?property = value]</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Returning the respective length via <b>len</b>.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
(These apply both to arrays and key-value pairs.)
<div style="height: 1.00em;">&#x00A0;</div>
Here is a JSONPath example demonstrating some of these features. Given JSON data
  as follows:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
{
    &quot;pets&quot;: [
        {&quot;type&quot;: &quot;cat&quot;, &quot;sound&quot;: &quot;meow&quot;},
        {&quot;type&quot;: &quot;dog&quot;, &quot;sound&quot;: &quot;woof&quot;}
    ]
}
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
If the ordering of the list in <b>pets</b> is predictable and reliable it is
  relatively straightforward to test values:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
response_json_paths:
    # length of list is two
    $.pets.`len`: 2
    # sound of second item in list is woof
    $.pets[1].sound: woof
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
If the ordering is <i>not</i> predictable additional effort is required:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
response_json_paths:
    # sort by type
    $.pets[/type][0].sound: meow
    # sort by type, reversed
    $.pets[\type][0].sound: woof
    # all the sounds
    $.pets[/type]..sound: ['meow', 'woof']
    # filter by type = dog
    $.pets[?type = &quot;dog&quot;].sound: woof
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
If it is necessary to validate the entire JSON response use a JSONPath of
  <b>$</b>:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
response_json_paths:
    $:
        pets:
            - type: cat
              sound: meow
            - type: dog
              sound: woof
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
This is not a technique that should be used frequently as it can lead to
  difficult to read tests and it also indicates that your gabbi tests are being
  used to test your serializers and data models, not just your API interactions.
<div style="height: 1.00em;">&#x00A0;</div>
There are more JSONPath examples in example and in the <i>jsonpath_rw</i> and
  <i>jsonpath_rw_ext</i> documentation.
<div style="height: 1.00em;">&#x00A0;</div>
The target host is the host on which the API to be tested can be found. Gabbi
  intends to preserve the flow and semantics of HTTP interactions as much as
  possible, and every HTTP request needs to be directed at a host of some form.
  Gabbi provides three ways to control this:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Using <i>wsgi-intercept</i> to provide a fake socket and
      <b>WSGI</b> environment on an arbitrary host and port attached to a
      <b>WSGI</b> application (see <i>intercept examples</i>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Using fully qualified <b>url</b> values in the YAML defined
      tests (see <i>full examples</i>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Using a host and (optionally) port defined at test build
      time (see <i>live examples</i>).</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The intercept and live methods are mutually exclusive per test builder, but
  either kind of test can freely intermix fully qualified URLs into the sequence
  of tests in a YAML file.
<div style="height: 1.00em;">&#x00A0;</div>
For test driven development and local tests the intercept style of testing
  lowers test requirements (no web server required) and is fast. Interception is
  performed as part of fixtures processing as the most deeply nested fixture.
  This allows any configuration or database setup to be performed prior to the
  WSGI application being created.
<div style="height: 1.00em;">&#x00A0;</div>
For the implementation of the above see <b>build_tests()</b>.
<div style="height: 1.00em;">&#x00A0;</div>
Each suite of tests is represented by a single YAML file, and may optionally use
  one or more fixtures to provide the necessary environment required by the
  tests in that file.
<div style="height: 1.00em;">&#x00A0;</div>
Fixtures are implemented as nested context managers. Subclasses of
  <b>GabbiFixture</b> must implement <b>start_fixture</b> and
  <b>stop_fixture</b> methods for creating and destroying, respectively, any
  resources managed by the fixture. While the subclass may choose to implement
  <b>__init__</b> it is important that no exceptions are thrown in that method,
  otherwise the stack of context managers will fail in unexpected ways. Instead
  initialization of real resources should happen in <b>start_fixture</b>.
<div style="height: 1.00em;">&#x00A0;</div>
At this time there is no mechanism for the individual tests to have any direct
  awareness of the fixtures. The fixtures exist, conceptually, on the server
  side of the API being tested.
<div style="height: 1.00em;">&#x00A0;</div>
Fixtures may do whatever is required by the testing environment, however there
  are two common scenarios:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Establishing (and then resetting when a test suite has
      finished) any baseline configuration settings and persistence systems
      required for the tests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Creating sample data for use by the tests.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
If a fixture raises <b>unittest.case.SkipTest</b> during <b>start_fixture</b>
  all the tests in the current file will be skipped. This makes it possible to
  skip the tests if some optional configuration (such as a particular type of
  database) is not available.
<div style="height: 1.00em;">&#x00A0;</div>
If an exception is raised while a fixture is being used, information about the
  exception will be stored on the fixture so that the <b>stop_fixture</b> method
  can decide if the exception should change how the fixture should clean up. The
  exception information can be found on <b>exc_type</b>, <b>exc_value</b> and
  <b>traceback</b> method attributes.
<div style="height: 1.00em;">&#x00A0;</div>
In some contexts (for example CI environments with a large number of tests being
  run in a broadly concurrent environment where output is logged to a single
  file) it can be important to capture and consolidate stray output that is
  produced during the tests and display it associated with an individual test.
  This can help debugging and avoids unusable output that is the result of
  multiple streams being interleaved.
<div style="height: 1.00em;">&#x00A0;</div>
Inner fixtures have been added to support this. These are fixtures more in line
  with the tradtional <b>unittest</b> concept of fixtures: a class on which
  <b>setUp</b> and <b>cleanUp</b> is automatically called.
<div style="height: 1.00em;">&#x00A0;</div>
<b>build_tests()</b> accepts a named parameter arguments of
  <b>inner_fixtures</b>. The value of that argument may be an ordered list of
  <i>fixtures.Fixture</i> classes that will be called when each individual test
  is set up.
<div style="height: 1.00em;">&#x00A0;</div>
An example fixture that could be useful is the <i>FakeLogger</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<b>NOTE:</b>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">At this time <b>inner_fixtures</b> are not
  supported when using the pytest loader.</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Content handlers are responsible for preparing request data and evaluating
  response data based on the content-type of the request and response. A content
  handler operates as follows:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Structured YAML data provided via the <b>data</b> attribute
      is converted to a string or bytes sequence and used as request body.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The response body (a string or sequence of bytes) is
      transformed into a content-type dependent structure and stored in an
      internal attribute named <b>response_data</b> that is:</dd>
</dl>
<div style="margin-left: 2.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">used when evaluating the response body</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">used in <b>$RESPONSE[]</b> substitutions</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
By default, gabbi provides content handlers for JSON. In that content handler
  the <b>data</b> test key is converted from structured YAML into a JSON string.
  Response bodies are converted from a JSON string into a data structure in
  <b>response_data</b> that is used when evaluating <b>response_json_paths</b>
  entries in a test or doing JSONPath-based <b>$RESPONSE[]</b> substitutions.
<div style="height: 1.00em;">&#x00A0;</div>
Further content handlers can be added as extensions. Test authors may need these
  extensions for their own suites, or enterprising developers may wish to create
  and distribute extensions for others to use.
<div style="height: 1.00em;">&#x00A0;</div>
<b>NOTE:</b>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">One extension that is likely to be useful is a
  content handler that turns <b>data</b> into url-encoded form data suitable for
  POST and turns an HTML response into a DOM object.</div>
<br/>
</div>
<br/>
<h1 class="Sh" title="Sh" id="EXTENSIONS"><a class="selflink" href="#EXTENSIONS">EXTENSIONS</a></h1>
Content handlers are an evolution of the response handler concept in earlier
  versions gabbi. To preserve backwards compatibility with existing response
  handlers, old style response handlers are still allowed, but new handlers
  should implement the content handler interface (described below).
<div style="height: 1.00em;">&#x00A0;</div>
Registering additional custom handlers is done by passing a subclass of
  <b>ContentHandler</b> to <b>build_tests()</b>:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
driver.build_tests(test_dir, loader, host=None,
                   intercept=simple_wsgi.SimpleWsgi,
                   content_handlers=[MyContentHandler])
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
If pytest is being used:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
driver.py_test_generator(test_dir, intercept=simple_wsgi.SimpleWsgi,
                         content_handlers=[MyContenHandler])
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>WARNING:</b>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">When there are multiple handlers listed that
  accept the same content-type, the one that is earliest in the list will be
  used.</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
With <b>gabbi-run</b>, custom handlers can be loaded via the
  <b>--response-handler</b> option -- see <b>load_response_handlers()</b> for
  details.
<div style="height: 1.00em;">&#x00A0;</div>
<b>NOTE:</b>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">The use of the <b>--response-handler</b>
  argument is done to preserve backwards compatibility and avoid excessive
  arguments. Both types of handler may be passed to the argument.</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="Implementation_Details"><a class="selflink" href="#Implementation_Details">Implementation
  Details</a></h2>
Creating a content handler requires subclassing <b>ContentHandler</b> and
  implementing several methods. These methods are described below, but
  inspecting <b>JSONHandler</b> will be instructive in highlighting required
  arguments and techniques.
<div style="height: 1.00em;">&#x00A0;</div>
To provide a <b>response_&lt;something&gt;</b> response-body evaluator a
  subclass must define:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>test_key_suffix</b>: This, along with the prefix
      <b>response_</b>, forms the key used in the test structure. It is a class
      level string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>test_key_value</b>: The key's default value, either an
      empty list ( <b>[]</b>) or empty dict ( <b>{}</b>). It is a class level
      value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>action</b>: An instance method which tests the expected
      values against the HTTP response - it is invoked for each entry, with the
      parameters depending on the default value. The arguments to <b>action</b>
      are (in order):</dd>
</dl>
<div style="margin-left: 2.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>self</b>: The current instance.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>test</b>: The currently active <b>HTTPTestCase</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>item</b>: The current entry if <b>test_key_value</b> is
      a list, otherwise the key half of the key/value pair at this entry.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>value</b>: <b>None</b> if <b>test_key_value</b> is a
      list, otherwise the value half of the key/value pair at this entry.</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To translate request or response bodies to or from structured data a subclass
  must define an <b>accepts</b> method. This should return <b>True</b> if this
  class is willing to translate the provided content-type. During request
  processing it is given the value of the content-type header that will be sent
  in the request. During response processing it is given the value of the
  content-type header of the response. This makes it possible to handle
  different request and response bodies in the same handler, if desired. For
  example a handler might accept <b>application/x-www-form-urlencoded</b> and
  <b>text/html</b>.
<div style="height: 1.00em;">&#x00A0;</div>
If <b>accepts</b> is defined two additional static methods should be defined:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>dumps</b>: Turn structured Python data from the
      <b>data</b> key in a test into a string or byte stream.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>loads</b>: Turn a string or byte stream in a response
      into a Python data structure. Gabbi will put this data on the
      <b>response_data</b> attribute on the test, where it can be used in the
      evaluations described above (in the <b>action</b> method) or in
      <b>$RESPONSE</b> handling. An example usage here would be to turn HTML
      into a DOM.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Finally if a <b>replacer</b> class method is defined, then when a
  <b>$RESPONSE</b> substitution is encountered, <b>replacer</b> will be passed
  the <b>response_data</b> of the prior test and the argument within the
  <b>$RESPONSE</b>.
<div style="height: 1.00em;">&#x00A0;</div>
Please see the <i>JSONHandler source</i> for additional detail.
<div style="height: 1.00em;">&#x00A0;</div>
If there is a running web service that needs to be tested and creating a test
  loader with <b>build_tests()</b> is either inconvenient or overkill it is
  possible to run YAML test files directly from the command line with the
  console-script <b>gabbi-run</b>. It accepts YAML on <b>stdin</b> or as
  multiple file arguments, and generates and runs tests and outputs a summary of
  the results.
<div style="height: 1.00em;">&#x00A0;</div>
The provided YAML may not use custom fixtures but otherwise uses the default
  format. host information is either expressed directly in the YAML file or
  provided on the command line:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run [host[:port]] &lt; /my/test.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
or:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run http://host:port &lt; /my/test.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To test with one or more files the following command syntax may be used:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run http://host:port -- /my/test.yaml /my/other.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>NOTE:</b>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">The filename arguments must come after a
  <b>--</b> and all other arguments (host, port, prefix, failfast) must come
  before the <b>--</b>.</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To facilitate using the same tests against the same application mounted in
  different locations in a WSGI server, a <b>prefix</b> may be provided as a
  second argument:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run host[:port] [prefix] &lt; /my/test.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
or in the target URL:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run http://host:port/prefix &lt; /my/test.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
The value of prefix will be prepended to the path portion of URLs that are not
  fully qualified.
<div style="height: 1.00em;">&#x00A0;</div>
Anywhere host is used, if it is a raw IPV6 address it should be wrapped in
  <b>[</b> and <b>]</b>.
<div style="height: 1.00em;">&#x00A0;</div>
If <b>https</b> is used in the target, then the tests in the provided YAML will
  default to <b>ssl: True</b>.
<div style="height: 1.00em;">&#x00A0;</div>
If a <b>-x</b> or <b>--failfast</b> argument is provided then <b>gabbi-run</b>
  will exit after the first test failure.
<div style="height: 1.00em;">&#x00A0;</div>
These are informal release notes for gabbi since version 1.0.0, highlighting
  major features and changes. For more detail see the <i>commit logs</i> on
  GitHub.
<h1 class="Sh" title="Sh" id="1.27.0"><a class="selflink" href="#1.27.0">1.27.0</a></h1>
Allow gabbi-run to accept multiple filenames as command line arguments instead
  of reading tests from stdin.
<h1 class="Sh" title="Sh" id="1.26.0"><a class="selflink" href="#1.26.0">1.26.0</a></h1>
Switch from response handlers to handlers to allow more flexible processing of
  both response _and_ request bodies.
<div style="height: 1.00em;">&#x00A0;</div>
Add inner fixtures for per test fixtures, useful for output capturing.
<h1 class="Sh" title="Sh" id="1.25.0"><a class="selflink" href="#1.25.0">1.25.0</a></h1>
Allow the <b>test_loader_name</b> arg to <b>gabbi.driver.build_tests()</b> to
  override the prefix of the pretty printed name of generated tests.
<h1 class="Sh" title="Sh" id="1.24.0"><a class="selflink" href="#1.24.0">1.24.0</a></h1>
String values in JSONPath matches may be wrapped in <b>/.../`</b> to be treated
  as regular expressions.
<h1 class="Sh" title="Sh" id="1.23.0"><a class="selflink" href="#1.23.0">1.23.0</a></h1>
Better documentation of how to run gabbi in a concurrent environment. Improved
  handling of pytest fixtures and test counts.
<h1 class="Sh" title="Sh" id="1.22.0"><a class="selflink" href="#1.22.0">1.22.0</a></h1>
Add <b>url</b> to <b>gabbi.driver.build_tests()</b> to use instead of
  <b>host</b>, <b>port</b> and <b>prefix</b>.
<h1 class="Sh" title="Sh" id="1.21.0"><a class="selflink" href="#1.21.0">1.21.0</a></h1>
Add <b>require_ssl</b> to <b>gabbi.driver.build_tests()</b> to force use of SSL.
<h1 class="Sh" title="Sh" id="1.20.0"><a class="selflink" href="#1.20.0">1.20.0</a></h1>
Add <b>$COOKIE</b> substitution.
<h1 class="Sh" title="Sh" id="1.19.1"><a class="selflink" href="#1.19.1">1.19.1</a></h1>
Correctly support IPV6 hosts.
<h1 class="Sh" title="Sh" id="1.19.0"><a class="selflink" href="#1.19.0">1.19.0</a></h1>
Add <b>$LAST_URL</b> substitution.
<h1 class="Sh" title="Sh" id="1.17.0"><a class="selflink" href="#1.17.0">1.17.0</a></h1>
Introduce support for loading and running tests with pytest.
<h1 class="Sh" title="Sh" id="1.16.0"><a class="selflink" href="#1.16.0">1.16.0</a></h1>
Use urllib3 instead of httplib2 for driving HTTP requests.
<h1 class="Sh" title="Sh" id="1.13.0"><a class="selflink" href="#1.13.0">1.13.0</a></h1>
Add sorting and filtering to jsonpath handling.
<h1 class="Sh" title="Sh" id="1.11.0"><a class="selflink" href="#1.11.0">1.11.0</a></h1>
Add the <b>response_forbidden_headers</b> to response expectations.
<h1 class="Sh" title="Sh" id="1.7.0"><a class="selflink" href="#1.7.0">1.7.0</a></h1>
Instead of:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
tests:
- name: a simple get
  url: /some/path
  method: get
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
1.7.0 also makes it possible to:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
tests:
- name: a simple get
  GET: /some/path
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Any upper case key is treated as a method.
<h1 class="Sh" title="Sh" id="1.4.0_AND_1.5.0"><a class="selflink" href="#1.4.0_AND_1.5.0">1.4.0
  AND 1.5.0</a></h1>
Enhanced flexibility and colorization when setting tests to be verbose.
<h1 class="Sh" title="Sh" id="1.3.0"><a class="selflink" href="#1.3.0">1.3.0</a></h1>
Adds the <b>query_parameters</b> key to request parameters.
<h1 class="Sh" title="Sh" id="1.2.0"><a class="selflink" href="#1.2.0">1.2.0</a></h1>
The start of improvements and extensions to jsonpath handling. In this case the
  addition of the <b>len</b> function.
<h1 class="Sh" title="Sh" id="1.1.0"><a class="selflink" href="#1.1.0">1.1.0</a></h1>
Vastly improved output and behavior in gabbi-run.
<h1 class="Sh" title="Sh" id="1.0.0"><a class="selflink" href="#1.0.0">1.0.0</a></h1>
Version 1 was the first release with a commitment to a stable format. Since then
  new fields have been added but have not been taken away.
<div style="height: 1.00em;">&#x00A0;</div>
The following people have contributed code to gabbi. Thanks to them. Thanks also
  to all the people who have made gabbi better by reporting <i>issues</i> and
  their successes and failures with using gabbi.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Chris Dent</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">FND</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Mehdi Abaakouk</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Jason Myers</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Kim Raymoure</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Michael McCune</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Imran Hayder</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Julien Danjou</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Danek Duvall</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Marc Abramowitz</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
<b>NOTE:</b>
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">This section provides a collection of
  questions with answers that don't otherwise fit in the rest of the
  documentation. If something is missing, please create an <i>issue</i>.
<div style="height: 1.00em;">&#x00A0;</div>
As this document grows it will gain a more refined structure.</div>
<br/>
</div>
<br/>
<h1 class="Sh" title="Sh" id="GENERAL"><a class="selflink" href="#GENERAL">GENERAL</a></h1>
<h2 class="Ss" title="Ss" id="Is_gabbi_only_for_testing_Python-based_APIs?"><a class="selflink" href="#Is_gabbi_only_for_testing_Python-based_APIs?">Is
  gabbi only for testing Python-based APIs?</a></h2>
No, you can use gabbi-run to test an HTTP service built in any programming
  language.
<h1 class="Sh" title="Sh" id="WORKAROUNDS"><a class="selflink" href="#WORKAROUNDS">WORKAROUNDS</a></h1>
<h2 class="Ss" title="Ss" id="pytest_produces_warnings_about_yield_tests._Can_I_make_them_stop?"><a class="selflink" href="#pytest_produces_warnings_about_yield_tests._Can_I_make_them_stop?">pytest
  produces warnings about yield tests. Can I make them stop?</a></h2>
Yes, run as <b>py.test --disable-pytest-warnings</b> to quiet the warnings. Or
  use a version of pytest less than <b>3.0</b>. For more details see pytest.
<h1 class="Sh" title="Sh" id="TESTING_STYLE"><a class="selflink" href="#TESTING_STYLE">TESTING
  STYLE</a></h1>
<h2 class="Ss" title="Ss" id="Can_I_have_variables_in_my_YAML_file?"><a class="selflink" href="#Can_I_have_variables_in_my_YAML_file?">Can
  I have variables in my YAML file?</a></h2>
Gabbi provides the <b>$ENVIRON</b> substitution which can operate a bit like
  variables that are set elsewhere and then used in the tests defined by the
  YAML.
<div style="height: 1.00em;">&#x00A0;</div>
If you find it necessary to have variables within a single YAML file you take
  advantage of YAML <i>alias nodes</i> list this:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
vars:
  - &amp;uuid_1 5613AABF-BAED-4BBA-887A-252B2D3543F8
<div class="Pp"></div>
tests:
- name: send a uuid to a post
  POST: /resource
  request_headers:
    content-type: application/json
  data:
    uuid: *uuid_1
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
You can alias all sorts of nodes, not just single items. Be aware that the
  replacement of an alias node happens while the YAML is being loaded, before
  gabbi does any processing.
<h2 class="Ss" title="Ss" id="How_many_tests_should_be_put_in_one_YAML_file?"><a class="selflink" href="#How_many_tests_should_be_put_in_one_YAML_file?">How
  many tests should be put in one YAML file?</a></h2>
For the sake of readability it is best to keep each YAML file relatively short.
  Since each YAML file represents a sequence of requests, it usually makes sense
  to create a new file when a test is not dependent on any before it.
<div style="height: 1.00em;">&#x00A0;</div>
It's tempting to put all the tests for any resource or URL in the same file, but
  this eventually leads to files that are too long and are thus difficult to
  read.
<h1 class="Sh" title="Sh" id="CASE_MODULE"><a class="selflink" href="#CASE_MODULE">CASE
  MODULE</a></h1>
A single HTTP request represented as a subclass of <b>testtools.TestCase</b>
<div style="height: 1.00em;">&#x00A0;</div>
The test case encapsulates the request headers and body and expected response
  headers and body. When the test is run an HTTP request is made using urllib3.
  Assertions are made against the reponse.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.case.HTTPTestCase(*args, **kwargs)</b></dt>
  <dd class="It-tag">Bases: <b>testtools.testcase.TestCase</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Encapsulate a single HTTP request as a TestCase.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the test is a member of a sequence of requests, ensure that prior tests
      are run.
    <div style="height: 1.00em;">&#x00A0;</div>
    To keep the test harness happy we need to make sure the setUp and tearDown
      are only run once.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>assert_in_or_print_output(expected, iterable)</b></dt>
  <dd class="It-tag">Assert the iterable contains expected or print some output.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the output is long, it is limited by either GABBI_MAX_CHARS_OUTPUT in the
      environment or the MAX_CHARS_OUTPUT constant.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>base_test = {'status': '200', 'xfail': False,
    'redirects': False, 'verbose': False, 'query_parameters': {}, 'url': '',
    'skip': '', 'name': '', 'ssl': False, 'request_headers': {}, 'poll': {},
    'data': '', 'method': 'GET', 'desc': ''}</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>get_content_handler(content_type)</b></dt>
  <dd class="It-tag">Determine the content handler for this media type.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>replace_template(message)</b></dt>
  <dd class="It-tag">Replace magic strings in message.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>run(result=None)</b></dt>
  <dd class="It-tag">Store the current result handler on this test.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>setUp()</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>tearDown()</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_request()</b></dt>
  <dd class="It-tag">Run this request if it has not yet run.
    <div style="height: 1.00em;">&#x00A0;</div>
    If there is a prior test in the sequence, run it first.</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.case.potentialFailure(func)</b></dt>
  <dd class="It-tag">Decorate a test method that is expected to fail if 'xfail'
      is true.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="DRIVER_MODULE"><a class="selflink" href="#DRIVER_MODULE">DRIVER
  MODULE</a></h1>
Generate HTTP tests from YAML files
<div style="height: 1.00em;">&#x00A0;</div>
Each HTTP request is its own TestCase and can be requested to be run in
  isolation from other tests. If it is a member of a sequence of requests, prior
  requests will be run.
<div style="height: 1.00em;">&#x00A0;</div>
A sequence is represented by an ordered list in a single YAML file.
<div style="height: 1.00em;">&#x00A0;</div>
Each sequence becomes a TestSuite.
<div style="height: 1.00em;">&#x00A0;</div>
An entire directory of YAML files is a TestSuite of TestSuites.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.driver.build_tests(path, loader, host=None,
    port=8001, intercept=None, test_loader_name=None, fixture_module=None,
    response_handlers=None, content_handlers=None, prefix='', require_ssl=False,
    url=None, inner_fixtures=None)</b></dt>
  <dd class="It-tag">Read YAML files from a directory to create tests.
    <div style="height: 1.00em;">&#x00A0;</div>
    Each YAML file represents an ordered sequence of HTTP requests.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Parameters</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>path</b> -- The directory where yaml files are
    located.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>loader</b> -- The TestLoader.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>host</b> -- The host to test against. Do not use with
      <b>intercept</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>port</b> -- The port to test against. Used with
      <b>host</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>intercept</b> -- WSGI app factory for
    wsgi-intercept.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>test_loader_name</b> -- Base name for test classes. Use
      this to align the naming of the tests with other tests in a system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>fixture_module</b> -- Python module containing fixture
      classes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>response_handers</b> -- <b>ResponseHandler</b>
    classes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>content_handlers</b> (<i>List of ContentHandler
      classes.</i>) -- ContentHandler classes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>prefix</b> -- A URL prefix for all URLs that are not
      fully qualified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>url</b> -- A full URL to test against. Replaces host,
      port and prefix.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>require_ssl</b> -- If <b>True</b>, make all tests
      default to using SSL.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>inner_fixtures</b> (<i>List of fixtures.Fixture
      classes.</i>) -- A list of <b>Fixtures</b> to use with each individual
      test request.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Return type</b></dt>
  <dd class="It-tag">TestSuite containing multiple TestSuites (one for each YAML
      file)</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.driver.py_test_generator(test_dir, host=None,
    port=8001, intercept=None, prefix=None, test_loader_name=None,
    fixture_module=None, response_handlers=None, content_handlers=None,
    require_ssl=False, url=None)</b></dt>
  <dd class="It-tag">Generate tests cases for py.test
    <div style="height: 1.00em;">&#x00A0;</div>
    This uses build_tests to create TestCases and then yields them in a way that
      pytest can handle.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.driver.test_suite_from_yaml(loader,
    test_base_name, test_yaml, test_directory, host, port, fixture_module,
    intercept, prefix='')</b></dt>
  <dd class="It-tag">Legacy wrapper retained for backwards compatibility.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="SUITEMAKER_MODULE"><a class="selflink" href="#SUITEMAKER_MODULE">SUITEMAKER
  MODULE</a></h1>
The code that creates a suite of tests.
<div style="height: 1.00em;">&#x00A0;</div>
The key piece of code is <i>test_suite_from_dict()</i>. It produces a
  <i>gabbi.suite.GabbiSuite</i> containing one or more
  <i>gabbi.case.HTTPTestCase</i>.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.suitemaker.TestBuilder</b></dt>
  <dd class="It-tag">Bases: <b>type</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Metaclass to munge a dynamically created test.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>required_attributes = {'has_run': False}</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.suitemaker.TestMaker(test_base_name,
    test_defaults, test_directory, fixture_classes, loader, host, port,
    intercept, prefix, response_handlers, content_handlers,
    test_loader_name=None, inner_fixtures=None)</b></dt>
  <dd class="It-tag">Bases: <b>object</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    A class for encapsulating test invariants.
    <div style="height: 1.00em;">&#x00A0;</div>
    All of the tests in a single gabbi file have invariants which are provided
      when creating each HTTPTestCase. It is not useful to pass these around
      when making each test case. So they are wrapped in this class which then
      has make_one_test called multiple times to generate all the tests in the
      suite.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>make_one_test(test_dict, prior_test)</b></dt>
  <dd class="It-tag">Create one single HTTPTestCase.
    <div style="height: 1.00em;">&#x00A0;</div>
    The returned HTTPTestCase is added to the TestSuite currently being built
      (one per YAML file).</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.suitemaker.test_suite_from_dict(loader,
    test_base_name, suite_dict, test_directory, host, port, fixture_module,
    intercept, prefix='', handlers=None, test_loader_name=None,
    inner_fixtures=None)</b></dt>
  <dd class="It-tag">Generate a GabbiSuite from a dict represent a list of
      tests.
    <div style="height: 1.00em;">&#x00A0;</div>
    The dict takes the form:</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>Parameters</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>fixtures</b> -- An optional list of fixture classes that
      this suite can use.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>defaults</b> -- An optional dictionary of default values
      to be used in each test.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>tests</b> -- A list of individual tests, themselves each
      being a dictionary. See <b>gabbi.case.BASE_TEST</b>.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.suitemaker.test_update(orig_dict,
    new_dict)</b></dt>
  <dd class="It-tag">Modify test in place to update with new data.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="FIXTURE_MODULE"><a class="selflink" href="#FIXTURE_MODULE">FIXTURE
  MODULE</a></h1>
Manage fixtures for gabbi at the test suite level.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.fixture.GabbiFixture</b></dt>
  <dd class="It-tag">Bases: <b>object</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    A context manager that operates as a fixture.
    <div style="height: 1.00em;">&#x00A0;</div>
    Subclasses must implement <b>start_fixture</b> and <b>stop_fixture</b>, each
      of which contain the logic for stopping and starting whatever the fixture
      is. What a fixture is is left as an exercise for the implementor.
    <div style="height: 1.00em;">&#x00A0;</div>
    These context managers will be nested so any actual work needs to happen in
      <b>start_fixture</b> and <b>stop_fixture</b> and not in <b>__init__</b>.
      Otherwise exception handling will not work properly.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>start_fixture()</b></dt>
  <dd class="It-tag">Implement the actual workings of starting the fixture
    here.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>stop_fixture()</b></dt>
  <dd class="It-tag">Implement the actual workings of stopping the fixture
    here.</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>exception gabbi.fixture.GabbiFixtureError</b></dt>
  <dd class="It-tag">Bases: <b>exceptions.Exception</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Generic exception for GabbiFixture.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.fixture.SkipAllFixture</b></dt>
  <dd class="It-tag">Bases: <i>gabbi.fixture.GabbiFixture</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    A fixture that skips all the tests in the current suite.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>start_fixture()</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.fixture.nest(*args, **kwds)</b></dt>
  <dd class="It-tag">Nest a series of fixtures.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is duplicated from <b>nested</b> in the stdlib, which has been
      deprecated because of issues with how exceptions are difficult to handle
      during <b>__init__</b>. Gabbi needs to nest an unknown number of fixtures
      dynamically, so the <b>with</b> syntax that replaces <b>nested</b> will
      not work.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="HANDLERS_MODULE"><a class="selflink" href="#HANDLERS_MODULE">HANDLERS
  MODULE</a></h1>
Package for response and content handlers that process the body of a response in
  various ways.
<h2 class="Ss" title="Ss" id="handlers.base_Module"><a class="selflink" href="#handlers.base_Module"><b>handlers.base</b>
  Module</a></h2>
Base classes for response and content handlers.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.handlers.base.ContentHandler</b></dt>
  <dd class="It-tag">Bases: <i>gabbi.handlers.base.ResponseHandler</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    A subclass of ResponseHandlers that adds content handling.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>static accepts(content_type)</b></dt>
  <dd class="It-tag">Return True if this handler can handler this type.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>static dumps(data, pretty=False)</b></dt>
  <dd class="It-tag">Return structured data as a string.
    <div style="height: 1.00em;">&#x00A0;</div>
    If pretty is true, prettify.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>classmethod gen_replacer(test)</b></dt>
  <dd class="It-tag">Return a function which does RESPONSE replacing.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>static loads(data)</b></dt>
  <dd class="It-tag">Create structured (Python) data from a stream.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>classmethod replacer(response_data, path)</b></dt>
  <dd class="It-tag">Return the string the is replacing RESPONSE.</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.handlers.base.ResponseHandler</b></dt>
  <dd class="It-tag">Bases: <b>object</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Add functionality for making assertions about an HTTP response.
    <div style="height: 1.00em;">&#x00A0;</div>
    A subclass may implement two methods: <b>action</b> and <b>preprocess</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>preprocess</b> takes one argument, the <b>TestCase</b>. It is called
      exactly once for each test before looping across the assertions. It is
      used, rarely, to copy the <b>test.output</b> into a useful form (such as a
      parsed DOM).
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>action</b> takes two or three arguments. If <b>test_key_value</b> is a
      list <b>action</b> is called with the test case and a single list item. If
      <b>test_key_value</b> is a dict then <b>action</b> is called with the test
      case and a key and value pair.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>action(test, item, value=None)</b></dt>
  <dd class="It-tag">Test an individual entry for this response handler.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the entry is a key value pair the key is in item and the value in value.
      Otherwise the entry is considered a single item from a list.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>preprocess(test)</b></dt>
  <dd class="It-tag">Do any pre-single-test preprocessing.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_key_suffix = ''</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_key_value = []</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="handlers.core_Module"><a class="selflink" href="#handlers.core_Module"><b>handlers.core</b>
  Module</a></h2>
Core response handlers.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class
    gabbi.handlers.core.ForbiddenHeadersResponseHandler</b></dt>
  <dd class="It-tag">Bases: <i>gabbi.handlers.base.ResponseHandler</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    Test that listed headers are not in the response.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>action(test, forbidden, value=None)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_key_suffix = 'forbidden_headers'</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_key_value = []</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class
    gabbi.handlers.core.HeadersResponseHandler</b></dt>
  <dd class="It-tag">Bases: <i>gabbi.handlers.base.ResponseHandler</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    Compare expected headers with actual headers.
    <div style="height: 1.00em;">&#x00A0;</div>
    If a header value is wrapped in <b>/</b> it is treated as a raw regular
      expression.
    <div style="height: 1.00em;">&#x00A0;</div>
    Headers values are always treated as strings.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>action(test, header, value=None)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_key_suffix = 'headers'</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_key_value = {}</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.handlers.core.StringResponseHandler</b></dt>
  <dd class="It-tag">Bases: <i>gabbi.handlers.base.ResponseHandler</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    Test for matching strings in the the response body.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>action(test, expected, value=None)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_key_suffix = 'strings'</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_key_value = []</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
</div>
<br/>
<h2 class="Ss" title="Ss" id="handlers.jsonhandler_Module"><a class="selflink" href="#handlers.jsonhandler_Module"><b>handlers.jsonhandler</b>
  Module</a></h2>
JSON-related content handling.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.handlers.jsonhandler.JSONHandler</b></dt>
  <dd class="It-tag">Bases: <i>gabbi.handlers.base.ContentHandler</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    A ContentHandler for JSON</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Structured test <b>data</b> is turned into JSON when
      request content-type is JSON.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Response bodies that are JSON strings are made into Python
      data on the test <b>response_data</b> attribute when the response
      content-type is JSON.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A <b>response_json_paths</b> response handler is
    added.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">JSONPaths in $RESPONSE substitutions are supported.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>static accepts(content_type)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>action(test, path, value=None)</b></dt>
  <dd class="It-tag">Test json_paths against json data.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>static dumps(data, pretty=False)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>static extract_json_path_value(data, path)</b></dt>
  <dd class="It-tag">Extract the value at JSON Path path from the data.
    <div style="height: 1.00em;">&#x00A0;</div>
    The input data is a Python datastructure, not a JSON string.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>static loads(data)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>classmethod replacer(response_data, match)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_key_suffix = 'json_paths'</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>test_key_value = {}</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
</div>
<br/>
<h1 class="Sh" title="Sh" id="SUITE_MODULE"><a class="selflink" href="#SUITE_MODULE">SUITE
  MODULE</a></h1>
A TestSuite for containing gabbi tests.
<div style="height: 1.00em;">&#x00A0;</div>
This suite has two features: the contained tests are ordered and there are
  suite-level fixtures that operate as context managers.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.suite.GabbiSuite(tests=())</b></dt>
  <dd class="It-tag">Bases: <b>unittest.suite.TestSuite</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    A TestSuite with fixtures.
    <div style="height: 1.00em;">&#x00A0;</div>
    The suite wraps the tests with a set of nested context managers that operate
      as fixtures.
    <div style="height: 1.00em;">&#x00A0;</div>
    If a fixture raises unittest.case.SkipTest during setup, all the tests in
      this suite will be skipped.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>run(result, debug=False)</b></dt>
  <dd class="It-tag">Override TestSuite run to start suite-level fixtures.
    <div style="height: 1.00em;">&#x00A0;</div>
    To avoid exception confusion, use a null Fixture when there are no
    fixtures.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>start(result)</b></dt>
  <dd class="It-tag">Start fixtures when using pytest.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>stop()</b></dt>
  <dd class="It-tag">Stop fixtures when using pytest.</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.suite.noop(*args)</b></dt>
  <dd class="It-tag">A noop method used to disable collected tests.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="RUNNER_MODULE"><a class="selflink" href="#RUNNER_MODULE">RUNNER
  MODULE</a></h1>
Implementation of a command-line runner for gabbi files (AKA suites).
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.runner.extract_file_paths(argv)</b></dt>
  <dd class="It-tag">Extract command-line arguments following the <i>--</i>
      end-of-options delimiter, if any.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.runner.initialize_handlers(response_handlers)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.runner.load_response_handlers(import_path)</b></dt>
  <dd class="It-tag">Load and return custom response handlers from the given
      Python package or module.
    <div style="height: 1.00em;">&#x00A0;</div>
    The import path references either a specific response handler class
      (&quot;package.module:class&quot;) or a module that contains one or more
      response handler classes (&quot;package.module&quot;).
    <div style="height: 1.00em;">&#x00A0;</div>
    For the latter, the module is expected to contain a
      <b>gabbi_response_handlers</b> object, which is either a list of response
      handler classes or a function returning such a list.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.runner.run()</b></dt>
  <dd class="It-tag">Run simple tests from STDIN.
    <div style="height: 1.00em;">&#x00A0;</div>
    This command provides a way to run a set of tests encoded in YAML that is
      provided on STDIN. No fixtures are supported, so this is primarily
      designed for use with real running services.
    <div style="height: 1.00em;">&#x00A0;</div>
    Host and port information may be provided in three different ways:</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">In the URL value of the tests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">In a <i>host</i> or <i>host:port</i> argument on the
      command line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">In a URL on the command line.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
An example run might looks like this:
<div style="margin-left: 7.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run example.com:9999 &lt; mytest.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
or:
<div style="margin-left: 7.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run http://example.com:999 &lt; mytest.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
It is also possible to provide a URL prefix which can be useful if the target
  application might be mounted in different locations. An example:
<div style="margin-left: 7.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run example.com:9999 /mountpoint &lt; mytest.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
or:
<div style="margin-left: 7.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run http://example.com:9999/mountpoint &lt; mytest.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Use <i>-x</i> or <i>--failfast</i> to abort after the first error or failure:
<div style="margin-left: 7.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run -x example.com:9999 /mountpoint &lt; mytest.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Multiple files may be named as arguments, separated from other arguments by a
  <b>--</b>. Each file will be run as a separate test suite:
<div style="margin-left: 7.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gabbi-run http://example.com -- /path/to/x.yaml /path/to/y.yaml
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Output is formatted as unittest summary information.</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.runner.run_suite(handle, handler_objects, host,
    port, prefix, force_ssl=False, failfast=False)</b></dt>
  <dd class="It-tag">Run the tests from the YAML in handle.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="REPORTER_MODULE"><a class="selflink" href="#REPORTER_MODULE">REPORTER
  MODULE</a></h1>
TestRunner and TestResult for gabbi-run.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.reporter.ConciseTestResult(stream,
    descriptions, verbosity)</b></dt>
  <dd class="It-tag">Bases: <b>unittest.runner.TextTestResult</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    A TextTestResult with simple but useful output.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the output is a tty or GABBI_FORCE_COLOR is set in the environment,
      output will be colorized.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addError(test, err)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addExpectedFailure(test, err)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addFailure(test, err)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addSkip(test, reason)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addSuccess(test)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addUnexpectedSuccess(test)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>getDescription(test)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>printErrorList(flavor, errors)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>startTest(test)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.reporter.ConciseTestRunner(stream=&lt;open
    file '&lt;stderr&gt;', mode 'w'&gt;, descriptions=True, verbosity=1,
    failfast=False, buffer=False, resultclass=None)</b></dt>
  <dd class="It-tag">Bases: <b>unittest.runner.TextTestRunner</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    A TextTestRunner that uses ConciseTestResult for reporting results.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>resultclass</b></dt>
  <dd class="It-tag">alias of <i>ConciseTestResult</i></dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.reporter.PyTestResult(stream=None,
    descriptions=None, verbosity=None)</b></dt>
  <dd class="It-tag">Bases: <b>unittest.result.TestResult</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Wrap a test result to allow it to work with pytest.
    <div style="height: 1.00em;">&#x00A0;</div>
    The main behaviors here are:</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">to turn what had been exceptions back into exceptions</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">use pytest's skip and xfail methods</dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addError(test, err)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addExpectedFailure(test, err)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addFailure(test, err)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addSkip(test, reason)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
</div>
<br/>
<h1 class="Sh" title="Sh" id="UTILS_MODULE"><a class="selflink" href="#UTILS_MODULE">UTILS
  MODULE</a></h1>
Utility functions grab bag.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.utils.create_url(base_url, host, port=None,
    prefix='', ssl=False)</b></dt>
  <dd class="It-tag">Given pieces of a path-based url, return a fully qualified
      url.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.utils.decode_response_content(header_dict,
    content)</b></dt>
  <dd class="It-tag">Decode content to a proper string.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.utils.extract_content_type(header_dict,
    default='application/binary')</b></dt>
  <dd class="It-tag">Extract parsed content-type from headers.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.utils.get_colorizer(stream)</b></dt>
  <dd class="It-tag">Return a function to colorize a string.
    <div style="height: 1.00em;">&#x00A0;</div>
    Only if stream is a tty .</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.utils.host_info_from_target(target,
    prefix=None)</b></dt>
  <dd class="It-tag">Turn url or host:port and target into test
    destination.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.utils.load_yaml(handle=None,
    yaml_file=None)</b></dt>
  <dd class="It-tag">Read and parse any YAML file or filehandle.
    <div style="height: 1.00em;">&#x00A0;</div>
    Let exceptions flow where they may.
    <div style="height: 1.00em;">&#x00A0;</div>
    If no file or handle is provided, read from STDIN.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.utils.not_binary(content_type)</b></dt>
  <dd class="It-tag">Decide if something is content we'd like to treat as a
      string.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.utils.parse_content_type(content_type,
    default_charset='utf-8')</b></dt>
  <dd class="It-tag">Parse content type value for media type and charset.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="EXCEPTION_MODULE"><a class="selflink" href="#EXCEPTION_MODULE">EXCEPTION
  MODULE</a></h1>
Gabbi specific exceptions.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>exception gabbi.exception.GabbiFormatError</b></dt>
  <dd class="It-tag">Bases: <b>exceptions.ValueError</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    An exception to encapsulate poorly formed test data.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>exception gabbi.exception.GabbiSyntaxWarning</b></dt>
  <dd class="It-tag">Bases: <b>exceptions.SyntaxWarning</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    A warning about syntax that is not desirable.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="HTTPCLIENT_MODULE"><a class="selflink" href="#HTTPCLIENT_MODULE">HTTPCLIENT
  MODULE</a></h1>
Subclass of Http class for verbosity.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.httpclient.Http(num_pools=10, headers=None,
    **connection_pool_kw)</b></dt>
  <dd class="It-tag">Bases: <b>urllib3.poolmanager.PoolManager</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    A subclass of the urllib3.PoolManager to munge the data.
    <div style="height: 1.00em;">&#x00A0;</div>
    This transforms the response to look more like what httplib2 provided when
      it was used as the httpclient.</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>request(absolute_uri, method, body, headers,
    redirect)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>class gabbi.httpclient.VerboseHttp(**kwargs)</b></dt>
  <dd class="It-tag">Bases: <i>gabbi.httpclient.Http</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    A subclass of Http that verbosely reports on activity.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the output is a tty or <b>GABBI_FORCE_COLOR</b> is set in the
      environment, then output will be colorized according to <b>COLORMAP</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Output can include request and response headers, request and response body
      content (if of a printable content-type), or both.
    <div style="height: 1.00em;">&#x00A0;</div>
    The color of the output has reasonable defaults. These may be overridden by
      setting the following environment variables</dd>
</dl>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">GABBI_CAPTION_COLOR</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">GABBI_HEADER_COLOR</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">GABBI_REQUEST_COLOR</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">GABBI_STATUS_COLOR</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
to any of: BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>COLORMAP = {'status': 'CYAN', 'caption': 'BLUE',
    'request': 'CYAN', 'header': 'YELLOW'}</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>HEADER_BLACKLIST = ['status', 'reason']</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>REQUEST_PREFIX = '&gt;'</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>RESPONSE_PREFIX = '&lt;'</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<br/>
<div style="margin-left: 7.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>request(absolute_uri, method, body, headers,
    redirect)</b></dt>
  <dd class="It-tag">Display request parameters before requesting.</dd>
</dl>
</div>
<br/>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.httpclient.get_http(verbose=False,
    caption='')</b></dt>
  <dd class="It-tag">Return an Http class for making requests.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="JSON_PARSER_MODULE"><a class="selflink" href="#JSON_PARSER_MODULE">JSON_PARSER
  MODULE</a></h1>
Keep one single global jsonpath parser.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gabbi.json_parser.parse(path)</b></dt>
  <dd class="It-tag">Parse a JSONPath expression use the global parser.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Gabbi is a tool for running HTTP tests where requests and responses are
  expressed as declarations in a collection of YAML files. The simplest test
  looks like this:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
tests:
- name: A test
  GET: /api/resources/id
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
See the rest of these docs for more details on the many features and formats for
  setting request headers and bodies and evaluating responses.
<div style="height: 1.00em;">&#x00A0;</div>
The name is derived from &quot;gabby&quot;: excessively talkative. In a test
  environment having visibility of what a test is actually doing is a good
  thing. This is especially true when the goal of a test is to test the HTTP,
  not the testing infrastructure. Gabbi tries to put the HTTP interaction in the
  foreground of testing.
<div style="height: 1.00em;">&#x00A0;</div>
Tests can be run using unittest style test runners or py.test or from the
  command line with a gabbi-run script.
<div style="height: 1.00em;">&#x00A0;</div>
If you want to get straight to creating tests look at example, the test files in
  the <i>source distribution</i> and format. A <i>gabbi-demo</i> repository
  provides a tutorial of using gabbi to build an API, via the commit history of
  the repo.
<h1 class="Sh" title="Sh" id="PURPOSE"><a class="selflink" href="#PURPOSE">PURPOSE</a></h1>
Gabbi works to bridge the gap between human readable YAML files (see format for
  details) that represent HTTP requests and expected responses and the rather
  complex world of automated testing.
<div style="height: 1.00em;">&#x00A0;</div>
Each YAML file represents an ordered list of HTTP requests along with the
  expected responses. This allows a single file to represent a process in the
  API being tested. For example:
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Create a resource.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Retrieve a resource.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Delete a resource.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Retrieve a resource again to confirm it is gone.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
At the same time it is still possible to ask gabbi to run just one request. If
  it is in a sequence of tests, those tests prior to it in the YAML file will be
  run (in order). In any single process any test will only be run once.
  Concurrency is handled such that one file runs in one process.
<div style="height: 1.00em;">&#x00A0;</div>
These features mean that it is possible to create tests that are useful for both
  humans (as tools for learning, improving and developing APIs) and automated CI
  systems.
<div style="height: 1.00em;">&#x00A0;</div>
Significant flexibility and power is available in the format to make it
  relatively straightforward to test existing complex APIs. This extended
  functionality includes the use of <i>JSONPath</i> to query response bodies and
  templating of test data to allow access to the prior HTTP response in the
  current request. For APIs which do not use JSON additional handlers can be
  created.
<div style="height: 1.00em;">&#x00A0;</div>
Care should be taken when using this functionality when you are creating a new
  API. If your API is so complex that it needs complex test files then you may
  wish to take that as a sign that your API itself too complex. One goal of
  gabbi is to encourage transparent and comprehensible APIs.
<div style="height: 1.00em;">&#x00A0;</div>
Though gabbi is written in Python and under the covers uses <b>unittest</b> data
  structures and processes, there is no requirement that the host be a
  Python-based service. Anything talking HTTP can be tested. A runner makes it
  possible to simply create YAML files and point them at a running server.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Chris Dent</div>
<table class="foot">
  <tr>
    <td class="foot-date">February 11, 2017</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
