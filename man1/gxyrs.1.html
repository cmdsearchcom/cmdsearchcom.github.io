<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:16:15 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>gxyrs(1) gxyrs gxyrs(1)</p>

<p style="margin-top: 1em">NAME <br>
gxyrs - is a program to batch process XYRS files.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
gxyrs file [OPTIONS]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
XYRS files are usually generated by PCB design programs, and
are used by board assemblers.</p>

<p style="margin-top: 1em">Format of XYRS files is
discussed in FILES section.</p>

<p style="margin-top: 1em">Processing of these files is
often needed by board assemblers or designers to suit their
process and tools flows.</p>

<p style="margin-top: 1em">gxyrs helps batch-processing
these files. Rules and commands can be defined to make
batch-processing easy.</p>

<p style="margin-top: 1em">gxyrs consists on a perl library
providing the core functions, and a perl script providing
some basic functionality.</p>

<p style="margin-top: 1em">It takes some arguments from the
command line: input and output files, some modifiers, and an
action-file or an action-string.</p>

<p style="margin-top: 1em">The action-file or action-script
contains some commands. For every line of the input file,
gxyrs executes those commands, which can modify the contents
of the line, and then <br>
writes the resulting line to the output file.</p>

<p style="margin-top: 1em">Since gxyrs is written in perl,
actions are also written in this language.</p>

<p style="margin-top: 1em">OPTIONS <br>
--help Display a usage message on standard output and exit
successfully. --verbose Display more information messages
when processing files.</p>

<p style="margin-top: 1em">--process-comments <br>
By default, gxyrs doesn&rsquo;t process lines starting with
&rsquo;*&rsquo; and &rsquo;#&rsquo; characters.</p>

<p style="margin-top: 1em">It just copies these lines to
the output, without further processing.</p>

<p style="margin-top: 1em">With this option, it processes
these lines as well.</p>

<p style="margin-top: 1em">--tabulate <br>
Give each field in the output file a fixed length, enough to
contain the longest string. Using this option make the
output file easier to read by humans.</p>

<p style="margin-top: 1em">--caseinsensitive <br>
Ignore case distinctions when comparing patterns.</p>

<p style="margin-top: 1em">--adjust FILE <br>
File with the commands to process the input file.</p>

<p style="margin-top: 1em">--eval PATTERN <br>
Interpret PATTERN as the commands to process the input
file.</p>

<p style="margin-top: 1em">--output FILE <br>
Save the output to the specified FILE.</p>

<p style="margin-top: 1em">If FILE string is &quot;-&quot;
(without double quotes), then output is redirected to
standard output STDOUT.</p>

<p style="margin-top: 1em">--output-delimiter CHAR <br>
Use the given CHAR as an output field delimiter.</p>

<p style="margin-top: 1em">PREDEFINED VARIABLES <br>
gxyrs defines automatically the following variables:</p>

<p style="margin-top: 1em">REF_COL <br>
column number (starting at 0) where the component reference
is.</p>

<p style="margin-top: 1em">FOOTPRINT_COL <br>
column number (starting at 0) where the component footprint
is.</p>

<p style="margin-top: 1em">X_COL column number (starting at
0) where the component&rsquo;s X location coordinate is.</p>

<p style="margin-top: 1em">Y_COL column number (starting at
0) where the component&rsquo;s Y location coordinate is.</p>

<p style="margin-top: 1em">ANGLE_COL <br>
column number (starting at 0) where the component rotation
angle is.</p>

<p style="margin-top: 1em">LAYER_COL <br>
column number (starting at 0) where the component&rsquo;s
layer side location is.</p>

<p style="margin-top: 1em">VALUE_COL <br>
column number (starting at 0) where the component&rsquo;s
value is. Usually this is the component&rsquo;s part
number.</p>

<p style="margin-top: 1em">LINE_NUMBER <br>
this is the line number of the input file that is being
currently processed.</p>

<p style="margin-top: 1em">LINE array where each array
element is a field or column of the input file&rsquo;s line
being processed.</p>

<p style="margin-top: 1em">BUILTIN COMMANDS <br>
All the following commands accept a checklist parameter. A
checklist is a list of one or more check_items. A checkitem
is a list of two single elements:</p>

<p style="margin-top: 1em">column_number <br>
is the data index number &rsquo;n&rsquo; of the global
variable LINE to be checked. The first element of the data
has the number 1.</p>

<p style="margin-top: 1em">pattern <br>
is the regular expression to be matched.</p>

<p style="margin-top: 1em">The commands will only be
executed on those lines that match all the checkitems in the
checklist.</p>

<p style="margin-top: 1em">del_line checklist; <br>
Delete the line (global variable LINE) if checklist is
matched.</p>

<p style="margin-top: 1em">Returns -1 if error, 0 if not
match, 1 if match and changed.</p>

<p style="margin-top: 1em">rotate_comp angle_col, angle,
checklist; <br>
rotate the component the degrees given in angle parameter,
if checklist is matched.</p>

<p style="margin-top: 1em">The angle column number is
angle_col.</p>

<p style="margin-top: 1em">Returns 1 if match and changed,
0 if not match, -1 if error.</p>

<p style="margin-top: 1em">subst_col_val col, value,
checklist; <br>
Replace a column value by the new value value, if checklist
is matched.</p>

<p style="margin-top: 1em">Returns 1 if match and changed,
0 if not match, -1 if error.</p>

<p style="margin-top: 1em">change_col_units units,
column_numbers; <br>
Change units of a given column number. More than one column
number can be specified.</p>

<p style="margin-top: 1em">Units is a string with the
desired units. Only &quot;mm&quot; (milimeters),
&quot;in&quot; (inches) and &quot;mil&quot; (thousands of an
inch) are supported.</p>

<p style="margin-top: 1em">It is required that numbers to
be converted are followed their units (see supported units
above). Otherwise, the number is not changed.</p>

<p style="margin-top: 1em">add_number_to_col col_number,
value, checklist; <br>
Adds a number to the value in a given column number. Note:
offset and the value to be changed can be in different
units.</p>

<p style="margin-top: 1em">Returns -1 if error, -2 if
warning, and 1 if success.</p>

<p style="margin-top: 1em">translate_col_val col_number,
string, substitution, checklist; <br>
Translate a string in the column col_number if checklist is
matched.</p>

<p style="margin-top: 1em">Substitution is an expression
with the new string. Old column value can be used here.</p>

<p style="margin-top: 1em">Returns -1 if error, 0 if not
match, 1 if match and changed.</p>

<p style="margin-top: 1em">Example: <br>
translate 2,
&rsquo;^([0-9]+)n$&rsquo;,&rsquo;sprintf(&quot;%dnF&quot;,$1)&rsquo;,
3, &rsquo;C[0-9]+&rsquo;; <br>
if the value in column 3 is C followed by a number, then
<br>
if the value in column 2 is a number followed by
&rsquo;n&rsquo;, translate it to the same value followed by
&rsquo;nF&rsquo;. <br>
If there is &rsquo;C10&rsquo; in column 3 and
&rsquo;10n&rsquo; in column 2, <br>
change &rsquo;10n&rsquo; to &rsquo;10nF&rsquo;.</p>

<p style="margin-top: 1em">mul_col_val col_number, factor,
checklist; <br>
Multiply the number in the specified column number
col_number by the given factor, if checklist is matched.</p>

<p style="margin-top: 1em">The number in the specified
column number may have units at the end.</p>

<p style="margin-top: 1em">Returns -1 if error, 0 if not
match, 1 if match and changed.</p>

<p style="margin-top: 1em">swap_columns col_number1,
col_number2, checklist; <br>
Swap columns col_number1 and col_number2 if checklist is
matched.</p>

<p style="margin-top: 1em">Returns -1 if error, 0 if not
match, 1 if match and changed.</p>

<p style="margin-top: 1em">insert_column col_number,
new_column_value; <br>
Insert a new column in the given col_number position (0 if
it&rsquo;s going to be the first column), with the value
new_column_value.</p>

<p style="margin-top: 1em">Returns -1 if error, 1 if the
new column was inserted.</p>

<p style="margin-top: 1em">RETURN VALUE <br>
The return value of gxyrs is an integer with the following
possible values:</p>

<p style="margin-top: 1em">1 if the command found a match
and the execution was successful</p>

<p style="margin-top: 1em">0 if there was no match</p>

<p style="margin-top: 1em">-1 if there was an error</p>

<p style="margin-top: 1em">-2 if there was a warning</p>

<p style="margin-top: 1em">FILES <br>
XYRS files <br>
The format of these files is not standard, and depends on
the application used to generate it.</p>

<p style="margin-top: 1em">The data stored in these files
is usually a header, and one line per component of the
board.</p>

<p style="margin-top: 1em">For each component, at least the
following information is needed by assemblers:</p>

<p style="margin-top: 1em">- Reference</p>

<p style="margin-top: 1em">- Coordinates (X and Y)</p>

<p style="margin-top: 1em">- Rotation angle</p>

<p style="margin-top: 1em">- Side where the component is
located (top or bottom)</p>

<p style="margin-top: 1em">There can be more information,
such as description, footprint, but this depends on the
design program an its configuration.</p>

<p style="margin-top: 1em">This information is organized in
lines, one line per component, and each line is divided in
as much fields or columns as needed. Field delimiters are
used between col&acirc; <br>
umns, but field delimiters are not standardized and they
depend on the program used to generate the XYRS file.</p>

<p style="margin-top: 1em">The program that generates the
XYRS file usually write a header (usually the first two or
thre lines in the file) with a column title.</p>

<p style="margin-top: 1em">gxyrs tries to guess the file
format, and column numbers, based on this header. Thus, the
known column titles are the following:</p>

<p style="margin-top: 1em">- for reference designator:
Designator, RefDesignator, RefDes.</p>

<p style="margin-top: 1em">- for footprint: Footprint,
TopCell, Description (only if there is no other
&quot;TopCell&quot; column title).</p>

<p style="margin-top: 1em">- for X coordinate: Mid X,
X.</p>

<p style="margin-top: 1em">- for Y coordinate: Mid Y,
Y.</p>

<p style="margin-top: 1em">- for rotation angle: Rotation,
rotation, Rot.</p>

<p style="margin-top: 1em">- for location side: TB, Side,
top/bottom.</p>

<p style="margin-top: 1em">- for value: Comment,
PartNumber, Value.</p>

<p style="margin-top: 1em">Action files <br>
An action file contains a list of commands, using perl
language, that can include any call to a built-in function
or use any variable defined by gxyrs.</p>

<p style="margin-top: 1em">Each action file should end with
the following line (with a carrier return at the end of the
line):</p>

<p style="margin-top: 1em">1;</p>

<p style="margin-top: 1em">EXAMPLES <br>
Run an action file: <br>
Run the action file your_comands.txt with the XYRS file
your_xyrs_file.txt and write the output result to the file
output_file.txt:</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt
--adjust your_commands.txt --output output_file.txt</p>

<p style="margin-top: 1em">Run a command specified in the
command line: <br>
Run the commands your_commands wiith the XYRS file
your_xyrs_file.txt and write the output result to the file
output_file.txt:</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;your_commands&quot; --output output_file.txt</p>

<p style="margin-top: 1em">Delete some lines matching a
pattern. <br>
Parse the XYRS file your_xyrs_file.txt, delete all lines
having a R followed by a number in column number 2, and
write the output result to the file output_file.txt:</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;del 2, &rsquo;R[0-9]+&rsquo;;&quot; --output
output_file.txt</p>

<p style="margin-top: 1em">Delete some lines matching a
pattern, using the column number guessed by gxyrs. <br>
Parse the XYRS file your_xyrs_file.txt, delete all lines
having a R followed by a number in reference designator
column, and write the output result to the file out&acirc;
<br>
put_file.txt:</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;del EF_COL, &rsquo;R[0-9]+&rsquo;;&quot; --output
output_file.txt</p>

<p style="margin-top: 1em">Rotate some lines matching a
pattern. <br>
Parse the XYRS file your_xyrs_file.txt, rotate by
90&Acirc;&ordm; all lines having a R followed by a number in
reference designator column, and write the output result to
the file <br>
output_file.txt. Use the rotation and reference column
number guessed by gxyrs:</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;rotate NGLE_COL, 90, EF_COL,
&rsquo;R[0-9]+&rsquo;;&quot; --output output_file.txt</p>

<p style="margin-top: 1em">Change all numbers to
&rsquo;mm&rsquo; units. <br>
Parse the XYRS file your_xyrs_file.txt, convert all numbers
in column 3 and 5 to its equivalent in mm, and write the
output result to the file output_file.txt:</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;change_units &rsquo;mm&rsquo;, 3, 5;&quot; --output
output_file.txt</p>

<p style="margin-top: 1em">Replace a value matching a
pattern with another value. <br>
Parse the XYRS file your_xyrs_file.txt, if the value in
column 3 is &quot;0.1u&quot;, then replace it with
&quot;100nF&quot;, and write the output result to the file
output_file.txt:</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;subst 3 , &rsquo;100nF&rsquo;, 3,
&rsquo;0.1u&rsquo;&quot; --output output_file.txt</p>

<p style="margin-top: 1em">Change the reference of a
component with a value matching a pattern. <br>
Parse the XYRS file your_xyrs_file.txt, if the value in
value column is &quot;1n4148&quot;, then replace reference
column with &quot;D1&quot;, and write the output result to
the file out&acirc; <br>
put_file.txt:</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;subst EF_COL , &rsquo;D1&rsquo;, ALUE_COL,
&rsquo;1n4148&rsquo;;&quot; --output output_file.txt</p>

<p style="margin-top: 1em">Adds an offset to the X
coordinate of a component with a reference having a R
followed by a number. <br>
Parse the XYRS file your_xyrs_file.txt, if the text in
reference column is R followed by a number, then adds
102.5mm to the value in X coordinate column, and write the
<br>
output result to the file output_file.txt.</p>

<p style="margin-top: 1em">Value in column 3 can be in
other units (for example: &rsquo;640mil&rsquo;):</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;offset _COL, &rsquo;102.5mm&rsquo;, EF_COL,
&rsquo;R[0-9]+&rsquo; ;&quot; --output output_file.txt</p>

<p style="margin-top: 1em">Multiply the value of the X
coordinate of a component by a number, if the component
reference is having a R followed by a number. <br>
Parse the XYRS file your_xyrs_file.txt, if the text in
reference column is R followed by a number, then multiply
the value in X coordinate column by 2.5, and write the <br>
output result to the file output_file.txt.</p>

<p style="margin-top: 1em">Value in column 3 can be in
other units (for example: &rsquo;640mil&rsquo;):</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;mul_col_val _COL, 2.5, EF_COL, &rsquo;R[0-9]+&rsquo;
;&quot; --output output_file.txt</p>

<p style="margin-top: 1em">Swap two columns. <br>
Parse the XYRS file your_xyrs_file.txt, swap columns 3 and 4
if the text in column number 4 is R followed by a number,
and write the output result to the file out&acirc; <br>
put_file.txt:</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;swap_columns 3, 4, 4, &rsquo;R[0-9]+&rsquo; ;&quot;
--output output_file.txt</p>

<p style="margin-top: 1em">Insert a column. <br>
Insert a column in the first position, displacing all
existing columns to the right. Column value is
&rsquo;new_column_value&rsquo;:</p>

<p style="margin-top: 1em">gxyrs your_xyrs_file.txt --eval
&quot;insert_column 0, &rsquo;new_column_value&rsquo;;&quot;
--output output_file.txt</p>

<p style="margin-top: 1em">SEE ALSO <br>
regex(7), GNU regular expression manual</p>

<p style="margin-top: 1em">Agosto 22, 2010 gxyrs(1)</p>
<hr>
</body>
</html>
