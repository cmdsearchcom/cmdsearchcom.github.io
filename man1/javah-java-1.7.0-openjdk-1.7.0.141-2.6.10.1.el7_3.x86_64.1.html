<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:19:32 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>javah(1) General Commands Manual javah(1)</p>

<p style="margin-top: 1em">Name <br>
javah - C Header and Stub File Generator</p>

<p style="margin-top: 1em">javah produces C header files
and C source files from a Java class. These files provide
the connective glue that allow your Java and C code to
interact.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
javah [ options ] fully-qualified-classname. . .</p>

<p style="margin-top: 1em">DESCRIPTION <br>
javah generates C header and source files that are needed to
implement native methods. The generated header and source
files are used by C programs to reference an object&rsquo;s
<br>
instance variables from native source code. The .h file
contains a struct definition whose layout parallels the
layout of the corresponding class. The fields in the struct
corre&acirc; <br>
spond to instance variables in the class.</p>

<p style="margin-top: 1em">The name of the header file and
the structure declared within it are derived from the name
of the class. If the class passed to javah is inside a
package, the package name is <br>
prepended to both the header file name and the structure
name. Underscores (_) are used as name delimiters.</p>

<p style="margin-top: 1em">By default javah creates a
header file for each class listed on the command line and
puts the files in the current directory. Use the -stubs
option to create source files. Use <br>
the -o option to concatenate the results for all listed
classes into a single file.</p>

<p style="margin-top: 1em">The new native method interface,
Java Native Interface (JNI), does not require header
information or stub files. javah can still be used to
generate native method function prop&acirc; <br>
totypes needed for JNI-style native methods. javah produces
JNI-style output by default, and places the result in the .h
file.</p>

<p style="margin-top: 1em">OPTIONS <br>
-o outputfile <br>
Concatenates the resulting header or source files for all
the classes listed on the command line into outputfile. Only
one of -o or -d may be used.</p>

<p style="margin-top: 1em">-d directory <br>
Sets the directory where javah saves the header files or the
stub files. Only one of -d or -o may be used.</p>

<p style="margin-top: 1em">-stubs <br>
Causes javah to generate C declarations from the Java object
file.</p>

<p style="margin-top: 1em">-verbose <br>
Indicates verbose output and causes javah to print a message
to stdout concerning the status of the generated files.</p>

<p style="margin-top: 1em">-help <br>
Print help message for javah usage.</p>

<p style="margin-top: 1em">-version <br>
Print out javah version information.</p>

<p style="margin-top: 1em">-jni <br>
Causes javah to create an output file containing JNI-style
native method function prototypes. This is the default
output, so use of -jni is optional.</p>

<p style="margin-top: 1em">-classpath path <br>
Specifies the path javah uses to look up classes. Overrides
the default or the CLASSPATH environment variable if it is
set. Directories are separated by colons. Thus the <br>
general format for path is: <br>
.:&lt;your_path&gt; <br>
For example: <br>
.:/home/avh/classes:/usr/local/java/classes <br>
As a special convenience, a class path element containing a
basename of * is considered equivalent to specifying a list
of all the files in the directory with the extension <br>
.jar or .JAR (a java program cannot tell the difference
between the two invocations). <br>
For example, if directory foo contains a.jar and b.JAR, then
the class path element foo/* is expanded to a A.jar:b.JAR,
except that the order of jar files is unspecified. <br>
All jar files in the specified directory, even hidden ones,
are included in the list. A classpath entry consisting
simply of * expands to a list of all the jar files in the
<br>
current directory. The CLASSPATH environment variable, where
defined, will be similarly expanded. Any classpath wildcard
expansion occurs before the Java virtual machine is <br>
started -- no Java program will ever see unexpanded
wildcards except by querying the environment. For example;
by invoking System.getenv(&quot;CLASSPATH&quot;).</p>

<p style="margin-top: 1em">-bootclasspath path <br>
Specifies path from which to load bootstrap classes. By
default, the bootstrap classes are the classes implementing
the core Java 2 platform located in jre/lib/rt.jar and <br>
several other jar files.</p>

<p style="margin-top: 1em">-old <br>
Specifies that old JDK1.0-style header files should be
generated.</p>

<p style="margin-top: 1em">-force <br>
Specifies that output files should always be written.</p>

<p style="margin-top: 1em">-Joption <br>
Pass option to the Java virtual machine, where option is one
of the options described on the reference page for the
java(1). For example, -J-Xms48m sets the startup memory <br>
to 48 megabytes.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
CLASSPATH <br>
Used to provide the system a path to user-defined classes.
Directories are separated by colons, for example,</p>

<p style="margin-top: 1em">SEE ALSO <br>
javac(1), java(1), jdb(1), javap(1), javadoc(1)</p>

<p style="margin-top: 1em">16 Mar 2012 javah(1)</p>
<hr>
</body>
</html>
