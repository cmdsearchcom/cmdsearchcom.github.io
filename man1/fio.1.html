<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:10:01 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>fio(1) General Commands Manual fio(1)</p>

<p style="margin-top: 1em">NAME <br>
fio - flexible I/O tester</p>

<p style="margin-top: 1em">SYNOPSIS <br>
fio [options] [jobfile]...</p>

<p style="margin-top: 1em">DESCRIPTION <br>
fio is a tool that will spawn a number of threads or
processes doing a particular type of I/O action as specified
by the user. The typical use of fio is to write a job file
<br>
matching the I/O load one wants to simulate.</p>

<p style="margin-top: 1em">OPTIONS <br>
--debug=type <br>
Enable verbose tracing of various fio actions. May be
&lsquo;all&rsquo; for all types or individual types
separated by a comma (eg --debug=io,file).
&lsquo;help&rsquo; will list all available <br>
tracing options.</p>

<p style="margin-top: 1em">--output=filename <br>
Write output to filename.</p>

<p style="margin-top: 1em">--output-format=format <br>
Set the reporting format to normal, terse, json, or json+.
Multiple formats can be selected, separate by a comma. terse
is a CSV based format. json+ is like json, except <br>
it adds a full dump of the latency buckets.</p>

<p style="margin-top: 1em">--runtime=runtime <br>
Limit run time to runtime seconds.</p>

<p style="margin-top: 1em">--bandwidth-log <br>
Generate aggregate bandwidth logs.</p>

<p style="margin-top: 1em">--minimal <br>
Print statistics in a terse, semicolon-delimited format.</p>

<p style="margin-top: 1em">--append-terse <br>
Print statistics in selected mode AND terse,
semicolon-delimited format. Deprecated, use --output-format
instead to select multiple formats.</p>

<p style="margin-top: 1em">--version <br>
Display version information and exit.</p>

<p style="margin-top: 1em">--terse-version=version <br>
Set terse version output format (Current version 3, or older
version 2).</p>

<p style="margin-top: 1em">--help Display usage information
and exit.</p>

<p style="margin-top: 1em">--cpuclock-test <br>
Perform test and validation of internal CPU clock</p>

<p style="margin-top: 1em">--crctest[=test] <br>
Test the speed of the builtin checksumming functions. If no
argument is given, all of them are tested. Or a comma
separated list can be passed, in which case the given <br>
ones are tested.</p>

<p style="margin-top: 1em">--cmdhelp=command <br>
Print help information for command. May be &lsquo;all&rsquo;
for all commands.</p>

<p style="margin-top: 1em">--enghelp=ioengine[,command]
<br>
List all commands defined by ioengine, or print help for
command defined by ioengine.</p>

<p style="margin-top: 1em">--showcmd=jobfile <br>
Convert jobfile to a set of command-line options.</p>

<p style="margin-top: 1em">--eta=when <br>
Specifies when real-time ETA estimate should be printed.
when may be one of &lsquo;always&rsquo;, &lsquo;never&rsquo;
or &lsquo;auto&rsquo;.</p>

<p style="margin-top: 1em">--eta-newline=time <br>
Force an ETA newline for every &lsquo;time&lsquo; period
passed.</p>

<p style="margin-top: 1em">--status-interval=time <br>
Report full output status every &lsquo;time&lsquo; period
passed.</p>

<p style="margin-top: 1em">--readonly <br>
Turn on safety read-only checks, preventing any attempted
write.</p>

<p style="margin-top: 1em">--section=sec <br>
Only run section sec from job file. This option can be used
multiple times to add more sections to run.</p>

<p style="margin-top: 1em">--alloc-size=kb <br>
Set the internal smalloc pool size to kb kilobytes.</p>

<p style="margin-top: 1em">--warnings-fatal <br>
All fio parser warnings are fatal, causing fio to exit with
an error.</p>

<p style="margin-top: 1em">--max-jobs=nr <br>
Set the maximum allowed number of jobs (threads/processes)
to support.</p>

<p style="margin-top: 1em">--server=args <br>
Start a backend server, with args specifying what to listen
to. See client/server section.</p>

<p style="margin-top: 1em">--daemonize=pidfile <br>
Background a fio server, writing the pid to the given pid
file.</p>

<p style="margin-top: 1em">--client=host <br>
Instead of running the jobs locally, send and run them on
the given host or set of hosts. See client/server
section.</p>

<p style="margin-top: 1em">--idle-prof=option <br>
Report cpu idleness on a system or percpu basis
(option=system,percpu) or run unit work calibration only
(option=calibrate).</p>

<p style="margin-top: 1em">JOB FILE FORMAT <br>
Job files are in &lsquo;ini&rsquo; format. They consist of
one or more job definitions, which begin with a job name in
square brackets and extend to the next job name. The job
name can be <br>
any ASCII string except &lsquo;global&rsquo;, which has a
special meaning. Following the job name is a sequence of
zero or more parameters, one per line, that define the
behavior of the <br>
job. Any line starting with a &lsquo;;&rsquo; or
&lsquo;#&rsquo; character is considered a comment and
ignored.</p>

<p style="margin-top: 1em">If jobfile is specified as
&lsquo;-&rsquo;, the job file will be read from standard
input.</p>

<p style="margin-top: 1em">Global Section <br>
The global section contains default parameters for jobs
specified in the job file. A job is only affected by global
sections residing above it, and there may be any number of
<br>
global sections. Specific job definitions may override any
parameter set in global sections.</p>

<p style="margin-top: 1em">JOB PARAMETERS <br>
Types <br>
Some parameters may take arguments of a specific type.
Anywhere a numeric value is required, an arithmetic
expression may be used, provided it is surrounded by
parentheses. Sup&acirc; <br>
ported operators are:</p>

<p style="margin-top: 1em">addition (+)</p>

<p style="margin-top: 1em">subtraction (-)</p>

<p style="margin-top: 1em">multiplication (*)</p>

<p style="margin-top: 1em">division (/)</p>

<p style="margin-top: 1em">modulus (%)</p>

<p style="margin-top: 1em">exponentiation (^)</p>

<p style="margin-top: 1em">For time values in expressions,
units are microseconds by default. This is different than
for time values not in expressions (not enclosed in
parentheses). The types used are:</p>

<p style="margin-top: 1em">str String: a sequence of
alphanumeric characters.</p>

<p style="margin-top: 1em">int SI integer: a whole number,
possibly containing a suffix denoting the base unit of the
value. Accepted suffixes are &lsquo;k&rsquo;,
&rsquo;M&rsquo;, &rsquo;G&rsquo;, &rsquo;T&rsquo;, and
&rsquo;P&rsquo;, denoting kilo (1024), <br>
mega (1024^2), giga (1024^3), tera (1024^4), and peta
(1024^5) respectively. If prefixed with &rsquo;0x&rsquo;,
the value is assumed to be base 16 (hexadecimal). A suffix
may include <br>
a trailing &rsquo;b&rsquo;, for instance &rsquo;kb&rsquo; is
identical to &rsquo;k&rsquo;. You can specify a base 10
value by using &rsquo;KiB&rsquo;,
&rsquo;MiB&rsquo;,&rsquo;GiB&rsquo;, etc. This is useful for
disk drives where values are <br>
often given in base 10 values. Specifying
&rsquo;30GiB&rsquo; will get you 30*1000^3 bytes. When
specifying times the default suffix meaning changes, still
denoting the base unit of <br>
the value, but accepted suffixes are &rsquo;D&rsquo; (days),
&rsquo;H&rsquo; (hours), &rsquo;M&rsquo; (minutes),
&rsquo;S&rsquo; Seconds, &rsquo;ms&rsquo; (or msec) milli
seconds, &rsquo;us&rsquo; (or &rsquo;usec&rsquo;) micro
seconds. Time values without <br>
a unit specify seconds. The suffixes are not case
sensitive.</p>

<p style="margin-top: 1em">bool Boolean: a true or false
value. &lsquo;0&rsquo; denotes false, &lsquo;1&rsquo;
denotes true.</p>

<p style="margin-top: 1em">irange Integer range: a range of
integers specified in the format lower:upper or lower-upper.
lower and upper may contain a suffix as described above. If
an option allows two <br>
sets of ranges, they are separated with a &lsquo;,&rsquo; or
&lsquo;/&rsquo; character. For example:
&lsquo;8-8k/8M-4G&rsquo;.</p>

<p style="margin-top: 1em">float_list <br>
List of floating numbers: A list of floating numbers,
separated by a &rsquo;:&rsquo; character.</p>

<p style="margin-top: 1em">Parameter List <br>
name=str <br>
May be used to override the job name. On the command line,
this parameter has the special purpose of signalling the
start of a new job.</p>

<p style="margin-top: 1em">wait_for=str <br>
Specifies the name of the already defined job to wait for.
Single waitee name only may be specified. If set, the job
won&rsquo;t be started until all workers of the waitee job
<br>
are done. Wait_for operates on the job name basis, so there
are a few limitations. First, the waitee must be defined
prior to the waiter job (meaning no forward refer&acirc;
<br>
ences). Second, if a job is being referenced as a waitee, it
must have a unique name (no duplicate waitees).</p>

<p style="margin-top: 1em">description=str <br>
Human-readable description of the job. It is printed when
the job is run, but otherwise has no special purpose.</p>

<p style="margin-top: 1em">directory=str <br>
Prefix filenames with this directory. Used to place files in
a location other than &lsquo;./&rsquo;. You can specify a
number of directories by separating the names with a
&rsquo;:&rsquo; char&acirc; <br>
acter. These directories will be assigned equally
distributed to job clones creates with numjobs as long as
they are using generated filenames. If specific filename(s)
<br>
are set fio will use the first listed directory, and thereby
matching the filename semantic which generates a file each
clone if not specified, but let all clones use the <br>
same if set. See filename for considerations regarding
escaping certain characters on some platforms.</p>

<p style="margin-top: 1em">filename=str <br>
fio normally makes up a file name based on the job name,
thread number, and file number. If you want to share files
between threads in a job or several jobs, specify a <br>
filename for each of them to override the default. If the
I/O engine is file-based, you can specify a number of files
by separating the names with a &lsquo;:&rsquo; character.
&lsquo;-&rsquo; is <br>
a reserved name, meaning stdin or stdout, depending on the
read/write direction set. On Windows, disk devices are
accessed as .PhysicalDrive0 for the first device, <br>
.PhysicalDrive1 for the second etc. Note: Windows and
FreeBSD prevent write access to areas of the disk containing
in-use data (e.g. filesystems). If the wanted filename <br>
does need to include a colon, then escape that with a
&rsquo;&acute; character. For instance, if the filename is
&quot;/dev/dsk/foo@3,0:c&quot;, then you would use
file&acirc; <br>
name=&quot;/dev/dsk/foo@3,0c&quot;.</p>

<p style="margin-top: 1em">filename_format=str <br>
If sharing multiple files between jobs, it is usually
necessary to have fio generate the exact names that you
want. By default, fio will name a file based on the default
<br>
file format specification of jobname.jobnumber.filenumber.
With this option, that can be customized. Fio will recognize
and replace the following keywords in this string:</p>

<p style="margin-top: 1em">$jobname <br>
The name of the worker thread or process.</p>

<p style="margin-top: 1em">$jobnum <br>
The incremental number of the worker thread or process.</p>

<p style="margin-top: 1em">$filenum <br>
The incremental number of the file for that worker thread or
process.</p>

<p style="margin-top: 1em">To have dependent jobs share a
set of files, this option can be set to have fio generate
filenames that are shared between the two. For instance, if
testfiles.$filenum is <br>
specified, file number 4 for any job will be named
testfiles.4. The default of $jobname.$jobnum.$filenum will
be used if no other format specifier is given.</p>

<p style="margin-top: 1em">unique_filename=bool <br>
To avoid collisions between networked clients, fio defaults
to prefixing any generated filenames (with a directory
specified) with the source of the client connecting. To <br>
disable this behavior, set this option to 0.</p>

<p style="margin-top: 1em">lockfile=str <br>
Fio defaults to not locking any files before it does IO to
them. If a file or file descriptor is shared, fio can
serialize IO to that file to make the end result
consis&acirc; <br>
tent. This is usual for emulating real workloads that share
files. The lock modes are:</p>

<p style="margin-top: 1em">none No locking. This is the
default.</p>

<p style="margin-top: 1em">exclusive <br>
Only one thread or process may do IO at a time, excluding
all others.</p>

<p style="margin-top: 1em">readwrite <br>
Read-write locking on the file. Many readers may access the
file at the same time, but writes get exclusive access.</p>

<p style="margin-top: 1em">opendir=str Recursively open any
files below directory str.</p>

<p style="margin-top: 1em">readwrite=str, rw=str <br>
Type of I/O pattern. Accepted values are:</p>

<p style="margin-top: 1em">read Sequential reads.</p>

<p style="margin-top: 1em">write Sequential writes.</p>

<p style="margin-top: 1em">trim Sequential trim (Linux
block devices only).</p>

<p style="margin-top: 1em">randread <br>
Random reads.</p>

<p style="margin-top: 1em">randwrite <br>
Random writes.</p>

<p style="margin-top: 1em">randtrim <br>
Random trim (Linux block devices only).</p>

<p style="margin-top: 1em">rw, readwrite <br>
Mixed sequential reads and writes.</p>

<p style="margin-top: 1em">randrw Mixed random reads and
writes.</p>

<p style="margin-top: 1em">trimwrite <br>
Trim and write mixed workload. Blocks will be trimmed first,
then the same blocks will be written to.</p>

<p style="margin-top: 1em">Fio defaults to read if the
option is not specified. For mixed I/O, the default split is
50/50. For certain types of io the result may still be
skewed a bit, since the <br>
speed may be different. It is possible to specify a number
of IO&rsquo;s to do before getting a new offset, this is
done by appending a &lsquo;:&lt;nr&gt; to the end of the
string given. <br>
For a random read, it would look like rw=randread:8 for
passing in an offset modifier with a value of 8. If the
postfix is used with a sequential IO pattern, then the <br>
value specified will be added to the generated offset for
each IO. For instance, using rw=write:4k will skip 4k for
every write. It turns sequential IO into sequential IO <br>
with holes. See the rw_sequencer option.</p>

<p style="margin-top: 1em">rw_sequencer=str <br>
If an offset modifier is given by appending a number to the
rw=&lt;str&gt; line, then this option controls how that
number modifies the IO offset being generated. Accepted
val&acirc; <br>
ues are:</p>

<p style="margin-top: 1em">sequential <br>
Generate sequential offset</p>

<p style="margin-top: 1em">identical <br>
Generate the same offset</p>

<p style="margin-top: 1em">sequential is only useful for
random IO, where fio would normally generate a new random
offset for every IO. If you append eg 8 to randread, you
would get a new random <br>
offset for every 8 IO&rsquo;s. The result would be a seek
for only every 8 IO&rsquo;s, instead of for every IO. Use
rw=randread:8 to specify that. As sequential IO is already
sequen&acirc; <br>
tial, setting sequential for that would not result in any
differences. identical behaves in a similar fashion, except
it sends the same offset 8 number of times before <br>
generating a new offset.</p>

<p style="margin-top: 1em">kb_base=int <br>
The base unit for a kilobyte. The defacto base is 2^10,
1024. Storage manufacturers like to use 10^3 or 1000 as a
base ten unit instead, for obvious reasons. Allowed
val&acirc; <br>
ues are 1024 or 1000, with 1024 being the default.</p>

<p style="margin-top: 1em">unified_rw_reporting=bool <br>
Fio normally reports statistics on a per data direction
basis, meaning that read, write, and trim are accounted and
reported separately. If this option is set fio sums the <br>
results and reports them as &quot;mixed&quot; instead.</p>

<p style="margin-top: 1em">randrepeat=bool <br>
Seed the random number generator used for random I/O
patterns in a predictable way so the pattern is repeatable
across runs. Default: true.</p>

<p style="margin-top: 1em">allrandrepeat=bool <br>
Seed all random number generators in a predictable way so
results are repeatable across runs. Default: false.</p>

<p style="margin-top: 1em">randseed=int <br>
Seed the random number generators based on this seed value,
to be able to control what sequence of output is being
generated. If not set, the random sequence depends on <br>
the randrepeat setting.</p>

<p style="margin-top: 1em">fallocate=str <br>
Whether pre-allocation is performed when laying down files.
Accepted values are:</p>

<p style="margin-top: 1em">none Do not pre-allocate
space.</p>

<p style="margin-top: 1em">posix Pre-allocate via
posix_fallocate(3).</p>

<p style="margin-top: 1em">keep Pre-allocate via
fallocate(2) with FALLOC_FL_KEEP_SIZE set.</p>

<p style="margin-top: 1em">0 Backward-compatible alias for
&rsquo;none&rsquo;.</p>

<p style="margin-top: 1em">1 Backward-compatible alias for
&rsquo;posix&rsquo;.</p>

<p style="margin-top: 1em">May not be available on all
supported platforms. &rsquo;keep&rsquo; is only available on
Linux. If using ZFS on Solaris this must be set to
&rsquo;none&rsquo; because ZFS doesn&rsquo;t support it.
<br>
Default: &rsquo;posix&rsquo;.</p>

<p style="margin-top: 1em">fadvise_hint=str <br>
Use posix_fadvise(2) to advise the kernel what I/O patterns
are likely to be issued. Accepted values are:</p>

<p style="margin-top: 1em">0 Backwards compatible hint for
&quot;no hint&quot;.</p>

<p style="margin-top: 1em">1 Backwards compatible hint for
&quot;advise with fio workload type&quot;. This uses
FADV_RANDOM for a random workload, and FADV_SEQUENTIAL for a
sequential workload.</p>

<p style="margin-top: 1em">sequential <br>
Advise using FADV_SEQUENTIAL</p>

<p style="margin-top: 1em">random Advise using
FADV_RANDOM</p>

<p style="margin-top: 1em">fadvise_stream=int <br>
Use posix_fadvise(2) to advise the kernel what stream ID the
writes issued belong to. Only supported on Linux. Note, this
option may change going forward.</p>

<p style="margin-top: 1em">size=int <br>
Total size of I/O for this job. fio will run until this many
bytes have been transferred, unless limited by other options
(runtime, for instance, or increased/descreased <br>
by io_size). Unless nrfiles and filesize options are given,
this amount will be divided between the available files for
the job. If not set, fio will use the full size of <br>
the given files or devices. If the files do not exist, size
must be given. It is also possible to give size as a
percentage between 1 and 100. If size=20% is given, fio <br>
will use 20% of the full size of the given files or
devices.</p>

<p style="margin-top: 1em">io_size=int, io_limit =int <br>
Normally fio operates within the region set by size, which
means that the size option sets both the region and size of
IO to be performed. Sometimes that is not what you <br>
want. With this option, it is possible to define just the
amount of IO that fio should do. For instance, if size is
set to 20G and io_limit is set to 5G, fio will perform <br>
IO within the first 20G but exit when 5G have been done. The
opposite is also possible - if size is set to 20G, and
io_size is set to 40G, then fio will do 40G of IO <br>
within the 0..20G region.</p>

<p style="margin-top: 1em">fill_device=bool, fill_fs=bool
<br>
Sets size to something really large and waits for ENOSPC (no
space left on device) as the terminating condition. Only
makes sense with sequential write. For a read work&acirc;
<br>
load, the mount point will be filled first then IO started
on the result. This option doesn&rsquo;t make sense if
operating on a raw device node, since the size of that is
<br>
already known by the file system. Additionally, writing
beyond end-of-device will not return ENOSPC there.</p>

<p style="margin-top: 1em">filesize=irange <br>
Individual file sizes. May be a range, in which case fio
will select sizes for files at random within the given
range, limited to size in total (if that is given). If <br>
filesize is not specified, each created file is the same
size.</p>

<p style="margin-top: 1em">file_append=bool <br>
Perform IO after the end of the file. Normally fio will
operate within the size of a file. If this option is set,
then fio will append to the file instead. This has
iden&acirc; <br>
tical behavior to setting offset to the size of a file. This
option is ignored on non-regular files.</p>

<p style="margin-top: 1em">blocksize=int[,int],
bs=int[,int] <br>
Block size for I/O units. Default: 4k. Values for reads,
writes, and trims can be specified separately in the format
read,write,trim either of which may be empty to <br>
leave that value at its default. If a trailing comma
isn&rsquo;t given, the remainder will inherit the last value
set.</p>


<p style="margin-top: 1em">blocksize_range=irange[,irange],
bsrange=irange[,irange] <br>
Specify a range of I/O block sizes. The issued I/O unit will
always be a multiple of the minimum size, unless
blocksize_unaligned is set. Applies to both reads and <br>
writes if only one range is given, but can be specified
separately with a comma separating the values. Example:
bsrange=1k-4k,2k-8k. Also (see blocksize).</p>

<p style="margin-top: 1em">bssplit=str <br>
This option allows even finer grained control of the block
sizes issued, not just even splits between them. With this
option, you can weight various block sizes for exact <br>
control of the issued IO for a job that has mixed block
sizes. The format of the option is
bssplit=blocksize/percentage, optionally adding as many
definitions as needed <br>
separated by a colon. Example: bssplit=4k/10:64k/50:32k/40
would issue 50% 64k blocks, 10% 4k blocks and 40% 32k
blocks. bssplit also supports giving separate splits to <br>
reads and writes. The format is identical to what the bs
option accepts, the read and write parts are separated with
a comma.</p>

<p style="margin-top: 1em">blocksize_unaligned,
bs_unaligned <br>
If set, any size in blocksize_range may be used. This
typically won&rsquo;t work with direct I/O, as that normally
requires sector alignment.</p>

<p style="margin-top: 1em">blockalign=int[,int],
ba=int[,int] <br>
At what boundary to align random IO offsets. Defaults to the
same as &rsquo;blocksize&rsquo; the minimum blocksize given.
Minimum alignment is typically 512b for using direct IO,
<br>
though it usually depends on the hardware block size. This
option is mutually exclusive with using a random map for
files, so it will turn off that option.</p>

<p style="margin-top: 1em">bs_is_seq_rand=bool <br>
If this option is set, fio will use the normal read,write
blocksize settings as sequential,random instead. Any random
read or write will use the WRITE blocksize settings, <br>
and any sequential read or write will use the READ blocksize
setting.</p>

<p style="margin-top: 1em">zero_buffers <br>
Initialize buffers with all zeros. Default: fill buffers
with random data.</p>

<p style="margin-top: 1em">refill_buffers <br>
If this option is given, fio will refill the IO buffers on
every submit. The default is to only fill it at init time
and reuse that data. Only makes sense if zero_buffers <br>
isn&rsquo;t specified, naturally. If data verification is
enabled, refill_buffers is also automatically enabled.</p>

<p style="margin-top: 1em">scramble_buffers=bool <br>
If refill_buffers is too costly and the target is using data
deduplication, then setting this option will slightly modify
the IO buffer contents to defeat normal de-dupe <br>
attempts. This is not enough to defeat more clever block
compression attempts, but it will stop naive dedupe of
blocks. Default: true.</p>

<p style="margin-top: 1em">buffer_compress_percentage=int
<br>
If this is set, then fio will attempt to provide IO buffer
content (on WRITEs) that compress to the specified level.
Fio does this by providing a mix of random data and a <br>
fixed pattern. The fixed pattern is either zeroes, or the
pattern specified by buffer_pattern. If the pattern option
is used, it might skew the compression ratio slightly. <br>
Note that this is per block size unit, for file/disk wide
compression level that matches this setting. Note that this
is per block size unit, for file/disk wide compres&acirc;
<br>
sion level that matches this setting, you&rsquo;ll also want
to set refill_buffers.</p>

<p style="margin-top: 1em">buffer_compress_chunk=int <br>
See buffer_compress_percentage. This setting allows fio to
manage how big the ranges of random data and zeroed data is.
Without this set, fio will provide buffer_com&acirc; <br>
press_percentage of blocksize random data, followed by the
remaining zeroed. With this set to some chunk size smaller
than the block size, fio can alternate random and <br>
zeroed data throughout the IO buffer.</p>

<p style="margin-top: 1em">buffer_pattern=str <br>
If set, fio will fill the IO buffers with this pattern. If
not set, the contents of IO buffers is defined by the other
options related to buffer contents. The setting can <br>
be any pattern of bytes, and can be prefixed with 0x for hex
values. It may also be a string, where the string must then
be wrapped with &quot;&quot;, e.g.: <br>
buffer_pattern=&quot;abcd&quot; <br>
or <br>
buffer_pattern=-12 <br>
or <br>
buffer_pattern=0xdeadface</p>

<p style="margin-top: 1em">Also you can combine everything
together in any order:</p>


<p style="margin-top: 1em">buffer_pattern=0xdeadface&quot;abcd&quot;-12</p>

<p style="margin-top: 1em">dedupe_percentage=int <br>
If set, fio will generate this percentage of identical
buffers when writing. These buffers will be naturally
dedupable. The contents of the buffers depend on what other
<br>
buffer compression settings have been set. It&rsquo;s
possible to have the individual buffers either fully
compressible, or not at all. This option only controls the
distribu&acirc; <br>
tion of unique buffers.</p>

<p style="margin-top: 1em">nrfiles=int <br>
Number of files to use for this job. Default: 1.</p>

<p style="margin-top: 1em">openfiles=int <br>
Number of files to keep open at the same time. Default:
nrfiles.</p>

<p style="margin-top: 1em">file_service_type=str <br>
Defines how files to service are selected. The following
types are defined:</p>

<p style="margin-top: 1em">random Choose a file at
random.</p>

<p style="margin-top: 1em">roundrobin <br>
Round robin over opened files (default).</p>

<p style="margin-top: 1em">sequential <br>
Do each file in the set sequentially.</p>

<p style="margin-top: 1em">zipf Use a Zipfian distribution
to decide what file to access.</p>

<p style="margin-top: 1em">pareto Use a Pareto distribution
to decide what file to access.</p>

<p style="margin-top: 1em">gauss Use a Gaussian (normal)
distribution to decide what file to access.</p>

<p style="margin-top: 1em">For random, roundrobin, and
sequential, a postfix can be appended to tell fio how many
I/Os to issue before switching to a new file. For example,
specifying file_ser&acirc; <br>
vice_type=random:8 would cause fio to issue 8 I/Os before
selecting a new file at random. For the non-uniform
distributions, a floating point postfix can be given to <br>
influence how the distribution is skewed. See
random_distribution for a description of how that would
work.</p>

<p style="margin-top: 1em">ioengine=str <br>
Defines how the job issues I/O. The following types are
defined:</p>

<p style="margin-top: 1em">sync Basic read(2) or write(2)
I/O. fseek(2) is used to position the I/O location.</p>

<p style="margin-top: 1em">psync Basic pread(2) or
pwrite(2) I/O. Default on all supported operating systems
except for Windows.</p>

<p style="margin-top: 1em">vsync Basic readv(2) or
writev(2) I/O. Will emulate queuing by coalescing adjacent
IOs into a single submission.</p>

<p style="margin-top: 1em">pvsync Basic preadv(2) or
pwritev(2) I/O.</p>

<p style="margin-top: 1em">pvsync2 <br>
Basic preadv2(2) or pwritev2(2) I/O.</p>

<p style="margin-top: 1em">libaio Linux native asynchronous
I/O. This ioengine defines engine specific options.</p>

<p style="margin-top: 1em">posixaio <br>
POSIX asynchronous I/O using aio_read(3) and
aio_write(3).</p>

<p style="margin-top: 1em">solarisaio <br>
Solaris native asynchronous I/O.</p>

<p style="margin-top: 1em">windowsaio <br>
Windows native asynchronous I/O. Default on Windows.</p>

<p style="margin-top: 1em">mmap File is memory mapped with
mmap(2) and data copied using memcpy(3).</p>

<p style="margin-top: 1em">splice splice(2) is used to
transfer the data and vmsplice(2) to transfer data from
user-space to the kernel.</p>

<p style="margin-top: 1em">sg SCSI generic sg v3 I/O. May
be either synchronous using the SG_IO ioctl, or if the
target is an sg character device, we use read(2) and
write(2) for asyn&acirc; <br>
chronous I/O.</p>

<p style="margin-top: 1em">null Doesn&rsquo;t transfer any
data, just pretends to. Mainly used to exercise fio itself
and for debugging and testing purposes.</p>

<p style="margin-top: 1em">net Transfer over the network.
The protocol to be used can be defined with the protocol
parameter. Depending on the protocol, filename, hostname,
port, or lis&acirc; <br>
ten must be specified. This ioengine defines engine specific
options.</p>

<p style="margin-top: 1em">netsplice <br>
Like net, but uses splice(2) and vmsplice(2) to map data and
send/receive. This ioengine defines engine specific
options.</p>

<p style="margin-top: 1em">cpuio Doesn&rsquo;t transfer any
data, but burns CPU cycles according to cpuload and
cpuchunks parameters. A job never finishes unless there is
at least one non-cpuio <br>
job.</p>

<p style="margin-top: 1em">guasi The GUASI I/O engine is
the Generic Userspace Asynchronous Syscall Interface
approach to asynchronous I/O. <br>
See &lt;http://www.xmailserver.org/guasi-lib.html&gt;.</p>

<p style="margin-top: 1em">rdma The RDMA I/O engine
supports both RDMA memory semantics (RDMA_WRITE/RDMA_READ)
and channel semantics (Send/Recv) for the InfiniBand, RoCE
and iWARP proto&acirc; <br>
cols.</p>

<p style="margin-top: 1em">external <br>
Loads an external I/O engine object file. Append the engine
filename as &lsquo;:enginepath&rsquo;.</p>

<p style="margin-top: 1em">falloc <br>
IO engine that does regular linux native fallocate call to
simulate data transfer as fio ioengine <br>
DDIR_READ does fallocate(,mode = FALLOC_FL_KEEP_SIZE,) <br>
DIR_WRITE does fallocate(,mode = 0) <br>
DDIR_TRIM does fallocate(,mode =
FALLOC_FL_KEEP_SIZE|FALLOC_FL_PUNCH_HOLE)</p>

<p style="margin-top: 1em">e4defrag <br>
IO engine that does regular EXT4_IOC_MOVE_EXT ioctls to
simulate defragment activity request to DDIR_WRITE event</p>

<p style="margin-top: 1em">rbd IO engine supporting direct
access to Ceph Rados Block Devices (RBD) via librbd without
the need to use the kernel rbd driver. This ioengine defines
engine <br>
specific options.</p>

<p style="margin-top: 1em">gfapi Using Glusterfs libgfapi
sync interface to direct access to Glusterfs volumes without
having to go through FUSE. This ioengine defines engine
specific <br>
options.</p>

<p style="margin-top: 1em">gfapi_async <br>
Using Glusterfs libgfapi async interface to direct access to
Glusterfs volumes without having to go through FUSE. This
ioengine defines engine specific <br>
options.</p>

<p style="margin-top: 1em">libhdfs <br>
Read and write through Hadoop (HDFS). The filename option is
used to specify host,port of the hdfs name-node to connect.
This engine interprets offsets a <br>
little differently. In HDFS, files once created cannot be
modified. So random writes are not possible. To imitate
this, libhdfs engine expects bunch of <br>
small files to be created over HDFS, and engine will
randomly pick a file out of those files based on the offset
generated by fio backend. (see the example <br>
job file to create such files, use rw=write option). Please
note, you might want to set necessary environment variables
to work with hdfs/libhdfs properly.</p>

<p style="margin-top: 1em">mtd Read, write and erase an MTD
character device (e.g., /dev/mtd0). Discards are treated as
erases. Depending on the underlying device type, the I/O may
have to <br>
go in a certain pattern, e.g., on NAND, writing sequentially
to erase blocks and discarding before overwriting. The
writetrim mode works well for this con&acirc; <br>
straint.</p>

<p style="margin-top: 1em">pmemblk <br>
Read and write through the NVML libpmemblk interface.</p>

<p style="margin-top: 1em">dev-dax <br>
Read and write through a DAX device exposed from persistent
memory.</p>

<p style="margin-top: 1em">iodepth=int <br>
Number of I/O units to keep in flight against the file. Note
that increasing iodepth beyond 1 will not affect synchronous
ioengines (except for small degress when ver&acirc; <br>
ify_async is in use). Even async engines may impose OS
restrictions causing the desired depth not to be achieved.
This may happen on Linux when using libaio and not
set&acirc; <br>
ting direct=1, since buffered IO is not async on that OS.
Keep an eye on the IO depth distribution in the fio output
to verify that the achieved depth is as expected. <br>
Default: 1.</p>

<p style="margin-top: 1em">iodepth_batch=int,
iodepth_batch_submit=int <br>
This defines how many pieces of IO to submit at once. It
defaults to 1 which means that we submit each IO as soon as
it is available, but can be raised to submit bigger <br>
batches of IO at the time. If it is set to 0 the iodepth
value will be used.</p>

<p style="margin-top: 1em">iodepth_batch_complete_min=int,
iodepth_batch_complete=int <br>
This defines how many pieces of IO to retrieve at once. It
defaults to 1 which <br>
means that we&rsquo;ll ask for a minimum of 1 IO in the
retrieval process from the kernel. The IO retrieval will go
on until we hit the limit set by iodepth_low. If this
vari&acirc; <br>
able is set to 0, then fio will always check for completed
events before queuing more IO. This helps reduce IO latency,
at the cost of more retrieval system calls.</p>

<p style="margin-top: 1em">iodepth_batch_complete_max=int
<br>
This defines maximum pieces of IO to retrieve at once. This
variable should be used along with
iodepth_batch_complete_min=int variable, specifying the
range of min and max <br>
amount of IO which should be retrieved. By default it is
equal to iodepth_batch_complete_min value.</p>

<p style="margin-top: 1em">Example #1: <br>
iodepth_batch_complete_min=1</p>


<p style="margin-top: 1em">iodepth_batch_complete_max=&lt;iodepth&gt;</p>

<p style="margin-top: 1em">which means that we will
retrieve at least 1 IO and up to the whole submitted queue
depth. If none of IO has been completed yet, we will
wait.</p>

<p style="margin-top: 1em">Example #2: <br>
iodepth_batch_complete_min=0</p>


<p style="margin-top: 1em">iodepth_batch_complete_max=&lt;iodepth&gt;</p>

<p style="margin-top: 1em">which means that we can retrieve
up to the whole submitted queue depth, but if none of IO has
been completed yet, we will NOT wait and immediately exit
the system call. In <br>
this example we simply do polling.</p>

<p style="margin-top: 1em">iodepth_low=int <br>
Low watermark indicating when to start filling the queue
again. Default: iodepth.</p>

<p style="margin-top: 1em">io_submit_mode=str <br>
This option controls how fio submits the IO to the IO
engine. The default is inline, which means that the fio job
threads submit and reap IO directly. If set to offload, <br>
the job threads will offload IO submission to a dedicated
pool of IO threads. This requires some coordination and thus
has a bit of extra overhead, especially for lower <br>
queue depth IO where it can increase latencies. The benefit
is that fio can manage submission rates independently of the
device completion rates. This avoids skewed <br>
latency reporting if IO gets back up on the device side (the
coordinated omission problem).</p>

<p style="margin-top: 1em">direct=bool <br>
If true, use non-buffered I/O (usually O_DIRECT). Default:
false.</p>

<p style="margin-top: 1em">atomic=bool <br>
If value is true, attempt to use atomic direct IO. Atomic
writes are guaranteed to be stable once acknowledged by the
operating system. Only Linux supports O_ATOMIC right <br>
now.</p>

<p style="margin-top: 1em">buffered=bool <br>
If true, use buffered I/O. This is the opposite of the
direct parameter. Default: true.</p>

<p style="margin-top: 1em">offset=int <br>
Offset in the file to start I/O. Data before the offset will
not be touched.</p>

<p style="margin-top: 1em">offset_increment=int <br>
If this is provided, then the real offset becomes the offset
+ offset_increment * thread_number, where the thread number
is a counter that starts at 0 and is incremented <br>
for each sub-job (i.e. when numjobs option is specified).
This option is useful if there are several jobs which are
intended to operate on a file in parallel disjoint
seg&acirc; <br>
ments, with even spacing between the starting points.</p>

<p style="margin-top: 1em">number_ios=int <br>
Fio will normally perform IOs until it has exhausted the
size of the region set by size, or if it exhaust the
allocated time (or hits an error condition). With this
set&acirc; <br>
ting, the range/size can be set independently of the number
of IOs to perform. When fio reaches this number, it will
exit normally and report status. Note that this does <br>
not extend the amount of IO that will be done, it will only
stop fio if this condition is met before other end-of-job
criteria.</p>

<p style="margin-top: 1em">fsync=int <br>
How many I/Os to perform before issuing an fsync(2) of dirty
data. If 0, don&rsquo;t sync. Default: 0.</p>

<p style="margin-top: 1em">fdatasync=int <br>
Like fsync, but uses fdatasync(2) instead to only sync the
data parts of the file. Default: 0.</p>

<p style="margin-top: 1em">write_barrier=int <br>
Make every Nth write a barrier write.</p>

<p style="margin-top: 1em">sync_file_range=str:int <br>
Use sync_file_range(2) for every val number of write
operations. Fio will track range of writes that have
happened since the last sync_file_range(2) call. str can
cur&acirc; <br>
rently be one or more of:</p>

<p style="margin-top: 1em">wait_before <br>
SYNC_FILE_RANGE_WAIT_BEFORE</p>

<p style="margin-top: 1em">write SYNC_FILE_RANGE_WRITE</p>

<p style="margin-top: 1em">wait_after <br>
SYNC_FILE_RANGE_WRITE</p>

<p style="margin-top: 1em">So if you do
sync_file_range=wait_before,write:8, fio would use <br>
SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE for
every 8 writes. Also see the sync_file_range(2) man page.
This option is Linux specific.</p>

<p style="margin-top: 1em">overwrite=bool <br>
If writing, setup the file first and do overwrites. Default:
false.</p>

<p style="margin-top: 1em">end_fsync=bool <br>
Sync file contents when a write stage has completed.
Default: false.</p>

<p style="margin-top: 1em">fsync_on_close=bool <br>
If true, sync file contents on close. This differs from
end_fsync in that it will happen on every close, not just at
the end of the job. Default: false.</p>

<p style="margin-top: 1em">rwmixread=int <br>
Percentage of a mixed workload that should be reads.
Default: 50.</p>

<p style="margin-top: 1em">rwmixwrite=int <br>
Percentage of a mixed workload that should be writes. If
rwmixread and rwmixwrite are given and do not sum to 100%,
the latter of the two overrides the first. This may <br>
interfere with a given rate setting, if fio is asked to
limit reads or writes to a certain rate. If that is the
case, then the distribution may be skewed. Default: 50.</p>

<p style="margin-top: 1em">random_distribution=str:float
<br>
By default, fio will use a completely uniform random
distribution when asked to perform random IO. Sometimes it
is useful to skew the distribution in specific ways,
ensur&acirc; <br>
ing that some parts of the data is more hot than others. Fio
includes the following distribution models:</p>

<p style="margin-top: 1em">random Uniform random
distribution</p>

<p style="margin-top: 1em">zipf Zipf distribution</p>

<p style="margin-top: 1em">pareto Pareto distribution</p>

<p style="margin-top: 1em">gauss Normal (gaussian)
distribution</p>

<p style="margin-top: 1em">zoned Zoned random
distribution</p>

<p style="margin-top: 1em">When using a zipf or pareto
distribution, an input value is also <br>
needed to define the access pattern. For zipf, this is the
zipf theta. For pareto, it&rsquo;s the pareto power. Fio
includes a test program, genzipf, that can be used visualize
<br>
what the given input values will yield in terms of hit
rates. If you wanted to use zipf with a theta of 1.2, you
would use random_distribution=zipf:1.2 as the option. If a
<br>
non-uniform model is used, fio will disable use of the
random map. For the gauss distribution, a normal deviation
is supplied as a value between 0 and 100.</p>

<p style="margin-top: 1em">For a zoned distribution, fio
supports specifying percentages of IO access that should
fall within what range of the file or device. For example,
given a criteria of:</p>

<p style="margin-top: 1em">60% of accesses should be to the
first 10% <br>
30% of accesses should be to the next 20% <br>
8% of accesses should be to to the next 30% <br>
2% of accesses should be to the next 40%</p>

<p style="margin-top: 1em">we can define that through
zoning of the random accesses. For the above example, the
user would do:</p>


<p style="margin-top: 1em">random_distribution=zoned:60/10:30/20:8/30:2/40</p>

<p style="margin-top: 1em">similarly to how bssplit works
for setting ranges and percentages of block sizes. Like
bssplit, it&rsquo;s possible to specify separate zones for
reads, writes, and trims. If <br>
just one set is given, it&rsquo;ll apply to all of them.</p>

<p style="margin-top: 1em">percentage_random=int <br>
For a random workload, set how big a percentage should be
random. This defaults to 100%, in which case the workload is
fully random. It can be set from anywhere from 0 to <br>
100. Setting it to 0 would make the workload fully
sequential. It is possible to set different values for
reads, writes, and trim. To do so, simply use a comma
separated <br>
list. See blocksize.</p>

<p style="margin-top: 1em">norandommap <br>
Normally fio will cover every block of the file when doing
random I/O. If this parameter is given, a new offset will be
chosen without looking at past I/O history. This <br>
parameter is mutually exclusive with verify.</p>

<p style="margin-top: 1em">softrandommap=bool <br>
See norandommap. If fio runs with the random block map
enabled and it fails to allocate the map, if this option is
set it will continue without a random block map. As
cov&acirc; <br>
erage will not be as complete as with random maps, this
option is disabled by default.</p>

<p style="margin-top: 1em">random_generator=str <br>
Fio supports the following engines for generating IO offsets
for random IO:</p>

<p style="margin-top: 1em">tausworthe <br>
Strong 2^88 cycle random number generator</p>

<p style="margin-top: 1em">lfsr Linear feedback shift
register generator</p>

<p style="margin-top: 1em">tausworthe64 <br>
Strong 64-bit 2^258 cycle random number generator</p>

<p style="margin-top: 1em">Tausworthe is a strong random
number generator, but it requires tracking on the <br>
side if we want to ensure that blocks are only read or
written once. LFSR guarantees that we never generate the
same offset twice, and it&rsquo;s also less computationally
<br>
expensive. It&rsquo;s not a true random generator, however,
though for IO purposes it&rsquo;s typically good enough.
LFSR only works with single block sizes, not with workloads
that <br>
use multiple block sizes. If used with such a workload, fio
may read or write some blocks multiple times. The default
value is tausworthe, unless the required space <br>
exceeds 2^32 blocks. If it does, then tausworthe64 is
selected automatically.</p>

<p style="margin-top: 1em">nice=int <br>
Run job with given nice value. See nice(2).</p>

<p style="margin-top: 1em">prio=int <br>
Set I/O priority value of this job between 0 (highest) and 7
(lowest). See ionice(1).</p>

<p style="margin-top: 1em">prioclass=int <br>
Set I/O priority class. See ionice(1).</p>

<p style="margin-top: 1em">thinktime=int <br>
Stall job for given number of microseconds between issuing
I/Os.</p>

<p style="margin-top: 1em">thinktime_spin=int <br>
Pretend to spend CPU time for given number of microseconds,
sleeping the rest of the time specified by thinktime. Only
valid if thinktime is set.</p>

<p style="margin-top: 1em">thinktime_blocks=int <br>
Only valid if thinktime is set - control how many blocks to
issue, before waiting thinktime microseconds. If not set,
defaults to 1 which will make fio wait thinktime <br>
microseconds after every block. This effectively makes any
queue depth setting redundant, since no more than 1 IO will
be queued before we have to complete it and do our <br>
thinktime. In other words, this setting effectively caps the
queue depth if the latter is larger. Default: 1.</p>

<p style="margin-top: 1em">rate=int <br>
Cap bandwidth used by this job. The number is in bytes/sec,
the normal postfix rules apply. You can use rate=500k to
limit reads and writes to 500k each, or you can spec&acirc;
<br>
ify read and writes separately. Using rate=1m,500k would
limit reads to 1MB/sec and writes to 500KB/sec. Capping only
reads or writes can be done with rate=,500k or <br>
rate=500k,. The former will only limit writes (to
500KB/sec), the latter will only limit reads.</p>

<p style="margin-top: 1em">rate_min=int <br>
Tell fio to do whatever it can to maintain at least the
given bandwidth. Failing to meet this requirement will cause
the job to exit. The same format as rate is used for <br>
read vs write separation.</p>

<p style="margin-top: 1em">rate_iops=int <br>
Cap the bandwidth to this number of IOPS. Basically the same
as rate, just specified independently of bandwidth. The same
format as rate is used for read vs write separa&acirc; <br>
tion. If blocksize is a range, the smallest block size is
used as the metric.</p>

<p style="margin-top: 1em">rate_iops_min=int <br>
If this rate of I/O is not met, the job will exit. The same
format as rate is used for read vs write separation.</p>

<p style="margin-top: 1em">rate_process=str <br>
This option controls how fio manages rated IO submissions.
The default is linear, which submits IO in a linear fashion
with fixed delays between IOs that gets adjusted <br>
based on IO completion rates. If this is set to poisson, fio
will submit IO based on a more real world random request
flow, known as the Poisson process <br>
(https://en.wikipedia.org/wiki/Poisson_process). The lambda
will be 10^6 / IOPS for the given workload.</p>

<p style="margin-top: 1em">rate_cycle=int <br>
Average bandwidth for rate and rate_min over this number of
milliseconds. Default: 1000ms.</p>

<p style="margin-top: 1em">latency_target=int <br>
If set, fio will attempt to find the max performance point
that the given workload will run at while maintaining a
latency below this target. The values is given in <br>
microseconds. See latency_window and latency_percentile.</p>

<p style="margin-top: 1em">latency_window=int <br>
Used with latency_target to specify the sample window that
the job is run at varying queue depths to test the
performance. The value is given in microseconds.</p>

<p style="margin-top: 1em">latency_percentile=float <br>
The percentage of IOs that must fall within the criteria
specified by latency_target and latency_window. If not set,
this defaults to 100.0, meaning that all IOs must be <br>
equal or below to the value set by latency_target.</p>

<p style="margin-top: 1em">max_latency=int <br>
If set, fio will exit the job if it exceeds this maximum
latency. It will exit with an ETIME error.</p>

<p style="margin-top: 1em">cpumask=int <br>
Set CPU affinity for this job. int is a bitmask of allowed
CPUs the job may run on. See sched_setaffinity(2).</p>

<p style="margin-top: 1em">cpus_allowed=str <br>
Same as cpumask, but allows a comma-delimited list of CPU
numbers.</p>

<p style="margin-top: 1em">cpus_allowed_policy=str <br>
Set the policy of how fio distributes the CPUs specified by
cpus_allowed or cpumask. Two policies are supported:</p>

<p style="margin-top: 1em">shared All jobs will share the
CPU set specified.</p>

<p style="margin-top: 1em">split Each job will get a unique
CPU from the CPU set.</p>

<p style="margin-top: 1em">shared is the default behaviour,
if the option isn&rsquo;t specified. If split is specified,
then fio will assign one cpu per job. If not enough CPUs are
given for the jobs <br>
listed, then fio will roundrobin the CPUs in the set.</p>

<p style="margin-top: 1em">numa_cpu_nodes=str <br>
Set this job running on specified NUMA nodes&rsquo; CPUs.
The arguments allow comma delimited list of cpu numbers, A-B
ranges, or &rsquo;all&rsquo;.</p>

<p style="margin-top: 1em">numa_mem_policy=str <br>
Set this job&rsquo;s memory policy and corresponding NUMA
nodes. Format of the arguments:</p>


<p style="margin-top: 1em">&lt;mode&gt;[:&lt;nodelist&gt;]</p>

<p style="margin-top: 1em">mode is one of the following
memory policy:</p>

<p style="margin-top: 1em">default, prefer, bind,
interleave, local</p>

<p style="margin-top: 1em">For default and local memory
policy, no nodelist is <br>
needed to be specified. For prefer, only one node is
allowed. For bind and interleave, nodelist allows comma
delimited list of numbers, A-B ranges, or
&rsquo;all&rsquo;.</p>

<p style="margin-top: 1em">startdelay=irange <br>
Delay start of job for the specified number of seconds.
Supports all time suffixes to allow specification of hours,
minutes, seconds and milliseconds - seconds are the <br>
default if a unit is omitted. Can be given as a range which
causes each thread to choose randomly out of the range.</p>

<p style="margin-top: 1em">runtime=int <br>
Terminate processing after the specified number of
seconds.</p>

<p style="margin-top: 1em">time_based <br>
If given, run for the specified runtime duration even if the
files are completely read or written. The same workload will
be repeated as many times as runtime allows.</p>

<p style="margin-top: 1em">ramp_time=int <br>
If set, fio will run the specified workload for this amount
of time before logging any performance numbers. Useful for
letting performance settle before logging results, <br>
thus minimizing the runtime required for stable results.
Note that the ramp_time is considered lead in time for a
job, thus it will increase the total runtime if a special
<br>
timeout or runtime is specified.</p>

<p style="margin-top: 1em">steadystate=str:float,
ss=str:float <br>
Define the criterion and limit for assessing steady state
performance. The first parameter designates the criterion
whereas the second parameter sets the threshold. When <br>
the criterion falls below the threshold for the specified
duration, the job will stop. For example, iops_slope:0.1%
will direct fio to terminate the job when the least <br>
squares regression slope falls below 0.1% of the mean IOPS.
If group_reporting is enabled this will apply to all jobs in
the group. All assessments are carried out using <br>
only data from the rolling collection window. Threshold
limits can be expressed as a fixed value or as a percentage
of the mean in the collection window. Below are the <br>
available steady state assessment criteria.</p>

<p style="margin-top: 1em">iops Collect IOPS data. Stop the
job if all individual IOPS measurements are within the
specified limit of the mean IOPS (e.g., iops:2 means that
all individual <br>
IOPS values must be within 2 of the mean, whereas iops:0.2%
means that all individual IOPS values must be within 0.2% of
the mean IOPS to terminate the job).</p>

<p style="margin-top: 1em">iops_slope <br>
Collect IOPS data and calculate the least squares regression
slope. Stop the job if the slope falls below the specified
limit.</p>

<p style="margin-top: 1em">bw Collect bandwidth data. Stop
the job if all individual bandwidth measurements are within
the specified limit of the mean bandwidth.</p>

<p style="margin-top: 1em">bw_slope <br>
Collect bandwidth data and calculate the least squares
regression slope. Stop the job if the slope falls below the
specified limit.</p>

<p style="margin-top: 1em">steadystate_duration=time,
ss_dur=time <br>
A rolling window of this duration will be used to judge
whether steady state has been reached. Data will be
collected once per second. The default is 0 which disables
<br>
steady state detection.</p>

<p style="margin-top: 1em">steadystate_ramp_time=time,
ss_ramp=time <br>
Allow the job to run for the specified duration before
beginning data collection for checking the steady state job
termination criterion. The default is 0.</p>

<p style="margin-top: 1em">invalidate=bool <br>
Invalidate buffer-cache for the file prior to starting I/O.
Default: true.</p>

<p style="margin-top: 1em">sync=bool <br>
Use synchronous I/O for buffered writes. For the majority of
I/O engines, this means using O_SYNC. Default: false.</p>

<p style="margin-top: 1em">iomem=str, mem=str <br>
Allocation method for I/O unit buffer. Allowed values
are:</p>

<p style="margin-top: 1em">malloc Allocate memory with
malloc(3). Default memory type.</p>

<p style="margin-top: 1em">shm Use shared memory buffers
allocated through shmget(2).</p>

<p style="margin-top: 1em">shmhuge <br>
Same as shm, but use huge pages as backing.</p>

<p style="margin-top: 1em">mmap Use mmap(2) for allocation.
Uses anonymous memory unless a filename is given after the
option in the format &lsquo;:file&rsquo;.</p>

<p style="margin-top: 1em">mmaphuge <br>
Same as mmap, but use huge files as backing.</p>

<p style="margin-top: 1em">mmapshared <br>
Same as mmap, but use a MMAP_SHARED mapping.</p>

<p style="margin-top: 1em">The amount of memory allocated
is the maximum allowed blocksize for the job multiplied by
iodepth. For shmhuge or mmaphuge to work, the system must
have free huge pages <br>
allocated. mmaphuge also needs to have hugetlbfs mounted,
and file must point there. At least on Linux, huge pages
must be manually allocated. See /proc/sys/vm/nr_huge&acirc;
<br>
hages and the documentation for that. Normally you just need
to echo an appropriate number, eg echoing 8 will ensure that
the OS has 8 huge pages ready for use.</p>

<p style="margin-top: 1em">iomem_align=int, mem_align=int
<br>
This indicates the memory alignment of the IO memory
buffers. Note that the given alignment is applied to the
first IO unit buffer, if using iodepth the alignment of the
<br>
following buffers are given by the bs used. In other words,
if using a bs that is a multiple of the page sized in the
system, all buffers will be aligned to this value. If <br>
using a bs that is not page aligned, the alignment of
subsequent IO memory buffers is the sum of the iomem_align
and bs used.</p>

<p style="margin-top: 1em">hugepage-size=int <br>
Defines the size of a huge page. Must be at least equal to
the system setting. Should be a multiple of 1MB. Default:
4MB.</p>

<p style="margin-top: 1em">exitall <br>
Terminate all jobs when one finishes. Default: wait for each
job to finish.</p>

<p style="margin-top: 1em">exitall_on_error =bool <br>
Terminate all jobs if one job finishes in error. Default:
wait for each job to finish.</p>

<p style="margin-top: 1em">bwavgtime=int <br>
Average bandwidth calculations over the given time in
milliseconds. If the job also does bandwidth logging through
write_bw_log, then the minimum of this option and <br>
log_avg_msec will be used. Default: 500ms.</p>

<p style="margin-top: 1em">iopsavgtime=int <br>
Average IOPS calculations over the given time in
milliseconds. If the job also does IOPS logging through
write_iops_log, then the minimum of this option and
log_avg_msec <br>
will be used. Default: 500ms.</p>

<p style="margin-top: 1em">create_serialize=bool <br>
If true, serialize file creation for the jobs. Default:
true.</p>

<p style="margin-top: 1em">create_fsync=bool <br>
fsync(2) data file after creation. Default: true.</p>

<p style="margin-top: 1em">create_on_open=bool <br>
If true, the files are not created until they are opened for
IO by the job.</p>

<p style="margin-top: 1em">create_only=bool <br>
If true, fio will only run the setup phase of the job. If
files need to be laid out or updated on disk, only that will
be done. The actual job contents are not executed.</p>

<p style="margin-top: 1em">allow_file_create=bool <br>
If true, fio is permitted to create files as part of its
workload. This is the default behavior. If this option is
false, then fio will error out if the files it needs to <br>
use don&rsquo;t already exist. Default: true.</p>

<p style="margin-top: 1em">allow_mounted_write=bool <br>
If this isn&rsquo;t set, fio will abort jobs that are
destructive (eg that write) to what appears to be a mounted
device or partition. This should help catch creating
inadver&acirc; <br>
tently destructive tests, not realizing that the test will
destroy data on the mounted file system. Default: false.</p>

<p style="margin-top: 1em">pre_read=bool <br>
If this is given, files will be pre-read into memory before
starting the given IO operation. This will also clear the
invalidate flag, since it is pointless to pre-read <br>
and then drop the cache. This will only work for IO engines
that are seekable, since they allow you to read the same
data multiple times. Thus it will not work on eg net&acirc;
<br>
work or splice IO.</p>

<p style="margin-top: 1em">unlink=bool <br>
Unlink job files when done. Default: false.</p>

<p style="margin-top: 1em">unlink_each_loop=bool <br>
Unlink job files after each iteration or loop. Default:
false.</p>

<p style="margin-top: 1em">loops=int <br>
Specifies the number of iterations (runs of the same
workload) of this job. Default: 1.</p>

<p style="margin-top: 1em">verify_only=bool <br>
Do not perform the specified workload, only verify data
still matches previous invocation of this workload. This
option allows one to check data multiple times at a later
<br>
date without overwriting it. This option makes sense only
for workloads that write data, and does not support
workloads with the time_based option set.</p>

<p style="margin-top: 1em">do_verify=bool <br>
Run the verify phase after a write phase. Only valid if
verify is set. Default: true.</p>

<p style="margin-top: 1em">verify=str <br>
Method of verifying file contents after each iteration of
the job. Each verification method also implies verification
of special header, which is written to the beginning <br>
of each block. This header also includes meta information,
like offset of the block, block number, timestamp when block
was written, etc. verify=str can be combined with <br>
verify_pattern=str option. The allowed values are:</p>

<p style="margin-top: 1em">md5 crc16 crc32 crc32c
crc32c-intel crc64 crc7 sha256 sha512 sha1 xxhash <br>
Store appropriate checksum in the header of each block.
crc32c-intel is hardware accelerated SSE4.2 driven, falls
back to regular crc32c if not supported by <br>
the system.</p>

<p style="margin-top: 1em">meta This option is deprecated,
since now meta information is included in generic
verification header and meta verification happens by
default. For detailed <br>
information see the description of the verify=str setting.
This option is kept because of compatibility&rsquo;s sake
with old configurations. Do not use it.</p>

<p style="margin-top: 1em">pattern <br>
Verify a strict pattern. Normally fio includes a header with
some basic information and checksumming, but if this option
is set, only the specific pattern <br>
set with verify_pattern is verified.</p>

<p style="margin-top: 1em">null Pretend to verify. Used for
testing internals.</p>

<p style="margin-top: 1em">This option can be used for
repeated burn-in tests of a system to make sure that the
written data is also correctly read back. If the data
direction given is a read or <br>
random read, fio will assume that it should verify a
previously written file. If the data direction includes any
form of write, the verify will be of the newly written <br>
data.</p>

<p style="margin-top: 1em">verifysort=bool <br>
If true, written verify blocks are sorted if fio deems it to
be faster to read them back in a sorted manner. Default:
true.</p>

<p style="margin-top: 1em">verifysort_nr=int <br>
Pre-load and sort verify blocks for a read workload.</p>

<p style="margin-top: 1em">verify_offset=int <br>
Swap the verification header with data somewhere else in the
block before writing. It is swapped back before
verifying.</p>

<p style="margin-top: 1em">verify_interval=int <br>
Write the verification header for this number of bytes,
which should divide blocksize. Default: blocksize.</p>

<p style="margin-top: 1em">verify_pattern=str <br>
If set, fio will fill the io buffers with this pattern. Fio
defaults to filling with totally random bytes, but sometimes
it&rsquo;s interesting to fill with a known pattern for <br>
io verification purposes. Depending on the width of the
pattern, fio will fill 1/2/3/4 bytes of the buffer at the
time(it can be either a decimal or a hex number). The <br>
verify_pattern if larger than a 32-bit quantity has to be a
hex number that starts with either &quot;0x&quot; or
&quot;0X&quot;. Use with verify=str. Also, verify_pattern
supports %o format, <br>
which means that for each block offset will be written and
then verified back, e.g.: <br>
verify_pattern=%o <br>
Or use combination of everything:</p>


<p style="margin-top: 1em">verify_pattern=0xff%o&quot;abcd&quot;-21</p>

<p style="margin-top: 1em">verify_fatal=bool <br>
If true, exit the job on the first observed verification
failure. Default: false.</p>

<p style="margin-top: 1em">verify_dump=bool <br>
If set, dump the contents of both the original data block
and the data block we read off disk to files. This allows
later analysis to inspect just what kind of data cor&acirc;
<br>
ruption occurred. Off by default.</p>

<p style="margin-top: 1em">verify_async=int <br>
Fio will normally verify IO inline from the submitting
thread. This option takes an integer describing how many
async offload threads to create for IO verification <br>
instead, causing fio to offload the duty of verifying IO
contents to one or more separate threads. If using this
offload option, even sync IO engines can benefit from <br>
using an iodepth setting higher than 1, as it allows them to
have IO in flight while verifies are running.</p>

<p style="margin-top: 1em">verify_async_cpus=str <br>
Tell fio to set the given CPU affinity on the async IO
verification threads. See cpus_allowed for the format
used.</p>

<p style="margin-top: 1em">verify_backlog=int <br>
Fio will normally verify the written contents of a job that
utilizes verify once that job has completed. In other words,
everything is written then everything is read back <br>
and verified. You may want to verify continually instead for
a variety of reasons. Fio stores the meta data associated
with an IO block in memory, so for large verify <br>
workloads, quite a bit of memory would be used up holding
this meta data. If this option is enabled, fio will write
only N blocks before verifying these blocks.</p>

<p style="margin-top: 1em">verify_backlog_batch=int <br>
Control how many blocks fio will verify if verify_backlog is
set. If not set, will default to the value of verify_backlog
(meaning the entire queue is read back and veri&acirc; <br>
fied). If verify_backlog_batch is less than verify_backlog
then not all blocks will be verified, if
verify_backlog_batch is larger than verify_backlog, some
blocks will <br>
be verified more than once.</p>

<p style="margin-top: 1em">trim_percentage=int <br>
Number of verify blocks to discard/trim.</p>

<p style="margin-top: 1em">trim_verify_zero=bool <br>
Verify that trim/discarded blocks are returned as
zeroes.</p>

<p style="margin-top: 1em">trim_backlog=int <br>
Trim after this number of blocks are written.</p>

<p style="margin-top: 1em">trim_backlog_batch=int <br>
Trim this number of IO blocks.</p>

<p style="margin-top: 1em">experimental_verify=bool <br>
Enable experimental verification.</p>

<p style="margin-top: 1em">verify_state_save=bool <br>
When a job exits during the write phase of a verify
workload, save its current state. This allows fio to replay
up until that point, if the verify state is loaded for the
<br>
verify read phase.</p>

<p style="margin-top: 1em">verify_state_load=bool <br>
If a verify termination trigger was used, fio stores the
current write state of each thread. This can be used at
verification time so that fio knows how far it should
ver&acirc; <br>
ify. Without this information, fio will run a full
verification pass, according to the settings in the job file
used.</p>

<p style="margin-top: 1em">stonewall , wait_for_previous
<br>
Wait for preceding jobs in the job file to exit before
starting this one. stonewall implies new_group.</p>

<p style="margin-top: 1em">new_group <br>
Start a new reporting group. If not given, all jobs in a
file will be part of the same reporting group, unless
separated by a stonewall.</p>

<p style="margin-top: 1em">numjobs=int <br>
Number of clones (processes/threads performing the same
workload) of this job. Default: 1.</p>

<p style="margin-top: 1em">group_reporting <br>
If set, display per-group reports instead of per-job when
numjobs is specified.</p>

<p style="margin-top: 1em">thread Use threads created with
pthread_create(3) instead of processes created with
fork(2).</p>

<p style="margin-top: 1em">zonesize=int <br>
Divide file into zones of the specified size in bytes. See
zoneskip.</p>

<p style="margin-top: 1em">zonerange=int <br>
Give size of an IO zone. See zoneskip.</p>

<p style="margin-top: 1em">zoneskip=int <br>
Skip the specified number of bytes when zonesize bytes of
data have been read.</p>

<p style="margin-top: 1em">write_iolog=str <br>
Write the issued I/O patterns to the specified file. Specify
a separate file for each job, otherwise the iologs will be
interspersed and the file may be corrupt.</p>

<p style="margin-top: 1em">read_iolog=str <br>
Replay the I/O patterns contained in the specified file
generated by write_iolog, or may be a blktrace binary
file.</p>

<p style="margin-top: 1em">replay_no_stall=int <br>
While replaying I/O patterns using read_iolog the default
behavior attempts to respect timing information between
I/Os. Enabling replay_no_stall causes I/Os to be <br>
replayed as fast as possible while still respecting
ordering.</p>

<p style="margin-top: 1em">replay_redirect=str <br>
While replaying I/O patterns using read_iolog the default
behavior is to replay the IOPS onto the major/minor device
that each IOP was recorded from. Setting replay_redi&acirc;
<br>
rect causes all IOPS to be replayed onto the single
specified device regardless of the device it was recorded
from.</p>

<p style="margin-top: 1em">replay_align=int <br>
Force alignment of IO offsets and lengths in a trace to this
power of 2 value.</p>

<p style="margin-top: 1em">replay_scale=int <br>
Scale sector offsets down by this factor when replaying
traces.</p>

<p style="margin-top: 1em">per_job_logs=bool <br>
If set, this generates bw/clat/iops log with per file
private filenames. If not set, jobs with identical names
will share the log filename. Default: true.</p>

<p style="margin-top: 1em">write_bw_log=str <br>
If given, write a bandwidth log for this job. Can be used to
store data of the bandwidth of the jobs in their lifetime.
The included fio_generate_plots script uses gnuplot <br>
to turn these text files into nice graphs. See write_lat_log
for behaviour of given filename. For this option, the
postfix is _bw.x.log, where x is the index of the job <br>
(1..N, where N is the number of jobs). If per_job_logs is
false, then the filename will not include the job index. See
the LOG FILE FORMATS section.</p>

<p style="margin-top: 1em">write_lat_log=str <br>
Same as write_bw_log, but writes I/O completion latencies.
If no filename is given with this option, the default
filename of &quot;jobname_type.x.log&quot; is used, where x
is the <br>
index of the job (1..N, where N is the number of jobs). Even
if the filename is given, fio will still append the type of
log. If per_job_logs is false, then the filename <br>
will not include the job index. See the LOG FILE FORMATS
section.</p>

<p style="margin-top: 1em">write_hist_log=str <br>
Same as write_lat_log, but writes I/O completion latency
histograms. If no filename is given with this option, the
default filename of &quot;jobname_clat_hist.x.log&quot; is
used, <br>
where x is the index of the job (1..N, where N is the number
of jobs). Even if the filename is given, fio will still
append the type of log. If per_job_logs is false, then <br>
the filename will not include the job index. See the LOG
FILE FORMATS section.</p>

<p style="margin-top: 1em">write_iops_log=str <br>
Same as write_bw_log, but writes IOPS. If no filename is
given with this option, the default filename of
&quot;jobname_type.x.log&quot; is used, where x is the index
of the job <br>
(1..N, where N is the number of jobs). Even if the filename
is given, fio will still append the type of log. If
per_job_logs is false, then the filename will not include
<br>
the job index. See the LOG FILE FORMATS section.</p>

<p style="margin-top: 1em">log_avg_msec=int <br>
By default, fio will log an entry in the iops, latency, or
bw log for every IO that completes. When writing to the disk
log, that can quickly grow to a very large size. <br>
Setting this option makes fio average the each log entry
over the specified period of time, reducing the resolution
of the log. See log_max_value as well. Defaults to 0, <br>
logging all entries.</p>

<p style="margin-top: 1em">log_max_value=bool <br>
If log_avg_msec is set, fio logs the average over that
window. If you instead want to log the maximum value, set
this option to 1. Defaults to 0, meaning that averaged <br>
values are logged.</p>

<p style="margin-top: 1em">log_hist_msec=int <br>
Same as log_avg_msec, but logs entries for completion
latency histograms. Computing latency percentiles from
averages of intervals using log_avg_msec is inacurate.
Set&acirc; <br>
ting this option makes fio log histogram entries over the
specified period of time, reducing log sizes for high IOPS
devices while retaining percentile accuracy. See <br>
log_hist_coarseness as well. Defaults to 0, meaning
histogram logging is disabled.</p>

<p style="margin-top: 1em">log_hist_coarseness=int <br>
Integer ranging from 0 to 6, defining the coarseness of the
resolution of the histogram logs enabled with log_hist_msec.
For each increment in coarseness, fio outputs half <br>
as many bins. Defaults to 0, for which histogram logs
contain 1216 latency bins. See the LOG FILE FORMATS
section.</p>

<p style="margin-top: 1em">log_offset=bool <br>
If this is set, the iolog options will include the byte
offset for the IO entry as well as the other data
values.</p>

<p style="margin-top: 1em">log_compression=int <br>
If this is set, fio will compress the IO logs as it goes, to
keep the memory footprint lower. When a log reaches the
specified size, that chunk is removed and compressed <br>
in the background. Given that IO logs are fairly highly
compressible, this yields a nice memory savings for longer
runs. The downside is that the compression will consume <br>
some background CPU cycles, so it may impact the run. This,
however, is also true if the logging ends up consuming most
of the system memory. So pick your poison. The IO <br>
logs are saved normally at the end of a run, by
decompressing the chunks and storing them in the specified
log file. This feature depends on the availability of
zlib.</p>

<p style="margin-top: 1em">log_compression_cpus=str <br>
Define the set of CPUs that are allowed to handle online log
compression for the IO jobs. This can provide better
isolation between performance sensitive jobs, and
back&acirc; <br>
ground compression work.</p>

<p style="margin-top: 1em">log_store_compressed=bool <br>
If set, fio will store the log files in a compressed format.
They can be decompressed with fio, using the --inflate-log
command line parameter. The files will be stored <br>
with a .fz suffix.</p>

<p style="margin-top: 1em">log_unix_epoch=bool <br>
If set, fio will log Unix timestamps to the log files
produced by enabling write_type_log for each log type,
instead of the default zero-based timestamps.</p>

<p style="margin-top: 1em">block_error_percentiles=bool
<br>
If set, record errors in trim block-sized units from writes
and trims and output a histogram of how many trims it took
to get to errors, and what kind of error was encoun&acirc;
<br>
tered.</p>

<p style="margin-top: 1em">disable_lat=bool <br>
Disable measurements of total latency numbers. Useful only
for cutting back the number of calls to gettimeofday(2), as
that does impact performance at really high IOPS <br>
rates. Note that to really get rid of a large amount of
these calls, this option must be used with disable_slat and
disable_bw as well.</p>

<p style="margin-top: 1em">disable_clat=bool <br>
Disable measurements of completion latency numbers. See
disable_lat.</p>

<p style="margin-top: 1em">disable_slat=bool <br>
Disable measurements of submission latency numbers. See
disable_lat.</p>

<p style="margin-top: 1em">disable_bw_measurement=bool <br>
Disable measurements of throughput/bandwidth numbers. See
disable_lat.</p>

<p style="margin-top: 1em">lockmem=int <br>
Pin the specified amount of memory with mlock(2). Can be
used to simulate a smaller amount of memory. The amount
specified is per worker.</p>

<p style="margin-top: 1em">exec_prerun=str <br>
Before running the job, execute the specified command with
system(3). <br>
Output is redirected in a file called jobname.prerun.txt</p>

<p style="margin-top: 1em">exec_postrun=str <br>
Same as exec_prerun, but the command is executed after the
job completes. <br>
Output is redirected in a file called
jobname.postrun.txt</p>

<p style="margin-top: 1em">ioscheduler=str <br>
Attempt to switch the device hosting the file to the
specified I/O scheduler.</p>

<p style="margin-top: 1em">disk_util=bool <br>
Generate disk utilization statistics if the platform
supports it. Default: true.</p>

<p style="margin-top: 1em">clocksource=str <br>
Use the given clocksource as the base of timing. The
supported options are:</p>

<p style="margin-top: 1em">gettimeofday <br>
gettimeofday(2)</p>

<p style="margin-top: 1em">clock_gettime <br>
clock_gettime(2)</p>

<p style="margin-top: 1em">cpu Internal CPU clock
source</p>

<p style="margin-top: 1em">cpu is the preferred clocksource
if it is reliable, as it is very fast <br>
(and fio is heavy on time calls). Fio will automatically use
this clocksource if it&rsquo;s supported and considered
reliable on the system it is running on, unless another <br>
clocksource is specifically set. For x86/x86-64 CPUs, this
means supporting TSC Invariant.</p>

<p style="margin-top: 1em">gtod_reduce=bool <br>
Enable all of the gettimeofday(2) reducing options
(disable_clat, disable_slat, disable_bw) plus reduce
precision of the timeout somewhat to really shrink the
gettimeof&acirc; <br>
day(2) call count. With this option enabled, we only do
about 0.4% of the gtod() calls we would have done if all
time keeping was enabled.</p>

<p style="margin-top: 1em">gtod_cpu=int <br>
Sometimes it&rsquo;s cheaper to dedicate a single thread of
execution to just getting the current time. Fio (and
databases, for instance) are very intensive on
gettimeofday(2) <br>
calls. With this option, you can set one CPU aside for doing
nothing but logging current time to a shared memory
location. Then the other threads/processes that run IO <br>
workloads need only copy that segment, instead of entering
the kernel with a gettimeofday(2) call. The CPU set aside
for doing these time calls will be excluded from other <br>
uses. Fio will manually clear it from the CPU mask of other
jobs.</p>

<p style="margin-top: 1em">ignore_error=str <br>
Sometimes you want to ignore some errors during test in that
case you can specify error list for each error type. <br>
ignore_error=READ_ERR_LIST,WRITE_ERR_LIST,VERIFY_ERR_LIST
<br>
errors for given error type is separated with
&rsquo;:&rsquo;. Error may be symbol (&rsquo;ENOSPC&rsquo;,
&rsquo;ENOMEM&rsquo;) or an integer. <br>
Example: ignore_error=EAGAIN,ENOSPC:122 . <br>
This option will ignore EAGAIN from READ, and ENOSPC and
122(EDQUOT) from WRITE.</p>

<p style="margin-top: 1em">error_dump=bool <br>
If set dump every error even if it is non fatal, true by
default. If disabled only fatal error will be dumped</p>

<p style="margin-top: 1em">profile=str <br>
Select a specific builtin performance test.</p>

<p style="margin-top: 1em">cgroup=str <br>
Add job to this control group. If it doesn&rsquo;t exist, it
will be created. The system must have a mounted cgroup blkio
mount point for this to work. If your system doesn&rsquo;t
<br>
have it mounted, you can do so with:</p>

<p style="margin-top: 1em"># mount -t cgroup -o blkio none
/cgroup</p>

<p style="margin-top: 1em">cgroup_weight=int <br>
Set the weight of the cgroup to this value. See the
documentation that comes with the kernel, allowed values are
in the range of 100..1000.</p>

<p style="margin-top: 1em">cgroup_nodelete=bool <br>
Normally fio will delete the cgroups it has created after
the job completion. To override this behavior and to leave
cgroups around after the job completion, set <br>
cgroup_nodelete=1. This can be useful if one wants to
inspect various cgroup files after job completion. Default:
false</p>

<p style="margin-top: 1em">uid=int <br>
Instead of running as the invoking user, set the user ID to
this value before the thread/process does any work.</p>

<p style="margin-top: 1em">gid=int <br>
Set group ID, see uid.</p>

<p style="margin-top: 1em">unit_base=int <br>
Base unit for reporting. Allowed values are:</p>

<p style="margin-top: 1em">0 Use auto-detection
(default).</p>

<p style="margin-top: 1em">8 Byte based.</p>

<p style="margin-top: 1em">1 Bit based.</p>

<p style="margin-top: 1em">flow_id=int <br>
The ID of the flow. If not specified, it defaults to being a
global flow. See flow.</p>

<p style="margin-top: 1em">flow=int <br>
Weight in token-based flow control. If this value is used,
then there is a flow counter which is used to regulate the
proportion of activity between two or more jobs. fio <br>
attempts to keep this flow counter near zero. The flow
parameter stands for how much should be added or subtracted
to the flow counter on each iteration of the main I/O <br>
loop. That is, if one job has flow=8 and another job has
flow=-1, then there will be a roughly 1:8 ratio in how much
one runs vs the other.</p>

<p style="margin-top: 1em">flow_watermark=int <br>
The maximum value that the absolute value of the flow
counter is allowed to reach before the job must wait for a
lower value of the counter.</p>

<p style="margin-top: 1em">flow_sleep=int <br>
The period of time, in microseconds, to wait after the flow
watermark has been exceeded before retrying operations</p>

<p style="margin-top: 1em">clat_percentiles=bool <br>
Enable the reporting of percentiles of completion
latencies.</p>

<p style="margin-top: 1em">percentile_list=float_list <br>
Overwrite the default list of percentiles for completion
latencies and the block error histogram. Each number is a
floating number in the range (0,100], and the maximum <br>
length of the list is 20. Use &rsquo;:&rsquo; to separate
the numbers. For example, --percentile_list=99.5:99.9 will
cause fio to report the values of completion latency below
which <br>
99.5% and 99.9% of the observed latencies fell,
respectively.</p>

<p style="margin-top: 1em">Ioengine Parameters List <br>
Some parameters are only valid when a specific ioengine is
in use. These are used identically to normal parameters,
with the caveat that when used on the command line, they
must <br>
come after the ioengine.</p>

<p style="margin-top: 1em">(cpuio)cpuload=int <br>
Attempt to use the specified percentage of CPU cycles.</p>

<p style="margin-top: 1em">(cpuio)cpuchunks=int <br>
Split the load into cycles of the given time. In
microseconds.</p>

<p style="margin-top: 1em">(cpuio)exit_on_io_done=bool <br>
Detect when IO threads are done, then exit.</p>

<p style="margin-top: 1em">(libaio)userspace_reap <br>
Normally, with the libaio engine in use, fio will use the
io_getevents system call to reap newly returned events. With
this flag turned on, the AIO ring will be read <br>
directly from user-space to reap events. The reaping mode is
only enabled when polling for a minimum of 0 events (eg when
iodepth_batch_complete=0).</p>

<p style="margin-top: 1em">(pvsync2)hipri <br>
Set RWF_HIPRI on IO, indicating to the kernel that
it&rsquo;s of higher priority than normal.</p>

<p style="margin-top: 1em">(net,netsplice)hostname=str <br>
The host name or IP address to use for TCP or UDP based IO.
If the job is a TCP listener or UDP reader, the hostname is
not used and must be omitted unless it is a valid <br>
UDP multicast address.</p>

<p style="margin-top: 1em">(net,netsplice)port=int <br>
The TCP or UDP port to bind to or connect to. If this is
used with numjobs to spawn multiple instances of the same
job type, then this will be the starting port number <br>
since fio will use a range of ports.</p>

<p style="margin-top: 1em">(net,netsplice)interface=str
<br>
The IP address of the network interface used to send or
receive UDP multicast packets.</p>

<p style="margin-top: 1em">(net,netsplice)ttl=int <br>
Time-to-live value for outgoing UDP multicast packets.
Default: 1</p>

<p style="margin-top: 1em">(net,netsplice)nodelay=bool <br>
Set TCP_NODELAY on TCP connections.</p>

<p style="margin-top: 1em">(net,netsplice)protocol=str,
proto=str <br>
The network protocol to use. Accepted values are:</p>

<p style="margin-top: 1em">tcp Transmission control
protocol</p>

<p style="margin-top: 1em">tcpv6 Transmission control
protocol V6</p>

<p style="margin-top: 1em">udp User datagram protocol</p>

<p style="margin-top: 1em">udpv6 User datagram protocol
V6</p>

<p style="margin-top: 1em">unix UNIX domain socket</p>

<p style="margin-top: 1em">When the protocol is TCP or UDP,
the port must also be given, as well as the hostname if the
job is a TCP listener or UDP reader. For unix sockets, the
normal filename <br>
option should be used and the port is invalid.</p>

<p style="margin-top: 1em">(net,netsplice)listen <br>
For TCP network connections, tell fio to listen for incoming
connections rather than initiating an outgoing connection.
The hostname must be omitted if this option is <br>
used.</p>

<p style="margin-top: 1em">(net,pingpong)=bool <br>
Normally a network writer will just continue writing data,
and a network reader will just consume packets. If
pingpong=1 is set, a writer will send its normal payload to
<br>
the reader, then wait for the reader to send the same
payload back. This allows fio to measure network latencies.
The submission and completion latencies then measure <br>
local time spent sending or receiving, and the completion
latency measures how long it took for the other end to
receive and send back. For UDP multicast traffic ping&acirc;
<br>
pong=1 should only be set for a single reader when multiple
readers are listening to the same address.</p>

<p style="margin-top: 1em">(net,window_size)=int <br>
Set the desired socket buffer size for the connection.</p>

<p style="margin-top: 1em">(net,mss)=int <br>
Set the TCP maximum segment size (TCP_MAXSEG).</p>

<p style="margin-top: 1em">(e4defrag,donorname)=str <br>
File will be used as a block donor (swap extents between
files)</p>

<p style="margin-top: 1em">(e4defrag,inplace)=int <br>
Configure donor file block allocation strategy <br>
0(default): Preallocate donor&rsquo;s file on init</p>

<p style="margin-top: 1em">1: allocate space immediately
inside defragment event, and free right after event</p>

<p style="margin-top: 1em">(rbd)clustername=str <br>
Specifies the name of the ceph cluster.</p>

<p style="margin-top: 1em">(rbd)rbdname=str <br>
Specifies the name of the RBD.</p>

<p style="margin-top: 1em">(rbd)pool=str <br>
Specifies the name of the Ceph pool containing the RBD.</p>

<p style="margin-top: 1em">(rbd)clientname=str <br>
Specifies the username (without the &rsquo;client.&rsquo;
prefix) used to access the Ceph cluster. If the clustername
is specified, the clientname shall be the full type.id
string. If <br>
no type. prefix is given, fio will add &rsquo;client.&rsquo;
by default.</p>

<p style="margin-top: 1em">(mtd)skipbad=bool <br>
Skip operations against known bad blocks.</p>

<p style="margin-top: 1em">OUTPUT <br>
While running, fio will display the status of the created
jobs. For example:</p>

<p style="margin-top: 1em">Threads: 1: [_r] [24.8% done] [
13509/ 8334 kb/s] [eta 00h:01m:31s]</p>

<p style="margin-top: 1em">The characters in the first set
of brackets denote the current status of each threads. The
possible values are:</p>

<p style="margin-top: 1em">P Setup but not started. <br>
C Thread created. <br>
I Initialized, waiting. <br>
R Running, doing sequential reads. <br>
r Running, doing random reads. <br>
W Running, doing sequential writes. <br>
w Running, doing random writes. <br>
M Running, doing mixed sequential reads/writes. <br>
m Running, doing mixed random reads/writes. <br>
F Running, currently waiting for fsync(2). <br>
V Running, verifying written data. <br>
E Exited, not reaped by main thread. <br>
- Exited, thread reaped.</p>

<p style="margin-top: 1em">The second set of brackets shows
the estimated completion percentage of the current group.
The third set shows the read and write I/O rate,
respectively. Finally, the estimated <br>
run time of the job is displayed.</p>

<p style="margin-top: 1em">When fio completes (or is
interrupted by Ctrl-C), it will show data for each thread,
each group of threads, and each disk, in that order.</p>

<p style="margin-top: 1em">Per-thread statistics first show
the threads client number, group-id, and error code. The
remaining figures are as follows:</p>

<p style="margin-top: 1em">io Number of megabytes of I/O
performed.</p>

<p style="margin-top: 1em">bw Average data rate
(bandwidth).</p>

<p style="margin-top: 1em">runt Threads run time.</p>

<p style="margin-top: 1em">slat Submission latency minimum,
maximum, average and standard deviation. This is the time it
took to submit the I/O.</p>

<p style="margin-top: 1em">clat Completion latency minimum,
maximum, average and standard deviation. This is the time
between submission and completion.</p>

<p style="margin-top: 1em">bw Bandwidth minimum, maximum,
percentage of aggregate bandwidth received, average and
standard deviation.</p>

<p style="margin-top: 1em">cpu CPU usage statistics.
Includes user and system time, number of context switches
this thread went through and number of major and minor page
faults. The CPU utiliza&acirc; <br>
tion numbers are averages for the jobs in that reporting
group, while the context and fault counters are summed.</p>

<p style="margin-top: 1em">IO depths <br>
Distribution of I/O depths. Each depth includes everything
less than (or equal) to it, but greater than the previous
depth.</p>

<p style="margin-top: 1em">IO issued <br>
Number of read/write requests issued, and number of short
read/write requests.</p>

<p style="margin-top: 1em">IO latencies <br>
Distribution of I/O completion latencies. The numbers follow
the same pattern as IO depths.</p>

<p style="margin-top: 1em">The group statistics show: <br>
io Number of megabytes I/O performed. <br>
aggrb Aggregate bandwidth of threads in the group. <br>
minb Minimum average bandwidth a thread saw. <br>
maxb Maximum average bandwidth a thread saw. <br>
mint Shortest runtime of threads in the group. <br>
maxt Longest runtime of threads in the group.</p>

<p style="margin-top: 1em">Finally, disk statistics are
printed with reads first: <br>
ios Number of I/Os performed by all groups. <br>
merge Number of merges in the I/O scheduler. <br>
ticks Number of ticks we kept the disk busy. <br>
io_queue <br>
Total time spent in the disk queue. <br>
util Disk utilization.</p>

<p style="margin-top: 1em">It is also possible to get fio
to dump the current output while it is running, without
terminating the job. To do that, send fio the USR1
signal.</p>

<p style="margin-top: 1em">TERSE OUTPUT <br>
If the --minimal / --append-terse options are given, the
results will be printed/appended in a semicolon-delimited
format suitable for scripted use. A job description (if
pro&acirc; <br>
vided) follows on a new line. Note that the first number in
the line is the version number. If the output has to be
changed for some reason, this number will be incremented by
1 <br>
to signify that change. The fields are:</p>

<p style="margin-top: 1em">terse version, fio version,
jobname, groupid, error</p>

<p style="margin-top: 1em">Read status: <br>
Total I/O (KB), bandwidth (KB/s), IOPS, runtime (ms)</p>

<p style="margin-top: 1em">Submission latency: <br>
min, max, mean, standard deviation <br>
Completion latency: <br>
min, max, mean, standard deviation <br>
Completion latency percentiles (20 fields): <br>
Xth percentile=usec <br>
Total latency: <br>
min, max, mean, standard deviation <br>
Bandwidth: <br>
min, max, aggregate percentage of total, mean, standard
deviation</p>

<p style="margin-top: 1em">Write status: <br>
Total I/O (KB), bandwidth (KB/s), IOPS, runtime (ms)</p>

<p style="margin-top: 1em">Submission latency: <br>
min, max, mean, standard deviation <br>
Completion latency: <br>
min, max, mean, standard deviation <br>
Completion latency percentiles (20 fields): <br>
Xth percentile=usec <br>
Total latency: <br>
min, max, mean, standard deviation <br>
Bandwidth: <br>
min, max, aggregate percentage of total, mean, standard
deviation</p>

<p style="margin-top: 1em">CPU usage: <br>
user, system, context switches, major page faults, minor
page faults</p>

<p style="margin-top: 1em">IO depth distribution: <br>
&lt;=1, 2, 4, 8, 16, 32, &gt;=64</p>

<p style="margin-top: 1em">IO latency distribution: <br>
Microseconds: <br>
&lt;=2, 4, 10, 20, 50, 100, 250, 500, 750, 1000 <br>
Milliseconds: <br>
&lt;=2, 4, 10, 20, 50, 100, 250, 500, 750, 1000, 2000,
&gt;=2000</p>

<p style="margin-top: 1em">Disk utilization (1 for each
disk used): <br>
name, read ios, write ios, read merges, write merges, read
ticks, write ticks, read in-queue time, write in-queue time,
disk utilization percentage</p>

<p style="margin-top: 1em">Error Info (dependent on
continue_on_error, default off): <br>
total # errors, first error code</p>

<p style="margin-top: 1em">text description (if provided in
config - appears on newline)</p>

<p style="margin-top: 1em">TRACE FILE FORMAT <br>
There are two trace file format that you can encounter. The
older (v1) format is unsupported since version 1.20-rc3
(March 2008). It will still be described below in case that
<br>
you get an old trace and want to understand it.</p>

<p style="margin-top: 1em">In any case the trace is a
simple text file with a single action per line.</p>

<p style="margin-top: 1em">Trace file format v1 <br>
Each line represents a single io action in the following
format:</p>

<p style="margin-top: 1em">rw, offset, length</p>

<p style="margin-top: 1em">where rw=0/1 for read/write, and
the offset and length entries being in bytes.</p>

<p style="margin-top: 1em">This format is not supported in
Fio versions =&gt; 1.20-rc3.</p>

<p style="margin-top: 1em">Trace file format v2 <br>
The second version of the trace file format was added in Fio
version 1.17. It allows one to access more then one file per
trace and has a bigger set of possible file <br>
actions.</p>

<p style="margin-top: 1em">The first line of the trace file
has to be:</p>

<p style="margin-top: 1em">fio version 2 iolog</p>

<p style="margin-top: 1em">Following this can be lines in
two different formats, which are described below. The file
management format:</p>

<p style="margin-top: 1em">filename action</p>

<p style="margin-top: 1em">The filename is given as an
absolute path. The action can be one of these:</p>

<p style="margin-top: 1em">add Add the given filename to
the trace <br>
open Open the file with the given filename. The filename has
to have been previously added with the add action. <br>
close Close the file with the given filename. The file must
have previously been opened.</p>

<p style="margin-top: 1em">The file io action format:</p>

<p style="margin-top: 1em">filename action offset
length</p>

<p style="margin-top: 1em">The filename is given as an
absolute path, and has to have been added and opened before
it can be used with this format. The offset and length are
given in bytes. The <br>
action can be one of these:</p>

<p style="margin-top: 1em">wait Wait for
&rsquo;offset&rsquo; microseconds. Everything below 100 is
discarded. The time is relative to the previous wait
statement. <br>
read Read length bytes beginning from offset <br>
write Write length bytes beginning from offset <br>
sync fsync() the file <br>
datasync <br>
fdatasync() the file <br>
trim trim the given file from the given offset for length
bytes</p>

<p style="margin-top: 1em">CPU IDLENESS PROFILING <br>
In some cases, we want to understand CPU overhead in a test.
For example, we test patches for the specific goodness of
whether they reduce CPU usage. fio implements a balloon <br>
approach to create a thread per CPU that runs at idle
priority, meaning that it only runs when nobody else needs
the cpu. By measuring the amount of work completed by the
<br>
thread, idleness of each CPU can be derived accordingly.</p>

<p style="margin-top: 1em">An unit work is defined as
touching a full page of unsigned characters. Mean and
standard deviation of time to complete an unit work is
reported in &quot;unit work&quot; section. Options <br>
can be chosen to report detailed percpu idleness or overall
system idleness by aggregating percpu stats.</p>

<p style="margin-top: 1em">VERIFICATION AND TRIGGERS <br>
Fio is usually run in one of two ways, when data
verification is done. The first is a normal write job of
some sort with verify enabled. When the write phase has
completed, fio <br>
switches to reads and verifies everything it wrote. The
second model is running just the write phase, and then later
on running the same job (but with reads instead of writes)
to <br>
repeat the same IO patterns and verify the contents. Both of
these methods depend on the write phase being completed, as
fio otherwise has no idea how much data was written.</p>

<p style="margin-top: 1em">With verification triggers, fio
supports dumping the current write state to local files.
Then a subsequent read verify workload can load this state
and know exactly where to <br>
stop. This is useful for testing cases where power is cut to
a server in a managed fashion, for instance.</p>

<p style="margin-top: 1em">A verification trigger consists
of two things:</p>

<p style="margin-top: 1em">Storing the write state of each
job</p>

<p style="margin-top: 1em">Executing a trigger command</p>

<p style="margin-top: 1em">The write state is relatively
small, on the order of hundreds of bytes to single
kilobytes. It contains information on the number of
completions done, the last X completions, <br>
etc.</p>

<p style="margin-top: 1em">A trigger is invoked either
through creation (touch) of a specified file in the system,
or through a timeout setting. If fio is run with
--trigger-file=/tmp/trigger-file, then it <br>
will continually check for the existence of
/tmp/trigger-file. When it sees this file, it will fire off
the trigger (thus saving state, and executing the trigger
command).</p>

<p style="margin-top: 1em">For client/server runs,
there&rsquo;s both a local and remote trigger. If fio is
running as a server backend, it will send the job states
back to the client for safe storage, then exe&acirc; <br>
cute the remote trigger, if specified. If a local trigger is
specified, the server will still send back the write state,
but the client will then execute the trigger.</p>

<p style="margin-top: 1em">Verification trigger example</p>

<p style="margin-top: 1em">Lets say we want to run a
powercut test on the remote machine &rsquo;server&rsquo;.
Our write workload is in write-test.fio. We want to cut
power to &rsquo;server&rsquo; at some point during the <br>
run, and we&rsquo;ll run this test from the safety or our
local machine, &rsquo;localbox&rsquo;. On the server,
we&rsquo;ll start the fio backend normally:</p>

<p style="margin-top: 1em">server# fio --server</p>

<p style="margin-top: 1em">and on the client, we&rsquo;ll
fire off the workload:</p>

<p style="margin-top: 1em">localbox$ fio --client=server
--trigger-file=/tmp/my-trigger --trigger-remote=&quot;bash
-c &quot;echo b &gt; /proc/sysrq-triger&quot;&quot;</p>

<p style="margin-top: 1em">We set /tmp/my-trigger as the
trigger file, and we tell fio to execute</p>

<p style="margin-top: 1em">echo b &gt;
/proc/sysrq-trigger</p>

<p style="margin-top: 1em">on the server once it has
received the trigger and sent us the write state. This will
work, but it&rsquo;s not really cutting power to the server,
it&rsquo;s merely abruptly rebooting <br>
it. If we have a remote way of cutting power to the server
through IPMI or similar, we could do that through a local
trigger command instead. Lets assume we have a script <br>
that does IPMI reboot of a given hostname, ipmi-reboot. On
localbox, we could then have run fio with a local trigger
instead:</p>

<p style="margin-top: 1em">localbox$ fio --client=server
--trigger-file=/tmp/my-trigger --trigger=&quot;ipmi-reboot
server&quot;</p>

<p style="margin-top: 1em">For this case, fio would wait
for the server to send us the write state, then execute
&rsquo;ipmi-reboot server&rsquo; when that happened.</p>

<p style="margin-top: 1em">Loading verify state <br>
To load store write state, read verification job file must
contain the verify_state_load option. If that is set, fio
will load the previously stored state. For a local fio <br>
run this is done by loading the files directly, and on a
client/server run, the server backend will ask the client to
send the files over and load them from there.</p>

<p style="margin-top: 1em">LOG FILE FORMATS <br>
Fio supports a variety of log file formats, for logging
latencies, bandwidth, and IOPS. The logs share a common
format, which looks like this:</p>

<p style="margin-top: 1em">time (msec), value, data
direction, offset</p>

<p style="margin-top: 1em">Time for the log entry is always
in milliseconds. The value logged depends on the type of
log, it will be one of the following:</p>

<p style="margin-top: 1em">Latency log <br>
Value is in latency in usecs <br>
Bandwidth log <br>
Value is in KB/sec <br>
IOPS log <br>
Value is in IOPS</p>

<p style="margin-top: 1em">Data direction is one of the
following:</p>

<p style="margin-top: 1em">0 IO is a READ <br>
1 IO is a WRITE <br>
2 IO is a TRIM</p>

<p style="margin-top: 1em">The offset is the offset, in
bytes, from the start of the file, for that particular IO.
The logging of the offset can be toggled with
log_offset.</p>

<p style="margin-top: 1em">If windowed logging is enabled
through log_avg_msec, then fio doesn&rsquo;t log individual
IOs. Instead of logs the average values over the specified
period of time. Since data direc&acirc; <br>
tion and offset are per-IO values, they aren&rsquo;t
applicable if windowed logging is enabled. If windowed
logging is enabled and log_max_value is set, then fio logs
maximum values in <br>
that window instead of averages.</p>

<p style="margin-top: 1em">For histogram logging the logs
look like this:</p>

<p style="margin-top: 1em">time (msec), data direction,
block-size, bin 0, bin 1, ..., bin 1215</p>

<p style="margin-top: 1em">Where &rsquo;bin i&rsquo; gives
the frequency of IO requests with a latency falling in the
i-th bin. See log_hist_coarseness for logging fewer
bins.</p>

<p style="margin-top: 1em">CLIENT / SERVER <br>
Normally you would run fio as a stand-alone application on
the machine where the IO workload should be generated.
However, it is also possible to run the frontend and backend
of <br>
fio separately. This makes it possible to have a fio server
running on the machine(s) where the IO workload should be
running, while controlling it from another machine.</p>

<p style="margin-top: 1em">To start the server, you would
do:</p>

<p style="margin-top: 1em">fio --server=args</p>

<p style="margin-top: 1em">on that machine, where args
defines what fio listens to. The arguments are of the form
&rsquo;type:hostname or IP:port&rsquo;. &rsquo;type&rsquo;
is either &rsquo;ip&rsquo; (or ip4) for TCP/IP v4,
&rsquo;ip6&rsquo; for TCP/IP <br>
v6, or &rsquo;sock&rsquo; for a local unix domain socket.
&rsquo;hostname&rsquo; is either a hostname or IP address,
and &rsquo;port&rsquo; is the port to listen to (only valid
for TCP/IP, not a local socket). Some <br>
examples:</p>

<p style="margin-top: 1em">1) fio --server</p>

<p style="margin-top: 1em">Start a fio server, listening on
all interfaces on the default port (8765).</p>

<p style="margin-top: 1em">2) fio
--server=ip:hostname,4444</p>

<p style="margin-top: 1em">Start a fio server, listening on
IP belonging to hostname and on port 4444.</p>

<p style="margin-top: 1em">3) fio --server=ip6:::1,4444</p>

<p style="margin-top: 1em">Start a fio server, listening on
IPv6 localhost ::1 and on port 4444.</p>

<p style="margin-top: 1em">4) fio --server=,4444</p>

<p style="margin-top: 1em">Start a fio server, listening on
all interfaces on port 4444.</p>

<p style="margin-top: 1em">5) fio --server=1.2.3.4</p>

<p style="margin-top: 1em">Start a fio server, listening on
IP 1.2.3.4 on the default port.</p>

<p style="margin-top: 1em">6) fio
--server=sock:/tmp/fio.sock</p>

<p style="margin-top: 1em">Start a fio server, listening on
the local socket /tmp/fio.sock.</p>

<p style="margin-top: 1em">When a server is running, you
can connect to it from a client. The client is run with:</p>

<p style="margin-top: 1em">fio --local-args --client=server
--remote-args &lt;job file(s)&gt;</p>

<p style="margin-top: 1em">where --local-args are arguments
that are local to the client where it is running,
&rsquo;server&rsquo; is the connect string, and
--remote-args and &lt;job file(s)&gt; are sent to the
server. The <br>
&rsquo;server&rsquo; string follows the same format as it
does on the server side, to allow IP/hostname/socket and
port strings. You can connect to multiple clients as well,
to do that you <br>
could run:</p>

<p style="margin-top: 1em">fio --client=server2
--client=server2 &lt;job file(s)&gt;</p>

<p style="margin-top: 1em">If the job file is located on
the fio server, then you can tell the server to load a local
file as well. This is done by using --remote-config:</p>

<p style="margin-top: 1em">fio --client=server
--remote-config /path/to/file.fio</p>

<p style="margin-top: 1em">Then fio will open this local
(to the server) job file instead of being passed one from
the client.</p>

<p style="margin-top: 1em">If you have many servers
(example: 100 VMs/containers), you can input a pathname of a
file containing host IPs/names as the parameter value for
the --client option. For example, <br>
here is an example &quot;host.list&quot; file containing 2
hostnames:</p>

<p style="margin-top: 1em">host1.your.dns.domain <br>
host2.your.dns.domain</p>

<p style="margin-top: 1em">The fio command would then
be:</p>

<p style="margin-top: 1em">fio --client=host.list &lt;job
file&gt;</p>

<p style="margin-top: 1em">In this mode, you cannot input
server-specific parameters or job files, and all servers
receive the same job file.</p>

<p style="margin-top: 1em">In order to enable fio --client
runs utilizing a shared filesystem from multiple hosts, fio
--client now prepends the IP address of the server to the
filename. For example, if <br>
fio is using directory /mnt/nfs/fio and is writing filename
fileio.tmp, with a --client hostfile containing two
hostnames h1 and h2 with IP addresses 192.168.10.120 and
<br>
192.168.10.121, then fio will create two files:</p>


<p style="margin-top: 1em">/mnt/nfs/fio/192.168.10.120.fileio.tmp
<br>
/mnt/nfs/fio/192.168.10.121.fileio.tmp</p>

<p style="margin-top: 1em">AUTHORS <br>
fio was written by Jens Axboe &lt;jens.axboe@oracle.com&gt;,
now Jens Axboe &lt;axboe@fb.com&gt;. <br>
This man page was written by Aaron Carroll
&lt;aaronc@cse.unsw.edu.au&gt; based on documentation by
Jens Axboe.</p>

<p style="margin-top: 1em">REPORTING BUGS <br>
Report bugs to the fio mailing list
&lt;fio@vger.kernel.org&gt;. See README.</p>

<p style="margin-top: 1em">SEE ALSO <br>
For further documentation see HOWTO and README. <br>
Sample jobfiles are available in the examples directory.</p>

<p style="margin-top: 1em">User Manual December 2014
fio(1)</p>
<hr>
</body>
</html>
