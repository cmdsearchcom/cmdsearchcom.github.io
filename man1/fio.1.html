<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>fio(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">fio(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">fio(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
fio - flexible I/O tester
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>fio</b> [ <i>options</i>] [<i>jobfile</i>]...
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>fio</b> is a tool that will spawn a number of threads or processes doing a
  particular type of I/O action as specified by the user. The typical use of fio
  is to write a job file matching the I/O load one wants to simulate.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--debug</b><i>=type</i></dt>
  <dd class="It-tag">Enable verbose tracing of various fio actions. May be `all'
      for all types or individual types separated by a comma (eg
      --debug=io,file). `help' will list all available tracing options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--output</b><i>=filename</i></dt>
  <dd class="It-tag">Write output to <i>filename</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--output-format</b><i>=format</i></dt>
  <dd class="It-tag">Set the reporting format to <i>normal</i>, <i>terse</i>,
      <i>json</i>, or <i>json+</i>. Multiple formats can be selected, separate
      by a comma. <i>terse</i> is a CSV based format. <i>json+</i> is like
      <i>json</i>, except it adds a full dump of the latency buckets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--runtime</b><i>=runtime</i></dt>
  <dd class="It-tag">Limit run time to <i>runtime</i> seconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bandwidth-log</b></dt>
  <dd class="It-tag">Generate aggregate bandwidth logs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--minimal</b></dt>
  <dd class="It-tag">Print statistics in a terse, semicolon-delimited
    format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--append-terse</b></dt>
  <dd class="It-tag">Print statistics in selected mode AND terse,
      semicolon-delimited format. Deprecated, use --output-format instead to
      select multiple formats.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--version</b></dt>
  <dd class="It-tag">Display version information and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--terse-version</b><i>=version</i></dt>
  <dd class="It-tag">Set terse version output format (Current version 3, or
      older version 2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help</b></dt>
  <dd class="It-tag">Display usage information and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cpuclock-test</b></dt>
  <dd class="It-tag">Perform test and validation of internal CPU clock</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--crctest[=test]</b></dt>
  <dd class="It-tag">Test the speed of the builtin checksumming functions. If no
      argument is given, all of them are tested. Or a comma separated list can
      be passed, in which case the given ones are tested.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cmdhelp</b><i>=command</i></dt>
  <dd class="It-tag">Print help information for <i>command</i>. May be `all' for
      all commands.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--enghelp</b><i>=ioengine[,command]</i></dt>
  <dd class="It-tag">List all commands defined by <i>ioengine</i>, or print help
      for <i>command</i> defined by <i>ioengine</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--showcmd</b><i>=jobfile</i></dt>
  <dd class="It-tag">Convert <i>jobfile</i> to a set of command-line
    options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--eta</b><i>=when</i></dt>
  <dd class="It-tag">Specifies when real-time ETA estimate should be printed.
      <i>when</i> may be one of `always', `never' or `auto'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--eta-newline</b><i>=time</i></dt>
  <dd class="It-tag">Force an ETA newline for every `time` period passed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--status-interval</b><i>=time</i></dt>
  <dd class="It-tag">Report full output status every `time` period passed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--readonly</b></dt>
  <dd class="It-tag">Turn on safety read-only checks, preventing any attempted
      write.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--section</b><i>=sec</i></dt>
  <dd class="It-tag">Only run section <i>sec</i> from job file. This option can
      be used multiple times to add more sections to run.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--alloc-size</b><i>=kb</i></dt>
  <dd class="It-tag">Set the internal smalloc pool size to <i>kb</i>
    kilobytes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--warnings-fatal</b></dt>
  <dd class="It-tag">All fio parser warnings are fatal, causing fio to exit with
      an error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--max-jobs</b><i>=nr</i></dt>
  <dd class="It-tag">Set the maximum allowed number of jobs (threads/processes)
      to support.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--server</b><i>=args</i></dt>
  <dd class="It-tag">Start a backend server, with <i>args</i> specifying what to
      listen to. See client/server section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--daemonize</b><i>=pidfile</i></dt>
  <dd class="It-tag">Background a fio server, writing the pid to the given pid
      file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--client</b><i>=host</i></dt>
  <dd class="It-tag">Instead of running the jobs locally, send and run them on
      the given host or set of hosts. See client/server section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--idle-prof</b><i>=option</i></dt>
  <dd class="It-tag">Report cpu idleness on a system or percpu basis
      (<i>option</i>=system,percpu) or run unit work calibration only (
      <i>option</i>=calibrate).</dd>
</dl>
<h1 class="Sh" title="Sh" id="JOB_FILE_FORMAT"><a class="selflink" href="#JOB_FILE_FORMAT">JOB
  FILE FORMAT</a></h1>
Job files are in `ini' format. They consist of one or more job definitions,
  which begin with a job name in square brackets and extend to the next job
  name. The job name can be any ASCII string except `global', which has a
  special meaning. Following the job name is a sequence of zero or more
  parameters, one per line, that define the behavior of the job. Any line
  starting with a `;' or `#' character is considered a comment and ignored.
<div class="Pp"></div>
If <i>jobfile</i> is specified as `-', the job file will be read from standard
  input.
<h2 class="Ss" title="Ss" id="Global_Section"><a class="selflink" href="#Global_Section">Global
  Section</a></h2>
The global section contains default parameters for jobs specified in the job
  file. A job is only affected by global sections residing above it, and there
  may be any number of global sections. Specific job definitions may override
  any parameter set in global sections.
<h1 class="Sh" title="Sh" id="JOB_PARAMETERS"><a class="selflink" href="#JOB_PARAMETERS">JOB
  PARAMETERS</a></h1>
<h2 class="Ss" title="Ss" id="Types"><a class="selflink" href="#Types">Types</a></h2>
Some parameters may take arguments of a specific type. Anywhere a numeric value
  is required, an arithmetic expression may be used, provided it is surrounded
  by parentheses. Supported operators are:
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>addition (+)</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>subtraction (-)</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>multiplication (*)</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>division (/)</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>modulus (%)</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exponentiation (^)</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
</div>
<div class="Pp"></div>
For time values in expressions, units are microseconds by default. This is
  different than for time values not in expressions (not enclosed in
  parentheses). The types used are:
<dl class="Bl-tag">
  <dt class="It-tag"><i>str</i></dt>
  <dd class="It-tag">String: a sequence of alphanumeric characters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>int</i></dt>
  <dd class="It-tag">SI integer: a whole number, possibly containing a suffix
      denoting the base unit of the value. Accepted suffixes are `k', 'M', 'G',
      'T', and 'P', denoting kilo (1024), mega (1024^2), giga (1024^3), tera
      (1024^4), and peta (1024^5) respectively. If prefixed with '0x', the value
      is assumed to be base 16 (hexadecimal). A suffix may include a trailing
      'b', for instance 'kb' is identical to 'k'. You can specify a base 10
      value by using 'KiB', 'MiB','GiB', etc. This is useful for disk drives
      where values are often given in base 10 values. Specifying '30GiB' will
      get you 30*1000^3 bytes. When specifying times the default suffix meaning
      changes, still denoting the base unit of the value, but accepted suffixes
      are 'D' (days), 'H' (hours), 'M' (minutes), 'S' Seconds, 'ms' (or msec)
      milli seconds, 'us' (or 'usec') micro seconds. Time values without a unit
      specify seconds. The suffixes are not case sensitive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>bool</i></dt>
  <dd class="It-tag">Boolean: a true or false value. `0' denotes false, `1'
      denotes true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>irange</i></dt>
  <dd class="It-tag">Integer range: a range of integers specified in the format
      <i>lower</i>:<i>upper</i> or <i>lower</i>-<i>upper</i>. <i>lower</i> and
      <i>upper</i> may contain a suffix as described above. If an option allows
      two sets of ranges, they are separated with a `,' or `/' character. For
      example: `8-8k/8M-4G'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>float_list</i></dt>
  <dd class="It-tag">List of floating numbers: A list of floating numbers,
      separated by a ':' character.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Parameter_List"><a class="selflink" href="#Parameter_List">Parameter
  List</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>name</b><i>=str</i></dt>
  <dd class="It-tag">May be used to override the job name. On the command line,
      this parameter has the special purpose of signalling the start of a new
      job.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>wait_for</b><i>=str</i></dt>
  <dd class="It-tag">Specifies the name of the already defined job to wait for.
      Single waitee name only may be specified. If set, the job won't be started
      until all workers of the waitee job are done. Wait_for operates on the job
      name basis, so there are a few limitations. First, the waitee must be
      defined prior to the waiter job (meaning no forward references). Second,
      if a job is being referenced as a waitee, it must have a unique name (no
      duplicate waitees).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>description</b><i>=str</i></dt>
  <dd class="It-tag">Human-readable description of the job. It is printed when
      the job is run, but otherwise has no special purpose.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>directory</b><i>=str</i></dt>
  <dd class="It-tag">Prefix filenames with this directory. Used to place files
      in a location other than `./'. You can specify a number of directories by
      separating the names with a ':' character. These directories will be
      assigned equally distributed to job clones creates with <i>numjobs</i> as
      long as they are using generated filenames. If specific <i>filename(s)</i>
      are set fio will use the first listed directory, and thereby matching the
      <i>filename</i> semantic which generates a file each clone if not
      specified, but let all clones use the same if set. See <i>filename</i> for
      considerations regarding escaping certain characters on some
    platforms.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>filename</b><i>=str</i></dt>
  <dd class="It-tag"><b>fio</b> normally makes up a file name based on the job
      name, thread number, and file number. If you want to share files between
      threads in a job or several jobs, specify a <i>filename</i> for each of
      them to override the default. If the I/O engine is file-based, you can
      specify a number of files by separating the names with a `:' character.
      `-' is a reserved name, meaning stdin or stdout, depending on the
      read/write direction set. On Windows, disk devices are accessed as
      \.PhysicalDrive0 for the first device, \.PhysicalDrive1 for the second
      etc. Note: Windows and FreeBSD prevent write access to areas of the disk
      containing in-use data (e.g. filesystems). If the wanted filename does
      need to include a colon, then escape that with a '\' character. For
      instance, if the filename is &quot;/dev/dsk/foo@3,0:c&quot;, then you
      would use filename=&quot;/dev/dsk/foo@3,0\:c&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>filename_format</b><i>=str</i></dt>
  <dd class="It-tag">If sharing multiple files between jobs, it is usually
      necessary to have fio generate the exact names that you want. By default,
      fio will name a file based on the default file format specification of
      <b>jobname.jobnumber.filenumber</b>. With this option, that can be
      customized. Fio will recognize and replace the following keywords in this
      string:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>$jobname</b></dt>
  <dd class="It-tag">The name of the worker thread or process.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$jobnum</b></dt>
  <dd class="It-tag">The incremental number of the worker thread or
    process.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>$filenum</b></dt>
  <dd class="It-tag">The incremental number of the file for that worker thread
      or process.</dd>
</dl>
</div>
<div class="Pp"></div>
To have dependent jobs share a set of files, this option can be set to have fio
  generate filenames that are shared between the two. For instance, if
  <b>testfiles.$filenum</b> is specified, file number 4 for any job will be
  named <b>testfiles.4</b>. The default of <b>$jobname.$jobnum.$filenum</b> will
  be used if no other format specifier is given.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unique_filename</b><i>=bool</i></dt>
  <dd class="It-tag">To avoid collisions between networked clients, fio defaults
      to prefixing any generated filenames (with a directory specified) with the
      source of the client connecting. To disable this behavior, set this option
      to 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>lockfile</b><i>=str</i></dt>
  <dd class="It-tag">Fio defaults to not locking any files before it does IO to
      them. If a file or file descriptor is shared, fio can serialize IO to that
      file to make the end result consistent. This is usual for emulating real
      workloads that share files. The lock modes are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>none</b></dt>
  <dd class="It-tag">No locking. This is the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exclusive</b></dt>
  <dd class="It-tag">Only one thread or process may do IO at a time, excluding
      all others.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>readwrite</b></dt>
  <dd class="It-tag">Read-write locking on the file. Many readers may access the
      file at the same time, but writes get exclusive access.</dd>
</dl>
</div>
</div>
<div class="Pp"></div>
<b>opendir</b><i>=str</i> Recursively open any files below directory <i>str</i>.
<dl class="Bl-tag">
  <dt class="It-tag"><b>readwrite</b><i>=str</i><b>, rw</b><i>=str</i></dt>
  <dd class="It-tag">Type of I/O pattern. Accepted values are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>read</b></dt>
  <dd class="It-tag">Sequential reads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write</b></dt>
  <dd class="It-tag">Sequential writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>trim</b></dt>
  <dd class="It-tag">Sequential trim (Linux block devices only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>randread</b></dt>
  <dd class="It-tag">Random reads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>randwrite</b></dt>
  <dd class="It-tag">Random writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>randtrim</b></dt>
  <dd class="It-tag">Random trim (Linux block devices only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rw, readwrite</b></dt>
  <dd class="It-tag">Mixed sequential reads and writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>randrw</b></dt>
  <dd class="It-tag">Mixed random reads and writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>trimwrite</b></dt>
  <dd class="It-tag">Trim and write mixed workload. Blocks will be trimmed
      first, then the same blocks will be written to.</dd>
</dl>
</div>
<div class="Pp"></div>
Fio defaults to read if the option is not specified. For mixed I/O, the default
  split is 50/50. For certain types of io the result may still be skewed a bit,
  since the speed may be different. It is possible to specify a number of IO's
  to do before getting a new offset, this is done by appending a `:
  <i>&lt;nr&gt;</i> to the end of the string given. For a random read, it would
  look like <b>rw=randread:8</b> for passing in an offset modifier with a value
  of 8. If the postfix is used with a sequential IO pattern, then the value
  specified will be added to the generated offset for each IO. For instance,
  using <b>rw=write:4k</b> will skip 4k for every write. It turns sequential IO
  into sequential IO with holes. See the <b>rw_sequencer</b> option.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rw_sequencer</b><i>=str</i></dt>
  <dd class="It-tag">If an offset modifier is given by appending a number to the
      <b>rw=&lt;str&gt;</b> line, then this option controls how that number
      modifies the IO offset being generated. Accepted values are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>sequential</b></dt>
  <dd class="It-tag">Generate sequential offset</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>identical</b></dt>
  <dd class="It-tag">Generate the same offset</dd>
</dl>
</div>
<div class="Pp"></div>
<b>sequential</b> is only useful for random IO, where fio would normally
  generate a new random offset for every IO. If you append eg 8 to randread, you
  would get a new random offset for every 8 IO's. The result would be a seek for
  only every 8 IO's, instead of for every IO. Use <b>rw=randread:8</b> to
  specify that. As sequential IO is already sequential, setting
  <b>sequential</b> for that would not result in any differences.
  <b>identical</b> behaves in a similar fashion, except it sends the same offset
  8 number of times before generating a new offset.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>kb_base</b><i>=int</i></dt>
  <dd class="It-tag">The base unit for a kilobyte. The defacto base is 2^10,
      1024. Storage manufacturers like to use 10^3 or 1000 as a base ten unit
      instead, for obvious reasons. Allowed values are 1024 or 1000, with 1024
      being the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unified_rw_reporting</b><i>=bool</i></dt>
  <dd class="It-tag">Fio normally reports statistics on a per data direction
      basis, meaning that read, write, and trim are accounted and reported
      separately. If this option is set fio sums the results and reports them as
      &quot;mixed&quot; instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>randrepeat</b><i>=bool</i></dt>
  <dd class="It-tag">Seed the random number generator used for random I/O
      patterns in a predictable way so the pattern is repeatable across runs.
      Default: true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>allrandrepeat</b><i>=bool</i></dt>
  <dd class="It-tag">Seed all random number generators in a predictable way so
      results are repeatable across runs. Default: false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>randseed</b><i>=int</i></dt>
  <dd class="It-tag">Seed the random number generators based on this seed value,
      to be able to control what sequence of output is being generated. If not
      set, the random sequence depends on the <b>randrepeat</b> setting.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fallocate</b><i>=str</i></dt>
  <dd class="It-tag">Whether pre-allocation is performed when laying down files.
      Accepted values are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>none</b></dt>
  <dd class="It-tag">Do not pre-allocate space.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>posix</b></dt>
  <dd class="It-tag">Pre-allocate via <b>posix_fallocate</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>keep</b></dt>
  <dd class="It-tag">Pre-allocate via <b>fallocate</b>(2) with
      FALLOC_FL_KEEP_SIZE set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>0</b></dt>
  <dd class="It-tag">Backward-compatible alias for 'none'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>1</b></dt>
  <dd class="It-tag">Backward-compatible alias for 'posix'.</dd>
</dl>
</div>
<div class="Pp"></div>
May not be available on all supported platforms. 'keep' is only available on
  Linux. If using ZFS on Solaris this must be set to 'none' because ZFS doesn't
  support it. Default: 'posix'.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fadvise_hint</b><i>=str</i></dt>
  <dd class="It-tag">Use <b>posix_fadvise</b>(2) to advise the kernel what I/O
      patterns are likely to be issued. Accepted values are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>0</b></dt>
  <dd class="It-tag">Backwards compatible hint for &quot;no hint&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>1</b></dt>
  <dd class="It-tag">Backwards compatible hint for &quot;advise with fio
      workload type&quot;. This uses <b>FADV_RANDOM</b> for a random workload,
      and <b>FADV_SEQUENTIAL</b> for a sequential workload.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sequential</b></dt>
  <dd class="It-tag">Advise using <b>FADV_SEQUENTIAL</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>random</b></dt>
  <dd class="It-tag">Advise using <b>FADV_RANDOM</b></dd>
</dl>
</div>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fadvise_stream</b><i>=int</i></dt>
  <dd class="It-tag">Use <b>posix_fadvise</b>(2) to advise the kernel what
      stream ID the writes issued belong to. Only supported on Linux. Note, this
      option may change going forward.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>size</b><i>=int</i></dt>
  <dd class="It-tag">Total size of I/O for this job. <b>fio</b> will run until
      this many bytes have been transferred, unless limited by other options (
      <b>runtime</b>, for instance, or increased/descreased by <b>io_size</b>).
      Unless <b>nrfiles</b> and <b>filesize</b> options are given, this amount
      will be divided between the available files for the job. If not set, fio
      will use the full size of the given files or devices. If the files do not
      exist, size must be given. It is also possible to give size as a
      percentage between 1 and 100. If size=20% is given, fio will use 20% of
      the full size of the given files or devices.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>io_size</b><i>=int</i><b>,<b> io_limit
    </b>=<b>int</b></b></dt>
  <dd class="It-tag">Normally fio operates within the region set by <b>size</b>,
      which means that the <b>size</b> option sets both the region and size of
      IO to be performed. Sometimes that is not what you want. With this option,
      it is possible to define just the amount of IO that fio should do. For
      instance, if <b>size</b> is set to 20G and <b>io_limit</b> is set to 5G,
      fio will perform IO within the first 20G but exit when 5G have been done.
      The opposite is also possible - if <b>size</b> is set to 20G, and
      <b>io_size</b> is set to 40G, then fio will do 40G of IO within the 0..20G
      region.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fill_device</b><i>=bool</i><b>,<b>
    fill_fs</b></b><i><b></b>= <b>bool</b></i></dt>
  <dd class="It-tag">Sets size to something really large and waits for ENOSPC
      (no space left on device) as the terminating condition. Only makes sense
      with sequential write. For a read workload, the mount point will be filled
      first then IO started on the result. This option doesn't make sense if
      operating on a raw device node, since the size of that is already known by
      the file system. Additionally, writing beyond end-of-device will not
      return ENOSPC there.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>filesize</b><i>=irange</i></dt>
  <dd class="It-tag">Individual file sizes. May be a range, in which case
      <b>fio</b> will select sizes for files at random within the given range,
      limited to <b>size</b> in total (if that is given). If <b>filesize</b> is
      not specified, each created file is the same size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>file_append</b><i>=bool</i></dt>
  <dd class="It-tag">Perform IO after the end of the file. Normally fio will
      operate within the size of a file. If this option is set, then fio will
      append to the file instead. This has identical behavior to setting offset
      to the size of a file. This option is ignored on non-regular files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>blocksize</b><i>=int[,int]</i><b>,<b>
    bs</b></b><i><b></b>= <b>int[,int]</b></i></dt>
  <dd class="It-tag">Block size for I/O units. Default: 4k. Values for reads,
      writes, and trims can be specified separately in the format
      <i>read</i>,<i>write</i>,<i>trim</i> either of which may be empty to leave
      that value at its default. If a trailing comma isn't given, the remainder
      will inherit the last value set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>blocksize_range</b><i>=irange[,irange]</i><b>,<b>
    bsrange</b></b><i><b></b>=<b>irange[,irange]</b></i></dt>
  <dd class="It-tag">Specify a range of I/O block sizes. The issued I/O unit
      will always be a multiple of the minimum size, unless
      <b>blocksize_unaligned</b> is set. Applies to both reads and writes if
      only one range is given, but can be specified separately with a comma
      separating the values. Example: bsrange=1k-4k,2k-8k. Also (see
      <b>blocksize</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bssplit</b><i>=str</i></dt>
  <dd class="It-tag">This option allows even finer grained control of the block
      sizes issued, not just even splits between them. With this option, you can
      weight various block sizes for exact control of the issued IO for a job
      that has mixed block sizes. The format of the option is
      bssplit=blocksize/percentage, optionally adding as many definitions as
      needed separated by a colon. Example: bssplit=4k/10:64k/50:32k/40 would
      issue 50% 64k blocks, 10% 4k blocks and 40% 32k blocks. <b>bssplit</b>
      also supports giving separate splits to reads and writes. The format is
      identical to what the <b>bs</b> option accepts, the read and write parts
      are separated with a comma.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>blocksize_unaligned, bs_unaligned</b></dt>
  <dd class="It-tag">If set, any size in <b>blocksize_range</b> may be used.
      This typically won't work with direct I/O, as that normally requires
      sector alignment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>blockalign</b><i>=int[,int]</i><b>,<b>
    ba</b></b><i><b></b>= <b>int[,int]</b></i></dt>
  <dd class="It-tag">At what boundary to align random IO offsets. Defaults to
      the same as 'blocksize' the minimum blocksize given. Minimum alignment is
      typically 512b for using direct IO, though it usually depends on the
      hardware block size. This option is mutually exclusive with using a random
      map for files, so it will turn off that option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bs_is_seq_rand</b><i>=bool</i></dt>
  <dd class="It-tag">If this option is set, fio will use the normal read,write
      blocksize settings as sequential,random instead. Any random read or write
      will use the WRITE blocksize settings, and any sequential read or write
      will use the READ blocksize setting.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zero_buffers</b></dt>
  <dd class="It-tag">Initialize buffers with all zeros. Default: fill buffers
      with random data.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>refill_buffers</b></dt>
  <dd class="It-tag">If this option is given, fio will refill the IO buffers on
      every submit. The default is to only fill it at init time and reuse that
      data. Only makes sense if zero_buffers isn't specified, naturally. If data
      verification is enabled, refill_buffers is also automatically
    enabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>scramble_buffers</b><i>=bool</i></dt>
  <dd class="It-tag">If <b>refill_buffers</b> is too costly and the target is
      using data deduplication, then setting this option will slightly modify
      the IO buffer contents to defeat normal de-dupe attempts. This is not
      enough to defeat more clever block compression attempts, but it will stop
      naive dedupe of blocks. Default: true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>buffer_compress_percentage</b><i>=int</i></dt>
  <dd class="It-tag">If this is set, then fio will attempt to provide IO buffer
      content (on WRITEs) that compress to the specified level. Fio does this by
      providing a mix of random data and a fixed pattern. The fixed pattern is
      either zeroes, or the pattern specified by <b>buffer_pattern</b>. If the
      pattern option is used, it might skew the compression ratio slightly. Note
      that this is per block size unit, for file/disk wide compression level
      that matches this setting. Note that this is per block size unit, for
      file/disk wide compression level that matches this setting, you'll also
      want to set refill_buffers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>buffer_compress_chunk</b><i>=int</i></dt>
  <dd class="It-tag">See <b>buffer_compress_percentage</b>. This setting allows
      fio to manage how big the ranges of random data and zeroed data is.
      Without this set, fio will provide <b>buffer_compress_percentage</b> of
      blocksize random data, followed by the remaining zeroed. With this set to
      some chunk size smaller than the block size, fio can alternate random and
      zeroed data throughout the IO buffer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>buffer_pattern</b><i>=str</i></dt>
  <dd class="It-tag">If set, fio will fill the IO buffers with this pattern. If
      not set, the contents of IO buffers is defined by the other options
      related to buffer contents. The setting can be any pattern of bytes, and
      can be prefixed with 0x for hex values. It may also be a string, where the
      string must then be wrapped with &quot;&quot;, e.g.:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;"><b>buffer_pattern</b>=&quot;abcd&quot;
<div style="margin-left: 5.00ex;">or</div>
<b>buffer_pattern</b>=-12
<div style="margin-left: 5.00ex;">or</div>
<b>buffer_pattern</b>=0xdeadface</div>
<div class="Pp"></div>
Also you can combine everything together in any order:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;"><b>buffer_pattern</b>=0xdeadface&quot;abcd&quot;-12</div>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dedupe_percentage</b><i>=int</i></dt>
  <dd class="It-tag">If set, fio will generate this percentage of identical
      buffers when writing. These buffers will be naturally dedupable. The
      contents of the buffers depend on what other buffer compression settings
      have been set. It's possible to have the individual buffers either fully
      compressible, or not at all. This option only controls the distribution of
      unique buffers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nrfiles</b><i>=int</i></dt>
  <dd class="It-tag">Number of files to use for this job. Default: 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>openfiles</b><i>=int</i></dt>
  <dd class="It-tag">Number of files to keep open at the same time. Default:
      <b>nrfiles</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>file_service_type</b><i>=str</i></dt>
  <dd class="It-tag">Defines how files to service are selected. The following
      types are defined:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>random</b></dt>
  <dd class="It-tag">Choose a file at random.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>roundrobin</b></dt>
  <dd class="It-tag">Round robin over opened files (default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sequential</b></dt>
  <dd class="It-tag">Do each file in the set sequentially.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zipf</b></dt>
  <dd class="It-tag">Use a Zipfian distribution to decide what file to
    access.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pareto</b></dt>
  <dd class="It-tag">Use a Pareto distribution to decide what file to
    access.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gauss</b></dt>
  <dd class="It-tag">Use a Gaussian (normal) distribution to decide what file to
      access.</dd>
</dl>
</div>
<div class="Pp"></div>
For <b>random</b>, <b>roundrobin</b>, and <b>sequential</b>, a postfix can be
  appended to tell fio how many I/Os to issue before switching to a new file.
  For example, specifying <b>file_service_type=random:8</b> would cause fio to
  issue <i>8</i> I/Os before selecting a new file at random. For the non-uniform
  distributions, a floating point postfix can be given to influence how the
  distribution is skewed. See <b>random_distribution</b> for a description of
  how that would work.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ioengine</b><i>=str</i></dt>
  <dd class="It-tag">Defines how the job issues I/O. The following types are
      defined:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>sync</b></dt>
  <dd class="It-tag">Basic <b>read</b>(2) or <b>write</b>(2) I/O.
      <b>fseek</b>(2) is used to position the I/O location.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>psync</b></dt>
  <dd class="It-tag">Basic <b>pread</b>(2) or <b>pwrite</b>(2) I/O. Default on
      all supported operating systems except for Windows.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vsync</b></dt>
  <dd class="It-tag">Basic <b>readv</b>(2) or <b>writev</b>(2) I/O. Will emulate
      queuing by coalescing adjacent IOs into a single submission.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pvsync</b></dt>
  <dd class="It-tag">Basic <b>preadv</b>(2) or <b>pwritev</b>(2) I/O.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pvsync2</b></dt>
  <dd class="It-tag">Basic <b>preadv2</b>(2) or <b>pwritev2</b>(2) I/O.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>libaio</b></dt>
  <dd class="It-tag">Linux native asynchronous I/O. This ioengine defines engine
      specific options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>posixaio</b></dt>
  <dd class="It-tag">POSIX asynchronous I/O using <b>aio_read</b>(3) and
      <b>aio_write</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>solarisaio</b></dt>
  <dd class="It-tag">Solaris native asynchronous I/O.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>windowsaio</b></dt>
  <dd class="It-tag">Windows native asynchronous I/O. Default on Windows.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mmap</b></dt>
  <dd class="It-tag">File is memory mapped with <b>mmap</b>(2) and data copied
      using <b>memcpy</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>splice</b></dt>
  <dd class="It-tag"><b>splice</b>(2) is used to transfer the data and
      <b>vmsplice</b>(2) to transfer data from user-space to the kernel.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sg</b></dt>
  <dd class="It-tag">SCSI generic sg v3 I/O. May be either synchronous using the
      SG_IO ioctl, or if the target is an sg character device, we use
      <b>read</b>(2) and <b>write</b>(2) for asynchronous I/O.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>null</b></dt>
  <dd class="It-tag">Doesn't transfer any data, just pretends to. Mainly used to
      exercise <b>fio</b> itself and for debugging and testing purposes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>net</b></dt>
  <dd class="It-tag">Transfer over the network. The protocol to be used can be
      defined with the <b>protocol</b> parameter. Depending on the protocol,
      <b>filename</b>, <b>hostname</b>, <b>port</b>, or <b>listen</b> must be
      specified. This ioengine defines engine specific options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>netsplice</b></dt>
  <dd class="It-tag">Like <b>net</b>, but uses <b>splice</b>(2) and
      <b>vmsplice</b>(2) to map data and send/receive. This ioengine defines
      engine specific options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cpuio</b></dt>
  <dd class="It-tag">Doesn't transfer any data, but burns CPU cycles according
      to <b>cpuload</b> and <b>cpuchunks</b> parameters. A job never finishes
      unless there is at least one non-cpuio job.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>guasi</b></dt>
  <dd class="It-tag">The GUASI I/O engine is the Generic Userspace Asynchronous
      Syscall Interface approach to asynchronous I/O.
    <div>&#x00A0;</div>
    See &lt;http://www.xmailserver.org/guasi-lib.html&gt;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rdma</b></dt>
  <dd class="It-tag">The RDMA I/O engine supports both RDMA memory semantics
      (RDMA_WRITE/RDMA_READ) and channel semantics (Send/Recv) for the
      InfiniBand, RoCE and iWARP protocols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>external</b></dt>
  <dd class="It-tag">Loads an external I/O engine object file. Append the engine
      filename as `: <i>enginepath</i>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>falloc</b></dt>
  <dd class="It-tag">
    <br/>
     IO engine that does regular linux native fallocate call to simulate data
      transfer as fio ioengine
    <div>&#x00A0;</div>
    <br/>
     DDIR_READ does fallocate(,mode = FALLOC_FL_KEEP_SIZE,)
    <div>&#x00A0;</div>
    <br/>
     DIR_WRITE does fallocate(,mode = 0)
    <div>&#x00A0;</div>
    <br/>
     DDIR_TRIM does fallocate(,mode =
    FALLOC_FL_KEEP_SIZE|FALLOC_FL_PUNCH_HOLE)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>e4defrag</b></dt>
  <dd class="It-tag">IO engine that does regular EXT4_IOC_MOVE_EXT ioctls to
      simulate defragment activity request to DDIR_WRITE event</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rbd</b></dt>
  <dd class="It-tag">IO engine supporting direct access to Ceph Rados Block
      Devices (RBD) via librbd without the need to use the kernel rbd driver.
      This ioengine defines engine specific options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gfapi</b></dt>
  <dd class="It-tag">Using Glusterfs libgfapi sync interface to direct access to
      Glusterfs volumes without having to go through FUSE. This ioengine defines
      engine specific options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gfapi_async</b></dt>
  <dd class="It-tag">Using Glusterfs libgfapi async interface to direct access
      to Glusterfs volumes without having to go through FUSE. This ioengine
      defines engine specific options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>libhdfs</b></dt>
  <dd class="It-tag">Read and write through Hadoop (HDFS). The <b>filename</b>
      option is used to specify host,port of the hdfs name-node to connect. This
      engine interprets offsets a little differently. In HDFS, files once
      created cannot be modified. So random writes are not possible. To imitate
      this, libhdfs engine expects bunch of small files to be created over HDFS,
      and engine will randomly pick a file out of those files based on the
      offset generated by fio backend. (see the example job file to create such
      files, use rw=write option). Please note, you might want to set necessary
      environment variables to work with hdfs/libhdfs properly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mtd</b></dt>
  <dd class="It-tag">Read, write and erase an MTD character device (e.g.,
      /dev/mtd0). Discards are treated as erases. Depending on the underlying
      device type, the I/O may have to go in a certain pattern, e.g., on NAND,
      writing sequentially to erase blocks and discarding before overwriting.
      The writetrim mode works well for this constraint.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pmemblk</b></dt>
  <dd class="It-tag">Read and write through the NVML libpmemblk interface.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dev-dax</b></dt>
  <dd class="It-tag">Read and write through a DAX device exposed from persistent
      memory.</dd>
</dl>
</div>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iodepth</b><i>=int</i></dt>
  <dd class="It-tag">Number of I/O units to keep in flight against the file.
      Note that increasing iodepth beyond 1 will not affect synchronous
      ioengines (except for small degress when verify_async is in use). Even
      async engines may impose OS restrictions causing the desired depth not to
      be achieved. This may happen on Linux when using libaio and not setting
      <b>direct</b>=1, since buffered IO is not async on that OS. Keep an eye on
      the IO depth distribution in the fio output to verify that the achieved
      depth is as expected. Default: 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iodepth_batch</b><i>=int</i><b>,
    iodepth_batch_submit</b><i>=int</i></dt>
  <dd class="It-tag">This defines how many pieces of IO to submit at once. It
      defaults to 1 which means that we submit each IO as soon as it is
      available, but can be raised to submit bigger batches of IO at the time.
      If it is set to 0 the <b>iodepth</b> value will be used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iodepth_batch_complete_min</b><i>=int</i><b>,
    iodepth_batch_complete</b><i>=int</i></dt>
  <dd class="It-tag">This defines how many pieces of IO to retrieve at once. It
      defaults to 1 which
    <br/>
     means that we'll ask for a minimum of 1 IO in the retrieval process from
      the kernel. The IO retrieval will go on until we hit the limit set by
      <b>iodepth_low</b>. If this variable is set to 0, then fio will always
      check for completed events before queuing more IO. This helps reduce IO
      latency, at the cost of more retrieval system calls.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iodepth_batch_complete_max</b><i>=int</i></dt>
  <dd class="It-tag">This defines maximum pieces of IO to retrieve at once. This
      variable should be used along with <b>iodepth_batch_complete_min</b>=int
      variable, specifying the range of min and max amount of IO which should be
      retrieved. By default it is equal to <b>iodepth_batch_complete_min</b>
      value.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example #1:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;"><b>iodepth_batch_complete_min</b>=1
<div class="Pp"></div>
<b>iodepth_batch_complete_max</b>=&lt;iodepth&gt;</div>
<div style="height: 1.00em;">&#x00A0;</div>
which means that we will retrieve at least 1 IO and up to the whole submitted
  queue depth. If none of IO has been completed yet, we will wait.
<div style="height: 1.00em;">&#x00A0;</div>
Example #2:
<div style="margin-left: 5.00ex;"><b>iodepth_batch_complete_min</b>=0
<div class="Pp"></div>
<b>iodepth_batch_complete_max</b>=&lt;iodepth&gt;</div>
<div style="height: 1.00em;">&#x00A0;</div>
which means that we can retrieve up to the whole submitted queue depth, but if
  none of IO has been completed yet, we will NOT wait and immediately exit the
  system call. In this example we simply do polling.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iodepth_low</b><i>=int</i></dt>
  <dd class="It-tag">Low watermark indicating when to start filling the queue
      again. Default: <b>iodepth</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>io_submit_mode</b><i>=str</i></dt>
  <dd class="It-tag">This option controls how fio submits the IO to the IO
      engine. The default is <b>inline</b>, which means that the fio job threads
      submit and reap IO directly. If set to <b>offload</b>, the job threads
      will offload IO submission to a dedicated pool of IO threads. This
      requires some coordination and thus has a bit of extra overhead,
      especially for lower queue depth IO where it can increase latencies. The
      benefit is that fio can manage submission rates independently of the
      device completion rates. This avoids skewed latency reporting if IO gets
      back up on the device side (the coordinated omission problem).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>direct</b><i>=bool</i></dt>
  <dd class="It-tag">If true, use non-buffered I/O (usually O_DIRECT). Default:
      false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>atomic</b><i>=bool</i></dt>
  <dd class="It-tag">If value is true, attempt to use atomic direct IO. Atomic
      writes are guaranteed to be stable once acknowledged by the operating
      system. Only Linux supports O_ATOMIC right now.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>buffered</b><i>=bool</i></dt>
  <dd class="It-tag">If true, use buffered I/O. This is the opposite of the
      <b>direct</b> parameter. Default: true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>offset</b><i>=int</i></dt>
  <dd class="It-tag">Offset in the file to start I/O. Data before the offset
      will not be touched.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>offset_increment</b><i>=int</i></dt>
  <dd class="It-tag">If this is provided, then the real offset becomes the
      offset + offset_increment * thread_number, where the thread number is a
      counter that starts at 0 and is incremented for each sub-job (i.e. when
      numjobs option is specified). This option is useful if there are several
      jobs which are intended to operate on a file in parallel disjoint
      segments, with even spacing between the starting points.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>number_ios</b><i>=int</i></dt>
  <dd class="It-tag">Fio will normally perform IOs until it has exhausted the
      size of the region set by <b>size</b>, or if it exhaust the allocated time
      (or hits an error condition). With this setting, the range/size can be set
      independently of the number of IOs to perform. When fio reaches this
      number, it will exit normally and report status. Note that this does not
      extend the amount of IO that will be done, it will only stop fio if this
      condition is met before other end-of-job criteria.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fsync</b><i>=int</i></dt>
  <dd class="It-tag">How many I/Os to perform before issuing an <b>fsync</b>(2)
      of dirty data. If 0, don't sync. Default: 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fdatasync</b><i>=int</i></dt>
  <dd class="It-tag">Like <b>fsync</b>, but uses <b>fdatasync</b>(2) instead to
      only sync the data parts of the file. Default: 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write_barrier</b><i>=int</i></dt>
  <dd class="It-tag">Make every Nth write a barrier write.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sync_file_range</b><i>=str:int</i></dt>
  <dd class="It-tag">Use <b>sync_file_range</b>(2) for every val number of write
      operations. Fio will track range of writes that have happened since the
      last <b>sync_file_range</b>(2) call. str can currently be one or more
    of:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>wait_before</b></dt>
  <dd class="It-tag">SYNC_FILE_RANGE_WAIT_BEFORE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write</b></dt>
  <dd class="It-tag">SYNC_FILE_RANGE_WRITE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>wait_after</b></dt>
  <dd class="It-tag">SYNC_FILE_RANGE_WRITE</dd>
</dl>
</div>
<div class="Pp"></div>
So if you do sync_file_range=wait_before,write:8, fio would use
  <b>SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE</b> for every 8 writes.
  Also see the <b>sync_file_range</b>(2) man page. This option is Linux
  specific.
<dl class="Bl-tag">
  <dt class="It-tag"><b>overwrite</b><i>=bool</i></dt>
  <dd class="It-tag">If writing, setup the file first and do overwrites.
      Default: false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>end_fsync</b><i>=bool</i></dt>
  <dd class="It-tag">Sync file contents when a write stage has completed.
      Default: false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fsync_on_close</b><i>=bool</i></dt>
  <dd class="It-tag">If true, sync file contents on close. This differs from
      <b>end_fsync</b> in that it will happen on every close, not just at the
      end of the job. Default: false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rwmixread</b><i>=int</i></dt>
  <dd class="It-tag">Percentage of a mixed workload that should be reads.
      Default: 50.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rwmixwrite</b><i>=int</i></dt>
  <dd class="It-tag">Percentage of a mixed workload that should be writes. If
      <b>rwmixread</b> and <b>rwmixwrite</b> are given and do not sum to 100%,
      the latter of the two overrides the first. This may interfere with a given
      rate setting, if fio is asked to limit reads or writes to a certain rate.
      If that is the case, then the distribution may be skewed. Default:
    50.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>random_distribution</b><i>=str:float</i></dt>
  <dd class="It-tag">By default, fio will use a completely uniform random
      distribution when asked to perform random IO. Sometimes it is useful to
      skew the distribution in specific ways, ensuring that some parts of the
      data is more hot than others. Fio includes the following distribution
      models:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>random</b></dt>
  <dd class="It-tag">Uniform random distribution</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zipf</b></dt>
  <dd class="It-tag">Zipf distribution</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pareto</b></dt>
  <dd class="It-tag">Pareto distribution</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gauss</b></dt>
  <dd class="It-tag">Normal (gaussian) distribution</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zoned</b></dt>
  <dd class="It-tag">Zoned random distribution</dd>
</dl>
</div>
When using a <b>zipf</b> or <b>pareto</b> distribution, an input value is also
  needed to define the access pattern. For <b>zipf</b>, this is the zipf theta.
  For <b>pareto</b>, it's the pareto power. Fio includes a test program,
  genzipf, that can be used visualize what the given input values will yield in
  terms of hit rates. If you wanted to use <b>zipf</b> with a theta of 1.2, you
  would use random_distribution=zipf:1.2 as the option. If a non-uniform model
  is used, fio will disable use of the random map. For the <b>gauss</b>
  distribution, a normal deviation is supplied as a value between 0 and 100.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">For a <b>zoned</b> distribution, fio supports
  specifying percentages of IO access that should fall within what range of the
  file or device. For example, given a criteria of:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">60% of accesses should be to the first
  10%</div>
<div style="margin-left: 5.00ex;">30% of accesses should be to the next
  20%</div>
<div style="margin-left: 5.00ex;">8% of accesses should be to to the next
  30%</div>
<div style="margin-left: 5.00ex;">2% of accesses should be to the next 40%</div>
<div class="Pp"></div>
we can define that through zoning of the random accesses. For the above example,
  the user would do:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;"><b>random_distribution=zoned:60/10:30/20:8/30:2/40</b></div>
<div class="Pp"></div>
similarly to how <b>bssplit</b> works for setting ranges and percentages of
  block sizes. Like <b>bssplit</b>, it's possible to specify separate zones for
  reads, writes, and trims. If just one set is given, it'll apply to all of
  them.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>percentage_random</b><i>=int</i></dt>
  <dd class="It-tag">For a random workload, set how big a percentage should be
      random. This defaults to 100%, in which case the workload is fully random.
      It can be set from anywhere from 0 to 100. Setting it to 0 would make the
      workload fully sequential. It is possible to set different values for
      reads, writes, and trim. To do so, simply use a comma separated list. See
      <b>blocksize</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>norandommap</b></dt>
  <dd class="It-tag">Normally <b>fio</b> will cover every block of the file when
      doing random I/O. If this parameter is given, a new offset will be chosen
      without looking at past I/O history. This parameter is mutually exclusive
      with <b>verify</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>softrandommap</b><i>=bool</i></dt>
  <dd class="It-tag">See <b>norandommap</b>. If fio runs with the random block
      map enabled and it fails to allocate the map, if this option is set it
      will continue without a random block map. As coverage will not be as
      complete as with random maps, this option is disabled by default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>random_generator</b><i>=str</i></dt>
  <dd class="It-tag">Fio supports the following engines for generating IO
      offsets for random IO:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>tausworthe</b></dt>
  <dd class="It-tag">Strong 2^88 cycle random number generator</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>lfsr</b></dt>
  <dd class="It-tag">Linear feedback shift register generator</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tausworthe64</b></dt>
  <dd class="It-tag">Strong 64-bit 2^258 cycle random number generator</dd>
</dl>
</div>
<div class="Pp"></div>
Tausworthe is a strong random number generator, but it requires tracking on the
  side if we want to ensure that blocks are only read or written once. LFSR
  guarantees that we never generate the same offset twice, and it's also less
  computationally expensive. It's not a true random generator, however, though
  for IO purposes it's typically good enough. LFSR only works with single block
  sizes, not with workloads that use multiple block sizes. If used with such a
  workload, fio may read or write some blocks multiple times. The default value
  is tausworthe, unless the required space exceeds 2^32 blocks. If it does, then
  tausworthe64 is selected automatically.
<dl class="Bl-tag">
  <dt class="It-tag"><b>nice</b><i>=int</i></dt>
  <dd class="It-tag">Run job with given nice value. See <b>nice</b>(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>prio</b><i>=int</i></dt>
  <dd class="It-tag">Set I/O priority value of this job between 0 (highest) and
      7 (lowest). See <b>ionice</b>(1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>prioclass</b><i>=int</i></dt>
  <dd class="It-tag">Set I/O priority class. See <b>ionice</b>(1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>thinktime</b><i>=int</i></dt>
  <dd class="It-tag">Stall job for given number of microseconds between issuing
      I/Os.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>thinktime_spin</b><i>=int</i></dt>
  <dd class="It-tag">Pretend to spend CPU time for given number of microseconds,
      sleeping the rest of the time specified by <b>thinktime</b>. Only valid if
      <b>thinktime</b> is set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>thinktime_blocks</b><i>=int</i></dt>
  <dd class="It-tag">Only valid if thinktime is set - control how many blocks to
      issue, before waiting <b>thinktime</b> microseconds. If not set, defaults
      to 1 which will make fio wait <b>thinktime</b> microseconds after every
      block. This effectively makes any queue depth setting redundant, since no
      more than 1 IO will be queued before we have to complete it and do our
      thinktime. In other words, this setting effectively caps the queue depth
      if the latter is larger. Default: 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rate</b><i>=int</i></dt>
  <dd class="It-tag">Cap bandwidth used by this job. The number is in bytes/sec,
      the normal postfix rules apply. You can use <b>rate</b>=500k to limit
      reads and writes to 500k each, or you can specify read and writes
      separately. Using <b>rate</b>=1m,500k would limit reads to 1MB/sec and
      writes to 500KB/sec. Capping only reads or writes can be done with
      <b>rate</b>=,500k or <b>rate</b>=500k,. The former will only limit writes
      (to 500KB/sec), the latter will only limit reads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rate_min</b><i>=int</i></dt>
  <dd class="It-tag">Tell <b>fio</b> to do whatever it can to maintain at least
      the given bandwidth. Failing to meet this requirement will cause the job
      to exit. The same format as <b>rate</b> is used for read vs write
      separation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rate_iops</b><i>=int</i></dt>
  <dd class="It-tag">Cap the bandwidth to this number of IOPS. Basically the
      same as rate, just specified independently of bandwidth. The same format
      as <b>rate</b> is used for read vs write separation. If <b>blocksize</b>
      is a range, the smallest block size is used as the metric.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rate_iops_min</b><i>=int</i></dt>
  <dd class="It-tag">If this rate of I/O is not met, the job will exit. The same
      format as <b>rate</b> is used for read vs write separation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rate_process</b><i>=str</i></dt>
  <dd class="It-tag">This option controls how fio manages rated IO submissions.
      The default is <b>linear</b>, which submits IO in a linear fashion with
      fixed delays between IOs that gets adjusted based on IO completion rates.
      If this is set to <b>poisson</b>, fio will submit IO based on a more real
      world random request flow, known as the Poisson process
      (https://en.wikipedia.org/wiki/Poisson_process). The lambda will be 10^6 /
      IOPS for the given workload.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rate_cycle</b><i>=int</i></dt>
  <dd class="It-tag">Average bandwidth for <b>rate</b> and <b>rate_min</b> over
      this number of milliseconds. Default: 1000ms.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>latency_target</b><i>=int</i></dt>
  <dd class="It-tag">If set, fio will attempt to find the max performance point
      that the given workload will run at while maintaining a latency below this
      target. The values is given in microseconds. See <b>latency_window</b> and
      <b>latency_percentile</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>latency_window</b><i>=int</i></dt>
  <dd class="It-tag">Used with <b>latency_target</b> to specify the sample
      window that the job is run at varying queue depths to test the
      performance. The value is given in microseconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>latency_percentile</b><i>=float</i></dt>
  <dd class="It-tag">The percentage of IOs that must fall within the criteria
      specified by <b>latency_target</b> and <b>latency_window</b>. If not set,
      this defaults to 100.0, meaning that all IOs must be equal or below to the
      value set by <b>latency_target</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>max_latency</b><i>=int</i></dt>
  <dd class="It-tag">If set, fio will exit the job if it exceeds this maximum
      latency. It will exit with an ETIME error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cpumask</b><i>=int</i></dt>
  <dd class="It-tag">Set CPU affinity for this job. <i>int</i> is a bitmask of
      allowed CPUs the job may run on. See <b>sched_setaffinity</b>(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cpus_allowed</b><i>=str</i></dt>
  <dd class="It-tag">Same as <b>cpumask</b>, but allows a comma-delimited list
      of CPU numbers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cpus_allowed_policy</b><i>=str</i></dt>
  <dd class="It-tag">Set the policy of how fio distributes the CPUs specified by
      <b>cpus_allowed</b> or <b>cpumask</b>. Two policies are supported:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>shared</b></dt>
  <dd class="It-tag">All jobs will share the CPU set specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>split</b></dt>
  <dd class="It-tag">Each job will get a unique CPU from the CPU set.</dd>
</dl>
</div>
<div class="Pp"></div>
<b>shared</b> is the default behaviour, if the option isn't specified. If
  <b>split</b> is specified, then fio will assign one cpu per job. If not enough
  CPUs are given for the jobs listed, then fio will roundrobin the CPUs in the
  set.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>numa_cpu_nodes</b><i>=str</i></dt>
  <dd class="It-tag">Set this job running on specified NUMA nodes' CPUs. The
      arguments allow comma delimited list of cpu numbers, A-B ranges, or
    'all'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>numa_mem_policy</b><i>=str</i></dt>
  <dd class="It-tag">Set this job's memory policy and corresponding NUMA nodes.
      Format of the arguments:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>&lt;mode&gt;[:&lt;nodelist&gt;]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mode</b></dt>
  <dd class="It-tag">is one of the following memory policy:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>default, prefer, bind, interleave, local</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
For <b>default</b> and <b>local</b> memory policy, no <b>nodelist</b> is needed
  to be specified. For <b>prefer</b>, only one node is allowed. For <b>bind</b>
  and <b>interleave</b>, <b>nodelist</b> allows comma delimited list of numbers,
  A-B ranges, or 'all'.
<dl class="Bl-tag">
  <dt class="It-tag"><b>startdelay</b><i>=irange</i></dt>
  <dd class="It-tag">Delay start of job for the specified number of seconds.
      Supports all time suffixes to allow specification of hours, minutes,
      seconds and milliseconds - seconds are the default if a unit is omitted.
      Can be given as a range which causes each thread to choose randomly out of
      the range.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>runtime</b><i>=int</i></dt>
  <dd class="It-tag">Terminate processing after the specified number of
    seconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>time_based</b></dt>
  <dd class="It-tag">If given, run for the specified <b>runtime</b> duration
      even if the files are completely read or written. The same workload will
      be repeated as many times as <b>runtime</b> allows.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ramp_time</b><i>=int</i></dt>
  <dd class="It-tag">If set, fio will run the specified workload for this amount
      of time before logging any performance numbers. Useful for letting
      performance settle before logging results, thus minimizing the runtime
      required for stable results. Note that the <b>ramp_time</b> is considered
      lead in time for a job, thus it will increase the total runtime if a
      special timeout or runtime is specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>steadystate</b><i>=str:float</i><b>,
    ss</b><i>=str:float</i></dt>
  <dd class="It-tag">Define the criterion and limit for assessing steady state
      performance. The first parameter designates the criterion whereas the
      second parameter sets the threshold. When the criterion falls below the
      threshold for the specified duration, the job will stop. For example,
      iops_slope:0.1% will direct fio to terminate the job when the least
      squares regression slope falls below 0.1% of the mean IOPS. If
      group_reporting is enabled this will apply to all jobs in the group. All
      assessments are carried out using only data from the rolling collection
      window. Threshold limits can be expressed as a fixed value or as a
      percentage of the mean in the collection window. Below are the available
      steady state assessment criteria.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>iops</b></dt>
  <dd class="It-tag">Collect IOPS data. Stop the job if all individual IOPS
      measurements are within the specified limit of the mean IOPS (e.g., iops:2
      means that all individual IOPS values must be within 2 of the mean,
      whereas iops:0.2% means that all individual IOPS values must be within
      0.2% of the mean IOPS to terminate the job).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iops_slope</b></dt>
  <dd class="It-tag">Collect IOPS data and calculate the least squares
      regression slope. Stop the job if the slope falls below the specified
      limit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bw</b></dt>
  <dd class="It-tag">Collect bandwidth data. Stop the job if all individual
      bandwidth measurements are within the specified limit of the mean
      bandwidth.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bw_slope</b></dt>
  <dd class="It-tag">Collect bandwidth data and calculate the least squares
      regression slope. Stop the job if the slope falls below the specified
      limit.</dd>
</dl>
</div>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>steadystate_duration</b><i>=time</i><b>,
    ss_dur</b><i>=time</i></dt>
  <dd class="It-tag">A rolling window of this duration will be used to judge
      whether steady state has been reached. Data will be collected once per
      second. The default is 0 which disables steady state detection.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>steadystate_ramp_time</b><i>=time</i><b>,
    ss_ramp</b><i>=time</i></dt>
  <dd class="It-tag">Allow the job to run for the specified duration before
      beginning data collection for checking the steady state job termination
      criterion. The default is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>invalidate</b><i>=bool</i></dt>
  <dd class="It-tag">Invalidate buffer-cache for the file prior to starting I/O.
      Default: true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sync</b><i>=bool</i></dt>
  <dd class="It-tag">Use synchronous I/O for buffered writes. For the majority
      of I/O engines, this means using O_SYNC. Default: false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iomem</b><i>=str</i><b>, mem</b><i>=str</i></dt>
  <dd class="It-tag">Allocation method for I/O unit buffer. Allowed values
    are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>malloc</b></dt>
  <dd class="It-tag">Allocate memory with <b>malloc</b>(3). Default memory
    type.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>shm</b></dt>
  <dd class="It-tag">Use shared memory buffers allocated through
      <b>shmget</b>(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>shmhuge</b></dt>
  <dd class="It-tag">Same as <b>shm</b>, but use huge pages as backing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mmap</b></dt>
  <dd class="It-tag">Use <b>mmap</b>(2) for allocation. Uses anonymous memory
      unless a filename is given after the option in the format `:
    <i>file</i>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mmaphuge</b></dt>
  <dd class="It-tag">Same as <b>mmap</b>, but use huge files as backing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mmapshared</b></dt>
  <dd class="It-tag">Same as <b>mmap</b>, but use a MMAP_SHARED mapping.</dd>
</dl>
</div>
<div class="Pp"></div>
The amount of memory allocated is the maximum allowed <b>blocksize</b> for the
  job multiplied by <b>iodepth</b>. For <b>shmhuge</b> or <b>mmaphuge</b> to
  work, the system must have free huge pages allocated. <b>mmaphuge</b> also
  needs to have hugetlbfs mounted, and <i>file</i> must point there. At least on
  Linux, huge pages must be manually allocated. See
  <b>/proc/sys/vm/nr_hugehages</b> and the documentation for that. Normally you
  just need to echo an appropriate number, eg echoing 8 will ensure that the OS
  has 8 huge pages ready for use.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iomem_align</b><i>=int</i><b>,
    mem_align</b><i>=int</i></dt>
  <dd class="It-tag">This indicates the memory alignment of the IO memory
      buffers. Note that the given alignment is applied to the first IO unit
      buffer, if using <b>iodepth</b> the alignment of the following buffers are
      given by the <b>bs</b> used. In other words, if using a <b>bs</b> that is
      a multiple of the page sized in the system, all buffers will be aligned to
      this value. If using a <b>bs</b> that is not page aligned, the alignment
      of subsequent IO memory buffers is the sum of the <b>iomem_align</b> and
      <b>bs</b> used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hugepage-size</b><i>=int</i></dt>
  <dd class="It-tag">Defines the size of a huge page. Must be at least equal to
      the system setting. Should be a multiple of 1MB. Default: 4MB.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exitall</b></dt>
  <dd class="It-tag">Terminate all jobs when one finishes. Default: wait for
      each job to finish.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exitall_on_error =bool</b></dt>
  <dd class="It-tag">Terminate all jobs if one job finishes in error. Default:
      wait for each job to finish.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bwavgtime</b><i>=int</i></dt>
  <dd class="It-tag">Average bandwidth calculations over the given time in
      milliseconds. If the job also does bandwidth logging through
      <b>write_bw_log</b>, then the minimum of this option and
      <b>log_avg_msec</b> will be used. Default: 500ms.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>iopsavgtime</b><i>=int</i></dt>
  <dd class="It-tag">Average IOPS calculations over the given time in
      milliseconds. If the job also does IOPS logging through
      <b>write_iops_log</b>, then the minimum of this option and
      <b>log_avg_msec</b> will be used. Default: 500ms.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>create_serialize</b><i>=bool</i></dt>
  <dd class="It-tag">If true, serialize file creation for the jobs. Default:
      true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>create_fsync</b><i>=bool</i></dt>
  <dd class="It-tag"><b>fsync</b>(2) data file after creation. Default:
    true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>create_on_open</b><i>=bool</i></dt>
  <dd class="It-tag">If true, the files are not created until they are opened
      for IO by the job.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>create_only</b><i>=bool</i></dt>
  <dd class="It-tag">If true, fio will only run the setup phase of the job. If
      files need to be laid out or updated on disk, only that will be done. The
      actual job contents are not executed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>allow_file_create</b><i>=bool</i></dt>
  <dd class="It-tag">If true, fio is permitted to create files as part of its
      workload. This is the default behavior. If this option is false, then fio
      will error out if the files it needs to use don't already exist. Default:
      true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>allow_mounted_write</b><i>=bool</i></dt>
  <dd class="It-tag">If this isn't set, fio will abort jobs that are destructive
      (eg that write) to what appears to be a mounted device or partition. This
      should help catch creating inadvertently destructive tests, not realizing
      that the test will destroy data on the mounted file system. Default:
      false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pre_read</b><i>=bool</i></dt>
  <dd class="It-tag">If this is given, files will be pre-read into memory before
      starting the given IO operation. This will also clear the
      <b>invalidate</b> flag, since it is pointless to pre-read and then drop
      the cache. This will only work for IO engines that are seekable, since
      they allow you to read the same data multiple times. Thus it will not work
      on eg network or splice IO.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unlink</b><i>=bool</i></dt>
  <dd class="It-tag">Unlink job files when done. Default: false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unlink_each_loop</b><i>=bool</i></dt>
  <dd class="It-tag">Unlink job files after each iteration or loop. Default:
      false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>loops</b><i>=int</i></dt>
  <dd class="It-tag">Specifies the number of iterations (runs of the same
      workload) of this job. Default: 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_only</b><i>=bool</i></dt>
  <dd class="It-tag">Do not perform the specified workload, only verify data
      still matches previous invocation of this workload. This option allows one
      to check data multiple times at a later date without overwriting it. This
      option makes sense only for workloads that write data, and does not
      support workloads with the <b>time_based</b> option set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>do_verify</b><i>=bool</i></dt>
  <dd class="It-tag">Run the verify phase after a write phase. Only valid if
      <b>verify</b> is set. Default: true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify</b><i>=str</i></dt>
  <dd class="It-tag">Method of verifying file contents after each iteration of
      the job. Each verification method also implies verification of special
      header, which is written to the beginning of each block. This header also
      includes meta information, like offset of the block, block number,
      timestamp when block was written, etc. <b>verify</b>=str can be combined
      with <b>verify_pattern</b>=str option. The allowed values are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>md5 crc16 crc32 crc32c crc32c-intel crc64 crc7 sha256
    sha512 sha1 xxhash</b></dt>
  <dd class="It-tag">Store appropriate checksum in the header of each block.
      crc32c-intel is hardware accelerated SSE4.2 driven, falls back to regular
      crc32c if not supported by the system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>meta</b></dt>
  <dd class="It-tag">This option is deprecated, since now meta information is
      included in generic verification header and meta verification happens by
      default. For detailed information see the description of the
      <b>verify</b>=str setting. This option is kept because of compatibility's
      sake with old configurations. Do not use it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pattern</b></dt>
  <dd class="It-tag">Verify a strict pattern. Normally fio includes a header
      with some basic information and checksumming, but if this option is set,
      only the specific pattern set with <b>verify_pattern</b> is verified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>null</b></dt>
  <dd class="It-tag">Pretend to verify. Used for testing internals.</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
This option can be used for repeated burn-in tests of a system to make sure that
  the written data is also correctly read back. If the data direction given is a
  read or random read, fio will assume that it should verify a previously
  written file. If the data direction includes any form of write, the verify
  will be of the newly written data.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verifysort</b><i>=bool</i></dt>
  <dd class="It-tag">If true, written verify blocks are sorted if <b>fio</b>
      deems it to be faster to read them back in a sorted manner. Default:
    true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verifysort_nr</b><i>=int</i></dt>
  <dd class="It-tag">Pre-load and sort verify blocks for a read workload.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_offset</b><i>=int</i></dt>
  <dd class="It-tag">Swap the verification header with data somewhere else in
      the block before writing. It is swapped back before verifying.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_interval</b><i>=int</i></dt>
  <dd class="It-tag">Write the verification header for this number of bytes,
      which should divide <b>blocksize</b>. Default: <b>blocksize</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_pattern</b><i>=str</i></dt>
  <dd class="It-tag">If set, fio will fill the io buffers with this pattern. Fio
      defaults to filling with totally random bytes, but sometimes it's
      interesting to fill with a known pattern for io verification purposes.
      Depending on the width of the pattern, fio will fill 1/2/3/4 bytes of the
      buffer at the time(it can be either a decimal or a hex number). The
      verify_pattern if larger than a 32-bit quantity has to be a hex number
      that starts with either &quot;0x&quot; or &quot;0X&quot;. Use with
      <b>verify</b>=str. Also, verify_pattern supports %o format, which means
      that for each block offset will be written and then verified back,
    e.g.:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;"><b>verify_pattern</b>=%o</div>
Or use combination of everything:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;"><b>verify_pattern</b>=0xff%o&quot;abcd&quot;-21</div>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_fatal</b><i>=bool</i></dt>
  <dd class="It-tag">If true, exit the job on the first observed verification
      failure. Default: false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_dump</b><i>=bool</i></dt>
  <dd class="It-tag">If set, dump the contents of both the original data block
      and the data block we read off disk to files. This allows later analysis
      to inspect just what kind of data corruption occurred. Off by
    default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_async</b><i>=int</i></dt>
  <dd class="It-tag">Fio will normally verify IO inline from the submitting
      thread. This option takes an integer describing how many async offload
      threads to create for IO verification instead, causing fio to offload the
      duty of verifying IO contents to one or more separate threads. If using
      this offload option, even sync IO engines can benefit from using an
      <b>iodepth</b> setting higher than 1, as it allows them to have IO in
      flight while verifies are running.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_async_cpus</b><i>=str</i></dt>
  <dd class="It-tag">Tell fio to set the given CPU affinity on the async IO
      verification threads. See <b>cpus_allowed</b> for the format used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_backlog</b><i>=int</i></dt>
  <dd class="It-tag">Fio will normally verify the written contents of a job that
      utilizes verify once that job has completed. In other words, everything is
      written then everything is read back and verified. You may want to verify
      continually instead for a variety of reasons. Fio stores the meta data
      associated with an IO block in memory, so for large verify workloads,
      quite a bit of memory would be used up holding this meta data. If this
      option is enabled, fio will write only N blocks before verifying these
      blocks.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_backlog_batch</b><i>=int</i></dt>
  <dd class="It-tag">Control how many blocks fio will verify if verify_backlog
      is set. If not set, will default to the value of <b>verify_backlog</b>
      (meaning the entire queue is read back and verified). If
      <b>verify_backlog_batch</b> is less than <b>verify_backlog</b> then not
      all blocks will be verified, if <b>verify_backlog_batch</b> is larger than
      <b>verify_backlog</b>, some blocks will be verified more than once.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>trim_percentage</b><i>=int</i></dt>
  <dd class="It-tag">Number of verify blocks to discard/trim.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>trim_verify_zero</b><i>=bool</i></dt>
  <dd class="It-tag">Verify that trim/discarded blocks are returned as
    zeroes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>trim_backlog</b><i>=int</i></dt>
  <dd class="It-tag">Trim after this number of blocks are written.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>trim_backlog_batch</b><i>=int</i></dt>
  <dd class="It-tag">Trim this number of IO blocks.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>experimental_verify</b><i>=bool</i></dt>
  <dd class="It-tag">Enable experimental verification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_state_save</b><i>=bool</i></dt>
  <dd class="It-tag">When a job exits during the write phase of a verify
      workload, save its current state. This allows fio to replay up until that
      point, if the verify state is loaded for the verify read phase.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verify_state_load</b><i>=bool</i></dt>
  <dd class="It-tag">If a verify termination trigger was used, fio stores the
      current write state of each thread. This can be used at verification time
      so that fio knows how far it should verify. Without this information, fio
      will run a full verification pass, according to the settings in the job
      file used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>stonewall , wait_for_previous</b></dt>
  <dd class="It-tag">Wait for preceding jobs in the job file to exit before
      starting this one. <b>stonewall</b> implies <b>new_group</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>new_group</b></dt>
  <dd class="It-tag">Start a new reporting group. If not given, all jobs in a
      file will be part of the same reporting group, unless separated by a
      stonewall.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>numjobs</b><i>=int</i></dt>
  <dd class="It-tag">Number of clones (processes/threads performing the same
      workload) of this job. Default: 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>group_reporting</b></dt>
  <dd class="It-tag">If set, display per-group reports instead of per-job when
      <b>numjobs</b> is specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>thread</b></dt>
  <dd class="It-tag">Use threads created with <b>pthread_create</b>(3) instead
      of processes created with <b>fork</b>(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zonesize</b><i>=int</i></dt>
  <dd class="It-tag">Divide file into zones of the specified size in bytes. See
      <b>zoneskip</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zonerange</b><i>=int</i></dt>
  <dd class="It-tag">Give size of an IO zone. See <b>zoneskip</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zoneskip</b><i>=int</i></dt>
  <dd class="It-tag">Skip the specified number of bytes when <b>zonesize</b>
      bytes of data have been read.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write_iolog</b><i>=str</i></dt>
  <dd class="It-tag">Write the issued I/O patterns to the specified file.
      Specify a separate file for each job, otherwise the iologs will be
      interspersed and the file may be corrupt.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>read_iolog</b><i>=str</i></dt>
  <dd class="It-tag">Replay the I/O patterns contained in the specified file
      generated by <b>write_iolog</b>, or may be a <b>blktrace</b> binary
    file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>replay_no_stall</b><i>=int</i></dt>
  <dd class="It-tag">While replaying I/O patterns using <b>read_iolog</b> the
      default behavior attempts to respect timing information between I/Os.
      Enabling <b>replay_no_stall</b> causes I/Os to be replayed as fast as
      possible while still respecting ordering.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>replay_redirect</b><i>=str</i></dt>
  <dd class="It-tag">While replaying I/O patterns using <b>read_iolog</b> the
      default behavior is to replay the IOPS onto the major/minor device that
      each IOP was recorded from. Setting <b>replay_redirect</b> causes all IOPS
      to be replayed onto the single specified device regardless of the device
      it was recorded from.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>replay_align</b><i>=int</i></dt>
  <dd class="It-tag">Force alignment of IO offsets and lengths in a trace to
      this power of 2 value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>replay_scale</b><i>=int</i></dt>
  <dd class="It-tag">Scale sector offsets down by this factor when replaying
      traces.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>per_job_logs</b><i>=bool</i></dt>
  <dd class="It-tag">If set, this generates bw/clat/iops log with per file
      private filenames. If not set, jobs with identical names will share the
      log filename. Default: true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write_bw_log</b><i>=str</i></dt>
  <dd class="It-tag">If given, write a bandwidth log for this job. Can be used
      to store data of the bandwidth of the jobs in their lifetime. The included
      fio_generate_plots script uses gnuplot to turn these text files into nice
      graphs. See <b>write_lat_log</b> for behaviour of given filename. For this
      option, the postfix is _bw.x.log, where x is the index of the job (1..N,
      where N is the number of jobs). If <b>per_job_logs</b> is false, then the
      filename will not include the job index. See the <b>LOG FILE FORMATS</b>
      section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write_lat_log</b><i>=str</i></dt>
  <dd class="It-tag">Same as <b>write_bw_log</b>, but writes I/O completion
      latencies. If no filename is given with this option, the default filename
      of &quot;jobname_type.x.log&quot; is used, where x is the index of the job
      (1..N, where N is the number of jobs). Even if the filename is given, fio
      will still append the type of log. If <b>per_job_logs</b> is false, then
      the filename will not include the job index. See the <b>LOG FILE
      FORMATS</b> section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write_hist_log</b><i>=str</i></dt>
  <dd class="It-tag">Same as <b>write_lat_log</b>, but writes I/O completion
      latency histograms. If no filename is given with this option, the default
      filename of &quot;jobname_clat_hist.x.log&quot; is used, where x is the
      index of the job (1..N, where N is the number of jobs). Even if the
      filename is given, fio will still append the type of log. If
      <b>per_job_logs</b> is false, then the filename will not include the job
      index. See the <b>LOG FILE FORMATS</b> section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write_iops_log</b><i>=str</i></dt>
  <dd class="It-tag">Same as <b>write_bw_log</b>, but writes IOPS. If no
      filename is given with this option, the default filename of
      &quot;jobname_type.x.log&quot; is used, where x is the index of the job
      (1..N, where N is the number of jobs). Even if the filename is given, fio
      will still append the type of log. If <b>per_job_logs</b> is false, then
      the filename will not include the job index. See the <b>LOG FILE
      FORMATS</b> section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log_avg_msec</b><i>=int</i></dt>
  <dd class="It-tag">By default, fio will log an entry in the iops, latency, or
      bw log for every IO that completes. When writing to the disk log, that can
      quickly grow to a very large size. Setting this option makes fio average
      the each log entry over the specified period of time, reducing the
      resolution of the log. See <b>log_max_value</b> as well. Defaults to 0,
      logging all entries.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log_max_value</b><i>=bool</i></dt>
  <dd class="It-tag">If <b>log_avg_msec</b> is set, fio logs the average over
      that window. If you instead want to log the maximum value, set this option
      to 1. Defaults to 0, meaning that averaged values are logged.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log_hist_msec</b><i>=int</i></dt>
  <dd class="It-tag">Same as <b>log_avg_msec</b>, but logs entries for
      completion latency histograms. Computing latency percentiles from averages
      of intervals using <b>log_avg_msec</b> is inacurate. Setting this option
      makes fio log histogram entries over the specified period of time,
      reducing log sizes for high IOPS devices while retaining percentile
      accuracy. See <b>log_hist_coarseness</b> as well. Defaults to 0, meaning
      histogram logging is disabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log_hist_coarseness</b><i>=int</i></dt>
  <dd class="It-tag">Integer ranging from 0 to 6, defining the coarseness of the
      resolution of the histogram logs enabled with <b>log_hist_msec</b>. For
      each increment in coarseness, fio outputs half as many bins. Defaults to
      0, for which histogram logs contain 1216 latency bins. See the <b>LOG FILE
      FORMATS</b> section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log_offset</b><i>=bool</i></dt>
  <dd class="It-tag">If this is set, the iolog options will include the byte
      offset for the IO entry as well as the other data values.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log_compression</b><i>=int</i></dt>
  <dd class="It-tag">If this is set, fio will compress the IO logs as it goes,
      to keep the memory footprint lower. When a log reaches the specified size,
      that chunk is removed and compressed in the background. Given that IO logs
      are fairly highly compressible, this yields a nice memory savings for
      longer runs. The downside is that the compression will consume some
      background CPU cycles, so it may impact the run. This, however, is also
      true if the logging ends up consuming most of the system memory. So pick
      your poison. The IO logs are saved normally at the end of a run, by
      decompressing the chunks and storing them in the specified log file. This
      feature depends on the availability of zlib.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log_compression_cpus</b><i>=str</i></dt>
  <dd class="It-tag">Define the set of CPUs that are allowed to handle online
      log compression for the IO jobs. This can provide better isolation between
      performance sensitive jobs, and background compression work.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log_store_compressed</b><i>=bool</i></dt>
  <dd class="It-tag">If set, fio will store the log files in a compressed
      format. They can be decompressed with fio, using the <b>--inflate-log</b>
      command line parameter. The files will be stored with a <b>.fz</b>
    suffix.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log_unix_epoch</b><i>=bool</i></dt>
  <dd class="It-tag">If set, fio will log Unix timestamps to the log files
      produced by enabling <b>write_type_log</b> for each log type, instead of
      the default zero-based timestamps.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>block_error_percentiles</b><i>=bool</i></dt>
  <dd class="It-tag">If set, record errors in trim block-sized units from writes
      and trims and output a histogram of how many trims it took to get to
      errors, and what kind of error was encountered.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>disable_lat</b><i>=bool</i></dt>
  <dd class="It-tag">Disable measurements of total latency numbers. Useful only
      for cutting back the number of calls to <b>gettimeofday</b>(2), as that
      does impact performance at really high IOPS rates. Note that to really get
      rid of a large amount of these calls, this option must be used with
      disable_slat and disable_bw as well.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>disable_clat</b><i>=bool</i></dt>
  <dd class="It-tag">Disable measurements of completion latency numbers. See
      <b>disable_lat</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>disable_slat</b><i>=bool</i></dt>
  <dd class="It-tag">Disable measurements of submission latency numbers. See
      <b>disable_lat</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>disable_bw_measurement</b><i>=bool</i></dt>
  <dd class="It-tag">Disable measurements of throughput/bandwidth numbers. See
      <b>disable_lat</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>lockmem</b><i>=int</i></dt>
  <dd class="It-tag">Pin the specified amount of memory with <b>mlock</b>(2).
      Can be used to simulate a smaller amount of memory. The amount specified
      is per worker.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exec_prerun</b><i>=str</i></dt>
  <dd class="It-tag">Before running the job, execute the specified command with
      <b>system</b>(3).</dd>
</dl>
<div style="margin-left: 5.00ex;">Output is redirected in a file called
  <b>jobname.prerun.txt</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exec_postrun</b><i>=str</i></dt>
  <dd class="It-tag">Same as <b>exec_prerun</b>, but the command is executed
      after the job completes.</dd>
</dl>
<div style="margin-left: 5.00ex;">Output is redirected in a file called
  <b>jobname.postrun.txt</b></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ioscheduler</b><i>=str</i></dt>
  <dd class="It-tag">Attempt to switch the device hosting the file to the
      specified I/O scheduler.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>disk_util</b><i>=bool</i></dt>
  <dd class="It-tag">Generate disk utilization statistics if the platform
      supports it. Default: true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>clocksource</b><i>=str</i></dt>
  <dd class="It-tag">Use the given clocksource as the base of timing. The
      supported options are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>gettimeofday</b></dt>
  <dd class="It-tag"><b>gettimeofday</b>(2)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>clock_gettime</b></dt>
  <dd class="It-tag"><b>clock_gettime</b>(2)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cpu</b></dt>
  <dd class="It-tag">Internal CPU clock source</dd>
</dl>
</div>
<div class="Pp"></div>
<b>cpu</b> is the preferred clocksource if it is reliable, as it is very fast
  (and fio is heavy on time calls). Fio will automatically use this clocksource
  if it's supported and considered reliable on the system it is running on,
  unless another clocksource is specifically set. For x86/x86-64 CPUs, this
  means supporting TSC Invariant.
<dl class="Bl-tag">
  <dt class="It-tag"><b>gtod_reduce</b><i>=bool</i></dt>
  <dd class="It-tag">Enable all of the <b>gettimeofday</b>(2) reducing options
      (disable_clat, disable_slat, disable_bw) plus reduce precision of the
      timeout somewhat to really shrink the <b>gettimeofday</b>(2) call count.
      With this option enabled, we only do about 0.4% of the gtod() calls we
      would have done if all time keeping was enabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gtod_cpu</b><i>=int</i></dt>
  <dd class="It-tag">Sometimes it's cheaper to dedicate a single thread of
      execution to just getting the current time. Fio (and databases, for
      instance) are very intensive on <b>gettimeofday</b>(2) calls. With this
      option, you can set one CPU aside for doing nothing but logging current
      time to a shared memory location. Then the other threads/processes that
      run IO workloads need only copy that segment, instead of entering the
      kernel with a <b>gettimeofday</b>(2) call. The CPU set aside for doing
      these time calls will be excluded from other uses. Fio will manually clear
      it from the CPU mask of other jobs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ignore_error</b><i>=str</i></dt>
  <dd class="It-tag">Sometimes you want to ignore some errors during test in
      that case you can specify error list for each error type.
    <div>&#x00A0;</div>
    ignore_error=READ_ERR_LIST,WRITE_ERR_LIST,VERIFY_ERR_LIST
    <div>&#x00A0;</div>
    errors for given error type is separated with ':'. Error may be symbol
      ('ENOSPC', 'ENOMEM') or an integer.
    <div>&#x00A0;</div>
    Example: ignore_error=EAGAIN,ENOSPC:122 .
    <div>&#x00A0;</div>
    This option will ignore EAGAIN from READ, and ENOSPC and 122(EDQUOT) from
      WRITE.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>error_dump</b><i>=bool</i></dt>
  <dd class="It-tag">If set dump every error even if it is non fatal, true by
      default. If disabled only fatal error will be dumped</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>profile</b><i>=str</i></dt>
  <dd class="It-tag">Select a specific builtin performance test.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cgroup</b><i>=str</i></dt>
  <dd class="It-tag">Add job to this control group. If it doesn't exist, it will
      be created. The system must have a mounted cgroup blkio mount point for
      this to work. If your system doesn't have it mounted, you can do so with:
    <div style="height: 1.00em;">&#x00A0;</div>
    # mount -t cgroup -o blkio none /cgroup</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cgroup_weight</b><i>=int</i></dt>
  <dd class="It-tag">Set the weight of the cgroup to this value. See the
      documentation that comes with the kernel, allowed values are in the range
      of 100..1000.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cgroup_nodelete</b><i>=bool</i></dt>
  <dd class="It-tag">Normally fio will delete the cgroups it has created after
      the job completion. To override this behavior and to leave cgroups around
      after the job completion, set cgroup_nodelete=1. This can be useful if one
      wants to inspect various cgroup files after job completion. Default:
    false</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>uid</b><i>=int</i></dt>
  <dd class="It-tag">Instead of running as the invoking user, set the user ID to
      this value before the thread/process does any work.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gid</b><i>=int</i></dt>
  <dd class="It-tag">Set group ID, see <b>uid</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unit_base</b><i>=int</i></dt>
  <dd class="It-tag">Base unit for reporting. Allowed values are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>0</b></dt>
  <dd class="It-tag">Use auto-detection (default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>8</b></dt>
  <dd class="It-tag">Byte based.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>1</b></dt>
  <dd class="It-tag">Bit based.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>flow_id</b><i>=int</i></dt>
  <dd class="It-tag">The ID of the flow. If not specified, it defaults to being
      a global flow. See <b>flow</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>flow</b><i>=int</i></dt>
  <dd class="It-tag">Weight in token-based flow control. If this value is used,
      then there is a <b>flow counter</b> which is used to regulate the
      proportion of activity between two or more jobs. fio attempts to keep this
      flow counter near zero. The <b>flow</b> parameter stands for how much
      should be added or subtracted to the flow counter on each iteration of the
      main I/O loop. That is, if one job has <b>flow=8</b> and another job has
      <b>flow=-1</b>, then there will be a roughly 1:8 ratio in how much one
      runs vs the other.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>flow_watermark</b><i>=int</i></dt>
  <dd class="It-tag">The maximum value that the absolute value of the flow
      counter is allowed to reach before the job must wait for a lower value of
      the counter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>flow_sleep</b><i>=int</i></dt>
  <dd class="It-tag">The period of time, in microseconds, to wait after the flow
      watermark has been exceeded before retrying operations</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>clat_percentiles</b><i>=bool</i></dt>
  <dd class="It-tag">Enable the reporting of percentiles of completion
      latencies.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>percentile_list</b><i>=float_list</i></dt>
  <dd class="It-tag">Overwrite the default list of percentiles for completion
      latencies and the block error histogram. Each number is a floating number
      in the range (0,100], and the maximum length of the list is 20. Use ':' to
      separate the numbers. For example, --percentile_list=99.5:99.9 will cause
      fio to report the values of completion latency below which 99.5% and 99.9%
      of the observed latencies fell, respectively.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Ioengine_Parameters_List"><a class="selflink" href="#Ioengine_Parameters_List">Ioengine
  Parameters List</a></h2>
Some parameters are only valid when a specific ioengine is in use. These are
  used identically to normal parameters, with the caveat that when used on the
  command line, they must come after the ioengine.
<dl class="Bl-tag">
  <dt class="It-tag"><b>(cpuio)cpuload</b><i>=int</i></dt>
  <dd class="It-tag">Attempt to use the specified percentage of CPU cycles.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(cpuio)cpuchunks</b><i>=int</i></dt>
  <dd class="It-tag">Split the load into cycles of the given time. In
      microseconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(cpuio)exit_on_io_done</b><i>=bool</i></dt>
  <dd class="It-tag">Detect when IO threads are done, then exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(libaio)userspace_reap</b></dt>
  <dd class="It-tag">Normally, with the libaio engine in use, fio will use the
      io_getevents system call to reap newly returned events. With this flag
      turned on, the AIO ring will be read directly from user-space to reap
      events. The reaping mode is only enabled when polling for a minimum of 0
      events (eg when iodepth_batch_complete=0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(pvsync2)hipri</b></dt>
  <dd class="It-tag">Set RWF_HIPRI on IO, indicating to the kernel that it's of
      higher priority than normal.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(net,netsplice)hostname</b><i>=str</i></dt>
  <dd class="It-tag">The host name or IP address to use for TCP or UDP based IO.
      If the job is a TCP listener or UDP reader, the hostname is not used and
      must be omitted unless it is a valid UDP multicast address.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(net,netsplice)port</b><i>=int</i></dt>
  <dd class="It-tag">The TCP or UDP port to bind to or connect to. If this is
      used with <b>numjobs</b> to spawn multiple instances of the same job type,
      then this will be the starting port number since fio will use a range of
      ports.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(net,netsplice)interface</b><i>=str</i></dt>
  <dd class="It-tag">The IP address of the network interface used to send or
      receive UDP multicast packets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(net,netsplice)ttl</b><i>=int</i></dt>
  <dd class="It-tag">Time-to-live value for outgoing UDP multicast packets.
      Default: 1</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(net,netsplice)nodelay</b><i>=bool</i></dt>
  <dd class="It-tag">Set TCP_NODELAY on TCP connections.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(net,netsplice)protocol</b><i>=str</i><b>,
    proto</b><i>=str</i></dt>
  <dd class="It-tag">The network protocol to use. Accepted values are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>tcp</b></dt>
  <dd class="It-tag">Transmission control protocol</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tcpv6</b></dt>
  <dd class="It-tag">Transmission control protocol V6</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>udp</b></dt>
  <dd class="It-tag">User datagram protocol</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>udpv6</b></dt>
  <dd class="It-tag">User datagram protocol V6</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unix</b></dt>
  <dd class="It-tag">UNIX domain socket</dd>
</dl>
</div>
<div class="Pp"></div>
When the protocol is TCP or UDP, the port must also be given, as well as the
  hostname if the job is a TCP listener or UDP reader. For unix sockets, the
  normal filename option should be used and the port is invalid.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(net,netsplice)listen</b></dt>
  <dd class="It-tag">For TCP network connections, tell fio to listen for
      incoming connections rather than initiating an outgoing connection. The
      hostname must be omitted if this option is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(net,</b><i>pingpong)</i><b>=bool</b></dt>
  <dd class="It-tag">Normally a network writer will just continue writing data,
      and a network reader will just consume packets. If pingpong=1 is set, a
      writer will send its normal payload to the reader, then wait for the
      reader to send the same payload back. This allows fio to measure network
      latencies. The submission and completion latencies then measure local time
      spent sending or receiving, and the completion latency measures how long
      it took for the other end to receive and send back. For UDP multicast
      traffic pingpong=1 should only be set for a single reader when multiple
      readers are listening to the same address.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(net,</b><i>window_size)</i><b>=int</b></dt>
  <dd class="It-tag">Set the desired socket buffer size for the connection.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(net,</b><i>mss)</i><b>=int</b></dt>
  <dd class="It-tag">Set the TCP maximum segment size (TCP_MAXSEG).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(e4defrag,donorname)</b><i>=str</i></dt>
  <dd class="It-tag">File will be used as a block donor (swap extents between
      files)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(e4defrag,inplace)</b><i>=int</i></dt>
  <dd class="It-tag">Configure donor file block allocation strategy</dd>
</dl>
<div style="margin-left: 5.00ex;"><b>0(default)</b><i>:</i> Preallocate donor's
  file on init
<dl class="Bl-tag">
  <dt class="It-tag"><b>1:</b></dt>
  <dd class="It-tag">allocate space immediately inside defragment event, and
      free right after event</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(rbd)clustername</b><i>=str</i></dt>
  <dd class="It-tag">Specifies the name of the ceph cluster.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(rbd)rbdname</b><i>=str</i></dt>
  <dd class="It-tag">Specifies the name of the RBD.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(rbd)pool</b><i>=str</i></dt>
  <dd class="It-tag">Specifies the name of the Ceph pool containing the
    RBD.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(rbd)clientname</b><i>=str</i></dt>
  <dd class="It-tag">Specifies the username (without the 'client.' prefix) used
      to access the Ceph cluster. If the clustername is specified, the
      clientname shall be the full type.id string. If no type. prefix is given,
      fio will add 'client.' by default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>(mtd)skipbad</b><i>=bool</i></dt>
  <dd class="It-tag">Skip operations against known bad blocks.</dd>
</dl>
<h1 class="Sh" title="Sh" id="OUTPUT"><a class="selflink" href="#OUTPUT">OUTPUT</a></h1>
While running, <b>fio</b> will display the status of the created jobs. For
  example:
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
Threads: 1: [_r] [24.8% done] [ 13509/ 8334 kb/s] [eta 00h:01m:31s]</div>
<div class="Pp"></div>
The characters in the first set of brackets denote the current status of each
  threads. The possible values are:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>P</b></dt>
  <dd class="It-tag">Setup but not started.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>C</b></dt>
  <dd class="It-tag">Thread created.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>I</b></dt>
  <dd class="It-tag">Initialized, waiting.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>R</b></dt>
  <dd class="It-tag">Running, doing sequential reads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>r</b></dt>
  <dd class="It-tag">Running, doing random reads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>W</b></dt>
  <dd class="It-tag">Running, doing sequential writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>w</b></dt>
  <dd class="It-tag">Running, doing random writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>M</b></dt>
  <dd class="It-tag">Running, doing mixed sequential reads/writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>m</b></dt>
  <dd class="It-tag">Running, doing mixed random reads/writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>F</b></dt>
  <dd class="It-tag">Running, currently waiting for <b>fsync</b>(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>V</b></dt>
  <dd class="It-tag">Running, verifying written data.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>E</b></dt>
  <dd class="It-tag">Exited, not reaped by main thread.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-</b></dt>
  <dd class="It-tag">Exited, thread reaped.</dd>
</dl>
</div>
<div class="Pp"></div>
The second set of brackets shows the estimated completion percentage of the
  current group. The third set shows the read and write I/O rate, respectively.
  Finally, the estimated run time of the job is displayed.
<div class="Pp"></div>
When <b>fio</b> completes (or is interrupted by Ctrl-C), it will show data for
  each thread, each group of threads, and each disk, in that order.
<div class="Pp"></div>
Per-thread statistics first show the threads client number, group-id, and error
  code. The remaining figures are as follows:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>io</b></dt>
  <dd class="It-tag">Number of megabytes of I/O performed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bw</b></dt>
  <dd class="It-tag">Average data rate (bandwidth).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>runt</b></dt>
  <dd class="It-tag">Threads run time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>slat</b></dt>
  <dd class="It-tag">Submission latency minimum, maximum, average and standard
      deviation. This is the time it took to submit the I/O.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>clat</b></dt>
  <dd class="It-tag">Completion latency minimum, maximum, average and standard
      deviation. This is the time between submission and completion.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bw</b></dt>
  <dd class="It-tag">Bandwidth minimum, maximum, percentage of aggregate
      bandwidth received, average and standard deviation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cpu</b></dt>
  <dd class="It-tag">CPU usage statistics. Includes user and system time, number
      of context switches this thread went through and number of major and minor
      page faults. The CPU utilization numbers are averages for the jobs in that
      reporting group, while the context and fault counters are summed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>IO depths</b></dt>
  <dd class="It-tag">Distribution of I/O depths. Each depth includes everything
      less than (or equal) to it, but greater than the previous depth.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>IO issued</b></dt>
  <dd class="It-tag">Number of read/write requests issued, and number of short
      read/write requests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>IO latencies</b></dt>
  <dd class="It-tag">Distribution of I/O completion latencies. The numbers
      follow the same pattern as <b>IO depths</b>.</dd>
</dl>
</div>
<div class="Pp"></div>
The group statistics show:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>io</b></dt>
  <dd class="It-tag">Number of megabytes I/O performed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>aggrb</b></dt>
  <dd class="It-tag">Aggregate bandwidth of threads in the group.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>minb</b></dt>
  <dd class="It-tag">Minimum average bandwidth a thread saw.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>maxb</b></dt>
  <dd class="It-tag">Maximum average bandwidth a thread saw.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mint</b></dt>
  <dd class="It-tag">Shortest runtime of threads in the group.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>maxt</b></dt>
  <dd class="It-tag">Longest runtime of threads in the group.</dd>
</dl>
</div>
<div class="Pp"></div>
Finally, disk statistics are printed with reads first:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>ios</b></dt>
  <dd class="It-tag">Number of I/Os performed by all groups.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>merge</b></dt>
  <dd class="It-tag">Number of merges in the I/O scheduler.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ticks</b></dt>
  <dd class="It-tag">Number of ticks we kept the disk busy.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>io_queue</b></dt>
  <dd class="It-tag">Total time spent in the disk queue.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>util</b></dt>
  <dd class="It-tag">Disk utilization.</dd>
</dl>
</div>
<div class="Pp"></div>
It is also possible to get fio to dump the current output while it is running,
  without terminating the job. To do that, send fio the <b>USR1</b> signal.
<h1 class="Sh" title="Sh" id="TERSE_OUTPUT"><a class="selflink" href="#TERSE_OUTPUT">TERSE
  OUTPUT</a></h1>
If the <b>--minimal</b> / <b>--append-terse</b> options are given, the results
  will be printed/appended in a semicolon-delimited format suitable for scripted
  use. A job description (if provided) follows on a new line. Note that the
  first number in the line is the version number. If the output has to be
  changed for some reason, this number will be incremented by 1 to signify that
  change. The fields are:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;"><b>terse version, fio version, jobname,
  groupid, error</b>
<div class="Pp"></div>
Read status:
<div style="margin-left: 5.00ex;"><b>Total I/O (KB), bandwidth (KB/s), IOPS,
  runtime (ms)</b>
<div class="Pp"></div>
Submission latency:
<div style="margin-left: 5.00ex;"><b>min, max, mean, standard
  deviation</b></div>
Completion latency:
<div style="margin-left: 5.00ex;"><b>min, max, mean, standard
  deviation</b></div>
Completion latency percentiles (20 fields):
<div style="margin-left: 5.00ex;"><b>Xth percentile=usec</b></div>
Total latency:
<div style="margin-left: 5.00ex;"><b>min, max, mean, standard
  deviation</b></div>
Bandwidth:
<div style="margin-left: 5.00ex;"><b>min, max, aggregate percentage of total,
  mean, standard deviation</b></div>
</div>
<div class="Pp"></div>
Write status:
<div style="margin-left: 5.00ex;"><b>Total I/O (KB), bandwidth (KB/s), IOPS,
  runtime (ms)</b>
<div class="Pp"></div>
Submission latency:
<div style="margin-left: 5.00ex;"><b>min, max, mean, standard
  deviation</b></div>
Completion latency:
<div style="margin-left: 5.00ex;"><b>min, max, mean, standard
  deviation</b></div>
Completion latency percentiles (20 fields):
<div style="margin-left: 5.00ex;"><b>Xth percentile=usec</b></div>
Total latency:
<div style="margin-left: 5.00ex;"><b>min, max, mean, standard
  deviation</b></div>
Bandwidth:
<div style="margin-left: 5.00ex;"><b>min, max, aggregate percentage of total,
  mean, standard deviation</b></div>
</div>
<div class="Pp"></div>
CPU usage:
<div style="margin-left: 5.00ex;"><b>user, system, context switches, major page
  faults, minor page faults</b></div>
<div class="Pp"></div>
IO depth distribution:
<div style="margin-left: 5.00ex;"><b>&lt;=1, 2, 4, 8, 16, 32, &gt;=64</b></div>
<div class="Pp"></div>
IO latency distribution:
<div style="margin-left: 5.00ex;">Microseconds:
<div style="margin-left: 5.00ex;"><b>&lt;=2, 4, 10, 20, 50, 100, 250, 500, 750,
  1000</b></div>
Milliseconds:
<div style="margin-left: 5.00ex;"><b>&lt;=2, 4, 10, 20, 50, 100, 250, 500, 750,
  1000, 2000, &gt;=2000</b></div>
</div>
<div class="Pp"></div>
Disk utilization (1 for each disk used):
<div style="margin-left: 5.00ex;"><b>name, read ios, write ios, read merges,
  write merges, read ticks, write ticks, read in-queue time, write in-queue
  time, disk utilization percentage</b></div>
<div class="Pp"></div>
Error Info (dependent on continue_on_error, default off):
<div style="margin-left: 5.00ex;"><b>total # errors, first error code</b></div>
<div class="Pp"></div>
<b>text description (if provided in config - appears on newline)</b></div>
<h1 class="Sh" title="Sh" id="TRACE_FILE_FORMAT"><a class="selflink" href="#TRACE_FILE_FORMAT">TRACE
  FILE FORMAT</a></h1>
There are two trace file format that you can encounter. The older (v1) format is
  unsupported since version 1.20-rc3 (March 2008). It will still be described
  below in case that you get an old trace and want to understand it.
<div style="height: 1.00em;">&#x00A0;</div>
In any case the trace is a simple text file with a single action per line.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>Trace file format v1</b>
<div style="margin-left: 5.00ex;">Each line represents a single io action in the
  following format:
<div style="height: 1.00em;">&#x00A0;</div>
rw, offset, length
<div style="height: 1.00em;">&#x00A0;</div>
where rw=0/1 for read/write, and the offset and length entries being in bytes.
<div style="height: 1.00em;">&#x00A0;</div>
This format is not supported in Fio versions =&gt; 1.20-rc3.
<div style="height: 1.00em;">&#x00A0;</div>
</div>
<div class="Pp"></div>
<b>Trace file format v2</b>
<div style="margin-left: 5.00ex;">The second version of the trace file format
  was added in Fio version 1.17. It allows one to access more then one file per
  trace and has a bigger set of possible file actions.
<div style="height: 1.00em;">&#x00A0;</div>
The first line of the trace file has to be:
<div style="height: 1.00em;">&#x00A0;</div>
<b>fio version 2 iolog</b>
<div style="height: 1.00em;">&#x00A0;</div>
Following this can be lines in two different formats, which are described below.
  The file management format:
<div style="height: 1.00em;">&#x00A0;</div>
<b>filename action</b>
<div style="height: 1.00em;">&#x00A0;</div>
The filename is given as an absolute path. The action can be one of these:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>add</b></dt>
  <dd class="It-tag">Add the given filename to the trace</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>open</b></dt>
  <dd class="It-tag">Open the file with the given filename. The filename has to
      have been previously added with the <b>add</b> action.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>close</b></dt>
  <dd class="It-tag">Close the file with the given filename. The file must have
      previously been opened.</dd>
</dl>
</div>
<div class="Pp"></div>
The file io action format:
<div style="height: 1.00em;">&#x00A0;</div>
<b>filename action offset length</b>
<div style="height: 1.00em;">&#x00A0;</div>
The filename is given as an absolute path, and has to have been added and opened
  before it can be used with this format. The offset and length are given in
  bytes. The action can be one of these:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>wait</b></dt>
  <dd class="It-tag">Wait for 'offset' microseconds. Everything below 100 is
      discarded. The time is relative to the previous wait statement.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>read</b></dt>
  <dd class="It-tag">Read <b>length</b> bytes beginning from <b>offset</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write</b></dt>
  <dd class="It-tag">Write <b>length</b> bytes beginning from <b>offset</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sync</b></dt>
  <dd class="It-tag">fsync() the file</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>datasync</b></dt>
  <dd class="It-tag">fdatasync() the file</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>trim</b></dt>
  <dd class="It-tag">trim the given file from the given <b>offset</b> for
      <b>length</b> bytes</dd>
</dl>
</div>
</div>
<h1 class="Sh" title="Sh" id="CPU_IDLENESS_PROFILING"><a class="selflink" href="#CPU_IDLENESS_PROFILING">CPU
  IDLENESS PROFILING</a></h1>
In some cases, we want to understand CPU overhead in a test. For example, we
  test patches for the specific goodness of whether they reduce CPU usage. fio
  implements a balloon approach to create a thread per CPU that runs at idle
  priority, meaning that it only runs when nobody else needs the cpu. By
  measuring the amount of work completed by the thread, idleness of each CPU can
  be derived accordingly.
<div style="height: 1.00em;">&#x00A0;</div>
An unit work is defined as touching a full page of unsigned characters. Mean and
  standard deviation of time to complete an unit work is reported in &quot;unit
  work&quot; section. Options can be chosen to report detailed percpu idleness
  or overall system idleness by aggregating percpu stats.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="VERIFICATION_AND_TRIGGERS"><a class="selflink" href="#VERIFICATION_AND_TRIGGERS">VERIFICATION
  AND TRIGGERS</a></h1>
Fio is usually run in one of two ways, when data verification is done. The first
  is a normal write job of some sort with verify enabled. When the write phase
  has completed, fio switches to reads and verifies everything it wrote. The
  second model is running just the write phase, and then later on running the
  same job (but with reads instead of writes) to repeat the same IO patterns and
  verify the contents. Both of these methods depend on the write phase being
  completed, as fio otherwise has no idea how much data was written.
<div style="height: 1.00em;">&#x00A0;</div>
With verification triggers, fio supports dumping the current write state to
  local files. Then a subsequent read verify workload can load this state and
  know exactly where to stop. This is useful for testing cases where power is
  cut to a server in a managed fashion, for instance.
<div style="height: 1.00em;">&#x00A0;</div>
A verification trigger consists of two things:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">Storing the write state of each job
<div class="Pp"></div>
Executing a trigger command</div>
<div style="height: 1.00em;">&#x00A0;</div>
The write state is relatively small, on the order of hundreds of bytes to single
  kilobytes. It contains information on the number of completions done, the last
  X completions, etc.
<div style="height: 1.00em;">&#x00A0;</div>
A trigger is invoked either through creation ( <b>touch</b>) of a specified file
  in the system, or through a timeout setting. If fio is run with
  <b>--trigger-file=/tmp/trigger-file</b>, then it will continually check for
  the existence of /tmp/trigger-file. When it sees this file, it will fire off
  the trigger (thus saving state, and executing the trigger command).
<div style="height: 1.00em;">&#x00A0;</div>
For client/server runs, there's both a local and remote trigger. If fio is
  running as a server backend, it will send the job states back to the client
  for safe storage, then execute the remote trigger, if specified. If a local
  trigger is specified, the server will still send back the write state, but the
  client will then execute the trigger.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>Verification trigger example</b>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Lets say we want to run a powercut test on the remote machine 'server'. Our
  write workload is in write-test.fio. We want to cut power to 'server' at some
  point during the run, and we'll run this test from the safety or our local
  machine, 'localbox'. On the server, we'll start the fio backend normally:
<div style="height: 1.00em;">&#x00A0;</div>
server# <b>fio --server</b>
<div style="height: 1.00em;">&#x00A0;</div>
and on the client, we'll fire off the workload:
<div style="height: 1.00em;">&#x00A0;</div>
localbox$ <b>fio --client=server --trigger-file=/tmp/my-trigger
  --trigger-remote=&quot;bash -c &quot;echo b &gt;
  /proc/sysrq-triger&quot;&quot;</b>
<div style="height: 1.00em;">&#x00A0;</div>
We set <b>/tmp/my-trigger</b> as the trigger file, and we tell fio to execute
<div style="height: 1.00em;">&#x00A0;</div>
<b>echo b &gt; /proc/sysrq-trigger</b>
<div style="height: 1.00em;">&#x00A0;</div>
on the server once it has received the trigger and sent us the write state. This
  will work, but it's not <i>really</i> cutting power to the server, it's merely
  abruptly rebooting it. If we have a remote way of cutting power to the server
  through IPMI or similar, we could do that through a local trigger command
  instead. Lets assume we have a script that does IPMI reboot of a given
  hostname, ipmi-reboot. On localbox, we could then have run fio with a local
  trigger instead:
<div style="height: 1.00em;">&#x00A0;</div>
localbox$ <b>fio --client=server --trigger-file=/tmp/my-trigger
  --trigger=&quot;ipmi-reboot server&quot;</b>
<div style="height: 1.00em;">&#x00A0;</div>
For this case, fio would wait for the server to send us the write state, then
  execute 'ipmi-reboot server' when that happened.
<div style="height: 1.00em;">&#x00A0;</div>
</div>
<div class="Pp"></div>
<b>Loading verify state</b>
<div style="margin-left: 5.00ex;">To load store write state, read verification
  job file must contain the verify_state_load option. If that is set, fio will
  load the previously stored state. For a local fio run this is done by loading
  the files directly, and on a client/server run, the server backend will ask
  the client to send the files over and load them from there.
<div style="height: 1.00em;">&#x00A0;</div>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="LOG_FILE_FORMATS"><a class="selflink" href="#LOG_FILE_FORMATS">LOG
  FILE FORMATS</a></h1>
Fio supports a variety of log file formats, for logging latencies, bandwidth,
  and IOPS. The logs share a common format, which looks like this:
<div style="height: 1.00em;">&#x00A0;</div>
<b>time (msec), value, data direction, offset</b>
<div style="height: 1.00em;">&#x00A0;</div>
Time for the log entry is always in milliseconds. The value logged depends on
  the type of log, it will be one of the following:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Latency log</b></dt>
  <dd class="It-tag">Value is in latency in usecs</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Bandwidth log</b></dt>
  <dd class="It-tag">Value is in KB/sec</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>IOPS log</b></dt>
  <dd class="It-tag">Value is in IOPS</dd>
</dl>
<div class="Pp"></div>
Data direction is one of the following:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>0</b></dt>
  <dd class="It-tag">IO is a READ</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>1</b></dt>
  <dd class="It-tag">IO is a WRITE</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>2</b></dt>
  <dd class="It-tag">IO is a TRIM</dd>
</dl>
<div class="Pp"></div>
The <i>offset</i> is the offset, in bytes, from the start of the file, for that
  particular IO. The logging of the offset can be toggled with
  <b>log_offset</b>.
<div style="height: 1.00em;">&#x00A0;</div>
If windowed logging is enabled through <b>log_avg_msec</b>, then fio doesn't log
  individual IOs. Instead of logs the average values over the specified period
  of time. Since <i>data direction</i> and <i>offset</i> are per-IO values, they
  aren't applicable if windowed logging is enabled. If windowed logging is
  enabled and <b>log_max_value</b> is set, then fio logs maximum values in that
  window instead of averages.
<div style="height: 1.00em;">&#x00A0;</div>
For histogram logging the logs look like this:
<div style="height: 1.00em;">&#x00A0;</div>
<b>time (msec), data direction, block-size, bin 0, bin 1, ..., bin 1215</b>
<div style="height: 1.00em;">&#x00A0;</div>
Where 'bin i' gives the frequency of IO requests with a latency falling in the
  i-th bin. See <b>log_hist_coarseness</b> for logging fewer bins.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="CLIENT_/_SERVER"><a class="selflink" href="#CLIENT_/_SERVER">CLIENT
  / SERVER</a></h1>
Normally you would run fio as a stand-alone application on the machine where the
  IO workload should be generated. However, it is also possible to run the
  frontend and backend of fio separately. This makes it possible to have a fio
  server running on the machine(s) where the IO workload should be running,
  while controlling it from another machine.
<div style="height: 1.00em;">&#x00A0;</div>
To start the server, you would do:
<div style="height: 1.00em;">&#x00A0;</div>
<b>fio --server=args</b>
<div style="height: 1.00em;">&#x00A0;</div>
on that machine, where args defines what fio listens to. The arguments are of
  the form 'type:hostname or IP:port'. 'type' is either 'ip' (or ip4) for TCP/IP
  v4, 'ip6' for TCP/IP v6, or 'sock' for a local unix domain socket. 'hostname'
  is either a hostname or IP address, and 'port' is the port to listen to (only
  valid for TCP/IP, not a local socket). Some examples:
<div style="height: 1.00em;">&#x00A0;</div>
1) <b>fio --server</b>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Start a fio server, listening on all interfaces on the default port (8765).
<div style="height: 1.00em;">&#x00A0;</div>
2) <b>fio --server=ip:hostname,4444</b>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Start a fio server, listening on IP belonging to hostname and on port 4444.
<div style="height: 1.00em;">&#x00A0;</div>
3) <b>fio --server=ip6:::1,4444</b>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Start a fio server, listening on IPv6 localhost ::1 and on port 4444.
<div style="height: 1.00em;">&#x00A0;</div>
4) <b>fio --server=,4444</b>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Start a fio server, listening on all interfaces on port 4444.
<div style="height: 1.00em;">&#x00A0;</div>
5) <b>fio --server=1.2.3.4</b>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Start a fio server, listening on IP 1.2.3.4 on the default port.
<div style="height: 1.00em;">&#x00A0;</div>
6) <b>fio --server=sock:/tmp/fio.sock</b>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Start a fio server, listening on the local socket /tmp/fio.sock.
<div style="height: 1.00em;">&#x00A0;</div>
When a server is running, you can connect to it from a client. The client is run
  with:
<div style="height: 1.00em;">&#x00A0;</div>
<b>fio --local-args --client=server --remote-args &lt;job file(s)&gt;</b>
<div style="height: 1.00em;">&#x00A0;</div>
where --local-args are arguments that are local to the client where it is
  running, 'server' is the connect string, and --remote-args and &lt;job
  file(s)&gt; are sent to the server. The 'server' string follows the same
  format as it does on the server side, to allow IP/hostname/socket and port
  strings. You can connect to multiple clients as well, to do that you could
  run:
<div style="height: 1.00em;">&#x00A0;</div>
<b>fio --client=server2 --client=server2 &lt;job file(s)&gt;</b>
<div style="height: 1.00em;">&#x00A0;</div>
If the job file is located on the fio server, then you can tell the server to
  load a local file as well. This is done by using --remote-config:
<div style="height: 1.00em;">&#x00A0;</div>
<b>fio --client=server --remote-config /path/to/file.fio</b>
<div style="height: 1.00em;">&#x00A0;</div>
Then fio will open this local (to the server) job file instead of being passed
  one from the client.
<div style="height: 1.00em;">&#x00A0;</div>
If you have many servers (example: 100 VMs/containers), you can input a pathname
  of a file containing host IPs/names as the parameter value for the --client
  option. For example, here is an example &quot;host.list&quot; file containing
  2 hostnames:
<div style="height: 1.00em;">&#x00A0;</div>
host1.your.dns.domain
<div>&#x00A0;</div>
host2.your.dns.domain
<div style="height: 1.00em;">&#x00A0;</div>
The fio command would then be:
<div style="height: 1.00em;">&#x00A0;</div>
<b>fio --client=host.list &lt;job file&gt;</b>
<div style="height: 1.00em;">&#x00A0;</div>
In this mode, you cannot input server-specific parameters or job files, and all
  servers receive the same job file.
<div style="height: 1.00em;">&#x00A0;</div>
In order to enable fio --client runs utilizing a shared filesystem from multiple
  hosts, fio --client now prepends the IP address of the server to the filename.
  For example, if fio is using directory /mnt/nfs/fio and is writing filename
  fileio.tmp, with a --client hostfile containing two hostnames h1 and h2 with
  IP addresses 192.168.10.120 and 192.168.10.121, then fio will create two
  files:
<div style="height: 1.00em;">&#x00A0;</div>
/mnt/nfs/fio/192.168.10.120.fileio.tmp
<div>&#x00A0;</div>
/mnt/nfs/fio/192.168.10.121.fileio.tmp
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
<b>fio</b> was written by Jens Axboe &lt;jens.axboe@oracle.com&gt;, now Jens
  Axboe &lt;axboe@fb.com&gt;.
<div>&#x00A0;</div>
This man page was written by Aaron Carroll &lt;aaronc@cse.unsw.edu.au&gt; based
  on documentation by Jens Axboe.
<h1 class="Sh" title="Sh" id="REPORTING_BUGS"><a class="selflink" href="#REPORTING_BUGS">REPORTING
  BUGS</a></h1>
Report bugs to the <b>fio</b> mailing list &lt;fio@vger.kernel.org&gt;. See
  <b>README</b>.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
For further documentation see <b>HOWTO</b> and <b>README</b>.
<div>&#x00A0;</div>
Sample jobfiles are available in the <b>examples</b> directory.</div>
<table class="foot">
  <tr>
    <td class="foot-date">December 2014</td>
    <td class="foot-os">User Manual</td>
  </tr>
</table>
</body>
</html>
