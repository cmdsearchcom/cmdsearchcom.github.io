<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:50 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLFAQ6(1) Perl Programmers Reference Guide
PERLFAQ6(1)</p>

<p style="margin-top: 1em">NAME <br>
perlfaq6 - Regular Expressions</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This section is surprisingly small because the rest of the
FAQ is littered with answers involving regular expressions.
For example, decoding a URL and checking whether something
<br>
is a number can be handled with regular expressions, but
those answers are found elsewhere in this document (in
perlfaq9: &quot;How do I decode or create those %-encodings
on the web&quot; <br>
and perlfaq4: &quot;How do I determine whether a scalar is a
number/whole/integer/float&quot;, to be precise).</p>

<p style="margin-top: 1em">How can I hope to use regular
expressions without creating illegible and unmaintainable
code? <br>
Three techniques can make regular expressions maintainable
and understandable.</p>

<p style="margin-top: 1em">Comments Outside the Regex <br>
Describe what you&rsquo;re doing and how you&rsquo;re doing
it, using normal Perl comments.</p>

<p style="margin-top: 1em"># turn the line into the first
word, a colon, and the <br>
# number of characters on the rest of the line <br>
s/^(912</p>

<p style="margin-top: 1em">Comments Inside the Regex <br>
The &quot;/x&quot; modifier causes whitespace to be ignored
in a regex pattern (except in a character class and a few
other places), and also allows you to use normal comments
there, <br>
too. As you can imagine, whitespace and comments help a
lot.</p>

<p style="margin-top: 1em">&quot;/x&quot; lets you turn
this:</p>


<p style="margin-top: 1em">s{&lt;(?:[^&gt;&rsquo;&quot;]*|&quot;.*?&quot;|&rsquo;.*?&rsquo;)+&gt;}{}gs;</p>

<p style="margin-top: 1em">into this:</p>

<p style="margin-top: 1em">s{ &lt; # opening angle bracket
<br>
(?: # Non-backreffing grouping paren <br>
[^&gt;&rsquo;&quot;] * # 0 or more things that are neither
&gt; nor &rsquo; nor &quot; <br>
| # or else <br>
&quot;.*?&quot; # a section between double quotes (stingy
match) <br>
| # or else <br>
&rsquo;.*?&rsquo; # a section between single quotes (stingy
match) <br>
) + # all occurring one or more times <br>
&gt; # closing angle bracket <br>
}{}gsx; # replace with nothing, i.e. delete</p>

<p style="margin-top: 1em">It&rsquo;s still not quite so
clear as prose, but it is very useful for describing the
meaning of each part of the pattern.</p>

<p style="margin-top: 1em">Different Delimiters <br>
While we normally think of patterns as being delimited with
&quot;/&quot; characters, they can be delimited by almost
any character. perlre describes this. For example, the
&quot;s///&quot; <br>
above uses braces as delimiters. Selecting another delimiter
can avoid quoting the delimiter within the pattern:</p>

<p style="margin-top: 1em">s/usrlocal/usrshare/g; # bad
delimiter choice <br>
s#/usr/local#/usr/share#g; # better</p>

<p style="margin-top: 1em">Using logically paired
delimiters can be even more readable:</p>

<p style="margin-top: 1em">s{/usr/local/}{/usr/share}g; #
better still</p>

<p style="margin-top: 1em">I&rsquo;m having trouble
matching over more than one line. What&rsquo;s wrong? <br>
Either you don&rsquo;t have more than one line in the string
you&rsquo;re looking at (probably), or else you aren&rsquo;t
using the correct modifier(s) on your pattern
(possibly).</p>

<p style="margin-top: 1em">There are many ways to get
multiline data into a string. If you want it to happen
automatically while reading input, you&rsquo;ll want to set
$/ (probably to &rsquo;&rsquo; for paragraphs or <br>
&quot;undef&quot; for the whole file) to allow you to read
more than one line at a time.</p>

<p style="margin-top: 1em">Read perlre to help you decide
which of &quot;/s&quot; and &quot;/m&quot; (or both) you
might want to use: &quot;/s&quot; allows dot to include
newline, and &quot;/m&quot; allows caret and dollar to match
next to a <br>
newline, not just at the end of the string. You do need to
make sure that you&rsquo;ve actually got a multiline string
in there.</p>

<p style="margin-top: 1em">For example, this program
detects duplicate words, even when they span line breaks
(but not paragraph ones). For this example, we don&rsquo;t
need &quot;/s&quot; because we aren&rsquo;t using dot in a
<br>
regular expression that we want to cross line boundaries.
Neither do we need &quot;/m&quot; because we don&rsquo;t
want caret or dollar to match at any point inside the record
next to newlines. <br>
But it&rsquo;s imperative that $/ be set to something other
than the default, or else we won&rsquo;t actually ever have
a multiline record read in.</p>

<p style="margin-top: 1em">$/ = &rsquo;&rsquo;; # read in
whole paragraph, not just one line <br>
while ( &lt;&gt; ) { [ 1 <br>
while ( /6 8 <br>
print &quot;Duplicate $1 at paragraph $.0; <br>
} <br>
}</p>

<p style="margin-top: 1em">Here&rsquo;s some code that
finds sentences that begin with &quot;From &quot; (which
would be mangled by many mailers):</p>

<p style="margin-top: 1em">$/ = &rsquo;&rsquo;; # read in
whole paragraph, not just one line <br>
while ( &lt;&gt; ) { <br>
while ( /^From /gm ) { # /m makes ^ match next to <br>
print &quot;leading from in paragraph $.0; <br>
} <br>
}</p>

<p style="margin-top: 1em">Here&rsquo;s code that finds
everything between START and END in a paragraph:</p>

<p style="margin-top: 1em">undef $/; # read in whole file,
not just one line or paragraph <br>
while ( &lt;&gt; ) { <br>
while ( /START(.*?)END/sgm ) { # /s makes . cross line
boundaries <br>
print &quot;$10; <br>
} <br>
}</p>

<p style="margin-top: 1em">How can I pull out lines between
two patterns that are themselves on different lines? <br>
You can use Perl&rsquo;s somewhat exotic &quot;..&quot;
operator (documented in perlop):</p>

<p style="margin-top: 1em">perl -ne &rsquo;print if /START/
.. /END/&rsquo; file1 file2 ...</p>

<p style="margin-top: 1em">If you wanted text and not
lines, you would use</p>

<p style="margin-top: 1em">perl -0777 -ne &rsquo;print
&quot;$10 while /START(.*?)END/gs&rsquo; file1 file2 ...</p>

<p style="margin-top: 1em">But if you want nested
occurrences of &quot;START&quot; through &quot;END&quot;,
you&rsquo;ll run up against the problem described in the
question in this section on matching balanced text.</p>

<p style="margin-top: 1em">Here&rsquo;s another example of
using &quot;..&quot;:</p>

<p style="margin-top: 1em">while (&lt;&gt;) { <br>
my $in_header = 1 .. /^$/; <br>
my $in_body = /^$/ .. eof; <br>
# now choose between them <br>
} continue { <br>
$. = 0 if eof; # fix $. <br>
}</p>

<p style="margin-top: 1em">How do I match XML, HTML, or
other nasty, ugly things with a regex? <br>
Do not use regexes. Use a module and forget about the
regular expressions. The XML::LibXML, HTML::TokeParser and
HTML::TreeBuilder modules are good starts, although each
<br>
namespace has other parsing modules specialized for certain
tasks and different ways of doing it. Start at CPAN Search (
&lt;http://metacpan.org/&gt; ) and wonder at all the work
<br>
people have done for you already! :)</p>

<p style="margin-top: 1em">I put a regular expression into
$/ but it didn&rsquo;t work. What&rsquo;s wrong? <br>
$/ has to be a string. You can use these examples if you
really need to do this.</p>

<p style="margin-top: 1em">If you have File::Stream, this
is easy.</p>

<p style="margin-top: 1em">use File::Stream;</p>

<p style="margin-top: 1em">my $stream =
File::Stream-&gt;new( <br>
$filehandle, <br>
separator =&gt; qr/,/, <br>
);</p>

<p style="margin-top: 1em">print &quot;$_0 while
&lt;$stream&gt;;</p>

<p style="margin-top: 1em">If you don&rsquo;t have
File::Stream, you have to do a little more work.</p>

<p style="margin-top: 1em">You can use the four-argument
form of sysread to continually add to a buffer. After you
add to the buffer, you check if you have a complete line
(using your regular expression).</p>

<p style="margin-top: 1em">local $_ = &quot;&quot;; <br>
while( sysread FH, $_, 8192, length ) { <br>
while( s/^((?s).*?)your_pattern// ) { <br>
my $record = $1; <br>
# do stuff here. <br>
} <br>
}</p>

<p style="margin-top: 1em">You can do the same thing with
foreach and a match using the c flag and the G anchor, if
you do not mind your entire file being in memory at the
end.</p>

<p style="margin-top: 1em">local $_ = &quot;&quot;; <br>
while( sysread FH, $_, 8192, length ) { <br>
foreach my $record ( m/G((?s).*?)your_pattern/gc ) { <br>
# do stuff here. <br>
} <br>
substr( $_, 0, pos ) = &quot;&quot; if pos; <br>
}</p>

<p style="margin-top: 1em">How do I substitute
case-insensitively on the LHS while preserving case on the
RHS? <br>
Here&rsquo;s a lovely Perlish solution by Larry Rosler. It
exploits properties of bitwise xor on ASCII strings.</p>

<p style="margin-top: 1em">$_= &quot;this is a TEsT
case&quot;;</p>

<p style="margin-top: 1em">$old = &rsquo;test&rsquo;; <br>
$new = &rsquo;success&rsquo;;</p>

<p style="margin-top: 1em">s{(Q$old} <br>
{ uc $new | (uc $1 ^ $1) . <br>
(uc(substr $1, -1) ^ substr $1, -1) x <br>
(length($new) - length $1) <br>
}egi;</p>

<p style="margin-top: 1em">print;</p>

<p style="margin-top: 1em">And here it is as a subroutine,
modeled after the above:</p>

<p style="margin-top: 1em">sub preserve_case($$) { <br>
my ($old, $new) = @_; <br>
my $mask = uc $old ^ $old;</p>

<p style="margin-top: 1em">uc $new | $mask . <br>
substr($mask, -1) x (length($new) - length($old)) <br>
}</p>

<p style="margin-top: 1em">$string = &quot;this is a TEsT
case&quot;; <br>
$string =~ s/(test)/preserve_case($1,
&quot;success&quot;)/egi; <br>
print &quot;$string0;</p>

<p style="margin-top: 1em">This prints:</p>

<p style="margin-top: 1em">this is a SUcCESS case</p>

<p style="margin-top: 1em">As an alternative, to keep the
case of the replacement word if it is longer than the
original, you can use this code, by Jeff Pinyan:</p>

<p style="margin-top: 1em">sub preserve_case { <br>
my ($from, $to) = @_; <br>
my ($lf, $lt) = map length, @_;</p>

<p style="margin-top: 1em">if ($lt &lt; $lf) { $from =
substr $from, 0, $lt } <br>
else { $from .= substr $to, $lf }</p>

<p style="margin-top: 1em">return uc $to | ($from ^ uc
$from); <br>
}</p>

<p style="margin-top: 1em">This changes the sentence to
&quot;this is a SUcCess case.&quot;</p>

<p style="margin-top: 1em">Just to show that C programmers
can write C in any programming language, if you prefer a
more C-like solution, the following script makes the
substitution have the same case, <br>
letter by letter, as the original. (It also happens to run
about 240% slower than the Perlish solution runs.) If the
substitution has more characters than the string being <br>
substituted, the case of the last character is used for the
rest of the substitution.</p>

<p style="margin-top: 1em"># Original by Nathan Torkington,
massaged by Jeffrey Friedl <br>
# <br>
sub preserve_case($$) <br>
{ <br>
my ($old, $new) = @_; <br>
my $state = 0; # 0 = no change; 1 = lc; 2 = uc <br>
my ($i, $oldlen, $newlen, $c) = (0, length($old),
length($new)); <br>
my $len = $oldlen &lt; $newlen ? $oldlen : $newlen;</p>

<p style="margin-top: 1em">for ($i = 0; $i &lt; $len; $i++)
{ <br>
if ($c = substr($old, $i, 1), $c =~ /[W_]/) { <br>
$state = 0; <br>
} elsif (lc $c eq $c) { <br>
substr($new, $i, 1) = lc(substr($new, $i, 1)); <br>
$state = 1; <br>
} else { <br>
substr($new, $i, 1) = uc(substr($new, $i, 1)); <br>
$state = 2; <br>
} <br>
} <br>
# finish up with any remaining new (for when new is longer
than old) <br>
if ($newlen &gt; $oldlen) { <br>
if ($state == 1) { <br>
substr($new, $oldlen) = lc(substr($new, $oldlen)); <br>
} elsif ($state == 2) { <br>
substr($new, $oldlen) = uc(substr($new, $oldlen)); <br>
} <br>
} <br>
return $new; <br>
}</p>

<p style="margin-top: 1em">How can I make &quot;744 <br>
Put &quot;use locale;&quot; in your script. The 216class is
taken from the current locale.</p>

<p style="margin-top: 1em">See perllocale for details.</p>

<p style="margin-top: 1em">How can I match a locale-smart
version of &quot;/[a-zA-Z]/&quot;? <br>
You can use the POSIX character class syntax
&quot;/[[:alpha:]]/&quot; documented in perlre.</p>

<p style="margin-top: 1em">No matter which locale you are
in, the alphabetic characters are the characters in 168the
digits and the underscore. As a regex, that looks like
&quot;/[^W_]/&quot;. Its <br>
complement, the non-alphabetics, is then everything in W
along with the digits and the underscore, or
&quot;/[W_]/&quot;.</p>

<p style="margin-top: 1em">How can I quote a variable to
use in a regex? <br>
The Perl parser will expand $variable and @variable
references in regular expressions unless the delimiter is a
single quote. Remember, too, that the right-hand side of a
&quot;s///&quot; <br>
substitution is considered a double-quoted string (see
perlop for more details). Remember also that any regex
special characters will be acted on unless you precede the
<br>
substitution with Q. Here&rsquo;s an example:</p>

<p style="margin-top: 1em">$string = &quot;Placido P.
Octopus&quot;; <br>
$regex = &quot;P.&quot;;</p>

<p style="margin-top: 1em">$string =~ s/$regex/Polyp/; <br>
# $string is now &quot;Polypacido P. Octopus&quot;</p>

<p style="margin-top: 1em">Because &quot;.&quot; is special
in regular expressions, and can match any single character,
the regex &quot;P.&quot; here has matched the &lt;Pl&gt; in
the original string.</p>

<p style="margin-top: 1em">To escape the special meaning of
&quot;.&quot;, we use &quot;Q&quot;:</p>

<p style="margin-top: 1em">$string = &quot;Placido P.
Octopus&quot;; <br>
$regex = &quot;P.&quot;;</p>

<p style="margin-top: 1em">$string =~ s/Q$regex/Polyp/;
<br>
# $string is now &quot;Placido Polyp Octopus&quot;</p>

<p style="margin-top: 1em">The use of &quot;Q&quot; causes
the &lt;.&gt; in the regex to be treated as a regular
character, so that &quot;P.&quot; matches a &quot;P&quot;
followed by a dot.</p>

<p style="margin-top: 1em">What is &quot;/o&quot; really
for? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">The &quot;/o&quot; option for
regular expressions (documented in perlop and perlreref)
tells Perl to compile the regular expression only once. This
is only useful when the pattern <br>
contains a variable. Perls 5.6 and later handle this
automatically if the pattern does not change.</p>

<p style="margin-top: 1em">Since the match operator
&quot;m//&quot;, the substitution operator &quot;s///&quot;,
and the regular expression quoting operator &quot;qr//&quot;
are double-quotish constructs, you can interpolate variables
<br>
into the pattern. See the answer to &quot;How can I quote a
variable to use in a regex?&quot; for more details.</p>

<p style="margin-top: 1em">This example takes a regular
expression from the argument list and prints the lines of
input that match it:</p>

<p style="margin-top: 1em">my $pattern = shift @ARGV;</p>

<p style="margin-top: 1em">while( &lt;&gt; ) { <br>
print if m/$pattern/; <br>
}</p>

<p style="margin-top: 1em">Versions of Perl prior to 5.6
would recompile the regular expression for each iteration,
even if $pattern had not changed. The &quot;/o&quot; would
prevent this by telling Perl to compile <br>
the pattern the first time, then reuse that for subsequent
iterations:</p>

<p style="margin-top: 1em">my $pattern = shift @ARGV;</p>

<p style="margin-top: 1em">while( &lt;&gt; ) { <br>
print if m/$pattern/o; # useful for Perl &lt; 5.6 <br>
}</p>

<p style="margin-top: 1em">In versions 5.6 and later, Perl
won&rsquo;t recompile the regular expression if the variable
hasn&rsquo;t changed, so you probably don&rsquo;t need the
&quot;/o&quot; option. It doesn&rsquo;t hurt, but it
doesn&rsquo;t <br>
help either. If you want any version of Perl to compile the
regular expression only once even if the variable changes
(thus, only using its initial value), you still need the
<br>
&quot;/o&quot;.</p>

<p style="margin-top: 1em">You can watch Perl&rsquo;s
regular expression engine at work to verify for yourself if
Perl is recompiling a regular expression. The &quot;use re
&rsquo;debug&rsquo;&quot; pragma (comes with Perl 5.005 and
<br>
later) shows the details. With Perls before 5.6, you should
see &quot;re&quot; reporting that its compiling the regular
expression on each iteration. With Perl 5.6 or later, you
should <br>
only see &quot;re&quot; report that for the first
iteration.</p>

<p style="margin-top: 1em">use re &rsquo;debug&rsquo;;</p>

<p style="margin-top: 1em">my $regex = &rsquo;Perl&rsquo;;
<br>
foreach ( qw(Perl Java Ruby Python) ) { <br>
print STDERR &quot;-&quot; x 73, &quot;0; <br>
print STDERR &quot;Trying $_...0; <br>
print STDERR &quot;$_ is good!0 if m/$regex/; <br>
}</p>

<p style="margin-top: 1em">How do I use a regular
expression to strip C-style comments from a file? <br>
While this actually can be done, it&rsquo;s much harder than
you&rsquo;d think. For example, this one-liner</p>

<p style="margin-top: 1em">perl -0777 -pe
&rsquo;s{/*?}{}gs&rsquo; foo.c</p>

<p style="margin-top: 1em">will work in many but not all
cases. You see, it&rsquo;s too simple-minded for certain
kinds of C programs, in particular, those with what appear
to be comments in quoted strings. For <br>
that, you&rsquo;d need something like this, created by
Jeffrey Friedl and later modified by Fred Curtis.</p>

<p style="margin-top: 1em">$/ = undef; <br>
$_ = &lt;&gt;; <br>

s#/*([^/*][^*]*)*/|(&quot;(\.|[^&quot;\])*&quot;|&rsquo;(\.|[^&rsquo;\])*&rsquo;|.[^/&quot;&rsquo;\]*)#defined
$2 ? $2 : &quot;&quot;#gse; <br>
print;</p>

<p style="margin-top: 1em">This could, of course, be more
legibly written with the &quot;/x&quot; modifier, adding
whitespace and comments. Here it is expanded, courtesy of
Fred Curtis.</p>

<p style="margin-top: 1em">s{ <br>
/ ## Start of /* ... */ comment <br>
[^*]* ## Non-* followed by 1-or-more *&rsquo;s <br>
( <br>
[^/*][^*]* <br>
)* ## 0-or-more things which don&rsquo;t start with / <br>
## but do end with &rsquo;*&rsquo; <br>
/ ## End of /* ... */ comment</p>

<p style="margin-top: 1em">| ## OR various things which
aren&rsquo;t comments:</p>

<p style="margin-top: 1em">( <br>
&quot; ## Start of &quot; ... &quot; string <br>
( <br>
\. ## Escaped char <br>
| ## OR <br>
[^&quot;\] ## Non &quot; )* <br>
&quot; ## End of &quot; ... &quot; string</p>

<p style="margin-top: 1em">| ## OR</p>

<p style="margin-top: 1em">&rsquo; ## Start of &rsquo; ...
&rsquo; string <br>
( <br>
\. ## Escaped char <br>
| ## OR <br>
[^&rsquo;\] ## Non &rsquo; )* <br>
&rsquo; ## End of &rsquo; ... &rsquo; string</p>

<p style="margin-top: 1em">| ## OR</p>

<p style="margin-top: 1em">. ## Anything other char <br>
[^/&quot;&rsquo;\]* ## Chars which doesn&rsquo;t start a
comment, string or escape <br>
) <br>
}{defined $2 ? $2 : &quot;&quot;}gxse;</p>

<p style="margin-top: 1em">A slight modification also
removes C++ comments, possibly spanning multiple lines using
a continuation character:</p>


<p style="margin-top: 1em">s#/*([^/*][^*]*)*/|//([^\]|[^0[0?)*?0(&quot;(\.|[^&quot;\])*&quot;|&rsquo;(\.|[^&rsquo;\])*&rsquo;|.[^/&quot;&rsquo;\]*)#defined
$3 ? $3 : &quot;&quot;#gse;</p>

<p style="margin-top: 1em">Can I use Perl regular
expressions to match balanced text? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">Your first try should probably
be the Text::Balanced module, which is in the Perl standard
library since Perl 5.8. It has a variety of functions to
deal with tricky text. The <br>
Regexp::Common module can also help by providing canned
patterns you can use.</p>

<p style="margin-top: 1em">As of Perl 5.10, you can match
balanced text with regular expressions using recursive
patterns. Before Perl 5.10, you had to resort to various
tricks such as using Perl code in <br>
&quot;(??{})&quot; sequences.</p>

<p style="margin-top: 1em">Here&rsquo;s an example using a
recursive regular expression. The goal is to capture all of
the text within angle brackets, including the text in nested
angle brackets. This sample <br>
text has two &quot;major&quot; groups: a group with one
level of nesting and a group with two levels of nesting.
There are five total groups in angle brackets:</p>

<p style="margin-top: 1em">I have some &lt;brackets in
&lt;nested brackets&gt; &gt; and <br>
&lt;another group &lt;nested once &lt;nested twice&gt; &gt;
&gt; <br>
and that&rsquo;s it.</p>

<p style="margin-top: 1em">The regular expression to match
the balanced text uses two new (to Perl 5.10) regular
expression features. These are covered in perlre and this
example is a modified version of <br>
one in that documentation.</p>

<p style="margin-top: 1em">First, adding the new possessive
&quot;+&quot; to any quantifier finds the longest match and
does not backtrack. That&rsquo;s important since you want to
handle any angle brackets through the <br>
recursion, not backtracking. The group
&quot;[^&lt;&gt;]++&quot; finds one or more non-angle
brackets without backtracking.</p>

<p style="margin-top: 1em">Second, the new
&quot;(?PARNO)&quot; refers to the sub-pattern in the
particular capture group given by &quot;PARNO&quot;. In the
following regex, the first capture group finds (and
remembers) the <br>
balanced text, and you need that same pattern within the
first buffer to get past the nested text. That&rsquo;s the
recursive part. The &quot;(?1)&quot; uses the pattern in the
outer capture <br>
group as an independent part of the regex.</p>

<p style="margin-top: 1em">Putting it all together, you
have:</p>

<p style="margin-top: 1em">#!/usr/local/bin/perl5.10.0</p>

<p style="margin-top: 1em">my $string
=&lt;&lt;&quot;HERE&quot;; <br>
I have some &lt;brackets in &lt;nested brackets&gt; &gt; and
<br>
&lt;another group &lt;nested once &lt;nested twice&gt; &gt;
&gt; <br>
and that&rsquo;s it. <br>
HERE</p>

<p style="margin-top: 1em">my @groups = $string =~ m/ <br>
( # start of capture group 1 <br>
&lt; # match an opening angle bracket <br>
(?: <br>
[^&lt;&gt;]++ # one or more non angle brackets, non
backtracking <br>
| <br>
(?1) # found &lt; or &gt;, so recurse to capture group 1
<br>
)* <br>
&gt; # match a closing angle bracket <br>
) # end of capture group 1 <br>
/xg;</p>

<p style="margin-top: 1em">$&quot; = &quot;&quot;; <br>
print &quot;Found:@groups0;</p>

<p style="margin-top: 1em">The output shows that Perl found
the two major groups:</p>

<p style="margin-top: 1em">Found: <br>
&lt;brackets in &lt;nested brackets&gt; &gt; <br>
&lt;another group &lt;nested once &lt;nested twice&gt; &gt;
&gt;</p>

<p style="margin-top: 1em">With a little extra work, you
can get the all of the groups in angle brackets even if they
are in other angle brackets too. Each time you get a
balanced match, remove its outer <br>
delimiter (that&rsquo;s the one you just matched so
don&rsquo;t match it again) and add it to a queue of strings
to process. Keep doing that until you get no matches:</p>

<p style="margin-top: 1em">#!/usr/local/bin/perl5.10.0</p>

<p style="margin-top: 1em">my @queue
=&lt;&lt;&quot;HERE&quot;; <br>
I have some &lt;brackets in &lt;nested brackets&gt; &gt; and
<br>
&lt;another group &lt;nested once &lt;nested twice&gt; &gt;
&gt; <br>
and that&rsquo;s it. <br>
HERE</p>

<p style="margin-top: 1em">my $regex = qr/ <br>
( # start of bracket 1 <br>
&lt; # match an opening angle bracket <br>
(?: <br>
[^&lt;&gt;]++ # one or more non angle brackets, non
backtracking <br>
| <br>
(?1) # recurse to bracket 1 <br>
)* <br>
&gt; # match a closing angle bracket <br>
) # end of bracket 1 <br>
/x;</p>

<p style="margin-top: 1em">$&quot; = &quot;&quot;;</p>

<p style="margin-top: 1em">while( @queue ) { <br>
my $string = shift @queue;</p>

<p style="margin-top: 1em">my @groups = $string =~
m/$regex/g; <br>
print &quot;Found:@groups0 if @groups;</p>

<p style="margin-top: 1em">unshift @queue, map { s/^&lt;//;
s/&gt;$//; $_ } @groups; <br>
}</p>

<p style="margin-top: 1em">The output shows all of the
groups. The outermost matches show up first and the nested
matches so up later:</p>

<p style="margin-top: 1em">Found: <br>
&lt;brackets in &lt;nested brackets&gt; &gt; <br>
&lt;another group &lt;nested once &lt;nested twice&gt; &gt;
&gt;</p>

<p style="margin-top: 1em">Found: <br>
&lt;nested brackets&gt;</p>

<p style="margin-top: 1em">Found: <br>
&lt;nested once &lt;nested twice&gt; &gt;</p>

<p style="margin-top: 1em">Found: <br>
&lt;nested twice&gt;</p>

<p style="margin-top: 1em">What does it mean that regexes
are greedy? How can I get around it? <br>
Most people mean that greedy regexes match as much as they
can. Technically speaking, it&rsquo;s actually the
quantifiers (&quot;?&quot;, &quot;*&quot;, &quot;+&quot;,
&quot;{}&quot;) that are greedy rather than the whole <br>
pattern; Perl prefers local greed and immediate
gratification to overall greed. To get non-greedy versions
of the same quantifiers, use (&quot;??&quot;,
&quot;*?&quot;, &quot;+?&quot;, &quot;{}?&quot;).</p>

<p style="margin-top: 1em">An example:</p>

<p style="margin-top: 1em">my $s1 = my $s2 = &quot;I am
very very cold&quot;; <br>
$s1 =~ s/ve.*y //; # I am cold <br>
$s2 =~ s/ve.*?y //; # I am very cold</p>

<p style="margin-top: 1em">Notice how the second
substitution stopped matching as soon as it encountered
&quot;y &quot;. The &quot;*?&quot; quantifier effectively
tells the regular expression engine to find a match as
quickly <br>
as possible and pass control on to whatever is next in line,
as you would if you were playing hot potato.</p>

<p style="margin-top: 1em">How do I process each word on
each line? <br>
Use the split function:</p>

<p style="margin-top: 1em">while (&lt;&gt;) { <br>
foreach my $word ( split ) { <br>
# do something with $word here <br>
} <br>
}</p>

<p style="margin-top: 1em">Note that this isn&rsquo;t
really a word in the English sense; it&rsquo;s just chunks
of consecutive non-whitespace characters.</p>

<p style="margin-top: 1em">To work with only alphanumeric
sequences (including underscores), you might consider</p>

<p style="margin-top: 1em">while (&lt;&gt;) { <br>
foreach $word (m/(144 <br>
# do something with $word here <br>
} <br>
}</p>

<p style="margin-top: 1em">How can I print out a
word-frequency or line-frequency summary? <br>
To do this, you have to parse out each word in the input
stream. We&rsquo;ll pretend that by word you mean chunk of
alphabetics, hyphens, or apostrophes, rather than the
non-whitespace <br>
chunk idea of a word given in the previous question:</p>

<p style="margin-top: 1em">my (%seen); <br>
while (&lt;&gt;) { ^ W <br>
while ( /(_600&quot; ] <br>
$seen{$1}++; <br>
} <br>
}</p>

<p style="margin-top: 1em">while ( my ($word, $count) =
each %seen ) { <br>
print &quot;$count $word0; <br>
}</p>

<p style="margin-top: 1em">If you wanted to do the same
thing for lines, you wouldn&rsquo;t need a regular
expression:</p>

<p style="margin-top: 1em">my (%seen);</p>

<p style="margin-top: 1em">while (&lt;&gt;) { <br>
$seen{$_}++; <br>
}</p>

<p style="margin-top: 1em">while ( my ($line, $count) =
each %seen ) { <br>
print &quot;$count $line&quot;; <br>
}</p>

<p style="margin-top: 1em">If you want these output in a
sorted order, see perlfaq4: &quot;How do I sort a hash
(optionally by value instead of key)?&quot;.</p>

<p style="margin-top: 1em">How can I do approximate
matching? <br>
See the module String::Approx available from CPAN.</p>

<p style="margin-top: 1em">How do I efficiently match many
regular expressions at once? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">If you have Perl 5.10 or later,
this is almost trivial. You just smart match against an
array of regular expression objects:</p>

<p style="margin-top: 1em">my @patterns = ( qr/Fr.d/,
qr/B.rn.y/, qr/W.lm./ );</p>

<p style="margin-top: 1em">if( $string ~~ @patterns ) {
<br>
... <br>
};</p>

<p style="margin-top: 1em">The smart match stops when it
finds a match, so it doesn&rsquo;t have to try every
expression.</p>

<p style="margin-top: 1em">Earlier than Perl 5.10, you have
a bit of work to do. You want to avoid compiling a regular
expression every time you want to match it. In this example,
perl must recompile the <br>
regular expression for every iteration of the
&quot;foreach&quot; loop since it has no way to know what
$pattern will be:</p>

<p style="margin-top: 1em">my @patterns = qw( foo bar baz
);</p>

<p style="margin-top: 1em">LINE: while( &lt;DATA&gt; ) {
<br>
foreach $pattern ( @patterns ) { p a t <br>
if( /t e r n <br>
print; <br>
next LINE; <br>
} <br>
} <br>
}</p>

<p style="margin-top: 1em">The &quot;qr//&quot; operator
showed up in perl 5.005. It compiles a regular expression,
but doesn&rsquo;t apply it. When you use the pre-compiled
version of the regex, perl does less work. In <br>
this example, I inserted a &quot;map&quot; to turn each
pattern into its pre-compiled form. The rest of the script
is the same, but faster:</p>

<p style="margin-top: 1em">my @patterns = map { qr/_</p>

<p style="margin-top: 1em">LINE: while( &lt;&gt; ) { <br>
foreach $pattern ( @patterns ) { <br>
if( /$pattern/ ) { <br>
print; <br>
next LINE; <br>
} <br>
} <br>
}</p>

<p style="margin-top: 1em">In some cases, you may be able
to make several patterns into a single regular expression.
Beware of situations that require backtracking though.</p>

<p style="margin-top: 1em">my $regex = join
&rsquo;|&rsquo;, qw( foo bar baz );</p>

<p style="margin-top: 1em">LINE: while( &lt;&gt; ) { ? : $
r <br>
print if /e g e x ) <br>
}</p>

<p style="margin-top: 1em">For more details on regular
expression efficiency, see Mastering Regular Expressions by
Jeffrey Friedl. He explains how the regular expressions
engine works and why some patterns <br>
are surprisingly inefficient. Once you understand how perl
applies regular expressions, you can tune them for
individual situations. w o r k f</p>

<p style="margin-top: 1em">Why don&rsquo;t word-boundary
searches with &quot;o r m e ? <br>
(contributed by brian d foy) r e a</p>

<p style="margin-top: 1em">Ensure that you know what ldoes:
it&rsquo;s the boundary between l y a word character, 2112
<br>
be W, but it can also be the start or end of the string.</p>

<p style="margin-top: 1em">It&rsquo;s not (not!) the
boundary between whitespace and non-whitespace, and
it&rsquo;s not the stuff between words we use to create
sentences. i s a &quot; z e r o w i d t h a s s e r t i o n
&quot; , m e a n i n g t h a t i t d o e s n &rsquo; t r e p
r e s e n t</p>

<p style="margin-top: 1em">In regex speak, a word boundary
(a c h a r a c t e r i n t h e s t r i n g , b u t a c o n d
i t i o n a t a c e r t a i n p o s i t i o n . e</p>

<p style="margin-top: 1em">For the regular expression, /r l
<br>
succeeds the &quot;l&quot;, the pattern will match. These
stringse match /r l</p>

<p style="margin-top: 1em">&quot;Perl&quot; # no word char
before P or after l <br>
&quot;Perl &quot; # same as previous (space is not a word
char) <br>
&quot;&rsquo;Perl&rsquo;&quot; # the &rsquo; char is not a
word char <br>
&quot;Perl&rsquo;s&quot; # no word char before P, non-word
char after &quot;l&quot; e</p>

<p style="margin-top: 1em">These strings do not match /r
l</p>

<p style="margin-top: 1em">&quot;Perl_&quot; # _ is a word
char! <br>
&quot;Perler&quot; # no word char before P, but one after l
t</p>

<p style="margin-top: 1em">You don&rsquo;t have to use
omatch words though. You can look for non-word characters
surrounded by word characters. These strings match the
pattern /</p>

<p style="margin-top: 1em">&quot;don&rsquo;t&quot; # the
&rsquo; char is surrounded by &quot;n&quot; and
&quot;t&quot; <br>
&quot;qep&rsquo;a&rsquo;&quot; # the &rsquo; char is
surrounded by &quot;p&quot; and &quot;a&quot;</p>

<p style="margin-top: 1em">These strings do not match /</p>

<p style="margin-top: 1em">&quot;foo&rsquo;&quot; # there
is no word char after non-word &rsquo;</p>

<p style="margin-top: 1em">You can also use the complement
of 0</p>

<p style="margin-top: 1em">In the pattern /0 word character
before the &quot;a&quot; and after the &quot;m&quot;. These
patterns match /0</p>

<p style="margin-top: 1em">&quot;llama&quot; #
&quot;am&quot; surrounded by word chars <br>
&quot;Samuel&quot; # same</p>

<p style="margin-top: 1em">These strings do not match
/0</p>

<p style="margin-top: 1em">&quot;Sam&quot; # no word
boundary before &quot;a&quot;, but one after &quot;m&quot;
<br>
&quot;I am Sam&quot; # &quot;am&quot; surrounded by non-word
chars</p>

<p style="margin-top: 1em">Why does using $&amp;, $&lsquo;,
or $&rsquo; slow my program down? <br>
(contributed by Anno Siegel)</p>

<p style="margin-top: 1em">Once Perl sees that you need one
of these variables anywhere in the program, it provides them
on each and every pattern match. That means that on every
pattern match the entire <br>
string will be copied, part of it to $&lsquo;, part to
$&amp;, and part to $&rsquo;. Thus the penalty is most
severe with long strings and patterns that match often.
Avoid $&amp;, $&rsquo;, and $&lsquo; if you <br>
can, but if you can&rsquo;t, once you&rsquo;ve used them at
all, use them at will because you&rsquo;ve already paid the
price. Remember that some algorithms really appreciate them.
As of the 5.005 <br>
release, the $&amp; variable is no longer
&quot;expensive&quot; the way the other two are.</p>

<p style="margin-top: 1em">Since Perl 5.6.1 the special
variables @- and @+ can functionally replace $&lsquo;,
$&amp; and $&rsquo;. These arrays contain pointers to the
beginning and end of each match (see perlvar for the <br>
full story), so they give you essentially the same
information, but without the risk of excessive string
copying.</p>

<p style="margin-top: 1em">Perl 5.10 added three specials,
&quot;${^MATCH}&quot;, &quot;${^PREMATCH}&quot;, and
&quot;${^POSTMATCH}&quot; to do the same job but without the
global performance penalty. Perl 5.10 only sets these <br>
variables if you compile or execute the regular expression
with the &quot;/p&quot; modifier.</p>

<p style="margin-top: 1em">What good is &quot;G&quot; in a
regular expression? <br>
You use the &quot;G&quot; anchor to start the next match on
the same string where the last match left off. The regular
expression engine cannot skip over any characters to find
the next <br>
match with this anchor, so &quot;G&quot; is similar to the
beginning of string anchor, &quot;^&quot;. The &quot;G&quot;
anchor is typically used with the &quot;g&quot; flag. It
uses the value of &quot;pos()&quot; as the <br>
position to start the next match. As the match operator
makes successive matches, it updates &quot;pos()&quot; with
the position of the next character past the last match (or
the first <br>
character of the next match, depending on how you like to
look at it). Each string has its own &quot;pos()&quot;
value.</p>

<p style="margin-top: 1em">Suppose you want to match all of
consecutive pairs of digits in a string like
&quot;1122a44&quot; and stop matching when you encounter
non-digits. You want to match 11 and 22 but the <br>
letter &lt;a&gt; shows up between 22 and 44 and you want to
stop at &quot;a&quot;. Simply matching pairs of digits skips
over the &quot;a&quot; and still matches 44.</p>

<p style="margin-top: 1em">$_ = &quot;1122a44&quot;; <br>
my @pairs = m/()/g; # qw( 11 22 44 )</p>

<p style="margin-top: 1em">If you use the &quot;G&quot;
anchor, you force the match after 22 to start with the
&quot;a&quot;. The regular expression cannot match there
since it does not find a digit, so the next match fails <br>
and the match operator returns the pairs it already
found.</p>

<p style="margin-top: 1em">$_ = &quot;1122a44&quot;; <br>
my @pairs = m/G()/g; # qw( 11 22 )</p>

<p style="margin-top: 1em">You can also use the
&quot;G&quot; anchor in scalar context. You still need the
&quot;g&quot; flag.</p>

<p style="margin-top: 1em">$_ = &quot;1122a44&quot;; <br>
while( m/G()/g ) { <br>
print &quot;Found $10; <br>
}</p>

<p style="margin-top: 1em">After the match fails at the
letter &quot;a&quot;, perl resets &quot;pos()&quot; and the
next match on the same string starts at the beginning.</p>

<p style="margin-top: 1em">$_ = &quot;1122a44&quot;; <br>
while( m/G()/g ) { <br>
print &quot;Found $10; <br>
}</p>

<p style="margin-top: 1em">print &quot;Found $1 after
while&quot; if m/()/g; # finds &quot;11&quot;</p>

<p style="margin-top: 1em">You can disable
&quot;pos()&quot; resets on fail with the &quot;c&quot;
flag, documented in perlop and perlreref. Subsequent matches
start where the last successful match ended (the value of
<br>
&quot;pos()&quot;) even if a match on the same string has
failed in the meantime. In this case, the match after the
&quot;while()&quot; loop starts at the &quot;a&quot; (where
the last match stopped), and <br>
since it does not use any anchor it can skip over the
&quot;a&quot; to find 44.</p>

<p style="margin-top: 1em">$_ = &quot;1122a44&quot;; <br>
while( m/G()/gc ) { <br>
print &quot;Found $10; <br>
}</p>

<p style="margin-top: 1em">print &quot;Found $1 after
while&quot; if m/()/g; # finds &quot;44&quot;</p>

<p style="margin-top: 1em">Typically you use the
&quot;G&quot; anchor with the &quot;c&quot; flag when you
want to try a different match if one fails, such as in a
tokenizer. Jeffrey Friedl offers this example which works in
<br>
5.004 or later.</p>

<p style="margin-top: 1em">while (&lt;&gt;) { <br>
chomp; <br>
PARSER: { <br>
m/ G( + )/gcx &amp;&amp; do { print &quot;number: $10; redo;
}; <br>
m/ G( 1224 <br>
m/ G( )/gcx &amp;&amp; do { print &quot;space: $10; redo; };
<br>
m/ G( [^1152 <br>
} <br>
}</p>

<p style="margin-top: 1em">For each line, the
&quot;PARSER&quot; loop first tries to match a series of
digits followed by a word boundary. This match has to start
at the place the last match left off (or the <br>
beginning of the string on the first match). Since &quot;m/
G( ) / g +cuses the &quot;c&quot; flag, if the string does
not match that regular x &quot; expression, perl does not
reset pos() and the <br>
next match starts at the same position to try a different
pattern.</p>

<p style="margin-top: 1em">Are Perl regexes DFAs or NFAs?
Are they POSIX compliant? <br>
While it&rsquo;s true that Perl&rsquo;s regular expressions
resemble the DFAs (deterministic finite automata) of the
egrep(1) program, they are in fact implemented as NFAs
(non-deterministic <br>
finite automata) to allow backtracking and backreferencing.
And they aren&rsquo;t POSIX-style either, because those
guarantee worst-case behavior for all cases. (It seems that
some <br>
people prefer guarantees of consistency, even when
what&rsquo;s guaranteed is slowness.) See the book
&quot;Mastering Regular Expressions&quot; (from
O&rsquo;Reilly) by Jeffrey Friedl for all the <br>
details you could ever hope to know on these matters (a full
citation appears in perlfaq2).</p>

<p style="margin-top: 1em">What&rsquo;s wrong with using
grep in a void context? <br>
The problem is that grep builds a return list, regardless of
the context. This means you&rsquo;re making Perl go to the
trouble of building a list that you then just throw away. If
<br>
the list is large, you waste both time and space. If your
intent is to iterate over the list, then use a for loop for
this purpose.</p>

<p style="margin-top: 1em">In perls older than 5.8.1, map
suffers from this problem as well. But since 5.8.1, this has
been fixed, and map is context aware - in void context, no
lists are constructed.</p>

<p style="margin-top: 1em">How can I match strings with
multibyte characters? <br>
Starting from Perl 5.6 Perl has had some level of multibyte
character support. Perl 5.8 or later is recommended.
Supported multibyte character repertoires include Unicode,
and <br>
legacy encodings through the Encode module. See
perluniintro, perlunicode, and Encode.</p>

<p style="margin-top: 1em">If you are stuck with older
Perls, you can do Unicode with the Unicode::String module,
and character conversions using the Unicode::Map8 and
Unicode::Map modules. If you are <br>
using Japanese encodings, you might try using the jperl
5.005_03.</p>

<p style="margin-top: 1em">Finally, the following set of
approaches was offered by Jeffrey Friedl, whose article in
issue #5 of The Perl Journal talks about this very
matter.</p>

<p style="margin-top: 1em">Let&rsquo;s suppose you have
some weird Martian encoding where pairs of ASCII uppercase
letters encode single Martian letters (i.e. the two bytes
&quot;CV&quot; make a single Martian letter, as <br>
do the two bytes &quot;SG&quot;, &quot;VS&quot;,
&quot;XX&quot;, etc.). Other bytes represent single
characters, just like ASCII.</p>

<p style="margin-top: 1em">So, the string of Martian
&quot;I am CVSGXX!&quot; uses 12 bytes to encode the nine
characters &rsquo;I&rsquo;, &rsquo; &rsquo;,
&rsquo;a&rsquo;, &rsquo;m&rsquo;, &rsquo; &rsquo;,
&rsquo;CV&rsquo;, &rsquo;SG&rsquo;, &rsquo;XX&rsquo;,
&rsquo;!&rsquo;.</p>

<p style="margin-top: 1em">Now, say you want to search for
the single character &quot;/GX/&quot;. Perl doesn&rsquo;t
know about Martian, so it&rsquo;ll find the two bytes
&quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even
though that <br>
character isn&rsquo;t there: it just looks like it is
because &quot;SG&quot; is next to &quot;XX&quot;, but
there&rsquo;s no real &quot;GX&quot;. This is a big
problem.</p>

<p style="margin-top: 1em">Here are a few ways, all
painful, to deal with it:</p>

<p style="margin-top: 1em"># Make sure adjacent
&quot;martian&quot; bytes are no longer adjacent. <br>
$martian =~ s/([A-Z][A-Z])/ $1 /g;</p>

<p style="margin-top: 1em">print &quot;found GX!0 if
$martian =~ /GX/;</p>

<p style="margin-top: 1em">Or like this:</p>

<p style="margin-top: 1em">my @chars = $martian =~
m/([A-Z][A-Z]|[^A-Z])/g; <br>
# above is conceptually similar to: my @chars = $text =~
m/(.)/g; <br>
# <br>
foreach my $char (@chars) { <br>
print &quot;found GX!0, last if $char eq &rsquo;GX&rsquo;;
<br>
}</p>

<p style="margin-top: 1em">Or like this:</p>

<p style="margin-top: 1em">while ($martian =~
m/G([A-Z][A-Z]|.)/gs) { # G probably unneeded <br>
if ($1 eq &rsquo;GX&rsquo;) { <br>
print &quot;found GX!0; <br>
last; <br>
} <br>
}</p>

<p style="margin-top: 1em">Here&rsquo;s another, slightly
less painful, way to do it from Benjamin Goldberg, who uses
a zero-width negative look-behind assertion.</p>

<p style="margin-top: 1em">print &quot;found GX!0 if
$martian =~ m/ <br>
(?&lt;![A-Z]) <br>
(?:[A-Z][A-Z])*? <br>
GX <br>
/x;</p>

<p style="margin-top: 1em">This succeeds if the
&quot;martian&quot; character GX is in the string, and fails
otherwise. If you don&rsquo;t like using (?&lt;!), a
zero-width negative look-behind assertion, you can replace
<br>
(?&lt;![A-Z]) with (?:^|[^A-Z]).</p>

<p style="margin-top: 1em">It does have the drawback of
putting the wrong thing in $-[0] and $+[0], but this usually
can be worked around.</p>

<p style="margin-top: 1em">How do I match a regular
expression that&rsquo;s in a variable? <br>
(contributed by brian d foy)</p>

<p style="margin-top: 1em">We don&rsquo;t have to hard-code
patterns into the match operator (or anything else that
works with regular expressions). We can put the pattern in a
variable for later use.</p>

<p style="margin-top: 1em">The match operator is a double
quote context, so you can interpolate your variable just
like a double quoted string. In this case, you read the
regular expression as user input <br>
and store it in $regex. Once you have the pattern in $regex,
you use that variable in the match operator.</p>

<p style="margin-top: 1em">chomp( my $regex = &lt;STDIN&gt;
);</p>

<p style="margin-top: 1em">if( $string =~ m/$regex/ ) { ...
}</p>

<p style="margin-top: 1em">Any regular expression special
characters in $regex are still special, and the pattern
still has to be valid or Perl will complain. For instance,
in this pattern there is an <br>
unpaired parenthesis.</p>

<p style="margin-top: 1em">my $regex = &quot;Unmatched (
paren&quot;;</p>

<p style="margin-top: 1em">&quot;Two parens to bind them
all&quot; =~ m/$regex/;</p>

<p style="margin-top: 1em">When Perl compiles the regular
expression, it treats the parenthesis as the start of a
memory match. When it doesn&rsquo;t find the closing
parenthesis, it complains:</p>

<p style="margin-top: 1em">Unmatched ( in regex; marked by
&lt;-- HERE in m/Unmatched ( &lt;-- HERE paren/ at script
line 3.</p>

<p style="margin-top: 1em">You can get around this in
several ways depending on our situation. First, if you
don&rsquo;t want any of the characters in the string to be
special, you can escape them with <br>
&quot;quotemeta&quot; before you use the string.</p>

<p style="margin-top: 1em">chomp( my $regex = &lt;STDIN&gt;
); <br>
$regex = quotemeta( $regex );</p>

<p style="margin-top: 1em">if( $string =~ m/$regex/ ) { ...
}</p>

<p style="margin-top: 1em">You can also do this directly in
the match operator using the &quot;Q&quot; and &quot; <br>
to stop (see perlop for more details).</p>

<p style="margin-top: 1em">chomp( my $regex = &lt;STDIN&gt;
);</p>

<p style="margin-top: 1em">if( $string =~ m/Q$regex ) { ...
}</p>

<p style="margin-top: 1em">Alternately, you can use
&quot;qr//&quot;, the regular expression quote operator (see
perlop for more details). It quotes and perhaps compiles the
pattern, and you can apply regular <br>
expression flags to the pattern.</p>

<p style="margin-top: 1em">chomp( my $input = &lt;STDIN&gt;
);</p>

<p style="margin-top: 1em">my $regex = qr/$input/is;</p>

<p style="margin-top: 1em">$string =~ m/$regex/ # same as
m/$input/is;</p>

<p style="margin-top: 1em">You might also want to trap any
errors by wrapping an &quot;eval&quot; block around the
whole thing.</p>

<p style="margin-top: 1em">chomp( my $input = &lt;STDIN&gt;
);</p>

<p style="margin-top: 1em">eval { <br>
if( $string =~ m/Q$input ) { ... } <br>
}; <br>
warn $@ if $@;</p>

<p style="margin-top: 1em">Or...</p>

<p style="margin-top: 1em">my $regex = eval { qr/$input/is
}; <br>
if( defined $regex ) { <br>
$string =~ m/$regex/; <br>
} <br>
else { <br>
warn $@; <br>
}</p>

<p style="margin-top: 1em">AUTHOR AND COPYRIGHT <br>
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington,
and other authors as noted. All rights reserved.</p>

<p style="margin-top: 1em">This documentation is free; you
can redistribute it and/or modify it under the same terms as
Perl itself.</p>

<p style="margin-top: 1em">Irrespective of its
distribution, all code examples in this file are hereby
placed into the public domain. You are permitted and
encouraged to use this code in your own programs <br>
for fun or for profit as you see fit. A simple comment in
the code giving credit would be courteous but is not
required.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLFAQ6(1)</p>
<hr>
</body>
</html>
