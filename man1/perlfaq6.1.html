<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLFAQ6(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLFAQ6(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLFAQ6(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlfaq6 - Regular Expressions
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This section is surprisingly small because the rest of the FAQ is littered with
  answers involving regular expressions. For example, decoding a URL and
  checking whether something is a number can be handled with regular
  expressions, but those answers are found elsewhere in this document (in
  perlfaq9: &quot;How do I decode or create those %-encodings on the web&quot;
  and perlfaq4: &quot;How do I determine whether a scalar is a
  number/whole/integer/float&quot;, to be precise).
<h2 class="Ss" title="Ss" id="How_can_I_hope_to_use_regular_expressions_without_creating_illegible_and_unmaintainable_code?"><a class="selflink" href="#How_can_I_hope_to_use_regular_expressions_without_creating_illegible_and_unmaintainable_code?">How
  can I hope to use regular expressions without creating illegible and
  unmaintainable code?</a></h2>
Three techniques can make regular expressions maintainable and understandable.
<dl class="Bl-tag">
  <dt class="It-tag">Comments Outside the Regex</dt>
  <dd class="It-tag">Describe what you're doing and how you're doing it, using
      normal Perl comments.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    # turn the line into the first word, a colon, and the
    # number of characters on the rest of the line
    s/^(\w+)(.*)/ lc($1) . &quot;:&quot; . length($2) /meg;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Comments Inside the Regex</dt>
  <dd class="It-tag">The &quot;/x&quot; modifier causes whitespace to be ignored
      in a regex pattern (except in a character class and a few other places),
      and also allows you to use normal comments there, too. As you can imagine,
      whitespace and comments help a lot.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;/x&quot; lets you turn this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    s{&lt;(?:[^&gt;'&quot;]*|&quot;.*?&quot;|'.*?')+&gt;}{}gs;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    into this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    s{ &lt;                    # opening angle bracket
        (?:                 # Non-backreffing grouping paren
            [^&gt;'&quot;] *        # 0 or more things that are neither &gt; nor ' nor &quot;
                |           #    or else
            &quot;.*?&quot;           # a section between double quotes (stingy match)
                |           #    or else
            '.*?'           # a section between single quotes (stingy match)
        ) +                 #   all occurring one or more times
        &gt;                   # closing angle bracket
    }{}gsx;                 # replace with nothing, i.e. delete
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    It's still not quite so clear as prose, but it is very useful for describing
      the meaning of each part of the pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Different Delimiters</dt>
  <dd class="It-tag">While we normally think of patterns as being delimited with
      &quot;/&quot; characters, they can be delimited by almost any character.
      perlre describes this. For example, the &quot;s///&quot; above uses braces
      as delimiters. Selecting another delimiter can avoid quoting the delimiter
      within the pattern:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    s/\/usr\/local/\/usr\/share/g;    # bad delimiter choice
    s#/usr/local#/usr/share#g;        # better
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Using logically paired delimiters can be even more readable:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    s{/usr/local/}{/usr/share}g;      # better still
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="I'm_having_trouble_matching_over_more_than_one_line._What's_wrong?"><a class="selflink" href="#I'm_having_trouble_matching_over_more_than_one_line._What's_wrong?">I'm
  having trouble matching over more than one line. What's wrong?</a></h2>
Either you don't have more than one line in the string you're looking at
  (probably), or else you aren't using the correct modifier(s) on your pattern
  (possibly).
<div class="Pp"></div>
There are many ways to get multiline data into a string. If you want it to
  happen automatically while reading input, you'll want to set $/ (probably to
  '' for paragraphs or &quot;undef&quot; for the whole file) to allow you to
  read more than one line at a time.
<div class="Pp"></div>
Read perlre to help you decide which of &quot;/s&quot; and &quot;/m&quot; (or
  both) you might want to use: &quot;/s&quot; allows dot to include newline, and
  &quot;/m&quot; allows caret and dollar to match next to a newline, not just at
  the end of the string. You do need to make sure that you've actually got a
  multiline string in there.
<div class="Pp"></div>
For example, this program detects duplicate words, even when they span line
  breaks (but not paragraph ones). For this example, we don't need
  &quot;/s&quot; because we aren't using dot in a regular expression that we
  want to cross line boundaries. Neither do we need &quot;/m&quot; because we
  don't want caret or dollar to match at any point inside the record next to
  newlines. But it's imperative that $/ be set to something other than the
  default, or else we won't actually ever have a multiline record read in.
<div class="Pp"></div>
<pre>
    $/ = '';          # read in whole paragraph, not just one line
    while ( &lt;&gt; ) {
        while ( /\b([\w'-]+)(\s+\g1)+\b/gi ) {     # word starts alpha
            print &quot;Duplicate $1 at paragraph $.\n&quot;;
        }
    }
</pre>
<div class="Pp"></div>
Here's some code that finds sentences that begin with &quot;From &quot; (which
  would be mangled by many mailers):
<div class="Pp"></div>
<pre>
    $/ = '';          # read in whole paragraph, not just one line
    while ( &lt;&gt; ) {
        while ( /^From /gm ) { # /m makes ^ match next to \n
        print &quot;leading from in paragraph $.\n&quot;;
        }
    }
</pre>
<div class="Pp"></div>
Here's code that finds everything between START and END in a paragraph:
<div class="Pp"></div>
<pre>
    undef $/;          # read in whole file, not just one line or paragraph
    while ( &lt;&gt; ) {
        while ( /START(.*?)END/sgm ) { # /s makes . cross line boundaries
            print &quot;$1\n&quot;;
        }
    }
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_pull_out_lines_between_two_patterns_that_are_themselves_on_different_lines?"><a class="selflink" href="#How_can_I_pull_out_lines_between_two_patterns_that_are_themselves_on_different_lines?">How
  can I pull out lines between two patterns that are themselves on different
  lines?</a></h2>
You can use Perl's somewhat exotic &quot;..&quot; operator (documented in
  perlop):
<div class="Pp"></div>
<pre>
    perl -ne 'print if /START/ .. /END/' file1 file2 ...
</pre>
<div class="Pp"></div>
If you wanted text and not lines, you would use
<div class="Pp"></div>
<pre>
    perl -0777 -ne 'print &quot;$1\n&quot; while /START(.*?)END/gs' file1 file2 ...
</pre>
<div class="Pp"></div>
But if you want nested occurrences of &quot;START&quot; through &quot;END&quot;,
  you'll run up against the problem described in the question in this section on
  matching balanced text.
<div class="Pp"></div>
Here's another example of using &quot;..&quot;:
<div class="Pp"></div>
<pre>
    while (&lt;&gt;) {
        my $in_header =   1  .. /^$/;
        my $in_body   = /^$/ .. eof;
    # now choose between them
    } continue {
        $. = 0 if eof;    # fix $.
    }
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_match_XML,_HTML,_or_other_nasty,_ugly_things_with_a_regex?"><a class="selflink" href="#How_do_I_match_XML,_HTML,_or_other_nasty,_ugly_things_with_a_regex?">How
  do I match XML, HTML, or other nasty, ugly things with a regex?</a></h2>
Do not use regexes. Use a module and forget about the regular expressions. The
  XML::LibXML, HTML::TokeParser and HTML::TreeBuilder modules are good starts,
  although each namespace has other parsing modules specialized for certain
  tasks and different ways of doing it. Start at CPAN Search (
  &lt;http://metacpan.org/&gt; ) and wonder at all the work people have done for
  you already! :)
<h2 class="Ss" title="Ss" id="I_put_a_regular_expression_into_$/_but_it_didn't_work._What's_wrong?"><a class="selflink" href="#I_put_a_regular_expression_into_$/_but_it_didn't_work._What's_wrong?">I
  put a regular expression into $/ but it didn't work. What's wrong?</a></h2>
$/ has to be a string. You can use these examples if you really need to do this.
<div class="Pp"></div>
If you have File::Stream, this is easy.
<div class="Pp"></div>
<pre>
    use File::Stream;
    my $stream = File::Stream-&gt;new(
        $filehandle,
        separator =&gt; qr/\s*,\s*/,
        );
    print &quot;$_\n&quot; while &lt;$stream&gt;;
</pre>
<div class="Pp"></div>
If you don't have File::Stream, you have to do a little more work.
<div class="Pp"></div>
You can use the four-argument form of sysread to continually add to a buffer.
  After you add to the buffer, you check if you have a complete line (using your
  regular expression).
<div class="Pp"></div>
<pre>
    local $_ = &quot;&quot;;
    while( sysread FH, $_, 8192, length ) {
        while( s/^((?s).*?)your_pattern// ) {
            my $record = $1;
            # do stuff here.
        }
    }
</pre>
<div class="Pp"></div>
You can do the same thing with foreach and a match using the c flag and the \G
  anchor, if you do not mind your entire file being in memory at the end.
<div class="Pp"></div>
<pre>
    local $_ = &quot;&quot;;
    while( sysread FH, $_, 8192, length ) {
        foreach my $record ( m/\G((?s).*?)your_pattern/gc ) {
            # do stuff here.
        }
        substr( $_, 0, pos ) = &quot;&quot; if pos;
    }
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_substitute_case-insensitively_on_the_LHS_while_preserving_case_on_the_RHS?"><a class="selflink" href="#How_do_I_substitute_case-insensitively_on_the_LHS_while_preserving_case_on_the_RHS?">How
  do I substitute case-insensitively on the LHS while preserving case on the
  RHS?</a></h2>
Here's a lovely Perlish solution by Larry Rosler. It exploits properties of
  bitwise xor on ASCII strings.
<div class="Pp"></div>
<pre>
    $_= &quot;this is a TEsT case&quot;;
    $old = 'test';
    $new = 'success';
    s{(\Q$old\E)}
    { uc $new | (uc $1 ^ $1) .
        (uc(substr $1, -1) ^ substr $1, -1) x
        (length($new) - length $1)
    }egi;
    print;
</pre>
<div class="Pp"></div>
And here it is as a subroutine, modeled after the above:
<div class="Pp"></div>
<pre>
    sub preserve_case($$) {
        my ($old, $new) = @_;
        my $mask = uc $old ^ $old;
        uc $new | $mask .
            substr($mask, -1) x (length($new) - length($old))
    }
    $string = &quot;this is a TEsT case&quot;;
    $string =~ s/(test)/preserve_case($1, &quot;success&quot;)/egi;
    print &quot;$string\n&quot;;
</pre>
<div class="Pp"></div>
This prints:
<div class="Pp"></div>
<pre>
    this is a SUcCESS case
</pre>
<div class="Pp"></div>
As an alternative, to keep the case of the replacement word if it is longer than
  the original, you can use this code, by Jeff Pinyan:
<div class="Pp"></div>
<pre>
    sub preserve_case {
        my ($from, $to) = @_;
        my ($lf, $lt) = map length, @_;
        if ($lt &lt; $lf) { $from = substr $from, 0, $lt }
        else { $from .= substr $to, $lf }
        return uc $to | ($from ^ uc $from);
    }
</pre>
<div class="Pp"></div>
This changes the sentence to &quot;this is a SUcCess case.&quot;
<div class="Pp"></div>
Just to show that C programmers can write C in any programming language, if you
  prefer a more C-like solution, the following script makes the substitution
  have the same case, letter by letter, as the original. (It also happens to run
  about 240% slower than the Perlish solution runs.) If the substitution has
  more characters than the string being substituted, the case of the last
  character is used for the rest of the substitution.
<div class="Pp"></div>
<pre>
    # Original by Nathan Torkington, massaged by Jeffrey Friedl
    #
    sub preserve_case($$)
    {
        my ($old, $new) = @_;
        my $state = 0; # 0 = no change; 1 = lc; 2 = uc
        my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
        my $len = $oldlen &lt; $newlen ? $oldlen : $newlen;
        for ($i = 0; $i &lt; $len; $i++) {
            if ($c = substr($old, $i, 1), $c =~ /[\W\d_]/) {
                $state = 0;
            } elsif (lc $c eq $c) {
                substr($new, $i, 1) = lc(substr($new, $i, 1));
                $state = 1;
            } else {
                substr($new, $i, 1) = uc(substr($new, $i, 1));
                $state = 2;
            }
        }
        # finish up with any remaining new (for when new is longer than old)
        if ($newlen &gt; $oldlen) {
            if ($state == 1) {
                substr($new, $oldlen) = lc(substr($new, $oldlen));
            } elsif ($state == 2) {
                substr($new, $oldlen) = uc(substr($new, $oldlen));
            }
        }
        return $new;
    }
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_make_&quot;\w&quot;_match_national_character_sets?"><a class="selflink" href="#How_can_I_make_&quot;\w&quot;_match_national_character_sets?">How
  can I make &quot;\w&quot; match national character sets?</a></h2>
Put &quot;use locale;&quot; in your script. The \w character class is taken from
  the current locale.
<div class="Pp"></div>
See perllocale for details.
<h2 class="Ss" title="Ss" id="How_can_I_match_a_locale-smart_version_of_&quot;/[a-zA-Z]/&quot;?"><a class="selflink" href="#How_can_I_match_a_locale-smart_version_of_&quot;/[a-zA-Z]/&quot;?">How
  can I match a locale-smart version of &quot;/[a-zA-Z]/&quot;?</a></h2>
You can use the POSIX character class syntax &quot;/[[:alpha:]]/&quot;
  documented in perlre.
<div class="Pp"></div>
No matter which locale you are in, the alphabetic characters are the characters
  in \w without the digits and the underscore. As a regex, that looks like
  &quot;/[^\W\d_]/&quot;. Its complement, the non-alphabetics, is then
  everything in \W along with the digits and the underscore, or
  &quot;/[\W\d_]/&quot;.
<h2 class="Ss" title="Ss" id="How_can_I_quote_a_variable_to_use_in_a_regex?"><a class="selflink" href="#How_can_I_quote_a_variable_to_use_in_a_regex?">How
  can I quote a variable to use in a regex?</a></h2>
The Perl parser will expand $variable and @variable references in regular
  expressions unless the delimiter is a single quote. Remember, too, that the
  right-hand side of a &quot;s///&quot; substitution is considered a
  double-quoted string (see perlop for more details). Remember also that any
  regex special characters will be acted on unless you precede the substitution
  with \Q. Here's an example:
<div class="Pp"></div>
<pre>
    $string = &quot;Placido P. Octopus&quot;;
    $regex  = &quot;P.&quot;;
    $string =~ s/$regex/Polyp/;
    # $string is now &quot;Polypacido P. Octopus&quot;
</pre>
<div class="Pp"></div>
Because &quot;.&quot; is special in regular expressions, and can match any
  single character, the regex &quot;P.&quot; here has matched the &lt;Pl&gt; in
  the original string.
<div class="Pp"></div>
To escape the special meaning of &quot;.&quot;, we use &quot;\Q&quot;:
<div class="Pp"></div>
<pre>
    $string = &quot;Placido P. Octopus&quot;;
    $regex  = &quot;P.&quot;;
    $string =~ s/\Q$regex/Polyp/;
    # $string is now &quot;Placido Polyp Octopus&quot;
</pre>
<div class="Pp"></div>
The use of &quot;\Q&quot; causes the &lt;.&gt; in the regex to be treated as a
  regular character, so that &quot;P.&quot; matches a &quot;P&quot; followed by
  a dot.
<h2 class="Ss" title="Ss" id="What_is_&quot;/o&quot;_really_for?"><a class="selflink" href="#What_is_&quot;/o&quot;_really_for?">What
  is &quot;/o&quot; really for?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
The &quot;/o&quot; option for regular expressions (documented in perlop and
  perlreref) tells Perl to compile the regular expression only once. This is
  only useful when the pattern contains a variable. Perls 5.6 and later handle
  this automatically if the pattern does not change.
<div class="Pp"></div>
Since the match operator &quot;m//&quot;, the substitution operator
  &quot;s///&quot;, and the regular expression quoting operator &quot;qr//&quot;
  are double-quotish constructs, you can interpolate variables into the pattern.
  See the answer to &quot;How can I quote a variable to use in a regex?&quot;
  for more details.
<div class="Pp"></div>
This example takes a regular expression from the argument list and prints the
  lines of input that match it:
<div class="Pp"></div>
<pre>
    my $pattern = shift @ARGV;
    while( &lt;&gt; ) {
        print if m/$pattern/;
    }
</pre>
<div class="Pp"></div>
Versions of Perl prior to 5.6 would recompile the regular expression for each
  iteration, even if $pattern had not changed. The &quot;/o&quot; would prevent
  this by telling Perl to compile the pattern the first time, then reuse that
  for subsequent iterations:
<div class="Pp"></div>
<pre>
    my $pattern = shift @ARGV;
    while( &lt;&gt; ) {
        print if m/$pattern/o; # useful for Perl &lt; 5.6
    }
</pre>
<div class="Pp"></div>
In versions 5.6 and later, Perl won't recompile the regular expression if the
  variable hasn't changed, so you probably don't need the &quot;/o&quot; option.
  It doesn't hurt, but it doesn't help either. If you want any version of Perl
  to compile the regular expression only once even if the variable changes
  (thus, only using its initial value), you still need the &quot;/o&quot;.
<div class="Pp"></div>
You can watch Perl's regular expression engine at work to verify for yourself if
  Perl is recompiling a regular expression. The &quot;use re 'debug'&quot;
  pragma (comes with Perl 5.005 and later) shows the details. With Perls before
  5.6, you should see &quot;re&quot; reporting that its compiling the regular
  expression on each iteration. With Perl 5.6 or later, you should only see
  &quot;re&quot; report that for the first iteration.
<div class="Pp"></div>
<pre>
    use re 'debug';
    my $regex = 'Perl';
    foreach ( qw(Perl Java Ruby Python) ) {
        print STDERR &quot;-&quot; x 73, &quot;\n&quot;;
        print STDERR &quot;Trying $_...\n&quot;;
        print STDERR &quot;\t$_ is good!\n&quot; if m/$regex/;
    }
</pre>
<h2 class="Ss" title="Ss" id="How_do_I_use_a_regular_expression_to_strip_C-style_comments_from_a_file?"><a class="selflink" href="#How_do_I_use_a_regular_expression_to_strip_C-style_comments_from_a_file?">How
  do I use a regular expression to strip C-style comments from a file?</a></h2>
While this actually can be done, it's much harder than you'd think. For example,
  this one-liner
<div class="Pp"></div>
<pre>
    perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c
</pre>
<div class="Pp"></div>
will work in many but not all cases. You see, it's too simple-minded for certain
  kinds of C programs, in particular, those with what appear to be comments in
  quoted strings. For that, you'd need something like this, created by Jeffrey
  Friedl and later modified by Fred Curtis.
<div class="Pp"></div>
<pre>
    $/ = undef;
    $_ = &lt;&gt;;
    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|(&quot;(\\.|[^&quot;\\])*&quot;|'(\\.|[^'\\])*'|.[^/&quot;'\\]*)#defined $2 ? $2 : &quot;&quot;#gse;
    print;
</pre>
<div class="Pp"></div>
This could, of course, be more legibly written with the &quot;/x&quot; modifier,
  adding whitespace and comments. Here it is expanded, courtesy of Fred Curtis.
<div class="Pp"></div>
<pre>
    s{
       /\*         ##  Start of /* ... */ comment
       [^*]*\*+    ##  Non-* followed by 1-or-more *'s
       (
         [^/*][^*]*\*+
       )*          ##  0-or-more things which don't start with /
                   ##    but do end with '*'
       /           ##  End of /* ... */ comment
     |         ##     OR  various things which aren't comments:
       (
         &quot;           ##  Start of &quot; ... &quot; string
         (
           \\.           ##  Escaped char
         |               ##    OR
           [^&quot;\\]        ##  Non &quot;\
         )*
         &quot;           ##  End of &quot; ... &quot; string
       |         ##     OR
         '           ##  Start of ' ... ' string
         (
           \\.           ##  Escaped char
         |               ##    OR
           [^'\\]        ##  Non '\
         )*
         '           ##  End of ' ... ' string
       |         ##     OR
         .           ##  Anything other char
         [^/&quot;'\\]*   ##  Chars which doesn't start a comment, string or escape
       )
     }{defined $2 ? $2 : &quot;&quot;}gxse;
</pre>
<div class="Pp"></div>
A slight modification also removes C++ comments, possibly spanning multiple
  lines using a continuation character:
<div class="Pp"></div>
<pre>
 s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//([^\\]|[^\n][\n]?)*?\n|(&quot;(\\.|[^&quot;\\])*&quot;|'(\\.|[^'\\])*'|.[^/&quot;'\\]*)#defined $3 ? $3 : &quot;&quot;#gse;
</pre>
<h2 class="Ss" title="Ss" id="Can_I_use_Perl_regular_expressions_to_match_balanced_text?"><a class="selflink" href="#Can_I_use_Perl_regular_expressions_to_match_balanced_text?">Can
  I use Perl regular expressions to match balanced text?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
Your first try should probably be the Text::Balanced module, which is in the
  Perl standard library since Perl 5.8. It has a variety of functions to deal
  with tricky text. The Regexp::Common module can also help by providing canned
  patterns you can use.
<div class="Pp"></div>
As of Perl 5.10, you can match balanced text with regular expressions using
  recursive patterns. Before Perl 5.10, you had to resort to various tricks such
  as using Perl code in &quot;(??{})&quot; sequences.
<div class="Pp"></div>
Here's an example using a recursive regular expression. The goal is to capture
  all of the text within angle brackets, including the text in nested angle
  brackets. This sample text has two &quot;major&quot; groups: a group with one
  level of nesting and a group with two levels of nesting. There are five total
  groups in angle brackets:
<div class="Pp"></div>
<pre>
    I have some &lt;brackets in &lt;nested brackets&gt; &gt; and
    &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
    and that's it.
</pre>
<div class="Pp"></div>
The regular expression to match the balanced text uses two new (to Perl 5.10)
  regular expression features. These are covered in perlre and this example is a
  modified version of one in that documentation.
<div class="Pp"></div>
First, adding the new possessive &quot;+&quot; to any quantifier finds the
  longest match and does not backtrack. That's important since you want to
  handle any angle brackets through the recursion, not backtracking. The group
  &quot;[^&lt;&gt;]++&quot; finds one or more non-angle brackets without
  backtracking.
<div class="Pp"></div>
Second, the new &quot;(?PARNO)&quot; refers to the sub-pattern in the particular
  capture group given by &quot;PARNO&quot;. In the following regex, the first
  capture group finds (and remembers) the balanced text, and you need that same
  pattern within the first buffer to get past the nested text. That's the
  recursive part. The &quot;(?1)&quot; uses the pattern in the outer capture
  group as an independent part of the regex.
<div class="Pp"></div>
Putting it all together, you have:
<div class="Pp"></div>
<pre>
    #!/usr/local/bin/perl5.10.0
    my $string =&lt;&lt;&quot;HERE&quot;;
    I have some &lt;brackets in &lt;nested brackets&gt; &gt; and
    &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
    and that's it.
    HERE
    my @groups = $string =~ m/
            (                   # start of capture group 1
            &lt;                   # match an opening angle bracket
                (?:
                    [^&lt;&gt;]++     # one or more non angle brackets, non backtracking
                      |
                    (?1)        # found &lt; or &gt;, so recurse to capture group 1
                )*
            &gt;                   # match a closing angle bracket
            )                   # end of capture group 1
            /xg;
    $&quot; = &quot;\n\t&quot;;
    print &quot;Found:\n\t@groups\n&quot;;
</pre>
<div class="Pp"></div>
The output shows that Perl found the two major groups:
<div class="Pp"></div>
<pre>
    Found:
        &lt;brackets in &lt;nested brackets&gt; &gt;
        &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
</pre>
<div class="Pp"></div>
With a little extra work, you can get the all of the groups in angle brackets
  even if they are in other angle brackets too. Each time you get a balanced
  match, remove its outer delimiter (that's the one you just matched so don't
  match it again) and add it to a queue of strings to process. Keep doing that
  until you get no matches:
<div class="Pp"></div>
<pre>
    #!/usr/local/bin/perl5.10.0
    my @queue =&lt;&lt;&quot;HERE&quot;;
    I have some &lt;brackets in &lt;nested brackets&gt; &gt; and
    &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
    and that's it.
    HERE
    my $regex = qr/
            (                   # start of bracket 1
            &lt;                   # match an opening angle bracket
                (?:
                    [^&lt;&gt;]++     # one or more non angle brackets, non backtracking
                      |
                    (?1)        # recurse to bracket 1
                )*
            &gt;                   # match a closing angle bracket
            )                   # end of bracket 1
            /x;
    $&quot; = &quot;\n\t&quot;;
    while( @queue ) {
        my $string = shift @queue;
        my @groups = $string =~ m/$regex/g;
        print &quot;Found:\n\t@groups\n\n&quot; if @groups;
        unshift @queue, map { s/^&lt;//; s/&gt;$//; $_ } @groups;
    }
</pre>
<div class="Pp"></div>
The output shows all of the groups. The outermost matches show up first and the
  nested matches so up later:
<div class="Pp"></div>
<pre>
    Found:
        &lt;brackets in &lt;nested brackets&gt; &gt;
        &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
    Found:
        &lt;nested brackets&gt;
    Found:
        &lt;nested once &lt;nested twice&gt; &gt;
    Found:
        &lt;nested twice&gt;
</pre>
<h2 class="Ss" title="Ss" id="What_does_it_mean_that_regexes_are_greedy?_How_can_I_get_around_it?"><a class="selflink" href="#What_does_it_mean_that_regexes_are_greedy?_How_can_I_get_around_it?">What
  does it mean that regexes are greedy? How can I get around it?</a></h2>
Most people mean that greedy regexes match as much as they can. Technically
  speaking, it's actually the quantifiers (&quot;?&quot;, &quot;*&quot;,
  &quot;+&quot;, &quot;{}&quot;) that are greedy rather than the whole pattern;
  Perl prefers local greed and immediate gratification to overall greed. To get
  non-greedy versions of the same quantifiers, use (&quot;??&quot;,
  &quot;*?&quot;, &quot;+?&quot;, &quot;{}?&quot;).
<div class="Pp"></div>
An example:
<div class="Pp"></div>
<pre>
    my $s1 = my $s2 = &quot;I am very very cold&quot;;
    $s1 =~ s/ve.*y //;      # I am cold
    $s2 =~ s/ve.*?y //;     # I am very cold
</pre>
<div class="Pp"></div>
Notice how the second substitution stopped matching as soon as it encountered
  &quot;y &quot;. The &quot;*?&quot; quantifier effectively tells the regular
  expression engine to find a match as quickly as possible and pass control on
  to whatever is next in line, as you would if you were playing hot potato.
<h2 class="Ss" title="Ss" id="How_do_I_process_each_word_on_each_line?"><a class="selflink" href="#How_do_I_process_each_word_on_each_line?">How
  do I process each word on each line?</a></h2>
Use the split function:
<div class="Pp"></div>
<pre>
    while (&lt;&gt;) {
        foreach my $word ( split ) {
            # do something with $word here
        }
    }
</pre>
<div class="Pp"></div>
Note that this isn't really a word in the English sense; it's just chunks of
  consecutive non-whitespace characters.
<div class="Pp"></div>
To work with only alphanumeric sequences (including underscores), you might
  consider
<div class="Pp"></div>
<pre>
    while (&lt;&gt;) {
        foreach $word (m/(\w+)/g) {
            # do something with $word here
        }
    }
</pre>
<h2 class="Ss" title="Ss" id="How_can_I_print_out_a_word-frequency_or_line-frequency_summary?"><a class="selflink" href="#How_can_I_print_out_a_word-frequency_or_line-frequency_summary?">How
  can I print out a word-frequency or line-frequency summary?</a></h2>
To do this, you have to parse out each word in the input stream. We'll pretend
  that by word you mean chunk of alphabetics, hyphens, or apostrophes, rather
  than the non-whitespace chunk idea of a word given in the previous question:
<div class="Pp"></div>
<pre>
    my (%seen);
    while (&lt;&gt;) {
        while ( /(\b[^\W_\d][\w'-]+\b)/g ) {   # misses &quot;`sheep'&quot;
            $seen{$1}++;
        }
    }
    while ( my ($word, $count) = each %seen ) {
        print &quot;$count $word\n&quot;;
    }
</pre>
<div class="Pp"></div>
If you wanted to do the same thing for lines, you wouldn't need a regular
  expression:
<div class="Pp"></div>
<pre>
    my (%seen);
    while (&lt;&gt;) {
        $seen{$_}++;
    }
    while ( my ($line, $count) = each %seen ) {
        print &quot;$count $line&quot;;
    }
</pre>
<div class="Pp"></div>
If you want these output in a sorted order, see perlfaq4: &quot;How do I sort a
  hash (optionally by value instead of key)?&quot;.
<h2 class="Ss" title="Ss" id="How_can_I_do_approximate_matching?"><a class="selflink" href="#How_can_I_do_approximate_matching?">How
  can I do approximate matching?</a></h2>
See the module String::Approx available from CPAN.
<h2 class="Ss" title="Ss" id="How_do_I_efficiently_match_many_regular_expressions_at_once?"><a class="selflink" href="#How_do_I_efficiently_match_many_regular_expressions_at_once?">How
  do I efficiently match many regular expressions at once?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
If you have Perl 5.10 or later, this is almost trivial. You just smart match
  against an array of regular expression objects:
<div class="Pp"></div>
<pre>
    my @patterns = ( qr/Fr.d/, qr/B.rn.y/, qr/W.lm./ );
    if( $string ~~ @patterns ) {
        ...
    };
</pre>
<div class="Pp"></div>
The smart match stops when it finds a match, so it doesn't have to try every
  expression.
<div class="Pp"></div>
Earlier than Perl 5.10, you have a bit of work to do. You want to avoid
  compiling a regular expression every time you want to match it. In this
  example, perl must recompile the regular expression for every iteration of the
  &quot;foreach&quot; loop since it has no way to know what $pattern will be:
<div class="Pp"></div>
<pre>
    my @patterns = qw( foo bar baz );
    LINE: while( &lt;DATA&gt; ) {
        foreach $pattern ( @patterns ) {
            if( /\b$pattern\b/i ) {
                print;
                next LINE;
            }
        }
    }
</pre>
<div class="Pp"></div>
The &quot;qr//&quot; operator showed up in perl 5.005. It compiles a regular
  expression, but doesn't apply it. When you use the pre-compiled version of the
  regex, perl does less work. In this example, I inserted a &quot;map&quot; to
  turn each pattern into its pre-compiled form. The rest of the script is the
  same, but faster:
<div class="Pp"></div>
<pre>
    my @patterns = map { qr/\b$_\b/i } qw( foo bar baz );
    LINE: while( &lt;&gt; ) {
        foreach $pattern ( @patterns ) {
            if( /$pattern/ ) {
                print;
                next LINE;
            }
        }
    }
</pre>
<div class="Pp"></div>
In some cases, you may be able to make several patterns into a single regular
  expression. Beware of situations that require backtracking though.
<div class="Pp"></div>
<pre>
    my $regex = join '|', qw( foo bar baz );
    LINE: while( &lt;&gt; ) {
        print if /\b(?:$regex)\b/i;
    }
</pre>
<div class="Pp"></div>
For more details on regular expression efficiency, see <i>Mastering</i>
  <i>Regular Expressions</i> by Jeffrey Friedl. He explains how the regular
  expressions engine works and why some patterns are surprisingly inefficient.
  Once you understand how perl applies regular expressions, you can tune them
  for individual situations.
<h2 class="Ss" title="Ss" id="Why_don't_word-boundary_searches_with_&quot;\b&quot;_work_for_me?"><a class="selflink" href="#Why_don't_word-boundary_searches_with_&quot;\b&quot;_work_for_me?">Why
  don't word-boundary searches with &quot;\b&quot; work for me?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
Ensure that you know what \b really does: it's the boundary between a word
  character, \w, and something that isn't a word character. That thing that
  isn't a word character might be \W, but it can also be the start or end of the
  string.
<div class="Pp"></div>
It's not (not!) the boundary between whitespace and non-whitespace, and it's not
  the stuff between words we use to create sentences.
<div class="Pp"></div>
In regex speak, a word boundary (\b) is a &quot;zero width assertion&quot;,
  meaning that it doesn't represent a character in the string, but a condition
  at a certain position.
<div class="Pp"></div>
For the regular expression, /\bPerl\b/, there has to be a word boundary before
  the &quot;P&quot; and after the &quot;l&quot;. As long as something other than
  a word character precedes the &quot;P&quot; and succeeds the &quot;l&quot;,
  the pattern will match. These strings match /\bPerl\b/.
<div class="Pp"></div>
<pre>
    &quot;Perl&quot;    # no word char before P or after l
    &quot;Perl &quot;   # same as previous (space is not a word char)
    &quot;'Perl'&quot;  # the ' char is not a word char
    &quot;Perl's&quot;  # no word char before P, non-word char after &quot;l&quot;
</pre>
<div class="Pp"></div>
These strings do not match /\bPerl\b/.
<div class="Pp"></div>
<pre>
    &quot;Perl_&quot;   # _ is a word char!
    &quot;Perler&quot;  # no word char before P, but one after l
</pre>
<div class="Pp"></div>
You don't have to use \b to match words though. You can look for non-word
  characters surrounded by word characters. These strings match the pattern
  /\b'\b/.
<div class="Pp"></div>
<pre>
    &quot;don't&quot;   # the ' char is surrounded by &quot;n&quot; and &quot;t&quot;
    &quot;qep'a'&quot;  # the ' char is surrounded by &quot;p&quot; and &quot;a&quot;
</pre>
<div class="Pp"></div>
These strings do not match /\b'\b/.
<div class="Pp"></div>
<pre>
    &quot;foo'&quot;    # there is no word char after non-word '
</pre>
<div class="Pp"></div>
You can also use the complement of \b, \B, to specify that there should not be a
  word boundary.
<div class="Pp"></div>
In the pattern /\Bam\B/, there must be a word character before the &quot;a&quot;
  and after the &quot;m&quot;. These patterns match /\Bam\B/:
<div class="Pp"></div>
<pre>
    &quot;llama&quot;   # &quot;am&quot; surrounded by word chars
    &quot;Samuel&quot;  # same
</pre>
<div class="Pp"></div>
These strings do not match /\Bam\B/
<div class="Pp"></div>
<pre>
    &quot;Sam&quot;      # no word boundary before &quot;a&quot;, but one after &quot;m&quot;
    &quot;I am Sam&quot; # &quot;am&quot; surrounded by non-word chars
</pre>
<h2 class="Ss" title="Ss" id="Why_does_using_$&amp;,_$`,_or_$'_slow_my_program_down?"><a class="selflink" href="#Why_does_using_$&amp;,_$`,_or_$'_slow_my_program_down?">Why
  does using $&amp;, $`, or $' slow my program down?</a></h2>
(contributed by Anno Siegel)
<div class="Pp"></div>
Once Perl sees that you need one of these variables anywhere in the program, it
  provides them on each and every pattern match. That means that on every
  pattern match the entire string will be copied, part of it to $`, part to
  $&amp;, and part to $'. Thus the penalty is most severe with long strings and
  patterns that match often. Avoid $&amp;, $', and $` if you can, but if you
  can't, once you've used them at all, use them at will because you've already
  paid the price. Remember that some algorithms really appreciate them. As of
  the 5.005 release, the $&amp; variable is no longer &quot;expensive&quot; the
  way the other two are.
<div class="Pp"></div>
Since Perl 5.6.1 the special variables @- and @+ can functionally replace $`,
  $&amp; and $'. These arrays contain pointers to the beginning and end of each
  match (see perlvar for the full story), so they give you essentially the same
  information, but without the risk of excessive string copying.
<div class="Pp"></div>
Perl 5.10 added three specials, &quot;${^MATCH}&quot;, &quot;${^PREMATCH}&quot;,
  and &quot;${^POSTMATCH}&quot; to do the same job but without the global
  performance penalty. Perl 5.10 only sets these variables if you compile or
  execute the regular expression with the &quot;/p&quot; modifier.
<h2 class="Ss" title="Ss" id="What_good_is_&quot;\G&quot;_in_a_regular_expression?"><a class="selflink" href="#What_good_is_&quot;\G&quot;_in_a_regular_expression?">What
  good is &quot;\G&quot; in a regular expression?</a></h2>
You use the &quot;\G&quot; anchor to start the next match on the same string
  where the last match left off. The regular expression engine cannot skip over
  any characters to find the next match with this anchor, so &quot;\G&quot; is
  similar to the beginning of string anchor, &quot;^&quot;. The &quot;\G&quot;
  anchor is typically used with the &quot;g&quot; flag. It uses the value of
  &quot;pos()&quot; as the position to start the next match. As the match
  operator makes successive matches, it updates &quot;pos()&quot; with the
  position of the next character past the last match (or the first character of
  the next match, depending on how you like to look at it). Each string has its
  own &quot;pos()&quot; value.
<div class="Pp"></div>
Suppose you want to match all of consecutive pairs of digits in a string like
  &quot;1122a44&quot; and stop matching when you encounter non-digits. You want
  to match 11 and 22 but the letter &lt;a&gt; shows up between 22 and 44 and you
  want to stop at &quot;a&quot;. Simply matching pairs of digits skips over the
  &quot;a&quot; and still matches 44.
<div class="Pp"></div>
<pre>
    $_ = &quot;1122a44&quot;;
    my @pairs = m/(\d\d)/g;   # qw( 11 22 44 )
</pre>
<div class="Pp"></div>
If you use the &quot;\G&quot; anchor, you force the match after 22 to start with
  the &quot;a&quot;. The regular expression cannot match there since it does not
  find a digit, so the next match fails and the match operator returns the pairs
  it already found.
<div class="Pp"></div>
<pre>
    $_ = &quot;1122a44&quot;;
    my @pairs = m/\G(\d\d)/g; # qw( 11 22 )
</pre>
<div class="Pp"></div>
You can also use the &quot;\G&quot; anchor in scalar context. You still need the
  &quot;g&quot; flag.
<div class="Pp"></div>
<pre>
    $_ = &quot;1122a44&quot;;
    while( m/\G(\d\d)/g ) {
        print &quot;Found $1\n&quot;;
    }
</pre>
<div class="Pp"></div>
After the match fails at the letter &quot;a&quot;, perl resets &quot;pos()&quot;
  and the next match on the same string starts at the beginning.
<div class="Pp"></div>
<pre>
    $_ = &quot;1122a44&quot;;
    while( m/\G(\d\d)/g ) {
        print &quot;Found $1\n&quot;;
    }
    print &quot;Found $1 after while&quot; if m/(\d\d)/g; # finds &quot;11&quot;
</pre>
<div class="Pp"></div>
You can disable &quot;pos()&quot; resets on fail with the &quot;c&quot; flag,
  documented in perlop and perlreref. Subsequent matches start where the last
  successful match ended (the value of &quot;pos()&quot;) even if a match on the
  same string has failed in the meantime. In this case, the match after the
  &quot;while()&quot; loop starts at the &quot;a&quot; (where the last match
  stopped), and since it does not use any anchor it can skip over the
  &quot;a&quot; to find 44.
<div class="Pp"></div>
<pre>
    $_ = &quot;1122a44&quot;;
    while( m/\G(\d\d)/gc ) {
        print &quot;Found $1\n&quot;;
    }
    print &quot;Found $1 after while&quot; if m/(\d\d)/g; # finds &quot;44&quot;
</pre>
<div class="Pp"></div>
Typically you use the &quot;\G&quot; anchor with the &quot;c&quot; flag when you
  want to try a different match if one fails, such as in a tokenizer. Jeffrey
  Friedl offers this example which works in 5.004 or later.
<div class="Pp"></div>
<pre>
    while (&lt;&gt;) {
        chomp;
        PARSER: {
            m/ \G( \d+\b    )/gcx   &amp;&amp; do { print &quot;number: $1\n&quot;;  redo; };
            m/ \G( \w+      )/gcx   &amp;&amp; do { print &quot;word:   $1\n&quot;;  redo; };
            m/ \G( \s+      )/gcx   &amp;&amp; do { print &quot;space:  $1\n&quot;;  redo; };
            m/ \G( [^\w\d]+ )/gcx   &amp;&amp; do { print &quot;other:  $1\n&quot;;  redo; };
        }
    }
</pre>
<div class="Pp"></div>
For each line, the &quot;PARSER&quot; loop first tries to match a series of
  digits followed by a word boundary. This match has to start at the place the
  last match left off (or the beginning of the string on the first match). Since
  &quot;m/ \G( \d+\b )/gcx&quot; uses the &quot;c&quot; flag, if the string does
  not match that regular expression, perl does not reset <i>pos()</i> and the
  next match starts at the same position to try a different pattern.
<h2 class="Ss" title="Ss" id="Are_Perl_regexes_DFAs_or_NFAs?_Are_they_POSIX_compliant?"><a class="selflink" href="#Are_Perl_regexes_DFAs_or_NFAs?_Are_they_POSIX_compliant?">Are
  Perl regexes DFAs or NFAs? Are they POSIX compliant?</a></h2>
While it's true that Perl's regular expressions resemble the DFAs (deterministic
  finite automata) of the <i>egrep</i>(1) program, they are in fact implemented
  as NFAs (non-deterministic finite automata) to allow backtracking and
  backreferencing. And they aren't POSIX-style either, because those guarantee
  worst-case behavior for all cases. (It seems that some people prefer
  guarantees of consistency, even when what's guaranteed is slowness.) See the
  book &quot;Mastering Regular Expressions&quot; (from O'Reilly) by Jeffrey
  Friedl for all the details you could ever hope to know on these matters (a
  full citation appears in perlfaq2).
<h2 class="Ss" title="Ss" id="What's_wrong_with_using_grep_in_a_void_context?"><a class="selflink" href="#What's_wrong_with_using_grep_in_a_void_context?">What's
  wrong with using grep in a void context?</a></h2>
The problem is that grep builds a return list, regardless of the context. This
  means you're making Perl go to the trouble of building a list that you then
  just throw away. If the list is large, you waste both time and space. If your
  intent is to iterate over the list, then use a for loop for this purpose.
<div class="Pp"></div>
In perls older than 5.8.1, map suffers from this problem as well. But since
  5.8.1, this has been fixed, and map is context aware - in void context, no
  lists are constructed.
<h2 class="Ss" title="Ss" id="How_can_I_match_strings_with_multibyte_characters?"><a class="selflink" href="#How_can_I_match_strings_with_multibyte_characters?">How
  can I match strings with multibyte characters?</a></h2>
Starting from Perl 5.6 Perl has had some level of multibyte character support.
  Perl 5.8 or later is recommended. Supported multibyte character repertoires
  include Unicode, and legacy encodings through the Encode module. See
  perluniintro, perlunicode, and Encode.
<div class="Pp"></div>
If you are stuck with older Perls, you can do Unicode with the Unicode::String
  module, and character conversions using the Unicode::Map8 and Unicode::Map
  modules. If you are using Japanese encodings, you might try using the jperl
  5.005_03.
<div class="Pp"></div>
Finally, the following set of approaches was offered by Jeffrey Friedl, whose
  article in issue #5 of The Perl Journal talks about this very matter.
<div class="Pp"></div>
Let's suppose you have some weird Martian encoding where pairs of ASCII
  uppercase letters encode single Martian letters (i.e. the two bytes
  &quot;CV&quot; make a single Martian letter, as do the two bytes
  &quot;SG&quot;, &quot;VS&quot;, &quot;XX&quot;, etc.). Other bytes represent
  single characters, just like ASCII.
<div class="Pp"></div>
So, the string of Martian &quot;I am CVSGXX!&quot; uses 12 bytes to encode the
  nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.
<div class="Pp"></div>
Now, say you want to search for the single character &quot;/GX/&quot;. Perl
  doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the
  &quot;I am CVSGXX!&quot; string, even though that character isn't there: it
  just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but
  there's no real &quot;GX&quot;. This is a big problem.
<div class="Pp"></div>
Here are a few ways, all painful, to deal with it:
<div class="Pp"></div>
<pre>
    # Make sure adjacent &quot;martian&quot; bytes are no longer adjacent.
    $martian =~ s/([A-Z][A-Z])/ $1 /g;
    print &quot;found GX!\n&quot; if $martian =~ /GX/;
</pre>
<div class="Pp"></div>
Or like this:
<div class="Pp"></div>
<pre>
    my @chars = $martian =~ m/([A-Z][A-Z]|[^A-Z])/g;
    # above is conceptually similar to:     my @chars = $text =~ m/(.)/g;
    #
    foreach my $char (@chars) {
        print &quot;found GX!\n&quot;, last if $char eq 'GX';
    }
</pre>
<div class="Pp"></div>
Or like this:
<div class="Pp"></div>
<pre>
    while ($martian =~ m/\G([A-Z][A-Z]|.)/gs) {  # \G probably unneeded
        if ($1 eq 'GX') {
            print &quot;found GX!\n&quot;;
            last;
        }
    }
</pre>
<div class="Pp"></div>
Here's another, slightly less painful, way to do it from Benjamin Goldberg, who
  uses a zero-width negative look-behind assertion.
<div class="Pp"></div>
<pre>
    print &quot;found GX!\n&quot; if    $martian =~ m/
        (?&lt;![A-Z])
        (?:[A-Z][A-Z])*?
        GX
        /x;
</pre>
<div class="Pp"></div>
This succeeds if the &quot;martian&quot; character GX is in the string, and
  fails otherwise. If you don't like using (?&lt;!), a zero-width negative
  look-behind assertion, you can replace (?&lt;![A-Z]) with (?:^|[^A-Z]).
<div class="Pp"></div>
It does have the drawback of putting the wrong thing in $-[0] and $+[0], but
  this usually can be worked around.
<h2 class="Ss" title="Ss" id="How_do_I_match_a_regular_expression_that's_in_a_variable?"><a class="selflink" href="#How_do_I_match_a_regular_expression_that's_in_a_variable?">How
  do I match a regular expression that's in a variable?</a></h2>
(contributed by brian d foy)
<div class="Pp"></div>
We don't have to hard-code patterns into the match operator (or anything else
  that works with regular expressions). We can put the pattern in a variable for
  later use.
<div class="Pp"></div>
The match operator is a double quote context, so you can interpolate your
  variable just like a double quoted string. In this case, you read the regular
  expression as user input and store it in $regex. Once you have the pattern in
  $regex, you use that variable in the match operator.
<div class="Pp"></div>
<pre>
    chomp( my $regex = &lt;STDIN&gt; );
    if( $string =~ m/$regex/ ) { ... }
</pre>
<div class="Pp"></div>
Any regular expression special characters in $regex are still special, and the
  pattern still has to be valid or Perl will complain. For instance, in this
  pattern there is an unpaired parenthesis.
<div class="Pp"></div>
<pre>
    my $regex = &quot;Unmatched ( paren&quot;;
    &quot;Two parens to bind them all&quot; =~ m/$regex/;
</pre>
<div class="Pp"></div>
When Perl compiles the regular expression, it treats the parenthesis as the
  start of a memory match. When it doesn't find the closing parenthesis, it
  complains:
<div class="Pp"></div>
<pre>
    Unmatched ( in regex; marked by &lt;-- HERE in m/Unmatched ( &lt;-- HERE  paren/ at script line 3.
</pre>
<div class="Pp"></div>
You can get around this in several ways depending on our situation. First, if
  you don't want any of the characters in the string to be special, you can
  escape them with &quot;quotemeta&quot; before you use the string.
<div class="Pp"></div>
<pre>
    chomp( my $regex = &lt;STDIN&gt; );
    $regex = quotemeta( $regex );
    if( $string =~ m/$regex/ ) { ... }
</pre>
<div class="Pp"></div>
You can also do this directly in the match operator using the &quot;\Q&quot; and
  &quot;\E&quot; sequences. The &quot;\Q&quot; tells Perl where to start
  escaping special characters, and the &quot;\E&quot; tells it where to stop
  (see perlop for more details).
<div class="Pp"></div>
<pre>
    chomp( my $regex = &lt;STDIN&gt; );
    if( $string =~ m/\Q$regex\E/ ) { ... }
</pre>
<div class="Pp"></div>
Alternately, you can use &quot;qr//&quot;, the regular expression quote operator
  (see perlop for more details). It quotes and perhaps compiles the pattern, and
  you can apply regular expression flags to the pattern.
<div class="Pp"></div>
<pre>
    chomp( my $input = &lt;STDIN&gt; );
    my $regex = qr/$input/is;
    $string =~ m/$regex/  # same as m/$input/is;
</pre>
<div class="Pp"></div>
You might also want to trap any errors by wrapping an &quot;eval&quot; block
  around the whole thing.
<div class="Pp"></div>
<pre>
    chomp( my $input = &lt;STDIN&gt; );
    eval {
        if( $string =~ m/\Q$input\E/ ) { ... }
    };
    warn $@ if $@;
</pre>
<div class="Pp"></div>
Or...
<div class="Pp"></div>
<pre>
    my $regex = eval { qr/$input/is };
    if( defined $regex ) {
        $string =~ m/$regex/;
    }
    else {
        warn $@;
    }
</pre>
<h1 class="Sh" title="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="selflink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and other authors
  as noted. All rights reserved.
<div class="Pp"></div>
This documentation is free; you can redistribute it and/or modify it under the
  same terms as Perl itself.
<div class="Pp"></div>
Irrespective of its distribution, all code examples in this file are hereby
  placed into the public domain. You are permitted and encouraged to use this
  code in your own programs for fun or for profit as you see fit. A simple
  comment in the code giving credit would be courteous but is not
  required.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
