<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:38:58 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>srec_input(1) General Commands Manual srec_input(1)</p>

<p style="margin-top: 1em">NAME <br>
srec_input - input file specifications</p>

<p style="margin-top: 1em">SYNOPSIS <br>
srec_* filename [ format ]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This manual page describes the input file specifications for
the srec_cat(1), srec_cmp(1) and srec_info(1) commands.</p>

<p style="margin-top: 1em">Input files may be qualified in
a number of ways: you may specify their format and you may
specify filters to apply to them. An input file
specification looks like this: <br>
filename [ format ][ -ignore&acirc;checksums ][ filter ...
]</p>

<p style="margin-top: 1em">The filename may be specified as
a file name, or the special name &acirc;-&acirc; which is
understood to mean the standard input.</p>

<p style="margin-top: 1em">Grouping with Parentheses <br>
There are some cases where operator precedence of the
filters can be ambiguous. Input specifications may also be
enclosed by ( parentheses ) to make grouping explicit.
Remember <br>
that the parentheses must be separate words, i.e. surrounded
by spaces, and they will need to be quoted to get them past
the shell&rsquo;s interpretation of parentheses.</p>

<p style="margin-top: 1em">Those Option Names Sure Are Long
<br>
All options may be abbreviated; the abbreviation is
documented as the upper case letters, all lower case letters
and underscores (_) are optional. You must use consecutive
<br>
sequences of optional letters.</p>

<p style="margin-top: 1em">All options are case
insensitive, you may type them in upper case or lower case
or a combination of both, case is not important.</p>

<p style="margin-top: 1em">For example: the arguments
&acirc;-help&acirc;, &acirc;-HEL&acirc; and &acirc;-h&acirc;
are all interpreted to mean the -Help option. The argument
&acirc;-hlp&acirc; will not be understood, because
consecutive optional char&acirc; <br>
acters were not supplied.</p>

<p style="margin-top: 1em">Options and other command line
arguments may be mixed arbitrarily on the command line.</p>

<p style="margin-top: 1em">The GNU long option names are
understood. Since all option names for srec_input are long,
this means ignoring the extra leading &acirc;-&acirc;. The
&acirc;--option=value&acirc; convention is also <br>
understood.</p>

<p style="margin-top: 1em">File Formats <br>
The format is specified by the argument after the file name.
The format defaults to Motorola S&acirc;Record if not
specified. The format specifiers are:</p>

<p style="margin-top: 1em">-Absolute_Object_Module_Format
<br>
This option says to use the Intel Absolute Object Module
Format (AOMF) to read the file. (See srec_aomf(5) for a
description of this file format.)</p>

<p style="margin-top: 1em">-Ascii_Hex <br>
This option says to use the Ascii&acirc;Hex format to read
the file. See srec_ascii_hex(5) for a description of this
file format.</p>

<p style="margin-top: 1em">-Atmel_Generic <br>
This option says to use the Atmel Generic format to read the
file. See srec_atmel_genetic(5) for a description of this
file format.</p>

<p style="margin-top: 1em">-Binary This option says the
file is a raw binary file, and should be read literally.
(This option may also be written -Raw.) See srec_binary(5)
for more information.</p>

<p style="margin-top: 1em">-B&acirc;Record <br>
This option says to use the Freescale MC68EZ328 Dragonball
bootstrap b&acirc;record format to read the file. See
srec_brecord(5) for a description of this file format.</p>

<p style="margin-top: 1em">-COsmac This option says to use
the RCA Cosmac Elf format to read the file. See
srec_cosmac(5) for a description of this file format.</p>

<p style="margin-top: 1em">-Dec_Binary <br>
This option says to use the DEC Binary (XXDP) format to read
the file. See srec_dec_binary(5) for a description of this
file format.</p>

<p style="margin-top: 1em">-Elektor_Monitor52 <br>
This option says to use the EMON52 format to read the file.
See srec_emon52(5) for a description of this file
format.</p>

<p style="margin-top: 1em">-FAIrchild <br>
This option says to use the Fairchild Fairbug format to read
the file. See srec_fairchild(5) for a description of this
file format.</p>

<p style="margin-top: 1em">-Fast_Load <br>
This option says to use the LSI Logic Fast Load format to
read the file. See srec_fastload(5) for a description of
this file format.</p>

<p style="margin-top: 1em">-Formatted_Binary <br>
This option says to use the Formatted Binary format to read
the file. See srec_formatted_binary(5) for a description of
this file format.</p>

<p style="margin-top: 1em">-Four_Packed_Code <br>
This option says to use the FPC format to read the file. See
srec_fpc(5) for a description of this file format.</p>

<p style="margin-top: 1em">-Guess This option may be used
to ask the command to guess the input format. This is slower
than specifying an explicit format, as it may open and scan
and close the file a <br>
number of times.</p>

<p style="margin-top: 1em">-HEX_Dump <br>
This option says to try to read a hexadecimal dump file,
more or less in the style output by the same option. This is
not an exact reverse mapping, because if there are <br>
ASCII equivalents on the right hand side, these may be
confused for data bytes. Also, it doesn&rsquo;t understand
white space representing holes in the data in the line.</p>

<p style="margin-top: 1em">-IDT This option says to the the
IDT/sim binary format to read the file. See srec_idt(5) for
a description of this file format.</p>

<p style="margin-top: 1em">-Intel This option says to use
the Intel hex format to read the file. See srec_intel(5) for
a description of this file format.</p>

<p style="margin-top: 1em">-INtel_HeX_16 <br>
This option says to use the Intel hex 16 (INHX16) format to
read the file. See srec_intel16(5) for a description of this
file format.</p>

<p style="margin-top: 1em">-LOGIsim <br>
This format is read and written by the open source Logisim
program. See srec_logisim(5) for more informatuion.</p>

<p style="margin-top: 1em">-Memory_Initialization_File <br>
This option says to use the Memory Initialization File (MIF)
format by Altera to read the file. See srec_mif (5) for a
description of this file format.</p>

<p style="margin-top: 1em">-Mips_Flash_Big_Endian</p>

<p style="margin-top: 1em">-Mips_Flash_Little_Endian <br>
These options say to use the MIPS Flash file format to read
the file. See srec_mips_flash (5) for a description of this
file format.</p>

<p style="margin-top: 1em">-MOS_Technologies <br>
This option says to use the Mos Technologies format to read
the file. See srec_mos_tech(5) for a description of this
file format.</p>

<p style="margin-top: 1em">-Motorola [ width ] <br>
This option says to use the Motorola S&acirc;Record format
to read the file. (May be written -S&acirc;Record as well.)
See srec_motorola(5) for a description of this file
format.</p>

<p style="margin-top: 1em">The optional width argument
describes the number of bytes which form each address
multiple. For normal uses the default of one (1) byte is
appropriate. Some systems <br>
with 16&acirc;bit or 32&acirc;bit targets mutilate the
addresses in the file; this option will correct for that.
Unlike most other parameters, this one cannot be
guessed.</p>

<p style="margin-top: 1em">-MsBin This option says to use
the Windows CE Binary Image Data Format to read the file.
See srec_msbin(5) for a description of this file format.</p>

<p style="margin-top: 1em">-Needham_Hexadecimal <br>
This option says to use the Needham Electronics ASCII file
format to read the file. See srec_needham(5) for a
description of this file format.</p>

<p style="margin-top: 1em">-Ohio_Scientific <br>
This option says to use the Ohio Scientific format. See
srec_os65v(5) for a description of this file format.</p>

<p style="margin-top: 1em">-PPB This option says to use the
Stag Prom Programmer binary format. See srec_ppb(5) for a
description of this file format.</p>

<p style="margin-top: 1em">-PPX This option says to use the
Stag Prom Programmer hexadecimal format. See srec_ppx(5) for
a description of this file format.</p>

<p style="margin-top: 1em">-SIGnetics <br>
This option says to use the Signetics format. See
srec_spasm(5) for a description of this file format.</p>

<p style="margin-top: 1em">-SPAsm This is a synonym for the
-SPAsm_Big_Endian option.</p>

<p style="margin-top: 1em">-SPAsm_Big_Endian <br>
This option says to use the SPASM assembler output format
(commonly used by PIC programmers). See srec_spasm(5) for a
description of this file format.</p>

<p style="margin-top: 1em">-SPAsm_Little_Endian <br>
This option says to use the SPASM assembler output format,
but with the data the other way around.</p>

<p style="margin-top: 1em">-STewie This option says to use
the Stewie binary format to read the file. See
srec_stewie(5) for a description of this file format.</p>

<p style="margin-top: 1em">-Tektronix <br>
This option says to use the Tektronix hex format to read the
file. See srec_tektronix(5) for a description of this file
format.</p>

<p style="margin-top: 1em">-Tektronix_Extended <br>
This option says to use the Tektronix extended hex format to
read the file. See srec_tektronix_extended(5) for a
description of this file format.</p>

<p style="margin-top: 1em">-Texas_Instruments_Tagged <br>
This option says to use the Texas Instruments Tagged format
to read the file. See srec_ti_tagged(5) for a description of
this file format.</p>

<p style="margin-top: 1em">-Texas_Instruments_Tagged_16
<br>
This option says to use the Texas Instruments SDSMAC 320
format to read the file. See srec_ti_tagged_16(5) for a
description of this file format.</p>

<p style="margin-top: 1em">-Texas_Instruments_TeXT <br>
This option says to use the Texas Instruments TXT (MSP430)
format to read the file. See srec_ti_txt(5) for a
description of this file format.</p>

<p style="margin-top: 1em">-TRS80 This option says to use
the Radio Shack TRS&acirc;80 object file format to read the
file. See srec_trs80(5) for a description of this file
format.</p>

<p style="margin-top: 1em">-VMem This option says to use
the Verilog VMEM format to read the file. See srec_vmem(5)
for a description of this file format.</p>

<p style="margin-top: 1em">-WILson This option says to use
the wilson format to read the file. See srec_wilson(5) for a
description of this file format.</p>

<p style="margin-top: 1em">Ignore Checksums <br>
The -IGnore&acirc;Checksums option may be used to disable
checksum validation of input files, for those formats which
have checksums at all. Note that the checksum values are
still <br>
read in and parsed (so it is still an error if they are
missing) but their values are not checked. Used after an
input file name, the option affects that file alone; used
any&acirc; <br>
where else on the command line, it applies to all following
files.</p>

<p style="margin-top: 1em">-redundant&acirc;bytes=value
<br>
Use this option to permit a file to contain redundant values
for some memory locations. The default is for this condition
to be a warning.</p>

<p style="margin-top: 1em">ignore <br>
No warning or error is issued whena redundant settings are
detected.</p>

<p style="margin-top: 1em">warning <br>
A warning is issued when a redundant settings are observed,
the warning includes the problematic address.</p>

<p style="margin-top: 1em">error <br>
A fatal error is issued when a redundant settings are
observed, the fatal error message includes the problematic
address and byte value.</p>


<p style="margin-top: 1em">-contradictory&acirc;bytes=value
<br>
Use this option to permit a file to contain contradictory
values for some memory locations. The last value in the
input(s) will be used. The default is for this condi&acirc;
<br>
tion to be a fatal error.</p>

<p style="margin-top: 1em">ignore <br>
No warning or error is issued when contradictory setting is
detected.</p>

<p style="margin-top: 1em">warning <br>
A warning is issued when a vontradictory settings are
observed, the warning includes the problematic address, and
values.</p>

<p style="margin-top: 1em">error <br>
A fatal error is issued when contradictory settings are
observed, the fatal error message includes the problematic
address and byte values.</p>

<p style="margin-top: 1em">Generators <br>
It is also possible to generate data, rather than read it
from a file. You may use a generator anywhere you could use
a file. An input generator specification looks like
this:</p>

<p style="margin-top: 1em">-GENerate address&acirc;range
-data&acirc;source</p>

<p style="margin-top: 1em">The -data&acirc;source may be
one of the following:</p>

<p style="margin-top: 1em">-CONSTant byte&acirc;value <br>
This generator manufactures data with the given byte value
of the the given address range. It is an error if the
byte&acirc;value is not in the range 0..255.</p>

<p style="margin-top: 1em">For example, to fill memory
addresses 100..199 with newlines (0x0A), you could use a
command like</p>

<p style="margin-top: 1em">srec_cat -generate 100 200
-constant 10 -o newlines.srec</p>

<p style="margin-top: 1em">This can, of course, be combined
with data from files.</p>

<p style="margin-top: 1em">-REPeat_Data byte&acirc;value...
<br>
This generator manufactures data with the given byte values
repeating over the the given address range. It is an error
if any of the the byte&acirc;values are not in the range
<br>
0..255.</p>

<p style="margin-top: 1em">For example, to create a data
region with 0xDE in the even bytes and 0xAD in the odd
bytes, use a generator like this:</p>

<p style="margin-top: 1em">srec_cat -generate 0x1000 0x2000
-repeat&acirc;data 0xDE 0xAD</p>

<p style="margin-top: 1em">The repeat boundaries are
aligned with the base of the address range, modulo the
number of bytes.</p>

<p style="margin-top: 1em">-REPeat_String text <br>
This generator is almost identical to -repeat&acirc;data
except that the data to be repeated is the text of the given
string.</p>

<p style="margin-top: 1em">For example, to fill the holes
in an EPROM image eprom.srec with the text &acirc;Copyright
(C) 1812 Tchaikovsky&acirc;, combine a generator and an
-exclude filter, such as the com&acirc; <br>
mand</p>

<p style="margin-top: 1em">If you need to inject binary
data into the string (e.g. a terminating NUL character), use
the URL encoding that uses % followed by two hexadeimal
characters. For example <br>
a backspace would be encoded as &acirc;%08&acirc;.</p>

<p style="margin-top: 1em">srec_cat eprom.srec -generate 0
0x100000 -repeat&acirc;string &rsquo;Copyright (C) 1812
Tchaikovsky. &rsquo; -exclude -within eprom.srec -o
eprom.filled.srec</p>

<p style="margin-top: 1em">The thing to note is that we
have two data sources: the eprom.srec file, and generated
data over an address range which covers first megabyte of
memory but excluding <br>
areas covered by the eprom.srec data.</p>

<p style="margin-top: 1em">-CONSTant_Little_Endian value
width <br>
This generator manufactures data with the given numeric
value, of a given byte width, in little&acirc;endian byte
order. It is an error if the given value does not fit into
<br>
the given byte width. It will repeat over and over within
the address range range.</p>

<p style="margin-top: 1em">For example, to insert a
subversion commit number into 4 bytes at 0x0008..0x000B you
would use a command like</p>

<p style="margin-top: 1em">srec_cat -generate 8 12
-constant&acirc;l&acirc;e $VERSION 4 -o version.srec</p>

<p style="margin-top: 1em">This generator is a convenience
wrapper around the -REPeat_Data generator. It can, of
course, be combined with data from files.</p>

<p style="margin-top: 1em">-CONSTant_Big_Endian value width
<br>
As above, but using big&acirc;endian byte ordering.</p>

<p style="margin-top: 1em">Anything else will result in an
error.</p>

<p style="margin-top: 1em">Input Filters <br>
You may specify zero or more filters to be applied. Filters
are applied in the order the user specifies.</p>

<p style="margin-top: 1em">-Adler_16_Big_Endian address
<br>
This filter may be used to insert an &acirc;Adler&acirc;
16&acirc;bit checksum of the data into the data. Two bytes,
big&acirc;endian order, are inserted at the address given.
Holes in the <br>
input data are ignored. Bytes are processed in ascending
address order (not in the order they appear in the
input).</p>

<p style="margin-top: 1em">Note: If you have holes in your
data, you will get a different Adler checksum than if there
were no holes. This is important because the in&acirc;memory
EPROM image will not <br>
have holes. You almost always want to use the -fill filter
before any of the Adler checksum filters. You will receive a
warning if the data presented for Adler checksum <br>
has holes.</p>

<p style="margin-top: 1em">You should also be aware that
the lower and upper bounds of your data may not be the same
as the lower and upper bounds of your EPROM. This is another
reason to use the <br>
-fill filter, because it will establish the data across the
full EPROM address range.</p>


<p style="margin-top: 1em">http://en.wikipedia.org/wiki/Adler&acirc;32</p>

<p style="margin-top: 1em">-Adler_16_Little_Endian address
<br>
This filter may be used to insert an Adler 16&acirc;bit
checksum of the data into the data. Two bytes, in
little&acirc;endian order, are inserted at the address
given. Holes in the <br>
input data are ignored. Bytes are processed in ascending
address order (not in the order they appear in the
input).</p>

<p style="margin-top: 1em">Note: If you have holes in your
data, you will get a different Adler checksum than if there
were no holes. This is important because the in&acirc;memory
EPROM image will not <br>
have holes. You almost always want to use the -fill filter
before any of the Adler filters. You will receive a warning
if the data presented for Adler checksum has <br>
holes.</p>

<p style="margin-top: 1em">You should also be aware that
the lower and upper bounds of your data may not be the same
as the lower and upper bounds of your EPROM. This is another
reason to use the <br>
-fill filter, because it will establish the data across the
full EPROM address range.</p>


<p style="margin-top: 1em">http://en.wikipedia.org/wiki/Adler&acirc;32</p>

<p style="margin-top: 1em">-Adler_32_Big_Endian address
<br>
This filter may be used to insert a Adler 32&acirc;bit
checksum of the data into the data. Four bytes,
big&acirc;endian order, are inserted at the address given.
Holes in the input <br>
data are ignored. Bytes are processed in ascending address
order (not in the order they appear in the input).</p>

<p style="margin-top: 1em">Note: If you have holes in your
data, you will get a different Adler checksum than if there
were no holes. This is important because the in&acirc;memory
EPROM image will not <br>
have holes. You almost always want to use the -fill filter
before any of the Adler checksum filters. You will receive a
warning if the data presented for Adler checksum <br>
has holes.</p>

<p style="margin-top: 1em">You should also be aware that
the lower and upper bounds of your data may not be the same
as the lower and upper bounds of your EPROM. This is another
reason to use the <br>
-fill filter, because it will establish the data across the
full EPROM address range.</p>


<p style="margin-top: 1em">http://en.wikipedia.org/wiki/Adler&acirc;32</p>

<p style="margin-top: 1em">-Adler_32_Little_Endian address
<br>
This filter may be used to insert a Adler 32&acirc;bit
checksum of the data into the data. Four bytes, in
little&acirc;endian order, are inserted at the address
given. Holes in the <br>
input data are ignored. Bytes are processed in ascending
address order (not in the order they appear in the
input).</p>

<p style="margin-top: 1em">Note: If you have holes in your
data, you will get a different Adler checksum than if there
were no holes. This is important because the in&acirc;memory
EPROM image will not <br>
have holes. You almost always want to use the -fill filter
before any of the Adler checksum filters. You will receive a
warning if the data presented for Adler checksum <br>
has holes.</p>

<p style="margin-top: 1em">You should also be aware that
the lower and upper bounds of your data may not be the same
as the lower and upper bounds of your EPROM. This is another
reason to use the <br>
-fill filter, because it will establish the data across the
full EPROM address range.</p>


<p style="margin-top: 1em">http://en.wikipedia.org/wiki/Adler&acirc;32</p>

<p style="margin-top: 1em">-AND value <br>
This filter may be used to bit&acirc;wise AND a value to
every data byte. This is useful if you need to clear bits.
Only existing data is altered, no holes are filled.</p>

<p style="margin-top: 1em">-Bit_Reverse [ width ] <br>
This filter may be used to reverse the order of the bits in
each data byte. By specifying a width (in bytes) it is
possible to reverse the order multi&acirc;byte values; this
<br>
is implemented using the byte&acirc;swap filter.</p>

<p style="margin-top: 1em">-Byte_Swap [ width ] <br>
This filter may be used to swap pairs of odd and even bytes.
By specifying a width (in bytes) it is possible to reverse
the order of 4 and 8 bytes, the default is 2 <br>
bytes. (Widths in excess of 8 are assumed to be number of
bits.) It is not possible to swap
non&acirc;power&acirc;of&acirc;two addresses. To change the
alignment, use the offset filter <br>
before and after.</p>

<p style="margin-top: 1em">-Checksum_BitNot_Big_Endian
address [ nbytes [ width ]] <br>
This filter may be used to insert the one&rsquo;s complement
checksum of the data into the data, most significant byte
first. The data is literally summed; if there are
dupli&acirc; <br>
cate bytes, this will produce an incorrect result, if there
are holes, it will be as if they were filled with zeros. If
the data already contains bytes at the checksum <br>
location, you need to use an exclude filter, or this will
generate errors. You need to apply and crop or fill filters
before this filter. The value will be written with <br>
the most significant byte first. The number of bytes of
resulting checksum defaults to 4. The width (the width in
bytes of the values being summed) defaults to 1.</p>

<p style="margin-top: 1em">-Checksum_BitNot_Little_Endian
address [ nbytes [ width ]] <br>
This filter may be used to insert the one&rsquo;s complement
(bitnot) checksum of the data into the data, least
significant byte first. Otherwise similar to the above.</p>

<p style="margin-top: 1em">-Checksum_Negative_Big_Endian
address [ nbytes [ width ]] <br>
This filter may be used to insert the two&rsquo;s complement
(negative) checksum of the data into the data. Otherwise
similar to the above.</p>


<p style="margin-top: 1em">-Checksum_Negative_Little_Endian
address [ nbytes [ width ]] <br>
This filter may be used to insert the two&rsquo;s complement
(negative) checksum of the data into the data. Otherwise
similar to the above.</p>

<p style="margin-top: 1em">-Checksum_Positive_Big_Endian
address [ nbytes [ width ]] <br>
This filter may be used to insert the simple checksum of the
data into the data. Otherwise similar to the above.</p>


<p style="margin-top: 1em">-Checksum_Positive_Little_Endian
address [ nbytes [ width ]] <br>
This filter may be used to insert the simple checksum of the
data into the data. Otherwise similar to the above.</p>

<p style="margin-top: 1em">-CRC16_Big_Endian address [
modifier... ] <br>
This filter may be used to insert an industry standard
16&acirc;bit CRC checksum of the data into the data. Two
bytes, big&acirc;endian order, are inserted at the address
given. <br>
Holes in the input data are ignored. Bytes are processed in
ascending address order (not in the order they appear in the
input).</p>

<p style="margin-top: 1em">The following additional
modifiers are understood:</p>

<p style="margin-top: 1em">number Set the polynomial to be
used to the given number.</p>

<p style="margin-top: 1em">-POLYnomial name <br>
This option may be used to set the CRC polynomial to be
used, by name. The known names include:</p>

<p style="margin-top: 1em">ibm 0x8005 <br>
ansi 0x8005 <br>
ccitt 0x1021 <br>
t10&acirc;dif 0x8bb7 <br>
dnp 0x3d65 <br>
dect 0x0589</p>

<p style="margin-top: 1em">See
http://en.wikipedia.org/wiki/Cyclic_redundancy_check for a
table of names and values.</p>

<p style="margin-top: 1em">-Most_To_Least <br>
The CRC calculation is performed with the most significant
bit in each byte processed first, and then proceeding
towards the least significant bit. This is the <br>
default.</p>

<p style="margin-top: 1em">-Least_To_Most <br>
The CRC calculation is performed with the least significant
bit in each byte processed first, and then proceeding
towards the most significant bit.</p>

<p style="margin-top: 1em">-CCITT The CCITT calculation is
performed. The initial seed is 0xFFFF. This is the
default.</p>

<p style="margin-top: 1em">-XMODEM The alternate XMODEM
calculation is performed. The initial seed is 0x0000.</p>

<p style="margin-top: 1em">-BROKEN A
common&acirc;but&acirc;broken calculation is performed (see
note 2 below). The initial seed is 0x84CF.</p>

<p style="margin-top: 1em">-AUGment <br>
The CRC is augmented by sixteen zero bits at the end of the
calculation. This is the default.</p>

<p style="margin-top: 1em">-No&acirc;AUGment <br>
The CRC is not augmented at the end of the calculation. This
is less standard conforming, but some implementations do
this.</p>

<p style="margin-top: 1em">Note: If you have holes in your
data, you will get a different CRC than if there were no
holes. This is important because the in&acirc;memory EPROM
image will not have holes. <br>
You almost always want to use the -fill filter before any of
the CRC filters. You will receive a warning if the data
presented for CRC has holes.</p>

<p style="margin-top: 1em">You should also be aware that
the lower and upper bounds of your data may not be the same
as the lower and upper bounds of your EPROM. This is another
reason to use the <br>
-fill filter, because it will establish the data across the
full EPROM address range.</p>

<p style="margin-top: 1em">Note 2: there are a great many
CRC16 implementations out there, see
http://www.joegeluso.com/software/articles/ccitt.htm (now
gone, reproduced at http://&acirc; <br>
srecord.sourceforge.net/crc16-ccitt.html) and &acirc;A
painless guide to CRC error detection algorithms&acirc;
http://www.repairfaq.org/filipg/LINK/F_crc_v3.html for more
informa&acirc; <br>
tion. If all else fails, SRecord is open source software:
read the SRecord source code. The CRC16 source code (found
in the srecord/crc16.cc file of the distribution <br>
tarball) has a great many explanatory comments.</p>

<p style="margin-top: 1em">Please try all twelve
combinations of the above options before reporting a bug in
the CRC16 calculation.</p>

<p style="margin-top: 1em">-CRC16_Little_Endian address [
modifier... ] <br>
The same as the -CRC16_Big_Endian filter, except in
little&acirc;endian byte order.</p>

<p style="margin-top: 1em">-CRC32_Big_Endian address [
modifier... ] <br>
This filter may be used to insert an industry standard
32&acirc;bit CRC checksum of the data into the data. Four
bytes, big&acirc;endian order, are inserted at the address
given. <br>
Holes in the input data are ignored. Bytes are processed in
ascending address order (not in the order they appear in the
input). See also the note about holes, above.</p>

<p style="margin-top: 1em">The following additional
modifiers are understood:</p>

<p style="margin-top: 1em">-CCITT The CCITT calculation is
performed. The initial seed is all one bits. This is the
default.</p>

<p style="margin-top: 1em">-XMODEM An alternate
XMODEM&acirc;style calculation is performed. The initial
seed is all zero bits.</p>

<p style="margin-top: 1em">-CRC32_Little_Endian address
<br>
The same as the -CRC32_Big_Endian filter, except in
little&acirc;endian byte order.</p>

<p style="margin-top: 1em">-Crop address&acirc;range <br>
This filter may be used to isolate a section of data, and
discard the rest.</p>

<p style="margin-top: 1em">-Exclude address&acirc;range
<br>
This filter may be used to exclude a section of data, and
keep the rest. The is the logical complement of the -Crop
filter.</p>

<p style="margin-top: 1em">-Exclusive_Length_Big_Endian
address [ nbytes [ width ]] <br>
The same as the -Length_Big_Endian filter, except that the
result does not include the length itself.</p>

<p style="margin-top: 1em">-Exclusive_Length_Little_Endian
address [ nbytes [ width ]] <br>
The same as the -Length_Little_Endian filter, except that
the result does not include the length itself.</p>

<p style="margin-top: 1em">-Exclusive_MAXimum_Big_Endian
address [ nbytes ] <br>
The same as the -MAXimum_Big_Endian filter, except that the
result does not include the maximum itself.</p>


<p style="margin-top: 1em">-Exclusive_MAXimum_Little_Endian
address [ nbytes ] <br>
The same as the -MAXimum_Little_Endian filter, except that
the result does not include the maximum itself.</p>

<p style="margin-top: 1em">-Exclusive_MINimum_Big_Endian
address [ nbytes ] <br>
The same as the -MINimum_Big_Endian filter, except that the
result does not include the minimum itself.</p>


<p style="margin-top: 1em">-Exclusive_MINimum_Little_Endian
address [ nbytes ] <br>
The same as the -MINimum_Little_Endian filter, except that
the result does not include the minimum itself.</p>

<p style="margin-top: 1em">-eXclusive&acirc;OR value <br>
This filter may be used to bit&acirc;wise XOR a value to
every data byte. This is useful if you need to invert bits.
Only existing data is altered, no holes are filled.</p>

<p style="margin-top: 1em">-Fill value address&acirc;range
<br>
This filter may be used to fill any gaps in the data with
bytes equal to value. The fill will only occur in the
address range given.</p>

<p style="margin-top: 1em">-Fletcher_16_Big_Endian address
[ sum1 sum2 [ answer ]] <br>
This filter may be used to insert an Fletcher 16&acirc;bit
checksum of the data into the data. Two bytes,
big&acirc;endian order, are inserted at the address given.
Holes in the <br>
input data are ignored. Bytes are processed in ascending
address order (not in the order they appear in the
input).</p>

<p style="margin-top: 1em">Note: If you have holes in your
data, you will get a different Fletcher checksum than if
there were no holes. This is important because the
in&acirc;memory EPROM image will <br>
not have holes. You almost always want to use the -fill
filter before any of the Fletcher checksum filters. You will
receive a warning if the data presented for <br>
Fletcher checksum has holes.</p>

<p style="margin-top: 1em">You should also be aware that
the lower and upper bounds of your data may not be the same
as the lower and upper bounds of your EPROM. This is another
reason to use the <br>
-fill filter, because it will establish the data across the
full EPROM address range.</p>


<p style="margin-top: 1em">http://en.wikipedia.org/wiki/Fletcher%27s_checksum</p>

<p style="margin-top: 1em">It is possible to select seed
values for sum1 and sum2 in the algorithm, by adding seed
values on the command line. They each default to 0xFF if not
explicitly stated. <br>
The default values (0) means that an empty EPROM (all 0x00
or all 0xFF) will sum to zero; by changing the seeds, an
empty EPROM will always fail.</p>

<p style="margin-top: 1em">The third optional argument is
the desired sum, when the checksum itself is summed. A
common value is 0x0000, placed in the last two bytes of an
EPROM, so that the <br>
Fletcher 16 checksum of the EPROM is exactly 0x0000. No
manipulation of the final value is performed if this value
if not specified.</p>

<p style="margin-top: 1em">-Fletcher_16_Little_Endian
address <br>
This filter may be used to insert an Fletcher 16&acirc;bit
checksum of the data into the data. Two bytes, in
little&acirc;endian order, are inserted at the address
given. Holes in <br>
the input data are ignored. Bytes are processed in ascending
address order (not in the order they appear in the
input).</p>

<p style="margin-top: 1em">Note: If you have holes in your
data, you will get a different Fletcher checksum than if
there were no holes. This is important because the
in&acirc;memory EPROM image will <br>
not have holes. You almost always want to use the -fill
filter before any of the Fletcher filters. You will receive
a warning if the data presented for Fletcher check&acirc;
<br>
sum has holes.</p>

<p style="margin-top: 1em">You should also be aware that
the lower and upper bounds of your data may not be the same
as the lower and upper bounds of your EPROM. This is another
reason to use the <br>
-fill filter, because it will establish the data across the
full EPROM address range.</p>


<p style="margin-top: 1em">http://en.wikipedia.org/wiki/Fletcher%27s_checksum</p>

<p style="margin-top: 1em">-Fletcher_32_Big_Endian address
<br>
This filter may be used to insert a Fletcher 32&acirc;bit
checksum of the data into the data. Four bytes,
big&acirc;endian order, are inserted at the address given.
Holes in the <br>
input data are ignored. Bytes are processed in ascending
address order (not in the order they appear in the
input).</p>

<p style="margin-top: 1em">Note: If you have holes in your
data, you will get a different Fletcher checksum than if
there were no holes. This is important because the
in&acirc;memory EPROM image will <br>
not have holes. You almost always want to use the -fill
filter before any of the Fletcher checksum filters. You will
receive a warning if the data presented for <br>
Fletcher checksum has holes.</p>

<p style="margin-top: 1em">You should also be aware that
the lower and upper bounds of your data may not be the same
as the lower and upper bounds of your EPROM. This is another
reason to use the <br>
-fill filter, because it will establish the data across the
full EPROM address range.</p>


<p style="margin-top: 1em">http://en.wikipedia.org/wiki/Fletcher%27s_checksum</p>

<p style="margin-top: 1em">-Fletcher_32_Little_Endian
address <br>
This filter may be used to insert a Fletcher 32&acirc;bit
checksum of the data into the data. Four bytes, in
little&acirc;endian order, are inserted at the address
given. Holes in <br>
the input data are ignored. Bytes are processed in ascending
address order (not in the order they appear in the
input).</p>

<p style="margin-top: 1em">Note: If you have holes in your
data, you will get a different Fletcher checksum than if
there were no holes. This is important because the
in&acirc;memory EPROM image will <br>
not have holes. You almost always want to use the -fill
filter before any of the Fletcher checksum filters. You will
receive a warning if the data presented for <br>
Fletcher checksum has holes.</p>

<p style="margin-top: 1em">You should also be aware that
the lower and upper bounds of your data may not be the same
as the lower and upper bounds of your EPROM. This is another
reason to use the <br>
-fill filter, because it will establish the data across the
full EPROM address range.</p>


<p style="margin-top: 1em">http://en.wikipedia.org/wiki/Fletcher%27s_checksum</p>

<p style="margin-top: 1em">-Length_Big_Endian address [
nbytes [ width ]] <br>
This filter may be used to insert the length of the data
(high water minus low water) into the data. This includes
the length itself. If the data already contains bytes <br>
at the length location, you need to use an exclude filter,
or this will generate errors. The value will be written with
the most significant byte first. The number of <br>
bytes defaults to 4. The width defaults to 1, and is divided
into the actual length, thus you can insert the width in
units of words (2) or longs (4).</p>

<p style="margin-top: 1em">-Length_Little_Endian address [
nbytes [ width ]] <br>
The same as the -Length_Big_Endian filter, except the value
will be written with the least significant byte first.</p>

<p style="margin-top: 1em">-MAXimum_Big_Endian address [
nbytes ] <br>
This filter may be used to insert the maximum address of the
data (high water <br>
+ 1) into the data. This includes the maximum itself. If the
data already contains bytes at the given address, you need
to use an exclude filter, or this will generate <br>
errors. The value will be written with the most significant
byte first. The number of bytes defaults to 4.</p>

<p style="margin-top: 1em">-MAXimum_Little_Endian address [
nbytes ] <br>
The same as the -MAXimum_Big_Endian filter, except the value
will be written with the least significant byte first.</p>

<p style="margin-top: 1em">-Message_Digest_5 address <br>
This filter may be used to insert a 16 byte MD5 hash into
the data, at the address given.</p>

<p style="margin-top: 1em">-MINimum_Big_Endian address [
nbytes ] <br>
This filter may be used to insert the minimum address of the
data (low water) into the data. This includes the minimum
itself. If the data already contains bytes at the <br>
given address, you need to use an exclude filter, or this
will generate errors. The value will be written with the
most significant byte first. The number of bytes <br>
defaults to 4.</p>

<p style="margin-top: 1em">-MINimum_Little_Endian address [
nbytes ] <br>
The same as the -MINimum_Big_Endian filter, except the value
will be written with the least significant byte first.</p>

<p style="margin-top: 1em">-NOT This filter may be used to
bit&acirc;wise NOT the value of every data byte. This is
useful if you need to invert the data. Only existing data is
altered, no holes are filled.</p>

<p style="margin-top: 1em">-OFfset nbytes <br>
This filter may be used to offset the addresses by the given
number of bytes. No data is lost, the addresses will wrap
around in 32 bits, if necessary. You may use neg&acirc; <br>
ative numbers for the offset, if you wish to move data lower
in memory.</p>

<p style="margin-top: 1em">Please note: the execution start
address is a different concept than the first address in
memory of your data. If you want to change where your
monitor will start exe&acirc; <br>
cuting, use the -execution&acirc;start&acirc;address option
(srec_cat(1) only).</p>

<p style="margin-top: 1em">-OR value <br>
This filter may be used to bit&acirc;wise OR a value to
every data byte. This is useful if you need to set bits.
Only existing data is altered, no holes are filled.</p>

<p style="margin-top: 1em">-Random_Fill address&acirc;range
<br>
This filter may be used to fill any gaps in the data with
random bytes. The fill will only occur in the address range
given.</p>

<p style="margin-top: 1em">-Ripe_Message_Digest_160 address
<br>
This filter may be used to insert an RMD160 hash into the
data.</p>

<p style="margin-top: 1em">-Secure_Hash_Algorithm_1 address
<br>
This filter may be used to insert a 20 byte SHA1 hash into
the data, at the address given.</p>

<p style="margin-top: 1em">-Secure_Hash_Algorithm_224
address <br>
This filter may be used to insert a 28 byte SHA224 hash into
the data, at the address given. See Change Notice 1 for FIPS
180&acirc;2 for the specification.</p>

<p style="margin-top: 1em">-Secure_Hash_Algorithm_256
address <br>
This filter may be used to insert a 32 byte SHA256 hash into
the data, at the address given. See FIPS 180&acirc;2 for the
specification.</p>

<p style="margin-top: 1em">-Secure_Hash_Algorithm_384
address <br>
This filter may be used to insert a 48 byte SHA384 hash into
the data, at the address given. See FIPS 180&acirc;2 for the
specification.</p>

<p style="margin-top: 1em">-Secure_Hash_Algorithm_512
address <br>
This filter may be used to insert a 64 byte SHA512 hash into
the data, at the address given. See FIPS 180&acirc;2 for the
specification.</p>

<p style="margin-top: 1em">-SPlit multiple [ offset [ width
] ] <br>
This filter may be used to split the input into a subset of
the data, and compress the address range so as to leave no
gaps. This useful for wide data buses and memory <br>
striping. The multiple is the bytes multiple to split over,
the offset is the byte offset into this range (defaults to
0), the width is the number of bytes to extract <br>
(defaults to 1) within the multiple. In order to leave no
gaps, the output addresses are (width / multiple) times the
input addresses.</p>

<p style="margin-top: 1em">-STM32 address <br>
This is a synonym for the -STM32_Little_Endian filter.</p>

<p style="margin-top: 1em">-STM32_Little_Endian address</p>

<p style="margin-top: 1em">-STM32_Big_Endian address <br>
These filters many be use to generate the CRC used by the
hardware CRC unit on the STM32 series of ARM MPUs. The
algorithm used by the STM32 hardware unit is just a <br>
CRC32 with a different polynomial and word&acirc;fed instead
of byte&acirc;fed.</p>

<p style="margin-top: 1em">The address is where to place
the 4&acirc;byte STM32 CRC.</p>

<p style="margin-top: 1em">The CRC used is documented in
&acirc;RM0041, STM32F100xx reference manual&acirc;, page 46,
chapter &acirc;CRC Calculation Unit&acirc;, which can be
found at <br>
http://www.st.com/internet/mcu/product/216844.jsp</p>

<p style="margin-top: 1em">-TIGer address <br>
This filter may be used to insert a 24 byte TIGER/192 hash
into the data at the address given.</p>

<p style="margin-top: 1em">-UnFill value [
min&acirc;run&acirc;length ] <br>
This filter may be used to create gaps in the data with
bytes equal to value. You can think of it as reversing the
effects of the -Fill filter. The gaps will only be <br>
created if the are at least min&acirc;run&acirc;length bytes
in a row (defaults to 1).</p>

<p style="margin-top: 1em">-Un_SPlit multiple [ offset [
width ] ] <br>
This filter may be used to reverse the effects of the split
filter. The arguments are identical. Note that the address
range is expanded (multiple / width) times, leav&acirc; <br>
ing holes between the stripes.</p>

<p style="margin-top: 1em">-WHIrlpool address <br>
This filter may be used to insert a 64 byte WHIRLPOOL hash
into the data, at the address given.</p>

<p style="margin-top: 1em">Address Ranges <br>
There are eight ways to specify an address range:</p>

<p style="margin-top: 1em">minimum maximum <br>
If you specify two number on the command line (decimal,
octal and hexadecimal are understood, using the C
conventions) this is an explicit address range. The minimum
is <br>
inclusive, the maximum is exclusive (one more than the last
address). If the maximum is given as zero then the range
extends to the end of the address space.</p>

<p style="margin-top: 1em">-Within
input&acirc;specification <br>
This says to use the specified input file as a mask. The
range includes all the places the specified input has data,
and holes where it has holes. The input specifica&acirc;
<br>
tion need not be just a file name, it may be anything any
other input specification can be.</p>

<p style="margin-top: 1em">See also the -over option for a
discussion on operator precedence.</p>

<p style="margin-top: 1em">-OVER input&acirc;specification
<br>
This says to use the specified input file as a mask. The
range extends from the minimum to the maximum address used
by the input, without any holes, even if the input <br>
has holes. The input specification need not be just a file
name, it may be anything any other input specification can
be.</p>

<p style="margin-top: 1em">You may need to enclose
input&acirc;specification in parentheses to make sure it
can&rsquo;t misinterpret which arguments go with which input
specification. This is particularly <br>
important when a filter is to follow. For example <br>
filename -fill 0 -over filename2 -swap&acirc;bytes <br>
groups as <br>
filename -fill 0 -over &rsquo;(&rsquo; filename2
-swap&acirc;bytes &rsquo;)&rsquo; <br>
when what you actually wanted was <br>
&rsquo;(&rsquo; filename -fill 0 -over filename2
&rsquo;)&rsquo; -swap&acirc;bytes <br>
The command line expression parsing tends to be
&acirc;greedy&acirc; (or right associative) rather than
conservative (or left associative).</p>

<p style="margin-top: 1em">address&acirc;range
-RAnge&acirc;PADding number <br>
It is also possible to pad ranges to be whole aligned
multiples of the given number. For example <br>
input&acirc;file -fill 0xFF -within input&acirc;file
-range&acirc;pad 512 <br>
will fill the input&acirc;file so that it consists of whole
512&acirc;byte blocks, aligned on 512 byte boundaries. Any
large holes in the data will also be multiples of 512 bytes,
<br>
though they may have been shrunk as blocks before and after
are padded.</p>

<p style="margin-top: 1em">This operator has the same
precedence as the explicit union operator.</p>

<p style="margin-top: 1em">address&acirc;range -INTERsect
address&acirc;range <br>
You can intersect two address ranges to produce a smaller
address range. The intersection operator has higher
precedence than the implicit union operator (evaluated left
<br>
to right).</p>

<p style="margin-top: 1em">address&acirc;range -UNIon
address&acirc;range <br>
You can union two address ranges to produce a larger address
range. The union operator has lower precedence than the
intersection operator (evaluated left to right).</p>

<p style="margin-top: 1em">address&acirc;range -DIFference
address&acirc;range <br>
You can difference two address ranges to produce a smaller
address range. The result is the left hand range with all of
the right hand range removed. The difference <br>
operator has the same precedence as the implicit union
operator (evaluated left to right).</p>

<p style="margin-top: 1em">address&acirc;range
address&acirc;range <br>
In addition, all of these methods may be used, and used more
than once, and the results will be combined (implicit union
operator, same precedence as explicit union oper&acirc; <br>
ator).</p>

<p style="margin-top: 1em">Calculated Values <br>
Most of the places above where a number is expected, you may
supply one of the following:</p>

<p style="margin-top: 1em">- value <br>
The value of this expression is the negative of the
expression argument. Note the space between the minus sign
and its argument: this space is mandatory. <br>
srec_cat in.srec -offset &acirc; -minimum&acirc;addr in.srec
-o out.srec <br>
This example shows how to move data to the base of
memory.</p>

<p style="margin-top: 1em">( value ) <br>
You may use parentheses for grouping. When using
parentheses, they must each be a separate command line
argument, they can&rsquo;t be within the text of the
preceding or fol&acirc; <br>
lowing option, and you will need to quote them to get them
past the shell, such as &rsquo;(&rsquo; and
&rsquo;)&rsquo;.</p>

<p style="margin-top: 1em">-MINimum&acirc;Address
input&acirc;specification <br>
This inserts the minimum address of the specified input
file. The input specification need not be just a file name,
it may be anything any other input specification can <br>
be.</p>

<p style="margin-top: 1em">See also the -over option for a
discussion on operator precedence.</p>

<p style="margin-top: 1em">-MAXimum&acirc;Address
input&acirc;specification <br>
This inserts the maximum address of the specified input
file, plus one. The input specification need not be just a
file name, it may be anything any other input specifi&acirc;
<br>
cation can be.</p>

<p style="margin-top: 1em">See also the -over option for a
discussion on operator precedence.</p>

<p style="margin-top: 1em">-Length
input&acirc;specification <br>
This inserts the length of the address range in the
specified input file, ignoring any holes. The input
specification need not be just a file name, it may be
anything <br>
any other input specification can be.</p>

<p style="margin-top: 1em">See also the -over option for a
discussion on operator precedence.</p>

<p style="margin-top: 1em">For example, the -OVER
input&acirc;specification option can be thought of as
short&acirc;hand for &rsquo;(&rsquo; -min file -max file
&rsquo;)&rsquo;, except that it is much easier to type, and
also more efficient.</p>

<p style="margin-top: 1em">In addition, calculated values
may optionally be rounded in one of three ways:</p>

<p style="margin-top: 1em">value -Round_Down number <br>
The value is rounded down to the the largest integer smaller
than or equal to a whole multiple of the number.</p>

<p style="margin-top: 1em">value -Round_Nearest number <br>
The value is rounded to the the nearest whole multiple of
the number.</p>

<p style="margin-top: 1em">value -Round_Up number <br>
The value is rounded up to the the smallest integer larger
than or equal to a whole multiple of the number.</p>

<p style="margin-top: 1em">When using parentheses, they
must each be a separate command line argument, they
can&rsquo;t be within the text of the preceding or following
option, and you will need to quote them to <br>
get them past the shell, as &rsquo;(&rsquo; and
&rsquo;)&rsquo;.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
srec_input version 1.64 <br>
Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004,
2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014
Peter Miller</p>

<p style="margin-top: 1em">The srec_input program comes
with ABSOLUTELY NO WARRANTY; for details use the
&rsquo;srec_input -VERSion License&rsquo; command. This is
free software and you are welcome to redistribute it <br>
under certain conditions; for details use the
&rsquo;srec_input -VERSion License&rsquo; command.</p>

<p style="margin-top: 1em">MAINTAINER <br>
Scott Finneran E&acirc;Mail: scottfinneran@yahoo.com.au <br>
Peter Miller E&acirc;Mail: pmiller@opensource.org.au</p>

<p style="margin-top: 1em">Reference Manual SRecord
srec_input(1)</p>
<hr>
</body>
</html>
