<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:57:36 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>CCACHE(1) ccache Manual CCACHE(1)</p>

<p style="margin-top: 1em">NAME <br>
ccache - a fast C/C++ compiler cache</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ccache [options] <br>
ccache compiler [compiler options] <br>
compiler [compiler options] (via symbolic link)</p>

<p style="margin-top: 1em">DESCRIPTION <br>
ccache is a compiler cache. It speeds up recompilation by
caching the result of previous compilations and detecting
when the same compilation is being done again. Supported
<br>
languages are C, C++, Objective-C and Objective-C++.</p>

<p style="margin-top: 1em">ccache has been carefully
written to always produce exactly the same compiler output
that you would get without the cache. The only way you
should be able to tell that you are <br>
using ccache is the speed. Currently known exceptions to
this goal are listed under CAVEATS. If you ever discover an
undocumented case where ccache changes the output of your
<br>
compiler, please let us know.</p>

<p style="margin-top: 1em">Features <br>
&Acirc;&middot; Keeps statistics on hits/misses.</p>

<p style="margin-top: 1em">&Acirc;&middot; Automatic cache
size management.</p>

<p style="margin-top: 1em">&Acirc;&middot; Can cache
compilations that generate warnings.</p>

<p style="margin-top: 1em">&Acirc;&middot; Easy
installation.</p>

<p style="margin-top: 1em">&Acirc;&middot; Low
overhead.</p>

<p style="margin-top: 1em">&Acirc;&middot; Optionally uses
hard links where possible to avoid copies.</p>

<p style="margin-top: 1em">&Acirc;&middot; Optionally
compresses files in the cache to reduce disk space.</p>

<p style="margin-top: 1em">Limitations <br>
&Acirc;&middot; Only knows how to cache the compilation of a
single C/C++/Objective-C/Objective-C++ file. Other types of
compilations (multi-file compilation, linking, etc) will
silently <br>
fall back to running the real compiler.</p>

<p style="margin-top: 1em">&Acirc;&middot; Only works with
GCC and compilers that behave similar enough.</p>

<p style="margin-top: 1em">&Acirc;&middot; Some compiler
flags are not supported. If such a flag is detected, ccache
will silently fall back to running the real compiler.</p>

<p style="margin-top: 1em">RUN MODES <br>
There are two ways to use ccache. You can either prefix your
compilation commands with ccache or you can let ccache
masquerade as the compiler by creating a symbolic link
(named <br>
as the compiler) to ccache. The first method is most
convenient if you just want to try out ccache or wish to use
it for some specific projects. The second method is most
useful <br>
for when you wish to use ccache for all your
compilations.</p>

<p style="margin-top: 1em">To use the second method on a
Debian system, it&rsquo;s easiest to just prepend
/usr/lib/ccache to your PATH. /usr/lib/ccache contains
symlinks for all compilers currently installed as <br>
Debian packages.</p>

<p style="margin-top: 1em">Alternatively, you can create
any symlinks you like yourself like this:</p>

<p style="margin-top: 1em">ln -s /usr/bin/ccache
/usr/local/bin/gcc <br>
ln -s /usr/bin/ccache /usr/local/bin/g++ <br>
ln -s /usr/bin/ccache /usr/local/bin/cc <br>
ln -s /usr/bin/ccache /usr/local/bin/c++</p>

<p style="margin-top: 1em">And so forth. This will work as
long as the directory with symlinks comes before the path to
the compiler (which is usually in /usr/bin). After
installing you may wish to run <br>
&acirc;which gcc&acirc; to make sure that the correct link
is being used.</p>

<p style="margin-top: 1em">Warning <br>
The technique of letting ccache masquerade as the compiler
works well, but currently doesn&acirc;t interact well with
other tools that do the same thing. See USING CCACHE WITH
<br>
OTHER COMPILER WRAPPERS.</p>

<p style="margin-top: 1em">Warning <br>
Do not use a hard link, use a symbolic link. A hard link
will cause &acirc;interesting&acirc; problems.</p>

<p style="margin-top: 1em">OPTIONS <br>
These options only apply when you invoke ccache as
&acirc;ccache&acirc;. When invoked as a compiler (via a
symlink as described in the previous section), the normal
compiler options apply <br>
and you should refer to the compiler&acirc;s
documentation.</p>

<p style="margin-top: 1em">-c, --cleanup <br>
Clean up the cache by removing old cached files until the
specified file number and cache size limits are not
exceeded. This also recalculates the cache file count and
size <br>
totals. Normally, there is no need to initiate cleanup
manually as ccache keeps the cache below the specified
limits at runtime and keeps statistics up to date on each
<br>
compilation. Forcing a cleanup is mostly useful if you
manually modify the cache contents or believe that the cache
size statistics may be inaccurate.</p>

<p style="margin-top: 1em">-C, --clear <br>
Clear the entire cache, removing all cached files, but
keeping the configuration file.</p>

<p style="margin-top: 1em">-F, --max-files=N <br>
Set the maximum number of files allowed in the cache. Use 0
for no limit. The value is stored in a configuration file in
the cache directory and applies to all future <br>
compilations.</p>

<p style="margin-top: 1em">-h, --help <br>
Print an options summary page.</p>

<p style="margin-top: 1em">-M, --max-size=SIZE <br>
Set the maximum size of the files stored in the cache. SIZE
should be a number followed by an optional suffix: k, M, G,
T (decimal), Ki, Mi, Gi or Ti (binary). The default <br>
suffix is G. Use 0 for no limit. The value is stored in a
configuration file in the cache directory and applies to all
future compilations.</p>

<p style="margin-top: 1em">-o, --set-config=KEY=VALUE <br>
Set configuration KEY to VALUE. See CONFIGURATION for more
information.</p>

<p style="margin-top: 1em">-p, --print-config <br>
Print current configuration options and from where they
originate (environment variable, configuration file or
compile-time default).</p>

<p style="margin-top: 1em">-s, --show-stats <br>
Print the current statistics summary for the cache.</p>

<p style="margin-top: 1em">-V, --version <br>
Print version and copyright information.</p>

<p style="margin-top: 1em">-z, --zero-stats <br>
Zero the cache statistics (but not the configuration
options).</p>

<p style="margin-top: 1em">EXTRA OPTIONS <br>
When run as a compiler, ccache usually just takes the same
command line options as the compiler you are using. The only
exception to this is the option --ccache-skip. That option
<br>
can be used to tell ccache to avoid interpreting the next
option in any way and to pass it along to the compiler
as-is. Note: --ccache-skip currently only tells ccache not
to <br>
interpret the next option as a special compiler option
&acirc; the option will still be included in the direct mode
hash.</p>

<p style="margin-top: 1em">The reason this can be important
is that ccache does need to parse the command line and
determine what is an input filename and what is a compiler
option, as it needs the input <br>
filename to determine the name of the resulting object file
(among other things). The heuristic ccache uses when parsing
the command line is that any argument that exists as a <br>
file is treated as an input file name. By using
--ccache-skip you can force an option to not be treated as
an input file name and instead be passed along to the
compiler as a <br>
command line option.</p>

<p style="margin-top: 1em">Another case where --ccache-skip
can be useful is if ccache interprets an option specially
but shouldn&acirc;t, since the option has another meaning
for your compiler than what ccache <br>
thinks.</p>

<p style="margin-top: 1em">CONFIGURATION <br>
ccache&acirc;s default behavior can be overridden by
configuration file settings, which in turn can be overridden
by environment variables with names starting with CCACHE_.
ccache <br>
normally reads configuration from two files: first a
system-level configuration file and secondly a
cache-specific configuration file. The priority of
configuration settings is <br>
as follows (where 1 is highest):</p>

<p style="margin-top: 1em">1. Environment variables.</p>

<p style="margin-top: 1em">2. The cache-specific
configuration file &lt;ccachedir&gt;/ccache.conf (typically
$HOME/.ccache/ccache.conf).</p>

<p style="margin-top: 1em">3. The system-wide configuration
file &lt;sysconfdir&gt;/ccache.conf (typically
/etc/ccache.conf or /usr/local/etc/ccache.conf).</p>

<p style="margin-top: 1em">4. Compile-time defaults.</p>

<p style="margin-top: 1em">As a special case, if the
environment variable CCACHE_CONFIGPATH is set, ccache reads
configuration from the specified path instead of the default
paths.</p>

<p style="margin-top: 1em">Configuration file syntax <br>
Configuration files are in a simple &acirc;key =
value&acirc; format, one setting per line. Lines starting
with a hash sign are comments. Blank lines are ignored, as
is whitespace <br>
surrounding keys and values. Example:</p>

<p style="margin-top: 1em"># Set maximum cache size to 10
GB: <br>
max_size = 10G</p>

<p style="margin-top: 1em">Boolean values <br>
Some settings are boolean values (i.e. truth values). In a
configuration file, such values must be set to the string
true or false. For the corresponding environment variables,
<br>
the semantics are a bit different: a set environment
variable means &acirc;true&acirc; regardless of the value
(even if set to the empty string), and an unset environment
variable means <br>
&acirc;false&acirc;. Each boolean environment variable also
has a negated form starting with CCACHE_NO. For example,
CCACHE_COMPRESS can be set to force compression and
CCACHE_NOCOMPRESS can <br>
be set to force no compression.</p>

<p style="margin-top: 1em">Configuration settings <br>
Below is a list of available configuration settings. The
corresponding environment variable name is indicated in
parentheses after each configuration setting key.</p>

<p style="margin-top: 1em">base_dir (CCACHE_BASEDIR) <br>
This setting should be an absolute path to a directory.
ccache then rewrites absolute paths into relative paths
before computing the hash that identifies the compilation,
but <br>
only for paths under the specified directory. If set to the
empty string (which is the default), no rewriting is done.
See also the discussion under COMPILING IN DIFFERENT <br>
DIRECTORIES. If using GCC or newer versions of Clang, you
might want to look into the -fdebug-prefix-map=old=new
option for relocating debug info to a common prefix (mapping
<br>
prefix with old=new).</p>

<p style="margin-top: 1em">cache_dir (CCACHE_DIR) <br>
This setting specifies where ccache will keep its cached
compiler outputs. It will only take effect if set in the
system-wide configuration file or as an environment <br>
variable. The default is $HOME/.ccache.</p>

<p style="margin-top: 1em">cache_dir_levels
(CCACHE_NLEVELS) <br>
This setting allows you to choose the number of directory
levels in the cache directory. The default is 2. The minimum
is 1 and the maximum is 8.</p>

<p style="margin-top: 1em">compiler (CCACHE_CC) <br>
This setting can be used to force the name of the compiler
to use. If set to the empty string (which is the default),
ccache works it out from the command line.</p>

<p style="margin-top: 1em">compiler_check
(CCACHE_COMPILERCHECK) <br>
By default, ccache includes the modification time
(&acirc;mtime&acirc;) and size of the compiler in the hash
to ensure that results retrieved from the cache are
accurate. This setting <br>
can be used to select another strategy. Possible values
are:</p>

<p style="margin-top: 1em">content <br>
Hash the content of the compiler binary. This makes ccache
very slightly slower compared to the mtime setting, but
makes it cope better with compiler upgrades during a <br>
build bootstrapping process.</p>

<p style="margin-top: 1em">mtime <br>
Hash the compiler&acirc;s mtime and size, which is fast.
This is the default.</p>

<p style="margin-top: 1em">none <br>
Don&acirc;t hash anything. This may be good for situations
where you can safely use the cached results even though the
compiler&acirc;s mtime or size has changed (e.g. if the <br>
compiler is built as part of your build system and the
compiler&acirc;s source has not changed, or if the compiler
only has changes that don&acirc;t affect code generation).
You <br>
should only use the none setting if you know what you are
doing.</p>

<p style="margin-top: 1em">string:value <br>
Use value as the string to calculate hash from. This can be
the compiler revision number you retrieved earlier and set
here via environment variable.</p>

<p style="margin-top: 1em">a command string <br>
Hash the standard output and standard error output of the
specified command. The string will be split on whitespace to
find out the command and arguments to run. No other <br>
interpretation of the command string will be done, except
that the special word %compiler% will be replaced with the
path to the compiler. Several commands can be <br>
specified with semicolon as separator. Examples:</p>

<p style="margin-top: 1em">&Acirc;&middot; %compiler%
-v</p>

<p style="margin-top: 1em">&Acirc;&middot; %compiler%
-dumpmachine; %compiler% -dumpversion</p>

<p style="margin-top: 1em">You should make sure that the
specified command is as fast as possible since it will be
run once for each ccache invocation.</p>

<p style="margin-top: 1em">Identifying the compiler using a
command is useful if you want to avoid cache misses when the
compiler has been rebuilt but not changed.</p>

<p style="margin-top: 1em">Another case is when the
compiler (as seen by ccache) actually isn&acirc;t the real
compiler but another compiler wrapper &acirc; in that case,
the default mtime method will hash the <br>
mtime and size of the other compiler wrapper, which means
that ccache won&acirc;t be able to detect a compiler
upgrade. Using a suitable command to identify the compiler
is <br>
thus safer, but it&acirc;s also slower, so you should
consider continue using the mtime method in combination with
the prefix_command setting if possible. See USING CCACHE
WITH <br>
OTHER COMPILER WRAPPERS.</p>

<p style="margin-top: 1em">compression (CCACHE_COMPRESS or
CCACHE_NOCOMPRESS, see Boolean values above) <br>
If true, ccache will compress object files and other
compiler output it puts in the cache. However, this setting
has no effect on how files are retrieved from the cache;
<br>
compressed and uncompressed results will still be usable
regardless of this setting. The default is false.</p>

<p style="margin-top: 1em">compression_level
(CCACHE_COMPRESSLEVEL) <br>
This setting determines the level at which ccache will
compress object files. It only has effect if compression is
enabled. The value defaults to 6, and must be no lower than
<br>
1 (fastest, worst compression) and no higher than 9
(slowest, best compression).</p>

<p style="margin-top: 1em">cpp_extension (CCACHE_EXTENSION)
<br>
This setting can be used to force a certain extension for
the intermediate preprocessed file. The default is to
automatically determine the extension to use for
intermediate <br>
preprocessor files based on the type of file being compiled,
but that sometimes doesn&acirc;t work. For example, when
using the &acirc;aCC&acirc; compiler on HP-UX, set the cpp
extension to i.</p>

<p style="margin-top: 1em">direct_mode (CCACHE_DIRECT or
CCACHE_NODIRECT, see Boolean values above) <br>
If true, the direct mode will be used. The default is true.
See THE DIRECT MODE.</p>

<p style="margin-top: 1em">disable (CCACHE_DISABLE or
CCACHE_NODISABLE, see Boolean values above) <br>
When true, ccache will just call the real compiler,
bypassing the cache completely. The default is false.</p>

<p style="margin-top: 1em">extra_files_to_hash
(CCACHE_EXTRAFILES) <br>
This setting is a list of paths to files that ccache will
include in the the hash sum that identifies the build. The
list separator is semicolon on Windows systems and colon
<br>
on other systems.</p>

<p style="margin-top: 1em">hard_link (CCACHE_HARDLINK or
CCACHE_NOHARDLINK, see Boolean values above) <br>
If true, ccache will attempt to use hard links from the
cache directory when creating the compiler output rather
than using a file copy. Using hard links may be slightly
<br>
faster in some situations, but can confuse programs like
&acirc;make&acirc; that rely on modification times. Another
thing to keep in mind is that if the resulting object file
is <br>
modified in any way, this corrupts the cached object file as
well. Hard links are never made for compressed cache files.
This means that you should not enable compression if <br>
you want to use hard links. The default is false.</p>

<p style="margin-top: 1em">hash_dir (CCACHE_HASHDIR or
CCACHE_NOHASHDIR, see Boolean values above) <br>
If true (which is the default), ccache will include the
current working directory (CWD) in the hash that is used to
distinguish two compilations when generating debug info <br>
(compiler option -g with variations). Exception: The CWD
will not be included in the hash if base_dir is set (and
matches the CWD) and the compiler option -fdebug-prefix-map
<br>
is used.</p>

<p style="margin-top: 1em">The reason for including the CWD
in the hash by default is to prevent a <br>
problem with the storage of the current working directory in
the debug info <br>
of an object file, which can lead ccache to return a cached
object file <br>
that has the working directory in the debug info set
incorrectly.</p>

<p style="margin-top: 1em">You can disable this setting to
get cache hits when compiling the same <br>
source code in different directories if you don&rsquo;t mind
that CWD in the <br>
debug info might be incorrect.</p>

<p style="margin-top: 1em">ignore_headers_in_manifest
(CCACHE_IGNOREHEADERS) <br>
This setting is a list of paths to files (or directories
with headers) that ccache will not include in the manifest
list that makes up the direct mode. Note that this can <br>
cause stale cache hits if those headers do indeed change.
The list separator is semicolon on Windows systems and colon
on other systems.</p>

<p style="margin-top: 1em">keep_comments_cpp
(CCACHE_COMMENTS or CCACHE_NOCOMMENTS, see Boolean values
above) <br>
If true, ccache will not discard the comments before hashing
preprocessor output. This can be used to check documentation
with -Wdocumentation.</p>

<p style="margin-top: 1em">limit_multiple
(CCACHE_LIMIT_MULTIPLE) <br>
Sets the limit when cleaning up. Files are deleted (in LRU
order) until the levels are below the limit. The default is
0.8 (= 80%).</p>

<p style="margin-top: 1em">log_file (CCACHE_LOGFILE) <br>
If set to a file path, ccache will write information on what
it is doing to the specified file. This is useful for
tracking down problems.</p>

<p style="margin-top: 1em">max_files (CCACHE_MAXFILES) <br>
This option specifies the maximum number of files to keep in
the cache. Use 0 for no limit (which is the default).</p>

<p style="margin-top: 1em">max_size (CCACHE_MAXSIZE) <br>
This option specifies the maximum size of the cache. Use 0
for no limit. The default value is 5G. Available suffixes:
k, M, G, T (decimal) and Ki, Mi, Gi, Ti (binary). The <br>
default suffix is &quot;G&quot;.</p>

<p style="margin-top: 1em">path (CCACHE_PATH) <br>
If set, ccache will search directories in this list when
looking for the real compiler. The list separator is
semicolon on Windows systems and colon on other systems. If
not <br>
set, ccache will look for the first executable matching the
compiler name in the normal PATH that isn&acirc;t a symbolic
link to ccache itself.</p>

<p style="margin-top: 1em">prefix_command (CCACHE_PREFIX)
<br>
This option adds a list of prefixes (separated by space) to
the command line that ccache uses when invoking the
compiler. See also USING CCACHE WITH OTHER COMPILER
WRAPPERS.</p>

<p style="margin-top: 1em">prefix_command_cpp
(CCACHE_PREFIX_CPP) <br>
This option adds a list of prefixes (separated by space) to
the command line that ccache uses when invoking the
preprocessor.</p>

<p style="margin-top: 1em">read_only (CCACHE_READONLY or
CCACHE_NOREADONLY, see Boolean values above) <br>
If true, ccache will attempt to use existing cached object
files, but it will not to try to add anything new to the
cache. If you are using this because your ccache directory
<br>
is read-only, then you need to set temporary_dir as
otherwise ccache will fail to create temporary files.</p>

<p style="margin-top: 1em">read_only_direct
(CCACHE_READONLY_DIRECT or CCACHE_NOREADONLY_DIRECT, see
Boolean values above) <br>
Just like read_only except that ccache will only try to
retrieve results from the cache using the direct mode, not
the preprocessor mode. See documentation for read_only <br>
regarding using a read-only ccache directory.</p>

<p style="margin-top: 1em">recache (CCACHE_RECACHE or
CCACHE_NORECACHE, see Boolean values above) <br>
If true, ccache will not use any previously stored result.
New results will still be cached, possibly overwriting any
pre-existing results.</p>

<p style="margin-top: 1em">run_second_cpp (CCACHE_CPP2 or
CCACHE_NOCPP2, see Boolean values above) <br>
If true, ccache will first run the preprocessor to
preprocess the source code (see THE PREPROCESSOR MODE) and
then on a cache miss run the compiler on the source code to
get <br>
hold of the object file. This is the default.</p>

<p style="margin-top: 1em">If false, ccache will first run
preprocessor to preprocess the source code <br>
and then on a cache miss run the compiler on the
_preprocessed source code_ <br>
instead of the original source code. This makes cache misses
slightly <br>
faster since the source code only has to be preprocessed
once. The downside <br>
is that some compilers won&rsquo;t produce the same result
(for instance <br>
diagnostics warnings) when compiling preprocessed source
code.</p>

<p style="margin-top: 1em">sloppiness (CCACHE_SLOPPINESS)
<br>
By default, ccache tries to give as few false cache hits as
possible. However, in certain situations it&acirc;s possible
that you know things that ccache can&acirc;t take for
granted. <br>
This setting makes it possible to tell ccache to relax some
checks in order to increase the hit rate. The value should
be a comma-separated string with options. Available <br>
options are:</p>

<p style="margin-top: 1em">file_macro <br>
Ignore __FILE__ being present in the source.</p>

<p style="margin-top: 1em">file_stat_matches <br>
ccache normally examines a file&acirc;s contents to
determine whether it matches the cached version. With this
option set, ccache will consider a file as matching its
cached <br>
version if the sizes, mtimes and ctimes match.</p>

<p style="margin-top: 1em">include_file_ctime <br>
By default, ccache also will not cache a file if it includes
a header whose ctime is too new. This option disables that
check.</p>

<p style="margin-top: 1em">include_file_mtime <br>
By default, ccache will not cache a file if it includes a
header whose mtime is too new. This option disables that
check.</p>

<p style="margin-top: 1em">no_system_headers <br>
By default, ccache will also include all system headers in
the manifest. With this option set, ccache will only include
system headers in the hash but not add the system <br>
header files to the list of include files.</p>

<p style="margin-top: 1em">pch_defines <br>
Be sloppy about #defines when precompiling a header file.
See PRECOMPILED HEADERS for more information.</p>

<p style="margin-top: 1em">time_macros <br>
Ignore __DATE__ and __TIME__ being present in the source
code.</p>

<p style="margin-top: 1em">See the discussion under
TROUBLESHOOTING for more information.</p>

<p style="margin-top: 1em">stats (CCACHE_STATS or
CCACHE_NOSTATS, see Boolean values above) <br>
If true, ccache will update the statistics counters on each
compilation. The default is true.</p>

<p style="margin-top: 1em">temporary_dir (CCACHE_TEMPDIR)
<br>
This setting specifies where ccache will put temporary
files. The default is &lt;cache_dir&gt;/tmp.</p>

<p style="margin-top: 1em">Note <br>
In previous versions of ccache, CCACHE_TEMPDIR had to be on
the same filesystem as the CCACHE_DIR path, but this
requirement has been relaxed.)</p>

<p style="margin-top: 1em">umask (CCACHE_UMASK) <br>
This setting specifies the umask for ccache and all child
processes (such as the compiler). This is mostly useful when
you wish to share your cache with other users. Note <br>
that this also affects the file permissions set on the
object files created from your compilations.</p>

<p style="margin-top: 1em">unify (CCACHE_UNIFY or
CCACHE_NOUNIFY, see Boolean values above) <br>
If true, ccache will use a C/C++ unifier when hashing the
preprocessor output if the -g option is not used. The
unifier is slower than a normal hash, so setting this <br>
environment variable loses a little bit of speed, but it
means that ccache can take advantage of not recompiling when
the changes to the source code consist of reformatting <br>
only. Note that enabling the unifier changes the hash, so
cached compilations produced when the unifier is enabled
cannot be reused when the unifier is disabled, and vice <br>
versa. Enabling the unifier may result in incorrect line
number information in compiler warning messages and
expansions of the __LINE__ macro. Also note that enabling
the <br>
unifier implies turning off the direct mode.</p>

<p style="margin-top: 1em">CACHE SIZE MANAGEMENT <br>
By default, ccache has a five gigabyte limit on the total
size of files in the cache and no maximum number of files.
You can set different limits using the -M/--max-size and
<br>
-F/--max-files options. Use ccache -s/--show-stats to see
the cache size and the currently configured limits (in
addition to other various statistics).</p>

<p style="margin-top: 1em">CACHE COMPRESSION <br>
ccache can optionally compress all files it puts into the
cache using the compression library zlib. While this may
involve a tiny performance slowdown, it increases the number
of <br>
files that fit in the cache. You can turn on compression
with the compression configuration setting and you can also
tweak the compression level with compression_level.</p>

<p style="margin-top: 1em">HOW CCACHE WORKS <br>
The basic idea is to detect when you are compiling exactly
the same code a second time and reuse the previously
produced output. The detection is done by hashing different
kinds <br>
of information that should be unique for the compilation and
then using the hash sum to identify the cached output.
ccache uses MD4, a very fast cryptographic hash algorithm,
for <br>
the hashing. (MD4 is nowadays too weak to be useful in
cryptographic contexts, but it should be safe enough to be
used to identify recompilations.) On a cache hit, ccache is
able <br>
to supply all of the correct compiler outputs (including all
warnings, dependency file, etc) from the cache.</p>

<p style="margin-top: 1em">ccache has two ways of doing the
detection:</p>

<p style="margin-top: 1em">&Acirc;&middot; the direct mode,
where ccache hashes the source code and include files
directly</p>

<p style="margin-top: 1em">&Acirc;&middot; the preprocessor
mode, where ccache runs the preprocessor on the source code
and hashes the result</p>

<p style="margin-top: 1em">The direct mode is generally
faster since running the preprocessor has some overhead.</p>

<p style="margin-top: 1em">Common hashed information <br>
For both modes, the following information is included in the
hash:</p>

<p style="margin-top: 1em">&Acirc;&middot; the extension
used by the compiler for a file with preprocessor output
(normally .i for C code and .ii for C++ code)</p>

<p style="margin-top: 1em">&Acirc;&middot; the
compiler&acirc;s size and modification time (or other
compiler-specific information specified by the
compiler_check setting)</p>

<p style="margin-top: 1em">&Acirc;&middot; the name of the
compiler</p>

<p style="margin-top: 1em">&Acirc;&middot; the current
directory (if the hash_dir setting is enabled)</p>

<p style="margin-top: 1em">&Acirc;&middot; contents of
files specified by the extra_files_to_hash setting (if
any)</p>

<p style="margin-top: 1em">The direct mode <br>
In the direct mode, the hash is formed of the common
information and:</p>

<p style="margin-top: 1em">&Acirc;&middot; the input source
file</p>

<p style="margin-top: 1em">&Acirc;&middot; the command line
options</p>

<p style="margin-top: 1em">Based on the hash, a data
structure called &acirc;manifest&acirc; is looked up in the
cache. The manifest contains:</p>

<p style="margin-top: 1em">&Acirc;&middot; references to
cached compilation results (object file, dependency file,
etc) that were produced by previous compilations that
matched the hash</p>

<p style="margin-top: 1em">&Acirc;&middot; paths to the
include files that were read at the time the compilation
results were stored in the cache</p>

<p style="margin-top: 1em">&Acirc;&middot; hash sums of the
include files at the time the compilation results were
stored in the cache</p>

<p style="margin-top: 1em">The current contents of the
include files are then hashed and compared to the
information in the manifest. If there is a match, ccache
knows the result of the compilation. If <br>
there is no match, ccache falls back to running the
preprocessor. The output from the preprocessor is parsed to
find the include files that were read. The paths and hash
sums of <br>
those include files are then stored in the manifest along
with information about the produced compilation result.</p>

<p style="margin-top: 1em">There is a catch with the direct
mode: header files that were used by the compiler are
recorded, but header files that were not used, but would
have been used if they existed, <br>
are not. So, when ccache checks if a result can be taken
from the cache, it currently can&acirc;t check if the
existence of a new header file should invalidate the result.
In practice, <br>
the direct mode is safe to use in the absolute majority of
cases.</p>

<p style="margin-top: 1em">The direct mode will be disabled
if any of the following holds:</p>

<p style="margin-top: 1em">&Acirc;&middot; the
configuration setting direct_mode is false</p>

<p style="margin-top: 1em">&Acirc;&middot; a modification
time of one of the include files is too new (needed to avoid
a race condition)</p>

<p style="margin-top: 1em">&Acirc;&middot; the unifier is
enabled (the configuration setting unify is true)</p>

<p style="margin-top: 1em">&Acirc;&middot; a compiler
option not supported by the direct mode is used:</p>

<p style="margin-top: 1em">&Acirc;&middot; a -Wp,X compiler
option other than -Wp,-MD,path, -Wp,-MMD,path and
-Wp,-D_define_</p>

<p style="margin-top: 1em">&Acirc;&middot;
-Xpreprocessor</p>

<p style="margin-top: 1em">&Acirc;&middot; the string
&acirc;__TIME__&acirc; is present in the source code</p>

<p style="margin-top: 1em">The preprocessor mode <br>
In the preprocessor mode, the hash is formed of the common
information and:</p>

<p style="margin-top: 1em">&Acirc;&middot; the preprocessor
output from running the compiler with -E</p>

<p style="margin-top: 1em">&Acirc;&middot; the command line
options except options that affect include files (-I,
-include, -D, etc; the theory is that these options will
change the preprocessor output if they have <br>
any effect at all)</p>

<p style="margin-top: 1em">&Acirc;&middot; any standard
error output generated by the preprocessor</p>

<p style="margin-top: 1em">Based on the hash, the cached
compilation result can be looked up directly in the
cache.</p>

<p style="margin-top: 1em">COMPILING IN DIFFERENT
DIRECTORIES <br>
Some information included in the hash that identifies a
unique compilation may contain absolute paths:</p>

<p style="margin-top: 1em">&Acirc;&middot; The preprocessed
source code may contain absolute paths to include files if
the compiler option -g is used or if absolute paths are
given to -I and similar compiler options.</p>

<p style="margin-top: 1em">&Acirc;&middot; Paths specified
by compiler options (such as -I, -MF, etc) may be
absolute.</p>

<p style="margin-top: 1em">&Acirc;&middot; The source code
file path may be absolute, and that path may substituted for
__FILE__ macros in the source code or included in warnings
emitted to standard error by the <br>
preprocessor.</p>

<p style="margin-top: 1em">This means that if you compile
the same code in different locations, you can&acirc;t share
compilation results between the different build directories
since you get cache misses <br>
because of the absolute build directory paths that are part
of the hash. To mitigate this problem, you can specify a
&acirc;base directory&acirc; in the configuration setting
base_dir to an <br>
absolute path to the directory. ccache will then rewrite
absolute paths that are under the base directory (i.e.,
paths that have the base directory as a prefix) to relative
paths <br>
when constructing the hash. A typical path to use as the
base directory is your home directory or another directory
that is a parent of your build directories. (Don&acirc;t use
/ as <br>
the base directory since that will make ccache also rewrite
paths to system header files, which doesn&acirc;t gain
anything.)</p>

<p style="margin-top: 1em">The drawbacks of using a base
directory are:</p>

<p style="margin-top: 1em">&Acirc;&middot; If you specify
an absolute path to the source code file, __FILE__ macros
will be expanded to a relative path instead.</p>

<p style="margin-top: 1em">&Acirc;&middot; If you specify
an absolute path to the source code file and compile with
-g, the source code path stored in the object file may point
to the wrong directory, which may <br>
prevent debuggers like GDB from finding the source code.
Sometimes, a work-around is to change the directory
explicitly with the &acirc;cd&acirc; command in GDB.</p>

<p style="margin-top: 1em">PRECOMPILED HEADERS <br>
ccache has support for GCC&acirc;s precompiled headers.
However, you have to do some things to make it work
properly:</p>

<p style="margin-top: 1em">&Acirc;&middot; You must set
sloppiness to pch_defines,time_macros. The reason is that
ccache can&acirc;t tell whether __TIME__ or __DATE__ is used
when using a precompiled header. Further, it <br>
can&acirc;t detect changes in #defines in the source code
because of how preprocessing works in combination with
precompiled headers.</p>

<p style="margin-top: 1em">&Acirc;&middot; You must
either:</p>

<p style="margin-top: 1em">&Acirc;&middot; use the -include
compiler option to include the precompiled header (i.e.,
don&acirc;t use #include in the source code to include the
header); or</p>

<p style="margin-top: 1em">&Acirc;&middot; (for the Clang
compiler) use the -include-pch compiler option to include
the PCH file generated from the precompiled header; or</p>

<p style="margin-top: 1em">&Acirc;&middot; add the
-fpch-preprocess compiler option when compiling.</p>

<p style="margin-top: 1em">If you don&acirc;t do this,
either the non-precompiled version of the header file will
be used (if available) or ccache will fall back to running
the real compiler and increase the <br>
statistics counter &acirc;preprocessor error&acirc; (if the
non-precompiled header file is not available).</p>

<p style="margin-top: 1em">SHARING A CACHE <br>
A group of developers can increase the cache hit rate by
sharing a cache directory. To share a cache without
unpleasant side effects, the following conditions should to
be met:</p>

<p style="margin-top: 1em">&Acirc;&middot; Use the same
cache directory.</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure that
the configuration setting hard_link is false (which is the
default).</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure that
all users are in the same group.</p>

<p style="margin-top: 1em">&Acirc;&middot; Set the
configuration setting umask to 002. This ensures that cached
files are accessible to everyone in the group.</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure that
all users have write permission in the entire cache
directory (and that you trust all users of the shared
cache).</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure that
the setgid bit is set on all directories in the cache. This
tells the filesystem to inherit group ownership for new
directories. The command &acirc;find $CCACHE_DIR <br>
-type d | xargs chmod g+s&acirc; might be useful for
this.</p>

<p style="margin-top: 1em">The reason to avoid the hard
link mode is that the hard links cause unwanted side
effects, as all links to a cached file share the
file&acirc;s modification timestamp. This results in <br>
false dependencies to be triggered by timestamp-based build
systems whenever another user links to an existing file.
Typically, users will see that their libraries and binaries
<br>
are relinked without reason.</p>

<p style="margin-top: 1em">You may also want to make sure
that a base directory is set appropriately, as discussed in
a previous section.</p>

<p style="margin-top: 1em">SHARING A CACHE ON NFS <br>
It is possible to put the cache directory on an NFS
filesystem (or similar filesystems), but keep in mind
that:</p>

<p style="margin-top: 1em">&Acirc;&middot; Having the cache
on NFS may slow down compilation. Make sure to do some
benchmarking to see if it&acirc;s worth it.</p>

<p style="margin-top: 1em">&Acirc;&middot; ccache
hasn&acirc;t been tested very thoroughly on NFS.</p>

<p style="margin-top: 1em">A tip is to set temporary_dir to
a directory on the local host to avoid NFS traffic for
temporary files.</p>

<p style="margin-top: 1em">USING CCACHE WITH OTHER COMPILER
WRAPPERS <br>
The recommended way of combining ccache with another
compiler wrapper (such as &acirc;distcc&acirc;) is by
letting ccache execute the compiler wrapper. This is
accomplished by defining the <br>
configuration setting prefix_command, for example by setting
the environment variable CCACHE_PREFIX to the name of the
wrapper (e.g. distcc). ccache will then prefix the command
<br>
line with the specified command when running the compiler.
To specify several prefix commands, set prefix_command to a
colon-separated list of commands.</p>

<p style="margin-top: 1em">Unless you set compiler_check to
a suitable command (see the description of that
configuration option), it is not recommended to use the form
ccache anotherwrapper compiler args <br>
as the compilation command. It&acirc;s also not recommended
to use the masquerading technique for the other compiler
wrapper. The reason is that by default, ccache will in both
cases <br>
hash the mtime and size of the other wrapper instead of the
real compiler, which means that:</p>

<p style="margin-top: 1em">&Acirc;&middot; Compiler
upgrades will not be detected properly.</p>

<p style="margin-top: 1em">&Acirc;&middot; The cached
results will not be shared between compilations with and
without the other wrapper.</p>

<p style="margin-top: 1em">Another minor thing is that if
prefix_command is used, ccache will not invoke the other
wrapper when running the preprocessor, which increases
performance. You can use the <br>
prefix_command_cpp configuration setting if you also want to
invoke the other wrapper when doing preprocessing (normally
by adding -E).</p>

<p style="margin-top: 1em">CAVEATS <br>
&Acirc;&middot; The direct mode fails to pick up new header
files in some rare scenarios. See THE DIRECT MODE above.</p>

<p style="margin-top: 1em">TROUBLESHOOTING <br>
General <br>
A general tip for getting information about what ccache is
doing is to enable debug logging by setting log_file. The
log contains executed commands, important decisions that
<br>
ccache makes, read and written files, etc. Another way of
keeping track of what is happening is to check the output of
ccache -s.</p>

<p style="margin-top: 1em">Performance <br>
ccache has been written to perform well out of the box, but
sometimes you may have to do some adjustments of how you use
the compiler and ccache in order to improve performance.</p>

<p style="margin-top: 1em">Since ccache works best when I/O
is fast, put the cache directory on a fast storage device if
possible. Having lots of free memory so that files in the
cache directory stay in <br>
the disk cache is also preferable.</p>

<p style="margin-top: 1em">A good way of monitoring how
well ccache works is to run ccache -s before and after your
build and then compare the statistics counters. Here are
some common problems and what <br>
may be done to increase the hit rate:</p>

<p style="margin-top: 1em">&Acirc;&middot; If &acirc;cache
hit (preprocessed)&acirc; has been incremented instead of
&acirc;cache hit (direct)&acirc;, ccache has fallen back to
preprocessor mode, which is generally slower. Some possible
<br>
reasons are:</p>

<p style="margin-top: 1em">&Acirc;&middot; The source code
has been modified in such a way that the preprocessor output
is not affected.</p>

<p style="margin-top: 1em">&Acirc;&middot; Compiler
arguments that are hashed in the direct mode but not in the
preprocessor mode have changed (-I, -include, -D, etc) and
they didn&acirc;t affect the preprocessor <br>
output.</p>

<p style="margin-top: 1em">&Acirc;&middot; The compiler
option -Xpreprocessor or -Wp,X (except -Wp,-MD,path,
-Wp,-MMD,path, and -Wp,-D_define_) is used.</p>

<p style="margin-top: 1em">&Acirc;&middot; This was the
first compilation with a new value of the base directory
setting.</p>

<p style="margin-top: 1em">&Acirc;&middot; A modification
time of one of the include files is too new (created the
same second as the compilation is being done). This check is
made to avoid a race condition. To <br>
fix this, create the include file earlier in the build
process, if possible, or set sloppiness to
include_file_mtime if you are willing to take the risk. (The
race <br>
condition consists of these events: the preprocessor is run;
an include file is modified by someone; the new include file
is hashed by ccache; the real compiler is run on <br>
the preprocessor&acirc;s output, which contains data from
the old header file; the wrong object file is stored in the
cache.)</p>

<p style="margin-top: 1em">&Acirc;&middot; The __TIME__
preprocessor macro is (potentially) being used. ccache turns
off direct mode if &acirc;__TIME__&acirc; is present in the
source code. This is done as a safety measure <br>
since the string indicates that a __TIME__ macro may affect
the output. (To be sure, ccache would have to run the
preprocessor, but the sole point of the direct mode is <br>
to avoid that.) If you know that __TIME__ isn&acirc;t used
in practise, or don&acirc;t care if ccache produces objects
where __TIME__ is expanded to something in the past, you can
<br>
set sloppiness to time_macros.</p>

<p style="margin-top: 1em">&Acirc;&middot; The __DATE__
preprocessor macro is (potentially) being used and the date
has changed. This is similar to how __TIME__ is handled. If
&acirc;__DATE__&acirc; is present in the source <br>
code, ccache hashes the current date in order to be able to
produce the correct object file if the __DATE__ macro
affects the output. If you know that __DATE__ isn&acirc;t
used <br>
in practise, or don&acirc;t care if ccache produces objects
where __DATE__ is expanded to something in the past, you can
set sloppiness to time_macros.</p>

<p style="margin-top: 1em">&Acirc;&middot; The __FILE__
preprocessor macro is (potentially) being used and the file
path has changed. If &acirc;__FILE__&acirc; is present in
the source code, ccache hashes the current input <br>
file path in order to be able to produce the correct object
file if the __FILE__ macro affects the output. If you know
that __FILE__ isn&acirc;t used in practise, or don&acirc;t
care <br>
if ccache produces objects where __FILE__ is expanded to the
wrong path, you can set sloppiness to file_macro.</p>

<p style="margin-top: 1em">&Acirc;&middot; If &acirc;cache
miss&acirc; has been incremented even though the same code
has been compiled and cached before, ccache has either
detected that something has changed anyway or a cleanup <br>
has been performed (either explicitly or implicitly when a
cache limit has been reached). Some perhaps unobvious things
that may result in a cache miss are usage of __TIME__ <br>
or __DATE__ macros, or use of automatically generated code
that contains a timestamp, build counter or other volatile
information.</p>

<p style="margin-top: 1em">&Acirc;&middot; If
&acirc;multiple source files&acirc; has been incremented,
it&acirc;s an indication that the compiler has been invoked
on several source code files at once. ccache doesn&acirc;t
support that. <br>
Compile the source code files separately if possible.</p>

<p style="margin-top: 1em">&Acirc;&middot; If
&acirc;unsupported compiler option&acirc; has been
incremented, enable debug logging and check which option was
rejected.</p>

<p style="margin-top: 1em">&Acirc;&middot; If
&acirc;preprocessor error&acirc; has been incremented, one
possible reason is that precompiled headers are being used.
See PRECOMPILED HEADERS for how to remedy this.</p>

<p style="margin-top: 1em">&Acirc;&middot; If
&acirc;can&acirc;t use precompiled header&acirc; has been
incremented, see PRECOMPILED HEADERS.</p>

<p style="margin-top: 1em">Corrupt object files <br>
It should be noted that ccache is susceptible to general
storage problems. If a bad object file sneaks into the cache
for some reason, it will of course stay bad. Some possible
<br>
reasons for erroneous object files are bad hardware (disk
drive, disk controller, memory, etc), buggy drivers or file
systems, a bad prefix_command or compiler wrapper. If this
<br>
happens, the easiest way of fixing it is this:</p>

<p style="margin-top: 1em">1. Build so that the bad object
file ends up in the build tree.</p>

<p style="margin-top: 1em">2. Remove the bad object file
from the build tree.</p>

<p style="margin-top: 1em">3. Rebuild with CCACHE_RECACHE
set.</p>

<p style="margin-top: 1em">An alternative is to clear the
whole cache with ccache -C if you don&acirc;t mind losing
other cached results.</p>

<p style="margin-top: 1em">There are no reported issues
about ccache producing broken object files reproducibly.
That doesn&acirc;t mean it can&acirc;t happen, so if you
find a repeatable case, please report it.</p>

<p style="margin-top: 1em">MORE INFORMATION <br>
Credits, mailing list information, bug reporting
instructions, source code, etc, can be found on
ccache&acirc;s web site: https://ccache.samba.org.</p>

<p style="margin-top: 1em">AUTHOR <br>
ccache was originally written by Andrew Tridgell and is
currently developed and maintained by Joel Rosdahl. See
AUTHORS.txt or AUTHORS.html and <br>
https://ccache.samba.org/credits.html for a list of
contributors.</p>

<p style="margin-top: 1em">ccache 3.3.3 10/26/2016
CCACHE(1)</p>
<hr>
</body>
</html>
