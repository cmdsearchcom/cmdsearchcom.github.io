<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:44:58 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>ZSHCOMPWID(1) General Commands Manual ZSHCOMPWID(1)</p>

<p style="margin-top: 1em">NAME <br>
zshcompwid - zsh completion widgets</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The shell&rsquo;s programmable completion mechanism can be
manipulated in two ways; here the low-level features
supporting the newer, function-based mechanism are defined.
A complete <br>
set of shell functions based on these features is described
in zshcompsys(1), and users with no interest in adding to
that system (or, potentially, writing their own -- see
dic&acirc; <br>
tionary entry for &lsquo;hubris&rsquo;) should skip the
current section. The older system based on the compctl
builtin command is described in zshcompctl(1).</p>

<p style="margin-top: 1em">Completion widgets are defined
by the -C option to the zle builtin command provided by the
zsh/zle module (see zshzle(1)). For example,</p>

<p style="margin-top: 1em">zle -C complete
expand-or-complete completer</p>

<p style="margin-top: 1em">defines a widget named
&lsquo;complete&rsquo;. The second argument is the name of
any of the builtin widgets that handle completions:
complete-word, expand-or-complete, expand-or-com&acirc; <br>
plete-prefix, menu-complete, menu-expand-or-complete,
reverse-menu-complete, list-choices, or delete-char-or-list.
Note that this will still work even if the widget in
question <br>
has been re-bound.</p>

<p style="margin-top: 1em">When this newly defined widget
is bound to a key using the bindkey builtin command defined
in the zsh/zle module (see zshzle(1)), typing that key will
call the shell function <br>
&lsquo;completer&rsquo;. This function is responsible for
generating the possible matches using the builtins described
below. As with other ZLE widgets, the function is called
with its <br>
standard input closed.</p>

<p style="margin-top: 1em">Once the function returns, the
completion code takes over control again and treats the
matches in the same manner as the specified builtin widget,
in this case expand-or-com&acirc; <br>
plete.</p>

<p style="margin-top: 1em">COMPLETION SPECIAL PARAMETERS
<br>
The parameters ZLE_REMOVE_SUFFIX_CHARS and
ZLE_SPACE_SUFFIX_CHARS are used by the completion mechanism,
but are not special. See Parameters Used By The Shell in
zshparam(1).</p>

<p style="margin-top: 1em">Inside completion widgets, and
any functions called from them, some parameters have special
meaning; outside these functions they are not special to the
shell in any way. These <br>
parameters are used to pass information between the
completion code and the completion widget. Some of the
builtin commands and the condition codes use or change the
current val&acirc; <br>
ues of these parameters. Any existing values will be hidden
during execution of completion widgets; except for
compstate, the parameters are reset on each function exit
(includ&acirc; <br>
ing nested function calls from within the completion widget)
to the values they had when the function was entered.</p>

<p style="margin-top: 1em">CURRENT <br>
This is the number of the current word, i.e. the word the
cursor is currently on in the words array. Note that this
value is only correct if the ksharrays option is not <br>
set.</p>

<p style="margin-top: 1em">IPREFIX <br>
Initially this will be set to the empty string. This
parameter functions like PREFIX; it contains a string which
precedes the one in PREFIX and is not considered part of
<br>
the list of matches. Typically, a string is transferred from
the beginning of PREFIX to the end of IPREFIX, for
example:</p>

<p style="margin-top: 1em">IPREFIX=${PREFIX%%=*}= <br>
PREFIX=${PREFIX#*=}</p>

<p style="margin-top: 1em">causes the part of the prefix up
to and including the first equal sign not to be treated as
part of a matched string. This can be done automatically by
the compset <br>
builtin, see below.</p>

<p style="margin-top: 1em">ISUFFIX <br>
As IPREFIX, but for a suffix that should not be considered
part of the matches; note that the ISUFFIX string follows
the SUFFIX string.</p>

<p style="margin-top: 1em">PREFIX Initially this will be
set to the part of the current word from the beginning of
the word up to the position of the cursor; it may be altered
to give a common prefix for <br>
all matches.</p>

<p style="margin-top: 1em">QIPREFIX <br>
This parameter is read-only and contains the quoted string
up to the word being completed. E.g. when completing
&lsquo;&quot;foo&rsquo;, this parameter contains the double
quote. If the -q <br>
option of compset is used (see below), and the original
string was &lsquo;&quot;foo bar&rsquo; with the cursor on
the &lsquo;bar&rsquo;, this parameter contains
&lsquo;&quot;foo &rsquo;.</p>

<p style="margin-top: 1em">QISUFFIX <br>
Like QIPREFIX, but containing the suffix.</p>

<p style="margin-top: 1em">SUFFIX Initially this will be
set to the part of the current word from the cursor position
to the end; it may be altered to give a common suffix for
all matches. It is most use&acirc; <br>
ful when the option COMPLETE_IN_WORD is set, as otherwise
the whole word on the command line is treated as a
prefix.</p>

<p style="margin-top: 1em">compstate <br>
This is an associative array with various keys and values
that the completion code uses to exchange information with
the completion widget. The keys are:</p>

<p style="margin-top: 1em">all_quotes <br>
The -q option of the compset builtin command (see below)
allows a quoted string to be broken into separate words; if
the cursor is on one of those words, that word <br>
will be completed, possibly invoking &lsquo;compset
-q&rsquo; recursively. With this key it is possible to test
the types of quoted strings which are currently broken into
<br>
parts in this fashion. Its value contains one character for
each quoting level. The characters are a single quote or a
double quote for strings quoted with these <br>
characters, a dollars sign for strings quoted with
$&rsquo;...&rsquo; and a backslash for strings not starting
with a quote character. The first character in the value
always <br>
corresponds to the innermost quoting level.</p>

<p style="margin-top: 1em">context <br>
This will be set by the completion code to the overall
context in which completion is attempted. Possible values
are:</p>

<p style="margin-top: 1em">array_value <br>
when completing inside the value of an array parameter
assignment; in this case the words array contains the words
inside the parentheses.</p>

<p style="margin-top: 1em">brace_parameter <br>
when completing the name of a parameter in a parameter
expansion beginning with ${. This context will also be set
when completing parameter flags following <br>
${(; the full command line argument is presented and the
handler must test the value to be completed to ascertain
that this is the case.</p>

<p style="margin-top: 1em">assign_parameter <br>
when completing the name of a parameter in a parameter
assignment.</p>

<p style="margin-top: 1em">command <br>
when completing for a normal command (either in command
position or for an argument of the command).</p>

<p style="margin-top: 1em">condition <br>
when completing inside a &lsquo;[[...]]&rsquo; conditional
expression; in this case the words array contains only the
words inside the conditional expression.</p>

<p style="margin-top: 1em">math when completing in a
mathematical environment such as a &lsquo;((...))&rsquo;
construct.</p>

<p style="margin-top: 1em">parameter <br>
when completing the name of a parameter in a parameter
expansion beginning with $ but not ${.</p>

<p style="margin-top: 1em">redirect <br>
when completing after a redirection operator.</p>

<p style="margin-top: 1em">subscript <br>
when completing inside a parameter subscript.</p>

<p style="margin-top: 1em">value when completing the value
of a parameter assignment.</p>

<p style="margin-top: 1em">exact Controls the behaviour
when the REC_EXACT option is set. It will be set to accept
if an exact match would be accepted, and will be unset
otherwise.</p>

<p style="margin-top: 1em">If it was set when at least one
match equal to the string on the line was generated, the
match is accepted.</p>

<p style="margin-top: 1em">exact_string <br>
The string of an exact match if one was found, otherwise
unset.</p>

<p style="margin-top: 1em">ignored <br>
The number of words that were ignored because they matched
one of the patterns given with the -F option to the compadd
builtin command.</p>

<p style="margin-top: 1em">insert This controls the manner
in which a match is inserted into the command line. On entry
to the widget function, if it is unset the command line is
not to be changed; <br>
if set to unambiguous, any prefix common to all matches is
to be inserted; if set to automenu-unambiguous, the common
prefix is to be inserted and the next invoca&acirc; <br>
tion of the completion code may start menu completion (due
to the AUTO_MENU option being set); if set to menu or
automenu menu completion will be started for the <br>
matches currently generated (in the latter case this will
happen because the AUTO_MENU is set). The value may also
contain the string &lsquo;tab&rsquo; when the completion
code <br>
would normally not really do completion, but only insert the
TAB character.</p>

<p style="margin-top: 1em">On exit it may be set to any of
the values above (where setting it to the empty string is
the same as unsetting it), or to a number, in which case the
match whose <br>
number is given will be inserted into the command line.
Negative numbers count backward from the last match (with
&lsquo;-1&rsquo; selecting the last match) and out-of-range
<br>
values are wrapped around, so that a value of zero selects
the last match and a value one more than the maximum selects
the first. Unless the value of this key ends <br>
in a space, the match is inserted as in a menu completion,
i.e. without automatically appending a space.</p>

<p style="margin-top: 1em">Both menu and automenu may also
specify the number of the match to insert, given after a
colon. For example, &lsquo;menu:2&rsquo; says to start menu
completion, beginning with <br>
the second match.</p>

<p style="margin-top: 1em">Note that a value containing the
substring &lsquo;tab&rsquo; makes the matches generated be
ignored and only the TAB be inserted.</p>

<p style="margin-top: 1em">Finally, it may also be set to
all, which makes all matches generated be inserted into the
line.</p>

<p style="margin-top: 1em">insert_positions <br>
When the completion system inserts an unambiguous string
into the line, there may be multiple places where characters
are missing or where the character inserted <br>
differs from at least one match. The value of this key
contains a colon separated list of all these positions, as
indexes into the command line.</p>

<p style="margin-top: 1em">last_prompt <br>
If this is set to a non-empty string for every match added,
the completion code will move the cursor back to the
previous prompt after the list of completions has <br>
been displayed. Initially this is set or unset according to
the ALWAYS_LAST_PROMPT option.</p>

<p style="margin-top: 1em">list This controls whether or
how the list of matches will be displayed. If it is unset or
empty they will never be listed; if its value begins with
list, they will <br>
always be listed; if it begins with autolist or ambiguous,
they will be listed when the AUTO_LIST or LIST_AMBIGUOUS
options respectively would normally cause them <br>
to be.</p>

<p style="margin-top: 1em">If the substring force appears
in the value, this makes the list be shown even if there is
only one match. Normally, the list would be shown only if
there are at <br>
least two matches.</p>

<p style="margin-top: 1em">The value contains the substring
packed if the LIST_PACKED option is set. If this substring
is given for all matches added to a group, this group will
show the <br>
LIST_PACKED behavior. The same is done for the
LIST_ROWS_FIRST option with the substring rows.</p>

<p style="margin-top: 1em">Finally, if the value contains
the string explanations, only the explanation strings, if
any, will be listed and if it contains messages, only the
messages (added <br>
with the -x option of compadd) will be listed. If it
contains both explanations and messages both kinds of
explanation strings will be listed. It will be set <br>
appropriately on entry to a completion widget and may be
changed there.</p>

<p style="margin-top: 1em">list_lines <br>
This gives the number of lines that are needed to display
the full list of completions. Note that to calculate the
total number of lines to display you need to add <br>
the number of lines needed for the command line to this
value, this is available as the value of the BUFFERLINES
special parameter.</p>

<p style="margin-top: 1em">list_max <br>
Initially this is set to the value of the LISTMAX parameter.
It may be set to any other value; when the widget exits this
value will be used in the same way as the <br>
value of LISTMAX.</p>

<p style="margin-top: 1em">nmatches <br>
The number of matches generated and accepted by the
completion code so far.</p>

<p style="margin-top: 1em">old_insert <br>
On entry to the widget this will be set to the number of the
match of an old list of completions that is currently
inserted into the command line. If no match has <br>
been inserted, this is unset.</p>

<p style="margin-top: 1em">As with old_list, the value of
this key will only be used if it is the string keep. If it
was set to this value by the widget and there was an old
match inserted <br>
into the command line, this match will be kept and if the
value of the insert key specifies that another match should
be inserted, this will be inserted after the <br>
old one.</p>

<p style="margin-top: 1em">old_list <br>
This is set to yes if there is still a valid list of
completions from a previous completion at the time the
widget is invoked. This will usually be the case if and <br>
only if the previous editing operation was a completion
widget or one of the builtin completion functions. If there
is a valid list and it is also currently shown <br>
on the screen, the value of this key is shown.</p>

<p style="margin-top: 1em">After the widget has exited the
value of this key is only used if it was set to keep. In
this case the completion code will continue to use this old
list. If the <br>
widget generated new matches, they will not be used.</p>

<p style="margin-top: 1em">parameter <br>
The name of the parameter when completing in a subscript or
in the value of a parameter assignment.</p>

<p style="margin-top: 1em">pattern_insert <br>
Normally this is set to menu, which specifies that menu
completion will be used whenever a set of matches was
generated using pattern matching. If it is set to any <br>
other non-empty string by the user and menu completion is
not selected by other option settings, the code will instead
insert any common prefix for the generated <br>
matches as with normal completion.</p>

<p style="margin-top: 1em">pattern_match <br>
Locally controls the behaviour given by the GLOB_COMPLETE
option. Initially it is set to &lsquo;*&rsquo; if and only
if the option is set. The completion widget may set it to
<br>
this value, to an empty string (which has the same effect as
unsetting it), or to any other non-empty string. If it is
non-empty, unquoted metacharacters on the <br>
command line will be treated as patterns; if it is
&lsquo;*&rsquo;, then additionally a wildcard
&lsquo;*&rsquo; is assumed at the cursor position; if it is
empty or unset, metacharacters <br>
will be treated literally.</p>

<p style="margin-top: 1em">Note that the matcher
specifications given to the compadd builtin command are not
used if this is set to a non-empty string.</p>

<p style="margin-top: 1em">quote When completing inside
quotes, this contains the quotation character (i.e. either a
single quote, a double quote, or a backtick). Otherwise it
is unset.</p>

<p style="margin-top: 1em">quoting <br>
When completing inside single quotes, this is set to the
string single; inside double quotes, the string double;
inside backticks, the string backtick. Otherwise <br>
it is unset.</p>

<p style="margin-top: 1em">redirect <br>
The redirection operator when completing in a redirection
position, i.e. one of &lt;, &gt;, etc.</p>

<p style="margin-top: 1em">restore <br>
This is set to auto before a function is entered, which
forces the special parameters mentioned above (words,
CURRENT, PREFIX, IPREFIX, SUFFIX, and ISUFFIX) to be <br>
restored to their previous values when the function exits.
If a function unsets it or sets it to any other string, they
will not be restored.</p>

<p style="margin-top: 1em">to_end Specifies the occasions
on which the cursor is moved to the end of a string when a
match is inserted. On entry to a widget function, it may be
single if this will <br>
happen when a single unambiguous match was inserted or match
if it will happen any time a match is inserted (for example,
by menu completion; this is likely to be <br>
the effect of the ALWAYS_TO_END option).</p>

<p style="margin-top: 1em">On exit, it may be set to single
as above. It may also be set to always, or to the empty
string or unset; in those cases the cursor will be moved to
the end of the <br>
string always or never respectively. Any other string is
treated as match.</p>

<p style="margin-top: 1em">unambiguous <br>
This key is read-only and will always be set to the common
(unambiguous) prefix the completion code has generated for
all matches added so far.</p>

<p style="margin-top: 1em">unambiguous_cursor <br>
This gives the position the cursor would be placed at if the
common prefix in the unambiguous key were inserted, relative
to the value of that key. The cursor would <br>
be placed before the character whose index is given by this
key.</p>

<p style="margin-top: 1em">unambiguous_positions <br>
This contains all positions where characters in the
unambiguous string are missing or where the character
inserted differs from at least one of the matches. The <br>
positions are given as indexes into the string given by the
value of the unambiguous key.</p>

<p style="margin-top: 1em">vared If completion is called
while editing a line using the vared builtin, the value of
this key is set to the name of the parameter given as an
argument to vared. This <br>
key is only set while a vared command is active.</p>

<p style="margin-top: 1em">words This array contains the
words present on the command line currently being
edited.</p>

<p style="margin-top: 1em">COMPLETION BUILTIN COMMANDS <br>
compadd [ -akqQfenUld12C ] [ -F array ] <br>
[ -P prefix ] [ -S suffix ] <br>
[ -p hidden-prefix ] [ -s hidden-suffix ] <br>
[ -i ignored-prefix ] [ -I ignored-suffix ] <br>
[ -W file-prefix ] [ -d array ] <br>
[ -J name ] [ -V name ] [ -X explanation ] [ -x message ]
<br>
[ -r remove-chars ] [ -R remove-func ] <br>
[ -D array ] [ -O array ] [ -A array ] <br>
[ -E number ] <br>
[ -M match-spec ] [ -- ] [ words ... ]</p>

<p style="margin-top: 1em">This builtin command can be used
to add matches directly and control all the information the
completion code stores with each possible match. The return
status is zero if <br>
at least one match was added and non-zero if no matches were
added.</p>

<p style="margin-top: 1em">The completion code breaks the
string to complete into seven fields in the order:</p>


<p style="margin-top: 1em">&lt;ipre&gt;&lt;apre&gt;&lt;hpre&gt;&lt;word&gt;&lt;hsuf&gt;&lt;asuf&gt;&lt;isuf&gt;</p>

<p style="margin-top: 1em">The first field is an ignored
prefix taken from the command line, the contents of the
IPREFIX parameter plus the string given with the -i option.
With the -U option, only <br>
the string from the -i option is used. The field
&lt;apre&gt; is an optional prefix string given with the -P
option. The &lt;hpre&gt; field is a string that is
considered part of the <br>
match but that should not be shown when listing completions,
given with the -p option; for example, functions that do
filename generation might specify a common path pre&acirc;
<br>
fix this way. &lt;word&gt; is the part of the match that
should appear in the list of completions, i.e. one of the
words given at the end of the compadd command line. The
suf&acirc; <br>
fixes &lt;hsuf&gt;, &lt;asuf&gt; and &lt;isuf&gt; correspond
to the prefixes &lt;hpre&gt;, &lt;apre&gt; and &lt;ipre&gt;
and are given by the options -s, -S and -I,
respectively.</p>

<p style="margin-top: 1em">The supported flags are:</p>

<p style="margin-top: 1em">-P prefix <br>
This gives a string to be inserted before the given words.
The string given is not considered as part of the match and
any shell metacharacters in it will not be <br>
quoted when the string is inserted.</p>

<p style="margin-top: 1em">-S suffix <br>
Like -P, but gives a string to be inserted after the
match.</p>

<p style="margin-top: 1em">-p hidden-prefix <br>
This gives a string that should be inserted into the command
line before the match but that should not appear in the list
of matches. Unless the -U option is given, <br>
this string must be matched as part of the string on the
command line.</p>

<p style="margin-top: 1em">-s hidden-suffix <br>
Like &lsquo;-p&rsquo;, but gives a string to insert after
the match.</p>

<p style="margin-top: 1em">-i ignored-prefix <br>
This gives a string to insert into the command line just
before any string given with the &lsquo;-P&rsquo; option.
Without &lsquo;-P&rsquo; the string is inserted before the
string given <br>
with &lsquo;-p&rsquo; or directly before the match.</p>

<p style="margin-top: 1em">-I ignored-suffix <br>
Like -i, but gives an ignored suffix.</p>

<p style="margin-top: 1em">-a With this flag the words are
taken as names of arrays and the possible matches are their
values. If only some elements of the arrays are needed, the
words may also <br>
contain subscripts, as in &lsquo;foo[2,-1]&rsquo;.</p>

<p style="margin-top: 1em">-k With this flag the words are
taken as names of associative arrays and the possible
matches are their keys. As for -a, the words may also
contain subscripts, as in <br>
&lsquo;foo[(R)*bar*]&rsquo;.</p>

<p style="margin-top: 1em">-d array <br>
This adds per-match display strings. The array should
contain one element per word given. The completion code will
then display the first element instead of the <br>
first word, and so on. The array may be given as the name of
an array parameter or directly as a space-separated list of
words in parentheses.</p>

<p style="margin-top: 1em">If there are fewer display
strings than words, the leftover words will be displayed
unchanged and if there are more display strings than words,
the leftover display <br>
strings will be silently ignored.</p>

<p style="margin-top: 1em">-l This option only has an
effect if used together with the -d option. If it is given,
the display strings are listed one per line, not arrayed in
columns.</p>

<p style="margin-top: 1em">-o This option only has an
effect if used together with the -d option. If it is given,
the order of the output is determined by the match strings;
otherwise it is <br>
determined by the display strings (i.e. the strings given by
the -d option).</p>

<p style="margin-top: 1em">-J name <br>
Gives the name of the group of matches the words should be
stored in.</p>

<p style="margin-top: 1em">-V name <br>
Like -J but naming an unsorted group. These are in a
different name space than groups created with the -J
flag.</p>

<p style="margin-top: 1em">-1 If given together with the -V
option, makes only consecutive duplicates in the group be
removed. If combined with the -J option, this has no visible
effect. Note <br>
that groups with and without this flag are in different name
spaces.</p>

<p style="margin-top: 1em">-2 If given together with the -J
or -V option, makes all duplicates be kept. Again, groups
with and without this flag are in different name spaces.</p>

<p style="margin-top: 1em">-X explanation <br>
The explanation string will be printed with the list of
matches, above the group currently selected.</p>

<p style="margin-top: 1em">-x message <br>
Like -X, but the message will be printed even if there are
no matches in the group.</p>

<p style="margin-top: 1em">-q The suffix given with -S will
be automatically removed if the next character typed is a
blank or does not insert anything, or if the suffix consists
of only one <br>
character and the next character typed is the same
character.</p>

<p style="margin-top: 1em">-r remove-chars <br>
This is a more versatile form of the -q option. The suffix
given with -S or the slash automatically added after
completing directories will be automatically <br>
removed if the next character typed inserts one of the
characters given in the remove-chars. This string is parsed
as a characters class and understands the back&acirc; <br>
slash sequences used by the print command. For example,
&lsquo;-r &quot;a-z&quot;&rsquo; removes the suffix if the
next character typed inserts a lower case character or a
TAB, and <br>
&lsquo;-r &quot;^0-9&quot;&rsquo; removes the suffix if the
next character typed inserts anything but a digit. One extra
backslash sequence is understood in this string:
&lsquo;&minus;&rsquo; stands for <br>
all characters that insert nothing. Thus &lsquo;-S
&quot;=&quot; -q&rsquo; is the same as &lsquo;-S
&quot;=&quot; -r &quot;= &quot;&rsquo;.</p>

<p style="margin-top: 1em">This option may also be used
without the -S option; then any automatically added space
will be removed when one of the characters in the list is
typed.</p>

<p style="margin-top: 1em">-R remove-func <br>
This is another form of the -r option. When a suffix has
been inserted and the completion accepted, the function
remove-func will be called after the next character <br>
typed. It is passed the length of the suffix as an argument
and can use the special parameters available in ordinary
(non-completion) zle widgets (see zshzle(1)) <br>
to analyse and modify the command line.</p>

<p style="margin-top: 1em">-f If this flag is given, all of
the matches built from words are marked as being the names
of files. They are not required to be actual filenames, but
if they are, <br>
and the option LIST_TYPES is set, the characters describing
the types of the files in the completion lists will be
shown. This also forces a slash to be added when <br>
the name of a directory is completed.</p>

<p style="margin-top: 1em">-e This flag can be used to tell
the completion code that the matches added are parameter
names for a parameter expansion. This will make the
AUTO_PARAM_SLASH and <br>
AUTO_PARAM_KEYS options be used for the matches.</p>

<p style="margin-top: 1em">-W file-prefix <br>
This string is a pathname that will be prepended to each of
the matches formed by the given words together with any
prefix specified by the -p option to form a com&acirc; <br>
plete filename for testing. Hence it is only useful if
combined with the -f flag, as the tests will not otherwise
be performed.</p>

<p style="margin-top: 1em">-F array <br>
Specifies an array containing patterns. Words matching one
of these patterns are ignored, i.e. not considered to be
possible matches.</p>

<p style="margin-top: 1em">The array may be the name of an
array parameter or a list of literal patterns enclosed in
parentheses and quoted, as in &lsquo;-F &quot;(*?.o
*?.h)&quot;&rsquo;. If the name of an array <br>
is given, the elements of the array are taken as the
patterns.</p>

<p style="margin-top: 1em">-Q This flag instructs the
completion code not to quote any metacharacters in the words
when inserting them into the command line.</p>

<p style="margin-top: 1em">-M match-spec <br>
This gives local match specifications as described below in
the section &lsquo;Completion Matching Control&rsquo;. This
option may be given more than once. In this case all <br>
match-specs given are concatenated with spaces between them
to form the specification string to use. Note that they will
only be used if the -U option is not <br>
given.</p>

<p style="margin-top: 1em">-n Specifies that the words
added are to be used as possible matches, but are not to
appear in the completion listing.</p>

<p style="margin-top: 1em">-U If this flag is given, all
words given will be accepted and no matching will be done by
the completion code. Normally this is used in functions that
do the matching <br>
themselves.</p>

<p style="margin-top: 1em">-O array <br>
If this option is given, the words are not added to the set
of possible completions. Instead, matching is done as usual
and all of the words given as arguments <br>
that match the string on the command line will be stored in
the array parameter whose name is given as array.</p>

<p style="margin-top: 1em">-A array <br>
As the -O option, except that instead of those of the words
which match being stored in array, the strings generated
internally by the completion code are stored. <br>
For example, with a matching specification of &lsquo;-M
&quot;L:|no=&quot;&rsquo;, the string &lsquo;nof&rsquo; on
the command line and the string &lsquo;foo&rsquo; as one of
the words, this option stores the <br>
string &lsquo;nofoo&rsquo; in the array, whereas the -O
option stores the &lsquo;foo&rsquo; originally given.</p>

<p style="margin-top: 1em">-D array <br>
As with -O, the words are not added to the set of possible
completions. Instead, the completion code tests whether each
word in turn matches what is on the line. <br>
If the nth word does not match, the nth element of the array
is removed. Elements for which the corresponding word is
matched are retained.</p>

<p style="margin-top: 1em">-C This option adds a special
match which expands to all other matches when inserted into
the line, even those that are added after this option is
used. Together with <br>
the -d option it is possible to specify a string that should
be displayed in the list for this special match. If no
string is given, it will be shown as a string <br>
containing the strings that would be inserted for the other
matches, truncated to the width of the screen.</p>

<p style="margin-top: 1em">-E This option adds number empty
matches after the words have been added. An empty match
takes up space in completion listings but will never be
inserted in the line <br>
and can&rsquo;t be selected with menu completion or menu
selection. This makes empty matches only useful to format
completion lists and to make explanatory string be <br>
shown in completion lists (since empty matches can be given
display strings with the -d option). And because all but one
empty string would otherwise be removed, <br>
this option implies the -V and -2 options (even if an
explicit -J option is given).</p>

<p style="margin-top: 1em">- <br>
-- This flag ends the list of flags and options. All
arguments after it will be taken as the words to use as
matches even if they begin with hyphens.</p>

<p style="margin-top: 1em">Except for the -M flag, if any
of these flags is given more than once, the first one (and
its argument) will be used.</p>

<p style="margin-top: 1em">compset -p number <br>
compset -P [ number ] pattern <br>
compset -s number <br>
compset -S [ number ] pattern <br>
compset -n begin [ end ] <br>
compset -N beg-pat [ end-pat ] <br>
compset -q <br>
This command simplifies modification of the special
parameters, while its return status allows tests on them to
be carried out.</p>

<p style="margin-top: 1em">The options are:</p>

<p style="margin-top: 1em">-p number <br>
If the contents of the PREFIX parameter is longer than
number characters, the first number characters are removed
from it and appended to the contents of the <br>
IPREFIX parameter.</p>

<p style="margin-top: 1em">-P [ number ] pattern <br>
If the value of the PREFIX parameter begins with anything
that matches the pattern, the matched portion is removed
from PREFIX and appended to IPREFIX.</p>

<p style="margin-top: 1em">Without the optional number, the
longest match is taken, but if number is given, anything up
to the numberth match is moved. If the number is negative,
the num&acirc; <br>
berth longest match is moved. For example, if PREFIX
contains the string &lsquo;a=b=c&rsquo;, then compset -P
&rsquo;*=&rsquo; will move the string &lsquo;a=b=&rsquo;
into the IPREFIX parameter, but <br>
compset -P 1 &rsquo;*=&rsquo; will move only the string
&lsquo;a=&rsquo;.</p>

<p style="margin-top: 1em">-s number <br>
As -p, but transfer the last number characters from the
value of SUFFIX to the front of the value of ISUFFIX.</p>

<p style="margin-top: 1em">-S [ number ] pattern <br>
As -P, but match the last portion of SUFFIX and transfer the
matched portion to the front of the value of ISUFFIX.</p>

<p style="margin-top: 1em">-n begin [ end ] <br>
If the current word position as specified by the parameter
CURRENT is greater than or equal to begin, anything up to
the beginth word is removed from the words <br>
array and the value of the parameter CURRENT is decremented
by begin.</p>

<p style="margin-top: 1em">If the optional end is given,
the modification is done only if the current word position
is also less than or equal to end. In this case, the words
from position <br>
end onwards are also removed from the words array.</p>

<p style="margin-top: 1em">Both begin and end may be
negative to count backwards from the last element of the
words array.</p>

<p style="margin-top: 1em">-N beg-pat [ end-pat ] <br>
If one of the elements of the words array before the one at
the index given by the value of the parameter CURRENT
matches the pattern beg-pat, all elements up to <br>
and including the matching one are removed from the words
array and the value of CURRENT is changed to point to the
same word in the changed array.</p>

<p style="margin-top: 1em">If the optional pattern end-pat
is also given, and there is an element in the words array
matching this pattern, the parameters are modified only if
the index of <br>
this word is higher than the one given by the CURRENT
parameter (so that the matching word has to be after the
cursor). In this case, the words starting with the <br>
one matching end-pat are also removed from the words array.
If words contains no word matching end-pat, the testing and
modification is performed as if it were not <br>
given.</p>

<p style="margin-top: 1em">-q The word currently being
completed is split on spaces into separate words, respecting
the usual shell quoting conventions. The resulting words are
stored in the <br>
words array, and CURRENT, PREFIX, SUFFIX, QIPREFIX, and
QISUFFIX are modified to reflect the word part that is
completed.</p>

<p style="margin-top: 1em">In all the above cases the
return status is zero if the test succeeded and the
parameters were modified and non-zero otherwise. This allows
one to use this builtin in <br>
tests such as:</p>

<p style="margin-top: 1em">if compset -P &rsquo;*=&rsquo;;
then ...</p>

<p style="margin-top: 1em">This forces anything up to and
including the last equal sign to be ignored by the
completion code.</p>

<p style="margin-top: 1em">compcall [ -TD ] <br>
This allows the use of completions defined with the compctl
builtin from within completion widgets. The list of matches
will be generated as if one of the non-widget com&acirc;
<br>
pletion functions (complete-word, etc.) had been called,
except that only compctls given for specific commands are
used. To force the code to try completions defined with <br>
the -T option of compctl and/or the default completion
(whether defined by compctl -D or the builtin default) in
the appropriate places, the -T and/or -D flags can be <br>
passed to compcall.</p>

<p style="margin-top: 1em">The return status can be used to
test if a matching compctl definition was found. It is
non-zero if a compctl was found and zero otherwise.</p>

<p style="margin-top: 1em">Note that this builtin is
defined by the zsh/compctl module.</p>

<p style="margin-top: 1em">COMPLETION CONDITION CODES <br>
The following additional condition codes for use within the
[[ ... ]] construct are available in completion widgets.
These work on the special parameters. All of these tests
<br>
can also be performed by the compset builtin, but in the
case of the condition codes the contents of the special
parameters are not modified.</p>

<p style="margin-top: 1em">-prefix [ number ] pattern <br>
true if the test for the -P option of compset would
succeed.</p>

<p style="margin-top: 1em">-suffix [ number ] pattern <br>
true if the test for the -S option of compset would
succeed.</p>

<p style="margin-top: 1em">-after beg-pat <br>
true if the test of the -N option with only the beg-pat
given would succeed.</p>

<p style="margin-top: 1em">-between beg-pat end-pat <br>
true if the test for the -N option with both patterns would
succeed.</p>

<p style="margin-top: 1em">COMPLETION MATCHING CONTROL <br>
It is possible by use of the -M option of the compadd
builtin command to specify how the characters in the string
to be completed (referred to here as the command line) map
onto <br>
the characters in the list of matches produced by the
completion code (referred to here as the trial completions).
Note that this is not used if the command line contains a
glob <br>
pattern and the GLOB_COMPLETE option is set or the
pattern_match of the compstate special association is set to
a non-empty string.</p>

<p style="margin-top: 1em">The match-spec given as the
argument to the -M option (see &lsquo;Completion Builtin
Commands&rsquo; above) consists of one or more matching
descriptions separated by whitespace. Each <br>
description consists of a letter followed by a colon and
then the patterns describing which character sequences on
the line match which character sequences in the trial
comple&acirc; <br>
tion. Any sequence of characters not handled in this fashion
must match exactly, as usual.</p>

<p style="margin-top: 1em">The forms of match-spec
understood are as follows. In each case, the form with an
upper case initial character retains the string already
typed on the command line as the final <br>
result of completion, while with a lower case initial
character the string on the command line is changed into the
corresponding part of the trial completion.</p>

<p style="margin-top: 1em">m:lpat=tpat <br>
M:lpat=tpat <br>
Here, lpat is a pattern that matches on the command line,
corresponding to tpat which matches in the trial
completion.</p>

<p style="margin-top: 1em">l:lanchor|lpat=tpat <br>
L:lanchor|lpat=tpat <br>
l:lanchor||ranchor=tpat <br>
L:lanchor||ranchor=tpat <br>
b:lpat=tpat <br>
B:lpat=tpat <br>
These letters are for patterns that are anchored by another
pattern on the left side. Matching for lpat and tpat is as
for m and M, but the pattern lpat matched on the <br>
command line must be preceded by the pattern lanchor. The
lanchor can be blank to anchor the match to the start of the
command line string; otherwise the anchor can occur <br>
anywhere, but must match in both the command line and trial
completion strings.</p>

<p style="margin-top: 1em">If no lpat is given but a
ranchor is, this matches the gap between substrings matched
by lanchor and ranchor. Unlike lanchor, the ranchor only
needs to match the trial <br>
completion string.</p>

<p style="margin-top: 1em">The b and B forms are similar to
l and L with an empty anchor, but need to match only the
beginning of the trial completion or the word on the command
line, respectively.</p>

<p style="margin-top: 1em">r:lpat|ranchor=tpat <br>
R:lpat|ranchor=tpat <br>
r:lanchor||ranchor=tpat <br>
R:lanchor||ranchor=tpat <br>
e:lpat=tpat <br>
E:lpat=tpat <br>
As l, L, b and B, with the difference that the command line
and trial completion patterns are anchored on the right
side. Here an empty ranchor and the e and E forms <br>
force the match to the end of the trial completion or
command line string.</p>

<p style="margin-top: 1em">Each lpat, tpat or anchor is
either an empty string or consists of a sequence of literal
characters (which may be quoted with a backslash), question
marks, character classes, and <br>
correspondence classes; ordinary shell patterns are not
used. Literal characters match only themselves, question
marks match any character, and character classes are formed
as <br>
for globbing and match any character in the given set.</p>

<p style="margin-top: 1em">Correspondence classes are
defined like character classes, but with two differences:
they are delimited by a pair of braces, and negated classes
are not allowed, so the charac&acirc; <br>
ters ! and ^ have no special meaning directly after the
opening brace. They indicate that a range of characters on
the line match a range of characters in the trial
completion, <br>
but (unlike ordinary character classes) paired according to
the corresponding position in the sequence. For example, to
make any ASCII lower case letter on the line match the <br>
corresponding upper case letter in the trial completion, you
can use &lsquo;m:{a-z}={A-Z}&rsquo; (however, see below for
the recommended form for this). More than one pair of
classes can <br>
occur, in which case the first class before the =
corresponds to the first after it, and so on. If one side
has more such classes than the other side, the superfluous
classes <br>
behave like normal character classes. In anchor patterns
correspondence classes also behave like normal character
classes.</p>

<p style="margin-top: 1em">The standard
&lsquo;[:name:]&rsquo; forms described for standard shell
patterns, see the section FILENAME GENERATION in zshexpn(1),
may appear in correspondence classes as well as normal <br>
character classes. The only special behaviour in
correspondence classes is if the form on the left and the
form on the right are each one of [:upper:], [:lower:]. In
these <br>
cases the character in the word and the character on the
line must be the same up to a difference in case. Hence to
make any lower case character on the line match the
corre&acirc; <br>
sponding upper case character in the trial completion you
can use &lsquo;m:{[:lower:]}={[:upper:]}&rsquo;. Although
the matching system does not yet handle multibyte
characters, this is <br>
likely to be a future extension, at which point this syntax
will handle arbitrary alphabets; hence this form, rather
than the use of explicit ranges, is the recommended form. In
<br>
other cases &lsquo;[:name:]&rsquo; forms are allowed. If the
two forms on the left and right are the same, the characters
must match exactly. In remaining cases, the corresponding
tests <br>
are applied to both characters, but they are not otherwise
constrained; any matching character in one set goes with any
matching character in the other set: this is equivalent <br>
to the behaviour of ordinary character classes.</p>

<p style="margin-top: 1em">The pattern tpat may also be one
or two stars, &lsquo;*&rsquo; or &lsquo;**&rsquo;. This
means that the pattern on the command line can match any
number of characters in the trial completion. In this <br>
case the pattern must be anchored (on either side); in the
case of a single star, the anchor then determines how much
of the trial completion is to be included -- only the
char&acirc; <br>
acters up to the next appearance of the anchor will be
matched. With two stars, substrings matched by the anchor
can be matched, too.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">The keys of the options
association defined by the parameter module are the option
names in all-lower-case form, without underscores, and
without the optional no at the beginning <br>
even though the builtins setopt and unsetopt understand
option names with upper case letters, underscores, and the
optional no. The following alters the matching rules so that
<br>
the prefix no and any underscore are ignored when trying to
match the trial completions generated and upper case letters
on the line match the corresponding lower case letters in
<br>
the words:</p>

<p style="margin-top: 1em">compadd -M &rsquo;L:|[nN][oO]=
M:_= M:{[:upper:]}={[:lower:]}&rsquo; - ${(k)options}</p>

<p style="margin-top: 1em">The first part says that the
pattern &lsquo;[nN][oO]&rsquo; at the beginning (the empty
anchor before the pipe symbol) of the string on the line
matches the empty string in the list of words <br>
generated by completion, so it will be ignored if present.
The second part does the same for an underscore anywhere in
the command line string, and the third part uses
correspon&acirc; <br>
dence classes so that any upper case letter on the line
matches the corresponding lower case letter in the word. The
use of the upper case forms of the specification characters
<br>
(L and M) guarantees that what has already been typed on the
command line (in particular the prefix no) will not be
deleted.</p>

<p style="margin-top: 1em">Note that the use of L in the
first part means that it matches only when at the beginning
of both the command line string and the trial completion.
I.e., the string &lsquo;_NO_f&rsquo; would <br>
not be completed to &lsquo;_NO_foo&rsquo;, nor would
&lsquo;NONO_f&rsquo; be completed to &lsquo;NONO_foo&rsquo;
because of the leading underscore or the second
&lsquo;NO&rsquo; on the line which makes the pattern fail
even <br>
though they are otherwise ignored. To fix this, one would
use &lsquo;B:[nN][oO]=&rsquo; instead of the first part. As
described above, this matches at the beginning of the trial
completion, <br>
independent of other characters or substrings at the
beginning of the command line word which are ignored by the
same or other match-specs.</p>

<p style="margin-top: 1em">The second example makes
completion case insensitive. This is just the same as in the
option example, except here we wish to retain the characters
in the list of completions:</p>

<p style="margin-top: 1em">compadd -M
&rsquo;m:{[:lower:]}={[:upper:]}&rsquo; ...</p>

<p style="margin-top: 1em">This makes lower case letters
match their upper case counterparts. To make upper case
letters match the lower case forms as well:</p>

<p style="margin-top: 1em">compadd -M
&rsquo;m:{[:lower:][:upper:]}={[:upper:][:lower:]}&rsquo;
...</p>

<p style="margin-top: 1em">A nice example for the use of *
patterns is partial word completion. Sometimes you would
like to make strings like &lsquo;c.s.u&rsquo; complete to
strings like &lsquo;comp.source.unix&rsquo;, i.e. the <br>
word on the command line consists of multiple parts,
separated by a dot in this example, where each part should
be completed separately -- note, however, that the case
where each <br>
part of the word, i.e. &lsquo;comp&rsquo;,
&lsquo;source&rsquo; and &lsquo;unix&rsquo; in this example,
is to be completed from separate sets of matches is a
different problem to be solved by the implementation of <br>
the completion widget. The example can be handled by:</p>

<p style="margin-top: 1em">compadd -M &rsquo;r:|.=*
r:|=*&rsquo; - comp.sources.unix comp.sources.misc ...</p>

<p style="margin-top: 1em">The first specification says
that lpat is the empty string, while anchor is a dot; tpat
is *, so this can match anything except for the
&lsquo;.&rsquo; from the anchor in the trial comple&acirc;
<br>
tion word. So in &lsquo;c.s.u&rsquo;, the matcher sees
&lsquo;c&rsquo;, followed by the empty string, followed by
the anchor &lsquo;.&rsquo;, and likewise for the second dot,
and replaces the empty strings before <br>
the anchors, giving &lsquo;c[omp].s[ources].u[nix]&rsquo;,
where the last part of the completion is just as normal.</p>

<p style="margin-top: 1em">With the pattern shown above,
the string &lsquo;c.u&rsquo; could not be completed to
&lsquo;comp.sources.unix&rsquo; because the single star
means that no dot (matched by the anchor) can be skipped. By
<br>
using two stars as in &lsquo;r:|.=**&rsquo;, however,
&lsquo;c.u&rsquo; could be completed to
&lsquo;comp.sources.unix&rsquo;. This also shows that in
some cases, especially if the anchor is a real pattern, like
a <br>
character class, the form with two stars may result in more
matches than one would like.</p>

<p style="margin-top: 1em">The second specification is
needed to make this work when the cursor is in the middle of
the string on the command line and the option
COMPLETE_IN_WORD is set. In this case the <br>
completion code would normally try to match trial
completions that end with the string as typed so far, i.e.
it will only insert new characters at the cursor position
rather than <br>
at the end. However in our example we would like the code to
recognise matches which contain extra characters after the
string on the line (the &lsquo;nix&rsquo; in the example).
Hence we <br>
say that the empty string at the end of the string on the
line matches any characters at the end of the trial
completion.</p>

<p style="margin-top: 1em">More generally, the
specification</p>

<p style="margin-top: 1em">compadd -M &rsquo;r:|[.,_-]=*
r:|=*&rsquo; ...</p>

<p style="margin-top: 1em">allows one to complete words
with abbreviations before any of the characters in the
square brackets. For example, to complete veryverylongfile.c
rather than veryverylongheader.h <br>
with the above in effect, you can just type very.c before
attempting completion.</p>

<p style="margin-top: 1em">The specifications with both a
left and a right anchor are useful to complete partial words
whose parts are not separated by some special character. For
example, in some places <br>
strings have to be completed that are formed
&lsquo;LikeThis&rsquo; (i.e. the separate parts are
determined by a leading upper case letter) or maybe one has
to complete strings with trailing <br>
numbers. Here one could use the simple form with only one
anchor as in:</p>

<p style="margin-top: 1em">compadd -M
&rsquo;r:|[[:upper:]0-9]=* r:|=*&rsquo; LikeTHIS FooHoo
5foo123 5bar234</p>

<p style="margin-top: 1em">But with this, the string
&lsquo;H&rsquo; would neither complete to
&lsquo;FooHoo&rsquo; nor to &lsquo;LikeTHIS&rsquo; because
in each case there is an upper case letter before the
&lsquo;H&rsquo; and that is matched by the <br>
anchor. Likewise, a &lsquo;2&rsquo; would not be completed.
In both cases this could be changed by using
&lsquo;r:|[[:upper:]0-9]=**&rsquo;, but then &lsquo;H&rsquo;
completes to both &lsquo;LikeTHIS&rsquo; and
&lsquo;FooHoo&rsquo; and a <br>
&lsquo;2&rsquo; matches the other strings because characters
can be inserted before every upper case letter and digit. To
avoid this one would use:</p>

<p style="margin-top: 1em">compadd -M
&rsquo;r:[^[:upper:]0-9]||[[:upper:]0-9]=** r:|=*&rsquo;
LikeTHIS FooHoo foo123 bar234</p>

<p style="margin-top: 1em">By using these two anchors, a
&lsquo;H&rsquo; matches only upper case &lsquo;H&rsquo;s
that are immediately preceded by something matching the left
anchor &lsquo;[^[:upper:]0-9]&rsquo;. The effect is, of
course, <br>
that &lsquo;H&rsquo; matches only the string
&lsquo;FooHoo&rsquo;, a &lsquo;2&rsquo; matches only
&lsquo;bar234&rsquo; and so on.</p>

<p style="margin-top: 1em">When using the completion system
(see zshcompsys(1)), users can define match specifications
that are to be used for specific contexts by using the
matcher and matcher-list <br>
styles. The values for the latter will be used
everywhere.</p>

<p style="margin-top: 1em">COMPLETION WIDGET EXAMPLE <br>
The first step is to define the widget:</p>

<p style="margin-top: 1em">zle -C complete complete-word
complete-files</p>

<p style="margin-top: 1em">Then the widget can be bound to
a key using the bindkey builtin command:</p>

<p style="margin-top: 1em">bindkey &rsquo;^X&rsquo;
complete</p>

<p style="margin-top: 1em">After that the shell function
complete-files will be invoked after typing control-X and
TAB. The function should then generate the matches,
e.g.:</p>

<p style="margin-top: 1em">complete-files () { compadd - *
}</p>

<p style="margin-top: 1em">This function will complete
files in the current directory matching the current
word.</p>

<p style="margin-top: 1em">zsh 5.0.2 December 21, 2012
ZSHCOMPWID(1)</p>
<hr>
</body>
</html>
