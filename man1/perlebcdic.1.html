<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:48 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLEBCDIC(1) Perl Programmers Reference Guide
PERLEBCDIC(1)</p>

<p style="margin-top: 1em">NAME <br>
perlebcdic - Considerations for running Perl on EBCDIC
platforms</p>

<p style="margin-top: 1em">DESCRIPTION <br>
An exploration of some of the issues facing Perl programmers
on EBCDIC based computers. We do not cover localization,
internationalization, or multi-byte character set issues
<br>
other than some discussion of UTF-8 and UTF-EBCDIC.</p>

<p style="margin-top: 1em">Portions that are still
incomplete are marked with XXX.</p>

<p style="margin-top: 1em">Perl used to work on EBCDIC
machines, but there are now areas of the code where it
doesn&rsquo;t. If you want to use Perl on an EBCDIC machine,
please let us know by sending mail to <br>
perlbug@perl.org</p>

<p style="margin-top: 1em">COMMON CHARACTER CODE SETS <br>
ASCII <br>
The American Standard Code for Information Interchange
(ASCII or US-ASCII) is a set of integers running from 0 to
127 (decimal) that imply character interpretation by the
display <br>
and other systems of computers. The range 0..127 can be
covered by setting the bits in a 7-bit binary digit, hence
the set is sometimes referred to as &quot;7-bit ASCII&quot;.
ASCII was <br>
described by the American National Standards Institute
document ANSI X3.4-1986. It was also described by ISO
646:1991 (with localization for currency symbols). The full
ASCII <br>
set is given in the table below as the first 128 elements.
Languages that can be written adequately with the characters
in ASCII include English, Hawaiian, Indonesian, Swahili <br>
and some Native American languages.</p>

<p style="margin-top: 1em">There are many character sets
that extend the range of integers from 0..2**7-1 up to
2**8-1, or 8 bit bytes (octets if you prefer). One common
one is the ISO 8859-1 character <br>
set.</p>

<p style="margin-top: 1em">ISO 8859 <br>
The ISO 8859-$n are a collection of character code sets from
the International Organization for Standardization (ISO)
each of which adds characters to the ASCII set that are <br>
typically found in European languages many of which are
based on the Roman, or Latin, alphabet.</p>

<p style="margin-top: 1em">Latin 1 (ISO 8859-1) <br>
A particular 8-bit extension to ASCII that includes grave
and acute accented Latin characters. Languages that can
employ ISO 8859-1 include all the languages covered by ASCII
as <br>
well as Afrikaans, Albanian, Basque, Catalan, Danish,
Faroese, Finnish, Norwegian, Portuguese, Spanish, and
Swedish. Dutch is covered albeit without the ij ligature.
French is <br>
covered too but without the oe ligature. German can use ISO
8859-1 but must do so without German-style quotation marks.
This set is based on Western European extensions to <br>
ASCII and is commonly encountered in world wide web work. In
IBM character code set identification terminology ISO 8859-1
is also known as CCSID 819 (or sometimes 0819 or even <br>
00819).</p>

<p style="margin-top: 1em">EBCDIC <br>
The Extended Binary Coded Decimal Interchange Code refers to
a large collection of single- and multi-byte coded character
sets that are different from ASCII or ISO 8859-1 and are
<br>
all slightly different from each other; they typically run
on host computers. The EBCDIC encodings derive from 8-bit
byte extensions of Hollerith punched card encodings. The
<br>
layout on the cards was such that high bits were set for the
upper and lower case alphabet characters [a-z] and [A-Z],
but there were gaps within each Latin alphabet range.</p>

<p style="margin-top: 1em">Some IBM EBCDIC character sets
may be known by character code set identification numbers
(CCSID numbers) or code page numbers.</p>

<p style="margin-top: 1em">Perl can be compiled on
platforms that run any of three commonly used EBCDIC
character sets, listed below.</p>

<p style="margin-top: 1em">The 13 variant characters <br>
Among IBM EBCDIC character code sets there are 13 characters
that are often mapped to different integer values. Those
characters are known as the 13 &quot;variant&quot;
characters and <br>
are: &nbsp;</p>

<p style="margin-top: 1em">[ ] { } ^ ~ ! # | $ @
&lsquo;</p>

<p style="margin-top: 1em">When Perl is compiled for a
platform, it looks at some of these characters to guess
which EBCDIC character set the platform uses, and adapts
itself accordingly to that platform. <br>
If the platform uses a character set that is not one of the
three Perl knows about, Perl will either fail to compile, or
mistakenly and silently choose one of the three. They <br>
are:</p>

<p style="margin-top: 1em">0037 <br>
Character code set ID 0037 is a mapping of the ASCII plus
Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set. 0037
is used in North American English locales on the OS/400 <br>
operating system that runs on AS/400 computers. CCSID 0037
differs from ISO 8859-1 in 237 places, in other words they
agree on only 19 code point values.</p>

<p style="margin-top: 1em">1047 <br>
Character code set ID 1047 is also a mapping of the ASCII
plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set.
1047 is used under Unix System Services for OS/390 or z/OS,
<br>
and OpenEdition for VM/ESA. CCSID 1047 differs from CCSID
0037 in eight places.</p>

<p style="margin-top: 1em">POSIX-BC <br>
The EBCDIC code page in use on Siemens&rsquo; BS2000 system
is distinct from 1047 and 0037. It is identified below as
the POSIX-BC set.</p>

<p style="margin-top: 1em">Unicode code points versus
EBCDIC code points <br>
In Unicode terminology a code point is the number assigned
to a character: for example, in EBCDIC the character
&quot;A&quot; is usually assigned the number 193. In Unicode
the character <br>
&quot;A&quot; is assigned the number 65. This causes a
problem with the semantics of the pack/unpack &quot;U&quot;,
which are supposed to pack Unicode code points to characters
and back to numbers. <br>
The problem is: which code points to use for code points
less than 256? (for 256 and over there&rsquo;s no problem:
Unicode code points are used) In EBCDIC, for the low 256 the
EBCDIC <br>
code points are used. This means that the equivalences</p>

<p style="margin-top: 1em">pack(&quot;U&quot;,
ord($character)) eq $character <br>
unpack(&quot;U&quot;, $character) == ord $character</p>

<p style="margin-top: 1em">will hold. (If Unicode code
points were applied consistently over all the possible code
points, pack(&quot;U&quot;,ord(&quot;A&quot;)) would in
EBCDIC equal A with acute or chr(101), and <br>
unpack(&quot;U&quot;, &quot;A&quot;) would equal 65, or
non-breaking space, not 193, or ord &quot;A&quot;.)</p>

<p style="margin-top: 1em">Remaining Perl Unicode problems
in EBCDIC <br>
&Acirc;&middot; Many of the remaining problems seem to be
related to case-insensitive matching</p>

<p style="margin-top: 1em">&Acirc;&middot; The extensions
Unicode::Collate and Unicode::Normalized are not supported
under EBCDIC, likewise for the encoding pragma.</p>

<p style="margin-top: 1em">Unicode and UTF <br>
UTF stands for &quot;Unicode Transformation Format&quot;.
UTF-8 is an encoding of Unicode into a sequence of 8-bit
byte chunks, based on ASCII and Latin-1. The length of a
sequence <br>
required to represent a Unicode code point depends on the
ordinal number of that code point, with larger numbers
requiring more bytes. UTF-EBCDIC is like UTF-8, but based on
<br>
EBCDIC.</p>

<p style="margin-top: 1em">You may see the term
&quot;invariant&quot; character or code point. This simply
means that the character has the same numeric value when
encoded as when not. (Note that this is a very <br>
different concept from &quot;The 13 variant characters&quot;
mentioned above.) For example, the ordinal value of
&rsquo;A&rsquo; is 193 in most EBCDIC code pages, and also
is 193 when encoded in UTF- <br>
EBCDIC. All variant code points occupy at least two bytes
when encoded. In UTF-8, the code points corresponding to the
lowest 128 ordinal numbers (0 - 127: the ASCII <br>
characters) are invariant. In UTF-EBCDIC, there are 160
invariant characters. (If you care, the EBCDIC invariants
are those characters which have ASCII equivalents, plus
those <br>
that correspond to the C1 controls (80..9f on ASCII
platforms).)</p>

<p style="margin-top: 1em">A string encoded in UTF-EBCDIC
may be longer (but never shorter) than one encoded in
UTF-8.</p>

<p style="margin-top: 1em">Using Encode <br>
Starting from Perl 5.8 you can use the standard new module
Encode to translate from EBCDIC to Latin-1 code points.
Encode knows about more EBCDIC character sets than Perl can
<br>
currently be compiled to run on.</p>

<p style="margin-top: 1em">use Encode
&rsquo;from_to&rsquo;;</p>

<p style="margin-top: 1em">my %ebcdic = ( 176 =&gt;
&rsquo;cp37&rsquo;, 95 =&gt; &rsquo;cp1047&rsquo;, 106 =&gt;
&rsquo;posix-bc&rsquo; );</p>

<p style="margin-top: 1em"># $a is in EBCDIC code points
<br>
from_to($a, $ebcdic{ord &rsquo;^&rsquo;},
&rsquo;latin1&rsquo;); <br>
# $a is ISO 8859-1 code points</p>

<p style="margin-top: 1em">and from Latin-1 code points to
EBCDIC code points</p>

<p style="margin-top: 1em">use Encode
&rsquo;from_to&rsquo;;</p>

<p style="margin-top: 1em">my %ebcdic = ( 176 =&gt;
&rsquo;cp37&rsquo;, 95 =&gt; &rsquo;cp1047&rsquo;, 106 =&gt;
&rsquo;posix-bc&rsquo; );</p>

<p style="margin-top: 1em"># $a is ISO 8859-1 code points
<br>
from_to($a, &rsquo;latin1&rsquo;, $ebcdic{ord
&rsquo;^&rsquo;}); <br>
# $a is in EBCDIC code points</p>

<p style="margin-top: 1em">For doing I/O it is suggested
that you use the autotranslating features of PerlIO, see
perluniintro.</p>

<p style="margin-top: 1em">Since version 5.8 Perl uses the
new PerlIO I/O library. This enables you to use different
encodings per IO channel. For example you may use</p>

<p style="margin-top: 1em">use Encode; <br>
open($f, &quot;&gt;:encoding(ascii)&quot;,
&quot;test.ascii&quot;); <br>
print $f &quot;Hello World!0; <br>
open($f, &quot;&gt;:encoding(cp37)&quot;,
&quot;test.ebcdic&quot;); <br>
print $f &quot;Hello World!0; <br>
open($f, &quot;&gt;:encoding(latin1)&quot;,
&quot;test.latin1&quot;); <br>
print $f &quot;Hello World!0; <br>
open($f, &quot;&gt;:encoding(utf8)&quot;,
&quot;test.utf8&quot;); <br>
print $f &quot;Hello World!0;</p>

<p style="margin-top: 1em">to get four files containing
&quot;Hello World!0 in ASCII, CP 0037 EBCDIC, ISO 8859-1
(Latin-1) (in this example identical to ASCII since only
ASCII characters were printed), and <br>
UTF-EBCDIC (in this example identical to normal EBCDIC since
only characters that don&rsquo;t differ between EBCDIC and
UTF-EBCDIC were printed). See the documentation of <br>
Encode::PerlIO for details.</p>

<p style="margin-top: 1em">As the PerlIO layer uses raw IO
(bytes) internally, all this totally ignores things like the
type of your filesystem (ASCII or EBCDIC).</p>

<p style="margin-top: 1em">SINGLE OCTET TABLES <br>
The following tables list the ASCII and Latin 1 ordered sets
including the subsets: C0 controls (0..31), ASCII graphics
(32..7e), delete (7f), C1 controls (80..9f), and Latin-1
<br>
(a.k.a. ISO 8859-1) (a0..ff). In the table non-printing
control character names as well as the Latin 1 extensions to
ASCII have been labelled with character names roughly <br>
corresponding to The Unicode Standard, Version 3.0 albeit
with substitutions such as s/LATIN// and s/VULGAR// in all
cases, s/CAPITAL LETTER// in some cases, and s/SMALL LETTER
<br>
([A-Z])/in some other cases. The &quot;names&quot; of the
controls listed here are the Unicode Version 1 names, except
for the few that don&rsquo;t have names, in which case the
names in <br>
the Wikipedia article were used
(&lt;http://en.wikipedia.org/wiki/C0_and_C1_control_codes&gt;).
The differences between the 0037 and 1047 sets are flagged
with ***. The differences <br>
between the 1047 and POSIX-BC sets are flagged with ###. All
ord() numbers listed are decimal. If you would rather see
this table listing octal values then run the table (that
<br>
is, the pod version of this document since this recipe may
not work with a pod2_other_format translation) through:</p>

<p style="margin-top: 1em">recipe 0</p>

<p style="margin-top: 1em">perl -ne
&rsquo;if(/(.{43})(+)+)+)+)/)&rsquo; -e
&rsquo;{printf(&quot;%s%-9.03o%-9.03o%-9.03o%.03o0,$1,$2,$3,$4,$5)}&rsquo;
perlebcdic.pod</p>

<p style="margin-top: 1em">If you want to retain the UTF-x
code points then in script form you might want to write:</p>

<p style="margin-top: 1em">recipe 1</p>


<p style="margin-top: 1em">open(FH,&quot;&lt;perlebcdic.pod&quot;)
or die &quot;Could not open perlebcdic.pod: $!&quot;; <br>
while (&lt;FH&gt;) { <br>
if (/(.{43})(+)+)+)+)+).?(*)+).?(*)/) <br>
{ <br>
if ($7 ne &rsquo;&rsquo; &amp;&amp; $9 ne &rsquo;&rsquo;) {
<br>
printf( <br>
&quot;%s%-9.03o%-9.03o%-9.03o%-9.03o%-3o.%-5o%-3o.%.03o0,
<br>
$1,$2,$3,$4,$5,$6,$7,$8,$9); <br>
} <br>
elsif ($7 ne &rsquo;&rsquo;) { <br>
printf(&quot;%s%-9.03o%-9.03o%-9.03o%-9.03o%-3o.%-5o%.03o0,
<br>
$1,$2,$3,$4,$5,$6,$7,$8); <br>
} <br>
else { <br>
printf(&quot;%s%-9.03o%-9.03o%-9.03o%-9.03o%-9.03o%.03o0,
<br>
$1,$2,$3,$4,$5,$6,$8); <br>
} <br>
} <br>
}</p>

<p style="margin-top: 1em">If you would rather see this
table listing hexadecimal values then run the table
through:</p>

<p style="margin-top: 1em">recipe 2</p>

<p style="margin-top: 1em">perl -ne
&rsquo;if(/(.{43})(+)+)+)+)/)&rsquo; -e
&rsquo;{printf(&quot;%s%-9.02X%-9.02X%-9.02X%.02X0,$1,$2,$3,$4,$5)}&rsquo;
perlebcdic.pod</p>

<p style="margin-top: 1em">Or, in order to retain the UTF-x
code points in hexadecimal:</p>

<p style="margin-top: 1em">recipe 3</p>


<p style="margin-top: 1em">open(FH,&quot;&lt;perlebcdic.pod&quot;)
or die &quot;Could not open perlebcdic.pod: $!&quot;; <br>
while (&lt;FH&gt;) { <br>
if (/(.{43})(+)+)+)+)+).?(*)+).?(*)/) <br>
{ <br>
if ($7 ne &rsquo;&rsquo; &amp;&amp; $9 ne &rsquo;&rsquo;) {
<br>
printf( <br>
&quot;%s%-9.02X%-9.02X%-9.02X%-9.02X%-2X.%-6.02X%02X.%02X0,
<br>
$1,$2,$3,$4,$5,$6,$7,$8,$9); <br>
} <br>
elsif ($7 ne &rsquo;&rsquo;) { <br>

printf(&quot;%s%-9.02X%-9.02X%-9.02X%-9.02X%-2X.%-6.02X%02X0,
<br>
$1,$2,$3,$4,$5,$6,$7,$8); <br>
} <br>
else { <br>
printf(&quot;%s%-9.02X%-9.02X%-9.02X%-9.02X%-9.02X%02X0,
<br>
$1,$2,$3,$4,$5,$6,$8); <br>
} <br>
} <br>
}</p>

<p style="margin-top: 1em">ISO 8859-1 CCSID CCSID CCSID
1047 <br>
chr CCSID 0819 0037 1047 POSIX-BC UTF-8 UTF-EBCDIC <br>

----------------------------------------------------------------------------------------------
<br>
&lt;NULL&gt; 0 0 0 0 0 0 <br>
&lt;START OF HEADING&gt; 1 1 1 1 1 1 <br>
&lt;START OF TEXT&gt; 2 2 2 2 2 2 <br>
&lt;END OF TEXT&gt; 3 3 3 3 3 3 <br>
&lt;END OF TRANSMISSION&gt; 4 55 55 55 4 55 <br>
&lt;ENQUIRY&gt; 5 45 45 45 5 45 <br>
&lt;ACKNOWLEDGE&gt; 6 46 46 46 6 46 <br>
&lt;BELL&gt; 7 47 47 47 7 47 <br>
&lt;BACKSPACE&gt; 8 22 22 22 8 22 <br>
&lt;HORIZONTAL TABULATION&gt; 9 5 5 5 9 5 <br>
&lt;LINE FEED&gt; 10 37 21 21 10 21 *** <br>
&lt;VERTICAL TABULATION&gt; 11 11 11 11 11 11 <br>
&lt;FORM FEED&gt; 12 12 12 12 12 12 <br>
&lt;CARRIAGE RETURN&gt; 13 13 13 13 13 13 <br>
&lt;SHIFT OUT&gt; 14 14 14 14 14 14 <br>
&lt;SHIFT IN&gt; 15 15 15 15 15 15 <br>
&lt;DATA LINK ESCAPE&gt; 16 16 16 16 16 16 <br>
&lt;DEVICE CONTROL ONE&gt; 17 17 17 17 17 17 <br>
&lt;DEVICE CONTROL TWO&gt; 18 18 18 18 18 18 <br>
&lt;DEVICE CONTROL THREE&gt; 19 19 19 19 19 19 <br>
&lt;DEVICE CONTROL FOUR&gt; 20 60 60 60 20 60 <br>
&lt;NEGATIVE ACKNOWLEDGE&gt; 21 61 61 61 21 61 <br>
&lt;SYNCHRONOUS IDLE&gt; 22 50 50 50 22 50 <br>
&lt;END OF TRANSMISSION BLOCK&gt; 23 38 38 38 23 38 <br>
&lt;CANCEL&gt; 24 24 24 24 24 24 <br>
&lt;END OF MEDIUM&gt; 25 25 25 25 25 25 <br>
&lt;SUBSTITUTE&gt; 26 63 63 63 26 63 <br>
&lt;ESCAPE&gt; 27 39 39 39 27 39 <br>
&lt;FILE SEPARATOR&gt; 28 28 28 28 28 28 <br>
&lt;GROUP SEPARATOR&gt; 29 29 29 29 29 29 <br>
&lt;RECORD SEPARATOR&gt; 30 30 30 30 30 30 <br>
&lt;UNIT SEPARATOR&gt; 31 31 31 31 31 31 <br>
&lt;SPACE&gt; 32 64 64 64 32 64 <br>
! 33 90 90 90 33 90 <br>
&quot; 34 127 127 127 34 127 <br>
# 35 123 123 123 35 123 <br>
$ 36 91 91 91 36 91 <br>
% 37 108 108 108 37 108 <br>
&amp; 38 80 80 80 38 80 <br>
&rsquo; 39 125 125 125 39 125 <br>
( 40 77 77 77 40 77 <br>
) 41 93 93 93 41 93 <br>
* 42 92 92 92 42 92 <br>
+ 43 78 78 78 43 78 <br>
, 44 107 107 107 44 107 <br>
- 45 96 96 96 45 96 <br>
. 46 75 75 75 46 75 <br>
/ 47 97 97 97 47 97 <br>
0 48 240 240 240 48 240 <br>
1 49 241 241 241 49 241 <br>
2 50 242 242 242 50 242 <br>
3 51 243 243 243 51 243 <br>
4 52 244 244 244 52 244 <br>
5 53 245 245 245 53 245 <br>
6 54 246 246 246 54 246 <br>
7 55 247 247 247 55 247 <br>
8 56 248 248 248 56 248 <br>
9 57 249 249 249 57 249 <br>
: 58 122 122 122 58 122 <br>
; 59 94 94 94 59 94 <br>
&lt; 60 76 76 76 60 76 <br>
= 61 126 126 126 61 126 <br>
&gt; 62 110 110 110 62 110 <br>
? 63 111 111 111 63 111 <br>
@ 64 124 124 124 64 124 <br>
A 65 193 193 193 65 193 <br>
B 66 194 194 194 66 194 <br>
C 67 195 195 195 67 195 <br>
D 68 196 196 196 68 196 <br>
E 69 197 197 197 69 197 <br>
F 70 198 198 198 70 198 <br>
G 71 199 199 199 71 199 <br>
H 72 200 200 200 72 200 <br>
I 73 201 201 201 73 201 <br>
J 74 209 209 209 74 209 <br>
K 75 210 210 210 75 210 <br>
L 76 211 211 211 76 211 <br>
M 77 212 212 212 77 212 <br>
N 78 213 213 213 78 213 <br>
O 79 214 214 214 79 214 <br>
P 80 215 215 215 80 215 <br>
Q 81 216 216 216 81 216 <br>
R 82 217 217 217 82 217 <br>
S 83 226 226 226 83 226 <br>
T 84 227 227 227 84 227 <br>
U 85 228 228 228 85 228 <br>
V 86 229 229 229 86 229 <br>
W 87 230 230 230 87 230 <br>
X 88 231 231 231 88 231 <br>
Y 89 232 232 232 89 232 <br>
Z 90 233 233 233 90 233 <br>
[ 91 186 173 187 91 173 *** ### &nbsp; <br>
92 224 224 188 92 224 ### <br>
] 93 187 189 189 93 189 *** <br>
^ 94 176 95 106 94 95 *** ### <br>
_ 95 109 109 109 95 109 <br>
&lsquo; 96 121 121 74 96 121 ### <br>
a 97 129 129 129 97 129 <br>
b 98 130 130 130 98 130 <br>
c 99 131 131 131 99 131 <br>
d 100 132 132 132 100 132 <br>
e 101 133 133 133 101 133 <br>
f 102 134 134 134 102 134 <br>
g 103 135 135 135 103 135 <br>
h 104 136 136 136 104 136 <br>
i 105 137 137 137 105 137 <br>
j 106 145 145 145 106 145 <br>
k 107 146 146 146 107 146 <br>
l 108 147 147 147 108 147 <br>
m 109 148 148 148 109 148 <br>
n 110 149 149 149 110 149 <br>
o 111 150 150 150 111 150 <br>
p 112 151 151 151 112 151 <br>
q 113 152 152 152 113 152 <br>
r 114 153 153 153 114 153 <br>
s 115 162 162 162 115 162 <br>
t 116 163 163 163 116 163 <br>
u 117 164 164 164 117 164 <br>
v 118 165 165 165 118 165 <br>
w 119 166 166 166 119 166 <br>
x 120 167 167 167 120 167 <br>
y 121 168 168 168 121 168 <br>
z 122 169 169 169 122 169 <br>
{ 123 192 192 251 123 192 ### <br>
| 124 79 79 79 124 79 <br>
} 125 208 208 253 125 208 ### <br>
~ 126 161 161 255 126 161 ### <br>
&lt;DELETE&gt; 127 7 7 7 127 7 <br>
&lt;PADDING CHARACTER&gt; 128 32 32 32 194.128 32 <br>
&lt;HIGH OCTET PRESET&gt; 129 33 33 33 194.129 33 <br>
&lt;BREAK PERMITTED HERE&gt; 130 34 34 34 194.130 34 <br>
&lt;NO BREAK HERE&gt; 131 35 35 35 194.131 35 <br>
&lt;INDEX&gt; 132 36 36 36 194.132 36 <br>
&lt;NEXT LINE&gt; 133 21 37 37 194.133 37 *** <br>
&lt;START OF SELECTED AREA&gt; 134 6 6 6 194.134 6 <br>
&lt;END OF SELECTED AREA&gt; 135 23 23 23 194.135 23 <br>
&lt;CHARACTER TABULATION SET&gt; 136 40 40 40 194.136 40
<br>
&lt;CHARACTER TABULATION WITH JUSTIFICATION&gt; 137 41 41 41
194.137 41 <br>
&lt;LINE TABULATION SET&gt; 138 42 42 42 194.138 42 <br>
&lt;PARTIAL LINE FORWARD&gt; 139 43 43 43 194.139 43 <br>
&lt;PARTIAL LINE BACKWARD&gt; 140 44 44 44 194.140 44 <br>
&lt;REVERSE LINE FEED&gt; 141 9 9 9 194.141 9 <br>
&lt;SINGLE SHIFT TWO&gt; 142 10 10 10 194.142 10 <br>
&lt;SINGLE SHIFT THREE&gt; 143 27 27 27 194.143 27 <br>
&lt;DEVICE CONTROL STRING&gt; 144 48 48 48 194.144 48 <br>
&lt;PRIVATE USE ONE&gt; 145 49 49 49 194.145 49 <br>
&lt;PRIVATE USE TWO&gt; 146 26 26 26 194.146 26 <br>
&lt;SET TRANSMIT STATE&gt; 147 51 51 51 194.147 51 <br>
&lt;CANCEL CHARACTER&gt; 148 52 52 52 194.148 52 <br>
&lt;MESSAGE WAITING&gt; 149 53 53 53 194.149 53 <br>
&lt;START OF GUARDED AREA&gt; 150 54 54 54 194.150 54 <br>
&lt;END OF GUARDED AREA&gt; 151 8 8 8 194.151 8 <br>
&lt;START OF STRING&gt; 152 56 56 56 194.152 56 <br>
&lt;SINGLE GRAPHIC CHARACTER INTRODUCER&gt; 153 57 57 57
194.153 57 <br>
&lt;SINGLE CHARACTER INTRODUCER&gt; 154 58 58 58 194.154 58
<br>
&lt;CONTROL SEQUENCE INTRODUCER&gt; 155 59 59 59 194.155 59
<br>
&lt;STRING TERMINATOR&gt; 156 4 4 4 194.156 4 <br>
&lt;OPERATING SYSTEM COMMAND&gt; 157 20 20 20 194.157 20
<br>
&lt;PRIVACY MESSAGE&gt; 158 62 62 62 194.158 62 <br>
&lt;APPLICATION PROGRAM COMMAND&gt; 159 255 255 95 194.159
255 ### <br>
&lt;NON-BREAKING SPACE&gt; 160 65 65 65 194.160 128.65 <br>
&lt;INVERTED EXCLAMATION MARK&gt; 161 170 170 170 194.161
128.66 <br>
&lt;CENT SIGN&gt; 162 74 74 176 194.162 128.67 ### <br>
&lt;POUND SIGN&gt; 163 177 177 177 194.163 128.68 <br>
&lt;CURRENCY SIGN&gt; 164 159 159 159 194.164 128.69 <br>
&lt;YEN SIGN&gt; 165 178 178 178 194.165 128.70 <br>
&lt;BROKEN BAR&gt; 166 106 106 208 194.166 128.71 ### <br>
&lt;SECTION SIGN&gt; 167 181 181 181 194.167 128.72 <br>
&lt;DIAERESIS&gt; 168 189 187 121 194.168 128.73 *** ###
<br>
&lt;COPYRIGHT SIGN&gt; 169 180 180 180 194.169 128.74 <br>
&lt;FEMININE ORDINAL INDICATOR&gt; 170 154 154 154 194.170
128.81 <br>
&lt;LEFT POINTING GUILLEMET&gt; 171 138 138 138 194.171
128.82 <br>
&lt;NOT SIGN&gt; 172 95 176 186 194.172 128.83 *** ### <br>
&lt;SOFT HYPHEN&gt; 173 202 202 202 194.173 128.84 <br>
&lt;REGISTERED TRADE MARK SIGN&gt; 174 175 175 175 194.174
128.85 <br>
&lt;MACRON&gt; 175 188 188 161 194.175 128.86 ### <br>
&lt;DEGREE SIGN&gt; 176 144 144 144 194.176 128.87 <br>
&lt;PLUS-OR-MINUS SIGN&gt; 177 143 143 143 194.177 128.88
<br>
&lt;SUPERSCRIPT TWO&gt; 178 234 234 234 194.178 128.89 <br>
&lt;SUPERSCRIPT THREE&gt; 179 250 250 250 194.179 128.98
<br>
&lt;ACUTE ACCENT&gt; 180 190 190 190 194.180 128.99 <br>
&lt;MICRO SIGN&gt; 181 160 160 160 194.181 128.100 <br>
&lt;PARAGRAPH SIGN&gt; 182 182 182 182 194.182 128.101 <br>
&lt;MIDDLE DOT&gt; 183 179 179 179 194.183 128.102 <br>
&lt;CEDILLA&gt; 184 157 157 157 194.184 128.103 <br>
&lt;SUPERSCRIPT ONE&gt; 185 218 218 218 194.185 128.104 <br>
&lt;MASC. ORDINAL INDICATOR&gt; 186 155 155 155 194.186
128.105 <br>
&lt;RIGHT POINTING GUILLEMET&gt; 187 139 139 139 194.187
128.106 <br>
&lt;FRACTION ONE QUARTER&gt; 188 183 183 183 194.188 128.112
<br>
&lt;FRACTION ONE HALF&gt; 189 184 184 184 194.189 128.113
<br>
&lt;FRACTION THREE QUARTERS&gt; 190 185 185 185 194.190
128.114 <br>
&lt;INVERTED QUESTION MARK&gt; 191 171 171 171 194.191
128.115 <br>
&lt;A WITH GRAVE&gt; 192 100 100 100 195.128 138.65 <br>
&lt;A WITH ACUTE&gt; 193 101 101 101 195.129 138.66 <br>
&lt;A WITH CIRCUMFLEX&gt; 194 98 98 98 195.130 138.67 <br>
&lt;A WITH TILDE&gt; 195 102 102 102 195.131 138.68 <br>
&lt;A WITH DIAERESIS&gt; 196 99 99 99 195.132 138.69 <br>
&lt;A WITH RING ABOVE&gt; 197 103 103 103 195.133 138.70
<br>
&lt;CAPITAL LIGATURE AE&gt; 198 158 158 158 195.134 138.71
<br>
&lt;C WITH CEDILLA&gt; 199 104 104 104 195.135 138.72 <br>
&lt;E WITH GRAVE&gt; 200 116 116 116 195.136 138.73 <br>
&lt;E WITH ACUTE&gt; 201 113 113 113 195.137 138.74 <br>
&lt;E WITH CIRCUMFLEX&gt; 202 114 114 114 195.138 138.81
<br>
&lt;E WITH DIAERESIS&gt; 203 115 115 115 195.139 138.82 <br>
&lt;I WITH GRAVE&gt; 204 120 120 120 195.140 138.83 <br>
&lt;I WITH ACUTE&gt; 205 117 117 117 195.141 138.84 <br>
&lt;I WITH CIRCUMFLEX&gt; 206 118 118 118 195.142 138.85
<br>
&lt;I WITH DIAERESIS&gt; 207 119 119 119 195.143 138.86 <br>
&lt;CAPITAL LETTER ETH&gt; 208 172 172 172 195.144 138.87
<br>
&lt;N WITH TILDE&gt; 209 105 105 105 195.145 138.88 <br>
&lt;O WITH GRAVE&gt; 210 237 237 237 195.146 138.89 <br>
&lt;O WITH ACUTE&gt; 211 238 238 238 195.147 138.98 <br>
&lt;O WITH CIRCUMFLEX&gt; 212 235 235 235 195.148 138.99
<br>
&lt;O WITH TILDE&gt; 213 239 239 239 195.149 138.100 <br>
&lt;O WITH DIAERESIS&gt; 214 236 236 236 195.150 138.101
<br>
&lt;MULTIPLICATION SIGN&gt; 215 191 191 191 195.151 138.102
<br>
&lt;O WITH STROKE&gt; 216 128 128 128 195.152 138.103 <br>
&lt;U WITH GRAVE&gt; 217 253 253 224 195.153 138.104 ###
<br>
&lt;U WITH ACUTE&gt; 218 254 254 254 195.154 138.105 <br>
&lt;U WITH CIRCUMFLEX&gt; 219 251 251 221 195.155 138.106
### <br>
&lt;U WITH DIAERESIS&gt; 220 252 252 252 195.156 138.112
<br>
&lt;Y WITH ACUTE&gt; 221 173 186 173 195.157 138.113 *** ###
<br>
&lt;CAPITAL LETTER THORN&gt; 222 174 174 174 195.158 138.114
<br>
&lt;SMALL LETTER SHARP S&gt; 223 89 89 89 195.159 138.115
<br>
&lt;a WITH GRAVE&gt; 224 68 68 68 195.160 139.65 <br>
&lt;a WITH ACUTE&gt; 225 69 69 69 195.161 139.66 <br>
&lt;a WITH CIRCUMFLEX&gt; 226 66 66 66 195.162 139.67 <br>
&lt;a WITH TILDE&gt; 227 70 70 70 195.163 139.68 <br>
&lt;a WITH DIAERESIS&gt; 228 67 67 67 195.164 139.69 <br>
&lt;a WITH RING ABOVE&gt; 229 71 71 71 195.165 139.70 <br>
&lt;SMALL LIGATURE ae&gt; 230 156 156 156 195.166 139.71
<br>
&lt;c WITH CEDILLA&gt; 231 72 72 72 195.167 139.72 <br>
&lt;e WITH GRAVE&gt; 232 84 84 84 195.168 139.73 <br>
&lt;e WITH ACUTE&gt; 233 81 81 81 195.169 139.74 <br>
&lt;e WITH CIRCUMFLEX&gt; 234 82 82 82 195.170 139.81 <br>
&lt;e WITH DIAERESIS&gt; 235 83 83 83 195.171 139.82 <br>
&lt;i WITH GRAVE&gt; 236 88 88 88 195.172 139.83 <br>
&lt;i WITH ACUTE&gt; 237 85 85 85 195.173 139.84 <br>
&lt;i WITH CIRCUMFLEX&gt; 238 86 86 86 195.174 139.85 <br>
&lt;i WITH DIAERESIS&gt; 239 87 87 87 195.175 139.86 <br>
&lt;SMALL LETTER eth&gt; 240 140 140 140 195.176 139.87 <br>
&lt;n WITH TILDE&gt; 241 73 73 73 195.177 139.88 <br>
&lt;o WITH GRAVE&gt; 242 205 205 205 195.178 139.89 <br>
&lt;o WITH ACUTE&gt; 243 206 206 206 195.179 139.98 <br>
&lt;o WITH CIRCUMFLEX&gt; 244 203 203 203 195.180 139.99
<br>
&lt;o WITH TILDE&gt; 245 207 207 207 195.181 139.100 <br>
&lt;o WITH DIAERESIS&gt; 246 204 204 204 195.182 139.101
<br>
&lt;DIVISION SIGN&gt; 247 225 225 225 195.183 139.102 <br>
&lt;o WITH STROKE&gt; 248 112 112 112 195.184 139.103 <br>
&lt;u WITH GRAVE&gt; 249 221 221 192 195.185 139.104 ###
<br>
&lt;u WITH ACUTE&gt; 250 222 222 222 195.186 139.105 <br>
&lt;u WITH CIRCUMFLEX&gt; 251 219 219 219 195.187 139.106
<br>
&lt;u WITH DIAERESIS&gt; 252 220 220 220 195.188 139.112
<br>
&lt;y WITH ACUTE&gt; 253 141 141 141 195.189 139.113 <br>
&lt;SMALL LETTER thorn&gt; 254 142 142 142 195.190 139.114
<br>
&lt;y WITH DIAERESIS&gt; 255 223 223 223 195.191 139.115</p>

<p style="margin-top: 1em">If you would rather see the
above table in CCSID 0037 order rather than ASCII + Latin-1
order then run the table through:</p>

<p style="margin-top: 1em">recipe 4</p>

<p style="margin-top: 1em">perl -ne
&rsquo;if(/.{43}{1,3}8}{1,3}8}{1,3}8}{1,3}/)&rsquo; -e
&rsquo;{push(@l,$_)}&rsquo; -e &rsquo;END{print
map{$_-&gt;[0]}&rsquo; -e &rsquo; sort{$a-&gt;[1] &lt;=&gt;
$b-&gt;[1]}&rsquo; -e &rsquo;
map{[$_,substr($_,52,3)]}@l;}&rsquo; perlebcdic.pod</p>

<p style="margin-top: 1em">If you would rather see it in
CCSID 1047 order then change the number 52 in the last line
to 61, like this:</p>

<p style="margin-top: 1em">recipe 5</p>

<p style="margin-top: 1em">perl -ne
&rsquo;if(/.{43}{1,3}8}{1,3}8}{1,3}8}{1,3}/)&rsquo; -e
&rsquo;{push(@l,$_)}&rsquo; -e &rsquo;END{print
map{$_-&gt;[0]}&rsquo; -e &rsquo; sort{$a-&gt;[1] &lt;=&gt;
$b-&gt;[1]}&rsquo; -e &rsquo;
map{[$_,substr($_,61,3)]}@l;}&rsquo; perlebcdic.pod</p>

<p style="margin-top: 1em">If you would rather see it in
POSIX-BC order then change the number 61 in the last line to
70, like this:</p>

<p style="margin-top: 1em">recipe 6</p>

<p style="margin-top: 1em">perl -ne
&rsquo;if(/.{43}{1,3}8}{1,3}8}{1,3}8}{1,3}/)&rsquo; -e
&rsquo;{push(@l,$_)}&rsquo; -e &rsquo;END{print
map{$_-&gt;[0]}&rsquo; -e &rsquo; sort{$a-&gt;[1] &lt;=&gt;
$b-&gt;[1]}&rsquo; -e &rsquo;
map{[$_,substr($_,70,3)]}@l;}&rsquo; perlebcdic.pod</p>

<p style="margin-top: 1em">IDENTIFYING CHARACTER CODE SETS
<br>
To determine the character set you are running under from
perl one could use the return value of ord() or chr() to
test one or more character values. For example:</p>

<p style="margin-top: 1em">$is_ascii = &quot;A&quot; eq
chr(65); <br>
$is_ebcdic = &quot;A&quot; eq chr(193);</p>

<p style="margin-top: 1em">Also, &quot;&quot; is a
&quot;HORIZONTAL TABULATION&quot; character so that:</p>

<p style="margin-top: 1em">$is_ascii = ord(&quot;&quot;) ==
9; <br>
$is_ebcdic = ord(&quot;&quot;) == 5;</p>

<p style="margin-top: 1em">To distinguish EBCDIC code pages
try looking at one or more of the characters that differ
between them. For example:</p>

<p style="margin-top: 1em">$is_ebcdic_37 = &quot;0 eq
chr(37); <br>
$is_ebcdic_1047 = &quot;0 eq chr(21);</p>

<p style="margin-top: 1em">Or better still choose a
character that is uniquely encoded in any of the code sets,
e.g.:</p>

<p style="margin-top: 1em">$is_ascii = ord(&rsquo;[&rsquo;)
== 91; <br>
$is_ebcdic_37 = ord(&rsquo;[&rsquo;) == 186; <br>
$is_ebcdic_1047 = ord(&rsquo;[&rsquo;) == 173; <br>
$is_ebcdic_POSIX_BC = ord(&rsquo;[&rsquo;) == 187;</p>

<p style="margin-top: 1em">However, it would be unwise to
write tests such as: &quot; ne chr(13); # WRONG</p>

<p style="margin-top: 1em">$is_ascii = &quot; <br>
$is_ascii = &quot;0 ne chr(10); # ILL ADVISED</p>

<p style="margin-top: 1em">Obviously the first of these
will fail to distinguish most ASCII platforms from either a
CCSID 0037, a 1047, or a POSIX-BC&quot; eq chr(13) under all
of EBCDIC platform since &quot; <br>
those coded character sets. But note too that because
&quot;0&quot; is chr(10) on the Macintosh (which is an ASCII
is chr(13) and &quot; platform) the second $is_ascii test
will lead to <br>
trouble there.</p>

<p style="margin-top: 1em">To determine whether or not perl
was built under an EBCDIC code page you can use the Config
module like so:</p>

<p style="margin-top: 1em">use Config; <br>
$is_ebcdic = $Config{&rsquo;ebcdic&rsquo;} eq
&rsquo;define&rsquo;;</p>

<p style="margin-top: 1em">CONVERSIONS <br>
tr/// <br>
In order to convert a string of characters from one
character set to another a simple list of numbers, such as
in the right columns in the above table, along with
perl&rsquo;s tr/// <br>
operator is all that is needed. The data in the table are in
ASCII/Latin1 order, hence the EBCDIC columns provide
easy-to-use ASCII/Latin1 to EBCDIC operations that are also
<br>
easily reversed.</p>

<p style="margin-top: 1em">For example, to convert
ASCII/Latin1 to code page 037 take the output of the second
numbers column from the output of recipe 2 (modified to add
&rsquo;&acute; characters) and use it in <br>
tr/// like so:</p>

<p style="margin-top: 1em">$cp_037 = <br>
&rsquo;01237DEF655BCDEF&rsquo; . <br>
&rsquo;0123CD2689F7CDEF&rsquo; . <br>
&rsquo;0AFBBC0DDDCEB0B1&rsquo; . <br>
&rsquo;ECEEF&rsquo; . <br>
&rsquo;C . <br>
&rsquo;&rsquo; . <br>
&rsquo;9123456789123456&rsquo; . <br>
&rsquo;789 . <br>
&rsquo;0123456789ABC9AB&rsquo; . <br>
&rsquo;01A3456889AB44E&rsquo; . <br>
&rsquo;1AAF&rsquo; . <br>
&rsquo;0FBB . <br>
&rsquo;452637E841238567&rsquo; . <br>
&rsquo;909&rsquo; . <br>
&rsquo;452637C841238567&rsquo; . <br>
&rsquo;C9E&rsquo;;</p>

<p style="margin-top: 1em">my $ebcdic_string =
$ascii_string; <br>
eval &rsquo;$ebcdic_string =~ tr/ 00-377/&rsquo; . $cp_037 .
&rsquo;/&rsquo;;</p>

<p style="margin-top: 1em">To convert from EBCDIC 037 to
ASCII just reverse the order of the tr/// arguments like
so:</p>

<p style="margin-top: 1em">my $ascii_string =
$ebcdic_string; <br>
eval &rsquo;$ascii_string =~ tr/&rsquo; . $cp_037 . &rsquo;/
00-377/&rsquo;;</p>

<p style="margin-top: 1em">Similarly one could take the
output of the third numbers column from recipe 2 to obtain a
$cp_1047 table. The fourth numbers column of the output from
recipe 2 could provide a <br>
$cp_posix_bc table suitable for transcoding as well.</p>

<p style="margin-top: 1em">If you wanted to see the inverse
tables, you would first have to sort on the desired numbers
column as in recipes 4, 5 or 6, then take the output of the
first numbers column.</p>

<p style="margin-top: 1em">iconv <br>
XPG operability often implies the presence of an iconv
utility available from the shell or from the C library.
Consult your system&rsquo;s documentation for information on
iconv.</p>

<p style="margin-top: 1em">On OS/390 or z/OS see the
iconv(1) manpage. One way to invoke the iconv shell utility
from within perl would be to:</p>

<p style="margin-top: 1em"># OS/390 or z/OS example <br>
$ascii_data = &lsquo;echo &rsquo;$ebcdic_data&rsquo;| iconv
-f IBM-1047 -t ISO8859-1&lsquo;</p>

<p style="margin-top: 1em">or the inverse map:</p>

<p style="margin-top: 1em"># OS/390 or z/OS example <br>
$ebcdic_data = &lsquo;echo &rsquo;$ascii_data&rsquo;| iconv
-f ISO8859-1 -t IBM-1047&lsquo;</p>

<p style="margin-top: 1em">For other perl-based conversion
options see the Convert::* modules on CPAN.</p>

<p style="margin-top: 1em">C RTL <br>
The OS/390 and z/OS C run-time libraries provide _atoe() and
_etoa() functions.</p>

<p style="margin-top: 1em">OPERATOR DIFFERENCES <br>
The &quot;..&quot; range operator treats certain character
ranges with care on EBCDIC platforms. For example the
following array will have twenty six elements on either an
EBCDIC platform <br>
or an ASCII platform:</p>

<p style="margin-top: 1em">@alphabet =
(&rsquo;A&rsquo;..&rsquo;Z&rsquo;); # $#alphabet == 25</p>

<p style="margin-top: 1em">The bitwise operators such as
&amp; ^ | may return different results when operating on
string or character data in a perl program running on an
EBCDIC platform than when run on an <br>
ASCII platform. Here is an example adapted from the one in
perlop:</p>

<p style="margin-top: 1em"># EBCDIC-based examples <br>
print &quot;j p 0 ^ &quot; a h&quot;; # prints &quot;JAPH0
<br>
print &quot;JA&quot; | &quot; ph0; # prints &quot;japh0 <br>
print &quot;JAPH0unk&quot; &amp;
&quot;277277277277277&quot;; # prints &quot;japh0; <br>
print &rsquo;p N$&rsquo; ^ &quot; E&lt;H0; # prints
&quot;Perl0;</p>

<p style="margin-top: 1em">An interesting property of the
32 C0 control characters in the ASCII table is that they can
&quot;literally&quot; be constructed as control characters
in perl, e.g. &quot;(chr(0)&quot; eq &quot;
&quot;(chr(1)&quot; eq &quot; depend on which code page you
are using. The table below uses the standard acronyms for
the controls. The POSIX-BC and 1047 sets are identical
throughout this range and differ <br>
from the 0037 set at only one spot (21 decimal). Note that
the &quot;LINE FEED&quot; character may be generated by
&quot; cannot be generated as a &quot; terminator. But
&quot; <br>
chr ord 8859-1 0037 1047 &amp;&amp; POSIX-BC <br>

-----------------------------------------------------------------------
FUNCTION DIFFERENCES <br>
chr() chr() must be given an EBCDIC code number argument to
yield a desired character return value on an EBCDIC
platform. For example:</p>

<p style="margin-top: 1em">$CAPITAL_LETTER_A =
chr(193);</p>

<p style="margin-top: 1em">ord() ord() will return EBCDIC
code number values on an EBCDIC platform. For example:</p>

<p style="margin-top: 1em">$the_number_193 =
ord(&quot;A&quot;);</p>

<p style="margin-top: 1em">pack() The c and C templates for
pack() are dependent upon character set encoding. Examples
of usage on EBCDIC include:</p>

<p style="margin-top: 1em">$foo =
pack(&quot;CCCC&quot;,193,194,195,196); <br>
# $foo eq &quot;ABCD&quot; <br>
$foo = pack(&quot;C4&quot;,193,194,195,196); <br>
# same thing</p>

<p style="margin-top: 1em">$foo =
pack(&quot;ccxxcc&quot;,193,194,195,196); <br>
# $foo eq &quot;AB CD&quot;</p>

<p style="margin-top: 1em">print() One must be careful with
scalars and strings that are passed to print that contain
ASCII encodings. One common place for this to occur is in
the output of the MIME type <br>
header for CGI script writing. For example, many perl
programming guides recommend something similar to:</p>

<p style="margin-top: 1em">print
&quot;Content-type:text/html 15 12 15 12&quot;; <br>
# this may be wrong on EBCDIC</p>

<p style="margin-top: 1em">Under the IBM OS/390 USS Web
Server or WebSphere on z/OS for example you should instead
write that as: 0r0; # OK for DGW</p>

<p style="margin-top: 1em">print
&quot;Content-type:text/html et al</p>

<p style="margin-top: 1em">That is because the translation
from EBCDIC to ASCII is done by the web server in this case
(such code will not be appropriate for the Macintosh
however). Consult your <br>
web server&rsquo;s documentation for further details.</p>

<p style="margin-top: 1em">printf() <br>
The formats that can convert characters to numbers and vice
versa will be different from their ASCII counterparts when
executed on an EBCDIC platform. Examples include:</p>


<p style="margin-top: 1em">printf(&quot;%c%c%c&quot;,193,194,195);
# prints ABC</p>

<p style="margin-top: 1em">sort() EBCDIC sort results may
differ from ASCII sort results especially for mixed case
strings. This is discussed in more detail below.</p>

<p style="margin-top: 1em">sprintf() <br>
See the discussion of printf() above. An example of the use
of sprintf would be:</p>

<p style="margin-top: 1em">$CAPITAL_LETTER_A =
sprintf(&quot;%c&quot;,193);</p>

<p style="margin-top: 1em">unpack() <br>
See the discussion of pack() above.</p>

<p style="margin-top: 1em">REGULAR EXPRESSION DIFFERENCES
<br>
As of perl 5.005_03 the letter range regular expressions
such as [A-Z] and [a-z] have been especially coded to not
pick up gap characters. For example, characters such as o
&quot;o <br>
WITH CIRCUMFLEX&quot; that lie between I and J would not be
matched by the regular expression range &quot;/[H-K]/&quot;.
This works in the other direction, too, if either of the
range end <br>
points is explicitly numeric: &quot;[9-1]&quot; will match
&quot;e&quot;, even though &quot;9&quot; is &quot;i&quot;
and &quot;1 &quot; is &quot;j&quot;, and &quot;e&quot; is a
gap character from the alphabetic viewpoint.</p>

<p style="margin-top: 1em">If you do want to match the
alphabet gap characters in a single octet regular expression
try matching the hex or octal code such as &quot;/313/&quot;
on EBCDIC or &quot;/364/&quot; on ASCII <br>
platforms to have your regular expression match &quot;o WITH
CIRCUMFLEX&quot;.</p>

<p style="margin-top: 1em">Another construct to be wary of
is the inappropriate use of hex or octal constants in
regular expressions. Consider the following set of subs:</p>

<p style="margin-top: 1em">sub is_c0 { <br>
my $char = substr(shift,0,1); <br>
$char =~ /[ 00- 37]/; <br>
}</p>

<p style="margin-top: 1em">sub is_print_ascii { <br>
my $char = substr(shift,0,1); <br>
$char =~ /[ 40-176]/; <br>
}</p>

<p style="margin-top: 1em">sub is_delete { <br>
my $char = substr(shift,0,1); <br>
$char eq &quot;177&quot;; <br>
}</p>

<p style="margin-top: 1em">sub is_c1 { <br>
my $char = substr(shift,0,1); <br>
$char =~ /[200-237]/; <br>
}</p>

<p style="margin-top: 1em">sub is_latin_1 { <br>
my $char = substr(shift,0,1); <br>
$char =~ /[240-377]/; <br>
}</p>

<p style="margin-top: 1em">The above would be adequate if
the concern was only with numeric code points. However, the
concern may be with characters rather than code points and
on an EBCDIC platform it <br>
may be desirable for constructs such as &quot;if
(is_print_ascii(&quot;A&quot;)) {print &quot;A is a
printable character0;}&quot; to print out the expected
message. One way to represent the above <br>
collection of character classification subs that is capable
of working across the four coded character sets discussed in
this document is as follows:</p>

<p style="margin-top: 1em">sub Is_c0 { <br>
my $char = substr(shift,0,1); <br>
if (ord(&rsquo;^&rsquo;)==94) { # ascii <br>
return $char =~ /[ 00- 37]/; <br>
} <br>
if (ord(&rsquo;^&rsquo;)==176) { # 0037 <br>
return $char =~ /[ 00- 03 67 55- 57 26 05 45 13- 23 74 75 62
46 30 31 77 47 34- 37]/; <br>
} <br>
if (ord(&rsquo;^&rsquo;)==95 || ord(&rsquo;^&rsquo;)==106) {
# 1047 || posix-bc <br>
return $char =~ /[ 00- 03 67 55- 57 26 05 25 13- 23 74 75 62
46 30 31 77 47 34- 37]/; <br>
} <br>
}</p>

<p style="margin-top: 1em">sub Is_print_ascii { <br>
my $char = substr(shift,0,1); <br>
$char =~ /[ !&quot; }</p>

<p style="margin-top: 1em">sub Is_delete { <br>
my $char = substr(shift,0,1); <br>
if (ord(&rsquo;^&rsquo;)==94) { # ascii <br>
return $char eq &quot;177&quot;; <br>
} <br>
else { # ebcdic <br>
return $char eq &quot; 07&quot;; <br>
} <br>
}</p>

<p style="margin-top: 1em">sub Is_c1 { <br>
my $char = substr(shift,0,1); <br>
if (ord(&rsquo;^&rsquo;)==94) { # ascii <br>
return $char =~ /[200-237]/; <br>
} <br>
if (ord(&rsquo;^&rsquo;)==176) { # 0037 <br>
return $char =~ /[ 40- 44 25 06 27 50- 54 11 12 33 60 61 32
63- 66 10 70- 73 40 24 76377]/; <br>
} <br>
if (ord(&rsquo;^&rsquo;)==95) { # 1047 <br>
return $char =~ /[ 40- 45 06 27 50- 54 11 12 33 60 61 32 63-
66 10 70- 73 40 24 76377]/; <br>
} <br>
if (ord(&rsquo;^&rsquo;)==106) { # posix-bc <br>
return $char =~ <br>
/[ 40- 45 06 27 50- 54 11 12 33 60 61 32 63- 66 10 70- 73 40
24 76137]/; <br>
} <br>
}</p>

<p style="margin-top: 1em">sub Is_latin_1 { <br>
my $char = substr(shift,0,1); <br>
if (ord(&rsquo;^&rsquo;)==94) { # ascii <br>
return $char =~ /[240-377]/; <br>
} <br>
if (ord(&rsquo;^&rsquo;)==176) { # 0037 <br>
return $char =~ <br>

/[101252112261237262152265275264232212137312257274220217352372276240266263235332233213267270271253144145142146143147236150164161-163170165-167254151355356353357354277200375376373374255256131104105102106103107234110124121-123130125-127214111315316313317314341160335336333334215216337]/;
<br>
} <br>
if (ord(&rsquo;^&rsquo;)==95) { # 1047 <br>
return $char =~ <br>

/[101252112261237262152265273264232212260312257274220217352372276240266263235332233213267270271253144145142146143147236150164161-163170165-167254151355356353357354277200375376373374272256131104105102106103107234110124121-123130125-127214111315316313317314341160335336333334215216337]/;
<br>
} <br>
if (ord(&rsquo;^&rsquo;)==106) { # posix-bc <br>
return $char =~ <br>

/[101252260261237262320265171264232212272312257241220217352372276240266263235332233213267270271253144145142146143147236150164161-163170165-167254151355356353357354277200340376335374255256131104105102106103107234110124121-123130125-127214111315316313317314341160300336333334215216337]/;
<br>
} <br>
}</p>

<p style="margin-top: 1em">Note however that only the
&quot;Is_ascii_print()&quot; sub is really independent of
coded character set. Another way to write
&quot;Is_latin_1()&quot; would be to use the characters in
the range <br>
explicitly:</p>

<p style="margin-top: 1em">sub Is_latin_1 { <br>
my $char = substr(shift,0,1); <br>
$char =~ /[A
AXAXAXAXAXAXAXAXAXAXAXAXAAXAXAXAXAXAXAXAXAXAXAXAXAXAXAXAXAXAXA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~
A~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~A~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~X]/;
<br>
}</p>

<p style="margin-top: 1em">Although that form may run into
trouble in network transit (due to the presence of 8 bit
characters) or on non ISO-Latin character sets.</p>

<p style="margin-top: 1em">SOCKETS <br>
Most socket programming assumes ASCII character encodings in
network byte order. Exceptions can include CGI script
writing under a host web server where the server may take
care <br>
of translation for you. Most host web servers convert EBCDIC
data to ISO-8859-1 or Unicode on output.</p>

<p style="margin-top: 1em">SORTING <br>
One big difference between ASCII-based character sets and
EBCDIC ones are the relative positions of upper and lower
case letters and the letters compared to the digits. If <br>
sorted on an ASCII-based platform the two-letter
abbreviation for a physician comes before the two letter
abbreviation for drive; that is:</p>

<p style="margin-top: 1em">@sorted = sort(qw(Dr. dr.)); #
@sorted holds (&rsquo;Dr.&rsquo;,&rsquo;dr.&rsquo;) on
ASCII, <br>
# but (&rsquo;dr.&rsquo;,&rsquo;Dr.&rsquo;) on EBCDIC</p>

<p style="margin-top: 1em">The property of lowercase before
uppercase letters in EBCDIC is even carried to the Latin 1
EBCDIC pages such as 0037 and 1047. An example would be that
Ee &quot;E WITH DIAERESIS&quot; <br>
(203) comes before ee &quot;e WITH DIAERESIS&quot; (235) on
an ASCII platform, but the latter (83) comes before the
former (115) on an EBCDIC platform. (Astute readers will
note that the <br>
uppercase version of ss &quot;SMALL LETTER SHARP S&quot; is
simply &quot;SS&quot; and that the upper case version of ye
&quot;y WITH DIAERESIS&quot; is not in the 0..255 range but
it is at U+x0178 in Unicode, <br>
or &quot;&quot; in a Unicode enabled Perl).</p>

<p style="margin-top: 1em">The sort order will cause
differences between results obtained on ASCII platforms
versus EBCDIC platforms. What follows are some suggestions
on how to deal with these <br>
differences.</p>

<p style="margin-top: 1em">Ignore ASCII vs. EBCDIC sort
differences. <br>
This is the least computationally expensive strategy. It may
require some user education.</p>

<p style="margin-top: 1em">MONO CASE then sort data. <br>
In order to minimize the expense of mono casing mixed-case
text, try to &quot;tr///&quot; towards the character set
case most employed within the data. If the data are
primarily UPPERCASE <br>
non Latin 1 then apply tr/[a-z]/[A-Z]/ then sort(). If the
data are primarily lowercase non Latin 1 then apply
tr/[A-Z]/[a-z]/ before sorting. If the data are primarily
<br>
UPPERCASE and include Latin-1 characters then apply:</p>

<p style="margin-top: 1em">tr/[a-z]/[A-Z]/; <br>
tr/[A~
A~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~A~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~X]/[A~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~X/;
<br>
s/A~X/SS/g;</p>

<p style="margin-top: 1em">then sort(). Do note however
that such Latin-1 manipulation does not address the ye
&quot;y WITH DIAERESIS&quot; character that will remain at
code point 255 on ASCII platforms, but 223 <br>
on most EBCDIC platforms where it will sort to a place less
than the EBCDIC numerals. With a Unicode-enabled Perl you
might try:</p>

<p style="margin-top: 1em">tr/^?//;</p>

<p style="margin-top: 1em">The strategy of mono casing data
before sorting does not preserve the case of the data and
may not be acceptable for that reason.</p>

<p style="margin-top: 1em">Convert, sort data, then re
convert. <br>
This is the most expensive proposition that does not employ
a network connection.</p>

<p style="margin-top: 1em">Perform sorting on one type of
platform only. <br>
This strategy can employ a network connection. As such it
would be computationally expensive.</p>

<p style="margin-top: 1em">TRANSFORMATION FORMATS <br>
There are a variety of ways of transforming data with an
intra character set mapping that serve a variety of
purposes. Sorting was discussed in the previous section and
a few of <br>
the other more popular mapping techniques are discussed
next.</p>

<p style="margin-top: 1em">URL decoding and encoding <br>
Note that some URLs have hexadecimal ASCII code points in
them in an attempt to overcome character or protocol
limitation issues. For example the tilde character is not on
every <br>
keyboard hence a URL of the form:</p>

<p style="margin-top: 1em">http://www.pvhp.com/~pvhp/</p>

<p style="margin-top: 1em">may also be expressed as either
of:</p>


<p style="margin-top: 1em">http://www.pvhp.com/%7Epvhp/</p>


<p style="margin-top: 1em">http://www.pvhp.com/%7epvhp/</p>

<p style="margin-top: 1em">where 7E is the hexadecimal
ASCII code point for &rsquo;~&rsquo;. Here is an example of
decoding such a URL under CCSID 1047:</p>

<p style="margin-top: 1em">$url =
&rsquo;http://www.pvhp.com/%7Epvhp/&rsquo;; <br>
# this array assumes code page 1047 <br>
my @a2e_1047 = ( <br>
0, 1, 2, 3, 55, 45, 46, 47, 22, 5, 21, 11, 12, 13, 14, 15,
<br>
16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30,
31, <br>
64, 90,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75,
97, <br>
240,241,242,243,244,245,246,247,248,249,122, 94,
76,126,110,111, <br>

124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
<br>
215,216,217,226,227,228,229,230,231,232,233,173,224,189,
95,109, <br>

121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
<br>
151,152,153,162,163,164,165,166,167,168,169,192, 79,208,161,
7, <br>
32, 33, 34, 35, 36, 37, 6, 23, 40, 41, 42, 43, 44, 9, 10,
27, <br>
48, 49, 26, 51, 52, 53, 54, 8, 56, 57, 58, 59, 4, 20,
62,255, <br>
65,170,
74,177,159,178,106,181,187,180,154,138,176,202,175,188, <br>

144,143,234,250,190,160,182,179,157,218,155,139,183,184,185,171,
<br>
100,101, 98,102,
99,103,158,104,116,113,114,115,120,117,118,119, <br>

172,105,237,238,235,239,236,191,128,253,254,251,252,186,174,
89, <br>
68, 69, 66, 70, 67, 71,156, 72, 84, 81, 82, 83, 88, 85, 86,
87, <br>
140,
73,205,206,203,207,204,225,112,221,222,219,220,141,142,223
<br>
); <br>
$url =~
s/%([0-9a-fA-F]{2})/pack(&quot;c&quot;,$a2e_1047[hex($1)])/ge;</p>

<p style="margin-top: 1em">Conversely, here is a partial
solution for the task of encoding such a URL under the 1047
code page:</p>

<p style="margin-top: 1em">$url =
&rsquo;http://www.pvhp.com/~pvhp/&rsquo;; <br>
# this array assumes code page 1047 <br>
my @e2a_1047 = ( <br>
0, 1, 2, 3,156, 9,134,127,151,141,142, 11, 12, 13, 14, 15,
<br>
16, 17, 18, 19,157, 10, 8,135, 24, 25,146,143, 28, 29, 30,
31, <br>
128,129,130,131,132,133, 23, 27,136,137,138,139,140, 5, 6,
7, <br>
144,145, 22,147,148,149,150, 4,152,153,154,155, 20, 21,158,
26, <br>
32,160,226,228,224,225,227,229,231,241,162, 46, 60, 40,
43,124, <br>
38,233,234,235,232,237,238,239,236,223, 33, 36, 42, 41, 59,
94, <br>
45, 47,194,196,192,193,195,197,199,209,166, 44, 37, 95, 62,
63, <br>
248,201,202,203,200,205,206,207,204, 96, 58, 35, 64, 39, 61,
34, <br>
216, 97, 98,
99,100,101,102,103,104,105,171,187,240,253,254,177, <br>

176,106,107,108,109,110,111,112,113,114,170,186,230,184,198,164,
<br>
181,126,115,116,117,118,119,120,121,122,161,191,208,
91,222,174, <br>
172,163,165,183,169,167,182,188,189,190,221,168,175,
93,180,215, <br>
123, 65, 66, 67, 68, 69, 70, 71, 72,
73,173,244,246,242,243,245, <br>
125, 74, 75, 76, 77, 78, 79, 80, 81,
82,185,251,252,249,250,255, <br>
92,247, 83, 84, 85, 86, 87, 88, 89,
90,178,212,214,210,211,213, <br>
48, 49, 50, 51, 52, 53, 54, 55, 56,
57,179,219,220,217,218,159 <br>
); <br>
# The following regular expression does not address the <br>
# mappings for: (&rsquo;.&rsquo; =&gt; &rsquo;%2E&rsquo;,
&rsquo;/&rsquo; =&gt; &rsquo;%2F&rsquo;, &rsquo;:&rsquo;
=&gt; &rsquo;%3A&rsquo;) <br>
$url =~ s/([ &quot;#%&amp;,;&lt;=&gt; <br>
where a more complete solution would split the URL into
components and apply a full s/// substitution only to the
appropriate parts.</p>

<p style="margin-top: 1em">In the remaining examples a @e2a
or @a2e array may be employed but the assignment will not be
shown explicitly. For code page 1047 you could use the
@a2e_1047 or @e2a_1047 <br>
arrays just shown.</p>

<p style="margin-top: 1em">uu encoding and decoding <br>
The &quot;u&quot; template to pack() or unpack() will render
EBCDIC data in EBCDIC characters equivalent to their ASCII
counterparts. For example, the following will print
&quot;Yes indeed0 <br>
on either an ASCII or EBCDIC computer:</p>

<p style="margin-top: 1em">$all_byte_chrs = &rsquo;&rsquo;;
<br>
for (0..255) { $all_byte_chrs .= chr($_); } <br>
$uuencode_byte_chrs = pack(&rsquo;u&rsquo;, $all_byte_chrs);
<br>
($uu = &lt;&lt;&rsquo;ENDOFHEREDOC&rsquo;) =~ s/^//gm; <br>

M&lsquo;&lsquo;$&quot;&lsquo;P0%!@&lt;(&quot;0H+#&lsquo;T.#Q&lsquo;1$A,4%187&amp;!D:&amp;QP=&rsquo;A@(2(C)&quot;4F)R@I*BLL
<br>

M+2XO,#$R,S0U-C&lt;X.3H[/#T^/T!!0D-$149&rsquo;2$E*2TQ-3D]045)35%565UA9
<br>

M6EM&lt;75Y?8&amp;%B8V1E9F=H:6IK;&amp;UN;W!Q&lt;G-T=79W&gt;&rsquo;EZ&gt;WQ]?G^&lsquo;@8*#A(6&amp;
<br>

MAXB)BHN,C8Z/D)&amp;2DY25EI&gt;8F9J;G)V&gt;GZ&quot;AHJ.DI::GJ*FJJZRMKJ^PL;*S
<br>

MM+6VM[BYNKNZ_P,&rsquo;&quot;P3%QL?(R&lt;K+S,W.S]#1TM/4U=;7V-G:V]S=WM_@
<br>

?X&gt;+CY.7FY^CIZNOL[&gt;[O&rsquo;R_3U]O?X^?K[_/W^_P&lsquo;&lsquo;
<br>
ENDOFHEREDOC <br>
if ($uuencode_byte_chrs eq $uu) { <br>
print &quot;Yes &quot;; <br>
} <br>
$uudecode_byte_chrs = unpack(&rsquo;u&rsquo;,
$uuencode_byte_chrs); <br>
if ($uudecode_byte_chrs eq $all_byte_chrs) { <br>
print &quot;indeed0; <br>
}</p>

<p style="margin-top: 1em">Here is a very spartan uudecoder
that will work on EBCDIC provided that the @e2a array is
filled in appropriately:</p>

<p style="margin-top: 1em">#!/usr/local/bin/perl <br>
@e2a = ( # this must be filled in <br>
); <br>
$_ = &lt;&gt; until ($mode,$file) = /^begin(*)()/; <br>
open(OUT, &quot;&gt; $file&quot;) if $file ne &quot;&quot;;
<br>
while(&lt;&gt;) { <br>
last if /^end/; <br>
next if /[a-z]/; <br>
next unless int(((($e2a[ord()] - 32 ) &amp; 077) + 2) / 3)
== <br>
int(length() / 4); <br>
print OUT unpack(&quot;u&quot;, $_); <br>
} <br>
close(OUT); <br>
chmod oct($mode), $file;</p>

<p style="margin-top: 1em">Quoted-Printable encoding and
decoding <br>
On ASCII-encoded platforms it is possible to strip
characters outside of the printable set using:</p>

<p style="margin-top: 1em"># This QP encoder works on ASCII
only <br>
$qp_string =~
s/([=0-F0-])/sprintf(&quot;=%02X&quot;,ord($1))/ge;</p>

<p style="margin-top: 1em">Whereas a QP encoder that works
on both ASCII and EBCDIC platforms would look somewhat like
the following (where the EBCDIC branch @e2a array is omitted
for brevity):</p>

<p style="margin-top: 1em">if (ord(&rsquo;A&rsquo;) == 65)
{ # ASCII <br>
$delete = &quot;F&quot;; # ASCII <br>
@e2a = (0 .. 255) # ASCII to ASCII identity map <br>
} <br>
else { # EBCDIC <br>
$delete = &quot;7&quot;; # EBCDIC <br>
@e2a = # EBCDIC to ASCII map (as shown above) <br>
} <br>
$qp_string =~ <br>
s/([^ !&quot; <br>
(although in production code the substitutions might be done
in the EBCDIC branch with the @e2a array and separately in
the ASCII branch without the expense of the identity
map).</p>

<p style="margin-top: 1em">Such QP strings can be decoded
with:</p>

<p style="margin-top: 1em"># This QP decoder is limited to
ASCII only <br>
$string =~ s/=([0-9A-Fa-f][0-9A-Fa-f])/chr hex $1/ge; <br>
$string =~ s/=[0r]+$//;</p>

<p style="margin-top: 1em">Whereas a QP decoder that works
on both ASCII and EBCDIC platforms would look somewhat like
the following (where the @a2e array is omitted for
brevity):</p>

<p style="margin-top: 1em">$string =~
s/=([0-9A-Fa-f][0-9A-Fa-f])/chr $a2e[hex $1]/ge; <br>
$string =~ s/=[0r]+$//;</p>

<p style="margin-top: 1em">Caesarean ciphers <br>
The practice of shifting an alphabet one or more characters
for encipherment dates back thousands of years and was
explicitly detailed by Gaius Julius Caesar in his Gallic
Wars <br>
text. A single alphabet shift is sometimes referred to as a
rotation and the shift amount is given as a number $n after
the string &rsquo;rot&rsquo; or &quot;rot$n&quot;. Rot0 and
rot26 would <br>
designate identity maps on the 26-letter English version of
the Latin alphabet. Rot13 has the interesting property that
alternate subsequent invocations are identity maps (thus
<br>
rot13 is its own non-trivial inverse in the group of 26
alphabet rotations). Hence the following is a rot13 encoder
and decoder that will work on ASCII and EBCDIC
platforms:</p>

<p style="margin-top: 1em">#!/usr/local/bin/perl</p>

<p style="margin-top: 1em">while(&lt;&gt;){ <br>
tr/n-za-mN-ZA-M/a-zA-Z/; <br>
print; <br>
}</p>

<p style="margin-top: 1em">In one-liner form:</p>

<p style="margin-top: 1em">perl -ne
&rsquo;tr/n-za-mN-ZA-M/a-zA-Z/;print&rsquo;</p>

<p style="margin-top: 1em">Hashing order and checksums <br>
To the extent that it is possible to write code that depends
on hashing order there may be differences between hashes as
stored on an ASCII-based platform and hashes stored on an
<br>
EBCDIC-based platform. XXX</p>

<p style="margin-top: 1em">I18N AND L10N <br>
Internationalization (I18N) and localization (L10N) are
supported at least in principle even on EBCDIC platforms.
The details are system-dependent and discussed under the
&quot;OS <br>
ISSUES&quot; in perlebcdic section below.</p>

<p style="margin-top: 1em">MULTI-OCTET CHARACTER SETS <br>
Perl may work with an internal UTF-EBCDIC encoding form for
wide characters on EBCDIC platforms in a manner analogous to
the way that it works with the UTF-8 internal encoding <br>
form on ASCII based platforms.</p>

<p style="margin-top: 1em">Legacy multi byte EBCDIC code
pages XXX.</p>

<p style="margin-top: 1em">OS ISSUES <br>
There may be a few system-dependent issues of concern to
EBCDIC Perl programmers.</p>

<p style="margin-top: 1em">OS/400 <br>
PASE The PASE environment is a runtime environment for
OS/400 that can run executables built for PowerPC AIX in
OS/400; see perlos400. PASE is ASCII-based, not EBCDIC-based
<br>
as the ILE.</p>

<p style="margin-top: 1em">IFS access <br>
XXX.</p>

<p style="margin-top: 1em">OS/390, z/OS <br>
Perl runs under Unix Systems Services or USS.</p>

<p style="margin-top: 1em">chcp chcp is supported as a
shell utility for displaying and changing one&rsquo;s code
page. See also chcp(1).</p>

<p style="margin-top: 1em">dataset access <br>
For sequential data set access try:</p>

<p style="margin-top: 1em">my @ds_records = &lsquo;cat
//DSNAME&lsquo;;</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">my @ds_records = &lsquo;cat
//&rsquo;HLQ.DSNAME&rsquo;&lsquo;;</p>

<p style="margin-top: 1em">See also the OS390::Stdio module
on CPAN.</p>

<p style="margin-top: 1em">OS/390, z/OS iconv <br>
iconv is supported as both a shell utility and a C RTL
routine. See also the iconv(1) and iconv(3) manual
pages.</p>

<p style="margin-top: 1em">locales On OS/390 or z/OS see
locale for information on locales. The L10N files are in
/usr/nls/locale. $Config{d_setlocale} is
&rsquo;define&rsquo; on OS/390 or z/OS.</p>

<p style="margin-top: 1em">VM/ESA? <br>
XXX.</p>

<p style="margin-top: 1em">POSIX-BC? <br>
XXX.</p>

<p style="margin-top: 1em">BUGS <br>
This pod document contains literal Latin 1 characters and
may encounter translation difficulties. In particular one
popular nroff implementation was known to strip accented
<br>
characters to their unaccented counterparts while attempting
to view this document through the pod2man program (for
example, you may see a plain &quot;y&quot; rather than one
with a <br>
diaeresis as in ye). Another nroff truncated the resultant
manpage at the first occurrence of 8 bit characters.</p>

<p style="margin-top: 1em">Not all shells will allow
multiple &quot;-e&quot; string arguments to perl to be
concatenated together properly as recipes 0, 2, 4, 5, and 6
might seem to imply.</p>

<p style="margin-top: 1em">SEE ALSO <br>
perllocale, perlfunc, perlunicode, utf8.</p>

<p style="margin-top: 1em">REFERENCES <br>
&lt;http://anubis.dkuug.dk/i18n/charmaps&gt;</p>


<p style="margin-top: 1em">&lt;http://www.unicode.org/&gt;</p>


<p style="margin-top: 1em">&lt;http://www.unicode.org/unicode/reports/tr16/&gt;</p>


<p style="margin-top: 1em">&lt;http://www.wps.com/projects/codes/&gt;
ASCII: American Standard Code for Information Infiltration
Tom Jennings, September 1999.</p>

<p style="margin-top: 1em">The Unicode Standard, Version
3.0 The Unicode Consortium, Lisa Moore ed., ISBN
0-201-61633-5, Addison Wesley Developers Press, February
2000.</p>

<p style="margin-top: 1em">CDRA: IBM - Character Data
Representation Architecture - Reference and Registry, IBM
SC09-2190-00, December 1996.</p>

<p style="margin-top: 1em">&quot;Demystifying Character
Sets&quot;, Andrea Vine, Multilingual Computing &amp;
Technology, #26 Vol. 10 Issue 4, August/September 1999; ISSN
1523-0309; Multilingual Computing Inc. Sandpoint <br>
ID, USA.</p>

<p style="margin-top: 1em">Codes, Ciphers, and Other
Cryptic and Clandestine Communication Fred B. Wrixon, ISBN
1-57912-040-7, Black Dog &amp; Leventhal Publishers,
1998.</p>


<p style="margin-top: 1em">http://www.bobbemer.com/P-BIT.HTM
&lt;http://www.bobbemer.com/P-BIT.HTM&gt; IBM - EBCDIC and
the P-bit; The biggest Computer Goof Ever Robert Bemer.</p>

<p style="margin-top: 1em">HISTORY <br>
15 April 2001: added UTF-8 and UTF-EBCDIC to main table,
pvhp.</p>

<p style="margin-top: 1em">AUTHOR <br>
Peter Prymmer pvhp@best.com wrote this in 1999 and 2000 with
CCSID 0819 and 0037 help from Chris Leach and Andre Pirard
A.Pirard@ulg.ac.be as well as POSIX-BC help from Thomas <br>
Dorner Thomas.Dorner@start.de. Thanks also to Vickie Cooper,
Philip Newton, William Raffloer, and Joe Smith. Trademarks,
registered trademarks, service marks and registered <br>
service marks used in this document are the property of
their respective owners.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLEBCDIC(1)</p>
<hr>
</body>
</html>
