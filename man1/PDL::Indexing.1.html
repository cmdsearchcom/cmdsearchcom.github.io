<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:22 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>INDEXING(1) User Contributed Perl Documentation
INDEXING(1)</p>

<p style="margin-top: 1em">NAME <br>
PDL::Indexing - Introduction to indexing and slicing
piddles.</p>

<p style="margin-top: 1em">OVERVIEW <br>
This man page should serve as a first tutorial on the
indexing and threading features of PDL.</p>

<p style="margin-top: 1em">Like all vectorized languages,
PDL automates looping over multi-dimensional data structures
(&quot;piddles&quot;) using a variant of mathematical vector
notation. The automatic looping is <br>
called &quot;threading&quot;, in part because ultimately PDL
will implement parallel processing to speed up the
loops.</p>

<p style="margin-top: 1em">A lot of the flexibility and
power of PDL relies on the indexing and threading features
of the Perl extension. Indexing allows access to the data of
a piddle in a very flexible <br>
way. Threading provides efficient vectorization of simple
operations.</p>

<p style="margin-top: 1em">The values of a piddle are
stored compactly as typed values in a single block of
memory, not (as in a normal Perl list-of-lists) as
individual Perl scalars.</p>

<p style="margin-top: 1em">In the sections that follow many
&quot;methods&quot; are called out -- these are Perl
operators that apply to piddles. From the perldl (or pdl2)
shell, you can find out more about each <br>
method by typing &quot;?&quot; followed by the method
name.</p>

<p style="margin-top: 1em">Dimension lists <br>
A piddle (PDL variable), in general, is an N-dimensional
array where N can be 0 (for a scalar), 1 (e.g. for a sound
sample), or higher values for images and more complex <br>
structures. Each dimension of the piddle has a positive
integer size. The &quot;perl&quot; interpreter treats each
piddle as a special type of Perl scalar (a blessed Perl
object, <br>
actually -- but you don&rsquo;t have to know that to use
them) that can be used anywhere you can put a normal
scalar.</p>

<p style="margin-top: 1em">You can access the dimensions of
a piddle as a Perl list and otherwise determine the size of
a piddle with several methods. The important ones are:</p>

<p style="margin-top: 1em">nelem - the total number of
elements in a piddle <br>
ndims - returns the number of dimensions in a piddle <br>
dims - returns the dimension list of a piddle as a Perl list
<br>
dim - returns the size of a particular dimension of a
piddle</p>

<p style="margin-top: 1em">Indexing and Dataflow <br>
PDL maintains a notion of &quot;dataflow&quot; between a
piddle and indexed subfields of that piddle. When you
produce an indexed subfield or single element of a parent
piddle, the child <br>
and parent remain attached until you manually disconnect
them. This lets you represent the same data different ways
within your code -- for example, you can consider an RGB
<br>
image simultaneously as a collection of (R,G,B) values in a
3 x 1000 x 1000 image, and as three separate 1000 x 1000
color planes stored in different variables. Modifying any of
<br>
the variables changes the underlying memory, and the changes
are reflected in all representations of the data.</p>

<p style="margin-top: 1em">There are two important methods
that let you control dataflow connections between a child
and parent piddle:</p>

<p style="margin-top: 1em">copy - forces an explicit copy
of a piddle <br>
sever - breaks the dataflow connection between a piddle and
its parents (if any)</p>

<p style="margin-top: 1em">Threading and Dimension Order
<br>
Most PDL operations act on the first few dimensions of their
piddle arguments. For example, &quot;sumover&quot; sums all
elements along the first dimension in the list (dimension
0). If <br>
you feed in a three-dimensional piddle, then the first
dimension is considered the &quot;active&quot; dimension and
the later dimensions are &quot;thread&quot; dimensions
because they are simply <br>
looped over. There are several ways to transpose or re-order
the dimension list of a piddle. Those techniques are very
fast since they don&rsquo;t touch the underlying data, only
<br>
change the way that PDL accesses the data. The main
dimension ordering functions are:</p>

<p style="margin-top: 1em">mv - moves a particular
dimension somewhere else in the dimension list <br>
xchg - exchanges two dimensions in the dimension list,
leaving the rest alone <br>
reorder - allows wholesale mixing of the dimensions <br>
clump - clumps together two or more small dimensions into
one larger one <br>
squeeze - eliminates any dimensions of size 1</p>

<p style="margin-top: 1em">Physical and Dummy Dimensions
<br>
&Acirc;&middot; document Perl level threading</p>

<p style="margin-top: 1em">&Acirc;&middot; threadids</p>

<p style="margin-top: 1em">&Acirc;&middot; update and
correct description of slice</p>

<p style="margin-top: 1em">&Acirc;&middot; new functions in
slice.pd (affine, lag, splitdim)</p>

<p style="margin-top: 1em">&Acirc;&middot; reworking of
paragraph on explicit threading</p>

<p style="margin-top: 1em">Indexing and threading with PDL
<br>
A lot of the flexibility and power of PDL relies on the
indexing and looping features of the Perl extension.
Indexing allows access to the data of a piddle in a very
flexible <br>
way. Threading provides efficient implicit looping
functionality (since the loops are implemented as optimized
C code).</p>

<p style="margin-top: 1em">Piddles are Perl objects that
represent multidimensional arrays and operations on those.
In contrast to simple Perl @x style lists the array data is
compactly stored in a single <br>
block of memory thus taking up a lot less memory and
enabling use of fast C code to implement operations (e.g.
addition, etc) on piddles.</p>

<p style="margin-top: 1em">piddles can have children <br>
Central to many of the indexing capabilities of PDL are the
relation of &quot;parent&quot; and &quot;child&quot; between
piddles. Many of the indexing commands create a new piddle
from an existing <br>
piddle. The new piddle is the &quot;child&quot; and the old
one is the &quot;parent&quot;. The data of the new piddle is
defined by a transformation that specifies how to generate
(compute) its data <br>
from the parent&rsquo;s data. The relation between the child
piddle and its parent are often bidirectional, meaning that
changes in the child&rsquo;s data are propagated back to the
parent. <br>
(Note: You see, we are aiming in our terminology already
towards the new dataflow features. The kind of dataflow that
is used by the indexing commands (about which you will learn
<br>
in a minute) is always in operation, not only when you have
explicitly switched on dataflow in your piddle by saying
&quot;$a-&gt;doflow&quot;. For further information about
data flow check <br>
the dataflow man page.)</p>

<p style="margin-top: 1em">Another way to interpret the
piddles created by our indexing commands is to view them as
a kind of intelligent pointer that points back to some
portion or all of its parent&rsquo;s <br>
data. Therefore, it is not surprising that the
parent&rsquo;s data (or a portion of it) changes when
manipulated through this &quot;pointer&quot;. After these
introductory remarks that hopefully <br>
prepared you for what is coming (rather than confuse you too
much) we are going to dive right in and start with a
description of the indexing commands and some typical
examples <br>
how they might be used in PDL programs. We will further
illustrate the pointer/dataflow analogies in the context of
some of the examples later on.</p>

<p style="margin-top: 1em">There are two different
implementations of this &lsquo;&lsquo;smart
pointer&rsquo;&rsquo; relationship: the first one, which is
a little slower but works for any transformation is simply
to do the <br>
transformation forwards and backwards as necessary. The
other is to consider the child piddle a
&lsquo;&lsquo;virtual&rsquo;&rsquo; piddle, which only
stores a pointer to the parent and access <br>
information so that routines which use the child piddle
actually directly access the data in the parent. If the
virtual piddle is given to a routine which cannot use it,
PDL <br>
transparently physicalizes the virtual piddle before letting
the routine use it.</p>

<p style="margin-top: 1em">Currently (1.94_01) all
transformations which are
&lsquo;&lsquo;affine&rsquo;&rsquo;, i.e. the indices of the
data item in the parent piddle are determined by a linear
transformation (+ constant) from <br>
the indices of the child piddle result in virtual piddles.
All other indexing routines (e.g.
&quot;-&gt;index(...)&quot;) result in physical piddles. All
routines compiled by PP can accept <br>
affine piddles (except those routines that pass pointers to
external library functions).</p>

<p style="margin-top: 1em">Note that whether something is
affine or not does not affect the semantics of what you do
in any way: both</p>

<p style="margin-top: 1em">$a-&gt;index(...) .= 5; <br>
$a-&gt;slice(...) .= 5;</p>

<p style="margin-top: 1em">change the data in $a. The
affinity does, however, have a significant impact on memory
usage and performance.</p>

<p style="margin-top: 1em">Slicing piddles <br>
Probably the most important application of the concept of
parent/child piddles is the representation of rectangular
slices of a physical piddle by a virtual piddle. Having
talked <br>
long enough about concepts let&rsquo;s get more specific.
Suppose we are working with a 2D piddle representing a 5x5
image (its unusually small so that we can print it without
filling <br>
several screens full of digits ;).</p>

<p style="margin-top: 1em">pdl&gt; $im = sequence(5,5) <br>
pdl&gt; p $im</p>

<p style="margin-top: 1em">[ <br>
[ 0 1 2 3 4] <br>
[ 5 6 7 8 9] <br>
[10 11 12 13 14] <br>
[15 16 17 18 19] <br>
[20 21 22 23 24] <br>
]</p>

<p style="margin-top: 1em">pdl&gt; help vars <br>
PDL variables in package main::</p>

<p style="margin-top: 1em">Name Type Dimension Flow State
Mem <br>

----------------------------------------------------------------
<br>
$im Double D [5,5] P 0.20Kb</p>

<p style="margin-top: 1em">[ here it might be appropriate
to quickly talk about the &quot;help vars&quot; command that
provides information about piddles in the interactive
&quot;perldl&quot; or &quot;pdl2&quot; shell that comes with
<br>
PDL. ]</p>

<p style="margin-top: 1em">Now suppose we want to create a
1-D piddle that just references one line of the image, say
line 2; or a piddle that represents all even lines of the
image (imagine we have to <br>
deal with even and odd frames of an interlaced image due to
some peculiar behaviour of our frame grabber). As another
frequent application of slices we might want to create a
<br>
piddle that represents a rectangular region of the image
with top and bottom reversed. All these effects (and many
more) can be easily achieved with the powerful slice
function:</p>

<p style="margin-top: 1em">pdl&gt; $line =
$im-&gt;slice(&rsquo;:,(2)&rsquo;) <br>
pdl&gt; $even = $im-&gt;slice(&rsquo;:,1:-1:2&rsquo;) <br>
pdl&gt; $area = $im-&gt;slice(&rsquo;3:4,3:1&rsquo;) <br>
pdl&gt; help vars # or just PDL-&gt;vars <br>
PDL variables in package main::</p>

<p style="margin-top: 1em">Name Type Dimension Flow State
Mem <br>

----------------------------------------------------------------
<br>
$even Double D [5,2] -C 0.00Kb <br>
$im Double D [5,5] P 0.20Kb <br>
$line Double D [5] -C 0.00Kb <br>
$area Double D [2,3] -C 0.00Kb</p>

<p style="margin-top: 1em">All three &quot;child&quot;
piddles are children of $im or in the other (largely
equivalent) interpretation pointers to data of $im.
Operations on those virtual piddles access only those <br>
portions of the data as specified by the argument to slice.
So we can just print line 2:</p>

<p style="margin-top: 1em">pdl&gt; p $line <br>
[10 11 12 13 14]</p>

<p style="margin-top: 1em">Also note the difference in the
&quot;Flow State&quot; of $area above and below:</p>

<p style="margin-top: 1em">pdl&gt; p $area <br>
pdl&gt; help $area <br>
This variable is Double D [2,3] VC 0.00Kb</p>

<p style="margin-top: 1em">The following demonstrates that
$im and $line really behave as you would expect from a
pointer-like object (or in the dataflow picture: the changes
in $line&rsquo;s data are propagated <br>
back to $im):</p>

<p style="margin-top: 1em">pdl&gt; $im++ <br>
pdl&gt; p $line <br>
[11 12 13 14 15] <br>
pdl&gt; $line += 2 <br>
pdl&gt; p $im</p>

<p style="margin-top: 1em">[ <br>
[ 1 2 3 4 5] <br>
[ 6 7 8 9 10] <br>
[13 14 15 16 17] <br>
[16 17 18 19 20] <br>
[21 22 23 24 25] <br>
]</p>

<p style="margin-top: 1em">Note how assignment operations
on the child virtual piddles change the parent physical
piddle and vice versa (however, the basic &quot;=&quot;
assignment doesn&rsquo;t, use &quot;.=&quot; to obtain that
<br>
effect. See below for the reasons). The virtual child
piddles are something like &quot;live links&quot; to the
&quot;original&quot; parent piddle. As previously said, they
can be thought of to work <br>
similar to a C-pointer. But in contrast to a C-pointer they
carry a lot more information. Firstly, they specify the
structure of the data they represent (the dimensionality of
<br>
the new piddle) and secondly, specify how to create this
structure from its parents data (the way this works is
buried in the internals of PDL and not important for you to
know <br>
anyway (unless you want to hack the core in the future or
would like to become a PDL guru in general (for a definition
of this strange creature see PDL::Internals)).</p>

<p style="margin-top: 1em">The previous examples have
demonstrated typical usage of the slice function. Since the
slicing functionality is so important here is an explanation
of the syntax for the string <br>
argument to slice:</p>

<p style="margin-top: 1em">$vpdl =
$a-&gt;slice(&rsquo;ind0,ind1...&rsquo;)</p>

<p style="margin-top: 1em">where &quot;ind0&quot; specifies
what to do with index No 0 of the piddle $a, etc. Each
element of the comma separated list can have one of the
following forms:</p>

<p style="margin-top: 1em">&rsquo;:&rsquo; Use the whole
dimension</p>

<p style="margin-top: 1em">&rsquo;n&rsquo; Use only index
&quot;n&quot;. The dimension of this index in the resulting
virtual piddle is 1. An example involving those first two
index formats:</p>

<p style="margin-top: 1em">pdl&gt; $column =
$im-&gt;slice(&rsquo;2,:&rsquo;) <br>
pdl&gt; $row = $im-&gt;slice(&rsquo;:,0&rsquo;) <br>
pdl&gt; p $column</p>

<p style="margin-top: 1em">[ <br>
[ 3] <br>
[ 8] <br>
[15] <br>
[18] <br>
[23] <br>
]</p>

<p style="margin-top: 1em">pdl&gt; p $row</p>

<p style="margin-top: 1em">[ <br>
[1 2 3 4 5] <br>
]</p>

<p style="margin-top: 1em">pdl&gt; help $column <br>
This variable is Double D [1,5] VC 0.00Kb</p>

<p style="margin-top: 1em">pdl&gt; help $row <br>
This variable is Double D [5,1] VC 0.00Kb</p>

<p style="margin-top: 1em">&rsquo;(n)&rsquo; Use only index
&quot;n&quot;. This dimension is removed from the resulting
piddle (relying on the fact that a dimension of size 1 can
always be removed). The distinction between this <br>
case and the previous one becomes important in assignments
where left and right hand side have to have appropriate
dimensions.</p>

<p style="margin-top: 1em">pdl&gt; $line =
$im-&gt;slice(&rsquo;:,(0)&rsquo;) <br>
pdl&gt; help $line <br>
This variable is Double D [5] -C 0.00Kb</p>

<p style="margin-top: 1em">pdl&gt; p $line <br>
[1 2 3 4 5]</p>

<p style="margin-top: 1em">Spot the difference to the
previous example?</p>

<p style="margin-top: 1em">&rsquo;n1:n2&rsquo; or
&rsquo;n1:n2:n3&rsquo; <br>
Take the range of indices from &quot;n1&quot; to
&quot;n2&quot; or (second form) take the range of indices
from &quot;n1&quot; to &quot;n2&quot; with step
&quot;n3&quot;. An example for the use of this format is the
<br>
previous definition of the sub-image composed of even
lines.</p>

<p style="margin-top: 1em">pdl&gt; $even =
$im-&gt;slice(&rsquo;:,1:-1:2&rsquo;)</p>

<p style="margin-top: 1em">This example also demonstrates
that negative indices work like they do for normal Perl
style arrays by counting backwards from the end of the
dimension. If &quot;n2&quot; is smaller <br>
than &quot;n1&quot; (in the example -1 is equivalent to
index 4) the elements in the virtual piddle are effectively
reverted with respect to its parent.</p>

<p style="margin-top: 1em">&rsquo;*[n]&rsquo; <br>
Add a dummy dimension. The size of this dimension will be 1
by default or equal to &quot;n&quot; if the optional
numerical argument is given.</p>

<p style="margin-top: 1em">Now, this is really something a
bit strange on first sight. What is a dummy dimension? A
dummy dimension inserts a dimension where there wasn&rsquo;t
one before. How is that done <br>
? Well, in the case of the new dimension having size 1 it
can be easily explained by the way in which you can identify
a vector (with &quot;m&quot; elements) with an
&quot;(1,m)&quot; or <br>
&quot;(m,1)&quot; matrix. The same holds obviously for
higher dimensional objects. More interesting is the case of
a dummy dimensions of size greater than one (e.g.
&quot;slice(&rsquo;*5,:&rsquo;)&quot;). <br>
This works in the same way as a call to the dummy function
creates a new dummy dimension. So read on and check its
explanation below.</p>

<p style="margin-top: 1em">&rsquo;([n1:n2[:n3]]=i)&rsquo;
<br>
[Not yet implemented ??????] With an argument like this you
make generalised diagonals. The diagonal will be dimension
no. &quot;i&quot; of the new output piddle and (if optional
<br>
part in brackets specified) will extend along the range of
indices specified of the respective parent piddle&rsquo;s
dimension. In general an argument like this only makes sense
<br>
if there are other arguments like this in the same call to
slice. The part in brackets is optional for this type of
argument. All arguments of this type that specify the <br>
same target dimension &quot;i&quot; have to relate to the
same number of indices in their parent dimension. The best
way to explain it is probably to give an example, here we
make a <br>
piddle that refers to the elements along the space diagonal
of its parent piddle (a cube):</p>

<p style="margin-top: 1em">$cube = zeroes(5,5,5); <br>
$sdiag = $cube-&gt;slice(&rsquo;(=0),(=0),(=0)&rsquo;);</p>

<p style="margin-top: 1em">The above command creates a
virtual piddle that represents the diagonal along the
parents&rsquo; dimension no. 0, 1 and 2 and makes its
dimension 0 (the only dimension) of it. <br>
You use the extended syntax if the dimension sizes of the
parent dimensions you want to build the diagonal from have
different sizes or you want to reverse the sequence of <br>
elements in the diagonal, e.g.</p>

<p style="margin-top: 1em">$rect = zeroes(12,3,5,6,2); <br>
$vpdl =
$rect-&gt;slice(&rsquo;2:7,(0:1=1),(4),(5:4=1),(=1)&rsquo;);</p>

<p style="margin-top: 1em">So the elements of $vpdl will
then be related to those of its parent in way we can express
as:</p>

<p style="margin-top: 1em">vpdl(i,j) = rect(i+2,j,4,5-j,j)
0&lt;=i&lt;5, 0&lt;=j&lt;2</p>

<p style="margin-top: 1em">[ work in the new index
function: &quot;$b = $a-&gt;index($c);&quot; ???? ]</p>

<p style="margin-top: 1em">There are different kinds of
assignments in PDL <br>
The previous examples have already shown that virtual
piddles can be used to operate on or access portions of data
of a parent piddle. They can also be used as lvalues in <br>
assignments (as the use of &quot;++&quot; in some of the
examples above has already demonstrated). For explicit
assignments to the data represented by a virtual piddle you
have to use the <br>
overloaded &quot;.=&quot; operator (which in this context we
call propagated assignment). Why can&rsquo;t you use the
normal assignment operator &quot;=&quot;?</p>

<p style="margin-top: 1em">Well, you definitely still can
use the &rsquo;=&rsquo; operator but it wouldn&rsquo;t do
what you want. This is due to the fact that the
&rsquo;=&rsquo; operator cannot be overloaded in the same
way as other <br>
assignment operators. If we tried to use &rsquo;=&rsquo; to
try to assign data to a portion of a physical piddle through
a virtual piddle we wouldn&rsquo;t achieve the desired
effect (instead the <br>
variable representing the virtual piddle (a reference to a
blessed thingy) would after the assignment just contain the
reference to another blessed thingy which would behave to
<br>
future assignments as a &quot;physical&quot; copy of the
original rvalue [this is actually not yet clear and subject
of discussions in the PDL developers mailing list]. In that
sense it <br>
would break the connection of the piddle to the parent [
isn&rsquo;t this behaviour in a sense the opposite of what
happens in dataflow, where &quot;.=&quot; breaks the
connection to the parent? <br>
].</p>

<p style="margin-top: 1em">E.g.</p>

<p style="margin-top: 1em">pdl&gt; $line =
$im-&gt;slice(&rsquo;:,(2)&rsquo;) <br>
pdl&gt; $line = zeroes(5); <br>
pdl&gt; $line++; <br>
pdl&gt; p $im</p>

<p style="margin-top: 1em">[ <br>
[ 1 2 3 4 5] <br>
[ 6 7 8 9 10] <br>
[13 14 15 16 17] <br>
[16 17 18 19 20] <br>
[21 22 23 24 25] <br>
]</p>

<p style="margin-top: 1em">pdl&gt; p $line <br>
[1 1 1 1 1]</p>

<p style="margin-top: 1em">But using &quot;.=&quot;</p>

<p style="margin-top: 1em">pdl&gt; $line =
$im-&gt;slice(&rsquo;:,(2)&rsquo;) <br>
pdl&gt; $line .= zeroes(5) <br>
pdl&gt; $line++ <br>
pdl&gt; p $im</p>

<p style="margin-top: 1em">[ <br>
[ 1 2 3 4 5] <br>
[ 6 7 8 9 10] <br>
[ 1 1 1 1 1] <br>
[16 17 18 19 20] <br>
[21 22 23 24 25] <br>
]</p>

<p style="margin-top: 1em">pdl&gt; print $line <br>
[1 1 1 1 1]</p>

<p style="margin-top: 1em">Also, you can substitute</p>

<p style="margin-top: 1em">pdl&gt; $line .= 0;</p>

<p style="margin-top: 1em">for the assignment above (the
zero is converted to a scalar piddle, with no dimensions so
it can be assigned to any piddle).</p>

<p style="margin-top: 1em">A nice feature in recent perl
versions is lvalue subroutines (i.e., versions 5.6.x and
higher including all perls currently supported by PDL). That
allows one to use the slicing <br>
syntax on both sides of the assignment:</p>

<p style="margin-top: 1em">pdl&gt;
$im-&gt;slice(&rsquo;:,(2)&rsquo;) .=
zeroes(5)-&gt;xvals-&gt;float</p>

<p style="margin-top: 1em">Related to the lvalue sub
assignment feature is a little trap for the unwary: recent
perls introduced a &quot;feature&quot; which breaks
PDL&rsquo;s use of lvalue subs for slice assignments when
<br>
running under the perl debugger, &quot;perl -d&quot;. Under
the debugger, the above usage gives an error like: &quot;
Can&rsquo;t return a temporary from lvalue subroutine...
&quot; So you must use <br>
syntax like this:</p>

<p style="margin-top: 1em">pdl&gt; ($pdl =
$im-&gt;slice(&rsquo;:,(2)&rsquo;)) .=
zeroes(5)-&gt;xvals-&gt;float</p>

<p style="margin-top: 1em">which works both with and
without the debugger but is arguably clumsy and awkward to
read.</p>

<p style="margin-top: 1em">Note that there can be a problem
with assignments like this when lvalue and rvalue piddles
refer to overlapping portions of data in the parent
piddle:</p>

<p style="margin-top: 1em"># revert the elements of the
first line of $a <br>
($tmp = $a-&gt;slice(&rsquo;:,(1)&rsquo;)) .=
$a-&gt;slice(&rsquo;-1:0,(1)&rsquo;);</p>

<p style="margin-top: 1em">Currently, the parent data on
the right side of the assignments is not copied before the
(internal) assignment loop proceeds. Therefore, the outcome
of this assignment will <br>
depend on the sequence in which elements are assigned and
almost certainly not do what you wanted. So the semantics
are currently undefined for now and liable to change
anytime. <br>
To obtain the desired behaviour, use</p>

<p style="margin-top: 1em">($tmp =
$a-&gt;slice(&rsquo;:,(1)&rsquo;)) .=
$a-&gt;slice(&rsquo;-1:0,(1)&rsquo;)-&gt;copy;</p>

<p style="margin-top: 1em">which makes a physical copy of
the slice or</p>

<p style="margin-top: 1em">($tmp =
$a-&gt;slice(&rsquo;:,(1)&rsquo;)) .=
$a-&gt;slice(&rsquo;-1:0,(1)&rsquo;)-&gt;sever;</p>

<p style="margin-top: 1em">which returns the same slice but
severs the connection of the slice to its parent.</p>

<p style="margin-top: 1em">Other functions that manipulate
dimensions <br>
Having talked extensively about the slice function it should
be noted that this is not the only PDL indexing function.
There are additional indexing functions which are also <br>
useful (especially in the context of threading which we will
talk about later). Here are a list and some examples how to
use them.</p>

<p style="margin-top: 1em">&quot;dummy&quot; <br>
inserts a dummy dimension of the size you specify (default
1) at the chosen location. You can&rsquo;t wait to hear how
that is achieved? Well, all elements with index
&quot;(X,x,Y)&quot; <br>
(&quot;0&lt;=x&lt;size_of_dummy_dim&quot;) just map to the
element with index &quot;(X,Y)&quot; of the parent piddle
(where &quot;X&quot; and &quot;Y&quot; refer to the group of
indices before and after the location <br>
where the dummy dimension was inserted.)</p>

<p style="margin-top: 1em">This example calculates the x
coordinate of the centroid of an image (later we will learn
that we didn&rsquo;t actually need the dummy dimension
thanks to the magic of implicit <br>
threading; but using dummy dimensions the code would also
work in a thread-less world; though once you have worked
with PDL threads you wouldn&rsquo;t want to live without
them <br>
again).</p>

<p style="margin-top: 1em"># centroid <br>
($xd,$yd) = $im-&gt;dims; <br>
$xc =
sum($im*xvals(zeroes($xd))-&gt;dummy(1,$yd))/sum($im);</p>

<p style="margin-top: 1em">Let&rsquo;s explain how that
works in a little more detail. First, the product:</p>

<p style="margin-top: 1em">$xvs = xvals(zeroes($xd)); <br>
print $xvs-&gt;dummy(1,$yd); # repeat the line $yd times
<br>
$prod = $im*xvs-&gt;dummy(1,$yd); # form the pixel-wise
product with <br>
# the repeated line of x-values</p>

<p style="margin-top: 1em">The rest is then summing the
results of the pixel-wise product together and normalizing
with the sum of all pixel values in the original image
thereby calculating the <br>
x-coordinate of the &quot;center of mass&quot; of the image
(interpreting pixel values as local mass) which is known as
the centroid of an image.</p>

<p style="margin-top: 1em">Next is a (from the point of
view of memory consumption) very cheap conversion from
grey-scale to RGB, i.e. every pixel holds now a triple of
values instead of a scalar. The <br>
three values in the triple are, fortunately, all the same
for a grey image, so that our trick works well in that it
maps all the three members of the triple to the same <br>
source element:</p>

<p style="margin-top: 1em"># a cheap grey-scale to RGB
conversion <br>
$rgb = $grey-&gt;dummy(0,3)</p>

<p style="margin-top: 1em">Unfortunately this trick cannot
be used to convert your old B/W photos to color ones in the
way you&rsquo;d like. :(</p>

<p style="margin-top: 1em">Note that the memory usage of
piddles with dummy dimensions is especially sensitive to the
internal representation. If the piddle can be represented as
a virtual affine <br>
(&lsquo;&lsquo;vaffine&rsquo;&rsquo;) piddle, only the
control structures are stored. But if $b in</p>

<p style="margin-top: 1em">$a = zeroes(10000); <br>
$b = $a-&gt;dummy(1,10000);</p>

<p style="margin-top: 1em">is made physical by some
routine, you will find that the memory usage of your program
has suddenly grown by 100Mb.</p>

<p style="margin-top: 1em">&quot;diagonal&quot; <br>
replaces two dimensions (which have to be of equal size) by
one dimension that references all the elements along the
&quot;diagonal&quot; along those two dimensions. Here, we
have two <br>
examples which should appear familiar to anyone who has ever
done some linear algebra. Firstly, make a unity matrix:</p>

<p style="margin-top: 1em"># unity matrix <br>
$e = zeroes(float, 3, 3); # make everything zero <br>
($tmp = $e-&gt;diagonal(0,1)) .= 1; # set the elements along
the diagonal to 1 <br>
print $e;</p>

<p style="margin-top: 1em">Or the other diagonal:</p>

<p style="margin-top: 1em">($tmp =
$e-&gt;slice(&rsquo;:-1:0&rsquo;)-&gt;diagonal(0,1)) .= 2;
<br>
print $e;</p>

<p style="margin-top: 1em">(Did you notice how we used the
slice function to revert the sequence of lines before
setting the diagonal of the new child, thereby setting the
cross diagonal of the parent <br>
?) Or a mapping from the space of diagonal matrices to the
field over which the matrices are defined, the trace of a
matrix:</p>

<p style="margin-top: 1em"># trace of a matrix <br>
$trace = sum($mat-&gt;diagonal(0,1)); # sum all the diagonal
elements</p>

<p style="margin-top: 1em">&quot;xchg&quot; and
&quot;mv&quot; <br>
xchg exchanges or &quot;transposes&quot; the two specified
dimensions. A straightforward example:</p>

<p style="margin-top: 1em"># transpose a matrix (without
explicitly reshuffling data and <br>
# making a copy) <br>
$prod = $a x $a-&gt;xchg(0,1);</p>

<p style="margin-top: 1em">$prod should now be pretty close
to the unity matrix if $a is an orthogonal matrix. Often
&quot;xchg&quot; will be used in the context of threading
but more about that later.</p>

<p style="margin-top: 1em">mv works in a similar fashion.
It moves a dimension (specified by its number in the parent)
to a new position in the new child piddle:</p>

<p style="margin-top: 1em">$b = $a-&gt;mv(4,0); # make the
5th dimension of $a the first in the <br>
# new child $b</p>

<p style="margin-top: 1em">The difference between
&quot;xchg&quot; and &quot;mv&quot; is that &quot;xchg&quot;
only changes the position of two dimensions with each other,
whereas &quot;mv&quot; inserts the first dimension to the
place of <br>
second, moving the other dimensions around accordingly.</p>

<p style="margin-top: 1em">&quot;clump&quot; <br>
collapses several dimensions into one. Its only argument
specifies how many dimensions of the source piddle should be
collapsed (starting from the first). An (admittedly <br>
unrealistic) example is a 3D piddle which holds data from a
stack of image files that you have just read in. However,
the data from each image really represents a 1D time <br>
series and has only been arranged that way because it was
digitized with a frame grabber. So to have it again as an
array of time sequences you say</p>

<p style="margin-top: 1em">pdl&gt; $seqs =
$stack-&gt;clump(2) <br>
pdl&gt; help vars <br>
PDL variables in package main::</p>

<p style="margin-top: 1em">Name Type Dimension Flow State
Mem <br>

----------------------------------------------------------------
<br>
$seqs Double D [8000,50] -C 0.00Kb <br>
$stack Double D [100,80,50] P 3.05Mb</p>

<p style="margin-top: 1em">Unrealistic as it may seem, our
confocal microscope software writes data (sometimes) this
way. But more often you use clump to achieve a certain
effect when using implicit or <br>
explicit threading.</p>

<p style="margin-top: 1em">Calls to indexing functions can
be chained <br>
As you might have noticed in some of the examples above
calls to the indexing functions can be nicely chained since
all of these functions return a newly created child object.
<br>
However, when doing extensive index manipulations in a chain
be sure to keep track of what you are doing, e.g.</p>


<p style="margin-top: 1em">$a-&gt;xchg(0,1)-&gt;mv(0,4)</p>

<p style="margin-top: 1em">moves the dimension 1 of $a to
position 4 since when the second command is executed the
original dimension 1 has been moved to position 0 of the new
child that calls the &quot;mv&quot; <br>
function. I think you get the idea (in spite of my
convoluted explanations).</p>

<p style="margin-top: 1em">Propagated assignments
(&rsquo;.=&rsquo;) and dummy dimensions <br>
A subtlety related to indexing is the assignment to piddles
containing dummy dimensions of size greater than 1. These
assignments (using &quot;.=&quot;) are forbidden since
several <br>
elements of the lvalue piddle point to the same element of
the parent. As a consequence the value of those parent
elements are potentially ambiguous and would depend on the
<br>
sequence in which the implementation makes the assignments
to elements. Therefore, an assignment like this:</p>

<p style="margin-top: 1em">$a = pdl [1,2,3]; <br>
$b = $a-&gt;dummy(1,4); <br>
$b .= yvals(zeroes(3,4));</p>

<p style="margin-top: 1em">can produce unexpected results
and the results are explicitly undefined by PDL because when
PDL gets parallel computing features, the current result may
well change.</p>

<p style="margin-top: 1em">From the point of view of
dataflow the introduction of greater-size-than-one dummy
dimensions is regarded as an irreversible transformation
(similar to the terminology in <br>
thermodynamics) which precludes backward propagation of
assignment to a parent (which you had explicitly requested
using the &quot;.=&quot; assignment). A similar problem to
watch out for <br>
occurs in the context of threading where sometimes dummy
dimensions are created implicitly during the thread loop
(see below).</p>

<p style="margin-top: 1em">Reasons for the parent/child (or
&quot;pointer&quot;) concept <br>
[ this will have to wait a bit ]</p>

<p style="margin-top: 1em">XXXXX being memory efficient
<br>
XXXXX in the context of threading <br>
XXXXX very flexible and powerful way of accessing portions
of piddle data <br>
(in much more general way than sec, etc allow) <br>
XXXXX efficient implementation <br>
XXXXX difference to section/at, etc.</p>

<p style="margin-top: 1em">How to make things physical
again <br>
[ XXXXX fill in later when everything has settled a bit more
]</p>

<p style="margin-top: 1em">** When needed (xsub routine
interfacing C lib function) <br>
** How achieved (-&gt;physical) <br>
** How to test (isphysical (explain how it works currently))
<br>
** -&gt;copy and -&gt;sever</p>

<p style="margin-top: 1em">Threading <br>
In the previous paragraph on indexing we have already
mentioned the term occasionally but now its really time to
talk explicitly about &quot;threading&quot; with piddles.
The term <br>
threading has many different meanings in different fields of
computing. Within the framework of PDL it could probably be
loosely defined as an implicit looping facility. It is <br>
implicit because you don&rsquo;t specify anything like
enclosing for-loops but rather the loops are automatically
(or &rsquo;magically&rsquo;) generated by PDL based on the
dimensions of the <br>
piddles involved. This should give you a first idea why the
index/dimension manipulating functions you have met in the
previous paragraphs are especially important and useful in
<br>
the context of threading. The other ingredient for threading
(apart from the piddles involved) is a function that is
threading aware (generally, these are PDL::PP compiled <br>
functions) and that the piddles are &quot;threaded&quot;
over. So much about the terminology and now let&rsquo;s try
to shed some light on what it all means.</p>

<p style="margin-top: 1em">Implicit threading - a first
example <br>
There are two slightly different variants of threading. We
start with what we call &quot;implicit threading&quot;.
Let&rsquo;s pick a practical example that involves looping
of a function over <br>
many elements of a piddle. Suppose we have an RGB image that
we want to convert to grey-scale. The RGB image is
represented by a 3-dim piddle &quot;im(3,x,y)&quot; where
the first <br>
dimension contains the three color components of each pixel
and &quot;x&quot; and &quot;y&quot; are width and height of
the image, respectively. Next we need to specify how to
convert a color-triple <br>
at a given pixel into a grey-value (to be a realistic
example it should represent the relative intensity with
which our color insensitive eye cells would detect that
color to <br>
achieve what we would call a natural conversion from color
to grey-scale). An approximation that works quite well is to
compute the grey intensity from each RGB triplet (r,g,b)
<br>
as a weighted sum</p>

<p style="margin-top: 1em">grey-value = 77/256*r +
150/256*g + 29/256*b = <br>
inner([77,150,29]/256, [r,g,b])</p>

<p style="margin-top: 1em">where the last form indicates
that we can write this as an inner product of the 3-vector
comprising the weights for red, green and blue components
with the 3-vector containing <br>
the color components. Traditionally, we might have written a
function like the following to process the whole image:</p>

<p style="margin-top: 1em">my @dims=$im-&gt;dims; <br>
# here normally check that first dim has correct size (3),
etc <br>
$grey=zeroes(@dims[1,2]); # make the piddle for the
resulting grey image <br>
$w = pdl [77,150,29] / 256; # the vector of weights <br>
for ($j=0;$j&lt;dims[2];$j++) { <br>
for ($i=0;$i&lt;dims[1];$i++) { <br>
# compute the pixel value <br>
$tmp = inner($w,$im-&gt;slice(&rsquo;:,(i),(j)&rsquo;));
<br>
set($grey,$i,$j,$tmp); # and set it in the grey-scale image
<br>
} <br>
}</p>

<p style="margin-top: 1em">Now we write the same using
threading (noting that &quot;inner&quot; is a threading
aware function defined in the PDL::Primitive package)</p>

<p style="margin-top: 1em">$grey =
inner($im,pdl([77,150,29]/256));</p>

<p style="margin-top: 1em">We have ended up with a
one-liner that automatically creates the piddle $grey with
the right number and size of dimensions and performs the
loops automatically (these loops are <br>
implemented as fast C code in the internals of PDL). Well,
we still owe you an explanation how this &rsquo;magic&rsquo;
is achieved.</p>

<p style="margin-top: 1em">How does the example work ? <br>
The first thing to note is that every function that is
threading aware (these are without exception functions
compiled from concise descriptions by PDL::PP, later just
called PP- <br>
functions) expects a defined (minimum) number of dimensions
(we call them core dimensions) from each of its piddle
arguments. The inner function expects two one-dimensional
<br>
(input) parameters from which it calculates a
zero-dimensional (output) parameter. We write that
symbolically as &quot;inner((n),(n),[o]())&quot; and call it
&quot;inner&quot;&rsquo;s signature, where n <br>
represents the size of that dimension. n being equal in the
first and second parameter means that those dimensions have
to be of equal size in any call. As a different example <br>
take the outer product which takes two 1D vectors to
generate a 2D matrix, symbolically written as
&quot;outer((n),(m),[o](n,m))&quot;. The &quot;[o]&quot; in
both examples indicates that this (here <br>
third) argument is an output argument. In the latter example
the dimensions of first and second argument don&rsquo;t have
to agree but you see how they determine the size of the two
<br>
dimensions of the output piddle.</p>

<p style="margin-top: 1em">Here is the point when threading
finally enters the game. If you call PP-functions with
piddles that have more than the required core dimensions the
first dimensions of the <br>
piddle arguments are used as the core dimensions and the
additional extra dimensions are threaded over. Let us
demonstrate this first with our example above</p>

<p style="margin-top: 1em">$grey = inner($im,$w); # w is
the weight vector from above</p>

<p style="margin-top: 1em">In this case $w is 1D and so
supplied just the core dimension, $im is 3D, more
specifically &quot;(3,x,y)&quot;. The first dimension (of
size 3) is the required core dimension that matches <br>
(as required by inner) the first (and only) dimension of $w.
The second dimension is the first thread dimension (of size
&quot;x&quot;) and the third is here the second thread
dimension <br>
(of size &quot;y&quot;). The output piddle is automatically
created (as requested by setting $grey to &quot;null&quot;
prior to invocation). The output dimensions are obtained by
appending the loop <br>
dimensions (here &quot;(x,y)&quot;) to the core output
dimensions (here 0D) to yield the final dimensions of the
auto-created piddle (here &quot;0D+2D=2D&quot; to yield a 2D
output of size &quot;(x,y)&quot;).</p>

<p style="margin-top: 1em">So the above command calls the
core functionality that computes the inner product of two 1D
vectors &quot;x*y&quot; times with $w and all 1D slices of
the form &quot;(&rsquo;:,(i),(j)&rsquo;)&quot; of $im and
<br>
sets the respective elements of the output piddle
&quot;$grey(i,j)&quot; to the result of each computation. We
could write that symbolically as</p>

<p style="margin-top: 1em">$grey(0,0) =
f($w,$im(:,(0),(0))) <br>
$grey(1,0) = f($w,$im(:,(1),(0))) <br>
. <br>
. <br>
. <br>
$grey(x-2,y-1) = f($w,$im(:,(x-2),(y-1))) <br>
$grey(x-1,y-1) = f($w,$im(:,(x-1),(y-1)))</p>

<p style="margin-top: 1em">But this is done automatically
by PDL without writing any explicit Perl loops. We see that
the command really creates an output piddle with the right
dimensions and sets the <br>
elements indeed to the result of the computation for each
pixel of the input image.</p>

<p style="margin-top: 1em">When even more piddles and extra
dimensions are involved things get a bit more complicated.
We will first give the general rules how the thread
dimensions depend on the <br>
dimensions of input piddles enabling you to figure out the
dimensionality of an auto-created output piddle (for any
given set of input piddles and core dimensions of the PP-
<br>
function in question). The general rules will most likely
appear a bit confusing on first sight so that we&rsquo;ll
set out to illustrate the usage with a set of further
examples <br>
(which will hopefully also demonstrate that there are indeed
many practical situations where threading comes in extremely
handy).</p>

<p style="margin-top: 1em">A call for coding discipline
<br>
Before we point out the other technical details of
threading, please note this call for programming discipline
when using threading:</p>

<p style="margin-top: 1em">In order to preserve human
readability, PLEASE comment any nontrivial expression in
your code involving threading. Most importantly, for any
subroutine, include information at <br>
the beginning about what you expect the dimensions to
represent (or ranges of dimensions).</p>

<p style="margin-top: 1em">As a warning, look at this
undocumented function and try to guess what might be going
on:</p>

<p style="margin-top: 1em">sub lookup { <br>
my ($im,$palette) = @_; <br>
my $res; <br>
index($palette-&gt;xchg(0,1), <br>
$im-&gt;long-&gt;dummy(0,($palette-&gt;dim)[0]), <br>
($res=null)); <br>
return $res; <br>
}</p>

<p style="margin-top: 1em">Would you agree that it might be
difficult to figure out expected dimensions, purpose of the
routine, etc ? (If you want to find out what this piece of
code does, see below)</p>

<p style="margin-top: 1em">How to figure out the loop
dimensions <br>
There are a couple of rules that allow you to figure out
number and size of loop dimensions (and if the size of your
input piddles comply with the threading rules). Dimensions
of <br>
any piddle argument are broken down into two groups in the
following: Core dimensions (as defined by the PP-function,
see Appendix B for a list of PDL primitives) and extra <br>
dimensions which comprises all remaining dimensions of that
piddle. For example calling a function &quot;func&quot; with
the signature &quot;func((n,m),[o](n))&quot; with a piddle
&quot;a(2,4,7,1,3)&quot; as <br>
&quot;f($a,($o = null))&quot; results in the semantic
splitting of a&rsquo;s dimensions into: core dimensions
&quot;(2,4)&quot; and extra dimensions
&quot;(7,1,3)&quot;.</p>

<p style="margin-top: 1em">R0 Core dimensions are
identified with the first N dimensions of the respective
piddle argument (and are required). Any further dimensions
are extra dimensions and used to <br>
determine the loop dimensions.</p>

<p style="margin-top: 1em">R1 The number of (implicit) loop
dimensions is equal to the maximal number of extra
dimensions taken over the set of piddle arguments.</p>

<p style="margin-top: 1em">R2 The size of each of the loop
dimensions is derived from the size of the respective
dimensions of the piddle arguments. The size of a loop
dimension is given by the maximal <br>
size found in any of the piddles having this extra
dimension.</p>

<p style="margin-top: 1em">R3 For all piddles that have a
given extra dimension the size must be equal to the size of
the loop dimension (as determined by the previous rule) or
1; otherwise you raise a <br>
runtime exception. If the size of the extra dimension in a
piddle is one it is implicitly treated as a dummy dimension
of size equal to that loop dim size when performing <br>
the thread loop.</p>

<p style="margin-top: 1em">R4 If a piddle doesn&rsquo;t
have a loop dimension, in the thread loop this piddle is
treated as if having a dummy dimension of size equal to the
size of that loop dimension.</p>

<p style="margin-top: 1em">R5 If output auto-creation is
used (by setting the relevant piddle to
&quot;PDL-&gt;null&quot; before invocation) the number of
dimensions of the created piddle is equal to the sum of the
<br>
number of core output dimensions + number of loop
dimensions. The size of the core output dimensions is
derived from the relevant dimension of input piddles (as
specified <br>
in the function definition) and the sizes of the other
dimensions are equal to the size of the loop dimension it is
derived from. The automatically created piddle will be <br>
physical (unless dataflow is in operation).</p>

<p style="margin-top: 1em">In this context, note that you
can run into the problem with assignment to piddles
containing greater-than-one dummy dimensions (see above).
Although your output piddle(s) <br>
didn&rsquo;t contain any dummy dimensions in the first place
they may end up with implicitly created dummy dimensions
according to R4.</p>

<p style="margin-top: 1em">As an example, suppose we have a
(here unspecified) PP-function with the signature:</p>


<p style="margin-top: 1em">func((m,n),(m,n,o),(m),[o](m,o))</p>

<p style="margin-top: 1em">and you call it with 3 piddles
&quot;a(5,3,10,11)&quot;, &quot;b(5,3,2,10,1,12)&quot;, and
&quot;c(5,1,11,12)&quot; as</p>

<p style="margin-top: 1em">func($a,$b,$c,($d=null))</p>

<p style="margin-top: 1em">then the number of loop
dimensions is 3 (by &quot;R0+R1&quot; from $b and $c) with
sizes &quot;(10,11,12)&quot; (by R2); the two output core
dimensions are &quot;(5,2)&quot; (from the signature of
func) <br>
resulting in a 5-dimensional output piddle $c of size
&quot;(5,2,10,11,12)&quot; (see R5) and (the automatically
created) $d is derived from &quot;($a,$b,$c)&quot; in a way
that can be expressed in <br>
pdl pseudo-code as</p>

<p style="margin-top: 1em">$d(:,:,i,j,k) .=
func($a(:,:,i,j),$b(:,:,:,i,0,k),$c(:,0,j,k)) <br>
with 0&lt;=i&lt;10, 0&lt;=j&lt;=11, 0&lt;=k&lt;12</p>

<p style="margin-top: 1em">If we analyze the color to
grey-scale conversion again with these rules in mind we note
another great advantage of implicit threading. We can call
the conversion with a piddle <br>
representing a pixel (im(3)), a line of rgb pixels
(&quot;im(3,x)&quot;), a proper color image
(&quot;im(3,x,y)&quot;) or a whole stack of RGB images
(&quot;im(3,x,y,z)&quot;). As long as $im is of the form
<br>
&quot;(3,...)&quot; the automatically created output piddle
will contain the right number of dimensions and contain the
intensity data as we expect it since the loops have been
implicitly <br>
performed thanks to implicit threading. You can easily
convince yourself that calling with a color pixel $grey is
0D, with a line it turns out 1D grey(x), with an image we
get <br>
&quot;grey(x,y)&quot; and finally we get a converted image
stack &quot;grey(x,y,z)&quot;.</p>

<p style="margin-top: 1em">Let&rsquo;s fill these general
rules with some more life by going through a couple of
further examples. The reader may try to figure out
equivalent formulations with explicit for- <br>
looping and compare the flexibility of those routines using
implicit threading to the explicit formulation. Furthermore,
especially when using several thread dimensions it is a <br>
useful exercise to check the relative speed by doing some
benchmark tests (which we still have to do).</p>

<p style="margin-top: 1em">First in the row is a slightly
reworked centroid example, now coded with threading in
mind.</p>

<p style="margin-top: 1em"># threaded mult to calculate
centroid coords, works for stacks as well <br>
$xc = sumover(($im*xvals(($im-&gt;dims)[0]))-&gt;clump(2)) /
<br>
sumover($im-&gt;clump(2));</p>

<p style="margin-top: 1em">Let&rsquo;s analyze what&rsquo;s
going on step by step. First the product:</p>

<p style="margin-top: 1em">$prod =
$im*xvals(zeroes(($im-&gt;dims)[0]))</p>

<p style="margin-top: 1em">This will actually work for $im
being one, two, three, and higher dimensional. If $im is
one-dimensional it&rsquo;s just an ordinary product (in the
sense that every element of $im is <br>
multiplied with the respective element of
&quot;xvals(...)&quot;), if $im has more dimensions further
threading is done by adding appropriate dummy dimensions to
&quot;xvals(...)&quot; according to <br>
R4. More importantly, the two sumover operations show a
first example of how to make use of the dimension
manipulating commands. A quick look at sumover&rsquo;s
signature will remind <br>
you that it will only &quot;gobble up&quot; the first
dimension of a given input piddle. But what if we want to
really compute the sum over all elements of the first two
dimensions? Well, <br>
nothing keeps us from passing a virtual piddle into sumover
which in this case is formed by clumping the first two
dimensions of the &quot;parent piddle&quot; into one. From
the point of <br>
view of the parent piddle the sum is now computed over the
first two dimensions, just as we wanted, though sumover has
just done the job as specified by its signature. Got it
?</p>

<p style="margin-top: 1em">Another little finesse of
writing the code like that: we intentionally used
&quot;sumover($pdl-&gt;clump(2))&quot; instead of
&quot;sum($pdl)&quot; so that we can either pass just an
image &quot;(x,y)&quot; or a <br>
stack of images &quot;(x,y,t)&quot; into this routine and
get either just one x-coordiante or a vector of
x-coordinates (of size t) in return.</p>

<p style="margin-top: 1em">Another set of common operations
are what one could call &quot;projection operations&quot;.
These operations take a N-D piddle as input and return a
(N-1)-D &quot;projected&quot; piddle. These <br>
operations are often performed with functions like sumover,
prodover, minimum and maximum. Using again images as
examples we might want to calculate the maximum pixel value
for <br>
each line of an image or image stack. We know how to do
that</p>

<p style="margin-top: 1em"># maxima of lines (as function
of line number and time) <br>
maximum($stack,($ret=null));</p>

<p style="margin-top: 1em">But what if you want to
calculate maxima per column when implicit threading always
applies the core functionality to the first dimension and
threads over all others? How can we <br>
achieve that instead the core functionality is applied to
the second dimension and threading is done over the others.
Can you guess it? Yes, we make a virtual piddle that has the
<br>
second dimension of the &quot;parent piddle&quot; as its
first dimension using the &quot;mv&quot; command.</p>

<p style="margin-top: 1em"># maxima of columns (as function
of column number and time) <br>
maximum($stack-&gt;mv(1,0),($ret=null));</p>

<p style="margin-top: 1em">and calculating all the sums of
sub-slices over the third dimension is now almost too
easy</p>

<p style="margin-top: 1em"># sums of pixels in time
(assuming time is the third dim) <br>
sumover($stack-&gt;mv(2,0),($ret=null));</p>

<p style="margin-top: 1em">Finally, if you want to apply
the operation to all elements (like max over all elements or
sum over all elements) regardless of the dimensions of the
piddle in question &quot;clump&quot; <br>
comes in handy. As an example look at the definition of
&quot;sum&quot; (as defined in &quot;Ufunc.pm&quot;):</p>

<p style="margin-top: 1em">sub sum { <br>
PDL::Ufunc::sumover($name-&gt;clump(-1),($tmp=null)); <br>
return $tmp-&gt;at(); # return a Perl number, not a 0D
piddle <br>
}</p>

<p style="margin-top: 1em">We have already mentioned that
all basic operations support threading and assignment is no
exception. So here are a couple of threaded assignments</p>

<p style="margin-top: 1em">pdl&gt; $im = zeroes(byte,
10,20) <br>
pdl&gt; $line = exp(-rvals(10)**2/9) <br>
# threaded assignment <br>
pdl&gt; $im .= $line # set every line of $im to $line <br>
pdl&gt; $im2 .= 5 # set every element of $im2 to 5</p>

<p style="margin-top: 1em">By now you probably see how it
works and what it does, don&rsquo;t you?</p>

<p style="margin-top: 1em">To finish the examples in this
paragraph here is a function to create an RGB image from
what is called a palette image. The palette image consists
of two parts: an image of <br>
indices into a color lookup table and the color lookup table
itself. [ describe how it works ] We are going to use a
PP-function we haven&rsquo;t encoutered yet in the previous
<br>
examples. It is the aptly named index function, signature
&quot;((n),(),[o]())&quot; (see Appendix B) with the core
functionality that &quot;index(pdl
(0,2,4,5),2,($ret=null))&quot; will return the <br>
element with index 2 of the first input piddle. In this
case, $ret will contain the value 4. So here is the
example:</p>

<p style="margin-top: 1em"># a threaded index lookup to
generate an RGB, or RGBA or YMCK image <br>
# from a palette image (represented by a lookup table
$palette and <br>
# an color-index image $im) <br>
# you can say just dummy(0) since the rules of threading
make it fit <br>
pdl&gt; index($palette-&gt;xchg(0,1), <br>
$im-&gt;long-&gt;dummy(0,($palette-&gt;dim)[0]), <br>
($res=null));</p>

<p style="margin-top: 1em">Let&rsquo;s go through it and
explain the steps involved. Assuming we are dealing with an
RGB lookup-table $palette is of size &quot;(3,x)&quot;.
First we exchange the dimensions of the palette <br>
so that looping is done over the first dimension of $palette
(of size 3 that represent r, g, and b components). Now
looking at $im, we add a dummy dimension of size equal to
the <br>
length of the number of components (in the case we are
discussing here we could have just used the number 3 since
we have 3 color components). We can use a dummy dimension
since <br>
for red, green and blue color components we use the same
index from the original image, e.g. assuming a certain pixel
of $im had the value 4 then the lookup should produce the
<br>
triple</p>


<p style="margin-top: 1em">[palette(0,4),palette(1,4),palette(2,4)]</p>

<p style="margin-top: 1em">for the new red, green and blue
components of the output image. Hopefully by now you have
some sort of idea what the above piece of code is supposed
to do (it is often actually <br>
quite complicated to describe in detail how a piece of
threading code works; just go ahead and experiment a bit to
get a better feeling for it).</p>

<p style="margin-top: 1em">If you have read the threading
rules carefully, then you might have noticed that we
didn&rsquo;t have to explicitly state the size of the dummy
dimension that we created for $im; when <br>
we create it with size 1 (the default) the rules of
threading make it automatically fit to the desired size (by
rule R3, in our example the size would be 3 assuming a
palette of <br>
size &quot;(3,x)&quot;). Since situations like this do occur
often in practice this is actually why rule R3 has been
introduced (the part that makes dimensions of size 1 fit to
the thread <br>
loop dim size). So we can just say</p>

<p style="margin-top: 1em">pdl&gt;
index($palette-&gt;xchg(0,1),$im-&gt;long-&gt;dummy(0),($res=null));</p>

<p style="margin-top: 1em">Again, you can convince yourself
that this routine will create the right output if called
with a pixel ($im is 0D), a line ($im is 1D), an image ($im
is 2D), ..., an RGB lookup <br>
table (palette is &quot;(3,x)&quot;) and RGBA lookup table
(palette is &quot;(4,x)&quot;, see e.g. OpenGL). This
flexibility is achieved by the rules of threading which are
made to do the right <br>
thing in most situations.</p>

<p style="margin-top: 1em">To wrap it all up once again,
the general idea is as follows. If you want to achieve
looping over certain dimensions and have the core
functionality applied to another specified <br>
set of dimensions you use the dimension manipulating
commands to create a (or several) virtual piddle(s) so that
from the point of view of the parent piddle(s) you get what
you <br>
want (always having the signature of the function in
question and R1-R5 in mind!). Easy, isn&rsquo;t it ?</p>

<p style="margin-top: 1em">Output auto-creation and
PP-function calling conventions <br>
At this point we have to divert to some technical detail
that has to do with the general calling conventions of
PP-functions and the automatic creation of output arguments.
<br>
Basically, there are two ways of invoking PDL routines,
namely</p>

<p style="margin-top: 1em">$result = func($a,$b);</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">func($a,$b,$result);</p>

<p style="margin-top: 1em">If you are only using implicit
threading then the output variable can be automatically
created by PDL. You flag that to the PP-function by setting
the output argument to a <br>
special kind of piddle that is returned from a call to the
function &quot;PDL-&gt;null&quot; that returns an
essentially &quot;empty&quot; piddle (for those interested
in details there is a flag in the <br>
C pdl structure for this). The dimensions of the created
piddle are determined by the rules of implicit threading:
the first dimensions are the core output dimensions to which
<br>
the threading dimensions are appended (which are in turn
determined by the dimensions of the input piddles as
described above). So you can say</p>


<p style="margin-top: 1em">func($a,$b,($result=PDL-&gt;null));</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">$result = func($a,$b)</p>

<p style="margin-top: 1em">which are exactly
equivalent.</p>

<p style="margin-top: 1em">Be warned that you can not use
output auto-creation when using explicit threading (for
reasons explained in the following section on explicit
threading, the second variant of <br>
threading).</p>

<p style="margin-top: 1em">In &quot;tight&quot; loops you
probably want to avoid the implicit creation of a temporary
piddle in each step of the loop that comes along with the
&quot;functional&quot; style but rather say</p>

<p style="margin-top: 1em"># create output piddle of
appropriate size only at first invocation <br>
$result = null; <br>
for (0...$n) { <br>
func($a,$b,$result); # in all but the first invocation
$result <br>
func2($b); # is defined and has the right size to <br>
# take the output provided $b&rsquo;s dims don&rsquo;t
change <br>
twiddle($result,$a); # do something from $result to $a for
iteration <br>
}</p>

<p style="margin-top: 1em">The take-home message of this
section once more: be aware of the limitation on output
creation when using explicit threading.</p>

<p style="margin-top: 1em">Explicit threading <br>
Having so far only talked about the first flavour of
threading it is now about time to introduce the second
variant. Instead of shuffling around dimensions all the time
and <br>
relying on the rules of implicit threading to get it all
right you sometimes might want to specify in a more explicit
way how to perform the thread loop. It is probably not too
<br>
surprising that this variant of the game is called explicit
threading. Now, before we create the wrong impression: it is
not either implicit or explicit; the two flavours do <br>
mix. But more about that later.</p>

<p style="margin-top: 1em">The two most used functions with
explicit threading are thread and unthread. We start with an
example that illustrates typical usage of the former:</p>

<p style="margin-top: 1em">[ # ** this is the worst
possible example to start with ] <br>
# but can be used to show that $mat += $line is different
from <br>
# $mat-&gt;thread(0) += $line <br>
# explicit threading to add a vector to each column of a
matrix <br>
pdl&gt; $mat = zeroes(4,3) <br>
pdl&gt; $line = pdl (3.1416,2,-2) <br>
pdl&gt; ($tmp = $mat-&gt;thread(0)) += $line</p>

<p style="margin-top: 1em">In this example,
&quot;$mat-&gt;thread(0)&quot; tells PDL that you want the
second dimension of this piddle to be threaded over first
leading to a thread loop that can be expressed as</p>

<p style="margin-top: 1em">for (j=0; j&lt;3; j++) { <br>
for (i=0; i&lt;4; i++) { <br>
mat(i,j) += src(j); <br>
} <br>
}</p>

<p style="margin-top: 1em">&quot;thread&quot; takes a list
of numbers as arguments which explicitly specify which
dimensions to thread over first. With the introduction of
explicit threading the dimensions of a <br>
piddle are conceptually split into three different groups
the latter two of which we have already encountered: thread
dimensions, core dimensions and extra dimensions.</p>

<p style="margin-top: 1em">Conceptually, it is best to
think of those dimensions of a piddle that have been
specified in a call to &quot;thread&quot; as being taken
away from the set of normal dimensions and put on <br>
a separate stack. So assuming we have a piddle
&quot;a(4,7,2,8)&quot; saying</p>

<p style="margin-top: 1em">$b = $a-&gt;thread(2,1)</p>

<p style="margin-top: 1em">creates a new virtual piddle of
dimension &quot;b(4,8)&quot; (which we call the remaining
dims) that also has 2 thread dimensions of size
&quot;(2,7)&quot;. For the purposes of this document we <br>
write that symbolically as &quot;b(4,8){2,7}&quot;. An
important difference to the previous examples where only
implicit threading was used is the fact that the core
dimensions are matched <br>
against the remaining dimensions which are not necessarily
the first dimensions of the piddle. We will now specify how
the presence of thread dimensions changes the rules R1-R5
<br>
for thread loops (which apply to the special case where none
of the piddle arguments has any thread dimensions).</p>

<p style="margin-top: 1em">T0 Core dimensions are matched
against the first n remaining dimensions of the piddle
argument (note the difference to R1). Any further remaining
dimensions are extra dimensions <br>
and are used to determine the implicit loop dimensions.</p>

<p style="margin-top: 1em">T1a The number of implicit loop
dimensions is equal to the maximal number of extra
dimensions taken over the set of piddle arguments.</p>

<p style="margin-top: 1em">T1b The number of explicit loop
dimensions is equal to the maximal number of thread
dimensions taken over the set of piddle arguments.</p>

<p style="margin-top: 1em">T1c The total number of loop
dimensions is equal to the sum of explicit loop dimensions
and implicit loop dimensions. In the thread loop, explicit
loop dimensions are threaded <br>
over first followed by implicit loop dimensions.</p>

<p style="margin-top: 1em">T2 The size of each of the loop
dimensions is derived from the size of the respective
dimensions of the piddle arguments. It is given by the
maximal size found in any piddles <br>
having this thread dimension (for explicit loop dimensions)
or extra dimension (for implicit loop dimensions).</p>

<p style="margin-top: 1em">T3 This rule applies to any
explicit loop dimension as well as any implicit loop
dimension. For all piddles that have a given thread/extra
dimension the size must be equal to <br>
the size of the respective explicit/implicit loop dimension
or 1; otherwise you raise a runtime exception. If the size
of a thread/extra dimension of a piddle is one it is <br>
implicitly treated as a dummy dimension of size equal to the
explicit/implicit loop dimension.</p>

<p style="margin-top: 1em">T4 If a piddle doesn&rsquo;t
have a thread/extra dimension that corresponds to an
explicit/implicit loop dimension, in the thread loop this
piddle is treated as if having a dummy <br>
dimension of size equal to the size of that loop
dimension.</p>

<p style="margin-top: 1em">T4a All piddles that do have
thread dimensions must have the same number of thread
dimensions.</p>

<p style="margin-top: 1em">T5 Output auto-creation cannot
be used if any of the piddle arguments has any thread
dimensions. Otherwise R5 applies.</p>

<p style="margin-top: 1em">The same restrictions apply with
regard to implicit dummy dimensions (created by application
of T4) as already mentioned in the section on implicit
threading: if any of the <br>
output piddles has an (explicit or implicitly created)
greater-than-one dummy dimension a runtime exception will be
raised.</p>

<p style="margin-top: 1em">Let us demonstrate these rules
at work in a generic case. Suppose we have a (here
unspecified) PP-function with the signature:</p>

<p style="margin-top: 1em">func((m,n),(m),(),[o](m))</p>

<p style="margin-top: 1em">and you call it with 3 piddles
&quot;a(5,3,10,11)&quot;, &quot;b(3,5,10,1,12)&quot;,
&quot;c(10)&quot; and an output piddle
&quot;d(3,11,5,10,12)&quot; (which can here not be
automatically created) as</p>


<p style="margin-top: 1em">func($a-&gt;thread(1,3),$b-&gt;thread(0,3),$c,$d-&gt;thread(0,1))</p>

<p style="margin-top: 1em">From the signature of func and
the above call the piddles split into the following groups
of core, extra and thread dimensions (written in the form
&quot;pdl(core dims){thread <br>
dims}[extra dims]&quot;):</p>

<p style="margin-top: 1em">a(5,10){3,11}[] b(5){3,1}[10,12]
c(){}[10] d(5){3,11}[10,12]</p>

<p style="margin-top: 1em">With this to help us along (it
is in general helpful to write the arguments down like this
when you start playing with threading and want to keep track
of what is going on) we <br>
further deduce that the number of explicit loop dimensions
is 2 (by T1b from $a and $b) with sizes &quot;(3,11)&quot;
(by T2); 2 implicit loop dimensions (by T1a from $b and $d)
of size <br>
&quot;(10,12)&quot; (by T2) and the elements of are computed
from the input piddles in a way that can be expressed in pdl
pseudo-code as</p>

<p style="margin-top: 1em">for (l=0;l&lt;12;l++) <br>
for (k=0;k&lt;10;k++) <br>
for (j=0;j&lt;11;j++) effect of treating it as dummy dim
(index j) <br>
for (i=0;i&lt;3;i++) | <br>
d(i,j,:,k,l) = func(a(:,i,:,j),b(i,:,k,0,l),c(k))</p>

<p style="margin-top: 1em">Ugh, this example was really not
easy in terms of bookkeeping. It serves mostly as an example
how to figure out what&rsquo;s going on when you encounter a
complicated looking <br>
expression. But now it is really time to show that threading
is useful by giving some more of our so called
&quot;practical&quot; examples.</p>

<p style="margin-top: 1em">[ The following examples will
need some additional explanations in the future. For the
moment please try to live with the comments in the code
fragments. ]</p>

<p style="margin-top: 1em">Example 1:</p>

<p style="margin-top: 1em">*** inverse of matrix
represented by eigvecs and eigvals <br>
** given a symmetrical matrix M = A^T x diag(lambda_i) x A
<br>
** =&gt; inverse M^-1 = A^T x diag(1/lambda_i) x A <br>
** first $tmp = diag(1/lambda_i)*A <br>
** then A^T * $tmp by threaded inner product <br>
# index handling so that matrices print correct under pdl
<br>
$inv .= $evecs*0; # just copy to get appropriately sized
output <br>
$tmp .= $evecs; # initialise, no back-propagation <br>
($tmp2 = $tmp-&gt;thread(0)) /= $evals; # threaded division
<br>
# and now a matrix multiplication in disguise <br>

PDL::Primitive::inner($evecs-&gt;xchg(0,1)-&gt;thread(-1,1),
<br>
$tmp-&gt;thread(0,-1), <br>
$inv-&gt;thread(0,1)); <br>
# alternative for matrix mult using implicit threading, <br>
# first xchg only for transpose <br>
PDL::Primitive::inner($evecs-&gt;xchg(0,1)-&gt;dummy(1),
<br>
$tmp-&gt;xchg(0,1)-&gt;dummy(2), <br>
($inv=null));</p>

<p style="margin-top: 1em">Example 2:</p>

<p style="margin-top: 1em"># outer product by threaded
multiplication <br>
# stress that we need to do it with explicit call to
my_biop1 <br>
# when using explicit threading <br>
$res=zeroes(($a-&gt;dims)[0],($b-&gt;dims)[0]); <br>

my_biop1($a-&gt;thread(0,-1),$b-&gt;thread(-1,0),$res-&gt;(0,1),&quot;*&quot;);
<br>
# similar thing by implicit threading with auto-created
piddle <br>
$res = $a-&gt;dummy(1) * $b-&gt;dummy(0);</p>

<p style="margin-top: 1em">Example 3:</p>

<p style="margin-top: 1em"># different use of thread and
unthread to shuffle a number of <br>
# dimensions in one go without lots of calls to -&gt;xchg
and -&gt;mv</p>

<p style="margin-top: 1em"># use thread/unthread to shuffle
dimensions around <br>
# just try it out and compare the child piddle with its
parent <br>
$trans = $a-&gt;thread(4,1,0,3,2)-&gt;unthread;</p>

<p style="margin-top: 1em">Example 4:</p>

<p style="margin-top: 1em"># calculate a couple of bounding
boxes <br>
# $bb will hold BB as [xmin,xmax],[ymin,ymax],[zmin,zmax]
<br>
# we use again thread and unthread to shuffle dimensions
around <br>
pdl&gt; $bb = zeroes(double, 2,3 ); <br>
pdl&gt;
minimum($vertices-&gt;thread(0)-&gt;clump-&gt;unthread(1),
$bb-&gt;slice(&rsquo;(0),:&rsquo;)); <br>
pdl&gt;
maximum($vertices-&gt;thread(0)-&gt;clump-&gt;unthread(1),
$bb-&gt;slice(&rsquo;(1),:&rsquo;));</p>

<p style="margin-top: 1em">Example 5:</p>

<p style="margin-top: 1em"># calculate a self-rationed
(i.e. self normalized) sequence of images <br>
# uses explicit threading and an implicitly threaded
division <br>
$stack = read_image_stack(); <br>
# calculate the average (per pixel average) of the first
$n+1 images <br>
$aver = zeroes([stack-&gt;dims]-&gt;[0,1]); # make the
output piddle <br>

sumover($stack-&gt;slice(&quot;:,:,0:$n&quot;)-&gt;thread(0,1),$aver);
<br>
$aver /= ($n+1); <br>
$stack /= $aver; # normalize the stack by doing a threaded
division <br>
# implicit versus explicit <br>
# alternatively calculate $aver with implicit threading and
auto-creation <br>

sumover($stack-&gt;slice(&quot;:,:,0:$n&quot;)-&gt;mv(2,0),($aver=null));
<br>
$aver /= ($n+1); <br>
#</p>

<p style="margin-top: 1em">Implicit versus explicit
threading <br>
In this paragraph we are going to illustrate when explicit
threading is preferable over implicit threading and vice
versa. But then again, this is probably not the best way of
<br>
putting the case since you already know: the two flavours do
mix. So, it&rsquo;s more about how to get the best of both
worlds and, anyway, in the best of Perl traditions:
TIMTOWTDI !</p>

<p style="margin-top: 1em">[ Sorry, this still has to be
filled in in a later release; either refer to above examples
or choose some new ones ]</p>

<p style="margin-top: 1em">Finally, this may be a good
place to justify all the technical detail we have been going
on about for a couple of pages: why threading ?</p>

<p style="margin-top: 1em">Well, code that uses threading
should be (considerably) faster than code that uses explicit
for-loops (or similar Perl constructs) to achieve the same
functionality. Especially <br>
on supercomputers (with vector computing facilities/parallel
processing) PDL threading will be implemented in a way that
takes advantage of the additional facilities of these <br>
machines. Furthermore, it is a conceptually simply construct
(though technical details might get involved at times) and
can greatly reduce the syntactical complexity of PDL code
<br>
(but keep the admonition for documentation in mind). Once
you are comfortable with the threading way of thinking (and
coding) it shouldn&rsquo;t be too difficult to understand
code <br>
that somebody else has written than (provided he gave you an
idea what expected input dimensions are, etc.). As a general
tip to increase the performance of your code: if you <br>
have to introduce a loop into your code try to reformulate
the problem so that you can use threading to perform the
loop (as with anything there are exceptions to this rule of
<br>
thumb; but the authors of this document tend to think that
these are rare cases ;).</p>

<p style="margin-top: 1em">PDL::PP <br>
An easy way to define functions that are aware of indexing
and threading (and the universe and everything) <br>
PDL:PP is part of the PDL distribution. It is used to
generate functions that are aware of indexing and threading
rules from very concise descriptions. It can be useful for
you <br>
if you want to write your own functions or if you want to
interface functions from an external library so that they
support indexing and threading (and maybe dataflow as well,
<br>
see PDL::Dataflow). For further details check PDL::PP.</p>

<p style="margin-top: 1em">Appendix A <br>
Affine transformations - a special class of simple and
powerful transformations <br>
[ This is also something to be added in future releases. Do
we already have the general make_affine routine in PDL ? It
is possible that we will reference another appropriate man
<br>
page from here ]</p>

<p style="margin-top: 1em">Appendix B <br>
signatures of standard PDL::PP compiled functions <br>
A selection of signatures of PDL primitives to show how many
dimensions PP compiled functions gobble up (and therefore
you can figure out what will be threaded over). Most of <br>
those functions are the basic ones defined in
&quot;primitive.pd&quot;</p>

<p style="margin-top: 1em"># functions in primitive.pd <br>
# <br>
sumover ((n),[o]()) <br>
prodover ((n),[o]()) <br>
axisvalues ((n)) inplace <br>
inner ((n),(n),[o]()) <br>
outer ((n),(m),[o](n,m)) <br>
innerwt ((n),(n),(n),[o]()) <br>
inner2 ((m),(m,n),(n),[o]()) <br>
inner2t ((j,n),(n,m),(m,k),[o]()) <br>
index (1D,0D,[o]) <br>
minimum (1D,[o]) <br>
maximum (1D,[o]) <br>
wstat ((n),(n),(),[o],()) <br>
assgn ((),())</p>

<p style="margin-top: 1em"># basic operations <br>
binary operations ((),(),[o]()) <br>
unary operations ((),[o]())</p>

<p style="margin-top: 1em">AUTHOR &amp; COPYRIGHT <br>
Copyright (C) 1997 Christian Soeller
(c.soeller@auckland.ac.nz) &amp; Tuomas J. Lukka
(lukka@fas.harvard.edu). All rights reserved. Although
destined for release as a man page with <br>
the standard PDL distribution, it is not public domain.
Permission is granted to freely distribute verbatim copies
of this document provided that no modifications outside of
<br>
formatting be made, and that this notice remain intact. You
are permitted and encouraged to use its code and derivatives
thereof in your own source code for fun or for profit as
<br>
you see fit.</p>

<p style="margin-top: 1em">perl v5.24.1 2017-01-14
INDEXING(1)</p>
<hr>
</body>
</html>
