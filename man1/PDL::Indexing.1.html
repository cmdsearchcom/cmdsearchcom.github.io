<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>INDEXING(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">INDEXING(1)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">INDEXING(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
PDL::Indexing - Introduction to indexing and slicing piddles.
<h1 class="Sh" title="Sh" id="OVERVIEW"><a class="selflink" href="#OVERVIEW">OVERVIEW</a></h1>
This man page should serve as a first tutorial on the indexing and threading
  features of <i>PDL</i>.
<div class="Pp"></div>
Like all vectorized languages, PDL automates looping over multi-dimensional data
  structures (&quot;piddles&quot;) using a variant of mathematical vector
  notation. The automatic looping is called &quot;threading&quot;, in part
  because ultimately PDL will implement parallel processing to speed up the
  loops.
<div class="Pp"></div>
A lot of the flexibility and power of PDL relies on the indexing and threading
  features of the Perl extension. Indexing allows access to the data of a piddle
  in a very flexible way. Threading provides efficient vectorization of simple
  operations.
<div class="Pp"></div>
The values of a piddle are stored compactly as typed values in a single block of
  memory, not (as in a normal Perl list-of-lists) as individual Perl scalars.
<div class="Pp"></div>
In the sections that follow many &quot;methods&quot; are called out -- these are
  Perl operators that apply to piddles. From the perldl (or pdl2) shell, you can
  find out more about each method by typing &quot;?&quot; followed by the method
  name.
<h2 class="Ss" title="Ss" id="Dimension_lists"><a class="selflink" href="#Dimension_lists">Dimension
  lists</a></h2>
A piddle (PDL variable), in general, is an N-dimensional array where N can be 0
  (for a scalar), 1 (e.g. for a sound sample), or higher values for images and
  more complex structures. Each dimension of the piddle has a positive integer
  size. The &quot;perl&quot; interpreter treats each piddle as a special type of
  Perl scalar (a blessed Perl object, actually -- but you don't have to know
  that to use them) that can be used anywhere you can put a normal scalar.
<div class="Pp"></div>
You can access the dimensions of a piddle as a Perl list and otherwise determine
  the size of a piddle with several methods. The important ones are:
<dl class="Bl-tag">
  <dt class="It-tag">nelem - the total number of elements in a piddle</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ndims - returns the number of dimensions in a piddle</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dims - returns the dimension list of a piddle as a Perl
    list</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dim - returns the size of a particular dimension of a
    piddle</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="Indexing_and_Dataflow"><a class="selflink" href="#Indexing_and_Dataflow">Indexing
  and Dataflow</a></h2>
PDL maintains a notion of &quot;dataflow&quot; between a piddle and indexed
  subfields of that piddle. When you produce an indexed subfield or single
  element of a parent piddle, the child and parent remain attached until you
  manually disconnect them. This lets you represent the same data different ways
  within your code -- for example, you can consider an RGB image simultaneously
  as a collection of (R,G,B) values in a 3 x 1000 x 1000 image, and as three
  separate 1000 x 1000 color planes stored in different variables. Modifying any
  of the variables changes the underlying memory, and the changes are reflected
  in all representations of the data.
<div class="Pp"></div>
There are two important methods that let you control dataflow connections
  between a child and parent piddle:
<dl class="Bl-tag">
  <dt class="It-tag">copy - forces an explicit copy of a piddle</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sever - breaks the dataflow connection between a piddle and
    its parents (if any)</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="Threading_and_Dimension_Order"><a class="selflink" href="#Threading_and_Dimension_Order">Threading
  and Dimension Order</a></h2>
Most PDL operations act on the first few dimensions of their piddle arguments.
  For example, &quot;sumover&quot; sums all elements along the first dimension
  in the list (dimension 0). If you feed in a three-dimensional piddle, then the
  first dimension is considered the &quot;active&quot; dimension and the later
  dimensions are &quot;thread&quot; dimensions because they are simply looped
  over. There are several ways to transpose or re-order the dimension list of a
  piddle. Those techniques are very fast since they don't touch the underlying
  data, only change the way that PDL accesses the data. The main dimension
  ordering functions are:
<dl class="Bl-tag">
  <dt class="It-tag">mv - moves a particular dimension somewhere else in the
    dimension list</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">xchg - exchanges two dimensions in the dimension list,
    leaving the rest alone</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">reorder - allows wholesale mixing of the dimensions</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">clump - clumps together two or more small dimensions into
    one larger one</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">squeeze - eliminates any dimensions of size 1</dt>
  <dd class="It-tag"></dd>
</dl>
<h2 class="Ss" title="Ss" id="Physical_and_Dummy_Dimensions"><a class="selflink" href="#Physical_and_Dummy_Dimensions">Physical
  and Dummy Dimensions</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">document Perl level threading</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">threadids</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">update and correct description of slice</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">new functions in slice.pd (affine, lag, splitdim)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">reworking of paragraph on explicit threading</dd>
</dl>
<h1 class="Sh" title="Sh" id="Indexing_and_threading_with_PDL"><a class="selflink" href="#Indexing_and_threading_with_PDL">Indexing
  and threading with PDL</a></h1>
A lot of the flexibility and power of PDL relies on the indexing and looping
  features of the Perl extension. Indexing allows access to the data of a piddle
  in a very flexible way. Threading provides efficient implicit looping
  functionality (since the loops are implemented as optimized C code).
<div class="Pp"></div>
Piddles are Perl objects that represent multidimensional arrays and operations
  on those. In contrast to simple Perl @x style lists the array data is
  compactly stored in a single block of memory thus taking up a lot less memory
  and enabling use of fast C code to implement operations (e.g. addition, etc)
  on piddles.
<h2 class="Ss" title="Ss" id="piddles_can_have_children"><a class="selflink" href="#piddles_can_have_children">piddles
  can have children</a></h2>
Central to many of the indexing capabilities of PDL are the relation of
  &quot;parent&quot; and &quot;child&quot; between piddles. Many of the indexing
  commands create a new piddle from an existing piddle. The new piddle is the
  &quot;child&quot; and the old one is the &quot;parent&quot;. The data of the
  new piddle is defined by a transformation that specifies how to generate
  (compute) its data from the parent's data. The relation between the child
  piddle and its parent are often bidirectional, meaning that changes in the
  child's data are propagated back to the parent. (Note: You see, we are aiming
  in our terminology already towards the new dataflow features. The kind of
  dataflow that is used by the indexing commands (about which you will learn in
  a minute) is always in operation, not only when you have explicitly switched
  on dataflow in your piddle by saying &quot;$a-&gt;doflow&quot;. For further
  information about data flow check the dataflow man page.)
<div class="Pp"></div>
Another way to interpret the piddles created by our indexing commands is to view
  them as a kind of intelligent pointer that points back to some portion or all
  of its parent's data. Therefore, it is not surprising that the parent's data
  (or a portion of it) changes when manipulated through this
  &quot;pointer&quot;. After these introductory remarks that hopefully prepared
  you for what is coming (rather than confuse you too much) we are going to dive
  right in and start with a description of the indexing commands and some
  typical examples how they might be used in PDL programs. We will further
  illustrate the pointer/dataflow analogies in the context of some of the
  examples later on.
<div class="Pp"></div>
There are two different implementations of this ``smart pointer'' relationship:
  the first one, which is a little slower but works for any transformation is
  simply to do the transformation forwards and backwards as necessary. The other
  is to consider the child piddle a ``virtual'' piddle, which only stores a
  pointer to the parent and access information so that routines which use the
  child piddle actually directly access the data in the parent. If the virtual
  piddle is given to a routine which cannot use it, PDL transparently
  physicalizes the virtual piddle before letting the routine use it.
<div class="Pp"></div>
Currently (1.94_01) all transformations which are ``affine'', i.e. the indices
  of the data item in the parent piddle are determined by a linear
  transformation (+ constant) from the indices of the child piddle result in
  virtual piddles. All other indexing routines (e.g.
  &quot;-&gt;index(...)&quot;) result in physical piddles. All routines compiled
  by PP can accept affine piddles (except those routines that pass pointers to
  external library functions).
<div class="Pp"></div>
Note that whether something is affine or not does not affect the semantics of
  what you do in any way: both
<div class="Pp"></div>
<pre>
 $a-&gt;index(...) .= 5;
 $a-&gt;slice(...) .= 5;
</pre>
<div class="Pp"></div>
change the data in $a. The affinity does, however, have a significant impact on
  memory usage and performance.
<h2 class="Ss" title="Ss" id="Slicing_piddles"><a class="selflink" href="#Slicing_piddles">Slicing
  piddles</a></h2>
Probably the most important application of the concept of parent/child piddles
  is the representation of rectangular slices of a physical piddle by a virtual
  piddle. Having talked long enough about concepts let's get more specific.
  Suppose we are working with a 2D piddle representing a 5x5 image (its
  unusually small so that we can print it without filling several screens full
  of digits ;).
<div class="Pp"></div>
<pre>
 pdl&gt; $im = sequence(5,5)
 pdl&gt; p $im
 [
  [ 0  1  2  3  4]
  [ 5  6  7  8  9]
  [10 11 12 13 14]
  [15 16 17 18 19]
  [20 21 22 23 24]
 ]                                                                                
 pdl&gt; help vars
 PDL variables in package main::
 Name         Type   Dimension       Flow  State          Mem
 ----------------------------------------------------------------
 $im          Double D [5,5]                P            0.20Kb
</pre>
<div class="Pp"></div>
[ here it might be appropriate to quickly talk about the &quot;help vars&quot;
  command that provides information about piddles in the interactive
  &quot;perldl&quot; or &quot;pdl2&quot; shell that comes with PDL. ]
<div class="Pp"></div>
Now suppose we want to create a 1-D piddle that just references one line of the
  image, say line 2; or a piddle that represents all even lines of the image
  (imagine we have to deal with even and odd frames of an interlaced image due
  to some peculiar behaviour of our frame grabber). As another frequent
  application of slices we might want to create a piddle that represents a
  rectangular region of the image with top and bottom reversed. All these
  effects (and many more) can be easily achieved with the powerful slice
  function:
<div class="Pp"></div>
<pre>
 pdl&gt; $line = $im-&gt;slice(':,(2)')
 pdl&gt; $even = $im-&gt;slice(':,1:-1:2')
 pdl&gt; $area = $im-&gt;slice('3:4,3:1')
 pdl&gt; help vars  # or just PDL-&gt;vars
 PDL variables in package main::
 Name         Type   Dimension       Flow  State          Mem
 ----------------------------------------------------------------
 $even        Double D [5,2]                -C           0.00Kb
 $im          Double D [5,5]                P            0.20Kb
 $line        Double D [5]                  -C           0.00Kb
 $area        Double D [2,3]                -C           0.00Kb
</pre>
<div class="Pp"></div>
All three &quot;child&quot; piddles are children of $im or in the other (largely
  equivalent) interpretation pointers to data of $im. Operations on those
  virtual piddles access only those portions of the data as specified by the
  argument to slice. So we can just print line 2:
<div class="Pp"></div>
<pre>
 pdl&gt; p $line
 [10 11 12 13 14]
</pre>
<div class="Pp"></div>
Also note the difference in the &quot;Flow State&quot; of $area above and below:
<div class="Pp"></div>
<pre>
 pdl&gt; p $area
 pdl&gt; help $area
 This variable is Double D [2,3]                VC           0.00Kb
</pre>
<div class="Pp"></div>
The following demonstrates that $im and $line really behave as you would expect
  from a pointer-like object (or in the dataflow picture: the changes in $line's
  data are propagated back to $im):
<div class="Pp"></div>
<pre>
 pdl&gt; $im++
 pdl&gt; p $line
 [11 12 13 14 15]
 pdl&gt; $line += 2
 pdl&gt; p $im
 [
  [ 1  2  3  4  5]
  [ 6  7  8  9 10]
  [13 14 15 16 17]
  [16 17 18 19 20]
  [21 22 23 24 25]
 ]
</pre>
<div class="Pp"></div>
Note how assignment operations on the child virtual piddles change the parent
  physical piddle and vice versa (however, the basic &quot;=&quot; assignment
  doesn't, use &quot;.=&quot; to obtain that effect. See below for the reasons).
  The virtual child piddles are something like &quot;live links&quot; to the
  &quot;original&quot; parent piddle. As previously said, they can be thought of
  to work similar to a C-pointer. But in contrast to a C-pointer they carry a
  lot more information. Firstly, they specify the structure of the data they
  represent (the dimensionality of the new piddle) and secondly, specify how to
  create this structure from its parents data (the way this works is buried in
  the internals of PDL and not important for you to know anyway (unless you want
  to hack the core in the future or would like to become a PDL guru in general
  (for a definition of this strange creature see PDL::Internals)).
<div class="Pp"></div>
The previous examples have demonstrated typical usage of the slice function.
  Since the slicing functionality is so important here is an explanation of the
  syntax for the string argument to slice:
<div class="Pp"></div>
<pre>
 $vpdl = $a-&gt;slice('ind0,ind1...')
</pre>
<div class="Pp"></div>
where &quot;ind0&quot; specifies what to do with index No 0 of the piddle $a,
  etc. Each element of the comma separated list can have one of the following
  forms:
<dl class="Bl-tag">
  <dt class="It-tag">':'</dt>
  <dd class="It-tag">Use the whole dimension</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">'n'</dt>
  <dd class="It-tag">Use only index &quot;n&quot;. The dimension of this index
      in the resulting virtual piddle is 1. An example involving those first two
      index formats:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 pdl&gt; $column = $im-&gt;slice('2,:')
 pdl&gt; $row = $im-&gt;slice(':,0')
 pdl&gt; p $column
 [
  [ 3]
  [ 8]
  [15]
  [18]
  [23]
 ]                                                                               
 pdl&gt; p $row
 [
  [1 2 3 4 5]
 ]                                                                               
 pdl&gt; help $column
 This variable is Double D [1,5]                VC           0.00Kb
 pdl&gt; help $row
 This variable is Double D [5,1]                VC           0.00Kb
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">'(n)'</dt>
  <dd class="It-tag">Use only index &quot;n&quot;. This dimension is removed
      from the resulting piddle (relying on the fact that a dimension of size 1
      can always be removed). The distinction between this case and the previous
      one becomes important in assignments where left and right hand side have
      to have appropriate dimensions.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 pdl&gt; $line = $im-&gt;slice(':,(0)')
 pdl&gt; help $line
 This variable is Double D [5]                  -C           0.00Kb
 pdl&gt; p $line
 [1 2 3 4 5]
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Spot the difference to the previous example?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">'n1:n2' or 'n1:n2:n3'</dt>
  <dd class="It-tag">Take the range of indices from &quot;n1&quot; to
      &quot;n2&quot; or (second form) take the range of indices from
      &quot;n1&quot; to &quot;n2&quot; with step &quot;n3&quot;. An example for
      the use of this format is the previous definition of the sub-image
      composed of even lines.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 pdl&gt; $even = $im-&gt;slice(':,1:-1:2')
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This example also demonstrates that negative indices work like they do for
      normal Perl style arrays by counting backwards from the end of the
      dimension. If &quot;n2&quot; is smaller than &quot;n1&quot; (in the
      example -1 is equivalent to index 4) the elements in the virtual piddle
      are effectively reverted with respect to its parent.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">'*[n]'</dt>
  <dd class="It-tag">Add a dummy dimension. The size of this dimension will be 1
      by default or equal to &quot;n&quot; if the optional numerical argument is
      given.
    <div style="height: 1.00em;">&#x00A0;</div>
    Now, this is really something a bit strange on first sight. What is a dummy
      dimension? A dummy dimension inserts a dimension where there wasn't one
      before. How is that done ? Well, in the case of the new dimension having
      size 1 it can be easily explained by the way in which you can identify a
      vector (with &quot;m&quot; elements) with an &quot;(1,m)&quot; or
      &quot;(m,1)&quot; matrix. The same holds obviously for higher dimensional
      objects. More interesting is the case of a dummy dimensions of size
      greater than one (e.g. &quot;slice('*5,:')&quot;). This works in the same
      way as a call to the dummy function creates a new dummy dimension. So read
      on and check its explanation below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">'([n1:n2[:n3]]=i)'</dt>
  <dd class="It-tag">[Not yet implemented ??????] With an argument like this you
      make <i>generalised diagonals</i>. The <i>diagonal</i> will be dimension
      no. &quot;i&quot; of the new output piddle and (if optional part in
      brackets specified) will extend along the range of indices specified of
      the respective parent piddle's dimension. In general an argument like this
      only makes sense if there are other arguments like this in the same call
      to slice. The part in brackets is optional for this type of argument. All
      arguments of this type that specify the same target dimension
      &quot;i&quot; have to relate to the same number of indices in their parent
      dimension. The best way to explain it is probably to give an example, here
      we make a piddle that refers to the elements along the space diagonal of
      its parent piddle (a cube):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 $cube = zeroes(5,5,5);
 $sdiag = $cube-&gt;slice('(=0),(=0),(=0)');
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The above command creates a virtual piddle that represents the diagonal
      along the parents' dimension no. 0, 1 and 2 and makes its dimension 0 (the
      only dimension) of it. You use the extended syntax if the dimension sizes
      of the parent dimensions you want to build the diagonal from have
      different sizes or you want to reverse the sequence of elements in the
      diagonal, e.g.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 $rect = zeroes(12,3,5,6,2);
 $vpdl = $rect-&gt;slice('2:7,(0:1=1),(4),(5:4=1),(=1)');
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    So the elements of $vpdl will then be related to those of its parent in way
      we can express as:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  vpdl(i,j) = rect(i+2,j,4,5-j,j)       0&lt;=i&lt;5, 0&lt;=j&lt;2
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
[ work in the new index function: &quot;$b = $a-&gt;index($c);&quot; ???? ]
<h2 class="Ss" title="Ss" id="There_are_different_kinds_of_assignments_in_PDL"><a class="selflink" href="#There_are_different_kinds_of_assignments_in_PDL">There
  are different kinds of assignments in PDL</a></h2>
The previous examples have already shown that virtual piddles can be used to
  operate on or access portions of data of a parent piddle. They can also be
  used as lvalues in assignments (as the use of &quot;++&quot; in some of the
  examples above has already demonstrated). For explicit assignments to the data
  represented by a virtual piddle you have to use the overloaded &quot;.=&quot;
  operator (which in this context we call <i>propagated</i> <i>assignment</i>).
  Why can't you use the normal assignment operator &quot;=&quot;?
<div class="Pp"></div>
Well, you definitely still can use the '=' operator but it wouldn't do what you
  want. This is due to the fact that the '=' operator cannot be overloaded in
  the same way as other assignment operators. If we tried to use '=' to try to
  assign data to a portion of a physical piddle through a virtual piddle we
  wouldn't achieve the desired effect (instead the variable representing the
  virtual piddle (a reference to a blessed thingy) would after the assignment
  just contain the reference to another blessed thingy which would behave to
  future assignments as a &quot;physical&quot; copy of the original rvalue [this
  is actually not yet clear and subject of discussions in the PDL developers
  mailing list]. In that sense it would break the connection of the piddle to
  the parent [ isn't this behaviour in a sense the opposite of what happens in
  dataflow, where &quot;.=&quot; breaks the connection to the parent? ].
<div class="Pp"></div>
E.g.
<div class="Pp"></div>
<pre>
 pdl&gt; $line = $im-&gt;slice(':,(2)')
 pdl&gt; $line = zeroes(5);
 pdl&gt; $line++;
 pdl&gt; p $im
 [
  [ 1  2  3  4  5]
  [ 6  7  8  9 10]
  [13 14 15 16 17]
  [16 17 18 19 20]
  [21 22 23 24 25]
 ]
 pdl&gt; p $line
 [1 1 1 1 1]
</pre>
<div class="Pp"></div>
But using &quot;.=&quot;
<div class="Pp"></div>
<pre>
 pdl&gt; $line = $im-&gt;slice(':,(2)')
 pdl&gt; $line .= zeroes(5)
 pdl&gt; $line++
 pdl&gt; p $im
 [
  [ 1  2  3  4  5]
  [ 6  7  8  9 10]
  [ 1  1  1  1  1]
  [16 17 18 19 20]
  [21 22 23 24 25]
 ]                                                                               
 pdl&gt; print $line
 [1 1 1 1 1]
</pre>
<div class="Pp"></div>
Also, you can substitute
<div class="Pp"></div>
<pre>
 pdl&gt; $line .= 0;
</pre>
<div class="Pp"></div>
for the assignment above (the zero is converted to a scalar piddle, with no
  dimensions so it can be assigned to any piddle).
<div class="Pp"></div>
A nice feature in recent perl versions is lvalue subroutines (i.e., versions
  5.6.x and higher including all perls currently supported by PDL). That allows
  one to use the slicing syntax on both sides of the assignment:
<div class="Pp"></div>
<pre>
 pdl&gt; $im-&gt;slice(':,(2)') .= zeroes(5)-&gt;xvals-&gt;float
</pre>
<div class="Pp"></div>
Related to the lvalue sub assignment feature is a little trap for the unwary:
  recent perls introduced a &quot;feature&quot; which breaks PDL's use of lvalue
  subs for slice assignments when running under the perl debugger, &quot;perl
  -d&quot;. Under the debugger, the above usage gives an error like: &quot;
  Can't return a temporary from lvalue subroutine... &quot; So you must use
  syntax like this:
<div class="Pp"></div>
<pre>
 pdl&gt; ($pdl = $im-&gt;slice(':,(2)')) .= zeroes(5)-&gt;xvals-&gt;float
</pre>
<div class="Pp"></div>
which works both with and without the debugger but is arguably clumsy and
  awkward to read.
<div class="Pp"></div>
Note that there can be a problem with assignments like this when lvalue and
  rvalue piddles refer to overlapping portions of data in the parent piddle:
<div class="Pp"></div>
<pre>
 # revert the elements of the first line of $a
 ($tmp = $a-&gt;slice(':,(1)')) .= $a-&gt;slice('-1:0,(1)');
</pre>
<div class="Pp"></div>
Currently, the parent data on the right side of the assignments is not copied
  before the (internal) assignment loop proceeds. Therefore, the outcome of this
  assignment will depend on the sequence in which elements are assigned and
  almost certainly <i>not</i> do what you wanted. So the semantics are currently
  <b>undefined</b> for now and liable to change anytime. To obtain the desired
  behaviour, use
<div class="Pp"></div>
<pre>
 ($tmp = $a-&gt;slice(':,(1)')) .= $a-&gt;slice('-1:0,(1)')-&gt;copy;
</pre>
<div class="Pp"></div>
which makes a physical copy of the slice or
<div class="Pp"></div>
<pre>
 ($tmp = $a-&gt;slice(':,(1)')) .= $a-&gt;slice('-1:0,(1)')-&gt;sever;
</pre>
<div class="Pp"></div>
which returns the same slice but severs the connection of the slice to its
  parent.
<h2 class="Ss" title="Ss" id="Other_functions_that_manipulate_dimensions"><a class="selflink" href="#Other_functions_that_manipulate_dimensions">Other
  functions that manipulate dimensions</a></h2>
Having talked extensively about the slice function it should be noted that this
  is not the only PDL indexing function. There are additional indexing functions
  which are also useful (especially in the context of threading which we will
  talk about later). Here are a list and some examples how to use them.
<dl class="Bl-tag">
  <dt class="It-tag">&quot;dummy&quot;</dt>
  <dd class="It-tag">inserts a dummy dimension of the size you specify (default
      1) at the chosen location. You can't wait to hear how that is achieved?
      Well, all elements with index &quot;(X,x,Y)&quot;
      (&quot;0&lt;=x&lt;size_of_dummy_dim&quot;) just map to the element with
      index &quot;(X,Y)&quot; of the parent piddle (where &quot;X&quot; and
      &quot;Y&quot; refer to the group of indices before and after the location
      where the dummy dimension was inserted.)
    <div style="height: 1.00em;">&#x00A0;</div>
    This example calculates the x coordinate of the centroid of an image (later
      we will learn that we didn't actually need the dummy dimension thanks to
      the magic of implicit threading; but using dummy dimensions the code would
      also work in a thread-less world; though once you have worked with PDL
      threads you wouldn't want to live without them again).
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # centroid
 ($xd,$yd) = $im-&gt;dims;
 $xc = sum($im*xvals(zeroes($xd))-&gt;dummy(1,$yd))/sum($im);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Let's explain how that works in a little more detail. First, the product:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 $xvs = xvals(zeroes($xd));
 print $xvs-&gt;dummy(1,$yd);      # repeat the line $yd times
 $prod = $im*xvs-&gt;dummy(1,$yd); # form the pixel-wise product with
                                # the repeated line of x-values
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The rest is then summing the results of the pixel-wise product together and
      normalizing with the sum of all pixel values in the original image thereby
      calculating the x-coordinate of the &quot;center of mass&quot; of the
      image (interpreting pixel values as local mass) which is known as the
      centroid of an image.
    <div style="height: 1.00em;">&#x00A0;</div>
    Next is a (from the point of view of memory consumption) very cheap
      conversion from grey-scale to RGB, i.e. every pixel holds now a triple of
      values instead of a scalar. The three values in the triple are,
      fortunately, all the same for a grey image, so that our trick works well
      in that it maps all the three members of the triple to the same source
      element:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # a cheap grey-scale to RGB conversion
 $rgb = $grey-&gt;dummy(0,3)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Unfortunately this trick cannot be used to convert your old B/W photos to
      color ones in the way you'd like. :(
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the memory usage of piddles with dummy dimensions is especially
      sensitive to the internal representation. If the piddle can be represented
      as a virtual affine (``vaffine'') piddle, only the control structures are
      stored. But if $b in
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 $a = zeroes(10000);
 $b = $a-&gt;dummy(1,10000);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    is made physical by some routine, you will find that the memory usage of
      your program has suddenly grown by 100Mb.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;diagonal&quot;</dt>
  <dd class="It-tag">replaces two dimensions (which have to be of equal size) by
      one dimension that references all the elements along the
      &quot;diagonal&quot; along those two dimensions. Here, we have two
      examples which should appear familiar to anyone who has ever done some
      linear algebra. Firstly, make a unity matrix:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # unity matrix
 $e = zeroes(float, 3, 3); # make everything zero
 ($tmp = $e-&gt;diagonal(0,1)) .= 1; # set the elements along the diagonal to 1
 print $e;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Or the other diagonal:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 ($tmp = $e-&gt;slice(':-1:0')-&gt;diagonal(0,1)) .= 2;
 print $e;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    (Did you notice how we used the slice function to revert the sequence of
      lines before setting the diagonal of the new child, thereby setting the
      cross diagonal of the parent ?) Or a mapping from the space of diagonal
      matrices to the field over which the matrices are defined, the trace of a
      matrix:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # trace of a matrix
 $trace = sum($mat-&gt;diagonal(0,1));  # sum all the diagonal elements
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;xchg&quot; and &quot;mv&quot;</dt>
  <dd class="It-tag">xchg exchanges or &quot;transposes&quot; the two specified
      dimensions. A straightforward example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # transpose a matrix (without explicitly reshuffling data and
 # making a copy)
 $prod = $a x $a-&gt;xchg(0,1);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    $prod should now be pretty close to the unity matrix if $a is an orthogonal
      matrix. Often &quot;xchg&quot; will be used in the context of threading
      but more about that later.
    <div style="height: 1.00em;">&#x00A0;</div>
    mv works in a similar fashion. It moves a dimension (specified by its number
      in the parent) to a new position in the new child piddle:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 $b = $a-&gt;mv(4,0);  # make the 5th dimension of $a the first in the
                    # new child $b
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The difference between &quot;xchg&quot; and &quot;mv&quot; is that
      &quot;xchg&quot; only changes the position of two dimensions with each
      other, whereas &quot;mv&quot; inserts the first dimension to the place of
      second, moving the other dimensions around accordingly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;clump&quot;</dt>
  <dd class="It-tag">collapses several dimensions into one. Its only argument
      specifies how many dimensions of the source piddle should be collapsed
      (starting from the first). An (admittedly unrealistic) example is a 3D
      piddle which holds data from a stack of image files that you have just
      read in. However, the data from each image really represents a 1D time
      series and has only been arranged that way because it was digitized with a
      frame grabber. So to have it again as an array of time sequences you say
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 pdl&gt; $seqs = $stack-&gt;clump(2)
 pdl&gt; help vars
 PDL variables in package main::
 Name         Type   Dimension       Flow  State          Mem
 ----------------------------------------------------------------
 $seqs        Double D [8000,50]            -C           0.00Kb                  
 $stack       Double D [100,80,50]          P            3.05Mb
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Unrealistic as it may seem, our confocal microscope software writes data
      (sometimes) this way. But more often you use clump to achieve a certain
      effect when using implicit or explicit threading.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Calls_to_indexing_functions_can_be_chained"><a class="selflink" href="#Calls_to_indexing_functions_can_be_chained">Calls
  to indexing functions can be chained</a></h2>
As you might have noticed in some of the examples above calls to the indexing
  functions can be nicely chained since all of these functions return a newly
  created child object. However, when doing extensive index manipulations in a
  chain be sure to keep track of what you are doing, e.g.
<div class="Pp"></div>
<pre>
 $a-&gt;xchg(0,1)-&gt;mv(0,4)
</pre>
<div class="Pp"></div>
moves the dimension 1 of $a to position 4 since when the second command is
  executed the original dimension 1 has been moved to position 0 of the new
  child that calls the &quot;mv&quot; function. I think you get the idea (in
  spite of my convoluted explanations).
<h2 class="Ss" title="Ss" id="Propagated_assignments_('.=')_and_dummy_dimensions"><a class="selflink" href="#Propagated_assignments_('.=')_and_dummy_dimensions">Propagated
  assignments ('.=') and dummy dimensions</a></h2>
A subtlety related to indexing is the assignment to piddles containing dummy
  dimensions of size greater than 1. These assignments (using &quot;.=&quot;)
  are forbidden since several elements of the lvalue piddle point to the same
  element of the parent. As a consequence the value of those parent elements are
  potentially ambiguous and would depend on the sequence in which the
  implementation makes the assignments to elements. Therefore, an assignment
  like this:
<div class="Pp"></div>
<pre>
 $a = pdl [1,2,3];
 $b = $a-&gt;dummy(1,4);
 $b .= yvals(zeroes(3,4));
</pre>
<div class="Pp"></div>
can produce unexpected results and the results are explicitly <b>undefined</b>
  by PDL because when PDL gets parallel computing features, the current result
  may well change.
<div class="Pp"></div>
From the point of view of dataflow the introduction of greater-size-than-one
  dummy dimensions is regarded as an irreversible transformation (similar to the
  terminology in thermodynamics) which precludes backward propagation of
  assignment to a parent (which you had explicitly requested using the
  &quot;.=&quot; assignment). A similar problem to watch out for occurs in the
  context of threading where sometimes dummy dimensions are created implicitly
  during the thread loop (see below).
<h2 class="Ss" title="Ss" id="Reasons_for_the_parent/child_(or_&quot;pointer&quot;)_concept"><a class="selflink" href="#Reasons_for_the_parent/child_(or_&quot;pointer&quot;)_concept">Reasons
  for the parent/child (or &quot;pointer&quot;) concept</a></h2>
[ this will have to wait a bit ]
<div class="Pp"></div>
<pre>
 XXXXX being memory efficient
 XXXXX in the context of threading
 XXXXX very flexible and powerful way of accessing portions of piddle data
       (in much more general way than sec, etc allow)
 XXXXX efficient implementation
 XXXXX difference to section/at, etc.
</pre>
<h2 class="Ss" title="Ss" id="How_to_make_things_physical_again"><a class="selflink" href="#How_to_make_things_physical_again">How
  to make things physical again</a></h2>
[ XXXXX fill in later when everything has settled a bit more ]
<div class="Pp"></div>
<pre>
 ** When needed (xsub routine interfacing C lib function)
 ** How achieved (-&gt;physical)
 ** How to test (isphysical (explain how it works currently))
 ** -&gt;copy and -&gt;sever
</pre>
<h1 class="Sh" title="Sh" id="Threading"><a class="selflink" href="#Threading">Threading</a></h1>
In the previous paragraph on indexing we have already mentioned the term
  occasionally but now its really time to talk explicitly about
  &quot;threading&quot; with piddles. The term threading has many different
  meanings in different fields of computing. Within the framework of PDL it
  could probably be loosely defined as an implicit looping facility. It is
  implicit because you don't specify anything like enclosing for-loops but
  rather the loops are automatically (or 'magically') generated by PDL based on
  the dimensions of the piddles involved. This should give you a first idea why
  the index/dimension manipulating functions you have met in the previous
  paragraphs are especially important and useful in the context of threading.
  The other ingredient for threading (apart from the piddles involved) is a
  function that is threading aware (generally, these are PDL::PP compiled
  functions) and that the piddles are &quot;threaded&quot; over. So much about
  the terminology and now let's try to shed some light on what it all means.
<h2 class="Ss" title="Ss" id="Implicit_threading_-_a_first_example"><a class="selflink" href="#Implicit_threading_-_a_first_example">Implicit
  threading - a first example</a></h2>
There are two slightly different variants of threading. We start with what we
  call &quot;implicit threading&quot;. Let's pick a practical example that
  involves looping of a function over many elements of a piddle. Suppose we have
  an RGB image that we want to convert to grey-scale. The RGB image is
  represented by a 3-dim piddle &quot;im(3,x,y)&quot; where the first dimension
  contains the three color components of each pixel and &quot;x&quot; and
  &quot;y&quot; are width and height of the image, respectively. Next we need to
  specify how to convert a color-triple at a given pixel into a grey-value (to
  be a realistic example it should represent the relative intensity with which
  our color insensitive eye cells would detect that color to achieve what we
  would call a natural conversion from color to grey-scale). An approximation
  that works quite well is to compute the grey intensity from each RGB triplet
  (r,g,b) as a weighted sum
<div class="Pp"></div>
<pre>
 grey-value = 77/256*r + 150/256*g + 29/256*b =
     inner([77,150,29]/256, [r,g,b])
</pre>
<div class="Pp"></div>
where the last form indicates that we can write this as an inner product of the
  3-vector comprising the weights for red, green and blue components with the
  3-vector containing the color components. Traditionally, we might have written
  a function like the following to process the whole image:
<div class="Pp"></div>
<pre>
 my @dims=$im-&gt;dims;
 # here normally check that first dim has correct size (3), etc
 $grey=zeroes(@dims[1,2]);   # make the piddle for the resulting grey image
 $w = pdl [77,150,29] / 256; # the vector of weights
 for ($j=0;$j&lt;dims[2];$j++) {
    for ($i=0;$i&lt;dims[1];$i++) {
        # compute the pixel value
        $tmp = inner($w,$im-&gt;slice(':,(i),(j)'));
        set($grey,$i,$j,$tmp); # and set it in the grey-scale image
    }
 }
</pre>
<div class="Pp"></div>
Now we write the same using threading (noting that &quot;inner&quot; is a
  threading aware function defined in the PDL::Primitive package)
<div class="Pp"></div>
<pre>
 $grey = inner($im,pdl([77,150,29]/256));
</pre>
<div class="Pp"></div>
We have ended up with a one-liner that automatically creates the piddle $grey
  with the right number and size of dimensions and performs the loops
  automatically (these loops are implemented as fast C code in the internals of
  PDL). Well, we still owe you an explanation how this 'magic' is achieved.
<h2 class="Ss" title="Ss" id="How_does_the_example_work_?"><a class="selflink" href="#How_does_the_example_work_?">How
  does the example work ?</a></h2>
The first thing to note is that every function that is threading aware (these
  are without exception functions compiled from concise descriptions by PDL::PP,
  later just called PP-functions) expects a defined (minimum) number of
  dimensions (we call them core dimensions) from each of its piddle arguments.
  The inner function expects two one-dimensional (input) parameters from which
  it calculates a zero-dimensional (output) parameter. We write that
  symbolically as &quot;inner((n),(n),[o]())&quot; and call it
  &quot;inner&quot;'s <i>signature</i>, where n represents the size of that
  dimension. n being equal in the first and second parameter means that those
  dimensions have to be of equal size in any call. As a different example take
  the outer product which takes two 1D vectors to generate a 2D matrix,
  symbolically written as &quot;outer((n),(m),[o](n,m))&quot;. The
  &quot;[o]&quot; in both examples indicates that this (here third) argument is
  an output argument. In the latter example the dimensions of first and second
  argument don't have to agree but you see how they determine the size of the
  two dimensions of the output piddle.
<div class="Pp"></div>
Here is the point when threading finally enters the game. If you call
  PP-functions with piddles that have <i>more</i> than the required core
  dimensions the first dimensions of the piddle arguments are used as the core
  dimensions and the additional extra dimensions are threaded over. Let us
  demonstrate this first with our example above
<div class="Pp"></div>
<pre>
 $grey = inner($im,$w); # w is the weight vector from above
</pre>
<div class="Pp"></div>
In this case $w is 1D and so supplied just the core dimension, $im is 3D, more
  specifically &quot;(3,x,y)&quot;. The first dimension (of size 3) is the
  required core dimension that matches (as required by inner) the first (and
  only) dimension of $w. The second dimension is the first thread dimension (of
  size &quot;x&quot;) and the third is here the second thread dimension (of size
  &quot;y&quot;). The output piddle is automatically created (as requested by
  setting $grey to &quot;null&quot; prior to invocation). The output dimensions
  are obtained by appending the <i>loop dimensions</i> (here &quot;(x,y)&quot;)
  to the core output dimensions (here 0D) to yield the final dimensions of the
  auto-created piddle (here &quot;0D+2D=2D&quot; to yield a 2D output of size
  &quot;(x,y)&quot;).
<div class="Pp"></div>
So the above command calls the core functionality that computes the inner
  product of two 1D vectors &quot;x*y&quot; times with $w and all 1D slices of
  the form &quot;(':,(i),(j)')&quot; of $im and sets the respective elements of
  the output piddle &quot;$grey(i,j)&quot; to the result of each computation. We
  could write that symbolically as
<div class="Pp"></div>
<pre>
 $grey(0,0) = f($w,$im(:,(0),(0)))
 $grey(1,0) = f($w,$im(:,(1),(0)))
     .
     .
     .
 $grey(x-2,y-1) = f($w,$im(:,(x-2),(y-1)))
 $grey(x-1,y-1) = f($w,$im(:,(x-1),(y-1)))
</pre>
<div class="Pp"></div>
But this is done automatically by PDL without writing any explicit Perl loops.
  We see that the command really creates an output piddle with the right
  dimensions and sets the elements indeed to the result of the computation for
  each pixel of the input image.
<div class="Pp"></div>
When even more piddles and extra dimensions are involved things get a bit more
  complicated. We will first give the general rules how the thread dimensions
  depend on the dimensions of input piddles enabling you to figure out the
  dimensionality of an auto-created output piddle (for any given set of input
  piddles and core dimensions of the PP-function in question). The general rules
  will most likely appear a bit confusing on first sight so that we'll set out
  to illustrate the usage with a set of further examples (which will hopefully
  also demonstrate that there are indeed many practical situations where
  threading comes in extremely handy).
<h2 class="Ss" title="Ss" id="A_call_for_coding_discipline"><a class="selflink" href="#A_call_for_coding_discipline">A
  call for coding discipline</a></h2>
Before we point out the other technical details of threading, please note this
  call for programming discipline when using threading:
<div class="Pp"></div>
In order to preserve human readability, <i>PLEASE</i> comment any nontrivial
  expression in your code involving threading. Most importantly, for any
  subroutine, include information at the beginning about what you expect the
  dimensions to represent (or ranges of dimensions).
<div class="Pp"></div>
As a warning, look at this undocumented function and try to guess what might be
  going on:
<div class="Pp"></div>
<pre>
 sub lookup {
   my ($im,$palette) = @_;
   my $res;
   index($palette-&gt;xchg(0,1),
              $im-&gt;long-&gt;dummy(0,($palette-&gt;dim)[0]),
              ($res=null));
   return $res;
 }
</pre>
<div class="Pp"></div>
Would you agree that it might be difficult to figure out expected dimensions,
  purpose of the routine, etc ? (If you want to find out what this piece of code
  does, see below)
<h2 class="Ss" title="Ss" id="How_to_figure_out_the_loop_dimensions"><a class="selflink" href="#How_to_figure_out_the_loop_dimensions">How
  to figure out the loop dimensions</a></h2>
There are a couple of rules that allow you to figure out number and size of loop
  dimensions (and if the size of your input piddles comply with the threading
  rules). Dimensions of any piddle argument are broken down into two groups in
  the following: Core dimensions (as defined by the PP-function, see <b>Appendix
  B</b> for a list of PDL primitives) and extra dimensions which comprises all
  remaining dimensions of that piddle. For example calling a function
  &quot;func&quot; with the signature &quot;func((n,m),[o](n))&quot; with a
  piddle &quot;a(2,4,7,1,3)&quot; as &quot;f($a,($o = null))&quot; results in
  the semantic splitting of a's dimensions into: core dimensions
  &quot;(2,4)&quot; and extra dimensions &quot;(7,1,3)&quot;.
<dl class="Bl-tag">
  <dt class="It-tag">R0</dt>
  <dd class="It-tag">Core dimensions are identified with the first N dimensions
      of the respective piddle argument (and are required). Any further
      dimensions are extra dimensions and used to determine the loop
    dimensions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">R1</dt>
  <dd class="It-tag">The number of (implicit) loop dimensions is equal to the
      maximal number of extra dimensions taken over the set of piddle
    arguments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">R2</dt>
  <dd class="It-tag">The size of each of the loop dimensions is derived from the
      size of the respective dimensions of the piddle arguments. The size of a
      loop dimension is given by the maximal size found in any of the piddles
      having this extra dimension.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">R3</dt>
  <dd class="It-tag">For all piddles that have a given extra dimension the size
      must be equal to the size of the loop dimension (as determined by the
      previous rule) or 1; otherwise you raise a runtime exception. If the size
      of the extra dimension in a piddle is one it is implicitly treated as a
      dummy dimension of size equal to that loop dim size when performing the
      thread loop.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">R4</dt>
  <dd class="It-tag">If a piddle doesn't have a loop dimension, in the thread
      loop this piddle is treated as if having a dummy dimension of size equal
      to the size of that loop dimension.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">R5</dt>
  <dd class="It-tag">If output auto-creation is used (by setting the relevant
      piddle to &quot;PDL-&gt;null&quot; before invocation) the number of
      dimensions of the created piddle is equal to the sum of the number of core
      output dimensions + number of loop dimensions. The size of the core output
      dimensions is derived from the relevant dimension of input piddles (as
      specified in the function definition) and the sizes of the other
      dimensions are equal to the size of the loop dimension it is derived from.
      The automatically created piddle will be physical (unless dataflow is in
      operation).</dd>
</dl>
<div class="Pp"></div>
In this context, note that you can run into the problem with assignment to
  piddles containing greater-than-one dummy dimensions (see above). Although
  your output piddle(s) didn't contain any dummy dimensions in the first place
  they may end up with implicitly created dummy dimensions according to
  <i>R4</i>.
<div class="Pp"></div>
As an example, suppose we have a (here unspecified) PP-function with the
  signature:
<div class="Pp"></div>
<pre>
 func((m,n),(m,n,o),(m),[o](m,o))
</pre>
<div class="Pp"></div>
and you call it with 3 piddles &quot;a(5,3,10,11)&quot;,
  &quot;b(5,3,2,10,1,12)&quot;, and &quot;c(5,1,11,12)&quot; as
<div class="Pp"></div>
<pre>
 func($a,$b,$c,($d=null))
</pre>
<div class="Pp"></div>
then the number of loop dimensions is 3 (by &quot;R0+R1&quot; from $b and $c)
  with sizes &quot;(10,11,12)&quot; (by R2); the two output core dimensions are
  &quot;(5,2)&quot; (from the signature of func) resulting in a 5-dimensional
  output piddle $c of size &quot;(5,2,10,11,12)&quot; (see R5) and (the
  automatically created) $d is derived from &quot;($a,$b,$c)&quot; in a way that
  can be expressed in pdl pseudo-code as
<div class="Pp"></div>
<pre>
 $d(:,:,i,j,k) .= func($a(:,:,i,j),$b(:,:,:,i,0,k),$c(:,0,j,k))
    with 0&lt;=i&lt;10, 0&lt;=j&lt;=11, 0&lt;=k&lt;12
</pre>
<div class="Pp"></div>
If we analyze the color to grey-scale conversion again with these rules in mind
  we note another great advantage of implicit threading. We can call the
  conversion with a piddle representing a pixel (im(3)), a line of rgb pixels
  (&quot;im(3,x)&quot;), a proper color image (&quot;im(3,x,y)&quot;) or a whole
  stack of RGB images (&quot;im(3,x,y,z)&quot;). As long as $im is of the form
  &quot;(3,...)&quot; the automatically created output piddle will contain the
  right number of dimensions and contain the intensity data as we expect it
  since the loops have been implicitly performed thanks to <i>implicit</i>
  <i>threading</i>. You can easily convince yourself that calling with a color
  pixel $grey is 0D, with a line it turns out 1D grey(x), with an image we get
  &quot;grey(x,y)&quot; and finally we get a converted image stack
  &quot;grey(x,y,z)&quot;.
<div class="Pp"></div>
Let's fill these general rules with some more life by going through a couple of
  further examples. The reader may try to figure out equivalent formulations
  with explicit for-looping and compare the flexibility of those routines using
  implicit threading to the explicit formulation. Furthermore, especially when
  using several thread dimensions it is a useful exercise to check the relative
  speed by doing some benchmark tests (which we still have to do).
<div class="Pp"></div>
First in the row is a slightly reworked centroid example, now coded with
  threading in mind.
<div class="Pp"></div>
<pre>
 # threaded mult to calculate centroid coords, works for stacks as well
 $xc = sumover(($im*xvals(($im-&gt;dims)[0]))-&gt;clump(2)) /
       sumover($im-&gt;clump(2));
</pre>
<div class="Pp"></div>
Let's analyze what's going on step by step. First the product:
<div class="Pp"></div>
<pre>
 $prod = $im*xvals(zeroes(($im-&gt;dims)[0]))
</pre>
<div class="Pp"></div>
This will actually work for $im being one, two, three, and higher dimensional.
  If $im is one-dimensional it's just an ordinary product (in the sense that
  every element of $im is multiplied with the respective element of
  &quot;xvals(...)&quot;), if $im has more dimensions further threading is done
  by adding appropriate dummy dimensions to &quot;xvals(...)&quot; according to
  R4. More importantly, the two sumover operations show a first example of how
  to make use of the dimension manipulating commands. A quick look at sumover's
  signature will remind you that it will only &quot;gobble up&quot; the first
  dimension of a given input piddle. But what if we want to really compute the
  sum over all elements of the first two dimensions? Well, nothing keeps us from
  passing a virtual piddle into sumover which in this case is formed by clumping
  the first two dimensions of the &quot;parent piddle&quot; into one. From the
  point of view of the parent piddle the sum is now computed over the first two
  dimensions, just as we wanted, though sumover has just done the job as
  specified by its signature. Got it ?
<div class="Pp"></div>
Another little finesse of writing the code like that: we intentionally used
  &quot;sumover($pdl-&gt;clump(2))&quot; instead of &quot;sum($pdl)&quot; so
  that we can either pass just an image &quot;(x,y)&quot; or a stack of images
  &quot;(x,y,t)&quot; into this routine and get either just one x-coordiante or
  a vector of x-coordinates (of size t) in return.
<div class="Pp"></div>
Another set of common operations are what one could call &quot;projection
  operations&quot;. These operations take a N-D piddle as input and return a
  (N-1)-D &quot;projected&quot; piddle. These operations are often performed
  with functions like sumover, prodover, minimum and maximum. Using again images
  as examples we might want to calculate the maximum pixel value for each line
  of an image or image stack. We know how to do that
<div class="Pp"></div>
<pre>
 # maxima of lines (as function of line number and time)
 maximum($stack,($ret=null));
</pre>
<div class="Pp"></div>
But what if you want to calculate maxima per column when implicit threading
  always applies the core functionality to the first dimension and threads over
  all others? How can we achieve that instead the core functionality is applied
  to the second dimension and threading is done over the others. Can you guess
  it? Yes, we make a virtual piddle that has the second dimension of the
  &quot;parent piddle&quot; as its first dimension using the &quot;mv&quot;
  command.
<div class="Pp"></div>
<pre>
 # maxima of columns (as function of column number and time)
 maximum($stack-&gt;mv(1,0),($ret=null));
</pre>
<div class="Pp"></div>
and calculating all the sums of sub-slices over the third dimension is now
  almost too easy
<div class="Pp"></div>
<pre>
 # sums of pixels in time (assuming time is the third dim)
 sumover($stack-&gt;mv(2,0),($ret=null));
</pre>
<div class="Pp"></div>
Finally, if you want to apply the operation to all elements (like max over all
  elements or sum over all elements) regardless of the dimensions of the piddle
  in question &quot;clump&quot; comes in handy. As an example look at the
  definition of &quot;sum&quot; (as defined in &quot;Ufunc.pm&quot;):
<div class="Pp"></div>
<pre>
 sub sum {
   PDL::Ufunc::sumover($name-&gt;clump(-1),($tmp=null));
   return $tmp-&gt;at(); # return a Perl number, not a 0D piddle
 }
</pre>
<div class="Pp"></div>
We have already mentioned that all basic operations support threading and
  assignment is no exception. So here are a couple of threaded assignments
<div class="Pp"></div>
<pre>
 pdl&gt; $im = zeroes(byte, 10,20)
 pdl&gt; $line = exp(-rvals(10)**2/9)
 # threaded assignment
 pdl&gt; $im .= $line      # set every line of $im to $line
 pdl&gt; $im2 .= 5         # set every element of $im2 to 5
</pre>
<div class="Pp"></div>
By now you probably see how it works and what it does, don't you?
<div class="Pp"></div>
To finish the examples in this paragraph here is a function to create an RGB
  image from what is called a palette image. The palette image consists of two
  parts: an image of indices into a color lookup table and the color lookup
  table itself. [ describe how it works ] We are going to use a PP-function we
  haven't encoutered yet in the previous examples. It is the aptly named index
  function, signature &quot;((n),(),[o]())&quot; (see <b>Appendix B</b>) with
  the core functionality that &quot;index(pdl (0,2,4,5),2,($ret=null))&quot;
  will return the element with index 2 of the first input piddle. In this case,
  $ret will contain the value 4. So here is the example:
<div class="Pp"></div>
<pre>
 # a threaded index lookup to generate an RGB, or RGBA or YMCK image
 # from a palette image (represented by a lookup table $palette and
 # an color-index image $im)
 # you can say just dummy(0) since the rules of threading make it fit
 pdl&gt; index($palette-&gt;xchg(0,1),
               $im-&gt;long-&gt;dummy(0,($palette-&gt;dim)[0]),
               ($res=null));
</pre>
<div class="Pp"></div>
Let's go through it and explain the steps involved. Assuming we are dealing with
  an RGB lookup-table $palette is of size &quot;(3,x)&quot;. First we exchange
  the dimensions of the palette so that looping is done over the first dimension
  of $palette (of size 3 that represent r, g, and b components). Now looking at
  $im, we add a dummy dimension of size equal to the length of the number of
  components (in the case we are discussing here we could have just used the
  number 3 since we have 3 color components). We can use a dummy dimension since
  for red, green and blue color components we use the same index from the
  original image, e.g. assuming a certain pixel of $im had the value 4 then the
  lookup should produce the triple
<div class="Pp"></div>
<pre>
 [palette(0,4),palette(1,4),palette(2,4)]
</pre>
<div class="Pp"></div>
for the new red, green and blue components of the output image. Hopefully by now
  you have some sort of idea what the above piece of code is supposed to do (it
  is often actually quite complicated to describe in detail how a piece of
  threading code works; just go ahead and experiment a bit to get a better
  feeling for it).
<div class="Pp"></div>
If you have read the threading rules carefully, then you might have noticed that
  we didn't have to explicitly state the size of the dummy dimension that we
  created for $im; when we create it with size 1 (the default) the rules of
  threading make it automatically fit to the desired size (by rule R3, in our
  example the size would be 3 assuming a palette of size &quot;(3,x)&quot;).
  Since situations like this do occur often in practice this is actually why
  rule R3 has been introduced (the part that makes dimensions of size 1 fit to
  the thread loop dim size). So we can just say
<div class="Pp"></div>
<pre>
 pdl&gt; index($palette-&gt;xchg(0,1),$im-&gt;long-&gt;dummy(0),($res=null));
</pre>
<div class="Pp"></div>
Again, you can convince yourself that this routine will create the right output
  if called with a pixel ($im is 0D), a line ($im is 1D), an image ($im is 2D),
  ..., an RGB lookup table (palette is &quot;(3,x)&quot;) and RGBA lookup table
  (palette is &quot;(4,x)&quot;, see e.g. OpenGL). This flexibility is achieved
  by the rules of threading which are made to do the right thing in most
  situations.
<div class="Pp"></div>
To wrap it all up once again, the general idea is as follows. If you want to
  achieve looping over certain dimensions and have the <i>core functionality</i>
  applied to another specified set of dimensions you use the dimension
  manipulating commands to create a (or several) <i>virtual</i> piddle(s) so
  that from the point of view of the <i>parent</i> piddle(s) you get what you
  want (always having the signature of the function in question and R1-R5 in
  mind!). Easy, isn't it ?
<h2 class="Ss" title="Ss" id="Output_auto-creation_and_PP-function_calling_conventions"><a class="selflink" href="#Output_auto-creation_and_PP-function_calling_conventions">Output
  auto-creation and PP-function calling conventions</a></h2>
At this point we have to divert to some technical detail that has to do with the
  general calling conventions of PP-functions and the automatic creation of
  output arguments. Basically, there are two ways of invoking PDL routines,
  namely
<div class="Pp"></div>
<pre>
 $result = func($a,$b);
</pre>
<div class="Pp"></div>
and
<div class="Pp"></div>
<pre>
 func($a,$b,$result);
</pre>
<div class="Pp"></div>
If you are only using implicit threading then the output variable can be
  automatically created by PDL. You flag that to the PP-function by setting the
  output argument to a special kind of piddle that is returned from a call to
  the function &quot;PDL-&gt;null&quot; that returns an essentially
  &quot;empty&quot; piddle (for those interested in details there is a flag in
  the C pdl structure for this). The dimensions of the created piddle are
  determined by the rules of implicit threading: the first dimensions are the
  core output dimensions to which the threading dimensions are appended (which
  are in turn determined by the dimensions of the input piddles as described
  above). So you can say
<div class="Pp"></div>
<pre>
 func($a,$b,($result=PDL-&gt;null));
</pre>
<div class="Pp"></div>
or
<div class="Pp"></div>
<pre>
 $result = func($a,$b)
</pre>
<div class="Pp"></div>
which are <b>exactly</b> equivalent.
<div class="Pp"></div>
Be warned that you can <i>not</i> use output auto-creation when using explicit
  threading (for reasons explained in the following section on <b>explicit
  threading</b>, the second variant of threading).
<div class="Pp"></div>
In &quot;tight&quot; loops you probably want to avoid the implicit creation of a
  temporary piddle in each step of the loop that comes along with the
  &quot;functional&quot; style but rather say
<div class="Pp"></div>
<pre>
 # create output piddle of appropriate size only at first invocation
 $result = null;  
 for (0...$n) {
      func($a,$b,$result); # in all but the first invocation $result
      func2($b);           # is defined and has the right size to
                           # take the output provided $b's dims don't change
      twiddle($result,$a); # do something from $result to $a for iteration
 }
</pre>
<div class="Pp"></div>
The take-home message of this section once more: be aware of the limitation on
  output creation when using <b>explicit threading</b>.
<h2 class="Ss" title="Ss" id="Explicit_threading"><a class="selflink" href="#Explicit_threading">Explicit
  threading</a></h2>
Having so far only talked about the first flavour of threading it is now about
  time to introduce the second variant. Instead of shuffling around dimensions
  all the time and relying on the rules of implicit threading to get it all
  right you sometimes might want to specify in a more explicit way how to
  perform the thread loop. It is probably not too surprising that this variant
  of the game is called <i>explicit threading</i>. Now, before we create the
  wrong impression: it is not either <i>implicit</i> or <i>explicit</i>; the two
  flavours do mix. But more about that later.
<div class="Pp"></div>
The two most used functions with explicit threading are thread and unthread. We
  start with an example that illustrates typical usage of the former:
<div class="Pp"></div>
<pre>
 [ # ** this is the worst possible example to start with ]
 #  but can be used to show that $mat += $line is different from
 #                               $mat-&gt;thread(0) += $line
 # explicit threading to add a vector to each column of a matrix
 pdl&gt; $mat  = zeroes(4,3)
 pdl&gt; $line = pdl (3.1416,2,-2)
 pdl&gt; ($tmp = $mat-&gt;thread(0)) += $line
</pre>
<div class="Pp"></div>
In this example, &quot;$mat-&gt;thread(0)&quot; tells PDL that you want the
  second dimension of this piddle to be threaded over first leading to a thread
  loop that can be expressed as
<div class="Pp"></div>
<pre>
 for (j=0; j&lt;3; j++) {
    for (i=0; i&lt;4; i++) {
        mat(i,j) += src(j);
    }
 }
</pre>
<div class="Pp"></div>
&quot;thread&quot; takes a list of numbers as arguments which explicitly specify
  which dimensions to thread over first. With the introduction of explicit
  threading the dimensions of a piddle are conceptually split into three
  different groups the latter two of which we have already encountered: thread
  dimensions, core dimensions and extra dimensions.
<div class="Pp"></div>
Conceptually, it is best to think of those dimensions of a piddle that have been
  specified in a call to &quot;thread&quot; as being taken away from the set of
  normal dimensions and put on a separate stack. So assuming we have a piddle
  &quot;a(4,7,2,8)&quot; saying
<div class="Pp"></div>
<pre>
 $b = $a-&gt;thread(2,1)
</pre>
<div class="Pp"></div>
creates a new virtual piddle of dimension &quot;b(4,8)&quot; (which we call the
  remaining dims) that also has 2 thread dimensions of size &quot;(2,7)&quot;.
  For the purposes of this document we write that symbolically as
  &quot;b(4,8){2,7}&quot;. An important difference to the previous examples
  where only implicit threading was used is the fact that the core dimensions
  are matched against the <i>remaining dimensions</i> which are not necessarily
  the first dimensions of the piddle. We will now specify how the presence of
  thread dimensions changes the rules R1-R5 for thread loops (which apply to the
  special case where none of the piddle arguments has any thread dimensions).
<dl class="Bl-tag">
  <dt class="It-tag">T0</dt>
  <dd class="It-tag">Core dimensions are matched against the first n
      <i>remaining dimensions</i> of the piddle argument (note the difference to
      R1). Any further <i>remaining dimensions</i> are <i>extra dimensions</i>
      and are used to determine the <i>implicit loop dimensions</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T1a</dt>
  <dd class="It-tag">The number of <i>implicit loop dimensions</i> is equal to
      the maximal number of extra dimensions taken over the set of piddle
      arguments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T1b</dt>
  <dd class="It-tag">The number of <i>explicit loop dimensions</i> is equal to
      the maximal number of thread dimensions taken over the set of piddle
      arguments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T1c</dt>
  <dd class="It-tag">The total number of <i>loop dimensions</i> is equal to the
      sum of <i>explicit loop dimensions</i> and <i>implicit loop
      dimensions</i>. In the thread loop, <i>explicit loop dimensions</i> are
      threaded over first followed by <i>implicit loop dimensions</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T2</dt>
  <dd class="It-tag">The size of each of the <i>loop dimensions</i> is derived
      from the size of the respective dimensions of the piddle arguments. It is
      given by the maximal size found in any piddles having this thread
      dimension (for <i>explicit loop dimensions</i>) or extra dimension (for
      <i>implicit loop dimensions</i>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T3</dt>
  <dd class="It-tag">This rule applies to any <i>explicit loop dimension</i> as
      well as any <i>implicit loop dimension</i>. For all piddles that have a
      given <i>thread/extra dimension</i> the size must be equal to the size of
      the respective <i>explicit/implicit loop dimension</i> or 1; otherwise you
      raise a runtime exception. If the size of a <i>thread/extra dimension</i>
      of a piddle is one it is implicitly treated as a dummy dimension of size
      equal to the <i>explicit/implicit loop dimension</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T4</dt>
  <dd class="It-tag">If a piddle doesn't have a <i>thread/extra dimension</i>
      that corresponds to an <i>explicit/implicit loop dimension</i>, in the
      thread loop this piddle is treated as if having a dummy dimension of size
      equal to the size of that loop dimension.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T4a</dt>
  <dd class="It-tag">All piddles that do have <i>thread dimensions</i> must have
      the same number of thread dimensions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T5</dt>
  <dd class="It-tag">Output auto-creation cannot be used if any of the piddle
      arguments has any <i>thread dimensions</i>. Otherwise R5 applies.</dd>
</dl>
<div class="Pp"></div>
The same restrictions apply with regard to implicit dummy dimensions (created by
  application of T4) as already mentioned in the section on implicit threading:
  if any of the output piddles has an (explicit or implicitly created)
  greater-than-one dummy dimension a runtime exception will be raised.
<div class="Pp"></div>
Let us demonstrate these rules at work in a generic case. Suppose we have a
  (here unspecified) PP-function with the signature:
<div class="Pp"></div>
<pre>
 func((m,n),(m),(),[o](m))
</pre>
<div class="Pp"></div>
and you call it with 3 piddles &quot;a(5,3,10,11)&quot;,
  &quot;b(3,5,10,1,12)&quot;, &quot;c(10)&quot; and an output piddle
  &quot;d(3,11,5,10,12)&quot; (which can here <i>not</i> be automatically
  created) as
<div class="Pp"></div>
<pre>
 func($a-&gt;thread(1,3),$b-&gt;thread(0,3),$c,$d-&gt;thread(0,1))
</pre>
<div class="Pp"></div>
From the signature of func and the above call the piddles split into the
  following groups of core, extra and thread dimensions (written in the form
  &quot;pdl(core dims){thread dims}[extra dims]&quot;):
<div class="Pp"></div>
<pre>
 a(5,10){3,11}[] b(5){3,1}[10,12] c(){}[10] d(5){3,11}[10,12]
</pre>
<div class="Pp"></div>
With this to help us along (it is in general helpful to write the arguments down
  like this when you start playing with threading and want to keep track of what
  is going on) we further deduce that the number of explicit loop dimensions is
  2 (by T1b from $a and $b) with sizes &quot;(3,11)&quot; (by T2); 2 implicit
  loop dimensions (by T1a from $b and $d) of size &quot;(10,12)&quot; (by T2)
  and the elements of are computed from the input piddles in a way that can be
  expressed in pdl pseudo-code as
<div class="Pp"></div>
<pre>
 for (l=0;l&lt;12;l++)
  for (k=0;k&lt;10;k++)
   for (j=0;j&lt;11;j++)         effect of treating it as dummy dim (index j)
    for (i=0;i&lt;3;i++)                         |
       d(i,j,:,k,l) = func(a(:,i,:,j),b(i,:,k,0,l),c(k))
</pre>
<div class="Pp"></div>
Ugh, this example was really not easy in terms of bookkeeping. It serves mostly
  as an example how to figure out what's going on when you encounter a
  complicated looking expression. But now it is really time to show that
  threading is useful by giving some more of our so called &quot;practical&quot;
  examples.
<div class="Pp"></div>
[ The following examples will need some additional explanations in the future.
  For the moment please try to live with the comments in the code fragments. ]
<div class="Pp"></div>
Example 1:
<div class="Pp"></div>
<pre>
 *** inverse of matrix represented by eigvecs and eigvals
 ** given a symmetrical matrix M = A^T x diag(lambda_i) x A
 **    =&gt;  inverse M^-1 = A^T x diag(1/lambda_i) x A
 ** first $tmp = diag(1/lambda_i)*A
 ** then  A^T * $tmp by threaded inner product
 # index handling so that matrices print correct under pdl
 $inv .= $evecs*0;  # just copy to get appropriately sized output
 $tmp .= $evecs;    # initialise, no back-propagation
 ($tmp2 = $tmp-&gt;thread(0)) /= $evals;    #  threaded division
 # and now a matrix multiplication in disguise
 PDL::Primitive::inner($evecs-&gt;xchg(0,1)-&gt;thread(-1,1),
                       $tmp-&gt;thread(0,-1),
                       $inv-&gt;thread(0,1));
 # alternative for matrix mult using implicit threading,
 # first xchg only for transpose
 PDL::Primitive::inner($evecs-&gt;xchg(0,1)-&gt;dummy(1),
                       $tmp-&gt;xchg(0,1)-&gt;dummy(2),
                       ($inv=null));
</pre>
<div class="Pp"></div>
Example 2:
<div class="Pp"></div>
<pre>
 # outer product by threaded multiplication
 # stress that we need to do it with explicit call to my_biop1
 # when using explicit threading
 $res=zeroes(($a-&gt;dims)[0],($b-&gt;dims)[0]);
 my_biop1($a-&gt;thread(0,-1),$b-&gt;thread(-1,0),$res-&gt;(0,1),&quot;*&quot;);
 # similar thing by implicit threading with auto-created piddle
 $res = $a-&gt;dummy(1) * $b-&gt;dummy(0);
</pre>
<div class="Pp"></div>
Example 3:
<div class="Pp"></div>
<pre>
 # different use of thread and unthread to shuffle a number of
 # dimensions in one go without lots of calls to -&gt;xchg and -&gt;mv
 # use thread/unthread to shuffle dimensions around
 # just try it out and compare the child piddle with its parent
 $trans = $a-&gt;thread(4,1,0,3,2)-&gt;unthread;
</pre>
<div class="Pp"></div>
Example 4:
<div class="Pp"></div>
<pre>
 # calculate a couple of bounding boxes
 # $bb will hold BB as [xmin,xmax],[ymin,ymax],[zmin,zmax]
 # we use again thread and unthread to shuffle dimensions around
 pdl&gt; $bb = zeroes(double, 2,3 );
 pdl&gt; minimum($vertices-&gt;thread(0)-&gt;clump-&gt;unthread(1), $bb-&gt;slice('(0),:'));
 pdl&gt; maximum($vertices-&gt;thread(0)-&gt;clump-&gt;unthread(1), $bb-&gt;slice('(1),:'));
</pre>
<div class="Pp"></div>
Example 5:
<div class="Pp"></div>
<pre>
 # calculate a self-rationed (i.e. self normalized) sequence of images
 # uses explicit threading and an implicitly threaded division
 $stack = read_image_stack();
 # calculate the average (per pixel average) of the first $n+1 images
 $aver = zeroes([stack-&gt;dims]-&gt;[0,1]);  # make the output piddle
 sumover($stack-&gt;slice(&quot;:,:,0:$n&quot;)-&gt;thread(0,1),$aver);
 $aver /= ($n+1);
 $stack /= $aver;  # normalize the stack by doing a threaded division
 # implicit versus explicit
 # alternatively calculate $aver with implicit threading and auto-creation
 sumover($stack-&gt;slice(&quot;:,:,0:$n&quot;)-&gt;mv(2,0),($aver=null));
 $aver /= ($n+1);
 #
</pre>
<h2 class="Ss" title="Ss" id="Implicit_versus_explicit_threading"><a class="selflink" href="#Implicit_versus_explicit_threading">Implicit
  versus explicit threading</a></h2>
In this paragraph we are going to illustrate when explicit threading is
  preferable over implicit threading and vice versa. But then again, this is
  probably not the best way of putting the case since you already know: the two
  flavours do mix. So, it's more about how to get the best of both worlds and,
  anyway, in the best of Perl traditions: TIMTOWTDI !
<div class="Pp"></div>
[ Sorry, this still has to be filled in in a later release; either refer to
  above examples or choose some new ones ]
<div class="Pp"></div>
Finally, this may be a good place to justify all the technical detail we have
  been going on about for a couple of pages: why threading ?
<div class="Pp"></div>
Well, code that uses threading should be (considerably) faster than code that
  uses explicit for-loops (or similar Perl constructs) to achieve the same
  functionality. Especially on supercomputers (with vector computing
  facilities/parallel processing) PDL threading will be implemented in a way
  that takes advantage of the additional facilities of these machines.
  Furthermore, it is a conceptually simply construct (though technical details
  might get involved at times) and can <i>greatly</i> reduce the syntactical
  complexity of PDL code (but keep the admonition for documentation in mind).
  Once you are comfortable with the <i>threading</i> way of thinking (and
  coding) it shouldn't be too difficult to understand code that somebody else
  has written than (provided he gave you an idea what expected input dimensions
  are, etc.). As a general tip to increase the performance of your code: if you
  have to introduce a loop into your code try to reformulate the problem so that
  you can use threading to perform the loop (as with anything there are
  exceptions to this rule of thumb; but the authors of this document tend to
  think that these are rare cases ;).
<h1 class="Sh" title="Sh" id="PDL::PP"><a class="selflink" href="#PDL::PP">PDL::PP</a></h1>
<h2 class="Ss" title="Ss" id="An_easy_way_to_define_functions_that_are_aware_of_indexing_and_threading_(and_the_universe_and_everything)"><a class="selflink" href="#An_easy_way_to_define_functions_that_are_aware_of_indexing_and_threading_(and_the_universe_and_everything)">An
  easy way to define functions that are aware of indexing and threading (and the
  universe and everything)</a></h2>
PDL:PP is part of the PDL distribution. It is used to generate functions that
  are aware of indexing and threading rules from very concise descriptions. It
  can be useful for you if you want to write your own functions or if you want
  to interface functions from an external library so that they support indexing
  and threading (and maybe dataflow as well, see PDL::Dataflow). For further
  details check PDL::PP.
<h1 class="Sh" title="Sh" id="Appendix_A"><a class="selflink" href="#Appendix_A">Appendix
  A</a></h1>
<h2 class="Ss" title="Ss" id="Affine_transformations_-_a_special_class_of_simple_and_powerful_transformations"><a class="selflink" href="#Affine_transformations_-_a_special_class_of_simple_and_powerful_transformations">Affine
  transformations - a special class of simple and powerful
  transformations</a></h2>
[ This is also something to be added in future releases. Do we already have the
  general make_affine routine in PDL ? It is possible that we will reference
  another appropriate man page from here ]
<h1 class="Sh" title="Sh" id="Appendix_B"><a class="selflink" href="#Appendix_B">Appendix
  B</a></h1>
<h2 class="Ss" title="Ss" id="signatures_of_standard_PDL::PP_compiled_functions"><a class="selflink" href="#signatures_of_standard_PDL::PP_compiled_functions">signatures
  of standard PDL::PP compiled functions</a></h2>
A selection of signatures of PDL primitives to show how many dimensions PP
  compiled functions gobble up (and therefore you can figure out what will be
  threaded over). Most of those functions are the basic ones defined in
  &quot;primitive.pd&quot;
<div class="Pp"></div>
<pre>
 # functions in primitive.pd
 #
 sumover        ((n),[o]())
 prodover       ((n),[o]())
 axisvalues     ((n))                                   inplace
 inner          ((n),(n),[o]())
 outer          ((n),(m),[o](n,m))
 innerwt        ((n),(n),(n),[o]())
 inner2         ((m),(m,n),(n),[o]())
 inner2t        ((j,n),(n,m),(m,k),[o]())
 index          (1D,0D,[o])
 minimum        (1D,[o])
 maximum        (1D,[o])
 wstat          ((n),(n),(),[o],())
 assgn          ((),())
 # basic operations
 binary operations ((),(),[o]())
 unary operations  ((),[o]())
</pre>
<h1 class="Sh" title="Sh" id="AUTHOR_&amp;_COPYRIGHT"><a class="selflink" href="#AUTHOR_&amp;_COPYRIGHT">AUTHOR
  &amp; COPYRIGHT</a></h1>
Copyright (C) 1997 Christian Soeller (c.soeller@auckland.ac.nz) &amp; Tuomas J.
  Lukka (lukka@fas.harvard.edu). All rights reserved. Although destined for
  release as a man page with the standard PDL distribution, it is not public
  domain. Permission is granted to freely distribute verbatim copies of this
  document provided that no modifications outside of formatting be made, and
  that this notice remain intact. You are permitted and encouraged to use its
  code and derivatives thereof in your own source code for fun or for profit as
  you see fit.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-01-14</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
