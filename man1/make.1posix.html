<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:23:38 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MAKE(1POSIX) POSIX Programmer&rsquo;s Manual
MAKE(1POSIX)</p>

<p style="margin-top: 1em">PROLOG <br>
This manual page is part of the POSIX Programmer&rsquo;s
Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of <br>
Linux behavior), or the interface may not be implemented on
Linux.</p>

<p style="margin-top: 1em">NAME <br>
make &acirc; maintain, update, and regenerate groups of
programs (DEVELOPMENT)</p>

<p style="margin-top: 1em">SYNOPSIS <br>
make [&acirc;einpqrst] [&acirc;f makefile]...
[&acirc;k|&acirc;S] [macro=value...] <br>
[target_name...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The make utility shall update files that are derived from
other files. A typical case is one where object files are
derived from the corresponding source files. The make
utility <br>
examines time relationships and shall update those derived
files (called targets) that have modified times earlier than
the modified times of the files (called prerequisites) <br>
from which they are derived. A description file (makefile)
contains a description of the relationships between files,
and the commands that need to be executed to update the <br>
targets to reflect changes in their prerequisites. Each
specification, or rule, shall consist of a target, optional
prerequisites, and optional commands to be executed when a
<br>
prerequisite is newer than the target. There are two types
of rule:</p>

<p style="margin-top: 1em">1. Inference rules, which have
one target name with at least one &lt;period&gt;
(&rsquo;.&rsquo;) and no &lt;slash&gt; (&rsquo;/&rsquo;)</p>

<p style="margin-top: 1em">2. Target rules, which can have
more than one target name</p>

<p style="margin-top: 1em">In addition, make shall have a
collection of built-in macros and inference rules that infer
prerequisite relationships to simplify maintenance of
programs.</p>

<p style="margin-top: 1em">To receive exactly the behavior
described in this section, the user shall ensure that a
portable makefile shall:</p>

<p style="margin-top: 1em">* Include the special target
.POSIX</p>

<p style="margin-top: 1em">* Omit any special target
reserved for implementations (a leading period followed by
uppercase letters) that has not been specified by this
section</p>

<p style="margin-top: 1em">The behavior of make is
unspecified if either or both of these conditions are not
met.</p>

<p style="margin-top: 1em">OPTIONS <br>
The make utility shall conform to the Base Definitions
volume of POSIX.1&acirc;2008, Section 12.2, Utility Syntax
Guidelines, except for Guideline 9.</p>

<p style="margin-top: 1em">The following options shall be
supported:</p>

<p style="margin-top: 1em">&acirc;e Cause environment
variables, including those with null values, to override
macro assignments within makefiles.</p>

<p style="margin-top: 1em">&acirc;f makefile <br>
Specify a different makefile. The argument makefile is a
pathname of a description file, which is also referred to as
the makefile. A pathname of &rsquo;&acirc;&rsquo; shall
denote the <br>
standard input. There can be multiple instances of this
option, and they shall be processed in the order specified.
The effect of specifying the same option-argument <br>
more than once is unspecified.</p>

<p style="margin-top: 1em">&acirc;i Ignore error codes
returned by invoked commands. This mode is the same as if
the special target .IGNORE were specified without
prerequisites.</p>

<p style="margin-top: 1em">&acirc;k Continue to update
other targets that do not depend on the current target if a
non-ignored error occurs while executing the commands to
bring a target up-to-date.</p>

<p style="margin-top: 1em">&acirc;n Write commands that
would be executed on standard output, but do not execute
them. However, lines with a &lt;plus-sign&gt;
(&rsquo;+&rsquo;) prefix shall be executed. In this mode,
lines <br>
with an at-sign (&rsquo;@&rsquo;) character prefix shall be
written to standard output.</p>

<p style="margin-top: 1em">&acirc;p Write to standard
output the complete set of macro definitions and target
descriptions. The output format is unspecified.</p>

<p style="margin-top: 1em">&acirc;q Return a zero exit
value if the target file is up-to-date; otherwise, return an
exit value of 1. Targets shall not be updated if this option
is specified. However, a <br>
makefile command line (associated with the targets) with a
&lt;plus-sign&gt; (&rsquo;+&rsquo;) prefix shall be
executed.</p>

<p style="margin-top: 1em">&acirc;r Clear the suffix list
and do not use the built-in rules.</p>

<p style="margin-top: 1em">&acirc;S Terminate make if an
error occurs while executing the commands to bring a target
up-to-date. This shall be the default and the opposite of
&acirc;k.</p>

<p style="margin-top: 1em">&acirc;s Do not write makefile
command lines or touch messages (see &acirc;t) to standard
output before executing. This mode shall be the same as if
the special target .SILENT were <br>
specified without prerequisites.</p>

<p style="margin-top: 1em">&acirc;t Update the modification
time of each target as though a touch target had been
executed. Targets that have prerequisites but no commands
(see Target Rules), or that are <br>
already up-to-date, shall not be touched in this manner.
Write messages to standard output for each target file
indicating the name of the file and that it was <br>
touched. Normally, the makefile command lines associated
with each target are not executed. However, a command line
with a &lt;plus-sign&gt; (&rsquo;+&rsquo;) prefix shall be
executed.</p>

<p style="margin-top: 1em">Any options specified in the
MAKEFLAGS environment variable shall be evaluated before any
options specified on the make utility command line. If the
&acirc;k and &acirc;S options are both <br>
specified on the make utility command line or by the
MAKEFLAGS environment variable, the last option specified
shall take precedence. If the &acirc;f or &acirc;p options
appear in the MAKE&acirc; <br>
FLAGS environment variable, the result is undefined.</p>

<p style="margin-top: 1em">OPERANDS <br>
The following operands shall be supported:</p>

<p style="margin-top: 1em">target_name <br>
Target names, as defined in the EXTENDED DESCRIPTION
section. If no target is specified, while make is processing
the makefiles, the first target that make encounters <br>
that is not a special target or an inference rule shall be
used.</p>

<p style="margin-top: 1em">macro=value <br>
Macro definitions, as defined in Macros.</p>

<p style="margin-top: 1em">If the target_name and
macro=value operands are intermixed on the make utility
command line, the results are unspecified.</p>

<p style="margin-top: 1em">STDIN <br>
The standard input shall be used only if the makefile
option-argument is &rsquo;&acirc;&rsquo;. See the INPUT
FILES section.</p>

<p style="margin-top: 1em">INPUT FILES <br>
The input file, otherwise known as the makefile, is a text
file containing rules, macro definitions, and comments. See
the EXTENDED DESCRIPTION section.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
The following environment variables shall affect the
execution of make:</p>

<p style="margin-top: 1em">LANG Provide a default value for
the internationalization variables that are unset or null.
(See the Base Definitions volume of POSIX.1&acirc;2008,
Section 8.2, Internationaliza&acirc; <br>
tion Variables for the precedence of internationalization
variables used to determine the values of locale
categories.)</p>

<p style="margin-top: 1em">LC_ALL If set to a non-empty
string value, override the values of all the other
internationalization variables.</p>

<p style="margin-top: 1em">LC_CTYPE Determine the locale
for the interpretation of sequences of bytes of text data as
characters (for example, single-byte as opposed to
multi-byte characters in arguments <br>
and input files).</p>

<p style="margin-top: 1em">LC_MESSAGES <br>
Determine the locale that should be used to affect the
format and contents of diagnostic messages written to
standard error.</p>

<p style="margin-top: 1em">MAKEFLAGS <br>
This variable shall be interpreted as a character string
representing a series of option characters to be used as the
default options. The implementation shall accept <br>
both of the following formats (but need not accept them when
intermixed):</p>

<p style="margin-top: 1em">* The characters are option
letters without the leading &lt;hyphen&gt; characters or
&lt;blank&gt; separation used on a make utility command
line.</p>

<p style="margin-top: 1em">* The characters are formatted
in a manner similar to a portion of the make utility command
line: options are preceded by &lt;hyphen&gt; characters and
&lt;blank&gt;-separated as <br>
described in the Base Definitions volume of
POSIX.1&acirc;2008, Section 12.2, Utility Syntax Guidelines.
The macro=value macro definition operands can also be
included. <br>
The difference between the contents of MAKEFLAGS and the
make utility command line is that the contents of the
variable shall not be subjected to the word expan&acirc;
<br>
sions (see Section 2.6, Word Expansions) associated with
parsing the command line values.</p>

<p style="margin-top: 1em">NLSPATH Determine the location
of message catalogs for the processing of LC_MESSAGES.</p>

<p style="margin-top: 1em">PROJECTDIR <br>
Provide a directory to be used to search for SCCS files not
found in the current directory. In all of the following
cases, the search for SCCS files is made in the <br>
directory SCCS in the identified directory. If the value of
PROJECTDIR begins with a &lt;slash&gt;, it shall be
considered an absolute pathname; otherwise, the value of
PRO&acirc; <br>
JECTDIR is treated as a user name and that user&rsquo;s
initial working directory shall be examined for a
subdirectory src or source. If such a directory is found, it
shall <br>
be used. Otherwise, the value is used as a relative
pathname.</p>

<p style="margin-top: 1em">If PROJECTDIR is not set or has
a null value, the search for SCCS files shall be made in the
directory SCCS in the current directory.</p>

<p style="margin-top: 1em">The setting of PROJECTDIR
affects all files listed in the remainder of this utility
description for files with a component named SCCS.</p>

<p style="margin-top: 1em">The value of the SHELL
environment variable shall not be used as a macro and shall
not be modified by defining the SHELL macro in a makefile or
on the command line. All other <br>
environment variables, including those with null values,
shall be used as macros, as defined in Macros.</p>

<p style="margin-top: 1em">ASYNCHRONOUS EVENTS <br>
If not already ignored, make shall trap SIGHUP, SIGTERM,
SIGINT, and SIGQUIT and remove the current target unless the
target is a directory or the target is a prerequisite of the
<br>
special target .PRECIOUS or unless one of the &acirc;n,
&acirc;p, or &acirc;q options was specified. Any targets
removed in this manner shall be reported in diagnostic
messages of unspecified for&acirc; <br>
mat, written to standard error. After this cleanup process,
if any, make shall take the standard action for all other
signals.</p>

<p style="margin-top: 1em">STDOUT <br>
The make utility shall write all commands to be executed to
standard output unless the &acirc;s option was specified,
the command is prefixed with an at-sign, or the special
target <br>
.SILENT has either the current target as a prerequisite or
has no prerequisites. If make is invoked without any work
needing to be done, it shall write a message to standard
out&acirc; <br>
put indicating that no action was taken. If the &acirc;t
option is present and a file is touched, make shall write to
standard output a message of unspecified format indicating
that <br>
the file was touched, including the filename of the
file.</p>

<p style="margin-top: 1em">STDERR <br>
The standard error shall be used only for diagnostic
messages.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
Files can be created when the &acirc;t option is present.
Additional files can also be created by the utilities
invoked by make.</p>

<p style="margin-top: 1em">EXTENDED DESCRIPTION <br>
The make utility attempts to perform the actions required to
ensure that the specified targets are up-to-date. A target
is considered out-of-date if it is older than any of its
<br>
prerequisites or if it does not exist. The make utility
shall treat all prerequisites as targets themselves and
recursively ensure that they are up-to-date, processing them
in <br>
the order in which they appear in the rule. The make utility
shall use the modification times of files to determine
whether the corresponding targets are out-of-date.</p>

<p style="margin-top: 1em">After make has ensured that all
of the prerequisites of a target are up-to-date and if the
target is out-of-date, the commands associated with the
target entry shall be executed. <br>
If there are no commands listed for the target, the target
shall be treated as up-to-date.</p>

<p style="margin-top: 1em">Makefile Syntax <br>
A makefile can contain rules, macro definitions (see
Macros), include lines, and comments. There are two kinds of
rules: inference rules and target rules. The make utility
shall <br>
contain a set of built-in inference rules. If the &acirc;r
option is present, the built-in rules shall not be used and
the suffix list shall be cleared. Additional rules of both
types <br>
can be specified in a makefile. If a rule is defined more
than once, the value of the rule shall be that of the last
one specified. Macros can also be defined more than once,
and <br>
the value of the macro is specified in Macros. Comments
start with a &lt;number-sign&gt; (&rsquo;#&rsquo;) and
continue until an unescaped &lt;newline&gt; is reached.</p>

<p style="margin-top: 1em">By default, the following files
shall be tried in sequence: ./makefile and ./Makefile. If
neither ./makefile or ./Makefile are found, other
implementation-defined files may also <br>
be tried. On XSI-conformant systems, the additional files
./s.makefile, SCCS/s.makefile, ./s.Makefile, and
SCCS/s.Makefile shall also be tried.</p>

<p style="margin-top: 1em">The &acirc;f option shall direct
make to ignore any of these default files and use the
specified argument as a makefile instead. If the
&rsquo;&acirc;&rsquo; argument is specified, standard input
shall <br>
be used.</p>

<p style="margin-top: 1em">The term makefile is used to
refer to any rules provided by the user, whether in
./makefile or its variants, or specified by the &acirc;f
option.</p>

<p style="margin-top: 1em">The rules in makefiles shall
consist of the following types of lines: target rules,
including special targets (see Target Rules), inference
rules (see Inference Rules), macro <br>
definitions (see Macros), empty lines, and comments.</p>

<p style="margin-top: 1em">Target and Inference Rules may
contain command lines. Command lines can have a prefix that
shall be removed before execution (see Makefile
Execution).</p>

<p style="margin-top: 1em">When an escaped &lt;newline&gt;
(one preceded by a &lt;backslash&gt;) is found anywhere in
the makefile except in a command line, an include line, or a
line immediately preceding an include <br>
line, it shall be replaced, along with any leading white
space on the following line, with a single &lt;space&gt;.
When an escaped &lt;newline&gt; is found in a command line
in a makefile, <br>
the command line shall contain the &lt;backslash&gt;, the
&lt;newline&gt;, and the next line, except that the first
character of the next line shall not be included if it is a
&lt;tab&gt;. When <br>
an escaped &lt;newline&gt; is found in an include line or in
a line immediately preceding an include line, the behavior
is unspecified.</p>

<p style="margin-top: 1em">Include Lines <br>
If the word include appears at the beginning of a line and
is followed by one or more &lt;blank&gt; characters, the
string formed by the remainder of the line shall be
processed as <br>
follows to produce a pathname:</p>

<p style="margin-top: 1em">* The trailing &lt;newline&gt;
and any comment shall be discarded. If the resulting string
contains any double-quote characters (&rsquo;&quot;&rsquo;)
the behavior is unspecified.</p>

<p style="margin-top: 1em">* The resulting string shall be
processed for macro expansion (see Macros.</p>

<p style="margin-top: 1em">* Any &lt;blank&gt; characters
that appear after the first non-&lt;blank&gt; shall be used
as separators to divide the macro-expanded string into
fields. It is unspecified whether any <br>
other white-space characters are also used as separators. It
is unspecified whether pathname expansion (see Section 2.13,
Pattern Matching Notation) is also performed.</p>

<p style="margin-top: 1em">* If the processing of
separators and optional pathname expansion results in either
zero or two or more non-empty fields, the behavior is
unspecified. If it results in one non- <br>
empty field, that field is taken as the pathname.</p>

<p style="margin-top: 1em">If the pathname does not begin
with a &rsquo;/&rsquo; it shall be treated as relative to
the current working directory of the process, not relative
to the directory containing the makefile. <br>
If the file does not exist in this location, it is
unspecified whether additional directories are searched.</p>

<p style="margin-top: 1em">The contents of the file
specified by the pathname shall be read and processed as if
they appeared in the makefile in place of the include line.
If the file ends with an escaped <br>
&lt;newline&gt; the behavior is unspecified.</p>

<p style="margin-top: 1em">The file may itself contain
further include lines. Implementations shall support nesting
of include files up to a depth of at least 16.</p>

<p style="margin-top: 1em">Makefile Execution <br>
Makefile command lines shall be processed one at a time.</p>

<p style="margin-top: 1em">Makefile command lines can have
one or more of the following prefixes: a &lt;hyphen&gt;
(&rsquo;-&rsquo;), an at-sign (&rsquo;@&rsquo;), or a
&lt;plus-sign&gt; (&rsquo;+&rsquo;). These shall modify the
way in which make pro&acirc; <br>
cesses the command.</p>

<p style="margin-top: 1em">&acirc; If the command prefix
contains a &lt;hyphen&gt;, or the &acirc;i option is
present, or the special target .IGNORE has either the
current target as a prerequisite or has no prerequi&acirc;
<br>
sites, any error found while executing the command shall be
ignored.</p>

<p style="margin-top: 1em">@ If the command prefix contains
an at-sign and the make utility command line &acirc;n option
is not specified, or the &acirc;s option is present, or the
special target .SILENT has <br>
either the current target as a prerequisite or has no
prerequisites, the command shall not be written to standard
output before it is executed.</p>

<p style="margin-top: 1em">+ If the command prefix contains
a &lt;plus-sign&gt;, this indicates a makefile command line
that shall be executed even if &acirc;n, &acirc;q, or
&acirc;t is specified.</p>

<p style="margin-top: 1em">An execution line is built from
the command line by removing any prefix characters. Except
as described under the at-sign prefix, the execution line
shall be written to the stan&acirc; <br>
dard output, optionally preceded by a &lt;tab&gt;. The
execution line shall then be executed by a shell as if it
were passed as the argument to the system() interface,
except that if <br>
errors are not being ignored then the shell &acirc;e option
shall also be in effect. If errors are being ignored for the
command (as a result of the &acirc;i option, a
&rsquo;&acirc;&rsquo; command prefix, or <br>
a .IGNORE special target), the shell &acirc;e option shall
not be in effect. The environment for the command being
executed shall contain all of the variables in the
environment of <br>
make.</p>

<p style="margin-top: 1em">By default, when make receives a
non-zero status from the execution of a command, it shall
terminate with an error message to standard error.</p>

<p style="margin-top: 1em">Target Rules <br>
Target rules are formatted as follows:</p>

<p style="margin-top: 1em">target [target...]:
[prerequisite...][;command] <br>
[&lt;tab&gt;command <br>
&lt;tab&gt;command <br>
...]</p>

<p style="margin-top: 1em">line that does not begin with
&lt;tab&gt;</p>

<p style="margin-top: 1em">Target entries are specified by
a &lt;blank&gt;-separated, non-null list of targets, then a
&lt;colon&gt;, then a &lt;blank&gt;-separated, possibly
empty list of prerequisites. Text following a <br>
&lt;semicolon&gt;, if any, and all following lines that
begin with a &lt;tab&gt;, are makefile command lines to be
executed to update the target. The first non-empty line that
does not begin <br>
with a &lt;tab&gt; or &rsquo;#&rsquo; shall begin a new
entry. An empty or blank line, or a line beginning with
&rsquo;#&rsquo;, may begin a new entry.</p>

<p style="margin-top: 1em">Applications shall select target
names from the set of characters consisting solely of
periods, underscores, digits, and alphabetics from the
portable character set (see the Base <br>
Definitions volume of POSIX.1&acirc;2008, Section 6.1,
Portable Character Set). Implementations may allow other
characters in target names as extensions. The interpretation
of targets <br>
containing the characters &rsquo;%&rsquo; and
&rsquo;&quot;&rsquo; is implementation-defined.</p>

<p style="margin-top: 1em">A target that has prerequisites,
but does not have any commands, can be used to add to the
prerequisite list for that target. Only one target rule for
any given target can con&acirc; <br>
tain commands.</p>

<p style="margin-top: 1em">Lines that begin with one of the
following are called special targets and control the
operation of make:</p>

<p style="margin-top: 1em">.DEFAULT If the makefile uses
this special target, the application shall ensure that it is
specified with commands, but without prerequisites. The
commands shall be used by make <br>
if there are no other rules available to build a target.</p>

<p style="margin-top: 1em">.IGNORE Prerequisites of this
special target are targets themselves; this shall cause
errors from commands associated with them to be ignored in
the same manner as specified by <br>
the &acirc;i option. Subsequent occurrences of .IGNORE shall
add to the list of targets ignoring command errors. If no
prerequisites are specified, make shall behave as if <br>
the &acirc;i option had been specified and errors from all
commands associated with all targets shall be ignored.</p>

<p style="margin-top: 1em">.POSIX The application shall
ensure that this special target is specified without
prerequisites or commands. If it appears as the first
non-comment line in the makefile, make <br>
shall process the makefile as specified by this section;
otherwise, the behavior of make is unspecified.</p>

<p style="margin-top: 1em">.PRECIOUS Prerequisites of this
special target shall not be removed if make receives one of
the asynchronous events explicitly described in the
ASYNCHRONOUS EVENTS section. Sub&acirc; <br>
sequent occurrences of .PRECIOUS shall add to the list of
precious files. If no prerequisites are specified, all
targets in the makefile shall be treated as if speci&acirc;
<br>
fied with .PRECIOUS.</p>

<p style="margin-top: 1em">.SCCS_GET The application shall
ensure that this special target is specified without
prerequisites. If this special target is included in a
makefile, the commands specified with <br>
this target shall replace the default commands associated
with this special target (see Default Rules). The commands
specified with this target are used to get all <br>
SCCS files that are not found in the current directory.</p>

<p style="margin-top: 1em">When source files are named in a
dependency list, make shall treat them just like any other
target. Because the source file is presumed to be present in
the directory, <br>
there is no need to add an entry for it to the makefile.
When a target has no dependencies, but is present in the
directory, make shall assume that that file is up-to- <br>
date. If, however, an SCCS file named SCCS/s.source_file is
found for a target source_file, make compares the timestamp
of the target file with that of the <br>
SCCS/s.source_file to ensure the target is up-to-date. If
the target is missing, or if the SCCS file is newer, make
shall automatically issue the commands specified for <br>
the .SCCS_GET special target to retrieve the most recent
version. However, if the target is writable by anyone, make
shall not retrieve a new version.</p>

<p style="margin-top: 1em">.SILENT Prerequisites of this
special target are targets themselves; this shall cause
commands associated with them not to be written to the
standard output before they are <br>
executed. Subsequent occurrences of .SILENT shall add to the
list of targets with silent commands. If no prerequisites
are specified, make shall behave as if the &acirc;s <br>
option had been specified and no commands or touch messages
associated with any target shall be written to standard
output.</p>

<p style="margin-top: 1em">.SUFFIXES Prerequisites of
.SUFFIXES shall be appended to the list of known suffixes
and are used in conjunction with the inference rules (see
Inference Rules). If .SUFFIXES <br>
does not have any prerequisites, the list of known suffixes
shall be cleared.</p>

<p style="margin-top: 1em">The special targets .IGNORE,
.POSIX, .PRECIOUS, .SILENT, and .SUFFIXES shall be specified
without commands.</p>

<p style="margin-top: 1em">Targets with names consisting of
a leading &lt;period&gt; followed by the uppercase letters
&quot;POSIX&quot; and then any other characters are reserved
for future standardization. Targets with <br>
names consisting of a leading &lt;period&gt; followed by one
or more uppercase letters are reserved for implementation
extensions.</p>

<p style="margin-top: 1em">Macros <br>
Macro definitions are in the form:</p>

<p style="margin-top: 1em">string1 = [string2]</p>

<p style="margin-top: 1em">The macro named string1 is
defined as having the value of string2, where string2 is
defined as all characters, if any, after the
&lt;equals-sign&gt;, up to a comment character
(&rsquo;#&rsquo;) or <br>
an unescaped &lt;newline&gt;. Any &lt;blank&gt; characters
immediately before or after the &lt;equals-sign&gt; shall be
ignored.</p>

<p style="margin-top: 1em">Applications shall select macro
names from the set of characters consisting solely of
periods, underscores, digits, and alphabetics from the
portable character set (see the Base <br>
Definitions volume of POSIX.1&acirc;2008, Section 6.1,
Portable Character Set). A macro name shall not contain an
&lt;equals-sign&gt;. Implementations may allow other
characters in macro <br>
names as extensions.</p>

<p style="margin-top: 1em">Macros can appear anywhere in
the makefile. Macro expansions using the forms $(string1) or
${string1} shall be replaced by string2, as follows:</p>

<p style="margin-top: 1em">* Macros in target lines shall
be evaluated when the target line is read.</p>

<p style="margin-top: 1em">* Macros in makefile command
lines shall be evaluated when the command is executed.</p>

<p style="margin-top: 1em">* Macros in the string before
the &lt;equals-sign&gt; in a macro definition shall be
evaluated when the macro assignment is made.</p>

<p style="margin-top: 1em">* Macros after the
&lt;equals-sign&gt; in a macro definition shall not be
evaluated until the defined macro is used in a rule or
command, or before the &lt;equals-sign&gt; in a macro
defi&acirc; <br>
nition.</p>

<p style="margin-top: 1em">The parentheses or braces are
optional if string1 is a single character. The macro $$
shall be replaced by the single character &rsquo;$&rsquo;.
If string1 in a macro expansion contains a <br>
macro expansion, the results are unspecified.</p>

<p style="margin-top: 1em">Macro expansions using the forms
$(string1[:subst1=[subst2]]) or ${string1[:subst1=[subst2]]}
can be used to replace all occurrences of subst1 with subst2
when the macro substi&acirc; <br>
tution is performed. The subst1 to be replaced shall be
recognized when it is a suffix at the end of a word in
string1 (where a word, in this context, is defined to be a
string <br>
delimited by the beginning of the line, a &lt;blank&gt;, or
a &lt;newline&gt;). If string1 in a macro expansion contains
a macro expansion, the results are unspecified.</p>

<p style="margin-top: 1em">Macro expansions in string1 of
macro definition lines shall be evaluated when read. Macro
expansions in string2 of macro definition lines shall be
performed when the macro iden&acirc; <br>
tified by string1 is expanded in a rule or command.</p>

<p style="margin-top: 1em">Macro definitions shall be taken
from the following sources, in the following logical order,
before the makefile(s) are read.</p>

<p style="margin-top: 1em">1. Macros specified on the make
utility command line, in the order specified on the command
line. It is unspecified whether the internal macros defined
in Internal Macros are <br>
accepted from this source.</p>

<p style="margin-top: 1em">2. Macros defined by the
MAKEFLAGS environment variable, in the order specified in
the environment variable. It is unspecified whether the
internal macros defined in Internal <br>
Macros are accepted from this source.</p>

<p style="margin-top: 1em">3. The contents of the
environment, excluding the MAKEFLAGS and SHELL variables and
including the variables with null values.</p>

<p style="margin-top: 1em">4. Macros defined in the
inference rules built into make.</p>

<p style="margin-top: 1em">Macro definitions from these
sources shall not override macro definitions from a
lower-numbered source. Macro definitions from a single
source (for example, the make utility com&acirc; <br>
mand line, the MAKEFLAGS environment variable, or the other
environment variables) shall override previous macro
definitions from the same source.</p>

<p style="margin-top: 1em">Macros defined in the
makefile(s) shall override macro definitions that occur
before them in the makefile(s) and macro definitions from
source 4. If the &acirc;e option is not speci&acirc; <br>
fied, macros defined in the makefile(s) shall override macro
definitions from source 3. Macros defined in the makefile(s)
shall not override macro definitions from source 1 or <br>
source 2.</p>

<p style="margin-top: 1em">Before the makefile(s) are read,
all of the make utility command line options (except
&acirc;f and &acirc;p) and make utility command line macro
definitions (except any for the MAKEFLAGS <br>
macro), not already included in the MAKEFLAGS macro, shall
be added to the MAKEFLAGS macro, quoted in an
implementation-defined manner such that when MAKEFLAGS is
read by another <br>
instance of the make command, the original macro&rsquo;s
value is recovered. Other implementation-defined options and
macros may also be added to the MAKEFLAGS macro. If this
modifies <br>
the value of the MAKEFLAGS macro, or, if the MAKEFLAGS macro
is modified at any subsequent time, the MAKEFLAGS
environment variable shall be modified to match the new
value of <br>
the MAKEFLAGS macro. The result of setting MAKEFLAGS in the
Makefile is unspecified.</p>

<p style="margin-top: 1em">Before the makefile(s) are read,
all of the make utility command line macro definitions
(except the MAKEFLAGS macro or the SHELL macro) shall be
added to the environment of make. <br>
Other implementation-defined variables may also be added to
the environment of make.</p>

<p style="margin-top: 1em">The SHELL macro shall be treated
specially. It shall be provided by make and set to the
pathname of the shell command language interpreter (see sh).
The SHELL environment vari&acirc; <br>
able shall not affect the value of the SHELL macro. If SHELL
is defined in the makefile or is specified on the command
line, it shall replace the original value of the SHELL <br>
macro, but shall not affect the SHELL environment variable.
Other effects of defining SHELL in the makefile or on the
command line are implementation-defined.</p>

<p style="margin-top: 1em">Inference Rules <br>
Inference rules are formatted as follows:</p>

<p style="margin-top: 1em">target: <br>
&lt;tab&gt;command <br>
[&lt;tab&gt;command] <br>
...</p>

<p style="margin-top: 1em">line that does not begin with
&lt;tab&gt; or #</p>

<p style="margin-top: 1em">The application shall ensure
that the target portion is a valid target name (see Target
Rules) of the form .s2 or .s1.s2 (where .s1 and .s2 are
suffixes that have been given as <br>
prerequisites of the .SUFFIXES special target and s1 and s2
do not contain any &lt;slash&gt; or &lt;period&gt;
characters.) If there is only one &lt;period&gt; in the
target, it is a single-suffix <br>
inference rule. Targets with two periods are double-suffix
inference rules. Inference rules can have only one target
before the &lt;colon&gt;.</p>

<p style="margin-top: 1em">The application shall ensure
that the makefile does not specify prerequisites for
inference rules; no characters other than white space shall
follow the &lt;colon&gt; in the first <br>
line, except when creating the empty rule, described below.
Prerequisites are inferred, as described below.</p>

<p style="margin-top: 1em">Inference rules can be
redefined. A target that matches an existing inference rule
shall overwrite the old inference rule. An empty rule can be
created with a command consisting <br>
of simply a &lt;semicolon&gt; (that is, the rule still
exists and is found during inference rule search, but since
it is empty, execution has no effect). The empty rule can
also be <br>
formatted as follows:</p>

<p style="margin-top: 1em">rule: ;</p>

<p style="margin-top: 1em">where zero or more &lt;blank&gt;
characters separate the &lt;colon&gt; and
&lt;semicolon&gt;.</p>

<p style="margin-top: 1em">The make utility uses the
suffixes of targets and their prerequisites to infer how a
target can be made up-to-date. A list of inference rules
defines the commands to be executed. <br>
By default, make contains a built-in set of inference rules.
Additional rules can be specified in the makefile.</p>

<p style="margin-top: 1em">The special target .SUFFIXES
contains as its prerequisites a list of suffixes that shall
be used by the inference rules. The order in which the
suffixes are specified defines the <br>
order in which the inference rules for the suffixes are
used. New suffixes shall be appended to the current list by
specifying a .SUFFIXES special target in the makefile. A
.SUF&acirc; <br>
FIXES target with no prerequisites shall clear the list of
suffixes. An empty .SUFFIXES target followed by a new
.SUFFIXES list is required to change the order of the
suffixes.</p>

<p style="margin-top: 1em">Normally, the user would provide
an inference rule for each suffix. The inference rule to
update a target with a suffix .s1 from a prerequisite with a
suffix .s2 is specified as <br>
a target .s2.s1. The internal macros provide the means to
specify general inference rules (see Internal Macros).</p>

<p style="margin-top: 1em">When no target rule is found to
update a target, the inference rules shall be checked. The
suffix of the target (.s1) to be built is compared to the
list of suffixes specified by <br>
the .SUFFIXES special targets. If the .s1 suffix is found in
.SUFFIXES, the inference rules shall be searched in the
order defined for the first .s2.s1 rule whose prerequisite
<br>
file ($*.s2) exists. If the target is out-of-date with
respect to this prerequisite, the commands for that
inference rule shall be executed.</p>

<p style="margin-top: 1em">If the target to be built does
not contain a suffix and there is no rule for the target,
the single suffix inference rules shall be checked. The
single-suffix inference rules <br>
define how to build a target if a file is found with a name
that matches the target name with one of the single suffixes
appended. A rule with one suffix .s2 is the definition of
<br>
how to build target from target.s2. The other suffix (.s1)
is treated as null.</p>

<p style="margin-top: 1em">A &lt;tilde&gt;
(&rsquo;~&rsquo;) in the above rules refers to an SCCS file
in the current directory. Thus, the rule .c~.o would
transform an SCCS C-language source file into an object file
(.o). <br>
Because the s. of the SCCS files is a prefix, it is
incompatible with make&rsquo;s suffix point of view. Hence,
the &rsquo;~&rsquo; is a way of changing any file reference
into an SCCS file ref&acirc; <br>
erence.</p>

<p style="margin-top: 1em">Libraries <br>
If a target or prerequisite contains parentheses, it shall
be treated as a member of an archive library. For the
lib(member.o) expression lib refers to the name of the
archive <br>
library and member.o to the member name. The application
shall ensure that the member is an object file with the .o
suffix. The modification time of the expression is the
modifi&acirc; <br>
cation time for the member as kept in the archive library;
see ar. The .a suffix shall refer to an archive library. The
.s2.a rule shall be used to update a member in the <br>
library from a file with a suffix .s2.</p>

<p style="margin-top: 1em">Internal Macros <br>
The make utility shall maintain five internal macros that
can be used in target and inference rules. In order to
clearly define the meaning of these macros, some
clarification of <br>
the terms target rule, inference rule, target, and
prerequisite is necessary.</p>

<p style="margin-top: 1em">Target rules are specified by
the user in a makefile for a particular target. Inference
rules are user-specified or make-specified rules for a
particular class of target name. <br>
Explicit prerequisites are those prerequisites specified in
a makefile on target lines. Implicit prerequisites are those
prerequisites that are generated when inference rules <br>
are used. Inference rules are applied to implicit
prerequisites or to explicit prerequisites that do not have
target rules defined for them in the makefile. Target rules
are <br>
applied to targets specified in the makefile.</p>

<p style="margin-top: 1em">Before any target in the
makefile is updated, each of its prerequisites (both
explicit and implicit) shall be updated. This shall be
accomplished by recursively processing each <br>
prerequisite. Upon recursion, each prerequisite shall become
a target itself. Its prerequisites in turn shall be
processed recursively until a target is found that has no
prereq&acirc; <br>
uisites, at which point the recursion stops. The recursion
shall then back up, updating each target as it goes.</p>

<p style="margin-top: 1em">In the definitions that follow,
the word target refers to one of:</p>

<p style="margin-top: 1em">* A target specified in the
makefile</p>

<p style="margin-top: 1em">* An explicit prerequisite
specified in the makefile that becomes the target when make
processes it during recursion</p>

<p style="margin-top: 1em">* An implicit prerequisite that
becomes a target when make processes it during recursion</p>

<p style="margin-top: 1em">In the definitions that follow,
the word prerequisite refers to one of the following:</p>

<p style="margin-top: 1em">* An explicit prerequisite
specified in the makefile for a particular target</p>

<p style="margin-top: 1em">* An implicit prerequisite
generated as a result of locating an appropriate inference
rule and corresponding file that matches the suffix of the
target</p>

<p style="margin-top: 1em">The five internal macros
are:</p>

<p style="margin-top: 1em">$@ The $@ shall evaluate to the
full target name of the current target, or the archive
filename part of a library archive target. It shall be
evaluated for both target and <br>
inference rules.</p>

<p style="margin-top: 1em">For example, in the .c.a
inference rule, $@ represents the out-of-date .a file to be
built. Similarly, in a makefile target rule to build lib.a
from file.c, $@ represents <br>
the out-of-date lib.a.</p>

<p style="margin-top: 1em">$% The $% macro shall be
evaluated only when the current target is an archive library
member of the form libname(member.o). In these cases, $@
shall evaluate to libname and <br>
$% shall evaluate to member.o. The $% macro shall be
evaluated for both target and inference rules.</p>

<p style="margin-top: 1em">For example, in a makefile
target rule to build lib.a(file.o), $% represents file.o, as
opposed to $@, which represents lib.a.</p>

<p style="margin-top: 1em">$? The $? macro shall evaluate
to the list of prerequisites that are newer than the current
target. It shall be evaluated for both target and inference
rules.</p>

<p style="margin-top: 1em">For example, in a makefile
target rule to build prog from file1.o, file2.o, and
file3.o, and where prog is not out-of-date with respect to
file1.o, but is out-of-date <br>
with respect to file2.o and file3.o, $? represents file2.o
and file3.o.</p>

<p style="margin-top: 1em">$&lt; In an inference rule, the
$&lt; macro shall evaluate to the filename whose existence
allowed the inference rule to be chosen for the target. In
the .DEFAULT rule, the $&lt; <br>
macro shall evaluate to the current target name. The meaning
of the $&lt; macro shall be otherwise unspecified.</p>

<p style="margin-top: 1em">For example, in the .c.a
inference rule, $&lt; represents the prerequisite .c
file.</p>

<p style="margin-top: 1em">$* The $* macro shall evaluate
to the current target name with its suffix deleted. It shall
be evaluated at least for inference rules.</p>

<p style="margin-top: 1em">For example, in the .c.a
inference rule, $*.o represents the out-of-date .o file that
corresponds to the prerequisite .c file.</p>

<p style="margin-top: 1em">Each of the internal macros has
an alternative form. When an uppercase &rsquo;D&rsquo; or
&rsquo;F&rsquo; is appended to any of the macros, the
meaning shall be changed to the directory part for
&rsquo;D&rsquo; and <br>
filename part for &rsquo;F&rsquo;. The directory part is the
path prefix of the file without a trailing &lt;slash&gt;;
for the current directory, the directory part is
&rsquo;.&rsquo;. When the $? macro <br>
contains more than one prerequisite filename, the $(?D) and
$(?F) (or ${?D} and ${?F}) macros expand to a list of
directory name parts and filename parts respectively.</p>

<p style="margin-top: 1em">For the target lib(member.o) and
the s2.a rule, the internal macros shall be defined as:</p>

<p style="margin-top: 1em">$&lt; member.s2</p>

<p style="margin-top: 1em">$* member</p>

<p style="margin-top: 1em">$@ lib</p>

<p style="margin-top: 1em">$? member.s2</p>

<p style="margin-top: 1em">$% member.o</p>

<p style="margin-top: 1em">Default Rules <br>
The default rules for make shall achieve results that are
the same as if the following were used. Implementations that
do not support the C-Language Development Utilities option
<br>
may omit CC, CFLAGS, YACC, YFLAGS, LEX, LFLAGS, LDFLAGS, and
the .c, .y, and .l inference rules. Implementations that do
not support FORTRAN may omit FC, FFLAGS, and the .f <br>
inference rules. Implementations may provide additional
macros and rules.</p>

<p style="margin-top: 1em">SPECIAL TARGETS</p>

<p style="margin-top: 1em">.SCCS_GET: sccs $(SCCSFLAGS) get
$(SCCSGETFLAGS) $@</p>

<p style="margin-top: 1em">.SUFFIXES: .o .c .y .l .a .sh .f
.c~ .y~ .l~ .sh~ .f~</p>

<p style="margin-top: 1em">MACROS</p>

<p style="margin-top: 1em">MAKE=make <br>
AR=ar <br>
ARFLAGS=&acirc;rv <br>
YACC=yacc <br>
YFLAGS= <br>
LEX=lex <br>
LFLAGS= <br>
LDFLAGS= <br>
CC=c99 <br>
CFLAGS=&acirc;O <br>
FC=fort77 <br>
FFLAGS=&acirc;O 1 <br>
GET=get <br>
GFLAGS= <br>
SCCSFLAGS= <br>
SCCSGETFLAGS=&acirc;s</p>

<p style="margin-top: 1em">SINGLE SUFFIX RULES</p>

<p style="margin-top: 1em">.c: <br>
$(CC) $(CFLAGS) $(LDFLAGS) &acirc;o $@ $&lt;</p>

<p style="margin-top: 1em">.f: <br>
$(FC) $(FFLAGS) $(LDFLAGS) &acirc;o $@ $&lt;</p>

<p style="margin-top: 1em">.sh: <br>
cp $&lt; $@ <br>
chmod a+x $@</p>

<p style="margin-top: 1em">.c~: <br>
$(GET) $(GFLAGS) &acirc;p $&lt; &gt; $*.c <br>
$(CC) $(CFLAGS) $(LDFLAGS) &acirc;o $@ $*.c</p>

<p style="margin-top: 1em">.f~: <br>
$(GET) $(GFLAGS) &acirc;p $&lt; &gt; $*.f <br>
$(FC) $(FFLAGS) $(LDFLAGS) &acirc;o $@ $*.f</p>

<p style="margin-top: 1em">.sh~: <br>
$(GET) $(GFLAGS) &acirc;p $&lt; &gt; $*.sh <br>
cp $*.sh $@ <br>
chmod a+x $@</p>

<p style="margin-top: 1em">DOUBLE SUFFIX RULES</p>

<p style="margin-top: 1em">.c.o: <br>
$(CC) $(CFLAGS) &acirc;c $&lt;</p>

<p style="margin-top: 1em">.f.o: <br>
$(FC) $(FFLAGS) &acirc;c $&lt;</p>

<p style="margin-top: 1em">.y.o: <br>
$(YACC) $(YFLAGS) $&lt; <br>
$(CC) $(CFLAGS) &acirc;c y.tab.c <br>
rm &acirc;f y.tab.c <br>
mv y.tab.o $@</p>

<p style="margin-top: 1em">.l.o: <br>
$(LEX) $(LFLAGS) $&lt; <br>
$(CC) $(CFLAGS) &acirc;c lex.yy.c <br>
rm &acirc;f lex.yy.c <br>
mv lex.yy.o $@</p>

<p style="margin-top: 1em">.y.c: <br>
$(YACC) $(YFLAGS) $&lt; <br>
mv y.tab.c $@</p>

<p style="margin-top: 1em">.l.c: <br>
$(LEX) $(LFLAGS) $&lt; <br>
mv lex.yy.c $@</p>

<p style="margin-top: 1em">.c~.o: <br>
$(GET) $(GFLAGS) &acirc;p $&lt; &gt; $*.c <br>
$(CC) $(CFLAGS) &acirc;c $*.c</p>

<p style="margin-top: 1em">.f~.o: <br>
$(GET) $(GFLAGS) &acirc;p $&lt; &gt; $*.f <br>
$(FC) $(FFLAGS) &acirc;c $*.f</p>

<p style="margin-top: 1em">.y~.o: <br>
$(GET) $(GFLAGS) &acirc;p $&lt; &gt; $*.y <br>
$(YACC) $(YFLAGS) $*.y <br>
$(CC) $(CFLAGS) &acirc;c y.tab.c <br>
rm &acirc;f y.tab.c <br>
mv y.tab.o $@</p>

<p style="margin-top: 1em">.l~.o: <br>
$(GET) $(GFLAGS) &acirc;p $&lt; &gt; $*.l <br>
$(LEX) $(LFLAGS) $*.l <br>
$(CC) $(CFLAGS) &acirc;c lex.yy.c <br>
rm &acirc;f lex.yy.c <br>
mv lex.yy.o $@</p>

<p style="margin-top: 1em">.y~.c: <br>
$(GET) $(GFLAGS) &acirc;p $&lt; &gt; $*.y <br>
$(YACC) $(YFLAGS) $*.y <br>
mv y.tab.c $@</p>

<p style="margin-top: 1em">.l~.c: <br>
$(GET) $(GFLAGS) &acirc;p $&lt; &gt; $*.l <br>
$(LEX) $(LFLAGS) $*.l <br>
mv lex.yy.c $@</p>

<p style="margin-top: 1em">.c.a: <br>
$(CC) &acirc;c $(CFLAGS) $&lt; <br>
$(AR) $(ARFLAGS) $@ $*.o <br>
rm &acirc;f $*.o</p>

<p style="margin-top: 1em">.f.a: <br>
$(FC) &acirc;c $(FFLAGS) $&lt; <br>
$(AR) $(ARFLAGS) $@ $*.o <br>
rm &acirc;f $*.o</p>

<p style="margin-top: 1em">EXIT STATUS <br>
When the &acirc;q option is specified, the make utility
shall exit with one of the following values:</p>

<p style="margin-top: 1em">0 Successful completion.</p>

<p style="margin-top: 1em">1 The target was not
up-to-date.</p>

<p style="margin-top: 1em">&gt;1 An error occurred.</p>

<p style="margin-top: 1em">When the &acirc;q option is not
specified, the make utility shall exit with one of the
following values:</p>

<p style="margin-top: 1em">0 Successful completion.</p>

<p style="margin-top: 1em">&gt;0 An error occurred.</p>

<p style="margin-top: 1em">CONSEQUENCES OF ERRORS <br>
Default.</p>

<p style="margin-top: 1em">The following sections are
informative.</p>

<p style="margin-top: 1em">APPLICATION USAGE <br>
If there is a source file (such as ./source.c) and there are
two SCCS files corresponding to it (./s.source.c and
./SCCS/s.source.c), on XSI-conformant systems make uses the
SCCS <br>
file in the current directory. However, users are advised to
use the underlying SCCS utilities (admin, delta, get, and so
on) or the sccs utility for all source files in a given <br>
directory. If both forms are used for a given source file,
future developers are very likely to be confused.</p>

<p style="margin-top: 1em">It is incumbent upon portable
makefiles to specify the .POSIX special target in order to
guarantee that they are not affected by local
extensions.</p>

<p style="margin-top: 1em">The &acirc;k and &acirc;S
options are both present so that the relationship between
the command line, the MAKEFLAGS variable, and the makefile
can be controlled precisely. If the k flag is <br>
passed in MAKEFLAGS and a command is of the form:</p>

<p style="margin-top: 1em">$(MAKE) &acirc;S foo</p>

<p style="margin-top: 1em">then the default behavior is
restored for the child make.</p>

<p style="margin-top: 1em">When the &acirc;n option is
specified, it is always added to MAKEFLAGS. This allows a
recursive make &acirc;n target to be used to see all of the
action that would be taken to update tar&acirc; <br>
get.</p>

<p style="margin-top: 1em">Because of widespread historical
practice, interpreting a &lt;number-sign&gt;
(&rsquo;#&rsquo;) inside a variable as the start of a
comment has the unfortunate side-effect of making it
impossible <br>
to place a &lt;number-sign&gt; in a variable, thus
forbidding something like:</p>

<p style="margin-top: 1em">CFLAGS = &quot;&acirc;D
COMMENT_CHAR=&rsquo;#&rsquo;&quot;</p>

<p style="margin-top: 1em">Many historical make utilities
stop chaining together inference rules when an intermediate
target is nonexistent. For example, it might be possible for
a make to determine that <br>
both .y.c and .c.o could be used to convert a .y to a .o.
Instead, in this case, make requires the use of a .y.o
rule.</p>

<p style="margin-top: 1em">The best way to provide portable
makefiles is to include all of the rules needed in the
makefile itself. The rules provided use only features
provided by other parts of this vol&acirc; <br>
ume of POSIX.1&acirc;2008. The default rules include rules
for optional commands in this volume of POSIX.1&acirc;2008.
Only rules pertaining to commands that are provided are
needed in an <br>
implementation&rsquo;s default set.</p>

<p style="margin-top: 1em">Macros used within other macros
are evaluated when the new macro is used rather than when
the new macro is defined. Therefore:</p>

<p style="margin-top: 1em">MACRO = value1 <br>
NEW = $(MACRO) <br>
MACRO = value2</p>

<p style="margin-top: 1em">target: <br>
echo $(NEW)</p>

<p style="margin-top: 1em">would produce value2 and not
value1 since NEW was not expanded until it was needed in the
echo command line.</p>

<p style="margin-top: 1em">Some historical applications
have been known to intermix target_name and macro=name
operands on the command line, expecting that all of the
macros are processed before any of the <br>
targets are dealt with. Conforming applications do not do
this, although some backwards-compatibility support may be
included in some implementations.</p>

<p style="margin-top: 1em">The following characters in
filenames may give trouble: &rsquo;=&rsquo;,
&rsquo;:&rsquo;, &rsquo;&lsquo;&rsquo;, single-quote, and
&rsquo;@&rsquo;. In include filenames, pattern matching
characters and &rsquo;&quot;&rsquo; should also be avoided,
<br>
as they may be treated as special by some
implementations.</p>

<p style="margin-top: 1em">For inference rules, the
description of $&lt; and $? seem similar. However, an
example shows the minor difference. In a makefile
containing:</p>

<p style="margin-top: 1em">foo.o: foo.h</p>

<p style="margin-top: 1em">if foo.h is newer than foo.o,
yet foo.c is older than foo.o, the built-in rule to make
foo.o from foo.c is used, with $&lt; equal to foo.c and $?
equal to foo.h. If foo.c is also <br>
newer than foo.o, $&lt; is equal to foo.c and $? is equal to
foo.h foo.c.</p>

<p style="margin-top: 1em">EXAMPLES <br>
1. The following command:</p>

<p style="margin-top: 1em">make</p>

<p style="margin-top: 1em">makes the first target found in
the makefile.</p>

<p style="margin-top: 1em">2. The following command:</p>

<p style="margin-top: 1em">make junk</p>

<p style="margin-top: 1em">makes the target junk.</p>

<p style="margin-top: 1em">3. The following makefile says
that pgm depends on two files, a.o and b.o, and that they in
turn depend on their corresponding source files (a.c and
b.c), and a common file <br>
incl.h:</p>

<p style="margin-top: 1em">pgm: a.o b.o <br>
c99 a.o b.o &acirc;o pgm <br>
a.o: incl.h a.c <br>
c99 &acirc;c a.c <br>
b.o: incl.h b.c <br>
c99 &acirc;c b.c</p>

<p style="margin-top: 1em">4. An example for making
optimized .o files from .c files is:</p>

<p style="margin-top: 1em">.c.o: <br>
c99 &acirc;c &acirc;O $*.c</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">.c.o: <br>
c99 &acirc;c &acirc;O $&lt;</p>

<p style="margin-top: 1em">5. The most common use of the
archive interface follows. Here, it is assumed that the
source files are all C-language source:</p>

<p style="margin-top: 1em">lib: lib(file1.o) lib(file2.o)
lib(file3.o) <br>
@echo lib is now up-to-date</p>

<p style="margin-top: 1em">The .c.a rule is used to make
file1.o, file2.o, and file3.o and insert them into lib.</p>

<p style="margin-top: 1em">The treatment of escaped
&lt;newline&gt; characters throughout the makefile is
historical practice. For example, the inference rule:</p>

<p style="margin-top: 1em">.c.o :</p>

<p style="margin-top: 1em">works, and the macro:</p>

<p style="margin-top: 1em">f= bar baz biz <br>
a: <br>
echo ==$f==</p>

<p style="margin-top: 1em">echoes &quot;==bar baz
biz==&quot;.</p>

<p style="margin-top: 1em">If $? were:</p>

<p style="margin-top: 1em">/usr/include/stdio.h
/usr/include/unistd.h foo.h</p>

<p style="margin-top: 1em">then $(?D) would be:</p>

<p style="margin-top: 1em">/usr/include /usr/include .</p>

<p style="margin-top: 1em">and $(?F) would be:</p>

<p style="margin-top: 1em">stdio.h unistd.h foo.h</p>

<p style="margin-top: 1em">6. The contents of the built-in
rules can be viewed by running:</p>

<p style="margin-top: 1em">make &acirc;p &acirc;f /dev/null
2&gt;/dev/null</p>

<p style="margin-top: 1em">RATIONALE <br>
The make utility described in this volume of
POSIX.1&acirc;2008 is intended to provide the means for
changing portable source code into executables that can be
run on an <br>
POSIX.1&acirc;2008-conforming system. It reflects the most
common features present in System V and BSD makes.</p>

<p style="margin-top: 1em">Historically, the make utility
has been an especially fertile ground for vendor and
research organization-specific syntax modifications and
extensions. Examples include:</p>

<p style="margin-top: 1em">* Syntax supporting parallel
execution (such as from various multi-processor vendors,
GNU, and others)</p>

<p style="margin-top: 1em">* Additional
&lsquo;&lsquo;operators&rsquo;&rsquo; separating targets and
their prerequisites (System V, BSD, and others)</p>

<p style="margin-top: 1em">* Specifying that command lines
containing the strings &quot;${MAKE}&quot; and
&quot;$(MAKE)&quot; are executed when the &acirc;n option is
specified (GNU and System V)</p>

<p style="margin-top: 1em">* Modifications of the meaning
of internal macros when referencing libraries (BSD and
others)</p>

<p style="margin-top: 1em">* Using a single instance of the
shell for all of the command lines of the target (BSD and
others)</p>

<p style="margin-top: 1em">* Allowing &lt;space&gt;
characters as well as &lt;tab&gt; characters to delimit
command lines (BSD)</p>

<p style="margin-top: 1em">* Adding C preprocessor-style
&lsquo;&lsquo;include&rsquo;&rsquo; and
&lsquo;&lsquo;ifdef&rsquo;&rsquo; constructs (System V, GNU,
BSD, and others)</p>

<p style="margin-top: 1em">* Remote execution of command
lines (Sprite and others)</p>

<p style="margin-top: 1em">* Specifying additional special
targets (BSD, System V, and most others)</p>

<p style="margin-top: 1em">Additionally, many vendors and
research organizations have rethought the basic concepts of
make, creating vastly extended, as well as completely new,
syntaxes. Each of these ver&acirc; <br>
sions of make fulfills the needs of a different community of
users; it is unreasonable for this volume of
POSIX.1&acirc;2008 to require behavior that would be
incompatible (and proba&acirc; <br>
bly inferior) to historical practice for such a
community.</p>

<p style="margin-top: 1em">In similar circumstances, when
the industry has enough sufficiently incompatible formats as
to make them irreconcilable, this volume of
POSIX.1&acirc;2008 has followed one or both of <br>
two courses of action. Commands have been renamed (cksum,
echo, and pax) and/or command line options have been
provided to select the desired behavior (grep, od, and
pax).</p>

<p style="margin-top: 1em">Because the syntax specified for
the make utility is, by and large, a subset of the syntaxes
accepted by almost all versions of make, it was decided that
it would be counter-pro&acirc; <br>
ductive to change the name. And since the makefile itself is
a basic unit of portability, it would not be completely
effective to reserve a new option letter, such as make
&acirc;P, <br>
to achieve the portable behavior. Therefore, the special
target .POSIX was added to the makefile, allowing users to
specify &lsquo;&lsquo;standard&rsquo;&rsquo; behavior. This
special target does not <br>
preclude extensions in the make utility, nor does it
preclude such extensions being used by the makefile
specifying the target; it does, however, preclude any
extensions from <br>
being applied that could alter the behavior of previously
valid syntax; such extensions must be controlled via command
line options or new special targets. It is incumbent upon
<br>
portable makefiles to specify the .POSIX special target in
order to guarantee that they are not affected by local
extensions.</p>

<p style="margin-top: 1em">The portable version of make
described in this reference page is not intended to be the
state-of-the-art software generation tool and, as such, some
newer and more leading-edge <br>
features have not been included. An attempt has been made to
describe the portable makefile in a manner that does not
preclude such extensions as long as they do not disturb the
<br>
portable behavior described here.</p>

<p style="margin-top: 1em">When the &acirc;n option is
specified, it is always added to MAKEFLAGS. This allows a
recursive make &acirc;n target to be used to see all of the
action that would be taken to update tar&acirc; <br>
get.</p>

<p style="margin-top: 1em">The definition of MAKEFLAGS
allows both the System V letter string and the BSD command
line formats. The two formats are sufficiently different to
allow implementations to sup&acirc; <br>
port both without ambiguity.</p>

<p style="margin-top: 1em">Early proposals stated that an
&lsquo;&lsquo;unquoted&rsquo;&rsquo; &lt;number-sign&gt; was
treated as the start of a comment. The make utility does not
pay any attention to quotes. A &lt;number-sign&gt; starts a
<br>
comment regardless of its surroundings.</p>

<p style="margin-top: 1em">The text about
&lsquo;&lsquo;other implementation-defined pathnames may
also be tried&rsquo;&rsquo; in addition to ./makefile and
./Makefile is to allow such extensions as SCCS/s.Makefile
and other <br>
variations. It was made an implementation-defined
requirement (as opposed to unspecified behavior) to
highlight surprising implementations that might select
something unexpected <br>
like /etc/Makefile. XSI-conformant systems also try
./s.makefile, SCCS/s.makefile, ./s.Makefile, and
SCCS/s.Makefile.</p>

<p style="margin-top: 1em">Early proposals contained the
macro NPROC as a means of specifying that make should use n
processes to do the work required. While this feature is a
valuable extension for many <br>
systems, it is not common usage and could require other
non-trivial extensions to makefile syntax. This extension is
not required by this volume of POSIX.1&acirc;2008, but could
be <br>
provided as a compatible extension. The macro PARALLEL is
used by some historical systems with essentially the same
meaning (but without using a name that is a common system
<br>
limit value). It is suggested that implementors recognize
the existing use of NPROC and/or PARALLEL as extensions to
make.</p>

<p style="margin-top: 1em">The default rules are based on
System V. The default CC= value is c99 instead of cc because
this volume of POSIX.1&acirc;2008 does not standardize the
utility named cc. Thus, every <br>
conforming application would be required to define CC=c99 to
expect to run. There is no advantage conferred by the hope
that the makefile might hit the
&lsquo;&lsquo;preferred&rsquo;&rsquo; compiler <br>
because this cannot be guaranteed to work. Also, since the
portable makescript can only use the c99 options, no
advantage is conferred in terms of what the script can do.
It is <br>
a quality-of-implementation issue as to whether c99 is as
valuable as cc.</p>

<p style="margin-top: 1em">The &acirc;d option to make is
frequently used to produce debugging information, but is too
implementation-defined to add to this volume of
POSIX.1&acirc;2008.</p>

<p style="margin-top: 1em">The &acirc;p option is not
passed in MAKEFLAGS on most historical implementations and
to change this would cause many implementations to break
without sufficiently increased portabil&acirc; <br>
ity.</p>

<p style="margin-top: 1em">Commands that begin with a
&lt;plus-sign&gt; (&rsquo;+&rsquo;) are executed even if the
&acirc;n option is present. Based on the GNU version of
make, the behavior of &acirc;n when the &lt;plus-sign&gt;
prefix is <br>
encountered has been extended to apply to &acirc;q and
&acirc;t as well. However, the System V convention of
forcing command execution with &acirc;n when the command
line of a target contains <br>
either of the strings &quot;$(MAKE)&quot; or
&quot;${MAKE}&quot; has not been adopted. This functionality
appeared in early proposals, but the danger of this approach
was pointed out with the fol&acirc; <br>
lowing example of a portion of a makefile:</p>

<p style="margin-top: 1em">subdir: <br>
cd subdir; rm all_the_files; $(MAKE)</p>

<p style="margin-top: 1em">The loss of the System V
behavior in this case is well-balanced by the safety
afforded to other makefiles that were not aware of this
situation. In any event, the command line <br>
&lt;plus-sign&gt; prefix can provide the desired
functionality.</p>

<p style="margin-top: 1em">The double &lt;colon&gt; in the
target rule format is supported in BSD systems to allow more
than one target line containing the same target name to have
commands associated with it. <br>
Since this is not functionality described in the SVID or
XPG3 it has been allowed as an extension, but not
mandated.</p>

<p style="margin-top: 1em">The default rules are provided
with text specifying that the built-in rules shall be the
same as if the listed set were used. The intent is that
implementations should be able to <br>
use the rules without change, but will be allowed to alter
them in ways that do not affect the primary behavior.</p>

<p style="margin-top: 1em">The best way to provide portable
makefiles is to include all of the rules needed in the
makefile itself. The rules provided use only features
provided by other portions of this <br>
volume of POSIX.1&acirc;2008. The default rules include
rules for optional commands in this volume of
POSIX.1&acirc;2008. Only rules pertaining to commands that
are provided are needed in <br>
the default set of an implementation.</p>

<p style="margin-top: 1em">One point of discussion was
whether to drop the default rules list from this volume of
POSIX.1&acirc;2008. They provide convenience, but do not
enhance portability of applications. The <br>
prime benefit is in portability of users who wish to type
make command and have the command build from a command.c
file.</p>

<p style="margin-top: 1em">The historical MAKESHELL feature
was omitted. In some implementations it is used to let a
user override the shell to be used to run make commands.
This was confusing; for a por&acirc; <br>
table make, the shell should be chosen by the makefile
writer or specified on the make command line and not by a
user running make.</p>

<p style="margin-top: 1em">The make utilities in most
historical implementations process the prerequisites of a
target in left-to-right order, and the makefile format
requires this. It supports the stan&acirc; <br>
dard idiom used in many makefiles that produce yacc
programs; for example:</p>

<p style="margin-top: 1em">foo: y.tab.o lex.o main.o <br>
$(CC) $(CFLAGS) &acirc;o $@ t.tab.o lex.o main.o</p>

<p style="margin-top: 1em">In this example, if make chose
any arbitrary order, the lex.o might not be made with the
correct y.tab.h. Although there may be better ways to
express this relationship, it is <br>
widely used historically. Implementations that desire to
update prerequisites in parallel should require an explicit
extension to make or the makefile format to accomplish it,
as <br>
described previously.</p>

<p style="margin-top: 1em">The algorithm for determining a
new entry for target rules is partially unspecified. Some
historical makes allow blank, empty, or comment lines within
the collection of commands <br>
marked by leading &lt;tab&gt; characters. A conforming
makefile must ensure that each command starts with a
&lt;tab&gt;, but implementations are free to ignore blank,
empty, and comment <br>
lines without triggering the start of a new entry.</p>

<p style="margin-top: 1em">The ASYNCHRONOUS EVENTS section
includes having SIGTERM and SIGHUP, along with the more
traditional SIGINT and SIGQUIT, remove the current target
unless directed not to do so. <br>
SIGTERM and SIGHUP were added to parallel other utilities
that have historically cleaned up their work as a result of
these signals. When make receives any signal other than <br>
SIGQUIT, it is required to resend itself the signal it
received so that it exits with a status that reflects the
signal. The results from SIGQUIT are partially unspecified
<br>
because, on systems that create core files upon receipt of
SIGQUIT, the core from make would conflict with a core file
from the command that was running when the SIGQUIT arrived.
<br>
The main concern was to prevent damaged files from appearing
up-to-date when make is rerun.</p>

<p style="margin-top: 1em">The .PRECIOUS special target was
extended to affect all targets globally (by specifying no
prerequisites). The .IGNORE and .SILENT special targets were
extended to allow prereq&acirc; <br>
uisites; it was judged to be more useful in some cases to be
able to turn off errors or echoing for a list of targets
than for the entire makefile. These extensions to make in
<br>
System V were made to match historical practice from the BSD
make.</p>

<p style="margin-top: 1em">Macros are not exported to the
environment of commands to be run. This was never the case
in any historical make and would have serious consequences.
The environment is the same <br>
as the environment to make except that MAKEFLAGS and macros
defined on the make command line are added.</p>

<p style="margin-top: 1em">Some implementations do not use
system() for all command lines, as required by the portable
makefile format; as a performance enhancement, they select
lines without shell <br>
metacharacters for direct execution by execve(). There is no
requirement that system() be used specifically, but merely
that the same results be achieved. The metacharacters <br>
typically used to bypass the direct execve() execution have
been any of:</p>

<p style="margin-top: 1em">= | ^ ( ) ; &amp; &lt; &gt; * ?
[ ] : $ &lsquo; &rsquo; &quot; &nbsp;</p>

<p style="margin-top: 1em">The default in some advanced
versions of make is to group all the command lines for a
target and execute them using a single shell invocation; the
System V method is to pass each <br>
line individually to a separate shell. The single-shell
method has the advantages in performance and the lack of a
requirement for many continued lines. However, converting to
<br>
this newer method has caused portability problems with many
historical makefiles, so the behavior with the POSIX
makefile is specified to be the same as that of System V. It
is <br>
suggested that the special target .ONESHELL be used as an
implementation extension to achieve the single-shell
grouping for a target or group of targets.</p>

<p style="margin-top: 1em">Novice users of make have had
difficulty with the historical need to start commands with a
&lt;tab&gt;. Since it is often difficult to discern
differences between &lt;tab&gt; and &lt;space&gt; <br>
characters on terminals or printed listings, confusing bugs
can arise. In early proposals, an attempt was made to
correct this problem by allowing leading &lt;blank&gt;
characters <br>
instead of &lt;tab&gt; characters. However, implementors
reported many makefiles that failed in subtle ways following
this change, and it is difficult to implement a make that
unam&acirc; <br>
biguously can differentiate between macro and command lines.
There is extensive historical practice of allowing leading
&lt;space&gt; characters before macro definitions. Forcing
<br>
macro lines into column 1 would be a significant
backwards-compatibility problem for some makefiles.
Therefore, historical practice was restored.</p>

<p style="margin-top: 1em">There is substantial variation
in the handling of include lines by different
implementations. However, there is enough commonality for
the standard to be able to specify a mini&acirc; <br>
mum set of requirements that allow the feature to be used
portably. Known variations have been explicitly called out
as unspecified behavior in the description.</p>

<p style="margin-top: 1em">The System V dynamic dependency
feature was not included. It would support:</p>

<p style="margin-top: 1em">cat: $$@.c</p>

<p style="margin-top: 1em">that would expand to;</p>

<p style="margin-top: 1em">cat: cat.c</p>

<p style="margin-top: 1em">This feature exists only in the
new version of System V make and, while useful, is not in
wide usage. This means that macros are expanded twice for
prerequisites: once at make&acirc; <br>
file parse time and once at target update time.</p>

<p style="margin-top: 1em">Consideration was given to
adding metarules to the POSIX make. This would make %.o: %.c
the same as .c.o:. This is quite useful and available from
some vendors, but it would <br>
cause too many changes to this make to support. It would
have introduced rule chaining and new substitution rules.
However, the rules for target names have been set to reserve
<br>
the &rsquo;%&rsquo; and &rsquo;&quot;&rsquo; characters.
These are traditionally used to implement metarules and
quoting of target names, respectively. Implementors are
strongly encouraged to use these char&acirc; <br>
acters only for these purposes.</p>

<p style="margin-top: 1em">A request was made to extend the
suffix delimiter character from a &lt;period&gt; to any
character. The metarules feature in newer makes solves this
problem in a more general way. This <br>
volume of POSIX.1&acirc;2008 is staying with the more
conservative historical definition.</p>

<p style="margin-top: 1em">The standard output format for
the &acirc;p option is not described because it is primarily
a debugging option and because the format is not generally
useful to programs. In historical <br>
implementations the output is not suitable for use in
generating makefiles. The &acirc;p format has been variable
across historical implementations. Therefore, the definition
of &acirc;p was <br>
only to provide a consistently named option for obtaining
make script debugging information.</p>

<p style="margin-top: 1em">Some historical implementations
have not cleared the suffix list with &acirc;r.</p>

<p style="margin-top: 1em">Implementations should be aware
that some historical applications have intermixed
target_name and macro=value operands on the command line,
expecting that all of the macros are <br>
processed before any of the targets are dealt with.
Conforming applications do not do this, but some
backwards-compatibility support may be warranted.</p>

<p style="margin-top: 1em">Empty inference rules are
specified with a &lt;semicolon&gt; command rather than
omitting all commands, as described in an early proposal.
The latter case has no traditional meaning <br>
and is reserved for implementation extensions, such as in
GNU make.</p>

<p style="margin-top: 1em">FUTURE DIRECTIONS <br>
None.</p>

<p style="margin-top: 1em">SEE ALSO <br>
Chapter 2, Shell Command Language, ar, c99, get, lex, sccs,
sh, yacc</p>

<p style="margin-top: 1em">The Base Definitions volume of
POSIX.1&acirc;2008, Section 6.1, Portable Character Set,
Chapter 8, Environment Variables, Section 12.2, Utility
Syntax Guidelines</p>

<p style="margin-top: 1em">The System Interfaces volume of
POSIX.1&acirc;2008, exec, system()</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Portions of this text are reprinted and reproduced in
electronic form from IEEE Std 1003.1, 2013 Edition, Standard
for Information Technology -- Portable Operating System
Inter&acirc; <br>
face (POSIX), The Open Group Base Specifications Issue 7,
Copyright (C) 2013 by the Institute of Electrical and
Electronics Engineers, Inc and The Open Group. (This is <br>
POSIX.1-2008 with the 2013 Technical Corrigendum 1 applied.)
In the event of any discrepancy between this version and the
original IEEE and The Open Group Standard, the original <br>
IEEE and The Open Group Standard is the referee document.
The original Standard can be obtained online at
http://www.unix.org/online.html .</p>

<p style="margin-top: 1em">Any typographical or formatting
errors that appear in this page are most likely to have been
introduced during the conversion of the source files to man
page format. To report <br>
such errors, see
https://www.kernel.org/doc/man-pages/reporting_bugs.html
.</p>

<p style="margin-top: 1em">IEEE/The Open Group 2013
MAKE(1POSIX)</p>
<hr>
</body>
</html>
