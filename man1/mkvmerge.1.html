<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:25:43 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MKVMERGE(1) User Commands MKVMERGE(1)</p>

<p style="margin-top: 1em">NAME <br>
mkvmerge - Merge multimedia streams into a Matroska(TM)
file</p>

<p style="margin-top: 1em">SYNOPSIS <br>
mkvmerge [global options] {-o out} [options1] {file1}
[[options2] {file2}] [@options-file.json]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This program takes the input from several media files and
joins their streams (all of them or just a selection) into a
Matroska(TM) file; see the Matroska(TM) website[1].</p>

<p style="margin-top: 1em">Important <br>
The order of command line options is important. Please read
the section &quot;Option order&quot; if you&rsquo;re new to
the program.</p>

<p style="margin-top: 1em">Global options <br>
-v, --verbose <br>
Increase verbosity.</p>

<p style="margin-top: 1em">-q, --quiet <br>
Suppress status output.</p>

<p style="margin-top: 1em">-o, --output file-name <br>
Write to the file file-name. If splitting is used then this
parameter is treated a bit differently. See the explanation
for the --split option for details.</p>

<p style="margin-top: 1em">-w, --webm <br>
Create a WebM compliant file. This is also turned on if the
output file name&rsquo;s extension is &quot;webm&quot;. This
mode enforces several restrictions. The only allowed codecs
are VP8, <br>
VP9 video and Opus, Vorbis audio tracks. The DocType header
item is changed to &quot;webm&quot;.</p>

<p style="margin-top: 1em">For chapters and tags only a
subset of elements are allowed. mkvmerge(1) will
automatically remove all elements not allowed by the
specification.</p>

<p style="margin-top: 1em">--title title <br>
Sets the general title for the output file, e.g. the movie
name.</p>

<p style="margin-top: 1em">--default-language language-code
<br>
Sets the default language code that will be used for tracks
for which no language is set with the --language option and
for which the source container doesn&rsquo;t provide a <br>
language.</p>

<p style="margin-top: 1em">The default language code is
&rsquo;und&rsquo; for &rsquo;undefined&rsquo;.</p>

<p style="margin-top: 1em">Segment info handling (global
options) <br>
--segmentinfo filename.xml <br>
Read segment information from a XML file. This file can
contain the segment family UID, segment UID, previous and
next segment UID elements. An example file and a DTD are
<br>
included in the MKVToolNix distribution.</p>

<p style="margin-top: 1em">See the section about segment
info XML files below for details.</p>

<p style="margin-top: 1em">--segment-uid SID1,SID2,... <br>
Sets the segment UIDs to use. This is a comma-separated list
of 128bit segment UIDs in the usual UID form: hex numbers
with or without the &quot;0x&quot; prefix, with or without
<br>
spaces, exactly 32 digits.</p>

<p style="margin-top: 1em">If SID starts with = then its
rest is interpreted as the name of a Matroska file whose
segment UID is read and used.</p>

<p style="margin-top: 1em">Each file created contains one
segment, and each segment has one segment UID. If more
segment UIDs are specified than segments are created then
the surplus UIDs are ignored. <br>
If fewer UIDs are specified than segments are created then
random UIDs will be created for them.</p>

<p style="margin-top: 1em">Chapter and tag handling (global
options) <br>
--chapter-language language-code <br>
Sets the ISO639-2 language code that is written for each
chapter entry. Defaults to &rsquo;eng&rsquo;. See the
section about chapters below for details.</p>

<p style="margin-top: 1em">This option can be used both for
simple chapter files and for source files that contain
chapters but no information about the chapters&rsquo;
language, e.g. MP4 and OGM files.</p>

<p style="margin-top: 1em">The language set with this
option is also used when chapters are generated with the
--generate-chapters option.</p>

<p style="margin-top: 1em">--chapter-charset character-set
<br>
Sets the character set that is used for the conversion to
UTF-8 for simple chapter files. See the section about text
files and character sets for an explanation how <br>
mkvmerge(1) converts between character sets.</p>

<p style="margin-top: 1em">This switch does also apply to
chapters that are copied from certain container types, e.g.
Ogg/OGM and MP4 files. See the section about chapters below
for details.</p>

<p style="margin-top: 1em">--generate-chapters mode <br>
mkvmerge(1) can create chapters automatically. The following
two modes are currently supported:</p>

<p style="margin-top: 1em">&Acirc;&middot;
&rsquo;when-appending&rsquo; &acirc; This mode creates one
chapter at the start and one chapter whenever a file is
appended.</p>

<p style="margin-top: 1em">Note <br>
mkvmerge(1) requires a video or an audio track to be present
in order to be able to determine when a new file is
appended. If one or more video tracks are muxed the <br>
first one is used. Otherwise the first audio track is
used.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&rsquo;interval:time-spec&rsquo; &acirc; This mode creates
one chapter at fixed intervals given by time-spec. The
format is either the form HH:MM:SS.nnnnnnnnn or a number
followed by one <br>
of the units &rsquo;s&rsquo;, &rsquo;ms&rsquo; or
&rsquo;us&rsquo;.</p>

<p style="margin-top: 1em">Example: --generate-chapters
interval:45s</p>

<p style="margin-top: 1em">The names for the new chapters
are controlled by the option
--generate-chapters-name-template. The language is set with
--chapter-language which must occur before <br>
--generate-chapters.</p>


<p style="margin-top: 1em">--generate-chapters-name-template
template <br>
This sets the name template for chapter names generated by
the option --generate-chapters. If the option is not used
then default &rsquo;Chapter &lt;NUM:2&gt;&rsquo; will be
used.</p>

<p style="margin-top: 1em">There are several variables that
can be used in the template that are replaced by their
actual values when a chapter is generated. The string
&rsquo;&lt;NUM&gt;&rsquo; will be replaced by the <br>
chapter number. The string &rsquo;&lt;START&gt;&rsquo; will
be replaced by the chapter&rsquo;s start timestamp.</p>

<p style="margin-top: 1em">The strings
&rsquo;&lt;FILE_NAME&gt;&rsquo; and
&rsquo;&lt;FILE_NAME_WITH_EXT&gt;&rsquo; are only filled
when generating chapters for appended files. They will be
replaced by the appended file&rsquo;s name wihtout <br>
respectively with its extension. Note that only the
file&rsquo;s base name and extension are inserted, not its
directory or drive components.</p>

<p style="margin-top: 1em">You can specify a minimum number
of places for the chapter number with
&rsquo;&lt;NUM:places&gt;&rsquo;, e.g.
&rsquo;&lt;NUM:3&gt;&rsquo;. The resulting number will be
padded with leading zeroes if the number <br>
of places is less than specified.</p>

<p style="margin-top: 1em">You can control the format used
by the start timestamp with &lt;START:format&gt;. The format
defaults to &rsquo;%H:%M:%S&rsquo; if none is given. Valid
format codes are:</p>

<p style="margin-top: 1em">&Acirc;&middot; %h &acirc;
hours</p>

<p style="margin-top: 1em">&Acirc;&middot; %H &acirc; hours
zero-padded to two places</p>

<p style="margin-top: 1em">&Acirc;&middot; %m &acirc;
minutes</p>

<p style="margin-top: 1em">&Acirc;&middot; %M &acirc;
minutes zero-padded to two places</p>

<p style="margin-top: 1em">&Acirc;&middot; %s &acirc;
seconds</p>

<p style="margin-top: 1em">&Acirc;&middot; %S &acirc;
seconds zero-padded to two places</p>

<p style="margin-top: 1em">&Acirc;&middot; %n &acirc;
nanoseconds with nine places</p>

<p style="margin-top: 1em">&Acirc;&middot; %&lt;1-9&gt;n
&acirc; nanoseconds with up to nine places (e.g. three
places with %3n)</p>

<p style="margin-top: 1em">--cue-chapter-name-format format
<br>
mkvmerge(1) supports reading CUE sheets for audio files as
the input for chapters. CUE sheets usually contain the
entries PERFORMER and TITLE for each index entry. <br>
mkvmerge(1) uses these two strings in order to construct the
chapter name. With this option the format used for this name
can be set.</p>

<p style="margin-top: 1em">If this option is not given then
mkvmerge(1) defaults to the format &rsquo;%p - %t&rsquo;
(the performer, followed by a space, a dash, another space
and the title).</p>

<p style="margin-top: 1em">If the format is given then
everything except the following meta characters is copied
as-is, and the meta characters are replaced like this:</p>

<p style="margin-top: 1em">&Acirc;&middot; %p is replaced
by the current entry&rsquo;s PERFORMER string,</p>

<p style="margin-top: 1em">&Acirc;&middot; %t is replaced
by the current entry&rsquo;s TITLE string,</p>

<p style="margin-top: 1em">&Acirc;&middot; %n is replaced
by the current track number and</p>

<p style="margin-top: 1em">&Acirc;&middot; %N is replaced
by the current track number padded with a leading zero if it
is &lt; 10.</p>

<p style="margin-top: 1em">--chapters file-name <br>
Read chapter information from the file file-name. See the
section about chapters below for details.</p>

<p style="margin-top: 1em">--global-tags file-name <br>
Read global tags from the file file-name. See the section
about tags below for details.</p>

<p style="margin-top: 1em">General output control (advanced
global options) <br>
--track-order FID1:TID1,FID2:TID2,... <br>
This option changes the order in which the tracks for an
input file are created. The argument is a comma separated
list of pairs IDs. Each pair contains first the file ID <br>
(FID1) which is simply the number of the file on the command
line starting at 0. The second is a track ID (TID1) from
that file. If some track IDs are omitted then those <br>
tracks are created after the ones given with this option
have been created.</p>

<p style="margin-top: 1em">--cluster-length spec <br>
Limit the number of data blocks or the duration of data in
each cluster. The spec parameter can either be a number n
without a unit or a number d postfixed with
&rsquo;ms&rsquo;.</p>

<p style="margin-top: 1em">If no unit is used then
mkvmerge(1) will put at most n data blocks into each
cluster. The maximum number of blocks is 65535.</p>

<p style="margin-top: 1em">If the number d is postfixed
with &rsquo;ms&rsquo; then mkvmerge(1) puts at most d
milliseconds of data into each cluster. The minimum for d is
&rsquo;100ms&rsquo;, and the maximum is
&rsquo;32000ms&rsquo;.</p>

<p style="margin-top: 1em">mkvmerge(1) defaults to putting
at most 65535 data blocks and 5000ms of data into a
cluster.</p>

<p style="margin-top: 1em">Programs trying to find a
certain frame can only seek directly to a cluster and have
to read the whole cluster afterwards. Therefore creating
larger clusters may lead to <br>
imprecise or slow seeking.</p>

<p style="margin-top: 1em">--no-cues <br>
Tells mkvmerge(1) not to create and write the cue data which
can be compared to an index in an AVI. Matroska(TM) files
can be played back without the cue data, but seeking <br>
will probably be imprecise and slower. Use this only if
you&rsquo;re really desperate for space or for testing
purposes. See also option --cues which can be specified for
each <br>
input file.</p>

<p style="margin-top: 1em">--clusters-in-meta-seek <br>
Tells mkvmerge(1) to create a meta seek element at the end
of the file containing all clusters. See also the section
about the Matroska(TM) file layout.</p>

<p style="margin-top: 1em">--disable-lacing <br>
Disables lacing for all tracks. This will increase the
file&rsquo;s size, especially if there are many audio
tracks. This option is not intended for everyday use.</p>

<p style="margin-top: 1em">--enable-durations <br>
Write durations for all blocks. This will increase file size
and does not offer any additional value for players at the
moment.</p>

<p style="margin-top: 1em">--disable-track-statistics-tags
<br>
Normally mkvmerge(1) will write certain tags with statistics
for each track. If such tags are already present then they
will be overwritten. The tags are BPS, DURATION, <br>
NUMBER_OF_BYTES and NUMBER_OF_FRAMES.</p>

<p style="margin-top: 1em">Enabling this option prevents
mkvmerge(1) from writing those tags and from touching any
existing tags with same names.</p>

<p style="margin-top: 1em">--timecode-scale factor <br>
Forces the timecode scale factor to factor. Valid values are
in the range 1000..10000000 or the special value -1.</p>

<p style="margin-top: 1em">Normally mkvmerge(1) will use a
value of 1000000 which means that timecodes and durations
will have a precision of 1ms. For files that will not
contain a video track but at <br>
least one audio track mkvmerge(1) will automatically chose a
timecode scale factor so that all timecodes and durations
have a precision of one audio sample. This causes <br>
bigger overhead but allows precise seeking and
extraction.</p>

<p style="margin-top: 1em">If the special value -1 is used
then mkvmerge(1) will use sample precision even if a video
track is present.</p>

<p style="margin-top: 1em">File splitting, linking,
appending and concatenation (more global options) <br>
--split specification <br>
Splits the output file after a given size or a given time.
Please note that tracks can only be split right before a key
frame. Due to buffering mkvmerge(1) will split right <br>
before the next key frame after the split point has been
reached. Therefore the split point may be a bit off from
what the user has specified.</p>

<p style="margin-top: 1em">At the moment mkvmerge(1)
supports four different modes.</p>

<p style="margin-top: 1em">1. Splitting by size.</p>

<p style="margin-top: 1em">Syntax: --split
[size:]d[k|m|g]</p>

<p style="margin-top: 1em">Examples: --split size:700m or
--split 150000000</p>

<p style="margin-top: 1em">The parameter d may end with
&rsquo;k&rsquo;, &rsquo;m&rsquo; or &rsquo;g&rsquo; to
indicate that the size is in KB, MB or GB respectively.
Otherwise a size in bytes is assumed. After the current
output <br>
file has reached this size limit a new one will be
started.</p>

<p style="margin-top: 1em">The &rsquo;size:&rsquo; prefix
may be omitted for compatibility reasons.</p>

<p style="margin-top: 1em">2. Splitting after a
duration.</p>

<p style="margin-top: 1em">Syntax: --split
[duration:]HH:MM:SS.nnnnnnnnn|ds</p>

<p style="margin-top: 1em">Examples: --split
duration:00:60:00.000 or --split 3600s</p>

<p style="margin-top: 1em">The parameter must either have
the form HH:MM:SS.nnnnnnnnn for specifying the duration in
up to nano-second precision or be a number d followed by the
letter &rsquo;s&rsquo; for the <br>
duration in seconds. HH is the number of hours, MM the
number of minutes, SS the number of seconds and nnnnnnnnn
the number of nanoseconds. Both the number of hours and <br>
the number of nanoseconds can be omitted. There can be up to
nine digits after the decimal point. After the duration of
the contents in the current output has reached <br>
this limit a new output file will be started.</p>

<p style="margin-top: 1em">The &rsquo;duration:&rsquo;
prefix may be omitted for compatibility reasons.</p>

<p style="margin-top: 1em">3. Splitting after specific
timecodes.</p>

<p style="margin-top: 1em">Syntax: --split
timecodes:A[,B[,C...]]</p>

<p style="margin-top: 1em">Example: --split
timecodes:00:45:00.000,01:20:00.250,6300s</p>

<p style="margin-top: 1em">The parameters A, B, C etc must
all have the same format as the ones used for the duration
(see above). The list of timecodes is separated by commas.
After the input <br>
stream has reached the current split point&rsquo;s timecode
a new file is created. Then the next split point given in
this list is used.</p>

<p style="margin-top: 1em">The &rsquo;timecodes:&rsquo;
prefix must not be omitted.</p>

<p style="margin-top: 1em">4. Keeping specific parts by
specifying timecode ranges while discarding others.</p>

<p style="margin-top: 1em">Syntax: --split
parts:start1-end1[,[+]start2-end2[,[+]start3-end3...]]</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">1. --split
parts:00:01:20-00:02:45,00:05:50-00:10:30</p>

<p style="margin-top: 1em">2. --split
parts:00:01:20-00:02:45,+00:05:50-00:10:30</p>

<p style="margin-top: 1em">3. --split
parts:-00:02:45,00:05:50-</p>

<p style="margin-top: 1em">The parts mode tells mkvmerge(1)
to keep certain ranges of timecodes while discarding others.
The ranges to keep have to be listed after the parts:
keyword and be <br>
separated by commas. A range itself consists of a start and
an end timecode in the same format the other variations of
--split accept (e.g. both 00:01:20 and 80s refer to <br>
the same timecode).</p>

<p style="margin-top: 1em">If a start timecode is left out
then it defaults to the previous range&rsquo;s end timecode.
If there was no previous range then it defaults to the start
of the file (see <br>
example 3).</p>

<p style="margin-top: 1em">If an end timecode is left out
then it defaults to the end of the source files which
basically tells mkvmerge(1) to keep the rest (see example
3).</p>

<p style="margin-top: 1em">Normally each range will be
written to a new file. This can be changed so that
consecutive ranges are written to the same file. For that
the user has to prefix the start <br>
timecode with a +. This tells mkvmerge(1) not to create a
new file and instead append the range to the same file the
previous range was written to. Timecodes will be <br>
adjusted so that there will be no gap in the output file
even if there was a gap in the two ranges in the input
file.</p>

<p style="margin-top: 1em">In example 1 mkvmerge(1) will
create two files. The first will contain the content
starting from 00:01:20 until 00:02:45. The second file will
contain the content <br>
starting from 00:05:50 until 00:10:30.</p>

<p style="margin-top: 1em">In example 2 mkvmerge(1) will
create only one file. This file will contain both the
content starting from 00:01:20 until 00:02:45 and the
content starting from 00:05:50 <br>
until 00:10:30.</p>

<p style="margin-top: 1em">In example 3 mkvmerge(1) will
create two files. The first will contain the content from
the start of the source files until 00:02:45. The second
file will contain the <br>
content starting from 00:05:50 until the end of the source
files.</p>

<p style="margin-top: 1em">Note <br>
Note that mkvmerge(1) only makes decisions about splitting
at key frame positions. This applies to both the start and
the end of each range. So even if an end <br>
timecode is between two key frames mkvmerge(1) will continue
outputting the frames up to but excluding the following key
frame.</p>

<p style="margin-top: 1em">5. Keeping specific parts by
specifying frame/field number ranges while discarding
others.</p>

<p style="margin-top: 1em">Syntax: --split
parts-frames:start1-end1[,[+]start2-end2[,[+]start3-end3...]]</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">1. --split
parts-frames:137-258,548-1211</p>

<p style="margin-top: 1em">2. --split
parts-frames:733-912,+1592-2730</p>

<p style="margin-top: 1em">3. --split
parts-frames:-430,2512-</p>

<p style="margin-top: 1em">The parts-frames mode tells
mkvmerge(1) to keep certain ranges of frame/field numbers
while discarding others. The ranges to keep have to be
listed after the <br>
parts-frames: keyword and be separated by commas. A range
itself consists of a start and an end frame/field number.
Numbering starts at 1.</p>

<p style="margin-top: 1em">If a start number is left out
then it defaults to the previous range&rsquo;s end number.
If there was no previous range then it defaults to the start
of the file (see example <br>
3).</p>

<p style="margin-top: 1em">If an end number is left out
then it defaults to the end of the source files which
basically tells mkvmerge(1) to keep the rest (see example
3).</p>

<p style="margin-top: 1em">Normally each range will be
written to a new file. This can be changed so that
consecutive ranges are written to the same file. For that
the user has to prefix the start <br>
number with a +. This tells mkvmerge(1) not to create a new
file and instead append the range to the same file the
previous range was written to. Timecodes will be <br>
adjusted so that there will be no gap in the output file
even if there was a gap in the two ranges in the input
file.</p>

<p style="margin-top: 1em">Note <br>
Note that mkvmerge(1) only makes decisions about splitting
at key frame positions. This applies to both the start and
the end of each range. So even if an end <br>
frame/field number is between two key frames mkvmerge(1)
will continue outputting the frames up to but excluding the
following key frame. <br>
In example 1 mkvmerge(1) will create two files. The first
will contain the content starting from the first key frame
at or after 137 up to but excluding the first key <br>
frame at or after 258. The second file will contain the
content starting from 548 until 1211.</p>

<p style="margin-top: 1em">In example 2 mkvmerge(1) will
create only one file. This file will contain both the
content starting from 733 until 912 and the content starting
from 1592 until 2730.</p>

<p style="margin-top: 1em">In example 3 mkvmerge(1) will
create two files. The first will contain the content from
the start of the source files until 430. The second file
will contain the content <br>
starting from 2512 until the end of the source files.</p>

<p style="margin-top: 1em">This mode considers only the
first video track that is output. If no video track is
output no splitting will occur.</p>

<p style="margin-top: 1em">Note <br>
The numbers given with this argument are interpreted based
on the number of Matroska(TM) blocks that are output. A
single Matroska(TM) block contains either a full <br>
frame (for progressive content) or a single field (for
interlaced content). mkvmerge does not distinguish between
those two and simply counts the number of blocks. <br>
For example: If one wanted to split after the 25th full
frame with interlaced content one would have to use 50 (two
fields per full frame) as the split point.</p>

<p style="margin-top: 1em">6. Splitting after specific
frames/fields.</p>

<p style="margin-top: 1em">Syntax: --split
frames:A[,B[,C...]]</p>

<p style="margin-top: 1em">Example: --split
frames:120,237,891</p>

<p style="margin-top: 1em">The parameters A, B, C etc must
all be positive integers. Numbering starts at 1. The list of
frame/field numbers is separated by commas. After the input
stream has <br>
reached the current split point&rsquo;s frame/field number a
new file is created. Then the next split point given in this
list is used.</p>

<p style="margin-top: 1em">The &rsquo;frames:&rsquo; prefix
must not be omitted.</p>

<p style="margin-top: 1em">This mode considers only the
first video track that is output. If no video track is
output no splitting will occur.</p>

<p style="margin-top: 1em">Note <br>
The numbers given with this argument are interpreted based
on the number of Matroska(TM) blocks that are output. A
single Matroska(TM) block contains either a full <br>
frame (for progressive content) or a single field (for
interlaced content). mkvmerge does not distinguish between
those two and simply counts the number of blocks. <br>
For example: If one wanted to split after the 25th full
frame with interlaced content one would have to use 50 (two
fields per full frame) as the split point.</p>

<p style="margin-top: 1em">7. Splitting before specific
chapters.</p>

<p style="margin-top: 1em">Syntax: --split chapters:all or
--split chapters:A[,B[,C...]]</p>

<p style="margin-top: 1em">Example: --split
chapters:5,8</p>

<p style="margin-top: 1em">The parameters A, B, C etc must
all be positive integers. Numbering starts at 1. The list of
chapter numbers is separated by commas. Splitting will occur
right before the <br>
first key frame whose timecode is equal to or bigger than
the start timecode for the chapters whose numbers are
listed. A chapter starting at 0s is never considered for
<br>
splitting and discarded silently.</p>

<p style="margin-top: 1em">The keyword all can be used
instead of listing all chapter numbers manually.</p>

<p style="margin-top: 1em">The &rsquo;chapters:&rsquo;
prefix must not be omitted.</p>

<p style="margin-top: 1em">Note <br>
The Matroska(TM) file format supports arbitrary deeply
nested chapter structures called &rsquo;edition
entries&rsquo; and &rsquo;chapter atoms&rsquo;. However,
this mode only considers the <br>
top-most level of chapters across all edition entries.</p>

<p style="margin-top: 1em">For this splitting mode the
output filename is treated differently than for the normal
operation. It may contain a printf like expression
&rsquo;%d&rsquo; including an optional field <br>
width, e.g. &rsquo;%02d&rsquo;. If it does then the current
file number will be formatted appropriately and inserted at
that point in the filename. If there is no such pattern then
a <br>
pattern of &rsquo;-%03d&rsquo; is assumed right before the
file&rsquo;s extension: &rsquo;-o output.mkv&rsquo; would
result in &rsquo;output-001.mkv&rsquo; and so on. If
there&rsquo;s no extension then &rsquo;-%03d&rsquo; will be
<br>
appended to the name.</p>

<p style="margin-top: 1em">--link <br>
Link files to one another when splitting the output file.
See the section on file linking below for details.</p>

<p style="margin-top: 1em">--link-to-previous segment-UID
<br>
Links the first output file to the segment with the segment
UID given by the segment-UID parameter. See the section on
file linking below for details.</p>

<p style="margin-top: 1em">If SID starts with = then its
rest is interpreted as the name of a Matroska file whose
segment UID is read and used.</p>

<p style="margin-top: 1em">--link-to-next segment-UID <br>
Links the last output file to the segment with the segment
UID given by the segment-UID parameter. See the section on
file linking below for details.</p>

<p style="margin-top: 1em">If SID starts with = then its
rest is interpreted as the name of a Matroska file whose
segment UID is read and used.</p>

<p style="margin-top: 1em">--append-mode mode <br>
Determines how timecodes are calculated when appending
files. The parameter mode can have two values:
&rsquo;file&rsquo; which is also the default and
&rsquo;track&rsquo;.</p>

<p style="margin-top: 1em">When mkvmerge appends a track
(called &rsquo;track2_1&rsquo; from now on) from a second
file (called &rsquo;file2&rsquo;) to a track (called
&rsquo;track1_1&rsquo;) from the first file (called
&rsquo;file1&rsquo;) then it <br>
has to offset all timecodes for &rsquo;track2_1&rsquo; by an
amount. For &rsquo;file&rsquo; mode this amount is the
highest timecode encountered in &rsquo;file1&rsquo; even if
that timecode was from a different <br>
track than &rsquo;track1_1&rsquo;. In track mode the offset
is the highest timecode of &rsquo;track1_1&rsquo;.</p>

<p style="margin-top: 1em">Unfortunately mkvmerge cannot
detect which mode to use reliably. Therefore it defaults to
&rsquo;file&rsquo; mode. &rsquo;file&rsquo; mode usually
works better for files that have been created <br>
independently of each other; e.g. when appending AVI or MP4
files. &rsquo;track&rsquo; mode may work better for sources
that are essentially just parts of one big file, e.g. for
VOB and <br>
EVO files.</p>

<p style="margin-top: 1em">Subtitle tracks are always
treated as if &rsquo;file&rsquo; mode were active even if
&rsquo;track&rsquo; mode actually is.</p>

<p style="margin-top: 1em">--append-to
SFID1:STID1:DFID1:DTID1[,...] <br>
This option controls to which track another track is
appended. Each spec contains four IDs: a file ID, a track
ID, a second file ID and a second track ID. The first pair,
<br>
&quot;source file ID&quot; and &quot;source track ID&quot;,
identifies the track that is to be appended. The second
pair, &quot;destination file ID&quot; and &quot;destination
track ID&quot;, identifies the track <br>
the first one is appended to.</p>

<p style="margin-top: 1em">If this option has been omitted
then a standard mapping is used. This standard mapping
appends each track from the current file to a track from the
previous file with the <br>
same track ID. This allows for easy appending if a movie has
been split into two parts and both file have the same number
of tracks and track IDs with the command mkvmerge -o <br>
output.mkv part1.mkv +part2.mkv.</p>

<p style="margin-top: 1em">+ <br>
A single &rsquo;+&rsquo; causes the next file to be appended
instead of added. The &rsquo;+&rsquo; can also be put in
front of the next file name. Therefore the following two
commands are <br>
equivalent:</p>

<p style="margin-top: 1em">$ mkvmerge -o full.mkv file1.mkv
+ file2.mkv <br>
$ mkvmerge -o full.mkv file1.mkv +file2.mkv</p>

<p style="margin-top: 1em">[ file1 file2 ] <br>
If multiple file names are contained in a pair of square
brackets then the second and all following files will be
appended to the first file named within the brackets.</p>

<p style="margin-top: 1em">This is an alternative syntax to
using &rsquo;+&rsquo; between the file names. Therefore the
following two commands are equivalent:</p>

<p style="margin-top: 1em">$ mkvmerge -o full.mkv file1.mkv
+ file2.mkv <br>
$ mkvmerge -o full.mkv &rsquo;[&rsquo; file1.mkv file2.mkv
&rsquo;]&rsquo;</p>

<p style="margin-top: 1em">= <br>
Normally mkvmerge(1) looks for files in the same directory
as an input file that have the same base name and only
differ in their running number (e.g.
&rsquo;VTS_01_1.VOB&rsquo;, <br>
&rsquo;VTS_01_2.VOB&rsquo;, &rsquo;VTS_01_3.VOB&rsquo; etc)
and treats all of those files as if they were concatenated
into a single big file. This option, a single
&rsquo;=&rsquo;, causes mkvmerge not to look <br>
for those additional files.</p>

<p style="margin-top: 1em">The &rsquo;=&rsquo; can also be
put in front of the next file name. Therefore the following
two commands are equivalent:</p>

<p style="margin-top: 1em">$ mkvmerge -o full.mkv =
file1.mkv <br>
$ mkvmerge -o full.mkv =file1.mkv</p>

<p style="margin-top: 1em">( file1 file2 ) <br>
If multiple file names are contained in a pair of
parenthesis then those files will be treated as if they were
concatenated into a single big file consisting of the
content <br>
of each of the files one after the other.</p>

<p style="margin-top: 1em">This can be used for e.g. VOB
files coming from a DVD or MPEG transport streams. It cannot
be used if each file contains its own set of headers which
is usually the case with <br>
stand-alone files like AVI or MP4.</p>

<p style="margin-top: 1em">Putting a file name into
parenthesis also prevents mkvmerge(1) from looking for
additional files with the same base name as described in
option =. Therefore these two command <br>
lines are equivalent:</p>

<p style="margin-top: 1em">$ mkvmerge -o out.mkv = file.mkv
<br>
$ mkvmerge -o out.mkv &rsquo;(&rsquo; file.mkv
&rsquo;)&rsquo;</p>

<p style="margin-top: 1em">Several things should be
noted:</p>

<p style="margin-top: 1em">1. There must be spaces both
after the opening and before the closing parenthesis.</p>

<p style="margin-top: 1em">2. Every parameter between
parenthesis is interpreted as a file name. Therefore all
options applying to this logical file must be listed before
the opening parenthesis.</p>

<p style="margin-top: 1em">3. Some shells treat parenthesis
as special characters. Hence you must escape or quote them
as shown in the example above.</p>

<p style="margin-top: 1em">Attachment support (more global
options) <br>
--attachment-description description <br>
Plain text description of the following attachment. Applies
to the next --attach-file or --attach-file-once option.</p>

<p style="margin-top: 1em">--attachment-mime-type MIME type
<br>
MIME type of the following attachment. Applies to the next
--attach-file or --attach-file-once option. A list of
officially recognized MIME types can be found e.g. at the
<br>
IANA homepage[2]. The MIME type is mandatory for an
attachment.</p>

<p style="margin-top: 1em">--attachment-name name <br>
Sets the name that will be stored in the output file for
this attachment. If this option is not given then the name
will be derived from the file name of the attachment as <br>
given with the --attach-file or the --attach-file-once
option.</p>

<p style="margin-top: 1em">--attach-file file-name,
--attach-file-once file-name <br>
Creates a file attachment inside the Matroska(TM) file. The
MIME type must have been set before this option can used.
The difference between the two forms is that during <br>
splitting the files attached with --attach-file are attached
to all output files while the ones attached with
--attach-file-once are only attached to the first file
created. <br>
If splitting is not used then both do the same.</p>

<p style="margin-top: 1em">mkvextract(1) can be used to
extract attached files from a Matroska(TM) file.</p>

<p style="margin-top: 1em">Options that can be used for
each input file <br>
-a, --audio-tracks [!]n,m,... <br>
Copy the audio tracks n, m etc. The numbers are track IDs
which can be obtained with the --identify switch.
They&rsquo;re not simply the track numbers (see section
track IDs). <br>
Default: copy all audio tracks.</p>

<p style="margin-top: 1em">Instead of track IDs you can
also provide ISO 639-2 language codes. This will only work
for source files that provide language tags for their
tracks.</p>

<p style="margin-top: 1em">Default: copy all tracks of this
kind.</p>

<p style="margin-top: 1em">If the IDs are prefixed with !
then the meaning is reversed: copy all tracks of this kind
but the ones listed after the !.</p>

<p style="margin-top: 1em">-d, --video-tracks [!]n,m,...
<br>
Copy the video tracks n, m etc. The numbers are track IDs
which can be obtained with the --identify switch.
They&rsquo;re not simply the track numbers (see section
track IDs). <br>
Default: copy all video tracks.</p>

<p style="margin-top: 1em">Instead of track IDs you can
also provide ISO 639-2 language codes. This will only work
for source files that provide language tags for their
tracks.</p>

<p style="margin-top: 1em">If the IDs are prefixed with !
then the meaning is reversed: copy all tracks of this kind
but the ones listed after the !.</p>

<p style="margin-top: 1em">-s, --subtitle-tracks [!]n,m,...
<br>
Copy the subtitle tracks n, m etc. The numbers are track IDs
which can be obtained with the --identify switch.
They&rsquo;re not simply the track numbers (see section
track IDs). <br>
Default: copy all subtitle tracks.</p>

<p style="margin-top: 1em">Instead of track IDs you can
also provide ISO 639-2 language codes. This will only work
for source files that provide language tags for their
tracks.</p>

<p style="margin-top: 1em">If the IDs are prefixed with !
then the meaning is reversed: copy all tracks of this kind
but the ones listed after the !.</p>

<p style="margin-top: 1em">-b, --button-tracks [!]n,m,...
<br>
Copy the button tracks n, m etc. The numbers are track IDs
which can be obtained with the --identify switch.
They&rsquo;re not simply the track numbers (see section
track IDs). <br>
Default: copy all button tracks.</p>

<p style="margin-top: 1em">Instead of track IDs you can
also provide ISO 639-2 language codes. This will only work
for source files that provide language tags for their
tracks.</p>

<p style="margin-top: 1em">If the IDs are prefixed with !
then the meaning is reversed: copy all tracks of this kind
but the ones listed after the !.</p>

<p style="margin-top: 1em">--track-tags [!]n,m,... <br>
Copy the tags for tracks n, m etc. The numbers are track IDs
which can be obtained with the --identify switch (see
section track IDs). They&rsquo;re not simply the track
numbers. <br>
Default: copy tags for all tracks.</p>

<p style="margin-top: 1em">If the IDs are prefixed with !
then the meaning is reversed: copy everything but the IDs
listed after the !.</p>

<p style="margin-top: 1em">-m, --attachments
[!]n[:all|first],m[:all|first],... <br>
Copy the attachments with the IDs n, m etc to all or only
the first output file. Each ID can be followed by either
&rsquo;:all&rsquo; (which is the default if neither is
entered) or <br>
&rsquo;:first&rsquo;. If splitting is active then those
attachments whose IDs are specified with &rsquo;:all&rsquo;
are copied to all of the resulting output files while the
others are only copied <br>
into the first output file. If splitting is not active then
both variants have the same effect.</p>

<p style="margin-top: 1em">The default is to copy all
attachments to all output files.</p>

<p style="margin-top: 1em">If the IDs are prefixed with !
then the meaning is reversed: copy everything but the IDs
listed after the !.</p>

<p style="margin-top: 1em">-A, --no-audio <br>
Don&rsquo;t copy any audio track from this file.</p>

<p style="margin-top: 1em">-D, --no-video <br>
Don&rsquo;t copy any video track from this file.</p>

<p style="margin-top: 1em">-S, --no-subtitles <br>
Don&rsquo;t copy any subtitle track from this file.</p>

<p style="margin-top: 1em">-B, --no-buttons <br>
Don&rsquo;t copy any button track from this file.</p>

<p style="margin-top: 1em">-T, --no-track-tags <br>
Don&rsquo;t copy any track specific tags from this file.</p>

<p style="margin-top: 1em">--no-chapters <br>
Don&rsquo;t copy chapters from this file.</p>

<p style="margin-top: 1em">-M, --no-attachments <br>
Don&rsquo;t copy attachments from this file.</p>

<p style="margin-top: 1em">--no-global-tags <br>
Don&rsquo;t copy global tags from this file.</p>

<p style="margin-top: 1em">--chapter-charset character-set
<br>
Sets the charset that is used for the conversion to UTF-8
for chapter information contained in the source file. See
the section about text files and character sets for an <br>
explanation how mkvmerge(1) converts between character
sets.</p>

<p style="margin-top: 1em">--chapter-language language-code
<br>
Sets the ISO639-2 language code that is written for each
chapter entry. This option can be used for source files that
contain chapters but no information about the
chapters&rsquo; <br>
languages, e.g. for MP4 and OGM files.</p>

<p style="margin-top: 1em">-y, --sync TID:d[,o[/p]] <br>
Adjust the timecodes of the track with the id TID by d ms.
The track IDs are the same as the ones given with --identify
(see section track IDs).</p>

<p style="margin-top: 1em">o/p: adjust the timestamps by
o/p to fix linear drifts. p defaults to 1 if omitted. Both o
and p can be floating point numbers.</p>

<p style="margin-top: 1em">Defaults: no manual sync
correction (which is the same as d = 0 and o/p = 1.0).</p>

<p style="margin-top: 1em">This option can be used multiple
times for an input file applying to several tracks by
selecting different track IDs each time.</p>

<p style="margin-top: 1em">--cues TID:none|iframes|all <br>
Controls for which tracks cue (index) entries are created
for the given track (see section track IDs).
&rsquo;none&rsquo; inhibits the creation of cue entries. For
&rsquo;iframes&rsquo; only blocks <br>
with no backward or forward references ( = I frames in video
tracks) are put into the cue sheet. &rsquo;all&rsquo; causes
mkvmerge(1) to create cue entries for all blocks which will
make <br>
the file very big.</p>

<p style="margin-top: 1em">The default is
&rsquo;iframes&rsquo; for video and subtitle tracks and
&rsquo;none&rsquo; for audio tracks. See also option
--no-cues which inhibits the creation of cue entries
regardless of the <br>
--cues options used.</p>

<p style="margin-top: 1em">This option can be used multiple
times for an input file applying to several tracks by
selecting different track IDs each time.</p>

<p style="margin-top: 1em">--default-track TID[:bool] <br>
Sets the &rsquo;default&rsquo; flag for the given track (see
section track IDs) if the optional argument bool is not
present. If the user does not explicitly select a track
himself then <br>
the player should prefer the track that has his
&rsquo;default&rsquo; flag set. Only one track of each kind
(audio, video, subtitles, buttons) can have his
&rsquo;default&rsquo; flag set. If the <br>
user wants no track to have the default track flag set then
he has to set bool to 0 for all tracks.</p>

<p style="margin-top: 1em">This option can be used multiple
times for an input file applying to several tracks by
selecting different track IDs each time.</p>

<p style="margin-top: 1em">--forced-track TID[:bool] <br>
Sets the &rsquo;forced&rsquo; flag for the given track (see
section track IDs) if the optional argument bool is not
present. A player must play all tracks for which this flag
is set to <br>
1.</p>

<p style="margin-top: 1em">This option can be used multiple
times for an input file applying to several tracks by
selecting different track IDs each time.</p>

<p style="margin-top: 1em">--blockadd TID:level <br>
Keep only the BlockAdditions up to the level level for the
given track. The default is to keep all levels. This option
only affects certain kinds of codecs like WAVPACK4.</p>

<p style="margin-top: 1em">--track-name TID:name <br>
Sets the track name for the given track (see section track
IDs) to name.</p>

<p style="margin-top: 1em">--language TID:language <br>
Sets the language for the given track (see section track
IDs). Both ISO639-2 language codes and ISO639-1 country
codes are allowed. The country codes will be converted to
<br>
language codes automatically. All languages including their
ISO639-2 codes can be listed with the --list-languages
option.</p>

<p style="margin-top: 1em">This option can be used multiple
times for an input file applying to several tracks by
selecting different track IDs each time.</p>

<p style="margin-top: 1em">-t, --tags TID:file-name <br>
Read tags for the track with the number TID from the file
file-name. See the section about tags below for details.</p>

<p style="margin-top: 1em">--aac-is-sbr TID[:0|1] <br>
Tells mkvmerge(1) that the track with the ID TID is SBR AAC
(also known as HE-AAC or AAC+). This options is needed if a)
the source file is an AAC file (not for a <br>
Matroska(TM) file) and b) the AAC file contains SBR AAC
data. The reason for this switch is that it is technically
impossible to automatically tell normal AAC data from SBR
<br>
AAC data without decoding a complete AAC frame. As there are
several patent issues with AAC decoders mkvmerge(1) will
never contain this decoding stage. So for SBR AAC files <br>
this switch is mandatory. The resulting file might not play
back correctly or even not at all if the switch was
omitted.</p>

<p style="margin-top: 1em">If the source file is a
Matroska(TM) file then the CodecID should be enough to
detect SBR AAC. However, if the CodecID is wrong then this
switch can be used to correct that.</p>

<p style="margin-top: 1em">If mkvmerge wrongfully detects
that an AAC file is SBR then you can add &rsquo;:0&rsquo; to
the track ID.</p>

<p style="margin-top: 1em">--reduce-to-core TID <br>
Some audio codecs have a lossy core and optional extensions
that implement lossless decoding. This option tells
mkvmerge(1) to only copy the core but not the extensions. By
<br>
default mkvmerge(1) copies both the core and the
extensions.</p>

<p style="margin-top: 1em">Currently only DTS tracks are
affected by this option. TrueHD tracks that contain an
embedded AC-3 core are instead presented as two separate
tracks for which the user can <br>
select which track to copy. For DTS such a scheme would not
work as the HD extensions cannot be decoded by themselves
&acirc; unlike the TrueHD data.</p>

<p style="margin-top: 1em">--timecodes TID:file-name <br>
Read the timecodes to be used for the specific track ID from
file-name. These timecodes forcefully override the timecodes
that mkvmerge(1) normally calculates. Read the <br>
section about external timecode files.</p>

<p style="margin-top: 1em">--default-duration TID:x <br>
Forces the default duration of a given track to the
specified value. Also modifies the track&rsquo;s timecodes
to match the default duration. The argument x must be
postfixed with <br>
&rsquo;s&rsquo;, &rsquo;ms&rsquo;, &rsquo;us&rsquo;,
&rsquo;ns&rsquo;, &rsquo;fps&rsquo;, &rsquo;p&rsquo; or
&rsquo;i&rsquo; to specify the default duration in seconds,
milliseconds, microseconds, nanoseconds, &rsquo;frames per
second&rsquo;, &rsquo;progressive frames per <br>
second&rsquo; or &rsquo;interlaced frames per second&rsquo;
respectively. The number x itself can be a floating point
number or a fraction.</p>

<p style="margin-top: 1em">If the default duration is not
forced then mkvmerge will try to derive the track&rsquo;s
default duration from the container and/or the encoded
bitstream for certain track types, <br>
e.g. AVC/h.264 or MPEG-2.</p>

<p style="margin-top: 1em">This option can also be used to
change the FPS of video tracks without having to use an
external timecode file.</p>


<p style="margin-top: 1em">--fix-bitstream-timing-information
TID[:0|1] <br>
Normally mkvmerge(1) does not change the timing information
(frame/field rate) stored in the video bitstream. With this
option that information is adjusted to match the <br>
container timing information. The container timing
information can come from various sources: from the command
line (see option --default-duration), the source container
or <br>
derived from the bitstream.</p>

<p style="margin-top: 1em">Note <br>
This has only been implemented for AVC/h.264 video tracks so
far.</p>

<p style="margin-top: 1em">--nalu-size-length TID:n <br>
Forces the NALU size length to n bytes. This parameter is
only used if the AVC/h.264 elementary stream packetizer is
used. If left out it defaults to 4 bytes, but there are <br>
files that contain frames or slices that are all smaller
than 65536 bytes. For such files you can use this parameter
and decrease the size to 2.</p>

<p style="margin-top: 1em">--compression TID:n <br>
Selects the compression method to be used for the track.
Note that the player also has to support this method. Valid
values are &rsquo;none&rsquo;, &rsquo;zlib&rsquo; and
&rsquo;mpeg4_p2&rsquo;/&rsquo;mpeg4p2&rsquo;.</p>

<p style="margin-top: 1em">The compression method
&rsquo;mpeg4_p2&rsquo;/&rsquo;mpeg4p2&rsquo; is a special
compression method called &rsquo;header removal&rsquo; that
is only available for MPEG4 part 2 video tracks.</p>

<p style="margin-top: 1em">The default for some subtitle
types is &rsquo;zlib&rsquo; compression. This compression
method is also the one that most if not all playback
applications support. Support for other <br>
compression methods other than &rsquo;none&rsquo; is not
assured.</p>

<p style="margin-top: 1em">Options that only apply to video
tracks <br>
-f, --fourcc TID:FourCC <br>
Forces the FourCC to the specified value. Works only for
video tracks in the &rsquo;MS compatibility mode&rsquo;.</p>

<p style="margin-top: 1em">--display-dimensions
TID:widthxheight <br>
Matroska(TM) files contain two values that set the display
properties that a player should scale the image on playback
to: display width and display height. These values can <br>
be set with this option, e.g. &rsquo;1:640x480&rsquo;.</p>

<p style="margin-top: 1em">Another way to specify the
values is to use the --aspect-ratio or the
--aspect-ratio-factor option (see below). These options are
mutually exclusive.</p>

<p style="margin-top: 1em">--aspect-ratio
TID:ratio|width/height <br>
Matroska(TM) files contain two values that set the display
properties that a player should scale the image on playback
to: display width and display height. With this option <br>
mkvmerge(1) will automatically calculate the display width
and display height based on the image&rsquo;s original width
and height and the aspect ratio given with this option. The
<br>
ratio can be given either as a floating point number ratio
or as a fraction &rsquo;width/height&rsquo;, e.g.
&rsquo;16/9&rsquo;.</p>

<p style="margin-top: 1em">Another way to specify the
values is to use the --aspect-ratio-factor or
--display-dimensions options (see above and below). These
options are mutually exclusive.</p>

<p style="margin-top: 1em">--aspect-ratio-factor
TID:factor|n/d <br>
Another way to set the aspect ratio is to specify a factor.
The original aspect ratio is first multiplied with this
factor and used as the target aspect ratio afterwards.</p>

<p style="margin-top: 1em">Another way to specify the
values is to use the --aspect-ratio or --display-dimensions
options (see above). These options are mutually
exclusive.</p>

<p style="margin-top: 1em">--cropping
TID:left,top,right,bottom <br>
Sets the pixel cropping parameters of a video track to the
given values.</p>

<p style="margin-top: 1em">--colour-matrix TID:n <br>
Sets the matrix coefficients of the video used to derive
luma and chroma values from red, green and blue color
primaries. The parameter n is an integer rangeing from 0 and
<br>
10.</p>

<p style="margin-top: 1em">Valid values and their meaning
are:</p>

<p style="margin-top: 1em">0: GBR, 1: BT709, 2:
unspecified, 3: reserved, 4: FCC, 5: BT470BG, 6: SMPTE 170M,
7: SMPTE 240M, 8: YCOCG, 9: BT2020 non-constant luminance,
10: BT2020 constant luminance</p>

<p style="margin-top: 1em">--colour-bits-per-channel TID:n
<br>
Sets the number of coded bits for a colour channel. A value
of 0 indicates that the number of bits is unspecified.</p>

<p style="margin-top: 1em">--chroma-subsample TID:hori,vert
<br>
The amount of pixels to remove in the Cr and Cb channels for
every pixel not removed horizontally/vertically.</p>

<p style="margin-top: 1em">Example: For video with 4:2:0
chroma subsampling, the parameter should be set to
TID:1,1.</p>

<p style="margin-top: 1em">--cb-subsample TID:hori,vert
<br>
The amount of pixels to remove in the Cb channel for every
pixel not removed horizontally/vertically. This is additive
with --chroma-subsample.</p>

<p style="margin-top: 1em">Example: For video with 4:2:1
chroma subsampling, the parameter --chroma-subsample should
be set to TID:1,0 and Cb-subsample should be set to
TID:1,0.</p>

<p style="margin-top: 1em">--chroma-siting TID:hori,vert
<br>
Sets how chroma is sited horizontally/vertically (0:
unspecified, 1: top collocated, 2: half).</p>

<p style="margin-top: 1em">--colour-range TID:n <br>
Sets the clipping of the color ranges (0: unspecified, 1:
broadcast range, 2: full range (no clipping), 3: defined by
MatrixCoefficients/TransferCharacteristics).</p>


<p style="margin-top: 1em">--colour-transfer-characteristics
TID:n <br>
The transfer characteristics of the video.</p>

<p style="margin-top: 1em">Valid values and their meaning
are:</p>

<p style="margin-top: 1em">0: reserved, 1: ITU-R BT.709, 2:
unspecified, 3: reserved, 4: gamma 2.2 curve, 5: gamma 2.8
curve, 6: SMPTE 170M, 7: SMPTE 240M, 8: linear, 9: log, 10:
log sqrt, 11: IEC <br>
61966-2-4, 12: ITU-R BT.1361 extended colour gamut, 13: IEC
61966-2-1, 14: ITU-R BT.2020 10 bit, 15: ITU-R BT.2020 12
bit, 16: SMPTE ST 2084, 17: SMPTE ST 428-1; 18: ARIB <br>
STD-B67 (HLG)</p>

<p style="margin-top: 1em">--colour-primaries TID:n <br>
Sets the colour primaries of the video.</p>

<p style="margin-top: 1em">Valid values and their meaning
are:</p>

<p style="margin-top: 1em">0: reserved, 1: ITU-R BT.709, 2:
unspecified, 3: reserved, 4: ITU-R BT.470M, 5: ITU-R
BT.470BG, 6: SMPTE 170M, 7: SMPTE 240M, 8: FILM, 9: ITU-R
BT.2020, 10: SMPTE ST 428-1, <br>
22: JEDEC P22 phosphors</p>

<p style="margin-top: 1em">--max-content-light TID:n <br>
Sets the maximum brightness of a single pixel (Maximum
Content Light Level) in candelas per square meter
(cd/m&Acirc;&sup2;). The value of n should be a non-negtive
integer.</p>

<p style="margin-top: 1em">--max-frame-light TID:n <br>
Sets the maximum brightness of a single full frame (Maximum
Frame-Average Light Level) in candelas per square meter
(cd/m&Acirc;&sup2;). The value of n should be a non-negtive
integer.</p>

<p style="margin-top: 1em">--chromaticity-coordinates
TID:red-x,red-y,green-x,green-y,blue-x,blue-y <br>
Sets the red/green/blue chromaticity coordinates as defined
by CIE 1931.</p>

<p style="margin-top: 1em">--white-colour-coordinates
TID:x,y <br>
Sets the white colour chromaticity coordinates as defined by
CIE 1931.</p>

<p style="margin-top: 1em">--max-luminance TID:float <br>
Sets the maximum luminance in candelas per square meter
(cd/m&Acirc;&sup2;). The value should be less than
9999.99.</p>

<p style="margin-top: 1em">--min-luminance TID:float <br>
Sets the mininum luminance in candelas per square meter
(cd/m&Acirc;&sup2;). The value should be less than
999.9999.</p>

<p style="margin-top: 1em">--field-order TID:n <br>
Sets the field order for the video track with the track ID
TID. The order must be one of the following numbers:</p>

<p style="margin-top: 1em">0: progressive; 1: interlaced
with top field displayed first and top field stored first;
2: undetermined field order; 6: interlaced with bottom field
displayed first and <br>
bottom field stored first; 9: interlaced with bottom field
displayed first and top field stored first; 14: interlaced
with top field displayed first and bottom field stored <br>
first</p>

<p style="margin-top: 1em">--stereo-mode TID:n|keyword <br>
Sets the stereo mode for the video track with the track ID
TID. The mode can either be a number n between 0 and 14 or
one of these keywords:</p>

<p style="margin-top: 1em">&rsquo;mono&rsquo;,
&rsquo;side_by_side_left_first&rsquo;,
&rsquo;top_bottom_right_first&rsquo;,
&rsquo;top_bottom_left_first&rsquo;,
&rsquo;checkerboard_right_first&rsquo;,
&rsquo;checkerboard_left_first&rsquo;,
&rsquo;row_interleaved_right_first&rsquo;, <br>
&rsquo;row_interleaved_left_first&rsquo;,
&rsquo;column_interleaved_right_first&rsquo;,
&rsquo;column_interleaved_left_first&rsquo;,
&rsquo;anaglyph_cyan_red&rsquo;,
&rsquo;side_by_side_right_first&rsquo;,
&rsquo;anaglyph_green_magenta&rsquo;, <br>
&rsquo;both_eyes_laced_left_first&rsquo;,
&rsquo;both_eyes_laced_right_first&rsquo;.</p>

<p style="margin-top: 1em">Options that only apply to text
subtitle tracks <br>
--sub-charset TID:character-set <br>
Sets the character set for the conversion to UTF-8 for UTF-8
subtitles for the given track ID. If not specified the
charset will be derived from the current locale settings.
<br>
Note that a charset is not needed for subtitles read from
Matroska(TM) files or from Kate streams, as these are always
stored in UTF-8. See the section about text files and <br>
character sets for an explanation how mkvmerge(1) converts
between character sets.</p>

<p style="margin-top: 1em">This option can be used multiple
times for an input file applying to several tracks by
selecting different track IDs each time.</p>

<p style="margin-top: 1em">Other options <br>
-i, --identify file-name <br>
Will let mkvmerge(1) probe the single file and report its
type, the tracks contained in the file and their track IDs.
If this option is used then the only other option <br>
allowed is the filename.</p>

<p style="margin-top: 1em">The output format used for the
result can be changed with the option
--identification-format.</p>

<p style="margin-top: 1em">-J file-name <br>
This is a convenient alias for &quot;--identification-format
json --identify file-name&quot;.</p>

<p style="margin-top: 1em">-I, --identify-verbose file-name
<br>
Will let mkvmerge(1) probe the single file and report its
type, the tracks contained in the file and their track IDs.
If this option is used then the only other option <br>
allowed is the filename.</p>

<p style="margin-top: 1em">The output will also contain
properties for all items found, e.g. the file title or the
track language.</p>

<p style="margin-top: 1em">Note <br>
This option is deprecated. It will be removed in 2018.</p>

<p style="margin-top: 1em">-F, --identification-format
format <br>
Determines the output format used by the --identify option.
The following formats are supported: text (the default if
this option isn&rsquo;t used), verbose-text and json.</p>

<p style="margin-top: 1em">1. The text format is short and
human-readable. It consists of one line per item found
(container, tracks, attachments etc.).</p>

<p style="margin-top: 1em">This format is not meant to be
parsed. The output will be translated into the language
mkvmerge(1) uses (see also --ui-language).</p>

<p style="margin-top: 1em">2. The verbose-text format
extends the text format with additional properties for each
item. The extra information is surronded by square brackets.
It consists of <br>
space-saparated key/value pairs where keys and values are
separated by a colon.</p>

<p style="margin-top: 1em">Each value is escaped according
to the rules described in the section about escaping special
characters in text.</p>

<p style="margin-top: 1em">This format is not meant to be
parsed. The output will be translated into the language
mkvmerge(1) uses (see also --ui-language).</p>

<p style="margin-top: 1em">Note <br>
This option is deprecated. It will be removed in 2018.</p>

<p style="margin-top: 1em">3. The json format outputs a
machine-readable JSON representation. This format follows
the JSON schema described in the following file:</p>


<p style="margin-top: 1em">mkvmerge-identification-output-schema-v9.json[3]</p>

<p style="margin-top: 1em">All versions of the JSON schema
are available both online and in the released source code
archives.</p>

<p style="margin-top: 1em">--probe-range-percentage
percentage <br>
File types such as MPEG program and transport streams (.vob,
.m2ts) require parsing a certain amount of data in order to
detect all tracks contained in the file. This amount <br>
is 0.3% of the source file&rsquo;s size or 10 MB, whichever
is higher.</p>

<p style="margin-top: 1em">If tracks are known to be
present but not found then the percentage to probe can be
changed with this option. The minimum of 10 MB is built-in
and cannot be changed.</p>

<p style="margin-top: 1em">-l, --list-types <br>
Lists supported input file types.</p>

<p style="margin-top: 1em">--list-languages <br>
Lists all languages and their ISO639-2 code which can be
used with the --language option.</p>

<p style="margin-top: 1em">--priority priority <br>
Sets the process priority that mkvmerge(1) runs with. Valid
values are &rsquo;lowest&rsquo;, &rsquo;lower&rsquo;,
&rsquo;normal&rsquo;, &rsquo;higher&rsquo; and
&rsquo;highest&rsquo;. If nothing is given then
&rsquo;normal&rsquo; is used. On Unix <br>
like systems mkvmerge(1) will use the nice(2) function.
Therefore only the super user can use &rsquo;higher&rsquo;
and &rsquo;highest&rsquo;. On Windows all values are useable
for every user.</p>

<p style="margin-top: 1em">Selecting &rsquo;lowest&rsquo;
also causes mkvmerge(1) to select idle I/O priority in
addition to the lowest possible process priority.</p>

<p style="margin-top: 1em">--command-line-charset
character-set <br>
Sets the character set to convert strings given on the
command line from. It defaults to the character set given by
system&rsquo;s current locale. This settings applies to <br>
arguments of the following options: --title, --track-name
and --attachment-description.</p>

<p style="margin-top: 1em">--output-charset character-set
<br>
Sets the character set to which strings are converted that
are to be output. It defaults to the character set given by
system&rsquo;s current locale.</p>

<p style="margin-top: 1em">-r, --redirect-output file-name
<br>
Writes all messages to the file file-name instead of to the
console. While this can be done easily with output
redirection there are cases in which this option is needed:
<br>
when the terminal reinterprets the output before writing it
to a file. The character set set with --output-charset is
honored.</p>

<p style="margin-top: 1em">--ui-language code <br>
Forces the translations for the language code to be used
(e.g. &rsquo;de_DE&rsquo; for the German translations).
Entering &rsquo;list&rsquo; as the code will cause the
program to output a list of <br>
available translations.</p>

<p style="margin-top: 1em">--debug topic <br>
Turn on debugging for a specific feature. This option is
only useful for developers.</p>

<p style="margin-top: 1em">--engage feature <br>
Turn on experimental features. A list of available features
can be requested with mkvmerge --engage list. These features
are not meant to be used in normal situations.</p>

<p style="margin-top: 1em">--gui-mode <br>
Turns on GUI mode. In this mode specially-formatted lines
may be output that can tell a controlling GUI what&rsquo;s
happening. These messages follow the format
&rsquo;#GUI#message&rsquo;. The <br>
message may be followed by key/value pairs as in
&rsquo;#GUI#message#key1=value1#key2=value2...&rsquo;.
Neither the messages nor the keys are ever translated and
always output in <br>
English.</p>

<p style="margin-top: 1em">@options-file.json <br>
Reads additional command line arguments from the file
options-file. See the section about option files for further
information.</p>

<p style="margin-top: 1em">--capabilities <br>
Lists information about optional features that have been
compiled in and exit. The first line output will be the
version information. All following lines contain exactly one
<br>
word whose presence indicates that the feature has been
compiled in. These features are:</p>

<p style="margin-top: 1em">&Acirc;&middot;
&rsquo;FLAC&rsquo; -- reading raw FLAC files and handling
FLAC tracks in other containers, e.g. Ogg(TM) or
Matroska(TM).</p>

<p style="margin-top: 1em">-h, --help <br>
Show usage information and exit.</p>

<p style="margin-top: 1em">-V, --version <br>
Show version information and exit.</p>

<p style="margin-top: 1em">--check-for-updates <br>
Checks online for new releases by downloading the URL
http://mkvtoolnix-releases.bunkus.org/latest-release.xml.
Four lines will be output in key=value style: the URL from
<br>
where the information was retrieved (key version_check_url),
the currently running version (key running_version), the
latest release&rsquo;s version (key available_version) and
the <br>
download URL (key download_url).</p>

<p style="margin-top: 1em">Afterwards the program exists
with an exit code of 0 if no newer release is available,
with 1 if a newer release is available and with 2 if an
error occured (e.g. if the <br>
update information could not be retrieved).</p>

<p style="margin-top: 1em">This option is only available if
the program was built with support for libcurl.</p>

<p style="margin-top: 1em">USAGE <br>
For each file the user can select which tracks mkvmerge(1)
should take. They are all put into the file specified with
-o. A list of known (and supported) source formats can be
<br>
obtained with the -l option.</p>

<p style="margin-top: 1em">Important <br>
The order of command line options is important. Please read
the section &quot;Option order&quot; if you&rsquo;re new to
the program.</p>

<p style="margin-top: 1em">OPTION ORDER <br>
The order in which options are entered is important for some
options. Options fall into two categories:</p>

<p style="margin-top: 1em">1. Options that affect the whole
program and are not tied to any input file. These include
but are not limited to --command-line-charset, --output or
--title. These can appear <br>
anywhere on the command line.</p>

<p style="margin-top: 1em">2. Options that affect a single
input file or a single track in an input file. These options
all apply to the following input file on the command line.
All options applying to <br>
the same input (or to tracks from the same input file) file
can be written in any order as long as they all appear
before that input file&rsquo;s name. Examples for options
<br>
applying to an input file are --no-chapters or
--chapter-charset. Examples for options applying to a single
track are --default-duration or --language.</p>

<p style="margin-top: 1em">The options are processed from
left to right. If an option appears multiple times within
the same scope then the last occurence will be used.
Therefore the title will be set to <br>
&quot;Something else&quot; in the following example:</p>

<p style="margin-top: 1em">$ mkvmerge -o output.mkv --title
&rsquo;This and that&rsquo; input.avi --title
&rsquo;Something else&rsquo;</p>

<p style="margin-top: 1em">The following example shows that
using the --language option twice is OK because
they&rsquo;re used in different scopes. Even though they
apply to the same track ID they apply to <br>
different input files and therefore have different
scopes:</p>

<p style="margin-top: 1em">$ mkvmerge -o output.mkv
--language 0:fre fran&Atilde;&sect;ais.ogg --language 0:deu
deutsch.ogg</p>

<p style="margin-top: 1em">EXAMPLES <br>
Let&rsquo;s assume you have a file called MyMovie.avi and
the audio track in a separate file, e.g.
&rsquo;MyMovie.wav&rsquo;. First you want to encode the
audio to OggVorbis(TM):</p>

<p style="margin-top: 1em">$ oggenc -q4 -oMyMovie.ogg
MyMovie.wav</p>

<p style="margin-top: 1em">After a couple of minutes you
can join video and audio:</p>

<p style="margin-top: 1em">$ mkvmerge -o
MyMovie-with-sound.mkv MyMovie.avi MyMovie.ogg</p>

<p style="margin-top: 1em">If your AVI already contains an
audio track then it will be copied as well (if mkvmerge(1)
supports the audio format). To avoid that simply do</p>

<p style="margin-top: 1em">$ mkvmerge -o
MyMovie-with-sound.mkv -A MyMovie.avi MyMovie.ogg</p>

<p style="margin-top: 1em">After some minutes of
consideration you rip another audio track, e.g. the
director&rsquo;s comments or another language to
&rsquo;MyMovie-add-audio.wav&rsquo;. Encode it again and
join it up with <br>
the other file:</p>

<p style="margin-top: 1em">$ oggenc -q4
-oMyMovie-add-audio.ogg MyMovie-add-audio.wav <br>
$ mkvmerge -o MM-complete.mkv MyMovie-with-sound.mkv
MyMovie-add-audio.ogg</p>

<p style="margin-top: 1em">The same result can be achieved
with</p>

<p style="margin-top: 1em">$ mkvmerge -o MM-complete.mkv -A
MyMovie.avi MyMovie.ogg MyMovie-add-audio.ogg</p>

<p style="margin-top: 1em">Now fire up mplayer(TM) and
enjoy. If you have multiple audio tracks (or even video
tracks) then you can tell mplayer(TM) which track to play
with the &rsquo;-vid&rsquo; and &rsquo;-aid&rsquo; options.
<br>
These are 0-based and do not distinguish between video and
audio.</p>

<p style="margin-top: 1em">If you need an audio track
synchronized you can do that easily. First find out which
track ID the Vorbis track has with</p>

<p style="margin-top: 1em">$ mkvmerge --identify
outofsync.ogg</p>

<p style="margin-top: 1em">Now you can use that ID in the
following command line:</p>

<p style="margin-top: 1em">$ mkvmerge -o goodsync.mkv -A
source.avi -y 12345:200 outofsync.ogg</p>

<p style="margin-top: 1em">This would add 200ms of silence
at the beginning of the audio track with the ID 12345 taken
from &rsquo;outofsync.ogg&rsquo;.</p>

<p style="margin-top: 1em">Some movies start synced
correctly but slowly drift out of sync. For these kind of
movies you can specify a delay factor that is applied to all
timestamps -- no data is added or <br>
removed. So if you make that factor too big or too small
you&rsquo;ll get bad results. An example is that an episode
I transcoded was 0.2 seconds out of sync at the end of the
movie <br>
which was 77340 frames long. At 29.97fps 0.2 seconds
correspond to approx. 6 frames. So I did</p>

<p style="margin-top: 1em">$ mkvmerge -o goodsync.mkv -y
23456:0,77346/77340 outofsync.mkv</p>

<p style="margin-top: 1em">The result was fine.</p>

<p style="margin-top: 1em">The sync options can also be
used for subtitles in the same manner.</p>

<p style="margin-top: 1em">For text subtitles you can
either use some Windows software (like SubRipper(TM)) or the
subrip(TM) package found in transcode(1)&rsquo;s sources in
the &rsquo;contrib/subrip&rsquo; directory. The <br>
general process is:</p>

<p style="margin-top: 1em">1. extract a raw subtitle stream
from the source:</p>

<p style="margin-top: 1em">$ tccat -i /path/to/copied/dvd/
-T 1 -L | tcextract -x ps1 -t vob -a 0x20 | subtitle2pgm -o
mymovie</p>

<p style="margin-top: 1em">2. convert the resulting PGM
images to text with gocr:</p>

<p style="margin-top: 1em">$ pgm2txt mymovie</p>

<p style="margin-top: 1em">3. spell-check the resulting
text files:</p>

<p style="margin-top: 1em">$ ispell -d american *txt</p>

<p style="margin-top: 1em">4. convert the text files to a
SRT file:</p>

<p style="margin-top: 1em">$ srttool -s -w -i mymovie.srtx
-o mymovie.srt</p>

<p style="margin-top: 1em">The resulting file can be used
as another input file for mkvmerge(1):</p>

<p style="margin-top: 1em">$ mkvmerge -o mymovie.mkv
mymovie.avi mymovie.srt</p>

<p style="margin-top: 1em">If you want to specify the
language for a given track then this is easily done. First
find out the ISO639-2 code for your language. mkvmerge(1)
can list all of those codes for <br>
you:</p>

<p style="margin-top: 1em">$ mkvmerge --list-languages</p>

<p style="margin-top: 1em">Search the list for the
languages you need. Let&rsquo;s assume you have put two
audio tracks into a Matroska(TM) file and want to set their
language codes and that their track IDs are <br>
2 and 3. This can be done with</p>

<p style="margin-top: 1em">$ mkvmerge -o
with-lang-codes.mkv --language 2:ger --language 3:dut
without-lang-codes.mkv</p>

<p style="margin-top: 1em">As you can see you can use the
--language switch multiple times.</p>

<p style="margin-top: 1em">Maybe you&rsquo;d also like to
have the player use the Dutch language as the default
language. You also have extra subtitles, e.g. in English and
French, and want to have the player <br>
display the French ones by default. This can be done
with</p>

<p style="margin-top: 1em">$ mkvmerge -o
with-lang-codes.mkv --language 2:ger --language 3:dut
--default-track 3 without-lang-codes.mkv --language 0:eng
english.srt --default-track 0 --language 0:fre
french.srt</p>

<p style="margin-top: 1em">If you do not see the language
or default track flags that you&rsquo;ve specified in
mkvinfo(1)&rsquo;s output then please read the section about
default values.</p>

<p style="margin-top: 1em">Turn off the compression for an
input file.</p>

<p style="margin-top: 1em">$ mkvmerge -o no-compression.mkv
--compression -1:none MyMovie.avi --compression -1:none
mymovie.srt</p>

<p style="margin-top: 1em">TRACK IDS <br>
Some of the options for mkvmerge(1) need a track ID to
specify which track they should be applied to. Those track
IDs are printed by the readers when demuxing the current
input <br>
file, or if mkvmerge(1) is called with the --identify
option. An example for such output:</p>

<p style="margin-top: 1em">$ mkvmerge -i v.mkv <br>
File &rsquo;v.mkv&rsquo;: container: Matroska(TM) <br>
Track ID 0: video (V_MS/VFW/FOURCC, DIV3) <br>
Track ID 1: audio (A_MPEG/L3)</p>

<p style="margin-top: 1em">Do not confuse the track IDs
that are assigned to the tracks that are placed in the
output MKV file with the track IDs of the input files. Only
the input file track IDs are used <br>
for options needing these values.</p>

<p style="margin-top: 1em">Also note that each input file
has its own set of track IDs. Therefore the track IDs for
file &rsquo;file1.ext&rsquo; as reported by &rsquo;mkvmerge
--identify&rsquo; do not change no matter how many <br>
other input files are there or in which position
&rsquo;file1.ext&rsquo; is used.</p>

<p style="margin-top: 1em">Track IDs are assigned like
this:</p>

<p style="margin-top: 1em">&Acirc;&middot; AVI files: The
video track has the ID 0. The audio tracks get IDs in
ascending order starting at 1.</p>

<p style="margin-top: 1em">&Acirc;&middot; AAC, AC-3, MP3,
SRT and WAV files: The one &rsquo;track&rsquo; in that file
gets the ID 0.</p>

<p style="margin-top: 1em">&Acirc;&middot; Most other
files: The track IDs are assigned in order the tracks are
found in the file starting at 0.</p>

<p style="margin-top: 1em">The special track ID
&rsquo;-1&rsquo; is a wild card and applies the given switch
to all tracks that are read from an input file.</p>

<p style="margin-top: 1em">The options that use the track
IDs are the ones whose description contains
&rsquo;TID&rsquo;. The following options use track IDs as
well: --audio-tracks, --video-tracks, --subtitle-tracks,
<br>
--button-tracks and --track-tags.</p>

<p style="margin-top: 1em">TEXT FILES AND CHARACTER SET
CONVERSIONS <br>
Note <br>
This section applies to all programs in MKVToolNix even if
it only mentions mkvmerge(1).</p>

<p style="margin-top: 1em">Introduction <br>
All text in a Matroska(TM) file is encoded in UTF-8. This
means that mkvmerge(1) has to convert every text file it
reads as well as every text given on the command line from
one <br>
character set into UTF-8. In return this also means that
mkvmerge(1)&rsquo;s output has to be converted back to that
character set from UTF-8, e.g. if a non-English translation
is used <br>
with --ui-language or for text originating from a
Matroska(TM) file.</p>

<p style="margin-top: 1em">mkvmerge(1) does this conversion
automatically based on the presence of a byte order marker
(short: BOM) or the system&rsquo;s current locale. How the
character set is inferred from <br>
the locale depends on the operating system that mkvmerge(1)
is run on.</p>

<p style="margin-top: 1em">Byte order markers (BOM) <br>
Text files that start with a BOM are already encoded in one
representation of UTF. mkvmerge(1) supports the following
five modes: UTF-8, UTF-16 Little and Big Endian, UTF-32 <br>
Little and Big Endian. Text files with a BOM are
automatically converted to UTF-8. Any of the parameters that
would otherwise set the character set for such a file (e.g.
<br>
--sub-charset) is silently ignored.</p>

<p style="margin-top: 1em">Linux and Unix-like systems
including Mac OS <br>
On Unix-like systems mkvmerge(1) uses the setlocale(3)
system call which in turn uses the environment variables
LANG, LC_ALL and LC_CYPE. The resulting character set is
often one <br>
of UTF-8 or the ISO-8859-* family and is used for all text
file operations and for encoding strings on the command line
and for output to the console.</p>

<p style="margin-top: 1em">Windows <br>
On Windows the default character set used for converting
text files is determined by a call to the GetACP() system
call.</p>

<p style="margin-top: 1em">Reading the command line is done
with the GetCommandLineW() function which already returns a
Unicode string. Therefore the option --command-line-charset
is ignored on Windows.</p>

<p style="margin-top: 1em">Output to the console consists
of three scenarios:</p>

<p style="margin-top: 1em">1. If the output is redirected
with the option --redirect-output then the default charset
is UTF-8. This can be changed with --output-charset.</p>

<p style="margin-top: 1em">If the output is redirected with
cmd.exe itself, e.g. with mkvinfo file.mkv &gt; info.txt,
then the charset is always UTF-8 and cannot be changed.</p>

<p style="margin-top: 1em">Otherwise (when writing directly
to the console) the Windows function WriteConsoleW() is used
and the option --output-charset is ignored. The console
should be able to output <br>
all Unicode characters for which the corresponding language
support is installed (e.g. Chinese characters might not be
displayed on English Windows versions).</p>

<p style="margin-top: 1em">Command line options <br>
The following options exist that allow specifying the
character sets:</p>

<p style="margin-top: 1em">&Acirc;&middot; --sub-charset
for text subtitle files and for text subtitle tracks stored
in container formats for which the character set cannot be
determined unambiguously (e.g. Ogg <br>
files),</p>

<p style="margin-top: 1em">&Acirc;&middot;
--chapter-charset for chapter text files and for chapters
and file titles stored in container formats for which the
character set cannot be determined unambiguously (e.g. Ogg
<br>
files for chapter information, track and file titles etc;
MP4 files for chapter information),</p>

<p style="margin-top: 1em">&Acirc;&middot;
--command-line-charset for all strings on the command
line,</p>

<p style="margin-top: 1em">&Acirc;&middot; --output-charset
for all strings written to the console or to a file if the
output has been redirected with the --redirect-output
option. On non-Windows systems the default <br>
for the output charset is the system&rsquo;s current
charset. On Windows it defaults to UTF-8 both for
redirecting with --redirect-output and with cmd.exe itself,
e.g. mkvinfo <br>
file.mkv &gt; info.txt.</p>

<p style="margin-top: 1em">OPTION FILES <br>
An option file is a file mkvmerge(1) can read additional
command line arguments from. This can be used in order to
circumvent certain limitations of the shell or the operating
<br>
system when executing external programs like a limited
command line length.</p>

<p style="margin-top: 1em">There are two formats for option
files: a JSON format and a proprietary legacy format. The
legacy format is deprecated, and support for it will likely
be removed in 2018.</p>

<p style="margin-top: 1em">The JSON format <br>
A JSON option file&rsquo;s name must end in
&rsquo;.json&rsquo;. Its content must be a valid JSON array
consisting solely of JSON strings. The file&rsquo;s encoding
must be UTF-8. The file should not <br>
start with a byte order marker (BOM), but if one exists, it
will be skipped.</p>

<p style="margin-top: 1em">The rules for escaping special
characters inside JSON are the ones in the official JSON
specification, RFC 7159[4].</p>

<p style="margin-top: 1em">The command line &rsquo;mkvmerge
-o &quot;my file.mkv&quot; -A &quot;a movie.avi&quot;
sound.ogg&rsquo; could be converted into the following JSON
option file called e.g. &rsquo;options.json&rsquo;:</p>

<p style="margin-top: 1em">[ <br>
&quot;-o&quot;, <br>
&quot;c:\Matroska\my file.mkv&quot;, <br>
&quot;--title&quot;, <br>
&quot;#65&quot;, <br>
&quot;-A&quot;, <br>
&quot;a movie.avi&quot;, <br>
&quot;sound.ogg&quot; <br>
]</p>

<p style="margin-top: 1em">The legacy format <br>
There are several rules regarding option files. Lines whose
first non-whitespace character is a hash mark
(&rsquo;#&rsquo;) are treated as comments and ignored. White
spaces at the start and <br>
end of a line will be stripped. Each line must contain
exactly one option.</p>

<p style="margin-top: 1em">A line not containing anything
is also ignored. An empty argument is represented by the
line &rsquo;#EMPTY#&rsquo;.</p>

<p style="margin-top: 1em">Several chars can be escaped,
e.g. if you need to start a non-comment line with
&rsquo;#&rsquo;. The rules are described in the section
about escaping text.</p>

<p style="margin-top: 1em">Note that backslashes must
always be escaped. Hash marks (&rsquo;#&rsquo;) must be
escaped if they should not start a comment.</p>

<p style="margin-top: 1em">The command line &rsquo;mkvmerge
-o &quot;my file.mkv&quot; -A &quot;a movie.avi&quot;
sound.ogg&rsquo; could be converted into the following
legacy option file called e.g.
&rsquo;options.txt&rsquo;:</p>

<p style="margin-top: 1em"># Write to the file
&quot;c:troska file.mkv&quot; on Windows. <br>
-o <br>
c:\Matroska\my file.mkv <br>
# Set the title to &rsquo;#65&rsquo;. <br>
--title <br>
5 <br>
# Only take the video from &quot;a movie.avi&quot;. <br>
-A <br>
a movie.avi <br>
sound.ogg</p>

<p style="margin-top: 1em">ESCAPING SPECIAL CHARS IN TEXT
<br>
There are a few places in which special characters in text
must or should be escaped. The rules for escaping are
simple: each character that needs escaping is replaced with
a <br>
backslash followed by another character.</p>

<p style="margin-top: 1em">The rules are: &rsquo; &rsquo;
(a space) becomes &rsquo; &rsquo;&quot;&rsquo; (double
quotes) becomes &rsquo;2&rsquo;, &rsquo;:&rsquo; becomes
&rsquo; itself becomes &rsquo;\&rsquo;.</p>

<p style="margin-top: 1em">SUBTITLES <br>
There are several text and bitmap subtitle formats that can
be embedded into Matroska(TM). Text subtitles must be
recoded to UTF-8 so that they can be displayed correctly by
a <br>
player (see the section about text files and character sets
for an explanation how mkvmerge(1) converts between
character sets). Kate subtitles are already encoded in UTF-8
and <br>
do not have to be re-encoded.</p>

<p style="margin-top: 1em">The following subtitle formats
are supported at the moment:</p>

<p style="margin-top: 1em">&Acirc;&middot; Subtitle Ripper
(SRT) files</p>

<p style="margin-top: 1em">&Acirc;&middot; Substation Alpha
(SSA) / Advanced Substation Alpha scripts (ASS)</p>

<p style="margin-top: 1em">&Acirc;&middot; Universal
Subtitle Format (USF) files</p>

<p style="margin-top: 1em">&Acirc;&middot; OggKate
streams</p>

<p style="margin-top: 1em">&Acirc;&middot; VobSub bitmap
subtitle files</p>

<p style="margin-top: 1em">&Acirc;&middot; PGS bitmap
subtitle files as found on BluRay discs</p>

<p style="margin-top: 1em">FILE LINKING <br>
Matroska(TM) supports file linking which simply says that a
specific file is the predecessor or successor of the current
file. To be precise, it&rsquo;s not really the files that
are <br>
linked but the Matroska(TM) segments. As most files will
probably only contain one Matroska(TM) segment the following
explanations use the term &rsquo;file linking&rsquo;
although &rsquo;segment <br>
linking&rsquo; would be more appropriate.</p>

<p style="margin-top: 1em">Each segment is identified by a
unique 128 bit wide segment UID. This UID is automatically
generated by mkvmerge(1). The linking is done primarily via
putting the segment UIDs <br>
(short: SID) of the previous/next file into the segment
header information. mkvinfo(1) prints these SIDs if it finds
them.</p>

<p style="margin-top: 1em">If a file is split into several
smaller ones and linking is used then the timecodes will not
start at 0 again but will continue where the last file has
left off. This way the <br>
absolute time is kept even if the previous files are not
available (e.g. when streaming). If no linking is used then
the timecodes should start at 0 for each file. By default
<br>
mkvmerge(1) does not use file linking. If you want that you
can turn it on with the --link option. This option is only
useful if splitting is activated as well.</p>

<p style="margin-top: 1em">Regardless of whether splitting
is active or not the user can tell mkvmerge(1) to link the
produced files to specific SIDs. This is achieved with the
options --link-to-previous <br>
and --link-to-next. These options accept a segment SID in
the format that mkvinfo(1) outputs: 16 hexadecimal numbers
between 0x00 and 0xff prefixed with &rsquo;0x&rsquo; each,
e.g. &rsquo;0x41 <br>
0xda 0x73 0x66 0xd9 0xcf 0xb2 0x1e 0xae 0x78 0xeb 0xb4 0x5e
0xca 0xb3 0x93&rsquo;. Alternatively a shorter form can be
used: 16 hexadecimal numbers between 0x00 and 0xff without
the <br>
&rsquo;0x&rsquo; prefixes and without the spaces, e.g.
&rsquo;41da7366d9cfb21eae78ebb45ecab393&rsquo;.</p>

<p style="margin-top: 1em">If splitting is used then the
first file is linked to the SID given with
--link-to-previous and the last file is linked to the SID
given with --link-to-next. If splitting is not <br>
used then the one output file will be linked to both of the
two SIDs.</p>

<p style="margin-top: 1em">DEFAULT VALUES <br>
The Matroska(TM) specification states that some elements
have a default value. Usually an element is not written to
the file if its value is equal to its default value in order
<br>
to save space. The elements that the user might miss in
mkvinfo(1)&rsquo;s output are the language and the default
track flag elements. The default value for the language is
English <br>
(&rsquo;eng&rsquo;), and the default value for the default
track flag is true. Therefore if you used --language 0:eng
for a track then it will not show up in mkvinfo(1)&rsquo;s
output.</p>

<p style="margin-top: 1em">ATTACHMENTS <br>
Maybe you also want to keep some photos along with your
Matroska(TM) file, or you&rsquo;re using SSA subtitles and
need a special TrueType(TM) font that&rsquo;s really rare.
In these cases <br>
you can attach those files to the Matroska(TM) file. They
will not be just appended to the file but embedded in it. A
player can then show those files (the &rsquo;photos&rsquo;
case) or use <br>
them to render the subtitles (the &rsquo;TrueType(TM)
fonts&rsquo; case).</p>

<p style="margin-top: 1em">Here&rsquo;s an example how to
attach a photo and a TrueType(TM) font to the output
file:</p>

<p style="margin-top: 1em">$ mkvmerge -o output.mkv -A
video.avi sound.ogg --attachment-description &quot;Me and
the band behind the stage in a small get-together&quot;
--attachment-mime-type image/jpeg --attach-file
me_and_the_band.jpg --attachment-description &quot;The real
rare and unbelievably good looking font&quot;
--attachment-mime-type application/octet-stream
--attach-file really_cool_font.ttf</p>

<p style="margin-top: 1em">If a Matroska(TM) containing
attachments file is used as an input file then mkvmerge(1)
will copy the attachments into the new file. The selection
which attachments are copied <br>
and which are not can be changed with the options
--attachments and --no-attachments.</p>

<p style="margin-top: 1em">CHAPTERS <br>
The Matroska(TM) chapter system is more powerful than the
old known system used by OGM files. The full specifications
can be found at the Matroska(TM) website[1].</p>

<p style="margin-top: 1em">mkvmerge(1) supports two kinds
of chapter files as its input. The first format, called
&rsquo;simple chapter format&rsquo;, is the same format that
the OGM tools expect. The second format is <br>
a XML based chapter format which supports all of
Matroska(TM)&rsquo;s chapter functionality.</p>

<p style="margin-top: 1em">The simple chapter format <br>
This formmat consists of pairs of lines that start with
&rsquo;CHAPTERxx=&rsquo; and &rsquo;CHAPTERxxNAME=&rsquo;
respectively. The first one contains the start timecode
while the second one contains <br>
the title. Here&rsquo;s an example:</p>

<p style="margin-top: 1em">CHAPTER01=00:00:00.000 <br>
CHAPTER01NAME=Intro <br>
CHAPTER02=00:02:30.000 <br>
CHAPTER02NAME=Baby prepares to rock <br>
CHAPTER03=00:02:42.300 <br>
CHAPTER03NAME=Baby rocks the house</p>

<p style="margin-top: 1em">mkvmerge(1) will transform every
pair or lines into one Matroska(TM) ChapterAtom. It does not
set any ChapterTrackNumber which means that the chapters all
apply to all tracks in <br>
the file.</p>

<p style="margin-top: 1em">As this is a text file character
set conversion may need to be done. See the section about
text files and character sets for an explanation how
mkvmerge(1) converts between <br>
character sets.</p>

<p style="margin-top: 1em">The XML based chapter format
<br>
The XML based chapter format looks like this example:</p>

<p style="margin-top: 1em">&lt;?xml version=&quot;1.0&quot;
encoding=&quot;ISO-8859-1&quot;?&gt; <br>
&lt;!DOCTYPE Chapters SYSTEM
&quot;matroskachapters.dtd&quot;&gt; <br>
&lt;Chapters&gt; <br>
&lt;EditionEntry&gt; <br>
&lt;ChapterAtom&gt; <br>

&lt;ChapterTimeStart&gt;00:00:30.000&lt;/ChapterTimeStart&gt;
<br>
&lt;ChapterTimeEnd&gt;00:01:20.000&lt;/ChapterTimeEnd&gt;
<br>
&lt;ChapterDisplay&gt; <br>
&lt;ChapterString&gt;A short chapter&lt;/ChapterString&gt;
<br>
&lt;ChapterLanguage&gt;eng&lt;/ChapterLanguage&gt; <br>
&lt;/ChapterDisplay&gt; <br>
&lt;ChapterAtom&gt; <br>

&lt;ChapterTimeStart&gt;00:00:46.000&lt;/ChapterTimeStart&gt;
<br>
&lt;ChapterTimeEnd&gt;00:01:10.000&lt;/ChapterTimeEnd&gt;
<br>
&lt;ChapterDisplay&gt; <br>
&lt;ChapterString&gt;A part of that short
chapter&lt;/ChapterString&gt; <br>
&lt;ChapterLanguage&gt;eng&lt;/ChapterLanguage&gt; <br>
&lt;/ChapterDisplay&gt; <br>
&lt;/ChapterAtom&gt; <br>
&lt;/ChapterAtom&gt; <br>
&lt;/EditionEntry&gt; <br>
&lt;/Chapters&gt;</p>

<p style="margin-top: 1em">With this format three things
are possible that are not possible with the simple chapter
format:</p>

<p style="margin-top: 1em">1. The timestamp for the end of
the chapter can be set,</p>

<p style="margin-top: 1em">2. chapters can be nested,</p>

<p style="margin-top: 1em">3. the language and country can
be set.</p>

<p style="margin-top: 1em">The mkvtoolnix distribution
contains some sample files in the doc subdirectory which can
be used as a basis.</p>

<p style="margin-top: 1em">The following lists the
supported XML tags, their data types and, where appropriate,
the valid range for their values:</p>

<p style="margin-top: 1em">Chapters (master) <br>
EditionEntry (master) <br>
EditionUID (unsigned integer, valid range: 1 &lt;= value)
<br>
EditionFlagHidden (unsigned integer, valid range: 0 &lt;=
value &lt;= 1) <br>
EditionFlagDefault (unsigned integer, valid range: 0 &lt;=
value &lt;= 1) <br>
EditionFlagOrdered (unsigned integer, valid range: 0 &lt;=
value &lt;= 1) <br>
ChapterAtom (master) <br>
ChapterAtom (master) <br>
ChapterUID (unsigned integer, valid range: 1 &lt;= value)
<br>
ChapterTimeStart (unsigned integer) <br>
ChapterTimeEnd (unsigned integer) <br>
ChapterFlagHidden (unsigned integer, valid range: 0 &lt;=
value &lt;= 1) <br>
ChapterFlagEnabled (unsigned integer, valid range: 0 &lt;=
value &lt;= 1) <br>
ChapterSegmentUID (binary, valid range: 1 &lt;= length in
bytes) <br>
ChapterSegmentEditionUID (unsigned integer, valid range: 1
&lt;= value) <br>
ChapterPhysicalEquiv (unsigned integer) <br>
ChapterTrack (master) <br>
ChapterTrackNumber (unsigned integer, valid range: 1 &lt;=
value) <br>
ChapterDisplay (master) <br>
ChapterString (UTF-8 string) <br>
ChapterLanguage (UTF-8 string) <br>
ChapterCountry (UTF-8 string) <br>
ChapterProcess (master) <br>
ChapterProcessCodecID (unsigned integer) <br>
ChapterProcessPrivate (binary) <br>
ChapterProcessCommand (master) <br>
ChapterProcessTime (unsigned integer) <br>
ChapterProcessData (binary)</p>

<p style="margin-top: 1em">General notes <br>
When splitting files mkvmerge(1) will correctly adjust the
chapters as well. This means that each file only includes
the chapter entries that apply to it, and that the timecodes
<br>
will be offset to match the new timecodes of each output
file.</p>

<p style="margin-top: 1em">mkvmerge(1) is able to copy
chapters from Matroska(TM) source files unless this is
explicitly disabled with the --no-chapters option. The
chapters from all sources (Matroska(TM) <br>
files, Ogg files, MP4 files, chapter text files) are usually
not merged but end up in separate ChapterEditions. Only if
chapters are read from several Matroska(TM) or XML files
<br>
that share the same edition UIDs will chapters be merged
into a single ChapterEdition. If such a merge is desired in
other situations as well then the user has to extract the
<br>
chapters from all sources with mkvextract(1) first, merge
the XML files manually and mux them afterwards.</p>

<p style="margin-top: 1em">TAGS <br>
Introduction <br>
Matroska(TM) supports an extensive set of tags that is
deprecated and a new, simpler system like it is is used in
most other containers: KEY=VALUE. However, in Matroska(TM)
these <br>
tags can also be nested, and both the KEY and the VALUE are
elements of their own. The example file example-tags-2.xml
shows how to use this new system.</p>

<p style="margin-top: 1em">Scope of the tags <br>
Matroska(TM) tags do not automatically apply to the complete
file. They can, but they also may apply to different parts
of the file: to one or more tracks, to one or more <br>
chapters, or even to a combination of both. The the
Matroska(TM) specification[5] gives more details about this
fact.</p>

<p style="margin-top: 1em">One important fact is that tags
are linked to tracks or chapters with the Targets
Matroska(TM) tag element, and that the UIDs used for this
linking are not the track IDs <br>
mkvmerge(1) uses everywhere. Instead the numbers used are
the UIDs which mkvmerge(1) calculates automatically (if the
track is taken from a file format other than Matroska(TM))
<br>
or which are copied from the source file if the
track&rsquo;s source file is a Matroska(TM) file. Therefore
it is difficult to know which UIDs to use in the tag file
before the file is <br>
handed over to mkvmerge(1).</p>

<p style="margin-top: 1em">mkvmerge(1) knows two options
with which you can add tags to Matroska(TM) files: The
--global-tags and the --tags options. The difference is that
the former option, <br>
--global-tags, will make the tags apply to the complete file
by removing any of those Targets elements mentioned above.
The latter option, --tags, automatically inserts the UID
<br>
that mkvmerge(1) generates for the tag specified with the
TID part of the --tags option.</p>

<p style="margin-top: 1em">Example <br>
Let&rsquo;s say that you want to add tags to a video track
read from an AVI. mkvmerge --identify file.avi tells you
that the video track&rsquo;s ID (do not mix this ID with the
UID!) is 0. <br>
So you create your tag file, leave out all Targets elements
and call mkvmerge(1):</p>

<p style="margin-top: 1em">$ mkvmerge -o file.mkv --tags
0:tags.xml file.avi</p>

<p style="margin-top: 1em">Tag file format <br>
mkvmerge(1) supports a XML based tag file format. The format
is very closely modeled after the Matroska(TM)
specification[5]. Both the binary and the source
distributions of <br>
MKVToolNix come with a sample file called example-tags-2.xml
which simply lists all known tags and which can be used as a
basis for real life tag files.</p>

<p style="margin-top: 1em">The basics are:</p>

<p style="margin-top: 1em">&Acirc;&middot; The outermost
element must be &lt;Tags&gt;.</p>

<p style="margin-top: 1em">&Acirc;&middot; One logical tag
is contained inside one pair of &lt;Tag&gt; XML tags.</p>

<p style="margin-top: 1em">&Acirc;&middot; White spaces
directly before and after tag contents are ignored.</p>

<p style="margin-top: 1em">Data types <br>
The new Matroska(TM) tagging system only knows two data
types, a UTF-8 string and a binary type. The first is used
for the tag&rsquo;s name and the &lt;String&gt; element
while the binary <br>
type is used for the &lt;Binary&gt; element.</p>

<p style="margin-top: 1em">As binary data itself would not
fit into a XML file mkvmerge(1) supports two other methods
of storing binary data. If the contents of a XML tag starts
with &rsquo;@&rsquo; then the following <br>
text is treated as a file name. The corresponding
file&rsquo;s content is copied into the Matroska(TM)
element.</p>

<p style="margin-top: 1em">Otherwise the data is expected
to be Base64 encoded. This is an encoding that transforms
binary data into a limited set of ASCII characters and is
used e.g. in email programs. <br>
mkvextract(1) will output Base64 encoded data for binary
elements.</p>

<p style="margin-top: 1em">The deprecated tagging system
knows some more data types which can be found in the
official Matroska(TM) tag specs. As mkvmerge(1) does not
support this system anymore these <br>
types aren&rsquo;t described here.</p>

<p style="margin-top: 1em">Known tags for the XML file
format <br>
The following lists the supported XML tags, their data types
and, where appropriate, the valid range for their
values:</p>

<p style="margin-top: 1em">Tags (master) <br>
Tag (master) <br>
Targets (master) <br>
TargetTypeValue (unsigned integer) <br>
TargetType (UTF-8 string) <br>
TrackUID (unsigned integer) <br>
EditionUID (unsigned integer) <br>
ChapterUID (unsigned integer) <br>
AttachmentUID (unsigned integer) <br>
Simple (master) <br>
Simple (master) <br>
Name (UTF-8 string) <br>
TagLanguage (UTF-8 string) <br>
DefaultLanguage (unsigned integer) <br>
String (UTF-8 string) <br>
Binary (binary)</p>

<p style="margin-top: 1em">THE SEGMENT INFO XML FILES <br>
With a segment info XML file it is possible to set certain
values in the &quot;segment information&quot; header field
of a Matroska(TM) file. All of these values cannot be set
via other <br>
command line options.</p>

<p style="margin-top: 1em">Other &quot;segment
information&quot; header fields can be set via command line
options but not via the XML file. This includes e.g. the
--title and the --timecode-scale options.</p>

<p style="margin-top: 1em">There are other elements that
can be set neither via command line options nor via the XML
files. These include the following elements: DateUTC (also
known as the &quot;muxing date&quot;), <br>
MuxingApp, WritingApp and Duration. They&rsquo;re always set
by mkvmerge(1) itself.</p>

<p style="margin-top: 1em">The following lists the
supported XML tags, their data types and, where appropriate,
the valid range for their values:</p>

<p style="margin-top: 1em">Info (master) <br>
SegmentUID (binary, valid range: length in bytes == 16) <br>
SegmentFilename (UTF-8 string) <br>
PreviousSegmentUID (binary, valid range: length in bytes ==
16) <br>
PreviousSegmentFilename (UTF-8 string) <br>
NextSegmentUID (binary, valid range: length in bytes == 16)
<br>
NextSegmentFilename (UTF-8 string) <br>
SegmentFamily (binary, valid range: length in bytes == 16)
<br>
ChapterTranslate (master) <br>
ChapterTranslateEditionUID (unsigned integer) <br>
ChapterTranslateCodec (unsigned integer) <br>
ChapterTranslateID (binary)</p>

<p style="margin-top: 1em">MATROSKA(TM) FILE LAYOUT <br>
The Matroska(TM) file layout is quite flexible. mkvmerge(1)
will render a file in a predefined way. The resulting file
looks like this:</p>

<p style="margin-top: 1em">[EBML head] [segment {meta seek
#1} [segment information] [track information] {attachments}
{chapters} [cluster 1] {cluster 2} ... {cluster n} {cues}
{meta seek #2} {tags}]</p>

<p style="margin-top: 1em">The elements in curly braces are
optional and depend on the contents and options used. A
couple of notes:</p>

<p style="margin-top: 1em">&Acirc;&middot; meta seek #1
includes only a small number of level 1 elements, and only
if they actually exist: attachments, chapters, cues, tags,
meta seek #2. Older versions of mkvmerge(1) <br>
used to put the clusters into this meta seek element as
well. Therefore some imprecise guessing was necessary to
reserve enough space. It often failed. Now only the clusters
<br>
are stored in meta seek #2, and meta seek #1 refers to the
meta seek element #2.</p>

<p style="margin-top: 1em">&Acirc;&middot; Attachment,
chapter and tag elements are only present if they were
added.</p>

<p style="margin-top: 1em">The shortest possible
Matroska(TM) file would look like this:</p>

<p style="margin-top: 1em">[EBML head] [segment [segment
information] [track information] [cluster 1]]</p>

<p style="margin-top: 1em">This might be the case for
audio-only files.</p>

<p style="margin-top: 1em">EXTERNAL TIMECODE FILES <br>
mkvmerge(1) allows the user to chose the timecodes for a
specific track himself. This can be used in order to create
files with variable frame rate video or include gaps in <br>
audio. A frame in this case is the unit that mkvmerge(1)
creates separately per Matroska(TM) block. For video this is
exactly one frame, for audio this is one packet of the <br>
specific audio type. E.g. for AC-3 this would be a packet
containing 1536 samples.</p>

<p style="margin-top: 1em">Timecode files that are used
when tracks are appended to each other must only be
specified for the first part in a chain of tracks. For
example if you append two files, v1.avi <br>
and v2.avi, and want to use timecodes then your command line
must look something like this:</p>

<p style="margin-top: 1em">$ mkvmerge ... --timecodes
0:my_timecodes.txt v1.avi +v2.avi</p>

<p style="margin-top: 1em">There are four formats that are
recognized by mkvmerge(1). The first line always contains
the version number. Empty lines, lines containing only
whitespace and lines beginning <br>
with &rsquo;#&rsquo; are ignored.</p>

<p style="margin-top: 1em">Timecode file format v1 <br>
This format starts with the version line. The second line
declares the default number of frames per second. All
following lines contain three numbers separated by commas:
the <br>
start frame (0 is the first frame), the end frame and the
number of frames in this range. The FPS is a floating point
number with the dot &rsquo;.&rsquo; as the decimal point.
The ranges can <br>
contain gaps for which the default FPS is used. An
example:</p>

<p style="margin-top: 1em"># timecode format v1 <br>
assume 27.930 <br>
800,1000,25 <br>
1500,1700,30</p>

<p style="margin-top: 1em">Timecode file format v2 <br>
In this format each line contains a timecode for the
corresponding frame. This timecode must be given in
millisecond precision. It can be a floating point number,
but it doesn&rsquo;t <br>
have to be. You have to give at least as many timecode lines
as there are frames in the track. The timecodes in this file
must be sorted. Example for 25fps:</p>

<p style="margin-top: 1em"># timecode format v2 <br>
0 <br>
40 <br>
80</p>

<p style="margin-top: 1em">Timecode file format v3 <br>
In this format each line contains a duration in seconds
followed by an optional number of frames per second. Both
can be floating point numbers. If the number of frames per
<br>
second is not present the default one is used. For audio you
should let the codec calculate the frame timecodes itself.
For that you should be using 0.0 as the number of frames
<br>
per second. You can also create gaps in the stream by using
the &rsquo;gap&rsquo; keyword followed by the duration of
the gap. Example for an audio file:</p>

<p style="margin-top: 1em"># timecode format v3 <br>
assume 0.0 <br>
25.325 <br>
7.530,38.236 <br>
gap, 10.050 <br>
2.000,38.236</p>

<p style="margin-top: 1em">Timecode file format v4 <br>
This format is identical to the v2 format. The only
difference is that the timecodes do not have to be sorted.
This format should almost never be used.</p>

<p style="margin-top: 1em">EXIT CODES <br>
mkvmerge(1) exits with one of three exit codes:</p>

<p style="margin-top: 1em">&Acirc;&middot; 0 -- This exit
codes means that muxing has completed successfully.</p>

<p style="margin-top: 1em">&Acirc;&middot; 1 -- In this
case mkvmerge(1) has output at least one warning, but muxing
did continue. A warning is prefixed with the text
&rsquo;Warning:&rsquo;. Depending on the issues involved the
<br>
resulting file might be ok or not. The user is urged to
check both the warning and the resulting file.</p>

<p style="margin-top: 1em">&Acirc;&middot; 2 -- This exit
code is used after an error occurred. mkvmerge(1) aborts
right after outputting the error message. Error messages
range from wrong command line arguments over <br>
read/write errors to broken files.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
mkvmerge(1) uses the default variables that determine the
system&rsquo;s locale (e.g. LANG and the LC_* family).
Additional variables:</p>

<p style="margin-top: 1em">MKVMERGE_DEBUG, MKVTOOLNIX_DEBUG
and its short form MTX_DEBUG <br>
The content is treated as if it had been passed via the
--debug option.</p>

<p style="margin-top: 1em">MKVMERGE_ENGAGE,
MKVTOOLNIX_ENGAGE and its short form MTX_ENGAGE <br>
The content is treated as if it had been passed via the
--engage option.</p>

<p style="margin-top: 1em">MKVMERGE_OPTIONS,
MKVTOOLNIX_OPTIONS and its short form MTX_OPTIONS <br>
The content is split on white space. The resulting partial
strings are treated as if it had been passed as command line
options. If you need to pass special characters (e.g. <br>
spaces) then you have to escape them (see the section about
escaping special characters in text).</p>

<p style="margin-top: 1em">SEE ALSO <br>
mkvinfo(1), mkvextract(1), mkvpropedit(1),
mkvtoolnix-gui(1)</p>

<p style="margin-top: 1em">WWW <br>
The latest version can always be found at the MKVToolNix
homepage[6].</p>

<p style="margin-top: 1em">AUTHOR <br>
Moritz Bunkus &lt;moritz@bunkus.org&gt; <br>
Developer</p>

<p style="margin-top: 1em">NOTES <br>
1. the Matroska(TM) website <br>
http://www.matroska.org/</p>

<p style="margin-top: 1em">2. the IANA homepage <br>
http://www.iana.org/assignments/media-types/</p>

<p style="margin-top: 1em">3.
mkvmerge-identification-output-schema-v9.json <br>

https://mkvtoolnix.download/doc/mkvmerge-identification-output-schema-v9.json</p>

<p style="margin-top: 1em">4. RFC 7159 <br>
https://tools.ietf.org/html/rfc7159</p>

<p style="margin-top: 1em">5. the Matroska(TM)
specification <br>
http://matroska.org/technical/specs/index.html</p>

<p style="margin-top: 1em">6. the MKVToolNix homepage <br>
https://mkvtoolnix.download/</p>

<p style="margin-top: 1em">MKVToolNix 14.0.0 2017-07-23
MKVMERGE(1)</p>
<hr>
</body>
</html>
