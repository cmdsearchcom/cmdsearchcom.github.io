<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:19:25 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>javac(1) General Commands Manual javac(1)</p>

<p style="margin-top: 1em">Name <br>
javac - Java programming language compiler</p>

<p style="margin-top: 1em">SYNOPSIS <br>
javac [ options ] [ sourcefiles ] [ classes ] [ @argfiles
]</p>

<p style="margin-top: 1em">Arguments may be in any
order.</p>

<p style="margin-top: 1em">options <br>
Command-line options.</p>

<p style="margin-top: 1em">sourcefiles <br>
One or more source files to be compiled (such as
MyClass.java).</p>

<p style="margin-top: 1em">classes <br>
One or more classes to be processed for annotations (such as
MyPackage.MyClass).</p>

<p style="margin-top: 1em">@argfiles <br>
One or more files that lists options and source files. The
-J options are not allowed in these files.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The javac tool reads class and interface definitions,
written in the Java programming language, and compiles them
into bytecode class files. It can also process annotations
in <br>
Java source files and classes.</p>

<p style="margin-top: 1em">There are two ways to pass
source code file names to javac:</p>

<p style="margin-top: 1em">o For a small number of source
files, simply list the file names on the command line.</p>

<p style="margin-top: 1em">o For a large number of source
files, list the file names in a file, separated by blanks or
line breaks. Then use the list file name on the javac
command line, preceded by an <br>
@ character.</p>

<p style="margin-top: 1em">Source code file names must have
.java suffixes, class file names must have .class suffixes,
and both source and class files must have root names that
identify the class. For <br>
example, a class called MyClass would be written in a source
file called MyClass.java and compiled into a bytecode class
file called MyClass.class.</p>

<p style="margin-top: 1em">Inner class definitions produce
additional class files. These class files have names
combining the inner and outer class names, such as
MyClass$MyInnerClass.class.</p>

<p style="margin-top: 1em">You should arrange source files
in a directory tree that reflects their package tree. For
example, if you keep all your source files in /workspace,
the source code for <br>
com.mysoft.mypack.MyClass should be in
/workspace/com/mysoft/mypack/MyClass.java.</p>

<p style="margin-top: 1em">By default, the compiler puts
each class file in the same directory as its source file.
You can specify a separate destination directory with -d
(see Options, below).</p>

<p style="margin-top: 1em">OPTIONS <br>
The compiler has a set of standard options that are
supported on the current development environment and will be
supported in future releases. An additional set of
non-standard <br>
options are specific to the current virtual machine and
compiler implementations and are subject to change in the
future. Non-standard options begin with -X.</p>

<p style="margin-top: 1em">Standard Options <br>
-Akey[=value] <br>
Options to pass to annotation processors. These are not
interpreted by javac directly, but are made available for
use by individual processors. key should be one or more <br>
identifiers separated by &quot;.&quot;.</p>

<p style="margin-top: 1em">-cp path or -classpath path <br>
Specify where to find user class files, and (optionally)
annotation processors and source files. This class path
overrides the user class path in the CLASSPATH environment
<br>
variable. If neither CLASSPATH, -cp nor -classpath is
specified, the user class path consists of the current
directory. See Setting the Class Path for more details. <br>
&gt;If the -sourcepath option is not specified, the user
class path is also searched for source files. <br>
If the -processorpath option is not specified, the class
path is also searched for annotation processors.</p>

<p style="margin-top: 1em">-Djava.ext.dirs=directories <br>
Override the location of installed extensions.</p>


<p style="margin-top: 1em">-Djava.endorsed.dirs=directories
<br>
Override the location of endorsed standards path.</p>

<p style="margin-top: 1em">-d directory <br>
Set the destination directory for class files. The directory
must already exist; javac will not create it. If a class is
part of a package, javac puts the class file in a <br>
subdirectory reflecting the package name, creating
directories as needed. For example, if you specify -d
/home/myclasses and the class is called
com.mypackage.MyClass, then <br>
the class file is called
/home/myclasses/com/mypackage/MyClass.class. <br>
If -d is not specified, javac puts each class files in the
same directory as the source file from which it was
generated. <br>
Note: The directory specified by -d is not automatically
added to your user class path.</p>

<p style="margin-top: 1em">-deprecation <br>
Show a description of each use or override of a deprecated
member or class. Without -deprecation, javac shows a summary
of the source files that use or override deprecated <br>
members or classes. -deprecation is shorthand for
-Xlint:deprecation.</p>

<p style="margin-top: 1em">-encoding encoding <br>
Set the source file encoding name, such as EUC-JP and UTF-8.
If -encoding is not specified, the platform default
converter is used.</p>

<p style="margin-top: 1em">-endorseddirs directories <br>
Override the location of endorsed standards path.</p>

<p style="margin-top: 1em">-extdirs directories <br>
Overrides the location of the ext directory. The directories
variable is a colon-separated list of directories. Each JAR
archive in the specified directories is searched <br>
for class files. All JAR archives found are automatically
part of the class path. <br>
If you are cross-compiling (compiling classes against
bootstrap and extension classes of a different Java platform
implementation), this option specifies the directories <br>
that contain the extension classes. See Cross-Compilation
Options for more information.</p>

<p style="margin-top: 1em">-g Generate all debugging
information, including local variables. By default, only
line number and source file information is generated.</p>

<p style="margin-top: 1em">-g:none <br>
Do not generate any debugging information.</p>

<p style="margin-top: 1em">-g:{keyword list} <br>
Generate only some kinds of debugging information, specified
by a comma separated list of keywords. Valid keywords
are:</p>

<p style="margin-top: 1em">source <br>
Source file debugging information</p>

<p style="margin-top: 1em">lines <br>
Line number debugging information</p>

<p style="margin-top: 1em">vars <br>
Local variable debugging information</p>

<p style="margin-top: 1em">-help <br>
Print a synopsis of standard options.</p>

<p style="margin-top: 1em">-implicit:{class,none} <br>
Controls the generation of class files for implicitly loaded
source files. To automatically generate class files, use
-implicit:class. To suppress class file generation, <br>
use -implicit:none. If this option is not specified, the
default is to automatically generate class files. In this
case, the compiler will issue a warning if any such class
<br>
files are generated when also doing annotation processing.
The warning will not be issued if this option is set
explicitly. See Searching For Types.</p>

<p style="margin-top: 1em">-Joption <br>
Pass option to the java launcher called by javac. For
example, -J-Xms48m sets the startup memory to 48 megabytes.
It is a common convention for -J to pass options to the <br>
underlying VM executing applications written in Java. <br>
Note: CLASSPATH, -classpath, -bootclasspath, and -extdirs do
not specify the classes used to run javac. Fiddling with the
implementation of the compiler in this way is usu&acirc;
<br>
ally pointless and always risky. If you do need to do this,
use the -J option to pass through options to the underlying
java launcher.</p>

<p style="margin-top: 1em">-nowarn <br>
Disable warning messages. This has the same meaning as
-Xlint:none.</p>

<p style="margin-top: 1em">-proc: {none,only} <br>
Controls whether annotation processing and/or compilation is
done. -proc:none means that compilation takes place without
annotation processing. -proc:only means that only <br>
annotation processing is done, without any subsequent
compilation.</p>

<p style="margin-top: 1em">-processor
class1[,class2,class3...] <br>
Names of the annotation processors to run. This bypasses the
default discovery process.</p>

<p style="margin-top: 1em">-processorpath path <br>
Specify where to find annotation processors; if this option
is not used, the class path will be searched for
processors.</p>

<p style="margin-top: 1em">-s dir <br>
Specify the directory where to place generated source files.
The directory must already exist; javac will not create it.
If a class is part of a package, the compiler puts <br>
the source file in a subdirectory reflecting the package
name, creating directories as needed. For example, if you
specify -s /home/mysrc and the class is called <br>
com.mypackage.MyClass, then the source file will be placed
in /home/mysrc/com/mypackage/MyClass.java.</p>

<p style="margin-top: 1em">-source release <br>
Specifies the version of source code accepted. The following
values for release are allowed:</p>

<p style="margin-top: 1em">1.3 <br>
The compiler does not support assertions, generics, or other
language features introduced after Java SE 1.3.</p>

<p style="margin-top: 1em">1.4 <br>
The compiler accepts code containing assertions, which were
introduced in Java SE 1.4.</p>

<p style="margin-top: 1em">1.5 <br>
The compiler accepts code containing generics and other
language features introduced in Java SE 5.</p>

<p style="margin-top: 1em">5 Synonym for 1.5.</p>

<p style="margin-top: 1em">1.6 <br>
No language changes were introduced in Java SE 6. However,
encoding errors in source files are now reported as errors
instead of warnings as in previous releases of Java <br>
SE.</p>

<p style="margin-top: 1em">6 Synonym for 1.6.</p>

<p style="margin-top: 1em">1.7 <br>
This is the default value. The compiler accepts code with
features introduced in Java SE 7.</p>

<p style="margin-top: 1em">7 Synonym for 1.7.</p>

<p style="margin-top: 1em">-sourcepath sourcepath <br>
Specify the source code path to search for class or
interface definitions. As with the user class path, source
path entries are separated by colons (:) and can be
directo&acirc; <br>
ries, JAR archives, or ZIP archives. If packages are used,
the local path name within the directory or archive must
reflect the package name. <br>
Note: Classes found through the class path may be subject to
automatic recompilation if their sources are also found. See
Searching For Types.</p>

<p style="margin-top: 1em">-verbose <br>
Verbose output. This includes information about each class
loaded and each source file compiled.</p>

<p style="margin-top: 1em">-version <br>
Print version information.</p>

<p style="margin-top: 1em">-Werror <br>
Terminate compilation if warnings occur.</p>

<p style="margin-top: 1em">-X Display information about
non-standard options and exit.</p>

<p style="margin-top: 1em">Cross-Compilation Options <br>
By default, classes are compiled against the bootstrap and
extension classes of the platform that javac shipped with.
But javac also supports cross-compiling, where classes are
<br>
compiled against a bootstrap and extension classes of a
different Java platform implementation. It is important to
use -bootclasspath and -extdirs when cross-compiling; see
<br>
Cross-Compilation Example below.</p>

<p style="margin-top: 1em">-target version <br>
Generate class files that target a specified version of the
VM. Class files will run on the specified target and on
later versions, but not on earlier versions of the VM. <br>
Valid targets are 1.1, 1.2, 1.3, 1.4, 1.5 (also 5), 1.6
(also 6), and 1.7 (also 7).</p>

<p style="margin-top: 1em">The default for -target depends
on the value of -source:</p>

<p style="margin-top: 1em">o If -source is not specified,
the value of -target is 1.7</p>

<p style="margin-top: 1em">o If -source is 1.2, the value
of -target is 1.4</p>

<p style="margin-top: 1em">o If -source is 1.3, the value
of -target is 1.4</p>

<p style="margin-top: 1em">o If -source is 1.5, the value
of -target is 1.7</p>

<p style="margin-top: 1em">o If -source is 1.6, the value
of -target is 1.7</p>

<p style="margin-top: 1em">o For all other values of
-source, the value of -target is the value of -source.</p>

<p style="margin-top: 1em">-bootclasspath bootclasspath
<br>
Cross-compile against the specified set of boot classes. As
with the user class path, boot class path entries are
separated by colons (:) and can be directories, JAR
ar&acirc; <br>
chives, or ZIP archives.</p>

<p style="margin-top: 1em">Non-Standard Options <br>
-Xbootclasspath/p:path <br>
Prepend to the bootstrap class path.</p>

<p style="margin-top: 1em">-Xbootclasspath/a:path <br>
Append to the bootstrap class path.</p>

<p style="margin-top: 1em">-Xbootclasspath/:path <br>
Override location of bootstrap class files.</p>

<p style="margin-top: 1em">-Xlint <br>
Enable all recommended warnings. In this release, enabling
all available warnings is recommended.</p>

<p style="margin-top: 1em">-Xlint:all <br>
Enable all recommended warnings. In this release, enabling
all available warnings is recommended.</p>

<p style="margin-top: 1em">-Xlint:none <br>
Disable all warnings.</p>

<p style="margin-top: 1em">-Xlint:name <br>
Enable warning name. See the section Warnings That Can Be
Enabled or Disabled with -Xlint Option for a list of
warnings you can enable with this option.</p>

<p style="margin-top: 1em">-Xlint:-name <br>
Disable warning name. See the section Warnings That Can Be
Enabled or Disabled with -Xlint Option for a list of
warnings you can disable with this option.</p>

<p style="margin-top: 1em">-Xmaxerrs number <br>
Set the maximum number of errors to print.</p>

<p style="margin-top: 1em">-Xmaxwarns number <br>
Set the maximum number of warnings to print.</p>

<p style="margin-top: 1em">-Xstdout filename <br>
Send compiler messages to the named file. By default,
compiler messages go to System.err.</p>

<p style="margin-top: 1em">-Xprefer:{newer,source} <br>
Specify which file to read when both a source file and class
file are found for a type. (See Searching For Types). If
-Xprefer:newer is used, it reads the newer of the <br>
source or class file for a type (default). If the
-Xprefer:source option is used, it reads source file. Use
-Xprefer:source when you want to be sure that any annotation
<br>
processors can access annotations declared with a retention
policy of SOURCE.</p>


<p style="margin-top: 1em">-Xpkginfo:{always,legacy,nonempty}
<br>
Specify handling of package-info files</p>

<p style="margin-top: 1em">-Xprint <br>
Print out textual representation of specified types for
debugging purposes; perform neither annotation processing
nor compilation. The format of the output may change.</p>

<p style="margin-top: 1em">-XprintProcessorInfo <br>
Print information about which annotations a processor is
asked to process.</p>

<p style="margin-top: 1em">-XprintRounds <br>
Print information about initial and subsequent annotation
processing rounds.</p>

<p style="margin-top: 1em">Warnings That Can Be Enabled or
Disabled with -Xlint Option <br>
Enable warning name with the option -Xlint:name, where name
is one of the following warning names. Similarly, you can
disable warning name with the option -Xlint:-name:</p>

<p style="margin-top: 1em">cast <br>
Warn about unnecessary and redundant casts. For example:
<br>
String s = (String)&quot;Hello!&quot;</p>

<p style="margin-top: 1em">classfile <br>
Warn about issues related to classfile contents.</p>

<p style="margin-top: 1em">deprecation <br>
Warn about use of deprecated items. For example: <br>
java.util.Date myDate = new java.util.Date(); <br>
int currentDay = myDate.getDay(); <br>
The method java.util.Date.getDay has been deprecated since
JDK 1.1.</p>

<p style="margin-top: 1em">dep-ann <br>
Warn about items that are documented with an @deprecated
Javadoc comment, but do not have a @Deprecated annotation.
For example: <br>
/** <br>
* @deprecated As of Java SE 7, replaced by {@link
#newMethod()} <br>
*/</p>

<p style="margin-top: 1em">public static void
deprecatedMethood() { }</p>

<p style="margin-top: 1em">public static void newMethod() {
}</p>

<p style="margin-top: 1em">divzero <br>
Warn about division by constant integer 0. For example: <br>
int divideByZero = 42 / 0;</p>

<p style="margin-top: 1em">empty <br>
Warn about empty statements after if statements. For
example: <br>
class E { <br>
void m() { <br>
if (true) ; <br>
} <br>
}</p>

<p style="margin-top: 1em">fallthrough <br>
Check switch blocks for fall-through cases and provide a
warning message for any that are found. Fall-through cases
are cases in a switch block, other than the last case in
<br>
the block, whose code does not include a break statement,
allowing code execution to &quot;fall through&quot; from
that case to the next case. For example, the code following
the <br>
case 1 label in this switch block does not end with a break
statement: <br>
switch (x) { <br>
case 1: <br>
System.out.println(&quot;1&quot;); <br>
// No break statement here. <br>
case 2: <br>
System.out.println(&quot;2&quot;); <br>
} <br>
If the -Xlint:fallthrough flag were used when compiling this
code, the compiler would emit a warning about &quot;possible
fall-through into case,&quot; along with the line number of
<br>
the case in question.</p>

<p style="margin-top: 1em">finally <br>
Warn about finally clauses that cannot complete normally.
For example: <br>
public static int m() { <br>
try { <br>
throw new NullPointerException(); <br>
} catch (NullPointerException e) { <br>
System.err.println(&quot;Caught
NullPointerException.&quot;); <br>
return 1; <br>
} finally { <br>
return 0; <br>
} <br>
} <br>
The compiler generates a warning for finally block in this
example. When this method is called, it returns a value of
0, not 1. A finally block always executes when the try <br>
block exits. In this example, if control is transferred to
the catch, then the method exits. However, the finally block
must be executed, so it is executed, even though <br>
control has already been transferred outside the method.</p>

<p style="margin-top: 1em">options <br>
Warn about issues relating to the use of command line
options. See Cross-Compilation Example for an example of
this kind of warning.</p>

<p style="margin-top: 1em">overrides <br>
Warn about issues regarding method overrides. For example,
consider the following two classes: <br>
public class ClassWithVarargsMethod { <br>
void varargsMethod(String... s) { } <br>
} <br>
public class ClassWithOverridingMethod extends
ClassWithVarargsMethod { <br>
@Override <br>
void varargsMethod(String[] s) { } <br>
} <br>
The compiler generates a warning similar to the following:
<br>
warning: [override] varargsMethod(String[]) in
ClassWithOverridingMethod overrides varargsMethod(String...)
in ClassWithVarargsMethod; overriding method is missing
&rsquo;...&rsquo; <br>
When the compiler encounters a varargs method, it translates
the varargs formal parameter into an array. In the method
ClassWithVarargsMethod.varargsMethod, the compiler <br>
translates the varargs formal parameter String... s to the
formal parameter String[] s, an array, which matches the
formal parameter of the method ClassWithOverriding&acirc;
<br>
Method.varargsMethod. Consequently, this example
compiles.</p>

<p style="margin-top: 1em">path <br>
Warn about invalid path elements and nonexistent path
directories on the command line (with regards to the class
path, the source path, and other paths). Such warnings
can&acirc; <br>
not be suppressed with the @SuppressWarnings annotation. For
example: <br>
javac -Xlint:path -classpath /nonexistentpath
Example.java</p>

<p style="margin-top: 1em">processing <br>
Warn about issues regarding annotation processing. The
compiler generates this warning if you have a class that has
an annotation, and you use an annotation processor that <br>
cannot handle that type of exception. For example, the
following is a simple annotation processor: <br>
Source file AnnoProc.java: <br>
import java.util.*; <br>
import javax.annotation.processing.*; <br>
import javax.lang.model.*; <br>
import javax.lang.model.element.*;</p>


<p style="margin-top: 1em">@SupportedAnnotationTypes(&quot;NotAnno&quot;)
<br>
public class AnnoProc extends AbstractProcessor { <br>
public boolean process(Set&lt;? extends TypeElement&gt;
elems, RoundEnvironment renv) { <br>
return true; <br>
}</p>

<p style="margin-top: 1em">public SourceVersion
getSupportedSourceVersion() { <br>
return SourceVersion.latest(); <br>
} <br>
} <br>
Source file AnnosWithoutProcessors.java: <br>
@interface Anno { }</p>

<p style="margin-top: 1em">@Anno <br>
class AnnosWithoutProcessors { } <br>
The following commands compile the annotation processor
AnnoProc, then run this annotation processor against the
source file AnnosWithoutProcessors.java: <br>
% javac AnnoProc.java <br>
% javac -cp . -Xlint:processing -processor AnnoProc
-proc:only AnnosWithoutProcessors.java <br>
When the compiler runs the annotation processor against the
source file AnnosWithoutProcessors.java, it generates the
following warning: <br>
warning: [processing] No processor claimed any of these
annotations: Anno <br>
To resolve this issue, you can rename the annotation defined
and used in the class AnnosWithoutProcessors from Anno to
NotAnno.</p>

<p style="margin-top: 1em">rawtypes <br>
Warn about unchecked operations on raw types. The following
statement generates a rawtypes warning: <br>
void countElements(List l) { ... } <br>
The following does not generate a rawtypes warning: <br>
void countElements(List&lt;?&gt; l) { ... } <br>
List is a raw type. However, List&lt;?&gt; is a unbounded
wildcard parameterized type. Because List is a parameterized
interface, you should always specify its type argument. In
<br>
this example, the List formal argument is specified with a
unbounded wildcard (?) as its formal type parameter, which
means that the countElements method can accept any <br>
instantiation of the List interface.</p>

<p style="margin-top: 1em">serial <br>
Warn about missing serialVersionUID definitions on
serializable classes. For example: <br>
public class PersistentTime implements Serializable <br>
{ <br>
private Date time;</p>

<p style="margin-top: 1em">public PersistentTime() { <br>
time = Calendar.getInstance().getTime(); <br>
}</p>

<p style="margin-top: 1em">public Date getTime() { <br>
return time; <br>
} <br>
} <br>
The compiler generates the following warning: <br>
warning: [serial] serializable class PersistentTime has no
definition of serialVersionUID <br>
If a serializable class does not explicitly declare a field
named serialVersionUID, then the serialization runtime will
calculate a default serialVersionUID value for that <br>
class based on various aspects of the class, as described in
the Java Object Serialization Specification. However, it is
strongly recommended that all serializable classes <br>
explicitly declare serialVersionUID values because the
default process of computing serialVersionUID vales is
highly sensitive to class details that may vary depending on
<br>
compiler implementations, and can thus result in unexpected
InvalidClassExceptions during deserialization. Therefore, to
guarantee a consistent serialVersionUID value <br>
across different Java compiler implementations, a
serializable class must declare an explicit serialVersionUID
value.</p>

<p style="margin-top: 1em">static <br>
Warn about issues relating to use of statics. For example:
<br>
class XLintStatic { <br>
static void m1() { } <br>
void m2() { this.m1(); } <br>
} <br>
The compiler generates the following warning: <br>
warning: [static] static method should be qualified by type
name, XLintStatic, instead of by an expression <br>
To resolve this issue, you can call the static method m1 as
follows: <br>
XLintStatic.m1(); <br>
Alternatively, you can remove the static keyword from the
declaration of the method m1.</p>

<p style="margin-top: 1em">try <br>
Warn about issues relating to use of try blocks, including
try-with-resources statements. For example, a warning is
generated for the following statement because the <br>
resource ac declared in the try statement is not used: <br>
try ( AutoCloseable ac = getResource() ) { <br>
// do nothing <br>
}</p>

<p style="margin-top: 1em">unchecked <br>
Give more detail for unchecked conversion warnings that are
mandated by the Java Language Specification. For example:
<br>
List l = new ArrayList&lt;Number&gt;(); <br>
List&lt;String&gt; ls = l; // unchecked warning <br>
During type erasure, the types ArrayList&lt;Number&gt; and
List&lt;String&gt; become ArrayList and List, respectively.
<br>
The variable ls has the parameterized type
List&lt;String&gt;. When the List referenced by l is
assigned to ls, the compiler generates an unchecked warning;
the compiler is <br>
unable to determine at compile time, and moreover knows that
the JVM will not be able to determine at runtime, if l
refers to a List&lt;String&gt; type; it does not.
Conse&acirc; <br>
quently, heap pollution occurs. <br>
In detail, a heap pollution situation occurs when the List
object l, whose static type is List&lt;Number&gt;, is
assigned to another List object, ls, that has a different
static <br>
type, List&lt;String&gt;. However, the compiler still allows
this assignment. It must allow this assignment to preserve
backwards compatibility with versions of Java SE that do
<br>
not support generics. Because of type erasure,
List&lt;Number&gt; and List&lt;String&gt; both become List.
Consequently, the compiler allows the assignment of the
object l, which has a <br>
raw type of List, to the object ls.</p>

<p style="margin-top: 1em">varargs <br>
Warn about unsafe usages of variable arguments (varargs)
methods, in particular, those that contain non-reifiable
arguments. For example: <br>
public class ArrayBuilder { <br>
public static &lt;T&gt; void addToList (List&lt;T&gt;
listArg, T... elements) { <br>
for (T x : elements) { <br>
listArg.add(x); <br>
} <br>
} <br>
} <br>
The compiler generates the following warning for the
definition of the method ArrayBuilder.addToList: <br>
warning: [varargs] Possible heap pollution from
parameterized vararg type T <br>
When the compiler encounters a varargs method, it translates
the varargs formal parameter into an array. However, the
Java programming language does not permit the creation <br>
of arrays of parameterized types. In the method
ArrayBuilder.addToList, the compiler translates the varargs
formal parameter T... elements to the formal parameter T[]
ele&acirc; <br>
ments, an array. However, because of type erasure, the
compiler converts the varargs formal parameter to Object[]
elements. Consequently, there is a possibility of heap <br>
pollution.</p>

<p style="margin-top: 1em">COMMAND LINE ARGUMENT FILES <br>
To shorten or simplify the javac command line, you can
specify one or more files that themselves contain arguments
to the javac command (except -J options). This enables you
to <br>
create javac commands of any length on any operating
system.</p>

<p style="margin-top: 1em">An argument file can include
javac options and source filenames in any combination. The
arguments within a file can be space-separated or
newline-separated. If a filename con&acirc; <br>
tains embedded spaces, put the whole filename in double
quotes.</p>

<p style="margin-top: 1em">Filenames within an argument
file are relative to the current directory, not the location
of the argument file. Wildcards (*) are not allowed in these
lists (such as for specify&acirc; <br>
ing *.java). Use of the &rsquo;@&rsquo; character to
recursively interpret files is not supported. The -J options
are not supported because they are passed to the launcher,
which does not <br>
support argument files.</p>

<p style="margin-top: 1em">When executing javac, pass in
the path and name of each argument file with the
&rsquo;@&rsquo; leading character. When javac encounters an
argument beginning with the character &lsquo;@&rsquo;, it
<br>
expands the contents of that file into the argument
list.</p>

<p style="margin-top: 1em">Example - Single Arg File <br>
You could use a single argument file named
&quot;argfile&quot; to hold all javac arguments:</p>

<p style="margin-top: 1em">% javac @argfile</p>

<p style="margin-top: 1em">This argument file could contain
the contents of both files shown in the next example.</p>

<p style="margin-top: 1em">Example - Two Arg Files <br>
You can create two argument files -- one for the javac
options and the other for the source filenames: (Notice the
following lists have no line-continuation characters.)</p>

<p style="margin-top: 1em">Create a file named
&quot;options&quot; containing:</p>

<p style="margin-top: 1em">-d classes <br>
-g <br>
-sourcepath /java/pubs/ws/1.3/src/share/classes</p>

<p style="margin-top: 1em">Create a file named
&quot;classes&quot; containing:</p>

<p style="margin-top: 1em">MyClass1.java <br>
MyClass2.java <br>
MyClass3.java</p>

<p style="margin-top: 1em">You would then run javac
with:</p>

<p style="margin-top: 1em">% javac @options @classes</p>

<p style="margin-top: 1em">Example - Arg Files with Paths
<br>
The argument files can have paths, but any filenames inside
the files are relative to the current working directory (not
path1 or path2):</p>

<p style="margin-top: 1em">% javac @path1/options
@path2/classes</p>

<p style="margin-top: 1em">ANNOTATION PROCESSING <br>
javac provides direct support for annotation processing,
superseding the need for the separate annotation processing
tool, apt.</p>

<p style="margin-top: 1em">The API for annotation
processors is defined in the javax.annotation.processing and
javax.lang.model packages and subpackages.</p>

<p style="margin-top: 1em">Overview of annotation
processing <br>
Unless annotation processing is disabled with the -proc:none
option, the compiler searches for any annotation processors
that are available. The search path can be specified with
<br>
the -processorpath option; if it is not given, the user
class path is used. Processors are located by means of
service provider-configuration files named
META-INF/ser&acirc; <br>
vices/javax.annotation.processing.Processor on the search
path. Such files should contain the names of any annotation
processors to be used, listed one per line. Alternatively,
<br>
processors can be specified explicitly, using the -processor
option.</p>

<p style="margin-top: 1em">After scanning the source files
and classes on the command line to determine what
annotations are present, the compiler queries the processors
to determine what annotations they <br>
process. When a match is found, the processor will be
invoked. A processor may &quot;claim&quot; the annotations
it processes, in which case no further attempt is made to
find any proces&acirc; <br>
sors for those annotations. Once all annotations have been
claimed, the compiler does not look for additional
processors.</p>

<p style="margin-top: 1em">If any processors generate any
new source files, another round of annotation processing
will occur: any newly generated source files will be
scanned, and the annotations pro&acirc; <br>
cessed as before. Any processors invoked on previous rounds
will also be invoked on all subsequent rounds. This
continues until no new source files are generated.</p>

<p style="margin-top: 1em">After a round occurs where no
new source files are generated, the annotation processors
will be invoked one last time, to give them a chance to
complete any work they may need to <br>
do. Finally, unless the -proc:only option is used, the
compiler will compile the original and all the generated
source files.</p>

<p style="margin-top: 1em">Implicitly loaded source files
<br>
To compile a set of source files, the compiler may need to
implicitly load additional source files. (See Searching For
Types). Such files are currently not subject to annotation
<br>
processing. By default, the compiler will give a warning if
annotation processing has occurred and any implicitly loaded
source files are compiled. See the -implicit option for <br>
ways to suppress the warning.</p>

<p style="margin-top: 1em">SEARCHING FOR TYPES <br>
When compiling a source file, the compiler often needs
information about a type whose definition did not appear in
the source files given on the command line. The compiler
needs <br>
type information for every class or interface used,
extended, or implemented in the source file. This includes
classes and interfaces not explicitly mentioned in the
source file <br>
but which provide information through inheritance.</p>

<p style="margin-top: 1em">For example, when you subclass
java.applet.Applet, you are also using Applet&rsquo;s
ancestor classes: java.awt.Panel, java.awt.Container,
java.awt.Component, and java.lang.Object.</p>

<p style="margin-top: 1em">When the compiler needs type
information, it looks for a source file or class file which
defines the type. The compiler searches for class files
first in the bootstrap and exten&acirc; <br>
sion classes, then in the user class path (which by default
is the current directory). The user class path is defined by
setting the CLASSPATH environment variable or by using <br>
the -classpath command line option. (For details, see
Setting the Class Path).</p>

<p style="margin-top: 1em">If you set the -sourcepath
option, the compiler searches the indicated path for source
files; otherwise the compiler searches the user class path
for both class files and source <br>
files.</p>

<p style="margin-top: 1em">You can specify different
bootstrap or extension classes with the -bootclasspath and
-extdirs options; see Cross-Compilation Options below.</p>

<p style="margin-top: 1em">A successful type search may
produce a class file, a source file, or both. If both are
found, you can use the -Xprefer option to instruct the
compiler which to use. If newer is <br>
given, the compiler will use the newer of the two files. If
source is given, it will use the source file. The default is
newer.</p>

<p style="margin-top: 1em">If a type search finds a source
file for a required type, either by itself, or as a result
of the setting for -Xprefer, the compiler will read the
source file to get the informa&acirc; <br>
tion it needs. In addition, it will by default compile the
source file as well. You can use the -implicit option to
specify the behavior. If none is given, no class files will
be <br>
generated for the source file. If class is given, class
files will be generated for the source file.</p>

<p style="margin-top: 1em">The compiler may not discover
the need for some type information until after annotation
processing is complete. If the type information is found in
a source file and no -implicit <br>
option is given, the compiler will give a warning that the
file is being compiled without being subject to annotation
processing. To disable the warning, either specify the file
<br>
on the command line (so that it will be subject to
annotation processing) or use the -implicit option to
specify whether or not class files should be generated for
such source <br>
files.</p>

<p style="margin-top: 1em">PROGRAMMATIC INTERFACE <br>
javac supports the new Java Compiler API defined by the
classes and interfaces in the javax.tools package.</p>

<p style="margin-top: 1em">Example <br>
To perform a compilation using arguments as you would give
on the command line, you can use the following:</p>

<p style="margin-top: 1em">JavaCompiler javac =
ToolProvider.getSystemJavaCompiler(); <br>
int rc = javac.run(null, null, null, args);</p>

<p style="margin-top: 1em">This will write any diagnostics
to the standard output stream, and return the exit code that
javac would give when invoked from the command line.</p>

<p style="margin-top: 1em">You can use other methods on the
javax.tools.JavaCompiler interface to handle diagnostics,
control where files are read from and written to, and so
on.</p>

<p style="margin-top: 1em">Old Interface <br>
Note: This API is retained for backwards compatibility only;
all new code should use the Java Compiler API, described
above.</p>

<p style="margin-top: 1em">The com.sun.tools.javac.Main
class provides two static methods to invoke the compiler
from a program:</p>

<p style="margin-top: 1em">public static int
compile(String[] args); <br>
public static int compile(String[] args, PrintWriter
out);</p>

<p style="margin-top: 1em">The args parameter represents
any of the command line arguments that would normally be
passed to the javac program and are outlined in the above
Synopsis section.</p>

<p style="margin-top: 1em">The out parameter indicates
where the compiler&rsquo;s diagnostic output is
directed.</p>

<p style="margin-top: 1em">The return value is equivalent
to the exit value from javac.</p>

<p style="margin-top: 1em">Note that all other classes and
methods found in a package whose name starts with
com.sun.tools.javac (informally known as sub-packages of
com.sun.tools.javac) are strictly <br>
internal and subject to change at any time.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Compiling a Simple Program <br>
One source file, Hello.java, defines a class called
greetings.Hello. The greetings directory is the package
directory both for the source file and the class file and is
off the <br>
current directory. This allows us to use the default user
class path. It also makes it unnecessary to specify a
separate destination directory with -d.</p>

<p style="margin-top: 1em">% ls <br>
greetings/ <br>
% ls greetings <br>
Hello.java <br>
% cat greetings/Hello.java <br>
package greetings;</p>

<p style="margin-top: 1em">public class Hello { <br>
public static void main(String[] args) { <br>
for (int i=0; i &lt; args.length; i++) { <br>
System.out.println(&quot;Hello &quot; + args[i]); <br>
} <br>
} <br>
} <br>
% javac greetings/Hello.java <br>
% ls greetings <br>
Hello.class Hello.java <br>
% java greetings.Hello World Universe Everyone <br>
Hello World <br>
Hello Universe <br>
Hello Everyone</p>

<p style="margin-top: 1em">Compiling Multiple Source Files
<br>
This example compiles all the source files in the package
greetings.</p>

<p style="margin-top: 1em">% ls <br>
greetings/ <br>
% ls greetings <br>
Aloha.java GutenTag.java Hello.java Hi.java <br>
% javac greetings/*.java <br>
% ls greetings <br>
Aloha.class GutenTag.class Hello.class Hi.class <br>
Aloha.java GutenTag.java Hello.java Hi.java</p>

<p style="margin-top: 1em">Specifying a User Class Path
<br>
Having changed one of the source files in the previous
example, we recompile it:</p>

<p style="margin-top: 1em">% pwd <br>
/examples <br>
% javac greetings/Hi.java</p>

<p style="margin-top: 1em">Since greetings.Hi refers to
other classes in the greetings package, the compiler needs
to find these other classes. The example above works,
because our default user class path <br>
happens to be the directory containing the package
directory. But suppose we want to recompile this file and
not worry about which directory we&rsquo;re in? Then we need
to add /exam&acirc; <br>
ples to the user class path. We can do this by setting
CLASSPATH, but here we&rsquo;ll use the -classpath
option.</p>

<p style="margin-top: 1em">% javac -classpath /examples
/examples/greetings/Hi.java</p>

<p style="margin-top: 1em">If we change greetings.Hi again,
to use a banner utility, that utility also needs to be
accessible through the user class path.</p>

<p style="margin-top: 1em">% javac -classpath
/examples:/lib/Banners.jar /examples/greetings/Hi.java</p>

<p style="margin-top: 1em">To execute a class in greetings,
we need access both to greetings and to the classes it
uses.</p>

<p style="margin-top: 1em">% java -classpath
/examples:/lib/Banners.jar greetings.Hi</p>

<p style="margin-top: 1em">Separating Source Files and
Class Files <br>
It often makes sense to keep source files and class files in
separate directories, especially on large projects. We use
-d to indicate the separate class file destination. Since
<br>
the source files are not in the user class path, we use
-sourcepath to help the compiler find them.</p>

<p style="margin-top: 1em">% ls <br>
classes/ lib/ src/ <br>
% ls src <br>
farewells/ <br>
% ls src/farewells <br>
Base.java GoodBye.java <br>
% ls lib <br>
Banners.jar <br>
% ls classes <br>
% javac -sourcepath src -classpath classes:lib/Banners.jar
src/farewells/GoodBye.java -d classes <br>
% ls classes <br>
farewells/ <br>
% ls classes/farewells <br>
Base.class GoodBye.class</p>

<p style="margin-top: 1em">Note: The compiler compiled
src/farewells/Base.java, even though we didn&rsquo;t specify
it on the command line. To trace automatic compiles, use the
-verbose option.</p>

<p style="margin-top: 1em">Cross-Compilation Example <br>
The following example uses javac to compile code that will
run on a 1.6 VM.</p>

<p style="margin-top: 1em">% javac -source 1.6 -target 1.6
-bootclasspath jdk1.6.0/lib/rt.jar -extdirs &quot;&quot;
OldCode.java</p>

<p style="margin-top: 1em">The -source 1.6 option specifies
that version 1.6 (or 6) of the Java programming language be
used to compile OldCode.java. The option -target 1.6 option
ensures that the gener&acirc; <br>
ated class files will be compatible with 1.6 VMs. Note that
in most cases, the value of the -target option is the value
of the -source option; in this example, you can omit the
<br>
-target option.</p>

<p style="margin-top: 1em">You must specify the
-bootclasspath option to specify the correct version of the
bootstrap classes (the rt.jar library). If not, the compiler
generates a warning:</p>

<p style="margin-top: 1em">% javac -source 1.6 OldCode.java
<br>
warning: [options] bootstrap class path not set in
conjunction with -source 1.6</p>

<p style="margin-top: 1em">If you do not specify the
correct version of bootstrap classes, the compiler will use
the old language rules (in this example, it will use version
1.6 of the Java programming <br>
language) combined with the new bootstrap classes, which can
result in class files that do not work on the older platform
(in this case, Java SE 6) because reference to
non-exis&acirc; <br>
tent methods can get included.</p>

<p style="margin-top: 1em">SEE ALSO <br>
o The javac Guide @ <br>

http://docs.oracle.com/javase/7/docs/technotes/guides/javac/index.html</p>

<p style="margin-top: 1em">o java(1) - the Java Application
Launcher</p>

<p style="margin-top: 1em">o jdb(1) - Java Application
Debugger</p>

<p style="margin-top: 1em">o javah(1) - C Header and Stub
File Generator</p>

<p style="margin-top: 1em">o javap(1) - Class File
Disassembler</p>

<p style="margin-top: 1em">o javadoc(1) - API Documentation
Generator</p>

<p style="margin-top: 1em">o jar(1) - JAR Archive Tool</p>

<p style="margin-top: 1em">o The Java Extensions Framework
@ <br>

http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/index.html</p>

<p style="margin-top: 1em">16 Mar 2012 javac(1)</p>
<hr>
</body>
</html>
