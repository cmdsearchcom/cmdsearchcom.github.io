<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:20:13 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>KAK_HIGHLIGHTERS(1) highlighters KAK_HIGHLIGHTERS(1)</p>

<p style="margin-top: 1em">NAME <br>
highlighters - a</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Manipulation of the displayed text is done through
highlighters, which can be added or removed with the
following commands:</p>

<p style="margin-top: 1em">addhl &lt;highlighter_name&gt;
&lt;highlighter_parameters&gt; ...</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">rmhl &lt;highlighter_id&gt;</p>

<p style="margin-top: 1em">highlighter_id is a name
generated by the highlighter specified with
highlighter_name, possibly dependent on the parameters. Use
command completion in a prompt on the rmhl <br>
command to see the existing highlighters ids.</p>

<p style="margin-top: 1em">GENERAL HIGHLIGHTERS <br>
regex &lt;ex&gt; &lt;capture_id&gt;:&lt;face&gt; ... <br>
highlight a regex, takes the regex as first parameter,
followed by any number of face parameters. For example:</p>

<p style="margin-top: 1em">addhl regex //(DO:)?[^0 0:cyan
1:yellow,red</p>

<p style="margin-top: 1em">will highlight C++ style
comments in cyan, with an eventual &rsquo;TODO:&rsquo; <br>
in yellow on red background</p>

<p style="margin-top: 1em">dynregex <br>
Similar to regex, but expand (like a command parameter
would) the given expression before building a regex from the
result</p>

<p style="margin-top: 1em">flag_lines &lt;flag&gt;
&lt;option_name&gt; <br>
add a column in front of text, and display the given flag in
it for every line contained in the int-list option named
&lt;option_name&gt;</p>

<p style="margin-top: 1em">show_matching <br>
highlight matching char of the character under the
selections cursor using MatchingChar face</p>

<p style="margin-top: 1em">number_lines [options] <br>
show line numbers, with the following options:</p>

<p style="margin-top: 1em">-relative <br>
show line numbers relative to the main cursor line</p>

<p style="margin-top: 1em">-hlcursor <br>
highlight the cursor line with a separate face</p>

<p style="margin-top: 1em">-separator &lt;separator
text&gt; <br>
specify a string to separate the line numbers column with
the rest of the buffer (default is |)</p>

<p style="margin-top: 1em">ranges &lt;option_name&gt; <br>
use the data in the range-faces option of the given name to
highlight the buffer.</p>

<p style="margin-top: 1em">fill &lt;face&gt; <br>
fill using the given face, mostly useful with regions
highlighters</p>

<p style="margin-top: 1em">HIGHLIGHTING GROUPS <br>
The group highlighter is a container for other highlighters.
You can add a group to the current window using</p>

<p style="margin-top: 1em">addhl group &lt;name&gt;</p>

<p style="margin-top: 1em">The -group switch of the addhl
command provides a mean to add highlighters inside this
group:</p>

<p style="margin-top: 1em">addhl -group &lt;name&gt;
&lt;type&gt; &lt;params&gt;...</p>

<p style="margin-top: 1em">Groups can contain other groups,
the -group switch can be used to define a path as
follows:</p>

<p style="margin-top: 1em">addhl -group &lt;name&gt; group
&lt;subname&gt; <br>
addhl -group &lt;name&gt;/&lt;subname&gt; &lt;type&gt;
&lt;params&gt;...</p>

<p style="margin-top: 1em">REGIONS HIGHLIGHTERS <br>
A special highlighter provides a way to segment the buffer
into regions, which are to be highlighted differently.</p>

<p style="margin-top: 1em">name <br>
user defined, used to identify the region</p>

<p style="margin-top: 1em">opening <br>
regex that defines the region start text</p>

<p style="margin-top: 1em">closing <br>
regex that defines the region end text</p>

<p style="margin-top: 1em">recurse <br>
regex that defines the text that matches recursively an end
token into the region</p>

<p style="margin-top: 1em">The recurse option is useful for
regions that can be nested, for example the following
construct:</p>

<p style="margin-top: 1em">%sh{ ... }</p>

<p style="margin-top: 1em">accepts nested braces scopes ({
... }) so the following string is valid:</p>

<p style="margin-top: 1em">%sh{ ... { ... } ... }</p>

<p style="margin-top: 1em">This region can be defined
with:</p>

<p style="margin-top: 1em">shell_expand %sh</p>

<p style="margin-top: 1em">Regions are used in the regions
highlighter which can take any number of regions.</p>

<p style="margin-top: 1em">The following command:</p>

<p style="margin-top: 1em">addhl regions &lt;name&gt;
&lt;region_name1&gt; &lt;opening1&gt; &lt;closing1&gt;
&lt;recurse1&gt; <br>
&lt;region_name2&gt; &lt;opening2&gt; &lt;closing2&gt;
&lt;recurse2&gt;...</p>

<p style="margin-top: 1em">defines multiple regions in
which other highlighters can be added as follows:</p>

<p style="margin-top: 1em">addhl -group
&lt;name&gt;/&lt;region_name&gt; ...</p>

<p style="margin-top: 1em">Regions are matched using the
left-most rule: the left-most region opening starts a new
region. When a region closes, the closest next opening start
another region.</p>

<p style="margin-top: 1em">That matches the rule governing
most programming language parsing.</p>

<p style="margin-top: 1em">Regions also supports a -default
&lt;default_region&gt; switch to define the default region,
when no other region matches the current buffer range.</p>

<p style="margin-top: 1em">Most programming languages can
then be properly highlighted using a regions highlighter as
root:</p>

<p style="margin-top: 1em">addhl regions -default code
&lt;lang&gt; string &lt;str_opening&gt; &lt;str_closing&gt;
&lt;str_recurse&gt; comment &lt;comment_opening&gt;
&lt;comment_closing&gt; &lt;comment_recurse&gt;</p>

<p style="margin-top: 1em">addhl -group &lt;lang&gt;/code
... <br>
addhl -group &lt;lang&gt;/string ... <br>
addhl -group &lt;lang&gt;/comment ...</p>

<p style="margin-top: 1em">SHARED HIGHLIGHTERS <br>
Highlighters are often defined for a specific filetype, and
it makes then sense to share the highlighters between all
the windows on the same filetypes.</p>

<p style="margin-top: 1em">A shared highlighter can be
defined with the following command:</p>

<p style="margin-top: 1em">addhl -group /&lt;group_name&gt;
...</p>

<p style="margin-top: 1em">When the group switch values
starts with a /, it references a group in the shared
highlighters, rather than the window highlighters.</p>

<p style="margin-top: 1em">The common case would be to
create a named shared group, and then fill it with
highlighters:</p>

<p style="margin-top: 1em">addhl -group / group
&lt;name&gt; <br>
addhl -group /name regex ...</p>

<p style="margin-top: 1em">It can then be referenced in a
window using the ref highlighter.</p>

<p style="margin-top: 1em">addhl ref &lt;name&gt;</p>

<p style="margin-top: 1em">The ref can reference any named
highlighter in the shared namespace.</p>
 
<p style="margin-top: 1em">KAK_HIGHLIGHTERS(1)</p>
<hr>
</body>
</html>
