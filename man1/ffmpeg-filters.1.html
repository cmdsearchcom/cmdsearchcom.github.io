<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:09:37 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>FFMPEG-FILTERS(1) FFMPEG-FILTERS(1)</p>

<p style="margin-top: 1em">NAME <br>
ffmpeg-filters - FFmpeg filters</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This document describes filters, sources, and sinks provided
by the libavfilter library.</p>

<p style="margin-top: 1em">FILTERING INTRODUCTION <br>
Filtering in FFmpeg is enabled through the libavfilter
library.</p>

<p style="margin-top: 1em">In libavfilter, a filter can
have multiple inputs and multiple outputs. To illustrate the
sorts of things that are possible, we consider the following
filtergraph.</p>

<p style="margin-top: 1em">[main] <br>
input --&gt; split ---------------------&gt; overlay --&gt;
output <br>
| ^ <br>
|[tmp] [flip]| <br>
+-----&gt; crop --&gt; vflip -------+</p>

<p style="margin-top: 1em">This filtergraph splits the
input stream in two streams, then sends one stream through
the crop filter and the vflip filter, before merging it back
with the other stream by <br>
overlaying it on top. You can use the following command to
achieve this:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -vf &quot;split
[main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip];
[main][flip] overlay=0:H/2&quot; OUTPUT</p>

<p style="margin-top: 1em">The result will be that the top
half of the video is mirrored onto the bottom half of the
output video.</p>

<p style="margin-top: 1em">Filters in the same linear chain
are separated by commas, and distinct linear chains of
filters are separated by semicolons. In our example,
crop,vflip are in one linear chain, <br>
split and overlay are separately in another. The points
where the linear chains join are labelled by names enclosed
in square brackets. In the example, the split filter
generates <br>
two outputs that are associated to the labels [main] and
[tmp].</p>

<p style="margin-top: 1em">The stream sent to the second
output of split, labelled as [tmp], is processed through the
crop filter, which crops away the lower half part of the
video, and then vertically <br>
flipped. The overlay filter takes in input the first
unchanged output of the split filter (which was labelled as
[main]), and overlay on its lower half the output generated
by <br>
the crop,vflip filterchain.</p>

<p style="margin-top: 1em">Some filters take in input a
list of parameters: they are specified after the filter name
and an equal sign, and are separated from each other by a
colon.</p>

<p style="margin-top: 1em">There exist so-called source
filters that do not have an audio/video input, and sink
filters that will not have audio/video output.</p>

<p style="margin-top: 1em">GRAPH <br>
The graph2dot program included in the FFmpeg tools directory
can be used to parse a filtergraph description and issue a
corresponding textual representation in the dot
language.</p>

<p style="margin-top: 1em">Invoke the command:</p>

<p style="margin-top: 1em">graph2dot -h</p>

<p style="margin-top: 1em">to see how to use graph2dot.</p>

<p style="margin-top: 1em">You can then pass the dot
description to the dot program (from the graphviz suite of
programs) and obtain a graphical representation of the
filtergraph.</p>

<p style="margin-top: 1em">For example the sequence of
commands:</p>

<p style="margin-top: 1em">echo &lt;GRAPH_DESCRIPTION&gt; |
tools/graph2dot -o graph.tmp &amp;&amp; dot -Tpng graph.tmp
-o graph.png &amp;&amp; display graph.png</p>

<p style="margin-top: 1em">can be used to create and
display an image representing the graph described by the
GRAPH_DESCRIPTION string. Note that this string must be a
complete self-contained graph, with <br>
its inputs and outputs explicitly defined. For example if
your command line is of the form:</p>

<p style="margin-top: 1em">ffmpeg -i infile -vf
scale=640:360 outfile</p>

<p style="margin-top: 1em">your GRAPH_DESCRIPTION string
will need to be of the form:</p>


<p style="margin-top: 1em">nullsrc,scale=640:360,nullsink</p>

<p style="margin-top: 1em">you may also need to set the
nullsrc parameters and add a format filter in order to
simulate a specific input file.</p>

<p style="margin-top: 1em">FILTERGRAPH DESCRIPTION <br>
A filtergraph is a directed graph of connected filters. It
can contain cycles, and there can be multiple links between
a pair of filters. Each link has one input pad on one side
<br>
connecting it to one filter from which it takes its input,
and one output pad on the other side connecting it to one
filter accepting its output.</p>

<p style="margin-top: 1em">Each filter in a filtergraph is
an instance of a filter class registered in the application,
which defines the features and the number of input and
output pads of the filter.</p>

<p style="margin-top: 1em">A filter with no input pads is
called a &quot;source&quot;, and a filter with no output
pads is called a &quot;sink&quot;.</p>

<p style="margin-top: 1em">Filtergraph syntax <br>
A filtergraph has a textual representation, which is
recognized by the -filter/-vf/-af and -filter_complex
options in ffmpeg and -vf/-af in ffplay, and by the <br>
&quot;avfilter_graph_parse_ptr()&quot; function defined in
libavfilter/avfilter.h.</p>

<p style="margin-top: 1em">A filterchain consists of a
sequence of connected filters, each one connected to the
previous one in the sequence. A filterchain is represented
by a list of &quot;,&quot;-separated filter <br>
descriptions.</p>

<p style="margin-top: 1em">A filtergraph consists of a
sequence of filterchains. A sequence of filterchains is
represented by a list of &quot;;&quot;-separated filterchain
descriptions.</p>

<p style="margin-top: 1em">A filter is represented by a
string of the form:
[in_link_1]...[in_link_N]filter_name=arguments[out_link_1]...[out_link_M]</p>

<p style="margin-top: 1em">filter_name is the name of the
filter class of which the described filter is an instance
of, and has to be the name of one of the filter classes
registered in the program. The <br>
name of the filter class is optionally followed by a string
&quot;=arguments&quot;.</p>

<p style="margin-top: 1em">arguments is a string which
contains the parameters used to initialize the filter
instance. It may have one of two forms:</p>

<p style="margin-top: 1em">&Acirc;&middot; A
&rsquo;:&rsquo;-separated list of key=value pairs.</p>

<p style="margin-top: 1em">&Acirc;&middot; A
&rsquo;:&rsquo;-separated list of value. In this case, the
keys are assumed to be the option names in the order they
are declared. E.g. the &quot;fade&quot; filter declares
three options in this <br>
order -- type, start_frame and nb_frames. Then the parameter
list in:0:30 means that the value in is assigned to the
option type, 0 to start_frame and 30 to nb_frames.</p>

<p style="margin-top: 1em">&Acirc;&middot; A
&rsquo;:&rsquo;-separated list of mixed direct value and
long key=value pairs. The direct value must precede the
key=value pairs, and follow the same constraints order of
the previous <br>
point. The following key=value pairs can be set in any
preferred order.</p>

<p style="margin-top: 1em">If the option value itself is a
list of items (e.g. the &quot;format&quot; filter takes a
list of pixel formats), the items in the list are usually
separated by |.</p>

<p style="margin-top: 1em">The list of arguments can be
quoted using the character &rsquo; as initial and ending
mark, and the character &nbsp;for escaping the characters
within the quoted text; otherwise the <br>
argument string is considered terminated when the next
special character (belonging to the set []=;,) is
encountered.</p>

<p style="margin-top: 1em">The name and arguments of the
filter are optionally preceded and followed by a list of
link labels. A link label allows one to name a link and
associate it to a filter output or <br>
input pad. The preceding labels in_link_1 ... in_link_N, are
associated to the filter input pads, the following labels
out_link_1 ... out_link_M, are associated to the output <br>
pads.</p>

<p style="margin-top: 1em">When two link labels with the
same name are found in the filtergraph, a link between the
corresponding input and output pad is created.</p>

<p style="margin-top: 1em">If an output pad is not
labelled, it is linked by default to the first unlabelled
input pad of the next filter in the filterchain. For example
in the filterchain</p>

<p style="margin-top: 1em">nullsrc, split[L1], [L2]overlay,
nullsink</p>

<p style="margin-top: 1em">the split filter instance has
two output pads, and the overlay filter instance two input
pads. The first output pad of split is labelled
&quot;L1&quot;, the first input pad of overlay is <br>
labelled &quot;L2&quot;, and the second output pad of split
is linked to the second input pad of overlay, which are both
unlabelled.</p>

<p style="margin-top: 1em">In a filter description, if the
input label of the first filter is not specified,
&quot;in&quot; is assumed; if the output label of the last
filter is not specified, &quot;out&quot; is assumed.</p>

<p style="margin-top: 1em">In a complete filterchain all
the unlabelled filter input and output pads must be
connected. A filtergraph is considered valid if all the
filter input and output pads of all the <br>
filterchains are connected.</p>

<p style="margin-top: 1em">Libavfilter will automatically
insert scale filters where format conversion is required. It
is possible to specify swscale flags for those automatically
inserted scalers by <br>
prepending &quot;sws_flags=flags;&quot; to the filtergraph
description.</p>

<p style="margin-top: 1em">Here is a BNF description of the
filtergraph syntax:</p>

<p style="margin-top: 1em">&lt;NAME&gt; ::= sequence of
alphanumeric characters and &rsquo;_&rsquo; <br>
&lt;LINKLABEL&gt; ::= &quot;[&quot; &lt;NAME&gt;
&quot;]&quot; <br>
&lt;LINKLABELS&gt; ::= &lt;LINKLABEL&gt;
[&lt;LINKLABELS&gt;] <br>
&lt;FILTER_ARGUMENTS&gt; ::= sequence of chars (possibly
quoted) <br>
&lt;FILTER&gt; ::= [&lt;LINKLABELS&gt;] &lt;NAME&gt;
[&quot;=&quot; &lt;FILTER_ARGUMENTS&gt;]
[&lt;LINKLABELS&gt;] <br>
&lt;FILTERCHAIN&gt; ::= &lt;FILTER&gt;
[,&lt;FILTERCHAIN&gt;] <br>
&lt;FILTERGRAPH&gt; ::= [sws_flags=&lt;flags&gt;;]
&lt;FILTERCHAIN&gt; [;&lt;FILTERGRAPH&gt;]</p>

<p style="margin-top: 1em">Notes on filtergraph escaping
<br>
Filtergraph description composition entails several levels
of escaping. See the &quot;Quoting and escaping&quot;
section in the ffmpeg-utils(1) manual for more information
about the <br>
employed escaping procedure.</p>

<p style="margin-top: 1em">A first level escaping affects
the content of each filter option value, which may contain
the special character &quot;:&quot; used to separate values,
or one of the escaping characters <br>
&quot;&acute;&quot;.</p>

<p style="margin-top: 1em">A second level escaping affects
the whole filter description, which may contain the escaping
characters &quot;&acute;&quot; or the special characters
&quot;[],;&quot; used by the filtergraph description.</p>

<p style="margin-top: 1em">Finally, when you specify a
filtergraph on a shell commandline, you need to perform a
third level escaping for the shell special characters
contained within it.</p>

<p style="margin-top: 1em">For example, consider the
following string to be embedded in the drawtext filter
description text value:</p>

<p style="margin-top: 1em">this is a &rsquo;string&rsquo;:
may contain one, or more, special characters</p>

<p style="margin-top: 1em">This string contains the
&quot;&rsquo;&quot; special escaping character, and the
&quot;:&quot; special character, so it needs to be escaped
in this way:</p>

<p style="margin-top: 1em">text=this is a
&acute;string&acute; may contain one, or more, special
characters</p>

<p style="margin-top: 1em">A second level of escaping is
required when embedding the filter description in a
filtergraph description, in order to escape all the
filtergraph special characters. Thus the <br>
example above becomes:</p>

<p style="margin-top: 1em">drawtext=text=this is a
\&acute;string\&acute;\: may contain one or more special
characters</p>

<p style="margin-top: 1em">(note that in addition to the
&quot;&acute;&quot; escaping special characters, also
&quot;,&quot; needs to be escaped).</p>

<p style="margin-top: 1em">Finally an additional level of
escaping is needed when writing the filtergraph description
in a shell command, which depends on the escaping rules of
the adopted shell. For <br>
example, assuming that &quot;</p>

<p style="margin-top: 1em">-vf &quot;drawtext=text=this is
a \\\&rsquo;string\\\&rsquo;\\: may contain one\, or more\,
special characters&quot;</p>

<p style="margin-top: 1em">TIMELINE EDITING <br>
Some filters support a generic enable option. For the
filters supporting timeline editing, this option can be set
to an expression which is evaluated before sending a frame
to <br>
the filter. If the evaluation is non-zero, the filter will
be enabled, otherwise the frame will be sent unchanged to
the next filter in the filtergraph.</p>

<p style="margin-top: 1em">The expression accepts the
following values:</p>

<p style="margin-top: 1em">t timestamp expressed in
seconds, NAN if the input timestamp is unknown</p>

<p style="margin-top: 1em">n sequential number of the input
frame, starting from 0</p>

<p style="margin-top: 1em">pos the position in the file of
the input frame, NAN if unknown</p>

<p style="margin-top: 1em">w <br>
h width and height of the input frame if video</p>

<p style="margin-top: 1em">Additionally, these filters
support an enable command that can be used to re-define the
expression.</p>

<p style="margin-top: 1em">Like any other filtering option,
the enable option follows the same rules.</p>

<p style="margin-top: 1em">For example, to enable a blur
filter (smartblur) from 10 seconds to 3 minutes, and a
curves filter starting at 3 seconds:</p>

<p style="margin-top: 1em">smartblur =
enable=&rsquo;between(t,10,3*60)&rsquo;, <br>
curves = enable=&rsquo;gte(t,3)&rsquo; :
preset=cross_process</p>

<p style="margin-top: 1em">AUDIO FILTERS <br>
When you configure your FFmpeg build, you can disable any of
the existing filters using &quot;--disable-filters&quot;.
The configure output will show the audio filters included in
your <br>
build.</p>

<p style="margin-top: 1em">Below is a description of the
currently available audio filters.</p>

<p style="margin-top: 1em">acompressor <br>
A compressor is mainly used to reduce the dynamic range of a
signal. Especially modern music is mostly compressed at a
high ratio to improve the overall loudness. It&rsquo;s done
to <br>
get the highest attention of a listener, &quot;fatten&quot;
the sound and bring more &quot;power&quot; to the track. If
a signal is compressed too much it may sound dull or
&quot;dead&quot; afterwards or it <br>
may start to &quot;pump&quot; (which could be a powerful
effect but can also destroy a track completely). The right
compression is the key to reach a professional sound and is
the high <br>
art of mixing and mastering. Because of its complex settings
it may take a long time to get the right feeling for this
kind of effect.</p>

<p style="margin-top: 1em">Compression is done by detecting
the volume above a chosen level &quot;threshold&quot; and
dividing it by the factor set with &quot;ratio&quot;. So if
you set the threshold to -12dB and your signal <br>
reaches -6dB a ratio of 2:1 will result in a signal at -9dB.
Because an exact manipulation of the signal would cause
distortion of the waveform the reduction can be levelled
over <br>
the time. This is done by setting &quot;Attack&quot; and
&quot;Release&quot;. &quot;attack&quot; determines how long
the signal has to rise above the threshold before any
reduction will occur and &quot;release&quot; <br>
sets the time the signal has to fall below the threshold to
reduce the reduction again. Shorter signals than the chosen
attack time will be left untouched. The overall reduction
<br>
of the signal can be made up afterwards with the
&quot;makeup&quot; setting. So compressing the peaks of a
signal about 6dB and raising the makeup to this level
results in a signal twice <br>
as loud than the source. To gain a softer entry in the
compression the &quot;knee&quot; flattens the hard edge at
the threshold in the range of the chosen decibels.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">level_in <br>
Set input gain. Default is 1. Range is between 0.015625 and
64.</p>

<p style="margin-top: 1em">threshold <br>
If a signal of second stream rises above this level it will
affect the gain reduction of the first stream. By default it
is 0.125. Range is between 0.00097563 and 1.</p>

<p style="margin-top: 1em">ratio <br>
Set a ratio by which the signal is reduced. 1:2 means that
if the level rose 4dB above the threshold, it will be only
2dB above after the reduction. Default is 2. Range is <br>
between 1 and 20.</p>

<p style="margin-top: 1em">attack <br>
Amount of milliseconds the signal has to rise above the
threshold before gain reduction starts. Default is 20. Range
is between 0.01 and 2000.</p>

<p style="margin-top: 1em">release <br>
Amount of milliseconds the signal has to fall below the
threshold before reduction is decreased again. Default is
250. Range is between 0.01 and 9000.</p>

<p style="margin-top: 1em">makeup <br>
Set the amount by how much signal will be amplified after
processing. Default is 2. Range is from 1 and 64.</p>

<p style="margin-top: 1em">knee <br>
Curve the sharp knee around the threshold to enter gain
reduction more softly. Default is 2.82843. Range is between
1 and 8.</p>

<p style="margin-top: 1em">link <br>
Choose if the &quot;average&quot; level between all channels
of input stream or the louder(&quot;maximum&quot;) channel
of input stream affects the reduction. Default is
&quot;average&quot;.</p>

<p style="margin-top: 1em">detection <br>
Should the exact signal be taken in case of &quot;peak&quot;
or an RMS one in case of &quot;rms&quot;. Default is
&quot;rms&quot; which is mostly smoother.</p>

<p style="margin-top: 1em">mix How much to use compressed
signal in output. Default is 1. Range is between 0 and
1.</p>

<p style="margin-top: 1em">acrossfade <br>
Apply cross fade from one input audio stream to another
input audio stream. The cross fade is applied for specified
duration near the end of first stream.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">nb_samples, ns <br>
Specify the number of samples for which the cross fade
effect has to last. At the end of the cross fade effect the
first input audio will be completely silent. Default is <br>
44100.</p>

<p style="margin-top: 1em">duration, d <br>
Specify the duration of the cross fade effect. See the Time
duration section in the ffmpeg-utils(1) manual for the
accepted syntax. By default the duration is determined by
<br>
nb_samples. If set this option is used instead of
nb_samples.</p>

<p style="margin-top: 1em">overlap, o <br>
Should first stream end overlap with second stream start.
Default is enabled.</p>

<p style="margin-top: 1em">curve1 <br>
Set curve for cross fade transition for first stream.</p>

<p style="margin-top: 1em">curve2 <br>
Set curve for cross fade transition for second stream.</p>

<p style="margin-top: 1em">For description of available
curve types see afade filter description.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Cross fade from
one input to another:</p>

<p style="margin-top: 1em">ffmpeg -i first.flac -i
second.flac -filter_complex acrossfade=d=10:c1=exp:c2=exp
output.flac</p>

<p style="margin-top: 1em">&Acirc;&middot; Cross fade from
one input to another but without overlapping:</p>

<p style="margin-top: 1em">ffmpeg -i first.flac -i
second.flac -filter_complex
acrossfade=d=10:o=0:c1=exp:c2=exp output.flac</p>

<p style="margin-top: 1em">acrusher <br>
Reduce audio bit resolution.</p>

<p style="margin-top: 1em">This filter is bit crusher with
enhanced functionality. A bit crusher is used to audibly
reduce number of bits an audio signal is sampled with. This
doesn&rsquo;t change the bit depth <br>
at all, it just produces the effect. Material reduced in bit
depth sounds more harsh and &quot;digital&quot;. This filter
is able to even round to continuous values instead of
discrete <br>
bit depths. Additionally it has a D/C offset which results
in different crushing of the lower and the upper half of the
signal. An Anti-Aliasing setting is able to produce <br>
&quot;softer&quot; crushing sounds.</p>

<p style="margin-top: 1em">Another feature of this filter
is the logarithmic mode. This setting switches from linear
distances between bits to logarithmic ones. The result is a
much more &quot;natural&quot; <br>
sounding crusher which doesn&rsquo;t gate low signals for
example. The human ear has a logarithmic perception, too so
this kind of crushing is much more pleasant. Logarithmic
crushing <br>
is also able to get anti-aliased.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">level_in <br>
Set level in.</p>

<p style="margin-top: 1em">level_out <br>
Set level out.</p>

<p style="margin-top: 1em">bits <br>
Set bit reduction.</p>

<p style="margin-top: 1em">mix Set mixing amount.</p>

<p style="margin-top: 1em">mode <br>
Can be linear: &quot;lin&quot; or logarithmic:
&quot;log&quot;.</p>

<p style="margin-top: 1em">dc Set DC.</p>

<p style="margin-top: 1em">aa Set anti-aliasing.</p>

<p style="margin-top: 1em">samples <br>
Set sample reduction.</p>

<p style="margin-top: 1em">lfo Enable LFO. By default
disabled.</p>

<p style="margin-top: 1em">lforange <br>
Set LFO range.</p>

<p style="margin-top: 1em">lforate <br>
Set LFO rate.</p>

<p style="margin-top: 1em">adelay <br>
Delay one or more audio channels.</p>

<p style="margin-top: 1em">Samples in delayed channel are
filled with silence.</p>

<p style="margin-top: 1em">The filter accepts the following
option:</p>

<p style="margin-top: 1em">delays <br>
Set list of delays in milliseconds for each channel
separated by &rsquo;|&rsquo;. At least one delay greater
than 0 should be provided. Unused delays will be silently
ignored. If <br>
number of given delays is smaller than number of channels
all remaining channels will not be delayed. If you want to
delay exact number of samples, append &rsquo;S&rsquo; to
number.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Delay first
channel by 1.5 seconds, the third channel by 0.5 seconds and
leave the second channel (and any other channels that may be
present) unchanged.</p>

<p style="margin-top: 1em">adelay=1500|0|500</p>

<p style="margin-top: 1em">&Acirc;&middot; Delay second
channel by 500 samples, the third channel by 700 samples and
leave the first channel (and any other channels that may be
present) unchanged.</p>

<p style="margin-top: 1em">adelay=0|500S|700S</p>

<p style="margin-top: 1em">aecho <br>
Apply echoing to the input audio.</p>

<p style="margin-top: 1em">Echoes are reflected sound and
can occur naturally amongst mountains (and sometimes large
buildings) when talking or shouting; digital echo effects
emulate this behaviour and are <br>
often used to help fill out the sound of a single instrument
or vocal. The time difference between the original signal
and the reflection is the &quot;delay&quot;, and the
loudness of the <br>
reflected signal is the &quot;decay&quot;. Multiple echoes
can have different delays and decays.</p>

<p style="margin-top: 1em">A description of the accepted
parameters follows.</p>

<p style="margin-top: 1em">in_gain <br>
Set input gain of reflected signal. Default is 0.6.</p>

<p style="margin-top: 1em">out_gain <br>
Set output gain of reflected signal. Default is 0.3.</p>

<p style="margin-top: 1em">delays <br>
Set list of time intervals in milliseconds between original
signal and reflections separated by &rsquo;|&rsquo;. Allowed
range for each &quot;delay&quot; is &quot;(0 -
90000.0]&quot;. Default is 1000.</p>

<p style="margin-top: 1em">decays <br>
Set list of loudnesses of reflected signals separated by
&rsquo;|&rsquo;. Allowed range for each &quot;decay&quot; is
&quot;(0 - 1.0]&quot;. Default is 0.5.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Make it sound as
if there are twice as many instruments as are actually
playing:</p>

<p style="margin-top: 1em">aecho=0.8:0.88:60:0.4</p>

<p style="margin-top: 1em">&Acirc;&middot; If delay is very
short, then it sound like a (metallic) robot playing
music:</p>

<p style="margin-top: 1em">aecho=0.8:0.88:6:0.4</p>

<p style="margin-top: 1em">&Acirc;&middot; A longer delay
will sound like an open air concert in the mountains:</p>

<p style="margin-top: 1em">aecho=0.8:0.9:1000:0.3</p>

<p style="margin-top: 1em">&Acirc;&middot; Same as above
but with one more mountain:</p>


<p style="margin-top: 1em">aecho=0.8:0.9:1000|1800:0.3|0.25</p>

<p style="margin-top: 1em">aemphasis <br>
Audio emphasis filter creates or restores material directly
taken from LPs or emphased CDs with different filter curves.
E.g. to store music on vinyl the signal has to be altered
<br>
by a filter first to even out the disadvantages of this
recording medium. Once the material is played back the
inverse filter has to be applied to restore the distortion
of the <br>
frequency response.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">level_in <br>
Set input gain.</p>

<p style="margin-top: 1em">level_out <br>
Set output gain.</p>

<p style="margin-top: 1em">mode <br>
Set filter mode. For restoring material use
&quot;reproduction&quot; mode, otherwise use
&quot;production&quot; mode. Default is
&quot;reproduction&quot; mode.</p>

<p style="margin-top: 1em">type <br>
Set filter type. Selects medium. Can be one of the
following:</p>

<p style="margin-top: 1em">col select Columbia.</p>

<p style="margin-top: 1em">emi select EMI.</p>

<p style="margin-top: 1em">bsi select BSI (78RPM).</p>

<p style="margin-top: 1em">riaa <br>
select RIAA.</p>

<p style="margin-top: 1em">cd select Compact Disc (CD).</p>

<p style="margin-top: 1em">50fm <br>
select 50Xs (FM).</p>

<p style="margin-top: 1em">75fm <br>
select 75Xs (FM).</p>

<p style="margin-top: 1em">50kf <br>
select 50Xs (FM-KF).</p>

<p style="margin-top: 1em">75kf <br>
select 75Xs (FM-KF).</p>

<p style="margin-top: 1em">aeval <br>
Modify an audio signal according to the specified
expressions.</p>

<p style="margin-top: 1em">This filter accepts one or more
expressions (one for each channel), which are evaluated and
used to modify a corresponding audio signal.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">exprs <br>
Set the &rsquo;|&rsquo;-separated expressions list for each
separate channel. If the number of input channels is greater
than the number of expressions, the last specified
expression is <br>
used for the remaining output channels.</p>

<p style="margin-top: 1em">channel_layout, c <br>
Set output channel layout. If not specified, the channel
layout is specified by the number of expressions. If set to
same, it will use by default the same input channel <br>
layout.</p>

<p style="margin-top: 1em">Each expression in exprs can
contain the following constants and functions:</p>

<p style="margin-top: 1em">ch channel number of the current
expression</p>

<p style="margin-top: 1em">n number of the evaluated
sample, starting from 0</p>

<p style="margin-top: 1em">s sample rate</p>

<p style="margin-top: 1em">t time of the evaluated sample
expressed in seconds</p>

<p style="margin-top: 1em">nb_in_channels <br>
nb_out_channels <br>
input and output number of channels</p>

<p style="margin-top: 1em">val(CH) <br>
the value of input channel with number CH</p>

<p style="margin-top: 1em">Note: this filter is slow. For
faster processing you should use a dedicated filter.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Half volume:</p>

<p style="margin-top: 1em">aeval=val(ch)/2:c=same</p>

<p style="margin-top: 1em">&Acirc;&middot; Invert phase of
the second channel:</p>

<p style="margin-top: 1em">aeval=val(0)|-val(1)</p>

<p style="margin-top: 1em">afade <br>
Apply fade-in/out effect to input audio.</p>

<p style="margin-top: 1em">A description of the accepted
parameters follows.</p>

<p style="margin-top: 1em">type, t <br>
Specify the effect type, can be either &quot;in&quot; for
fade-in, or &quot;out&quot; for a fade-out effect. Default
is &quot;in&quot;.</p>

<p style="margin-top: 1em">start_sample, ss <br>
Specify the number of the start sample for starting to apply
the fade effect. Default is 0.</p>

<p style="margin-top: 1em">nb_samples, ns <br>
Specify the number of samples for which the fade effect has
to last. At the end of the fade-in effect the output audio
will have the same volume as the input audio, at the <br>
end of the fade-out transition the output audio will be
silence. Default is 44100.</p>

<p style="margin-top: 1em">start_time, st <br>
Specify the start time of the fade effect. Default is 0. The
value must be specified as a time duration; see the Time
duration section in the ffmpeg-utils(1) manual for the <br>
accepted syntax. If set this option is used instead of
start_sample.</p>

<p style="margin-top: 1em">duration, d <br>
Specify the duration of the fade effect. See the Time
duration section in the ffmpeg-utils(1) manual for the
accepted syntax. At the end of the fade-in effect the output
<br>
audio will have the same volume as the input audio, at the
end of the fade-out transition the output audio will be
silence. By default the duration is determined by <br>
nb_samples. If set this option is used instead of
nb_samples.</p>

<p style="margin-top: 1em">curve <br>
Set curve for fade transition.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">tri select triangular, linear
slope (default)</p>

<p style="margin-top: 1em">qsin <br>
select quarter of sine wave</p>

<p style="margin-top: 1em">hsin <br>
select half of sine wave</p>

<p style="margin-top: 1em">esin <br>
select exponential sine wave</p>

<p style="margin-top: 1em">log select logarithmic</p>

<p style="margin-top: 1em">ipar <br>
select inverted parabola</p>

<p style="margin-top: 1em">qua select quadratic</p>

<p style="margin-top: 1em">cub select cubic</p>

<p style="margin-top: 1em">squ select square root</p>

<p style="margin-top: 1em">cbr select cubic root</p>

<p style="margin-top: 1em">par select parabola</p>

<p style="margin-top: 1em">exp select exponential</p>

<p style="margin-top: 1em">iqsin <br>
select inverted quarter of sine wave</p>

<p style="margin-top: 1em">ihsin <br>
select inverted half of sine wave</p>

<p style="margin-top: 1em">dese <br>
select double-exponential seat</p>

<p style="margin-top: 1em">desi <br>
select double-exponential sigmoid</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Fade in first 15
seconds of audio:</p>

<p style="margin-top: 1em">afade=t=in:ss=0:d=15</p>

<p style="margin-top: 1em">&Acirc;&middot; Fade out last 25
seconds of a 900 seconds audio:</p>

<p style="margin-top: 1em">afade=t=out:st=875:d=25</p>

<p style="margin-top: 1em">afftfilt <br>
Apply arbitrary expressions to samples in frequency
domain.</p>

<p style="margin-top: 1em">real <br>
Set frequency domain real expression for each separate
channel separated by &rsquo;|&rsquo;. Default is
&quot;1&quot;. If the number of input channels is greater
than the number of expressions, <br>
the last specified expression is used for the remaining
output channels.</p>

<p style="margin-top: 1em">imag <br>
Set frequency domain imaginary expression for each separate
channel separated by &rsquo;|&rsquo;. If not set, real
option is used.</p>

<p style="margin-top: 1em">Each expression in real and imag
can contain the following constants:</p>

<p style="margin-top: 1em">sr sample rate</p>

<p style="margin-top: 1em">b current frequency bin
number</p>

<p style="margin-top: 1em">nb number of available bins</p>

<p style="margin-top: 1em">ch channel number of the current
expression</p>

<p style="margin-top: 1em">chs number of channels</p>

<p style="margin-top: 1em">pts current frame pts</p>

<p style="margin-top: 1em">win_size <br>
Set window size.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">w16 <br>
w32 <br>
w64 <br>
w128 <br>
w256 <br>
w512 <br>
w1024 <br>
w2048 <br>
w4096 <br>
w8192 <br>
w16384 <br>
w32768 <br>
w65536</p>

<p style="margin-top: 1em">Default is &quot;w4096&quot;</p>

<p style="margin-top: 1em">win_func <br>
Set window function. Default is &quot;hann&quot;.</p>

<p style="margin-top: 1em">overlap <br>
Set window overlap. If set to 1, the recommended overlap for
selected window function will be picked. Default is
0.75.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Leave almost
only low frequencies in audio:</p>


<p style="margin-top: 1em">afftfilt=&quot;1-clip((b/nb)*b,0,1)&quot;</p>

<p style="margin-top: 1em">aformat <br>
Set output format constraints for the input audio. The
framework will negotiate the most appropriate format to
minimize conversions.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">sample_fmts <br>
A &rsquo;|&rsquo;-separated list of requested sample
formats.</p>

<p style="margin-top: 1em">sample_rates <br>
A &rsquo;|&rsquo;-separated list of requested sample
rates.</p>

<p style="margin-top: 1em">channel_layouts <br>
A &rsquo;|&rsquo;-separated list of requested channel
layouts.</p>

<p style="margin-top: 1em">See the Channel Layout section
in the ffmpeg-utils(1) manual for the required syntax.</p>

<p style="margin-top: 1em">If a parameter is omitted, all
values are allowed.</p>

<p style="margin-top: 1em">Force the output to either
unsigned 8-bit or signed 16-bit stereo</p>


<p style="margin-top: 1em">aformat=sample_fmts=u8|s16:channel_layouts=stereo</p>

<p style="margin-top: 1em">agate <br>
A gate is mainly used to reduce lower parts of a signal.
This kind of signal processing reduces disturbing noise
between useful signals.</p>

<p style="margin-top: 1em">Gating is done by detecting the
volume below a chosen level threshold and dividing it by the
factor set with ratio. The bottom of the noise floor is set
via range. Because an <br>
exact manipulation of the signal would cause distortion of
the waveform the reduction can be levelled over time. This
is done by setting attack and release.</p>

<p style="margin-top: 1em">attack determines how long the
signal has to fall below the threshold before any reduction
will occur and release sets the time the signal has to rise
above the threshold to <br>
reduce the reduction again. Shorter signals than the chosen
attack time will be left untouched.</p>

<p style="margin-top: 1em">level_in <br>
Set input level before filtering. Default is 1. Allowed
range is from 0.015625 to 64.</p>

<p style="margin-top: 1em">range <br>
Set the level of gain reduction when the signal is below the
threshold. Default is 0.06125. Allowed range is from 0 to
1.</p>

<p style="margin-top: 1em">threshold <br>
If a signal rises above this level the gain reduction is
released. Default is 0.125. Allowed range is from 0 to
1.</p>

<p style="margin-top: 1em">ratio <br>
Set a ratio by which the signal is reduced. Default is 2.
Allowed range is from 1 to 9000.</p>

<p style="margin-top: 1em">attack <br>
Amount of milliseconds the signal has to rise above the
threshold before gain reduction stops. Default is 20
milliseconds. Allowed range is from 0.01 to 9000.</p>

<p style="margin-top: 1em">release <br>
Amount of milliseconds the signal has to fall below the
threshold before the reduction is increased again. Default
is 250 milliseconds. Allowed range is from 0.01 to 9000.</p>

<p style="margin-top: 1em">makeup <br>
Set amount of amplification of signal after processing.
Default is 1. Allowed range is from 1 to 64.</p>

<p style="margin-top: 1em">knee <br>
Curve the sharp knee around the threshold to enter gain
reduction more softly. Default is 2.828427125. Allowed range
is from 1 to 8.</p>

<p style="margin-top: 1em">detection <br>
Choose if exact signal should be taken for detection or an
RMS like one. Default is &quot;rms&quot;. Can be
&quot;peak&quot; or &quot;rms&quot;.</p>

<p style="margin-top: 1em">link <br>
Choose if the average level between all channels or the
louder channel affects the reduction. Default is
&quot;average&quot;. Can be &quot;average&quot; or
&quot;maximum&quot;.</p>

<p style="margin-top: 1em">alimiter <br>
The limiter prevents an input signal from rising over a
desired threshold. This limiter uses lookahead technology to
prevent your signal from distorting. It means that there is
<br>
a small delay after the signal is processed. Keep in mind
that the delay it produces is the attack time you set.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">level_in <br>
Set input gain. Default is 1.</p>

<p style="margin-top: 1em">level_out <br>
Set output gain. Default is 1.</p>

<p style="margin-top: 1em">limit <br>
Don&rsquo;t let signals above this level pass the limiter.
Default is 1.</p>

<p style="margin-top: 1em">attack <br>
The limiter will reach its attenuation level in this amount
of time in milliseconds. Default is 5 milliseconds.</p>

<p style="margin-top: 1em">release <br>
Come back from limiting to attenuation 1.0 in this amount of
milliseconds. Default is 50 milliseconds.</p>

<p style="margin-top: 1em">asc When gain reduction is
always needed ASC takes care of releasing to an average
reduction level rather than reaching a reduction of 0 in the
release time.</p>

<p style="margin-top: 1em">asc_level <br>
Select how much the release time is affected by ASC, 0 means
nearly no changes in release time while 1 produces higher
release times.</p>

<p style="margin-top: 1em">level <br>
Auto level output signal. Default is enabled. This
normalizes audio back to 0dB if enabled.</p>

<p style="margin-top: 1em">Depending on picked setting it
is recommended to upsample input 2x or 4x times with
aresample before applying this filter.</p>

<p style="margin-top: 1em">allpass <br>
Apply a two-pole all-pass filter with central frequency (in
Hz) frequency, and filter-width width. An all-pass filter
changes the audio&rsquo;s frequency to phase relationship
without <br>
changing its frequency to amplitude relationship.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">frequency, f <br>
Set frequency in Hz.</p>

<p style="margin-top: 1em">width_type <br>
Set method to specify band-width of filter.</p>

<p style="margin-top: 1em">h Hz</p>

<p style="margin-top: 1em">q Q-Factor</p>

<p style="margin-top: 1em">o octave</p>

<p style="margin-top: 1em">s slope</p>

<p style="margin-top: 1em">width, w <br>
Specify the band-width of a filter in width_type units.</p>

<p style="margin-top: 1em">aloop <br>
Loop audio samples.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">loop <br>
Set the number of loops.</p>

<p style="margin-top: 1em">size <br>
Set maximal number of samples.</p>

<p style="margin-top: 1em">start <br>
Set first sample of loop.</p>

<p style="margin-top: 1em">amerge <br>
Merge two or more audio streams into a single multi-channel
stream.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">inputs <br>
Set the number of inputs. Default is 2.</p>

<p style="margin-top: 1em">If the channel layouts of the
inputs are disjoint, and therefore compatible, the channel
layout of the output will be set accordingly and the
channels will be reordered as <br>
necessary. If the channel layouts of the inputs are not
disjoint, the output will have all the channels of the first
input then all the channels of the second input, in that
<br>
order, and the channel layout of the output will be the
default value corresponding to the total number of
channels.</p>

<p style="margin-top: 1em">For example, if the first input
is in 2.1 (FL+FR+LF) and the second input is FC+BL+BR, then
the output will be in 5.1, with the channels in the
following order: a1, a2, b1, a3, <br>
b2, b3 (a1 is the first channel of the first input, b1 is
the first channel of the second input).</p>

<p style="margin-top: 1em">On the other hand, if both input
are in stereo, the output channels will be in the default
order: a1, a2, b1, b2, and the channel layout will be
arbitrarily set to 4.0, which may <br>
or may not be the expected value.</p>

<p style="margin-top: 1em">All inputs must have the same
sample rate, and format.</p>

<p style="margin-top: 1em">If inputs do not have the same
duration, the output will stop with the shortest.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Merge two mono
files into a stereo stream:</p>

<p style="margin-top: 1em">amovie=left.wav [l] ;
amovie=right.mp3 [r] ; [l] [r] amerge</p>

<p style="margin-top: 1em">&Acirc;&middot; Multiple merges
assuming 1 video stream and 6 audio streams in
input.mkv:</p>

<p style="margin-top: 1em">ffmpeg -i input.mkv
-filter_complex &quot;[0:1][0:2][0:3][0:4][0:5][0:6]
amerge=inputs=6&quot; -c:a pcm_s16le output.mkv</p>

<p style="margin-top: 1em">amix <br>
Mixes multiple audio inputs into a single output.</p>

<p style="margin-top: 1em">Note that this filter only
supports float samples (the amerge and pan audio filters
support many formats). If the amix input has integer samples
then aresample will be <br>
automatically inserted to perform the conversion to float
samples.</p>

<p style="margin-top: 1em">For example</p>

<p style="margin-top: 1em">ffmpeg -i INPUT1 -i INPUT2 -i
INPUT3 -filter_complex
amix=inputs=3:duration=first:dropout_transition=3 OUTPUT</p>

<p style="margin-top: 1em">will mix 3 input audio streams
to a single output with the same duration as the first input
and a dropout transition time of 3 seconds.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">inputs <br>
The number of inputs. If unspecified, it defaults to 2.</p>

<p style="margin-top: 1em">duration <br>
How to determine the end-of-stream.</p>

<p style="margin-top: 1em">longest <br>
The duration of the longest input. (default)</p>

<p style="margin-top: 1em">shortest <br>
The duration of the shortest input.</p>

<p style="margin-top: 1em">first <br>
The duration of the first input.</p>

<p style="margin-top: 1em">dropout_transition <br>
The transition time, in seconds, for volume renormalization
when an input stream ends. The default value is 2
seconds.</p>

<p style="margin-top: 1em">anequalizer <br>
High-order parametric multiband equalizer for each
channel.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">params <br>
This option string is in format: &quot;cchn f=cf w=w g=g t=f
| ...&quot; Each equalizer band is separated by
&rsquo;|&rsquo;.</p>

<p style="margin-top: 1em">chn Set channel number to which
equalization will be applied. If input doesn&rsquo;t have
that channel the entry is ignored.</p>

<p style="margin-top: 1em">f Set central frequency for
band. If input doesn&rsquo;t have that frequency the entry
is ignored.</p>

<p style="margin-top: 1em">w Set band width in hertz.</p>

<p style="margin-top: 1em">g Set band gain in dB.</p>

<p style="margin-top: 1em">t Set filter type for band,
optional, can be:</p>

<p style="margin-top: 1em">0 Butterworth, this is
default.</p>

<p style="margin-top: 1em">1 Chebyshev type 1.</p>

<p style="margin-top: 1em">2 Chebyshev type 2.</p>

<p style="margin-top: 1em">curves <br>
With this option activated frequency response of anequalizer
is displayed in video stream.</p>

<p style="margin-top: 1em">size <br>
Set video stream size. Only useful if curves option is
activated.</p>

<p style="margin-top: 1em">mgain <br>
Set max gain that will be displayed. Only useful if curves
option is activated. Setting this to a reasonable value
makes it possible to display gain which is derived from <br>
neighbour bands which are too close to each other and thus
produce higher gain when both are activated.</p>

<p style="margin-top: 1em">fscale <br>
Set frequency scale used to draw frequency response in video
output. Can be linear or logarithmic. Default is
logarithmic.</p>

<p style="margin-top: 1em">colors <br>
Set color for each channel curve which is going to be
displayed in video stream. This is list of color names
separated by space or by &rsquo;|&rsquo;. Unrecognised or
missing colors <br>
will be replaced by white color.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Lower gain by 10
of central frequency 200Hz and width 100 Hz for first 2
channels using Chebyshev type 1 filter:</p>

<p style="margin-top: 1em">anequalizer=c0 f=200 w=100 g=-10
t=1|c1 f=200 w=100 g=-10 t=1</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">This filter supports the
following commands:</p>

<p style="margin-top: 1em">change <br>
Alter existing filter parameters. Syntax for the commands is
: &quot;fN|f=freq|w=width|g=gain&quot;</p>

<p style="margin-top: 1em">fN is existing filter number,
starting from 0, if no such filter is available error is
returned. freq set new frequency parameter. width set new
width parameter in herz. <br>
gain set new gain parameter in dB.</p>

<p style="margin-top: 1em">Full filter invocation with
asendcmd may look like this: asendcmd=c=&rsquo;4.0
anequalizer change
0|f=200|w=50|g=1&rsquo;,anequalizer=...</p>

<p style="margin-top: 1em">anull <br>
Pass the audio source unchanged to the output.</p>

<p style="margin-top: 1em">apad <br>
Pad the end of an audio stream with silence.</p>

<p style="margin-top: 1em">This can be used together with
ffmpeg -shortest to extend audio streams to the same length
as the video stream.</p>

<p style="margin-top: 1em">A description of the accepted
options follows.</p>

<p style="margin-top: 1em">packet_size <br>
Set silence packet size. Default value is 4096.</p>

<p style="margin-top: 1em">pad_len <br>
Set the number of samples of silence to add to the end.
After the value is reached, the stream is terminated. This
option is mutually exclusive with whole_len.</p>

<p style="margin-top: 1em">whole_len <br>
Set the minimum total number of samples in the output audio
stream. If the value is longer than the input audio length,
silence is added to the end, until the value is <br>
reached. This option is mutually exclusive with pad_len.</p>

<p style="margin-top: 1em">If neither the pad_len nor the
whole_len option is set, the filter will add silence to the
end of the input stream indefinitely.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Add 1024 samples
of silence to the end of the input:</p>

<p style="margin-top: 1em">apad=pad_len=1024</p>

<p style="margin-top: 1em">&Acirc;&middot; Make sure the
audio output will contain at least 10000 samples, pad the
input with silence if required:</p>

<p style="margin-top: 1em">apad=whole_len=10000</p>

<p style="margin-top: 1em">&Acirc;&middot; Use ffmpeg to
pad the audio input with silence, so that the video stream
will always result the shortest and will be converted until
the end in the output file when using the <br>
shortest option:</p>

<p style="margin-top: 1em">ffmpeg -i VIDEO -i AUDIO
-filter_complex &quot;[1:0]apad&quot; -shortest OUTPUT</p>

<p style="margin-top: 1em">aphaser <br>
Add a phasing effect to the input audio.</p>

<p style="margin-top: 1em">A phaser filter creates series
of peaks and troughs in the frequency spectrum. The position
of the peaks and troughs are modulated so that they vary
over time, creating a <br>
sweeping effect.</p>

<p style="margin-top: 1em">A description of the accepted
parameters follows.</p>

<p style="margin-top: 1em">in_gain <br>
Set input gain. Default is 0.4.</p>

<p style="margin-top: 1em">out_gain <br>
Set output gain. Default is 0.74</p>

<p style="margin-top: 1em">delay <br>
Set delay in milliseconds. Default is 3.0.</p>

<p style="margin-top: 1em">decay <br>
Set decay. Default is 0.4.</p>

<p style="margin-top: 1em">speed <br>
Set modulation speed in Hz. Default is 0.5.</p>

<p style="margin-top: 1em">type <br>
Set modulation type. Default is triangular.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">triangular, t <br>
sinusoidal, s</p>

<p style="margin-top: 1em">apulsator <br>
Audio pulsator is something between an autopanner and a
tremolo. But it can produce funny stereo effects as well.
Pulsator changes the volume of the left and right channel
based <br>
on a LFO (low frequency oscillator) with different waveforms
and shifted phases. This filter have the ability to define
an offset between left and right channel. An offset of 0
<br>
means that both LFO shapes match each other. The left and
right channel are altered equally - a conventional tremolo.
An offset of 50% means that the shape of the right channel
<br>
is exactly shifted in phase (or moved backwards about half
of the frequency) - pulsator acts as an autopanner. At 1
both curves match again. Every setting in between moves the
<br>
phase shift gapless between all stages and produces some
&quot;bypassing&quot; sounds with sine and triangle
waveforms. The more you set the offset near 1 (starting from
the 0.5) the <br>
faster the signal passes from the left to the right
speaker.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">level_in <br>
Set input gain. By default it is 1. Range is [0.015625 -
64].</p>

<p style="margin-top: 1em">level_out <br>
Set output gain. By default it is 1. Range is [0.015625 -
64].</p>

<p style="margin-top: 1em">mode <br>
Set waveform shape the LFO will use. Can be one of: sine,
triangle, square, sawup or sawdown. Default is sine.</p>

<p style="margin-top: 1em">amount <br>
Set modulation. Define how much of original signal is
affected by the LFO.</p>

<p style="margin-top: 1em">offset_l <br>
Set left channel offset. Default is 0. Allowed range is [0 -
1].</p>

<p style="margin-top: 1em">offset_r <br>
Set right channel offset. Default is 0.5. Allowed range is
[0 - 1].</p>

<p style="margin-top: 1em">width <br>
Set pulse width. Default is 1. Allowed range is [0 - 2].</p>

<p style="margin-top: 1em">timing <br>
Set possible timing mode. Can be one of: bpm, ms or hz.
Default is hz.</p>

<p style="margin-top: 1em">bpm Set bpm. Default is 120.
Allowed range is [30 - 300]. Only used if timing is set to
bpm.</p>

<p style="margin-top: 1em">ms Set ms. Default is 500.
Allowed range is [10 - 2000]. Only used if timing is set to
ms.</p>

<p style="margin-top: 1em">hz Set frequency in Hz. Default
is 2. Allowed range is [0.01 - 100]. Only used if timing is
set to hz.</p>

<p style="margin-top: 1em">aresample <br>
Resample the input audio to the specified parameters, using
the libswresample library. If none are specified then the
filter will automatically convert between its input and <br>
output.</p>

<p style="margin-top: 1em">This filter is also able to
stretch/squeeze the audio data to make it match the
timestamps or to inject silence / cut out audio to make it
match the timestamps, do a combination <br>
of both or do neither.</p>

<p style="margin-top: 1em">The filter accepts the syntax
[sample_rate:]resampler_options, where sample_rate expresses
a sample rate and resampler_options is a list of key=value
pairs, separated by &quot;:&quot;. See <br>
the ffmpeg-resampler manual for the complete list of
supported options.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Resample the
input audio to 44100Hz:</p>

<p style="margin-top: 1em">aresample=44100</p>

<p style="margin-top: 1em">&Acirc;&middot; Stretch/squeeze
samples to the given timestamps, with a maximum of 1000
samples per second compensation:</p>

<p style="margin-top: 1em">aresample=async=1000</p>

<p style="margin-top: 1em">areverse <br>
Reverse an audio clip.</p>

<p style="margin-top: 1em">Warning: This filter requires
memory to buffer the entire clip, so trimming is
suggested.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Take the first 5
seconds of a clip, and reverse it.</p>

<p style="margin-top: 1em">atrim=end=5,areverse</p>

<p style="margin-top: 1em">asetnsamples <br>
Set the number of samples per each output audio frame.</p>

<p style="margin-top: 1em">The last output packet may
contain a different number of samples, as the filter will
flush all the remaining samples when the input audio signals
its end.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">nb_out_samples, n <br>
Set the number of frames per each output audio frame. The
number is intended as the number of samples per each
channel. Default value is 1024.</p>

<p style="margin-top: 1em">pad, p <br>
If set to 1, the filter will pad the last audio frame with
zeroes, so that the last frame will contain the same number
of samples as the previous ones. Default value is 1.</p>

<p style="margin-top: 1em">For example, to set the number
of per-frame samples to 1234 and disable padding for the
last frame, use:</p>

<p style="margin-top: 1em">asetnsamples=n=1234:p=0</p>

<p style="margin-top: 1em">asetrate <br>
Set the sample rate without altering the PCM data. This will
result in a change of speed and pitch.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">sample_rate, r <br>
Set the output sample rate. Default is 44100 Hz.</p>

<p style="margin-top: 1em">ashowinfo <br>
Show a line containing various information for each input
audio frame. The input audio is not modified.</p>

<p style="margin-top: 1em">The shown line contains a
sequence of key/value pairs of the form key:value.</p>

<p style="margin-top: 1em">The following values are shown
in the output:</p>

<p style="margin-top: 1em">n The (sequential) number of the
input frame, starting from 0.</p>

<p style="margin-top: 1em">pts The presentation timestamp
of the input frame, in time base units; the time base
depends on the filter input pad, and is usually
1/sample_rate.</p>

<p style="margin-top: 1em">pts_time <br>
The presentation timestamp of the input frame in
seconds.</p>

<p style="margin-top: 1em">pos position of the frame in the
input stream, -1 if this information in unavailable and/or
meaningless (for example in case of synthetic audio)</p>

<p style="margin-top: 1em">fmt The sample format.</p>

<p style="margin-top: 1em">chlayout <br>
The channel layout.</p>

<p style="margin-top: 1em">rate <br>
The sample rate for the audio frame.</p>

<p style="margin-top: 1em">nb_samples <br>
The number of samples (per channel) in the frame.</p>

<p style="margin-top: 1em">checksum <br>
The Adler-32 checksum (printed in hexadecimal) of the audio
data. For planar audio, the data is treated as if all the
planes were concatenated.</p>

<p style="margin-top: 1em">plane_checksums <br>
A list of Adler-32 checksums for each data plane.</p>

<p style="margin-top: 1em">astats <br>
Display time domain statistical information about the audio
channels. Statistics are calculated and displayed for each
audio channel and, where applicable, an overall figure is
<br>
also given.</p>

<p style="margin-top: 1em">It accepts the following
option:</p>

<p style="margin-top: 1em">length <br>
Short window length in seconds, used for peak and trough RMS
measurement. Default is 0.05 (50 milliseconds). Allowed
range is &quot;[0.1 - 10]&quot;.</p>

<p style="margin-top: 1em">metadata <br>
Set metadata injection. All the metadata keys are prefixed
with &quot;lavfi.astats.X&quot;, where &quot;X&quot; is
channel number starting from 1 or string
&quot;Overall&quot;. Default is disabled.</p>

<p style="margin-top: 1em">Available keys for each channel
are: DC_offset Min_level Max_level Min_difference
Max_difference Mean_difference Peak_level RMS_peak
RMS_trough Crest_factor Flat_factor <br>
Peak_count Bit_depth</p>

<p style="margin-top: 1em">and for Overall: DC_offset
Min_level Max_level Min_difference Max_difference
Mean_difference Peak_level RMS_level RMS_peak RMS_trough
Flat_factor Peak_count Bit_depth <br>
Number_of_samples</p>

<p style="margin-top: 1em">For example full key look like
this &quot;lavfi.astats.1.DC_offset&quot; or this
&quot;lavfi.astats.Overall.Peak_count&quot;.</p>

<p style="margin-top: 1em">For description what each key
means read below.</p>

<p style="margin-top: 1em">reset <br>
Set number of frame after which stats are going to be
recalculated. Default is disabled.</p>

<p style="margin-top: 1em">A description of each shown
parameter follows:</p>

<p style="margin-top: 1em">DC offset <br>
Mean amplitude displacement from zero.</p>

<p style="margin-top: 1em">Min level <br>
Minimal sample level.</p>

<p style="margin-top: 1em">Max level <br>
Maximal sample level.</p>

<p style="margin-top: 1em">Min difference <br>
Minimal difference between two consecutive samples.</p>

<p style="margin-top: 1em">Max difference <br>
Maximal difference between two consecutive samples.</p>

<p style="margin-top: 1em">Mean difference <br>
Mean difference between two consecutive samples. The average
of each difference between two consecutive samples.</p>

<p style="margin-top: 1em">Peak level dB <br>
RMS level dB <br>
Standard peak and RMS level measured in dBFS.</p>

<p style="margin-top: 1em">RMS peak dB <br>
RMS trough dB <br>
Peak and trough values for RMS level measured over a short
window.</p>

<p style="margin-top: 1em">Crest factor <br>
Standard ratio of peak to RMS level (note: not in dB).</p>

<p style="margin-top: 1em">Flat factor <br>
Flatness (i.e. consecutive samples with the same value) of
the signal at its peak levels (i.e. either Min level or Max
level).</p>

<p style="margin-top: 1em">Peak count <br>
Number of occasions (not the number of samples) that the
signal attained either Min level or Max level.</p>

<p style="margin-top: 1em">Bit depth <br>
Overall bit depth of audio. Number of bits used for each
sample.</p>

<p style="margin-top: 1em">asyncts <br>
Synchronize audio data with timestamps by
squeezing/stretching it and/or dropping samples/adding
silence when needed.</p>

<p style="margin-top: 1em">This filter is not built by
default, please use aresample to do
squeezing/stretching.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">compensate <br>
Enable stretching/squeezing the data to make it match the
timestamps. Disabled by default. When disabled, time gaps
are covered with silence.</p>

<p style="margin-top: 1em">min_delta <br>
The minimum difference between timestamps and audio data (in
seconds) to trigger adding/dropping samples. The default
value is 0.1. If you get an imperfect sync with this <br>
filter, try setting this parameter to 0.</p>

<p style="margin-top: 1em">max_comp <br>
The maximum compensation in samples per second. Only
relevant with compensate=1. The default value is 500.</p>

<p style="margin-top: 1em">first_pts <br>
Assume that the first PTS should be this value. The time
base is 1 / sample rate. This allows for padding/trimming at
the start of the stream. By default, no assumption is <br>
made about the first frame&rsquo;s expected PTS, so no
padding or trimming is done. For example, this could be set
to 0 to pad the beginning with silence if an audio stream
starts <br>
after the video stream or to trim any samples with a
negative PTS due to encoder delay.</p>

<p style="margin-top: 1em">atempo <br>
Adjust audio tempo.</p>

<p style="margin-top: 1em">The filter accepts exactly one
parameter, the audio tempo. If not specified then the filter
will assume nominal 1.0 tempo. Tempo must be in the [0.5,
2.0] range.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Slow down audio
to 80% tempo:</p>

<p style="margin-top: 1em">atempo=0.8</p>

<p style="margin-top: 1em">&Acirc;&middot; To speed up
audio to 125% tempo:</p>

<p style="margin-top: 1em">atempo=1.25</p>

<p style="margin-top: 1em">atrim <br>
Trim the input so that the output contains one continuous
subpart of the input.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">start <br>
Timestamp (in seconds) of the start of the section to keep.
I.e. the audio sample with the timestamp start will be the
first sample in the output.</p>

<p style="margin-top: 1em">end Specify time of the first
audio sample that will be dropped, i.e. the audio sample
immediately preceding the one with the timestamp end will be
the last sample in the output.</p>

<p style="margin-top: 1em">start_pts <br>
Same as start, except this option sets the start timestamp
in samples instead of seconds.</p>

<p style="margin-top: 1em">end_pts <br>
Same as end, except this option sets the end timestamp in
samples instead of seconds.</p>

<p style="margin-top: 1em">duration <br>
The maximum duration of the output in seconds.</p>

<p style="margin-top: 1em">start_sample <br>
The number of the first sample that should be output.</p>

<p style="margin-top: 1em">end_sample <br>
The number of the first sample that should be dropped.</p>

<p style="margin-top: 1em">start, end, and duration are
expressed as time duration specifications; see the Time
duration section in the ffmpeg-utils(1) manual.</p>

<p style="margin-top: 1em">Note that the first two sets of
the start/end options and the duration option look at the
frame timestamp, while the _sample options simply count the
samples that pass through <br>
the filter. So start/end_pts and start/end_sample will give
different results when the timestamps are wrong, inexact or
do not start at zero. Also note that this filter does not
<br>
modify the timestamps. If you wish to have the output
timestamps start at zero, insert the asetpts filter after
the atrim filter.</p>

<p style="margin-top: 1em">If multiple start or end options
are set, this filter tries to be greedy and keep all samples
that match at least one of the specified constraints. To
keep only the part that <br>
matches all the constraints at once, chain multiple atrim
filters.</p>

<p style="margin-top: 1em">The defaults are such that all
the input is kept. So it is possible to set e.g. just the
end values to keep everything before the specified time.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">&Acirc;&middot; Drop everything
except the second minute of input:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -af
atrim=60:120</p>

<p style="margin-top: 1em">&Acirc;&middot; Keep only the
first 1000 samples:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -af
atrim=end_sample=1000</p>

<p style="margin-top: 1em">bandpass <br>
Apply a two-pole Butterworth band-pass filter with central
frequency frequency, and (3dB-point) band-width width. The
csg option selects a constant skirt gain (peak gain = Q)
<br>
instead of the default: constant 0dB peak gain. The filter
roll off at 6dB per octave (20dB per decade).</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">frequency, f <br>
Set the filter&rsquo;s central frequency. Default is
3000.</p>

<p style="margin-top: 1em">csg Constant skirt gain if set
to 1. Defaults to 0.</p>

<p style="margin-top: 1em">width_type <br>
Set method to specify band-width of filter.</p>

<p style="margin-top: 1em">h Hz</p>

<p style="margin-top: 1em">q Q-Factor</p>

<p style="margin-top: 1em">o octave</p>

<p style="margin-top: 1em">s slope</p>

<p style="margin-top: 1em">width, w <br>
Specify the band-width of a filter in width_type units.</p>

<p style="margin-top: 1em">bandreject <br>
Apply a two-pole Butterworth band-reject filter with central
frequency frequency, and (3dB-point) band-width width. The
filter roll off at 6dB per octave (20dB per decade).</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">frequency, f <br>
Set the filter&rsquo;s central frequency. Default is
3000.</p>

<p style="margin-top: 1em">width_type <br>
Set method to specify band-width of filter.</p>

<p style="margin-top: 1em">h Hz</p>

<p style="margin-top: 1em">q Q-Factor</p>

<p style="margin-top: 1em">o octave</p>

<p style="margin-top: 1em">s slope</p>

<p style="margin-top: 1em">width, w <br>
Specify the band-width of a filter in width_type units.</p>

<p style="margin-top: 1em">bass <br>
Boost or cut the bass (lower) frequencies of the audio using
a two-pole shelving filter with a response similar to that
of a standard hi-fi&rsquo;s tone-controls. This is also
known as <br>
shelving equalisation (EQ).</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">gain, g <br>
Give the gain at 0 Hz. Its useful range is about -20 (for a
large cut) to +20 (for a large boost). Beware of clipping
when using a positive gain.</p>

<p style="margin-top: 1em">frequency, f <br>
Set the filter&rsquo;s central frequency and so can be used
to extend or reduce the frequency range to be boosted or
cut. The default value is 100 Hz.</p>

<p style="margin-top: 1em">width_type <br>
Set method to specify band-width of filter.</p>

<p style="margin-top: 1em">h Hz</p>

<p style="margin-top: 1em">q Q-Factor</p>

<p style="margin-top: 1em">o octave</p>

<p style="margin-top: 1em">s slope</p>

<p style="margin-top: 1em">width, w <br>
Determine how steep is the filter&rsquo;s shelf
transition.</p>

<p style="margin-top: 1em">biquad <br>
Apply a biquad IIR filter with the given coefficients. Where
b0, b1, b2 and a0, a1, a2 are the numerator and denominator
coefficients respectively.</p>

<p style="margin-top: 1em">bs2b <br>
Bauer stereo to binaural transformation, which improves
headphone listening of stereo audio records.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">profile <br>
Pre-defined crossfeed level.</p>

<p style="margin-top: 1em">default <br>
Default level (fcut=700, feed=50).</p>

<p style="margin-top: 1em">cmoy <br>
Chu Moy circuit (fcut=700, feed=60).</p>

<p style="margin-top: 1em">jmeier <br>
Jan Meier circuit (fcut=650, feed=95).</p>

<p style="margin-top: 1em">fcut <br>
Cut frequency (in Hz).</p>

<p style="margin-top: 1em">feed <br>
Feed level (in Hz).</p>

<p style="margin-top: 1em">channelmap <br>
Remap input channels to new locations.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">channel_layout <br>
The channel layout of the output stream.</p>

<p style="margin-top: 1em">map Map channels from input to
output. The argument is a &rsquo;|&rsquo;-separated list of
mappings, each in the &quot;in_channel-out_channel&quot; or
in_channel form. in_channel can be either the <br>
name of the input channel (e.g. FL for front left) or its
index in the input channel layout. out_channel is the name
of the output channel or its index in the output channel
<br>
layout. If out_channel is not given then it is implicitly an
index, starting with zero and increasing by one for each
mapping.</p>

<p style="margin-top: 1em">If no mapping is present, the
filter will implicitly map input channels to output
channels, preserving indices.</p>

<p style="margin-top: 1em">For example, assuming a
5.1+downmix input MOV file,</p>

<p style="margin-top: 1em">ffmpeg -i in.mov -filter
&rsquo;channelmap=map=DL-FL|DR-FR&rsquo; out.wav</p>

<p style="margin-top: 1em">will create an output WAV file
tagged as stereo from the downmix channels of the input.</p>

<p style="margin-top: 1em">To fix a 5.1 WAV improperly
encoded in AAC&rsquo;s native channel order</p>

<p style="margin-top: 1em">ffmpeg -i in.wav -filter
&rsquo;channelmap=1|2|0|5|3|4:5.1&rsquo; out.wav</p>

<p style="margin-top: 1em">channelsplit <br>
Split each channel from an input audio stream into a
separate output stream.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">channel_layout <br>
The channel layout of the input stream. The default is
&quot;stereo&quot;.</p>

<p style="margin-top: 1em">For example, assuming a stereo
input MP3 file,</p>

<p style="margin-top: 1em">ffmpeg -i in.mp3 -filter_complex
channelsplit out.mkv</p>

<p style="margin-top: 1em">will create an output Matroska
file with two audio streams, one containing only the left
channel and the other the right channel.</p>

<p style="margin-top: 1em">Split a 5.1 WAV file into
per-channel files:</p>

<p style="margin-top: 1em">ffmpeg -i in.wav -filter_complex
<br>

&rsquo;channelsplit=channel_layout=5.1[FL][FR][FC][LFE][SL][SR]&rsquo;
<br>
-map &rsquo;[FL]&rsquo; front_left.wav -map
&rsquo;[FR]&rsquo; front_right.wav -map &rsquo;[FC]&rsquo;
<br>
front_center.wav -map &rsquo;[LFE]&rsquo; lfe.wav -map
&rsquo;[SL]&rsquo; side_left.wav -map &rsquo;[SR]&rsquo;
<br>
side_right.wav</p>

<p style="margin-top: 1em">chorus <br>
Add a chorus effect to the audio.</p>

<p style="margin-top: 1em">Can make a single vocal sound
like a chorus, but can also be applied to
instrumentation.</p>

<p style="margin-top: 1em">Chorus resembles an echo effect
with a short delay, but whereas with echo the delay is
constant, with chorus, it is varied using using sinusoidal
or triangular modulation. The <br>
modulation depth defines the range the modulated delay is
played before or after the delay. Hence the delayed sound
will sound slower or faster, that is the delayed sound tuned
<br>
around the original one, like in a chorus where some vocals
are slightly off key.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">in_gain <br>
Set input gain. Default is 0.4.</p>

<p style="margin-top: 1em">out_gain <br>
Set output gain. Default is 0.4.</p>

<p style="margin-top: 1em">delays <br>
Set delays. A typical delay is around 40ms to 60ms.</p>

<p style="margin-top: 1em">decays <br>
Set decays.</p>

<p style="margin-top: 1em">speeds <br>
Set speeds.</p>

<p style="margin-top: 1em">depths <br>
Set depths.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; A single
delay:</p>


<p style="margin-top: 1em">chorus=0.7:0.9:55:0.4:0.25:2</p>

<p style="margin-top: 1em">&Acirc;&middot; Two delays:</p>


<p style="margin-top: 1em">chorus=0.6:0.9:50|60:0.4|0.32:0.25|0.4:2|1.3</p>

<p style="margin-top: 1em">&Acirc;&middot; Fuller sounding
chorus with three delays:</p>


<p style="margin-top: 1em">chorus=0.5:0.9:50|60|40:0.4|0.32|0.3:0.25|0.4|0.3:2|2.3|1.3</p>

<p style="margin-top: 1em">compand <br>
Compress or expand the audio&rsquo;s dynamic range.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">attacks <br>
decays <br>
A list of times in seconds for each channel over which the
instantaneous level of the input signal is averaged to
determine its volume. attacks refers to increase of volume
<br>
and decays refers to decrease of volume. For most
situations, the attack time (response to the audio getting
louder) should be shorter than the decay time, because the
human <br>
ear is more sensitive to sudden loud audio than sudden soft
audio. A typical value for attack is 0.3 seconds and a
typical value for decay is 0.8 seconds. If specified <br>
number of attacks &amp; decays is lower than number of
channels, the last set attack/decay will be used for all
remaining channels.</p>

<p style="margin-top: 1em">points <br>
A list of points for the transfer function, specified in dB
relative to the maximum possible signal amplitude. Each key
points list must be defined using the following <br>
syntax: &quot;x0/y0|x1/y1|x2/y2|....&quot; or &quot;x0/y0
x1/y1 x2/y2 ....&quot;</p>

<p style="margin-top: 1em">The input values must be in
strictly increasing order but the transfer function does not
have to be monotonically rising. The point &quot;0/0&quot;
is assumed but may be overridden (by <br>
&quot;0/out-dBn&quot;). Typical values for the transfer
function are &quot;-70/-70|-60/-20&quot;.</p>

<p style="margin-top: 1em">soft-knee <br>
Set the curve radius in dB for all joints. It defaults to
0.01.</p>

<p style="margin-top: 1em">gain <br>
Set the additional gain in dB to be applied at all points on
the transfer function. This allows for easy adjustment of
the overall gain. It defaults to 0.</p>

<p style="margin-top: 1em">volume <br>
Set an initial volume, in dB, to be assumed for each channel
when filtering starts. This permits the user to supply a
nominal level initially, so that, for example, a very <br>
large gain is not applied to initial signal levels before
the companding has begun to operate. A typical value for
audio which is initially quiet is -90 dB. It defaults to
0.</p>

<p style="margin-top: 1em">delay <br>
Set a delay, in seconds. The input audio is analyzed
immediately, but audio is delayed before being fed to the
volume adjuster. Specifying a delay approximately equal to
the <br>
attack/decay times allows the filter to effectively operate
in predictive rather than reactive mode. It defaults to
0.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Make music with
both quiet and loud passages suitable for listening to in a
noisy environment:</p>


<p style="margin-top: 1em">compand=.3|.3:1|1:-90/-60|-60/-40|-40/-30|-20/-20:6:0:-90:0.2</p>

<p style="margin-top: 1em">Another example for audio with
whisper and explosion parts:</p>


<p style="margin-top: 1em">compand=0|0:1|1:-90/-900|-70/-70|-30/-9|0/-3:6:0:0:0</p>

<p style="margin-top: 1em">&Acirc;&middot; A noise gate for
when the noise is at a lower level than the signal:</p>


<p style="margin-top: 1em">compand=.1|.1:.2|.2:-900/-900|-50.1/-900|-50/-50:.01:0:-90:.1</p>

<p style="margin-top: 1em">&Acirc;&middot; Here is another
noise gate, this time for when the noise is at a higher
level than the signal (making it, in some ways, similar to
squelch):</p>


<p style="margin-top: 1em">compand=.1|.1:.1|.1:-45.1/-45.1|-45/-900|0/-900:.01:45:-90:.1</p>

<p style="margin-top: 1em">&Acirc;&middot; 2:1 compression
starting at -6dB:</p>


<p style="margin-top: 1em">compand=points=-80/-80|-6/-6|0/-3.8|20/3.5</p>

<p style="margin-top: 1em">&Acirc;&middot; 2:1 compression
starting at -9dB:</p>


<p style="margin-top: 1em">compand=points=-80/-80|-9/-9|0/-5.3|20/2.9</p>

<p style="margin-top: 1em">&Acirc;&middot; 2:1 compression
starting at -12dB:</p>


<p style="margin-top: 1em">compand=points=-80/-80|-12/-12|0/-6.8|20/1.9</p>

<p style="margin-top: 1em">&Acirc;&middot; 2:1 compression
starting at -18dB:</p>


<p style="margin-top: 1em">compand=points=-80/-80|-18/-18|0/-9.8|20/0.7</p>

<p style="margin-top: 1em">&Acirc;&middot; 3:1 compression
starting at -15dB:</p>


<p style="margin-top: 1em">compand=points=-80/-80|-15/-15|0/-10.8|20/-5.2</p>

<p style="margin-top: 1em">&Acirc;&middot;
Compressor/Gate:</p>


<p style="margin-top: 1em">compand=points=-80/-105|-62/-80|-15.4/-15.4|0/-12|20/-7.6</p>

<p style="margin-top: 1em">&Acirc;&middot; Expander:</p>


<p style="margin-top: 1em">compand=attacks=0:points=-80/-169|-54/-80|-49.5/-64.6|-41.1/-41.1|-25.8/-15|-10.8/-4.5|0/0|20/8.3</p>

<p style="margin-top: 1em">&Acirc;&middot; Hard limiter at
-6dB:</p>


<p style="margin-top: 1em">compand=attacks=0:points=-80/-80|-6/-6|20/-6</p>

<p style="margin-top: 1em">&Acirc;&middot; Hard limiter at
-12dB:</p>


<p style="margin-top: 1em">compand=attacks=0:points=-80/-80|-12/-12|20/-12</p>

<p style="margin-top: 1em">&Acirc;&middot; Hard noise gate
at -35 dB:</p>


<p style="margin-top: 1em">compand=attacks=0:points=-80/-115|-35.1/-80|-35/-35|20/20</p>

<p style="margin-top: 1em">&Acirc;&middot; Soft
limiter:</p>


<p style="margin-top: 1em">compand=attacks=0:points=-80/-80|-12.4/-12.4|-6/-8|0/-6.8|20/-2.8</p>

<p style="margin-top: 1em">compensationdelay <br>
Compensation Delay Line is a metric based delay to
compensate differing positions of microphones or
speakers.</p>

<p style="margin-top: 1em">For example, you have recorded
guitar with two microphones placed in different location.
Because the front of sound wave has fixed speed in normal
conditions, the phasing of <br>
microphones can vary and depends on their location and
interposition. The best sound mix can be achieved when these
microphones are in phase (synchronized). Note that distance
of <br>
~30 cm between microphones makes one microphone to capture
signal in antiphase to another microphone. That makes the
final mix sounding moody. This filter helps to solve phasing
<br>
problems by adding different delays to each microphone track
and make them synchronized.</p>

<p style="margin-top: 1em">The best result can be reached
when you take one track as base and synchronize other tracks
one by one with it. Remember that synchronization/delay
tolerance depends on sample <br>
rate, too. Higher sample rates will give more tolerance.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">mm Set millimeters distance.
This is compensation distance for fine tuning. Default is
0.</p>

<p style="margin-top: 1em">cm Set cm distance. This is
compensation distance for tightening distance setup. Default
is 0.</p>

<p style="margin-top: 1em">m Set meters distance. This is
compensation distance for hard distance setup. Default is
0.</p>

<p style="margin-top: 1em">dry Set dry amount. Amount of
unprocessed (dry) signal. Default is 0.</p>

<p style="margin-top: 1em">wet Set wet amount. Amount of
processed (wet) signal. Default is 1.</p>

<p style="margin-top: 1em">temp <br>
Set temperature degree in Celsius. This is the temperature
of the environment. Default is 20.</p>

<p style="margin-top: 1em">crystalizer <br>
Simple algorithm to expand audio dynamic range.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">i Sets the intensity of effect
(default: 2.0). Must be in range between 0.0 (unchanged
sound) to 10.0 (maximum effect).</p>

<p style="margin-top: 1em">c Enable clipping. By default is
enabled.</p>

<p style="margin-top: 1em">dcshift <br>
Apply a DC shift to the audio.</p>

<p style="margin-top: 1em">This can be useful to remove a
DC offset (caused perhaps by a hardware problem in the
recording chain) from the audio. The effect of a DC offset
is reduced headroom and hence <br>
volume. The astats filter can be used to determine if a
signal has a DC offset.</p>

<p style="margin-top: 1em">shift <br>
Set the DC shift, allowed range is [-1, 1]. It indicates the
amount to shift the audio.</p>

<p style="margin-top: 1em">limitergain <br>
Optional. It should have a value much less than 1 (e.g. 0.05
or 0.02) and is used to prevent clipping.</p>

<p style="margin-top: 1em">dynaudnorm <br>
Dynamic Audio Normalizer.</p>

<p style="margin-top: 1em">This filter applies a certain
amount of gain to the input audio in order to bring its peak
magnitude to a target level (e.g. 0 dBFS). However, in
contrast to more &quot;simple&quot; <br>
normalization algorithms, the Dynamic Audio Normalizer
*dynamically* re-adjusts the gain factor to the input audio.
This allows for applying extra gain to the &quot;quiet&quot;
sections <br>
of the audio while avoiding distortions or clipping the
&quot;loud&quot; sections. In other words: The Dynamic Audio
Normalizer will &quot;even out&quot; the volume of quiet and
loud sections, in <br>
the sense that the volume of each section is brought to the
same target level. Note, however, that the Dynamic Audio
Normalizer achieves this goal *without* applying
&quot;dynamic <br>
range compressing&quot;. It will retain 100% of the dynamic
range *within* each section of the audio file.</p>

<p style="margin-top: 1em">f Set the frame length in
milliseconds. In range from 10 to 8000 milliseconds. Default
is 500 milliseconds. The Dynamic Audio Normalizer processes
the input audio in small <br>
chunks, referred to as frames. This is required, because a
peak magnitude has no meaning for just a single sample
value. Instead, we need to determine the peak magnitude for
<br>
a contiguous sequence of sample values. While a
&quot;standard&quot; normalizer would simply use the peak
magnitude of the complete file, the Dynamic Audio Normalizer
determines the <br>
peak magnitude individually for each frame. The length of a
frame is specified in milliseconds. By default, the Dynamic
Audio Normalizer uses a frame length of 500 <br>
milliseconds, which has been found to give good results with
most files. Note that the exact frame length, in number of
samples, will be determined automatically, based on <br>
the sampling rate of the individual input audio file.</p>

<p style="margin-top: 1em">g Set the Gaussian filter window
size. In range from 3 to 301, must be odd number. Default is
31. Probably the most important parameter of the Dynamic
Audio Normalizer is the <br>
&quot;window size&quot; of the Gaussian smoothing filter.
The filter&rsquo;s window size is specified in frames,
centered around the current frame. For the sake of
simplicity, this must be <br>
an odd number. Consequently, the default value of 31 takes
into account the current frame, as well as the 15 preceding
frames and the 15 subsequent frames. Using a larger <br>
window results in a stronger smoothing effect and thus in
less gain variation, i.e. slower gain adaptation.
Conversely, using a smaller window results in a weaker
smoothing <br>
effect and thus in more gain variation, i.e. faster gain
adaptation. In other words, the more you increase this
value, the more the Dynamic Audio Normalizer will behave
like <br>
a &quot;traditional&quot; normalization filter. On the
contrary, the more you decrease this value, the more the
Dynamic Audio Normalizer will behave like a dynamic range
compressor.</p>

<p style="margin-top: 1em">p Set the target peak value.
This specifies the highest permissible magnitude level for
the normalized audio input. This filter will try to approach
the target peak magnitude <br>
as closely as possible, but at the same time it also makes
sure that the normalized signal will never exceed the peak
magnitude. A frame&rsquo;s maximum local gain factor is <br>
imposed directly by the target peak magnitude. The default
value is 0.95 and thus leaves a headroom of 5%*. It is not
recommended to go above this value.</p>

<p style="margin-top: 1em">m Set the maximum gain factor.
In range from 1.0 to 100.0. Default is 10.0. The Dynamic
Audio Normalizer determines the maximum possible (local)
gain factor for each input <br>
frame, i.e. the maximum gain factor that does not result in
clipping or distortion. The maximum gain factor is
determined by the frame&rsquo;s highest magnitude sample.
However, <br>
the Dynamic Audio Normalizer additionally bounds the
frame&rsquo;s maximum gain factor by a predetermined
(global) maximum gain factor. This is done in order to avoid
excessive <br>
gain factors in &quot;silent&quot; or almost silent frames.
By default, the maximum gain factor is 10.0, For most inputs
the default value should be sufficient and it usually is not
<br>
recommended to increase this value. Though, for input with
an extremely low overall volume level, it may be necessary
to allow even higher gain factors. Note, however, that <br>
the Dynamic Audio Normalizer does not simply apply a
&quot;hard&quot; threshold (i.e. cut off values above the
threshold). Instead, a &quot;sigmoid&quot; threshold
function will be applied. <br>
This way, the gain factors will smoothly approach the
threshold value, but never exceed that value.</p>

<p style="margin-top: 1em">r Set the target RMS. In range
from 0.0 to 1.0. Default is 0.0 - disabled. By default, the
Dynamic Audio Normalizer performs &quot;peak&quot;
normalization. This means that the maximum <br>
local gain factor for each frame is defined (only) by the
frame&rsquo;s highest magnitude sample. This way, the
samples can be amplified as much as possible without
exceeding the <br>
maximum signal level, i.e. without clipping. Optionally,
however, the Dynamic Audio Normalizer can also take into
account the frame&rsquo;s root mean square, abbreviated RMS.
In <br>
electrical engineering, the RMS is commonly used to
determine the power of a time-varying signal. It is
therefore considered that the RMS is a better approximation
of the <br>
&quot;perceived loudness&quot; than just looking at the
signal&rsquo;s peak magnitude. Consequently, by adjusting
all frames to a constant RMS value, a uniform
&quot;perceived loudness&quot; can be <br>
established. If a target RMS value has been specified, a
frame&rsquo;s local gain factor is defined as the factor
that would result in exactly that RMS value. Note, however,
that <br>
the maximum local gain factor is still restricted by the
frame&rsquo;s highest magnitude sample, in order to prevent
clipping.</p>

<p style="margin-top: 1em">n Enable channels coupling. By
default is enabled. By default, the Dynamic Audio Normalizer
will amplify all channels by the same amount. This means the
same gain factor will <br>
be applied to all channels, i.e. the maximum possible gain
factor is determined by the &quot;loudest&quot; channel.
However, in some recordings, it may happen that the volume
of the <br>
different channels is uneven, e.g. one channel may be
&quot;quieter&quot; than the other one(s). In this case,
this option can be used to disable the channel coupling.
This way, the <br>
gain factor will be determined independently for each
channel, depending only on the individual channel&rsquo;s
highest magnitude sample. This allows for harmonizing the
volume of <br>
the different channels.</p>

<p style="margin-top: 1em">c Enable DC bias correction. By
default is disabled. An audio signal (in the time domain) is
a sequence of sample values. In the Dynamic Audio Normalizer
these sample values <br>
are represented in the -1.0 to 1.0 range, regardless of the
original input format. Normally, the audio signal, or
&quot;waveform&quot;, should be centered around the zero
point. That <br>
means if we calculate the mean value of all samples in a
file, or in a single frame, then the result should be 0.0 or
at least very close to that value. If, however, there is
<br>
a significant deviation of the mean value from 0.0, in
either positive or negative direction, this is referred to
as a DC bias or DC offset. Since a DC bias is clearly <br>
undesirable, the Dynamic Audio Normalizer provides optional
DC bias correction. With DC bias correction enabled, the
Dynamic Audio Normalizer will determine the mean value, <br>
or &quot;DC correction&quot; offset, of each input frame and
subtract that value from all of the frame&rsquo;s sample
values which ensures those samples are centered around 0.0
again. Also, <br>
in order to avoid &quot;gaps&quot; at the frame boundaries,
the DC correction offset values will be interpolated
smoothly between neighbouring frames.</p>

<p style="margin-top: 1em">b Enable alternative boundary
mode. By default is disabled. The Dynamic Audio Normalizer
takes into account a certain neighbourhood around each
frame. This includes the <br>
preceding frames as well as the subsequent frames. However,
for the &quot;boundary&quot; frames, located at the very
beginning and at the very end of the audio file, not all
<br>
neighbouring frames are available. In particular, for the
first few frames in the audio file, the preceding frames are
not known. And, similarly, for the last few frames in <br>
the audio file, the subsequent frames are not known. Thus,
the question arises which gain factors should be assumed for
the missing frames in the &quot;boundary&quot; region. The
<br>
Dynamic Audio Normalizer implements two modes to deal with
this situation. The default boundary mode assumes a gain
factor of exactly 1.0 for the missing frames, resulting in
<br>
a smooth &quot;fade in&quot; and &quot;fade out&quot; at the
beginning and at the end of the input, respectively.</p>

<p style="margin-top: 1em">s Set the compress factor. In
range from 0.0 to 30.0. Default is 0.0. By default, the
Dynamic Audio Normalizer does not apply
&quot;traditional&quot; compression. This means that signal
<br>
peaks will not be pruned and thus the full dynamic range
will be retained within each local neighbourhood. However,
in some cases it may be desirable to combine the Dynamic
<br>
Audio Normalizer&rsquo;s normalization algorithm with a more
&quot;traditional&quot; compression. For this purpose, the
Dynamic Audio Normalizer provides an optional compression
<br>
(thresholding) function. If (and only if) the compression
feature is enabled, all input frames will be processed by a
soft knee thresholding function prior to the actual <br>
normalization process. Put simply, the thresholding function
is going to prune all samples whose magnitude exceeds a
certain threshold value. However, the Dynamic Audio <br>
Normalizer does not simply apply a fixed threshold value.
Instead, the threshold value will be adjusted for each
individual frame. In general, smaller parameters result in
<br>
stronger compression, and vice versa. Values below 3.0 are
not recommended, because audible distortion may appear.</p>

<p style="margin-top: 1em">earwax <br>
Make audio easier to listen to on headphones.</p>

<p style="margin-top: 1em">This filter adds
&lsquo;cues&rsquo; to 44.1kHz stereo (i.e. audio CD format)
audio so that when listened to on headphones the stereo
image is moved from inside your head (standard for <br>
headphones) to outside and in front of the listener
(standard for speakers).</p>

<p style="margin-top: 1em">Ported from SoX.</p>

<p style="margin-top: 1em">equalizer <br>
Apply a two-pole peaking equalisation (EQ) filter. With this
filter, the signal-level at and around a selected frequency
can be increased or decreased, whilst (unlike bandpass <br>
and bandreject filters) that at all other frequencies is
unchanged.</p>

<p style="margin-top: 1em">In order to produce complex
equalisation curves, this filter can be given several times,
each with a different central frequency.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">frequency, f <br>
Set the filter&rsquo;s central frequency in Hz.</p>

<p style="margin-top: 1em">width_type <br>
Set method to specify band-width of filter.</p>

<p style="margin-top: 1em">h Hz</p>

<p style="margin-top: 1em">q Q-Factor</p>

<p style="margin-top: 1em">o octave</p>

<p style="margin-top: 1em">s slope</p>

<p style="margin-top: 1em">width, w <br>
Specify the band-width of a filter in width_type units.</p>

<p style="margin-top: 1em">gain, g <br>
Set the required gain or attenuation in dB. Beware of
clipping when using a positive gain.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Attenuate 10 dB
at 1000 Hz, with a bandwidth of 200 Hz:</p>


<p style="margin-top: 1em">equalizer=f=1000:width_type=h:width=200:g=-10</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply 2 dB gain
at 1000 Hz with Q 1 and attenuate 5 dB at 100 Hz with Q
2:</p>


<p style="margin-top: 1em">equalizer=f=1000:width_type=q:width=1:g=2,equalizer=f=100:width_type=q:width=2:g=-5</p>

<p style="margin-top: 1em">extrastereo <br>
Linearly increases the difference between left and right
channels which adds some sort of &quot;live&quot; effect to
playback.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">m Sets the difference
coefficient (default: 2.5). 0.0 means mono sound (average of
both channels), with 1.0 sound will be unchanged, with -1.0
left and right channels will be <br>
swapped.</p>

<p style="margin-top: 1em">c Enable clipping. By default is
enabled.</p>

<p style="margin-top: 1em">firequalizer <br>
Apply FIR Equalization using arbitrary frequency
response.</p>

<p style="margin-top: 1em">The filter accepts the following
option:</p>

<p style="margin-top: 1em">gain <br>
Set gain curve equation (in dB). The expression can contain
variables:</p>

<p style="margin-top: 1em">f the evaluated frequency</p>

<p style="margin-top: 1em">sr sample rate</p>

<p style="margin-top: 1em">ch channel number, set to 0 when
multichannels evaluation is disabled</p>

<p style="margin-top: 1em">chid <br>
channel id, see libavutil/channel_layout.h, set to the first
channel id when multichannels evaluation is disabled</p>

<p style="margin-top: 1em">chs number of channels</p>

<p style="margin-top: 1em">chlayout <br>
channel_layout, see libavutil/channel_layout.h</p>

<p style="margin-top: 1em">and functions:</p>

<p style="margin-top: 1em">gain_interpolate(f) <br>
interpolate gain on frequency f based on gain_entry</p>

<p style="margin-top: 1em">cubic_interpolate(f) <br>
same as gain_interpolate, but smoother</p>

<p style="margin-top: 1em">This option is also available as
command. Default is gain_interpolate(f).</p>

<p style="margin-top: 1em">gain_entry <br>
Set gain entry for gain_interpolate function. The expression
can contain functions:</p>

<p style="margin-top: 1em">entry(f, g) <br>
store gain entry at frequency f with value g</p>

<p style="margin-top: 1em">This option is also available as
command.</p>

<p style="margin-top: 1em">delay <br>
Set filter delay in seconds. Higher value means more
accurate. Default is 0.01.</p>

<p style="margin-top: 1em">accuracy <br>
Set filter accuracy in Hz. Lower value means more accurate.
Default is 5.</p>

<p style="margin-top: 1em">wfunc <br>
Set window function. Acceptable values are:</p>

<p style="margin-top: 1em">rectangular <br>
rectangular window, useful when gain curve is already
smooth</p>

<p style="margin-top: 1em">hann <br>
hann window (default)</p>

<p style="margin-top: 1em">hamming <br>
hamming window</p>

<p style="margin-top: 1em">blackman <br>
blackman window</p>

<p style="margin-top: 1em">nuttall3 <br>
3-terms continuous 1st derivative nuttall window</p>

<p style="margin-top: 1em">mnuttall3 <br>
minimum 3-terms discontinuous nuttall window</p>

<p style="margin-top: 1em">nuttall <br>
4-terms continuous 1st derivative nuttall window</p>

<p style="margin-top: 1em">bnuttall <br>
minimum 4-terms discontinuous nuttall (blackman-nuttall)
window</p>

<p style="margin-top: 1em">bharris <br>
blackman-harris window</p>

<p style="margin-top: 1em">tukey <br>
tukey window</p>

<p style="margin-top: 1em">fixed <br>
If enabled, use fixed number of audio samples. This improves
speed when filtering with large delay. Default is
disabled.</p>

<p style="margin-top: 1em">multi <br>
Enable multichannels evaluation on gain. Default is
disabled.</p>

<p style="margin-top: 1em">zero_phase <br>
Enable zero phase mode by subtracting timestamp to
compensate delay. Default is disabled.</p>

<p style="margin-top: 1em">scale <br>
Set scale used by gain. Acceptable values are:</p>

<p style="margin-top: 1em">linlin <br>
linear frequency, linear gain</p>

<p style="margin-top: 1em">linlog <br>
linear frequency, logarithmic (in dB) gain (default)</p>

<p style="margin-top: 1em">loglin <br>
logarithmic (in octave scale where 20 Hz is 0) frequency,
linear gain</p>

<p style="margin-top: 1em">loglog <br>
logarithmic frequency, logarithmic gain</p>

<p style="margin-top: 1em">dumpfile <br>
Set file for dumping, suitable for gnuplot.</p>

<p style="margin-top: 1em">dumpscale <br>
Set scale for dumpfile. Acceptable values are same with
scale option. Default is linlog.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; lowpass at 1000
Hz:</p>


<p style="margin-top: 1em">firequalizer=gain=&rsquo;if(lt(f,1000),
0, -INF)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; lowpass at 1000
Hz with gain_entry:</p>


<p style="margin-top: 1em">firequalizer=gain_entry=&rsquo;entry(1000,0);
entry(1001, -INF)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; custom
equalization:</p>


<p style="margin-top: 1em">firequalizer=gain_entry=&rsquo;entry(100,0);
entry(400, -4); entry(1000, -6); entry(2000, 0)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; higher delay
with zero phase to compensate delay:</p>


<p style="margin-top: 1em">firequalizer=delay=0.1:fixed=on:zero_phase=on</p>

<p style="margin-top: 1em">&Acirc;&middot; lowpass on left
channel, highpass on right channel:</p>


<p style="margin-top: 1em">firequalizer=gain=&rsquo;if(eq(chid,1),
gain_interpolate(f), if(eq(chid,2), gain_interpolate(1e6+f),
0))&rsquo; <br>
:gain_entry=&rsquo;entry(1000, 0); entry(1001,-INF);
entry(1e6+1000,0)&rsquo;:multi=on</p>

<p style="margin-top: 1em">flanger <br>
Apply a flanging effect to the audio.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">delay <br>
Set base delay in milliseconds. Range from 0 to 30. Default
value is 0.</p>

<p style="margin-top: 1em">depth <br>
Set added swep delay in milliseconds. Range from 0 to 10.
Default value is 2.</p>

<p style="margin-top: 1em">regen <br>
Set percentage regeneration (delayed signal feedback). Range
from -95 to 95. Default value is 0.</p>

<p style="margin-top: 1em">width <br>
Set percentage of delayed signal mixed with original. Range
from 0 to 100. Default value is 71.</p>

<p style="margin-top: 1em">speed <br>
Set sweeps per second (Hz). Range from 0.1 to 10. Default
value is 0.5.</p>

<p style="margin-top: 1em">shape <br>
Set swept wave shape, can be triangular or sinusoidal.
Default value is sinusoidal.</p>

<p style="margin-top: 1em">phase <br>
Set swept wave percentage-shift for multi channel. Range
from 0 to 100. Default value is 25.</p>

<p style="margin-top: 1em">interp <br>
Set delay-line interpolation, linear or quadratic. Default
is linear.</p>

<p style="margin-top: 1em">hdcd <br>
Decodes High Definition Compatible Digital (HDCD) data. A
16-bit PCM stream with embedded HDCD codes is expanded into
a 20-bit PCM stream.</p>

<p style="margin-top: 1em">The filter supports the Peak
Extend and Low-level Gain Adjustment features of HDCD, and
detects the Transient Filter flag.</p>

<p style="margin-top: 1em">ffmpeg -i HDCD16.flac -af hdcd
OUT24.flac</p>

<p style="margin-top: 1em">When using the filter with wav,
note the default encoding for wav is 16-bit, so the
resulting 20-bit stream will be truncated back to 16-bit.
Use something like -acodec pcm_s24le <br>
after the filter to get 24-bit PCM output.</p>

<p style="margin-top: 1em">ffmpeg -i HDCD16.wav -af hdcd
OUT16.wav <br>
ffmpeg -i HDCD16.wav -af hdcd -acodec pcm_s24le
OUT24.wav</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">disable_autoconvert <br>
Disable any automatic format conversion or resampling in the
filter graph.</p>

<p style="margin-top: 1em">process_stereo <br>
Process the stereo channels together. If target_gain does
not match between channels, consider it invalid and use the
last valid target_gain.</p>

<p style="margin-top: 1em">cdt_ms <br>
Set the code detect timer period in ms.</p>

<p style="margin-top: 1em">force_pe <br>
Always extend peaks above -3dBFS even if PE isn&rsquo;t
signaled.</p>

<p style="margin-top: 1em">analyze_mode <br>
Replace audio with a solid tone and adjust the amplitude to
signal some specific aspect of the decoding process. The
output file can be loaded in an audio editor alongside <br>
the original to aid analysis.</p>


<p style="margin-top: 1em">&quot;analyze_mode=pe:force_pe=true&quot;
can be used to see all samples above the PE level.</p>

<p style="margin-top: 1em">Modes are:</p>

<p style="margin-top: 1em">0, off <br>
Disabled</p>

<p style="margin-top: 1em">1, lle <br>
Gain adjustment level at each sample</p>

<p style="margin-top: 1em">2, pe <br>
Samples where peak extend occurs</p>

<p style="margin-top: 1em">3, cdt <br>
Samples where the code detect timer is active</p>

<p style="margin-top: 1em">4, tgm <br>
Samples where the target gain does not match between
channels</p>

<p style="margin-top: 1em">highpass <br>
Apply a high-pass filter with 3dB point frequency. The
filter can be either single-pole, or double-pole (the
default). The filter roll off at 6dB per pole per octave
(20dB per <br>
pole per decade).</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">frequency, f <br>
Set frequency in Hz. Default is 3000.</p>

<p style="margin-top: 1em">poles, p <br>
Set number of poles. Default is 2.</p>

<p style="margin-top: 1em">width_type <br>
Set method to specify band-width of filter.</p>

<p style="margin-top: 1em">h Hz</p>

<p style="margin-top: 1em">q Q-Factor</p>

<p style="margin-top: 1em">o octave</p>

<p style="margin-top: 1em">s slope</p>

<p style="margin-top: 1em">width, w <br>
Specify the band-width of a filter in width_type units.
Applies only to double-pole filter. The default is 0.707q
and gives a Butterworth response.</p>

<p style="margin-top: 1em">join <br>
Join multiple input streams into one multi-channel
stream.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">inputs <br>
The number of input streams. It defaults to 2.</p>

<p style="margin-top: 1em">channel_layout <br>
The desired output channel layout. It defaults to
stereo.</p>

<p style="margin-top: 1em">map Map channels from inputs to
output. The argument is a &rsquo;|&rsquo;-separated list of
mappings, each in the
&quot;input_idx.in_channel-out_channel&quot; form. input_idx
is the 0-based index of <br>
the input stream. in_channel can be either the name of the
input channel (e.g. FL for front left) or its index in the
specified input stream. out_channel is the name of the <br>
output channel.</p>

<p style="margin-top: 1em">The filter will attempt to guess
the mappings when they are not specified explicitly. It does
so by first trying to find an unused matching input channel
and if that fails it <br>
picks the first unused input channel.</p>

<p style="margin-top: 1em">Join 3 inputs (with properly set
channel layouts):</p>

<p style="margin-top: 1em">ffmpeg -i INPUT1 -i INPUT2 -i
INPUT3 -filter_complex join=inputs=3 OUTPUT</p>

<p style="margin-top: 1em">Build a 5.1 output from 6
single-channel streams:</p>

<p style="margin-top: 1em">ffmpeg -i fl -i fr -i fc -i sl
-i sr -i lfe -filter_complex <br>

&rsquo;join=inputs=6:channel_layout=5.1:map=0.0-FL|1.0-FR|2.0-FC|3.0-SL|4.0-SR|5.0-LFE&rsquo;
<br>
out</p>

<p style="margin-top: 1em">ladspa <br>
Load a LADSPA (Linux Audio Developer&rsquo;s Simple Plugin
API) plugin.</p>

<p style="margin-top: 1em">To enable compilation of this
filter you need to configure FFmpeg with
&quot;--enable-ladspa&quot;.</p>

<p style="margin-top: 1em">file, f <br>
Specifies the name of LADSPA plugin library to load. If the
environment variable LADSPA_PATH is defined, the LADSPA
plugin is searched in each one of the directories <br>
specified by the colon separated list in LADSPA_PATH,
otherwise in the standard LADSPA paths, which are in this
order: HOME/.ladspa/lib/, /usr/local/lib/ladspa/, <br>
/usr/lib/ladspa/.</p>

<p style="margin-top: 1em">plugin, p <br>
Specifies the plugin within the library. Some libraries
contain only one plugin, but others contain many of them. If
this is not set filter will list all available plugins <br>
within the specified library.</p>

<p style="margin-top: 1em">controls, c <br>
Set the &rsquo;|&rsquo; separated list of controls which are
zero or more floating point values that determine the
behavior of the loaded plugin (for example delay, threshold
or gain). <br>
Controls need to be defined using the following syntax:
c0=value0|c1=value1|c2=value2|..., where valuei is the value
set on the i-th control. Alternatively they can be also <br>
defined using the following syntax:
value0|value1|value2|..., where valuei is the value set on
the i-th control. If controls is set to &quot;help&quot;,
all available controls and <br>
their valid ranges are printed.</p>

<p style="margin-top: 1em">sample_rate, s <br>
Specify the sample rate, default to 44100. Only used if
plugin have zero inputs.</p>

<p style="margin-top: 1em">nb_samples, n <br>
Set the number of samples per channel per each output frame,
default is 1024. Only used if plugin have zero inputs.</p>

<p style="margin-top: 1em">duration, d <br>
Set the minimum duration of the sourced audio. See the Time
duration section in the ffmpeg-utils(1) manual for the
accepted syntax. Note that the resulting duration may be
<br>
greater than the specified duration, as the generated audio
is always cut at the end of a complete frame. If not
specified, or the expressed duration is negative, the audio
<br>
is supposed to be generated forever. Only used if plugin
have zero inputs.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; List all
available plugins within amp (LADSPA example plugin)
library:</p>

<p style="margin-top: 1em">ladspa=file=amp</p>

<p style="margin-top: 1em">&Acirc;&middot; List all
available controls and their valid ranges for
&quot;vcf_notch&quot; plugin from &quot;VCF&quot;
library:</p>


<p style="margin-top: 1em">ladspa=f=vcf:p=vcf_notch:c=help</p>

<p style="margin-top: 1em">&Acirc;&middot; Simulate low
quality audio equipment using &quot;Computer Music
Toolkit&quot; (CMT) plugin library:</p>


<p style="margin-top: 1em">ladspa=file=cmt:plugin=lofi:controls=c0=22|c1=12|c2=12</p>

<p style="margin-top: 1em">&Acirc;&middot; Add
reverberation to the audio using TAP-plugins (Tom&rsquo;s
Audio Processing plugins):</p>


<p style="margin-top: 1em">ladspa=file=tap_reverb:tap_reverb</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate white
noise, with 0.2 amplitude:</p>


<p style="margin-top: 1em">ladspa=file=cmt:noise_source_white:c=c0=.2</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate 20 bpm
clicks using plugin &quot;C* Click - Metronome&quot; from
the &quot;C* Audio Plugin Suite&quot; (CAPS) library:</p>


<p style="margin-top: 1em">ladspa=file=caps:Click:c=c1=20&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply &quot;C*
Eq10X2 - Stereo 10-band equaliser&quot; effect:</p>


<p style="margin-top: 1em">ladspa=caps:Eq10X2:c=c0=-48|c9=-24|c3=12|c4=2</p>

<p style="margin-top: 1em">&Acirc;&middot; Increase volume
by 20dB using fast lookahead limiter from Steve Harris
&quot;SWH Plugins&quot; collection:</p>


<p style="margin-top: 1em">ladspa=fast_lookahead_limiter_1913:fastLookaheadLimiter:20|0|2</p>

<p style="margin-top: 1em">&Acirc;&middot; Attenuate low
frequencies using Multiband EQ from Steve Harris &quot;SWH
Plugins&quot; collection:</p>


<p style="margin-top: 1em">ladspa=mbeq_1197:mbeq:-24|-24|-24|0|0|0|0|0|0|0|0|0|0|0|0</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">This filter supports the
following commands:</p>

<p style="margin-top: 1em">cN Modify the N-th control
value.</p>

<p style="margin-top: 1em">If the specified value is not
valid, it is ignored and prior one is kept.</p>

<p style="margin-top: 1em">loudnorm <br>
EBU R128 loudness normalization. Includes both dynamic and
linear normalization modes. Support for both single pass
(livestreams, files) and double pass (files) modes. This
<br>
algorithm can target IL, LRA, and maximum true peak.</p>

<p style="margin-top: 1em">To enable compilation of this
filter you need to configure FFmpeg with
&quot;--enable-libebur128&quot;.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">I, i <br>
Set integrated loudness target. Range is -70.0 - -5.0.
Default value is -24.0.</p>

<p style="margin-top: 1em">LRA, lra <br>
Set loudness range target. Range is 1.0 - 20.0. Default
value is 7.0.</p>

<p style="margin-top: 1em">TP, tp <br>
Set maximum true peak. Range is -9.0 - +0.0. Default value
is -2.0.</p>

<p style="margin-top: 1em">measured_I, measured_i <br>
Measured IL of input file. Range is -99.0 - +0.0.</p>

<p style="margin-top: 1em">measured_LRA, measured_lra <br>
Measured LRA of input file. Range is 0.0 - 99.0.</p>

<p style="margin-top: 1em">measured_TP, measured_tp <br>
Measured true peak of input file. Range is -99.0 -
+99.0.</p>

<p style="margin-top: 1em">measured_thresh <br>
Measured threshold of input file. Range is -99.0 - +0.0.</p>

<p style="margin-top: 1em">offset <br>
Set offset gain. Gain is applied before the true-peak
limiter. Range is -99.0 - +99.0. Default is +0.0.</p>

<p style="margin-top: 1em">linear <br>
Normalize linearly if possible. measured_I, measured_LRA,
measured_TP, and measured_thresh must also to be specified
in order to use this mode. Options are true or false. <br>
Default is true.</p>

<p style="margin-top: 1em">dual_mono <br>
Treat mono input files as &quot;dual-mono&quot;. If a mono
file is intended for playback on a stereo system, its EBU
R128 measurement will be perceptually incorrect. If set to
&quot;true&quot;, <br>
this option will compensate for this effect. Multi-channel
input files are not affected by this option. Options are
true or false. Default is false.</p>

<p style="margin-top: 1em">print_format <br>
Set print format for stats. Options are summary, json, or
none. Default value is none.</p>

<p style="margin-top: 1em">lowpass <br>
Apply a low-pass filter with 3dB point frequency. The filter
can be either single-pole or double-pole (the default). The
filter roll off at 6dB per pole per octave (20dB per <br>
pole per decade).</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">frequency, f <br>
Set frequency in Hz. Default is 500.</p>

<p style="margin-top: 1em">poles, p <br>
Set number of poles. Default is 2.</p>

<p style="margin-top: 1em">width_type <br>
Set method to specify band-width of filter.</p>

<p style="margin-top: 1em">h Hz</p>

<p style="margin-top: 1em">q Q-Factor</p>

<p style="margin-top: 1em">o octave</p>

<p style="margin-top: 1em">s slope</p>

<p style="margin-top: 1em">width, w <br>
Specify the band-width of a filter in width_type units.
Applies only to double-pole filter. The default is 0.707q
and gives a Butterworth response.</p>

<p style="margin-top: 1em">pan <br>
Mix channels with specific gain levels. The filter accepts
the output channel layout followed by a set of channels
definitions.</p>

<p style="margin-top: 1em">This filter is also designed to
efficiently remap the channels of an audio stream.</p>

<p style="margin-top: 1em">The filter accepts parameters of
the form: &quot;l|outdef|outdef|...&quot;</p>

<p style="margin-top: 1em">l output channel layout or
number of channels</p>

<p style="margin-top: 1em">outdef <br>
output channel specification, of the form:
&quot;out_name=[gain*]in_name[+[gain*]in_name...]&quot;</p>

<p style="margin-top: 1em">out_name <br>
output channel to define, either a channel name (FL, FR,
etc.) or a channel number (c0, c1, etc.)</p>

<p style="margin-top: 1em">gain <br>
multiplicative coefficient for the channel, 1 leaving the
volume unchanged</p>

<p style="margin-top: 1em">in_name <br>
input channel to use, see out_name for details; it is not
possible to mix named and numbered input channels</p>

<p style="margin-top: 1em">If the &lsquo;=&rsquo; in a
channel specification is replaced by &lsquo;&lt;&rsquo;,
then the gains for that specification will be renormalized
so that the total is 1, thus avoiding clipping noise.</p>

<p style="margin-top: 1em">Mixing examples</p>

<p style="margin-top: 1em">For example, if you want to
down-mix from stereo to mono, but with a bigger factor for
the left channel:</p>

<p style="margin-top: 1em">pan=1c|c0=0.9*c0+0.1*c1</p>

<p style="margin-top: 1em">A customized down-mix to stereo
that works automatically for 3-, 4-, 5- and 7-channels
surround:</p>

<p style="margin-top: 1em">pan=stereo| FL &lt; FL + 0.5*FC
+ 0.6*BL + 0.6*SL | FR &lt; FR + 0.5*FC + 0.6*BR +
0.6*SR</p>

<p style="margin-top: 1em">Note that ffmpeg integrates a
default down-mix (and up-mix) system that should be
preferred (see &quot;-ac&quot; option) unless you have very
specific needs.</p>

<p style="margin-top: 1em">Remapping examples</p>

<p style="margin-top: 1em">The channel remapping will be
effective if, and only if:</p>

<p style="margin-top: 1em">*&lt;gain coefficients are
zeroes or ones,&gt; <br>
*&lt;only one input per channel output,&gt;</p>

<p style="margin-top: 1em">If all these conditions are
satisfied, the filter will notify the user (&quot;Pure
channel mapping detected&quot;), and use an optimized and
lossless method to do the remapping.</p>

<p style="margin-top: 1em">For example, if you have a 5.1
source and want a stereo audio stream by dropping the extra
channels:</p>

<p style="margin-top: 1em">pan=&quot;stereo| c0=FL |
c1=FR&quot;</p>

<p style="margin-top: 1em">Given the same source, you can
also switch front left and front right channels and keep the
input channel layout:</p>

<p style="margin-top: 1em">pan=&quot;5.1| c0=c1 | c1=c0 |
c2=c2 | c3=c3 | c4=c4 | c5=c5&quot;</p>

<p style="margin-top: 1em">If the input is a stereo audio
stream, you can mute the front left channel (and still keep
the stereo channel layout) with:</p>


<p style="margin-top: 1em">pan=&quot;stereo|c1=c1&quot;</p>

<p style="margin-top: 1em">Still with a stereo audio stream
input, you can copy the right channel in both front left and
right:</p>

<p style="margin-top: 1em">pan=&quot;stereo| c0=FR |
c1=FR&quot;</p>

<p style="margin-top: 1em">replaygain <br>
ReplayGain scanner filter. This filter takes an audio stream
as an input and outputs it unchanged. At end of filtering it
displays &quot;track_gain&quot; and
&quot;track_peak&quot;.</p>

<p style="margin-top: 1em">resample <br>
Convert the audio sample format, sample rate and channel
layout. It is not meant to be used directly.</p>

<p style="margin-top: 1em">rubberband <br>
Apply time-stretching and pitch-shifting with
librubberband.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">tempo <br>
Set tempo scale factor.</p>

<p style="margin-top: 1em">pitch <br>
Set pitch scale factor.</p>

<p style="margin-top: 1em">transients <br>
Set transients detector. Possible values are:</p>

<p style="margin-top: 1em">crisp <br>
mixed <br>
smooth <br>
detector <br>
Set detector. Possible values are:</p>

<p style="margin-top: 1em">compound <br>
percussive <br>
soft <br>
phase <br>
Set phase. Possible values are:</p>

<p style="margin-top: 1em">laminar <br>
independent <br>
window <br>
Set processing window size. Possible values are:</p>

<p style="margin-top: 1em">standard <br>
short <br>
long <br>
smoothing <br>
Set smoothing. Possible values are:</p>

<p style="margin-top: 1em">off <br>
on <br>
formant <br>
Enable formant preservation when shift pitching. Possible
values are:</p>

<p style="margin-top: 1em">shifted <br>
preserved <br>
pitchq <br>
Set pitch quality. Possible values are:</p>

<p style="margin-top: 1em">quality <br>
speed <br>
consistency <br>
channels <br>
Set channels. Possible values are:</p>

<p style="margin-top: 1em">apart <br>
together</p>

<p style="margin-top: 1em">sidechaincompress <br>
This filter acts like normal compressor but has the ability
to compress detected signal using second input signal. It
needs two input streams and returns one output stream. <br>
First input stream will be processed depending on second
stream signal. The filtered signal then can be filtered with
other filters in later stages of processing. See pan and
<br>
amerge filter.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">level_in <br>
Set input gain. Default is 1. Range is between 0.015625 and
64.</p>

<p style="margin-top: 1em">threshold <br>
If a signal of second stream raises above this level it will
affect the gain reduction of first stream. By default is
0.125. Range is between 0.00097563 and 1.</p>

<p style="margin-top: 1em">ratio <br>
Set a ratio about which the signal is reduced. 1:2 means
that if the level raised 4dB above the threshold, it will be
only 2dB above after the reduction. Default is 2. Range <br>
is between 1 and 20.</p>

<p style="margin-top: 1em">attack <br>
Amount of milliseconds the signal has to rise above the
threshold before gain reduction starts. Default is 20. Range
is between 0.01 and 2000.</p>

<p style="margin-top: 1em">release <br>
Amount of milliseconds the signal has to fall below the
threshold before reduction is decreased again. Default is
250. Range is between 0.01 and 9000.</p>

<p style="margin-top: 1em">makeup <br>
Set the amount by how much signal will be amplified after
processing. Default is 2. Range is from 1 and 64.</p>

<p style="margin-top: 1em">knee <br>
Curve the sharp knee around the threshold to enter gain
reduction more softly. Default is 2.82843. Range is between
1 and 8.</p>

<p style="margin-top: 1em">link <br>
Choose if the &quot;average&quot; level between all channels
of side-chain stream or the louder(&quot;maximum&quot;)
channel of side-chain stream affects the reduction. Default
is &quot;average&quot;.</p>

<p style="margin-top: 1em">detection <br>
Should the exact signal be taken in case of &quot;peak&quot;
or an RMS one in case of &quot;rms&quot;. Default is
&quot;rms&quot; which is mainly smoother.</p>

<p style="margin-top: 1em">level_sc <br>
Set sidechain gain. Default is 1. Range is between 0.015625
and 64.</p>

<p style="margin-top: 1em">mix How much to use compressed
signal in output. Default is 1. Range is between 0 and
1.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Full ffmpeg
example taking 2 audio inputs, 1st input to be compressed
depending on the signal of 2nd input and later compressed
signal to be merged with 2nd input:</p>

<p style="margin-top: 1em">ffmpeg -i main.flac -i
sidechain.flac -filter_complex
&quot;[1:a]asplit=2[sc][mix];[0:a][sc]sidechaincompress[compr];[compr][mix]amerge&quot;</p>

<p style="margin-top: 1em">sidechaingate <br>
A sidechain gate acts like a normal (wideband) gate but has
the ability to filter the detected signal before sending it
to the gain reduction stage. Normally a gate uses the <br>
full range signal to detect a level above the threshold. For
example: If you cut all lower frequencies from your
sidechain signal the gate will decrease the volume of your
track <br>
only if not enough highs appear. With this technique you are
able to reduce the resonation of a natural drum or remove
&quot;rumbling&quot; of muted strokes from a heavily
distorted <br>
guitar. It needs two input streams and returns one output
stream. First input stream will be processed depending on
second stream signal.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">level_in <br>
Set input level before filtering. Default is 1. Allowed
range is from 0.015625 to 64.</p>

<p style="margin-top: 1em">range <br>
Set the level of gain reduction when the signal is below the
threshold. Default is 0.06125. Allowed range is from 0 to
1.</p>

<p style="margin-top: 1em">threshold <br>
If a signal rises above this level the gain reduction is
released. Default is 0.125. Allowed range is from 0 to
1.</p>

<p style="margin-top: 1em">ratio <br>
Set a ratio about which the signal is reduced. Default is 2.
Allowed range is from 1 to 9000.</p>

<p style="margin-top: 1em">attack <br>
Amount of milliseconds the signal has to rise above the
threshold before gain reduction stops. Default is 20
milliseconds. Allowed range is from 0.01 to 9000.</p>

<p style="margin-top: 1em">release <br>
Amount of milliseconds the signal has to fall below the
threshold before the reduction is increased again. Default
is 250 milliseconds. Allowed range is from 0.01 to 9000.</p>

<p style="margin-top: 1em">makeup <br>
Set amount of amplification of signal after processing.
Default is 1. Allowed range is from 1 to 64.</p>

<p style="margin-top: 1em">knee <br>
Curve the sharp knee around the threshold to enter gain
reduction more softly. Default is 2.828427125. Allowed range
is from 1 to 8.</p>

<p style="margin-top: 1em">detection <br>
Choose if exact signal should be taken for detection or an
RMS like one. Default is rms. Can be peak or rms.</p>

<p style="margin-top: 1em">link <br>
Choose if the average level between all channels or the
louder channel affects the reduction. Default is average.
Can be average or maximum.</p>

<p style="margin-top: 1em">level_sc <br>
Set sidechain gain. Default is 1. Range is from 0.015625 to
64.</p>

<p style="margin-top: 1em">silencedetect <br>
Detect silence in an audio stream.</p>

<p style="margin-top: 1em">This filter logs a message when
it detects that the input audio volume is less or equal to a
noise tolerance value for a duration greater or equal to the
minimum detected noise <br>
duration.</p>

<p style="margin-top: 1em">The printed times and duration
are expressed in seconds.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">duration, d <br>
Set silence duration until notification (default is 2
seconds).</p>

<p style="margin-top: 1em">noise, n <br>
Set noise tolerance. Can be specified in dB (in case
&quot;dB&quot; is appended to the specified value) or
amplitude ratio. Default is -60dB, or 0.001.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Detect 5 seconds
of silence with -50dB noise tolerance:</p>

<p style="margin-top: 1em">silencedetect=n=-50dB:d=5</p>

<p style="margin-top: 1em">&Acirc;&middot; Complete example
with ffmpeg to detect silence with 0.0001 noise tolerance in
silence.mp3:</p>

<p style="margin-top: 1em">ffmpeg -i silence.mp3 -af
silencedetect=noise=0.0001 -f null -</p>

<p style="margin-top: 1em">silenceremove <br>
Remove silence from the beginning, middle or end of the
audio.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">start_periods <br>
This value is used to indicate if audio should be trimmed at
beginning of the audio. A value of zero indicates no silence
should be trimmed from the beginning. When <br>
specifying a non-zero value, it trims audio up until it
finds non-silence. Normally, when trimming silence from
beginning of audio the start_periods will be 1 but it can be
<br>
increased to higher values to trim all audio up to specific
count of non-silence periods. Default value is 0.</p>

<p style="margin-top: 1em">start_duration <br>
Specify the amount of time that non-silence must be detected
before it stops trimming audio. By increasing the duration,
bursts of noises can be treated as silence and <br>
trimmed off. Default value is 0.</p>

<p style="margin-top: 1em">start_threshold <br>
This indicates what sample value should be treated as
silence. For digital audio, a value of 0 may be fine but for
audio recorded from analog, you may wish to increase the
<br>
value to account for background noise. Can be specified in
dB (in case &quot;dB&quot; is appended to the specified
value) or amplitude ratio. Default value is 0.</p>

<p style="margin-top: 1em">stop_periods <br>
Set the count for trimming silence from the end of audio. To
remove silence from the middle of a file, specify a
stop_periods that is negative. This value is then treated as
<br>
a positive value and is used to indicate the effect should
restart processing as specified by start_periods, making it
suitable for removing periods of silence in the middle <br>
of the audio. Default value is 0.</p>

<p style="margin-top: 1em">stop_duration <br>
Specify a duration of silence that must exist before audio
is not copied any more. By specifying a higher duration,
silence that is wanted can be left in the audio. Default
<br>
value is 0.</p>

<p style="margin-top: 1em">stop_threshold <br>
This is the same as start_threshold but for trimming silence
from the end of audio. Can be specified in dB (in case
&quot;dB&quot; is appended to the specified value) or
amplitude <br>
ratio. Default value is 0.</p>

<p style="margin-top: 1em">leave_silence <br>
This indicates that stop_duration length of audio should be
left intact at the beginning of each period of silence. For
example, if you want to remove long pauses between <br>
words but do not want to remove the pauses completely.
Default value is 0.</p>

<p style="margin-top: 1em">detection <br>
Set how is silence detected. Can be &quot;rms&quot; or
&quot;peak&quot;. Second is faster and works better with
digital silence which is exactly 0. Default value is
&quot;rms&quot;.</p>

<p style="margin-top: 1em">window <br>
Set ratio used to calculate size of window for detecting
silence. Default value is 0.02. Allowed range is from 0 to
10.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; The following
example shows how this filter can be used to start a
recording that does not contain the delay at the start which
usually occurs between pressing the record <br>
button and the start of the performance:</p>

<p style="margin-top: 1em">silenceremove=1:5:0.02</p>

<p style="margin-top: 1em">&Acirc;&middot; Trim all silence
encountered from beginning to end where there is more than 1
second of silence in audio:</p>


<p style="margin-top: 1em">silenceremove=0:0:0:-1:1:-90dB</p>

<p style="margin-top: 1em">sofalizer <br>
SOFAlizer uses head-related transfer functions (HRTFs) to
create virtual loudspeakers around the user for binaural
listening via headphones (audio formats up to 9 channels
<br>
supported). The HRTFs are stored in SOFA files (see
&lt;http://www.sofacoustics.org/&gt; for a database).
SOFAlizer is developed at the Acoustics Research Institute
(ARI) of the <br>
Austrian Academy of Sciences.</p>

<p style="margin-top: 1em">To enable compilation of this
filter you need to configure FFmpeg with
&quot;--enable-netcdf&quot;.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">sofa <br>
Set the SOFA file used for rendering.</p>

<p style="margin-top: 1em">gain <br>
Set gain applied to audio. Value is in dB. Default is 0.</p>

<p style="margin-top: 1em">rotation <br>
Set rotation of virtual loudspeakers in deg. Default is
0.</p>

<p style="margin-top: 1em">elevation <br>
Set elevation of virtual speakers in deg. Default is 0.</p>

<p style="margin-top: 1em">radius <br>
Set distance in meters between loudspeakers and the listener
with near-field HRTFs. Default is 1.</p>

<p style="margin-top: 1em">type <br>
Set processing type. Can be time or freq. time is processing
audio in time domain which is slow. freq is processing audio
in frequency domain which is fast. Default is <br>
freq.</p>

<p style="margin-top: 1em">speakers <br>
Set custom positions of virtual loudspeakers. Syntax for
this option is: &lt;CH&gt; &lt;AZIM&gt;
&lt;ELEV&gt;[|&lt;CH&gt; &lt;AZIM&gt; &lt;ELEV&gt;|...].
Each virtual loudspeaker is described with short <br>
channel name following with azimuth and elevation in
degreees. Each virtual loudspeaker description is separated
by &rsquo;|&rsquo;. For example to override front left and
front right <br>
channel positions use: &rsquo;speakers=FL 45 15|FR 345
15&rsquo;. Descriptions with unrecognised channel names are
ignored.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Using ClubFritz6
sofa file:</p>


<p style="margin-top: 1em">sofalizer=sofa=/path/to/ClubFritz6.sofa:type=freq:radius=1</p>

<p style="margin-top: 1em">&Acirc;&middot; Using
ClubFritz12 sofa file and bigger radius with small
rotation:</p>


<p style="margin-top: 1em">sofalizer=sofa=/path/to/ClubFritz12.sofa:type=freq:radius=2:rotation=5</p>

<p style="margin-top: 1em">&Acirc;&middot; Similar as above
but with custom speaker positions for front left, front
right, rear left and rear right and also with custom
gain:</p>


<p style="margin-top: 1em">&quot;sofalizer=sofa=/path/to/ClubFritz6.sofa:type=freq:radius=2:speakers=FL
45|FR 315|RL 135|RR 225:gain=28&quot;</p>

<p style="margin-top: 1em">stereotools <br>
This filter has some handy utilities to manage stereo
signals, for converting M/S stereo recordings to L/R signal
while having control over the parameters or spreading the
stereo <br>
image of master track.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">level_in <br>
Set input level before filtering for both channels. Defaults
is 1. Allowed range is from 0.015625 to 64.</p>

<p style="margin-top: 1em">level_out <br>
Set output level after filtering for both channels. Defaults
is 1. Allowed range is from 0.015625 to 64.</p>

<p style="margin-top: 1em">balance_in <br>
Set input balance between both channels. Default is 0.
Allowed range is from -1 to 1.</p>

<p style="margin-top: 1em">balance_out <br>
Set output balance between both channels. Default is 0.
Allowed range is from -1 to 1.</p>

<p style="margin-top: 1em">softclip <br>
Enable softclipping. Results in analog distortion instead of
harsh digital 0dB clipping. Disabled by default.</p>

<p style="margin-top: 1em">mutel <br>
Mute the left channel. Disabled by default.</p>

<p style="margin-top: 1em">muter <br>
Mute the right channel. Disabled by default.</p>

<p style="margin-top: 1em">phasel <br>
Change the phase of the left channel. Disabled by
default.</p>

<p style="margin-top: 1em">phaser <br>
Change the phase of the right channel. Disabled by
default.</p>

<p style="margin-top: 1em">mode <br>
Set stereo mode. Available values are:</p>

<p style="margin-top: 1em">lr&gt;lr <br>
Left/Right to Left/Right, this is default.</p>

<p style="margin-top: 1em">lr&gt;ms <br>
Left/Right to Mid/Side.</p>

<p style="margin-top: 1em">ms&gt;lr <br>
Mid/Side to Left/Right.</p>

<p style="margin-top: 1em">lr&gt;ll <br>
Left/Right to Left/Left.</p>

<p style="margin-top: 1em">lr&gt;rr <br>
Left/Right to Right/Right.</p>

<p style="margin-top: 1em">lr&gt;l+r <br>
Left/Right to Left + Right.</p>

<p style="margin-top: 1em">lr&gt;rl <br>
Left/Right to Right/Left.</p>

<p style="margin-top: 1em">slev <br>
Set level of side signal. Default is 1. Allowed range is
from 0.015625 to 64.</p>

<p style="margin-top: 1em">sbal <br>
Set balance of side signal. Default is 0. Allowed range is
from -1 to 1.</p>

<p style="margin-top: 1em">mlev <br>
Set level of the middle signal. Default is 1. Allowed range
is from 0.015625 to 64.</p>

<p style="margin-top: 1em">mpan <br>
Set middle signal pan. Default is 0. Allowed range is from
-1 to 1.</p>

<p style="margin-top: 1em">base <br>
Set stereo base between mono and inversed channels. Default
is 0. Allowed range is from -1 to 1.</p>

<p style="margin-top: 1em">delay <br>
Set delay in milliseconds how much to delay left from right
channel and vice versa. Default is 0. Allowed range is from
-20 to 20.</p>

<p style="margin-top: 1em">sclevel <br>
Set S/C level. Default is 1. Allowed range is from 1 to
100.</p>

<p style="margin-top: 1em">phase <br>
Set the stereo phase in degrees. Default is 0. Allowed range
is from 0 to 360.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply karaoke
like effect:</p>

<p style="margin-top: 1em">stereotools=mlev=0.015625</p>

<p style="margin-top: 1em">&Acirc;&middot; Convert M/S
signal to L/R:</p>


<p style="margin-top: 1em">&quot;stereotools=mode=ms&gt;lr&quot;</p>

<p style="margin-top: 1em">stereowiden <br>
This filter enhance the stereo effect by suppressing signal
common to both channels and by delaying the signal of left
into right and vice versa, thereby widening the stereo <br>
effect.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">delay <br>
Time in milliseconds of the delay of left signal into right
and vice versa. Default is 20 milliseconds.</p>

<p style="margin-top: 1em">feedback <br>
Amount of gain in delayed signal into right and vice versa.
Gives a delay effect of left signal in right output and vice
versa which gives widening effect. Default is 0.3.</p>

<p style="margin-top: 1em">crossfeed <br>
Cross feed of left into right with inverted phase. This
helps in suppressing the mono. If the value is 1 it will
cancel all the signal common to both channels. Default is
<br>
0.3.</p>

<p style="margin-top: 1em">drymix <br>
Set level of input signal of original channel. Default is
0.8.</p>

<p style="margin-top: 1em">treble <br>
Boost or cut treble (upper) frequencies of the audio using a
two-pole shelving filter with a response similar to that of
a standard hi-fi&rsquo;s tone-controls. This is also known
as <br>
shelving equalisation (EQ).</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">gain, g <br>
Give the gain at whichever is the lower of ~22 kHz and the
Nyquist frequency. Its useful range is about -20 (for a
large cut) to +20 (for a large boost). Beware of clipping
<br>
when using a positive gain.</p>

<p style="margin-top: 1em">frequency, f <br>
Set the filter&rsquo;s central frequency and so can be used
to extend or reduce the frequency range to be boosted or
cut. The default value is 3000 Hz.</p>

<p style="margin-top: 1em">width_type <br>
Set method to specify band-width of filter.</p>

<p style="margin-top: 1em">h Hz</p>

<p style="margin-top: 1em">q Q-Factor</p>

<p style="margin-top: 1em">o octave</p>

<p style="margin-top: 1em">s slope</p>

<p style="margin-top: 1em">width, w <br>
Determine how steep is the filter&rsquo;s shelf
transition.</p>

<p style="margin-top: 1em">tremolo <br>
Sinusoidal amplitude modulation.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">f Modulation frequency in Hertz.
Modulation frequencies in the subharmonic range (20 Hz or
lower) will result in a tremolo effect. This filter may also
be used as a ring <br>
modulator by specifying a modulation frequency higher than
20 Hz. Range is 0.1 - 20000.0. Default value is 5.0 Hz.</p>

<p style="margin-top: 1em">d Depth of modulation as a
percentage. Range is 0.0 - 1.0. Default value is 0.5.</p>

<p style="margin-top: 1em">vibrato <br>
Sinusoidal phase modulation.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">f Modulation frequency in Hertz.
Range is 0.1 - 20000.0. Default value is 5.0 Hz.</p>

<p style="margin-top: 1em">d Depth of modulation as a
percentage. Range is 0.0 - 1.0. Default value is 0.5.</p>

<p style="margin-top: 1em">volume <br>
Adjust the input audio volume.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">volume <br>
Set audio volume expression.</p>

<p style="margin-top: 1em">Output values are clipped to the
maximum value.</p>

<p style="margin-top: 1em">The output audio volume is given
by the relation:</p>

<p style="margin-top: 1em">&lt;output_volume&gt; =
&lt;volume&gt; * &lt;input_volume&gt;</p>

<p style="margin-top: 1em">The default value for volume is
&quot;1.0&quot;.</p>

<p style="margin-top: 1em">precision <br>
This parameter represents the mathematical precision.</p>

<p style="margin-top: 1em">It determines which input sample
formats will be allowed, which affects the precision of the
volume scaling.</p>

<p style="margin-top: 1em">fixed <br>
8-bit fixed-point; this limits input sample format to U8,
S16, and S32.</p>

<p style="margin-top: 1em">float <br>
32-bit floating-point; this limits input sample format to
FLT. (default)</p>

<p style="margin-top: 1em">double <br>
64-bit floating-point; this limits input sample format to
DBL.</p>

<p style="margin-top: 1em">replaygain <br>
Choose the behaviour on encountering ReplayGain side data in
input frames.</p>

<p style="margin-top: 1em">drop <br>
Remove ReplayGain side data, ignoring its contents (the
default).</p>

<p style="margin-top: 1em">ignore <br>
Ignore ReplayGain side data, but leave it in the frame.</p>

<p style="margin-top: 1em">track <br>
Prefer the track gain, if present.</p>

<p style="margin-top: 1em">album <br>
Prefer the album gain, if present.</p>

<p style="margin-top: 1em">replaygain_preamp <br>
Pre-amplification gain in dB to apply to the selected
replaygain gain.</p>

<p style="margin-top: 1em">Default value for
replaygain_preamp is 0.0.</p>

<p style="margin-top: 1em">eval <br>
Set when the volume expression is evaluated.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">once <br>
only evaluate expression once during the filter
initialization, or when the volume command is sent</p>

<p style="margin-top: 1em">frame <br>
evaluate expression for each incoming frame</p>

<p style="margin-top: 1em">Default value is once.</p>

<p style="margin-top: 1em">The volume expression can
contain the following parameters.</p>

<p style="margin-top: 1em">n frame number (starting at
zero)</p>

<p style="margin-top: 1em">nb_channels <br>
number of channels</p>

<p style="margin-top: 1em">nb_consumed_samples <br>
number of samples consumed by the filter</p>

<p style="margin-top: 1em">nb_samples <br>
number of samples in the current frame</p>

<p style="margin-top: 1em">pos original frame position in
the file</p>

<p style="margin-top: 1em">pts frame PTS</p>

<p style="margin-top: 1em">sample_rate <br>
sample rate</p>

<p style="margin-top: 1em">startpts <br>
PTS at start of stream</p>

<p style="margin-top: 1em">startt <br>
time at start of stream</p>

<p style="margin-top: 1em">t frame time</p>

<p style="margin-top: 1em">tb timestamp timebase</p>

<p style="margin-top: 1em">volume <br>
last set volume value</p>

<p style="margin-top: 1em">Note that when eval is set to
once only the sample_rate and tb variables are available,
all other variables will evaluate to NAN.</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">This filter supports the
following commands:</p>

<p style="margin-top: 1em">volume <br>
Modify the volume expression. The command accepts the same
syntax of the corresponding option.</p>

<p style="margin-top: 1em">If the specified expression is
not valid, it is kept at its current value.</p>

<p style="margin-top: 1em">replaygain_noclip <br>
Prevent clipping by limiting the gain applied.</p>

<p style="margin-top: 1em">Default value for
replaygain_noclip is 1.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Halve the input
audio volume:</p>

<p style="margin-top: 1em">volume=volume=0.5 <br>
volume=volume=1/2 <br>
volume=volume=-6.0206dB</p>

<p style="margin-top: 1em">In all the above example the
named key for volume can be omitted, for example like
in:</p>

<p style="margin-top: 1em">volume=0.5</p>

<p style="margin-top: 1em">&Acirc;&middot; Increase input
audio power by 6 decibels using fixed-point precision:</p>


<p style="margin-top: 1em">volume=volume=6dB:precision=fixed</p>

<p style="margin-top: 1em">&Acirc;&middot; Fade volume
after time 10 with an annihilation period of 5 seconds:</p>


<p style="margin-top: 1em">volume=&rsquo;if(lt(t,10),1,max(1-(t-10)/5,0))&rsquo;:eval=frame</p>

<p style="margin-top: 1em">volumedetect <br>
Detect the volume of the input video.</p>

<p style="margin-top: 1em">The filter has no parameters.
The input is not modified. Statistics about the volume will
be printed in the log when the input stream end is
reached.</p>

<p style="margin-top: 1em">In particular it will show the
mean volume (root mean square), maximum volume (on a
per-sample basis), and the beginning of a histogram of the
registered volume values (from the <br>
maximum value to a cumulated 1/1000 of the samples).</p>

<p style="margin-top: 1em">All volumes are in decibels
relative to the maximum PCM value.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">Here is an excerpt of the
output:</p>

<p style="margin-top: 1em">[Parsed_volumedetect_0 0xa23120]
mean_volume: -27 dB <br>
[Parsed_volumedetect_0 0xa23120] max_volume: -4 dB <br>
[Parsed_volumedetect_0 0xa23120] histogram_4db: 6 <br>
[Parsed_volumedetect_0 0xa23120] histogram_5db: 62 <br>
[Parsed_volumedetect_0 0xa23120] histogram_6db: 286 <br>
[Parsed_volumedetect_0 0xa23120] histogram_7db: 1042 <br>
[Parsed_volumedetect_0 0xa23120] histogram_8db: 2551 <br>
[Parsed_volumedetect_0 0xa23120] histogram_9db: 4609 <br>
[Parsed_volumedetect_0 0xa23120] histogram_10db: 8409</p>

<p style="margin-top: 1em">It means that:</p>

<p style="margin-top: 1em">&Acirc;&middot; The mean square
energy is approximately -27 dB, or 10^-2.7.</p>

<p style="margin-top: 1em">&Acirc;&middot; The largest
sample is at -4 dB, or more precisely between -4 dB and -5
dB.</p>

<p style="margin-top: 1em">&Acirc;&middot; There are 6
samples at -4 dB, 62 at -5 dB, 286 at -6 dB, etc.</p>

<p style="margin-top: 1em">In other words, raising the
volume by +4 dB does not cause any clipping, raising it by
+5 dB causes clipping for 6 samples, etc.</p>

<p style="margin-top: 1em">AUDIO SOURCES <br>
Below is a description of the currently available audio
sources.</p>

<p style="margin-top: 1em">abuffer <br>
Buffer audio frames, and make them available to the filter
chain.</p>

<p style="margin-top: 1em">This source is mainly intended
for a programmatic use, in particular through the interface
defined in libavfilter/asrc_abuffer.h.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">time_base <br>
The timebase which will be used for timestamps of submitted
frames. It must be either a floating-point number or in
numerator/denominator form.</p>

<p style="margin-top: 1em">sample_rate <br>
The sample rate of the incoming audio buffers.</p>

<p style="margin-top: 1em">sample_fmt <br>
The sample format of the incoming audio buffers. Either a
sample format name or its corresponding integer
representation from the enum AVSampleFormat in <br>
libavutil/samplefmt.h</p>

<p style="margin-top: 1em">channel_layout <br>
The channel layout of the incoming audio buffers. Either a
channel layout name from channel_layout_map in
libavutil/channel_layout.c or its corresponding integer <br>
representation from the AV_CH_LAYOUT_* macros in
libavutil/channel_layout.h</p>

<p style="margin-top: 1em">channels <br>
The number of channels of the incoming audio buffers. If
both channels and channel_layout are specified, then they
must be consistent.</p>

<p style="margin-top: 1em">Examples</p>


<p style="margin-top: 1em">abuffer=sample_rate=44100:sample_fmt=s16p:channel_layout=stereo</p>

<p style="margin-top: 1em">will instruct the source to
accept planar 16bit signed stereo at 44100Hz. Since the
sample format with name &quot;s16p&quot; corresponds to the
number 6 and the &quot;stereo&quot; channel layout <br>
corresponds to the value 0x3, this is equivalent to:</p>


<p style="margin-top: 1em">abuffer=sample_rate=44100:sample_fmt=6:channel_layout=0x3</p>

<p style="margin-top: 1em">aevalsrc <br>
Generate an audio signal specified by an expression.</p>

<p style="margin-top: 1em">This source accepts in input one
or more expressions (one for each channel), which are
evaluated and used to generate a corresponding audio
signal.</p>

<p style="margin-top: 1em">This source accepts the
following options:</p>

<p style="margin-top: 1em">exprs <br>
Set the &rsquo;|&rsquo;-separated expressions list for each
separate channel. In case the channel_layout option is not
specified, the selected channel layout depends on the number
of <br>
provided expressions. Otherwise the last specified
expression is applied to the remaining output channels.</p>

<p style="margin-top: 1em">channel_layout, c <br>
Set the channel layout. The number of channels in the
specified layout must be equal to the number of specified
expressions.</p>

<p style="margin-top: 1em">duration, d <br>
Set the minimum duration of the sourced audio. See the Time
duration section in the ffmpeg-utils(1) manual for the
accepted syntax. Note that the resulting duration may be
<br>
greater than the specified duration, as the generated audio
is always cut at the end of a complete frame.</p>

<p style="margin-top: 1em">If not specified, or the
expressed duration is negative, the audio is supposed to be
generated forever.</p>

<p style="margin-top: 1em">nb_samples, n <br>
Set the number of samples per channel per each output frame,
default to 1024.</p>

<p style="margin-top: 1em">sample_rate, s <br>
Specify the sample rate, default to 44100.</p>

<p style="margin-top: 1em">Each expression in exprs can
contain the following constants:</p>

<p style="margin-top: 1em">n number of the evaluated
sample, starting from 0</p>

<p style="margin-top: 1em">t time of the evaluated sample
expressed in seconds, starting from 0</p>

<p style="margin-top: 1em">s sample rate</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate
silence:</p>

<p style="margin-top: 1em">aevalsrc=0</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a sin
signal with frequency of 440 Hz, set sample rate to 8000
Hz:</p>


<p style="margin-top: 1em">aevalsrc=&quot;sin(440*2*PI*t):s=8000&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a two
channels signal, specify the channel layout (Front Center +
Back Center) explicitly:</p>


<p style="margin-top: 1em">aevalsrc=&quot;sin(420*2*PI*t)|cos(430*2*PI*t):c=FC|BC&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate white
noise:</p>


<p style="margin-top: 1em">aevalsrc=&quot;-2+random(0)&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate an
amplitude modulated signal:</p>


<p style="margin-top: 1em">aevalsrc=&quot;sin(10*2*PI*t)*sin(880*2*PI*t)&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate 2.5 Hz
binaural beats on a 360 Hz carrier:</p>


<p style="margin-top: 1em">aevalsrc=&quot;0.1*sin(2*PI*(360-2.5/2)*t)
| 0.1*sin(2*PI*(360+2.5/2)*t)&quot;</p>

<p style="margin-top: 1em">anullsrc <br>
The null audio source, return unprocessed audio frames. It
is mainly useful as a template and to be employed in
analysis / debugging tools, or as the source for filters
which <br>
ignore the input data (for example the sox synth
filter).</p>

<p style="margin-top: 1em">This source accepts the
following options:</p>

<p style="margin-top: 1em">channel_layout, cl <br>
Specifies the channel layout, and can be either an integer
or a string representing a channel layout. The default value
of channel_layout is &quot;stereo&quot;.</p>

<p style="margin-top: 1em">Check the channel_layout_map
definition in libavutil/channel_layout.c for the mapping
between strings and channel layout values.</p>

<p style="margin-top: 1em">sample_rate, r <br>
Specifies the sample rate, and defaults to 44100.</p>

<p style="margin-top: 1em">nb_samples, n <br>
Set the number of samples per requested frames.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Set the sample
rate to 48000 Hz and the channel layout to
AV_CH_LAYOUT_MONO.</p>

<p style="margin-top: 1em">anullsrc=r=48000:cl=4</p>

<p style="margin-top: 1em">&Acirc;&middot; Do the same
operation with a more obvious syntax:</p>

<p style="margin-top: 1em">anullsrc=r=48000:cl=mono</p>

<p style="margin-top: 1em">All the parameters need to be
explicitly defined.</p>

<p style="margin-top: 1em">flite <br>
Synthesize a voice utterance using the libflite library.</p>

<p style="margin-top: 1em">To enable compilation of this
filter you need to configure FFmpeg with
&quot;--enable-libflite&quot;.</p>

<p style="margin-top: 1em">Note that the flite library is
not thread-safe.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">list_voices <br>
If set to 1, list the names of the available voices and exit
immediately. Default value is 0.</p>

<p style="margin-top: 1em">nb_samples, n <br>
Set the maximum number of samples per frame. Default value
is 512.</p>

<p style="margin-top: 1em">textfile <br>
Set the filename containing the text to speak.</p>

<p style="margin-top: 1em">text <br>
Set the text to speak.</p>

<p style="margin-top: 1em">voice, v <br>
Set the voice to use for the speech synthesis. Default value
is &quot;kal&quot;. See also the list_voices option.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Read from file
speech.txt, and synthesize the text using the standard flite
voice:</p>

<p style="margin-top: 1em">flite=textfile=speech.txt</p>

<p style="margin-top: 1em">&Acirc;&middot; Read the
specified text selecting the &quot;slt&quot; voice:</p>

<p style="margin-top: 1em">flite=text=&rsquo;So fare thee
well, poor devil of a Sub-Sub, whose commentator I
am&rsquo;:voice=slt</p>

<p style="margin-top: 1em">&Acirc;&middot; Input text to
ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -f lavfi -i
flite=text=&rsquo;So fare thee well, poor devil of a
Sub-Sub, whose commentator I am&rsquo;:voice=slt</p>

<p style="margin-top: 1em">&Acirc;&middot; Make ffplay
speak the specified text, using &quot;flite&quot; and the
&quot;lavfi&quot; device:</p>

<p style="margin-top: 1em">ffplay -f lavfi
flite=text=&rsquo;No more be grieved for which that thou
hast done.&rsquo;</p>

<p style="margin-top: 1em">For more information about
libflite, check:
&lt;http://www.speech.cs.cmu.edu/flite/&gt;</p>

<p style="margin-top: 1em">anoisesrc <br>
Generate a noise audio signal.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">sample_rate, r <br>
Specify the sample rate. Default value is 48000 Hz.</p>

<p style="margin-top: 1em">amplitude, a <br>
Specify the amplitude (0.0 - 1.0) of the generated audio
stream. Default value is 1.0.</p>

<p style="margin-top: 1em">duration, d <br>
Specify the duration of the generated audio stream. Not
specifying this option results in noise with an infinite
length.</p>

<p style="margin-top: 1em">color, colour, c <br>
Specify the color of noise. Available noise colors are
white, pink, and brown. Default color is white.</p>

<p style="margin-top: 1em">seed, s <br>
Specify a value used to seed the PRNG.</p>

<p style="margin-top: 1em">nb_samples, n <br>
Set the number of samples per each output frame, default is
1024.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate 60
seconds of pink noise, with a 44.1 kHz sampling rate and an
amplitude of 0.5:</p>


<p style="margin-top: 1em">anoisesrc=d=60:c=pink:r=44100:a=0.5</p>

<p style="margin-top: 1em">sine <br>
Generate an audio signal made of a sine wave with amplitude
1/8.</p>

<p style="margin-top: 1em">The audio signal is
bit-exact.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">frequency, f <br>
Set the carrier frequency. Default is 440 Hz.</p>

<p style="margin-top: 1em">beep_factor, b <br>
Enable a periodic beep every second with frequency
beep_factor times the carrier frequency. Default is 0,
meaning the beep is disabled.</p>

<p style="margin-top: 1em">sample_rate, r <br>
Specify the sample rate, default is 44100.</p>

<p style="margin-top: 1em">duration, d <br>
Specify the duration of the generated audio stream.</p>

<p style="margin-top: 1em">samples_per_frame <br>
Set the number of samples per output frame.</p>

<p style="margin-top: 1em">The expression can contain the
following constants:</p>

<p style="margin-top: 1em">n The (sequential) number of the
output audio frame, starting from 0.</p>

<p style="margin-top: 1em">pts The PTS (Presentation
TimeStamp) of the output audio frame, expressed in TB
units.</p>

<p style="margin-top: 1em">t The PTS of the output audio
frame, expressed in seconds.</p>

<p style="margin-top: 1em">TB The timebase of the output
audio frames.</p>

<p style="margin-top: 1em">Default is 1024.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a
simple 440 Hz sine wave:</p>

<p style="margin-top: 1em">sine</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a 220
Hz sine wave with a 880 Hz beep each second, for 5
seconds:</p>

<p style="margin-top: 1em">sine=220:4:d=5 <br>
sine=f=220:b=4:d=5 <br>
sine=frequency=220:beep_factor=4:duration=5</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a 1 kHz
sine wave following &quot;1602,1601,1602,1601,1602&quot;
NTSC pattern:</p>


<p style="margin-top: 1em">sine=1000:samples_per_frame=&rsquo;st(0,mod(n,5));
1602-not(not(eq(ld(0),1)+eq(ld(0),3)))&rsquo;</p>

<p style="margin-top: 1em">AUDIO SINKS <br>
Below is a description of the currently available audio
sinks.</p>

<p style="margin-top: 1em">abuffersink <br>
Buffer audio frames, and make them available to the end of
filter chain.</p>

<p style="margin-top: 1em">This sink is mainly intended for
programmatic use, in particular through the interface
defined in libavfilter/buffersink.h or the options
system.</p>

<p style="margin-top: 1em">It accepts a pointer to an
AVABufferSinkContext structure, which defines the incoming
buffers&rsquo; formats, to be passed as the opaque parameter
to &quot;avfilter_init_filter&quot; for <br>
initialization.</p>

<p style="margin-top: 1em">anullsink <br>
Null audio sink; do absolutely nothing with the input audio.
It is mainly useful as a template and for use in analysis /
debugging tools.</p>

<p style="margin-top: 1em">VIDEO FILTERS <br>
When you configure your FFmpeg build, you can disable any of
the existing filters using &quot;--disable-filters&quot;.
The configure output will show the video filters included in
your <br>
build.</p>

<p style="margin-top: 1em">Below is a description of the
currently available video filters.</p>

<p style="margin-top: 1em">alphaextract <br>
Extract the alpha component from the input as a grayscale
video. This is especially useful with the alphamerge
filter.</p>

<p style="margin-top: 1em">alphamerge <br>
Add or replace the alpha component of the primary input with
the grayscale value of a second input. This is intended for
use with alphaextract to allow the transmission or <br>
storage of frame sequences that have alpha in a format that
doesn&rsquo;t support an alpha channel.</p>

<p style="margin-top: 1em">For example, to reconstruct full
frames from a normal YUV-encoded video and a separate video
created with alphaextract, you might use:</p>

<p style="margin-top: 1em">movie=in_alpha.mkv [alpha];
[in][alpha] alphamerge [out]</p>

<p style="margin-top: 1em">Since this filter is designed
for reconstruction, it operates on frame sequences without
considering timestamps, and terminates when either input
reaches end of stream. This will <br>
cause problems if your encoding pipeline drops frames. If
you&rsquo;re trying to apply an image as an overlay to a
video stream, consider the overlay filter instead.</p>

<p style="margin-top: 1em">ass <br>
Same as the subtitles filter, except that it doesn&rsquo;t
require libavcodec and libavformat to work. On the other
hand, it is limited to ASS (Advanced Substation Alpha)
subtitles <br>
files.</p>

<p style="margin-top: 1em">This filter accepts the
following option in addition to the common options from the
subtitles filter:</p>

<p style="margin-top: 1em">shaping <br>
Set the shaping engine</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">auto <br>
The default libass shaping engine, which is the best
available.</p>

<p style="margin-top: 1em">simple <br>
Fast, font-agnostic shaper that can do only
substitutions</p>

<p style="margin-top: 1em">complex <br>
Slower shaper using OpenType for substitutions and
positioning</p>

<p style="margin-top: 1em">The default is
&quot;auto&quot;.</p>

<p style="margin-top: 1em">atadenoise <br>
Apply an Adaptive Temporal Averaging Denoiser to the video
input.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">0a Set threshold A for 1st
plane. Default is 0.02. Valid range is 0 to 0.3.</p>

<p style="margin-top: 1em">0b Set threshold B for 1st
plane. Default is 0.04. Valid range is 0 to 5.</p>

<p style="margin-top: 1em">1a Set threshold A for 2nd
plane. Default is 0.02. Valid range is 0 to 0.3.</p>

<p style="margin-top: 1em">1b Set threshold B for 2nd
plane. Default is 0.04. Valid range is 0 to 5.</p>

<p style="margin-top: 1em">2a Set threshold A for 3rd
plane. Default is 0.02. Valid range is 0 to 0.3.</p>

<p style="margin-top: 1em">2b Set threshold B for 3rd
plane. Default is 0.04. Valid range is 0 to 5.</p>

<p style="margin-top: 1em">Threshold A is designed to react
on abrupt changes in the input signal and threshold B is
designed to react on continuous changes in the input
signal.</p>

<p style="margin-top: 1em">s Set number of frames filter
will use for averaging. Default is 33. Must be odd number in
range [5, 129].</p>

<p style="margin-top: 1em">p Set what planes of frame
filter will use for averaging. Default is all.</p>

<p style="margin-top: 1em">avgblur <br>
Apply average blur filter.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">sizeX <br>
Set horizontal kernel size.</p>

<p style="margin-top: 1em">planes <br>
Set which planes to filter. By default all planes are
filtered.</p>

<p style="margin-top: 1em">sizeY <br>
Set vertical kernel size, if zero it will be same as
&quot;sizeX&quot;. Default is 0.</p>

<p style="margin-top: 1em">bbox <br>
Compute the bounding box for the non-black pixels in the
input frame luminance plane.</p>

<p style="margin-top: 1em">This filter computes the
bounding box containing all the pixels with a luminance
value greater than the minimum allowed value. The parameters
describing the bounding box are <br>
printed on the filter log.</p>

<p style="margin-top: 1em">The filter accepts the following
option:</p>

<p style="margin-top: 1em">min_val <br>
Set the minimal luminance value. Default is 16.</p>

<p style="margin-top: 1em">bitplanenoise <br>
Show and measure bit plane noise.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">bitplane <br>
Set which plane to analyze. Default is 1.</p>

<p style="margin-top: 1em">filter <br>
Filter out noisy pixels from &quot;bitplane&quot; set above.
Default is disabled.</p>

<p style="margin-top: 1em">blackdetect <br>
Detect video intervals that are (almost) completely black.
Can be useful to detect chapter transitions, commercials, or
invalid recordings. Output lines contains the time for the
<br>
start, end and duration of the detected black interval
expressed in seconds.</p>

<p style="margin-top: 1em">In order to display the output
lines, you need to set the loglevel at least to the
AV_LOG_INFO value.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">black_min_duration, d <br>
Set the minimum detected black duration expressed in
seconds. It must be a non-negative floating point
number.</p>

<p style="margin-top: 1em">Default value is 2.0.</p>

<p style="margin-top: 1em">picture_black_ratio_th, pic_th
<br>
Set the threshold for considering a picture
&quot;black&quot;. Express the minimum value for the
ratio:</p>

<p style="margin-top: 1em">&lt;nb_black_pixels&gt; /
&lt;nb_pixels&gt;</p>

<p style="margin-top: 1em">for which a picture is
considered black. Default value is 0.98.</p>

<p style="margin-top: 1em">pixel_black_th, pix_th <br>
Set the threshold for considering a pixel
&quot;black&quot;.</p>

<p style="margin-top: 1em">The threshold expresses the
maximum pixel luminance value for which a pixel is
considered &quot;black&quot;. The provided value is scaled
according to the following equation:</p>

<p style="margin-top: 1em">&lt;absolute_threshold&gt; =
&lt;luminance_minimum_value&gt; + &lt;pixel_black_th&gt; *
&lt;luminance_range_size&gt;</p>

<p style="margin-top: 1em">luminance_range_size and
luminance_minimum_value depend on the input video format,
the range is [0-255] for YUV full-range formats and [16-235]
for YUV non full-range <br>
formats.</p>

<p style="margin-top: 1em">Default value is 0.10.</p>

<p style="margin-top: 1em">The following example sets the
maximum pixel threshold to the minimum value, and detects
only black intervals of 2 or more seconds:</p>

<p style="margin-top: 1em">blackdetect=d=2:pix_th=0.00</p>

<p style="margin-top: 1em">blackframe <br>
Detect frames that are (almost) completely black. Can be
useful to detect chapter transitions or commercials. Output
lines consist of the frame number of the detected frame, the
<br>
percentage of blackness, the position in the file if known
or -1 and the timestamp in seconds.</p>

<p style="margin-top: 1em">In order to display the output
lines, you need to set the loglevel at least to the
AV_LOG_INFO value.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">amount <br>
The percentage of the pixels that have to be below the
threshold; it defaults to 98.</p>

<p style="margin-top: 1em">threshold, thresh <br>
The threshold below which a pixel value is considered black;
it defaults to 32.</p>

<p style="margin-top: 1em">blend, tblend <br>
Blend two video frames into each other.</p>

<p style="margin-top: 1em">The &quot;blend&quot; filter
takes two input streams and outputs one stream, the first
input is the &quot;top&quot; layer and second input is
&quot;bottom&quot; layer. By default, the output terminates
when <br>
the longest input terminates.</p>

<p style="margin-top: 1em">The &quot;tblend&quot; (time
blend) filter takes two consecutive frames from one single
stream, and outputs the result obtained by blending the new
frame on top of the old frame.</p>

<p style="margin-top: 1em">A description of the accepted
options follows.</p>

<p style="margin-top: 1em">c0_mode <br>
c1_mode <br>
c2_mode <br>
c3_mode <br>
all_mode <br>
Set blend mode for specific pixel component or all pixel
components in case of all_mode. Default value is
&quot;normal&quot;.</p>

<p style="margin-top: 1em">Available values for component
modes are:</p>

<p style="margin-top: 1em">addition <br>
addition128 <br>
and <br>
average <br>
burn <br>
darken <br>
difference <br>
difference128 <br>
divide <br>
dodge <br>
freeze <br>
exclusion <br>
glow <br>
hardlight <br>
hardmix <br>
heat <br>
lighten <br>
linearlight <br>
multiply <br>
multiply128 <br>
negation <br>
normal <br>
or <br>
overlay <br>
phoenix <br>
pinlight <br>
reflect <br>
screen <br>
softlight <br>
subtract <br>
vividlight <br>
xor <br>
c0_opacity <br>
c1_opacity <br>
c2_opacity <br>
c3_opacity <br>
all_opacity <br>
Set blend opacity for specific pixel component or all pixel
components in case of all_opacity. Only used in combination
with pixel component blend modes.</p>

<p style="margin-top: 1em">c0_expr <br>
c1_expr <br>
c2_expr <br>
c3_expr <br>
all_expr <br>
Set blend expression for specific pixel component or all
pixel components in case of all_expr. Note that related mode
options will be ignored if those are set.</p>

<p style="margin-top: 1em">The expressions can use the
following variables:</p>

<p style="margin-top: 1em">N The sequential number of the
filtered frame, starting from 0.</p>

<p style="margin-top: 1em">X <br>
Y the coordinates of the current sample</p>

<p style="margin-top: 1em">W <br>
H the width and height of currently filtered plane</p>

<p style="margin-top: 1em">SW <br>
SH Width and height scale depending on the currently
filtered plane. It is the ratio between the corresponding
luma plane number of pixels and the current plane ones. E.g.
<br>
for YUV4:2:0 the values are &quot;1,1&quot; for the luma
plane, and &quot;0.5,0.5&quot; for chroma planes.</p>

<p style="margin-top: 1em">T Time of the current frame,
expressed in seconds.</p>

<p style="margin-top: 1em">TOP, A <br>
Value of pixel component at current location for first video
frame (top layer).</p>

<p style="margin-top: 1em">BOTTOM, B <br>
Value of pixel component at current location for second
video frame (bottom layer).</p>

<p style="margin-top: 1em">shortest <br>
Force termination when the shortest input terminates.
Default is 0. This option is only defined for the
&quot;blend&quot; filter.</p>

<p style="margin-top: 1em">repeatlast <br>
Continue applying the last bottom frame after the end of the
stream. A value of 0 disable the filter after the last frame
of the bottom layer is reached. Default is 1. This <br>
option is only defined for the &quot;blend&quot; filter.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply transition
from bottom layer to top layer in first 10 seconds:</p>


<p style="margin-top: 1em">blend=all_expr=&rsquo;A*(if(gte(T,10),1,T/10))+B*(1-(if(gte(T,10),1,T/10)))&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply 1x1
checkerboard effect:</p>


<p style="margin-top: 1em">blend=all_expr=&rsquo;if(eq(mod(X,2),mod(Y,2)),A,B)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply uncover
left effect:</p>


<p style="margin-top: 1em">blend=all_expr=&rsquo;if(gte(N*SW+X,W),A,B)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply uncover
down effect:</p>


<p style="margin-top: 1em">blend=all_expr=&rsquo;if(gte(Y-N*SH,0),A,B)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply uncover
up-left effect:</p>


<p style="margin-top: 1em">blend=all_expr=&rsquo;if(gte(T*SH*40+Y,H)*gte((T*40*SW+X)*W/H,W),A,B)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Split diagonally
video and shows top and bottom layer on each side:</p>


<p style="margin-top: 1em">blend=all_expr=if(gt(X,Y*(W/H)),A,B)</p>

<p style="margin-top: 1em">&Acirc;&middot; Display
differences between the current and the previous frame:</p>


<p style="margin-top: 1em">tblend=all_mode=difference128</p>

<p style="margin-top: 1em">boxblur <br>
Apply a boxblur algorithm to the input video.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">luma_radius, lr <br>
luma_power, lp <br>
chroma_radius, cr <br>
chroma_power, cp <br>
alpha_radius, ar <br>
alpha_power, ap</p>

<p style="margin-top: 1em">A description of the accepted
options follows.</p>

<p style="margin-top: 1em">luma_radius, lr <br>
chroma_radius, cr <br>
alpha_radius, ar <br>
Set an expression for the box radius in pixels used for
blurring the corresponding input plane.</p>

<p style="margin-top: 1em">The radius value must be a
non-negative number, and must not be greater than the value
of the expression &quot;min(w,h)/2&quot; for the luma and
alpha planes, and of &quot;min(cw,ch)/2&quot; for <br>
the chroma planes.</p>

<p style="margin-top: 1em">Default value for luma_radius is
&quot;2&quot;. If not specified, chroma_radius and
alpha_radius default to the corresponding value set for
luma_radius.</p>

<p style="margin-top: 1em">The expressions can contain the
following constants:</p>

<p style="margin-top: 1em">w <br>
h The input width and height in pixels.</p>

<p style="margin-top: 1em">cw <br>
ch The input chroma image width and height in pixels.</p>

<p style="margin-top: 1em">hsub <br>
vsub <br>
The horizontal and vertical chroma subsample values. For
example, for the pixel format &quot;yuv422p&quot;, hsub is 2
and vsub is 1.</p>

<p style="margin-top: 1em">luma_power, lp <br>
chroma_power, cp <br>
alpha_power, ap <br>
Specify how many times the boxblur filter is applied to the
corresponding plane.</p>

<p style="margin-top: 1em">Default value for luma_power is
2. If not specified, chroma_power and alpha_power default to
the corresponding value set for luma_power.</p>

<p style="margin-top: 1em">A value of 0 will disable the
effect.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply a boxblur
filter with the luma, chroma, and alpha radii set to 2:</p>


<p style="margin-top: 1em">boxblur=luma_radius=2:luma_power=1
<br>
boxblur=2:1</p>

<p style="margin-top: 1em">&Acirc;&middot; Set the luma
radius to 2, and alpha and chroma radius to 0:</p>

<p style="margin-top: 1em">boxblur=2:1:cr=0:ar=0</p>

<p style="margin-top: 1em">&Acirc;&middot; Set the luma and
chroma radii to a fraction of the video dimension:</p>


<p style="margin-top: 1em">boxblur=luma_radius=min(hw)/10:luma_power=1:chroma_radius=min(cwch)/10:chroma_power=1</p>

<p style="margin-top: 1em">bwdif <br>
Deinterlace the input video (&quot;bwdif&quot; stands for
&quot;Bob Weaver Deinterlacing Filter&quot;).</p>

<p style="margin-top: 1em">Motion adaptive deinterlacing
based on yadif with the use of w3fdif and cubic
interpolation algorithms. It accepts the following
parameters:</p>

<p style="margin-top: 1em">mode <br>
The interlacing mode to adopt. It accepts one of the
following values:</p>

<p style="margin-top: 1em">0, send_frame <br>
Output one frame for each frame.</p>

<p style="margin-top: 1em">1, send_field <br>
Output one frame for each field.</p>

<p style="margin-top: 1em">The default value is
&quot;send_field&quot;.</p>

<p style="margin-top: 1em">parity <br>
The picture field parity assumed for the input interlaced
video. It accepts one of the following values:</p>

<p style="margin-top: 1em">0, tff <br>
Assume the top field is first.</p>

<p style="margin-top: 1em">1, bff <br>
Assume the bottom field is first.</p>

<p style="margin-top: 1em">-1, auto <br>
Enable automatic detection of field parity.</p>

<p style="margin-top: 1em">The default value is
&quot;auto&quot;. If the interlacing is unknown or the
decoder does not export this information, top field first
will be assumed.</p>

<p style="margin-top: 1em">deint <br>
Specify which frames to deinterlace. Accept one of the
following values:</p>

<p style="margin-top: 1em">0, all <br>
Deinterlace all frames.</p>

<p style="margin-top: 1em">1, interlaced <br>
Only deinterlace frames marked as interlaced.</p>

<p style="margin-top: 1em">The default value is
&quot;all&quot;.</p>

<p style="margin-top: 1em">chromakey <br>
YUV colorspace color/chroma keying.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">color <br>
The color which will be replaced with transparency.</p>

<p style="margin-top: 1em">similarity <br>
Similarity percentage with the key color.</p>

<p style="margin-top: 1em">0.01 matches only the exact key
color, while 1.0 matches everything.</p>

<p style="margin-top: 1em">blend <br>
Blend percentage.</p>

<p style="margin-top: 1em">0.0 makes pixels either fully
transparent, or not transparent at all.</p>

<p style="margin-top: 1em">Higher values result in
semi-transparent pixels, with a higher transparency the more
similar the pixels color is to the key color.</p>

<p style="margin-top: 1em">yuv Signals that the color
passed is already in YUV instead of RGB.</p>

<p style="margin-top: 1em">Litteral colors like
&quot;green&quot; or &quot;red&quot; don&rsquo;t make sense
with this enabled anymore. This can be used to pass exact
YUV values as hexadecimal numbers.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Make every green
pixel in the input image transparent:</p>

<p style="margin-top: 1em">ffmpeg -i input.png -vf
chromakey=green out.png</p>

<p style="margin-top: 1em">&Acirc;&middot; Overlay a
greenscreen-video on top of a static black background.</p>

<p style="margin-top: 1em">ffmpeg -f lavfi -i
color=c=black:s=1280x720 -i video.mp4 -shortest
-filter_complex
&quot;[1:v]chromakey=0x70de77:0.1:0.2[ckout];[0:v][ckout]overlay[out]&quot;
-map &quot;[out]&quot; output.mkv</p>

<p style="margin-top: 1em">ciescope <br>
Display CIE color diagram with pixels overlaid onto it.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">system <br>
Set color system.</p>

<p style="margin-top: 1em">ntsc, 470m <br>
ebu, 470bg <br>
smpte <br>
240m <br>
apple <br>
widergb <br>
cie1931 <br>
rec709, hdtv <br>
uhdtv, rec2020 <br>
cie Set CIE system.</p>

<p style="margin-top: 1em">xyy <br>
ucs <br>
luv <br>
gamuts <br>
Set what gamuts to draw.</p>

<p style="margin-top: 1em">See &quot;system&quot; option
for available values.</p>

<p style="margin-top: 1em">size, s <br>
Set ciescope size, by default set to 512.</p>

<p style="margin-top: 1em">intensity, i <br>
Set intensity used to map input pixel values to CIE
diagram.</p>

<p style="margin-top: 1em">contrast <br>
Set contrast used to draw tongue colors that are out of
active color system gamut.</p>

<p style="margin-top: 1em">corrgamma <br>
Correct gamma displayed on scope, by default enabled.</p>

<p style="margin-top: 1em">showwhite <br>
Show white point on CIE diagram, by default disabled.</p>

<p style="margin-top: 1em">gamma <br>
Set input gamma. Used only with XYZ input color space.</p>

<p style="margin-top: 1em">codecview <br>
Visualize information exported by some codecs.</p>

<p style="margin-top: 1em">Some codecs can export
information through frames using side-data or other means.
For example, some MPEG based codecs export motion vectors
through the export_mvs flag in the <br>
codec flags2 option.</p>

<p style="margin-top: 1em">The filter accepts the following
option:</p>

<p style="margin-top: 1em">mv Set motion vectors to
visualize.</p>

<p style="margin-top: 1em">Available flags for mv are:</p>

<p style="margin-top: 1em">pf forward predicted MVs of
P-frames</p>

<p style="margin-top: 1em">bf forward predicted MVs of
B-frames</p>

<p style="margin-top: 1em">bb backward predicted MVs of
B-frames</p>

<p style="margin-top: 1em">qp Display quantization
parameters using the chroma planes.</p>

<p style="margin-top: 1em">mv_type, mvt <br>
Set motion vectors type to visualize. Includes MVs from all
frames unless specified by frame_type option.</p>

<p style="margin-top: 1em">Available flags for mv_type
are:</p>

<p style="margin-top: 1em">fp forward predicted MVs</p>

<p style="margin-top: 1em">bp backward predicted MVs</p>

<p style="margin-top: 1em">frame_type, ft <br>
Set frame type to visualize motion vectors of.</p>

<p style="margin-top: 1em">Available flags for frame_type
are:</p>

<p style="margin-top: 1em">if intra-coded frames
(I-frames)</p>

<p style="margin-top: 1em">pf predicted frames
(P-frames)</p>

<p style="margin-top: 1em">bf bi-directionally predicted
frames (B-frames)</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Visualize
forward predicted MVs of all frames using ffplay:</p>

<p style="margin-top: 1em">ffplay -flags2 +export_mvs
input.mp4 -vf codecview=mv_type=fp</p>

<p style="margin-top: 1em">&Acirc;&middot; Visualize
multi-directionals MVs of P and B-Frames using ffplay:</p>

<p style="margin-top: 1em">ffplay -flags2 +export_mvs
input.mp4 -vf codecview=mv=pf+bf+bb</p>

<p style="margin-top: 1em">colorbalance <br>
Modify intensity of primary colors (red, green and blue) of
input frames.</p>

<p style="margin-top: 1em">The filter allows an input frame
to be adjusted in the shadows, midtones or highlights
regions for the red-cyan, green-magenta or blue-yellow
balance.</p>

<p style="margin-top: 1em">A positive adjustment value
shifts the balance towards the primary color, a negative
value towards the complementary color.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">rs <br>
gs <br>
bs Adjust red, green and blue shadows (darkest pixels).</p>

<p style="margin-top: 1em">rm <br>
gm <br>
bm Adjust red, green and blue midtones (medium pixels).</p>

<p style="margin-top: 1em">rh <br>
gh <br>
bh Adjust red, green and blue highlights (brightest
pixels).</p>

<p style="margin-top: 1em">Allowed ranges for options are
&quot;[-1.0, 1.0]&quot;. Defaults are 0.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Add red color
cast to shadows:</p>

<p style="margin-top: 1em">colorbalance=rs=.3</p>

<p style="margin-top: 1em">colorkey <br>
RGB colorspace color keying.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">color <br>
The color which will be replaced with transparency.</p>

<p style="margin-top: 1em">similarity <br>
Similarity percentage with the key color.</p>

<p style="margin-top: 1em">0.01 matches only the exact key
color, while 1.0 matches everything.</p>

<p style="margin-top: 1em">blend <br>
Blend percentage.</p>

<p style="margin-top: 1em">0.0 makes pixels either fully
transparent, or not transparent at all.</p>

<p style="margin-top: 1em">Higher values result in
semi-transparent pixels, with a higher transparency the more
similar the pixels color is to the key color.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Make every green
pixel in the input image transparent:</p>

<p style="margin-top: 1em">ffmpeg -i input.png -vf
colorkey=green out.png</p>

<p style="margin-top: 1em">&Acirc;&middot; Overlay a
greenscreen-video on top of a static background image.</p>

<p style="margin-top: 1em">ffmpeg -i background.png -i
video.mp4 -filter_complex
&quot;[1:v]colorkey=0x3BBD1E:0.3:0.2[ckout];[0:v][ckout]overlay[out]&quot;
-map &quot;[out]&quot; output.flv</p>

<p style="margin-top: 1em">colorlevels <br>
Adjust video input frames using levels.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">rimin <br>
gimin <br>
bimin <br>
aimin <br>
Adjust red, green, blue and alpha input black point. Allowed
ranges for options are &quot;[-1.0, 1.0]&quot;. Defaults are
0.</p>

<p style="margin-top: 1em">rimax <br>
gimax <br>
bimax <br>
aimax <br>
Adjust red, green, blue and alpha input white point. Allowed
ranges for options are &quot;[-1.0, 1.0]&quot;. Defaults are
1.</p>

<p style="margin-top: 1em">Input levels are used to lighten
highlights (bright tones), darken shadows (dark tones),
change the balance of bright and dark tones.</p>

<p style="margin-top: 1em">romin <br>
gomin <br>
bomin <br>
aomin <br>
Adjust red, green, blue and alpha output black point.
Allowed ranges for options are &quot;[0, 1.0]&quot;.
Defaults are 0.</p>

<p style="margin-top: 1em">romax <br>
gomax <br>
bomax <br>
aomax <br>
Adjust red, green, blue and alpha output white point.
Allowed ranges for options are &quot;[0, 1.0]&quot;.
Defaults are 1.</p>

<p style="margin-top: 1em">Output levels allows manual
selection of a constrained output level range.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Make video
output darker:</p>


<p style="margin-top: 1em">colorlevels=rimin=0.058:gimin=0.058:bimin=0.058</p>

<p style="margin-top: 1em">&Acirc;&middot; Increase
contrast:</p>


<p style="margin-top: 1em">colorlevels=rimin=0.039:gimin=0.039:bimin=0.039:rimax=0.96:gimax=0.96:bimax=0.96</p>

<p style="margin-top: 1em">&Acirc;&middot; Make video
output lighter:</p>


<p style="margin-top: 1em">colorlevels=rimax=0.902:gimax=0.902:bimax=0.902</p>

<p style="margin-top: 1em">&Acirc;&middot; Increase
brightness:</p>


<p style="margin-top: 1em">colorlevels=romin=0.5:gomin=0.5:bomin=0.5</p>

<p style="margin-top: 1em">colorchannelmixer <br>
Adjust video input frames by re-mixing color channels.</p>

<p style="margin-top: 1em">This filter modifies a color
channel by adding the values associated to the other
channels of the same pixels. For example if the value to
modify is red, the output value will <br>
be:</p>


<p style="margin-top: 1em">&lt;red&gt;=&lt;red&gt;*&lt;rr&gt;
+ &lt;blue&gt;*&lt;rb&gt; + &lt;green&gt;*&lt;rg&gt; +
&lt;alpha&gt;*&lt;ra&gt;</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">rr <br>
rg <br>
rb <br>
ra Adjust contribution of input red, green, blue and alpha
channels for output red channel. Default is 1 for rr, and 0
for rg, rb and ra.</p>

<p style="margin-top: 1em">gr <br>
gg <br>
gb <br>
ga Adjust contribution of input red, green, blue and alpha
channels for output green channel. Default is 1 for gg, and
0 for gr, gb and ga.</p>

<p style="margin-top: 1em">br <br>
bg <br>
bb <br>
ba Adjust contribution of input red, green, blue and alpha
channels for output blue channel. Default is 1 for bb, and 0
for br, bg and ba.</p>

<p style="margin-top: 1em">ar <br>
ag <br>
ab <br>
aa Adjust contribution of input red, green, blue and alpha
channels for output alpha channel. Default is 1 for aa, and
0 for ar, ag and ab.</p>

<p style="margin-top: 1em">Allowed ranges for options are
&quot;[-2.0, 2.0]&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Convert source
to grayscale:</p>


<p style="margin-top: 1em">colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3</p>

<p style="margin-top: 1em">&Acirc;&middot; Simulate sepia
tones:</p>


<p style="margin-top: 1em">colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131</p>

<p style="margin-top: 1em">colormatrix <br>
Convert color matrix.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">src <br>
dst Specify the source and destination color matrix. Both
values must be specified.</p>

<p style="margin-top: 1em">The accepted values are:</p>

<p style="margin-top: 1em">bt709 <br>
BT.709</p>

<p style="margin-top: 1em">bt601 <br>
BT.601</p>

<p style="margin-top: 1em">smpte240m <br>
SMPTE-240M</p>

<p style="margin-top: 1em">fcc FCC</p>

<p style="margin-top: 1em">bt2020 <br>
BT.2020</p>

<p style="margin-top: 1em">For example to convert from
BT.601 to SMPTE-240M, use the command:</p>

<p style="margin-top: 1em">colormatrix=bt601:smpte240m</p>

<p style="margin-top: 1em">colorspace <br>
Convert colorspace, transfer characteristics or color
primaries.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">all Specify all color properties
at once.</p>

<p style="margin-top: 1em">The accepted values are:</p>

<p style="margin-top: 1em">bt470m <br>
BT.470M</p>

<p style="margin-top: 1em">bt470bg <br>
BT.470BG</p>

<p style="margin-top: 1em">bt601-6-525 <br>
BT.601-6 525</p>

<p style="margin-top: 1em">bt601-6-625 <br>
BT.601-6 625</p>

<p style="margin-top: 1em">bt709 <br>
BT.709</p>

<p style="margin-top: 1em">smpte170m <br>
SMPTE-170M</p>

<p style="margin-top: 1em">smpte240m <br>
SMPTE-240M</p>

<p style="margin-top: 1em">bt2020 <br>
BT.2020</p>

<p style="margin-top: 1em">space <br>
Specify output colorspace.</p>

<p style="margin-top: 1em">The accepted values are:</p>

<p style="margin-top: 1em">bt709 <br>
BT.709</p>

<p style="margin-top: 1em">fcc FCC</p>

<p style="margin-top: 1em">bt470bg <br>
BT.470BG or BT.601-6 625</p>

<p style="margin-top: 1em">smpte170m <br>
SMPTE-170M or BT.601-6 525</p>

<p style="margin-top: 1em">smpte240m <br>
SMPTE-240M</p>

<p style="margin-top: 1em">bt2020ncl <br>
BT.2020 with non-constant luminance</p>

<p style="margin-top: 1em">trc Specify output transfer
characteristics.</p>

<p style="margin-top: 1em">The accepted values are:</p>

<p style="margin-top: 1em">bt709 <br>
BT.709</p>

<p style="margin-top: 1em">gamma22 <br>
Constant gamma of 2.2</p>

<p style="margin-top: 1em">gamma28 <br>
Constant gamma of 2.8</p>

<p style="margin-top: 1em">smpte170m <br>
SMPTE-170M, BT.601-6 625 or BT.601-6 525</p>

<p style="margin-top: 1em">smpte240m <br>
SMPTE-240M</p>

<p style="margin-top: 1em">bt2020-10 <br>
BT.2020 for 10-bits content</p>

<p style="margin-top: 1em">bt2020-12 <br>
BT.2020 for 12-bits content</p>

<p style="margin-top: 1em">primaries <br>
Specify output color primaries.</p>

<p style="margin-top: 1em">The accepted values are:</p>

<p style="margin-top: 1em">bt709 <br>
BT.709</p>

<p style="margin-top: 1em">bt470m <br>
BT.470M</p>

<p style="margin-top: 1em">bt470bg <br>
BT.470BG or BT.601-6 625</p>

<p style="margin-top: 1em">smpte170m <br>
SMPTE-170M or BT.601-6 525</p>

<p style="margin-top: 1em">smpte240m <br>
SMPTE-240M</p>

<p style="margin-top: 1em">bt2020 <br>
BT.2020</p>

<p style="margin-top: 1em">range <br>
Specify output color range.</p>

<p style="margin-top: 1em">The accepted values are:</p>

<p style="margin-top: 1em">mpeg <br>
MPEG (restricted) range</p>

<p style="margin-top: 1em">jpeg <br>
JPEG (full) range</p>

<p style="margin-top: 1em">format <br>
Specify output color format.</p>

<p style="margin-top: 1em">The accepted values are:</p>

<p style="margin-top: 1em">yuv420p <br>
YUV 4:2:0 planar 8-bits</p>

<p style="margin-top: 1em">yuv420p10 <br>
YUV 4:2:0 planar 10-bits</p>

<p style="margin-top: 1em">yuv420p12 <br>
YUV 4:2:0 planar 12-bits</p>

<p style="margin-top: 1em">yuv422p <br>
YUV 4:2:2 planar 8-bits</p>

<p style="margin-top: 1em">yuv422p10 <br>
YUV 4:2:2 planar 10-bits</p>

<p style="margin-top: 1em">yuv422p12 <br>
YUV 4:2:2 planar 12-bits</p>

<p style="margin-top: 1em">yuv444p <br>
YUV 4:4:4 planar 8-bits</p>

<p style="margin-top: 1em">yuv444p10 <br>
YUV 4:4:4 planar 10-bits</p>

<p style="margin-top: 1em">yuv444p12 <br>
YUV 4:4:4 planar 12-bits</p>

<p style="margin-top: 1em">fast <br>
Do a fast conversion, which skips gamma/primary correction.
This will take significantly less CPU, but will be
mathematically incorrect. To get output compatible with that
<br>
produced by the colormatrix filter, use fast=1.</p>

<p style="margin-top: 1em">dither <br>
Specify dithering mode.</p>

<p style="margin-top: 1em">The accepted values are:</p>

<p style="margin-top: 1em">none <br>
No dithering</p>

<p style="margin-top: 1em">fsb Floyd-Steinberg
dithering</p>

<p style="margin-top: 1em">wpadapt <br>
Whitepoint adaptation mode.</p>

<p style="margin-top: 1em">The accepted values are:</p>

<p style="margin-top: 1em">bradford <br>
Bradford whitepoint adaptation</p>

<p style="margin-top: 1em">vonkries <br>
von Kries whitepoint adaptation</p>

<p style="margin-top: 1em">identity <br>
identity whitepoint adaptation (i.e. no whitepoint
adaptation)</p>

<p style="margin-top: 1em">iall <br>
Override all input properties at once. Same accepted values
as all.</p>

<p style="margin-top: 1em">ispace <br>
Override input colorspace. Same accepted values as
space.</p>

<p style="margin-top: 1em">iprimaries <br>
Override input color primaries. Same accepted values as
primaries.</p>

<p style="margin-top: 1em">itrc <br>
Override input transfer characteristics. Same accepted
values as trc.</p>

<p style="margin-top: 1em">irange <br>
Override input color range. Same accepted values as
range.</p>

<p style="margin-top: 1em">The filter converts the transfer
characteristics, color space and color primaries to the
specified user values. The output value, if not specified,
is set to a default value <br>
based on the &quot;all&quot; property. If that property is
also not specified, the filter will log an error. The output
color range and format default to the same value as the
input color <br>
range and format. The input transfer characteristics, color
space, color primaries and color range should be set on the
input data. If any of these are missing, the filter will
<br>
log an error and no conversion will take place.</p>

<p style="margin-top: 1em">For example to convert the input
to SMPTE-240M, use the command:</p>

<p style="margin-top: 1em">colorspace=smpte240m</p>

<p style="margin-top: 1em">convolution <br>
Apply convolution 3x3 or 5x5 filter.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">0m <br>
1m <br>
2m <br>
3m Set matrix for each plane. Matrix is sequence of 9 or 25
signed integers.</p>

<p style="margin-top: 1em">0rdiv <br>
1rdiv <br>
2rdiv <br>
3rdiv <br>
Set multiplier for calculated value for each plane.</p>

<p style="margin-top: 1em">0bias <br>
1bias <br>
2bias <br>
3bias <br>
Set bias for each plane. This value is added to the result
of the multiplication. Useful for making the overall image
brighter or darker. Default is 0.0.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply
sharpen:</p>

<p style="margin-top: 1em">convolution=&quot;0 -1 0 -1 5 -1
0 -1 0:0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1
5 -1 0 -1 0&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply blur:</p>

<p style="margin-top: 1em">convolution=&quot;1 1 1 1 1 1 1
1 1:1 1 1 1 1 1 1 1 1:1 1 1 1 1 1 1 1 1:1 1 1 1 1 1 1 1
1:1/9:1/9:1/9:1/9&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply edge
enhance:</p>

<p style="margin-top: 1em">convolution=&quot;0 0 0 -1 1 0 0
0 0:0 0 0 -1 1 0 0 0 0:0 0 0 -1 1 0 0 0 0:0 0 0 -1 1 0 0 0
0:5:1:1:1:0:128:128:128&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply edge
detect:</p>

<p style="margin-top: 1em">convolution=&quot;0 1 0 1 -4 1 0
1 0:0 1 0 1 -4 1 0 1 0:0 1 0 1 -4 1 0 1 0:0 1 0 1 -4 1 0 1
0:5:5:5:1:0:128:128:128&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply
emboss:</p>

<p style="margin-top: 1em">convolution=&quot;-2 -1 0 -1 1 1
0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1
1 0 1 2&quot;</p>

<p style="margin-top: 1em">copy <br>
Copy the input source unchanged to the output. This is
mainly useful for testing purposes.</p>

<p style="margin-top: 1em">coreimage <br>
Video filtering on GPU using Apple&rsquo;s CoreImage API on
OSX.</p>

<p style="margin-top: 1em">Hardware acceleration is based
on an OpenGL context. Usually, this means it is processed by
video hardware. However, software-based OpenGL
implementations exist which means there <br>
is no guarantee for hardware processing. It depends on the
respective OSX.</p>

<p style="margin-top: 1em">There are many filters and image
generators provided by Apple that come with a large variety
of options. The filter has to be referenced by its name
along with its options.</p>

<p style="margin-top: 1em">The coreimage filter accepts the
following options:</p>

<p style="margin-top: 1em">list_filters <br>
List all available filters and generators along with all
their respective options as well as possible minimum and
maximum values along with the default values.</p>

<p style="margin-top: 1em">list_filters=true</p>

<p style="margin-top: 1em">filter <br>
Specify all filters by their respective name and options.
Use list_filters to determine all valid filter names and
options. Numerical options are specified by a float value
<br>
and are automatically clamped to their respective value
range. Vector and color options have to be specified by a
list of space separated float values. Character escaping
<br>
has to be done. A special option name &quot;default&quot; is
available to use default options for a filter.</p>

<p style="margin-top: 1em">It is required to specify either
&quot;default&quot; or at least one of the filter options.
All omitted options are used with their default values. The
syntax of the filter string is <br>
as follows:</p>


<p style="margin-top: 1em">filter=&lt;NAME&gt;@&lt;OPTION&gt;=&lt;VALUE&gt;[@&lt;OPTION&gt;=&lt;VALUE&gt;][@...][#&lt;NAME&gt;@&lt;OPTION&gt;=&lt;VALUE&gt;[@&lt;OPTION&gt;=&lt;VALUE&gt;][@...]][#...]</p>

<p style="margin-top: 1em">output_rect <br>
Specify a rectangle where the output of the filter chain is
copied into the input image. It is given by a list of space
separated float values:</p>


<p style="margin-top: 1em">output_rect=x&nbsp;y&nbsp;width&nbsp;height</p>

<p style="margin-top: 1em">If not given, the output
rectangle equals the dimensions of the input image. The
output rectangle is automatically cropped at the borders of
the input image. Negative values <br>
are valid for each component.</p>


<p style="margin-top: 1em">output_rect=25&nbsp;25&nbsp;100&nbsp;100</p>

<p style="margin-top: 1em">Several filters can be chained
for successive processing without GPU-HOST transfers
allowing for fast processing of complex filter chains.
Currently, only filters with zero <br>
(generators) or exactly one (filters) input image and one
output image are supported. Also, transition filters are not
yet usable as intended.</p>

<p style="margin-top: 1em">Some filters generate output
images with additional padding depending on the respective
filter kernel. The padding is automatically removed to
ensure the filter output has the <br>
same size as the input image.</p>

<p style="margin-top: 1em">For image generators, the size
of the output image is determined by the previous output
image of the filter chain or the input image of the whole
filterchain, respectively. The <br>
generators do not use the pixel information of this image to
generate their output. However, the generated output is
blended onto this image, resulting in partial or complete
<br>
coverage of the output image.</p>

<p style="margin-top: 1em">The coreimagesrc video source
can be used for generating input images which are directly
fed into the filter chain. By using it, providing input
images by another video source or <br>
an input video is not required.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; List all filters
available:</p>

<p style="margin-top: 1em">coreimage=list_filters=true</p>

<p style="margin-top: 1em">&Acirc;&middot; Use the
CIBoxBlur filter with default options to blur an image:</p>


<p style="margin-top: 1em">coreimage=filter=CIBoxBlur@default</p>

<p style="margin-top: 1em">&Acirc;&middot; Use a filter
chain with CISepiaTone at default values and
CIVignetteEffect with its center at 100x100 and a radius of
50 pixels:</p>


<p style="margin-top: 1em">coreimage=filter=CIBoxBlur@default#CIVignetteEffect@inputCenter=100&nbsp;100@inputRadius=50</p>

<p style="margin-top: 1em">&Acirc;&middot; Use nullsrc and
CIQRCodeGenerator to create a QR code for the FFmpeg
homepage, given as complete and escaped command-line for
Apple&rsquo;s standard bash shell:</p>

<p style="margin-top: 1em">ffmpeg -f lavfi -i
nullsrc=s=100x100,coreimage=filter=CIQRCodeGenerator@inputMessage=https\\
//FFmpeg.org/@inputCorrectionLevel=H -frames:v 1
QRCode.png</p>

<p style="margin-top: 1em">crop <br>
Crop the input video to given dimensions.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">w, out_w <br>
The width of the output video. It defaults to
&quot;iw&quot;. This expression is evaluated only once
during the filter configuration, or when the w or out_w
command is sent.</p>

<p style="margin-top: 1em">h, out_h <br>
The height of the output video. It defaults to
&quot;ih&quot;. This expression is evaluated only once
during the filter configuration, or when the h or out_h
command is sent.</p>

<p style="margin-top: 1em">x The horizontal position, in
the input video, of the left edge of the output video. It
defaults to &quot;(in_w-out_w)/2&quot;. This expression is
evaluated per-frame.</p>

<p style="margin-top: 1em">y The vertical position, in the
input video, of the top edge of the output video. It
defaults to &quot;(in_h-out_h)/2&quot;. This expression is
evaluated per-frame.</p>

<p style="margin-top: 1em">keep_aspect <br>
If set to 1 will force the output display aspect ratio to be
the same of the input, by changing the output sample aspect
ratio. It defaults to 0.</p>

<p style="margin-top: 1em">exact <br>
Enable exact cropping. If enabled, subsampled videos will be
cropped at exact width/height/x/y as specified and will not
be rounded to nearest smaller value. It defaults to <br>
0.</p>

<p style="margin-top: 1em">The out_w, out_h, x, y
parameters are expressions containing the following
constants:</p>

<p style="margin-top: 1em">x <br>
y The computed values for x and y. They are evaluated for
each new frame.</p>

<p style="margin-top: 1em">in_w <br>
in_h <br>
The input width and height.</p>

<p style="margin-top: 1em">iw <br>
ih These are the same as in_w and in_h.</p>

<p style="margin-top: 1em">out_w <br>
out_h <br>
The output (cropped) width and height.</p>

<p style="margin-top: 1em">ow <br>
oh These are the same as out_w and out_h.</p>

<p style="margin-top: 1em">a same as iw / ih</p>

<p style="margin-top: 1em">sar input sample aspect
ratio</p>

<p style="margin-top: 1em">dar input display aspect ratio,
it is the same as (iw / ih) * sar</p>

<p style="margin-top: 1em">hsub <br>
vsub <br>
horizontal and vertical chroma subsample values. For example
for the pixel format &quot;yuv422p&quot; hsub is 2 and vsub
is 1.</p>

<p style="margin-top: 1em">n The number of the input frame,
starting from 0.</p>

<p style="margin-top: 1em">pos the position in the file of
the input frame, NAN if unknown</p>

<p style="margin-top: 1em">t The timestamp expressed in
seconds. It&rsquo;s NAN if the input timestamp is
unknown.</p>

<p style="margin-top: 1em">The expression for out_w may
depend on the value of out_h, and the expression for out_h
may depend on out_w, but they cannot depend on x and y, as x
and y are evaluated after <br>
out_w and out_h.</p>

<p style="margin-top: 1em">The x and y parameters specify
the expressions for the position of the top-left corner of
the output (non-cropped) area. They are evaluated for each
frame. If the evaluated value <br>
is not valid, it is approximated to the nearest valid
value.</p>

<p style="margin-top: 1em">The expression for x may depend
on y, and the expression for y may depend on x.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Crop area with
size 100x100 at position (12,34).</p>

<p style="margin-top: 1em">crop=100:100:12:34</p>

<p style="margin-top: 1em">Using named options, the example
above becomes:</p>

<p style="margin-top: 1em">crop=w=100:h=100:x=12:y=34</p>

<p style="margin-top: 1em">&Acirc;&middot; Crop the central
input area with size 100x100:</p>

<p style="margin-top: 1em">crop=100:100</p>

<p style="margin-top: 1em">&Acirc;&middot; Crop the central
input area with size 2/3 of the input video:</p>

<p style="margin-top: 1em">crop=2/3*in_w:2/3*in_h</p>

<p style="margin-top: 1em">&Acirc;&middot; Crop the input
video central square:</p>

<p style="margin-top: 1em">crop=out_w=in_h <br>
crop=in_h</p>

<p style="margin-top: 1em">&Acirc;&middot; Delimit the
rectangle with the top-left corner placed at position
100:100 and the right-bottom corner corresponding to the
right-bottom corner of the input image.</p>


<p style="margin-top: 1em">crop=in_w-100:in_h-100:100:100</p>

<p style="margin-top: 1em">&Acirc;&middot; Crop 10 pixels
from the left and right borders, and 20 pixels from the top
and bottom borders</p>

<p style="margin-top: 1em">crop=in_w-2*10:in_h-2*20</p>

<p style="margin-top: 1em">&Acirc;&middot; Keep only the
bottom right quarter of the input image:</p>


<p style="margin-top: 1em">crop=in_w/2:in_h/2:in_w/2:in_h/2</p>

<p style="margin-top: 1em">&Acirc;&middot; Crop height for
getting Greek harmony:</p>

<p style="margin-top: 1em">crop=in_w:1/PHI*in_w</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply trembling
effect:</p>


<p style="margin-top: 1em">crop=in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2
+((in_h-out_h)/2)*sin(n/7)</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply erratic
camera effect depending on timestamp:</p>


<p style="margin-top: 1em">crop=in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(t*10):(in_h-out_h)/2
+((in_h-out_h)/2)*sin(t*13)&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Set x depending
on the value of y:</p>


<p style="margin-top: 1em">crop=in_w/2:in_h/2:y:10+10*sin(n/10)</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">This filter supports the
following commands:</p>

<p style="margin-top: 1em">w, out_w <br>
h, out_h <br>
x <br>
y Set width/height of the output video and the
horizontal/vertical position in the input video. The command
accepts the same syntax of the corresponding option.</p>

<p style="margin-top: 1em">If the specified expression is
not valid, it is kept at its current value.</p>

<p style="margin-top: 1em">cropdetect <br>
Auto-detect the crop size.</p>

<p style="margin-top: 1em">It calculates the necessary
cropping parameters and prints the recommended parameters
via the logging system. The detected dimensions correspond
to the non-black area of the <br>
input video.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">limit <br>
Set higher black value threshold, which can be optionally
specified from nothing (0) to everything (255 for 8-bit
based formats). An intensity value greater to the set value
<br>
is considered non-black. It defaults to 24. You can also
specify a value between 0.0 and 1.0 which will be scaled
depending on the bitdepth of the pixel format.</p>

<p style="margin-top: 1em">round <br>
The value which the width/height should be divisible by. It
defaults to 16. The offset is automatically adjusted to
center the video. Use 2 to get only even dimensions <br>
(needed for 4:2:2 video). 16 is best when encoding to most
video codecs.</p>

<p style="margin-top: 1em">reset_count, reset <br>
Set the counter that determines after how many frames
cropdetect will reset the previously detected largest video
area and start over to detect the current optimal crop area.
<br>
Default value is 0.</p>

<p style="margin-top: 1em">This can be useful when channel
logos distort the video area. 0 indicates &rsquo;never
reset&rsquo;, and returns the largest area encountered
during playback.</p>

<p style="margin-top: 1em">curves <br>
Apply color adjustments using curves.</p>

<p style="margin-top: 1em">This filter is similar to the
Adobe Photoshop and GIMP curves tools. Each component (red,
green and blue) has its values defined by N key points tied
from each other using a <br>
smooth curve. The x-axis represents the pixel values from
the input frame, and the y-axis the new pixel values to be
set for the output frame.</p>

<p style="margin-top: 1em">By default, a component curve is
defined by the two points (0;0) and (1;1). This creates a
straight line where each original pixel value is
&quot;adjusted&quot; to its own value, which <br>
means no change to the image.</p>

<p style="margin-top: 1em">The filter allows you to
redefine these two points and add some more. A new curve
(using a natural cubic spline interpolation) will be define
to pass smoothly through all these <br>
new coordinates. The new defined points needs to be strictly
increasing over the x-axis, and their x and y values must be
in the [0;1] interval. If the computed curves happened <br>
to go outside the vector spaces, the values will be clipped
accordingly.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">preset <br>
Select one of the available color presets. This option can
be used in addition to the r, g, b parameters; in this case,
the later options takes priority on the preset values. <br>
Available presets are:</p>

<p style="margin-top: 1em">none <br>
color_negative <br>
cross_process <br>
darker <br>
increase_contrast <br>
lighter <br>
linear_contrast <br>
medium_contrast <br>
negative <br>
strong_contrast <br>
vintage</p>

<p style="margin-top: 1em">Default is &quot;none&quot;.</p>

<p style="margin-top: 1em">master, m <br>
Set the master key points. These points will define a second
pass mapping. It is sometimes called a &quot;luminance&quot;
or &quot;value&quot; mapping. It can be used with r, g, b or
all since <br>
it acts like a post-processing LUT.</p>

<p style="margin-top: 1em">red, r <br>
Set the key points for the red component.</p>

<p style="margin-top: 1em">green, g <br>
Set the key points for the green component.</p>

<p style="margin-top: 1em">blue, b <br>
Set the key points for the blue component.</p>

<p style="margin-top: 1em">all Set the key points for all
components (not including master). Can be used in addition
to the other key points component options. In this case, the
unset component(s) will <br>
fallback on this all setting.</p>

<p style="margin-top: 1em">psfile <br>
Specify a Photoshop curves file (&quot;.acv&quot;) to import
the settings from.</p>

<p style="margin-top: 1em">plot <br>
Save Gnuplot script of the curves in specified file.</p>

<p style="margin-top: 1em">To avoid some filtergraph syntax
conflicts, each key points list need to be defined using the
following syntax: &quot;x0/y0 x1/y1 x2/y2 ...&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Increase
slightly the middle level of blue:</p>

<p style="margin-top: 1em">curves=blue=&rsquo;0/0 0.5/0.58
1/1&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Vintage
effect:</p>

<p style="margin-top: 1em">curves=r=&rsquo;0/0.11 .42/.51
1/0.95&rsquo;:g=&rsquo;0/0 0.50/0.48
1/1&rsquo;:b=&rsquo;0/0.22 .49/.44 1/0.8&rsquo;</p>

<p style="margin-top: 1em">Here we obtain the following
coordinates for each components:</p>

<p style="margin-top: 1em">red &quot;(0;0.11) (0.42;0.51)
(1;0.95)&quot;</p>

<p style="margin-top: 1em">green <br>
&quot;(0;0) (0.50;0.48) (1;1)&quot;</p>

<p style="margin-top: 1em">blue <br>
&quot;(0;0.22) (0.49;0.44) (1;0.80)&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; The previous
example can also be achieved with the associated built-in
preset:</p>

<p style="margin-top: 1em">curves=preset=vintage</p>

<p style="margin-top: 1em">&Acirc;&middot; Or simply:</p>

<p style="margin-top: 1em">curves=vintage</p>

<p style="margin-top: 1em">&Acirc;&middot; Use a Photoshop
preset and redefine the points of the green component:</p>


<p style="margin-top: 1em">curves=psfile=&rsquo;MyCurvesPresets/purple.acv&rsquo;:green=&rsquo;0/0
0.45/0.53 1/1&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Check out the
curves of the &quot;cross_process&quot; profile using ffmpeg
and gnuplot:</p>

<p style="margin-top: 1em">ffmpeg -f lavfi -i color -vf
curves=cross_process:plot=/tmp/curves.plt -frames:v 1 -f
null - <br>
gnuplot -p /tmp/curves.plt</p>

<p style="margin-top: 1em">datascope <br>
Video data analysis filter.</p>

<p style="margin-top: 1em">This filter shows hexadecimal
pixel values of part of video.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">size, s <br>
Set output video size.</p>

<p style="margin-top: 1em">x Set x offset from where to
pick pixels.</p>

<p style="margin-top: 1em">y Set y offset from where to
pick pixels.</p>

<p style="margin-top: 1em">mode <br>
Set scope mode, can be one of the following:</p>

<p style="margin-top: 1em">mono <br>
Draw hexadecimal pixel values with white color on black
background.</p>

<p style="margin-top: 1em">color <br>
Draw hexadecimal pixel values with input video pixel color
on black background.</p>

<p style="margin-top: 1em">color2 <br>
Draw hexadecimal pixel values on color background picked
from input video, the text color is picked in such way so
its always visible.</p>

<p style="margin-top: 1em">axis <br>
Draw rows and columns numbers on left and top of video.</p>

<p style="margin-top: 1em">opacity <br>
Set background opacity.</p>

<p style="margin-top: 1em">dctdnoiz <br>
Denoise frames using 2D DCT (frequency domain
filtering).</p>

<p style="margin-top: 1em">This filter is not designed for
real time.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">sigma, s <br>
Set the noise sigma constant.</p>

<p style="margin-top: 1em">This sigma defines a hard
threshold of &quot;3 * sigma&quot;; every DCT coefficient
(absolute value) below this threshold with be dropped.</p>

<p style="margin-top: 1em">If you need a more advanced
filtering, see expr.</p>

<p style="margin-top: 1em">Default is 0.</p>

<p style="margin-top: 1em">overlap <br>
Set number overlapping pixels for each block. Since the
filter can be slow, you may want to reduce this value, at
the cost of a less effective filter and the risk of various
<br>
artefacts.</p>

<p style="margin-top: 1em">If the overlapping value
doesn&rsquo;t permit processing the whole input width or
height, a warning will be displayed and according borders
won&rsquo;t be denoised.</p>

<p style="margin-top: 1em">Default value is blocksize-1,
which is the best possible setting.</p>

<p style="margin-top: 1em">expr, e <br>
Set the coefficient factor expression.</p>

<p style="margin-top: 1em">For each coefficient of a DCT
block, this expression will be evaluated as a multiplier
value for the coefficient.</p>

<p style="margin-top: 1em">If this is option is set, the
sigma option will be ignored.</p>

<p style="margin-top: 1em">The absolute value of the
coefficient can be accessed through the c variable.</p>

<p style="margin-top: 1em">n Set the blocksize using the
number of bits. &quot;1&lt;&lt;n&quot; defines the
blocksize, which is the width and height of the processed
blocks.</p>

<p style="margin-top: 1em">The default value is 3 (8x8) and
can be raised to 4 for a blocksize of 16x16. Note that
changing this setting has huge consequences on the speed
processing. Also, a larger <br>
block size does not necessarily means a better
de-noising.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">Apply a denoise with a sigma of
4.5:</p>

<p style="margin-top: 1em">dctdnoiz=4.5</p>

<p style="margin-top: 1em">The same operation can be
achieved using the expression system:</p>

<p style="margin-top: 1em">dctdnoiz=e=&rsquo;gte(c,
4.5*3)&rsquo;</p>

<p style="margin-top: 1em">Violent denoise using a block
size of &quot;16x16&quot;:</p>

<p style="margin-top: 1em">dctdnoiz=15:n=4</p>

<p style="margin-top: 1em">deband <br>
Remove banding artifacts from input video. It works by
replacing banded pixels with average value of referenced
pixels.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">1thr <br>
2thr <br>
3thr <br>
4thr <br>
Set banding detection threshold for each plane. Default is
0.02. Valid range is 0.00003 to 0.5. If difference between
current pixel and reference pixel is less than <br>
threshold, it will be considered as banded.</p>

<p style="margin-top: 1em">range, r <br>
Banding detection range in pixels. Default is 16. If
positive, random number in range 0 to set value will be
used. If negative, exact absolute value will be used. The
range <br>
defines square of four pixels around current pixel.</p>

<p style="margin-top: 1em">direction, d <br>
Set direction in radians from which four pixel will be
compared. If positive, random direction from 0 to set
direction will be picked. If negative, exact of absolute
value <br>
will be picked. For example direction 0, -PI or -2*PI
radians will pick only pixels on same row and -PI/2 will
pick only pixels on same column.</p>

<p style="margin-top: 1em">blur <br>
If enabled, current pixel is compared with average value of
all four surrounding pixels. The default is enabled. If
disabled current pixel is compared with all four <br>
surrounding pixels. The pixel is considered banded if only
all four differences with surrounding pixels are less than
threshold.</p>

<p style="margin-top: 1em">decimate <br>
Drop duplicated frames at regular intervals.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">cycle <br>
Set the number of frames from which one will be dropped.
Setting this to N means one frame in every batch of N frames
will be dropped. Default is 5.</p>

<p style="margin-top: 1em">dupthresh <br>
Set the threshold for duplicate detection. If the difference
metric for a frame is less than or equal to this value, then
it is declared as duplicate. Default is 1.1</p>

<p style="margin-top: 1em">scthresh <br>
Set scene change threshold. Default is 15.</p>

<p style="margin-top: 1em">blockx <br>
blocky <br>
Set the size of the x and y-axis blocks used during metric
calculations. Larger blocks give better noise suppression,
but also give worse detection of small movements. Must <br>
be a power of two. Default is 32.</p>

<p style="margin-top: 1em">ppsrc <br>
Mark main input as a pre-processed input and activate clean
source input stream. This allows the input to be
pre-processed with various filters to help the metrics <br>
calculation while keeping the frame selection lossless. When
set to 1, the first stream is for the pre-processed input,
and the second stream is the clean source from where <br>
the kept frames are chosen. Default is 0.</p>

<p style="margin-top: 1em">chroma <br>
Set whether or not chroma is considered in the metric
calculations. Default is 1.</p>

<p style="margin-top: 1em">deflate <br>
Apply deflate effect to the video.</p>

<p style="margin-top: 1em">This filter replaces the pixel
by the local(3x3) average by taking into account only values
lower than the pixel.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">threshold0 <br>
threshold1 <br>
threshold2 <br>
threshold3 <br>
Limit the maximum change for each plane, default is 65535.
If 0, plane will remain unchanged.</p>

<p style="margin-top: 1em">dejudder <br>
Remove judder produced by partially interlaced telecined
content.</p>

<p style="margin-top: 1em">Judder can be introduced, for
instance, by pullup filter. If the original source was
partially telecined content then the output of
&quot;pullup,dejudder&quot; will have a variable frame <br>
rate. May change the recorded frame rate of the container.
Aside from that change, this filter will not affect constant
frame rate video.</p>

<p style="margin-top: 1em">The option available in this
filter is:</p>

<p style="margin-top: 1em">cycle <br>
Specify the length of the window over which the judder
repeats.</p>

<p style="margin-top: 1em">Accepts any integer greater than
1. Useful values are:</p>

<p style="margin-top: 1em">4 If the original was telecined
from 24 to 30 fps (Film to NTSC).</p>

<p style="margin-top: 1em">5 If the original was telecined
from 25 to 30 fps (PAL to NTSC).</p>

<p style="margin-top: 1em">20 If a mixture of the two.</p>

<p style="margin-top: 1em">The default is 4.</p>

<p style="margin-top: 1em">delogo <br>
Suppress a TV station logo by a simple interpolation of the
surrounding pixels. Just set a rectangle covering the logo
and watch it disappear (and sometimes something even uglier
<br>
appear - your mileage may vary).</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">x <br>
y Specify the top left corner coordinates of the logo. They
must be specified.</p>

<p style="margin-top: 1em">w <br>
h Specify the width and height of the logo to clear. They
must be specified.</p>

<p style="margin-top: 1em">band, t <br>
Specify the thickness of the fuzzy edge of the rectangle
(added to w and h). The default value is 1. This option is
deprecated, setting higher values should no longer be <br>
necessary and is not recommended.</p>

<p style="margin-top: 1em">show <br>
When set to 1, a green rectangle is drawn on the screen to
simplify finding the right x, y, w, and h parameters. The
default value is 0.</p>

<p style="margin-top: 1em">The rectangle is drawn on the
outermost pixels which will be (partly) replaced with
interpolated values. The values of the next pixels
immediately outside this rectangle in <br>
each direction will be used to compute the interpolated
pixel values inside the rectangle.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Set a rectangle
covering the area with top left corner coordinates 0,0 and
size 100x77, and a band of size 10:</p>


<p style="margin-top: 1em">delogo=x=0:y=0:w=100:h=77:band=10</p>

<p style="margin-top: 1em">deshake <br>
Attempt to fix small changes in horizontal and/or vertical
shift. This filter helps remove camera shake from
hand-holding a camera, bumping a tripod, moving on a
vehicle, etc.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">x <br>
y <br>
w <br>
h Specify a rectangular area where to limit the search for
motion vectors. If desired the search for motion vectors can
be limited to a rectangular area of the frame defined <br>
by its top left corner, width and height. These parameters
have the same meaning as the drawbox filter which can be
used to visualise the position of the bounding box.</p>

<p style="margin-top: 1em">This is useful when simultaneous
movement of subjects within the frame might be confused for
camera motion by the motion vector search.</p>

<p style="margin-top: 1em">If any or all of x, y, w and h
are set to -1 then the full frame is used. This allows later
options to be set without specifying the bounding box for
the motion vector <br>
search.</p>

<p style="margin-top: 1em">Default - search the whole
frame.</p>

<p style="margin-top: 1em">rx <br>
ry Specify the maximum extent of movement in x and y
directions in the range 0-64 pixels. Default 16.</p>

<p style="margin-top: 1em">edge <br>
Specify how to generate pixels to fill blanks at the edge of
the frame. Available values are:</p>

<p style="margin-top: 1em">blank, 0 <br>
Fill zeroes at blank locations</p>

<p style="margin-top: 1em">original, 1 <br>
Original image at blank locations</p>

<p style="margin-top: 1em">clamp, 2 <br>
Extruded edge value at blank locations</p>

<p style="margin-top: 1em">mirror, 3 <br>
Mirrored edge at blank locations</p>

<p style="margin-top: 1em">Default value is mirror.</p>

<p style="margin-top: 1em">blocksize <br>
Specify the blocksize to use for motion search. Range 4-128
pixels, default 8.</p>

<p style="margin-top: 1em">contrast <br>
Specify the contrast threshold for blocks. Only blocks with
more than the specified contrast (difference between darkest
and lightest pixels) will be considered. Range 1-255, <br>
default 125.</p>

<p style="margin-top: 1em">search <br>
Specify the search strategy. Available values are:</p>

<p style="margin-top: 1em">exhaustive, 0 <br>
Set exhaustive search</p>

<p style="margin-top: 1em">less, 1 <br>
Set less exhaustive search.</p>

<p style="margin-top: 1em">Default value is exhaustive.</p>

<p style="margin-top: 1em">filename <br>
If set then a detailed log of the motion search is written
to the specified file.</p>

<p style="margin-top: 1em">opencl <br>
If set to 1, specify using OpenCL capabilities, only
available if FFmpeg was configured with
&quot;--enable-opencl&quot;. Default value is 0.</p>

<p style="margin-top: 1em">detelecine <br>
Apply an exact inverse of the telecine operation. It
requires a predefined pattern specified using the pattern
option which must be the same as that passed to the telecine
<br>
filter.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">first_field <br>
top, t <br>
top field first</p>

<p style="margin-top: 1em">bottom, b <br>
bottom field first The default value is &quot;top&quot;.</p>

<p style="margin-top: 1em">pattern <br>
A string of numbers representing the pulldown pattern you
wish to apply. The default value is 23.</p>

<p style="margin-top: 1em">start_frame <br>
A number representing position of the first frame with
respect to the telecine pattern. This is to be used if the
stream is cut. The default value is 0.</p>

<p style="margin-top: 1em">dilation <br>
Apply dilation effect to the video.</p>

<p style="margin-top: 1em">This filter replaces the pixel
by the local(3x3) maximum.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">threshold0 <br>
threshold1 <br>
threshold2 <br>
threshold3 <br>
Limit the maximum change for each plane, default is 65535.
If 0, plane will remain unchanged.</p>

<p style="margin-top: 1em">coordinates <br>
Flag which specifies the pixel to refer to. Default is 255
i.e. all eight pixels are used.</p>

<p style="margin-top: 1em">Flags to local 3x3 coordinates
maps like this:</p>

<p style="margin-top: 1em">1 2 3 <br>
4 5 <br>
6 7 8</p>

<p style="margin-top: 1em">displace <br>
Displace pixels as indicated by second and third input
stream.</p>

<p style="margin-top: 1em">It takes three input streams and
outputs one stream, the first input is the source, and
second and third input are displacement maps.</p>

<p style="margin-top: 1em">The second input specifies how
much to displace pixels along the x-axis, while the third
input specifies how much to displace pixels along the
y-axis. If one of displacement map <br>
streams terminates, last frame from that displacement map
will be used.</p>

<p style="margin-top: 1em">Note that once generated,
displacements maps can be reused over and over again.</p>

<p style="margin-top: 1em">A description of the accepted
options follows.</p>

<p style="margin-top: 1em">edge <br>
Set displace behavior for pixels that are out of range.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">blank <br>
Missing pixels are replaced by black pixels.</p>

<p style="margin-top: 1em">smear <br>
Adjacent pixels will spread out to replace missing
pixels.</p>

<p style="margin-top: 1em">wrap <br>
Out of range pixels are wrapped so they point to pixels of
other side.</p>

<p style="margin-top: 1em">Default is smear.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Add ripple
effect to rgb input of video size hd720:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f lavfi -i
nullsrc=s=hd720,lutrgb=128:128:128 -f lavfi -i
nullsrc=s=hd720,geq=&rsquo;r=128+30*sin(2*PI*X/400+T):g=128+30*sin(2*PI*X/400+T):b=128+30*sin(2*PI*X/400+T)&rsquo;
-lavfi &rsquo;[0][1][2]displace&rsquo; OUTPUT</p>

<p style="margin-top: 1em">&Acirc;&middot; Add wave effect
to rgb input of video size hd720:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f lavfi -i
nullsrc=hd720,geq=&rsquo;r=128+80*(sin(sqrt((X-W/2)*(X-W/2)+(Y-H/2)*(Y-H/2))/220*2*PI+T)):g=128+80*(sin(sqrt((X-W/2)*(X-W/2)+(Y-H/2)*(Y-H/2))/220*2*PI+T)):b=128+80*(sin(sqrt((X-W/2)*(X-W/2)+(Y-H/2)*(Y-H/2))/220*2*PI+T))&rsquo;
-lavfi &rsquo;[1]split[x][y],[0][x][y]displace&rsquo;
OUTPUT</p>

<p style="margin-top: 1em">drawbox <br>
Draw a colored box on the input image.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">x <br>
y The expressions which specify the top left corner
coordinates of the box. It defaults to 0.</p>

<p style="margin-top: 1em">width, w <br>
height, h <br>
The expressions which specify the width and height of the
box; if 0 they are interpreted as the input width and
height. It defaults to 0.</p>

<p style="margin-top: 1em">color, c <br>
Specify the color of the box to write. For the general
syntax of this option, check the &quot;Color&quot; section
in the ffmpeg-utils manual. If the special value
&quot;invert&quot; is used, the <br>
box edge color is the same as the video with inverted
luma.</p>

<p style="margin-top: 1em">thickness, t <br>
The expression which sets the thickness of the box edge.
Default value is 3.</p>

<p style="margin-top: 1em">See below for the list of
accepted constants.</p>

<p style="margin-top: 1em">The parameters for x, y, w and h
and t are expressions containing the following
constants:</p>

<p style="margin-top: 1em">dar The input display aspect
ratio, it is the same as (w / h) * sar.</p>

<p style="margin-top: 1em">hsub <br>
vsub <br>
horizontal and vertical chroma subsample values. For example
for the pixel format &quot;yuv422p&quot; hsub is 2 and vsub
is 1.</p>

<p style="margin-top: 1em">in_h, ih <br>
in_w, iw <br>
The input width and height.</p>

<p style="margin-top: 1em">sar The input sample aspect
ratio.</p>

<p style="margin-top: 1em">x <br>
y The x and y offset coordinates where the box is drawn.</p>

<p style="margin-top: 1em">w <br>
h The width and height of the drawn box.</p>

<p style="margin-top: 1em">t The thickness of the drawn
box.</p>

<p style="margin-top: 1em">These constants allow the x, y,
w, h and t expressions to refer to each other, so you may
for example specify &quot;y=x/dar&quot; or
&quot;h=w/dar&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Draw a black box
around the edge of the input image:</p>

<p style="margin-top: 1em">drawbox</p>

<p style="margin-top: 1em">&Acirc;&middot; Draw a box with
color red and an opacity of 50%:</p>


<p style="margin-top: 1em">drawbox=10:20:200:60:red@0.5</p>

<p style="margin-top: 1em">The previous example can be
specified as:</p>


<p style="margin-top: 1em">drawbox=x=10:y=20:w=200:h=60:color=red@0.5</p>

<p style="margin-top: 1em">&Acirc;&middot; Fill the box
with pink color:</p>


<p style="margin-top: 1em">drawbox=x=10:y=10:w=100:h=100:color=pink@0.5:t=max</p>

<p style="margin-top: 1em">&Acirc;&middot; Draw a 2-pixel
red 2.40:1 mask:</p>


<p style="margin-top: 1em">drawbox=x=-t:y=0.5*(ih-iw/2.4)-t:w=iw+t*2:h=iw/2.4+t*2:t=2:c=red</p>

<p style="margin-top: 1em">drawgrid <br>
Draw a grid on the input image.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">x <br>
y The expressions which specify the coordinates of some
point of grid intersection (meant to configure offset). Both
default to 0.</p>

<p style="margin-top: 1em">width, w <br>
height, h <br>
The expressions which specify the width and height of the
grid cell, if 0 they are interpreted as the input width and
height, respectively, minus &quot;thickness&quot;, so image
gets <br>
framed. Default to 0.</p>

<p style="margin-top: 1em">color, c <br>
Specify the color of the grid. For the general syntax of
this option, check the &quot;Color&quot; section in the
ffmpeg-utils manual. If the special value &quot;invert&quot;
is used, the grid <br>
color is the same as the video with inverted luma.</p>

<p style="margin-top: 1em">thickness, t <br>
The expression which sets the thickness of the grid line.
Default value is 1.</p>

<p style="margin-top: 1em">See below for the list of
accepted constants.</p>

<p style="margin-top: 1em">The parameters for x, y, w and h
and t are expressions containing the following
constants:</p>

<p style="margin-top: 1em">dar The input display aspect
ratio, it is the same as (w / h) * sar.</p>

<p style="margin-top: 1em">hsub <br>
vsub <br>
horizontal and vertical chroma subsample values. For example
for the pixel format &quot;yuv422p&quot; hsub is 2 and vsub
is 1.</p>

<p style="margin-top: 1em">in_h, ih <br>
in_w, iw <br>
The input grid cell width and height.</p>

<p style="margin-top: 1em">sar The input sample aspect
ratio.</p>

<p style="margin-top: 1em">x <br>
y The x and y coordinates of some point of grid intersection
(meant to configure offset).</p>

<p style="margin-top: 1em">w <br>
h The width and height of the drawn cell.</p>

<p style="margin-top: 1em">t The thickness of the drawn
cell.</p>

<p style="margin-top: 1em">These constants allow the x, y,
w, h and t expressions to refer to each other, so you may
for example specify &quot;y=x/dar&quot; or
&quot;h=w/dar&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Draw a grid with
cell 100x100 pixels, thickness 2 pixels, with color red and
an opacity of 50%:</p>


<p style="margin-top: 1em">drawgrid=width=100:height=100:thickness=2:color=red@0.5</p>

<p style="margin-top: 1em">&Acirc;&middot; Draw a white 3x3
grid with an opacity of 50%:</p>


<p style="margin-top: 1em">drawgrid=w=iw/3:h=ih/3:t=2:c=white@0.5</p>

<p style="margin-top: 1em">drawtext <br>
Draw a text string or text from a specified file on top of a
video, using the libfreetype library.</p>

<p style="margin-top: 1em">To enable compilation of this
filter, you need to configure FFmpeg with
&quot;--enable-libfreetype&quot;. To enable default font
fallback and the font option you need to configure FFmpeg
<br>
with &quot;--enable-libfontconfig&quot;. To enable the
text_shaping option, you need to configure FFmpeg with
&quot;--enable-libfribidi&quot;.</p>

<p style="margin-top: 1em">Syntax</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">box Used to draw a box around
text using the background color. The value must be either 1
(enable) or 0 (disable). The default value of box is 0.</p>

<p style="margin-top: 1em">boxborderw <br>
Set the width of the border to be drawn around the box using
boxcolor. The default value of boxborderw is 0.</p>

<p style="margin-top: 1em">boxcolor <br>
The color to be used for drawing box around text. For the
syntax of this option, check the &quot;Color&quot; section
in the ffmpeg-utils manual.</p>

<p style="margin-top: 1em">The default value of boxcolor is
&quot;white&quot;.</p>

<p style="margin-top: 1em">borderw <br>
Set the width of the border to be drawn around the text
using bordercolor. The default value of borderw is 0.</p>

<p style="margin-top: 1em">bordercolor <br>
Set the color to be used for drawing border around text. For
the syntax of this option, check the &quot;Color&quot;
section in the ffmpeg-utils manual.</p>

<p style="margin-top: 1em">The default value of bordercolor
is &quot;black&quot;.</p>

<p style="margin-top: 1em">expansion <br>
Select how the text is expanded. Can be either
&quot;none&quot;, &quot;strftime&quot; (deprecated) or
&quot;normal&quot; (default). See the drawtext_expansion,
Text expansion section below for details.</p>

<p style="margin-top: 1em">fix_bounds <br>
If true, check and fix text coords to avoid clipping.</p>

<p style="margin-top: 1em">fontcolor <br>
The color to be used for drawing fonts. For the syntax of
this option, check the &quot;Color&quot; section in the
ffmpeg-utils manual.</p>

<p style="margin-top: 1em">The default value of fontcolor
is &quot;black&quot;.</p>

<p style="margin-top: 1em">fontcolor_expr <br>
String which is expanded the same way as text to obtain
dynamic fontcolor value. By default this option has empty
value and is not processed. When this option is set, it <br>
overrides fontcolor option.</p>

<p style="margin-top: 1em">font <br>
The font family to be used for drawing text. By default
Sans.</p>

<p style="margin-top: 1em">fontfile <br>
The font file to be used for drawing text. The path must be
included. This parameter is mandatory if the fontconfig
support is disabled.</p>

<p style="margin-top: 1em">draw <br>
This option does not exist, please see the timeline
system</p>

<p style="margin-top: 1em">alpha <br>
Draw the text applying alpha blending. The value can be a
number between 0.0 and 1.0. The expression accepts the same
variables x, y as well. The default value is 1. <br>
Please see fontcolor_expr.</p>

<p style="margin-top: 1em">fontsize <br>
The font size to be used for drawing text. The default value
of fontsize is 16.</p>

<p style="margin-top: 1em">text_shaping <br>
If set to 1, attempt to shape the text (for example, reverse
the order of right-to-left text and join Arabic characters)
before drawing it. Otherwise, just draw the text <br>
exactly as given. By default 1 (if supported).</p>

<p style="margin-top: 1em">ft_load_flags <br>
The flags to be used for loading the fonts.</p>

<p style="margin-top: 1em">The flags map the corresponding
flags supported by libfreetype, and are a combination of the
following values:</p>

<p style="margin-top: 1em">default <br>
no_scale <br>
no_hinting <br>
render <br>
no_bitmap <br>
vertical_layout <br>
force_autohint <br>
crop_bitmap <br>
pedantic <br>
ignore_global_advance_width <br>
no_recurse <br>
ignore_transform <br>
monochrome <br>
linear_design <br>
no_autohint</p>

<p style="margin-top: 1em">Default value is
&quot;default&quot;.</p>

<p style="margin-top: 1em">For more information consult the
documentation for the FT_LOAD_* libfreetype flags.</p>

<p style="margin-top: 1em">shadowcolor <br>
The color to be used for drawing a shadow behind the drawn
text. For the syntax of this option, check the
&quot;Color&quot; section in the ffmpeg-utils manual.</p>

<p style="margin-top: 1em">The default value of shadowcolor
is &quot;black&quot;.</p>

<p style="margin-top: 1em">shadowx <br>
shadowy <br>
The x and y offsets for the text shadow position with
respect to the position of the text. They can be either
positive or negative values. The default value for both is
&quot;0&quot;.</p>

<p style="margin-top: 1em">start_number <br>
The starting frame number for the n/frame_num variable. The
default value is &quot;0&quot;.</p>

<p style="margin-top: 1em">tabsize <br>
The size in number of spaces to use for rendering the tab.
Default value is 4.</p>

<p style="margin-top: 1em">timecode <br>
Set the initial timecode representation in
&quot;hh:mm:ss[:;.]ff&quot; format. It can be used with or
without text parameter. timecode_rate option must be
specified.</p>

<p style="margin-top: 1em">timecode_rate, rate, r <br>
Set the timecode frame rate (timecode only).</p>

<p style="margin-top: 1em">text <br>
The text string to be drawn. The text must be a sequence of
UTF-8 encoded characters. This parameter is mandatory if no
file is specified with the parameter textfile.</p>

<p style="margin-top: 1em">textfile <br>
A text file containing text to be drawn. The text must be a
sequence of UTF-8 encoded characters.</p>

<p style="margin-top: 1em">This parameter is mandatory if
no text string is specified with the parameter text.</p>

<p style="margin-top: 1em">If both text and textfile are
specified, an error is thrown.</p>

<p style="margin-top: 1em">reload <br>
If set to 1, the textfile will be reloaded before each
frame. Be sure to update it atomically, or it may be read
partially, or even fail.</p>

<p style="margin-top: 1em">x <br>
y The expressions which specify the offsets where text will
be drawn within the video frame. They are relative to the
top/left border of the output image.</p>

<p style="margin-top: 1em">The default value of x and y is
&quot;0&quot;.</p>

<p style="margin-top: 1em">See below for the list of
accepted constants and functions.</p>

<p style="margin-top: 1em">The parameters for x and y are
expressions containing the following constants and
functions:</p>

<p style="margin-top: 1em">dar input display aspect ratio,
it is the same as (w / h) * sar</p>

<p style="margin-top: 1em">hsub <br>
vsub <br>
horizontal and vertical chroma subsample values. For example
for the pixel format &quot;yuv422p&quot; hsub is 2 and vsub
is 1.</p>

<p style="margin-top: 1em">line_h, lh <br>
the height of each text line</p>

<p style="margin-top: 1em">main_h, h, H <br>
the input height</p>

<p style="margin-top: 1em">main_w, w, W <br>
the input width</p>

<p style="margin-top: 1em">max_glyph_a, ascent <br>
the maximum distance from the baseline to the highest/upper
grid coordinate used to place a glyph outline point, for all
the rendered glyphs. It is a positive value, due to <br>
the grid&rsquo;s orientation with the Y axis upwards.</p>

<p style="margin-top: 1em">max_glyph_d, descent <br>
the maximum distance from the baseline to the lowest grid
coordinate used to place a glyph outline point, for all the
rendered glyphs. This is a negative value, due to the <br>
grid&rsquo;s orientation, with the Y axis upwards.</p>

<p style="margin-top: 1em">max_glyph_h <br>
maximum glyph height, that is the maximum height for all the
glyphs contained in the rendered text, it is equivalent to
ascent - descent.</p>

<p style="margin-top: 1em">max_glyph_w <br>
maximum glyph width, that is the maximum width for all the
glyphs contained in the rendered text</p>

<p style="margin-top: 1em">n the number of input frame,
starting from 0</p>

<p style="margin-top: 1em">rand(min, max) <br>
return a random number included between min and max</p>

<p style="margin-top: 1em">sar The input sample aspect
ratio.</p>

<p style="margin-top: 1em">t timestamp expressed in
seconds, NAN if the input timestamp is unknown</p>

<p style="margin-top: 1em">text_h, th <br>
the height of the rendered text</p>

<p style="margin-top: 1em">text_w, tw <br>
the width of the rendered text</p>

<p style="margin-top: 1em">x <br>
y the x and y offset coordinates where the text is
drawn.</p>

<p style="margin-top: 1em">These parameters allow the x and
y expressions to refer each other, so you can for example
specify &quot;y=x/dar&quot;.</p>

<p style="margin-top: 1em">Text expansion</p>

<p style="margin-top: 1em">If expansion is set to
&quot;strftime&quot;, the filter recognizes strftime()
sequences in the provided text and expands them accordingly.
Check the documentation of strftime(). This <br>
feature is deprecated.</p>

<p style="margin-top: 1em">If expansion is set to
&quot;none&quot;, the text is printed verbatim.</p>

<p style="margin-top: 1em">If expansion is set to
&quot;normal&quot; (which is the default), the following
expansion mechanism is used.</p>

<p style="margin-top: 1em">The backslash character followed
by any character, always expands to the second
character.</p>

<p style="margin-top: 1em">Sequences of the form
&quot;%{...}&quot; are expanded. The text between the braces
is a function name, possibly followed by arguments separated
by &rsquo;:&rsquo;. If the arguments contain special <br>
characters or delimiters (&rsquo;:&rsquo; or
&rsquo;}&rsquo;), they should be escaped.</p>

<p style="margin-top: 1em">Note that they probably must
also be escaped as the value for the text option in the
filter argument string and as the filter argument in the
filtergraph description, and <br>
possibly also for the shell, that makes up to four levels of
escaping; using a text file avoids these problems.</p>

<p style="margin-top: 1em">The following functions are
available:</p>

<p style="margin-top: 1em">expr, e <br>
The expression evaluation result.</p>

<p style="margin-top: 1em">It must take one argument
specifying the expression to be evaluated, which accepts the
same constants and functions as the x and y values. Note
that not all constants should <br>
be used, for example the text size is not known when
evaluating the expression, so the constants text_w and
text_h will have an undefined value.</p>

<p style="margin-top: 1em">expr_int_format, eif <br>
Evaluate the expression&rsquo;s value and output as
formatted integer.</p>

<p style="margin-top: 1em">The first argument is the
expression to be evaluated, just as for the expr function.
The second argument specifies the output format. Allowed
values are x, X, d and u. They <br>
are treated exactly as in the &quot;printf&quot; function.
The third parameter is optional and sets the number of
positions taken by the output. It can be used to add padding
with <br>
zeros from the left.</p>

<p style="margin-top: 1em">gmtime <br>
The time at which the filter is running, expressed in UTC.
It can accept an argument: a strftime() format string.</p>

<p style="margin-top: 1em">localtime <br>
The time at which the filter is running, expressed in the
local time zone. It can accept an argument: a strftime()
format string.</p>

<p style="margin-top: 1em">metadata <br>
Frame metadata. Takes one or two arguments.</p>

<p style="margin-top: 1em">The first argument is mandatory
and specifies the metadata key.</p>

<p style="margin-top: 1em">The second argument is optional
and specifies a default value, used when the metadata key is
not found or empty.</p>

<p style="margin-top: 1em">n, frame_num <br>
The frame number, starting from 0.</p>

<p style="margin-top: 1em">pict_type <br>
A 1 character description of the current picture type.</p>

<p style="margin-top: 1em">pts The timestamp of the current
frame. It can take up to three arguments.</p>

<p style="margin-top: 1em">The first argument is the format
of the timestamp; it defaults to &quot;flt&quot; for seconds
as a decimal number with microsecond accuracy;
&quot;hms&quot; stands for a formatted <br>
[-]HH:MM:SS.mmm timestamp with millisecond accuracy.
&quot;gmtime&quot; stands for the timestamp of the frame
formatted as UTC time; &quot;localtime&quot; stands for the
timestamp of the frame <br>
formatted as local time zone time.</p>

<p style="margin-top: 1em">The second argument is an offset
added to the timestamp.</p>

<p style="margin-top: 1em">If the format is set to
&quot;localtime&quot; or &quot;gmtime&quot;, a third
argument may be supplied: a strftime() format string. By
default, YYYY-MM-DD HH:MM:SS format will be used.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Draw &quot;Test
Text&quot; with font FreeSerif, using the default values for
the optional parameters.</p>


<p style="margin-top: 1em">drawtext=&quot;fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf:
text=&rsquo;Test Text&rsquo;&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Draw &rsquo;Test
Text&rsquo; with font FreeSerif of size 24 at position x=100
and y=50 (counting from the top-left corner of the screen),
text is yellow with a red box around it. Both <br>
the text and the box have an opacity of 20%.</p>


<p style="margin-top: 1em">drawtext=&quot;fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf:
text=&rsquo;Test Text&rsquo;: x=100: y=50: fontsize=24:
fontcolor=yellow@0.2: box=1: boxcolor=red@0.2&quot;</p>

<p style="margin-top: 1em">Note that the double quotes are
not necessary if spaces are not used within the parameter
list.</p>

<p style="margin-top: 1em">&Acirc;&middot; Show the text at
the center of the video frame:</p>


<p style="margin-top: 1em">drawtext=&quot;fontsize=30:fontfile=FreeSerif.ttf:text=&rsquo;hello
world&rsquo;:x=(w-text_w)/2:y=(h-text_h)/2&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Show the text at
a random position, switching to a new position every 30
seconds:</p>


<p style="margin-top: 1em">drawtext=&quot;fontsize=30:fontfile=FreeSerif.ttf:text=&rsquo;hello
world&rsquo;:x=if(eq(mod(t30)0)rand(0(w-text_w))x):y=if(eq(mod(t30)0)rand(0(h-text_h))y)&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Show a text line
sliding from right to left in the last row of the video
frame. The file LONG_LINE is assumed to contain a single
line with no newlines.</p>


<p style="margin-top: 1em">drawtext=&quot;fontsize=15:fontfile=FreeSerif.ttf:text=LONG_LINE:y=h-line_h:x=-50*t&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Show the content
of file CREDITS off the bottom of the frame and scroll
up.</p>


<p style="margin-top: 1em">drawtext=&quot;fontsize=20:fontfile=FreeSerif.ttf:textfile=CREDITS:y=h-20*t&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Draw a single
green letter &quot;g&quot;, at the center of the input
video. The glyph baseline is placed at half screen
height.</p>


<p style="margin-top: 1em">drawtext=&quot;fontsize=60:fontfile=FreeSerif.ttf:fontcolor=green:text=g:x=(w-max_glyph_w)/2:y=h/2-ascent&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Show text for 1
second every 3 seconds:</p>


<p style="margin-top: 1em">drawtext=&quot;fontfile=FreeSerif.ttf:fontcolor=white:x=100:y=x/dar:enable=lt(mod(t3)1):text=&rsquo;blink&rsquo;&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Use fontconfig
to set the font. Note that the colons need to be
escaped.</p>

<p style="margin-top: 1em">drawtext=&rsquo;fontfile=Linux
Libertine O-40 style=Semibold:text=FFmpeg&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Print the date
of a real-time encoding (see strftime(3)):</p>


<p style="margin-top: 1em">drawtext=&rsquo;fontfile=FreeSans.ttf:text=%{localtime
%a %b %d %Y}&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Show text fading
in and out (appearing/disappearing):</p>

<p style="margin-top: 1em">#!/bin/sh <br>
DS=1.0 # display start <br>
DE=10.0 # display end <br>
FID=1.5 # fade in duration <br>
FOD=5 # fade out duration <br>
ffplay -f lavfi
&quot;color,drawtext=text=TEST:fontsize=50:fontfile=FreeSerif.ttf:fontcolor_expr=ff0000%{eif\\:
clip(255*(1*between(t\, $DS + $FID\, $DE - $FOD) + ((t -
$DS)/$FID)*between(t\, $DS\, $DS + $FID) + (-(t -
$DE)/$FOD)*between(t\, $DE - $FOD\, $DE) )\, 0\, 255) \\:
x\\: 2 }&quot;</p>

<p style="margin-top: 1em">For more information about
libfreetype, check: &lt;http://www.freetype.org/&gt;.</p>

<p style="margin-top: 1em">For more information about
fontconfig, check:
&lt;http://freedesktop.org/software/fontconfig/fontconfig-user.html&gt;.</p>

<p style="margin-top: 1em">For more information about
libfribidi, check: &lt;http://fribidi.org/&gt;.</p>

<p style="margin-top: 1em">edgedetect <br>
Detect and draw edges. The filter uses the Canny Edge
Detection algorithm.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">low <br>
high <br>
Set low and high threshold values used by the Canny
thresholding algorithm.</p>

<p style="margin-top: 1em">The high threshold selects the
&quot;strong&quot; edge pixels, which are then connected
through 8-connectivity with the &quot;weak&quot; edge pixels
selected by the low threshold.</p>

<p style="margin-top: 1em">low and high threshold values
must be chosen in the range [0,1], and low should be lesser
or equal to high.</p>

<p style="margin-top: 1em">Default value for low is
&quot;20/255&quot;, and default value for high is
&quot;50/255&quot;.</p>

<p style="margin-top: 1em">mode <br>
Define the drawing mode.</p>

<p style="margin-top: 1em">wires <br>
Draw white/gray wires on black background.</p>

<p style="margin-top: 1em">colormix <br>
Mix the colors to create a paint/cartoon effect.</p>

<p style="margin-top: 1em">Default value is wires.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Standard edge
detection with custom values for the hysteresis
thresholding:</p>

<p style="margin-top: 1em">edgedetect=low=0.1:high=0.4</p>

<p style="margin-top: 1em">&Acirc;&middot; Painting effect
without thresholding:</p>


<p style="margin-top: 1em">edgedetect=mode=colormix:high=0</p>

<p style="margin-top: 1em">eq <br>
Set brightness, contrast, saturation and approximate gamma
adjustment.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">contrast <br>
Set the contrast expression. The value must be a float value
in range &quot;-2.0&quot; to 2.0. The default value is
&quot;1&quot;.</p>

<p style="margin-top: 1em">brightness <br>
Set the brightness expression. The value must be a float
value in range &quot;-1.0&quot; to 1.0. The default value is
&quot;0&quot;.</p>

<p style="margin-top: 1em">saturation <br>
Set the saturation expression. The value must be a float in
range 0.0 to 3.0. The default value is &quot;1&quot;.</p>

<p style="margin-top: 1em">gamma <br>
Set the gamma expression. The value must be a float in range
0.1 to 10.0. The default value is &quot;1&quot;.</p>

<p style="margin-top: 1em">gamma_r <br>
Set the gamma expression for red. The value must be a float
in range 0.1 to 10.0. The default value is
&quot;1&quot;.</p>

<p style="margin-top: 1em">gamma_g <br>
Set the gamma expression for green. The value must be a
float in range 0.1 to 10.0. The default value is
&quot;1&quot;.</p>

<p style="margin-top: 1em">gamma_b <br>
Set the gamma expression for blue. The value must be a float
in range 0.1 to 10.0. The default value is
&quot;1&quot;.</p>

<p style="margin-top: 1em">gamma_weight <br>
Set the gamma weight expression. It can be used to reduce
the effect of a high gamma value on bright image areas, e.g.
keep them from getting overamplified and just plain <br>
white. The value must be a float in range 0.0 to 1.0. A
value of 0.0 turns the gamma correction all the way down
while 1.0 leaves it at its full strength. Default is
&quot;1&quot;.</p>

<p style="margin-top: 1em">eval <br>
Set when the expressions for brightness, contrast,
saturation and gamma expressions are evaluated.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">init <br>
only evaluate expressions once during the filter
initialization or when a command is processed</p>

<p style="margin-top: 1em">frame <br>
evaluate expressions for each incoming frame</p>

<p style="margin-top: 1em">Default value is init.</p>

<p style="margin-top: 1em">The expressions accept the
following parameters:</p>

<p style="margin-top: 1em">n frame count of the input frame
starting from 0</p>

<p style="margin-top: 1em">pos byte position of the
corresponding packet in the input file, NAN if
unspecified</p>

<p style="margin-top: 1em">r frame rate of the input video,
NAN if the input frame rate is unknown</p>

<p style="margin-top: 1em">t timestamp expressed in
seconds, NAN if the input timestamp is unknown</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">The filter supports the
following commands:</p>

<p style="margin-top: 1em">contrast <br>
Set the contrast expression.</p>

<p style="margin-top: 1em">brightness <br>
Set the brightness expression.</p>

<p style="margin-top: 1em">saturation <br>
Set the saturation expression.</p>

<p style="margin-top: 1em">gamma <br>
Set the gamma expression.</p>

<p style="margin-top: 1em">gamma_r <br>
Set the gamma_r expression.</p>

<p style="margin-top: 1em">gamma_g <br>
Set gamma_g expression.</p>

<p style="margin-top: 1em">gamma_b <br>
Set gamma_b expression.</p>

<p style="margin-top: 1em">gamma_weight <br>
Set gamma_weight expression.</p>

<p style="margin-top: 1em">The command accepts the same
syntax of the corresponding option.</p>

<p style="margin-top: 1em">If the specified expression is
not valid, it is kept at its current value.</p>

<p style="margin-top: 1em">erosion <br>
Apply erosion effect to the video.</p>

<p style="margin-top: 1em">This filter replaces the pixel
by the local(3x3) minimum.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">threshold0 <br>
threshold1 <br>
threshold2 <br>
threshold3 <br>
Limit the maximum change for each plane, default is 65535.
If 0, plane will remain unchanged.</p>

<p style="margin-top: 1em">coordinates <br>
Flag which specifies the pixel to refer to. Default is 255
i.e. all eight pixels are used.</p>

<p style="margin-top: 1em">Flags to local 3x3 coordinates
maps like this:</p>

<p style="margin-top: 1em">1 2 3 <br>
4 5 <br>
6 7 8</p>

<p style="margin-top: 1em">extractplanes <br>
Extract color channel components from input video stream
into separate grayscale video streams.</p>

<p style="margin-top: 1em">The filter accepts the following
option:</p>

<p style="margin-top: 1em">planes <br>
Set plane(s) to extract.</p>

<p style="margin-top: 1em">Available values for planes
are:</p>

<p style="margin-top: 1em">y <br>
u <br>
v <br>
a <br>
r <br>
g <br>
b</p>

<p style="margin-top: 1em">Choosing planes not available in
the input will result in an error. That means you cannot
select &quot;r&quot;, &quot;g&quot;, &quot;b&quot; planes
with &quot;y&quot;, &quot;u&quot;, &quot;v&quot; planes at
same time.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Extract luma, u
and v color channel component from input video frame into 3
grayscale outputs:</p>

<p style="margin-top: 1em">ffmpeg -i video.avi
-filter_complex &rsquo;extractplanes=y+u+v[y][u][v]&rsquo;
-map &rsquo;[y]&rsquo; y.avi -map &rsquo;[u]&rsquo; u.avi
-map &rsquo;[v]&rsquo; v.avi</p>

<p style="margin-top: 1em">elbg <br>
Apply a posterize effect using the ELBG (Enhanced LBG)
algorithm.</p>

<p style="margin-top: 1em">For each input image, the filter
will compute the optimal mapping from the input to the
output given the codebook length, that is the number of
distinct output colors.</p>

<p style="margin-top: 1em">This filter accepts the
following options.</p>

<p style="margin-top: 1em">codebook_length, l <br>
Set codebook length. The value must be a positive integer,
and represents the number of distinct output colors. Default
value is 256.</p>

<p style="margin-top: 1em">nb_steps, n <br>
Set the maximum number of iterations to apply for computing
the optimal mapping. The higher the value the better the
result and the higher the computation time. Default value
<br>
is 1.</p>

<p style="margin-top: 1em">seed, s <br>
Set a random seed, must be an integer included between 0 and
UINT32_MAX. If not specified, or if explicitly set to -1,
the filter will try to use a good random seed on a best <br>
effort basis.</p>

<p style="margin-top: 1em">pal8 <br>
Set pal8 output pixel format. This option does not work with
codebook length greater than 256.</p>

<p style="margin-top: 1em">fade <br>
Apply a fade-in/out effect to the input video.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">type, t <br>
The effect type can be either &quot;in&quot; for a fade-in,
or &quot;out&quot; for a fade-out effect. Default is
&quot;in&quot;.</p>

<p style="margin-top: 1em">start_frame, s <br>
Specify the number of the frame to start applying the fade
effect at. Default is 0.</p>

<p style="margin-top: 1em">nb_frames, n <br>
The number of frames that the fade effect lasts. At the end
of the fade-in effect, the output video will have the same
intensity as the input video. At the end of the fade- <br>
out transition, the output video will be filled with the
selected color. Default is 25.</p>

<p style="margin-top: 1em">alpha <br>
If set to 1, fade only alpha channel, if one exists on the
input. Default value is 0.</p>

<p style="margin-top: 1em">start_time, st <br>
Specify the timestamp (in seconds) of the frame to start to
apply the fade effect. If both start_frame and start_time
are specified, the fade will start at whichever comes <br>
last. Default is 0.</p>

<p style="margin-top: 1em">duration, d <br>
The number of seconds for which the fade effect has to last.
At the end of the fade-in effect the output video will have
the same intensity as the input video, at the end of <br>
the fade-out transition the output video will be filled with
the selected color. If both duration and nb_frames are
specified, duration is used. Default is 0 (nb_frames is <br>
used by default).</p>

<p style="margin-top: 1em">color, c <br>
Specify the color of the fade. Default is
&quot;black&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Fade in the
first 30 frames of video:</p>

<p style="margin-top: 1em">fade=in:0:30</p>

<p style="margin-top: 1em">The command above is equivalent
to:</p>

<p style="margin-top: 1em">fade=t=in:s=0:n=30</p>

<p style="margin-top: 1em">&Acirc;&middot; Fade out the
last 45 frames of a 200-frame video:</p>

<p style="margin-top: 1em">fade=out:155:45 <br>
fade=type=out:start_frame=155:nb_frames=45</p>

<p style="margin-top: 1em">&Acirc;&middot; Fade in the
first 25 frames and fade out the last 25 frames of a
1000-frame video:</p>

<p style="margin-top: 1em">fade=in:0:25,
fade=out:975:25</p>

<p style="margin-top: 1em">&Acirc;&middot; Make the first 5
frames yellow, then fade in from frame 5-24:</p>

<p style="margin-top: 1em">fade=in:5:20:color=yellow</p>

<p style="margin-top: 1em">&Acirc;&middot; Fade in alpha
over first 25 frames of video:</p>

<p style="margin-top: 1em">fade=in:0:25:alpha=1</p>

<p style="margin-top: 1em">&Acirc;&middot; Make the first
5.5 seconds black, then fade in for 0.5 seconds:</p>

<p style="margin-top: 1em">fade=t=in:st=5.5:d=0.5</p>

<p style="margin-top: 1em">fftfilt <br>
Apply arbitrary expressions to samples in frequency
domain</p>

<p style="margin-top: 1em">dc_Y <br>
Adjust the dc value (gain) of the luma plane of the image.
The filter accepts an integer value in range 0 to 1000. The
default value is set to 0.</p>

<p style="margin-top: 1em">dc_U <br>
Adjust the dc value (gain) of the 1st chroma plane of the
image. The filter accepts an integer value in range 0 to
1000. The default value is set to 0.</p>

<p style="margin-top: 1em">dc_V <br>
Adjust the dc value (gain) of the 2nd chroma plane of the
image. The filter accepts an integer value in range 0 to
1000. The default value is set to 0.</p>

<p style="margin-top: 1em">weight_Y <br>
Set the frequency domain weight expression for the luma
plane.</p>

<p style="margin-top: 1em">weight_U <br>
Set the frequency domain weight expression for the 1st
chroma plane.</p>

<p style="margin-top: 1em">weight_V <br>
Set the frequency domain weight expression for the 2nd
chroma plane.</p>

<p style="margin-top: 1em">The filter accepts the following
variables:</p>

<p style="margin-top: 1em">X <br>
Y The coordinates of the current sample.</p>

<p style="margin-top: 1em">W <br>
H The width and height of the image.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; High-pass:</p>


<p style="margin-top: 1em">fftfilt=dc_Y=128:weight_Y=&rsquo;squish(1-(Y+X)/100)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Low-pass:</p>


<p style="margin-top: 1em">fftfilt=dc_Y=0:weight_Y=&rsquo;squish((Y+X)/100-1)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Sharpen:</p>


<p style="margin-top: 1em">fftfilt=dc_Y=0:weight_Y=&rsquo;1+squish(1-(Y+X)/100)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Blur:</p>


<p style="margin-top: 1em">fftfilt=dc_Y=0:weight_Y=&rsquo;exp(-4
* ((Y+X)/(W+H)))&rsquo;</p>

<p style="margin-top: 1em">field <br>
Extract a single field from an interlaced image using stride
arithmetic to avoid wasting CPU time. The output frames are
marked as non-interlaced.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">type <br>
Specify whether to extract the top (if the value is 0 or
&quot;top&quot;) or the bottom field (if the value is 1 or
&quot;bottom&quot;).</p>

<p style="margin-top: 1em">fieldhint <br>
Create new frames by copying the top and bottom fields from
surrounding frames supplied as numbers by the hint file.</p>

<p style="margin-top: 1em">hint <br>
Set file containing hints: absolute/relative frame
numbers.</p>

<p style="margin-top: 1em">There must be one line for each
frame in a clip. Each line must contain two numbers
separated by the comma, optionally followed by &quot;-&quot;
or &quot;+&quot;. Numbers supplied on each line <br>
of file can not be out of [N-1,N+1] where N is current frame
number for &quot;absolute&quot; mode or out of [-1, 1] range
for &quot;relative&quot; mode. First number tells from which
frame to <br>
pick up top field and second number tells from which frame
to pick up bottom field.</p>

<p style="margin-top: 1em">If optionally followed by
&quot;+&quot; output frame will be marked as interlaced,
else if followed by &quot;-&quot; output frame will be
marked as progressive, else it will be marked same as <br>
input frame. If line starts with &quot;#&quot; or
&quot;;&quot; that line is skipped.</p>

<p style="margin-top: 1em">mode <br>
Can be item &quot;absolute&quot; or &quot;relative&quot;.
Default is &quot;absolute&quot;.</p>

<p style="margin-top: 1em">Example of first several lines
of &quot;hint&quot; file for &quot;relative&quot; mode:</p>

<p style="margin-top: 1em">0,0 - # first frame <br>
1,0 - # second frame, use third&rsquo;s frame top field and
second&rsquo;s frame bottom field <br>
1,0 - # third frame, use fourth&rsquo;s frame top field and
third&rsquo;s frame bottom field <br>
1,0 - <br>
0,0 - <br>
0,0 - <br>
1,0 - <br>
1,0 - <br>
1,0 - <br>
0,0 - <br>
0,0 - <br>
1,0 - <br>
1,0 - <br>
1,0 - <br>
0,0 -</p>

<p style="margin-top: 1em">fieldmatch <br>
Field matching filter for inverse telecine. It is meant to
reconstruct the progressive frames from a telecined stream.
The filter does not drop duplicated frames, so to achieve a
<br>
complete inverse telecine &quot;fieldmatch&quot; needs to be
followed by a decimation filter such as decimate in the
filtergraph.</p>

<p style="margin-top: 1em">The separation of the field
matching and the decimation is notably motivated by the
possibility of inserting a de-interlacing filter fallback
between the two. If the source has <br>
mixed telecined and real interlaced content,
&quot;fieldmatch&quot; will not be able to match fields for
the interlaced parts. But these remaining combed frames will
be marked as <br>
interlaced, and thus can be de-interlaced by a later filter
such as yadif before decimation.</p>

<p style="margin-top: 1em">In addition to the various
configuration options, &quot;fieldmatch&quot; can take an
optional second stream, activated through the ppsrc option.
If enabled, the frames reconstruction will <br>
be based on the fields and frames from this second stream.
This allows the first input to be pre-processed in order to
help the various algorithms of the filter, while keeping
<br>
the output lossless (assuming the fields are matched
properly). Typically, a field-aware denoiser, or
brightness/contrast adjustments can help.</p>

<p style="margin-top: 1em">Note that this filter uses the
same algorithms as TIVTC/TFM (AviSynth project) and
VIVTC/VFM (VapourSynth project). The later is a light clone
of TFM from which &quot;fieldmatch&quot; is <br>
based on. While the semantic and usage are very close, some
behaviour and options names can differ.</p>

<p style="margin-top: 1em">The decimate filter currently
only works for constant frame rate input. If your input has
mixed telecined (30fps) and progressive content with a lower
framerate like 24fps use <br>
the following filterchain to produce the necessary cfr
stream:
&quot;dejudder,fps=30000/1001,fieldmatch,decimate&quot;.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">order <br>
Specify the assumed field order of the input stream.
Available values are:</p>

<p style="margin-top: 1em">auto <br>
Auto detect parity (use FFmpeg&rsquo;s internal parity
value).</p>

<p style="margin-top: 1em">bff Assume bottom field
first.</p>

<p style="margin-top: 1em">tff Assume top field first.</p>

<p style="margin-top: 1em">Note that it is sometimes
recommended not to trust the parity announced by the
stream.</p>

<p style="margin-top: 1em">Default value is auto.</p>

<p style="margin-top: 1em">mode <br>
Set the matching mode or strategy to use. pc mode is the
safest in the sense that it won&rsquo;t risk creating
jerkiness due to duplicate frames when possible, but if
there are bad <br>
edits or blended fields it will end up outputting combed
frames when a good match might actually exist. On the other
hand, pcn_ub mode is the most risky in terms of creating
<br>
jerkiness, but will almost always find a good frame if there
is one. The other values are all somewhere in between pc and
pcn_ub in terms of risking jerkiness and creating <br>
duplicate frames versus finding good matches in sections
with bad edits, orphaned fields, blended fields, etc.</p>

<p style="margin-top: 1em">More details about p/c/n/u/b are
available in p/c/n/u/b meaning section.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">pc 2-way matching (p/c)</p>

<p style="margin-top: 1em">pc_n <br>
2-way matching, and trying 3rd match if still combed (p/c +
n)</p>

<p style="margin-top: 1em">pc_u <br>
2-way matching, and trying 3rd match (same order) if still
combed (p/c + u)</p>

<p style="margin-top: 1em">pc_n_ub <br>
2-way matching, trying 3rd match if still combed, and trying
4th/5th matches if still combed (p/c + n + u/b)</p>

<p style="margin-top: 1em">pcn 3-way matching (p/c/n)</p>

<p style="margin-top: 1em">pcn_ub <br>
3-way matching, and trying 4th/5th matches if all 3 of the
original matches are detected as combed (p/c/n + u/b)</p>

<p style="margin-top: 1em">The parenthesis at the end
indicate the matches that would be used for that mode
assuming order=tff (and field on auto or top).</p>

<p style="margin-top: 1em">In terms of speed pc mode is by
far the fastest and pcn_ub is the slowest.</p>

<p style="margin-top: 1em">Default value is pc_n.</p>

<p style="margin-top: 1em">ppsrc <br>
Mark the main input stream as a pre-processed input, and
enable the secondary input stream as the clean source to
pick the fields from. See the filter introduction for more
<br>
details. It is similar to the clip2 feature from
VFM/TFM.</p>

<p style="margin-top: 1em">Default value is 0
(disabled).</p>

<p style="margin-top: 1em">field <br>
Set the field to match from. It is recommended to set this
to the same value as order unless you experience matching
failures with that setting. In certain circumstances <br>
changing the field that is used to match from can have a
large impact on matching performance. Available values
are:</p>

<p style="margin-top: 1em">auto <br>
Automatic (same value as order).</p>

<p style="margin-top: 1em">bottom <br>
Match from the bottom field.</p>

<p style="margin-top: 1em">top Match from the top
field.</p>

<p style="margin-top: 1em">Default value is auto.</p>

<p style="margin-top: 1em">mchroma <br>
Set whether or not chroma is included during the match
comparisons. In most cases it is recommended to leave this
enabled. You should set this to 0 only if your clip has bad
<br>
chroma problems such as heavy rainbowing or other artifacts.
Setting this to 0 could also be used to speed things up at
the cost of some accuracy.</p>

<p style="margin-top: 1em">Default value is 1.</p>

<p style="margin-top: 1em">y0 <br>
y1 These define an exclusion band which excludes the lines
between y0 and y1 from being included in the field matching
decision. An exclusion band can be used to ignore <br>
subtitles, a logo, or other things that may interfere with
the matching. y0 sets the starting scan line and y1 sets the
ending line; all lines in between y0 and y1 (including <br>
y0 and y1) will be ignored. Setting y0 and y1 to the same
value will disable the feature. y0 and y1 defaults to 0.</p>

<p style="margin-top: 1em">scthresh <br>
Set the scene change detection threshold as a percentage of
maximum change on the luma plane. Good values are in the
&quot;[8.0, 14.0]&quot; range. Scene change detection is
only <br>
relevant in case combmatch=sc. The range for scthresh is
&quot;[0.0, 100.0]&quot;.</p>

<p style="margin-top: 1em">Default value is 12.0.</p>

<p style="margin-top: 1em">combmatch <br>
When combatch is not none, &quot;fieldmatch&quot; will take
into account the combed scores of matches when deciding what
match to use as the final match. Available values are:</p>

<p style="margin-top: 1em">none <br>
No final matching based on combed scores.</p>

<p style="margin-top: 1em">sc Combed scores are only used
when a scene change is detected.</p>

<p style="margin-top: 1em">full <br>
Use combed scores all the time.</p>

<p style="margin-top: 1em">Default is sc.</p>

<p style="margin-top: 1em">combdbg <br>
Force &quot;fieldmatch&quot; to calculate the combed metrics
for certain matches and print them. This setting is known as
micout in TFM/VFM vocabulary. Available values are:</p>

<p style="margin-top: 1em">none <br>
No forced calculation.</p>

<p style="margin-top: 1em">pcn Force p/c/n
calculations.</p>

<p style="margin-top: 1em">pcnub <br>
Force p/c/n/u/b calculations.</p>

<p style="margin-top: 1em">Default value is none.</p>

<p style="margin-top: 1em">cthresh <br>
This is the area combing threshold used for combed frame
detection. This essentially controls how &quot;strong&quot;
or &quot;visible&quot; combing must be to be detected.
Larger values mean <br>
combing must be more visible and smaller values mean combing
can be less visible or strong and still be detected. Valid
settings are from &quot;-1&quot; (every pixel will be
detected <br>
as combed) to 255 (no pixel will be detected as combed).
This is basically a pixel difference value. A good range is
&quot;[8, 12]&quot;.</p>

<p style="margin-top: 1em">Default value is 9.</p>

<p style="margin-top: 1em">chroma <br>
Sets whether or not chroma is considered in the combed frame
decision. Only disable this if your source has chroma
problems (rainbowing, etc.) that are causing problems for
<br>
the combed frame detection with chroma enabled. Actually,
using chroma=0 is usually more reliable, except for the case
where there is chroma only combing in the source.</p>

<p style="margin-top: 1em">Default value is 0.</p>

<p style="margin-top: 1em">blockx <br>
blocky <br>
Respectively set the x-axis and y-axis size of the window
used during combed frame detection. This has to do with the
size of the area in which combpel pixels are required to
<br>
be detected as combed for a frame to be declared combed. See
the combpel parameter description for more info. Possible
values are any number that is a power of 2 starting at <br>
4 and going up to 512.</p>

<p style="margin-top: 1em">Default value is 16.</p>

<p style="margin-top: 1em">combpel <br>
The number of combed pixels inside any of the blocky by
blockx size blocks on the frame for the frame to be detected
as combed. While cthresh controls how &quot;visible&quot;
the <br>
combing must be, this setting controls &quot;how much&quot;
combing there must be in any localized area (a window
defined by the blockx and blocky settings) on the frame.
Minimum value <br>
is 0 and maximum is &quot;blocky x blockx&quot; (at which
point no frames will ever be detected as combed). This
setting is known as MI in TFM/VFM vocabulary.</p>

<p style="margin-top: 1em">Default value is 80.</p>

<p style="margin-top: 1em">p/c/n/u/b meaning</p>

<p style="margin-top: 1em">p/c/n</p>

<p style="margin-top: 1em">We assume the following
telecined stream:</p>

<p style="margin-top: 1em">Top fields: 1 2 2 3 4 <br>
Bottom fields: 1 2 3 4 4</p>

<p style="margin-top: 1em">The numbers correspond to the
progressive frame the fields relate to. Here, the first two
frames are progressive, the 3rd and 4th are combed, and so
on.</p>

<p style="margin-top: 1em">When &quot;fieldmatch&quot; is
configured to run a matching from bottom (field=bottom) this
is how this input stream get transformed:</p>

<p style="margin-top: 1em">Input stream: <br>
T 1 2 2 3 4 <br>
B 1 2 3 4 4 &lt;-- matching reference</p>

<p style="margin-top: 1em">Matches: c c n n c</p>

<p style="margin-top: 1em">Output stream: <br>
T 1 2 3 4 4 <br>
B 1 2 3 4 4</p>

<p style="margin-top: 1em">As a result of the field
matching, we can see that some frames get duplicated. To
perform a complete inverse telecine, you need to rely on a
decimation filter after this <br>
operation. See for instance the decimate filter.</p>

<p style="margin-top: 1em">The same operation now matching
from top fields (field=top) looks like this:</p>

<p style="margin-top: 1em">Input stream: <br>
T 1 2 2 3 4 &lt;-- matching reference <br>
B 1 2 3 4 4</p>

<p style="margin-top: 1em">Matches: c c p p c</p>

<p style="margin-top: 1em">Output stream: <br>
T 1 2 2 3 4 <br>
B 1 2 2 3 4</p>

<p style="margin-top: 1em">In these examples, we can see
what p, c and n mean; basically, they refer to the frame and
field of the opposite parity:</p>

<p style="margin-top: 1em">*&lt;p matches the field of the
opposite parity in the previous frame&gt; <br>
*&lt;c matches the field of the opposite parity in the
current frame&gt; <br>
*&lt;n matches the field of the opposite parity in the next
frame&gt;</p>

<p style="margin-top: 1em">u/b</p>

<p style="margin-top: 1em">The u and b matching are a bit
special in the sense that they match from the opposite
parity flag. In the following examples, we assume that we
are currently matching the 2nd <br>
frame (Top:2, bottom:2). According to the match, a
&rsquo;x&rsquo; is placed above and below each matched
fields.</p>

<p style="margin-top: 1em">With bottom matching
(field=bottom):</p>

<p style="margin-top: 1em">Match: c p n b u</p>

<p style="margin-top: 1em">x x x x x <br>
Top 1 2 2 1 2 2 1 2 2 1 2 2 1 2 2 <br>
Bottom 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 <br>
x x x x x</p>

<p style="margin-top: 1em">Output frames: <br>
2 1 2 2 2 <br>
2 2 2 1 3</p>

<p style="margin-top: 1em">With top matching
(field=top):</p>

<p style="margin-top: 1em">Match: c p n b u</p>

<p style="margin-top: 1em">x x x x x <br>
Top 1 2 2 1 2 2 1 2 2 1 2 2 1 2 2 <br>
Bottom 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 <br>
x x x x x</p>

<p style="margin-top: 1em">Output frames: <br>
2 2 2 1 2 <br>
2 1 3 2 2</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">Simple IVTC of a top field first
telecined stream:</p>


<p style="margin-top: 1em">fieldmatch=order=tff:combmatch=none,
decimate</p>

<p style="margin-top: 1em">Advanced IVTC, with fallback on
yadif for still combed frames:</p>


<p style="margin-top: 1em">fieldmatch=order=tff:combmatch=full,
yadif=deint=interlaced, decimate</p>

<p style="margin-top: 1em">fieldorder <br>
Transform the field order of the input video.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">order <br>
The output field order. Valid values are tff for top field
first or bff for bottom field first.</p>

<p style="margin-top: 1em">The default value is tff.</p>

<p style="margin-top: 1em">The transformation is done by
shifting the picture content up or down by one line, and
filling the remaining line with appropriate picture content.
This method is consistent <br>
with most broadcast field order converters.</p>

<p style="margin-top: 1em">If the input video is not
flagged as being interlaced, or it is already flagged as
being of the required output field order, then this filter
does not alter the incoming video.</p>

<p style="margin-top: 1em">It is very useful when
converting to or from PAL DV material, which is bottom field
first.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">ffmpeg -i in.vob -vf
&quot;fieldorder=bff&quot; out.dv</p>

<p style="margin-top: 1em">fifo, afifo <br>
Buffer input images and send them when they are
requested.</p>

<p style="margin-top: 1em">It is mainly useful when
auto-inserted by the libavfilter framework.</p>

<p style="margin-top: 1em">It does not take parameters.</p>

<p style="margin-top: 1em">find_rect <br>
Find a rectangular object</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">object <br>
Filepath of the object image, needs to be in gray8.</p>

<p style="margin-top: 1em">threshold <br>
Detection threshold, default is 0.5.</p>

<p style="margin-top: 1em">mipmaps <br>
Number of mipmaps, default is 3.</p>

<p style="margin-top: 1em">xmin, ymin, xmax, ymax <br>
Specifies the rectangle in which to search.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a
representative palette of a given video using ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i file.ts -vf
find_rect=newref.pgm,cover_rect=cover.jpg:mode=cover
new.mkv</p>

<p style="margin-top: 1em">cover_rect <br>
Cover a rectangular object</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">cover <br>
Filepath of the optional cover image, needs to be in
yuv420.</p>

<p style="margin-top: 1em">mode <br>
Set covering mode.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">cover <br>
cover it by the supplied image</p>

<p style="margin-top: 1em">blur <br>
cover it by interpolating the surrounding pixels</p>

<p style="margin-top: 1em">Default value is blur.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a
representative palette of a given video using ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i file.ts -vf
find_rect=newref.pgm,cover_rect=cover.jpg:mode=cover
new.mkv</p>

<p style="margin-top: 1em">format <br>
Convert the input video to one of the specified pixel
formats. Libavfilter will try to pick one that is suitable
as input to the next filter.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">pix_fmts <br>
A &rsquo;|&rsquo;-separated list of pixel format names, such
as &quot;pix_fmts=yuv420p|monow|rgb24&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Convert the
input video to the yuv420p format</p>

<p style="margin-top: 1em">format=pix_fmts=yuv420p</p>

<p style="margin-top: 1em">Convert the input video to any
of the formats in the list</p>


<p style="margin-top: 1em">format=pix_fmts=yuv420p|yuv444p|yuv410p</p>

<p style="margin-top: 1em">fps <br>
Convert the video to specified constant frame rate by
duplicating or dropping frames as necessary.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">fps The desired output frame
rate. The default is 25.</p>

<p style="margin-top: 1em">round <br>
Rounding method.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">zero <br>
zero round towards 0</p>

<p style="margin-top: 1em">inf round away from 0</p>

<p style="margin-top: 1em">down <br>
round towards -infinity</p>

<p style="margin-top: 1em">up round towards +infinity</p>

<p style="margin-top: 1em">near <br>
round to nearest</p>

<p style="margin-top: 1em">The default is
&quot;near&quot;.</p>

<p style="margin-top: 1em">start_time <br>
Assume the first PTS should be the given value, in seconds.
This allows for padding/trimming at the start of stream. By
default, no assumption is made about the first frame&rsquo;s
<br>
expected PTS, so no padding or trimming is done. For
example, this could be set to 0 to pad the beginning with
duplicates of the first frame if a video stream starts after
<br>
the audio stream or to trim any frames with a negative
PTS.</p>

<p style="margin-top: 1em">Alternatively, the options can
be specified as a flat string: fps[:round].</p>

<p style="margin-top: 1em">See also the setpts filter.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; A typical usage
in order to set the fps to 25:</p>

<p style="margin-top: 1em">fps=fps=25</p>

<p style="margin-top: 1em">&Acirc;&middot; Sets the fps to
24, using abbreviation and rounding method to round to
nearest:</p>

<p style="margin-top: 1em">fps=fps=film:round=near</p>

<p style="margin-top: 1em">framepack <br>
Pack two different video streams into a stereoscopic video,
setting proper metadata on supported codecs. The two views
should have the same size and framerate and processing will
<br>
stop when the shorter video ends. Please note that you may
conveniently adjust view properties with the scale and fps
filters.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">format <br>
The desired packing format. Supported values are:</p>

<p style="margin-top: 1em">sbs The views are next to each
other (default).</p>

<p style="margin-top: 1em">tab The views are on top of each
other.</p>

<p style="margin-top: 1em">lines <br>
The views are packed by line.</p>

<p style="margin-top: 1em">columns <br>
The views are packed by column.</p>

<p style="margin-top: 1em">frameseq <br>
The views are temporally interleaved.</p>

<p style="margin-top: 1em">Some examples:</p>

<p style="margin-top: 1em"># Convert left and right views
into a frame-sequential video <br>
ffmpeg -i LEFT -i RIGHT -filter_complex framepack=frameseq
OUTPUT</p>

<p style="margin-top: 1em"># Convert views into a
side-by-side video with the same output resolution as the
input <br>
ffmpeg -i LEFT -i RIGHT -filter_complex
[0:v]scale=w=iw/2[left],[1:v]scale=w=iw/2[right],[left][right]framepack=sbs
OUTPUT</p>

<p style="margin-top: 1em">framerate <br>
Change the frame rate by interpolating new video output
frames from the source frames.</p>

<p style="margin-top: 1em">This filter is not designed to
function correctly with interlaced media. If you wish to
change the frame rate of interlaced media then you are
required to deinterlace before this <br>
filter and re-interlace after this filter.</p>

<p style="margin-top: 1em">A description of the accepted
options follows.</p>

<p style="margin-top: 1em">fps Specify the output frames
per second. This option can also be specified as a value
alone. The default is 50.</p>

<p style="margin-top: 1em">interp_start <br>
Specify the start of a range where the output frame will be
created as a linear interpolation of two frames. The range
is [0-255], the default is 15.</p>

<p style="margin-top: 1em">interp_end <br>
Specify the end of a range where the output frame will be
created as a linear interpolation of two frames. The range
is [0-255], the default is 240.</p>

<p style="margin-top: 1em">scene <br>
Specify the level at which a scene change is detected as a
value between 0 and 100 to indicate a new scene; a low value
reflects a low probability for the current frame to <br>
introduce a new scene, while a higher value means the
current frame is more likely to be one. The default is
7.</p>

<p style="margin-top: 1em">flags <br>
Specify flags influencing the filter process.</p>

<p style="margin-top: 1em">Available value for flags
is:</p>

<p style="margin-top: 1em">scene_change_detect, scd <br>
Enable scene change detection using the value of the option
scene. This flag is enabled by default.</p>

<p style="margin-top: 1em">framestep <br>
Select one frame every N-th frame.</p>

<p style="margin-top: 1em">This filter accepts the
following option:</p>

<p style="margin-top: 1em">step <br>
Select frame after every &quot;step&quot; frames. Allowed
values are positive integers higher than 0. Default value is
1.</p>

<p style="margin-top: 1em">frei0r <br>
Apply a frei0r effect to the input video.</p>

<p style="margin-top: 1em">To enable the compilation of
this filter, you need to install the frei0r header and
configure FFmpeg with &quot;--enable-frei0r&quot;.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">filter_name <br>
The name of the frei0r effect to load. If the environment
variable FREI0R_PATH is defined, the frei0r effect is
searched for in each of the directories specified by the
<br>
colon-separated list in FREIOR_PATH. Otherwise, the standard
frei0r paths are searched, in this order:
HOME/.frei0r-1/lib/, /usr/local/lib/frei0r-1/,
/usr/lib/frei0r-1/.</p>

<p style="margin-top: 1em">filter_params <br>
A &rsquo;|&rsquo;-separated list of parameters to pass to
the frei0r effect.</p>

<p style="margin-top: 1em">A frei0r effect parameter can be
a boolean (its value is either &quot;y&quot; or
&quot;n&quot;), a double, a color (specified as R/G/B, where
R, G, and B are floating point numbers between 0.0 and <br>
1.0, inclusive) or by a color description specified in the
&quot;Color&quot; section in the ffmpeg-utils manual), a
position (specified as X/Y, where X and Y are floating point
numbers) <br>
and/or a string.</p>

<p style="margin-top: 1em">The number and types of
parameters depend on the loaded effect. If an effect
parameter is not specified, the default value is set.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply the
distort0r effect, setting the first two double
parameters:</p>


<p style="margin-top: 1em">frei0r=filter_name=distort0r:filter_params=0.5|0.01</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply the
colordistance effect, taking a color as the first
parameter:</p>


<p style="margin-top: 1em">frei0r=colordistance:0.2/0.3/0.4
<br>
frei0r=colordistance:violet <br>
frei0r=colordistance:0x112233</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply the
perspective effect, specifying the top left and top right
image positions:</p>


<p style="margin-top: 1em">frei0r=perspective:0.2/0.2|0.8/0.2</p>

<p style="margin-top: 1em">For more information, see
&lt;http://frei0r.dyne.org&gt;</p>

<p style="margin-top: 1em">fspp <br>
Apply fast and simple postprocessing. It is a faster version
of spp.</p>

<p style="margin-top: 1em">It splits (I)DCT into
horizontal/vertical passes. Unlike the simple post-
processing filter, one of them is performed once per block,
not per pixel. This allows for much higher <br>
speed.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">quality <br>
Set quality. This option defines the number of levels for
averaging. It accepts an integer in the range 4-5. Default
value is 4.</p>

<p style="margin-top: 1em">qp Force a constant quantization
parameter. It accepts an integer in range 0-63. If not set,
the filter will use the QP from the video stream (if
available).</p>

<p style="margin-top: 1em">strength <br>
Set filter strength. It accepts an integer in range -15 to
32. Lower values mean more details but also more artifacts,
while higher values make the image smoother but also <br>
blurrier. Default value is 0 X PSNR optimal.</p>

<p style="margin-top: 1em">use_bframe_qp <br>
Enable the use of the QP from the B-Frames if set to 1.
Using this option may cause flicker since the B-Frames have
often larger QP. Default is 0 (not enabled).</p>

<p style="margin-top: 1em">gblur <br>
Apply Gaussian blur filter.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">sigma <br>
Set horizontal sigma, standard deviation of Gaussian blur.
Default is 0.5.</p>

<p style="margin-top: 1em">steps <br>
Set number of steps for Gaussian approximation. Defauls is
1.</p>

<p style="margin-top: 1em">planes <br>
Set which planes to filter. By default all planes are
filtered.</p>

<p style="margin-top: 1em">sigmaV <br>
Set vertical sigma, if negative it will be same as
&quot;sigma&quot;. Default is &quot;-1&quot;.</p>

<p style="margin-top: 1em">geq <br>
The filter accepts the following options:</p>

<p style="margin-top: 1em">lum_expr, lum <br>
Set the luminance expression.</p>

<p style="margin-top: 1em">cb_expr, cb <br>
Set the chrominance blue expression.</p>

<p style="margin-top: 1em">cr_expr, cr <br>
Set the chrominance red expression.</p>

<p style="margin-top: 1em">alpha_expr, a <br>
Set the alpha expression.</p>

<p style="margin-top: 1em">red_expr, r <br>
Set the red expression.</p>

<p style="margin-top: 1em">green_expr, g <br>
Set the green expression.</p>

<p style="margin-top: 1em">blue_expr, b <br>
Set the blue expression.</p>

<p style="margin-top: 1em">The colorspace is selected
according to the specified options. If one of the lum_expr,
cb_expr, or cr_expr options is specified, the filter will
automatically select a YCbCr <br>
colorspace. If one of the red_expr, green_expr, or blue_expr
options is specified, it will select an RGB colorspace.</p>

<p style="margin-top: 1em">If one of the chrominance
expression is not defined, it falls back on the other one.
If no alpha expression is specified it will evaluate to
opaque value. If none of chrominance <br>
expressions are specified, they will evaluate to the
luminance expression.</p>

<p style="margin-top: 1em">The expressions can use the
following variables and functions:</p>

<p style="margin-top: 1em">N The sequential number of the
filtered frame, starting from 0.</p>

<p style="margin-top: 1em">X <br>
Y The coordinates of the current sample.</p>

<p style="margin-top: 1em">W <br>
H The width and height of the image.</p>

<p style="margin-top: 1em">SW <br>
SH Width and height scale depending on the currently
filtered plane. It is the ratio between the corresponding
luma plane number of pixels and the current plane ones. E.g.
for <br>
YUV4:2:0 the values are &quot;1,1&quot; for the luma plane,
and &quot;0.5,0.5&quot; for chroma planes.</p>

<p style="margin-top: 1em">T Time of the current frame,
expressed in seconds.</p>

<p style="margin-top: 1em">p(x, y) <br>
Return the value of the pixel at location (x,y) of the
current plane.</p>

<p style="margin-top: 1em">lum(x, y) <br>
Return the value of the pixel at location (x,y) of the
luminance plane.</p>

<p style="margin-top: 1em">cb(x, y) <br>
Return the value of the pixel at location (x,y) of the
blue-difference chroma plane. Return 0 if there is no such
plane.</p>

<p style="margin-top: 1em">cr(x, y) <br>
Return the value of the pixel at location (x,y) of the
red-difference chroma plane. Return 0 if there is no such
plane.</p>

<p style="margin-top: 1em">r(x, y) <br>
g(x, y) <br>
b(x, y) <br>
Return the value of the pixel at location (x,y) of the
red/green/blue component. Return 0 if there is no such
component.</p>

<p style="margin-top: 1em">alpha(x, y) <br>
Return the value of the pixel at location (x,y) of the alpha
plane. Return 0 if there is no such plane.</p>

<p style="margin-top: 1em">For functions, if x and y are
outside the area, the value will be automatically clipped to
the closer edge.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Flip the image
horizontally:</p>

<p style="margin-top: 1em">geq=p(W-XY)</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a
bidimensional sine wave, with angle &quot;PI/3&quot; and a
wavelength of 100 pixels:</p>

<p style="margin-top: 1em">geq=128 +
100*sin(2*(PI/100)*(cos(PI/3)*(X-50*T) +
sin(PI/3)*Y)):128:128</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a fancy
enigmatic moving light:</p>


<p style="margin-top: 1em">nullsrc=s=256x256,geq=random(1)/hypot(X-cos(N*0.07)*W/2-W/2Y-sin(N*0.09)*H/2-H/2)^2*1000000*sin(N*0.02):128:128</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a quick
emboss effect:</p>


<p style="margin-top: 1em">format=gray,geq=lum_expr=&rsquo;(p(X,Y)+(256-p(X-4,Y-4)))/2&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Modify RGB
components depending on pixel position:</p>


<p style="margin-top: 1em">geq=r=&rsquo;X/W*r(X,Y)&rsquo;:g=&rsquo;(1-X/W)*g(X,Y)&rsquo;:b=&rsquo;(H-Y)/H*b(X,Y)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Create a radial
gradient that is the same size as the input (also see the
vignette filter):</p>


<p style="margin-top: 1em">geq=lum=255*gauss((X/W-0.5)*3)*gauss((Y/H-0.5)*3)/gauss(0)/gauss(0),format=gray</p>

<p style="margin-top: 1em">gradfun <br>
Fix the banding artifacts that are sometimes introduced into
nearly flat regions by truncation to 8-bit color depth.
Interpolate the gradients that should go where the bands
<br>
are, and dither them.</p>

<p style="margin-top: 1em">It is designed for playback
only. Do not use it prior to lossy compression, because
compression tends to lose the dither and bring back the
bands.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">strength <br>
The maximum amount by which the filter will change any one
pixel. This is also the threshold for detecting nearly flat
regions. Acceptable values range from .51 to 64; the <br>
default value is 1.2. Out-of-range values will be clipped to
the valid range.</p>

<p style="margin-top: 1em">radius <br>
The neighborhood to fit the gradient to. A larger radius
makes for smoother gradients, but also prevents the filter
from modifying the pixels near detailed regions. <br>
Acceptable values are 8-32; the default value is 16.
Out-of-range values will be clipped to the valid range.</p>

<p style="margin-top: 1em">Alternatively, the options can
be specified as a flat string: strength[:radius]</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply the filter
with a 3.5 strength and radius of 8:</p>

<p style="margin-top: 1em">gradfun=3.5:8</p>

<p style="margin-top: 1em">&Acirc;&middot; Specify radius,
omitting the strength (which will fall-back to the default
value):</p>

<p style="margin-top: 1em">gradfun=radius=8</p>

<p style="margin-top: 1em">haldclut <br>
Apply a Hald CLUT to a video stream.</p>

<p style="margin-top: 1em">First input is the video stream
to process, and second one is the Hald CLUT. The Hald CLUT
input can be a simple picture or a complete video
stream.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">shortest <br>
Force termination when the shortest input terminates.
Default is 0.</p>

<p style="margin-top: 1em">repeatlast <br>
Continue applying the last CLUT after the end of the stream.
A value of 0 disable the filter after the last frame of the
CLUT is reached. Default is 1.</p>

<p style="margin-top: 1em">&quot;haldclut&quot; also has
the same interpolation options as lut3d (both filters share
the same internals).</p>

<p style="margin-top: 1em">More information about the Hald
CLUT can be found on Eskil Steenberg&rsquo;s website (Hald
CLUT author) at
&lt;http://www.quelsolaar.com/technology/clut.html&gt;.</p>

<p style="margin-top: 1em">Workflow examples</p>

<p style="margin-top: 1em">Hald CLUT video stream</p>

<p style="margin-top: 1em">Generate an identity Hald CLUT
stream altered with various effects:</p>

<p style="margin-top: 1em">ffmpeg -f lavfi -i
B&lt;haldclutsrc&gt;=8 -vf
&quot;hue=H=2*PI*t:s=sin(2*PI*t)+1,
curves=cross_process&quot; -t 10 -c:v ffv1 clut.nut</p>

<p style="margin-top: 1em">Note: make sure you use a
lossless codec.</p>

<p style="margin-top: 1em">Then use it with
&quot;haldclut&quot; to apply it on some random stream:</p>

<p style="margin-top: 1em">ffmpeg -f lavfi -i mandelbrot -i
clut.nut -filter_complex &rsquo;[0][1] haldclut&rsquo; -t 20
mandelclut.mkv</p>

<p style="margin-top: 1em">The Hald CLUT will be applied to
the 10 first seconds (duration of clut.nut), then the latest
picture of that CLUT stream will be applied to the remaining
frames of the <br>
&quot;mandelbrot&quot; stream.</p>

<p style="margin-top: 1em">Hald CLUT with preview</p>

<p style="margin-top: 1em">A Hald CLUT is supposed to be a
squared image of &quot;Level*Level*Level&quot; by
&quot;Level*Level*Level&quot; pixels. For a given Hald CLUT,
FFmpeg will select the biggest possible square starting <br>
at the top left of the picture. The remaining padding pixels
(bottom or right) will be ignored. This area can be used to
add a preview of the Hald CLUT.</p>

<p style="margin-top: 1em">Typically, the following
generated Hald CLUT will be supported by the
&quot;haldclut&quot; filter:</p>

<p style="margin-top: 1em">ffmpeg -f lavfi -i
B&lt;haldclutsrc&gt;=8 -vf &quot; <br>
pad=iw+320 [padded_clut]; <br>
smptebars=s=320x256, split [a][b]; <br>
[padded_clut][a] overlay=W-320:h, curves=color_negative
[main]; <br>
[main][b] overlay=W-320&quot; -frames:v 1 clut.png</p>

<p style="margin-top: 1em">It contains the original and a
preview of the effect of the CLUT: SMPTE color bars are
displayed on the right-top, and below the same color bars
processed by the color changes.</p>

<p style="margin-top: 1em">Then, the effect of this Hald
CLUT can be visualized with:</p>

<p style="margin-top: 1em">ffplay input.mkv -vf
&quot;movie=clut.png, [in] haldclut&quot;</p>

<p style="margin-top: 1em">hflip <br>
Flip the input video horizontally.</p>

<p style="margin-top: 1em">For example, to horizontally
flip the input video with ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i in.avi -vf
&quot;hflip&quot; out.avi</p>

<p style="margin-top: 1em">histeq <br>
This filter applies a global color histogram equalization on
a per-frame basis.</p>

<p style="margin-top: 1em">It can be used to correct video
that has a compressed range of pixel intensities. The filter
redistributes the pixel intensities to equalize their
distribution across the <br>
intensity range. It may be viewed as an &quot;automatically
adjusting contrast filter&quot;. This filter is useful only
for correcting degraded or poorly captured source video.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">strength <br>
Determine the amount of equalization to be applied. As the
strength is reduced, the distribution of pixel intensities
more-and-more approaches that of the input frame. The <br>
value must be a float number in the range [0,1] and defaults
to 0.200.</p>

<p style="margin-top: 1em">intensity <br>
Set the maximum intensity that can generated and scale the
output values appropriately. The strength should be set as
desired and then the intensity can be limited if needed <br>
to avoid washing-out. The value must be a float number in
the range [0,1] and defaults to 0.210.</p>

<p style="margin-top: 1em">antibanding <br>
Set the antibanding level. If enabled the filter will
randomly vary the luminance of output pixels by a small
amount to avoid banding of the histogram. Possible values
are <br>
&quot;none&quot;, &quot;weak&quot; or &quot;strong&quot;. It
defaults to &quot;none&quot;.</p>

<p style="margin-top: 1em">histogram <br>
Compute and draw a color distribution histogram for the
input video.</p>

<p style="margin-top: 1em">The computed histogram is a
representation of the color component distribution in an
image.</p>

<p style="margin-top: 1em">Standard histogram displays the
color components distribution in an image. Displays color
graph for each color component. Shows distribution of the Y,
U, V, A or R, G, B <br>
components, depending on input format, in the current frame.
Below each graph a color component scale meter is shown.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">level_height <br>
Set height of level. Default value is 200. Allowed range is
[50, 2048].</p>

<p style="margin-top: 1em">scale_height <br>
Set height of color scale. Default value is 12. Allowed
range is [0, 40].</p>

<p style="margin-top: 1em">display_mode <br>
Set display mode. It accepts the following values:</p>

<p style="margin-top: 1em">parade <br>
Per color component graphs are placed below each other.</p>

<p style="margin-top: 1em">overlay <br>
Presents information identical to that in the
&quot;parade&quot;, except that the graphs representing
color components are superimposed directly over one
another.</p>

<p style="margin-top: 1em">Default is
&quot;parade&quot;.</p>

<p style="margin-top: 1em">levels_mode <br>
Set mode. Can be either &quot;linear&quot;, or
&quot;logarithmic&quot;. Default is &quot;linear&quot;.</p>

<p style="margin-top: 1em">components <br>
Set what color components to display. Default is 7.</p>

<p style="margin-top: 1em">fgopacity <br>
Set foreground opacity. Default is 0.7.</p>

<p style="margin-top: 1em">bgopacity <br>
Set background opacity. Default is 0.5.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Calculate and
draw histogram:</p>

<p style="margin-top: 1em">ffplay -i input -vf
histogram</p>

<p style="margin-top: 1em">hqdn3d <br>
This is a high precision/quality 3d denoise filter. It aims
to reduce image noise, producing smooth images and making
still images really still. It should enhance <br>
compressibility.</p>

<p style="margin-top: 1em">It accepts the following
optional parameters:</p>

<p style="margin-top: 1em">luma_spatial <br>
A non-negative floating point number which specifies spatial
luma strength. It defaults to 4.0.</p>

<p style="margin-top: 1em">chroma_spatial <br>
A non-negative floating point number which specifies spatial
chroma strength. It defaults to 3.0*luma_spatial/4.0.</p>

<p style="margin-top: 1em">luma_tmp <br>
A floating point number which specifies luma temporal
strength. It defaults to 6.0*luma_spatial/4.0.</p>

<p style="margin-top: 1em">chroma_tmp <br>
A floating point number which specifies chroma temporal
strength. It defaults to
luma_tmp*chroma_spatial/luma_spatial.</p>

<p style="margin-top: 1em">hwupload_cuda <br>
Upload system memory frames to a CUDA device.</p>

<p style="margin-top: 1em">It accepts the following
optional parameters:</p>

<p style="margin-top: 1em">device <br>
The number of the CUDA device to use</p>

<p style="margin-top: 1em">hqx <br>
Apply a high-quality magnification filter designed for pixel
art. This filter was originally created by Maxim Stepin.</p>

<p style="margin-top: 1em">It accepts the following
option:</p>

<p style="margin-top: 1em">n Set the scaling dimension: 2
for &quot;hq2x&quot;, 3 for &quot;hq3x&quot; and 4 for
&quot;hq4x&quot;. Default is 3.</p>

<p style="margin-top: 1em">hstack <br>
Stack input videos horizontally.</p>

<p style="margin-top: 1em">All streams must be of same
pixel format and of same height.</p>

<p style="margin-top: 1em">Note that this filter is faster
than using overlay and pad filter to create same output.</p>

<p style="margin-top: 1em">The filter accept the following
option:</p>

<p style="margin-top: 1em">inputs <br>
Set number of input streams. Default is 2.</p>

<p style="margin-top: 1em">shortest <br>
If set to 1, force the output to terminate when the shortest
input terminates. Default value is 0.</p>

<p style="margin-top: 1em">hue <br>
Modify the hue and/or the saturation of the input.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">h Specify the hue angle as a
number of degrees. It accepts an expression, and defaults to
&quot;0&quot;.</p>

<p style="margin-top: 1em">s Specify the saturation in the
[-10,10] range. It accepts an expression and defaults to
&quot;1&quot;.</p>

<p style="margin-top: 1em">H Specify the hue angle as a
number of radians. It accepts an expression, and defaults to
&quot;0&quot;.</p>

<p style="margin-top: 1em">b Specify the brightness in the
[-10,10] range. It accepts an expression and defaults to
&quot;0&quot;.</p>

<p style="margin-top: 1em">h and H are mutually exclusive,
and can&rsquo;t be specified at the same time.</p>

<p style="margin-top: 1em">The b, h, H and s option values
are expressions containing the following constants:</p>

<p style="margin-top: 1em">n frame count of the input frame
starting from 0</p>

<p style="margin-top: 1em">pts presentation timestamp of
the input frame expressed in time base units</p>

<p style="margin-top: 1em">r frame rate of the input video,
NAN if the input frame rate is unknown</p>

<p style="margin-top: 1em">t timestamp expressed in
seconds, NAN if the input timestamp is unknown</p>

<p style="margin-top: 1em">tb time base of the input
video</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Set the hue to
90 degrees and the saturation to 1.0:</p>

<p style="margin-top: 1em">hue=h=90:s=1</p>

<p style="margin-top: 1em">&Acirc;&middot; Same command but
expressing the hue in radians:</p>

<p style="margin-top: 1em">hue=H=PI/2:s=1</p>

<p style="margin-top: 1em">&Acirc;&middot; Rotate hue and
make the saturation swing between 0 and 2 over a period of 1
second:</p>

<p style="margin-top: 1em">hue=&quot;H=2*PI*t:
s=sin(2*PI*t)+1&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply a 3
seconds saturation fade-in effect starting at 0:</p>

<p style="margin-top: 1em">hue=&quot;s=min(t/31)&quot;</p>

<p style="margin-top: 1em">The general fade-in expression
can be written as:</p>

<p style="margin-top: 1em">hue=&quot;s=min(0
max((t-START)/DURATION 1))&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply a 3
seconds saturation fade-out effect starting at 5
seconds:</p>

<p style="margin-top: 1em">hue=&quot;s=max(0 min(1
(8-t)/3))&quot;</p>

<p style="margin-top: 1em">The general fade-out expression
can be written as:</p>

<p style="margin-top: 1em">hue=&quot;s=max(0 min(1
(START+DURATION-t)/DURATION))&quot;</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">This filter supports the
following commands:</p>

<p style="margin-top: 1em">b <br>
s <br>
h <br>
H Modify the hue and/or the saturation and/or brightness of
the input video. The command accepts the same syntax of the
corresponding option.</p>

<p style="margin-top: 1em">If the specified expression is
not valid, it is kept at its current value.</p>

<p style="margin-top: 1em">hysteresis <br>
Grow first stream into second stream by connecting
components. This makes it possible to build more robust edge
masks.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">planes <br>
Set which planes will be processed as bitmap, unprocessed
planes will be copied from first stream. By default value
0xf, all planes will be processed.</p>

<p style="margin-top: 1em">threshold <br>
Set threshold which is used in filtering. If pixel component
value is higher than this value filter algorithm for
connecting components is activated. By default value is
0.</p>

<p style="margin-top: 1em">idet <br>
Detect video interlacing type.</p>

<p style="margin-top: 1em">This filter tries to detect if
the input frames are interlaced, progressive, top or bottom
field first. It will also try to detect fields that are
repeated between adjacent <br>
frames (a sign of telecine).</p>

<p style="margin-top: 1em">Single frame detection considers
only immediately adjacent frames when classifying each
frame. Multiple frame detection incorporates the
classification history of previous <br>
frames.</p>

<p style="margin-top: 1em">The filter will log these
metadata values:</p>

<p style="margin-top: 1em">single.current_frame <br>
Detected type of current frame using single-frame detection.
One of: &lsquo;&lsquo;tff&rsquo;&rsquo; (top field first),
&lsquo;&lsquo;bff&rsquo;&rsquo; (bottom field first),
&lsquo;&lsquo;progressive&rsquo;&rsquo;, or
&lsquo;&lsquo;undetermined&rsquo;&rsquo;</p>

<p style="margin-top: 1em">single.tff <br>
Cumulative number of frames detected as top field first
using single-frame detection.</p>

<p style="margin-top: 1em">multiple.tff <br>
Cumulative number of frames detected as top field first
using multiple-frame detection.</p>

<p style="margin-top: 1em">single.bff <br>
Cumulative number of frames detected as bottom field first
using single-frame detection.</p>

<p style="margin-top: 1em">multiple.current_frame <br>
Detected type of current frame using multiple-frame
detection. One of: &lsquo;&lsquo;tff&rsquo;&rsquo; (top
field first), &lsquo;&lsquo;bff&rsquo;&rsquo; (bottom field
first), &lsquo;&lsquo;progressive&rsquo;&rsquo;, or
&lsquo;&lsquo;undetermined&rsquo;&rsquo;</p>

<p style="margin-top: 1em">multiple.bff <br>
Cumulative number of frames detected as bottom field first
using multiple-frame detection.</p>

<p style="margin-top: 1em">single.progressive <br>
Cumulative number of frames detected as progressive using
single-frame detection.</p>

<p style="margin-top: 1em">multiple.progressive <br>
Cumulative number of frames detected as progressive using
multiple-frame detection.</p>

<p style="margin-top: 1em">single.undetermined <br>
Cumulative number of frames that could not be classified
using single-frame detection.</p>

<p style="margin-top: 1em">multiple.undetermined <br>
Cumulative number of frames that could not be classified
using multiple-frame detection.</p>

<p style="margin-top: 1em">repeated.current_frame <br>
Which field in the current frame is repeated from the last.
One of &lsquo;&lsquo;neither&rsquo;&rsquo;,
&lsquo;&lsquo;top&rsquo;&rsquo;, or
&lsquo;&lsquo;bottom&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">repeated.neither <br>
Cumulative number of frames with no repeated field.</p>

<p style="margin-top: 1em">repeated.top <br>
Cumulative number of frames with the top field repeated from
the previous frame&rsquo;s top field.</p>

<p style="margin-top: 1em">repeated.bottom <br>
Cumulative number of frames with the bottom field repeated
from the previous frame&rsquo;s bottom field.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">intl_thres <br>
Set interlacing threshold.</p>

<p style="margin-top: 1em">prog_thres <br>
Set progressive threshold.</p>

<p style="margin-top: 1em">rep_thres <br>
Threshold for repeated field detection.</p>

<p style="margin-top: 1em">half_life <br>
Number of frames after which a given frame&rsquo;s
contribution to the statistics is halved (i.e., it
contributes only 0.5 to its classification). The default of
0 means that all <br>
frames seen are given full weight of 1.0 forever.</p>

<p style="margin-top: 1em">analyze_interlaced_flag <br>
When this is not 0 then idet will use the specified number
of frames to determine if the interlaced flag is accurate,
it will not count undetermined frames. If the flag is <br>
found to be accurate it will be used without any further
computations, if it is found to be inaccurate it will be
cleared without any further computations. This allows <br>
inserting the idet filter as a low computational method to
clean up the interlaced flag</p>

<p style="margin-top: 1em">il <br>
Deinterleave or interleave fields.</p>

<p style="margin-top: 1em">This filter allows one to
process interlaced images fields without deinterlacing them.
Deinterleaving splits the input frame into 2 fields (so
called half pictures). Odd lines <br>
are moved to the top half of the output image, even lines to
the bottom half. You can process (filter) them independently
and then re-interleave them.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">luma_mode, l <br>
chroma_mode, c <br>
alpha_mode, a <br>
Available values for luma_mode, chroma_mode and alpha_mode
are:</p>

<p style="margin-top: 1em">none <br>
Do nothing.</p>

<p style="margin-top: 1em">deinterleave, d <br>
Deinterleave fields, placing one above the other.</p>

<p style="margin-top: 1em">interleave, i <br>
Interleave fields. Reverse the effect of deinterleaving.</p>

<p style="margin-top: 1em">Default value is
&quot;none&quot;.</p>

<p style="margin-top: 1em">luma_swap, ls <br>
chroma_swap, cs <br>
alpha_swap, as <br>
Swap luma/chroma/alpha fields. Exchange even &amp; odd
lines. Default value is 0.</p>

<p style="margin-top: 1em">inflate <br>
Apply inflate effect to the video.</p>

<p style="margin-top: 1em">This filter replaces the pixel
by the local(3x3) average by taking into account only values
higher than the pixel.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">threshold0 <br>
threshold1 <br>
threshold2 <br>
threshold3 <br>
Limit the maximum change for each plane, default is 65535.
If 0, plane will remain unchanged.</p>

<p style="margin-top: 1em">interlace <br>
Simple interlacing filter from progressive contents. This
interleaves upper (or lower) lines from odd frames with
lower (or upper) lines from even frames, halving the frame
rate <br>
and preserving image height.</p>

<p style="margin-top: 1em">Original Original New Frame <br>
Frame &rsquo;j&rsquo; Frame &rsquo;j+1&rsquo; (tff) <br>
========== =========== ================== <br>
Line 0 --------------------&gt; Frame &rsquo;j&rsquo; Line 0
<br>
Line 1 Line 1 ----&gt; Frame &rsquo;j+1&rsquo; Line 1 <br>
Line 2 ---------------------&gt; Frame &rsquo;j&rsquo; Line
2 <br>
Line 3 Line 3 ----&gt; Frame &rsquo;j+1&rsquo; Line 3 <br>
... ... ... <br>
New Frame + 1 will be generated by Frame &rsquo;j+2&rsquo;
and Frame &rsquo;j+3&rsquo; and so on</p>

<p style="margin-top: 1em">It accepts the following
optional parameters:</p>

<p style="margin-top: 1em">scan <br>
This determines whether the interlaced frame is taken from
the even (tff - default) or odd (bff) lines of the
progressive frame.</p>

<p style="margin-top: 1em">lowpass <br>
Enable (default) or disable the vertical lowpass filter to
avoid twitter interlacing and reduce moire patterns.</p>

<p style="margin-top: 1em">kerndeint <br>
Deinterlace input video by applying Donald Graft&rsquo;s
adaptive kernel deinterling. Work on interlaced parts of a
video to produce progressive frames.</p>

<p style="margin-top: 1em">The description of the accepted
parameters follows.</p>

<p style="margin-top: 1em">thresh <br>
Set the threshold which affects the filter&rsquo;s tolerance
when determining if a pixel line must be processed. It must
be an integer in the range [0,255] and defaults to 10. A
<br>
value of 0 will result in applying the process on every
pixels.</p>

<p style="margin-top: 1em">map Paint pixels exceeding the
threshold value to white if set to 1. Default is 0.</p>

<p style="margin-top: 1em">order <br>
Set the fields order. Swap fields if set to 1, leave fields
alone if 0. Default is 0.</p>

<p style="margin-top: 1em">sharp <br>
Enable additional sharpening if set to 1. Default is 0.</p>

<p style="margin-top: 1em">twoway <br>
Enable twoway sharpening if set to 1. Default is 0.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply default
values:</p>


<p style="margin-top: 1em">kerndeint=thresh=10:map=0:order=0:sharp=0:twoway=0</p>

<p style="margin-top: 1em">&Acirc;&middot; Enable
additional sharpening:</p>

<p style="margin-top: 1em">kerndeint=sharp=1</p>

<p style="margin-top: 1em">&Acirc;&middot; Paint processed
pixels in white:</p>

<p style="margin-top: 1em">kerndeint=map=1</p>

<p style="margin-top: 1em">lenscorrection <br>
Correct radial lens distortion</p>

<p style="margin-top: 1em">This filter can be used to
correct for radial distortion as can result from the use of
wide angle lenses, and thereby re-rectify the image. To find
the right parameters one can <br>
use tools available for example as part of opencv or simply
trial-and-error. To use opencv use the calibration sample
(under samples/cpp) from the opencv sources and extract the
<br>
k1 and k2 coefficients from the resulting matrix.</p>

<p style="margin-top: 1em">Note that effectively the same
filter is available in the open-source tools Krita and
Digikam from the KDE project.</p>

<p style="margin-top: 1em">In contrast to the vignette
filter, which can also be used to compensate lens errors,
this filter corrects the distortion of the image, whereas
vignette corrects the brightness <br>
distribution, so you may want to use both filters together
in certain cases, though you will have to take care of
ordering, i.e. whether vignetting should be applied before
or <br>
after lens correction.</p>

<p style="margin-top: 1em">Options</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">cx Relative x-coordinate of the
focal point of the image, and thereby the center of the
distortion. This value has a range [0,1] and is expressed as
fractions of the image <br>
width.</p>

<p style="margin-top: 1em">cy Relative y-coordinate of the
focal point of the image, and thereby the center of the
distortion. This value has a range [0,1] and is expressed as
fractions of the image <br>
height.</p>

<p style="margin-top: 1em">k1 Coefficient of the quadratic
correction term. 0.5 means no correction.</p>

<p style="margin-top: 1em">k2 Coefficient of the double
quadratic correction term. 0.5 means no correction.</p>

<p style="margin-top: 1em">The formula that generates the
correction is:</p>

<p style="margin-top: 1em">r_src = r_tgt * (1 + k1 * (r_tgt
/ r_0)^2 + k2 * (r_tgt / r_0)^4)</p>

<p style="margin-top: 1em">where r_0 is halve of the image
diagonal and r_src and r_tgt are the distances from the
focal point in the source and target images,
respectively.</p>

<p style="margin-top: 1em">loop <br>
Loop video frames.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">loop <br>
Set the number of loops.</p>

<p style="margin-top: 1em">size <br>
Set maximal size in number of frames.</p>

<p style="margin-top: 1em">start <br>
Set first frame of loop.</p>

<p style="margin-top: 1em">lut3d <br>
Apply a 3D LUT to an input video.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">file <br>
Set the 3D LUT file name.</p>

<p style="margin-top: 1em">Currently supported formats:</p>

<p style="margin-top: 1em">3dl AfterEffects</p>

<p style="margin-top: 1em">cube <br>
Iridas</p>

<p style="margin-top: 1em">dat DaVinci</p>

<p style="margin-top: 1em">m3d Pandora</p>

<p style="margin-top: 1em">interp <br>
Select interpolation mode.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">nearest <br>
Use values from the nearest defined point.</p>

<p style="margin-top: 1em">trilinear <br>
Interpolate values using the 8 points defining a cube.</p>

<p style="margin-top: 1em">tetrahedral <br>
Interpolate values using a tetrahedron.</p>

<p style="margin-top: 1em">lut, lutrgb, lutyuv <br>
Compute a look-up table for binding each pixel component
input value to an output value, and apply it to the input
video.</p>

<p style="margin-top: 1em">lutyuv applies a lookup table to
a YUV input video, lutrgb to an RGB input video.</p>

<p style="margin-top: 1em">These filters accept the
following parameters:</p>

<p style="margin-top: 1em">c0 set first pixel component
expression</p>

<p style="margin-top: 1em">c1 set second pixel component
expression</p>

<p style="margin-top: 1em">c2 set third pixel component
expression</p>

<p style="margin-top: 1em">c3 set fourth pixel component
expression, corresponds to the alpha component</p>

<p style="margin-top: 1em">r set red component
expression</p>

<p style="margin-top: 1em">g set green component
expression</p>

<p style="margin-top: 1em">b set blue component
expression</p>

<p style="margin-top: 1em">a alpha component expression</p>

<p style="margin-top: 1em">y set Y/luminance component
expression</p>

<p style="margin-top: 1em">u set U/Cb component
expression</p>

<p style="margin-top: 1em">v set V/Cr component
expression</p>

<p style="margin-top: 1em">Each of them specifies the
expression to use for computing the lookup table for the
corresponding pixel component values.</p>

<p style="margin-top: 1em">The exact component associated
to each of the c* options depends on the format in
input.</p>

<p style="margin-top: 1em">The lut filter requires either
YUV or RGB pixel formats in input, lutrgb requires RGB pixel
formats in input, and lutyuv requires YUV.</p>

<p style="margin-top: 1em">The expressions can contain the
following constants and functions:</p>

<p style="margin-top: 1em">w <br>
h The input width and height.</p>

<p style="margin-top: 1em">val The input value for the
pixel component.</p>

<p style="margin-top: 1em">clipval <br>
The input value, clipped to the minval-maxval range.</p>

<p style="margin-top: 1em">maxval <br>
The maximum value for the pixel component.</p>

<p style="margin-top: 1em">minval <br>
The minimum value for the pixel component.</p>

<p style="margin-top: 1em">negval <br>
The negated value for the pixel component value, clipped to
the minval-maxval range; it corresponds to the expression
&quot;maxval-clipval+minval&quot;.</p>

<p style="margin-top: 1em">clip(val) <br>
The computed value in val, clipped to the minval-maxval
range.</p>

<p style="margin-top: 1em">gammaval(gamma) <br>
The computed gamma correction value of the pixel component
value, clipped to the minval-maxval range. It corresponds to
the expression <br>

&quot;pow((clipval-minval)/(maxval-minval)gamma)*(maxval-minval)+minval&quot;</p>

<p style="margin-top: 1em">All expressions default to
&quot;val&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Negate input
video:</p>


<p style="margin-top: 1em">lutrgb=&quot;r=maxval+minval-val:g=maxval+minval-val:b=maxval+minval-val&quot;
<br>

lutyuv=&quot;y=maxval+minval-val:u=maxval+minval-val:v=maxval+minval-val&quot;</p>

<p style="margin-top: 1em">The above is the same as:</p>


<p style="margin-top: 1em">lutrgb=&quot;r=negval:g=negval:b=negval&quot;
<br>
lutyuv=&quot;y=negval:u=negval:v=negval&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Negate
luminance:</p>

<p style="margin-top: 1em">lutyuv=y=negval</p>

<p style="margin-top: 1em">&Acirc;&middot; Remove chroma
components, turning the video into a graytone image:</p>


<p style="margin-top: 1em">lutyuv=&quot;u=128:v=128&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply a luma
burning effect:</p>

<p style="margin-top: 1em">lutyuv=&quot;y=2*val&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Remove green and
blue components:</p>

<p style="margin-top: 1em">lutrgb=&quot;g=0:b=0&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Set a constant
alpha channel value on input:</p>


<p style="margin-top: 1em">format=rgba,lutrgb=a=&quot;maxval-minval/2&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Correct
luminance gamma by a factor of 0.5:</p>

<p style="margin-top: 1em">lutyuv=y=gammaval(0.5)</p>

<p style="margin-top: 1em">&Acirc;&middot; Discard least
significant bits of luma:</p>

<p style="margin-top: 1em">lutyuv=y=&rsquo;bitand(val,
128+64+32)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Technicolor like
effect:</p>


<p style="margin-top: 1em">lutyuv=u=&rsquo;(val-maxval/2)*2+maxval/2&rsquo;:v=&rsquo;(val-maxval/2)*2+maxval/2&rsquo;</p>

<p style="margin-top: 1em">lut2 <br>
Compute and apply a lookup table from two video inputs.</p>

<p style="margin-top: 1em">This filter accepts the
following parameters:</p>

<p style="margin-top: 1em">c0 set first pixel component
expression</p>

<p style="margin-top: 1em">c1 set second pixel component
expression</p>

<p style="margin-top: 1em">c2 set third pixel component
expression</p>

<p style="margin-top: 1em">c3 set fourth pixel component
expression, corresponds to the alpha component</p>

<p style="margin-top: 1em">Each of them specifies the
expression to use for computing the lookup table for the
corresponding pixel component values.</p>

<p style="margin-top: 1em">The exact component associated
to each of the c* options depends on the format in
inputs.</p>

<p style="margin-top: 1em">The expressions can contain the
following constants:</p>

<p style="margin-top: 1em">w <br>
h The input width and height.</p>

<p style="margin-top: 1em">x The first input value for the
pixel component.</p>

<p style="margin-top: 1em">y The second input value for the
pixel component.</p>

<p style="margin-top: 1em">bdx The first input video bit
depth.</p>

<p style="margin-top: 1em">bdy The second input video bit
depth.</p>

<p style="margin-top: 1em">All expressions default to
&quot;x&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Highlight
differences between two RGB video streams:</p>


<p style="margin-top: 1em">lut2=&rsquo;ifnot(x-y,0,pow(2,bdx)-1):ifnot(x-y,0,pow(2,bdx)-1):ifnot(x-y,0,pow(2,bdx)-1)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Highlight
differences between two YUV video streams:</p>


<p style="margin-top: 1em">lut2=&rsquo;ifnot(x-y,0,pow(2,bdx)-1):ifnot(x-y,pow(2,bdx-1),pow(2,bdx)-1):ifnot(x-y,pow(2,bdx-1),pow(2,bdx)-1)&rsquo;</p>

<p style="margin-top: 1em">maskedclamp <br>
Clamp the first input stream with the second input and third
input stream.</p>

<p style="margin-top: 1em">Returns the value of first
stream to be between second input stream -
&quot;undershoot&quot; and third input stream +
&quot;overshoot&quot;.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">undershoot <br>
Default value is 0.</p>

<p style="margin-top: 1em">overshoot <br>
Default value is 0.</p>

<p style="margin-top: 1em">planes <br>
Set which planes will be processed as bitmap, unprocessed
planes will be copied from first stream. By default value
0xf, all planes will be processed.</p>

<p style="margin-top: 1em">maskedmerge <br>
Merge the first input stream with the second input stream
using per pixel weights in the third input stream.</p>

<p style="margin-top: 1em">A value of 0 in the third stream
pixel component means that pixel component from first stream
is returned unchanged, while maximum value (eg. 255 for
8-bit videos) means that <br>
pixel component from second stream is returned unchanged.
Intermediate values define the amount of merging between
both input stream&rsquo;s pixel components.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">planes <br>
Set which planes will be processed as bitmap, unprocessed
planes will be copied from first stream. By default value
0xf, all planes will be processed.</p>

<p style="margin-top: 1em">mcdeint <br>
Apply motion-compensation deinterlacing.</p>

<p style="margin-top: 1em">It needs one field per frame as
input and must thus be used together with yadif=1/3 or
equivalent.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">mode <br>
Set the deinterlacing mode.</p>

<p style="margin-top: 1em">It accepts one of the following
values:</p>

<p style="margin-top: 1em">fast <br>
medium <br>
slow <br>
use iterative motion estimation</p>

<p style="margin-top: 1em">extra_slow <br>
like slow, but use multiple reference frames.</p>

<p style="margin-top: 1em">Default value is fast.</p>

<p style="margin-top: 1em">parity <br>
Set the picture field parity assumed for the input video. It
must be one of the following values:</p>

<p style="margin-top: 1em">0, tff <br>
assume top field first</p>

<p style="margin-top: 1em">1, bff <br>
assume bottom field first</p>

<p style="margin-top: 1em">Default value is bff.</p>

<p style="margin-top: 1em">qp Set per-block quantization
parameter (QP) used by the internal encoder.</p>

<p style="margin-top: 1em">Higher values should result in a
smoother motion vector field but less optimal individual
vectors. Default value is 1.</p>

<p style="margin-top: 1em">mergeplanes <br>
Merge color channel components from several video
streams.</p>

<p style="margin-top: 1em">The filter accepts up to 4 input
streams, and merge selected input planes to the output
video.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">mapping <br>
Set input to output plane mapping. Default is 0.</p>

<p style="margin-top: 1em">The mappings is specified as a
bitmap. It should be specified as a hexadecimal number in
the form 0xAa[Bb[Cc[Dd]]]. &rsquo;Aa&rsquo; describes the
mapping for the first plane of the <br>
output stream. &rsquo;A&rsquo; sets the number of the input
stream to use (from 0 to 3), and &rsquo;a&rsquo; the plane
number of the corresponding input to use (from 0 to 3). The
rest of the <br>
mappings is similar, &rsquo;Bb&rsquo; describes the mapping
for the output stream second plane, &rsquo;Cc&rsquo;
describes the mapping for the output stream third plane and
&rsquo;Dd&rsquo; describes the <br>
mapping for the output stream fourth plane.</p>

<p style="margin-top: 1em">format <br>
Set output pixel format. Default is
&quot;yuva444p&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Merge three gray
video streams of same width and height into single video
stream:</p>


<p style="margin-top: 1em">[a0][a1][a2]mergeplanes=0x001020:yuv444p</p>

<p style="margin-top: 1em">&Acirc;&middot; Merge 1st
yuv444p stream and 2nd gray video stream into yuva444p video
stream:</p>


<p style="margin-top: 1em">[a0][a1]mergeplanes=0x00010210:yuva444p</p>

<p style="margin-top: 1em">&Acirc;&middot; Swap Y and A
plane in yuva444p stream:</p>


<p style="margin-top: 1em">format=yuva444p,mergeplanes=0x03010200:yuva444p</p>

<p style="margin-top: 1em">&Acirc;&middot; Swap U and V
plane in yuv420p stream:</p>


<p style="margin-top: 1em">format=yuv420p,mergeplanes=0x000201:yuv420p</p>

<p style="margin-top: 1em">&Acirc;&middot; Cast a rgb24
clip to yuv444p:</p>


<p style="margin-top: 1em">format=rgb24,mergeplanes=0x000102:yuv444p</p>

<p style="margin-top: 1em">mestimate <br>
Estimate and export motion vectors using block matching
algorithms. Motion vectors are stored in frame side data to
be used by other filters.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">method <br>
Specify the motion estimation method. Accepts one of the
following values:</p>

<p style="margin-top: 1em">esa Exhaustive search
algorithm.</p>

<p style="margin-top: 1em">tss Three step search
algorithm.</p>

<p style="margin-top: 1em">tdls <br>
Two dimensional logarithmic search algorithm.</p>

<p style="margin-top: 1em">ntss <br>
New three step search algorithm.</p>

<p style="margin-top: 1em">fss Four step search
algorithm.</p>

<p style="margin-top: 1em">ds Diamond search algorithm.</p>

<p style="margin-top: 1em">hexbs <br>
Hexagon-based search algorithm.</p>

<p style="margin-top: 1em">epzs <br>
Enhanced predictive zonal search algorithm.</p>

<p style="margin-top: 1em">umh Uneven multi-hexagon search
algorithm.</p>

<p style="margin-top: 1em">Default value is esa.</p>

<p style="margin-top: 1em">mb_size <br>
Macroblock size. Default 16.</p>

<p style="margin-top: 1em">search_param <br>
Search parameter. Default 7.</p>

<p style="margin-top: 1em">minterpolate <br>
Convert the video to specified frame rate using motion
interpolation.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">fps Specify the output frame
rate. This can be rational e.g. &quot;60000/1001&quot;.
Frames are dropped if fps is lower than source fps. Default
60.</p>

<p style="margin-top: 1em">mi_mode <br>
Motion interpolation mode. Following values are
accepted:</p>

<p style="margin-top: 1em">dup Duplicate previous or next
frame for interpolating new ones.</p>

<p style="margin-top: 1em">blend <br>
Blend source frames. Interpolated frame is mean of previous
and next frames.</p>

<p style="margin-top: 1em">mci Motion compensated
interpolation. Following options are effective when this
mode is selected:</p>

<p style="margin-top: 1em">mc_mode <br>
Motion compensation mode. Following values are accepted:</p>

<p style="margin-top: 1em">obmc <br>
Overlapped block motion compensation.</p>

<p style="margin-top: 1em">aobmc <br>
Adaptive overlapped block motion compensation. Window
weighting coefficients are controlled adaptively according
to the reliabilities of the neighboring motion <br>
vectors to reduce oversmoothing.</p>

<p style="margin-top: 1em">Default mode is obmc.</p>

<p style="margin-top: 1em">me_mode <br>
Motion estimation mode. Following values are accepted:</p>

<p style="margin-top: 1em">bidir <br>
Bidirectional motion estimation. Motion vectors are
estimated for each source frame in both forward and backward
directions.</p>

<p style="margin-top: 1em">bilat <br>
Bilateral motion estimation. Motion vectors are estimated
directly for interpolated frame.</p>

<p style="margin-top: 1em">Default mode is bilat.</p>

<p style="margin-top: 1em">me The algorithm to be used for
motion estimation. Following values are accepted:</p>

<p style="margin-top: 1em">esa Exhaustive search
algorithm.</p>

<p style="margin-top: 1em">tss Three step search
algorithm.</p>

<p style="margin-top: 1em">tdls <br>
Two dimensional logarithmic search algorithm.</p>

<p style="margin-top: 1em">ntss <br>
New three step search algorithm.</p>

<p style="margin-top: 1em">fss Four step search
algorithm.</p>

<p style="margin-top: 1em">ds Diamond search algorithm.</p>

<p style="margin-top: 1em">hexbs <br>
Hexagon-based search algorithm.</p>

<p style="margin-top: 1em">epzs <br>
Enhanced predictive zonal search algorithm.</p>

<p style="margin-top: 1em">umh Uneven multi-hexagon search
algorithm.</p>

<p style="margin-top: 1em">Default algorithm is epzs.</p>

<p style="margin-top: 1em">mb_size <br>
Macroblock size. Default 16.</p>

<p style="margin-top: 1em">search_param <br>
Motion estimation search parameter. Default 32.</p>

<p style="margin-top: 1em">vsmbc <br>
Enable variable-size block motion compensation. Motion
estimation is applied with smaller block sizes at object
boundaries in order to make the them less blur. <br>
Default is 0 (disabled).</p>

<p style="margin-top: 1em">scd Scene change detection
method. Scene change leads motion vectors to be in random
direction. Scene change detection replace interpolated
frames by duplicate ones. May not be <br>
needed for other modes. Following values are accepted:</p>

<p style="margin-top: 1em">none <br>
Disable scene change detection.</p>

<p style="margin-top: 1em">fdiff <br>
Frame difference. Corresponding pixel values are compared
and if it satisfies scd_threshold scene change is
detected.</p>

<p style="margin-top: 1em">Default method is fdiff.</p>

<p style="margin-top: 1em">scd_threshold <br>
Scene change detection threshold. Default is 5.0.</p>

<p style="margin-top: 1em">mpdecimate <br>
Drop frames that do not differ greatly from the previous
frame in order to reduce frame rate.</p>

<p style="margin-top: 1em">The main use of this filter is
for very-low-bitrate encoding (e.g. streaming over dialup
modem), but it could in theory be used for fixing movies
that were inverse-telecined <br>
incorrectly.</p>

<p style="margin-top: 1em">A description of the accepted
options follows.</p>

<p style="margin-top: 1em">max Set the maximum number of
consecutive frames which can be dropped (if positive), or
the minimum interval between dropped frames (if negative).
If the value is 0, the frame is <br>
dropped unregarding the number of previous sequentially
dropped frames.</p>

<p style="margin-top: 1em">Default value is 0.</p>

<p style="margin-top: 1em">hi <br>
lo <br>
frac <br>
Set the dropping threshold values.</p>

<p style="margin-top: 1em">Values for hi and lo are for 8x8
pixel blocks and represent actual pixel value differences,
so a threshold of 64 corresponds to 1 unit of difference for
each pixel, or the <br>
same spread out differently over the block.</p>

<p style="margin-top: 1em">A frame is a candidate for
dropping if no 8x8 blocks differ by more than a threshold of
hi, and if no more than frac blocks (1 meaning the whole
image) differ by more than a <br>
threshold of lo.</p>

<p style="margin-top: 1em">Default value for hi is 64*12,
default value for lo is 64*5, and default value for frac is
0.33.</p>

<p style="margin-top: 1em">negate <br>
Negate input video.</p>

<p style="margin-top: 1em">It accepts an integer in input;
if non-zero it negates the alpha component (if available).
The default value in input is 0.</p>

<p style="margin-top: 1em">nlmeans <br>
Denoise frames using Non-Local Means algorithm.</p>

<p style="margin-top: 1em">Each pixel is adjusted by
looking for other pixels with similar contexts. This context
similarity is defined by comparing their surrounding patches
of size pxp. Patches are <br>
searched in an area of rxr around the pixel.</p>

<p style="margin-top: 1em">Note that the research area
defines centers for patches, which means some patches will
be made of pixels outside that research area.</p>

<p style="margin-top: 1em">The filter accepts the following
options.</p>

<p style="margin-top: 1em">s Set denoising strength.</p>

<p style="margin-top: 1em">p Set patch size.</p>

<p style="margin-top: 1em">pc Same as p but for chroma
planes.</p>

<p style="margin-top: 1em">The default value is 0 and means
automatic.</p>

<p style="margin-top: 1em">r Set research size.</p>

<p style="margin-top: 1em">rc Same as r but for chroma
planes.</p>

<p style="margin-top: 1em">The default value is 0 and means
automatic.</p>

<p style="margin-top: 1em">nnedi <br>
Deinterlace video using neural network edge directed
interpolation.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">weights <br>
Mandatory option, without binary file filter can not work.
Currently file can be found here: <br>

https://github.com/dubhater/vapoursynth-nnedi3/blob/master/src/nnedi3_weights.bin</p>

<p style="margin-top: 1em">deint <br>
Set which frames to deinterlace, by default it is
&quot;all&quot;. Can be &quot;all&quot; or
&quot;interlaced&quot;.</p>

<p style="margin-top: 1em">field <br>
Set mode of operation.</p>

<p style="margin-top: 1em">Can be one of the following:</p>

<p style="margin-top: 1em">af Use frame flags, both
fields.</p>

<p style="margin-top: 1em">a Use frame flags, single
field.</p>

<p style="margin-top: 1em">t Use top field only.</p>

<p style="margin-top: 1em">b Use bottom field only.</p>

<p style="margin-top: 1em">tf Use both fields, top
first.</p>

<p style="margin-top: 1em">bf Use both fields, bottom
first.</p>

<p style="margin-top: 1em">planes <br>
Set which planes to process, by default filter process all
frames.</p>

<p style="margin-top: 1em">nsize <br>
Set size of local neighborhood around each pixel, used by
the predictor neural network.</p>

<p style="margin-top: 1em">Can be one of the following:</p>

<p style="margin-top: 1em">s8x6 <br>
s16x6 <br>
s32x6 <br>
s48x6 <br>
s8x4 <br>
s16x4 <br>
s32x4 <br>
nns Set the number of neurons in predicctor neural network.
Can be one of the following:</p>

<p style="margin-top: 1em">n16 <br>
n32 <br>
n64 <br>
n128 <br>
n256 <br>
qual <br>
Controls the number of different neural network predictions
that are blended together to compute the final output value.
Can be &quot;fast&quot;, default or &quot;slow&quot;.</p>

<p style="margin-top: 1em">etype <br>
Set which set of weights to use in the predictor. Can be one
of the following:</p>

<p style="margin-top: 1em">a weights trained to minimize
absolute error</p>

<p style="margin-top: 1em">s weights trained to minimize
squared error</p>

<p style="margin-top: 1em">pscrn <br>
Controls whether or not the prescreener neural network is
used to decide which pixels should be processed by the
predictor neural network and which can be handled by simple
<br>
cubic interpolation. The prescreener is trained to know
whether cubic interpolation will be sufficient for a pixel
or whether it should be predicted by the predictor nn. <br>
The computational complexity of the prescreener nn is much
less than that of the predictor nn. Since most pixels can be
handled by cubic interpolation, using the prescreener <br>
generally results in much faster processing. The prescreener
is pretty accurate, so the difference between using it and
not using it is almost always unnoticeable.</p>

<p style="margin-top: 1em">Can be one of the following:</p>

<p style="margin-top: 1em">none <br>
original <br>
new</p>

<p style="margin-top: 1em">Default is &quot;new&quot;.</p>

<p style="margin-top: 1em">fapprox <br>
Set various debugging flags.</p>

<p style="margin-top: 1em">noformat <br>
Force libavfilter not to use any of the specified pixel
formats for the input to the next filter.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">pix_fmts <br>
A &rsquo;|&rsquo;-separated list of pixel format names, such
as apix_fmts=yuv420p|monow|rgb24&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Force
libavfilter to use a format different from yuv420p for the
input to the vflip filter:</p>


<p style="margin-top: 1em">noformat=pix_fmts=yuv420p,vflip</p>

<p style="margin-top: 1em">&Acirc;&middot; Convert the
input video to any of the formats not contained in the
list:</p>


<p style="margin-top: 1em">noformat=yuv420p|yuv444p|yuv410p</p>

<p style="margin-top: 1em">noise <br>
Add noise on video input frame.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">all_seed <br>
c0_seed <br>
c1_seed <br>
c2_seed <br>
c3_seed <br>
Set noise seed for specific pixel component or all pixel
components in case of all_seed. Default value is 123457.</p>

<p style="margin-top: 1em">all_strength, alls <br>
c0_strength, c0s <br>
c1_strength, c1s <br>
c2_strength, c2s <br>
c3_strength, c3s <br>
Set noise strength for specific pixel component or all pixel
components in case all_strength. Default value is 0. Allowed
range is [0, 100].</p>

<p style="margin-top: 1em">all_flags, allf <br>
c0_flags, c0f <br>
c1_flags, c1f <br>
c2_flags, c2f <br>
c3_flags, c3f <br>
Set pixel component flags or set flags for all components if
all_flags. Available values for component flags are:</p>

<p style="margin-top: 1em">a averaged temporal noise
(smoother)</p>

<p style="margin-top: 1em">p mix random noise with a
(semi)regular pattern</p>

<p style="margin-top: 1em">t temporal noise (noise pattern
changes between frames)</p>

<p style="margin-top: 1em">u uniform noise (gaussian
otherwise)</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">Add temporal and uniform noise
to input video:</p>

<p style="margin-top: 1em">noise=alls=20:allf=t+u</p>

<p style="margin-top: 1em">null <br>
Pass the video source unchanged to the output.</p>

<p style="margin-top: 1em">ocr <br>
Optical Character Recognition</p>

<p style="margin-top: 1em">This filter uses Tesseract for
optical character recognition.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">datapath <br>
Set datapath to tesseract data. Default is to use whatever
was set at installation.</p>

<p style="margin-top: 1em">language <br>
Set language, default is &quot;eng&quot;.</p>

<p style="margin-top: 1em">whitelist <br>
Set character whitelist.</p>

<p style="margin-top: 1em">blacklist <br>
Set character blacklist.</p>

<p style="margin-top: 1em">The filter exports recognized
text as the frame metadata &quot;lavfi.ocr.text&quot;.</p>

<p style="margin-top: 1em">ocv <br>
Apply a video transform using libopencv.</p>

<p style="margin-top: 1em">To enable this filter, install
the libopencv library and headers and configure FFmpeg with
&quot;--enable-libopencv&quot;.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">filter_name <br>
The name of the libopencv filter to apply.</p>

<p style="margin-top: 1em">filter_params <br>
The parameters to pass to the libopencv filter. If not
specified, the default values are assumed.</p>

<p style="margin-top: 1em">Refer to the official libopencv
documentation for more precise information:
&lt;http://docs.opencv.org/master/modules/imgproc/doc/filtering.html&gt;</p>

<p style="margin-top: 1em">Several libopencv filters are
supported; see the following subsections.</p>

<p style="margin-top: 1em">dilate</p>

<p style="margin-top: 1em">Dilate an image by using a
specific structuring element. It corresponds to the
libopencv function &quot;cvDilate&quot;.</p>

<p style="margin-top: 1em">It accepts the parameters:
struct_el|nb_iterations.</p>

<p style="margin-top: 1em">struct_el represents a
structuring element, and has the syntax:
colsxrows+anchor_xxanchor_y/shape</p>

<p style="margin-top: 1em">cols and rows represent the
number of columns and rows of the structuring element,
anchor_x and anchor_y the anchor point, and shape the shape
for the structuring element. shape <br>
must be &quot;rect&quot;, &quot;cross&quot;,
&quot;ellipse&quot;, or &quot;custom&quot;.</p>

<p style="margin-top: 1em">If the value for shape is
&quot;custom&quot;, it must be followed by a string of the
form &quot;=filename&quot;. The file with name filename is
assumed to represent a binary image, with each <br>
printable character corresponding to a bright pixel. When a
custom shape is used, cols and rows are ignored, the number
or columns and rows of the read file are assumed
instead.</p>

<p style="margin-top: 1em">The default value for struct_el
is &quot;3x3+0x0/rect&quot;.</p>

<p style="margin-top: 1em">nb_iterations specifies the
number of times the transform is applied to the image, and
defaults to 1.</p>

<p style="margin-top: 1em">Some examples:</p>

<p style="margin-top: 1em"># Use the default values <br>
ocv=dilate</p>

<p style="margin-top: 1em"># Dilate using a structuring
element with a 5x5 cross, iterating two times <br>
ocv=filter_name=dilate:filter_params=5x5+2x2/cross|2</p>

<p style="margin-top: 1em"># Read the shape from the file
diamond.shape, iterating two times. <br>
# The file diamond.shape may contain a pattern of characters
like this <br>
# * <br>
# *** <br>
# ***** <br>
# *** <br>
# * <br>
# The specified columns and rows are ignored <br>
# but the anchor point coordinates are not <br>
ocv=dilate:0x0+2x2/custom=diamond.shape|2</p>

<p style="margin-top: 1em">erode</p>

<p style="margin-top: 1em">Erode an image by using a
specific structuring element. It corresponds to the
libopencv function &quot;cvErode&quot;.</p>

<p style="margin-top: 1em">It accepts the parameters:
struct_el:nb_iterations, with the same syntax and semantics
as the dilate filter.</p>

<p style="margin-top: 1em">smooth</p>

<p style="margin-top: 1em">Smooth the input video.</p>

<p style="margin-top: 1em">The filter takes the following
parameters: type|param1|param2|param3|param4.</p>

<p style="margin-top: 1em">type is the type of smooth
filter to apply, and must be one of the following values:
&quot;blur&quot;, &quot;blur_no_scale&quot;,
&quot;median&quot;, &quot;gaussian&quot;, or
&quot;bilateral&quot;. The default value is <br>
&quot;gaussian&quot;.</p>

<p style="margin-top: 1em">The meaning of param1, param2,
param3, and param4 depend on the smooth type. param1 and
param2 accept integer positive values or 0. param3 and
param4 accept floating point <br>
values.</p>

<p style="margin-top: 1em">The default value for param1 is
3. The default value for the other parameters is 0.</p>

<p style="margin-top: 1em">These parameters correspond to
the parameters assigned to the libopencv function
&quot;cvSmooth&quot;.</p>

<p style="margin-top: 1em">overlay <br>
Overlay one video on top of another.</p>

<p style="margin-top: 1em">It takes two inputs and has one
output. The first input is the &quot;main&quot; video on
which the second input is overlaid.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">A description of the accepted
options follows.</p>

<p style="margin-top: 1em">x <br>
y Set the expression for the x and y coordinates of the
overlaid video on the main video. Default value is
&quot;0&quot; for both expressions. In case the expression
is invalid, it is <br>
set to a huge value (meaning that the overlay will not be
displayed within the output visible area).</p>

<p style="margin-top: 1em">eof_action <br>
The action to take when EOF is encountered on the secondary
input; it accepts one of the following values:</p>

<p style="margin-top: 1em">repeat <br>
Repeat the last frame (the default).</p>

<p style="margin-top: 1em">endall <br>
End both streams.</p>

<p style="margin-top: 1em">pass <br>
Pass the main input through.</p>

<p style="margin-top: 1em">eval <br>
Set when the expressions for x, and y are evaluated.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">init <br>
only evaluate expressions once during the filter
initialization or when a command is processed</p>

<p style="margin-top: 1em">frame <br>
evaluate expressions for each incoming frame</p>

<p style="margin-top: 1em">Default value is frame.</p>

<p style="margin-top: 1em">shortest <br>
If set to 1, force the output to terminate when the shortest
input terminates. Default value is 0.</p>

<p style="margin-top: 1em">format <br>
Set the format for the output video.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">yuv420 <br>
force YUV420 output</p>

<p style="margin-top: 1em">yuv422 <br>
force YUV422 output</p>

<p style="margin-top: 1em">yuv444 <br>
force YUV444 output</p>

<p style="margin-top: 1em">rgb force RGB output</p>

<p style="margin-top: 1em">Default value is yuv420.</p>

<p style="margin-top: 1em">rgb (deprecated) <br>
If set to 1, force the filter to accept inputs in the RGB
color space. Default value is 0. This option is deprecated,
use format instead.</p>

<p style="margin-top: 1em">repeatlast <br>
If set to 1, force the filter to draw the last overlay frame
over the main input until the end of the stream. A value of
0 disables this behavior. Default value is 1.</p>

<p style="margin-top: 1em">The x, and y expressions can
contain the following parameters.</p>

<p style="margin-top: 1em">main_w, W <br>
main_h, H <br>
The main input width and height.</p>

<p style="margin-top: 1em">overlay_w, w <br>
overlay_h, h <br>
The overlay input width and height.</p>

<p style="margin-top: 1em">x <br>
y The computed values for x and y. They are evaluated for
each new frame.</p>

<p style="margin-top: 1em">hsub <br>
vsub <br>
horizontal and vertical chroma subsample values of the
output format. For example for the pixel format
&quot;yuv422p&quot; hsub is 2 and vsub is 1.</p>

<p style="margin-top: 1em">n the number of input frame,
starting from 0</p>

<p style="margin-top: 1em">pos the position in the file of
the input frame, NAN if unknown</p>

<p style="margin-top: 1em">t The timestamp, expressed in
seconds. It&rsquo;s NAN if the input timestamp is
unknown.</p>

<p style="margin-top: 1em">Note that the n, pos, t
variables are available only when evaluation is done per
frame, and will evaluate to NAN when eval is set to
init.</p>

<p style="margin-top: 1em">Be aware that frames are taken
from each input video in timestamp order, hence, if their
initial timestamps differ, it is a good idea to pass the two
inputs through a <br>
setpts=PTS-STARTPTS filter to have them begin in the same
zero timestamp, as the example for the movie filter
does.</p>

<p style="margin-top: 1em">You can chain together more
overlays but you should test the efficiency of such
approach.</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">This filter supports the
following commands:</p>

<p style="margin-top: 1em">x <br>
y Modify the x and y of the overlay input. The command
accepts the same syntax of the corresponding option.</p>

<p style="margin-top: 1em">If the specified expression is
not valid, it is kept at its current value.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Draw the overlay
at 10 pixels from the bottom right corner of the main
video:</p>


<p style="margin-top: 1em">overlay=main_w-overlay_w-10:main_h-overlay_h-10</p>

<p style="margin-top: 1em">Using named options the example
above becomes:</p>


<p style="margin-top: 1em">overlay=x=main_w-overlay_w-10:y=main_h-overlay_h-10</p>

<p style="margin-top: 1em">&Acirc;&middot; Insert a
transparent PNG logo in the bottom left corner of the input,
using the ffmpeg tool with the &quot;-filter_complex&quot;
option:</p>

<p style="margin-top: 1em">ffmpeg -i input -i logo
-filter_complex &rsquo;overlay=10:main_h-overlay_h-10&rsquo;
output</p>

<p style="margin-top: 1em">&Acirc;&middot; Insert 2
different transparent PNG logos (second logo on bottom right
corner) using the ffmpeg tool:</p>

<p style="margin-top: 1em">ffmpeg -i input -i logo1 -i
logo2 -filter_complex
&rsquo;overlay=x=10:y=H-h-10,overlay=x=W-w-10:y=H-h-10&rsquo;
output</p>

<p style="margin-top: 1em">&Acirc;&middot; Add a
transparent color layer on top of the main video;
&quot;WxH&quot; must specify the size of the main input to
the overlay filter:</p>

<p style="margin-top: 1em">color=color=red@.3:size=WxH
[over]; [in][over] overlay [out]</p>

<p style="margin-top: 1em">&Acirc;&middot; Play an original
video and a filtered version (here with the deshake filter)
side by side using the ffplay tool:</p>

<p style="margin-top: 1em">ffplay input.avi -vf
&rsquo;split[a][b]; [a]pad=iw*2:ih[src]; [b]deshake[filt];
[src][filt]overlay=w&rsquo;</p>

<p style="margin-top: 1em">The above command is the same
as:</p>

<p style="margin-top: 1em">ffplay input.avi -vf
&rsquo;split[b], pad=iw*2[src], [b]deshake,
[src]overlay=w&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Make a sliding
overlay appearing from the left to the right top part of the
screen starting since time 2:</p>

<p style="margin-top: 1em">overlay=x=&rsquo;if(gte(t,2),
-w+(t-2)*20, NAN)&rsquo;:y=0</p>

<p style="margin-top: 1em">&Acirc;&middot; Compose output
by putting two input videos side to side:</p>

<p style="margin-top: 1em">ffmpeg -i left.avi -i right.avi
-filter_complex &quot; <br>
nullsrc=size=200x100 [background]; <br>
[0:v] setpts=PTS-STARTPTS, scale=100x100 [left]; <br>
[1:v] setpts=PTS-STARTPTS, scale=100x100 [right]; <br>
[background][left] overlay=shortest=1 [background+left];
<br>
[background+left][right] overlay=shortest=1:x=100
[left+right] <br>
&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Mask 10-20
seconds of a video by applying the delogo filter to a
section</p>

<p style="margin-top: 1em">ffmpeg -i test.avi -codec:v:0
wmv2 -ar 11025 -b:v 9000k <br>
-vf
&rsquo;[in]split[split_main][split_delogo];[split_delogo]trim=start=360:end=371,delogo=0:0:640:480[delogoed];[split_main][delogoed]overlay=eof_action=pass[out]&rsquo;
<br>
masked.avi</p>

<p style="margin-top: 1em">&Acirc;&middot; Chain several
overlays in cascade:</p>

<p style="margin-top: 1em">nullsrc=s=200x200 [bg]; <br>
testsrc=s=100x100, split=4 [in0][in1][in2][in3]; <br>
[in0] lutrgb=r=0, [bg] overlay=0:0 [mid0]; <br>
[in1] lutrgb=g=0, [mid0] overlay=100:0 [mid1]; <br>
[in2] lutrgb=b=0, [mid1] overlay=0:100 [mid2]; <br>
[in3] null, [mid2] overlay=100:100 [out0]</p>

<p style="margin-top: 1em">owdenoise <br>
Apply Overcomplete Wavelet denoiser.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">depth <br>
Set depth.</p>

<p style="margin-top: 1em">Larger depth values will denoise
lower frequency components more, but slow down
filtering.</p>

<p style="margin-top: 1em">Must be an int in the range
8-16, default is 8.</p>

<p style="margin-top: 1em">luma_strength, ls <br>
Set luma strength.</p>

<p style="margin-top: 1em">Must be a double value in the
range 0-1000, default is 1.0.</p>

<p style="margin-top: 1em">chroma_strength, cs <br>
Set chroma strength.</p>

<p style="margin-top: 1em">Must be a double value in the
range 0-1000, default is 1.0.</p>

<p style="margin-top: 1em">pad <br>
Add paddings to the input image, and place the original
input at the provided x, y coordinates.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">width, w <br>
height, h <br>
Specify an expression for the size of the output image with
the paddings added. If the value for width or height is 0,
the corresponding input size is used for the output.</p>

<p style="margin-top: 1em">The width expression can
reference the value set by the height expression, and vice
versa.</p>

<p style="margin-top: 1em">The default value of width and
height is 0.</p>

<p style="margin-top: 1em">x <br>
y Specify the offsets to place the input image at within the
padded area, with respect to the top/left border of the
output image.</p>

<p style="margin-top: 1em">The x expression can reference
the value set by the y expression, and vice versa.</p>

<p style="margin-top: 1em">The default value of x and y is
0.</p>

<p style="margin-top: 1em">color <br>
Specify the color of the padded area. For the syntax of this
option, check the &quot;Color&quot; section in the
ffmpeg-utils manual.</p>

<p style="margin-top: 1em">The default value of color is
&quot;black&quot;.</p>

<p style="margin-top: 1em">The value for the width, height,
x, and y options are expressions containing the following
constants:</p>

<p style="margin-top: 1em">in_w <br>
in_h <br>
The input video width and height.</p>

<p style="margin-top: 1em">iw <br>
ih These are the same as in_w and in_h.</p>

<p style="margin-top: 1em">out_w <br>
out_h <br>
The output width and height (the size of the padded area),
as specified by the width and height expressions.</p>

<p style="margin-top: 1em">ow <br>
oh These are the same as out_w and out_h.</p>

<p style="margin-top: 1em">x <br>
y The x and y offsets as specified by the x and y
expressions, or NAN if not yet specified.</p>

<p style="margin-top: 1em">a same as iw / ih</p>

<p style="margin-top: 1em">sar input sample aspect
ratio</p>

<p style="margin-top: 1em">dar input display aspect ratio,
it is the same as (iw / ih) * sar</p>

<p style="margin-top: 1em">hsub <br>
vsub <br>
The horizontal and vertical chroma subsample values. For
example for the pixel format &quot;yuv422p&quot; hsub is 2
and vsub is 1.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Add paddings
with the color &quot;violet&quot; to the input video. The
output video size is 640x480, and the top-left corner of the
input video is placed at column 0, row 40</p>

<p style="margin-top: 1em">pad=640:480:0:40:violet</p>

<p style="margin-top: 1em">The example above is equivalent
to the following command:</p>


<p style="margin-top: 1em">pad=width=640:height=480:x=0:y=40:color=violet</p>

<p style="margin-top: 1em">&Acirc;&middot; Pad the input to
get an output with dimensions increased by 3/2, and put the
input video at the center of the padded area:</p>


<p style="margin-top: 1em">pad=&quot;3/2*iw:3/2*ih:(ow-iw)/2:(oh-ih)/2&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Pad the input to
get a squared output with size equal to the maximum value
between the input width and height, and put the input video
at the center of the padded area:</p>


<p style="margin-top: 1em">pad=&quot;max(iwih):ow:(ow-iw)/2:(oh-ih)/2&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Pad the input to
get a final w/h ratio of 16:9:</p>


<p style="margin-top: 1em">pad=&quot;ih*16/9:ih:(ow-iw)/2:(oh-ih)/2&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; In case of
anamorphic video, in order to set the output display aspect
correctly, it is necessary to use sar in the expression,
according to the relation:</p>

<p style="margin-top: 1em">(ih * X / ih) * sar = output_dar
<br>
X = output_dar / sar</p>

<p style="margin-top: 1em">Thus the previous example needs
to be modified to:</p>


<p style="margin-top: 1em">pad=&quot;ih*16/9/sar:ih:(ow-iw)/2:(oh-ih)/2&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Double the
output size and put the input video in the bottom-right
corner of the output padded area:</p>


<p style="margin-top: 1em">pad=&quot;2*iw:2*ih:ow-iw:oh-ih&quot;</p>

<p style="margin-top: 1em">palettegen <br>
Generate one palette for a whole video stream.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">max_colors <br>
Set the maximum number of colors to quantize in the palette.
Note: the palette will still contain 256 colors; the unused
palette entries will be black.</p>

<p style="margin-top: 1em">reserve_transparent <br>
Create a palette of 255 colors maximum and reserve the last
one for transparency. Reserving the transparency color is
useful for GIF optimization. If not set, the maximum of <br>
colors in the palette will be 256. You probably want to
disable this option for a standalone image. Set by
default.</p>

<p style="margin-top: 1em">stats_mode <br>
Set statistics mode.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">full <br>
Compute full frame histograms.</p>

<p style="margin-top: 1em">diff <br>
Compute histograms only for the part that differs from
previous frame. This might be relevant to give more
importance to the moving part of your input if the
background <br>
is static.</p>

<p style="margin-top: 1em">single <br>
Compute new histogram for each frame.</p>

<p style="margin-top: 1em">Default value is full.</p>

<p style="margin-top: 1em">The filter also exports the
frame metadata &quot;lavfi.color_quant_ratio&quot;
(&quot;nb_color_in / nb_color_out&quot;) which you can use
to evaluate the degree of color quantization of the palette.
<br>
This information is also visible at info logging level.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a
representative palette of a given video using ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i input.mkv -vf
palettegen palette.png</p>

<p style="margin-top: 1em">paletteuse <br>
Use a palette to downsample an input video stream.</p>

<p style="margin-top: 1em">The filter takes two inputs: one
video stream and a palette. The palette must be a 256 pixels
image.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">dither <br>
Select dithering mode. Available algorithms are:</p>

<p style="margin-top: 1em">bayer <br>
Ordered 8x8 bayer dithering (deterministic)</p>

<p style="margin-top: 1em">heckbert <br>
Dithering as defined by Paul Heckbert in 1982 (simple error
diffusion). Note: this dithering is sometimes considered
&quot;wrong&quot; and is included as a reference.</p>

<p style="margin-top: 1em">floyd_steinberg <br>
Floyd and Steingberg dithering (error diffusion)</p>

<p style="margin-top: 1em">sierra2 <br>
Frankie Sierra dithering v2 (error diffusion)</p>

<p style="margin-top: 1em">sierra2_4a <br>
Frankie Sierra dithering v2 &quot;Lite&quot; (error
diffusion)</p>

<p style="margin-top: 1em">Default is sierra2_4a.</p>

<p style="margin-top: 1em">bayer_scale <br>
When bayer dithering is selected, this option defines the
scale of the pattern (how much the crosshatch pattern is
visible). A low value means more visible pattern for less
<br>
banding, and higher value means less visible pattern at the
cost of more banding.</p>

<p style="margin-top: 1em">The option must be an integer
value in the range [0,5]. Default is 2.</p>

<p style="margin-top: 1em">diff_mode <br>
If set, define the zone to process</p>

<p style="margin-top: 1em">rectangle <br>
Only the changing rectangle will be reprocessed. This is
similar to GIF cropping/offsetting compression mechanism.
This option can be useful for speed if only a part of <br>
the image is changing, and has use cases such as limiting
the scope of the error diffusal dither to the rectangle that
bounds the moving scene (it leads to more <br>
deterministic output if the scene doesn&rsquo;t change much,
and as a result less moving noise and better GIF
compression).</p>

<p style="margin-top: 1em">Default is none.</p>

<p style="margin-top: 1em">new Take new palette for each
output frame.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Use a palette
(generated for example with palettegen) to encode a GIF
using ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i input.mkv -i
palette.png -lavfi paletteuse output.gif</p>

<p style="margin-top: 1em">perspective <br>
Correct perspective of video not recorded perpendicular to
the screen.</p>

<p style="margin-top: 1em">A description of the accepted
parameters follows.</p>

<p style="margin-top: 1em">x0 <br>
y0 <br>
x1 <br>
y1 <br>
x2 <br>
y2 <br>
x3 <br>
y3 Set coordinates expression for top left, top right,
bottom left and bottom right corners. Default values are
&quot;0:0:W:0:0:H:W:H&quot; with which perspective will
remain unchanged. <br>
If the &quot;sense&quot; option is set to
&quot;source&quot;, then the specified points will be sent
to the corners of the destination. If the &quot;sense&quot;
option is set to &quot;destination&quot;, then the <br>
corners of the source will be sent to the specified
coordinates.</p>

<p style="margin-top: 1em">The expressions can use the
following variables:</p>

<p style="margin-top: 1em">W <br>
H the width and height of video frame.</p>

<p style="margin-top: 1em">in Input frame count.</p>

<p style="margin-top: 1em">on Output frame count.</p>

<p style="margin-top: 1em">interpolation <br>
Set interpolation for perspective correction.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">linear <br>
cubic</p>

<p style="margin-top: 1em">Default value is linear.</p>

<p style="margin-top: 1em">sense <br>
Set interpretation of coordinate options.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">0, source <br>
Send point in the source specified by the given coordinates
to the corners of the destination.</p>

<p style="margin-top: 1em">1, destination <br>
Send the corners of the source to the point in the
destination specified by the given coordinates.</p>

<p style="margin-top: 1em">Default value is source.</p>

<p style="margin-top: 1em">eval <br>
Set when the expressions for coordinates x0,y0,...x3,y3 are
evaluated.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">init <br>
only evaluate expressions once during the filter
initialization or when a command is processed</p>

<p style="margin-top: 1em">frame <br>
evaluate expressions for each incoming frame</p>

<p style="margin-top: 1em">Default value is init.</p>

<p style="margin-top: 1em">phase <br>
Delay interlaced video by one field time so that the field
order changes.</p>

<p style="margin-top: 1em">The intended use is to fix PAL
movies that have been captured with the opposite field order
to the film-to-video transfer.</p>

<p style="margin-top: 1em">A description of the accepted
parameters follows.</p>

<p style="margin-top: 1em">mode <br>
Set phase mode.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">t Capture field order top-first,
transfer bottom-first. Filter will delay the bottom
field.</p>

<p style="margin-top: 1em">b Capture field order
bottom-first, transfer top-first. Filter will delay the top
field.</p>

<p style="margin-top: 1em">p Capture and transfer with the
same field order. This mode only exists for the
documentation of the other options to refer to, but if you
actually select it, the filter <br>
will faithfully do nothing.</p>

<p style="margin-top: 1em">a Capture field order determined
automatically by field flags, transfer opposite. Filter
selects among t and b modes on a frame by frame basis using
field flags. If no <br>
field information is available, then this works just like
u.</p>

<p style="margin-top: 1em">u Capture unknown or varying,
transfer opposite. Filter selects among t and b on a frame
by frame basis by analyzing the images and selecting the
alternative that produces <br>
best match between the fields.</p>

<p style="margin-top: 1em">T Capture top-first, transfer
unknown or varying. Filter selects among t and p using image
analysis.</p>

<p style="margin-top: 1em">B Capture bottom-first, transfer
unknown or varying. Filter selects among b and p using image
analysis.</p>

<p style="margin-top: 1em">A Capture determined by field
flags, transfer unknown or varying. Filter selects among t,
b and p using field flags and image analysis. If no field
information is <br>
available, then this works just like U. This is the default
mode.</p>

<p style="margin-top: 1em">U Both capture and transfer
unknown or varying. Filter selects among t, b and p using
image analysis only.</p>

<p style="margin-top: 1em">pixdesctest <br>
Pixel format descriptor test filter, mainly useful for
internal testing. The output video should be equal to the
input video.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">format=monow, pixdesctest</p>

<p style="margin-top: 1em">can be used to test the
monowhite pixel format descriptor definition.</p>

<p style="margin-top: 1em">pp <br>
Enable the specified chain of postprocessing subfilters
using libpostproc. This library should be automatically
selected with a GPL build (&quot;--enable-gpl&quot;).
Subfilters must be <br>
separated by &rsquo;/&rsquo; and can be disabled by
prepending a &rsquo;-&rsquo;. Each subfilter and some
options have a short and a long name that can be used
interchangeably, i.e. dr/dering are the <br>
same.</p>

<p style="margin-top: 1em">The filters accept the following
options:</p>

<p style="margin-top: 1em">subfilters <br>
Set postprocessing subfilters string.</p>

<p style="margin-top: 1em">All subfilters share common
options to determine their scope:</p>

<p style="margin-top: 1em">a/autoq <br>
Honor the quality commands for this subfilter.</p>

<p style="margin-top: 1em">c/chrom <br>
Do chrominance filtering, too (default).</p>

<p style="margin-top: 1em">y/nochrom <br>
Do luminance filtering only (no chrominance).</p>

<p style="margin-top: 1em">n/noluma <br>
Do chrominance filtering only (no luminance).</p>

<p style="margin-top: 1em">These options can be appended
after the subfilter name, separated by a
&rsquo;|&rsquo;.</p>

<p style="margin-top: 1em">Available subfilters are:</p>


<p style="margin-top: 1em">hb/hdeblock[|difference[|flatness]]
<br>
Horizontal deblocking filter</p>

<p style="margin-top: 1em">difference <br>
Difference factor where higher values mean more deblocking
(default: 32).</p>

<p style="margin-top: 1em">flatness <br>
Flatness threshold where lower values mean more deblocking
(default: 39).</p>


<p style="margin-top: 1em">vb/vdeblock[|difference[|flatness]]
<br>
Vertical deblocking filter</p>

<p style="margin-top: 1em">difference <br>
Difference factor where higher values mean more deblocking
(default: 32).</p>

<p style="margin-top: 1em">flatness <br>
Flatness threshold where lower values mean more deblocking
(default: 39).</p>


<p style="margin-top: 1em">ha/hadeblock[|difference[|flatness]]
<br>
Accurate horizontal deblocking filter</p>

<p style="margin-top: 1em">difference <br>
Difference factor where higher values mean more deblocking
(default: 32).</p>

<p style="margin-top: 1em">flatness <br>
Flatness threshold where lower values mean more deblocking
(default: 39).</p>


<p style="margin-top: 1em">va/vadeblock[|difference[|flatness]]
<br>
Accurate vertical deblocking filter</p>

<p style="margin-top: 1em">difference <br>
Difference factor where higher values mean more deblocking
(default: 32).</p>

<p style="margin-top: 1em">flatness <br>
Flatness threshold where lower values mean more deblocking
(default: 39).</p>

<p style="margin-top: 1em">The horizontal and vertical
deblocking filters share the difference and flatness values
so you cannot set different horizontal and vertical
thresholds.</p>

<p style="margin-top: 1em">h1/x1hdeblock <br>
Experimental horizontal deblocking filter</p>

<p style="margin-top: 1em">v1/x1vdeblock <br>
Experimental vertical deblocking filter</p>

<p style="margin-top: 1em">dr/dering <br>
Deringing filter</p>


<p style="margin-top: 1em">tn/tmpnoise[|threshold1[|threshold2[|threshold3]]],
temporal noise reducer <br>
threshold1 <br>
larger -&gt; stronger filtering</p>

<p style="margin-top: 1em">threshold2 <br>
larger -&gt; stronger filtering</p>

<p style="margin-top: 1em">threshold3 <br>
larger -&gt; stronger filtering</p>

<p style="margin-top: 1em">al/autolevels[:f/fullyrange],
automatic brightness / contrast correction <br>
f/fullyrange <br>
Stretch luminance to &quot;0-255&quot;.</p>

<p style="margin-top: 1em">lb/linblenddeint <br>
Linear blend deinterlacing filter that deinterlaces the
given block by filtering all lines with a &quot;(1 2
1)&quot; filter.</p>

<p style="margin-top: 1em">li/linipoldeint <br>
Linear interpolating deinterlacing filter that deinterlaces
the given block by linearly interpolating every second
line.</p>

<p style="margin-top: 1em">ci/cubicipoldeint <br>
Cubic interpolating deinterlacing filter deinterlaces the
given block by cubically interpolating every second
line.</p>

<p style="margin-top: 1em">md/mediandeint <br>
Median deinterlacing filter that deinterlaces the given
block by applying a median filter to every second line.</p>

<p style="margin-top: 1em">fd/ffmpegdeint <br>
FFmpeg deinterlacing filter that deinterlaces the given
block by filtering every second line with a &quot;(-1 4 2 4
-1)&quot; filter.</p>

<p style="margin-top: 1em">l5/lowpass5 <br>
Vertically applied FIR lowpass deinterlacing filter that
deinterlaces the given block by filtering all lines with a
&quot;(-1 2 6 2 -1)&quot; filter.</p>

<p style="margin-top: 1em">fq/forceQuant[|quantizer] <br>
Overrides the quantizer table from the input with the
constant quantizer you specify.</p>

<p style="margin-top: 1em">quantizer <br>
Quantizer to use</p>

<p style="margin-top: 1em">de/default <br>
Default pp filter combination
(&quot;hb|a,vb|a,dr|a&quot;)</p>

<p style="margin-top: 1em">fa/fast <br>
Fast pp filter combination (&quot;h1|a,v1|a,dr|a&quot;)</p>

<p style="margin-top: 1em">ac High quality pp filter
combination (&quot;ha|a|128|7,va|a,dr|a&quot;)</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply horizontal
and vertical deblocking, deringing and automatic
brightness/contrast:</p>

<p style="margin-top: 1em">pp=hb/vb/dr/al</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply default
filters without brightness/contrast correction:</p>

<p style="margin-top: 1em">pp=de/-al</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply default
filters and temporal denoiser:</p>

<p style="margin-top: 1em">pp=default/tmpnoise|1|2|3</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply deblocking
on luminance only, and switch vertical deblocking on or off
automatically depending on available CPU time:</p>

<p style="margin-top: 1em">pp=hb|y/vb|a</p>

<p style="margin-top: 1em">pp7 <br>
Apply Postprocessing filter 7. It is variant of the spp
filter, similar to spp = 6 with 7 point DCT, where only the
center sample is used after IDCT.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">qp Force a constant quantization
parameter. It accepts an integer in range 0 to 63. If not
set, the filter will use the QP from the video stream (if
available).</p>

<p style="margin-top: 1em">mode <br>
Set thresholding mode. Available modes are:</p>

<p style="margin-top: 1em">hard <br>
Set hard thresholding.</p>

<p style="margin-top: 1em">soft <br>
Set soft thresholding (better de-ringing effect, but likely
blurrier).</p>

<p style="margin-top: 1em">medium <br>
Set medium thresholding (good results, default).</p>

<p style="margin-top: 1em">prewitt <br>
Apply prewitt operator to input video stream.</p>

<p style="margin-top: 1em">The filter accepts the following
option:</p>

<p style="margin-top: 1em">planes <br>
Set which planes will be processed, unprocessed planes will
be copied. By default value 0xf, all planes will be
processed.</p>

<p style="margin-top: 1em">scale <br>
Set value which will be multiplied with filtered result.</p>

<p style="margin-top: 1em">delta <br>
Set value which will be added to filtered result.</p>

<p style="margin-top: 1em">psnr <br>
Obtain the average, maximum and minimum PSNR (Peak Signal to
Noise Ratio) between two input videos.</p>

<p style="margin-top: 1em">This filter takes in input two
input videos, the first input is considered the
&quot;main&quot; source and is passed unchanged to the
output. The second input is used as a &quot;reference&quot;
<br>
video for computing the PSNR.</p>

<p style="margin-top: 1em">Both video inputs must have the
same resolution and pixel format for this filter to work
correctly. Also it assumes that both inputs have the same
number of frames, which are <br>
compared one by one.</p>

<p style="margin-top: 1em">The obtained average PSNR is
printed through the logging system.</p>

<p style="margin-top: 1em">The filter stores the
accumulated MSE (mean squared error) of each frame, and at
the end of the processing it is averaged across all frames
equally, and the following formula is <br>
applied to obtain the PSNR:</p>

<p style="margin-top: 1em">PSNR = 10*log10(MAX^2/MSE)</p>

<p style="margin-top: 1em">Where MAX is the average of the
maximum values of each component of the image.</p>

<p style="margin-top: 1em">The description of the accepted
parameters follows.</p>

<p style="margin-top: 1em">stats_file, f <br>
If specified the filter will use the named file to save the
PSNR of each individual frame. When filename equals
&quot;-&quot; the data is sent to standard output.</p>

<p style="margin-top: 1em">stats_version <br>
Specifies which version of the stats file format to use.
Details of each format are written below. Default value is
1.</p>

<p style="margin-top: 1em">stats_add_max <br>
Determines whether the max value is output to the stats log.
Default value is 0. Requires stats_version &gt;= 2. If this
is set and stats_version &lt; 2, the filter will return <br>
an error.</p>

<p style="margin-top: 1em">The file printed if stats_file
is selected, contains a sequence of key/value pairs of the
form key:value for each compared couple of frames.</p>

<p style="margin-top: 1em">If a stats_version greater than
1 is specified, a header line precedes the list of
per-frame-pair stats, with key value pairs following the
frame format with the following <br>
parameters:</p>

<p style="margin-top: 1em">psnr_log_version <br>
The version of the log file format. Will match
stats_version.</p>

<p style="margin-top: 1em">fields <br>
A comma separated list of the per-frame-pair parameters
included in the log.</p>

<p style="margin-top: 1em">A description of each shown
per-frame-pair parameter follows:</p>

<p style="margin-top: 1em">n sequential number of the input
frame, starting from 1</p>

<p style="margin-top: 1em">mse_avg <br>
Mean Square Error pixel-by-pixel average difference of the
compared frames, averaged over all the image components.</p>

<p style="margin-top: 1em">mse_y, mse_u, mse_v, mse_r,
mse_g, mse_g, mse_a <br>
Mean Square Error pixel-by-pixel average difference of the
compared frames for the component specified by the
suffix.</p>

<p style="margin-top: 1em">psnr_y, psnr_u, psnr_v, psnr_r,
psnr_g, psnr_b, psnr_a <br>
Peak Signal to Noise ratio of the compared frames for the
component specified by the suffix.</p>

<p style="margin-top: 1em">max_avg, max_y, max_u, max_v
<br>
Maximum allowed value for each channel, and average over all
channels.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">movie=ref_movie.mpg,
setpts=PTS-STARTPTS [main]; <br>
[main][ref] psnr=&quot;stats_file=stats.log&quot; [out]</p>

<p style="margin-top: 1em">On this example the input file
being processed is compared with the reference file
ref_movie.mpg. The PSNR of each individual frame is stored
in stats.log.</p>

<p style="margin-top: 1em">pullup <br>
Pulldown reversal (inverse telecine) filter, capable of
handling mixed hard-telecine, 24000/1001 fps progressive,
and 30000/1001 fps progressive content.</p>

<p style="margin-top: 1em">The pullup filter is designed to
take advantage of future context in making its decisions.
This filter is stateless in the sense that it does not lock
onto a pattern to follow, <br>
but it instead looks forward to the following fields in
order to identify matches and rebuild progressive
frames.</p>

<p style="margin-top: 1em">To produce content with an even
framerate, insert the fps filter after pullup, use
&quot;fps=24000/1001&quot; if the input frame rate is
29.97fps, &quot;fps=24&quot; for 30fps and the (rare) <br>
telecined 25fps input.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">jl <br>
jr <br>
jt <br>
jb These options set the amount of &quot;junk&quot; to
ignore at the left, right, top, and bottom of the image,
respectively. Left and right are in units of 8 pixels, while
top and bottom <br>
are in units of 2 lines. The default is 8 pixels on each
side.</p>

<p style="margin-top: 1em">sb Set the strict breaks.
Setting this option to 1 will reduce the chances of filter
generating an occasional mismatched frame, but it may also
cause an excessive number of <br>
frames to be dropped during high motion sequences.
Conversely, setting it to -1 will make filter match fields
more easily. This may help processing of video where there
is <br>
slight blurring between the fields, but may also cause there
to be interlaced frames in the output. Default value is
0.</p>

<p style="margin-top: 1em">mp Set the metric plane to use.
It accepts the following values:</p>

<p style="margin-top: 1em">l Use luma plane.</p>

<p style="margin-top: 1em">u Use chroma blue plane.</p>

<p style="margin-top: 1em">v Use chroma red plane.</p>

<p style="margin-top: 1em">This option may be set to use
chroma plane instead of the default luma plane for doing
filter&rsquo;s computations. This may improve accuracy on
very clean source material, but <br>
more likely will decrease accuracy, especially if there is
chroma noise (rainbow effect) or any grayscale video. The
main purpose of setting mp to a chroma plane is to <br>
reduce CPU load and make pullup usable in realtime on slow
machines.</p>

<p style="margin-top: 1em">For best results (without
duplicated frames in the output file) it is necessary to
change the output frame rate. For example, to inverse
telecine NTSC input:</p>

<p style="margin-top: 1em">ffmpeg -i input -vf pullup -r
24000/1001 ...</p>

<p style="margin-top: 1em">qp <br>
Change video quantization parameters (QP).</p>

<p style="margin-top: 1em">The filter accepts the following
option:</p>

<p style="margin-top: 1em">qp Set expression for
quantization parameter.</p>

<p style="margin-top: 1em">The expression is evaluated
through the eval API and can contain, among others, the
following constants:</p>

<p style="margin-top: 1em">known <br>
1 if index is not 129, 0 otherwise.</p>

<p style="margin-top: 1em">qp Sequentional index starting
from -129 to 128.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Some equation
like:</p>

<p style="margin-top: 1em">qp=2+2*sin(PI*qp)</p>

<p style="margin-top: 1em">random <br>
Flush video frames from internal cache of frames into a
random order. No frame is discarded. Inspired by frei0r
nervous filter.</p>

<p style="margin-top: 1em">frames <br>
Set size in number of frames of internal cache, in range
from 2 to 512. Default is 30.</p>

<p style="margin-top: 1em">seed <br>
Set seed for random number generator, must be an integer
included between 0 and &quot;UINT32_MAX&quot;. If not
specified, or if explicitly set to less than 0, the filter
will try to <br>
use a good random seed on a best effort basis.</p>

<p style="margin-top: 1em">readvitc <br>
Read vertical interval timecode (VITC) information from the
top lines of a video frame.</p>

<p style="margin-top: 1em">The filter adds frame metadata
key &quot;lavfi.readvitc.tc_str&quot; with the timecode
value, if a valid timecode has been detected. Further
metadata key &quot;lavfi.readvitc.found&quot; is set to <br>
0/1 depending on whether timecode data has been found or
not.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">scan_max <br>
Set the maximum number of lines to scan for VITC data. If
the value is set to &quot;-1&quot; the full video frame is
scanned. Default is 45.</p>

<p style="margin-top: 1em">thr_b <br>
Set the luma threshold for black. Accepts float numbers in
the range [0.0,1.0], default value is 0.2. The value must be
equal or less than &quot;thr_w&quot;.</p>

<p style="margin-top: 1em">thr_w <br>
Set the luma threshold for white. Accepts float numbers in
the range [0.0,1.0], default value is 0.6. The value must be
equal or greater than &quot;thr_b&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Detect and draw
VITC data onto the video frame; if no valid VITC is
detected, draw &quot;--:--:--:--&quot; as a placeholder:</p>

<p style="margin-top: 1em">ffmpeg -i input.avi -filter:v
&rsquo;readvitc,drawtext=fontfile=FreeMono.ttf:text=%{metadata\:lavfi.readvitc.tc_str\:--\\\:--\\\:--\\\:--}:x=(w-tw)/2:y=400-ascent&rsquo;</p>

<p style="margin-top: 1em">remap <br>
Remap pixels using 2nd: Xmap and 3rd: Ymap input video
stream.</p>

<p style="margin-top: 1em">Destination pixel at position
(X, Y) will be picked from source (x, y) position where x =
Xmap(X, Y) and y = Ymap(X, Y). If mapping values are out of
range, zero value for pixel <br>
will be used for destination pixel.</p>

<p style="margin-top: 1em">Xmap and Ymap input video
streams must be of same dimensions. Output video stream will
have Xmap/Ymap video stream dimensions. Xmap and Ymap input
video streams are 16bit depth, <br>
single channel.</p>

<p style="margin-top: 1em">removegrain <br>
The removegrain filter is a spatial denoiser for progressive
video.</p>

<p style="margin-top: 1em">m0 Set mode for the first
plane.</p>

<p style="margin-top: 1em">m1 Set mode for the second
plane.</p>

<p style="margin-top: 1em">m2 Set mode for the third
plane.</p>

<p style="margin-top: 1em">m3 Set mode for the fourth
plane.</p>

<p style="margin-top: 1em">Range of mode is from 0 to 24.
Description of each mode follows:</p>

<p style="margin-top: 1em">0 Leave input plane unchanged.
Default.</p>

<p style="margin-top: 1em">1 Clips the pixel with the
minimum and maximum of the 8 neighbour pixels.</p>

<p style="margin-top: 1em">2 Clips the pixel with the
second minimum and maximum of the 8 neighbour pixels.</p>

<p style="margin-top: 1em">3 Clips the pixel with the third
minimum and maximum of the 8 neighbour pixels.</p>

<p style="margin-top: 1em">4 Clips the pixel with the
fourth minimum and maximum of the 8 neighbour pixels. This
is equivalent to a median filter.</p>

<p style="margin-top: 1em">5 Line-sensitive clipping giving
the minimal change.</p>

<p style="margin-top: 1em">6 Line-sensitive clipping,
intermediate.</p>

<p style="margin-top: 1em">7 Line-sensitive clipping,
intermediate.</p>

<p style="margin-top: 1em">8 Line-sensitive clipping,
intermediate.</p>

<p style="margin-top: 1em">9 Line-sensitive clipping on a
line where the neighbours pixels are the closest.</p>

<p style="margin-top: 1em">10 Replaces the target pixel
with the closest neighbour.</p>

<p style="margin-top: 1em">11 [1 2 1] horizontal and
vertical kernel blur.</p>

<p style="margin-top: 1em">12 Same as mode 11.</p>

<p style="margin-top: 1em">13 Bob mode, interpolates top
field from the line where the neighbours pixels are the
closest.</p>

<p style="margin-top: 1em">14 Bob mode, interpolates bottom
field from the line where the neighbours pixels are the
closest.</p>

<p style="margin-top: 1em">15 Bob mode, interpolates top
field. Same as 13 but with a more complicated interpolation
formula.</p>

<p style="margin-top: 1em">16 Bob mode, interpolates bottom
field. Same as 14 but with a more complicated interpolation
formula.</p>

<p style="margin-top: 1em">17 Clips the pixel with the
minimum and maximum of respectively the maximum and minimum
of each pair of opposite neighbour pixels.</p>

<p style="margin-top: 1em">18 Line-sensitive clipping using
opposite neighbours whose greatest distance from the current
pixel is minimal.</p>

<p style="margin-top: 1em">19 Replaces the pixel with the
average of its 8 neighbours.</p>

<p style="margin-top: 1em">20 Averages the 9 pixels ([1 1
1] horizontal and vertical blur).</p>

<p style="margin-top: 1em">21 Clips pixels using the
averages of opposite neighbour.</p>

<p style="margin-top: 1em">22 Same as mode 21 but simpler
and faster.</p>

<p style="margin-top: 1em">23 Small edge and halo removal,
but reputed useless.</p>

<p style="margin-top: 1em">24 Similar as 23.</p>

<p style="margin-top: 1em">removelogo <br>
Suppress a TV station logo, using an image file to determine
which pixels comprise the logo. It works by filling in the
pixels that comprise the logo with neighboring pixels.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">filename, f <br>
Set the filter bitmap file, which can be any image format
supported by libavformat. The width and height of the image
file must match those of the video stream being <br>
processed.</p>

<p style="margin-top: 1em">Pixels in the provided bitmap
image with a value of zero are not considered part of the
logo, non-zero pixels are considered part of the logo. If
you use white (255) for the logo <br>
and black (0) for the rest, you will be safe. For making the
filter bitmap, it is recommended to take a screen capture of
a black frame with the logo visible, and then using a <br>
threshold filter followed by the erode filter once or
twice.</p>

<p style="margin-top: 1em">If needed, little splotches can
be fixed manually. Remember that if logo pixels are not
covered, the filter quality will be much reduced. Marking
too many pixels as part of the <br>
logo does not hurt as much, but it will increase the amount
of blurring needed to cover over the image and will destroy
more information than necessary, and extra pixels will <br>
slow things down on a large logo.</p>

<p style="margin-top: 1em">repeatfields <br>
This filter uses the repeat_field flag from the Video ES
headers and hard repeats fields based on its value.</p>

<p style="margin-top: 1em">reverse <br>
Reverse a video clip.</p>

<p style="margin-top: 1em">Warning: This filter requires
memory to buffer the entire clip, so trimming is
suggested.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Take the first 5
seconds of a clip, and reverse it.</p>

<p style="margin-top: 1em">trim=end=5,reverse</p>

<p style="margin-top: 1em">rotate <br>
Rotate video by an arbitrary angle expressed in radians.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">A description of the optional
parameters follows.</p>

<p style="margin-top: 1em">angle, a <br>
Set an expression for the angle by which to rotate the input
video clockwise, expressed as a number of radians. A
negative value will result in a counter-clockwise rotation.
<br>
By default it is set to &quot;0&quot;.</p>

<p style="margin-top: 1em">This expression is evaluated for
each frame.</p>

<p style="margin-top: 1em">out_w, ow <br>
Set the output width expression, default value is
&quot;iw&quot;. This expression is evaluated just once
during configuration.</p>

<p style="margin-top: 1em">out_h, oh <br>
Set the output height expression, default value is
&quot;ih&quot;. This expression is evaluated just once
during configuration.</p>

<p style="margin-top: 1em">bilinear <br>
Enable bilinear interpolation if set to 1, a value of 0
disables it. Default value is 1.</p>

<p style="margin-top: 1em">fillcolor, c <br>
Set the color used to fill the output area not covered by
the rotated image. For the general syntax of this option,
check the &quot;Color&quot; section in the ffmpeg-utils
manual. If <br>
the special value &quot;none&quot; is selected then no
background is printed (useful for example if the background
is never shown).</p>

<p style="margin-top: 1em">Default value is
&quot;black&quot;.</p>

<p style="margin-top: 1em">The expressions for the angle
and the output size can contain the following constants and
functions:</p>

<p style="margin-top: 1em">n sequential number of the input
frame, starting from 0. It is always NAN before the first
frame is filtered.</p>

<p style="margin-top: 1em">t time in seconds of the input
frame, it is set to 0 when the filter is configured. It is
always NAN before the first frame is filtered.</p>

<p style="margin-top: 1em">hsub <br>
vsub <br>
horizontal and vertical chroma subsample values. For example
for the pixel format &quot;yuv422p&quot; hsub is 2 and vsub
is 1.</p>

<p style="margin-top: 1em">in_w, iw <br>
in_h, ih <br>
the input video width and height</p>

<p style="margin-top: 1em">out_w, ow <br>
out_h, oh <br>
the output width and height, that is the size of the padded
area as specified by the width and height expressions</p>

<p style="margin-top: 1em">rotw(a) <br>
roth(a) <br>
the minimal width/height required for completely containing
the input video rotated by a radians.</p>

<p style="margin-top: 1em">These are only available when
computing the out_w and out_h expressions.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Rotate the input
by PI/6 radians clockwise:</p>

<p style="margin-top: 1em">rotate=PI/6</p>

<p style="margin-top: 1em">&Acirc;&middot; Rotate the input
by PI/6 radians counter-clockwise:</p>

<p style="margin-top: 1em">rotate=-PI/6</p>

<p style="margin-top: 1em">&Acirc;&middot; Rotate the input
by 45 degrees clockwise:</p>

<p style="margin-top: 1em">rotate=45*PI/180</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply a constant
rotation with period T, starting from an angle of PI/3:</p>

<p style="margin-top: 1em">rotate=PI/3+2*PI*t/T</p>

<p style="margin-top: 1em">&Acirc;&middot; Make the input
video rotation oscillating with a period of T seconds and an
amplitude of A radians:</p>

<p style="margin-top: 1em">rotate=A*sin(2*PI/T*t)</p>

<p style="margin-top: 1em">&Acirc;&middot; Rotate the
video, output size is chosen so that the whole rotating
input video is always completely contained in the
output:</p>


<p style="margin-top: 1em">rotate=&rsquo;2*PI*t:ow=hypot(iw,ih):oh=ow&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Rotate the
video, reduce the output size so that no background is ever
shown:</p>


<p style="margin-top: 1em">rotate=2*PI*t:ow=&rsquo;min(iw,ih)/sqrt(2)&rsquo;:oh=ow:c=none</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">The filter supports the
following commands:</p>

<p style="margin-top: 1em">a, angle <br>
Set the angle expression. The command accepts the same
syntax of the corresponding option.</p>

<p style="margin-top: 1em">If the specified expression is
not valid, it is kept at its current value.</p>

<p style="margin-top: 1em">sab <br>
Apply Shape Adaptive Blur.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">luma_radius, lr <br>
Set luma blur filter strength, must be a value in range
0.1-4.0, default value is 1.0. A greater value will result
in a more blurred image, and in slower processing.</p>

<p style="margin-top: 1em">luma_pre_filter_radius, lpfr
<br>
Set luma pre-filter radius, must be a value in the 0.1-2.0
range, default value is 1.0.</p>

<p style="margin-top: 1em">luma_strength, ls <br>
Set luma maximum difference between pixels to still be
considered, must be a value in the 0.1-100.0 range, default
value is 1.0.</p>

<p style="margin-top: 1em">chroma_radius, cr <br>
Set chroma blur filter strength, must be a value in range
-0.9-4.0. A greater value will result in a more blurred
image, and in slower processing.</p>

<p style="margin-top: 1em">chroma_pre_filter_radius, cpfr
<br>
Set chroma pre-filter radius, must be a value in the
-0.9-2.0 range.</p>

<p style="margin-top: 1em">chroma_strength, cs <br>
Set chroma maximum difference between pixels to still be
considered, must be a value in the -0.9-100.0 range.</p>

<p style="margin-top: 1em">Each chroma option value, if not
explicitly specified, is set to the corresponding luma
option value.</p>

<p style="margin-top: 1em">scale <br>
Scale (resize) the input video, using the libswscale
library.</p>

<p style="margin-top: 1em">The scale filter forces the
output display aspect ratio to be the same of the input, by
changing the output sample aspect ratio.</p>

<p style="margin-top: 1em">If the input image format is
different from the format requested by the next filter, the
scale filter will convert the input to the requested
format.</p>

<p style="margin-top: 1em">Options</p>

<p style="margin-top: 1em">The filter accepts the following
options, or any of the options supported by the libswscale
scaler.</p>

<p style="margin-top: 1em">See the ffmpeg-scaler manual for
the complete list of scaler options.</p>

<p style="margin-top: 1em">width, w <br>
height, h <br>
Set the output video dimension expression. Default value is
the input dimension.</p>

<p style="margin-top: 1em">If the value is 0, the input
width is used for the output.</p>

<p style="margin-top: 1em">If one of the values is -1, the
scale filter will use a value that maintains the aspect
ratio of the input image, calculated from the other
specified dimension. If both of <br>
them are -1, the input size is used</p>

<p style="margin-top: 1em">If one of the values is -n with
n &gt; 1, the scale filter will also use a value that
maintains the aspect ratio of the input image, calculated
from the other specified <br>
dimension. After that it will, however, make sure that the
calculated dimension is divisible by n and adjust the value
if necessary.</p>

<p style="margin-top: 1em">See below for the list of
accepted constants for use in the dimension expression.</p>

<p style="margin-top: 1em">eval <br>
Specify when to evaluate width and height expression. It
accepts the following values:</p>

<p style="margin-top: 1em">init <br>
Only evaluate expressions once during the filter
initialization or when a command is processed.</p>

<p style="margin-top: 1em">frame <br>
Evaluate expressions for each incoming frame.</p>

<p style="margin-top: 1em">Default value is init.</p>

<p style="margin-top: 1em">interl <br>
Set the interlacing mode. It accepts the following
values:</p>

<p style="margin-top: 1em">1 Force interlaced aware
scaling.</p>

<p style="margin-top: 1em">0 Do not apply interlaced
scaling.</p>

<p style="margin-top: 1em">-1 Select interlaced aware
scaling depending on whether the source frames are flagged
as interlaced or not.</p>

<p style="margin-top: 1em">Default value is 0.</p>

<p style="margin-top: 1em">flags <br>
Set libswscale scaling flags. See the ffmpeg-scaler manual
for the complete list of values. If not explicitly specified
the filter applies the default flags.</p>

<p style="margin-top: 1em">param0, param1 <br>
Set libswscale input parameters for scaling algorithms that
need them. See the ffmpeg-scaler manual for the complete
documentation. If not explicitly specified the filter <br>
applies empty parameters.</p>

<p style="margin-top: 1em">size, s <br>
Set the video size. For the syntax of this option, check the
&quot;Video size&quot; section in the ffmpeg-utils
manual.</p>

<p style="margin-top: 1em">in_color_matrix <br>
out_color_matrix <br>
Set in/output YCbCr color space type.</p>

<p style="margin-top: 1em">This allows the autodetected
value to be overridden as well as allows forcing a specific
value used for the output and encoder.</p>

<p style="margin-top: 1em">If not specified, the color
space type depends on the pixel format.</p>

<p style="margin-top: 1em">Possible values:</p>

<p style="margin-top: 1em">auto <br>
Choose automatically.</p>

<p style="margin-top: 1em">bt709 <br>
Format conforming to International Telecommunication Union
(ITU) Recommendation BT.709.</p>

<p style="margin-top: 1em">fcc Set color space conforming
to the United States Federal Communications Commission (FCC)
Code of Federal Regulations (CFR) Title 47 (2003) 73.682
(a).</p>

<p style="margin-top: 1em">bt601 <br>
Set color space conforming to:</p>

<p style="margin-top: 1em">&Acirc;&middot; ITU
Radiocommunication Sector (ITU-R) Recommendation BT.601</p>

<p style="margin-top: 1em">&Acirc;&middot; ITU-R Rec.
BT.470-6 (1998) Systems B, B1, and G</p>

<p style="margin-top: 1em">&Acirc;&middot; Society of
Motion Picture and Television Engineers (SMPTE) ST
170:2004</p>

<p style="margin-top: 1em">smpte240m <br>
Set color space conforming to SMPTE ST 240:1999.</p>

<p style="margin-top: 1em">in_range <br>
out_range <br>
Set in/output YCbCr sample range.</p>

<p style="margin-top: 1em">This allows the autodetected
value to be overridden as well as allows forcing a specific
value used for the output and encoder. If not specified, the
range depends on the <br>
pixel format. Possible values:</p>

<p style="margin-top: 1em">auto <br>
Choose automatically.</p>

<p style="margin-top: 1em">jpeg/full/pc <br>
Set full range (0-255 in case of 8-bit luma).</p>

<p style="margin-top: 1em">mpeg/tv <br>
Set &quot;MPEG&quot; range (16-235 in case of 8-bit
luma).</p>

<p style="margin-top: 1em">force_original_aspect_ratio <br>
Enable decreasing or increasing output video width or height
if necessary to keep the original aspect ratio. Possible
values:</p>

<p style="margin-top: 1em">disable <br>
Scale the video as specified and disable this feature.</p>

<p style="margin-top: 1em">decrease <br>
The output video dimensions will automatically be decreased
if needed.</p>

<p style="margin-top: 1em">increase <br>
The output video dimensions will automatically be increased
if needed.</p>

<p style="margin-top: 1em">One useful instance of this
option is that when you know a specific device&rsquo;s
maximum allowed resolution, you can use this to limit the
output video to that, while retaining <br>
the aspect ratio. For example, device A allows 1280x720
playback, and your video is 1920x800. Using this option (set
it to decrease) and specifying 1280x720 to the command <br>
line makes the output 1280x533.</p>

<p style="margin-top: 1em">Please note that this is a
different thing than specifying -1 for w or h, you still
need to specify the output resolution for this option to
work.</p>

<p style="margin-top: 1em">The values of the w and h
options are expressions containing the following
constants:</p>

<p style="margin-top: 1em">in_w <br>
in_h <br>
The input width and height</p>

<p style="margin-top: 1em">iw <br>
ih These are the same as in_w and in_h.</p>

<p style="margin-top: 1em">out_w <br>
out_h <br>
The output (scaled) width and height</p>

<p style="margin-top: 1em">ow <br>
oh These are the same as out_w and out_h</p>

<p style="margin-top: 1em">a The same as iw / ih</p>

<p style="margin-top: 1em">sar input sample aspect
ratio</p>

<p style="margin-top: 1em">dar The input display aspect
ratio. Calculated from &quot;(iw / ih) * sar&quot;.</p>

<p style="margin-top: 1em">hsub <br>
vsub <br>
horizontal and vertical input chroma subsample values. For
example for the pixel format &quot;yuv422p&quot; hsub is 2
and vsub is 1.</p>

<p style="margin-top: 1em">ohsub <br>
ovsub <br>
horizontal and vertical output chroma subsample values. For
example for the pixel format &quot;yuv422p&quot; hsub is 2
and vsub is 1.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Scale the input
video to a size of 200x100</p>

<p style="margin-top: 1em">scale=w=200:h=100</p>

<p style="margin-top: 1em">This is equivalent to:</p>

<p style="margin-top: 1em">scale=200:100</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">scale=200x100</p>

<p style="margin-top: 1em">&Acirc;&middot; Specify a size
abbreviation for the output size:</p>

<p style="margin-top: 1em">scale=qcif</p>

<p style="margin-top: 1em">which can also be written
as:</p>

<p style="margin-top: 1em">scale=size=qcif</p>

<p style="margin-top: 1em">&Acirc;&middot; Scale the input
to 2x:</p>

<p style="margin-top: 1em">scale=w=2*iw:h=2*ih</p>

<p style="margin-top: 1em">&Acirc;&middot; The above is the
same as:</p>

<p style="margin-top: 1em">scale=2*in_w:2*in_h</p>

<p style="margin-top: 1em">&Acirc;&middot; Scale the input
to 2x with forced interlaced scaling:</p>

<p style="margin-top: 1em">scale=2*iw:2*ih:interl=1</p>

<p style="margin-top: 1em">&Acirc;&middot; Scale the input
to half size:</p>

<p style="margin-top: 1em">scale=w=iw/2:h=ih/2</p>

<p style="margin-top: 1em">&Acirc;&middot; Increase the
width, and set the height to the same size:</p>

<p style="margin-top: 1em">scale=3/2*iw:ow</p>

<p style="margin-top: 1em">&Acirc;&middot; Seek Greek
harmony:</p>

<p style="margin-top: 1em">scale=iw:1/PHI*iw <br>
scale=ih*PHI:ih</p>

<p style="margin-top: 1em">&Acirc;&middot; Increase the
height, and set the width to 3/2 of the height:</p>

<p style="margin-top: 1em">scale=w=3/2*oh:h=3/5*ih</p>

<p style="margin-top: 1em">&Acirc;&middot; Increase the
size, making the size a multiple of the chroma subsample
values:</p>


<p style="margin-top: 1em">scale=&quot;trunc(3/2*iw/hsub)*hsub:trunc(3/2*ih/vsub)*vsub&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Increase the
width to a maximum of 500 pixels, keeping the same aspect
ratio as the input:</p>

<p style="margin-top: 1em">scale=w=&rsquo;min(500
iw*3/2):h=-1&rsquo;</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">This filter supports the
following commands:</p>

<p style="margin-top: 1em">width, w <br>
height, h <br>
Set the output video dimension expression. The command
accepts the same syntax of the corresponding option.</p>

<p style="margin-top: 1em">If the specified expression is
not valid, it is kept at its current value.</p>

<p style="margin-top: 1em">scale_npp <br>
Use the NVIDIA Performance Primitives (libnpp) to perform
scaling and/or pixel format conversion on CUDA video frames.
Setting the output width and height works in the same way
<br>
as for the scale filter.</p>

<p style="margin-top: 1em">The following additional options
are accepted:</p>

<p style="margin-top: 1em">format <br>
The pixel format of the output CUDA frames. If set to the
string &quot;same&quot; (the default), the input format will
be kept. Note that automatic format negotiation and
conversion is <br>
not yet supported for hardware frames</p>

<p style="margin-top: 1em">interp_algo <br>
The interpolation algorithm used for resizing. One of the
following:</p>

<p style="margin-top: 1em">nn Nearest neighbour.</p>

<p style="margin-top: 1em">linear <br>
cubic <br>
cubic2p_bspline <br>
2-parameter cubic (B=1, C=0)</p>

<p style="margin-top: 1em">cubic2p_catmullrom <br>
2-parameter cubic (B=0, C=1/2)</p>

<p style="margin-top: 1em">cubic2p_b05c03 <br>
2-parameter cubic (B=1/2, C=3/10)</p>

<p style="margin-top: 1em">super <br>
Supersampling</p>

<p style="margin-top: 1em">lanczos</p>

<p style="margin-top: 1em">scale2ref <br>
Scale (resize) the input video, based on a reference
video.</p>

<p style="margin-top: 1em">See the scale filter for
available options, scale2ref supports the same but uses the
reference video instead of the main input as basis.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Scale a subtitle
stream to match the main video in size before overlaying</p>


<p style="margin-top: 1em">&rsquo;scale2ref[b][a];[a][b]overlay&rsquo;</p>

<p style="margin-top: 1em">selectivecolor <br>
Adjust cyan, magenta, yellow and black (CMYK) to certain
ranges of colors (such as &quot;reds&quot;,
&quot;yellows&quot;, &quot;greens&quot;, &quot;cyans&quot;,
...). The adjustment range is defined by the
&quot;purity&quot; of <br>
the color (that is, how saturated it already is).</p>

<p style="margin-top: 1em">This filter is similar to the
Adobe Photoshop Selective Color tool.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">correction_method <br>
Select color correction method.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">absolute <br>
Specified adjustments are applied &quot;as-is&quot;
(added/subtracted to original pixel component value).</p>

<p style="margin-top: 1em">relative <br>
Specified adjustments are relative to the original component
value.</p>

<p style="margin-top: 1em">Default is
&quot;absolute&quot;.</p>

<p style="margin-top: 1em">reds <br>
Adjustments for red pixels (pixels where the red component
is the maximum)</p>

<p style="margin-top: 1em">yellows <br>
Adjustments for yellow pixels (pixels where the blue
component is the minimum)</p>

<p style="margin-top: 1em">greens <br>
Adjustments for green pixels (pixels where the green
component is the maximum)</p>

<p style="margin-top: 1em">cyans <br>
Adjustments for cyan pixels (pixels where the red component
is the minimum)</p>

<p style="margin-top: 1em">blues <br>
Adjustments for blue pixels (pixels where the blue component
is the maximum)</p>

<p style="margin-top: 1em">magentas <br>
Adjustments for magenta pixels (pixels where the green
component is the minimum)</p>

<p style="margin-top: 1em">whites <br>
Adjustments for white pixels (pixels where all components
are greater than 128)</p>

<p style="margin-top: 1em">neutrals <br>
Adjustments for all pixels except pure black and pure
white</p>

<p style="margin-top: 1em">blacks <br>
Adjustments for black pixels (pixels where all components
are lesser than 128)</p>

<p style="margin-top: 1em">psfile <br>
Specify a Photoshop selective color file (&quot;.asv&quot;)
to import the settings from.</p>

<p style="margin-top: 1em">All the adjustment settings
(reds, yellows, ...) accept up to 4 space separated floating
point adjustment values in the [-1,1] range, respectively to
adjust the amount of cyan, <br>
magenta, yellow and black for the pixels of its range.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Increase cyan by
50% and reduce yellow by 33% in every green areas, and
increase magenta by 27% in blue areas:</p>

<p style="margin-top: 1em">selectivecolor=greens=.5 0 -.33
0:blues=0 .27</p>

<p style="margin-top: 1em">&Acirc;&middot; Use a Photoshop
selective color preset:</p>


<p style="margin-top: 1em">selectivecolor=psfile=MySelectiveColorPresets/Misty.asv</p>

<p style="margin-top: 1em">separatefields <br>
The &quot;separatefields&quot; takes a frame-based video
input and splits each frame into its components fields,
producing a new half height clip with twice the frame rate
and twice the <br>
frame count.</p>

<p style="margin-top: 1em">This filter use field-dominance
information in frame to decide which of each pair of fields
to place first in the output. If it gets it wrong use
setfield filter before <br>
&quot;separatefields&quot; filter.</p>

<p style="margin-top: 1em">setdar, setsar <br>
The &quot;setdar&quot; filter sets the Display Aspect Ratio
for the filter output video.</p>

<p style="margin-top: 1em">This is done by changing the
specified Sample (aka Pixel) Aspect Ratio, according to the
following equation:</p>

<p style="margin-top: 1em">&lt;DAR&gt; =
&lt;HORIZONTAL_RESOLUTION&gt; / &lt;VERTICAL_RESOLUTION&gt;
* &lt;SAR&gt;</p>

<p style="margin-top: 1em">Keep in mind that the
&quot;setdar&quot; filter does not modify the pixel
dimensions of the video frame. Also, the display aspect
ratio set by this filter may be changed by later filters
<br>
in the filterchain, e.g. in case of scaling or if another
&quot;setdar&quot; or a &quot;setsar&quot; filter is
applied.</p>

<p style="margin-top: 1em">The &quot;setsar&quot; filter
sets the Sample (aka Pixel) Aspect Ratio for the filter
output video.</p>

<p style="margin-top: 1em">Note that as a consequence of
the application of this filter, the output display aspect
ratio will change according to the equation above.</p>

<p style="margin-top: 1em">Keep in mind that the sample
aspect ratio set by the &quot;setsar&quot; filter may be
changed by later filters in the filterchain, e.g. if another
&quot;setsar&quot; or a &quot;setdar&quot; filter is
applied.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">r, ratio, dar
(&quot;setdar&quot; only), sar (&quot;setsar&quot; only)
<br>
Set the aspect ratio used by the filter.</p>

<p style="margin-top: 1em">The parameter can be a floating
point number string, an expression, or a string of the form
num:den, where num and den are the numerator and denominator
of the aspect ratio. <br>
If the parameter is not specified, it is assumed the value
&quot;0&quot;. In case the form &quot;num:den&quot; is used,
the &quot;:&quot; character should be escaped.</p>

<p style="margin-top: 1em">max Set the maximum integer
value to use for expressing numerator and denominator when
reducing the expressed aspect ratio to a rational. Default
value is 100.</p>

<p style="margin-top: 1em">The parameter sar is an
expression containing the following constants:</p>

<p style="margin-top: 1em">E, PI, PHI <br>
These are approximated values for the mathematical constants
e (Euler&rsquo;s number), pi (Greek pi), and phi (the golden
ratio).</p>

<p style="margin-top: 1em">w, h <br>
The input width and height.</p>

<p style="margin-top: 1em">a These are the same as w /
h.</p>

<p style="margin-top: 1em">sar The input sample aspect
ratio.</p>

<p style="margin-top: 1em">dar The input display aspect
ratio. It is the same as (w / h) * sar.</p>

<p style="margin-top: 1em">hsub, vsub <br>
Horizontal and vertical chroma subsample values. For
example, for the pixel format &quot;yuv422p&quot; hsub is 2
and vsub is 1.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; To change the
display aspect ratio to 16:9, specify one of the
following:</p>

<p style="margin-top: 1em">setdar=dar=1.77777 <br>
setdar=dar=16/9</p>

<p style="margin-top: 1em">&Acirc;&middot; To change the
sample aspect ratio to 10:11, specify:</p>

<p style="margin-top: 1em">setsar=sar=10/11</p>

<p style="margin-top: 1em">&Acirc;&middot; To set a display
aspect ratio of 16:9, and specify a maximum integer value of
1000 in the aspect ratio reduction, use the command:</p>

<p style="margin-top: 1em">setdar=ratio=16/9:max=1000</p>

<p style="margin-top: 1em">setfield <br>
Force field for the output video frame.</p>

<p style="margin-top: 1em">The &quot;setfield&quot; filter
marks the interlace type field for the output frames. It
does not change the input frame, but only sets the
corresponding property, which affects how the <br>
frame is treated by following filters (e.g.
&quot;fieldorder&quot; or &quot;yadif&quot;).</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">mode <br>
Available values are:</p>

<p style="margin-top: 1em">auto <br>
Keep the same field property.</p>

<p style="margin-top: 1em">bff Mark the frame as
bottom-field-first.</p>

<p style="margin-top: 1em">tff Mark the frame as
top-field-first.</p>

<p style="margin-top: 1em">prog <br>
Mark the frame as progressive.</p>

<p style="margin-top: 1em">showinfo <br>
Show a line containing various information for each input
video frame. The input video is not modified.</p>

<p style="margin-top: 1em">The shown line contains a
sequence of key/value pairs of the form key:value.</p>

<p style="margin-top: 1em">The following values are shown
in the output:</p>

<p style="margin-top: 1em">n The (sequential) number of the
input frame, starting from 0.</p>

<p style="margin-top: 1em">pts The Presentation TimeStamp
of the input frame, expressed as a number of time base
units. The time base unit depends on the filter input
pad.</p>

<p style="margin-top: 1em">pts_time <br>
The Presentation TimeStamp of the input frame, expressed as
a number of seconds.</p>

<p style="margin-top: 1em">pos The position of the frame in
the input stream, or -1 if this information is unavailable
and/or meaningless (for example in case of synthetic
video).</p>

<p style="margin-top: 1em">fmt The pixel format name.</p>

<p style="margin-top: 1em">sar The sample aspect ratio of
the input frame, expressed in the form num/den.</p>

<p style="margin-top: 1em">s The size of the input frame.
For the syntax of this option, check the &quot;Video
size&quot; section in the ffmpeg-utils manual.</p>

<p style="margin-top: 1em">i The type of interlaced mode
(&quot;P&quot; for &quot;progressive&quot;, &quot;T&quot;
for top field first, &quot;B&quot; for bottom field
first).</p>

<p style="margin-top: 1em">iskey <br>
This is 1 if the frame is a key frame, 0 otherwise.</p>

<p style="margin-top: 1em">type <br>
The picture type of the input frame (&quot;I&quot; for an
I-frame, &quot;P&quot; for a P-frame, &quot;B&quot; for a
B-frame, or &quot;?&quot; for an unknown type). Also refer
to the documentation of the <br>
&quot;AVPictureType&quot; enum and of the
&quot;av_get_picture_type_char&quot; function defined in
libavutil/avutil.h.</p>

<p style="margin-top: 1em">checksum <br>
The Adler-32 checksum (printed in hexadecimal) of all the
planes of the input frame.</p>

<p style="margin-top: 1em">plane_checksum <br>
The Adler-32 checksum (printed in hexadecimal) of each plane
of the input frame, expressed in the form &quot;[c0 c1 c2
c3]&quot;.</p>

<p style="margin-top: 1em">showpalette <br>
Displays the 256 colors palette of each frame. This filter
is only relevant for pal8 pixel format frames.</p>

<p style="margin-top: 1em">It accepts the following
option:</p>

<p style="margin-top: 1em">s Set the size of the box used
to represent one palette color entry. Default is 30 (for a
&quot;30x30&quot; pixel box).</p>

<p style="margin-top: 1em">shuffleframes <br>
Reorder and/or duplicate video frames.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">mapping <br>
Set the destination indexes of input frames. This is space
or &rsquo;|&rsquo; separated list of indexes that maps input
frames to output frames. Number of indexes also sets maximal
<br>
value that each index may have.</p>

<p style="margin-top: 1em">The first frame has the index 0.
The default is to keep the input unchanged.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Swap second and
third frame of every three frames of the input:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -vf
&quot;shuffleframes=0 2 1&quot; OUTPUT</p>

<p style="margin-top: 1em">&Acirc;&middot; Swap 10th and
1st frame of every ten frames of the input:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -vf
&quot;shuffleframes=9 1 2 3 4 5 6 7 8 0&quot; OUTPUT</p>

<p style="margin-top: 1em">shuffleplanes <br>
Reorder and/or duplicate video planes.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">map0 <br>
The index of the input plane to be used as the first output
plane.</p>

<p style="margin-top: 1em">map1 <br>
The index of the input plane to be used as the second output
plane.</p>

<p style="margin-top: 1em">map2 <br>
The index of the input plane to be used as the third output
plane.</p>

<p style="margin-top: 1em">map3 <br>
The index of the input plane to be used as the fourth output
plane.</p>

<p style="margin-top: 1em">The first plane has the index 0.
The default is to keep the input unchanged.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Swap the second
and third planes of the input:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -vf
shuffleplanes=0:2:1:3 OUTPUT</p>

<p style="margin-top: 1em">signalstats <br>
Evaluate various visual metrics that assist in determining
issues associated with the digitization of analog video
media.</p>

<p style="margin-top: 1em">By default the filter will log
these metadata values:</p>

<p style="margin-top: 1em">YMIN <br>
Display the minimal Y value contained within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">YLOW <br>
Display the Y value at the 10% percentile within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">YAVG <br>
Display the average Y value within the input frame.
Expressed in range of [0-255].</p>

<p style="margin-top: 1em">YHIGH <br>
Display the Y value at the 90% percentile within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">YMAX <br>
Display the maximum Y value contained within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">UMIN <br>
Display the minimal U value contained within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">ULOW <br>
Display the U value at the 10% percentile within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">UAVG <br>
Display the average U value within the input frame.
Expressed in range of [0-255].</p>

<p style="margin-top: 1em">UHIGH <br>
Display the U value at the 90% percentile within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">UMAX <br>
Display the maximum U value contained within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">VMIN <br>
Display the minimal V value contained within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">VLOW <br>
Display the V value at the 10% percentile within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">VAVG <br>
Display the average V value within the input frame.
Expressed in range of [0-255].</p>

<p style="margin-top: 1em">VHIGH <br>
Display the V value at the 90% percentile within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">VMAX <br>
Display the maximum V value contained within the input
frame. Expressed in range of [0-255].</p>

<p style="margin-top: 1em">SATMIN <br>
Display the minimal saturation value contained within the
input frame. Expressed in range of [0-~181.02].</p>

<p style="margin-top: 1em">SATLOW <br>
Display the saturation value at the 10% percentile within
the input frame. Expressed in range of [0-~181.02].</p>

<p style="margin-top: 1em">SATAVG <br>
Display the average saturation value within the input frame.
Expressed in range of [0-~181.02].</p>

<p style="margin-top: 1em">SATHIGH <br>
Display the saturation value at the 90% percentile within
the input frame. Expressed in range of [0-~181.02].</p>

<p style="margin-top: 1em">SATMAX <br>
Display the maximum saturation value contained within the
input frame. Expressed in range of [0-~181.02].</p>

<p style="margin-top: 1em">HUEMED <br>
Display the median value for hue within the input frame.
Expressed in range of [0-360].</p>

<p style="margin-top: 1em">HUEAVG <br>
Display the average value for hue within the input frame.
Expressed in range of [0-360].</p>

<p style="margin-top: 1em">YDIF <br>
Display the average of sample value difference between all
values of the Y plane in the current frame and corresponding
values of the previous input frame. Expressed in <br>
range of [0-255].</p>

<p style="margin-top: 1em">UDIF <br>
Display the average of sample value difference between all
values of the U plane in the current frame and corresponding
values of the previous input frame. Expressed in <br>
range of [0-255].</p>

<p style="margin-top: 1em">VDIF <br>
Display the average of sample value difference between all
values of the V plane in the current frame and corresponding
values of the previous input frame. Expressed in <br>
range of [0-255].</p>

<p style="margin-top: 1em">YBITDEPTH <br>
Display bit depth of Y plane in current frame. Expressed in
range of [0-16].</p>

<p style="margin-top: 1em">UBITDEPTH <br>
Display bit depth of U plane in current frame. Expressed in
range of [0-16].</p>

<p style="margin-top: 1em">VBITDEPTH <br>
Display bit depth of V plane in current frame. Expressed in
range of [0-16].</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">stat <br>
out stat specify an additional form of image analysis. out
output video with the specified type of pixel
highlighted.</p>

<p style="margin-top: 1em">Both options accept the
following values:</p>

<p style="margin-top: 1em">tout <br>
Identify temporal outliers pixels. A temporal outlier is a
pixel unlike the neighboring pixels of the same field.
Examples of temporal outliers include the results of <br>
video dropouts, head clogs, or tape tracking issues.</p>

<p style="margin-top: 1em">vrep <br>
Identify vertical line repetition. Vertical line repetition
includes similar rows of pixels within a frame. In
born-digital video vertical line repetition is common, but
<br>
this pattern is uncommon in video digitized from an analog
source. When it occurs in video that results from the
digitization of an analog source it can indicate <br>
concealment from a dropout compensator.</p>

<p style="margin-top: 1em">brng <br>
Identify pixels that fall outside of legal broadcast
range.</p>

<p style="margin-top: 1em">color, c <br>
Set the highlight color for the out option. The default
color is yellow.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Output data of
various video metrics:</p>

<p style="margin-top: 1em">ffprobe -f lavfi
movie=example.mov,signalstats=&quot;stat=tout+vrep+brng&quot;
-show_frames</p>

<p style="margin-top: 1em">&Acirc;&middot; Output specific
data about the minimum and maximum values of the Y plane per
frame:</p>

<p style="margin-top: 1em">ffprobe -f lavfi
movie=example.mov,signalstats -show_entries
frame_tags=lavfi.signalstats.YMAX,lavfi.signalstats.YMIN</p>

<p style="margin-top: 1em">&Acirc;&middot; Playback video
while highlighting pixels that are outside of broadcast
range in red.</p>

<p style="margin-top: 1em">ffplay example.mov -vf
signalstats=&quot;out=brng:color=red&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Playback video
with signalstats metadata drawn over the frame.</p>

<p style="margin-top: 1em">ffplay example.mov -vf
signalstats=stat=brng+vrep+tout,drawtext=fontfile=FreeSerif.ttf:textfile=signalstat_drawtext.txt</p>

<p style="margin-top: 1em">The contents of
signalstat_drawtext.txt used in the command are:</p>

<p style="margin-top: 1em">time %{pts:hms} <br>
Y
(%{metadata:lavfi.signalstats.YMIN}-%{metadata:lavfi.signalstats.YMAX})
<br>
U
(%{metadata:lavfi.signalstats.UMIN}-%{metadata:lavfi.signalstats.UMAX})
<br>
V
(%{metadata:lavfi.signalstats.VMIN}-%{metadata:lavfi.signalstats.VMAX})
<br>
saturation maximum: %{metadata:lavfi.signalstats.SATMAX}</p>

<p style="margin-top: 1em">smartblur <br>
Blur the input video without impacting the outlines.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">luma_radius, lr <br>
Set the luma radius. The option value must be a float number
in the range [0.1,5.0] that specifies the variance of the
gaussian filter used to blur the image (slower if <br>
larger). Default value is 1.0.</p>

<p style="margin-top: 1em">luma_strength, ls <br>
Set the luma strength. The option value must be a float
number in the range [-1.0,1.0] that configures the blurring.
A value included in [0.0,1.0] will blur the image whereas
<br>
a value included in [-1.0,0.0] will sharpen the image.
Default value is 1.0.</p>

<p style="margin-top: 1em">luma_threshold, lt <br>
Set the luma threshold used as a coefficient to determine
whether a pixel should be blurred or not. The option value
must be an integer in the range [-30,30]. A value of 0 <br>
will filter all the image, a value included in [0,30] will
filter flat areas and a value included in [-30,0] will
filter edges. Default value is 0.</p>

<p style="margin-top: 1em">chroma_radius, cr <br>
Set the chroma radius. The option value must be a float
number in the range [0.1,5.0] that specifies the variance of
the gaussian filter used to blur the image (slower if <br>
larger). Default value is 1.0.</p>

<p style="margin-top: 1em">chroma_strength, cs <br>
Set the chroma strength. The option value must be a float
number in the range [-1.0,1.0] that configures the blurring.
A value included in [0.0,1.0] will blur the image <br>
whereas a value included in [-1.0,0.0] will sharpen the
image. Default value is 1.0.</p>

<p style="margin-top: 1em">chroma_threshold, ct <br>
Set the chroma threshold used as a coefficient to determine
whether a pixel should be blurred or not. The option value
must be an integer in the range [-30,30]. A value of 0 <br>
will filter all the image, a value included in [0,30] will
filter flat areas and a value included in [-30,0] will
filter edges. Default value is 0.</p>

<p style="margin-top: 1em">If a chroma option is not
explicitly set, the corresponding luma value is set.</p>

<p style="margin-top: 1em">ssim <br>
Obtain the SSIM (Structural SImilarity Metric) between two
input videos.</p>

<p style="margin-top: 1em">This filter takes in input two
input videos, the first input is considered the
&quot;main&quot; source and is passed unchanged to the
output. The second input is used as a &quot;reference&quot;
<br>
video for computing the SSIM.</p>

<p style="margin-top: 1em">Both video inputs must have the
same resolution and pixel format for this filter to work
correctly. Also it assumes that both inputs have the same
number of frames, which are <br>
compared one by one.</p>

<p style="margin-top: 1em">The filter stores the calculated
SSIM of each frame.</p>

<p style="margin-top: 1em">The description of the accepted
parameters follows.</p>

<p style="margin-top: 1em">stats_file, f <br>
If specified the filter will use the named file to save the
SSIM of each individual frame. When filename equals
&quot;-&quot; the data is sent to standard output.</p>

<p style="margin-top: 1em">The file printed if stats_file
is selected, contains a sequence of key/value pairs of the
form key:value for each compared couple of frames.</p>

<p style="margin-top: 1em">A description of each shown
parameter follows:</p>

<p style="margin-top: 1em">n sequential number of the input
frame, starting from 1</p>

<p style="margin-top: 1em">Y, U, V, R, G, B <br>
SSIM of the compared frames for the component specified by
the suffix.</p>

<p style="margin-top: 1em">All SSIM of the compared frames
for the whole frame.</p>

<p style="margin-top: 1em">dB Same as above but in dB
representation.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">movie=ref_movie.mpg,
setpts=PTS-STARTPTS [main]; <br>
[main][ref] ssim=&quot;stats_file=stats.log&quot; [out]</p>

<p style="margin-top: 1em">On this example the input file
being processed is compared with the reference file
ref_movie.mpg. The SSIM of each individual frame is stored
in stats.log.</p>

<p style="margin-top: 1em">Another example with both psnr
and ssim at same time:</p>

<p style="margin-top: 1em">ffmpeg -i main.mpg -i ref.mpg
-lavfi &quot;ssim;[0:v][1:v]psnr&quot; -f null -</p>

<p style="margin-top: 1em">stereo3d <br>
Convert between different stereoscopic image formats.</p>

<p style="margin-top: 1em">The filters accept the following
options:</p>

<p style="margin-top: 1em">in Set stereoscopic image format
of input.</p>

<p style="margin-top: 1em">Available values for input image
formats are:</p>

<p style="margin-top: 1em">sbsl <br>
side by side parallel (left eye left, right eye right)</p>

<p style="margin-top: 1em">sbsr <br>
side by side crosseye (right eye left, left eye right)</p>

<p style="margin-top: 1em">sbs2l <br>
side by side parallel with half width resolution (left eye
left, right eye right)</p>

<p style="margin-top: 1em">sbs2r <br>
side by side crosseye with half width resolution (right eye
left, left eye right)</p>

<p style="margin-top: 1em">abl above-below (left eye above,
right eye below)</p>

<p style="margin-top: 1em">abr above-below (right eye
above, left eye below)</p>

<p style="margin-top: 1em">ab2l <br>
above-below with half height resolution (left eye above,
right eye below)</p>

<p style="margin-top: 1em">ab2r <br>
above-below with half height resolution (right eye above,
left eye below)</p>

<p style="margin-top: 1em">al alternating frames (left eye
first, right eye second)</p>

<p style="margin-top: 1em">ar alternating frames (right eye
first, left eye second)</p>

<p style="margin-top: 1em">irl interleaved rows (left eye
has top row, right eye starts on next row)</p>

<p style="margin-top: 1em">irr interleaved rows (right eye
has top row, left eye starts on next row)</p>

<p style="margin-top: 1em">icl interleaved columns, left
eye first</p>

<p style="margin-top: 1em">icr interleaved columns, right
eye first</p>

<p style="margin-top: 1em">Default value is sbsl.</p>

<p style="margin-top: 1em">out Set stereoscopic image
format of output.</p>

<p style="margin-top: 1em">sbsl <br>
side by side parallel (left eye left, right eye right)</p>

<p style="margin-top: 1em">sbsr <br>
side by side crosseye (right eye left, left eye right)</p>

<p style="margin-top: 1em">sbs2l <br>
side by side parallel with half width resolution (left eye
left, right eye right)</p>

<p style="margin-top: 1em">sbs2r <br>
side by side crosseye with half width resolution (right eye
left, left eye right)</p>

<p style="margin-top: 1em">abl above-below (left eye above,
right eye below)</p>

<p style="margin-top: 1em">abr above-below (right eye
above, left eye below)</p>

<p style="margin-top: 1em">ab2l <br>
above-below with half height resolution (left eye above,
right eye below)</p>

<p style="margin-top: 1em">ab2r <br>
above-below with half height resolution (right eye above,
left eye below)</p>

<p style="margin-top: 1em">al alternating frames (left eye
first, right eye second)</p>

<p style="margin-top: 1em">ar alternating frames (right eye
first, left eye second)</p>

<p style="margin-top: 1em">irl interleaved rows (left eye
has top row, right eye starts on next row)</p>

<p style="margin-top: 1em">irr interleaved rows (right eye
has top row, left eye starts on next row)</p>

<p style="margin-top: 1em">arbg <br>
anaglyph red/blue gray (red filter on left eye, blue filter
on right eye)</p>

<p style="margin-top: 1em">argg <br>
anaglyph red/green gray (red filter on left eye, green
filter on right eye)</p>

<p style="margin-top: 1em">arcg <br>
anaglyph red/cyan gray (red filter on left eye, cyan filter
on right eye)</p>

<p style="margin-top: 1em">arch <br>
anaglyph red/cyan half colored (red filter on left eye, cyan
filter on right eye)</p>

<p style="margin-top: 1em">arcc <br>
anaglyph red/cyan color (red filter on left eye, cyan filter
on right eye)</p>

<p style="margin-top: 1em">arcd <br>
anaglyph red/cyan color optimized with the least squares
projection of dubois (red filter on left eye, cyan filter on
right eye)</p>

<p style="margin-top: 1em">agmg <br>
anaglyph green/magenta gray (green filter on left eye,
magenta filter on right eye)</p>

<p style="margin-top: 1em">agmh <br>
anaglyph green/magenta half colored (green filter on left
eye, magenta filter on right eye)</p>

<p style="margin-top: 1em">agmc <br>
anaglyph green/magenta colored (green filter on left eye,
magenta filter on right eye)</p>

<p style="margin-top: 1em">agmd <br>
anaglyph green/magenta color optimized with the least
squares projection of dubois (green filter on left eye,
magenta filter on right eye)</p>

<p style="margin-top: 1em">aybg <br>
anaglyph yellow/blue gray (yellow filter on left eye, blue
filter on right eye)</p>

<p style="margin-top: 1em">aybh <br>
anaglyph yellow/blue half colored (yellow filter on left
eye, blue filter on right eye)</p>

<p style="margin-top: 1em">aybc <br>
anaglyph yellow/blue colored (yellow filter on left eye,
blue filter on right eye)</p>

<p style="margin-top: 1em">aybd <br>
anaglyph yellow/blue color optimized with the least squares
projection of dubois (yellow filter on left eye, blue filter
on right eye)</p>

<p style="margin-top: 1em">ml mono output (left eye
only)</p>

<p style="margin-top: 1em">mr mono output (right eye
only)</p>

<p style="margin-top: 1em">chl checkerboard, left eye
first</p>

<p style="margin-top: 1em">chr checkerboard, right eye
first</p>

<p style="margin-top: 1em">icl interleaved columns, left
eye first</p>

<p style="margin-top: 1em">icr interleaved columns, right
eye first</p>

<p style="margin-top: 1em">hdmi <br>
HDMI frame pack</p>

<p style="margin-top: 1em">Default value is arcd.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Convert input
video from side by side parallel to anaglyph yellow/blue
dubois:</p>

<p style="margin-top: 1em">stereo3d=sbsl:aybd</p>

<p style="margin-top: 1em">&Acirc;&middot; Convert input
video from above below (left eye above, right eye below) to
side by side crosseye.</p>

<p style="margin-top: 1em">stereo3d=abl:sbsr</p>

<p style="margin-top: 1em">streamselect, astreamselect <br>
Select video or audio streams.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">inputs <br>
Set number of inputs. Default is 2.</p>

<p style="margin-top: 1em">map Set input indexes to remap
to outputs.</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">The &quot;streamselect&quot; and
&quot;astreamselect&quot; filter supports the following
commands:</p>

<p style="margin-top: 1em">map Set input indexes to remap
to outputs.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Select first 5
seconds 1st stream and rest of time 2nd stream:</p>

<p style="margin-top: 1em">sendcmd=&rsquo;5.0 streamselect
map 1&rsquo;,streamselect=inputs=2:map=0</p>

<p style="margin-top: 1em">&Acirc;&middot; Same as above,
but for audio:</p>

<p style="margin-top: 1em">asendcmd=&rsquo;5.0
astreamselect map 1&rsquo;,astreamselect=inputs=2:map=0</p>

<p style="margin-top: 1em">sobel <br>
Apply sobel operator to input video stream.</p>

<p style="margin-top: 1em">The filter accepts the following
option:</p>

<p style="margin-top: 1em">planes <br>
Set which planes will be processed, unprocessed planes will
be copied. By default value 0xf, all planes will be
processed.</p>

<p style="margin-top: 1em">scale <br>
Set value which will be multiplied with filtered result.</p>

<p style="margin-top: 1em">delta <br>
Set value which will be added to filtered result.</p>

<p style="margin-top: 1em">spp <br>
Apply a simple postprocessing filter that compresses and
decompresses the image at several (or - in the case of
quality level 6 - all) shifts and average the results.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">quality <br>
Set quality. This option defines the number of levels for
averaging. It accepts an integer in the range 0-6. If set to
0, the filter will have no effect. A value of 6 means <br>
the higher quality. For each increment of that value the
speed drops by a factor of approximately 2. Default value is
3.</p>

<p style="margin-top: 1em">qp Force a constant quantization
parameter. If not set, the filter will use the QP from the
video stream (if available).</p>

<p style="margin-top: 1em">mode <br>
Set thresholding mode. Available modes are:</p>

<p style="margin-top: 1em">hard <br>
Set hard thresholding (default).</p>

<p style="margin-top: 1em">soft <br>
Set soft thresholding (better de-ringing effect, but likely
blurrier).</p>

<p style="margin-top: 1em">use_bframe_qp <br>
Enable the use of the QP from the B-Frames if set to 1.
Using this option may cause flicker since the B-Frames have
often larger QP. Default is 0 (not enabled).</p>

<p style="margin-top: 1em">subtitles <br>
Draw subtitles on top of input video using the libass
library.</p>

<p style="margin-top: 1em">To enable compilation of this
filter you need to configure FFmpeg with
&quot;--enable-libass&quot;. This filter also requires a
build with libavcodec and libavformat to convert the passed
<br>
subtitles file to ASS (Advanced Substation Alpha) subtitles
format.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">filename, f <br>
Set the filename of the subtitle file to read. It must be
specified.</p>

<p style="margin-top: 1em">original_size <br>
Specify the size of the original video, the video for which
the ASS file was composed. For the syntax of this option,
check the &quot;Video size&quot; section in the ffmpeg-utils
<br>
manual. Due to a misdesign in ASS aspect ratio arithmetic,
this is necessary to correctly scale the fonts if the aspect
ratio has been changed.</p>

<p style="margin-top: 1em">fontsdir <br>
Set a directory path containing fonts that can be used by
the filter. These fonts will be used in addition to whatever
the font provider uses.</p>

<p style="margin-top: 1em">charenc <br>
Set subtitles input character encoding.
&quot;subtitles&quot; filter only. Only useful if not
UTF-8.</p>

<p style="margin-top: 1em">stream_index, si <br>
Set subtitles stream index. &quot;subtitles&quot; filter
only.</p>

<p style="margin-top: 1em">force_style <br>
Override default style or script info parameters of the
subtitles. It accepts a string containing ASS style format
&quot;KEY=VALUE&quot; couples separated by
&quot;,&quot;.</p>

<p style="margin-top: 1em">If the first key is not
specified, it is assumed that the first value specifies the
filename.</p>

<p style="margin-top: 1em">For example, to render the file
sub.srt on top of the input video, use the command:</p>

<p style="margin-top: 1em">subtitles=sub.srt</p>

<p style="margin-top: 1em">which is equivalent to:</p>

<p style="margin-top: 1em">subtitles=filename=sub.srt</p>

<p style="margin-top: 1em">To render the default subtitles
stream from file video.mkv, use:</p>

<p style="margin-top: 1em">subtitles=video.mkv</p>

<p style="margin-top: 1em">To render the second subtitles
stream from that file, use:</p>

<p style="margin-top: 1em">subtitles=video.mkv:si=1</p>

<p style="margin-top: 1em">To make the subtitles stream
from sub.srt appear in transparent green &quot;DejaVu
Serif&quot;, use:</p>


<p style="margin-top: 1em">subtitles=sub.srt:force_style=&rsquo;FontName=DejaVu
Serif,PrimaryColour=&amp;HAA00FF00&rsquo;</p>

<p style="margin-top: 1em">super2xsai <br>
Scale the input by 2x and smooth using the Super2xSaI (Scale
and Interpolate) pixel art scaling algorithm.</p>

<p style="margin-top: 1em">Useful for enlarging pixel art
images without reducing sharpness.</p>

<p style="margin-top: 1em">swaprect <br>
Swap two rectangular objects in video.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">w Set object width.</p>

<p style="margin-top: 1em">h Set object height.</p>

<p style="margin-top: 1em">x1 Set 1st rect x
coordinate.</p>

<p style="margin-top: 1em">y1 Set 1st rect y
coordinate.</p>

<p style="margin-top: 1em">x2 Set 2nd rect x
coordinate.</p>

<p style="margin-top: 1em">y2 Set 2nd rect y
coordinate.</p>

<p style="margin-top: 1em">All expressions are evaluated
once for each frame.</p>

<p style="margin-top: 1em">The all options are expressions
containing the following constants:</p>

<p style="margin-top: 1em">w <br>
h The input width and height.</p>

<p style="margin-top: 1em">a same as w / h</p>

<p style="margin-top: 1em">sar input sample aspect
ratio</p>

<p style="margin-top: 1em">dar input display aspect ratio,
it is the same as (w / h) * sar</p>

<p style="margin-top: 1em">n The number of the input frame,
starting from 0.</p>

<p style="margin-top: 1em">t The timestamp expressed in
seconds. It&rsquo;s NAN if the input timestamp is
unknown.</p>

<p style="margin-top: 1em">pos the position in the file of
the input frame, NAN if unknown</p>

<p style="margin-top: 1em">swapuv <br>
Swap U &amp; V plane.</p>

<p style="margin-top: 1em">telecine <br>
Apply telecine process to the video.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">first_field <br>
top, t <br>
top field first</p>

<p style="margin-top: 1em">bottom, b <br>
bottom field first The default value is &quot;top&quot;.</p>

<p style="margin-top: 1em">pattern <br>
A string of numbers representing the pulldown pattern you
wish to apply. The default value is 23.</p>

<p style="margin-top: 1em">Some typical patterns:</p>

<p style="margin-top: 1em">NTSC output (30i): <br>
27.5p: 32222 <br>
24p: 23 (classic) <br>
24p: 2332 (preferred) <br>
20p: 33 <br>
18p: 334 <br>
16p: 3444</p>

<p style="margin-top: 1em">PAL output (25i): <br>
27.5p: 12222 <br>
24p: 222222222223 (&quot;Euro pulldown&quot;) <br>
16.67p: 33 <br>
16p: 33333334</p>

<p style="margin-top: 1em">thumbnail <br>
Select the most representative frame in a given sequence of
consecutive frames.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">n Set the frames batch size to
analyze; in a set of n frames, the filter will pick one of
them, and then handle the next batch of n frames until the
end. Default is 100.</p>

<p style="margin-top: 1em">Since the filter keeps track of
the whole frames sequence, a bigger n value will result in a
higher memory usage, so a high value is not recommended.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Extract one
picture each 50 frames:</p>

<p style="margin-top: 1em">thumbnail=50</p>

<p style="margin-top: 1em">&Acirc;&middot; Complete example
of a thumbnail creation with ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i in.avi -vf
thumbnail,scale=300:200 -frames:v 1 out.png</p>

<p style="margin-top: 1em">tile <br>
Tile several successive frames together.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">layout <br>
Set the grid size (i.e. the number of lines and columns).
For the syntax of this option, check the &quot;Video
size&quot; section in the ffmpeg-utils manual.</p>

<p style="margin-top: 1em">nb_frames <br>
Set the maximum number of frames to render in the given
area. It must be less than or equal to wxh. The default
value is 0, meaning all the area will be used.</p>

<p style="margin-top: 1em">margin <br>
Set the outer border margin in pixels.</p>

<p style="margin-top: 1em">padding <br>
Set the inner border thickness (i.e. the number of pixels
between frames). For more advanced padding options (such as
having different values for the edges), refer to the pad
<br>
video filter.</p>

<p style="margin-top: 1em">color <br>
Specify the color of the unused area. For the syntax of this
option, check the &quot;Color&quot; section in the
ffmpeg-utils manual. The default value of color is
&quot;black&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Produce 8x8 PNG
tiles of all keyframes (-skip_frame nokey) in a movie:</p>

<p style="margin-top: 1em">ffmpeg -skip_frame nokey -i
file.avi -vf &rsquo;scale=128:72,tile=8x8&rsquo; -an -vsync
0 keyframes%03d.png</p>

<p style="margin-top: 1em">The -vsync 0 is necessary to
prevent ffmpeg from duplicating each output frame to
accommodate the originally detected frame rate.</p>

<p style="margin-top: 1em">&Acirc;&middot; Display 5
pictures in an area of &quot;3x2&quot; frames, with 7 pixels
between them, and 2 pixels of initial margin, using mixed
flat and named options:</p>


<p style="margin-top: 1em">tile=3x2:nb_frames=5:padding=7:margin=2</p>

<p style="margin-top: 1em">tinterlace <br>
Perform various types of temporal field interlacing.</p>

<p style="margin-top: 1em">Frames are counted starting from
1, so the first input frame is considered odd.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">mode <br>
Specify the mode of the interlacing. This option can also be
specified as a value alone. See below for a list of values
for this option.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">merge, 0 <br>
Move odd frames into the upper field, even into the lower
field, generating a double height frame at half frame
rate.</p>

<p style="margin-top: 1em">------&gt; time <br>
Input: <br>
Frame 1 Frame 2 Frame 3 Frame 4</p>

<p style="margin-top: 1em">11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444</p>

<p style="margin-top: 1em">Output: <br>
11111 33333 <br>
22222 44444 <br>
11111 33333 <br>
22222 44444 <br>
11111 33333 <br>
22222 44444 <br>
11111 33333 <br>
22222 44444</p>

<p style="margin-top: 1em">drop_even, 1 <br>
Only output odd frames, even frames are dropped, generating
a frame with unchanged height at half frame rate.</p>

<p style="margin-top: 1em">------&gt; time <br>
Input: <br>
Frame 1 Frame 2 Frame 3 Frame 4</p>

<p style="margin-top: 1em">11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444</p>

<p style="margin-top: 1em">Output: <br>
11111 33333 <br>
11111 33333 <br>
11111 33333 <br>
11111 33333</p>

<p style="margin-top: 1em">drop_odd, 2 <br>
Only output even frames, odd frames are dropped, generating
a frame with unchanged height at half frame rate.</p>

<p style="margin-top: 1em">------&gt; time <br>
Input: <br>
Frame 1 Frame 2 Frame 3 Frame 4</p>

<p style="margin-top: 1em">11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444</p>

<p style="margin-top: 1em">Output: <br>
22222 44444 <br>
22222 44444 <br>
22222 44444 <br>
22222 44444</p>

<p style="margin-top: 1em">pad, 3 <br>
Expand each frame to full height, but pad alternate lines
with black, generating a frame with double height at the
same input frame rate.</p>

<p style="margin-top: 1em">------&gt; time <br>
Input: <br>
Frame 1 Frame 2 Frame 3 Frame 4</p>

<p style="margin-top: 1em">11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444</p>

<p style="margin-top: 1em">Output: <br>
11111 ..... 33333 ..... <br>
..... 22222 ..... 44444 <br>
11111 ..... 33333 ..... <br>
..... 22222 ..... 44444 <br>
11111 ..... 33333 ..... <br>
..... 22222 ..... 44444 <br>
11111 ..... 33333 ..... <br>
..... 22222 ..... 44444</p>

<p style="margin-top: 1em">interleave_top, 4 <br>
Interleave the upper field from odd frames with the lower
field from even frames, generating a frame with unchanged
height at half frame rate.</p>

<p style="margin-top: 1em">------&gt; time <br>
Input: <br>
Frame 1 Frame 2 Frame 3 Frame 4</p>

<p style="margin-top: 1em">11111&lt;- 22222 33333&lt;-
44444 <br>
11111 22222&lt;- 33333 44444&lt;- <br>
11111&lt;- 22222 33333&lt;- 44444 <br>
11111 22222&lt;- 33333 44444&lt;-</p>

<p style="margin-top: 1em">Output: <br>
11111 33333 <br>
22222 44444 <br>
11111 33333 <br>
22222 44444</p>

<p style="margin-top: 1em">interleave_bottom, 5 <br>
Interleave the lower field from odd frames with the upper
field from even frames, generating a frame with unchanged
height at half frame rate.</p>

<p style="margin-top: 1em">------&gt; time <br>
Input: <br>
Frame 1 Frame 2 Frame 3 Frame 4</p>

<p style="margin-top: 1em">11111 22222&lt;- 33333
44444&lt;- <br>
11111&lt;- 22222 33333&lt;- 44444 <br>
11111 22222&lt;- 33333 44444&lt;- <br>
11111&lt;- 22222 33333&lt;- 44444</p>

<p style="margin-top: 1em">Output: <br>
22222 44444 <br>
11111 33333 <br>
22222 44444 <br>
11111 33333</p>

<p style="margin-top: 1em">interlacex2, 6 <br>
Double frame rate with unchanged height. Frames are inserted
each containing the second temporal field from the previous
input frame and the first temporal field from the <br>
next input frame. This mode relies on the top_field_first
flag. Useful for interlaced video displays with no field
synchronisation.</p>

<p style="margin-top: 1em">------&gt; time <br>
Input: <br>
Frame 1 Frame 2 Frame 3 Frame 4</p>

<p style="margin-top: 1em">11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444</p>

<p style="margin-top: 1em">Output: <br>
11111 22222 22222 33333 33333 44444 44444 <br>
11111 11111 22222 22222 33333 33333 44444 <br>
11111 22222 22222 33333 33333 44444 44444 <br>
11111 11111 22222 22222 33333 33333 44444</p>

<p style="margin-top: 1em">mergex2, 7 <br>
Move odd frames into the upper field, even into the lower
field, generating a double height frame at same frame
rate.</p>

<p style="margin-top: 1em">------&gt; time <br>
Input: <br>
Frame 1 Frame 2 Frame 3 Frame 4</p>

<p style="margin-top: 1em">11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444 <br>
11111 22222 33333 44444</p>

<p style="margin-top: 1em">Output: <br>
11111 33333 33333 55555 <br>
22222 22222 44444 44444 <br>
11111 33333 33333 55555 <br>
22222 22222 44444 44444 <br>
11111 33333 33333 55555 <br>
22222 22222 44444 44444 <br>
11111 33333 33333 55555 <br>
22222 22222 44444 44444</p>

<p style="margin-top: 1em">Numeric values are deprecated
but are accepted for backward compatibility reasons.</p>

<p style="margin-top: 1em">Default mode is
&quot;merge&quot;.</p>

<p style="margin-top: 1em">flags <br>
Specify flags influencing the filter process.</p>

<p style="margin-top: 1em">Available value for flags
is:</p>

<p style="margin-top: 1em">low_pass_filter, vlfp <br>
Enable vertical low-pass filtering in the filter. Vertical
low-pass filtering is required when creating an interlaced
destination from a progressive source which <br>
contains high-frequency vertical detail. Filtering will
reduce interlace &rsquo;twitter&rsquo; and Moire
patterning.</p>

<p style="margin-top: 1em">Vertical low-pass filtering can
only be enabled for mode interleave_top and
interleave_bottom.</p>

<p style="margin-top: 1em">transpose <br>
Transpose rows with columns in the input video and
optionally flip it.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">dir Specify the transposition
direction.</p>

<p style="margin-top: 1em">Can assume the following
values:</p>

<p style="margin-top: 1em">0, 4, cclock_flip <br>
Rotate by 90 degrees counterclockwise and vertically flip
(default), that is:</p>

<p style="margin-top: 1em">L.R L.l <br>
. . -&gt; . . <br>
l.r R.r</p>

<p style="margin-top: 1em">1, 5, clock <br>
Rotate by 90 degrees clockwise, that is:</p>

<p style="margin-top: 1em">L.R l.L <br>
. . -&gt; . . <br>
l.r r.R</p>

<p style="margin-top: 1em">2, 6, cclock <br>
Rotate by 90 degrees counterclockwise, that is:</p>

<p style="margin-top: 1em">L.R R.r <br>
. . -&gt; . . <br>
l.r L.l</p>

<p style="margin-top: 1em">3, 7, clock_flip <br>
Rotate by 90 degrees clockwise and vertically flip, that
is:</p>

<p style="margin-top: 1em">L.R r.R <br>
. . -&gt; . . <br>
l.r l.L</p>

<p style="margin-top: 1em">For values between 4-7, the
transposition is only done if the input video geometry is
portrait and not landscape. These values are deprecated, the
&quot;passthrough&quot; option should <br>
be used instead.</p>

<p style="margin-top: 1em">Numerical values are deprecated,
and should be dropped in favor of symbolic constants.</p>

<p style="margin-top: 1em">passthrough <br>
Do not apply the transposition if the input geometry matches
the one specified by the specified value. It accepts the
following values:</p>

<p style="margin-top: 1em">none <br>
Always apply transposition.</p>

<p style="margin-top: 1em">portrait <br>
Preserve portrait geometry (when height &gt;= width).</p>

<p style="margin-top: 1em">landscape <br>
Preserve landscape geometry (when width &gt;= height).</p>

<p style="margin-top: 1em">Default value is
&quot;none&quot;.</p>

<p style="margin-top: 1em">For example to rotate by 90
degrees clockwise and preserve portrait layout:</p>


<p style="margin-top: 1em">transpose=dir=1:passthrough=portrait</p>

<p style="margin-top: 1em">The command above can also be
specified as:</p>

<p style="margin-top: 1em">transpose=1:portrait</p>

<p style="margin-top: 1em">trim <br>
Trim the input so that the output contains one continuous
subpart of the input.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">start <br>
Specify the time of the start of the kept section, i.e. the
frame with the timestamp start will be the first frame in
the output.</p>

<p style="margin-top: 1em">end Specify the time of the
first frame that will be dropped, i.e. the frame immediately
preceding the one with the timestamp end will be the last
frame in the output.</p>

<p style="margin-top: 1em">start_pts <br>
This is the same as start, except this option sets the start
timestamp in timebase units instead of seconds.</p>

<p style="margin-top: 1em">end_pts <br>
This is the same as end, except this option sets the end
timestamp in timebase units instead of seconds.</p>

<p style="margin-top: 1em">duration <br>
The maximum duration of the output in seconds.</p>

<p style="margin-top: 1em">start_frame <br>
The number of the first frame that should be passed to the
output.</p>

<p style="margin-top: 1em">end_frame <br>
The number of the first frame that should be dropped.</p>

<p style="margin-top: 1em">start, end, and duration are
expressed as time duration specifications; see the Time
duration section in the ffmpeg-utils(1) manual for the
accepted syntax.</p>

<p style="margin-top: 1em">Note that the first two sets of
the start/end options and the duration option look at the
frame timestamp, while the _frame variants simply count the
frames that pass through the <br>
filter. Also note that this filter does not modify the
timestamps. If you wish for the output timestamps to start
at zero, insert a setpts filter after the trim filter.</p>

<p style="margin-top: 1em">If multiple start or end options
are set, this filter tries to be greedy and keep all the
frames that match at least one of the specified constraints.
To keep only the part that <br>
matches all the constraints at once, chain multiple trim
filters.</p>

<p style="margin-top: 1em">The defaults are such that all
the input is kept. So it is possible to set e.g. just the
end values to keep everything before the specified time.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">&Acirc;&middot; Drop everything
except the second minute of input:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -vf
trim=60:120</p>

<p style="margin-top: 1em">&Acirc;&middot; Keep only the
first second:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -vf
trim=duration=1</p>

<p style="margin-top: 1em">unsharp <br>
Sharpen or blur the input video.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">luma_msize_x, lx <br>
Set the luma matrix horizontal size. It must be an odd
integer between 3 and 23. The default value is 5.</p>

<p style="margin-top: 1em">luma_msize_y, ly <br>
Set the luma matrix vertical size. It must be an odd integer
between 3 and 23. The default value is 5.</p>

<p style="margin-top: 1em">luma_amount, la <br>
Set the luma effect strength. It must be a floating point
number, reasonable values lay between -1.5 and 1.5.</p>

<p style="margin-top: 1em">Negative values will blur the
input video, while positive values will sharpen it, a value
of zero will disable the effect.</p>

<p style="margin-top: 1em">Default value is 1.0.</p>

<p style="margin-top: 1em">chroma_msize_x, cx <br>
Set the chroma matrix horizontal size. It must be an odd
integer between 3 and 23. The default value is 5.</p>

<p style="margin-top: 1em">chroma_msize_y, cy <br>
Set the chroma matrix vertical size. It must be an odd
integer between 3 and 23. The default value is 5.</p>

<p style="margin-top: 1em">chroma_amount, ca <br>
Set the chroma effect strength. It must be a floating point
number, reasonable values lay between -1.5 and 1.5.</p>

<p style="margin-top: 1em">Negative values will blur the
input video, while positive values will sharpen it, a value
of zero will disable the effect.</p>

<p style="margin-top: 1em">Default value is 0.0.</p>

<p style="margin-top: 1em">opencl <br>
If set to 1, specify using OpenCL capabilities, only
available if FFmpeg was configured with
&quot;--enable-opencl&quot;. Default value is 0.</p>

<p style="margin-top: 1em">All parameters are optional and
default to the equivalent of the string
&rsquo;5:5:1.0:5:5:0.0&rsquo;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply strong
luma sharpen effect:</p>


<p style="margin-top: 1em">unsharp=luma_msize_x=7:luma_msize_y=7:luma_amount=2.5</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply a strong
blur of both luma and chroma parameters:</p>

<p style="margin-top: 1em">unsharp=7:7:-2:7:7:-2</p>

<p style="margin-top: 1em">uspp <br>
Apply ultra slow/simple postprocessing filter that
compresses and decompresses the image at several (or - in
the case of quality level 8 - all) shifts and average the
results.</p>

<p style="margin-top: 1em">The way this differs from the
behavior of spp is that uspp actually encodes &amp; decodes
each case with libavcodec Snow, whereas spp uses a
simplified intra only 8x8 DCT similar to <br>
MJPEG.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">quality <br>
Set quality. This option defines the number of levels for
averaging. It accepts an integer in the range 0-8. If set to
0, the filter will have no effect. A value of 8 means <br>
the higher quality. For each increment of that value the
speed drops by a factor of approximately 2. Default value is
3.</p>

<p style="margin-top: 1em">qp Force a constant quantization
parameter. If not set, the filter will use the QP from the
video stream (if available).</p>

<p style="margin-top: 1em">vaguedenoiser <br>
Apply a wavelet based denoiser.</p>

<p style="margin-top: 1em">It transforms each frame from
the video input into the wavelet domain, using
Cohen-Daubechies-Feauveau 9/7. Then it applies some
filtering to the obtained coefficients. It does <br>
an inverse wavelet transform after. Due to wavelet
properties, it should give a nice smoothed result, and
reduced noise, without blurring picture features.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">threshold <br>
The filtering strength. The higher, the more filtered the
video will be. Hard thresholding can use a higher threshold
than soft thresholding before the video looks <br>
overfiltered.</p>

<p style="margin-top: 1em">method <br>
The filtering method the filter will use.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">hard <br>
All values under the threshold will be zeroed.</p>

<p style="margin-top: 1em">soft <br>
All values under the threshold will be zeroed. All values
above will be reduced by the threshold.</p>

<p style="margin-top: 1em">garrote <br>
Scales or nullifies coefficients - intermediary between
(more) soft and (less) hard thresholding.</p>

<p style="margin-top: 1em">nsteps <br>
Number of times, the wavelet will decompose the picture.
Picture can&rsquo;t be decomposed beyond a particular point
(typically, 8 for a 640x480 frame - as 2^9 = 512 &gt;
480)</p>

<p style="margin-top: 1em">percent <br>
Partial of full denoising (limited coefficients shrinking),
from 0 to 100.</p>

<p style="margin-top: 1em">planes <br>
A list of the planes to process. By default all planes are
processed.</p>

<p style="margin-top: 1em">vectorscope <br>
Display 2 color component values in the two dimensional
graph (which is called a vectorscope).</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">mode, m <br>
Set vectorscope mode.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">gray <br>
Gray values are displayed on graph, higher brightness means
more pixels have same component color value on location in
graph. This is the default mode.</p>

<p style="margin-top: 1em">color <br>
Gray values are displayed on graph. Surrounding pixels
values which are not present in video frame are drawn in
gradient of 2 color components which are set by option
&quot;x&quot; <br>
and &quot;y&quot;. The 3rd color component is static.</p>

<p style="margin-top: 1em">color2 <br>
Actual color components values present in video frame are
displayed on graph.</p>

<p style="margin-top: 1em">color3 <br>
Similar as color2 but higher frequency of same values
&quot;x&quot; and &quot;y&quot; on graph increases value of
another color component, which is luminance by default
values of &quot;x&quot; and <br>
&quot;y&quot;.</p>

<p style="margin-top: 1em">color4 <br>
Actual colors present in video frame are displayed on graph.
If two different colors map to same position on graph then
color with higher value of component not present <br>
in graph is picked.</p>

<p style="margin-top: 1em">color5 <br>
Gray values are displayed on graph. Similar to
&quot;color&quot; but with 3rd color component picked from
radial gradient.</p>

<p style="margin-top: 1em">x Set which color component will
be represented on X-axis. Default is 1.</p>

<p style="margin-top: 1em">y Set which color component will
be represented on Y-axis. Default is 2.</p>

<p style="margin-top: 1em">intensity, i <br>
Set intensity, used by modes: gray, color, color3 and color5
for increasing brightness of color component which
represents frequency of (X, Y) location in graph.</p>

<p style="margin-top: 1em">envelope, e <br>
none <br>
No envelope, this is default.</p>

<p style="margin-top: 1em">instant <br>
Instant envelope, even darkest single pixel will be clearly
highlighted.</p>

<p style="margin-top: 1em">peak <br>
Hold maximum and minimum values presented in graph over
time. This way you can still spot out of range values
without constantly looking at vectorscope.</p>

<p style="margin-top: 1em">peak+instant <br>
Peak and instant envelope combined together.</p>

<p style="margin-top: 1em">graticule, g <br>
Set what kind of graticule to draw.</p>

<p style="margin-top: 1em">none <br>
green <br>
color <br>
opacity, o <br>
Set graticule opacity.</p>

<p style="margin-top: 1em">flags, f <br>
Set graticule flags.</p>

<p style="margin-top: 1em">white <br>
Draw graticule for white point.</p>

<p style="margin-top: 1em">black <br>
Draw graticule for black point.</p>

<p style="margin-top: 1em">name <br>
Draw color points short names.</p>

<p style="margin-top: 1em">bgopacity, b <br>
Set background opacity.</p>

<p style="margin-top: 1em">lthreshold, l <br>
Set low threshold for color component not represented on X
or Y axis. Values lower than this value will be ignored.
Default is 0. Note this value is multiplied with actual <br>
max possible value one pixel component can have. So for
8-bit input and low threshold value of 0.1 actual threshold
is 0.1 * 255 = 25.</p>

<p style="margin-top: 1em">hthreshold, h <br>
Set high threshold for color component not represented on X
or Y axis. Values higher than this value will be ignored.
Default is 1. Note this value is multiplied with <br>
actual max possible value one pixel component can have. So
for 8-bit input and high threshold value of 0.9 actual
threshold is 0.9 * 255 = 230.</p>

<p style="margin-top: 1em">colorspace, c <br>
Set what kind of colorspace to use when drawing
graticule.</p>

<p style="margin-top: 1em">auto <br>
601 <br>
709</p>

<p style="margin-top: 1em">Default is auto.</p>

<p style="margin-top: 1em">vidstabdetect <br>
Analyze video stabilization/deshaking. Perform pass 1 of 2,
see vidstabtransform for pass 2.</p>

<p style="margin-top: 1em">This filter generates a file
with relative translation and rotation transform information
about subsequent frames, which is then used by the
vidstabtransform filter.</p>

<p style="margin-top: 1em">To enable compilation of this
filter you need to configure FFmpeg with
&quot;--enable-libvidstab&quot;.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">result <br>
Set the path to the file used to write the transforms
information. Default value is transforms.trf.</p>

<p style="margin-top: 1em">shakiness <br>
Set how shaky the video is and how quick the camera is. It
accepts an integer in the range 1-10, a value of 1 means
little shakiness, a value of 10 means strong shakiness. <br>
Default value is 5.</p>

<p style="margin-top: 1em">accuracy <br>
Set the accuracy of the detection process. It must be a
value in the range 1-15. A value of 1 means low accuracy, a
value of 15 means high accuracy. Default value is 15.</p>

<p style="margin-top: 1em">stepsize <br>
Set stepsize of the search process. The region around
minimum is scanned with 1 pixel resolution. Default value is
6.</p>

<p style="margin-top: 1em">mincontrast <br>
Set minimum contrast. Below this value a local measurement
field is discarded. Must be a floating point value in the
range 0-1. Default value is 0.3.</p>

<p style="margin-top: 1em">tripod <br>
Set reference frame number for tripod mode.</p>

<p style="margin-top: 1em">If enabled, the motion of the
frames is compared to a reference frame in the filtered
stream, identified by the specified number. The idea is to
compensate all movements in a <br>
more-or-less static scene and keep the camera view
absolutely still.</p>

<p style="margin-top: 1em">If set to 0, it is disabled. The
frames are counted starting from 1.</p>

<p style="margin-top: 1em">show <br>
Show fields and transforms in the resulting frames. It
accepts an integer in the range 0-2. Default value is 0,
which disables any visualization.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Use default
values:</p>

<p style="margin-top: 1em">vidstabdetect</p>

<p style="margin-top: 1em">&Acirc;&middot; Analyze strongly
shaky movie and put the results in file
mytransforms.trf:</p>


<p style="margin-top: 1em">vidstabdetect=shakiness=10:accuracy=15:result=&quot;mytransforms.trf&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Visualize the
result of internal transformations in the resulting
video:</p>

<p style="margin-top: 1em">vidstabdetect=show=1</p>

<p style="margin-top: 1em">&Acirc;&middot; Analyze a video
with medium shakiness using ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i input -vf
vidstabdetect=shakiness=5:show=1 dummy.avi</p>

<p style="margin-top: 1em">vidstabtransform <br>
Video stabilization/deshaking: pass 2 of 2, see
vidstabdetect for pass 1.</p>

<p style="margin-top: 1em">Read a file with transform
information for each frame and apply/compensate them.
Together with the vidstabdetect filter this can be used to
deshake videos. See also <br>
&lt;http://public.hronopik.de/vid.stab&gt;. It is important
to also use the unsharp filter, see below.</p>

<p style="margin-top: 1em">To enable compilation of this
filter you need to configure FFmpeg with
&quot;--enable-libvidstab&quot;.</p>

<p style="margin-top: 1em">Options</p>

<p style="margin-top: 1em">input <br>
Set path to the file used to read the transforms. Default
value is transforms.trf.</p>

<p style="margin-top: 1em">smoothing <br>
Set the number of frames (value*2 + 1) used for lowpass
filtering the camera movements. Default value is 10.</p>

<p style="margin-top: 1em">For example a number of 10 means
that 21 frames are used (10 in the past and 10 in the
future) to smoothen the motion in the video. A larger value
leads to a smoother video, <br>
but limits the acceleration of the camera (pan/tilt
movements). 0 is a special case where a static camera is
simulated.</p>

<p style="margin-top: 1em">optalgo <br>
Set the camera path optimization algorithm.</p>

<p style="margin-top: 1em">Accepted values are:</p>

<p style="margin-top: 1em">gauss <br>
gaussian kernel low-pass filter on camera motion
(default)</p>

<p style="margin-top: 1em">avg averaging on
transformations</p>

<p style="margin-top: 1em">maxshift <br>
Set maximal number of pixels to translate frames. Default
value is -1, meaning no limit.</p>

<p style="margin-top: 1em">maxangle <br>
Set maximal angle in radians (degree*PI/180) to rotate
frames. Default value is -1, meaning no limit.</p>

<p style="margin-top: 1em">crop <br>
Specify how to deal with borders that may be visible due to
movement compensation.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">keep <br>
keep image information from previous frame (default)</p>

<p style="margin-top: 1em">black <br>
fill the border black</p>

<p style="margin-top: 1em">invert <br>
Invert transforms if set to 1. Default value is 0.</p>

<p style="margin-top: 1em">relative <br>
Consider transforms as relative to previous frame if set to
1, absolute if set to 0. Default value is 0.</p>

<p style="margin-top: 1em">zoom <br>
Set percentage to zoom. A positive value will result in a
zoom-in effect, a negative value in a zoom-out effect.
Default value is 0 (no zoom).</p>

<p style="margin-top: 1em">optzoom <br>
Set optimal zooming to avoid borders.</p>

<p style="margin-top: 1em">Accepted values are:</p>

<p style="margin-top: 1em">0 disabled</p>

<p style="margin-top: 1em">1 optimal static zoom value is
determined (only very strong movements will lead to visible
borders) (default)</p>

<p style="margin-top: 1em">2 optimal adaptive zoom value is
determined (no borders will be visible), see zoomspeed</p>

<p style="margin-top: 1em">Note that the value given at
zoom is added to the one calculated here.</p>

<p style="margin-top: 1em">zoomspeed <br>
Set percent to zoom maximally each frame (enabled when
optzoom is set to 2). Range is from 0 to 5, default value is
0.25.</p>

<p style="margin-top: 1em">interpol <br>
Specify type of interpolation.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">no no interpolation</p>

<p style="margin-top: 1em">linear <br>
linear only horizontal</p>

<p style="margin-top: 1em">bilinear <br>
linear in both directions (default)</p>

<p style="margin-top: 1em">bicubic <br>
cubic in both directions (slow)</p>

<p style="margin-top: 1em">tripod <br>
Enable virtual tripod mode if set to 1, which is equivalent
to &quot;relative=0:smoothing=0&quot;. Default value is
0.</p>

<p style="margin-top: 1em">Use also &quot;tripod&quot;
option of vidstabdetect.</p>

<p style="margin-top: 1em">debug <br>
Increase log verbosity if set to 1. Also the detected global
motions are written to the temporary file
global_motions.trf. Default value is 0.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Use ffmpeg for a
typical stabilization with default values:</p>

<p style="margin-top: 1em">ffmpeg -i inp.mpeg -vf
vidstabtransform,unsharp=5:5:0.8:3:3:0.4
inp_stabilized.mpeg</p>

<p style="margin-top: 1em">Note the use of the unsharp
filter which is always recommended.</p>

<p style="margin-top: 1em">&Acirc;&middot; Zoom in a bit
more and load transform data from a given file:</p>


<p style="margin-top: 1em">vidstabtransform=zoom=5:input=&quot;mytransforms.trf&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Smoothen the
video even more:</p>


<p style="margin-top: 1em">vidstabtransform=smoothing=30</p>

<p style="margin-top: 1em">vflip <br>
Flip the input video vertically.</p>

<p style="margin-top: 1em">For example, to vertically flip
a video with ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i in.avi -vf
&quot;vflip&quot; out.avi</p>

<p style="margin-top: 1em">vignette <br>
Make or reverse a natural vignetting effect.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">angle, a <br>
Set lens angle expression as a number of radians.</p>

<p style="margin-top: 1em">The value is clipped in the
&quot;[0,PI/2]&quot; range.</p>

<p style="margin-top: 1em">Default value:
&quot;PI/5&quot;</p>

<p style="margin-top: 1em">x0 <br>
y0 Set center coordinates expressions. Respectively
&quot;w/2&quot; and &quot;h/2&quot; by default.</p>

<p style="margin-top: 1em">mode <br>
Set forward/backward mode.</p>

<p style="margin-top: 1em">Available modes are:</p>

<p style="margin-top: 1em">forward <br>
The larger the distance from the central point, the darker
the image becomes.</p>

<p style="margin-top: 1em">backward <br>
The larger the distance from the central point, the brighter
the image becomes. This can be used to reverse a vignette
effect, though there is no automatic detection to <br>
extract the lens angle and other settings (yet). It can also
be used to create a burning effect.</p>

<p style="margin-top: 1em">Default value is forward.</p>

<p style="margin-top: 1em">eval <br>
Set evaluation mode for the expressions (angle, x0, y0).</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">init <br>
Evaluate expressions only once during the filter
initialization.</p>

<p style="margin-top: 1em">frame <br>
Evaluate expressions for each incoming frame. This is way
slower than the init mode since it requires all the scalers
to be re-computed, but it allows advanced dynamic <br>
expressions.</p>

<p style="margin-top: 1em">Default value is init.</p>

<p style="margin-top: 1em">dither <br>
Set dithering to reduce the circular banding effects.
Default is 1 (enabled).</p>

<p style="margin-top: 1em">aspect <br>
Set vignette aspect. This setting allows one to adjust the
shape of the vignette. Setting this value to the SAR of the
input will make a rectangular vignetting following the <br>
dimensions of the video.</p>

<p style="margin-top: 1em">Default is &quot;1/1&quot;.</p>

<p style="margin-top: 1em">Expressions</p>

<p style="margin-top: 1em">The alpha, x0 and y0 expressions
can contain the following parameters.</p>

<p style="margin-top: 1em">w <br>
h input width and height</p>

<p style="margin-top: 1em">n the number of input frame,
starting from 0</p>

<p style="margin-top: 1em">pts the PTS (Presentation
TimeStamp) time of the filtered video frame, expressed in TB
units, NAN if undefined</p>

<p style="margin-top: 1em">r frame rate of the input video,
NAN if the input frame rate is unknown</p>

<p style="margin-top: 1em">t the PTS (Presentation
TimeStamp) of the filtered video frame, expressed in
seconds, NAN if undefined</p>

<p style="margin-top: 1em">tb time base of the input
video</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply simple
strong vignetting effect:</p>

<p style="margin-top: 1em">vignette=PI/4</p>

<p style="margin-top: 1em">&Acirc;&middot; Make a
flickering vignetting:</p>


<p style="margin-top: 1em">vignette=&rsquo;PI/4+random(1)*PI/50&rsquo;:eval=frame</p>

<p style="margin-top: 1em">vstack <br>
Stack input videos vertically.</p>

<p style="margin-top: 1em">All streams must be of same
pixel format and of same width.</p>

<p style="margin-top: 1em">Note that this filter is faster
than using overlay and pad filter to create same output.</p>

<p style="margin-top: 1em">The filter accept the following
option:</p>

<p style="margin-top: 1em">inputs <br>
Set number of input streams. Default is 2.</p>

<p style="margin-top: 1em">shortest <br>
If set to 1, force the output to terminate when the shortest
input terminates. Default value is 0.</p>

<p style="margin-top: 1em">w3fdif <br>
Deinterlace the input video (&quot;w3fdif&quot; stands for
&quot;Weston 3 Field Deinterlacing Filter&quot;).</p>

<p style="margin-top: 1em">Based on the process described
by Martin Weston for BBC R&amp;D, and implemented based on
the de-interlace algorithm written by Jim Easterbrook for
BBC R&amp;D, the Weston 3 field <br>
deinterlacing filter uses filter coefficients calculated by
BBC R&amp;D.</p>

<p style="margin-top: 1em">There are two sets of filter
coefficients, so called &quot;simple&quot;: and
&quot;complex&quot;. Which set of filter coefficients is
used can be set by passing an optional parameter:</p>

<p style="margin-top: 1em">filter <br>
Set the interlacing filter coefficients. Accepts one of the
following values:</p>

<p style="margin-top: 1em">simple <br>
Simple filter coefficient set.</p>

<p style="margin-top: 1em">complex <br>
More-complex filter coefficient set.</p>

<p style="margin-top: 1em">Default value is complex.</p>

<p style="margin-top: 1em">deint <br>
Specify which frames to deinterlace. Accept one of the
following values:</p>

<p style="margin-top: 1em">all Deinterlace all frames,</p>

<p style="margin-top: 1em">interlaced <br>
Only deinterlace frames marked as interlaced.</p>

<p style="margin-top: 1em">Default value is all.</p>

<p style="margin-top: 1em">waveform <br>
Video waveform monitor.</p>

<p style="margin-top: 1em">The waveform monitor plots color
component intensity. By default luminance only. Each column
of the waveform corresponds to a column of pixels in the
source video.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">mode, m <br>
Can be either &quot;row&quot;, or &quot;column&quot;.
Default is &quot;column&quot;. In row mode, the graph on the
left side represents color component value 0 and the right
side represents value = 255. <br>
In column mode, the top side represents color component
value = 0 and bottom side represents value = 255.</p>

<p style="margin-top: 1em">intensity, i <br>
Set intensity. Smaller values are useful to find out how
many values of the same luminance are distributed across
input rows/columns. Default value is 0.04. Allowed range is
<br>
[0, 1].</p>

<p style="margin-top: 1em">mirror, r <br>
Set mirroring mode. 0 means unmirrored, 1 means mirrored. In
mirrored mode, higher values will be represented on the left
side for &quot;row&quot; mode and at the top for
&quot;column&quot; <br>
mode. Default is 1 (mirrored).</p>

<p style="margin-top: 1em">display, d <br>
Set display mode. It accepts the following values:</p>

<p style="margin-top: 1em">overlay <br>
Presents information identical to that in the
&quot;parade&quot;, except that the graphs representing
color components are superimposed directly over one
another.</p>

<p style="margin-top: 1em">This display mode makes it
easier to spot relative differences or similarities in
overlapping areas of the color components that are supposed
to be identical, such as <br>
neutral whites, grays, or blacks.</p>

<p style="margin-top: 1em">stack <br>
Display separate graph for the color components side by side
in &quot;row&quot; mode or one below the other in
&quot;column&quot; mode.</p>

<p style="margin-top: 1em">parade <br>
Display separate graph for the color components side by side
in &quot;column&quot; mode or one below the other in
&quot;row&quot; mode.</p>

<p style="margin-top: 1em">Using this display mode makes it
easy to spot color casts in the highlights and shadows of an
image, by comparing the contours of the top and the bottom
graphs of each <br>
waveform. Since whites, grays, and blacks are characterized
by exactly equal amounts of red, green, and blue, neutral
areas of the picture should display three waveforms <br>
of roughly equal width/height. If not, the correction is
easy to perform by making level adjustments the three
waveforms.</p>

<p style="margin-top: 1em">Default is
&quot;stack&quot;.</p>

<p style="margin-top: 1em">components, c <br>
Set which color components to display. Default is 1, which
means only luminance or red color component if input is in
RGB colorspace. If is set for example to 7 it will <br>
display all 3 (if) available color components.</p>

<p style="margin-top: 1em">envelope, e <br>
none <br>
No envelope, this is default.</p>

<p style="margin-top: 1em">instant <br>
Instant envelope, minimum and maximum values presented in
graph will be easily visible even with small
&quot;step&quot; value.</p>

<p style="margin-top: 1em">peak <br>
Hold minimum and maximum values presented in graph across
time. This way you can still spot out of range values
without constantly looking at waveforms.</p>

<p style="margin-top: 1em">peak+instant <br>
Peak and instant envelope combined together.</p>

<p style="margin-top: 1em">filter, f <br>
lowpass <br>
No filtering, this is default.</p>

<p style="margin-top: 1em">flat <br>
Luma and chroma combined together.</p>

<p style="margin-top: 1em">aflat <br>
Similar as above, but shows difference between blue and red
chroma.</p>

<p style="margin-top: 1em">chroma <br>
Displays only chroma.</p>

<p style="margin-top: 1em">color <br>
Displays actual color value on waveform.</p>

<p style="margin-top: 1em">acolor <br>
Similar as above, but with luma showing frequency of chroma
values.</p>

<p style="margin-top: 1em">graticule, g <br>
Set which graticule to display.</p>

<p style="margin-top: 1em">none <br>
Do not display graticule.</p>

<p style="margin-top: 1em">green <br>
Display green graticule showing legal broadcast ranges.</p>

<p style="margin-top: 1em">opacity, o <br>
Set graticule opacity.</p>

<p style="margin-top: 1em">flags, fl <br>
Set graticule flags.</p>

<p style="margin-top: 1em">numbers <br>
Draw numbers above lines. By default enabled.</p>

<p style="margin-top: 1em">dots <br>
Draw dots instead of lines.</p>

<p style="margin-top: 1em">scale, s <br>
Set scale used for displaying graticule.</p>

<p style="margin-top: 1em">digital <br>
millivolts <br>
ire</p>

<p style="margin-top: 1em">Default is digital.</p>

<p style="margin-top: 1em">bgopacity, b <br>
Set background opacity.</p>

<p style="margin-top: 1em">weave <br>
The &quot;weave&quot; takes a field-based video input and
join each two sequential fields into single frame, producing
a new double height clip with half the frame rate and half
the frame <br>
count.</p>

<p style="margin-top: 1em">It accepts the following
option:</p>

<p style="margin-top: 1em">first_field <br>
Set first field. Available values are:</p>

<p style="margin-top: 1em">top, t <br>
Set the frame as top-field-first.</p>

<p style="margin-top: 1em">bottom, b <br>
Set the frame as bottom-field-first.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Interlace video
using select and separatefields filter:</p>


<p style="margin-top: 1em">separatefields,select=eq(mod(n,4),0)+eq(mod(n,4),3),weave</p>

<p style="margin-top: 1em">xbr <br>
Apply the xBR high-quality magnification filter which is
designed for pixel art. It follows a set of edge-detection
rules, see <br>

&lt;http://www.libretro.com/forums/viewtopic.php?f=6&amp;t=134&gt;.</p>

<p style="margin-top: 1em">It accepts the following
option:</p>

<p style="margin-top: 1em">n Set the scaling dimension: 2
for &quot;2xBR&quot;, 3 for &quot;3xBR&quot; and 4 for
&quot;4xBR&quot;. Default is 3.</p>

<p style="margin-top: 1em">yadif <br>
Deinterlace the input video (&quot;yadif&quot; means
&quot;yet another deinterlacing filter&quot;).</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">mode <br>
The interlacing mode to adopt. It accepts one of the
following values:</p>

<p style="margin-top: 1em">0, send_frame <br>
Output one frame for each frame.</p>

<p style="margin-top: 1em">1, send_field <br>
Output one frame for each field.</p>

<p style="margin-top: 1em">2, send_frame_nospatial <br>
Like &quot;send_frame&quot;, but it skips the spatial
interlacing check.</p>

<p style="margin-top: 1em">3, send_field_nospatial <br>
Like &quot;send_field&quot;, but it skips the spatial
interlacing check.</p>

<p style="margin-top: 1em">The default value is
&quot;send_frame&quot;.</p>

<p style="margin-top: 1em">parity <br>
The picture field parity assumed for the input interlaced
video. It accepts one of the following values:</p>

<p style="margin-top: 1em">0, tff <br>
Assume the top field is first.</p>

<p style="margin-top: 1em">1, bff <br>
Assume the bottom field is first.</p>

<p style="margin-top: 1em">-1, auto <br>
Enable automatic detection of field parity.</p>

<p style="margin-top: 1em">The default value is
&quot;auto&quot;. If the interlacing is unknown or the
decoder does not export this information, top field first
will be assumed.</p>

<p style="margin-top: 1em">deint <br>
Specify which frames to deinterlace. Accept one of the
following values:</p>

<p style="margin-top: 1em">0, all <br>
Deinterlace all frames.</p>

<p style="margin-top: 1em">1, interlaced <br>
Only deinterlace frames marked as interlaced.</p>

<p style="margin-top: 1em">The default value is
&quot;all&quot;.</p>

<p style="margin-top: 1em">zoompan <br>
Apply Zoom &amp; Pan effect.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">zoom, z <br>
Set the zoom expression. Default is 1.</p>

<p style="margin-top: 1em">x <br>
y Set the x and y expression. Default is 0.</p>

<p style="margin-top: 1em">d Set the duration expression in
number of frames. This sets for how many number of frames
effect will last for single input image.</p>

<p style="margin-top: 1em">s Set the output image size,
default is &rsquo;hd720&rsquo;.</p>

<p style="margin-top: 1em">fps Set the output frame rate,
default is &rsquo;25&rsquo;.</p>

<p style="margin-top: 1em">Each expression can contain the
following constants:</p>

<p style="margin-top: 1em">in_w, iw <br>
Input width.</p>

<p style="margin-top: 1em">in_h, ih <br>
Input height.</p>

<p style="margin-top: 1em">out_w, ow <br>
Output width.</p>

<p style="margin-top: 1em">out_h, oh <br>
Output height.</p>

<p style="margin-top: 1em">in Input frame count.</p>

<p style="margin-top: 1em">on Output frame count.</p>

<p style="margin-top: 1em">x <br>
y Last calculated &rsquo;x&rsquo; and &rsquo;y&rsquo;
position from &rsquo;x&rsquo; and &rsquo;y&rsquo; expression
for current input frame.</p>

<p style="margin-top: 1em">px <br>
py &rsquo;x&rsquo; and &rsquo;y&rsquo; of last output frame
of previous input frame or 0 when there was not yet such
frame (first input frame).</p>

<p style="margin-top: 1em">zoom <br>
Last calculated zoom from &rsquo;z&rsquo; expression for
current input frame.</p>

<p style="margin-top: 1em">pzoom <br>
Last calculated zoom of last output frame of previous input
frame.</p>

<p style="margin-top: 1em">duration <br>
Number of output frames for current input frame. Calculated
from &rsquo;d&rsquo; expression for each input frame.</p>

<p style="margin-top: 1em">pduration <br>
number of output frames created for previous input frame</p>

<p style="margin-top: 1em">a Rational number: input width /
input height</p>

<p style="margin-top: 1em">sar sample aspect ratio</p>

<p style="margin-top: 1em">dar display aspect ratio</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Zoom-in up to
1.5 and pan at same time to some spot near center of
picture:</p>


<p style="margin-top: 1em">zoompan=z=&rsquo;min(zoom+0.0015,1.5)&rsquo;:d=700:x=&rsquo;if(gte(zoom,1.5),x,x+1/a)&rsquo;:y=&rsquo;if(gte(zoom,1.5),y,y+1)&rsquo;:s=640x360</p>

<p style="margin-top: 1em">&Acirc;&middot; Zoom-in up to
1.5 and pan always at center of picture:</p>


<p style="margin-top: 1em">zoompan=z=&rsquo;min(zoom+0.0015,1.5)&rsquo;:d=700:x=&rsquo;iw/2-(iw/zoom/2)&rsquo;:y=&rsquo;ih/2-(ih/zoom/2)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Same as above
but without pausing:</p>


<p style="margin-top: 1em">zoompan=z=&rsquo;min(max(zoom,pzoom)+0.0015,1.5)&rsquo;:d=1:x=&rsquo;iw/2-(iw/zoom/2)&rsquo;:y=&rsquo;ih/2-(ih/zoom/2)&rsquo;</p>

<p style="margin-top: 1em">zscale <br>
Scale (resize) the input video, using the z.lib library:
https://github.com/sekrit-twc/zimg.</p>

<p style="margin-top: 1em">The zscale filter forces the
output display aspect ratio to be the same as the input, by
changing the output sample aspect ratio.</p>

<p style="margin-top: 1em">If the input image format is
different from the format requested by the next filter, the
zscale filter will convert the input to the requested
format.</p>

<p style="margin-top: 1em">Options</p>

<p style="margin-top: 1em">The filter accepts the following
options.</p>

<p style="margin-top: 1em">width, w <br>
height, h <br>
Set the output video dimension expression. Default value is
the input dimension.</p>

<p style="margin-top: 1em">If the width or w is 0, the
input width is used for the output. If the height or h is 0,
the input height is used for the output.</p>

<p style="margin-top: 1em">If one of the values is -1, the
zscale filter will use a value that maintains the aspect
ratio of the input image, calculated from the other
specified dimension. If both of <br>
them are -1, the input size is used</p>

<p style="margin-top: 1em">If one of the values is -n with
n &gt; 1, the zscale filter will also use a value that
maintains the aspect ratio of the input image, calculated
from the other specified <br>
dimension. After that it will, however, make sure that the
calculated dimension is divisible by n and adjust the value
if necessary.</p>

<p style="margin-top: 1em">See below for the list of
accepted constants for use in the dimension expression.</p>

<p style="margin-top: 1em">size, s <br>
Set the video size. For the syntax of this option, check the
&quot;Video size&quot; section in the ffmpeg-utils
manual.</p>

<p style="margin-top: 1em">dither, d <br>
Set the dither type.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">none <br>
ordered <br>
random <br>
error_diffusion</p>

<p style="margin-top: 1em">Default is none.</p>

<p style="margin-top: 1em">filter, f <br>
Set the resize filter type.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">point <br>
bilinear <br>
bicubic <br>
spline16 <br>
spline36 <br>
lanczos</p>

<p style="margin-top: 1em">Default is bilinear.</p>

<p style="margin-top: 1em">range, r <br>
Set the color range.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">input <br>
limited <br>
full</p>

<p style="margin-top: 1em">Default is same as input.</p>

<p style="margin-top: 1em">primaries, p <br>
Set the color primaries.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">input <br>
709 <br>
unspecified <br>
170m <br>
240m <br>
2020</p>

<p style="margin-top: 1em">Default is same as input.</p>

<p style="margin-top: 1em">transfer, t <br>
Set the transfer characteristics.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">input <br>
709 <br>
unspecified <br>
601 <br>
linear <br>
2020_10 <br>
2020_12</p>

<p style="margin-top: 1em">Default is same as input.</p>

<p style="margin-top: 1em">matrix, m <br>
Set the colorspace matrix.</p>

<p style="margin-top: 1em">Possible value are:</p>

<p style="margin-top: 1em">input <br>
709 <br>
unspecified <br>
470bg <br>
170m <br>
2020_ncl <br>
2020_cl</p>

<p style="margin-top: 1em">Default is same as input.</p>

<p style="margin-top: 1em">rangein, rin <br>
Set the input color range.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">input <br>
limited <br>
full</p>

<p style="margin-top: 1em">Default is same as input.</p>

<p style="margin-top: 1em">primariesin, pin <br>
Set the input color primaries.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">input <br>
709 <br>
unspecified <br>
170m <br>
240m <br>
2020</p>

<p style="margin-top: 1em">Default is same as input.</p>

<p style="margin-top: 1em">transferin, tin <br>
Set the input transfer characteristics.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">input <br>
709 <br>
unspecified <br>
601 <br>
linear <br>
2020_10 <br>
2020_12</p>

<p style="margin-top: 1em">Default is same as input.</p>

<p style="margin-top: 1em">matrixin, min <br>
Set the input colorspace matrix.</p>

<p style="margin-top: 1em">Possible value are:</p>

<p style="margin-top: 1em">input <br>
709 <br>
unspecified <br>
470bg <br>
170m <br>
2020_ncl <br>
2020_cl <br>
chromal, c <br>
Set the output chroma location.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">input <br>
left <br>
center <br>
topleft <br>
top <br>
bottomleft <br>
bottom <br>
chromalin, cin <br>
Set the input chroma location.</p>

<p style="margin-top: 1em">Possible values are:</p>

<p style="margin-top: 1em">input <br>
left <br>
center <br>
topleft <br>
top <br>
bottomleft <br>
bottom</p>

<p style="margin-top: 1em">The values of the w and h
options are expressions containing the following
constants:</p>

<p style="margin-top: 1em">in_w <br>
in_h <br>
The input width and height</p>

<p style="margin-top: 1em">iw <br>
ih These are the same as in_w and in_h.</p>

<p style="margin-top: 1em">out_w <br>
out_h <br>
The output (scaled) width and height</p>

<p style="margin-top: 1em">ow <br>
oh These are the same as out_w and out_h</p>

<p style="margin-top: 1em">a The same as iw / ih</p>

<p style="margin-top: 1em">sar input sample aspect
ratio</p>

<p style="margin-top: 1em">dar The input display aspect
ratio. Calculated from &quot;(iw / ih) * sar&quot;.</p>

<p style="margin-top: 1em">hsub <br>
vsub <br>
horizontal and vertical input chroma subsample values. For
example for the pixel format &quot;yuv422p&quot; hsub is 2
and vsub is 1.</p>

<p style="margin-top: 1em">ohsub <br>
ovsub <br>
horizontal and vertical output chroma subsample values. For
example for the pixel format &quot;yuv422p&quot; hsub is 2
and vsub is 1.</p>

<p style="margin-top: 1em">VIDEO SOURCES <br>
Below is a description of the currently available video
sources.</p>

<p style="margin-top: 1em">buffer <br>
Buffer video frames, and make them available to the filter
chain.</p>

<p style="margin-top: 1em">This source is mainly intended
for a programmatic use, in particular through the interface
defined in libavfilter/vsrc_buffer.h.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">video_size <br>
Specify the size (width and height) of the buffered video
frames. For the syntax of this option, check the &quot;Video
size&quot; section in the ffmpeg-utils manual.</p>

<p style="margin-top: 1em">width <br>
The input video width.</p>

<p style="margin-top: 1em">height <br>
The input video height.</p>

<p style="margin-top: 1em">pix_fmt <br>
A string representing the pixel format of the buffered video
frames. It may be a number corresponding to a pixel format,
or a pixel format name.</p>

<p style="margin-top: 1em">time_base <br>
Specify the timebase assumed by the timestamps of the
buffered frames.</p>

<p style="margin-top: 1em">frame_rate <br>
Specify the frame rate expected for the video stream.</p>

<p style="margin-top: 1em">pixel_aspect, sar <br>
The sample (pixel) aspect ratio of the input video.</p>

<p style="margin-top: 1em">sws_param <br>
Specify the optional parameters to be used for the scale
filter which is automatically inserted when an input change
is detected in the input size or format.</p>

<p style="margin-top: 1em">hw_frames_ctx <br>
When using a hardware pixel format, this should be a
reference to an AVHWFramesContext describing input
frames.</p>

<p style="margin-top: 1em">For example:</p>


<p style="margin-top: 1em">buffer=width=320:height=240:pix_fmt=yuv410p:time_base=1/24:sar=1</p>

<p style="margin-top: 1em">will instruct the source to
accept video frames with size 320x240 and with format
&quot;yuv410p&quot;, assuming 1/24 as the timestamps
timebase and square pixels (1:1 sample aspect ratio). <br>
Since the pixel format with name &quot;yuv410p&quot;
corresponds to the number 6 (check the enum AVPixelFormat
definition in libavutil/pixfmt.h), this example corresponds
to:</p>


<p style="margin-top: 1em">buffer=size=320x240:pixfmt=6:time_base=1/24:pixel_aspect=1/1</p>

<p style="margin-top: 1em">Alternatively, the options can
be specified as a flat string, but this syntax is
deprecated:</p>


<p style="margin-top: 1em">width:height:pix_fmt:time_base.num:time_base.den:pixel_aspect.num:pixel_aspect.den[:sws_param]</p>

<p style="margin-top: 1em">cellauto <br>
Create a pattern generated by an elementary cellular
automaton.</p>

<p style="margin-top: 1em">The initial state of the
cellular automaton can be defined through the filename and
pattern options. If such options are not specified an
initial state is created randomly.</p>

<p style="margin-top: 1em">At each new frame a new row in
the video is filled with the result of the cellular
automaton next generation. The behavior when the whole frame
is filled is defined by the scroll <br>
option.</p>

<p style="margin-top: 1em">This source accepts the
following options:</p>

<p style="margin-top: 1em">filename, f <br>
Read the initial cellular automaton state, i.e. the starting
row, from the specified file. In the file, each
non-whitespace character is considered an alive cell, a
newline <br>
will terminate the row, and further characters in the file
will be ignored.</p>

<p style="margin-top: 1em">pattern, p <br>
Read the initial cellular automaton state, i.e. the starting
row, from the specified string.</p>

<p style="margin-top: 1em">Each non-whitespace character in
the string is considered an alive cell, a newline will
terminate the row, and further characters in the string will
be ignored.</p>

<p style="margin-top: 1em">rate, r <br>
Set the video rate, that is the number of frames generated
per second. Default is 25.</p>

<p style="margin-top: 1em">random_fill_ratio, ratio <br>
Set the random fill ratio for the initial cellular automaton
row. It is a floating point number value ranging from 0 to
1, defaults to 1/PHI.</p>

<p style="margin-top: 1em">This option is ignored when a
file or a pattern is specified.</p>

<p style="margin-top: 1em">random_seed, seed <br>
Set the seed for filling randomly the initial row, must be
an integer included between 0 and UINT32_MAX. If not
specified, or if explicitly set to -1, the filter will try
to <br>
use a good random seed on a best effort basis.</p>

<p style="margin-top: 1em">rule <br>
Set the cellular automaton rule, it is a number ranging from
0 to 255. Default value is 110.</p>

<p style="margin-top: 1em">size, s <br>
Set the size of the output video. For the syntax of this
option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual.</p>

<p style="margin-top: 1em">If filename or pattern is
specified, the size is set by default to the width of the
specified initial state row, and the height is set to width
* PHI.</p>

<p style="margin-top: 1em">If size is set, it must contain
the width of the specified pattern string, and the specified
pattern will be centered in the larger row.</p>

<p style="margin-top: 1em">If a filename or a pattern
string is not specified, the size value defaults to
&quot;320x518&quot; (used for a randomly generated initial
state).</p>

<p style="margin-top: 1em">scroll <br>
If set to 1, scroll the output upward when all the rows in
the output have been already filled. If set to 0, the new
generated row will be written over the top row just after
<br>
the bottom row is filled. Defaults to 1.</p>

<p style="margin-top: 1em">start_full, full <br>
If set to 1, completely fill the output with generated rows
before outputting the first frame. This is the default
behavior, for disabling set the value to 0.</p>

<p style="margin-top: 1em">stitch <br>
If set to 1, stitch the left and right row edges together.
This is the default behavior, for disabling set the value to
0.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Read the initial
state from pattern, and specify an output of size
200x400.</p>


<p style="margin-top: 1em">cellauto=f=pattern:s=200x400</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a
random initial row with a width of 200 cells, with a fill
ratio of 2/3:</p>


<p style="margin-top: 1em">cellauto=ratio=2/3:s=200x200</p>

<p style="margin-top: 1em">&Acirc;&middot; Create a pattern
generated by rule 18 starting by a single alive cell
centered on an initial row with width 100:</p>


<p style="margin-top: 1em">cellauto=p=@s=100x400:full=0:rule=18</p>

<p style="margin-top: 1em">&Acirc;&middot; Specify a more
elaborated initial pattern:</p>

<p style="margin-top: 1em">cellauto=p=&rsquo;@@ @
@@&rsquo;:s=100x400:full=0:rule=18</p>

<p style="margin-top: 1em">coreimagesrc <br>
Video source generated on GPU using Apple&rsquo;s CoreImage
API on OSX.</p>

<p style="margin-top: 1em">This video source is a
specialized version of the coreimage video filter. Use a
core image generator at the beginning of the applied
filterchain to generate the content.</p>

<p style="margin-top: 1em">The coreimagesrc video source
accepts the following options:</p>

<p style="margin-top: 1em">list_generators <br>
List all available generators along with all their
respective options as well as possible minimum and maximum
values along with the default values.</p>

<p style="margin-top: 1em">list_generators=true</p>

<p style="margin-top: 1em">size, s <br>
Specify the size of the sourced video. For the syntax of
this option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual. The default value is
&quot;320x240&quot;.</p>

<p style="margin-top: 1em">rate, r <br>
Specify the frame rate of the sourced video, as the number
of frames generated per second. It has to be a string in the
format frame_rate_num/frame_rate_den, an integer <br>
number, a floating point number or a valid video frame rate
abbreviation. The default value is &quot;25&quot;.</p>

<p style="margin-top: 1em">sar Set the sample aspect ratio
of the sourced video.</p>

<p style="margin-top: 1em">duration, d <br>
Set the duration of the sourced video. See the Time duration
section in the ffmpeg-utils(1) manual for the accepted
syntax.</p>

<p style="margin-top: 1em">If not specified, or the
expressed duration is negative, the video is supposed to be
generated forever.</p>

<p style="margin-top: 1em">Additionally, all options of the
coreimage video filter are accepted. A complete filterchain
can be used for further processing of the generated input
without CPU-HOST transfer. <br>
See coreimage documentation and examples for details.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Use
CIQRCodeGenerator to create a QR code for the FFmpeg
homepage, given as complete and escaped command-line for
Apple&rsquo;s standard bash shell:</p>

<p style="margin-top: 1em">ffmpeg -f lavfi -i
coreimagesrc=s=100x100:filter=CIQRCodeGenerator@inputMessage=https\\
//FFmpeg.org/@inputCorrectionLevel=H -frames:v 1
QRCode.png</p>

<p style="margin-top: 1em">This example is equivalent to
the QRCode example of coreimage without the need for a
nullsrc video source.</p>

<p style="margin-top: 1em">mandelbrot <br>
Generate a Mandelbrot set fractal, and progressively zoom
towards the point specified with start_x and start_y.</p>

<p style="margin-top: 1em">This source accepts the
following options:</p>

<p style="margin-top: 1em">end_pts <br>
Set the terminal pts value. Default value is 400.</p>

<p style="margin-top: 1em">end_scale <br>
Set the terminal scale value. Must be a floating point
value. Default value is 0.3.</p>

<p style="margin-top: 1em">inner <br>
Set the inner coloring mode, that is the algorithm used to
draw the Mandelbrot fractal internal region.</p>

<p style="margin-top: 1em">It shall assume one of the
following values:</p>

<p style="margin-top: 1em">black <br>
Set black mode.</p>

<p style="margin-top: 1em">convergence <br>
Show time until convergence.</p>

<p style="margin-top: 1em">mincol <br>
Set color based on point closest to the origin of the
iterations.</p>

<p style="margin-top: 1em">period <br>
Set period mode.</p>

<p style="margin-top: 1em">Default value is mincol.</p>

<p style="margin-top: 1em">bailout <br>
Set the bailout value. Default value is 10.0.</p>

<p style="margin-top: 1em">maxiter <br>
Set the maximum of iterations performed by the rendering
algorithm. Default value is 7189.</p>

<p style="margin-top: 1em">outer <br>
Set outer coloring mode. It shall assume one of following
values:</p>

<p style="margin-top: 1em">iteration_count <br>
Set iteration cound mode.</p>

<p style="margin-top: 1em">normalized_iteration_count <br>
set normalized iteration count mode.</p>

<p style="margin-top: 1em">Default value is
normalized_iteration_count.</p>

<p style="margin-top: 1em">rate, r <br>
Set frame rate, expressed as number of frames per second.
Default value is &quot;25&quot;.</p>

<p style="margin-top: 1em">size, s <br>
Set frame size. For the syntax of this option, check the
&quot;Video size&quot; section in the ffmpeg-utils manual.
Default value is &quot;640x480&quot;.</p>

<p style="margin-top: 1em">start_scale <br>
Set the initial scale value. Default value is 3.0.</p>

<p style="margin-top: 1em">start_x <br>
Set the initial x position. Must be a floating point value
between -100 and 100. Default value is
-0.743643887037158704752191506114774.</p>

<p style="margin-top: 1em">start_y <br>
Set the initial y position. Must be a floating point value
between -100 and 100. Default value is
-0.131825904205311970493132056385139.</p>

<p style="margin-top: 1em">mptestsrc <br>
Generate various test patterns, as generated by the MPlayer
test filter.</p>

<p style="margin-top: 1em">The size of the generated video
is fixed, and is 256x256. This source is useful in
particular for testing encoding features.</p>

<p style="margin-top: 1em">This source accepts the
following options:</p>

<p style="margin-top: 1em">rate, r <br>
Specify the frame rate of the sourced video, as the number
of frames generated per second. It has to be a string in the
format frame_rate_num/frame_rate_den, an integer <br>
number, a floating point number or a valid video frame rate
abbreviation. The default value is &quot;25&quot;.</p>

<p style="margin-top: 1em">duration, d <br>
Set the duration of the sourced video. See the Time duration
section in the ffmpeg-utils(1) manual for the accepted
syntax.</p>

<p style="margin-top: 1em">If not specified, or the
expressed duration is negative, the video is supposed to be
generated forever.</p>

<p style="margin-top: 1em">test, t <br>
Set the number or the name of the test to perform. Supported
tests are:</p>

<p style="margin-top: 1em">dc_luma <br>
dc_chroma <br>
freq_luma <br>
freq_chroma <br>
amp_luma <br>
amp_chroma <br>
cbp <br>
mv <br>
ring1 <br>
ring2 <br>
all</p>

<p style="margin-top: 1em">Default value is
&quot;all&quot;, which will cycle through the list of all
tests.</p>

<p style="margin-top: 1em">Some examples:</p>

<p style="margin-top: 1em">mptestsrc=t=dc_luma</p>

<p style="margin-top: 1em">will generate a
&quot;dc_luma&quot; test pattern.</p>

<p style="margin-top: 1em">frei0r_src <br>
Provide a frei0r source.</p>

<p style="margin-top: 1em">To enable compilation of this
filter you need to install the frei0r header and configure
FFmpeg with &quot;--enable-frei0r&quot;.</p>

<p style="margin-top: 1em">This source accepts the
following parameters:</p>

<p style="margin-top: 1em">size <br>
The size of the video to generate. For the syntax of this
option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual.</p>

<p style="margin-top: 1em">framerate <br>
The framerate of the generated video. It may be a string of
the form num/den or a frame rate abbreviation.</p>

<p style="margin-top: 1em">filter_name <br>
The name to the frei0r source to load. For more information
regarding frei0r and how to set the parameters, read the
frei0r section in the video filters documentation.</p>

<p style="margin-top: 1em">filter_params <br>
A &rsquo;|&rsquo;-separated list of parameters to pass to
the frei0r source.</p>

<p style="margin-top: 1em">For example, to generate a
frei0r partik0l source with size 200x200 and frame rate 10
which is overlaid on the overlay filter main input:</p>


<p style="margin-top: 1em">frei0r_src=size=200x200:framerate=10:filter_name=partik0l:filter_params=1234
[overlay]; [in][overlay] overlay</p>

<p style="margin-top: 1em">life <br>
Generate a life pattern.</p>

<p style="margin-top: 1em">This source is based on a
generalization of John Conway&rsquo;s life game.</p>

<p style="margin-top: 1em">The sourced input represents a
life grid, each pixel represents a cell which can be in one
of two possible states, alive or dead. Every cell interacts
with its eight neighbours, <br>
which are the cells that are horizontally, vertically, or
diagonally adjacent.</p>

<p style="margin-top: 1em">At each interaction the grid
evolves according to the adopted rule, which specifies the
number of neighbor alive cells which will make a cell stay
alive or born. The rule option <br>
allows one to specify the rule to adopt.</p>

<p style="margin-top: 1em">This source accepts the
following options:</p>

<p style="margin-top: 1em">filename, f <br>
Set the file from which to read the initial grid state. In
the file, each non-whitespace character is considered an
alive cell, and newline is used to delimit the end of each
<br>
row.</p>

<p style="margin-top: 1em">If this option is not specified,
the initial grid is generated randomly.</p>

<p style="margin-top: 1em">rate, r <br>
Set the video rate, that is the number of frames generated
per second. Default is 25.</p>

<p style="margin-top: 1em">random_fill_ratio, ratio <br>
Set the random fill ratio for the initial random grid. It is
a floating point number value ranging from 0 to 1, defaults
to 1/PHI. It is ignored when a file is specified.</p>

<p style="margin-top: 1em">random_seed, seed <br>
Set the seed for filling the initial random grid, must be an
integer included between 0 and UINT32_MAX. If not specified,
or if explicitly set to -1, the filter will try to <br>
use a good random seed on a best effort basis.</p>

<p style="margin-top: 1em">rule <br>
Set the life rule.</p>

<p style="margin-top: 1em">A rule can be specified with a
code of the kind &quot;SNS/BNB&quot;, where NS and NB are
sequences of numbers in the range 0-8, NS specifies the
number of alive neighbor cells which <br>
make a live cell stay alive, and NB the number of alive
neighbor cells which make a dead cell to become alive (i.e.
to &quot;born&quot;). &quot;s&quot; and &quot;b&quot; can be
used in place of &quot;S&quot; and <br>
&quot;B&quot;, respectively.</p>

<p style="margin-top: 1em">Alternatively a rule can be
specified by an 18-bits integer. The 9 high order bits are
used to encode the next cell state if it is alive for each
number of neighbor alive <br>
cells, the low order bits specify the rule for
&quot;borning&quot; new cells. Higher order bits encode for
an higher number of neighbor cells. For example the number
6153 = <br>
&quot;(12&lt;&lt;9)+9&quot; specifies a stay alive rule of
12 and a born rule of 9, which corresponds to
&quot;S23/B03&quot;.</p>

<p style="margin-top: 1em">Default value is
&quot;S23/B3&quot;, which is the original Conway&rsquo;s
game of life rule, and will keep a cell alive if it has 2 or
3 neighbor alive cells, and will born a new cell if <br>
there are three alive cells around a dead cell.</p>

<p style="margin-top: 1em">size, s <br>
Set the size of the output video. For the syntax of this
option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual.</p>

<p style="margin-top: 1em">If filename is specified, the
size is set by default to the same size of the input file.
If size is set, it must contain the size specified in the
input file, and the initial <br>
grid defined in that file is centered in the larger
resulting area.</p>

<p style="margin-top: 1em">If a filename is not specified,
the size value defaults to &quot;320x240&quot; (used for a
randomly generated initial grid).</p>

<p style="margin-top: 1em">stitch <br>
If set to 1, stitch the left and right grid edges together,
and the top and bottom edges also. Defaults to 1.</p>

<p style="margin-top: 1em">mold <br>
Set cell mold speed. If set, a dead cell will go from
death_color to mold_color with a step of mold. mold can have
a value from 0 to 255.</p>

<p style="margin-top: 1em">life_color <br>
Set the color of living (or new born) cells.</p>

<p style="margin-top: 1em">death_color <br>
Set the color of dead cells. If mold is set, this is the
first color used to represent a dead cell.</p>

<p style="margin-top: 1em">mold_color <br>
Set mold color, for definitely dead and moldy cells.</p>

<p style="margin-top: 1em">For the syntax of these 3 color
options, check the &quot;Color&quot; section in the
ffmpeg-utils manual.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Read a grid from
pattern, and center it on a grid of size 300x300 pixels:</p>

<p style="margin-top: 1em">life=f=pattern:s=300x300</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate a
random grid of size 200x200, with a fill ratio of 2/3:</p>

<p style="margin-top: 1em">life=ratio=2/3:s=200x200</p>

<p style="margin-top: 1em">&Acirc;&middot; Specify a custom
rule for evolving a randomly generated grid:</p>

<p style="margin-top: 1em">life=rule=S14/B34</p>

<p style="margin-top: 1em">&Acirc;&middot; Full example
with slow death effect (mold) using ffplay:</p>

<p style="margin-top: 1em">ffplay -f lavfi
life=s=300x200:mold=10:r=60:ratio=0.1:death_color=#C83232:life_color=#00ff00,scale=1200:800:flags=16</p>

<p style="margin-top: 1em">allrgb, allyuv, color,
haldclutsrc, nullsrc, rgbtestsrc, smptebars, smptehdbars,
testsrc, testsrc2, yuvtestsrc <br>
The &quot;allrgb&quot; source returns frames of size
4096x4096 of all rgb colors.</p>

<p style="margin-top: 1em">The &quot;allyuv&quot; source
returns frames of size 4096x4096 of all yuv colors.</p>

<p style="margin-top: 1em">The &quot;color&quot; source
provides an uniformly colored input.</p>

<p style="margin-top: 1em">The &quot;haldclutsrc&quot;
source provides an identity Hald CLUT. See also haldclut
filter.</p>

<p style="margin-top: 1em">The &quot;nullsrc&quot; source
returns unprocessed video frames. It is mainly useful to be
employed in analysis / debugging tools, or as the source for
filters which ignore the input data.</p>

<p style="margin-top: 1em">The &quot;rgbtestsrc&quot;
source generates an RGB test pattern useful for detecting
RGB vs BGR issues. You should see a red, green and blue
stripe from top to bottom.</p>

<p style="margin-top: 1em">The &quot;smptebars&quot; source
generates a color bars pattern, based on the SMPTE
Engineering Guideline EG 1-1990.</p>

<p style="margin-top: 1em">The &quot;smptehdbars&quot;
source generates a color bars pattern, based on the SMPTE RP
219-2002.</p>

<p style="margin-top: 1em">The &quot;testsrc&quot; source
generates a test video pattern, showing a color pattern, a
scrolling gradient and a timestamp. This is mainly intended
for testing purposes.</p>

<p style="margin-top: 1em">The &quot;testsrc2&quot; source
is similar to testsrc, but supports more pixel formats
instead of just &quot;rgb24&quot;. This allows using it as
an input for other tests without requiring a format <br>
conversion.</p>

<p style="margin-top: 1em">The &quot;yuvtestsrc&quot;
source generates an YUV test pattern. You should see a y, cb
and cr stripe from top to bottom.</p>

<p style="margin-top: 1em">The sources accept the following
parameters:</p>

<p style="margin-top: 1em">color, c <br>
Specify the color of the source, only available in the
&quot;color&quot; source. For the syntax of this option,
check the &quot;Color&quot; section in the ffmpeg-utils
manual.</p>

<p style="margin-top: 1em">level <br>
Specify the level of the Hald CLUT, only available in the
&quot;haldclutsrc&quot; source. A level of &quot;N&quot;
generates a picture of &quot;N*N*N&quot; by
&quot;N*N*N&quot; pixels to be used as identity matrix <br>
for 3D lookup tables. Each component is coded on a
&quot;1/(N*N)&quot; scale.</p>

<p style="margin-top: 1em">size, s <br>
Specify the size of the sourced video. For the syntax of
this option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual. The default value is
&quot;320x240&quot;.</p>

<p style="margin-top: 1em">This option is not available
with the &quot;haldclutsrc&quot; filter.</p>

<p style="margin-top: 1em">rate, r <br>
Specify the frame rate of the sourced video, as the number
of frames generated per second. It has to be a string in the
format frame_rate_num/frame_rate_den, an integer <br>
number, a floating point number or a valid video frame rate
abbreviation. The default value is &quot;25&quot;.</p>

<p style="margin-top: 1em">sar Set the sample aspect ratio
of the sourced video.</p>

<p style="margin-top: 1em">duration, d <br>
Set the duration of the sourced video. See the Time duration
section in the ffmpeg-utils(1) manual for the accepted
syntax.</p>

<p style="margin-top: 1em">If not specified, or the
expressed duration is negative, the video is supposed to be
generated forever.</p>

<p style="margin-top: 1em">decimals, n <br>
Set the number of decimals to show in the timestamp, only
available in the &quot;testsrc&quot; source.</p>

<p style="margin-top: 1em">The displayed timestamp value
will correspond to the original timestamp value multiplied
by the power of 10 of the specified value. Default value is
0.</p>

<p style="margin-top: 1em">For example the following:</p>


<p style="margin-top: 1em">testsrc=duration=5.3:size=qcif:rate=10</p>

<p style="margin-top: 1em">will generate a video with a
duration of 5.3 seconds, with size 176x144 and a frame rate
of 10 frames per second.</p>

<p style="margin-top: 1em">The following graph description
will generate a red source with an opacity of 0.2, with size
&quot;qcif&quot; and a frame rate of 10 frames per
second.</p>

<p style="margin-top: 1em">color=c=red@0.2:s=qcif:r=10</p>

<p style="margin-top: 1em">If the input content is to be
ignored, &quot;nullsrc&quot; can be used. The following
command generates noise in the luminance plane by employing
the &quot;geq&quot; filter:</p>

<p style="margin-top: 1em">nullsrc=s=256x256,
geq=random(1)*255:128:128</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">The &quot;color&quot; source
supports the following commands:</p>

<p style="margin-top: 1em">c, color <br>
Set the color of the created image. Accepts the same syntax
of the corresponding color option.</p>

<p style="margin-top: 1em">VIDEO SINKS <br>
Below is a description of the currently available video
sinks.</p>

<p style="margin-top: 1em">buffersink <br>
Buffer video frames, and make them available to the end of
the filter graph.</p>

<p style="margin-top: 1em">This sink is mainly intended for
programmatic use, in particular through the interface
defined in libavfilter/buffersink.h or the options
system.</p>

<p style="margin-top: 1em">It accepts a pointer to an
AVBufferSinkContext structure, which defines the incoming
buffers&rsquo; formats, to be passed as the opaque parameter
to &quot;avfilter_init_filter&quot; for <br>
initialization.</p>

<p style="margin-top: 1em">nullsink <br>
Null video sink: do absolutely nothing with the input video.
It is mainly useful as a template and for use in analysis /
debugging tools.</p>

<p style="margin-top: 1em">MULTIMEDIA FILTERS <br>
Below is a description of the currently available multimedia
filters.</p>

<p style="margin-top: 1em">ahistogram <br>
Convert input audio to a video output, displaying the volume
histogram.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">dmode <br>
Specify how histogram is calculated.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">single <br>
Use single histogram for all channels.</p>

<p style="margin-top: 1em">separate <br>
Use separate histogram for each channel.</p>

<p style="margin-top: 1em">Default is
&quot;single&quot;.</p>

<p style="margin-top: 1em">rate, r <br>
Set frame rate, expressed as number of frames per second.
Default value is &quot;25&quot;.</p>

<p style="margin-top: 1em">size, s <br>
Specify the video size for the output. For the syntax of
this option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual. Default value is &quot;hd720&quot;.</p>

<p style="margin-top: 1em">scale <br>
Set display scale.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">log logarithmic</p>

<p style="margin-top: 1em">sqrt <br>
square root</p>

<p style="margin-top: 1em">cbrt <br>
cubic root</p>

<p style="margin-top: 1em">lin linear</p>

<p style="margin-top: 1em">rlog <br>
reverse logarithmic</p>

<p style="margin-top: 1em">Default is &quot;log&quot;.</p>

<p style="margin-top: 1em">ascale <br>
Set amplitude scale.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">log logarithmic</p>

<p style="margin-top: 1em">lin linear</p>

<p style="margin-top: 1em">Default is &quot;log&quot;.</p>

<p style="margin-top: 1em">acount <br>
Set how much frames to accumulate in histogram. Defauls is
1. Setting this to -1 accumulates all frames.</p>

<p style="margin-top: 1em">rheight <br>
Set histogram ratio of window height.</p>

<p style="margin-top: 1em">slide <br>
Set sonogram sliding.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">replace <br>
replace old rows with new ones.</p>

<p style="margin-top: 1em">scroll <br>
scroll from top to bottom.</p>

<p style="margin-top: 1em">Default is
&quot;replace&quot;.</p>

<p style="margin-top: 1em">aphasemeter <br>
Convert input audio to a video output, displaying the audio
phase.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">rate, r <br>
Set the output frame rate. Default value is 25.</p>

<p style="margin-top: 1em">size, s <br>
Set the video size for the output. For the syntax of this
option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual. Default value is
&quot;800x400&quot;.</p>

<p style="margin-top: 1em">rc <br>
gc <br>
bc Specify the red, green, blue contrast. Default values are
2, 7 and 1. Allowed range is &quot;[0, 255]&quot;.</p>

<p style="margin-top: 1em">mpc Set color which will be used
for drawing median phase. If color is &quot;none&quot; which
is default, no median phase value will be drawn.</p>

<p style="margin-top: 1em">The filter also exports the
frame metadata &quot;lavfi.aphasemeter.phase&quot; which
represents mean phase of current audio frame. Value is in
range &quot;[-1, 1]&quot;. The &quot;-1&quot; means left and
<br>
right channels are completely out of phase and 1 means
channels are in phase.</p>

<p style="margin-top: 1em">avectorscope <br>
Convert input audio to a video output, representing the
audio vector scope.</p>

<p style="margin-top: 1em">The filter is used to measure
the difference between channels of stereo audio stream. A
monoaural signal, consisting of identical left and right
signal, results in straight <br>
vertical line. Any stereo separation is visible as a
deviation from this line, creating a Lissajous figure. If
the straight (or deviation from it) but horizontal line
appears <br>
this indicates that the left and right channels are out of
phase.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">mode, m <br>
Set the vectorscope mode.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">lissajous <br>
Lissajous rotated by 45 degrees.</p>

<p style="margin-top: 1em">lissajous_xy <br>
Same as above but not rotated.</p>

<p style="margin-top: 1em">polar <br>
Shape resembling half of circle.</p>

<p style="margin-top: 1em">Default value is lissajous.</p>

<p style="margin-top: 1em">size, s <br>
Set the video size for the output. For the syntax of this
option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual. Default value is
&quot;400x400&quot;.</p>

<p style="margin-top: 1em">rate, r <br>
Set the output frame rate. Default value is 25.</p>

<p style="margin-top: 1em">rc <br>
gc <br>
bc <br>
ac Specify the red, green, blue and alpha contrast. Default
values are 40, 160, 80 and 255. Allowed range is &quot;[0,
255]&quot;.</p>

<p style="margin-top: 1em">rf <br>
gf <br>
bf <br>
af Specify the red, green, blue and alpha fade. Default
values are 15, 10, 5 and 5. Allowed range is &quot;[0,
255]&quot;.</p>

<p style="margin-top: 1em">zoom <br>
Set the zoom factor. Default value is 1. Allowed range is
&quot;[1, 10]&quot;.</p>

<p style="margin-top: 1em">draw <br>
Set the vectorscope drawing mode.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">dot Draw dot for each
sample.</p>

<p style="margin-top: 1em">line <br>
Draw line between previous and current sample.</p>

<p style="margin-top: 1em">Default value is dot.</p>

<p style="margin-top: 1em">scale <br>
Specify amplitude scale of audio samples.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">lin Linear.</p>

<p style="margin-top: 1em">sqrt <br>
Square root.</p>

<p style="margin-top: 1em">cbrt <br>
Cubic root.</p>

<p style="margin-top: 1em">log Logarithmic.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Complete example
using ffplay:</p>

<p style="margin-top: 1em">ffplay -f lavfi
&rsquo;amovie=input.mp3, asplit [a][out1]; <br>
[a] avectorscope=zoom=1.3:rc=2:gc=200:bc=10:rf=1:gf=8:bf=7
[out0]&rsquo;</p>

<p style="margin-top: 1em">bench, abench <br>
Benchmark part of a filtergraph.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">action <br>
Start or stop a timer.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">start <br>
Get the current time, set it as frame metadata (using the
key &quot;lavfi.bench.start_time&quot;), and forward the
frame to the next filter.</p>

<p style="margin-top: 1em">stop <br>
Get the current time and fetch the
&quot;lavfi.bench.start_time&quot; metadata from the input
frame metadata to get the time difference. Time difference,
average, maximum and <br>
minimum time (respectively &quot;t&quot;, &quot;avg&quot;,
&quot;max&quot; and &quot;min&quot;) are then printed. The
timestamps are expressed in seconds.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Benchmark
selectivecolor filter:</p>


<p style="margin-top: 1em">bench=start,selectivecolor=reds=-.2
.12 -.49,bench=stop</p>

<p style="margin-top: 1em">concat <br>
Concatenate audio and video streams, joining them together
one after the other.</p>

<p style="margin-top: 1em">The filter works on segments of
synchronized video and audio streams. All segments must have
the same number of streams of each type, and that will also
be the number of streams <br>
at output.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">n Set the number of segments.
Default is 2.</p>

<p style="margin-top: 1em">v Set the number of output video
streams, that is also the number of video streams in each
segment. Default is 1.</p>

<p style="margin-top: 1em">a Set the number of output audio
streams, that is also the number of audio streams in each
segment. Default is 0.</p>

<p style="margin-top: 1em">unsafe <br>
Activate unsafe mode: do not fail if segments have a
different format.</p>

<p style="margin-top: 1em">The filter has v+a outputs:
first v video outputs, then a audio outputs.</p>

<p style="margin-top: 1em">There are nx(v+a) inputs: first
the inputs for the first segment, in the same order as the
outputs, then the inputs for the second segment, etc.</p>

<p style="margin-top: 1em">Related streams do not always
have exactly the same duration, for various reasons
including codec frame size or sloppy authoring. For that
reason, related synchronized streams <br>
(e.g. a video and its audio track) should be concatenated at
once. The concat filter will use the duration of the longest
stream in each segment (except the last one), and if <br>
necessary pad shorter audio streams with silence.</p>

<p style="margin-top: 1em">For this filter to work
correctly, all segments must start at timestamp 0.</p>

<p style="margin-top: 1em">All corresponding streams must
have the same parameters in all segments; the filtering
system will automatically select a common pixel format for
video streams, and a common <br>
sample format, sample rate and channel layout for audio
streams, but other settings, such as resolution, must be
converted explicitly by the user.</p>

<p style="margin-top: 1em">Different frame rates are
acceptable but will result in variable frame rate at output;
be sure to configure the output file to handle it.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Concatenate an
opening, an episode and an ending, all in bilingual version
(video in stream 0, audio in streams 1 and 2):</p>

<p style="margin-top: 1em">ffmpeg -i opening.mkv -i
episode.mkv -i ending.mkv -filter_complex &rsquo;[0:0] [0:1]
[0:2] [1:0] [1:1] [1:2] [2:0] [2:1] [2:2] <br>
concat=n=3:v=1:a=2 [v] [a1] [a2]&rsquo; -map
&rsquo;[v]&rsquo; -map &rsquo;[a1]&rsquo; -map
&rsquo;[a2]&rsquo; output.mkv</p>

<p style="margin-top: 1em">&Acirc;&middot; Concatenate two
parts, handling audio and video separately, using the
(a)movie sources, and adjusting the resolution:</p>

<p style="margin-top: 1em">movie=part1.mp4, scale=512:288
[v1] ; amovie=part1.mp4 [a1] ; <br>
movie=part2.mp4, scale=512:288 [v2] ; amovie=part2.mp4 [a2]
; <br>
[v1] [v2] concat [outv] ; [a1] [a2] concat=v=0:a=1
[outa]</p>

<p style="margin-top: 1em">Note that a desync will happen
at the stitch if the audio and video streams do not have
exactly the same duration in the first file.</p>

<p style="margin-top: 1em">drawgraph, adrawgraph <br>
Draw a graph using input video or audio metadata.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">m1 Set 1st frame metadata key
from which metadata values will be used to draw a graph.</p>

<p style="margin-top: 1em">fg1 Set 1st foreground color
expression.</p>

<p style="margin-top: 1em">m2 Set 2nd frame metadata key
from which metadata values will be used to draw a graph.</p>

<p style="margin-top: 1em">fg2 Set 2nd foreground color
expression.</p>

<p style="margin-top: 1em">m3 Set 3rd frame metadata key
from which metadata values will be used to draw a graph.</p>

<p style="margin-top: 1em">fg3 Set 3rd foreground color
expression.</p>

<p style="margin-top: 1em">m4 Set 4th frame metadata key
from which metadata values will be used to draw a graph.</p>

<p style="margin-top: 1em">fg4 Set 4th foreground color
expression.</p>

<p style="margin-top: 1em">min Set minimal value of
metadata value.</p>

<p style="margin-top: 1em">max Set maximal value of
metadata value.</p>

<p style="margin-top: 1em">bg Set graph background color.
Default is white.</p>

<p style="margin-top: 1em">mode <br>
Set graph mode.</p>

<p style="margin-top: 1em">Available values for mode
is:</p>

<p style="margin-top: 1em">bar <br>
dot <br>
line</p>

<p style="margin-top: 1em">Default is &quot;line&quot;.</p>

<p style="margin-top: 1em">slide <br>
Set slide mode.</p>

<p style="margin-top: 1em">Available values for slide
is:</p>

<p style="margin-top: 1em">frame <br>
Draw new frame when right border is reached.</p>

<p style="margin-top: 1em">replace <br>
Replace old columns with new ones.</p>

<p style="margin-top: 1em">scroll <br>
Scroll from right to left.</p>

<p style="margin-top: 1em">rscroll <br>
Scroll from left to right.</p>

<p style="margin-top: 1em">picture <br>
Draw single picture.</p>

<p style="margin-top: 1em">Default is
&quot;frame&quot;.</p>

<p style="margin-top: 1em">size <br>
Set size of graph video. For the syntax of this option,
check the &quot;Video size&quot; section in the ffmpeg-utils
manual. The default value is &quot;900x256&quot;.</p>

<p style="margin-top: 1em">The foreground color expressions
can use the following variables:</p>

<p style="margin-top: 1em">MIN Minimal value of metadata
value.</p>

<p style="margin-top: 1em">MAX Maximal value of metadata
value.</p>

<p style="margin-top: 1em">VAL Current metadata key
value.</p>

<p style="margin-top: 1em">The color is defined as
0xAABBGGRR.</p>

<p style="margin-top: 1em">Example using metadata from
signalstats filter:</p>


<p style="margin-top: 1em">signalstats,drawgraph=lavfi.signalstats.YAVG:min=0:max=255</p>

<p style="margin-top: 1em">Example using metadata from
ebur128 filter:</p>


<p style="margin-top: 1em">ebur128=metadata=1,adrawgraph=lavfi.r128.M:min=-120:max=5</p>

<p style="margin-top: 1em">ebur128 <br>
EBU R128 scanner filter. This filter takes an audio stream
as input and outputs it unchanged. By default, it logs a
message at a frequency of 10Hz with the Momentary loudness
<br>
(identified by &quot;M&quot;), Short-term loudness
(&quot;S&quot;), Integrated loudness (&quot;I&quot;) and
Loudness Range (&quot;LRA&quot;).</p>

<p style="margin-top: 1em">The filter also has a video
output (see the video option) with a real time graph to
observe the loudness evolution. The graphic contains the
logged message mentioned above, so it <br>
is not printed anymore when this option is set, unless the
verbose logging is set. The main graphing area contains the
short-term loudness (3 seconds of analysis), and the gauge
<br>
on the right is for the momentary loudness (400
milliseconds).</p>

<p style="margin-top: 1em">More information about the
Loudness Recommendation EBU R128 on
&lt;http://tech.ebu.ch/loudness&gt;.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">video <br>
Activate the video output. The audio stream is passed
unchanged whether this option is set or no. The video stream
will be the first output stream if activated. Default is
0.</p>

<p style="margin-top: 1em">size <br>
Set the video size. This option is for video only. For the
syntax of this option, check the &quot;Video size&quot;
section in the ffmpeg-utils manual. Default and minimum
resolution <br>
is &quot;640x480&quot;.</p>

<p style="margin-top: 1em">meter <br>
Set the EBU scale meter. Default is 9. Common values are 9
and 18, respectively for EBU scale meter +9 and EBU scale
meter +18. Any other integer value between this range is
<br>
allowed.</p>

<p style="margin-top: 1em">metadata <br>
Set metadata injection. If set to 1, the audio input will be
segmented into 100ms output frames, each of them containing
various loudness information in metadata. All the <br>
metadata keys are prefixed with &quot;lavfi.r128.&quot;.</p>

<p style="margin-top: 1em">Default is 0.</p>

<p style="margin-top: 1em">framelog <br>
Force the frame logging level.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">info <br>
information logging level</p>

<p style="margin-top: 1em">verbose <br>
verbose logging level</p>

<p style="margin-top: 1em">By default, the logging level is
set to info. If the video or the metadata options are set,
it switches to verbose.</p>

<p style="margin-top: 1em">peak <br>
Set peak mode(s).</p>

<p style="margin-top: 1em">Available modes can be cumulated
(the option is a &quot;flag&quot; type). Possible values
are:</p>

<p style="margin-top: 1em">none <br>
Disable any peak mode (default).</p>

<p style="margin-top: 1em">sample <br>
Enable sample-peak mode.</p>

<p style="margin-top: 1em">Simple peak mode looking for the
higher sample value. It logs a message for sample-peak
(identified by &quot;SPK&quot;).</p>

<p style="margin-top: 1em">true <br>
Enable true-peak mode.</p>

<p style="margin-top: 1em">If enabled, the peak lookup is
done on an over-sampled version of the input stream for
better peak accuracy. It logs a message for true-peak.
(identified by &quot;TPK&quot;) and <br>
true-peak per frame (identified by &quot;FTPK&quot;). This
mode requires a build with &quot;libswresample&quot;.</p>

<p style="margin-top: 1em">dualmono <br>
Treat mono input files as &quot;dual mono&quot;. If a mono
file is intended for playback on a stereo system, its EBU
R128 measurement will be perceptually incorrect. If set to
&quot;true&quot;, <br>
this option will compensate for this effect. Multi-channel
input files are not affected by this option.</p>

<p style="margin-top: 1em">panlaw <br>
Set a specific pan law to be used for the measurement of
dual mono files. This parameter is optional, and has a
default value of -3.01dB.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Real-time graph
using ffplay, with a EBU scale meter +18:</p>

<p style="margin-top: 1em">ffplay -f lavfi -i
&quot;amovie=input.mp3,ebur128=video=1:meter=18
[out0][out1]&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Run an analysis
with ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -nostats -i input.mp3
-filter_complex ebur128 -f null -</p>

<p style="margin-top: 1em">interleave, ainterleave <br>
Temporally interleave frames from several inputs.</p>

<p style="margin-top: 1em">&quot;interleave&quot; works
with video inputs, &quot;ainterleave&quot; with audio.</p>

<p style="margin-top: 1em">These filters read frames from
several inputs and send the oldest queued frame to the
output.</p>

<p style="margin-top: 1em">Input streams must have well
defined, monotonically increasing frame timestamp
values.</p>

<p style="margin-top: 1em">In order to submit one frame to
output, these filters need to enqueue at least one frame for
each input, so they cannot work in case one input is not yet
terminated and will not <br>
receive incoming frames.</p>

<p style="margin-top: 1em">For example consider the case
when one input is a &quot;select&quot; filter which always
drops input frames. The &quot;interleave&quot; filter will
keep reading from that input, but it will never be <br>
able to send new frames to output until the input sends an
end-of-stream signal.</p>

<p style="margin-top: 1em">Also, depending on inputs
synchronization, the filters will drop frames in case one
input receives more frames than the other ones, and the
queue is already filled.</p>

<p style="margin-top: 1em">These filters accept the
following options:</p>

<p style="margin-top: 1em">nb_inputs, n <br>
Set the number of different inputs, it is 2 by default.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Interleave
frames belonging to different streams using ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i bambi.avi -i pr0n.mkv
-filter_complex &quot;[0:v][1:v] interleave&quot;
out.avi</p>

<p style="margin-top: 1em">&Acirc;&middot; Add flickering
blur effect:</p>

<p style="margin-top: 1em">select=&rsquo;if(gt(random(0),
0.2), 1, 2)&rsquo;:n=2 [tmp], boxblur=2:2, [tmp]
interleave</p>

<p style="margin-top: 1em">metadata, ametadata <br>
Manipulate frame metadata.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">mode <br>
Set mode of operation of the filter.</p>

<p style="margin-top: 1em">Can be one of the following:</p>

<p style="margin-top: 1em">select <br>
If both &quot;value&quot; and &quot;key&quot; is set, select
frames which have such metadata. If only &quot;key&quot; is
set, select every frame that has such key in metadata.</p>

<p style="margin-top: 1em">add Add new metadata
&quot;key&quot; and &quot;value&quot;. If key is already
available do nothing.</p>

<p style="margin-top: 1em">modify <br>
Modify value of already present key.</p>

<p style="margin-top: 1em">delete <br>
If &quot;value&quot; is set, delete only keys that have such
value. Otherwise, delete key. If &quot;key&quot; is not set,
delete all metadata values in the frame.</p>

<p style="margin-top: 1em">print <br>
Print key and its value if metadata was found. If
&quot;key&quot; is not set print all metadata values
available in frame.</p>

<p style="margin-top: 1em">key Set key used with all modes.
Must be set for all modes except &quot;print&quot; and
&quot;delete&quot;.</p>

<p style="margin-top: 1em">value <br>
Set metadata value which will be used. This option is
mandatory for &quot;modify&quot; and &quot;add&quot;
mode.</p>

<p style="margin-top: 1em">function <br>
Which function to use when comparing metadata value and
&quot;value&quot;.</p>

<p style="margin-top: 1em">Can be one of following:</p>

<p style="margin-top: 1em">same_str <br>
Values are interpreted as strings, returns true if metadata
value is same as &quot;value&quot;.</p>

<p style="margin-top: 1em">starts_with <br>
Values are interpreted as strings, returns true if metadata
value starts with the &quot;value&quot; option string.</p>

<p style="margin-top: 1em">less <br>
Values are interpreted as floats, returns true if metadata
value is less than &quot;value&quot;.</p>

<p style="margin-top: 1em">equal <br>
Values are interpreted as floats, returns true if
&quot;value&quot; is equal with metadata value.</p>

<p style="margin-top: 1em">greater <br>
Values are interpreted as floats, returns true if metadata
value is greater than &quot;value&quot;.</p>

<p style="margin-top: 1em">expr <br>
Values are interpreted as floats, returns true if expression
from option &quot;expr&quot; evaluates to true.</p>

<p style="margin-top: 1em">expr <br>
Set expression which is used when &quot;function&quot; is
set to &quot;expr&quot;. The expression is evaluated through
the eval API and can contain the following constants:</p>

<p style="margin-top: 1em">VALUE1 <br>
Float representation of &quot;value&quot; from metadata
key.</p>

<p style="margin-top: 1em">VALUE2 <br>
Float representation of &quot;value&quot; as supplied by
user in &quot;value&quot; option.</p>

<p style="margin-top: 1em">file <br>
If specified in &quot;print&quot; mode, output is written to
the named file. Instead of plain filename any writable url
can be specified. Filename &lsquo;&lsquo;-&rsquo;&rsquo; is
a shorthand for standard <br>
output. If &quot;file&quot; option is not set, output is
written to the log with AV_LOG_INFO loglevel.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Print all
metadata values for frames with key
&quot;lavfi.singnalstats.YDIF&quot; with values between 0
and 1.</p>


<p style="margin-top: 1em">signalstats,metadata=print:key=lavfi.signalstats.YDIF:value=0:function=expr:expr=&rsquo;between(VALUE1,0,1)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Print
silencedetect output to file metadata.txt.</p>


<p style="margin-top: 1em">silencedetect,ametadata=mode=print:file=metadata.txt</p>

<p style="margin-top: 1em">&Acirc;&middot; Direct all
metadata to a pipe with file descriptor 4.</p>


<p style="margin-top: 1em">metadata=mode=print:file=&rsquo;pipe4&rsquo;</p>

<p style="margin-top: 1em">perms, aperms <br>
Set read/write permissions for the output frames.</p>

<p style="margin-top: 1em">These filters are mainly aimed
at developers to test direct path in the following filter in
the filtergraph.</p>

<p style="margin-top: 1em">The filters accept the following
options:</p>

<p style="margin-top: 1em">mode <br>
Select the permissions mode.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">none <br>
Do nothing. This is the default.</p>

<p style="margin-top: 1em">ro Set all the output frames
read-only.</p>

<p style="margin-top: 1em">rw Set all the output frames
directly writable.</p>

<p style="margin-top: 1em">toggle <br>
Make the frame read-only if writable, and writable if
read-only.</p>

<p style="margin-top: 1em">random <br>
Set each output frame read-only or writable randomly.</p>

<p style="margin-top: 1em">seed <br>
Set the seed for the random mode, must be an integer
included between 0 and &quot;UINT32_MAX&quot;. If not
specified, or if explicitly set to &quot;-1&quot;, the
filter will try to use a good <br>
random seed on a best effort basis.</p>

<p style="margin-top: 1em">Note: in case of auto-inserted
filter between the permission filter and the following one,
the permission might not be received as expected in that
following filter. Inserting a <br>
format or aformat filter before the perms/aperms filter can
avoid this problem.</p>

<p style="margin-top: 1em">realtime, arealtime <br>
Slow down filtering to match real time approximatively.</p>

<p style="margin-top: 1em">These filters will pause the
filtering for a variable amount of time to match the output
rate with the input timestamps. They are similar to the re
option to &quot;ffmpeg&quot;.</p>

<p style="margin-top: 1em">They accept the following
options:</p>

<p style="margin-top: 1em">limit <br>
Time limit for the pauses. Any pause longer than that will
be considered a timestamp discontinuity and reset the timer.
Default is 2 seconds.</p>

<p style="margin-top: 1em">select, aselect <br>
Select frames to pass in output.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">expr, e <br>
Set expression, which is evaluated for each input frame.</p>

<p style="margin-top: 1em">If the expression is evaluated
to zero, the frame is discarded.</p>

<p style="margin-top: 1em">If the evaluation result is
negative or NaN, the frame is sent to the first output;
otherwise it is sent to the output with index
&quot;ceil(val)-1&quot;, assuming that the input index <br>
starts from 0.</p>

<p style="margin-top: 1em">For example a value of 1.2
corresponds to the output with index &quot;ceil(1.2)-1 = 2-1
= 1&quot;, that is the second output.</p>

<p style="margin-top: 1em">outputs, n <br>
Set the number of outputs. The output to which to send the
selected frame is based on the result of the evaluation.
Default value is 1.</p>

<p style="margin-top: 1em">The expression can contain the
following constants:</p>

<p style="margin-top: 1em">n The (sequential) number of the
filtered frame, starting from 0.</p>

<p style="margin-top: 1em">selected_n <br>
The (sequential) number of the selected frame, starting from
0.</p>

<p style="margin-top: 1em">prev_selected_n <br>
The sequential number of the last selected frame. It&rsquo;s
NAN if undefined.</p>

<p style="margin-top: 1em">TB The timebase of the input
timestamps.</p>

<p style="margin-top: 1em">pts The PTS (Presentation
TimeStamp) of the filtered video frame, expressed in TB
units. It&rsquo;s NAN if undefined.</p>

<p style="margin-top: 1em">t The PTS of the filtered video
frame, expressed in seconds. It&rsquo;s NAN if
undefined.</p>

<p style="margin-top: 1em">prev_pts <br>
The PTS of the previously filtered video frame. It&rsquo;s
NAN if undefined.</p>

<p style="margin-top: 1em">prev_selected_pts <br>
The PTS of the last previously filtered video frame.
It&rsquo;s NAN if undefined.</p>

<p style="margin-top: 1em">prev_selected_t <br>
The PTS of the last previously selected video frame.
It&rsquo;s NAN if undefined.</p>

<p style="margin-top: 1em">start_pts <br>
The PTS of the first video frame in the video. It&rsquo;s
NAN if undefined.</p>

<p style="margin-top: 1em">start_t <br>
The time of the first video frame in the video. It&rsquo;s
NAN if undefined.</p>

<p style="margin-top: 1em">pict_type (video only) <br>
The type of the filtered frame. It can assume one of the
following values:</p>

<p style="margin-top: 1em">I <br>
P <br>
B <br>
S <br>
SI <br>
SP <br>
BI <br>
interlace_type (video only) <br>
The frame interlace type. It can assume one of the following
values:</p>

<p style="margin-top: 1em">PROGRESSIVE <br>
The frame is progressive (not interlaced).</p>

<p style="margin-top: 1em">TOPFIRST <br>
The frame is top-field-first.</p>

<p style="margin-top: 1em">BOTTOMFIRST <br>
The frame is bottom-field-first.</p>

<p style="margin-top: 1em">consumed_sample_n (audio only)
<br>
the number of selected samples before the current frame</p>

<p style="margin-top: 1em">samples_n (audio only) <br>
the number of samples in the current frame</p>

<p style="margin-top: 1em">sample_rate (audio only) <br>
the input sample rate</p>

<p style="margin-top: 1em">key This is 1 if the filtered
frame is a key-frame, 0 otherwise.</p>

<p style="margin-top: 1em">pos the position in the file of
the filtered frame, -1 if the information is not available
(e.g. for synthetic video)</p>

<p style="margin-top: 1em">scene (video only) <br>
value between 0 and 1 to indicate a new scene; a low value
reflects a low probability for the current frame to
introduce a new scene, while a higher value means the
current <br>
frame is more likely to be one (see the example below)</p>

<p style="margin-top: 1em">concatdec_select <br>
The concat demuxer can select only part of a concat input
file by setting an inpoint and an outpoint, but the output
packets may not be entirely contained in the selected <br>
interval. By using this variable, it is possible to skip
frames generated by the concat demuxer which are not exactly
contained in the selected interval.</p>

<p style="margin-top: 1em">This works by comparing the
frame pts against the lavf.concat.start_time and the
lavf.concat.duration packet metadata values which are also
present in the decoded frames.</p>

<p style="margin-top: 1em">The concatdec_select variable is
-1 if the frame pts is at least start_time and either the
duration metadata is missing or the frame pts is less than
start_time + duration, 0 <br>
otherwise, and NaN if the start_time metadata is
missing.</p>

<p style="margin-top: 1em">That basically means that an
input frame is selected if its pts is within the interval
set by the concat demuxer.</p>

<p style="margin-top: 1em">The default value of the select
expression is &quot;1&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Select all
frames in input:</p>

<p style="margin-top: 1em">select</p>

<p style="margin-top: 1em">The example above is the same
as:</p>

<p style="margin-top: 1em">select=1</p>

<p style="margin-top: 1em">&Acirc;&middot; Skip all
frames:</p>

<p style="margin-top: 1em">select=0</p>

<p style="margin-top: 1em">&Acirc;&middot; Select only
I-frames:</p>


<p style="margin-top: 1em">select=&rsquo;eq(pict_typeI)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Select one frame
every 100:</p>


<p style="margin-top: 1em">select=&rsquo;not(mod(n100))&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Select only
frames contained in the 10-20 time interval:</p>

<p style="margin-top: 1em">select=between(t1020)</p>

<p style="margin-top: 1em">&Acirc;&middot; Select only
I-frames contained in the 10-20 time interval:</p>


<p style="margin-top: 1em">select=between(t1020)*eq(pict_typeI)</p>

<p style="margin-top: 1em">&Acirc;&middot; Select frames
with a minimum distance of 10 seconds:</p>


<p style="margin-top: 1em">select=&rsquo;isnan(prev_selected_t)+gte(t-prev_selected_t10)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Use aselect to
select only audio frames with samples number &gt; 100:</p>


<p style="margin-top: 1em">aselect=&rsquo;gt(samples_n100)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Create a mosaic
of the first scenes:</p>

<p style="margin-top: 1em">ffmpeg -i video.avi -vf
select=&rsquo;gt(scene0.4)&rsquo;,scale=160:120,tile
-frames:v 1 preview.png</p>

<p style="margin-top: 1em">Comparing scene against a value
between 0.3 and 0.5 is generally a sane choice.</p>

<p style="margin-top: 1em">&Acirc;&middot; Send even and
odd frames to separate outputs, and compose them:</p>

<p style="margin-top: 1em">select=n=2:e=&rsquo;mod(n,
2)+1&rsquo; [odd][even]; [odd] pad=h=2*ih [tmp]; [tmp][even]
overlay=y=h</p>

<p style="margin-top: 1em">&Acirc;&middot; Select useful
frames from an ffconcat file which is using inpoints and
outpoints but where the source files are not intra frame
only.</p>

<p style="margin-top: 1em">ffmpeg -copyts -vsync 0
-segment_time_metadata 1 -i input.ffconcat -vf
select=concatdec_select -af aselect=concatdec_select
output.avi</p>

<p style="margin-top: 1em">sendcmd, asendcmd <br>
Send commands to filters in the filtergraph.</p>

<p style="margin-top: 1em">These filters read commands to
be sent to other filters in the filtergraph.</p>

<p style="margin-top: 1em">&quot;sendcmd&quot; must be
inserted between two video filters, &quot;asendcmd&quot;
must be inserted between two audio filters, but apart from
that they act the same way.</p>

<p style="margin-top: 1em">The specification of commands
can be provided in the filter arguments with the commands
option, or in a file specified by the filename option.</p>

<p style="margin-top: 1em">These filters accept the
following options:</p>

<p style="margin-top: 1em">commands, c <br>
Set the commands to be read and sent to the other
filters.</p>

<p style="margin-top: 1em">filename, f <br>
Set the filename of the commands to be read and sent to the
other filters.</p>

<p style="margin-top: 1em">Commands syntax</p>

<p style="margin-top: 1em">A commands description consists
of a sequence of interval specifications, comprising a list
of commands to be executed when a particular event related
to that interval occurs. <br>
The occurring event is typically the current frame time
entering or leaving a given time interval.</p>

<p style="margin-top: 1em">An interval is specified by the
following syntax:</p>

<p style="margin-top: 1em">&lt;START&gt;[-&lt;END&gt;]
&lt;COMMANDS&gt;;</p>

<p style="margin-top: 1em">The time interval is specified
by the START and END times. END is optional and defaults to
the maximum time.</p>

<p style="margin-top: 1em">The current frame time is
considered within the specified interval if it is included
in the interval [START, END), that is when the time is
greater or equal to START and is <br>
lesser than END.</p>

<p style="margin-top: 1em">COMMANDS consists of a sequence
of one or more command specifications, separated by
&quot;,&quot;, relating to that interval. The syntax of a
command specification is given by:</p>

<p style="margin-top: 1em">[&lt;FLAGS&gt;] &lt;TARGET&gt;
&lt;COMMAND&gt; &lt;ARG&gt;</p>

<p style="margin-top: 1em">FLAGS is optional and specifies
the type of events relating to the time interval which
enable sending the specified command, and must be a non-null
sequence of identifier flags <br>
separated by &quot;+&quot; or &quot;|&quot; and enclosed
between &quot;[&quot; and &quot;]&quot;.</p>

<p style="margin-top: 1em">The following flags are
recognized:</p>

<p style="margin-top: 1em">enter <br>
The command is sent when the current frame timestamp enters
the specified interval. In other words, the command is sent
when the previous frame timestamp was not in the given <br>
interval, and the current is.</p>

<p style="margin-top: 1em">leave <br>
The command is sent when the current frame timestamp leaves
the specified interval. In other words, the command is sent
when the previous frame timestamp was in the given <br>
interval, and the current is not.</p>

<p style="margin-top: 1em">If FLAGS is not specified, a
default value of &quot;[enter]&quot; is assumed.</p>

<p style="margin-top: 1em">TARGET specifies the target of
the command, usually the name of the filter class or a
specific filter instance name.</p>

<p style="margin-top: 1em">COMMAND specifies the name of
the command for the target filter.</p>

<p style="margin-top: 1em">ARG is optional and specifies
the optional list of argument for the given COMMAND.</p>

<p style="margin-top: 1em">Between one interval
specification and another, whitespaces, or sequences of
characters starting with &quot;#&quot; until the end of
line, are ignored and can be used to annotate comments.</p>

<p style="margin-top: 1em">A simplified BNF description of
the commands specification syntax follows:</p>

<p style="margin-top: 1em">&lt;COMMAND_FLAG&gt; ::=
&quot;enter&quot; | &quot;leave&quot; <br>
&lt;COMMAND_FLAGS&gt; ::= &lt;COMMAND_FLAG&gt;
[(+|&quot;|&quot;)&lt;COMMAND_FLAG&gt;] <br>
&lt;COMMAND&gt; ::= [&quot;[&quot; &lt;COMMAND_FLAGS&gt;
&quot;]&quot;] &lt;TARGET&gt; &lt;COMMAND&gt; [&lt;ARG&gt;]
<br>
&lt;COMMANDS&gt; ::= &lt;COMMAND&gt; [,&lt;COMMANDS&gt;]
<br>
&lt;INTERVAL&gt; ::= &lt;START&gt;[-&lt;END&gt;]
&lt;COMMANDS&gt; <br>
&lt;INTERVALS&gt; ::=
&lt;INTERVAL&gt;[;&lt;INTERVALS&gt;]</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Specify audio
tempo change at second 4:</p>

<p style="margin-top: 1em">asendcmd=c=&rsquo;4.0 atempo
tempo 1.5&rsquo;,atempo</p>

<p style="margin-top: 1em">&Acirc;&middot; Specify a list
of drawtext and hue commands in a file.</p>

<p style="margin-top: 1em"># show text in the interval 5-10
<br>
5.0-10.0 [enter] drawtext reinit
&rsquo;fontfile=FreeSerif.ttf:text=hello world&rsquo;, <br>
[leave] drawtext reinit
&rsquo;fontfile=FreeSerif.ttf:text=&rsquo;;</p>

<p style="margin-top: 1em"># desaturate the image in the
interval 15-20 <br>
15.0-20.0 [enter] hue s 0, <br>
[enter] drawtext reinit
&rsquo;fontfile=FreeSerif.ttf:text=nocolor&rsquo;, <br>
[leave] hue s 1, <br>
[leave] drawtext reinit
&rsquo;fontfile=FreeSerif.ttf:text=color&rsquo;;</p>

<p style="margin-top: 1em"># apply an exponential
saturation fade-out effect, starting from time 25 <br>
25 [enter] hue s exp(25-t)</p>

<p style="margin-top: 1em">A filtergraph allowing to read
and process the above command list stored in a file
test.cmd, can be specified with:</p>


<p style="margin-top: 1em">sendcmd=f=test.cmd,drawtext=fontfile=FreeSerif.ttf:text=&rsquo;&rsquo;,hue</p>

<p style="margin-top: 1em">setpts, asetpts <br>
Change the PTS (presentation timestamp) of the input
frames.</p>

<p style="margin-top: 1em">&quot;setpts&quot; works on
video frames, &quot;asetpts&quot; on audio frames.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">expr <br>
The expression which is evaluated for each frame to
construct its timestamp.</p>

<p style="margin-top: 1em">The expression is evaluated
through the eval API and can contain the following
constants:</p>

<p style="margin-top: 1em">FRAME_RATE <br>
frame rate, only defined for constant frame-rate video</p>

<p style="margin-top: 1em">PTS The presentation timestamp
in input</p>

<p style="margin-top: 1em">N The count of the input frame
for video or the number of consumed samples, not including
the current frame for audio, starting from 0.</p>

<p style="margin-top: 1em">NB_CONSUMED_SAMPLES <br>
The number of consumed samples, not including the current
frame (only audio)</p>

<p style="margin-top: 1em">NB_SAMPLES, S <br>
The number of samples in the current frame (only audio)</p>

<p style="margin-top: 1em">SAMPLE_RATE, SR <br>
The audio sample rate.</p>

<p style="margin-top: 1em">STARTPTS <br>
The PTS of the first frame.</p>

<p style="margin-top: 1em">STARTT <br>
the time in seconds of the first frame</p>

<p style="margin-top: 1em">INTERLACED <br>
State whether the current frame is interlaced.</p>

<p style="margin-top: 1em">T the time in seconds of the
current frame</p>

<p style="margin-top: 1em">POS original position in the
file of the frame, or undefined if undefined for the current
frame</p>

<p style="margin-top: 1em">PREV_INPTS <br>
The previous input PTS.</p>

<p style="margin-top: 1em">PREV_INT <br>
previous input time in seconds</p>

<p style="margin-top: 1em">PREV_OUTPTS <br>
The previous output PTS.</p>

<p style="margin-top: 1em">PREV_OUTT <br>
previous output time in seconds</p>

<p style="margin-top: 1em">RTCTIME <br>
The wallclock (RTC) time in microseconds. This is
deprecated, use time(0) instead.</p>

<p style="margin-top: 1em">RTCSTART <br>
The wallclock (RTC) time at the start of the movie in
microseconds.</p>

<p style="margin-top: 1em">TB The timebase of the input
timestamps.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Start counting
PTS from zero</p>

<p style="margin-top: 1em">setpts=PTS-STARTPTS</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply fast
motion effect:</p>

<p style="margin-top: 1em">setpts=0.5*PTS</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply slow
motion effect:</p>

<p style="margin-top: 1em">setpts=2.0*PTS</p>

<p style="margin-top: 1em">&Acirc;&middot; Set fixed rate
of 25 frames per second:</p>

<p style="margin-top: 1em">setpts=N/(25*TB)</p>

<p style="margin-top: 1em">&Acirc;&middot; Set fixed rate
25 fps with some jitter:</p>

<p style="margin-top: 1em">setpts=&rsquo;1/(25*TB) * (N +
0.05 * sin(N*2*PI/25))&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Apply an offset
of 10 seconds to the input PTS:</p>

<p style="margin-top: 1em">setpts=PTS+10/TB</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate
timestamps from a &quot;live source&quot; and rebase onto
the current timebase:</p>

<p style="margin-top: 1em">setpts=&rsquo;(RTCTIME -
RTCSTART) / (TB * 1000000)&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Generate
timestamps by counting samples:</p>

<p style="margin-top: 1em">asetpts=N/SR/TB</p>

<p style="margin-top: 1em">settb, asettb <br>
Set the timebase to use for the output frames timestamps. It
is mainly useful for testing timebase configuration.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">expr, tb <br>
The expression which is evaluated into the output
timebase.</p>

<p style="margin-top: 1em">The value for tb is an
arithmetic expression representing a rational. The
expression can contain the constants &quot;AVTB&quot; (the
default timebase), &quot;intb&quot; (the input timebase) and
&quot;sr&quot; <br>
(the sample rate, audio only). Default value is
&quot;intb&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Set the timebase
to 1/25:</p>

<p style="margin-top: 1em">settb=expr=1/25</p>

<p style="margin-top: 1em">&Acirc;&middot; Set the timebase
to 1/10:</p>

<p style="margin-top: 1em">settb=expr=0.1</p>

<p style="margin-top: 1em">&Acirc;&middot; Set the timebase
to 1001/1000:</p>

<p style="margin-top: 1em">settb=1+0.001</p>

<p style="margin-top: 1em">&Acirc;&middot; Set the timebase
to 2*intb:</p>

<p style="margin-top: 1em">settb=2*intb</p>

<p style="margin-top: 1em">&Acirc;&middot; Set the default
timebase value:</p>

<p style="margin-top: 1em">settb=AVTB</p>

<p style="margin-top: 1em">showcqt <br>
Convert input audio to a video output representing frequency
spectrum logarithmically using Brown-Puckette constant Q
transform algorithm with direct frequency domain coefficient
<br>
calculation (but the transform itself is not really constant
Q, instead the Q factor is actually variable/clamped), with
musical tone scale, from E0 to D#10.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">size, s <br>
Specify the video size for the output. It must be even. For
the syntax of this option, check the &quot;Video size&quot;
section in the ffmpeg-utils manual. Default value is <br>
&quot;1920x1080&quot;.</p>

<p style="margin-top: 1em">fps, rate, r <br>
Set the output frame rate. Default value is 25.</p>

<p style="margin-top: 1em">bar_h <br>
Set the bargraph height. It must be even. Default value is
&quot;-1&quot; which computes the bargraph height
automatically.</p>

<p style="margin-top: 1em">axis_h <br>
Set the axis height. It must be even. Default value is
&quot;-1&quot; which computes the axis height
automatically.</p>

<p style="margin-top: 1em">sono_h <br>
Set the sonogram height. It must be even. Default value is
&quot;-1&quot; which computes the sonogram height
automatically.</p>

<p style="margin-top: 1em">fullhd <br>
Set the fullhd resolution. This option is deprecated, use
size, s instead. Default value is 1.</p>

<p style="margin-top: 1em">sono_v, volume <br>
Specify the sonogram volume expression. It can contain
variables:</p>

<p style="margin-top: 1em">bar_v <br>
the bar_v evaluated expression</p>

<p style="margin-top: 1em">frequency, freq, f <br>
the frequency where it is evaluated</p>

<p style="margin-top: 1em">timeclamp, tc <br>
the value of timeclamp option</p>

<p style="margin-top: 1em">and functions:</p>

<p style="margin-top: 1em">a_weighting(f) <br>
A-weighting of equal loudness</p>

<p style="margin-top: 1em">b_weighting(f) <br>
B-weighting of equal loudness</p>

<p style="margin-top: 1em">c_weighting(f) <br>
C-weighting of equal loudness.</p>

<p style="margin-top: 1em">Default value is 16.</p>

<p style="margin-top: 1em">bar_v, volume2 <br>
Specify the bargraph volume expression. It can contain
variables:</p>

<p style="margin-top: 1em">sono_v <br>
the sono_v evaluated expression</p>

<p style="margin-top: 1em">frequency, freq, f <br>
the frequency where it is evaluated</p>

<p style="margin-top: 1em">timeclamp, tc <br>
the value of timeclamp option</p>

<p style="margin-top: 1em">and functions:</p>

<p style="margin-top: 1em">a_weighting(f) <br>
A-weighting of equal loudness</p>

<p style="margin-top: 1em">b_weighting(f) <br>
B-weighting of equal loudness</p>

<p style="margin-top: 1em">c_weighting(f) <br>
C-weighting of equal loudness.</p>

<p style="margin-top: 1em">Default value is
&quot;sono_v&quot;.</p>

<p style="margin-top: 1em">sono_g, gamma <br>
Specify the sonogram gamma. Lower gamma makes the spectrum
more contrast, higher gamma makes the spectrum having more
range. Default value is 3. Acceptable range is &quot;[1,
<br>
7]&quot;.</p>

<p style="margin-top: 1em">bar_g, gamma2 <br>
Specify the bargraph gamma. Default value is 1. Acceptable
range is &quot;[1, 7]&quot;.</p>

<p style="margin-top: 1em">timeclamp, tc <br>
Specify the transform timeclamp. At low frequency, there is
trade-off between accuracy in time domain and frequency
domain. If timeclamp is lower, event in time domain is <br>
represented more accurately (such as fast bass drum),
otherwise event in frequency domain is represented more
accurately (such as bass guitar). Acceptable range is
&quot;[0.1, <br>
1]&quot;. Default value is 0.17.</p>

<p style="margin-top: 1em">basefreq <br>
Specify the transform base frequency. Default value is
20.01523126408007475, which is frequency 50 cents below E0.
Acceptable range is &quot;[10, 100000]&quot;.</p>

<p style="margin-top: 1em">endfreq <br>
Specify the transform end frequency. Default value is
20495.59681441799654, which is frequency 50 cents above
D#10. Acceptable range is &quot;[10, 100000]&quot;.</p>

<p style="margin-top: 1em">coeffclamp <br>
This option is deprecated and ignored.</p>

<p style="margin-top: 1em">tlength <br>
Specify the transform length in time domain. Use this option
to control accuracy trade-off between time domain and
frequency domain at every frequency sample. It can contain
<br>
variables:</p>

<p style="margin-top: 1em">frequency, freq, f <br>
the frequency where it is evaluated</p>

<p style="margin-top: 1em">timeclamp, tc <br>
the value of timeclamp option.</p>

<p style="margin-top: 1em">Default value is
&quot;384*tc/(384+tc*f)&quot;.</p>

<p style="margin-top: 1em">count <br>
Specify the transform count for every video frame. Default
value is 6. Acceptable range is &quot;[1, 30]&quot;.</p>

<p style="margin-top: 1em">fcount <br>
Specify the transform count for every single pixel. Default
value is 0, which makes it computed automatically.
Acceptable range is &quot;[0, 10]&quot;.</p>

<p style="margin-top: 1em">fontfile <br>
Specify font file for use with freetype to draw the axis. If
not specified, use embedded font. Note that drawing with
font file or embedded font is not implemented with <br>
custom basefreq and endfreq, use axisfile option
instead.</p>

<p style="margin-top: 1em">font <br>
Specify fontconfig pattern. This has lower priority than
fontfile. The : in the pattern may be replaced by | to avoid
unnecessary escaping.</p>

<p style="margin-top: 1em">fontcolor <br>
Specify font color expression. This is arithmetic expression
that should return integer value 0xRRGGBB. It can contain
variables:</p>

<p style="margin-top: 1em">frequency, freq, f <br>
the frequency where it is evaluated</p>

<p style="margin-top: 1em">timeclamp, tc <br>
the value of timeclamp option</p>

<p style="margin-top: 1em">and functions:</p>

<p style="margin-top: 1em">midi(f) <br>
midi number of frequency f, some midi numbers: E0(16),
C1(24), C2(36), A4(69)</p>

<p style="margin-top: 1em">r(x), g(x), b(x) <br>
red, green, and blue value of intensity x.</p>

<p style="margin-top: 1em">Default value is &quot;st(0,
(midi(f)-59.5)/12); st(1, if(between(ld(0),0,1),
0.5-0.5*cos(2*PI*ld(0)), 0)); r(1-ld(1)) +
b(ld(1))&quot;.</p>

<p style="margin-top: 1em">axisfile <br>
Specify image file to draw the axis. This option override
fontfile and fontcolor option.</p>

<p style="margin-top: 1em">axis, text <br>
Enable/disable drawing text to the axis. If it is set to 0,
drawing to the axis is disabled, ignoring fontfile and
axisfile option. Default value is 1.</p>

<p style="margin-top: 1em">csp Set colorspace. The accepted
values are:</p>

<p style="margin-top: 1em">unspecified <br>
Unspecified (default)</p>

<p style="margin-top: 1em">bt709 <br>
BT.709</p>

<p style="margin-top: 1em">fcc FCC</p>

<p style="margin-top: 1em">bt470bg <br>
BT.470BG or BT.601-6 625</p>

<p style="margin-top: 1em">smpte170m <br>
SMPTE-170M or BT.601-6 525</p>

<p style="margin-top: 1em">smpte240m <br>
SMPTE-240M</p>

<p style="margin-top: 1em">bt2020ncl <br>
BT.2020 with non-constant luminance</p>

<p style="margin-top: 1em">cscheme <br>
Set spectrogram color scheme. This is list of floating point
values with format
&quot;left_r|left_g|left_b|right_r|right_g|right_b&quot;.
The default is &quot;1|0.5|0|0|0.5|1&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Playing audio
while showing the spectrum:</p>

<p style="margin-top: 1em">ffplay -f lavfi
&rsquo;amovie=a.mp3, asplit [a][out1]; [a] showcqt
[out0]&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Same as above,
but with frame rate 30 fps:</p>

<p style="margin-top: 1em">ffplay -f lavfi
&rsquo;amovie=a.mp3, asplit [a][out1]; [a]
showcqt=fps=30:count=5 [out0]&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Playing at
1280x720:</p>

<p style="margin-top: 1em">ffplay -f lavfi
&rsquo;amovie=a.mp3, asplit [a][out1]; [a]
showcqt=s=1280x720:count=4 [out0]&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Disable sonogram
display:</p>

<p style="margin-top: 1em">sono_h=0</p>

<p style="margin-top: 1em">&Acirc;&middot; A1 and its
harmonics: A1, A2, (near)E3, A3:</p>

<p style="margin-top: 1em">ffplay -f lavfi
&rsquo;aevalsrc=0.1*sin(2*PI*55*t)+0.1*sin(4*PI*55*t)+0.1*sin(6*PI*55*t)+0.1*sin(8*PI*55*t),
<br>
asplit[a][out1]; [a] showcqt [out0]&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Same as above,
but with more accuracy in frequency domain:</p>

<p style="margin-top: 1em">ffplay -f lavfi
&rsquo;aevalsrc=0.1*sin(2*PI*55*t)+0.1*sin(4*PI*55*t)+0.1*sin(6*PI*55*t)+0.1*sin(8*PI*55*t),
<br>
asplit[a][out1]; [a] showcqt=timeclamp=0.5 [out0]&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Custom
volume:</p>


<p style="margin-top: 1em">bar_v=10:sono_v=bar_v*a_weighting(f)</p>

<p style="margin-top: 1em">&Acirc;&middot; Custom gamma,
now spectrum is linear to the amplitude.</p>

<p style="margin-top: 1em">bar_g=2:sono_g=2</p>

<p style="margin-top: 1em">&Acirc;&middot; Custom tlength
equation:</p>


<p style="margin-top: 1em">tc=0.33:tlength=&rsquo;st(0,0.17);
384*tc / (384 / ld(0) + tc*f /(1-ld(0))) + 384*tc / (tc*f /
ld(0) + 384 /(1-ld(0)))&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Custom fontcolor
and fontfile, C-note is colored green, others are colored
blue:</p>


<p style="margin-top: 1em">fontcolor=&rsquo;if(mod(floor(midi(f)+0.5),12),
0x0000FF, g(1))&rsquo;:fontfile=myfont.ttf</p>

<p style="margin-top: 1em">&Acirc;&middot; Custom font
using fontconfig:</p>

<p style="margin-top: 1em">font=&rsquo;Courier
New,Monospace,mono|bold&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Custom frequency
range with custom axis using image file:</p>


<p style="margin-top: 1em">axisfile=myaxis.png:basefreq=40:endfreq=10000</p>

<p style="margin-top: 1em">showfreqs <br>
Convert input audio to video output representing the audio
power spectrum. Audio amplitude is on Y-axis while frequency
is on X-axis.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">size, s <br>
Specify size of video. For the syntax of this option, check
the &quot;Video size&quot; section in the ffmpeg-utils
manual. Default is &quot;1024x512&quot;.</p>

<p style="margin-top: 1em">mode <br>
Set display mode. This set how each frequency bin will be
represented.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">line <br>
bar <br>
dot</p>

<p style="margin-top: 1em">Default is &quot;bar&quot;.</p>

<p style="margin-top: 1em">ascale <br>
Set amplitude scale.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">lin Linear scale.</p>

<p style="margin-top: 1em">sqrt <br>
Square root scale.</p>

<p style="margin-top: 1em">cbrt <br>
Cubic root scale.</p>

<p style="margin-top: 1em">log Logarithmic scale.</p>

<p style="margin-top: 1em">Default is &quot;log&quot;.</p>

<p style="margin-top: 1em">fscale <br>
Set frequency scale.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">lin Linear scale.</p>

<p style="margin-top: 1em">log Logarithmic scale.</p>

<p style="margin-top: 1em">rlog <br>
Reverse logarithmic scale.</p>

<p style="margin-top: 1em">Default is &quot;lin&quot;.</p>

<p style="margin-top: 1em">win_size <br>
Set window size.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">w16 <br>
w32 <br>
w64 <br>
w128 <br>
w256 <br>
w512 <br>
w1024 <br>
w2048 <br>
w4096 <br>
w8192 <br>
w16384 <br>
w32768 <br>
w65536</p>

<p style="margin-top: 1em">Default is &quot;w2048&quot;</p>

<p style="margin-top: 1em">win_func <br>
Set windowing function.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">rect <br>
bartlett <br>
hanning <br>
hamming <br>
blackman <br>
welch <br>
flattop <br>
bharris <br>
bnuttall <br>
bhann <br>
sine <br>
nuttall <br>
lanczos <br>
gauss <br>
tukey <br>
dolph <br>
cauchy <br>
parzen <br>
poisson</p>

<p style="margin-top: 1em">Default is
&quot;hanning&quot;.</p>

<p style="margin-top: 1em">overlap <br>
Set window overlap. In range &quot;[0, 1]&quot;. Default is
1, which means optimal overlap for selected window function
will be picked.</p>

<p style="margin-top: 1em">averaging <br>
Set time averaging. Setting this to 0 will display current
maximal peaks. Default is 1, which means time averaging is
disabled.</p>

<p style="margin-top: 1em">colors <br>
Specify list of colors separated by space or by
&rsquo;|&rsquo; which will be used to draw channel
frequencies. Unrecognized or missing colors will be replaced
by white color.</p>

<p style="margin-top: 1em">cmode <br>
Set channel display mode.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">combined <br>
separate</p>

<p style="margin-top: 1em">Default is
&quot;combined&quot;.</p>

<p style="margin-top: 1em">minamp <br>
Set minimum amplitude used in &quot;log&quot; amplitude
scaler.</p>

<p style="margin-top: 1em">showspectrum <br>
Convert input audio to a video output, representing the
audio frequency spectrum.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">size, s <br>
Specify the video size for the output. For the syntax of
this option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual. Default value is
&quot;640x512&quot;.</p>

<p style="margin-top: 1em">slide <br>
Specify how the spectrum should slide along the window.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">replace <br>
the samples start again on the left when they reach the
right</p>

<p style="margin-top: 1em">scroll <br>
the samples scroll from right to left</p>

<p style="margin-top: 1em">fullframe <br>
frames are only produced when the samples reach the
right</p>

<p style="margin-top: 1em">rscroll <br>
the samples scroll from left to right</p>

<p style="margin-top: 1em">Default value is
&quot;replace&quot;.</p>

<p style="margin-top: 1em">mode <br>
Specify display mode.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">combined <br>
all channels are displayed in the same row</p>

<p style="margin-top: 1em">separate <br>
all channels are displayed in separate rows</p>

<p style="margin-top: 1em">Default value is combined.</p>

<p style="margin-top: 1em">color <br>
Specify display color mode.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">channel <br>
each channel is displayed in a separate color</p>

<p style="margin-top: 1em">intensity <br>
each channel is displayed using the same color scheme</p>

<p style="margin-top: 1em">rainbow <br>
each channel is displayed using the rainbow color scheme</p>

<p style="margin-top: 1em">moreland <br>
each channel is displayed using the moreland color
scheme</p>

<p style="margin-top: 1em">nebulae <br>
each channel is displayed using the nebulae color scheme</p>

<p style="margin-top: 1em">fire <br>
each channel is displayed using the fire color scheme</p>

<p style="margin-top: 1em">fiery <br>
each channel is displayed using the fiery color scheme</p>

<p style="margin-top: 1em">fruit <br>
each channel is displayed using the fruit color scheme</p>

<p style="margin-top: 1em">cool <br>
each channel is displayed using the cool color scheme</p>

<p style="margin-top: 1em">Default value is channel.</p>

<p style="margin-top: 1em">scale <br>
Specify scale used for calculating intensity color
values.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">lin linear</p>

<p style="margin-top: 1em">sqrt <br>
square root, default</p>

<p style="margin-top: 1em">cbrt <br>
cubic root</p>

<p style="margin-top: 1em">log logarithmic</p>

<p style="margin-top: 1em">4thrt <br>
4th root</p>

<p style="margin-top: 1em">5thrt <br>
5th root</p>

<p style="margin-top: 1em">Default value is sqrt.</p>

<p style="margin-top: 1em">saturation <br>
Set saturation modifier for displayed colors. Negative
values provide alternative color scheme. 0 is no saturation
at all. Saturation must be in [-10.0, 10.0] range. <br>
Default value is 1.</p>

<p style="margin-top: 1em">win_func <br>
Set window function.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">rect <br>
bartlett <br>
hann <br>
hanning <br>
hamming <br>
blackman <br>
welch <br>
flattop <br>
bharris <br>
bnuttall <br>
bhann <br>
sine <br>
nuttall <br>
lanczos <br>
gauss <br>
tukey <br>
dolph <br>
cauchy <br>
parzen <br>
poisson</p>

<p style="margin-top: 1em">Default value is
&quot;hann&quot;.</p>

<p style="margin-top: 1em">orientation <br>
Set orientation of time vs frequency axis. Can be
&quot;vertical&quot; or &quot;horizontal&quot;. Default is
&quot;vertical&quot;.</p>

<p style="margin-top: 1em">overlap <br>
Set ratio of overlap window. Default value is 0. When value
is 1 overlap is set to recommended size for specific window
function currently used.</p>

<p style="margin-top: 1em">gain <br>
Set scale gain for calculating intensity color values.
Default value is 1.</p>

<p style="margin-top: 1em">data <br>
Set which data to display. Can be &quot;magnitude&quot;,
default or &quot;phase&quot;.</p>

<p style="margin-top: 1em">rotation <br>
Set color rotation, must be in [-1.0, 1.0] range. Default
value is 0.</p>

<p style="margin-top: 1em">The usage is very similar to the
showwaves filter; see the examples in that section.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Large window
with logarithmic color scaling:</p>


<p style="margin-top: 1em">showspectrum=s=1280x480:scale=log</p>

<p style="margin-top: 1em">&Acirc;&middot; Complete example
for a colored and sliding spectrum per channel using
ffplay:</p>

<p style="margin-top: 1em">ffplay -f lavfi
&rsquo;amovie=input.mp3, asplit [a][out1]; <br>
[a]
showspectrum=mode=separate:color=intensity:slide=1:scale=cbrt
[out0]&rsquo;</p>

<p style="margin-top: 1em">showspectrumpic <br>
Convert input audio to a single video frame, representing
the audio frequency spectrum.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">size, s <br>
Specify the video size for the output. For the syntax of
this option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual. Default value is
&quot;4096x2048&quot;.</p>

<p style="margin-top: 1em">mode <br>
Specify display mode.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">combined <br>
all channels are displayed in the same row</p>

<p style="margin-top: 1em">separate <br>
all channels are displayed in separate rows</p>

<p style="margin-top: 1em">Default value is combined.</p>

<p style="margin-top: 1em">color <br>
Specify display color mode.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">channel <br>
each channel is displayed in a separate color</p>

<p style="margin-top: 1em">intensity <br>
each channel is displayed using the same color scheme</p>

<p style="margin-top: 1em">rainbow <br>
each channel is displayed using the rainbow color scheme</p>

<p style="margin-top: 1em">moreland <br>
each channel is displayed using the moreland color
scheme</p>

<p style="margin-top: 1em">nebulae <br>
each channel is displayed using the nebulae color scheme</p>

<p style="margin-top: 1em">fire <br>
each channel is displayed using the fire color scheme</p>

<p style="margin-top: 1em">fiery <br>
each channel is displayed using the fiery color scheme</p>

<p style="margin-top: 1em">fruit <br>
each channel is displayed using the fruit color scheme</p>

<p style="margin-top: 1em">cool <br>
each channel is displayed using the cool color scheme</p>

<p style="margin-top: 1em">Default value is intensity.</p>

<p style="margin-top: 1em">scale <br>
Specify scale used for calculating intensity color
values.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">lin linear</p>

<p style="margin-top: 1em">sqrt <br>
square root, default</p>

<p style="margin-top: 1em">cbrt <br>
cubic root</p>

<p style="margin-top: 1em">log logarithmic</p>

<p style="margin-top: 1em">4thrt <br>
4th root</p>

<p style="margin-top: 1em">5thrt <br>
5th root</p>

<p style="margin-top: 1em">Default value is log.</p>

<p style="margin-top: 1em">saturation <br>
Set saturation modifier for displayed colors. Negative
values provide alternative color scheme. 0 is no saturation
at all. Saturation must be in [-10.0, 10.0] range. <br>
Default value is 1.</p>

<p style="margin-top: 1em">win_func <br>
Set window function.</p>

<p style="margin-top: 1em">It accepts the following
values:</p>

<p style="margin-top: 1em">rect <br>
bartlett <br>
hann <br>
hanning <br>
hamming <br>
blackman <br>
welch <br>
flattop <br>
bharris <br>
bnuttall <br>
bhann <br>
sine <br>
nuttall <br>
lanczos <br>
gauss <br>
tukey <br>
dolph <br>
cauchy <br>
parzen <br>
poisson</p>

<p style="margin-top: 1em">Default value is
&quot;hann&quot;.</p>

<p style="margin-top: 1em">orientation <br>
Set orientation of time vs frequency axis. Can be
&quot;vertical&quot; or &quot;horizontal&quot;. Default is
&quot;vertical&quot;.</p>

<p style="margin-top: 1em">gain <br>
Set scale gain for calculating intensity color values.
Default value is 1.</p>

<p style="margin-top: 1em">legend <br>
Draw time and frequency axes and legends. Default is
enabled.</p>

<p style="margin-top: 1em">rotation <br>
Set color rotation, must be in [-1.0, 1.0] range. Default
value is 0.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Extract an audio
spectrogram of a whole audio track in a 1024x1024 picture
using ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i audio.flac -lavfi
showspectrumpic=s=1024x1024 spectrogram.png</p>

<p style="margin-top: 1em">showvolume <br>
Convert input audio volume to a video output.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">rate, r <br>
Set video rate.</p>

<p style="margin-top: 1em">b Set border width, allowed
range is [0, 5]. Default is 1.</p>

<p style="margin-top: 1em">w Set channel width, allowed
range is [80, 8192]. Default is 400.</p>

<p style="margin-top: 1em">h Set channel height, allowed
range is [1, 900]. Default is 20.</p>

<p style="margin-top: 1em">f Set fade, allowed range is
[0.001, 1]. Default is 0.95.</p>

<p style="margin-top: 1em">c Set volume color
expression.</p>

<p style="margin-top: 1em">The expression can use the
following variables:</p>

<p style="margin-top: 1em">VOLUME <br>
Current max volume of channel in dB.</p>

<p style="margin-top: 1em">PEAK <br>
Current peak.</p>

<p style="margin-top: 1em">CHANNEL <br>
Current channel number, starting from 0.</p>

<p style="margin-top: 1em">t If set, displays channel
names. Default is enabled.</p>

<p style="margin-top: 1em">v If set, displays volume
values. Default is enabled.</p>

<p style="margin-top: 1em">o Set orientation, can be
&quot;horizontal&quot; or &quot;vertical&quot;, default is
&quot;horizontal&quot;.</p>

<p style="margin-top: 1em">s Set step size, allowed range s
[0, 5]. Default is 0, which means step is disabled.</p>

<p style="margin-top: 1em">showwaves <br>
Convert input audio to a video output, representing the
samples waves.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">size, s <br>
Specify the video size for the output. For the syntax of
this option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual. Default value is
&quot;600x240&quot;.</p>

<p style="margin-top: 1em">mode <br>
Set display mode.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">point <br>
Draw a point for each sample.</p>

<p style="margin-top: 1em">line <br>
Draw a vertical line for each sample.</p>

<p style="margin-top: 1em">p2p Draw a point for each sample
and a line between them.</p>

<p style="margin-top: 1em">cline <br>
Draw a centered vertical line for each sample.</p>

<p style="margin-top: 1em">Default value is
&quot;point&quot;.</p>

<p style="margin-top: 1em">n Set the number of samples
which are printed on the same column. A larger value will
decrease the frame rate. Must be a positive integer. This
option can be set only if the <br>
value for rate is not explicitly specified.</p>

<p style="margin-top: 1em">rate, r <br>
Set the (approximate) output frame rate. This is done by
setting the option n. Default value is &quot;25&quot;.</p>

<p style="margin-top: 1em">split_channels <br>
Set if channels should be drawn separately or overlap.
Default value is 0.</p>

<p style="margin-top: 1em">colors <br>
Set colors separated by &rsquo;|&rsquo; which are going to
be used for drawing of each channel.</p>

<p style="margin-top: 1em">scale <br>
Set amplitude scale.</p>

<p style="margin-top: 1em">Available values are:</p>

<p style="margin-top: 1em">lin Linear.</p>

<p style="margin-top: 1em">log Logarithmic.</p>

<p style="margin-top: 1em">sqrt <br>
Square root.</p>

<p style="margin-top: 1em">cbrt <br>
Cubic root.</p>

<p style="margin-top: 1em">Default is linear.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Output the input
file audio and the corresponding video representation at the
same time:</p>


<p style="margin-top: 1em">amovie=a.mp3,asplit[out0],showwaves[out1]</p>

<p style="margin-top: 1em">&Acirc;&middot; Create a
synthetic signal and show it with showwaves, forcing a frame
rate of 30 frames per second:</p>


<p style="margin-top: 1em">aevalsrc=sin(1*2*PI*t)*sin(880*2*PI*t):cos(2*PI*200*t),asplit[out0],showwaves=r=30[out1]</p>

<p style="margin-top: 1em">showwavespic <br>
Convert input audio to a single video frame, representing
the samples waves.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">size, s <br>
Specify the video size for the output. For the syntax of
this option, check the &quot;Video size&quot; section in the
ffmpeg-utils manual. Default value is
&quot;600x240&quot;.</p>

<p style="margin-top: 1em">split_channels <br>
Set if channels should be drawn separately or overlap.
Default value is 0.</p>

<p style="margin-top: 1em">colors <br>
Set colors separated by &rsquo;|&rsquo; which are going to
be used for drawing of each channel.</p>

<p style="margin-top: 1em">scale <br>
Set amplitude scale. Can be linear &quot;lin&quot; or
logarithmic &quot;log&quot;. Default is linear.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Extract a
channel split representation of the wave form of a whole
audio track in a 1024x800 picture using ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i audio.flac -lavfi
showwavespic=split_channels=1:s=1024x800 waveform.png</p>

<p style="margin-top: 1em">sidedata, asidedata <br>
Delete frame side data, or select frames based on it.</p>

<p style="margin-top: 1em">This filter accepts the
following options:</p>

<p style="margin-top: 1em">mode <br>
Set mode of operation of the filter.</p>

<p style="margin-top: 1em">Can be one of the following:</p>

<p style="margin-top: 1em">select <br>
Select every frame with side data of &quot;type&quot;.</p>

<p style="margin-top: 1em">delete <br>
Delete side data of &quot;type&quot;. If &quot;type&quot; is
not set, delete all side data in the frame.</p>

<p style="margin-top: 1em">type <br>
Set side data type used with all modes. Must be set for
&quot;select&quot; mode. For the list of frame side data
types, refer to the &quot;AVFrameSideDataType&quot; enum in
libavutil/frame.h. <br>
For example, to choose &quot;AV_FRAME_DATA_PANSCAN&quot;
side data, you must specify &quot;PANSCAN&quot;.</p>

<p style="margin-top: 1em">spectrumsynth <br>
Sythesize audio from 2 input video spectrums, first input
stream represents magnitude across time and second
represents phase across time. The filter will transform from
<br>
frequency domain as displayed in videos back to time domain
as presented in audio output.</p>

<p style="margin-top: 1em">This filter is primarily created
for reversing processed showspectrum filter outputs, but can
synthesize sound from other spectrograms too. But in such
case results are going to <br>
be poor if the phase data is not available, because in such
cases phase data need to be recreated, usually its just
recreated from random noise. For best results use gray only
<br>
output (&quot;channel&quot; color mode in showspectrum
filter) and &quot;log&quot; scale for magnitude video and
&quot;lin&quot; scale for phase video. To produce phase, for
2nd video, use &quot;data&quot; option. <br>
Inputs videos should generally use &quot;fullframe&quot;
slide mode as that saves resources needed for decoding
video.</p>

<p style="margin-top: 1em">The filter accepts the following
options:</p>

<p style="margin-top: 1em">sample_rate <br>
Specify sample rate of output audio, the sample rate of
audio from which spectrum was generated may differ.</p>

<p style="margin-top: 1em">channels <br>
Set number of channels represented in input video
spectrums.</p>

<p style="margin-top: 1em">scale <br>
Set scale which was used when generating magnitude input
spectrum. Can be &quot;lin&quot; or &quot;log&quot;. Default
is &quot;log&quot;.</p>

<p style="margin-top: 1em">slide <br>
Set slide which was used when generating inputs spectrums.
Can be &quot;replace&quot;, &quot;scroll&quot;,
&quot;fullframe&quot; or &quot;rscroll&quot;. Default is
&quot;fullframe&quot;.</p>

<p style="margin-top: 1em">win_func <br>
Set window function used for resynthesis.</p>

<p style="margin-top: 1em">overlap <br>
Set window overlap. In range &quot;[0, 1]&quot;. Default is
1, which means optimal overlap for selected window function
will be picked.</p>

<p style="margin-top: 1em">orientation <br>
Set orientation of input videos. Can be &quot;vertical&quot;
or &quot;horizontal&quot;. Default is
&quot;vertical&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; First create
magnitude and phase videos from audio, assuming audio is
stereo with 44100 sample rate, then resynthesize videos back
to audio with spectrumsynth:</p>

<p style="margin-top: 1em">ffmpeg -i input.flac -lavfi
showspectrum=mode=separate:scale=log:overlap=0.875:color=channel:slide=fullframe:data=magnitude
-an -c:v rawvideo magnitude.nut <br>
ffmpeg -i input.flac -lavfi
showspectrum=mode=separate:scale=lin:overlap=0.875:color=channel:slide=fullframe:data=phase
-an -c:v rawvideo phase.nut <br>
ffmpeg -i magnitude.nut -i phase.nut -lavfi
spectrumsynth=channels=2:sample_rate=44100:win_func=hann:overlap=0.875:slide=fullframe
output.flac</p>

<p style="margin-top: 1em">split, asplit <br>
Split input into several identical outputs.</p>

<p style="margin-top: 1em">&quot;asplit&quot; works with
audio input, &quot;split&quot; with video.</p>

<p style="margin-top: 1em">The filter accepts a single
parameter which specifies the number of outputs. If
unspecified, it defaults to 2.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Create two
separate outputs from the same input:</p>

<p style="margin-top: 1em">[in] split [out0][out1]</p>

<p style="margin-top: 1em">&Acirc;&middot; To create 3 or
more outputs, you need to specify the number of outputs,
like in:</p>

<p style="margin-top: 1em">[in] asplit=3
[out0][out1][out2]</p>

<p style="margin-top: 1em">&Acirc;&middot; Create two
separate outputs from the same input, one cropped and one
padded:</p>

<p style="margin-top: 1em">[in] split
[splitout1][splitout2]; <br>
[splitout1] crop=100:100:0:0 [cropout]; <br>
[splitout2] pad=200:200:100:100 [padout];</p>

<p style="margin-top: 1em">&Acirc;&middot; Create 5 copies
of the input audio with ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -filter_complex
asplit=5 OUTPUT</p>

<p style="margin-top: 1em">zmq, azmq <br>
Receive commands sent through a libzmq client, and forward
them to filters in the filtergraph.</p>

<p style="margin-top: 1em">&quot;zmq&quot; and
&quot;azmq&quot; work as a pass-through filters.
&quot;zmq&quot; must be inserted between two video filters,
&quot;azmq&quot; between two audio filters.</p>

<p style="margin-top: 1em">To enable these filters you need
to install the libzmq library and headers and configure
FFmpeg with &quot;--enable-libzmq&quot;.</p>

<p style="margin-top: 1em">For more information about
libzmq see: &lt;http://www.zeromq.org/&gt;</p>

<p style="margin-top: 1em">The &quot;zmq&quot; and
&quot;azmq&quot; filters work as a libzmq server, which
receives messages sent through a network interface defined
by the bind_address option.</p>

<p style="margin-top: 1em">The received message must be in
the form:</p>

<p style="margin-top: 1em">&lt;TARGET&gt; &lt;COMMAND&gt;
[&lt;ARG&gt;]</p>

<p style="margin-top: 1em">TARGET specifies the target of
the command, usually the name of the filter class or a
specific filter instance name.</p>

<p style="margin-top: 1em">COMMAND specifies the name of
the command for the target filter.</p>

<p style="margin-top: 1em">ARG is optional and specifies
the optional argument list for the given COMMAND.</p>

<p style="margin-top: 1em">Upon reception, the message is
processed and the corresponding command is injected into the
filtergraph. Depending on the result, the filter will send a
reply to the client, <br>
adopting the format:</p>

<p style="margin-top: 1em">&lt;ERROR_CODE&gt;
&lt;ERROR_REASON&gt; <br>
&lt;MESSAGE&gt;</p>

<p style="margin-top: 1em">MESSAGE is optional.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">Look at tools/zmqsend for an
example of a zmq client which can be used to send commands
processed by these filters.</p>

<p style="margin-top: 1em">Consider the following
filtergraph generated by ffplay</p>

<p style="margin-top: 1em">ffplay -dumpgraph 1 -f lavfi
&quot; <br>
color=s=100x100:c=red [l]; <br>
color=s=100x100:c=blue [r]; <br>
nullsrc=s=200x100, zmq [bg]; <br>
[bg][l] overlay [bg+l]; <br>
[bg+l][r] overlay=x=100 &quot;</p>

<p style="margin-top: 1em">To change the color of the left
side of the video, the following command can be used:</p>

<p style="margin-top: 1em">echo Parsed_color_0 c yellow |
tools/zmqsend</p>

<p style="margin-top: 1em">To change the right side:</p>

<p style="margin-top: 1em">echo Parsed_color_1 c pink |
tools/zmqsend</p>

<p style="margin-top: 1em">MULTIMEDIA SOURCES <br>
Below is a description of the currently available multimedia
sources.</p>

<p style="margin-top: 1em">amovie <br>
This is the same as movie source, except it selects an audio
stream by default.</p>

<p style="margin-top: 1em">movie <br>
Read audio and/or video stream(s) from a movie
container.</p>

<p style="margin-top: 1em">It accepts the following
parameters:</p>

<p style="margin-top: 1em">filename <br>
The name of the resource to read (not necessarily a file; it
can also be a device or a stream accessed through some
protocol).</p>

<p style="margin-top: 1em">format_name, f <br>
Specifies the format assumed for the movie to read, and can
be either the name of a container or an input device. If not
specified, the format is guessed from movie_name or <br>
by probing.</p>

<p style="margin-top: 1em">seek_point, sp <br>
Specifies the seek point in seconds. The frames will be
output starting from this seek point. The parameter is
evaluated with &quot;av_strtod&quot;, so the numerical value
may be <br>
suffixed by an IS postfix. The default value is
&quot;0&quot;.</p>

<p style="margin-top: 1em">streams, s <br>
Specifies the streams to read. Several streams can be
specified, separated by &quot;+&quot;. The source will then
have as many outputs, in the same order. The syntax is
explained in <br>
the &lsquo;&lsquo;Stream specifiers&rsquo;&rsquo; section in
the ffmpeg manual. Two special names, &quot;dv&quot; and
&quot;da&quot; specify respectively the default (best
suited) video and audio stream. Default is <br>
&quot;dv&quot;, or &quot;da&quot; if the filter is called as
&quot;amovie&quot;.</p>

<p style="margin-top: 1em">stream_index, si <br>
Specifies the index of the video stream to read. If the
value is -1, the most suitable video stream will be
automatically selected. The default value is &quot;-1&quot;.
Deprecated. If <br>
the filter is called &quot;amovie&quot;, it will select
audio instead of video.</p>

<p style="margin-top: 1em">loop <br>
Specifies how many times to read the stream in sequence. If
the value is less than 1, the stream will be read again and
again. Default value is &quot;1&quot;.</p>

<p style="margin-top: 1em">Note that when the movie is
looped the source timestamps are not changed, so it will
generate non monotonically increasing timestamps.</p>

<p style="margin-top: 1em">discontinuity <br>
Specifies the time difference between frames above which the
point is considered a timestamp discontinuity which is
removed by adjusting the later timestamps.</p>

<p style="margin-top: 1em">It allows overlaying a second
video on top of the main input of a filtergraph, as shown in
this graph:</p>

<p style="margin-top: 1em">input -----------&gt; deltapts0
--&gt; overlay --&gt; output <br>
^ <br>
| <br>
movie --&gt; scale--&gt; deltapts1 -------+</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Skip 3.2 seconds
from the start of the AVI file in.avi, and overlay it on top
of the input labelled &quot;in&quot;:</p>

<p style="margin-top: 1em">movie=in.avi:seek_point=3.2,
scale=180:-1, setpts=PTS-STARTPTS [over]; <br>
[in] setpts=PTS-STARTPTS [main]; <br>
[main][over] overlay=16:16 [out]</p>

<p style="margin-top: 1em">&Acirc;&middot; Read from a
video4linux2 device, and overlay it on top of the input
labelled &quot;in&quot;:</p>


<p style="margin-top: 1em">movie=/dev/video0:f=video4linux2,
scale=180:-1, setpts=PTS-STARTPTS [over]; <br>
[in] setpts=PTS-STARTPTS [main]; <br>
[main][over] overlay=16:16 [out]</p>

<p style="margin-top: 1em">&Acirc;&middot; Read the first
video stream and the audio stream with id 0x81 from dvd.vob;
the video is connected to the pad named &quot;video&quot;
and the audio is connected to the pad named <br>
&quot;audio&quot;:</p>

<p style="margin-top: 1em">movie=dvd.vob:s=v:0+#0x81
[video] [audio]</p>

<p style="margin-top: 1em">Commands</p>

<p style="margin-top: 1em">Both movie and amovie support
the following commands:</p>

<p style="margin-top: 1em">seek <br>
Perform seek using &quot;av_seek_frame&quot;. The syntax is:
seek stream_index|timestamp|flags</p>

<p style="margin-top: 1em">&Acirc;&middot; stream_index: If
stream_index is -1, a default stream is selected, and
timestamp is automatically converted from AV_TIME_BASE units
to the stream specific time_base.</p>

<p style="margin-top: 1em">&Acirc;&middot; timestamp:
Timestamp in AVStream.time_base units or, if no stream is
specified, in AV_TIME_BASE units.</p>

<p style="margin-top: 1em">&Acirc;&middot; flags: Flags
which select direction and seeking mode.</p>

<p style="margin-top: 1em">get_duration <br>
Get movie duration in AV_TIME_BASE units.</p>

<p style="margin-top: 1em">SEE ALSO <br>
ffmpeg(1), ffplay(1), ffprobe(1), ffserver(1),
libavfilter(3)</p>

<p style="margin-top: 1em">AUTHORS <br>
The FFmpeg developers.</p>

<p style="margin-top: 1em">For details about the
authorship, see the Git history of the project
(git://source.ffmpeg.org/ffmpeg), e.g. by typing the command
git log in the FFmpeg source directory, or <br>
browsing the online repository at
&lt;http://source.ffmpeg.org&gt;.</p>

<p style="margin-top: 1em">Maintainers for the specific
components are listed in the file MAINTAINERS in the source
code tree.</p>
 
<p style="margin-top: 1em">FFMPEG-FILTERS(1)</p>
<hr>
</body>
</html>
