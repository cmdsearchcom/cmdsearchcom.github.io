<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLDEBUG(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLDEBUG(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLDEBUG(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perldebug - Perl debugging
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
First of all, have you tried using the <b>-w</b> switch?
<div class="Pp"></div>
If you're new to the Perl debugger, you may prefer to read perldebtut, which is
  a tutorial introduction to the debugger.
<h1 class="Sh" title="Sh" id="The_Perl_Debugger"><a class="selflink" href="#The_Perl_Debugger">The
  Perl Debugger</a></h1>
If you invoke Perl with the <b>-d</b> switch, your script runs under the Perl
  source debugger. This works like an interactive Perl environment, prompting
  for debugger commands that let you examine source code, set breakpoints, get
  stack backtraces, change the values of variables, etc. This is so convenient
  that you often fire up the debugger all by itself just to test out Perl
  constructs interactively to see what they do. For example:
<div class="Pp"></div>
<pre>
    $ perl -d -e 42
</pre>
<div class="Pp"></div>
In Perl, the debugger is not a separate program the way it usually is in the
  typical compiled environment. Instead, the <b>-d</b> flag tells the compiler
  to insert source information into the parse trees it's about to hand off to
  the interpreter. That means your code must first compile correctly for the
  debugger to work on it. Then when the interpreter starts up, it preloads a
  special Perl library file containing the debugger.
<div class="Pp"></div>
The program will halt <i>right before</i> the first run-time executable
  statement (but see below regarding compile-time statements) and ask you to
  enter a debugger command. Contrary to popular expectations, whenever the
  debugger halts and shows you a line of code, it always displays the line it's
  <i>about</i> to execute, rather than the one it has just executed.
<div class="Pp"></div>
Any command not recognized by the debugger is directly executed
  (&quot;eval&quot;'d) as Perl code in the current package. (The debugger uses
  the DB package for keeping its own state information.)
<div class="Pp"></div>
Note that the said &quot;eval&quot; is bound by an implicit scope. As a result
  any newly introduced lexical variable or any modified capture buffer content
  is lost after the eval. The debugger is a nice environment to learn Perl, but
  if you interactively experiment using material which should be in the same
  scope, stuff it in one line.
<div class="Pp"></div>
For any text entered at the debugger prompt, leading and trailing whitespace is
  first stripped before further processing. If a debugger command coincides with
  some function in your own program, merely precede the function with something
  that doesn't look like a debugger command, such as a leading &quot;;&quot; or
  perhaps a &quot;+&quot;, or by wrapping it with parentheses or braces.
<h2 class="Ss" title="Ss" id="Calling_the_Debugger"><a class="selflink" href="#Calling_the_Debugger">Calling
  the Debugger</a></h2>
There are several ways to call the debugger:
<dl class="Bl-tag">
  <dt class="It-tag">perl -d program_name</dt>
  <dd class="It-tag">On the given program identified by
      &quot;program_name&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">perl -d -e 0</dt>
  <dd class="It-tag">Interactively supply an arbitrary &quot;expression&quot;
      using &quot;-e&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">perl -d:Ptkdb program_name</dt>
  <dd class="It-tag">Debug a given program via the &quot;Devel::Ptkdb&quot;
    GUI.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">perl -dt threaded_program_name</dt>
  <dd class="It-tag">Debug a given program using threads (experimental).</dd>
</dl>
<h2 class="Ss" title="Ss" id="Debugger_Commands"><a class="selflink" href="#Debugger_Commands">Debugger
  Commands</a></h2>
The interactive debugger understands the following commands:
<dl class="Bl-tag">
  <dt class="It-tag">h</dt>
  <dd class="It-tag">Prints out a summary help message</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">h [command]</dt>
  <dd class="It-tag">Prints out a help message for the given debugger
    command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">h h</dt>
  <dd class="It-tag">The special argument of &quot;h h&quot; produces the entire
      help page, which is quite long.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the output of the &quot;h h&quot; command (or any command, for that
      matter) scrolls past your screen, precede the command with a leading pipe
      symbol so that it's run through your pager, as in
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    DB&gt; |h h
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You may change the pager which is used via &quot;o pager=...&quot;
    command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">p expr</dt>
  <dd class="It-tag">Same as &quot;print {$DB::OUT} expr&quot; in the current
      package. In particular, because this is just Perl's own &quot;print&quot;
      function, this means that nested data structures and objects are not
      dumped, unlike with the &quot;x&quot; command.
    <div style="height: 1.00em;">&#x00A0;</div>
    The &quot;DB::OUT&quot; filehandle is opened to <i>/dev/tty</i>, regardless
      of where STDOUT may be redirected to.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">x [maxdepth] expr</dt>
  <dd class="It-tag">Evaluates its expression in list context and dumps out the
      result in a pretty-printed fashion. Nested data structures are printed out
      recursively, unlike the real &quot;print&quot; function in Perl. When
      dumping hashes, you'll probably prefer 'x \%h' rather than 'x %h'. See
      Dumpvalue if you'd like to do this yourself.
    <div style="height: 1.00em;">&#x00A0;</div>
    The output format is governed by multiple options described under
      &quot;Configurable Options&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the &quot;maxdepth&quot; is included, it must be a numeral <i>N</i>; the
      value is dumped only <i>N</i> levels deep, as if the &quot;dumpDepth&quot;
      option had been temporarily set to <i>N</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">V [pkg [vars]]</dt>
  <dd class="It-tag">Display all (or some) variables in package (defaulting to
      &quot;main&quot;) using a data pretty-printer (hashes show their keys and
      values so you see what's what, control characters are made printable,
      etc.). Make sure you don't put the type specifier (like &quot;$&quot;)
      there, just the symbol names, like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    V DB filename line
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Use &quot;~pattern&quot; and &quot;!pattern&quot; for positive and negative
      regexes.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is similar to calling the &quot;x&quot; command on each applicable
    var.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">X [vars]</dt>
  <dd class="It-tag">Same as &quot;V currentpackage [vars]&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">y [level [vars]]</dt>
  <dd class="It-tag">Display all (or some) lexical variables (mnemonic:
      &quot;mY&quot; variables) in the current scope or <i>level</i> scopes
      higher. You can limit the variables that you see with <i>vars</i> which
      works exactly as it does for the &quot;V&quot; and &quot;X&quot; commands.
      Requires the &quot;PadWalker&quot; module version 0.08 or higher; will
      warn if this isn't installed. Output is pretty-printed in the same style
      as for &quot;V&quot; and the format is controlled by the same
    options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T</dt>
  <dd class="It-tag">Produce a stack backtrace. See below for details on its
      output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">s [expr]</dt>
  <dd class="It-tag">Single step. Executes until the beginning of another
      statement, descending into subroutine calls. If an expression is supplied
      that includes function calls, it too will be single-stepped.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">n [expr]</dt>
  <dd class="It-tag">Next. Executes over subroutine calls, until the beginning
      of the next statement. If an expression is supplied that includes function
      calls, those functions will be executed with stops before each
    statement.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">r</dt>
  <dd class="It-tag">Continue until the return from the current subroutine. Dump
      the return value if the &quot;PrintRet&quot; option is set (default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;CR&gt;</dt>
  <dd class="It-tag">Repeat last &quot;n&quot; or &quot;s&quot; command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">c [line|sub]</dt>
  <dd class="It-tag">Continue, optionally inserting a one-time-only breakpoint
      at the specified line or subroutine.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">l</dt>
  <dd class="It-tag">List next window of lines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">l min+incr</dt>
  <dd class="It-tag">List &quot;incr+1&quot; lines starting at
    &quot;min&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">l min-max</dt>
  <dd class="It-tag">List lines &quot;min&quot; through &quot;max&quot;. &quot;l
      -&quot; is synonymous to &quot;-&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">l line</dt>
  <dd class="It-tag">List a single line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">l subname</dt>
  <dd class="It-tag">List first window of lines from subroutine. <i>subname</i>
      may be a variable that contains a code reference.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">List previous window of lines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">v [line]</dt>
  <dd class="It-tag">View a few lines of code around the current line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">.</dt>
  <dd class="It-tag">Return the internal debugger pointer to the line last
      executed, and print out that line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">f filename</dt>
  <dd class="It-tag">Switch to viewing a different file or &quot;eval&quot;
      statement. If <i>filename</i> is not a full pathname found in the values
      of %INC, it is considered a regex.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;eval&quot;ed strings (when accessible) are considered to be filenames:
      &quot;f (eval 7)&quot; and &quot;f eval 7\b&quot; access the body of the
      7th &quot;eval&quot;ed string (in the order of execution). The bodies of
      the currently executed &quot;eval&quot; and of &quot;eval&quot;ed strings
      that define subroutines are saved and thus accessible.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">/pattern/</dt>
  <dd class="It-tag">Search forwards for pattern (a Perl regex); final / is
      optional. The search is case-insensitive by default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?pattern?</dt>
  <dd class="It-tag">Search backwards for pattern; final ? is optional. The
      search is case-insensitive by default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">L [abw]</dt>
  <dd class="It-tag">List (default all) actions, breakpoints and watch
      expressions</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">S [[!]regex]</dt>
  <dd class="It-tag">List subroutine names [not] matching the regex.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">t [n]</dt>
  <dd class="It-tag">Toggle trace mode (see also the &quot;AutoTrace&quot;
      option). Optional argument is the maximum number of levels to trace below
      the current one; anything deeper than that will be silent.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">t [n] expr</dt>
  <dd class="It-tag">Trace through execution of &quot;expr&quot;. Optional first
      argument is the maximum number of levels to trace below the current one;
      anything deeper than that will be silent. See &quot;Frame Listing Output
      Examples&quot; in perldebguts for examples.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b</dt>
  <dd class="It-tag">Sets breakpoint on current line</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b [line] [condition]</dt>
  <dd class="It-tag">Set a breakpoint before the given line. If a condition is
      specified, it's evaluated each time the statement is reached: a breakpoint
      is taken only if the condition is true. Breakpoints may only be set on
      lines that begin an executable statement. Conditions don't use
      &quot;if&quot;:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    b 237 $x &gt; 30
    b 237 ++$count237 &lt; 11
    b 33 /pattern/i
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If the line number is &quot;.&quot;, sets a breakpoint on the current line:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    b . $n &gt; 100
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b [file]:[line] [condition]</dt>
  <dd class="It-tag">Set a breakpoint before the given line in a (possibly
      different) file. If a condition is specified, it's evaluated each time the
      statement is reached: a breakpoint is taken only if the condition is true.
      Breakpoints may only be set on lines that begin an executable statement.
      Conditions don't use &quot;if&quot;:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    b lib/MyModule.pm:237 $x &gt; 30
    b /usr/lib/perl5/site_perl/CGI.pm:100 ++$count100 &lt; 11
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b subname [condition]</dt>
  <dd class="It-tag">Set a breakpoint before the first line of the named
      subroutine. <i>subname</i> may be a variable containing a code reference
      (in this case <i>condition</i> is not supported).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b postpone subname [condition]</dt>
  <dd class="It-tag">Set a breakpoint at first line of subroutine after it is
      compiled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b load filename</dt>
  <dd class="It-tag">Set a breakpoint before the first executed line of the
      <i>filename</i>, which should be a full pathname found amongst the %INC
      values.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">b compile subname</dt>
  <dd class="It-tag">Sets a breakpoint before the first statement executed after
      the specified subroutine is compiled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">B line</dt>
  <dd class="It-tag">Delete a breakpoint from the specified <i>line</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">B *</dt>
  <dd class="It-tag">Delete all installed breakpoints.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">disable [file]:[line]</dt>
  <dd class="It-tag">Disable the breakpoint so it won't stop the execution of
      the program. Breakpoints are enabled by default and can be re-enabled
      using the &quot;enable&quot; command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">disable [line]</dt>
  <dd class="It-tag">Disable the breakpoint so it won't stop the execution of
      the program. Breakpoints are enabled by default and can be re-enabled
      using the &quot;enable&quot; command.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is done for a breakpoint in the current file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">enable [file]:[line]</dt>
  <dd class="It-tag">Enable the breakpoint so it will stop the execution of the
      program.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">enable [line]</dt>
  <dd class="It-tag">Enable the breakpoint so it will stop the execution of the
      program.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is done for a breakpoint in the current file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">a [line] command</dt>
  <dd class="It-tag">Set an action to be done before the line is executed. If
      <i>line</i> is omitted, set an action on the line about to be executed.
      The sequence of steps taken by the debugger is
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  1. check for a breakpoint at this line
  2. print the line if necessary (tracing)
  3. do any actions associated with that line
  4. prompt user if at a breakpoint or in single-step
  5. evaluate line
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, this will print out $foo every time line 53 is passed:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    a 53 print &quot;DB FOUND $foo\n&quot;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">A line</dt>
  <dd class="It-tag">Delete an action from the specified line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">A *</dt>
  <dd class="It-tag">Delete all installed actions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">w expr</dt>
  <dd class="It-tag">Add a global watch-expression. Whenever a watched global
      changes the debugger will stop and display the old and new values.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">W expr</dt>
  <dd class="It-tag">Delete watch-expression</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">W *</dt>
  <dd class="It-tag">Delete all watch-expressions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">Display all options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o booloption ...</dt>
  <dd class="It-tag">Set each listed Boolean option to the value 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o anyoption? ...</dt>
  <dd class="It-tag">Print out the value of one or more options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o option=value ...</dt>
  <dd class="It-tag">Set the value of one or more options. If the value has
      internal whitespace, it should be quoted. For example, you could set
      &quot;o pager=&quot;less -MQeicsNfr&quot;&quot; to call <b>less</b> with
      those specific options. You may use either single or double quotes, but if
      you do, you must escape any embedded instances of same sort of quote you
      began with, as well as any escaping any escapes that immediately precede
      that quote but which are not meant to escape the quote itself. In other
      words, you follow single-quoting rules irrespective of the quote; eg:
      &quot;o option='this isn\'t bad'&quot; or &quot;o option=&quot;She said,
      \&quot;Isn't it?\&quot;&quot;&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    For historical reasons, the &quot;=value&quot; is optional, but defaults to
      1 only where it is safe to do so--that is, mostly for Boolean options. It
      is always better to assign a specific value using &quot;=&quot;. The
      &quot;option&quot; can be abbreviated, but for clarity probably should not
      be. Several options can be set together. See &quot;Configurable
      Options&quot; for a list of these.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt; ?</dt>
  <dd class="It-tag">List out all pre-prompt Perl command actions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt; [ command ]</dt>
  <dd class="It-tag">Set an action (Perl command) to happen before every
      debugger prompt. A multi-line command may be entered by backslashing the
      newlines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt; *</dt>
  <dd class="It-tag">Delete all pre-prompt Perl command actions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;&lt; command</dt>
  <dd class="It-tag">Add an action (Perl command) to happen before every
      debugger prompt. A multi-line command may be entered by backwhacking the
      newlines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&gt; ?</dt>
  <dd class="It-tag">List out post-prompt Perl command actions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&gt; command</dt>
  <dd class="It-tag">Set an action (Perl command) to happen after the prompt
      when you've just given a command to return to executing the script. A
      multi-line command may be entered by backslashing the newlines (we bet you
      couldn't have guessed this by now).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&gt; *</dt>
  <dd class="It-tag">Delete all post-prompt Perl command actions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&gt;&gt; command</dt>
  <dd class="It-tag">Adds an action (Perl command) to happen after the prompt
      when you've just given a command to return to executing the script. A
      multi-line command may be entered by backslashing the newlines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">{ ?</dt>
  <dd class="It-tag">List out pre-prompt debugger commands.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">{ [ command ]</dt>
  <dd class="It-tag">Set an action (debugger command) to happen before every
      debugger prompt. A multi-line command may be entered in the customary
      fashion.
    <div style="height: 1.00em;">&#x00A0;</div>
    Because this command is in some senses new, a warning is issued if you
      appear to have accidentally entered a block instead. If that's what you
      mean to do, write it as with &quot;;{ ... }&quot; or even &quot;do { ...
      }&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">{ *</dt>
  <dd class="It-tag">Delete all pre-prompt debugger commands.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">{{ command</dt>
  <dd class="It-tag">Add an action (debugger command) to happen before every
      debugger prompt. A multi-line command may be entered, if you can guess
      how: see above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">! number</dt>
  <dd class="It-tag">Redo a previous command (defaults to the previous
    command).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">! -number</dt>
  <dd class="It-tag">Redo number'th previous command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">! pattern</dt>
  <dd class="It-tag">Redo last command that started with pattern. See &quot;o
      recallCommand&quot;, too.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">!! cmd</dt>
  <dd class="It-tag">Run cmd in a subprocess (reads from DB::IN, writes to
      DB::OUT) See &quot;o shellBang&quot;, also. Note that the user's current
      shell (well, their $ENV{SHELL} variable) will be used, which can interfere
      with proper interpretation of exit status or signal and coredump
      information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">source file</dt>
  <dd class="It-tag">Read and execute debugger commands from <i>file</i>.
      <i>file</i> may itself contain &quot;source&quot; commands.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">H -number</dt>
  <dd class="It-tag">Display last n commands. Only commands longer than one
      character are listed. If <i>number</i> is omitted, list them all.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">q or ^D</dt>
  <dd class="It-tag">Quit. (&quot;quit&quot; doesn't work for this, unless
      you've made an alias) This is the only supported way to exit the debugger,
      though typing &quot;exit&quot; twice might work.
    <div style="height: 1.00em;">&#x00A0;</div>
    Set the &quot;inhibit_exit&quot; option to 0 if you want to be able to step
      off the end the script. You may also need to set $finished to 0 if you
      want to step through global destruction.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">R</dt>
  <dd class="It-tag">Restart the debugger by &quot;exec()&quot;ing a new
      session. We try to maintain your history across this, but internal
      settings and command-line options may be lost.
    <div style="height: 1.00em;">&#x00A0;</div>
    The following setting are currently preserved: history, breakpoints,
      actions, debugger options, and the Perl command-line options <b>-w</b>,
      <b>-I</b>, and <b>-e</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">|dbcmd</dt>
  <dd class="It-tag">Run the debugger command, piping DB::OUT into your current
      pager.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">||dbcmd</dt>
  <dd class="It-tag">Same as &quot;|dbcmd&quot; but DB::OUT is temporarily
      &quot;select&quot;ed as well.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">= [alias value]</dt>
  <dd class="It-tag">Define a command alias, like
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    = quit q
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    or list current aliases.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">command</dt>
  <dd class="It-tag">Execute command as a Perl statement. A trailing semicolon
      will be supplied. If the Perl statement would otherwise be confused for a
      Perl debugger, use a leading semicolon, too.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">m expr</dt>
  <dd class="It-tag">List which methods may be called on the result of the
      evaluated expression. The expression may evaluated to a reference to a
      blessed object, or to a package name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">M</dt>
  <dd class="It-tag">Display all loaded modules and their versions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">man [manpage]</dt>
  <dd class="It-tag">Despite its name, this calls your system's default
      documentation viewer on the given page, or on the viewer itself if
      <i>manpage</i> is omitted. If that viewer is <b>man</b>, the current
      &quot;Config&quot; information is used to invoke <b>man</b> using the
      proper MANPATH or <b>-M</b>&#x00A0;<i>manpath</i> option. Failed lookups
      of the form &quot;XXX&quot; that match known manpages of the form
      <i>perlXXX</i> will be retried. This lets you type &quot;man debug&quot;
      or &quot;man op&quot; from the debugger.
    <div style="height: 1.00em;">&#x00A0;</div>
    On systems traditionally bereft of a usable <b>man</b> command, the debugger
      invokes <b>perldoc</b>. Occasionally this determination is incorrect due
      to recalcitrant vendors or rather more felicitously, to enterprising
      users. If you fall into either category, just manually set the $DB::doccmd
      variable to whatever viewer to view the Perl documentation on your system.
      This may be set in an rc file, or through direct assignment. We're still
      waiting for a working example of something along the lines of:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $DB::doccmd = 'netscape -remote http://something.here/';
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="Configurable_Options"><a class="selflink" href="#Configurable_Options">Configurable
  Options</a></h2>
The debugger has numerous options settable using the &quot;o&quot; command,
  either interactively or from the environment or an rc file. (./.perldb or
  ~/.perldb under Unix.)
<dl class="Bl-tag">
  <dt class="It-tag">&quot;recallCommand&quot;, &quot;ShellBang&quot;</dt>
  <dd class="It-tag">The characters used to recall command or spawn shell. By
      default, both are set to &quot;!&quot;, which is unfortunate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;pager&quot;</dt>
  <dd class="It-tag">Program to use for output of pager-piped commands (those
      beginning with a &quot;|&quot; character.) By default, $ENV{PAGER} will be
      used. Because the debugger uses your current terminal characteristics for
      bold and underlining, if the chosen pager does not pass escape sequences
      through unchanged, the output of some debugger commands will not be
      readable when sent through the pager.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;tkRunning&quot;</dt>
  <dd class="It-tag">Run Tk while prompting (with ReadLine).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;signalLevel&quot;, &quot;warnLevel&quot;,
    &quot;dieLevel&quot;</dt>
  <dd class="It-tag">Level of verbosity. By default, the debugger leaves your
      exceptions and warnings alone, because altering them can break correctly
      running programs. It will attempt to print a message when uncaught INT,
      BUS, or SEGV signals arrive. (But see the mention of signals in
      &quot;BUGS&quot; below.)
    <div style="height: 1.00em;">&#x00A0;</div>
    To disable this default safe mode, set these values to something higher than
      0. At a level of 1, you get backtraces upon receiving any kind of warning
      (this is often annoying) or exception (this is often valuable).
      Unfortunately, the debugger cannot discern fatal exceptions from non-fatal
      ones. If &quot;dieLevel&quot; is even 1, then your non-fatal exceptions
      are also traced and unceremoniously altered if they came from
      &quot;eval'ed&quot; strings or from any kind of &quot;eval&quot; within
      modules you're attempting to load. If &quot;dieLevel&quot; is 2, the
      debugger doesn't care where they came from: It usurps your exception
      handler and prints out a trace, then modifies all exceptions with its own
      embellishments. This may perhaps be useful for some tracing purposes, but
      tends to hopelessly destroy any program that takes its exception handling
      seriously.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;AutoTrace&quot;</dt>
  <dd class="It-tag">Trace mode (similar to &quot;t&quot; command, but can be
      put into &quot;PERLDB_OPTS&quot;).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;LineInfo&quot;</dt>
  <dd class="It-tag">File or pipe to print line number info to. If it is a pipe
      (say, &quot;|visual_perl_db&quot;), then a short message is used. This is
      the mechanism used to interact with a slave editor or visual debugger,
      such as the special &quot;vi&quot; or &quot;emacs&quot; hooks, or the
      &quot;ddd&quot; graphical debugger.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;inhibit_exit&quot;</dt>
  <dd class="It-tag">If 0, allows <i>stepping off</i> the end of the
    script.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;PrintRet&quot;</dt>
  <dd class="It-tag">Print return value after &quot;r&quot; command if set
      (default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;ornaments&quot;</dt>
  <dd class="It-tag">Affects screen appearance of the command line (see
      Term::ReadLine). There is currently no way to disable these, which can
      render some output illegible on some displays, or with some pagers. This
      is considered a bug.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;frame&quot;</dt>
  <dd class="It-tag">Affects the printing of messages upon entry and exit from
      subroutines. If &quot;frame &amp; 2&quot; is false, messages are printed
      on entry only. (Printing on exit might be useful if interspersed with
      other messages.)
    <div style="height: 1.00em;">&#x00A0;</div>
    If &quot;frame &amp; 4&quot;, arguments to functions are printed, plus
      context and caller info. If &quot;frame &amp; 8&quot;, overloaded
      &quot;stringify&quot; and &quot;tie&quot;d &quot;FETCH&quot; is enabled on
      the printed arguments. If &quot;frame &amp; 16&quot;, the return value
      from the subroutine is printed.
    <div style="height: 1.00em;">&#x00A0;</div>
    The length at which the argument list is truncated is governed by the next
      option:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;maxTraceLen&quot;</dt>
  <dd class="It-tag">Length to truncate the argument list when the
      &quot;frame&quot; option's bit 4 is set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;windowSize&quot;</dt>
  <dd class="It-tag">Change the size of code list window (default is 10
    lines).</dd>
</dl>
<div class="Pp"></div>
The following options affect what happens with &quot;V&quot;, &quot;X&quot;, and
  &quot;x&quot; commands:
<dl class="Bl-tag">
  <dt class="It-tag">&quot;arrayDepth&quot;, &quot;hashDepth&quot;</dt>
  <dd class="It-tag">Print only first N elements ('' for all).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;dumpDepth&quot;</dt>
  <dd class="It-tag">Limit recursion depth to N levels when dumping structures.
      Negative values are interpreted as infinity. Default: infinity.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;compactDump&quot;, &quot;veryCompact&quot;</dt>
  <dd class="It-tag">Change the style of array and hash output. If
      &quot;compactDump&quot;, short array may be printed on one line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;globPrint&quot;</dt>
  <dd class="It-tag">Whether to print contents of globs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;DumpDBFiles&quot;</dt>
  <dd class="It-tag">Dump arrays holding debugged files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;DumpPackages&quot;</dt>
  <dd class="It-tag">Dump symbol tables of packages.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;DumpReused&quot;</dt>
  <dd class="It-tag">Dump contents of &quot;reused&quot; addresses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;quote&quot;, &quot;HighBit&quot;,
    &quot;undefPrint&quot;</dt>
  <dd class="It-tag">Change the style of string dump. The default value for
      &quot;quote&quot; is &quot;auto&quot;; one can enable double-quotish or
      single-quotish format by setting it to &quot;&quot;&quot; or
      &quot;'&quot;, respectively. By default, characters with their high bit
      set are printed verbatim.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;UsageOnly&quot;</dt>
  <dd class="It-tag">Rudimentary per-package memory usage dump. Calculates total
      size of strings found in variables in the package. This does not include
      lexicals in a module's file scope, or lost in closures.</dd>
</dl>
<div class="Pp"></div>
After the rc file is read, the debugger reads the $ENV{PERLDB_OPTS} environment
  variable and parses this as the remainder of a &quot;O ...&quot; line as one
  might enter at the debugger prompt. You may place the initialization options
  &quot;TTY&quot;, &quot;noTTY&quot;, &quot;ReadLine&quot;, and
  &quot;NonStop&quot; there.
<div class="Pp"></div>
If your rc file contains:
<div class="Pp"></div>
<pre>
  parse_options(&quot;NonStop=1 LineInfo=db.out AutoTrace&quot;);
</pre>
<div class="Pp"></div>
then your script will run without human intervention, putting trace information
  into the file <i>db.out</i>. (If you interrupt it, you'd better reset
  &quot;LineInfo&quot; to <i>/dev/tty</i> if you expect to see anything.)
<dl class="Bl-tag">
  <dt class="It-tag">&quot;TTY&quot;</dt>
  <dd class="It-tag">The TTY to use for debugging I/O.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;noTTY&quot;</dt>
  <dd class="It-tag">If set, the debugger goes into &quot;NonStop&quot; mode and
      will not connect to a TTY. If interrupted (or if control goes to the
      debugger via explicit setting of $DB::signal or $DB::single from the Perl
      script), it connects to a TTY specified in the &quot;TTY&quot; option at
      startup, or to a tty found at runtime using the
      &quot;Term::Rendezvous&quot; module of your choice.
    <div style="height: 1.00em;">&#x00A0;</div>
    This module should implement a method named &quot;new&quot; that returns an
      object with two methods: &quot;IN&quot; and &quot;OUT&quot;. These should
      return filehandles to use for debugging input and output correspondingly.
      The &quot;new&quot; method should inspect an argument containing the value
      of $ENV{PERLDB_NOTTY} at startup, or &quot;$ENV{HOME}/.perldbtty$$&quot;
      otherwise. This file is not inspected for proper ownership, so security
      hazards are theoretically possible.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;ReadLine&quot;</dt>
  <dd class="It-tag">If false, readline support in the debugger is disabled in
      order to debug applications that themselves use ReadLine.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;NonStop&quot;</dt>
  <dd class="It-tag">If set, the debugger goes into non-interactive mode until
      interrupted, or programmatically by setting $DB::signal or
    $DB::single.</dd>
</dl>
<div class="Pp"></div>
Here's an example of using the $ENV{PERLDB_OPTS} variable:
<div class="Pp"></div>
<pre>
    $ PERLDB_OPTS=&quot;NonStop frame=2&quot; perl -d myprogram
</pre>
<div class="Pp"></div>
That will run the script <b>myprogram</b> without human intervention, printing
  out the call tree with entry and exit points. Note that &quot;NonStop=1
  frame=2&quot; is equivalent to &quot;N f=2&quot;, and that originally, options
  could be uniquely abbreviated by the first letter (modulo the
  &quot;Dump*&quot; options). It is nevertheless recommended that you always
  spell them out in full for legibility and future compatibility.
<div class="Pp"></div>
Other examples include
<div class="Pp"></div>
<pre>
    $ PERLDB_OPTS=&quot;NonStop LineInfo=listing frame=2&quot; perl -d myprogram
</pre>
<div class="Pp"></div>
which runs script non-interactively, printing info on each entry into a
  subroutine and each executed line into the file named <i>listing</i>. (If you
  interrupt it, you would better reset &quot;LineInfo&quot; to something
  &quot;interactive&quot;!)
<div class="Pp"></div>
Other examples include (using standard shell syntax to show environment variable
  settings):
<div class="Pp"></div>
<pre>
  $ ( PERLDB_OPTS=&quot;NonStop frame=1 AutoTrace LineInfo=tperl.out&quot;
      perl -d myprogram )
</pre>
<div class="Pp"></div>
which may be useful for debugging a program that uses &quot;Term::ReadLine&quot;
  itself. Do not forget to detach your shell from the TTY in the window that
  corresponds to <i>/dev/ttyXX</i>, say, by issuing a command like
<div class="Pp"></div>
<pre>
  $ sleep 1000000
</pre>
<div class="Pp"></div>
See &quot;Debugger Internals&quot; in perldebguts for details.
<h2 class="Ss" title="Ss" id="Debugger_Input/Output"><a class="selflink" href="#Debugger_Input/Output">Debugger
  Input/Output</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">Prompt</dt>
  <dd class="It-tag">The debugger prompt is something like
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    DB&lt;8&gt;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    or even
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    DB&lt;&lt;17&gt;&gt;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    where that number is the command number, and which you'd use to access with
      the built-in <b>csh</b>-like history mechanism. For example,
      &quot;!17&quot; would repeat command number 17. The depth of the angle
      brackets indicates the nesting depth of the debugger. You could get more
      than one set of brackets, for example, if you'd already at a breakpoint
      and then printed the result of a function call that itself has a
      breakpoint, or you step into an expression via &quot;s/n/t
      expression&quot; command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Multiline commands</dt>
  <dd class="It-tag">If you want to enter a multi-line command, such as a
      subroutine definition with several statements or a format, escape the
      newline that would normally end the debugger command with a backslash.
      Here's an example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
      DB&lt;1&gt; for (1..4) {         \
      cont:     print &quot;ok\n&quot;;   \
      cont: }
      ok
      ok
      ok
      ok
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that this business of escaping a newline is specific to interactive
      commands typed into the debugger.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Stack backtrace</dt>
  <dd class="It-tag">Here's an example of what a stack backtrace via
      &quot;T&quot; command might look like:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $ = main::infested called from file 'Ambulation.pm' line 10
    @ = Ambulation::legs(1, 2, 3, 4) called from file 'camel_flea' line 7
    $ = main::pests('bactrian', 4) called from file 'camel_flea' line 4
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The left-hand character up there indicates the context in which the function
      was called, with &quot;$&quot; and &quot;@&quot; meaning scalar or list
      contexts respectively, and &quot;.&quot; meaning void context (which is
      actually a sort of scalar context). The display above says that you were
      in the function &quot;main::infested&quot; when you ran the stack dump,
      and that it was called in scalar context from line 10 of the file
      <i>Ambulation.pm</i>, but without any arguments at all, meaning it was
      called as &amp;infested. The next stack frame shows that the function
      &quot;Ambulation::legs&quot; was called in list context from the
      <i>camel_flea</i> file with four arguments. The last stack frame shows
      that &quot;main::pests&quot; was called in scalar context, also from
      <i>camel_flea</i>, but from line 4.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you execute the &quot;T&quot; command from inside an active
      &quot;use&quot; statement, the backtrace will contain both a
      &quot;require&quot; frame and an &quot;eval&quot; frame.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Line Listing Format</dt>
  <dd class="It-tag">This shows the sorts of output the &quot;l&quot; command
      can produce:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    DB&lt;&lt;13&gt;&gt; l
  101:                @i{@i} = ();
  102:b               @isa{@i,$pack} = ()
  103                     if(exists $i{$prevpack} || exists $isa{$pack});
  104             }
  105
  106             next
  107==&gt;              if(exists $isa{$pack});
  108
  109:a           if ($extra-- &gt; 0) {
  110:                %isa = ($pack,1);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Breakable lines are marked with &quot;:&quot;. Lines with breakpoints are
      marked by &quot;b&quot; and those with actions by &quot;a&quot;. The line
      that's about to be executed is marked by &quot;==&gt;&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Please be aware that code in debugger listings may not look the same as your
      original source code. Line directives and external source filters can
      alter the code before Perl sees it, causing code to move from its original
      positions or take on entirely different forms.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Frame listing</dt>
  <dd class="It-tag">When the &quot;frame&quot; option is set, the debugger
      would print entered (and optionally exited) subroutines in different
      styles. See perldebguts for incredibly long examples of these.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Debugging_Compile-Time_Statements"><a class="selflink" href="#Debugging_Compile-Time_Statements">Debugging
  Compile-Time Statements</a></h2>
If you have compile-time executable statements (such as code within BEGIN,
  UNITCHECK and CHECK blocks or &quot;use&quot; statements), these will
  <i>not</i> be stopped by debugger, although &quot;require&quot;s and INIT
  blocks will, and compile-time statements can be traced with the
  &quot;AutoTrace&quot; option set in &quot;PERLDB_OPTS&quot;). From your own
  Perl code, however, you can transfer control back to the debugger using the
  following statement, which is harmless if the debugger is not running:
<div class="Pp"></div>
<pre>
    $DB::single = 1;
</pre>
<div class="Pp"></div>
If you set $DB::single to 2, it's equivalent to having just typed the
  &quot;n&quot; command, whereas a value of 1 means the &quot;s&quot; command.
  The $DB::trace variable should be set to 1 to simulate having typed the
  &quot;t&quot; command.
<div class="Pp"></div>
Another way to debug compile-time code is to start the debugger, set a
  breakpoint on the <i>load</i> of some module:
<div class="Pp"></div>
<pre>
    DB&lt;7&gt; b load f:/perllib/lib/Carp.pm
  Will stop on load of 'f:/perllib/lib/Carp.pm'.
</pre>
<div class="Pp"></div>
and then restart the debugger using the &quot;R&quot; command (if possible). One
  can use &quot;b compile subname&quot; for the same purpose.
<h2 class="Ss" title="Ss" id="Debugger_Customization"><a class="selflink" href="#Debugger_Customization">Debugger
  Customization</a></h2>
The debugger probably contains enough configuration hooks that you won't ever
  have to modify it yourself. You may change the behaviour of the debugger from
  within the debugger using its &quot;o&quot; command, from the command line via
  the &quot;PERLDB_OPTS&quot; environment variable, and from customization
  files.
<div class="Pp"></div>
You can do some customization by setting up a <i>.perldb</i> file, which
  contains initialization code. For instance, you could make aliases like these
  (the last one is one people expect to be there):
<div class="Pp"></div>
<pre>
    $DB::alias{'len'}  = 's/^len(.*)/p length($1)/';
    $DB::alias{'stop'} = 's/^stop (at|in)/b/';
    $DB::alias{'ps'}   = 's/^ps\b/p scalar /';
    $DB::alias{'quit'} = 's/^quit(\s*)/exit/';
</pre>
<div class="Pp"></div>
You can change options from <i>.perldb</i> by using calls like this one;
<div class="Pp"></div>
<pre>
    parse_options(&quot;NonStop=1 LineInfo=db.out AutoTrace=1 frame=2&quot;);
</pre>
<div class="Pp"></div>
The code is executed in the package &quot;DB&quot;. Note that <i>.perldb</i> is
  processed before processing &quot;PERLDB_OPTS&quot;. If <i>.perldb</i> defines
  the subroutine &quot;afterinit&quot;, that function is called after debugger
  initialization ends. <i>.perldb</i> may be contained in the current directory,
  or in the home directory. Because this file is sourced in by Perl and may
  contain arbitrary commands, for security reasons, it must be owned by the
  superuser or the current user, and writable by no one but its owner.
<div class="Pp"></div>
You can mock TTY input to debugger by adding arbitrary commands to
  @DB::typeahead. For example, your <i>.perldb</i> file might contain:
<div class="Pp"></div>
<pre>
    sub afterinit { push @DB::typeahead, &quot;b 4&quot;, &quot;b 6&quot;; }
</pre>
<div class="Pp"></div>
Which would attempt to set breakpoints on lines 4 and 6 immediately after
  debugger initialization. Note that @DB::typeahead is not a supported interface
  and is subject to change in future releases.
<div class="Pp"></div>
If you want to modify the debugger, copy <i>perl5db.pl</i> from the Perl library
  to another name and hack it to your heart's content. You'll then want to set
  your &quot;PERL5DB&quot; environment variable to say something like this:
<div class="Pp"></div>
<pre>
    BEGIN { require &quot;myperl5db.pl&quot; }
</pre>
<div class="Pp"></div>
As a last resort, you could also use &quot;PERL5DB&quot; to customize the
  debugger by directly setting internal variables or calling debugger functions.
<div class="Pp"></div>
Note that any variables and functions that are not documented in this document
  (or in perldebguts) are considered for internal use only, and as such are
  subject to change without notice.
<h2 class="Ss" title="Ss" id="Readline_Support_/_History_in_the_Debugger"><a class="selflink" href="#Readline_Support_/_History_in_the_Debugger">Readline
  Support / History in the Debugger</a></h2>
As shipped, the only command-line history supplied is a simplistic one that
  checks for leading exclamation points. However, if you install the
  Term::ReadKey and Term::ReadLine modules from CPAN (such as
  Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will have full editing
  capabilities much like those GNU <i>readline</i>(3) provides. Look for these
  in the <i>modules/by-module/Term</i> directory on CPAN. These do not support
  normal <b>vi</b> command-line editing, however.
<div class="Pp"></div>
A rudimentary command-line completion is also available, including lexical
  variables in the current scope if the &quot;PadWalker&quot; module is
  installed.
<div class="Pp"></div>
Without Readline support you may see the symbols &quot;^[[A&quot;,
  &quot;^[[C&quot;, &quot;^[[B&quot;, &quot;^[[D&quot;&quot;, &quot;^H&quot;,
  ... when using the arrow keys and/or the backspace key.
<h2 class="Ss" title="Ss" id="Editor_Support_for_Debugging"><a class="selflink" href="#Editor_Support_for_Debugging">Editor
  Support for Debugging</a></h2>
If you have the FSF's version of <b>emacs</b> installed on your system, it can
  interact with the Perl debugger to provide an integrated software development
  environment reminiscent of its interactions with C debuggers.
<div class="Pp"></div>
Recent versions of Emacs come with a start file for making <b>emacs</b> act like
  a syntax-directed editor that understands (some of) Perl's syntax. See
  perlfaq3.
<div class="Pp"></div>
A similar setup by Tom Christiansen for interacting with any vendor-shipped
  <b>vi</b> and the X11 window system is also available. This works similarly to
  the integrated multiwindow support that <b>emacs</b> provides, where the
  debugger drives the editor. At the time of this writing, however, that tool's
  eventual location in the Perl distribution was uncertain.
<div class="Pp"></div>
Users of <b>vi</b> should also look into <b>vim</b> and <b>gvim</b>, the mousey
  and windy version, for coloring of Perl keywords.
<div class="Pp"></div>
Note that only perl can truly parse Perl, so all such CASE tools fall somewhat
  short of the mark, especially if you don't program your Perl as a C programmer
  might.
<h2 class="Ss" title="Ss" id="The_Perl_Profiler"><a class="selflink" href="#The_Perl_Profiler">The
  Perl Profiler</a></h2>
If you wish to supply an alternative debugger for Perl to run, invoke your
  script with a colon and a package argument given to the <b>-d</b> flag. Perl's
  alternative debuggers include a Perl profiler, Devel::NYTProf, which is
  available separately as a CPAN distribution. To profile your Perl program in
  the file <i>mycode.pl</i>, just type:
<div class="Pp"></div>
<pre>
    $ perl -d:NYTProf mycode.pl
</pre>
<div class="Pp"></div>
When the script terminates the profiler will create a database of the profile
  information that you can turn into reports using the profiler's tools. See
  &lt;perlperf&gt; for details.
<h1 class="Sh" title="Sh" id="Debugging_Regular_Expressions"><a class="selflink" href="#Debugging_Regular_Expressions">Debugging
  Regular Expressions</a></h1>
&quot;use re 'debug'&quot; enables you to see the gory details of how the Perl
  regular expression engine works. In order to understand this typically
  voluminous output, one must not only have some idea about how regular
  expression matching works in general, but also know how Perl's regular
  expressions are internally compiled into an automaton. These matters are
  explored in some detail in &quot;Debugging Regular Expressions&quot; in
  perldebguts.
<h1 class="Sh" title="Sh" id="Debugging_Memory_Usage"><a class="selflink" href="#Debugging_Memory_Usage">Debugging
  Memory Usage</a></h1>
Perl contains internal support for reporting its own memory usage, but this is a
  fairly advanced concept that requires some understanding of how memory
  allocation works. See &quot;Debugging Perl Memory Usage&quot; in perldebguts
  for the details.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
You did try the <b>-w</b> switch, didn't you?
<div class="Pp"></div>
perldebtut, perldebguts, re, DB, Devel::NYTProf, Dumpvalue, and perlrun.
<div class="Pp"></div>
When debugging a script that uses #! and is thus normally found in $PATH, the -S
  option causes perl to search $PATH for it, so you don't have to type the path
  or &quot;which $scriptname&quot;.
<div class="Pp"></div>
<pre>
  $ perl -Sd foo.pl
</pre>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
You cannot get stack frame information or in any fashion debug functions that
  were not compiled by Perl, such as those from C or C++ extensions.
<div class="Pp"></div>
If you alter your @_ arguments in a subroutine (such as with &quot;shift&quot;
  or &quot;pop&quot;), the stack backtrace will not show the original values.
<div class="Pp"></div>
The debugger does not currently work in conjunction with the <b>-W</b>
  command-line switch, because it itself is not free of warnings.
<div class="Pp"></div>
If you're in a slow syscall (like &quot;wait&quot;ing, &quot;accept&quot;ing, or
  &quot;read&quot;ing from your keyboard or a socket) and haven't set up your
  own $SIG{INT} handler, then you won't be able to CTRL-C your way back to the
  debugger, because the debugger's own $SIG{INT} handler doesn't understand that
  it needs to raise an exception to <i>longjmp</i>(3) out of slow
  syscalls.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
