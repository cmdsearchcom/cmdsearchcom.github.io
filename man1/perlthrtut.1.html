<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLTHRTUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLTHRTUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLTHRTUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlthrtut - Tutorial on threads in Perl
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This tutorial describes the use of Perl interpreter threads (sometimes referred
  to as <i>ithreads</i>) that was first introduced in Perl 5.6.0. In this model,
  each thread runs in its own Perl interpreter, and any data sharing between
  threads must be explicit. The user-level interface for <i>ithreads</i> uses
  the threads class.
<div class="Pp"></div>
<b>NOTE</b>: There was another older Perl threading flavor called the 5.005
  model that used the threads class. This old model was known to have problems,
  is deprecated, and was removed for release 5.10. You are strongly encouraged
  to migrate any existing 5.005 threads code to the new model as soon as
  possible.
<div class="Pp"></div>
You can see which (or neither) threading flavour you have by running &quot;perl
  -V&quot; and looking at the &quot;Platform&quot; section. If you have
  &quot;useithreads=define&quot; you have ithreads, if you have
  &quot;use5005threads=define&quot; you have 5.005 threads. If you have neither,
  you don't have any thread support built in. If you have both, you are in
  trouble.
<div class="Pp"></div>
The threads and threads::shared modules are included in the core Perl
  distribution. Additionally, they are maintained as a separate modules on CPAN,
  so you can check there for any updates.
<h1 class="Sh" title="Sh" id="What_Is_A_Thread_Anyway?"><a class="selflink" href="#What_Is_A_Thread_Anyway?">What
  Is A Thread Anyway?</a></h1>
A thread is a flow of control through a program with a single execution point.
<div class="Pp"></div>
Sounds an awful lot like a process, doesn't it? Well, it should. Threads are one
  of the pieces of a process. Every process has at least one thread and, up
  until now, every process running Perl had only one thread. With 5.8, though,
  you can create extra threads. We're going to show you how, when, and why.
<h1 class="Sh" title="Sh" id="Threaded_Program_Models"><a class="selflink" href="#Threaded_Program_Models">Threaded
  Program Models</a></h1>
There are three basic ways that you can structure a threaded program. Which
  model you choose depends on what you need your program to do. For many
  non-trivial threaded programs, you'll need to choose different models for
  different pieces of your program.
<h2 class="Ss" title="Ss" id="Boss/Worker"><a class="selflink" href="#Boss/Worker">Boss/Worker</a></h2>
The boss/worker model usually has one <i>boss</i> thread and one or more
  <i>worker</i> threads. The boss thread gathers or generates tasks that need to
  be done, then parcels those tasks out to the appropriate worker thread.
<div class="Pp"></div>
This model is common in GUI and server programs, where a main thread waits for
  some event and then passes that event to the appropriate worker threads for
  processing. Once the event has been passed on, the boss thread goes back to
  waiting for another event.
<div class="Pp"></div>
The boss thread does relatively little work. While tasks aren't necessarily
  performed faster than with any other method, it tends to have the best
  user-response times.
<h2 class="Ss" title="Ss" id="Work_Crew"><a class="selflink" href="#Work_Crew">Work
  Crew</a></h2>
In the work crew model, several threads are created that do essentially the same
  thing to different pieces of data. It closely mirrors classical parallel
  processing and vector processors, where a large array of processors do the
  exact same thing to many pieces of data.
<div class="Pp"></div>
This model is particularly useful if the system running the program will
  distribute multiple threads across different processors. It can also be useful
  in ray tracing or rendering engines, where the individual threads can pass on
  interim results to give the user visual feedback.
<h2 class="Ss" title="Ss" id="Pipeline"><a class="selflink" href="#Pipeline">Pipeline</a></h2>
The pipeline model divides up a task into a series of steps, and passes the
  results of one step on to the thread processing the next. Each thread does one
  thing to each piece of data and passes the results to the next thread in line.
<div class="Pp"></div>
This model makes the most sense if you have multiple processors so two or more
  threads will be executing in parallel, though it can often make sense in other
  contexts as well. It tends to keep the individual tasks small and simple, as
  well as allowing some parts of the pipeline to block (on I/O or system calls,
  for example) while other parts keep going. If you're running different parts
  of the pipeline on different processors you may also take advantage of the
  caches on each processor.
<div class="Pp"></div>
This model is also handy for a form of recursive programming where, rather than
  having a subroutine call itself, it instead creates another thread. Prime and
  Fibonacci generators both map well to this form of the pipeline model. (A
  version of a prime number generator is presented later on.)
<h1 class="Sh" title="Sh" id="What_kind_of_threads_are_Perl_threads?"><a class="selflink" href="#What_kind_of_threads_are_Perl_threads?">What
  kind of threads are Perl threads?</a></h1>
If you have experience with other thread implementations, you might find that
  things aren't quite what you expect. It's very important to remember when
  dealing with Perl threads that <i>Perl Threads Are Not X</i> <i>Threads</i>
  for all values of X. They aren't POSIX threads, or DecThreads, or Java's Green
  threads, or Win32 threads. There are similarities, and the broad concepts are
  the same, but if you start looking for implementation details you're going to
  be either disappointed or confused. Possibly both.
<div class="Pp"></div>
This is not to say that Perl threads are completely different from everything
  that's ever come before. They're not. Perl's threading model owes a lot to
  other thread models, especially POSIX. Just as Perl is not C, though, Perl
  threads are not POSIX threads. So if you find yourself looking for mutexes, or
  thread priorities, it's time to step back a bit and think about what you want
  to do and how Perl can do it.
<div class="Pp"></div>
However, it is important to remember that Perl threads cannot magically do
  things unless your operating system's threads allow it. So if your system
  blocks the entire process on &quot;sleep()&quot;, Perl usually will, as well.
<div class="Pp"></div>
<b>Perl Threads Are Different.</b>
<h1 class="Sh" title="Sh" id="Thread-Safe_Modules"><a class="selflink" href="#Thread-Safe_Modules">Thread-Safe
  Modules</a></h1>
The addition of threads has changed Perl's internals substantially. There are
  implications for people who write modules with XS code or external libraries.
  However, since Perl data is not shared among threads by default, Perl modules
  stand a high chance of being thread-safe or can be made thread-safe easily.
  Modules that are not tagged as thread-safe should be tested or code reviewed
  before being used in production code.
<div class="Pp"></div>
Not all modules that you might use are thread-safe, and you should always assume
  a module is unsafe unless the documentation says otherwise. This includes
  modules that are distributed as part of the core. Threads are a relatively new
  feature, and even some of the standard modules aren't thread-safe.
<div class="Pp"></div>
Even if a module is thread-safe, it doesn't mean that the module is optimized to
  work well with threads. A module could possibly be rewritten to utilize the
  new features in threaded Perl to increase performance in a threaded
  environment.
<div class="Pp"></div>
If you're using a module that's not thread-safe for some reason, you can protect
  yourself by using it from one, and only one thread at all. If you need
  multiple threads to access such a module, you can use semaphores and lots of
  programming discipline to control access to it. Semaphores are covered in
  &quot;Basic semaphores&quot;.
<div class="Pp"></div>
See also &quot;Thread-Safety of System Libraries&quot;.
<h1 class="Sh" title="Sh" id="Thread_Basics"><a class="selflink" href="#Thread_Basics">Thread
  Basics</a></h1>
The threads module provides the basic functions you need to write threaded
  programs. In the following sections, we'll cover the basics, showing you what
  you need to do to create a threaded program. After that, we'll go over some of
  the features of the threads module that make threaded programming easier.
<h2 class="Ss" title="Ss" id="Basic_Thread_Support"><a class="selflink" href="#Basic_Thread_Support">Basic
  Thread Support</a></h2>
Thread support is a Perl compile-time option. It's something that's turned on or
  off when Perl is built at your site, rather than when your programs are
  compiled. If your Perl wasn't compiled with thread support enabled, then any
  attempt to use threads will fail.
<div class="Pp"></div>
Your programs can use the Config module to check whether threads are enabled. If
  your program can't run without them, you can say something like:
<div class="Pp"></div>
<pre>
    use Config;
    $Config{useithreads} or die('Recompile Perl with threads to run this program.');
</pre>
<div class="Pp"></div>
A possibly-threaded program using a possibly-threaded module might have code
  like this:
<div class="Pp"></div>
<pre>
    use Config;
    use MyMod;
    BEGIN {
        if ($Config{useithreads}) {
            # We have threads
            require MyMod_threaded;
            import MyMod_threaded;
        } else {
            require MyMod_unthreaded;
            import MyMod_unthreaded;
        }
    }
</pre>
<div class="Pp"></div>
Since code that runs both with and without threads is usually pretty messy, it's
  best to isolate the thread-specific code in its own module. In our example
  above, that's what &quot;MyMod_threaded&quot; is, and it's only imported if
  we're running on a threaded Perl.
<h2 class="Ss" title="Ss" id="A_Note_about_the_Examples"><a class="selflink" href="#A_Note_about_the_Examples">A
  Note about the Examples</a></h2>
In a real situation, care should be taken that all threads are finished
  executing before the program exits. That care has <b>not</b> been taken in
  these examples in the interest of simplicity. Running these examples <i>as
  is</i> will produce error messages, usually caused by the fact that there are
  still threads running when the program exits. You should not be alarmed by
  this.
<h2 class="Ss" title="Ss" id="Creating_Threads"><a class="selflink" href="#Creating_Threads">Creating
  Threads</a></h2>
The threads module provides the tools you need to create new threads. Like any
  other module, you need to tell Perl that you want to use it; &quot;use
  threads;&quot; imports all the pieces you need to create basic threads.
<div class="Pp"></div>
The simplest, most straightforward way to create a thread is with
  &quot;create()&quot;:
<div class="Pp"></div>
<pre>
    use threads;
    my $thr = threads-&gt;create(\&amp;sub1);
    sub sub1 {
        print(&quot;In the thread\n&quot;);
    }
</pre>
<div class="Pp"></div>
The &quot;create()&quot; method takes a reference to a subroutine and creates a
  new thread that starts executing in the referenced subroutine. Control then
  passes both to the subroutine and the caller.
<div class="Pp"></div>
If you need to, your program can pass parameters to the subroutine as part of
  the thread startup. Just include the list of parameters as part of the
  &quot;threads-&gt;create()&quot; call, like this:
<div class="Pp"></div>
<pre>
    use threads;
    my $Param3 = 'foo';
    my $thr1 = threads-&gt;create(\&amp;sub1, 'Param 1', 'Param 2', $Param3);
    my @ParamList = (42, 'Hello', 3.14);
    my $thr2 = threads-&gt;create(\&amp;sub1, @ParamList);
    my $thr3 = threads-&gt;create(\&amp;sub1, qw(Param1 Param2 Param3));
    sub sub1 {
        my @InboundParameters = @_;
        print(&quot;In the thread\n&quot;);
        print('Got parameters &gt;', join('&lt;&gt;', @InboundParameters), &quot;&lt;\n&quot;);
    }
</pre>
<div class="Pp"></div>
The last example illustrates another feature of threads. You can spawn off
  several threads using the same subroutine. Each thread executes the same
  subroutine, but in a separate thread with a separate environment and
  potentially separate arguments.
<div class="Pp"></div>
&quot;new()&quot; is a synonym for &quot;create()&quot;.
<h2 class="Ss" title="Ss" id="Waiting_For_A_Thread_To_Exit"><a class="selflink" href="#Waiting_For_A_Thread_To_Exit">Waiting
  For A Thread To Exit</a></h2>
Since threads are also subroutines, they can return values. To wait for a thread
  to exit and extract any values it might return, you can use the
  &quot;join()&quot; method:
<div class="Pp"></div>
<pre>
    use threads;
    my ($thr) = threads-&gt;create(\&amp;sub1);
    my @ReturnData = $thr-&gt;join();
    print('Thread returned ', join(', ', @ReturnData), &quot;\n&quot;);
    sub sub1 { return ('Fifty-six', 'foo', 2); }
</pre>
<div class="Pp"></div>
In the example above, the &quot;join()&quot; method returns as soon as the
  thread ends. In addition to waiting for a thread to finish and gathering up
  any values that the thread might have returned, &quot;join()&quot; also
  performs any OS cleanup necessary for the thread. That cleanup might be
  important, especially for long-running programs that spawn lots of threads. If
  you don't want the return values and don't want to wait for the thread to
  finish, you should call the &quot;detach()&quot; method instead, as described
  next.
<div class="Pp"></div>
NOTE: In the example above, the thread returns a list, thus necessitating that
  the thread creation call be made in list context (i.e., &quot;my
  ($thr)&quot;). See &quot;$thr-&gt; <i>join()</i>&quot; in threads and
  &quot;THREAD CONTEXT&quot; in threads for more details on thread context and
  return values.
<h2 class="Ss" title="Ss" id="Ignoring_A_Thread"><a class="selflink" href="#Ignoring_A_Thread">Ignoring
  A Thread</a></h2>
&quot;join()&quot; does three things: it waits for a thread to exit, cleans up
  after it, and returns any data the thread may have produced. But what if
  you're not interested in the thread's return values, and you don't really care
  when the thread finishes? All you want is for the thread to get cleaned up
  after when it's done.
<div class="Pp"></div>
In this case, you use the &quot;detach()&quot; method. Once a thread is
  detached, it'll run until it's finished; then Perl will clean up after it
  automatically.
<div class="Pp"></div>
<pre>
    use threads;
    my $thr = threads-&gt;create(\&amp;sub1);   # Spawn the thread
    $thr-&gt;detach();   # Now we officially don't care any more
    sleep(15);        # Let thread run for awhile
    sub sub1 {
        $a = 0;
        while (1) {
            $a++;
            print(&quot;\$a is $a\n&quot;);
            sleep(1);
        }
    }
</pre>
<div class="Pp"></div>
Once a thread is detached, it may not be joined, and any return data that it
  might have produced (if it was done and waiting for a join) is lost.
<div class="Pp"></div>
&quot;detach()&quot; can also be called as a class method to allow a thread to
  detach itself:
<div class="Pp"></div>
<pre>
    use threads;
    my $thr = threads-&gt;create(\&amp;sub1);
    sub sub1 {
        threads-&gt;detach();
        # Do more work
    }
</pre>
<h2 class="Ss" title="Ss" id="Process_and_Thread_Termination"><a class="selflink" href="#Process_and_Thread_Termination">Process
  and Thread Termination</a></h2>
With threads one must be careful to make sure they all have a chance to run to
  completion, assuming that is what you want.
<div class="Pp"></div>
An action that terminates a process will terminate <i>all</i> running threads.
  <i>die()</i> and <i>exit()</i> have this property, and perl does an exit when
  the main thread exits, perhaps implicitly by falling off the end of your code,
  even if that's not what you want.
<div class="Pp"></div>
As an example of this case, this code prints the message &quot;Perl exited with
  active threads: 2 running and unjoined&quot;:
<div class="Pp"></div>
<pre>
    use threads;
    my $thr1 = threads-&gt;new(\&amp;thrsub, &quot;test1&quot;);
    my $thr2 = threads-&gt;new(\&amp;thrsub, &quot;test2&quot;);
    sub thrsub {
       my ($message) = @_;
       sleep 1;
       print &quot;thread $message\n&quot;;
    }
</pre>
<div class="Pp"></div>
But when the following lines are added at the end:
<div class="Pp"></div>
<pre>
    $thr1-&gt;join();
    $thr2-&gt;join();
</pre>
<div class="Pp"></div>
it prints two lines of output, a perhaps more useful outcome.
<h1 class="Sh" title="Sh" id="Threads_And_Data"><a class="selflink" href="#Threads_And_Data">Threads
  And Data</a></h1>
Now that we've covered the basics of threads, it's time for our next topic:
  Data. Threading introduces a couple of complications to data access that
  non-threaded programs never need to worry about.
<h2 class="Ss" title="Ss" id="Shared_And_Unshared_Data"><a class="selflink" href="#Shared_And_Unshared_Data">Shared
  And Unshared Data</a></h2>
The biggest difference between Perl <i>ithreads</i> and the old 5.005 style
  threading, or for that matter, to most other threading systems out there, is
  that by default, no data is shared. When a new Perl thread is created, all the
  data associated with the current thread is copied to the new thread, and is
  subsequently private to that new thread! This is similar in feel to what
  happens when a Unix process forks, except that in this case, the data is just
  copied to a different part of memory within the same process rather than a
  real fork taking place.
<div class="Pp"></div>
To make use of threading, however, one usually wants the threads to share at
  least some data between themselves. This is done with the threads::shared
  module and the &quot;:shared&quot; attribute:
<div class="Pp"></div>
<pre>
    use threads;
    use threads::shared;
    my $foo :shared = 1;
    my $bar = 1;
    threads-&gt;create(sub { $foo++; $bar++; })-&gt;join();
    print(&quot;$foo\n&quot;);  # Prints 2 since $foo is shared
    print(&quot;$bar\n&quot;);  # Prints 1 since $bar is not shared
</pre>
<div class="Pp"></div>
In the case of a shared array, all the array's elements are shared, and for a
  shared hash, all the keys and values are shared. This places restrictions on
  what may be assigned to shared array and hash elements: only simple values or
  references to shared variables are allowed - this is so that a private
  variable can't accidentally become shared. A bad assignment will cause the
  thread to die. For example:
<div class="Pp"></div>
<pre>
    use threads;
    use threads::shared;
    my $var          = 1;
    my $svar :shared = 2;
    my %hash :shared;
    ... create some threads ...
    $hash{a} = 1;       # All threads see exists($hash{a}) and $hash{a} == 1
    $hash{a} = $var;    # okay - copy-by-value: same effect as previous
    $hash{a} = $svar;   # okay - copy-by-value: same effect as previous
    $hash{a} = \$svar;  # okay - a reference to a shared variable
    $hash{a} = \$var;   # This will die
    delete($hash{a});   # okay - all threads will see !exists($hash{a})
</pre>
<div class="Pp"></div>
Note that a shared variable guarantees that if two or more threads try to modify
  it at the same time, the internal state of the variable will not become
  corrupted. However, there are no guarantees beyond this, as explained in the
  next section.
<h2 class="Ss" title="Ss" id="Thread_Pitfalls:_Races"><a class="selflink" href="#Thread_Pitfalls:_Races">Thread
  Pitfalls: Races</a></h2>
While threads bring a new set of useful tools, they also bring a number of
  pitfalls. One pitfall is the race condition:
<div class="Pp"></div>
<pre>
    use threads;
    use threads::shared;
    my $a :shared = 1;
    my $thr1 = threads-&gt;create(\&amp;sub1);
    my $thr2 = threads-&gt;create(\&amp;sub2);
    $thr1-&gt;join();
    $thr2-&gt;join();
    print(&quot;$a\n&quot;);
    sub sub1 { my $foo = $a; $a = $foo + 1; }
    sub sub2 { my $bar = $a; $a = $bar + 1; }
</pre>
<div class="Pp"></div>
What do you think $a will be? The answer, unfortunately, is <i>it</i>
  <i>depends</i>. Both &quot;sub1()&quot; and &quot;sub2()&quot; access the
  global variable $a, once to read and once to write. Depending on factors
  ranging from your thread implementation's scheduling algorithm to the phase of
  the moon, $a can be 2 or 3.
<div class="Pp"></div>
Race conditions are caused by unsynchronized access to shared data. Without
  explicit synchronization, there's no way to be sure that nothing has happened
  to the shared data between the time you access it and the time you update it.
  Even this simple code fragment has the possibility of error:
<div class="Pp"></div>
<pre>
    use threads;
    my $a :shared = 2;
    my $b :shared;
    my $c :shared;
    my $thr1 = threads-&gt;create(sub { $b = $a; $a = $b + 1; });
    my $thr2 = threads-&gt;create(sub { $c = $a; $a = $c + 1; });
    $thr1-&gt;join();
    $thr2-&gt;join();
</pre>
<div class="Pp"></div>
Two threads both access $a. Each thread can potentially be interrupted at any
  point, or be executed in any order. At the end, $a could be 3 or 4, and both
  $b and $c could be 2 or 3.
<div class="Pp"></div>
Even &quot;$a += 5&quot; or &quot;$a++&quot; are not guaranteed to be atomic.
<div class="Pp"></div>
Whenever your program accesses data or resources that can be accessed by other
  threads, you must take steps to coordinate access or risk data inconsistency
  and race conditions. Note that Perl will protect its internals from your race
  conditions, but it won't protect you from you.
<h1 class="Sh" title="Sh" id="Synchronization_and_control"><a class="selflink" href="#Synchronization_and_control">Synchronization
  and control</a></h1>
Perl provides a number of mechanisms to coordinate the interactions between
  themselves and their data, to avoid race conditions and the like. Some of
  these are designed to resemble the common techniques used in thread libraries
  such as &quot;pthreads&quot;; others are Perl-specific. Often, the standard
  techniques are clumsy and difficult to get right (such as condition waits).
  Where possible, it is usually easier to use Perlish techniques such as queues,
  which remove some of the hard work involved.
<h2 class="Ss" title="Ss" id="Controlling_access:_lock()"><a class="selflink" href="#Controlling_access:_lock()">Controlling
  access: <i>lock()</i></a></h2>
The &quot;lock()&quot; function takes a shared variable and puts a lock on it.
  No other thread may lock the variable until the variable is unlocked by the
  thread holding the lock. Unlocking happens automatically when the locking
  thread exits the block that contains the call to the &quot;lock()&quot;
  function. Using &quot;lock()&quot; is straightforward: This example has
  several threads doing some calculations in parallel, and occasionally updating
  a running total:
<div class="Pp"></div>
<pre>
    use threads;
    use threads::shared;
    my $total :shared = 0;
    sub calc {
        while (1) {
            my $result;
            # (... do some calculations and set $result ...)
            {
                lock($total);  # Block until we obtain the lock
                $total += $result;
            } # Lock implicitly released at end of scope
            last if $result == 0;
        }
    }
    my $thr1 = threads-&gt;create(\&amp;calc);
    my $thr2 = threads-&gt;create(\&amp;calc);
    my $thr3 = threads-&gt;create(\&amp;calc);
    $thr1-&gt;join();
    $thr2-&gt;join();
    $thr3-&gt;join();
    print(&quot;total=$total\n&quot;);
</pre>
<div class="Pp"></div>
&quot;lock()&quot; blocks the thread until the variable being locked is
  available. When &quot;lock()&quot; returns, your thread can be sure that no
  other thread can lock that variable until the block containing the lock exits.
<div class="Pp"></div>
It's important to note that locks don't prevent access to the variable in
  question, only lock attempts. This is in keeping with Perl's longstanding
  tradition of courteous programming, and the advisory file locking that
  &quot;flock()&quot; gives you.
<div class="Pp"></div>
You may lock arrays and hashes as well as scalars. Locking an array, though,
  will not block subsequent locks on array elements, just lock attempts on the
  array itself.
<div class="Pp"></div>
Locks are recursive, which means it's okay for a thread to lock a variable more
  than once. The lock will last until the outermost &quot;lock()&quot; on the
  variable goes out of scope. For example:
<div class="Pp"></div>
<pre>
    my $x :shared;
    doit();
    sub doit {
        {
            {
                lock($x); # Wait for lock
                lock($x); # NOOP - we already have the lock
                {
                    lock($x); # NOOP
                    {
                        lock($x); # NOOP
                        lockit_some_more();
                    }
                }
            } # *** Implicit unlock here ***
        }
    }
    sub lockit_some_more {
        lock($x); # NOOP
    } # Nothing happens here
</pre>
<div class="Pp"></div>
Note that there is no &quot;unlock()&quot; function - the only way to unlock a
  variable is to allow it to go out of scope.
<div class="Pp"></div>
A lock can either be used to guard the data contained within the variable being
  locked, or it can be used to guard something else, like a section of code. In
  this latter case, the variable in question does not hold any useful data, and
  exists only for the purpose of being locked. In this respect, the variable
  behaves like the mutexes and basic semaphores of traditional thread libraries.
<h2 class="Ss" title="Ss" id="A_Thread_Pitfall:_Deadlocks"><a class="selflink" href="#A_Thread_Pitfall:_Deadlocks">A
  Thread Pitfall: Deadlocks</a></h2>
Locks are a handy tool to synchronize access to data, and using them properly is
  the key to safe shared data. Unfortunately, locks aren't without their
  dangers, especially when multiple locks are involved. Consider the following
  code:
<div class="Pp"></div>
<pre>
    use threads;
    my $a :shared = 4;
    my $b :shared = 'foo';
    my $thr1 = threads-&gt;create(sub {
        lock($a);
        sleep(20);
        lock($b);
    });
    my $thr2 = threads-&gt;create(sub {
        lock($b);
        sleep(20);
        lock($a);
    });
</pre>
<div class="Pp"></div>
This program will probably hang until you kill it. The only way it won't hang is
  if one of the two threads acquires both locks first. A guaranteed-to-hang
  version is more complicated, but the principle is the same.
<div class="Pp"></div>
The first thread will grab a lock on $a, then, after a pause during which the
  second thread has probably had time to do some work, try to grab a lock on $b.
  Meanwhile, the second thread grabs a lock on $b, then later tries to grab a
  lock on $a. The second lock attempt for both threads will block, each waiting
  for the other to release its lock.
<div class="Pp"></div>
This condition is called a deadlock, and it occurs whenever two or more threads
  are trying to get locks on resources that the others own. Each thread will
  block, waiting for the other to release a lock on a resource. That never
  happens, though, since the thread with the resource is itself waiting for a
  lock to be released.
<div class="Pp"></div>
There are a number of ways to handle this sort of problem. The best way is to
  always have all threads acquire locks in the exact same order. If, for
  example, you lock variables $a, $b, and $c, always lock $a before $b, and $b
  before $c. It's also best to hold on to locks for as short a period of time to
  minimize the risks of deadlock.
<div class="Pp"></div>
The other synchronization primitives described below can suffer from similar
  problems.
<h2 class="Ss" title="Ss" id="Queues:_Passing_Data_Around"><a class="selflink" href="#Queues:_Passing_Data_Around">Queues:
  Passing Data Around</a></h2>
A queue is a special thread-safe object that lets you put data in one end and
  take it out the other without having to worry about synchronization issues.
  They're pretty straightforward, and look like this:
<div class="Pp"></div>
<pre>
    use threads;
    use Thread::Queue;
    my $DataQueue = Thread::Queue-&gt;new();
    my $thr = threads-&gt;create(sub {
        while (my $DataElement = $DataQueue-&gt;dequeue()) {
            print(&quot;Popped $DataElement off the queue\n&quot;);
        }
    });
    $DataQueue-&gt;enqueue(12);
    $DataQueue-&gt;enqueue(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
    sleep(10);
    $DataQueue-&gt;enqueue(undef);
    $thr-&gt;join();
</pre>
<div class="Pp"></div>
You create the queue with &quot;Thread::Queue-&gt;new()&quot;. Then you can add
  lists of scalars onto the end with &quot;enqueue()&quot;, and pop scalars off
  the front of it with &quot;dequeue()&quot;. A queue has no fixed size, and can
  grow as needed to hold everything pushed on to it.
<div class="Pp"></div>
If a queue is empty, &quot;dequeue()&quot; blocks until another thread enqueues
  something. This makes queues ideal for event loops and other communications
  between threads.
<h2 class="Ss" title="Ss" id="Semaphores:_Synchronizing_Data_Access"><a class="selflink" href="#Semaphores:_Synchronizing_Data_Access">Semaphores:
  Synchronizing Data Access</a></h2>
Semaphores are a kind of generic locking mechanism. In their most basic form,
  they behave very much like lockable scalars, except that they can't hold data,
  and that they must be explicitly unlocked. In their advanced form, they act
  like a kind of counter, and can allow multiple threads to have the <i>lock</i>
  at any one time.
<h2 class="Ss" title="Ss" id="Basic_semaphores"><a class="selflink" href="#Basic_semaphores">Basic
  semaphores</a></h2>
Semaphores have two methods, &quot;down()&quot; and &quot;up()&quot;:
  &quot;down()&quot; decrements the resource count, while &quot;up()&quot;
  increments it. Calls to &quot;down()&quot; will block if the semaphore's
  current count would decrement below zero. This program gives a quick
  demonstration:
<div class="Pp"></div>
<pre>
    use threads;
    use Thread::Semaphore;
    my $semaphore = Thread::Semaphore-&gt;new();
    my $GlobalVariable :shared = 0;
    $thr1 = threads-&gt;create(\&amp;sample_sub, 1);
    $thr2 = threads-&gt;create(\&amp;sample_sub, 2);
    $thr3 = threads-&gt;create(\&amp;sample_sub, 3);
    sub sample_sub {
        my $SubNumber = shift(@_);
        my $TryCount = 10;
        my $LocalCopy;
        sleep(1);
        while ($TryCount--) {
            $semaphore-&gt;down();
            $LocalCopy = $GlobalVariable;
            print(&quot;$TryCount tries left for sub $SubNumber (\$GlobalVariable is $GlobalVariable)\n&quot;);
            sleep(2);
            $LocalCopy++;
            $GlobalVariable = $LocalCopy;
            $semaphore-&gt;up();
        }
    }
    $thr1-&gt;join();
    $thr2-&gt;join();
    $thr3-&gt;join();
</pre>
<div class="Pp"></div>
The three invocations of the subroutine all operate in sync. The semaphore,
  though, makes sure that only one thread is accessing the global variable at
  once.
<h2 class="Ss" title="Ss" id="Advanced_Semaphores"><a class="selflink" href="#Advanced_Semaphores">Advanced
  Semaphores</a></h2>
By default, semaphores behave like locks, letting only one thread
  &quot;down()&quot; them at a time. However, there are other uses for
  semaphores.
<div class="Pp"></div>
Each semaphore has a counter attached to it. By default, semaphores are created
  with the counter set to one, &quot;down()&quot; decrements the counter by one,
  and &quot;up()&quot; increments by one. However, we can override any or all of
  these defaults simply by passing in different values:
<div class="Pp"></div>
<pre>
    use threads;
    use Thread::Semaphore;
    my $semaphore = Thread::Semaphore-&gt;new(5);
                    # Creates a semaphore with the counter set to five
    my $thr1 = threads-&gt;create(\&amp;sub1);
    my $thr2 = threads-&gt;create(\&amp;sub1);
    sub sub1 {
        $semaphore-&gt;down(5); # Decrements the counter by five
        # Do stuff here
        $semaphore-&gt;up(5); # Increment the counter by five
    }
    $thr1-&gt;detach();
    $thr2-&gt;detach();
</pre>
<div class="Pp"></div>
If &quot;down()&quot; attempts to decrement the counter below zero, it blocks
  until the counter is large enough. Note that while a semaphore can be created
  with a starting count of zero, any &quot;up()&quot; or &quot;down()&quot;
  always changes the counter by at least one, and so
  &quot;$semaphore-&gt;down(0)&quot; is the same as
  &quot;$semaphore-&gt;down(1)&quot;.
<div class="Pp"></div>
The question, of course, is why would you do something like this? Why create a
  semaphore with a starting count that's not one, or why decrement or increment
  it by more than one? The answer is resource availability. Many resources that
  you want to manage access for can be safely used by more than one thread at
  once.
<div class="Pp"></div>
For example, let's take a GUI driven program. It has a semaphore that it uses to
  synchronize access to the display, so only one thread is ever drawing at once.
  Handy, but of course you don't want any thread to start drawing until things
  are properly set up. In this case, you can create a semaphore with a counter
  set to zero, and up it when things are ready for drawing.
<div class="Pp"></div>
Semaphores with counters greater than one are also useful for establishing
  quotas. Say, for example, that you have a number of threads that can do I/O at
  once. You don't want all the threads reading or writing at once though, since
  that can potentially swamp your I/O channels, or deplete your process's quota
  of filehandles. You can use a semaphore initialized to the number of
  concurrent I/O requests (or open files) that you want at any one time, and
  have your threads quietly block and unblock themselves.
<div class="Pp"></div>
Larger increments or decrements are handy in those cases where a thread needs to
  check out or return a number of resources at once.
<h2 class="Ss" title="Ss" id="Waiting_for_a_Condition"><a class="selflink" href="#Waiting_for_a_Condition">Waiting
  for a Condition</a></h2>
The functions &quot;cond_wait()&quot; and &quot;cond_signal()&quot; can be used
  in conjunction with locks to notify co-operating threads that a resource has
  become available. They are very similar in use to the functions found in
  &quot;pthreads&quot;. However for most purposes, queues are simpler to use and
  more intuitive. See threads::shared for more details.
<h2 class="Ss" title="Ss" id="Giving_up_control"><a class="selflink" href="#Giving_up_control">Giving
  up control</a></h2>
There are times when you may find it useful to have a thread explicitly give up
  the CPU to another thread. You may be doing something processor-intensive and
  want to make sure that the user-interface thread gets called frequently.
  Regardless, there are times that you might want a thread to give up the
  processor.
<div class="Pp"></div>
Perl's threading package provides the &quot;yield()&quot; function that does
  this. &quot;yield()&quot; is pretty straightforward, and works like this:
<div class="Pp"></div>
<pre>
    use threads;
    sub loop {
        my $thread = shift;
        my $foo = 50;
        while($foo--) { print(&quot;In thread $thread\n&quot;); }
        threads-&gt;yield();
        $foo = 50;
        while($foo--) { print(&quot;In thread $thread\n&quot;); }
    }
    my $thr1 = threads-&gt;create(\&amp;loop, 'first');
    my $thr2 = threads-&gt;create(\&amp;loop, 'second');
    my $thr3 = threads-&gt;create(\&amp;loop, 'third');
</pre>
<div class="Pp"></div>
It is important to remember that &quot;yield()&quot; is only a hint to give up
  the CPU, it depends on your hardware, OS and threading libraries what actually
  happens. <b>On many operating systems, </b><b><i>yield()</i></b><b> is a
  no-op.</b> Therefore it is important to note that one should not build the
  scheduling of the threads around &quot;yield()&quot; calls. It might work on
  your platform but it won't work on another platform.
<h1 class="Sh" title="Sh" id="General_Thread_Utility_Routines"><a class="selflink" href="#General_Thread_Utility_Routines">General
  Thread Utility Routines</a></h1>
We've covered the workhorse parts of Perl's threading package, and with these
  tools you should be well on your way to writing threaded code and packages.
  There are a few useful little pieces that didn't really fit in anyplace else.
<h2 class="Ss" title="Ss" id="What_Thread_Am_I_In?"><a class="selflink" href="#What_Thread_Am_I_In?">What
  Thread Am I In?</a></h2>
The &quot;threads-&gt;self()&quot; class method provides your program with a way
  to get an object representing the thread it's currently in. You can use this
  object in the same way as the ones returned from thread creation.
<h2 class="Ss" title="Ss" id="Thread_IDs"><a class="selflink" href="#Thread_IDs">Thread
  IDs</a></h2>
&quot;tid()&quot; is a thread object method that returns the thread ID of the
  thread the object represents. Thread IDs are integers, with the main thread in
  a program being 0. Currently Perl assigns a unique TID to every thread ever
  created in your program, assigning the first thread to be created a TID of 1,
  and increasing the TID by 1 for each new thread that's created. When used as a
  class method, &quot;threads-&gt;tid()&quot; can be used by a thread to get its
  own TID.
<h2 class="Ss" title="Ss" id="Are_These_Threads_The_Same?"><a class="selflink" href="#Are_These_Threads_The_Same?">Are
  These Threads The Same?</a></h2>
The &quot;equal()&quot; method takes two thread objects and returns true if the
  objects represent the same thread, and false if they don't.
<div class="Pp"></div>
Thread objects also have an overloaded &quot;==&quot; comparison so that you can
  do comparison on them as you would with normal objects.
<h2 class="Ss" title="Ss" id="What_Threads_Are_Running?"><a class="selflink" href="#What_Threads_Are_Running?">What
  Threads Are Running?</a></h2>
&quot;threads-&gt;list()&quot; returns a list of thread objects, one for each
  thread that's currently running and not detached. Handy for a number of
  things, including cleaning up at the end of your program (from the main Perl
  thread, of course):
<div class="Pp"></div>
<pre>
    # Loop through all the threads
    foreach my $thr (threads-&gt;list()) {
        $thr-&gt;join();
    }
</pre>
<div class="Pp"></div>
If some threads have not finished running when the main Perl thread ends, Perl
  will warn you about it and die, since it is impossible for Perl to clean up
  itself while other threads are running.
<div class="Pp"></div>
NOTE: The main Perl thread (thread 0) is in a <i>detached</i> state, and so does
  not appear in the list returned by &quot;threads-&gt;list()&quot;.
<h1 class="Sh" title="Sh" id="A_Complete_Example"><a class="selflink" href="#A_Complete_Example">A
  Complete Example</a></h1>
Confused yet? It's time for an example program to show some of the things we've
  covered. This program finds prime numbers using threads.
<div class="Pp"></div>
<pre>
     1 #!/usr/bin/perl
     2 # prime-pthread, courtesy of Tom Christiansen
     3
     4 use strict;
     5 use warnings;
     6
     7 use threads;
     8 use Thread::Queue;
     9
    10 sub check_num {
    11     my ($upstream, $cur_prime) = @_;
    12     my $kid;
    13     my $downstream = Thread::Queue-&gt;new();
    14     while (my $num = $upstream-&gt;dequeue()) {
    15         next unless ($num % $cur_prime);
    16         if ($kid) {
    17             $downstream-&gt;enqueue($num);
    18         } else {
    19             print(&quot;Found prime: $num\n&quot;);
    20             $kid = threads-&gt;create(\&amp;check_num, $downstream, $num);
    21             if (! $kid) {
    22                 warn(&quot;Sorry.  Ran out of threads.\n&quot;);
    23                 last;
    24             }
    25         }
    26     }
    27     if ($kid) {
    28         $downstream-&gt;enqueue(undef);
    29         $kid-&gt;join();
    30     }
    31 }
    32
    33 my $stream = Thread::Queue-&gt;new(3..1000, undef);
    34 check_num($stream, 2);
</pre>
<div class="Pp"></div>
This program uses the pipeline model to generate prime numbers. Each thread in
  the pipeline has an input queue that feeds numbers to be checked, a prime
  number that it's responsible for, and an output queue into which it funnels
  numbers that have failed the check. If the thread has a number that's failed
  its check and there's no child thread, then the thread must have found a new
  prime number. In that case, a new child thread is created for that prime and
  stuck on the end of the pipeline.
<div class="Pp"></div>
This probably sounds a bit more confusing than it really is, so let's go through
  this program piece by piece and see what it does. (For those of you who might
  be trying to remember exactly what a prime number is, it's a number that's
  only evenly divisible by itself and 1.)
<div class="Pp"></div>
The bulk of the work is done by the &quot;check_num()&quot; subroutine, which
  takes a reference to its input queue and a prime number that it's responsible
  for. After pulling in the input queue and the prime that the subroutine is
  checking (line 11), we create a new queue (line 13) and reserve a scalar for
  the thread that we're likely to create later (line 12).
<div class="Pp"></div>
The while loop from line 14 to line 26 grabs a scalar off the input queue and
  checks against the prime this thread is responsible for. Line 15 checks to see
  if there's a remainder when we divide the number to be checked by our prime.
  If there is one, the number must not be evenly divisible by our prime, so we
  need to either pass it on to the next thread if we've created one (line 17) or
  create a new thread if we haven't.
<div class="Pp"></div>
The new thread creation is line 20. We pass on to it a reference to the queue
  we've created, and the prime number we've found. In lines 21 through 24, we
  check to make sure that our new thread got created, and if not, we stop
  checking any remaining numbers in the queue.
<div class="Pp"></div>
Finally, once the loop terminates (because we got a 0 or &quot;undef&quot; in
  the queue, which serves as a note to terminate), we pass on the notice to our
  child, and wait for it to exit if we've created a child (lines 27 and 30).
<div class="Pp"></div>
Meanwhile, back in the main thread, we first create a queue (line 33) and queue
  up all the numbers from 3 to 1000 for checking, plus a termination notice.
  Then all we have to do to get the ball rolling is pass the queue and the first
  prime to the &quot;check_num()&quot; subroutine (line 34).
<div class="Pp"></div>
That's how it works. It's pretty simple; as with many Perl programs, the
  explanation is much longer than the program.
<h1 class="Sh" title="Sh" id="Different_implementations_of_threads"><a class="selflink" href="#Different_implementations_of_threads">Different
  implementations of threads</a></h1>
Some background on thread implementations from the operating system viewpoint.
  There are three basic categories of threads: user-mode threads, kernel
  threads, and multiprocessor kernel threads.
<div class="Pp"></div>
User-mode threads are threads that live entirely within a program and its
  libraries. In this model, the OS knows nothing about threads. As far as it's
  concerned, your process is just a process.
<div class="Pp"></div>
This is the easiest way to implement threads, and the way most OSes start. The
  big disadvantage is that, since the OS knows nothing about threads, if one
  thread blocks they all do. Typical blocking activities include most system
  calls, most I/O, and things like &quot;sleep()&quot;.
<div class="Pp"></div>
Kernel threads are the next step in thread evolution. The OS knows about kernel
  threads, and makes allowances for them. The main difference between a kernel
  thread and a user-mode thread is blocking. With kernel threads, things that
  block a single thread don't block other threads. This is not the case with
  user-mode threads, where the kernel blocks at the process level and not the
  thread level.
<div class="Pp"></div>
This is a big step forward, and can give a threaded program quite a performance
  boost over non-threaded programs. Threads that block performing I/O, for
  example, won't block threads that are doing other things. Each process still
  has only one thread running at once, though, regardless of how many CPUs a
  system might have.
<div class="Pp"></div>
Since kernel threading can interrupt a thread at any time, they will uncover
  some of the implicit locking assumptions you may make in your program. For
  example, something as simple as &quot;$a = $a + 2&quot; can behave
  unpredictably with kernel threads if $a is visible to other threads, as
  another thread may have changed $a between the time it was fetched on the
  right hand side and the time the new value is stored.
<div class="Pp"></div>
Multiprocessor kernel threads are the final step in thread support. With
  multiprocessor kernel threads on a machine with multiple CPUs, the OS may
  schedule two or more threads to run simultaneously on different CPUs.
<div class="Pp"></div>
This can give a serious performance boost to your threaded program, since more
  than one thread will be executing at the same time. As a tradeoff, though, any
  of those nagging synchronization issues that might not have shown with basic
  kernel threads will appear with a vengeance.
<div class="Pp"></div>
In addition to the different levels of OS involvement in threads, different OSes
  (and different thread implementations for a particular OS) allocate CPU cycles
  to threads in different ways.
<div class="Pp"></div>
Cooperative multitasking systems have running threads give up control if one of
  two things happen. If a thread calls a yield function, it gives up control. It
  also gives up control if the thread does something that would cause it to
  block, such as perform I/O. In a cooperative multitasking implementation, one
  thread can starve all the others for CPU time if it so chooses.
<div class="Pp"></div>
Preemptive multitasking systems interrupt threads at regular intervals while the
  system decides which thread should run next. In a preemptive multitasking
  system, one thread usually won't monopolize the CPU.
<div class="Pp"></div>
On some systems, there can be cooperative and preemptive threads running
  simultaneously. (Threads running with realtime priorities often behave
  cooperatively, for example, while threads running at normal priorities behave
  preemptively.)
<div class="Pp"></div>
Most modern operating systems support preemptive multitasking nowadays.
<h1 class="Sh" title="Sh" id="Performance_considerations"><a class="selflink" href="#Performance_considerations">Performance
  considerations</a></h1>
The main thing to bear in mind when comparing Perl's <i>ithreads</i> to other
  threading models is the fact that for each new thread created, a complete copy
  of all the variables and data of the parent thread has to be taken. Thus,
  thread creation can be quite expensive, both in terms of memory usage and time
  spent in creation. The ideal way to reduce these costs is to have a relatively
  short number of long-lived threads, all created fairly early on (before the
  base thread has accumulated too much data). Of course, this may not always be
  possible, so compromises have to be made. However, after a thread has been
  created, its performance and extra memory usage should be little different
  than ordinary code.
<div class="Pp"></div>
Also note that under the current implementation, shared variables use a little
  more memory and are a little slower than ordinary variables.
<h1 class="Sh" title="Sh" id="Process-scope_Changes"><a class="selflink" href="#Process-scope_Changes">Process-scope
  Changes</a></h1>
Note that while threads themselves are separate execution threads and Perl data
  is thread-private unless explicitly shared, the threads can affect
  process-scope state, affecting all the threads.
<div class="Pp"></div>
The most common example of this is changing the current working directory using
  &quot;chdir()&quot;. One thread calls &quot;chdir()&quot;, and the working
  directory of all the threads changes.
<div class="Pp"></div>
Even more drastic example of a process-scope change is &quot;chroot()&quot;: the
  root directory of all the threads changes, and no thread can undo it (as
  opposed to &quot;chdir()&quot;).
<div class="Pp"></div>
Further examples of process-scope changes include &quot;umask()&quot; and
  changing uids and gids.
<div class="Pp"></div>
Thinking of mixing &quot;fork()&quot; and threads? Please lie down and wait
  until the feeling passes. Be aware that the semantics of &quot;fork()&quot;
  vary between platforms. For example, some Unix systems copy all the current
  threads into the child process, while others only copy the thread that called
  &quot;fork()&quot;. You have been warned!
<div class="Pp"></div>
Similarly, mixing signals and threads may be problematic. Implementations are
  platform-dependent, and even the POSIX semantics may not be what you expect
  (and Perl doesn't even give you the full POSIX API). For example, there is no
  way to guarantee that a signal sent to a multi-threaded Perl application will
  get intercepted by any particular thread. (However, a recently added feature
  does provide the capability to send signals between threads. See &quot;THREAD
  SIGNALLING&quot; in threads for more details.)
<h1 class="Sh" title="Sh" id="Thread-Safety_of_System_Libraries"><a class="selflink" href="#Thread-Safety_of_System_Libraries">Thread-Safety
  of System Libraries</a></h1>
Whether various library calls are thread-safe is outside the control of Perl.
  Calls often suffering from not being thread-safe include:
  &quot;localtime()&quot;, &quot;gmtime()&quot;, functions fetching user, group
  and network information (such as &quot;getgrent()&quot;,
  &quot;gethostent()&quot;, &quot;getnetent()&quot; and so on),
  &quot;readdir()&quot;, &quot;rand()&quot;, and &quot;srand()&quot;. In
  general, calls that depend on some global external state.
<div class="Pp"></div>
If the system Perl is compiled in has thread-safe variants of such calls, they
  will be used. Beyond that, Perl is at the mercy of the thread-safety or
  -unsafety of the calls. Please consult your C library call documentation.
<div class="Pp"></div>
On some platforms the thread-safe library interfaces may fail if the result
  buffer is too small (for example the user group databases may be rather large,
  and the reentrant interfaces may have to carry around a full snapshot of those
  databases). Perl will start with a small buffer, but keep retrying and growing
  the result buffer until the result fits. If this limitless growing sounds bad
  for security or memory consumption reasons you can recompile Perl with
  &quot;PERL_REENTRANT_MAXSIZE&quot; defined to the maximum number of bytes you
  will allow.
<h1 class="Sh" title="Sh" id="Conclusion"><a class="selflink" href="#Conclusion">Conclusion</a></h1>
A complete thread tutorial could fill a book (and has, many times), but with
  what we've covered in this introduction, you should be well on your way to
  becoming a threaded Perl expert.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Annotated POD for threads:
  &lt;http://annocpan.org/?mode=search&amp;field=Module&amp;name=threads&gt;
<div class="Pp"></div>
Latest version of threads on CPAN:
  &lt;http://search.cpan.org/search?module=threads&gt;
<div class="Pp"></div>
Annotated POD for threads::shared:
  &lt;http://annocpan.org/?mode=search&amp;field=Module&amp;name=threads%3A%3Ashared&gt;
<div class="Pp"></div>
Latest version of threads::shared on CPAN:
  &lt;http://search.cpan.org/search?module=threads%3A%3Ashared&gt;
<div class="Pp"></div>
Perl threads mailing list: &lt;http://lists.perl.org/list/ithreads.html&gt;
<h1 class="Sh" title="Sh" id="Bibliography"><a class="selflink" href="#Bibliography">Bibliography</a></h1>
Here's a short bibliography courtesy of JA~Xrgen Christoffel:
<h2 class="Ss" title="Ss" id="Introductory_Texts"><a class="selflink" href="#Introductory_Texts">Introductory
  Texts</a></h2>
Birrell, Andrew D. An Introduction to Programming with Threads. Digital
  Equipment Corporation, 1989, DEC-SRC Research Report #35 online as
  ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf (highly
  recommended)
<div class="Pp"></div>
Robbins, Kay. A., and Steven Robbins. Practical Unix Programming: A Guide to
  Concurrency, Communication, and Multithreading. Prentice-Hall, 1996.
<div class="Pp"></div>
Lewis, Bill, and Daniel J. Berg. Multithreaded Programming with Pthreads.
  Prentice Hall, 1997, ISBN 0-13-443698-9 (a well-written introduction to
  threads).
<div class="Pp"></div>
Nelson, Greg (editor). Systems Programming with Modula-3. Prentice Hall, 1991,
  ISBN 0-13-590464-1.
<div class="Pp"></div>
Nichols, Bradford, Dick Buttlar, and Jacqueline Proulx Farrell. Pthreads
  Programming. O'Reilly &amp; Associates, 1996, ISBN 156592-115-1 (covers POSIX
  threads).
<h2 class="Ss" title="Ss" id="OS-Related_References"><a class="selflink" href="#OS-Related_References">OS-Related
  References</a></h2>
Boykin, Joseph, David Kirschen, Alan Langerman, and Susan LoVerso. Programming
  under Mach. Addison-Wesley, 1994, ISBN 0-201-52739-1.
<div class="Pp"></div>
Tanenbaum, Andrew S. Distributed Operating Systems. Prentice Hall, 1995, ISBN
  0-13-219908-4 (great textbook).
<div class="Pp"></div>
Silberschatz, Abraham, and Peter B. Galvin. Operating System Concepts, 4th ed.
  Addison-Wesley, 1995, ISBN 0-201-59292-4
<h2 class="Ss" title="Ss" id="Other_References"><a class="selflink" href="#Other_References">Other
  References</a></h2>
Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed.
  Addison-Wesley, 1998, ISBN 0-201-31006-6.
<div class="Pp"></div>
comp.programming.threads FAQ, http://www.serpentine.com/~bos/threads-faq/
  &lt;http://www.serpentine.com/~bos/threads-faq/&gt;
<div class="Pp"></div>
Le Sergent, T. and B. Berthomieu. &quot;Incremental MultiThreaded Garbage
  Collection on Virtually Shared Memory Architectures&quot; in Memory
  Management: Proc. of the International Workshop IWMM 92, St. Malo, France,
  September 1992, Yves Bekkers and Jacques Cohen, eds. Springer, 1992, ISBN
  3540-55940-X (real-life thread applications).
<div class="Pp"></div>
Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11, 2002,
  &lt;http://www.perl.com/pub/a/2002/06/11/threads.html&gt;
<h1 class="Sh" title="Sh" id="Acknowledgements"><a class="selflink" href="#Acknowledgements">Acknowledgements</a></h1>
Thanks (in no particular order) to Chaim Frenkel, Steve Fink, Gurusamy Sarathy,
  Ilya Zakharevich, Benjamin Sugars, JA~Xrgen Christoffel, Joshua Pritikin, and
  Alan Burlison, for their help in reality-checking and polishing this article.
  Big thanks to Tom Christiansen for his rewrite of the prime number generator.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Dan Sugalski &lt;dan@sidhe.org&lt;gt&gt;
<div class="Pp"></div>
Slightly modified by Arthur Bergman to fit the new thread model/module.
<div class="Pp"></div>
Reworked slightly by JA~Xrg Walter &lt;jwalt@cpan.org&lt;gt&gt; to be more
  concise about thread-safety of Perl code.
<div class="Pp"></div>
Rearranged slightly by Elizabeth Mattijsen &lt;liz@dijkmat.nl&lt;gt&gt; to put
  less emphasis on <i>yield()</i>.
<h1 class="Sh" title="Sh" id="Copyrights"><a class="selflink" href="#Copyrights">Copyrights</a></h1>
The original version of this article originally appeared in The Perl Journal
  #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant
  and The Perl Journal. This document may be distributed under the same terms as
  Perl itself.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
