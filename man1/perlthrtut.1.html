<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:08 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLTHRTUT(1) Perl Programmers Reference Guide
PERLTHRTUT(1)</p>

<p style="margin-top: 1em">NAME <br>
perlthrtut - Tutorial on threads in Perl</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This tutorial describes the use of Perl interpreter threads
(sometimes referred to as ithreads) that was first
introduced in Perl 5.6.0. In this model, each thread runs in
its <br>
own Perl interpreter, and any data sharing between threads
must be explicit. The user-level interface for ithreads uses
the threads class.</p>

<p style="margin-top: 1em">NOTE: There was another older
Perl threading flavor called the 5.005 model that used the
threads class. This old model was known to have problems, is
deprecated, and was removed <br>
for release 5.10. You are strongly encouraged to migrate any
existing 5.005 threads code to the new model as soon as
possible.</p>

<p style="margin-top: 1em">You can see which (or neither)
threading flavour you have by running &quot;perl -V&quot;
and looking at the &quot;Platform&quot; section. If you have
&quot;useithreads=define&quot; you have ithreads, if you
<br>
have &quot;use5005threads=define&quot; you have 5.005
threads. If you have neither, you don&rsquo;t have any
thread support built in. If you have both, you are in
trouble.</p>

<p style="margin-top: 1em">The threads and threads::shared
modules are included in the core Perl distribution.
Additionally, they are maintained as a separate modules on
CPAN, so you can check there for <br>
any updates.</p>

<p style="margin-top: 1em">What Is A Thread Anyway? <br>
A thread is a flow of control through a program with a
single execution point.</p>

<p style="margin-top: 1em">Sounds an awful lot like a
process, doesn&rsquo;t it? Well, it should. Threads are one
of the pieces of a process. Every process has at least one
thread and, up until now, every <br>
process running Perl had only one thread. With 5.8, though,
you can create extra threads. We&rsquo;re going to show you
how, when, and why.</p>

<p style="margin-top: 1em">Threaded Program Models <br>
There are three basic ways that you can structure a threaded
program. Which model you choose depends on what you need
your program to do. For many non-trivial threaded <br>
programs, you&rsquo;ll need to choose different models for
different pieces of your program.</p>

<p style="margin-top: 1em">Boss/Worker <br>
The boss/worker model usually has one boss thread and one or
more worker threads. The boss thread gathers or generates
tasks that need to be done, then parcels those tasks out
<br>
to the appropriate worker thread.</p>

<p style="margin-top: 1em">This model is common in GUI and
server programs, where a main thread waits for some event
and then passes that event to the appropriate worker threads
for processing. Once the <br>
event has been passed on, the boss thread goes back to
waiting for another event.</p>

<p style="margin-top: 1em">The boss thread does relatively
little work. While tasks aren&rsquo;t necessarily performed
faster than with any other method, it tends to have the best
user-response times.</p>

<p style="margin-top: 1em">Work Crew <br>
In the work crew model, several threads are created that do
essentially the same thing to different pieces of data. It
closely mirrors classical parallel processing and vector
<br>
processors, where a large array of processors do the exact
same thing to many pieces of data.</p>

<p style="margin-top: 1em">This model is particularly
useful if the system running the program will distribute
multiple threads across different processors. It can also be
useful in ray tracing or <br>
rendering engines, where the individual threads can pass on
interim results to give the user visual feedback.</p>

<p style="margin-top: 1em">Pipeline <br>
The pipeline model divides up a task into a series of steps,
and passes the results of one step on to the thread
processing the next. Each thread does one thing to each
piece of <br>
data and passes the results to the next thread in line.</p>

<p style="margin-top: 1em">This model makes the most sense
if you have multiple processors so two or more threads will
be executing in parallel, though it can often make sense in
other contexts as well. <br>
It tends to keep the individual tasks small and simple, as
well as allowing some parts of the pipeline to block (on I/O
or system calls, for example) while other parts keep <br>
going. If you&rsquo;re running different parts of the
pipeline on different processors you may also take advantage
of the caches on each processor.</p>

<p style="margin-top: 1em">This model is also handy for a
form of recursive programming where, rather than having a
subroutine call itself, it instead creates another thread.
Prime and Fibonacci <br>
generators both map well to this form of the pipeline model.
(A version of a prime number generator is presented later
on.)</p>

<p style="margin-top: 1em">What kind of threads are Perl
threads? <br>
If you have experience with other thread implementations,
you might find that things aren&rsquo;t quite what you
expect. It&rsquo;s very important to remember when dealing
with Perl threads <br>
that Perl Threads Are Not X Threads for all values of X.
They aren&rsquo;t POSIX threads, or DecThreads, or
Java&rsquo;s Green threads, or Win32 threads. There are
similarities, and the <br>
broad concepts are the same, but if you start looking for
implementation details you&rsquo;re going to be either
disappointed or confused. Possibly both.</p>

<p style="margin-top: 1em">This is not to say that Perl
threads are completely different from everything
that&rsquo;s ever come before. They&rsquo;re not.
Perl&rsquo;s threading model owes a lot to other thread
models, <br>
especially POSIX. Just as Perl is not C, though, Perl
threads are not POSIX threads. So if you find yourself
looking for mutexes, or thread priorities, it&rsquo;s time
to step back a <br>
bit and think about what you want to do and how Perl can do
it.</p>

<p style="margin-top: 1em">However, it is important to
remember that Perl threads cannot magically do things unless
your operating system&rsquo;s threads allow it. So if your
system blocks the entire process on <br>
&quot;sleep()&quot;, Perl usually will, as well.</p>

<p style="margin-top: 1em">Perl Threads Are Different.</p>

<p style="margin-top: 1em">Thread-Safe Modules <br>
The addition of threads has changed Perl&rsquo;s internals
substantially. There are implications for people who write
modules with XS code or external libraries. However, since
Perl <br>
data is not shared among threads by default, Perl modules
stand a high chance of being thread-safe or can be made
thread-safe easily. Modules that are not tagged as
thread-safe <br>
should be tested or code reviewed before being used in
production code.</p>

<p style="margin-top: 1em">Not all modules that you might
use are thread-safe, and you should always assume a module
is unsafe unless the documentation says otherwise. This
includes modules that are <br>
distributed as part of the core. Threads are a relatively
new feature, and even some of the standard modules
aren&rsquo;t thread-safe.</p>

<p style="margin-top: 1em">Even if a module is thread-safe,
it doesn&rsquo;t mean that the module is optimized to work
well with threads. A module could possibly be rewritten to
utilize the new features in <br>
threaded Perl to increase performance in a threaded
environment.</p>

<p style="margin-top: 1em">If you&rsquo;re using a module
that&rsquo;s not thread-safe for some reason, you can
protect yourself by using it from one, and only one thread
at all. If you need multiple threads to <br>
access such a module, you can use semaphores and lots of
programming discipline to control access to it. Semaphores
are covered in &quot;Basic semaphores&quot;.</p>

<p style="margin-top: 1em">See also &quot;Thread-Safety of
System Libraries&quot;.</p>

<p style="margin-top: 1em">Thread Basics <br>
The threads module provides the basic functions you need to
write threaded programs. In the following sections,
we&rsquo;ll cover the basics, showing you what you need to
do to create <br>
a threaded program. After that, we&rsquo;ll go over some of
the features of the threads module that make threaded
programming easier.</p>

<p style="margin-top: 1em">Basic Thread Support <br>
Thread support is a Perl compile-time option. It&rsquo;s
something that&rsquo;s turned on or off when Perl is built
at your site, rather than when your programs are compiled.
If your Perl <br>
wasn&rsquo;t compiled with thread support enabled, then any
attempt to use threads will fail.</p>

<p style="margin-top: 1em">Your programs can use the Config
module to check whether threads are enabled. If your program
can&rsquo;t run without them, you can say something
like:</p>

<p style="margin-top: 1em">use Config; <br>
$Config{useithreads} or die(&rsquo;Recompile Perl with
threads to run this program.&rsquo;);</p>

<p style="margin-top: 1em">A possibly-threaded program
using a possibly-threaded module might have code like
this:</p>

<p style="margin-top: 1em">use Config; <br>
use MyMod;</p>

<p style="margin-top: 1em">BEGIN { <br>
if ($Config{useithreads}) { <br>
# We have threads <br>
require MyMod_threaded; <br>
import MyMod_threaded; <br>
} else { <br>
require MyMod_unthreaded; <br>
import MyMod_unthreaded; <br>
} <br>
}</p>

<p style="margin-top: 1em">Since code that runs both with
and without threads is usually pretty messy, it&rsquo;s best
to isolate the thread-specific code in its own module. In
our example above, that&rsquo;s what <br>
&quot;MyMod_threaded&quot; is, and it&rsquo;s only imported
if we&rsquo;re running on a threaded Perl.</p>

<p style="margin-top: 1em">A Note about the Examples <br>
In a real situation, care should be taken that all threads
are finished executing before the program exits. That care
has not been taken in these examples in the interest of <br>
simplicity. Running these examples as is will produce error
messages, usually caused by the fact that there are still
threads running when the program exits. You should not be
<br>
alarmed by this.</p>

<p style="margin-top: 1em">Creating Threads <br>
The threads module provides the tools you need to create new
threads. Like any other module, you need to tell Perl that
you want to use it; &quot;use threads;&quot; imports all the
pieces <br>
you need to create basic threads.</p>

<p style="margin-top: 1em">The simplest, most
straightforward way to create a thread is with
&quot;create()&quot;:</p>

<p style="margin-top: 1em">use threads;</p>

<p style="margin-top: 1em">my $thr =
threads-&gt;create(sub1);</p>

<p style="margin-top: 1em">sub sub1 { <br>
print(&quot;In the thread0); <br>
}</p>

<p style="margin-top: 1em">The &quot;create()&quot; method
takes a reference to a subroutine and creates a new thread
that starts executing in the referenced subroutine. Control
then passes both to the subroutine <br>
and the caller.</p>

<p style="margin-top: 1em">If you need to, your program can
pass parameters to the subroutine as part of the thread
startup. Just include the list of parameters as part of the
&quot;threads-&gt;create()&quot; call, <br>
like this:</p>

<p style="margin-top: 1em">use threads;</p>

<p style="margin-top: 1em">my $Param3 = &rsquo;foo&rsquo;;
<br>
my $thr1 = threads-&gt;create(sub1, &rsquo;Param 1&rsquo;,
&rsquo;Param 2&rsquo;, $Param3); <br>
my @ParamList = (42, &rsquo;Hello&rsquo;, 3.14); <br>
my $thr2 = threads-&gt;create(sub1, @ParamList); <br>
my $thr3 = threads-&gt;create(sub1, qw(Param1 Param2
Param3));</p>

<p style="margin-top: 1em">sub sub1 { <br>
my @InboundParameters = @_; <br>
print(&quot;In the thread0); <br>
print(&rsquo;Got parameters &gt;&rsquo;,
join(&rsquo;&lt;&gt;&rsquo;, @InboundParameters),
&quot;&lt;0); <br>
}</p>

<p style="margin-top: 1em">The last example illustrates
another feature of threads. You can spawn off several
threads using the same subroutine. Each thread executes the
same subroutine, but in a <br>
separate thread with a separate environment and potentially
separate arguments.</p>

<p style="margin-top: 1em">&quot;new()&quot; is a synonym
for &quot;create()&quot;.</p>

<p style="margin-top: 1em">Waiting For A Thread To Exit
<br>
Since threads are also subroutines, they can return values.
To wait for a thread to exit and extract any values it might
return, you can use the &quot;join()&quot; method:</p>

<p style="margin-top: 1em">use threads;</p>

<p style="margin-top: 1em">my ($thr) =
threads-&gt;create(sub1);</p>

<p style="margin-top: 1em">my @ReturnData =
$thr-&gt;join(); <br>
print(&rsquo;Thread returned &rsquo;, join(&rsquo;, &rsquo;,
@ReturnData), &quot;0);</p>

<p style="margin-top: 1em">sub sub1 { return
(&rsquo;Fifty-six&rsquo;, &rsquo;foo&rsquo;, 2); }</p>

<p style="margin-top: 1em">In the example above, the
&quot;join()&quot; method returns as soon as the thread
ends. In addition to waiting for a thread to finish and
gathering up any values that the thread might <br>
have returned, &quot;join()&quot; also performs any OS
cleanup necessary for the thread. That cleanup might be
important, especially for long-running programs that spawn
lots of threads. <br>
If you don&rsquo;t want the return values and don&rsquo;t
want to wait for the thread to finish, you should call the
&quot;detach()&quot; method instead, as described next.</p>

<p style="margin-top: 1em">NOTE: In the example above, the
thread returns a list, thus necessitating that the thread
creation call be made in list context (i.e., &quot;my
($thr)&quot;). See &quot;$thr-&gt;join()&quot; in <br>
threads and &quot;THREAD CONTEXT&quot; in threads for more
details on thread context and return values.</p>

<p style="margin-top: 1em">Ignoring A Thread <br>
&quot;join()&quot; does three things: it waits for a thread
to exit, cleans up after it, and returns any data the thread
may have produced. But what if you&rsquo;re not interested
in the <br>
thread&rsquo;s return values, and you don&rsquo;t really
care when the thread finishes? All you want is for the
thread to get cleaned up after when it&rsquo;s done.</p>

<p style="margin-top: 1em">In this case, you use the
&quot;detach()&quot; method. Once a thread is detached,
it&rsquo;ll run until it&rsquo;s finished; then Perl will
clean up after it automatically.</p>

<p style="margin-top: 1em">use threads;</p>

<p style="margin-top: 1em">my $thr =
threads-&gt;create(sub1); # Spawn the thread</p>

<p style="margin-top: 1em">$thr-&gt;detach(); # Now we
officially don&rsquo;t care any more</p>

<p style="margin-top: 1em">sleep(15); # Let thread run for
awhile</p>

<p style="margin-top: 1em">sub sub1 { <br>
$a = 0; <br>
while (1) { <br>
$a++; <br>
print(&quot; is $a0); <br>
sleep(1); <br>
} <br>
}</p>

<p style="margin-top: 1em">Once a thread is detached, it
may not be joined, and any return data that it might have
produced (if it was done and waiting for a join) is
lost.</p>

<p style="margin-top: 1em">&quot;detach()&quot; can also be
called as a class method to allow a thread to detach
itself:</p>

<p style="margin-top: 1em">use threads;</p>

<p style="margin-top: 1em">my $thr =
threads-&gt;create(sub1);</p>

<p style="margin-top: 1em">sub sub1 { <br>
threads-&gt;detach(); <br>
# Do more work <br>
}</p>

<p style="margin-top: 1em">Process and Thread Termination
<br>
With threads one must be careful to make sure they all have
a chance to run to completion, assuming that is what you
want.</p>

<p style="margin-top: 1em">An action that terminates a
process will terminate all running threads. die() and exit()
have this property, and perl does an exit when the main
thread exits, perhaps implicitly <br>
by falling off the end of your code, even if that&rsquo;s
not what you want.</p>

<p style="margin-top: 1em">As an example of this case, this
code prints the message &quot;Perl exited with active
threads: 2 running and unjoined&quot;:</p>

<p style="margin-top: 1em">use threads; <br>
my $thr1 = threads-&gt;new(thrsub, &quot;test1&quot;); <br>
my $thr2 = threads-&gt;new(thrsub, &quot;test2&quot;); <br>
sub thrsub { <br>
my ($message) = @_; <br>
sleep 1; <br>
print &quot;thread $message0; <br>
}</p>

<p style="margin-top: 1em">But when the following lines are
added at the end:</p>

<p style="margin-top: 1em">$thr1-&gt;join(); <br>
$thr2-&gt;join();</p>

<p style="margin-top: 1em">it prints two lines of output, a
perhaps more useful outcome.</p>

<p style="margin-top: 1em">Threads And Data <br>
Now that we&rsquo;ve covered the basics of threads,
it&rsquo;s time for our next topic: Data. Threading
introduces a couple of complications to data access that
non-threaded programs never <br>
need to worry about.</p>

<p style="margin-top: 1em">Shared And Unshared Data <br>
The biggest difference between Perl ithreads and the old
5.005 style threading, or for that matter, to most other
threading systems out there, is that by default, no data is
<br>
shared. When a new Perl thread is created, all the data
associated with the current thread is copied to the new
thread, and is subsequently private to that new thread! This
is <br>
similar in feel to what happens when a Unix process forks,
except that in this case, the data is just copied to a
different part of memory within the same process rather than
a <br>
real fork taking place.</p>

<p style="margin-top: 1em">To make use of threading,
however, one usually wants the threads to share at least
some data between themselves. This is done with the
threads::shared module and the &quot;:shared&quot; <br>
attribute:</p>

<p style="margin-top: 1em">use threads; <br>
use threads::shared;</p>

<p style="margin-top: 1em">my $foo :shared = 1; <br>
my $bar = 1; <br>
threads-&gt;create(sub { $foo++; $bar++; })-&gt;join();</p>

<p style="margin-top: 1em">print(&quot;$foo0); # Prints 2
since $foo is shared <br>
print(&quot;$bar0); # Prints 1 since $bar is not shared</p>

<p style="margin-top: 1em">In the case of a shared array,
all the array&rsquo;s elements are shared, and for a shared
hash, all the keys and values are shared. This places
restrictions on what may be assigned to <br>
shared array and hash elements: only simple values or
references to shared variables are allowed - this is so that
a private variable can&rsquo;t accidentally become shared. A
bad <br>
assignment will cause the thread to die. For example:</p>

<p style="margin-top: 1em">use threads; <br>
use threads::shared;</p>

<p style="margin-top: 1em">my $var = 1; <br>
my $svar :shared = 2; <br>
my %hash :shared;</p>

<p style="margin-top: 1em">... create some threads ...</p>

<p style="margin-top: 1em">$hash{a} = 1; # All threads see
exists($hash{a}) and $hash{a} == 1 <br>
$hash{a} = $var; # okay - copy-by-value: same effect as
previous <br>
$hash{a} = $svar; # okay - copy-by-value: same effect as
previous <br>
$hash{a} = var; # okay - a reference to a shared variable
<br>
$hash{a} = ar; # This will die <br>
delete($hash{a}); # okay - all threads will see
!exists($hash{a})</p>

<p style="margin-top: 1em">Note that a shared variable
guarantees that if two or more threads try to modify it at
the same time, the internal state of the variable will not
become corrupted. However, there <br>
are no guarantees beyond this, as explained in the next
section.</p>

<p style="margin-top: 1em">Thread Pitfalls: Races <br>
While threads bring a new set of useful tools, they also
bring a number of pitfalls. One pitfall is the race
condition:</p>

<p style="margin-top: 1em">use threads; <br>
use threads::shared;</p>

<p style="margin-top: 1em">my $a :shared = 1; <br>
my $thr1 = threads-&gt;create(sub1); <br>
my $thr2 = threads-&gt;create(sub2);</p>

<p style="margin-top: 1em">$thr1-&gt;join(); <br>
$thr2-&gt;join(); <br>
print(&quot;$a0);</p>

<p style="margin-top: 1em">sub sub1 { my $foo = $a; $a =
$foo + 1; } <br>
sub sub2 { my $bar = $a; $a = $bar + 1; }</p>

<p style="margin-top: 1em">What do you think $a will be?
The answer, unfortunately, is it depends. Both
&quot;sub1()&quot; and &quot;sub2()&quot; access the global
variable $a, once to read and once to write. Depending on
<br>
factors ranging from your thread implementation&rsquo;s
scheduling algorithm to the phase of the moon, $a can be 2
or 3.</p>

<p style="margin-top: 1em">Race conditions are caused by
unsynchronized access to shared data. Without explicit
synchronization, there&rsquo;s no way to be sure that
nothing has happened to the shared data <br>
between the time you access it and the time you update it.
Even this simple code fragment has the possibility of
error:</p>

<p style="margin-top: 1em">use threads; <br>
my $a :shared = 2; <br>
my $b :shared; <br>
my $c :shared; <br>
my $thr1 = threads-&gt;create(sub { $b = $a; $a = $b + 1;
}); <br>
my $thr2 = threads-&gt;create(sub { $c = $a; $a = $c + 1;
}); <br>
$thr1-&gt;join(); <br>
$thr2-&gt;join();</p>

<p style="margin-top: 1em">Two threads both access $a. Each
thread can potentially be interrupted at any point, or be
executed in any order. At the end, $a could be 3 or 4, and
both $b and $c could be 2 <br>
or 3.</p>

<p style="margin-top: 1em">Even &quot;$a += 5&quot; or
&quot;$a++&quot; are not guaranteed to be atomic.</p>

<p style="margin-top: 1em">Whenever your program accesses
data or resources that can be accessed by other threads, you
must take steps to coordinate access or risk data
inconsistency and race conditions. <br>
Note that Perl will protect its internals from your race
conditions, but it won&rsquo;t protect you from you.</p>

<p style="margin-top: 1em">Synchronization and control <br>
Perl provides a number of mechanisms to coordinate the
interactions between themselves and their data, to avoid
race conditions and the like. Some of these are designed to
<br>
resemble the common techniques used in thread libraries such
as &quot;pthreads&quot;; others are Perl-specific. Often,
the standard techniques are clumsy and difficult to get
right (such <br>
as condition waits). Where possible, it is usually easier to
use Perlish techniques such as queues, which remove some of
the hard work involved.</p>

<p style="margin-top: 1em">Controlling access: lock() <br>
The &quot;lock()&quot; function takes a shared variable and
puts a lock on it. No other thread may lock the variable
until the variable is unlocked by the thread holding the
lock. <br>
Unlocking happens automatically when the locking thread
exits the block that contains the call to the
&quot;lock()&quot; function. Using &quot;lock()&quot; is
straightforward: This example has <br>
several threads doing some calculations in parallel, and
occasionally updating a running total:</p>

<p style="margin-top: 1em">use threads; <br>
use threads::shared;</p>

<p style="margin-top: 1em">my $total :shared = 0;</p>

<p style="margin-top: 1em">sub calc { <br>
while (1) { <br>
my $result; <br>
# (... do some calculations and set $result ...) <br>
{ <br>
lock($total); # Block until we obtain the lock <br>
$total += $result; <br>
} # Lock implicitly released at end of scope <br>
last if $result == 0; <br>
} <br>
}</p>

<p style="margin-top: 1em">my $thr1 =
threads-&gt;create(calc); <br>
my $thr2 = threads-&gt;create(calc); <br>
my $thr3 = threads-&gt;create(calc); <br>
$thr1-&gt;join(); <br>
$thr2-&gt;join(); <br>
$thr3-&gt;join(); <br>
print(&quot;total=$total0);</p>

<p style="margin-top: 1em">&quot;lock()&quot; blocks the
thread until the variable being locked is available. When
&quot;lock()&quot; returns, your thread can be sure that no
other thread can lock that variable until the <br>
block containing the lock exits.</p>

<p style="margin-top: 1em">It&rsquo;s important to note
that locks don&rsquo;t prevent access to the variable in
question, only lock attempts. This is in keeping with
Perl&rsquo;s longstanding tradition of courteous <br>
programming, and the advisory file locking that
&quot;flock()&quot; gives you.</p>

<p style="margin-top: 1em">You may lock arrays and hashes
as well as scalars. Locking an array, though, will not block
subsequent locks on array elements, just lock attempts on
the array itself.</p>

<p style="margin-top: 1em">Locks are recursive, which means
it&rsquo;s okay for a thread to lock a variable more than
once. The lock will last until the outermost
&quot;lock()&quot; on the variable goes out of scope. For
<br>
example:</p>

<p style="margin-top: 1em">my $x :shared; <br>
doit();</p>

<p style="margin-top: 1em">sub doit { <br>
{ <br>
{ <br>
lock($x); # Wait for lock <br>
lock($x); # NOOP - we already have the lock <br>
{ <br>
lock($x); # NOOP <br>
{ <br>
lock($x); # NOOP <br>
lockit_some_more(); <br>
} <br>
} <br>
} # *** Implicit unlock here *** <br>
} <br>
}</p>

<p style="margin-top: 1em">sub lockit_some_more { <br>
lock($x); # NOOP <br>
} # Nothing happens here</p>

<p style="margin-top: 1em">Note that there is no
&quot;unlock()&quot; function - the only way to unlock a
variable is to allow it to go out of scope.</p>

<p style="margin-top: 1em">A lock can either be used to
guard the data contained within the variable being locked,
or it can be used to guard something else, like a section of
code. In this latter case, <br>
the variable in question does not hold any useful data, and
exists only for the purpose of being locked. In this
respect, the variable behaves like the mutexes and basic
<br>
semaphores of traditional thread libraries.</p>

<p style="margin-top: 1em">A Thread Pitfall: Deadlocks <br>
Locks are a handy tool to synchronize access to data, and
using them properly is the key to safe shared data.
Unfortunately, locks aren&rsquo;t without their dangers,
especially when <br>
multiple locks are involved. Consider the following
code:</p>

<p style="margin-top: 1em">use threads;</p>

<p style="margin-top: 1em">my $a :shared = 4; <br>
my $b :shared = &rsquo;foo&rsquo;; <br>
my $thr1 = threads-&gt;create(sub { <br>
lock($a); <br>
sleep(20); <br>
lock($b); <br>
}); <br>
my $thr2 = threads-&gt;create(sub { <br>
lock($b); <br>
sleep(20); <br>
lock($a); <br>
});</p>

<p style="margin-top: 1em">This program will probably hang
until you kill it. The only way it won&rsquo;t hang is if
one of the two threads acquires both locks first. A
guaranteed-to-hang version is more <br>
complicated, but the principle is the same.</p>

<p style="margin-top: 1em">The first thread will grab a
lock on $a, then, after a pause during which the second
thread has probably had time to do some work, try to grab a
lock on $b. Meanwhile, the <br>
second thread grabs a lock on $b, then later tries to grab a
lock on $a. The second lock attempt for both threads will
block, each waiting for the other to release its lock.</p>

<p style="margin-top: 1em">This condition is called a
deadlock, and it occurs whenever two or more threads are
trying to get locks on resources that the others own. Each
thread will block, waiting for the <br>
other to release a lock on a resource. That never happens,
though, since the thread with the resource is itself waiting
for a lock to be released.</p>

<p style="margin-top: 1em">There are a number of ways to
handle this sort of problem. The best way is to always have
all threads acquire locks in the exact same order. If, for
example, you lock variables <br>
$a, $b, and $c, always lock $a before $b, and $b before $c.
It&rsquo;s also best to hold on to locks for as short a
period of time to minimize the risks of deadlock.</p>

<p style="margin-top: 1em">The other synchronization
primitives described below can suffer from similar
problems.</p>

<p style="margin-top: 1em">Queues: Passing Data Around <br>
A queue is a special thread-safe object that lets you put
data in one end and take it out the other without having to
worry about synchronization issues. They&rsquo;re pretty
<br>
straightforward, and look like this:</p>

<p style="margin-top: 1em">use threads; <br>
use Thread::Queue;</p>

<p style="margin-top: 1em">my $DataQueue =
Thread::Queue-&gt;new(); <br>
my $thr = threads-&gt;create(sub { <br>
while (my $DataElement = $DataQueue-&gt;dequeue()) { <br>
print(&quot;Popped $DataElement off the queue0); <br>
} <br>
});</p>

<p style="margin-top: 1em">$DataQueue-&gt;enqueue(12); <br>
$DataQueue-&gt;enqueue(&quot;A&quot;, &quot;B&quot;,
&quot;C&quot;); <br>
sleep(10); <br>
$DataQueue-&gt;enqueue(undef); <br>
$thr-&gt;join();</p>

<p style="margin-top: 1em">You create the queue with
&quot;Thread::Queue-&gt;new()&quot;. Then you can add lists
of scalars onto the end with &quot;enqueue()&quot;, and pop
scalars off the front of it with &quot;dequeue()&quot;. A
queue <br>
has no fixed size, and can grow as needed to hold everything
pushed on to it.</p>

<p style="margin-top: 1em">If a queue is empty,
&quot;dequeue()&quot; blocks until another thread enqueues
something. This makes queues ideal for event loops and other
communications between threads.</p>

<p style="margin-top: 1em">Semaphores: Synchronizing Data
Access <br>
Semaphores are a kind of generic locking mechanism. In their
most basic form, they behave very much like lockable
scalars, except that they can&rsquo;t hold data, and that
they must be <br>
explicitly unlocked. In their advanced form, they act like a
kind of counter, and can allow multiple threads to have the
lock at any one time.</p>

<p style="margin-top: 1em">Basic semaphores <br>
Semaphores have two methods, &quot;down()&quot; and
&quot;up()&quot;: &quot;down()&quot; decrements the resource
count, while &quot;up()&quot; increments it. Calls to
&quot;down()&quot; will block if the semaphore&rsquo;s
current <br>
count would decrement below zero. This program gives a quick
demonstration:</p>

<p style="margin-top: 1em">use threads; <br>
use Thread::Semaphore;</p>

<p style="margin-top: 1em">my $semaphore =
Thread::Semaphore-&gt;new(); <br>
my $GlobalVariable :shared = 0;</p>

<p style="margin-top: 1em">$thr1 =
threads-&gt;create(sample_sub, 1); <br>
$thr2 = threads-&gt;create(sample_sub, 2); <br>
$thr3 = threads-&gt;create(sample_sub, 3);</p>

<p style="margin-top: 1em">sub sample_sub { <br>
my $SubNumber = shift(@_); <br>
my $TryCount = 10; <br>
my $LocalCopy; <br>
sleep(1); <br>
while ($TryCount--) { <br>
$semaphore-&gt;down(); <br>
$LocalCopy = $GlobalVariable; <br>
print(&quot;$TryCount tries left for sub $SubNumber
(lobalVariable is $GlobalVariable)0); <br>
sleep(2); <br>
$LocalCopy++; <br>
$GlobalVariable = $LocalCopy; <br>
$semaphore-&gt;up(); <br>
} <br>
}</p>

<p style="margin-top: 1em">$thr1-&gt;join(); <br>
$thr2-&gt;join(); <br>
$thr3-&gt;join();</p>

<p style="margin-top: 1em">The three invocations of the
subroutine all operate in sync. The semaphore, though, makes
sure that only one thread is accessing the global variable
at once.</p>

<p style="margin-top: 1em">Advanced Semaphores <br>
By default, semaphores behave like locks, letting only one
thread &quot;down()&quot; them at a time. However, there are
other uses for semaphores.</p>

<p style="margin-top: 1em">Each semaphore has a counter
attached to it. By default, semaphores are created with the
counter set to one, &quot;down()&quot; decrements the
counter by one, and &quot;up()&quot; increments by one. <br>
However, we can override any or all of these defaults simply
by passing in different values:</p>

<p style="margin-top: 1em">use threads; <br>
use Thread::Semaphore;</p>

<p style="margin-top: 1em">my $semaphore =
Thread::Semaphore-&gt;new(5); <br>
# Creates a semaphore with the counter set to five</p>

<p style="margin-top: 1em">my $thr1 =
threads-&gt;create(sub1); <br>
my $thr2 = threads-&gt;create(sub1);</p>

<p style="margin-top: 1em">sub sub1 { <br>
$semaphore-&gt;down(5); # Decrements the counter by five
<br>
# Do stuff here <br>
$semaphore-&gt;up(5); # Increment the counter by five <br>
}</p>

<p style="margin-top: 1em">$thr1-&gt;detach(); <br>
$thr2-&gt;detach();</p>

<p style="margin-top: 1em">If &quot;down()&quot; attempts
to decrement the counter below zero, it blocks until the
counter is large enough. Note that while a semaphore can be
created with a starting count of zero, <br>
any &quot;up()&quot; or &quot;down()&quot; always changes
the counter by at least one, and so
&quot;$semaphore-&gt;down(0)&quot; is the same as
&quot;$semaphore-&gt;down(1)&quot;.</p>

<p style="margin-top: 1em">The question, of course, is why
would you do something like this? Why create a semaphore
with a starting count that&rsquo;s not one, or why decrement
or increment it by more than one? <br>
The answer is resource availability. Many resources that you
want to manage access for can be safely used by more than
one thread at once.</p>

<p style="margin-top: 1em">For example, let&rsquo;s take a
GUI driven program. It has a semaphore that it uses to
synchronize access to the display, so only one thread is
ever drawing at once. Handy, but of <br>
course you don&rsquo;t want any thread to start drawing
until things are properly set up. In this case, you can
create a semaphore with a counter set to zero, and up it
when things <br>
are ready for drawing.</p>

<p style="margin-top: 1em">Semaphores with counters greater
than one are also useful for establishing quotas. Say, for
example, that you have a number of threads that can do I/O
at once. You don&rsquo;t want <br>
all the threads reading or writing at once though, since
that can potentially swamp your I/O channels, or deplete
your process&rsquo;s quota of filehandles. You can use a
semaphore <br>
initialized to the number of concurrent I/O requests (or
open files) that you want at any one time, and have your
threads quietly block and unblock themselves.</p>

<p style="margin-top: 1em">Larger increments or decrements
are handy in those cases where a thread needs to check out
or return a number of resources at once.</p>

<p style="margin-top: 1em">Waiting for a Condition <br>
The functions &quot;cond_wait()&quot; and
&quot;cond_signal()&quot; can be used in conjunction with
locks to notify co-operating threads that a resource has
become available. They are very similar <br>
in use to the functions found in &quot;pthreads&quot;.
However for most purposes, queues are simpler to use and
more intuitive. See threads::shared for more details.</p>

<p style="margin-top: 1em">Giving up control <br>
There are times when you may find it useful to have a thread
explicitly give up the CPU to another thread. You may be
doing something processor-intensive and want to make sure
<br>
that the user-interface thread gets called frequently.
Regardless, there are times that you might want a thread to
give up the processor.</p>

<p style="margin-top: 1em">Perl&rsquo;s threading package
provides the &quot;yield()&quot; function that does this.
&quot;yield()&quot; is pretty straightforward, and works
like this:</p>

<p style="margin-top: 1em">use threads;</p>

<p style="margin-top: 1em">sub loop { <br>
my $thread = shift; <br>
my $foo = 50; <br>
while($foo--) { print(&quot;In thread $thread0); } <br>
threads-&gt;yield(); <br>
$foo = 50; <br>
while($foo--) { print(&quot;In thread $thread0); } <br>
}</p>

<p style="margin-top: 1em">my $thr1 =
threads-&gt;create(loop, &rsquo;first&rsquo;); <br>
my $thr2 = threads-&gt;create(loop, &rsquo;second&rsquo;);
<br>
my $thr3 = threads-&gt;create(loop,
&rsquo;third&rsquo;);</p>

<p style="margin-top: 1em">It is important to remember that
&quot;yield()&quot; is only a hint to give up the CPU, it
depends on your hardware, OS and threading libraries what
actually happens. On many operating <br>
systems, yield() is a no-op. Therefore it is important to
note that one should not build the scheduling of the threads
around &quot;yield()&quot; calls. It might work on your
platform but <br>
it won&rsquo;t work on another platform.</p>

<p style="margin-top: 1em">General Thread Utility Routines
<br>
We&rsquo;ve covered the workhorse parts of Perl&rsquo;s
threading package, and with these tools you should be well
on your way to writing threaded code and packages. There are
a few useful <br>
little pieces that didn&rsquo;t really fit in anyplace
else.</p>

<p style="margin-top: 1em">What Thread Am I In? <br>
The &quot;threads-&gt;self()&quot; class method provides
your program with a way to get an object representing the
thread it&rsquo;s currently in. You can use this object in
the same way as the <br>
ones returned from thread creation.</p>

<p style="margin-top: 1em">Thread IDs <br>
&quot;tid()&quot; is a thread object method that returns the
thread ID of the thread the object represents. Thread IDs
are integers, with the main thread in a program being 0.
Currently <br>
Perl assigns a unique TID to every thread ever created in
your program, assigning the first thread to be created a TID
of 1, and increasing the TID by 1 for each new thread <br>
that&rsquo;s created. When used as a class method,
&quot;threads-&gt;tid()&quot; can be used by a thread to get
its own TID.</p>

<p style="margin-top: 1em">Are These Threads The Same? <br>
The &quot;equal()&quot; method takes two thread objects and
returns true if the objects represent the same thread, and
false if they don&rsquo;t.</p>

<p style="margin-top: 1em">Thread objects also have an
overloaded &quot;==&quot; comparison so that you can do
comparison on them as you would with normal objects.</p>

<p style="margin-top: 1em">What Threads Are Running? <br>
&quot;threads-&gt;list()&quot; returns a list of thread
objects, one for each thread that&rsquo;s currently running
and not detached. Handy for a number of things, including
cleaning up at the end <br>
of your program (from the main Perl thread, of course):</p>

<p style="margin-top: 1em"># Loop through all the threads
<br>
foreach my $thr (threads-&gt;list()) { <br>
$thr-&gt;join(); <br>
}</p>

<p style="margin-top: 1em">If some threads have not
finished running when the main Perl thread ends, Perl will
warn you about it and die, since it is impossible for Perl
to clean up itself while other <br>
threads are running.</p>

<p style="margin-top: 1em">NOTE: The main Perl thread
(thread 0) is in a detached state, and so does not appear in
the list returned by &quot;threads-&gt;list()&quot;.</p>

<p style="margin-top: 1em">A Complete Example <br>
Confused yet? It&rsquo;s time for an example program to show
some of the things we&rsquo;ve covered. This program finds
prime numbers using threads.</p>

<p style="margin-top: 1em">1 #!/usr/bin/perl <br>
2 # prime-pthread, courtesy of Tom Christiansen <br>
3 <br>
4 use strict; <br>
5 use warnings; <br>
6 <br>
7 use threads; <br>
8 use Thread::Queue; <br>
9 <br>
10 sub check_num { <br>
11 my ($upstream, $cur_prime) = @_; <br>
12 my $kid; <br>
13 my $downstream = Thread::Queue-&gt;new(); <br>
14 while (my $num = $upstream-&gt;dequeue()) { <br>
15 next unless ($num % $cur_prime); <br>
16 if ($kid) { <br>
17 $downstream-&gt;enqueue($num); <br>
18 } else { <br>
19 print(&quot;Found prime: $num0); <br>
20 $kid = threads-&gt;create(check_num, $downstream, $num);
<br>
21 if (! $kid) { <br>
22 warn(&quot;Sorry. Ran out of threads.0); <br>
23 last; <br>
24 } <br>
25 } <br>
26 } <br>
27 if ($kid) { <br>
28 $downstream-&gt;enqueue(undef); <br>
29 $kid-&gt;join(); <br>
30 } <br>
31 } <br>
32 <br>
33 my $stream = Thread::Queue-&gt;new(3..1000, undef); <br>
34 check_num($stream, 2);</p>

<p style="margin-top: 1em">This program uses the pipeline
model to generate prime numbers. Each thread in the pipeline
has an input queue that feeds numbers to be checked, a prime
number that it&rsquo;s <br>
responsible for, and an output queue into which it funnels
numbers that have failed the check. If the thread has a
number that&rsquo;s failed its check and there&rsquo;s no
child thread, <br>
then the thread must have found a new prime number. In that
case, a new child thread is created for that prime and stuck
on the end of the pipeline.</p>

<p style="margin-top: 1em">This probably sounds a bit more
confusing than it really is, so let&rsquo;s go through this
program piece by piece and see what it does. (For those of
you who might be trying to <br>
remember exactly what a prime number is, it&rsquo;s a number
that&rsquo;s only evenly divisible by itself and 1.)</p>

<p style="margin-top: 1em">The bulk of the work is done by
the &quot;check_num()&quot; subroutine, which takes a
reference to its input queue and a prime number that
it&rsquo;s responsible for. After pulling in the input <br>
queue and the prime that the subroutine is checking (line
11), we create a new queue (line 13) and reserve a scalar
for the thread that we&rsquo;re likely to create later (line
12).</p>

<p style="margin-top: 1em">The while loop from line 14 to
line 26 grabs a scalar off the input queue and checks
against the prime this thread is responsible for. Line 15
checks to see if there&rsquo;s a <br>
remainder when we divide the number to be checked by our
prime. If there is one, the number must not be evenly
divisible by our prime, so we need to either pass it on to
the <br>
next thread if we&rsquo;ve created one (line 17) or create a
new thread if we haven&rsquo;t.</p>

<p style="margin-top: 1em">The new thread creation is line
20. We pass on to it a reference to the queue we&rsquo;ve
created, and the prime number we&rsquo;ve found. In lines 21
through 24, we check to make sure <br>
that our new thread got created, and if not, we stop
checking any remaining numbers in the queue.</p>

<p style="margin-top: 1em">Finally, once the loop
terminates (because we got a 0 or &quot;undef&quot; in the
queue, which serves as a note to terminate), we pass on the
notice to our child, and wait for it to exit <br>
if we&rsquo;ve created a child (lines 27 and 30).</p>

<p style="margin-top: 1em">Meanwhile, back in the main
thread, we first create a queue (line 33) and queue up all
the numbers from 3 to 1000 for checking, plus a termination
notice. Then all we have to do <br>
to get the ball rolling is pass the queue and the first
prime to the &quot;check_num()&quot; subroutine (line
34).</p>

<p style="margin-top: 1em">That&rsquo;s how it works.
It&rsquo;s pretty simple; as with many Perl programs, the
explanation is much longer than the program.</p>

<p style="margin-top: 1em">Different implementations of
threads <br>
Some background on thread implementations from the operating
system viewpoint. There are three basic categories of
threads: user-mode threads, kernel threads, and
multiprocessor <br>
kernel threads.</p>

<p style="margin-top: 1em">User-mode threads are threads
that live entirely within a program and its libraries. In
this model, the OS knows nothing about threads. As far as
it&rsquo;s concerned, your process <br>
is just a process.</p>

<p style="margin-top: 1em">This is the easiest way to
implement threads, and the way most OSes start. The big
disadvantage is that, since the OS knows nothing about
threads, if one thread blocks they all <br>
do. Typical blocking activities include most system calls,
most I/O, and things like &quot;sleep()&quot;.</p>

<p style="margin-top: 1em">Kernel threads are the next step
in thread evolution. The OS knows about kernel threads, and
makes allowances for them. The main difference between a
kernel thread and a user- <br>
mode thread is blocking. With kernel threads, things that
block a single thread don&rsquo;t block other threads. This
is not the case with user-mode threads, where the kernel
blocks <br>
at the process level and not the thread level.</p>

<p style="margin-top: 1em">This is a big step forward, and
can give a threaded program quite a performance boost over
non-threaded programs. Threads that block performing I/O,
for example, won&rsquo;t block <br>
threads that are doing other things. Each process still has
only one thread running at once, though, regardless of how
many CPUs a system might have.</p>

<p style="margin-top: 1em">Since kernel threading can
interrupt a thread at any time, they will uncover some of
the implicit locking assumptions you may make in your
program. For example, something as <br>
simple as &quot;$a = $a + 2&quot; can behave unpredictably
with kernel threads if $a is visible to other threads, as
another thread may have changed $a between the time it was
fetched on <br>
the right hand side and the time the new value is
stored.</p>

<p style="margin-top: 1em">Multiprocessor kernel threads
are the final step in thread support. With multiprocessor
kernel threads on a machine with multiple CPUs, the OS may
schedule two or more threads <br>
to run simultaneously on different CPUs.</p>

<p style="margin-top: 1em">This can give a serious
performance boost to your threaded program, since more than
one thread will be executing at the same time. As a
tradeoff, though, any of those nagging <br>
synchronization issues that might not have shown with basic
kernel threads will appear with a vengeance.</p>

<p style="margin-top: 1em">In addition to the different
levels of OS involvement in threads, different OSes (and
different thread implementations for a particular OS)
allocate CPU cycles to threads in <br>
different ways.</p>

<p style="margin-top: 1em">Cooperative multitasking systems
have running threads give up control if one of two things
happen. If a thread calls a yield function, it gives up
control. It also gives up <br>
control if the thread does something that would cause it to
block, such as perform I/O. In a cooperative multitasking
implementation, one thread can starve all the others for
<br>
CPU time if it so chooses.</p>

<p style="margin-top: 1em">Preemptive multitasking systems
interrupt threads at regular intervals while the system
decides which thread should run next. In a preemptive
multitasking system, one thread <br>
usually won&rsquo;t monopolize the CPU.</p>

<p style="margin-top: 1em">On some systems, there can be
cooperative and preemptive threads running simultaneously.
(Threads running with realtime priorities often behave
cooperatively, for example, while <br>
threads running at normal priorities behave
preemptively.)</p>

<p style="margin-top: 1em">Most modern operating systems
support preemptive multitasking nowadays.</p>

<p style="margin-top: 1em">Performance considerations <br>
The main thing to bear in mind when comparing Perl&rsquo;s
ithreads to other threading models is the fact that for each
new thread created, a complete copy of all the variables and
<br>
data of the parent thread has to be taken. Thus, thread
creation can be quite expensive, both in terms of memory
usage and time spent in creation. The ideal way to reduce
these <br>
costs is to have a relatively short number of long-lived
threads, all created fairly early on (before the base thread
has accumulated too much data). Of course, this may not <br>
always be possible, so compromises have to be made. However,
after a thread has been created, its performance and extra
memory usage should be little different than ordinary <br>
code.</p>

<p style="margin-top: 1em">Also note that under the current
implementation, shared variables use a little more memory
and are a little slower than ordinary variables.</p>

<p style="margin-top: 1em">Process-scope Changes <br>
Note that while threads themselves are separate execution
threads and Perl data is thread-private unless explicitly
shared, the threads can affect process-scope state,
affecting <br>
all the threads.</p>

<p style="margin-top: 1em">The most common example of this
is changing the current working directory using
&quot;chdir()&quot;. One thread calls &quot;chdir()&quot;,
and the working directory of all the threads changes.</p>

<p style="margin-top: 1em">Even more drastic example of a
process-scope change is &quot;chroot()&quot;: the root
directory of all the threads changes, and no thread can undo
it (as opposed to &quot;chdir()&quot;).</p>

<p style="margin-top: 1em">Further examples of
process-scope changes include &quot;umask()&quot; and
changing uids and gids.</p>

<p style="margin-top: 1em">Thinking of mixing
&quot;fork()&quot; and threads? Please lie down and wait
until the feeling passes. Be aware that the semantics of
&quot;fork()&quot; vary between platforms. For example, some
<br>
Unix systems copy all the current threads into the child
process, while others only copy the thread that called
&quot;fork()&quot;. You have been warned!</p>

<p style="margin-top: 1em">Similarly, mixing signals and
threads may be problematic. Implementations are
platform-dependent, and even the POSIX semantics may not be
what you expect (and Perl doesn&rsquo;t even <br>
give you the full POSIX API). For example, there is no way
to guarantee that a signal sent to a multi-threaded Perl
application will get intercepted by any particular thread.
<br>
(However, a recently added feature does provide the
capability to send signals between threads. See &quot;THREAD
SIGNALLING&quot; in threads for more details.)</p>

<p style="margin-top: 1em">Thread-Safety of System
Libraries <br>
Whether various library calls are thread-safe is outside the
control of Perl. Calls often suffering from not being
thread-safe include: &quot;localtime()&quot;,
&quot;gmtime()&quot;, functions <br>
fetching user, group and network information (such as
&quot;getgrent()&quot;, &quot;gethostent()&quot;,
&quot;getnetent()&quot; and so on), &quot;readdir()&quot;,
&quot;rand()&quot;, and &quot;srand()&quot;. In general,
calls that depend <br>
on some global external state.</p>

<p style="margin-top: 1em">If the system Perl is compiled
in has thread-safe variants of such calls, they will be
used. Beyond that, Perl is at the mercy of the thread-safety
or -unsafety of the calls. <br>
Please consult your C library call documentation.</p>

<p style="margin-top: 1em">On some platforms the
thread-safe library interfaces may fail if the result buffer
is too small (for example the user group databases may be
rather large, and the reentrant <br>
interfaces may have to carry around a full snapshot of those
databases). Perl will start with a small buffer, but keep
retrying and growing the result buffer until the result <br>
fits. If this limitless growing sounds bad for security or
memory consumption reasons you can recompile Perl with
&quot;PERL_REENTRANT_MAXSIZE&quot; defined to the maximum
number of bytes <br>
you will allow.</p>

<p style="margin-top: 1em">Conclusion <br>
A complete thread tutorial could fill a book (and has, many
times), but with what we&rsquo;ve covered in this
introduction, you should be well on your way to becoming a
threaded Perl <br>
expert.</p>

<p style="margin-top: 1em">SEE ALSO <br>
Annotated POD for threads:
&lt;http://annocpan.org/?mode=search&amp;field=Module&amp;name=threads&gt;</p>

<p style="margin-top: 1em">Latest version of threads on
CPAN:
&lt;http://search.cpan.org/search?module=threads&gt;</p>

<p style="margin-top: 1em">Annotated POD for
threads::shared:
&lt;http://annocpan.org/?mode=search&amp;field=Module&amp;name=threads%3A%3Ashared&gt;</p>

<p style="margin-top: 1em">Latest version of
threads::shared on CPAN:
&lt;http://search.cpan.org/search?module=threads%3A%3Ashared&gt;</p>

<p style="margin-top: 1em">Perl threads mailing list:
&lt;http://lists.perl.org/list/ithreads.html&gt;</p>

<p style="margin-top: 1em">Bibliography <br>
Here&rsquo;s a short bibliography courtesy of JA~Xrgen
Christoffel:</p>

<p style="margin-top: 1em">Introductory Texts <br>
Birrell, Andrew D. An Introduction to Programming with
Threads. Digital Equipment Corporation, 1989, DEC-SRC
Research Report #35 online as <br>
ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf
(highly recommended)</p>

<p style="margin-top: 1em">Robbins, Kay. A., and Steven
Robbins. Practical Unix Programming: A Guide to Concurrency,
Communication, and Multithreading. Prentice-Hall, 1996.</p>

<p style="margin-top: 1em">Lewis, Bill, and Daniel J. Berg.
Multithreaded Programming with Pthreads. Prentice Hall,
1997, ISBN 0-13-443698-9 (a well-written introduction to
threads).</p>

<p style="margin-top: 1em">Nelson, Greg (editor). Systems
Programming with Modula-3. Prentice Hall, 1991, ISBN
0-13-590464-1.</p>

<p style="margin-top: 1em">Nichols, Bradford, Dick Buttlar,
and Jacqueline Proulx Farrell. Pthreads Programming.
O&rsquo;Reilly &amp; Associates, 1996, ISBN 156592-115-1
(covers POSIX threads).</p>

<p style="margin-top: 1em">OS-Related References <br>
Boykin, Joseph, David Kirschen, Alan Langerman, and Susan
LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN
0-201-52739-1.</p>

<p style="margin-top: 1em">Tanenbaum, Andrew S. Distributed
Operating Systems. Prentice Hall, 1995, ISBN 0-13-219908-4
(great textbook).</p>

<p style="margin-top: 1em">Silberschatz, Abraham, and Peter
B. Galvin. Operating System Concepts, 4th ed.
Addison-Wesley, 1995, ISBN 0-201-59292-4</p>

<p style="margin-top: 1em">Other References <br>
Arnold, Ken and James Gosling. The Java Programming
Language, 2nd ed. Addison-Wesley, 1998, ISBN
0-201-31006-6.</p>

<p style="margin-top: 1em">comp.programming.threads FAQ,
http://www.serpentine.com/~bos/threads-faq/
&lt;http://www.serpentine.com/~bos/threads-faq/&gt;</p>

<p style="margin-top: 1em">Le Sergent, T. and B.
Berthomieu. &quot;Incremental MultiThreaded Garbage
Collection on Virtually Shared Memory Architectures&quot; in
Memory Management: Proc. of the International <br>
Workshop IWMM 92, St. Malo, France, September 1992, Yves
Bekkers and Jacques Cohen, eds. Springer, 1992, ISBN
3540-55940-X (real-life thread applications).</p>

<p style="margin-top: 1em">Artur Bergman, &quot;Where
Wizards Fear To Tread&quot;, June 11, 2002,
&lt;http://www.perl.com/pub/a/2002/06/11/threads.html&gt;</p>

<p style="margin-top: 1em">Acknowledgements <br>
Thanks (in no particular order) to Chaim Frenkel, Steve
Fink, Gurusamy Sarathy, Ilya Zakharevich, Benjamin Sugars,
JA~Xrgen Christoffel, Joshua Pritikin, and Alan Burlison,
for <br>
their help in reality-checking and polishing this article.
Big thanks to Tom Christiansen for his rewrite of the prime
number generator.</p>

<p style="margin-top: 1em">AUTHOR <br>
Dan Sugalski &lt;dan@sidhe.org&lt;gt&gt;</p>

<p style="margin-top: 1em">Slightly modified by Arthur
Bergman to fit the new thread model/module.</p>

<p style="margin-top: 1em">Reworked slightly by JA~Xrg
Walter &lt;jwalt@cpan.org&lt;gt&gt; to be more concise about
thread-safety of Perl code.</p>

<p style="margin-top: 1em">Rearranged slightly by Elizabeth
Mattijsen &lt;liz@dijkmat.nl&lt;gt&gt; to put less emphasis
on yield().</p>

<p style="margin-top: 1em">Copyrights <br>
The original version of this article originally appeared in
The Perl Journal #10, and is copyright 1998 The Perl
Journal. It appears courtesy of Jon Orwant and The Perl
Journal. <br>
This document may be distributed under the same terms as
Perl itself.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLTHRTUT(1)</p>
<hr>
</body>
</html>
