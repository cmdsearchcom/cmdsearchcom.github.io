<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>MAKEPP_VARIABLES(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MAKEPP_VARIABLES(1)</td>
    <td class="head-vol">Makepp</td>
    <td class="head-rtitle">MAKEPP_VARIABLES(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
makepp_variables -- How to use variables in makepp
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>?:</b>&#x00A0;$*,
<br/>
 $+,
<br/>
 $/,
<br/>
 $&lt;,
<br/>
 $?,
<br/>
 $@,
<br/>
 $^,
<br/>
 =,
<br/>
 !=,
<br/>
 &amp;=,
<br/>
 +=,
<br/>
 :=,
<br/>
 ;=,
<br/>
 ?=,&#x00A0; <b>A:</b>&#x00A0;AR,
<br/>
 ARFLAGS,
<br/>
 AS,&#x00A0; <b>C:</b>&#x00A0;CC,
<br/>
 CFLAGS,
<br/>
 &quot;changed_dependencies&quot;,
<br/>
 changed_inputs,
<br/>
 CURDIR,
<br/>
 CXX,
<br/>
 CXXFLAGS,&#x00A0; <b>D:</b>&#x00A0;&quot;dependencies&quot;,
<br/>
 &quot;dependency&quot;,&#x00A0; <b>F:</b>&#x00A0;F77,
<br/>
 FC,
<br/>
 &quot;foreach&quot;,&#x00A0; <b>I:</b>&#x00A0;input,
<br/>
 inputs,&#x00A0; <b>L:</b>&#x00A0;LD,
<br/>
 LEX,
<br/>
 LIBTOOL,&#x00A0; <b>M:</b>&#x00A0;MAKE,
<br/>
 MAKECMDGOALS,
<br/>
 MAKEFLAGS,
<br/>
 MAKEINFO,
<br/>
 MAKEPP_DEBUG,
<br/>
 MAKEPPFLAGS,
<br/>
 _MAKEPPFLAGS,
<br/>
 MAKEPP_LN_CP,
<br/>
 &quot;makepp_percent_subdirs&quot;,
<br/>
 &quot;makepp_require_phony&quot;,
<br/>
 makepp_signature_C_flat,
<br/>
 &quot;makepp_simple_concatenation&quot;,
<br/>
 MAKEPP_VERSION,&#x00A0; <b>O:</b>&#x00A0;&quot;output&quot;,
<br/>
 &quot;outputs&quot;,&#x00A0; <b>P:</b>&#x00A0;PERL,
<br/>
 PWD,&#x00A0; <b>R:</b>&#x00A0;RM,
<br/>
 ROOT,&#x00A0; <b>S:</b>&#x00A0;SHELL,
<br/>
 &quot;sorted_dependencies&quot;,
<br/>
 sorted_inputs,
<br/>
 &quot;stem&quot;,&#x00A0; <b>T:</b>&#x00A0;target,
<br/>
 targets,&#x00A0; <b>V:</b>&#x00A0;VPATH,&#x00A0; <b>Y:</b>&#x00A0;YACC
<div class="Pp"></div>
Makefiles typically use variables in many places. One important reason for using
  variables is to ensure that information is contained in only one place in the
  makefile, so that if it changes, there is no danger of the two copies of the
  information getting out of sync.
<div class="Pp"></div>
Variable names are case sensitive. In theory, variable names can be made of many
  characters, but makepp will probably not be able to grok it if you do anything
  other than alphanumeric characters, &quot;_&quot;, and &quot;-&quot;.
<div class="Pp"></div>
Each makefile has its own set of variables, and setting a variable in one
  makefile will have no effect on its value in any other makefile. If you want
  to have variables set in many makefiles, the best way to do it is to have each
  of them include a common definitions file (see the include statement) or use
  &quot;global&quot; variables.
<h2 class="Ss" title="Ss" id="Variable_Assignment"><a class="selflink" href="#Variable_Assignment">Variable
  Assignment</a></h2>
A variable can assume a value in several different ways:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A variable may be set inside a makefile. There are a number
      of different ways to do this; see below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A variable's value may be specified on the command line,
      like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    makepp CFLAGS=-O2 my_program
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If more than one makefile is loaded, the CFLAGS variable is propagated to
      all of the makefiles. Variables set on the command line automatically
      override any setting of the variable in any of the makefiles.
    <div style="height: 1.00em;">&#x00A0;</div>
    If ever needed, the makefile must in turn explicitly override command line
      settings. The intention is not to ignore what the user requests, but
      rather a way to modify it. The &quot;override&quot; modifier may precede
      any assignment statement. But in the case of keyword statements, the order
      is important, which is why the override variant is always shown below. The
      &quot;override&quot; modifier applies only to any assignments where it is
      present, and does not influence later assignments to the variable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If a variable is set in the environment, it can be
      referenced as a makepp variable. Ordinarily assignments to variables
      inside a makefile override settings from the environment, but you can
      change this by using the &quot;-e&quot; or
      &quot;--environment-overrides&quot; command line option.</dd>
</dl>
<div class="Pp"></div>
Variables are assigned with one of several assignment expressions, like this
<div class="Pp"></div>
<pre>
    X = 1
    MODULES := a b c d
    CC ?= gcc
    CFLAGS += -Wall
    define VAR
      var line 1
      var line 2
    enddef
    export PATH := $(PWD):$(PATH)
    global MYPROJECT.INFO = info to be seen in all makefiles
</pre>
<div class="Pp"></div>
Leading and trailing whitespace around values is always stripped off.
<div class="Pp"></div>
The different assignment operators have somewhat different meanings.
<div class="Pp"></div>
<i>Simple assignment operators</i>
<dl class="Bl-tag">
  <dt class="It-tag">=</dt>
  <dd class="It-tag">
    <pre>
    VARIABLE = text string
    override VARIABLE = text string
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This is the usual assignment statement that all implementations of make
      support. The expression on the right hand side is not evaluated until the
      value of &quot;$(VARIABLE)&quot; is actually used somewhere. Thus, if you
      do the following:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    X = 1
    Y = $(X)
    X = 2
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Then &quot;$(Y)&quot; later in the makefile will evaluate to &quot;2&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    In general, you usually want to use &quot;:=&quot; (see below) instead of
      &quot;=&quot; because it provides more predictable variable evaluation.
      However, there are times when you need to defer the variable evaluation.
      Also, if you're writing a makefile that must be backwards-compatible with
      some version of make other than GNU make, then you have no choice: you may
      only use &quot;=&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">:=</dt>
  <dd class="It-tag">
    <pre>
    VARIABLE := expr
    override VARIABLE := expr
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This is the same as &quot;VARIABLE = expr&quot; except that the right hand
      side is evaluated once and for all at the time of the assignment. Thus if
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    X := 1
    Y := $(X)
    X := 2
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    then &quot;$(Y)&quot; later in the makefile will evaluate to &quot;1&quot;
      since that's what &quot;$(X)&quot; was when &quot;$(Y)&quot; was
    defined.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">;=</dt>
  <dd class="It-tag">
    <pre>
    VARIABLE ;= expr
    override VARIABLE ;= expr
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This is the same as &quot;VARIABLE := expr&quot; except that the right hand
      side is evaluated only at the time of the first use and then remembered.
      This is useful for expensive commands, which always return the same value,
      but which you don't want to perform when building unrelated targets:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    VAR1 ;= $(perl expensive calculations)
    VAR2 ;= $(shell external command)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that old makefiles will usually use &quot;:=&quot; here, to at least do
      this only once. But with this operator you can even additionally not do
      it, if you currently don't need the value. For values which are identical
      in several directories, you can optimize this further with
      &quot;global&quot;, discussed below.
    <div style="height: 1.00em;">&#x00A0;</div>
    However this is not intended as a clever way to force order of evaluation.
      If a variable defined like this includes the value of another variable,
      and that other one has a target specific value, and the first expansion is
      for that target, then the target specific value will stick for all other
      contexts as well. This is a bug and will hopefully be fixed in the
    future.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">+=</dt>
  <dd class="It-tag">
    <pre>
    VARIABLE += expr
    override VARIABLE += expr
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Appends the string to the previous contents of the variable, separated by a
      space. If the variable was previously assigned with &quot;:=&quot;, then
      the right hand side is evaluated before appending.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;=</dt>
  <dd class="It-tag">
    <pre>
    VARIABLE &amp;= expr
    override VARIABLE &amp;= expr
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Prepends the string to the previous contents of the variable, separated by a
      space. If the variable was previously assigned with &quot;:=&quot;, then
      the right hand side is evaluated before appending.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example one way of guaranteeing that &quot;CFLAGS&quot;, whatever else
      the user may put in, always starts with &quot;-Wall&quot; are these two
      lines:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    CFLAGS = -O2                # Possibly overridden on the command line
    override CFLAGS &amp;= -Wall    # Unconditionally prepended
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    In old makefiles you typically had to do something like this, which had the
      side effect of forcing the type to &quot;:=&quot; to prevent endless
      recursion:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    VARIABLE := expr $(VARIABLE)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?=</dt>
  <dd class="It-tag">
    <pre>
    VARIABLE ?= expr
    override VARIABLE ?= expr   # Useless, but legal
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Sets the value of the variable, but only if the variable is not specified
      earlier in the makefile, on the command line, or in the environment. The
      above assignment is exactly equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    ifndef VARIABLE
      VARIABLE = expr
    endif
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">!=</dt>
  <dd class="It-tag">
    <pre>
    VARIABLE != shell command
    override VARIABLE != shell command
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Runs the shell command and sets the variable to contain the command's
      standard output. This is exactly equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    VARIABLE := $(shell command)
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
<i>Multiline variables</i>
<div class="Pp"></div>
The &quot;define&quot; statement is the multiline equivalent of the simple
  statements above. The operator after the variable is optional. If missing, it
  is equivalent to &quot;define VARIABLE =&quot;. The &quot;&amp;=&quot; and
  &quot;+=&quot; operators are slightly different here, in that they glue this
  to the old value with a newline, rather than a space. There must not be
  anything except a comment after the statement, i.e. the value starts on the
  next line.
<div class="Pp"></div>
<pre>
    define VARIABLE :=
    first line of variable's value
    second line of variable's value
    third line of variable's value
    endef
    override define VARIABLE
    ...
    enddef
</pre>
<div class="Pp"></div>
Keywords before &quot;define&quot; can be combinations of either one of
  &quot;export&quot; or &quot;global&quot; and &quot;override&quot;.
<div class="Pp"></div>
If you need a variable's value to contain newlines, you must use the
  &quot;define&quot; statement as shown (or you can assign the value directly in
  Perl). (&quot;endef&quot; was chosen for compatibility with GNU make. You may
  also use &quot;enddef&quot;.) This is primarily useful for &quot;canned
  command sequences&quot;, e.g., something like this:
<div class="Pp"></div>
<pre>
    define COMPILE_C_PROGRAM
        @&amp;echo &quot;Compiling $(input)&quot;
        @$(CC) $(CFLAGS) $(CPPFLAGS) $(INCLUDES) -c $(input) -o $(output)
    endef
</pre>
<div class="Pp"></div>
Then you can use this multi-line variable in several rules, like this:
<div class="Pp"></div>
<pre>
    %.o : %.c
        $(COMPILE_C_PROGRAM)
    $(ARCH)/%.o : $(ARCH)/%.c
        $(COMPILE_C_PROGRAM)
</pre>
<div class="Pp"></div>
Note that you can often achieve the same effect by using a semicolon instead of
  a newline, because the shell interprets that as a command delimeter too. For
  example,
<div class="Pp"></div>
<pre>
    COMPILE_C_PROGRAM = @echo &quot;Compiling $(input)&quot;; \
        $(CC) $(CFLAGS) $(CPPFLAGS) $(INCLUDES) -c $(input) -o $(output)
</pre>
<div class="Pp"></div>
will have the same effect, except that the semicolon forces Perl to pass it to
  the shell, instead of executing the command directly and more efficiently. You
  also have to put each builtin on a line of its own, meaning that you have to
  switch to the external echo in the semicolon case.
<div class="Pp"></div>
There is one speciality when expanding within &quot;define&quot;, i.e.
  &quot;define X :=&quot; or on a variable that was already &quot;:=&quot;,
  &quot;define X &amp;=&quot; and &quot;define X +=&quot;. In this case the
  &quot;$(shell command ...)&quot; or builtin &quot;$(&amp;command ...)&quot; do
  not get newlines transformed into spaces.
<div class="Pp"></div>
<i>Exporting variables to subprocesses</i>
<div class="Pp"></div>
<pre>
    export VAR ...
    export VAR = value
    override export VAR += value
</pre>
<div class="Pp"></div>
The first form marks the given variables for export to subprocesses, with
  whatever value the variable then has. The second form, which applies only to
  one variable, additionally assigns a value right away. All the variants of
  assignment are allowed.
<div class="Pp"></div>
<i>Sharing variables across makefiles</i>
<div class="Pp"></div>
<pre>
    global VAR ...
    global VAR = value
    override global VAR &amp;= value
</pre>
<div class="Pp"></div>
The first form marks the given variables as global to all makefiles. If any of
  them already had a value, that value is moved from the makefile local variable
  to the global one. However if, at the time this statement is seen, any other
  makefiles already had a value for any of them, then those makefiles will not
  see the global one.
<div class="Pp"></div>
The second form, which applies only to one variable, additionally assigns a
  value right away. All the variants of assignment are allowed. Note that
  &quot;:=&quot; will expand right away to the values in the local makefile. On
  the contrary &quot;=&quot; variables will expand to the values at the point of
  use.
<div class="Pp"></div>
Global variables can be tricky to deal with, because makepp may load makefiles
  in any order, as the need arises to build some target for which no rule or
  makefiles is loaded. For this reason it is recommended to have a
  <i>RootMakeppfile</i> and to explicitly load all others which modify or use
  the variable with &quot;load-makefile&quot;.
<div class="Pp"></div>
<pre>
    global GLIBLIBS ;= $(shell pkg-config --libs glib-2.0)
</pre>
<div class="Pp"></div>
Also note that your project may some day be built together with other projects.
  For this reason it is recommended to always make the project name part of any
  global variable name.
<div class="Pp"></div>
<i>Target-specific assignments</i>
<div class="Pp"></div>
<pre>
    target: VARIABLE = string
    target: VARIABLE := string
    target: override VARIABLE += string
</pre>
<div class="Pp"></div>
Sets a target-specific value of the variable. A target-specific value is in
  effect <i>only</i> in an action which produces the given target. This is
  primarily used for things like this:
<div class="Pp"></div>
<pre>
    CFLAGS := -O2
 
    my_prog: file1.o file2.o special_file.o
 
    special_file.o : CFLAGS := -g
 
    %.o: %.c
          $(CC) $(CFLAGS) -c $(input) -o $(output)
</pre>
<div class="Pp"></div>
What happens here is that all &quot;.c&quot; files will be compiled with
  optimization (&quot;-O2&quot;) <i>except</i> &quot;special_file.c&quot;, which
  is compiled in debug mode (&quot;-g&quot;). This is a convenient way to
  specify different compilation options for only a few files.
<div class="Pp"></div>
Target-specific variable assignments like this apply only to the actions of the
  rule; they are not in effect when evaluating the targets or the dependencies
  of a rule. If a rule has more than one target, target-specific variable
  assignments are taken only from the <i>first</i> target. Also note that
  makepp's target-specific variables are slightly different from GNU make's in
  that they only apply to the rule for the one file mentioned, and not to any of
  its predecessors.
<div class="Pp"></div>
Wildcard expansion is performed on the target, so you can do something like
  this:
<div class="Pp"></div>
<pre>
    test_*.o : CFLAGS += -DTEST
</pre>
<div class="Pp"></div>
For compatibility with GNU make, &quot;%&quot; may be used in place of
  &quot;*&quot;.
<h2 class="Ss" title="Ss" id="Variable_Substitution"><a class="selflink" href="#Variable_Substitution">Variable
  Substitution</a></h2>
Makepp's variable substitution rules are similar to those of other makes, but
  somewhat more powerful. As in all makes, &quot;$(CC)&quot; or
  &quot;${CC}&quot; both represent the value of the variable CC. If you need a
  literal dollar sign, put in a double dollar sign ($$), like this:
<div class="Pp"></div>
<pre>
    target: dep1 dep2 dep3 dep4
        &amp;rm -f $(output)
        for file in $(inputs); do cat $$file &gt;&gt; $(output); done
</pre>
<div class="Pp"></div>
Additionally makepp has a &quot;$[VARIABLE]&quot; syntax, which does the same
  thing as the other two, but before makepp groks anything else. This allows
  using it for complete rules and/or conditionals:
<div class="Pp"></div>
<pre>
    define bracket_rule =
      ifdef SOME_VAR
        bracket:
            &amp;echo this is a rule -o $(output)
      endif
    enddef
    $[bracket_rule]
</pre>
<div class="Pp"></div>
<i>rc-style substitution</i>
<div class="Pp"></div>
By default, makepp uses rc-style substitution (so called because it was
  pioneered by the rc shell). This is best illustrated by an example:
<div class="Pp"></div>
<pre>
    MODULES = a b c d
 
    mylib.a : module_dir/$(MODULES).o $(OTHER_OBJECTS)
        $(CXX) $(dependencies) -o $(target)
</pre>
<div class="Pp"></div>
The prefix &quot;module_dir/&quot; is prepended to each word in MODULES, and the
  suffix &quot;.o&quot; is appended to each word.
<div class="Pp"></div>
You can also use rc-style substitution without even putting the list of words
  into a variable; the syntax is &quot;$(&#x00A0;word1&#x00A0;word2)&quot;. Note
  the space between the parenthesis and the first word. So the above example
  could have been written as:
<div class="Pp"></div>
<pre>
    mylib.a : module_dir/$( a b c d).o $(OTHER_OBJECTS)
        $(CXX) $(dependencies) -o $(target)
</pre>
<div class="Pp"></div>
A variable will give rc-style substitution only when there is more than one word
  in it. With one word it is like traditional make. Alas, when the variable is
  empty, there is a conflict. Traditional makes simply expand it to the empty
  string. But when you think of it as a list, you'd want
  &quot;-I$(DIRLIST)&quot; to disapear, not to give a lonely &quot;-I&quot;. The
  solution is to wrap it into a list that starts with a space: &quot;-I$(
  $(DIRLIST))&quot; gives you exactly as many options, as there are words in the
  list.
<div class="Pp"></div>
If you put several variables in the same word which expand to arrays of words,
  rc-style substitution actually takes the cartesian product, so you can do
  something like this if you want:
<div class="Pp"></div>
<pre>
    DIRS = s1 s2
    MODULES = a b c
    SUFFIXES = .o .c
    FILES := $(DIRS)/$(MODULES)$(SUFFIXES)
</pre>
<div class="Pp"></div>
and FILES will contain the string
<div class="Pp"></div>
<pre>
    s1/a.o s1/a.c s1/b.o s1/b.c s1/c.o s1/c.c s2/a.o s2/a.c s2/b.o s2/b.c s2/c.o s2/c.c
</pre>
<div class="Pp"></div>
Besides white space, rc-style substitution stops at any quote, any round, curly
  or square parentheses, and any of &quot;, : ; = # @&quot;. Note that this may
  be surprising, and again need an explicit list. Say you want to look for
  headers by wildcard in all directories starting with an upper-case letter:
<div class="Pp"></div>
<pre>
    BAD := [A-Z]*/**/*.$( hpp h)        # [A-Z]*/**/*.hpp */**/*.h
    GOOD := $( [A-Z]*/**/*.)$( hpp h)   # [A-Z]*/**/*.hpp [A-Z]*/**/*.h
</pre>
<div class="Pp"></div>
If rc-style substitution gets in the way, or if you need to have leading or
  trailing whitespace in your make variables, then you can turn off rc-style
  substitution by setting the variable
  &quot;makepp_simple_concatenation=1&quot;. You can turn it off globally on the
  command line or as an environment variable. Or on a per-makefile basis by
  setting the variable in your makefile. You should do this near the top of the
  makefile, or else you may run into funny situations where rc-style
  substitution is used for some evaluations and not others. (All expressions
  evaluated before the assignment will use rc-style substitutions, and all
  expressions evaluated after will not. Since the time of evaluation of
  expressions in makefiles is complicated and not always obvious from the order
  of statements in the makefile, it's best to set
  &quot;makepp_simple_concatenation&quot; as early as possible.) You can even
  set it just for one target:
<div class="Pp"></div>
<pre>
    target: makepp_simple_concatenation = 1
    target:
        &amp;echo before_first$(LIST)after_last -o $(output)
</pre>
<div class="Pp"></div>
Because &quot;$[VARIABLE]&quot; is evaluated earlier than
  &quot;$(VARIABLE)&quot;, combining the two in rc-substitution will not give
  the result you may expect, unless you wrap it in an explicit list:
<div class="Pp"></div>
<pre>
    A = a b
    N = 1 2
    BAD := $(A)$[N]
    GOOD := $(A)$( $[N])
</pre>
<div class="Pp"></div>
The last lines get read as
<div class="Pp"></div>
<pre>
    BAD := $(A)1 2      # a1 b1 2
    GOOD := $(A)$( 1 2) # a1 a2 b1 b2
</pre>
<div class="Pp"></div>
<i>Substitution References</i>
<div class="Pp"></div>
A substitution reference has the form &quot;$(VAR:A=B)&quot;, where A is a
  pattern to match and B is a pattern to replace it with. Substitution
  references are an abbreviation for the &quot;patsubst&quot; function. For
  example:
<div class="Pp"></div>
<pre>
    source_files = a.c b.c c.c d.c
    object_files = $(source_files:%.c=%.o)
</pre>
<div class="Pp"></div>
will set &quot;$(object_files)&quot; to
  &quot;a.o&#x00A0;b.o&#x00A0;c.o&#x00A0;d.o&quot;. The &quot;%&quot; is a
  special character matches any arbitrary string. If both A and B start with
  &quot;%&quot;, a common case when replacing suffixes, they can be omitted:
<div class="Pp"></div>
<pre>
    object_files = $(source_files:.c=.o)
    object_files = $(source_files:c=o) # same, because . is not special
</pre>
<div class="Pp"></div>
<i>Whitespace in variables</i>
<div class="Pp"></div>
If you need to control the whitespace in a variable, you must (currently)
  disable rc-style substitution (by setting
  &quot;makepp_simple_concatenation=1&quot;) and then use a syntax like this:
<div class="Pp"></div>
<pre>
    null =
    T = -o $(null)
</pre>
<div class="Pp"></div>
or, with an empty evaluation:
<div class="Pp"></div>
<pre>
    T = -o $()
</pre>
<div class="Pp"></div>
When you do this, the variable &quot;T&quot; contains &quot;-o&quot; followed by
  a space.
<div class="Pp"></div>
This kind of a technique to handle whitespace is not recommended. If you need
  variables in your makefile to contain spaces, you should think seriously about
  what you're doing. If you need to handle spaces, it is usually much better to
  put Perl code into your makefile to take care of it (using the
  &quot;perl_begin&quot; or &quot;sub&quot; statements), or to handle it in
  shell statements in the actions of rules.
<div class="Pp"></div>
These cases typically come up when people attempt to use the same rules for
  different architectures which do not use typical Unix command syntax. E.g.,
  sometimes one sees things like this in makefiles:
<div class="Pp"></div>
<pre>
    ifeq ($(ARCH),weirdarch)
      O := /OUTPUT=
    else
      null :=
      O := -o $(null)
    endif
 
    %.o : %.c
        $(COMPILER) $(input) $(O)$(output)
</pre>
<div class="Pp"></div>
You can do this with makepp if you really want to, but you will probably find
  that your makefiles are substantially more readable if you have less
  complicated variable substitution, e.g.,
<div class="Pp"></div>
<pre>
    ifeq ($(ARCH),weirdarch)
      %.o : %.c
        $(WEIRD_COMPILER) $(input) /OUTPUT=$(output)
    else
      %.o : %.c
        $(CC) -c $(input) -o $(output)
    endif
</pre>
<div class="Pp"></div>
Whitespace is never allowed in variable names, only in their values. This is
  different from some make implementations.
<h2 class="Ss" title="Ss" id="Automatic_Variables"><a class="selflink" href="#Automatic_Variables">Automatic
  Variables</a></h2>
Automatic variables are variables that assume different values depending on
  which rule they are evaluated in. Makepp supports most of the automatic
  variables that other versions of make use. In addition, it has less cryptic,
  longer names for most of them that you can use instead. (For legacy makefiles
  that happen to redefine these names, the definition in the makefile overrides
  the default meaning. For example, if you say
  &quot;target&#x00A0;=&#x00A0;abc&quot; in your makefile, then
  &quot;$(target)&quot; will always expand to &quot;abc&quot;, and will no
  longer be equivalent to $@.)
<div class="Pp"></div>
The following is a complete list of all the automatic variables that makepp
  supports:
<dl class="Bl-tag">
  <dt class="It-tag">output</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">target</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$@</dt>
  <dd class="It-tag">The target of the current rule. Actually, since makepp
      supports multiple targets for any rule, this is the <b>first</b> target.
      For example, in the following rule
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    y.tab.c y.tab.h : parser.y
        $(YACC) -o $(output) $(YFLAGS) $(input)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;$(output)&quot; will contain the value <i>y.tab.c</i>. Since these
      magic variables are in fact functions, you can also pass an index as
      argument. This counts from 1 or backwards from -1. So &quot;$(output
      2)&quot; or &quot;$(output -1)&quot; will contain the value
      <i>y.tab.h</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    While all three forms of this variable have the same value, there is a
      difference in interpretation for multitarget rules. If you use the
      old-style cryptic name $@, makepp will interpret that as an old-style rule
      set, rather than a modern rule that produces all those targets in one go:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    a b:                        # really: one rule each for a and b
        touch $@
 
    c d:                        # error: mpp complains that this didn't build d
        touch $(output)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">outputs</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">targets</dt>
  <dd class="It-tag">All targets of the current rule. Same as
      &quot;$(target)&quot; unless there is more than one target. In the above
      example, &quot;$(outputs)&quot; will be y.tab.c&#x00A0;y.tab.h. You can
      pass an index list, so &quot;$(outputs 2 1)&quot; will be
      y.tab.h&#x00A0;y.tab.c.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dependency</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">input</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$&lt;</dt>
  <dd class="It-tag">The first explicit dependency of the rule. For example, in
      this rule
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.o : %.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;$(input)&quot; will be the name of the <i>.c</i> file, regardless of
      what <i>.h</i> files makepp discovers. If you specify more than one
      dependency, you can get them by passing an index: &quot;$(input
      $(INDEX))&quot; is the INDEXth dependency.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dependencies</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">inputs</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$^</dt>
  <dd class="It-tag">All the explicit dependencies of the target, not including
      <i>.h</i> files discovered by makepp_scanning for includes.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, in the rule
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    myprog.o : *.o
        $(CC) $(CFLAGS) $(inputs) -o $(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;$(inputs)&quot; will be all the .o files in the directory. You can
      pick only the ones you want by passing an index list. If you explicitly
      specify different kinds of files, you can pick them as in &quot;$(inputs 2
      3 4)&quot; (but with a wildcard this is not too promising).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sorted_dependencies</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sorted_inputs</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$+</dt>
  <dd class="It-tag">All the dependencies of the target, in sorted order, with
      duplicates removed. Equivalent to
    &quot;$(sort&#x00A0;$(inputs))&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">changed_dependencies</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">changed_inputs</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$?</dt>
  <dd class="It-tag">The dependencies of the target that have changed. This
      includes only explicit dependencies (i.e., ones you list in the makefile),
      not implicitly discovered dependencies from scanning (such as .h files).
    <div style="height: 1.00em;">&#x00A0;</div>
    This is commonly used in commands like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    libmine.a : $(MODULES) : build_check ignore_action
        $(AR) ru $@ $?
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    i.e., <i>ar</i> is told to replace only those modules that have changed.
      (Note the &quot;ignore_action&quot; build check rule. If you don't specify
      this, makepp will force the action to be executed whenever it changes. If
      no dependencies have changed, the action string will be
      &quot;ar&#x00A0;ru&#x00A0;libmine.a&quot; which is probably different from
      what it was last time you ran it, so without &quot;ignore_action&quot;
      makepp will execute it. In this case, it's harmless, but with other
      commands, it could be a problem. See makepp_build_check for details on
      &quot;ignore_action&quot;.)
    <div style="height: 1.00em;">&#x00A0;</div>
    Building archives like this is not a good idea because it will make your
      builds less reliable. The problem with this is that if you build the
      archive, then remove one of the modules from the list of MODULES, the
      modules will still be in the archive and makepp</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">stem</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$*</dt>
  <dd class="It-tag">The stem in a pattern rule (i.e., whatever the '%'
      matched). Alternatively, if this is not a pattern rule, returns the file
      name without the extension (i.e., it's equivalent to
      &quot;$(basename&#x00A0;$(input))&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is mostly for backward compatibility. For example, in old versions of
      make the only way to tell it how to compile any <i>.c</i> file into the
      corresponding <i>.o</i> file was like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    .c.o:
        $(CC) $(CFLAGS) -c $*.c -o $*.o
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This is a lousy way to write the rule. It's much clearer to use GNU-make
      style pattern rules, like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %.o : %.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">foreach</dt>
  <dd class="It-tag">The current filename from the &quot;foreach&quot; clause.
      &quot;foreach&quot; clauses are rarely used, but they are the most
      general-purpose kind of pattern rule that makepp supports. For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    #
    # Build .c files with some sort of a special preprocessor:
    #
    %.c : %.k
        $(preprocessor) $(input) &gt; $(output)
 
    #
    # Compile .c files into .o files:
    #
    %.o : %.c
        $(CC) $(CFLAGS) -c $(input) -o $(output)
 
    #
    # Special alternate compilation flags for .c files which are derived
    # from .k files:
    #
    $(foreach:%.k=%.o) : $(foreach:%.k=%.c) : foreach *.k
        $(CC) $(SPECIAL_K_FLAGS) -c $(input) -o $(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See the documentation on the foreach clause in rules for more details and
      examples.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$/</dt>
  <dd class="It-tag">This is essentially a constant, either &quot;/&quot;, or on
      native Windows &quot;\&quot;. You need it, if you want to start a program
      portably, e.g. one you built in the current directory:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    myoutput:
        .$/myprog &gt;$(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    For filenames passed as arguments it is not so necessary as Windows can
      handle Unix syntax there.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Option_Variables"><a class="selflink" href="#Option_Variables">Option
  Variables</a></h2>
You can set these in all the ways explained above (except if stated otherwise)
  to modify the bahaviour of makepp. By default they are all undefined.
<dl class="Bl-tag">
  <dt class="It-tag">MAKEPP_DEBUG</dt>
  <dd class="It-tag">If you export this with a true value before calling makepp,
      you get more debugging info. This is the &quot;RULE_SOURCE&quot; of files
      built while this is in effect under makeppinfo, mppi and details about
      variable expansion and rule matching under makepplog, mppl. This will also
      show you if makepp runs out of memory or hangs, because it is endlessly
      expanding the same variables:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    A = $A                      # deferred evaluation, need :=
    B = $C
    C = $B
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MAKEPP_LN_CP</dt>
  <dd class="It-tag">See the note under &amp;ln.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makepp_percent_subdirs</dt>
  <dd class="It-tag">Set this to some true value (like 1) to have &quot;%&quot;
      in targets or dependencies match across more than one directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makepp_require_phony</dt>
  <dd class="It-tag">Set this to some true value (like 1) to prevent implicit
      phonyness (i.e. if a rule succeeds without producing its target). This
      variable should be true by default, to prevent broken dependency chains,
      but that would break backward compatibility with sloppy makefiles.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makepp_signature_C_flat</dt>
  <dd class="It-tag">This is an option to signature C. Set this to some true
      value (like 1) to treat your sources as flattened, i.e. all newlines
      (except around preprocessor statements) are treated like whitespace and
      &quot;#line&quot; directives are ignored.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makepp_simple_concatenation</dt>
  <dd class="It-tag">Set this to some true value (like 1) to prevent
      &quot;rc-style substitution&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">PERL</dt>
  <dd class="It-tag">You can set this to the exact perl you are using to run the
      scripts in the makepp suite, and export it. This can help to run
      sub-scripts with the same perl. This is mostly useful for the test suite,
      the installation and for recursive builds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">VPATH</dt>
  <dd class="It-tag">Setting this variable to some value implicitly calls
      &quot;vpath % value&quot;.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Predefined_Variables"><a class="selflink" href="#Predefined_Variables">Predefined
  Variables</a></h2>
Makepp predefines a few variables, which you can override:
<dl class="Bl-tag">
  <dt class="It-tag">AR</dt>
  <dd class="It-tag"><i>Default:</i> &quot;ar&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ARFLAGS</dt>
  <dd class="It-tag"><i>Default:</i> &quot;rv&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">AS</dt>
  <dd class="It-tag"><i>Default:</i> &quot;as&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">CC</dt>
  <dd class="It-tag"><i>Default:</i> The first found among &quot;gcc&quot;,
      &quot;egcc&quot;, &quot;pgcc&quot;, &quot;c89&quot; or &quot;cc&quot;, or
      on Windows additionally &quot;cl&quot; or &quot;bcc32&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">CFLAGS</dt>
  <dd class="It-tag"><i>Default:</i> If &quot;$(CC)&quot; is a GNU compiler
      &quot;-g -Wall&quot;, if it is one of the two Windows compilers nothing,
      else &quot;-g&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">CURDIR</dt>
  <dd class="It-tag">The directory in which the current Makefile resides.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">CXX</dt>
  <dd class="It-tag"><i>Default:</i> The first found among &quot;g++&quot;,
      &quot;c++&quot;, &quot;pg++&quot;, &quot;cxx&quot;,
      &quot;C&quot;&quot;C&quot; or &quot;aCC&quot;, or on Windows additionally
      &quot;cl&quot; or &quot;bcc32&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">CXXFLAGS</dt>
  <dd class="It-tag"><i>Default:</i> If &quot;$(CXX)&quot; is a GNU compiler
      &quot;-g -Wall&quot;, if it is one of the two Windows compilers nothing,
      else &quot;-g&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">F77</dt>
  <dd class="It-tag"><i>Default:</i> The first found among &quot;f77&quot;,
      &quot;g77&quot; or &quot;fort77&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">FC</dt>
  <dd class="It-tag"><i>Default:</i> &quot;$(F77)&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">LD</dt>
  <dd class="It-tag"><i>Default:</i> &quot;ld&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">LEX</dt>
  <dd class="It-tag"><i>Default:</i> The first found among &quot;lex&quot; or
      &quot;flex&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">LIBTOOL</dt>
  <dd class="It-tag"><i>Default:</i> &quot;libtool&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MAKE</dt>
  <dd class="It-tag">This variable has two different values, depending on the
      presence or not of &quot;--traditional-recursive-make&quot;. Makepp
      recognizes when this variable is used and turns off some features, even
      before the recursion actually takes place. This can be undesirable while
      you are gradually eliminating it, so first convert the calls to a makepp
      specific &quot;$((MAKE))&quot;, which will not turn off features. You
      should not set it because that breaks our smart recursion work
    around.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MAKECMDGOALS</dt>
  <dd class="It-tag">This variable is set but not used by makepp. You can query
      it to do something only if a certain target was requested.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>Default:</i> Whatever explicit targets the user (or a recursive
      invocation) provided. Empty when implicitly building default target.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    ifneq $(filter special-target, $(MAKECMDGOALS))
        # special-target is one of the current explicit targets
    else ifeq $(MAKECMDGOALS)
        # no explicit targets
    endif
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MAKEFLAGS (exported)</dt>
  <dd class="It-tag">The standard options with which makepp was called. Those
      that have a single letter form are combined at the beginning without a
      leading &quot;-&quot; (heaven knows why gmake chose to drop the
      &quot;-&quot;).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MAKEINFO</dt>
  <dd class="It-tag"><i>Default:</i> &quot;makeinfo&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MAKEPPFLAGS (exported)</dt>
  <dd class="It-tag">This is set to the same value as MAKEFLAGS, but only if
      this variable is present in makepp's environment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">_MAKEPPFLAGS (exported)</dt>
  <dd class="It-tag">The makepp specific options needed for POSIX/gmake
      compatibility, with which makepp was called. These are in a separate
      variable so a legacy makefile can't break compatibility by unsetting
      MAKEFLAGS. This is only set with
    &quot;--traditional-recursive-make&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MAKEPP_VERSION</dt>
  <dd class="It-tag">The version of makepp you are running with. If it is a beta
      version, it will have a hyphen followed by YYMMDD plus some more internal
      data. You can use this for &quot;ifdef&quot; to hide makepp specific
      constructs from other makes.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>Default:</i> The same value displayed by &quot;makepp
    --version&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">PWD</dt>
  <dd class="It-tag">An alias for &quot;CURDIR&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">RM</dt>
  <dd class="It-tag"><i>Default:</i> &quot;rm -f&quot;. This is meant for legacy
      Makefiles. For new ones preferably use the builtin &amp;rm command
      directly. If you want to write a phony clean rule, look at the
      &quot;makeppclean -r&quot; command instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ROOT</dt>
  <dd class="It-tag">The relative path to the root of your build system, i.e.
      the directory further up in which you have a
      &quot;RootMakeppfile(.mk)&quot;. If you don't have one, this variable is
      empty.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">SHELL</dt>
  <dd class="It-tag">This variable is only respected if you &quot;export&quot;
      it. In that case it is the Shell which is used to execute not-builtin
      actions with some special character in it (plain ones being exec`ed
      directly). On Windows Strawberry or ActiveState Perl, if you have a
      Unix-like Shell, you must instead set your SHELL variable to a value
      ending in &quot;sh&quot; or &quot;sh.exe&quot; <b>before</b> calling
      makepp.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>Default:</i> The first found among &quot;/usr/xpg4/bin/sh&quot; (e.g.
      Solaris) or &quot;/sbin/xpg4/sh&quot; (e.g. Reliant Unix) or
      &quot;/bin/sh&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">YACC</dt>
  <dd class="It-tag"><i>Default:</i> The first found among &quot;bison -y&quot;
      or &quot;yacc&quot;.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Variables_and_Perl"><a class="selflink" href="#Variables_and_Perl">Variables
  and Perl</a></h2>
Variable values are stored as ordinary Perl scalars, so you can access them
  directly from Perl code if you need to do any complicated manipulations with
  them; see makepp_extending for details.
<div class="Pp"></div>
Accessing global variables from Perl is achieved by prefixing them with the
  &quot;Mpp::global&quot; package. In fact any variable, not yet present in the
  current makefile, and which you assign to in this package will from then on be
  global, as though you had just issued the &quot;global&quot; statement for it.
<div class="Pp"></div>
This direct access is however error-prone! The user may have overridden these
  variables on the command line or through the environment. Some other makefile
  loaded before this one may have made the variable global or target specific.
  In these cases you would not find the value of the variable, or when assigning
  it, might take away its property (equivalent to an &quot;override&quot;
  modifier, except for target specifics.)
<div class="Pp"></div>
With direct access you also bypass the expansion of these variables, if they are
  of type &quot;=&quot; or &quot;;=&quot;. Special variables like
  &quot;$(CC)&quot; start out as functions, until they are assigned to. So in
  many cases you won't see their value.
<div class="Pp"></div>
For these reasons it is better to let makepp determine the correct value. You
  can use the &quot;makeperl&quot; variant, in which the variable has been
  evaluated before the Perl code gets interpreted:
<div class="Pp"></div>
<pre>
    makeperl { $$current_value = '$(MAKEFILE_VAR)' }
</pre>
<div class="Pp"></div>
If you need a variable in makefile perl blocks this is achieved via the Perl
  variable $makefile as follows:
<div class="Pp"></div>
<pre>
    perl { $current_value = $makefile-&gt;expand_variable( 'MAKE_VAR' ) }
</pre>
<div class="Pp"></div>
Functions always get the makefile object passed in as the second argument $_[1]:
<div class="Pp"></div>
<pre>
    sub f_f { $current_value = $_[1]-&gt;expand_variable( 'MAKE_VAR' ) }
</pre>
<div class="Pp"></div>
Commands are supposed to be called within a rule action, where the makefile
  object is accessible via &quot;$Mpp::Subs::rule-&gt;{MAKEFILE}&quot;:
<div class="Pp"></div>
<pre>
    sub c_cmd { $current_value = $Mpp::Subs::rule-&gt;{MAKEFILE}-&gt;expand_variable( 'MAKE_VAR' ) }
</pre>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Gary Holt (holt-makepp@gholt.net)</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-28</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
