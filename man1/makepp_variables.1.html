<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:23:48 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MAKEPP_VARIABLES(1) Makepp MAKEPP_VARIABLES(1)</p>

<p style="margin-top: 1em">NAME <br>
makepp_variables -- How to use variables in makepp</p>

<p style="margin-top: 1em">DESCRIPTION <br>
?: $*, <br>
$+, <br>
$/, <br>
$&lt;, <br>
$?, <br>
$@, <br>
$^, <br>
=, <br>
!=, <br>
&amp;=, <br>
+=, <br>
:=, <br>
;=, <br>
?=, A: AR, <br>
ARFLAGS, <br>
AS, C: CC, <br>
CFLAGS, <br>
&quot;changed_dependencies&quot;, <br>
changed_inputs, <br>
CURDIR, <br>
CXX, <br>
CXXFLAGS, D: &quot;dependencies&quot;, <br>
&quot;dependency&quot;, F: F77, <br>
FC, <br>
&quot;foreach&quot;, I: input, <br>
inputs, L: LD, <br>
LEX, <br>
LIBTOOL, M: MAKE, <br>
MAKECMDGOALS, <br>
MAKEFLAGS, <br>
MAKEINFO, <br>
MAKEPP_DEBUG, <br>
MAKEPPFLAGS, <br>
_MAKEPPFLAGS, <br>
MAKEPP_LN_CP, <br>
&quot;makepp_percent_subdirs&quot;, <br>
&quot;makepp_require_phony&quot;, <br>
makepp_signature_C_flat, <br>
&quot;makepp_simple_concatenation&quot;, <br>
MAKEPP_VERSION, O: &quot;output&quot;, <br>
&quot;outputs&quot;, P: PERL, <br>
PWD, R: RM, <br>
ROOT, S: SHELL, <br>
&quot;sorted_dependencies&quot;, <br>
sorted_inputs, <br>
&quot;stem&quot;, T: target, <br>
targets, V: VPATH, Y: YACC</p>

<p style="margin-top: 1em">Makefiles typically use
variables in many places. One important reason for using
variables is to ensure that information is contained in only
one place in the makefile, so that <br>
if it changes, there is no danger of the two copies of the
information getting out of sync.</p>

<p style="margin-top: 1em">Variable names are case
sensitive. In theory, variable names can be made of many
characters, but makepp will probably not be able to grok it
if you do anything other than <br>
alphanumeric characters, &quot;_&quot;, and
&quot;-&quot;.</p>

<p style="margin-top: 1em">Each makefile has its own set of
variables, and setting a variable in one makefile will have
no effect on its value in any other makefile. If you want to
have variables set in <br>
many makefiles, the best way to do it is to have each of
them include a common definitions file (see the include
statement) or use &quot;global&quot; variables.</p>

<p style="margin-top: 1em">Variable Assignment <br>
A variable can assume a value in several different ways:</p>

<p style="margin-top: 1em">&Acirc;&middot; A variable may
be set inside a makefile. There are a number of different
ways to do this; see below.</p>

<p style="margin-top: 1em">&Acirc;&middot; A
variable&rsquo;s value may be specified on the command line,
like this:</p>

<p style="margin-top: 1em">makepp CFLAGS=-O2 my_program</p>

<p style="margin-top: 1em">If more than one makefile is
loaded, the CFLAGS variable is propagated to all of the
makefiles. Variables set on the command line automatically
override any setting of the <br>
variable in any of the makefiles.</p>

<p style="margin-top: 1em">If ever needed, the makefile
must in turn explicitly override command line settings. The
intention is not to ignore what the user requests, but
rather a way to modify it. <br>
The &quot;override&quot; modifier may precede any assignment
statement. But in the case of keyword statements, the order
is important, which is why the override variant is always
<br>
shown below. The &quot;override&quot; modifier applies only
to any assignments where it is present, and does not
influence later assignments to the variable.</p>

<p style="margin-top: 1em">&Acirc;&middot; If a variable is
set in the environment, it can be referenced as a makepp
variable. Ordinarily assignments to variables inside a
makefile override settings from the <br>
environment, but you can change this by using the
&quot;-e&quot; or &quot;--environment-overrides&quot;
command line option.</p>

<p style="margin-top: 1em">Variables are assigned with one
of several assignment expressions, like this</p>

<p style="margin-top: 1em">X = 1 <br>
MODULES := a b c d <br>
CC ?= gcc <br>
CFLAGS += -Wall <br>
define VAR <br>
var line 1 <br>
var line 2 <br>
enddef <br>
export PATH := $(PWD):$(PATH) <br>
global MYPROJECT.INFO = info to be seen in all makefiles</p>

<p style="margin-top: 1em">Leading and trailing whitespace
around values is always stripped off.</p>

<p style="margin-top: 1em">The different assignment
operators have somewhat different meanings.</p>

<p style="margin-top: 1em">Simple assignment operators</p>

<p style="margin-top: 1em">= <br>
VARIABLE = text string <br>
override VARIABLE = text string</p>

<p style="margin-top: 1em">This is the usual assignment
statement that all implementations of make support. The
expression on the right hand side is not evaluated until the
value of &quot;$(VARIABLE)&quot; is <br>
actually used somewhere. Thus, if you do the following:</p>

<p style="margin-top: 1em">X = 1 <br>
Y = $(X) <br>
X = 2</p>

<p style="margin-top: 1em">Then &quot;$(Y)&quot; later in
the makefile will evaluate to &quot;2&quot;.</p>

<p style="margin-top: 1em">In general, you usually want to
use &quot;:=&quot; (see below) instead of &quot;=&quot;
because it provides more predictable variable evaluation.
However, there are times when you need to defer <br>
the variable evaluation. Also, if you&rsquo;re writing a
makefile that must be backwards-compatible with some version
of make other than GNU make, then you have no choice: you
may <br>
only use &quot;=&quot;.</p>

<p style="margin-top: 1em">:= <br>
VARIABLE := expr <br>
override VARIABLE := expr</p>

<p style="margin-top: 1em">This is the same as
&quot;VARIABLE = expr&quot; except that the right hand side
is evaluated once and for all at the time of the assignment.
Thus if</p>

<p style="margin-top: 1em">X := 1 <br>
Y := $(X) <br>
X := 2</p>

<p style="margin-top: 1em">then &quot;$(Y)&quot; later in
the makefile will evaluate to &quot;1&quot; since
that&rsquo;s what &quot;$(X)&quot; was when &quot;$(Y)&quot;
was defined.</p>

<p style="margin-top: 1em">;= <br>
VARIABLE ;= expr <br>
override VARIABLE ;= expr</p>

<p style="margin-top: 1em">This is the same as
&quot;VARIABLE := expr&quot; except that the right hand side
is evaluated only at the time of the first use and then
remembered. This is useful for expensive <br>
commands, which always return the same value, but which you
don&rsquo;t want to perform when building unrelated
targets:</p>

<p style="margin-top: 1em">VAR1 ;= $(perl expensive
calculations) <br>
VAR2 ;= $(shell external command)</p>

<p style="margin-top: 1em">Note that old makefiles will
usually use &quot;:=&quot; here, to at least do this only
once. But with this operator you can even additionally not
do it, if you currently don&rsquo;t need <br>
the value. For values which are identical in several
directories, you can optimize this further with
&quot;global&quot;, discussed below.</p>

<p style="margin-top: 1em">However this is not intended as
a clever way to force order of evaluation. If a variable
defined like this includes the value of another variable,
and that other one has a <br>
target specific value, and the first expansion is for that
target, then the target specific value will stick for all
other contexts as well. This is a bug and will hopefully
<br>
be fixed in the future.</p>

<p style="margin-top: 1em">+= <br>
VARIABLE += expr <br>
override VARIABLE += expr</p>

<p style="margin-top: 1em">Appends the string to the
previous contents of the variable, separated by a space. If
the variable was previously assigned with &quot;:=&quot;,
then the right hand side is evaluated <br>
before appending.</p>

<p style="margin-top: 1em">&amp;= <br>
VARIABLE &amp;= expr <br>
override VARIABLE &amp;= expr</p>

<p style="margin-top: 1em">Prepends the string to the
previous contents of the variable, separated by a space. If
the variable was previously assigned with &quot;:=&quot;,
then the right hand side is evaluated <br>
before appending.</p>

<p style="margin-top: 1em">For example one way of
guaranteeing that &quot;CFLAGS&quot;, whatever else the user
may put in, always starts with &quot;-Wall&quot; are these
two lines:</p>

<p style="margin-top: 1em">CFLAGS = -O2 # Possibly
overridden on the command line <br>
override CFLAGS &amp;= -Wall # Unconditionally prepended</p>

<p style="margin-top: 1em">In old makefiles you typically
had to do something like this, which had the side effect of
forcing the type to &quot;:=&quot; to prevent endless
recursion:</p>

<p style="margin-top: 1em">VARIABLE := expr $(VARIABLE)</p>

<p style="margin-top: 1em">?= <br>
VARIABLE ?= expr <br>
override VARIABLE ?= expr # Useless, but legal</p>

<p style="margin-top: 1em">Sets the value of the variable,
but only if the variable is not specified earlier in the
makefile, on the command line, or in the environment. The
above assignment is <br>
exactly equivalent to</p>

<p style="margin-top: 1em">ifndef VARIABLE <br>
VARIABLE = expr <br>
endif</p>

<p style="margin-top: 1em">!= <br>
VARIABLE != shell command <br>
override VARIABLE != shell command</p>

<p style="margin-top: 1em">Runs the shell command and sets
the variable to contain the command&rsquo;s standard output.
This is exactly equivalent to</p>

<p style="margin-top: 1em">VARIABLE := $(shell command)</p>

<p style="margin-top: 1em">Multiline variables</p>

<p style="margin-top: 1em">The &quot;define&quot; statement
is the multiline equivalent of the simple statements above.
The operator after the variable is optional. If missing, it
is equivalent to &quot;define VARIABLE <br>
=&quot;. The &quot;&amp;=&quot; and &quot;+=&quot; operators
are slightly different here, in that they glue this to the
old value with a newline, rather than a space. There must
not be anything except a <br>
comment after the statement, i.e. the value starts on the
next line.</p>

<p style="margin-top: 1em">define VARIABLE := <br>
first line of variable&rsquo;s value <br>
second line of variable&rsquo;s value <br>
third line of variable&rsquo;s value <br>
endef</p>

<p style="margin-top: 1em">override define VARIABLE <br>
... <br>
enddef</p>

<p style="margin-top: 1em">Keywords before
&quot;define&quot; can be combinations of either one of
&quot;export&quot; or &quot;global&quot; and
&quot;override&quot;.</p>

<p style="margin-top: 1em">If you need a variable&rsquo;s
value to contain newlines, you must use the
&quot;define&quot; statement as shown (or you can assign the
value directly in Perl). (&quot;endef&quot; was chosen for
<br>
compatibility with GNU make. You may also use
&quot;enddef&quot;.) This is primarily useful for
&quot;canned command sequences&quot;, e.g., something like
this:</p>

<p style="margin-top: 1em">define COMPILE_C_PROGRAM <br>
@&amp;echo &quot;Compiling $(input)&quot; <br>
@$(CC) $(CFLAGS) $(CPPFLAGS) $(INCLUDES) -c $(input) -o
$(output) <br>
endef</p>

<p style="margin-top: 1em">Then you can use this multi-line
variable in several rules, like this:</p>

<p style="margin-top: 1em">%.o : %.c <br>
$(COMPILE_C_PROGRAM)</p>

<p style="margin-top: 1em">$(ARCH)/%.o : $(ARCH)/%.c <br>
$(COMPILE_C_PROGRAM)</p>

<p style="margin-top: 1em">Note that you can often achieve
the same effect by using a semicolon instead of a newline,
because the shell interprets that as a command delimeter
too. For example,</p>

<p style="margin-top: 1em">COMPILE_C_PROGRAM = @echo
&quot;Compiling $(input)&quot;; $(CC) $(CFLAGS) $(CPPFLAGS)
$(INCLUDES) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">will have the same effect,
except that the semicolon forces Perl to pass it to the
shell, instead of executing the command directly and more
efficiently. You also have to put <br>
each builtin on a line of its own, meaning that you have to
switch to the external echo in the semicolon case.</p>

<p style="margin-top: 1em">There is one speciality when
expanding within &quot;define&quot;, i.e. &quot;define X
:=&quot; or on a variable that was already &quot;:=&quot;,
&quot;define X &amp;=&quot; and &quot;define X +=&quot;. In
this case the &quot;$(shell <br>
command ...)&quot; or builtin &quot;$(&amp;command
...)&quot; do not get newlines transformed into spaces.</p>

<p style="margin-top: 1em">Exporting variables to
subprocesses</p>

<p style="margin-top: 1em">export VAR ... <br>
export VAR = value <br>
override export VAR += value</p>

<p style="margin-top: 1em">The first form marks the given
variables for export to subprocesses, with whatever value
the variable then has. The second form, which applies only
to one variable, additionally <br>
assigns a value right away. All the variants of assignment
are allowed.</p>

<p style="margin-top: 1em">Sharing variables across
makefiles</p>

<p style="margin-top: 1em">global VAR ... <br>
global VAR = value <br>
override global VAR &amp;= value</p>

<p style="margin-top: 1em">The first form marks the given
variables as global to all makefiles. If any of them already
had a value, that value is moved from the makefile local
variable to the global one. <br>
However if, at the time this statement is seen, any other
makefiles already had a value for any of them, then those
makefiles will not see the global one.</p>

<p style="margin-top: 1em">The second form, which applies
only to one variable, additionally assigns a value right
away. All the variants of assignment are allowed. Note that
&quot;:=&quot; will expand right away <br>
to the values in the local makefile. On the contrary
&quot;=&quot; variables will expand to the values at the
point of use.</p>

<p style="margin-top: 1em">Global variables can be tricky
to deal with, because makepp may load makefiles in any
order, as the need arises to build some target for which no
rule or makefiles is loaded. <br>
For this reason it is recommended to have a RootMakeppfile
and to explicitly load all others which modify or use the
variable with &quot;load-makefile&quot;.</p>

<p style="margin-top: 1em">global GLIBLIBS ;= $(shell
pkg-config --libs glib-2.0)</p>

<p style="margin-top: 1em">Also note that your project may
some day be built together with other projects. For this
reason it is recommended to always make the project name
part of any global variable <br>
name.</p>

<p style="margin-top: 1em">Target-specific assignments</p>

<p style="margin-top: 1em">target: VARIABLE = string <br>
target: VARIABLE := string <br>
target: override VARIABLE += string</p>

<p style="margin-top: 1em">Sets a target-specific value of
the variable. A target-specific value is in effect only in
an action which produces the given target. This is primarily
used for things like <br>
this:</p>

<p style="margin-top: 1em">CFLAGS := -O2</p>

<p style="margin-top: 1em">my_prog: file1.o file2.o
special_file.o</p>

<p style="margin-top: 1em">special_file.o : CFLAGS :=
-g</p>

<p style="margin-top: 1em">%.o: %.c <br>
$(CC) $(CFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">What happens here is that all
&quot;.c&quot; files will be compiled with optimization
(&quot;-O2&quot;) except &quot;special_file.c&quot;, which
is compiled in debug mode (&quot;-g&quot;). This is a
convenient way to <br>
specify different compilation options for only a few
files.</p>

<p style="margin-top: 1em">Target-specific variable
assignments like this apply only to the actions of the rule;
they are not in effect when evaluating the targets or the
dependencies of a rule. If a rule <br>
has more than one target, target-specific variable
assignments are taken only from the first target. Also note
that makepp&rsquo;s target-specific variables are slightly
different <br>
from GNU make&rsquo;s in that they only apply to the rule
for the one file mentioned, and not to any of its
predecessors.</p>

<p style="margin-top: 1em">Wildcard expansion is performed
on the target, so you can do something like this:</p>

<p style="margin-top: 1em">test_*.o : CFLAGS += -DTEST</p>

<p style="margin-top: 1em">For compatibility with GNU make,
&quot;%&quot; may be used in place of &quot;*&quot;.</p>

<p style="margin-top: 1em">Variable Substitution <br>
Makepp&rsquo;s variable substitution rules are similar to
those of other makes, but somewhat more powerful. As in all
makes, &quot;$(CC)&quot; or &quot;${CC}&quot; both represent
the value of the <br>
variable CC. If you need a literal dollar sign, put in a
double dollar sign ($$), like this:</p>

<p style="margin-top: 1em">target: dep1 dep2 dep3 dep4 <br>
&amp;rm -f $(output) <br>
for file in $(inputs); do cat $$file &gt;&gt; $(output);
done</p>

<p style="margin-top: 1em">Additionally makepp has a
&quot;$[VARIABLE]&quot; syntax, which does the same thing as
the other two, but before makepp groks anything else. This
allows using it for complete rules and/or <br>
conditionals:</p>

<p style="margin-top: 1em">define bracket_rule = <br>
ifdef SOME_VAR <br>
bracket: <br>
&amp;echo this is a rule -o $(output) <br>
endif <br>
enddef</p>

<p style="margin-top: 1em">$[bracket_rule]</p>

<p style="margin-top: 1em">rc-style substitution</p>

<p style="margin-top: 1em">By default, makepp uses rc-style
substitution (so called because it was pioneered by the rc
shell). This is best illustrated by an example:</p>

<p style="margin-top: 1em">MODULES = a b c d</p>

<p style="margin-top: 1em">mylib.a :
module_dir/$(MODULES).o $(OTHER_OBJECTS) <br>
$(CXX) $(dependencies) -o $(target)</p>

<p style="margin-top: 1em">The prefix
&quot;module_dir/&quot; is prepended to each word in
MODULES, and the suffix &quot;.o&quot; is appended to each
word.</p>

<p style="margin-top: 1em">You can also use rc-style
substitution without even putting the list of words into a
variable; the syntax is &quot;$( word1 word2)&quot;. Note
the space between the parenthesis and the <br>
first word. So the above example could have been written
as:</p>

<p style="margin-top: 1em">mylib.a : module_dir/$( a b c
d).o $(OTHER_OBJECTS) <br>
$(CXX) $(dependencies) -o $(target)</p>

<p style="margin-top: 1em">A variable will give rc-style
substitution only when there is more than one word in it.
With one word it is like traditional make. Alas, when the
variable is empty, there is a <br>
conflict. Traditional makes simply expand it to the empty
string. But when you think of it as a list, you&rsquo;d want
&quot;-I$(DIRLIST)&quot; to disapear, not to give a lonely
&quot;-I&quot;. The <br>
solution is to wrap it into a list that starts with a space:
&quot;-I$( $(DIRLIST))&quot; gives you exactly as many
options, as there are words in the list.</p>

<p style="margin-top: 1em">If you put several variables in
the same word which expand to arrays of words, rc-style
substitution actually takes the cartesian product, so you
can do something like this if <br>
you want:</p>

<p style="margin-top: 1em">DIRS = s1 s2 <br>
MODULES = a b c <br>
SUFFIXES = .o .c <br>
FILES := $(DIRS)/$(MODULES)$(SUFFIXES)</p>

<p style="margin-top: 1em">and FILES will contain the
string</p>

<p style="margin-top: 1em">s1/a.o s1/a.c s1/b.o s1/b.c
s1/c.o s1/c.c s2/a.o s2/a.c s2/b.o s2/b.c s2/c.o s2/c.c</p>

<p style="margin-top: 1em">Besides white space, rc-style
substitution stops at any quote, any round, curly or square
parentheses, and any of &quot;, : ; = # @&quot;. Note that
this may be surprising, and again need <br>
an explicit list. Say you want to look for headers by
wildcard in all directories starting with an upper-case
letter:</p>

<p style="margin-top: 1em">BAD := [A-Z]*/**/*.$( hpp h) #
[A-Z]*/**/*.hpp */**/*.h <br>
GOOD := $( [A-Z]*/**/*.)$( hpp h) # [A-Z]*/**/*.hpp
[A-Z]*/**/*.h</p>

<p style="margin-top: 1em">If rc-style substitution gets in
the way, or if you need to have leading or trailing
whitespace in your make variables, then you can turn off
rc-style substitution by setting the <br>
variable &quot;makepp_simple_concatenation=1&quot;. You can
turn it off globally on the command line or as an
environment variable. Or on a per-makefile basis by setting
the variable in <br>
your makefile. You should do this near the top of the
makefile, or else you may run into funny situations where
rc-style substitution is used for some evaluations and not
<br>
others. (All expressions evaluated before the assignment
will use rc-style substitutions, and all expressions
evaluated after will not. Since the time of evaluation of
<br>
expressions in makefiles is complicated and not always
obvious from the order of statements in the makefile,
it&rsquo;s best to set
&quot;makepp_simple_concatenation&quot; as early as
possible.) <br>
You can even set it just for one target:</p>

<p style="margin-top: 1em">target:
makepp_simple_concatenation = 1 <br>
target: <br>
&amp;echo before_first$(LIST)after_last -o $(output)</p>

<p style="margin-top: 1em">Because &quot;$[VARIABLE]&quot;
is evaluated earlier than &quot;$(VARIABLE)&quot;, combining
the two in rc-substitution will not give the result you may
expect, unless you wrap it in an explicit <br>
list:</p>

<p style="margin-top: 1em">A = a b <br>
N = 1 2 <br>
BAD := $(A)$[N] <br>
GOOD := $(A)$( $[N])</p>

<p style="margin-top: 1em">The last lines get read as</p>

<p style="margin-top: 1em">BAD := $(A)1 2 # a1 b1 2 <br>
GOOD := $(A)$( 1 2) # a1 a2 b1 b2</p>

<p style="margin-top: 1em">Substitution References</p>

<p style="margin-top: 1em">A substitution reference has the
form &quot;$(VAR:A=B)&quot;, where A is a pattern to match
and B is a pattern to replace it with. Substitution
references are an abbreviation for the <br>
&quot;patsubst&quot; function. For example:</p>

<p style="margin-top: 1em">source_files = a.c b.c c.c d.c
<br>
object_files = $(source_files:%.c=%.o)</p>

<p style="margin-top: 1em">will set
&quot;$(object_files)&quot; to &quot;a.o b.o c.o d.o&quot;.
The &quot;%&quot; is a special character matches any
arbitrary string. If both A and B start with &quot;%&quot;,
a common case when replacing <br>
suffixes, they can be omitted:</p>

<p style="margin-top: 1em">object_files =
$(source_files:.c=.o) <br>
object_files = $(source_files:c=o) # same, because . is not
special</p>

<p style="margin-top: 1em">Whitespace in variables</p>

<p style="margin-top: 1em">If you need to control the
whitespace in a variable, you must (currently) disable
rc-style substitution (by setting
&quot;makepp_simple_concatenation=1&quot;) and then use a
syntax like <br>
this:</p>

<p style="margin-top: 1em">null = <br>
T = -o $(null)</p>

<p style="margin-top: 1em">or, with an empty
evaluation:</p>

<p style="margin-top: 1em">T = -o $()</p>

<p style="margin-top: 1em">When you do this, the variable
&quot;T&quot; contains &quot;-o&quot; followed by a
space.</p>

<p style="margin-top: 1em">This kind of a technique to
handle whitespace is not recommended. If you need variables
in your makefile to contain spaces, you should think
seriously about what you&rsquo;re doing. <br>
If you need to handle spaces, it is usually much better to
put Perl code into your makefile to take care of it (using
the &quot;perl_begin&quot; or &quot;sub&quot; statements),
or to handle it in <br>
shell statements in the actions of rules.</p>

<p style="margin-top: 1em">These cases typically come up
when people attempt to use the same rules for different
architectures which do not use typical Unix command syntax.
E.g., sometimes one sees things <br>
like this in makefiles:</p>

<p style="margin-top: 1em">ifeq ($(ARCH),weirdarch) <br>
O := /OUTPUT= <br>
else <br>
null := <br>
O := -o $(null) <br>
endif</p>

<p style="margin-top: 1em">%.o : %.c <br>
$(COMPILER) $(input) $(O)$(output)</p>

<p style="margin-top: 1em">You can do this with makepp if
you really want to, but you will probably find that your
makefiles are substantially more readable if you have less
complicated variable <br>
substitution, e.g.,</p>

<p style="margin-top: 1em">ifeq ($(ARCH),weirdarch) <br>
%.o : %.c <br>
$(WEIRD_COMPILER) $(input) /OUTPUT=$(output) <br>
else <br>
%.o : %.c <br>
$(CC) -c $(input) -o $(output) <br>
endif</p>

<p style="margin-top: 1em">Whitespace is never allowed in
variable names, only in their values. This is different from
some make implementations.</p>

<p style="margin-top: 1em">Automatic Variables <br>
Automatic variables are variables that assume different
values depending on which rule they are evaluated in. Makepp
supports most of the automatic variables that other versions
<br>
of make use. In addition, it has less cryptic, longer names
for most of them that you can use instead. (For legacy
makefiles that happen to redefine these names, the
definition <br>
in the makefile overrides the default meaning. For example,
if you say &quot;target = abc&quot; in your makefile, then
&quot;$(target)&quot; will always expand to &quot;abc&quot;,
and will no longer be <br>
equivalent to $@.)</p>

<p style="margin-top: 1em">The following is a complete list
of all the automatic variables that makepp supports:</p>

<p style="margin-top: 1em">output <br>
target <br>
$@ The target of the current rule. Actually, since makepp
supports multiple targets for any rule, this is the first
target. For example, in the following rule</p>

<p style="margin-top: 1em">y.tab.c y.tab.h : parser.y <br>
$(YACC) -o $(output) $(YFLAGS) $(input)</p>

<p style="margin-top: 1em">&quot;$(output)&quot; will
contain the value y.tab.c. Since these magic variables are
in fact functions, you can also pass an index as argument.
This counts from 1 or backwards from <br>
-1. So &quot;$(output 2)&quot; or &quot;$(output -1)&quot;
will contain the value y.tab.h.</p>

<p style="margin-top: 1em">While all three forms of this
variable have the same value, there is a difference in
interpretation for multitarget rules. If you use the
old-style cryptic name $@, makepp <br>
will interpret that as an old-style rule set, rather than a
modern rule that produces all those targets in one go:</p>

<p style="margin-top: 1em">a b: # really: one rule each for
a and b <br>
touch $@</p>

<p style="margin-top: 1em">c d: # error: mpp complains that
this didn&rsquo;t build d <br>
touch $(output)</p>

<p style="margin-top: 1em">outputs <br>
targets <br>
All targets of the current rule. Same as
&quot;$(target)&quot; unless there is more than one target.
In the above example, &quot;$(outputs)&quot; will be y.tab.c
y.tab.h. You can pass an <br>
index list, so &quot;$(outputs 2 1)&quot; will be y.tab.h
y.tab.c.</p>

<p style="margin-top: 1em">dependency <br>
input <br>
$&lt; The first explicit dependency of the rule. For
example, in this rule</p>

<p style="margin-top: 1em">%.o : %.c <br>
$(CC) $(CFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">&quot;$(input)&quot; will be the
name of the .c file, regardless of what .h files makepp
discovers. If you specify more than one dependency, you can
get them by passing an index: <br>
&quot;$(input $(INDEX))&quot; is the INDEXth dependency.</p>

<p style="margin-top: 1em">dependencies <br>
inputs <br>
$^ All the explicit dependencies of the target, not
including .h files discovered by makepp_scanning for
includes.</p>

<p style="margin-top: 1em">For example, in the rule</p>

<p style="margin-top: 1em">myprog.o : *.o <br>
$(CC) $(CFLAGS) $(inputs) -o $(output)</p>

<p style="margin-top: 1em">&quot;$(inputs)&quot; will be
all the .o files in the directory. You can pick only the
ones you want by passing an index list. If you explicitly
specify different kinds of files, you <br>
can pick them as in &quot;$(inputs 2 3 4)&quot; (but with a
wildcard this is not too promising).</p>

<p style="margin-top: 1em">sorted_dependencies <br>
sorted_inputs <br>
$+ All the dependencies of the target, in sorted order, with
duplicates removed. Equivalent to &quot;$(sort
$(inputs))&quot;.</p>

<p style="margin-top: 1em">changed_dependencies <br>
changed_inputs <br>
$? The dependencies of the target that have changed. This
includes only explicit dependencies (i.e., ones you list in
the makefile), not implicitly discovered dependencies from
<br>
scanning (such as .h files).</p>

<p style="margin-top: 1em">This is commonly used in
commands like this:</p>

<p style="margin-top: 1em">libmine.a : $(MODULES) :
build_check ignore_action <br>
$(AR) ru $@ $?</p>

<p style="margin-top: 1em">i.e., ar is told to replace only
those modules that have changed. (Note the
&quot;ignore_action&quot; build check rule. If you
don&rsquo;t specify this, makepp will force the action to be
<br>
executed whenever it changes. If no dependencies have
changed, the action string will be &quot;ar ru
libmine.a&quot; which is probably different from what it was
last time you ran it, <br>
so without &quot;ignore_action&quot; makepp will execute it.
In this case, it&rsquo;s harmless, but with other commands,
it could be a problem. See makepp_build_check for details on
<br>
&quot;ignore_action&quot;.)</p>

<p style="margin-top: 1em">Building archives like this is
not a good idea because it will make your builds less
reliable. The problem with this is that if you build the
archive, then remove one of the <br>
modules from the list of MODULES, the modules will still be
in the archive and makepp</p>

<p style="margin-top: 1em">stem <br>
$* The stem in a pattern rule (i.e., whatever the
&rsquo;%&rsquo; matched). Alternatively, if this is not a
pattern rule, returns the file name without the extension
(i.e., it&rsquo;s equivalent <br>
to &quot;$(basename $(input))&quot;.</p>

<p style="margin-top: 1em">This is mostly for backward
compatibility. For example, in old versions of make the only
way to tell it how to compile any .c file into the
corresponding .o file was like <br>
this:</p>

<p style="margin-top: 1em">.c.o: <br>
$(CC) $(CFLAGS) -c $*.c -o $*.o</p>

<p style="margin-top: 1em">This is a lousy way to write the
rule. It&rsquo;s much clearer to use GNU-make style pattern
rules, like this:</p>

<p style="margin-top: 1em">%.o : %.c <br>
$(CC) $(CFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">foreach <br>
The current filename from the &quot;foreach&quot; clause.
&quot;foreach&quot; clauses are rarely used, but they are
the most general-purpose kind of pattern rule that makepp
supports. For <br>
example,</p>

<p style="margin-top: 1em"># <br>
# Build .c files with some sort of a special preprocessor:
<br>
# <br>
%.c : %.k <br>
$(preprocessor) $(input) &gt; $(output)</p>

<p style="margin-top: 1em"># <br>
# Compile .c files into .o files: <br>
# <br>
%.o : %.c <br>
$(CC) $(CFLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em"># <br>
# Special alternate compilation flags for .c files which are
derived <br>
# from .k files: <br>
# <br>
$(foreach:%.k=%.o) : $(foreach:%.k=%.c) : foreach *.k <br>
$(CC) $(SPECIAL_K_FLAGS) -c $(input) -o $(output)</p>

<p style="margin-top: 1em">See the documentation on the
foreach clause in rules for more details and examples.</p>

<p style="margin-top: 1em">$/ This is essentially a
constant, either &quot;/&quot;, or on native Windows
&quot;</p>

<p style="margin-top: 1em">myoutput: <br>
.$/myprog &gt;$(output)</p>

<p style="margin-top: 1em">For filenames passed as
arguments it is not so necessary as Windows can handle Unix
syntax there.</p>

<p style="margin-top: 1em">Option Variables <br>
You can set these in all the ways explained above (except if
stated otherwise) to modify the bahaviour of makepp. By
default they are all undefined.</p>

<p style="margin-top: 1em">MAKEPP_DEBUG <br>
If you export this with a true value before calling makepp,
you get more debugging info. This is the
&quot;RULE_SOURCE&quot; of files built while this is in
effect under makeppinfo, <br>
mppi and details about variable expansion and rule matching
under makepplog, mppl. This will also show you if makepp
runs out of memory or hangs, because it is endlessly <br>
expanding the same variables:</p>

<p style="margin-top: 1em">A = $A # deferred evaluation,
need := <br>
B = $C <br>
C = $B</p>

<p style="margin-top: 1em">MAKEPP_LN_CP <br>
See the note under &amp;ln.</p>

<p style="margin-top: 1em">makepp_percent_subdirs <br>
Set this to some true value (like 1) to have &quot;%&quot;
in targets or dependencies match across more than one
directory.</p>

<p style="margin-top: 1em">makepp_require_phony <br>
Set this to some true value (like 1) to prevent implicit
phonyness (i.e. if a rule succeeds without producing its
target). This variable should be true by default, to <br>
prevent broken dependency chains, but that would break
backward compatibility with sloppy makefiles.</p>

<p style="margin-top: 1em">makepp_signature_C_flat <br>
This is an option to signature C. Set this to some true
value (like 1) to treat your sources as flattened, i.e. all
newlines (except around preprocessor statements) are <br>
treated like whitespace and &quot;#line&quot; directives are
ignored.</p>

<p style="margin-top: 1em">makepp_simple_concatenation <br>
Set this to some true value (like 1) to prevent
&quot;rc-style substitution&quot;.</p>

<p style="margin-top: 1em">PERL <br>
You can set this to the exact perl you are using to run the
scripts in the makepp suite, and export it. This can help to
run sub-scripts with the same perl. This is mostly <br>
useful for the test suite, the installation and for
recursive builds.</p>

<p style="margin-top: 1em">VPATH <br>
Setting this variable to some value implicitly calls
&quot;vpath % value&quot;.</p>

<p style="margin-top: 1em">Predefined Variables <br>
Makepp predefines a few variables, which you can
override:</p>

<p style="margin-top: 1em">AR Default: &quot;ar&quot;.</p>

<p style="margin-top: 1em">ARFLAGS <br>
Default: &quot;rv&quot;.</p>

<p style="margin-top: 1em">AS Default: &quot;as&quot;.</p>

<p style="margin-top: 1em">CC Default: The first found
among &quot;gcc&quot;, &quot;egcc&quot;, &quot;pgcc&quot;,
&quot;c89&quot; or &quot;cc&quot;, or on Windows
additionally &quot;cl&quot; or &quot;bcc32&quot;.</p>

<p style="margin-top: 1em">CFLAGS <br>
Default: If &quot;$(CC)&quot; is a GNU compiler &quot;-g
-Wall&quot;, if it is one of the two Windows compilers
nothing, else &quot;-g&quot;.</p>

<p style="margin-top: 1em">CURDIR <br>
The directory in which the current Makefile resides.</p>

<p style="margin-top: 1em">CXX Default: The first found
among &quot;g++&quot;, &quot;c++&quot;, &quot;pg++&quot;,
&quot;cxx&quot;, &quot;C&quot;&quot;C&quot; or
&quot;aCC&quot;, or on Windows additionally &quot;cl&quot;
or &quot;bcc32&quot;.</p>

<p style="margin-top: 1em">CXXFLAGS <br>
Default: If &quot;$(CXX)&quot; is a GNU compiler &quot;-g
-Wall&quot;, if it is one of the two Windows compilers
nothing, else &quot;-g&quot;.</p>

<p style="margin-top: 1em">F77 Default: The first found
among &quot;f77&quot;, &quot;g77&quot; or
&quot;fort77&quot;.</p>

<p style="margin-top: 1em">FC Default:
&quot;$(F77)&quot;.</p>

<p style="margin-top: 1em">LD Default: &quot;ld&quot;.</p>

<p style="margin-top: 1em">LEX Default: The first found
among &quot;lex&quot; or &quot;flex&quot;.</p>

<p style="margin-top: 1em">LIBTOOL <br>
Default: &quot;libtool&quot;.</p>

<p style="margin-top: 1em">MAKE <br>
This variable has two different values, depending on the
presence or not of &quot;--traditional-recursive-make&quot;.
Makepp recognizes when this variable is used and turns off
some <br>
features, even before the recursion actually takes place.
This can be undesirable while you are gradually eliminating
it, so first convert the calls to a makepp specific <br>
&quot;$((MAKE))&quot;, which will not turn off features. You
should not set it because that breaks our smart recursion
work around.</p>

<p style="margin-top: 1em">MAKECMDGOALS <br>
This variable is set but not used by makepp. You can query
it to do something only if a certain target was
requested.</p>

<p style="margin-top: 1em">Default: Whatever explicit
targets the user (or a recursive invocation) provided. Empty
when implicitly building default target.</p>

<p style="margin-top: 1em">ifneq $(filter special-target,
$(MAKECMDGOALS)) <br>
# special-target is one of the current explicit targets <br>
else ifeq $(MAKECMDGOALS) <br>
# no explicit targets <br>
endif</p>

<p style="margin-top: 1em">MAKEFLAGS (exported) <br>
The standard options with which makepp was called. Those
that have a single letter form are combined at the beginning
without a leading &quot;-&quot; (heaven knows why gmake
chose to <br>
drop the &quot;-&quot;).</p>

<p style="margin-top: 1em">MAKEINFO <br>
Default: &quot;makeinfo&quot;.</p>

<p style="margin-top: 1em">MAKEPPFLAGS (exported) <br>
This is set to the same value as MAKEFLAGS, but only if this
variable is present in makepp&rsquo;s environment.</p>

<p style="margin-top: 1em">_MAKEPPFLAGS (exported) <br>
The makepp specific options needed for POSIX/gmake
compatibility, with which makepp was called. These are in a
separate variable so a legacy makefile can&rsquo;t break
<br>
compatibility by unsetting MAKEFLAGS. This is only set with
&quot;--traditional-recursive-make&quot;.</p>

<p style="margin-top: 1em">MAKEPP_VERSION <br>
The version of makepp you are running with. If it is a beta
version, it will have a hyphen followed by YYMMDD plus some
more internal data. You can use this for &quot;ifdef&quot;
to <br>
hide makepp specific constructs from other makes.</p>

<p style="margin-top: 1em">Default: The same value
displayed by &quot;makepp --version&quot;</p>

<p style="margin-top: 1em">PWD An alias for
&quot;CURDIR&quot;.</p>

<p style="margin-top: 1em">RM Default: &quot;rm -f&quot;.
This is meant for legacy Makefiles. For new ones preferably
use the builtin &amp;rm command directly. If you want to
write a phony clean rule, look at the <br>
&quot;makeppclean -r&quot; command instead.</p>

<p style="margin-top: 1em">ROOT <br>
The relative path to the root of your build system, i.e. the
directory further up in which you have a
&quot;RootMakeppfile(.mk)&quot;. If you don&rsquo;t have
one, this variable is empty.</p>

<p style="margin-top: 1em">SHELL <br>
This variable is only respected if you &quot;export&quot;
it. In that case it is the Shell which is used to execute
not-builtin actions with some special character in it (plain
ones <br>
being exec&lsquo;ed directly). On Windows Strawberry or
ActiveState Perl, if you have a Unix-like Shell, you must
instead set your SHELL variable to a value ending in
&quot;sh&quot; or <br>
&quot;sh.exe&quot; before calling makepp.</p>

<p style="margin-top: 1em">Default: The first found among
&quot;/usr/xpg4/bin/sh&quot; (e.g. Solaris) or
&quot;/sbin/xpg4/sh&quot; (e.g. Reliant Unix) or
&quot;/bin/sh&quot;.</p>

<p style="margin-top: 1em">YACC <br>
Default: The first found among &quot;bison -y&quot; or
&quot;yacc&quot;.</p>

<p style="margin-top: 1em">Variables and Perl <br>
Variable values are stored as ordinary Perl scalars, so you
can access them directly from Perl code if you need to do
any complicated manipulations with them; see <br>
makepp_extending for details.</p>

<p style="margin-top: 1em">Accessing global variables from
Perl is achieved by prefixing them with the
&quot;Mpp::global&quot; package. In fact any variable, not
yet present in the current makefile, and which you <br>
assign to in this package will from then on be global, as
though you had just issued the &quot;global&quot; statement
for it.</p>

<p style="margin-top: 1em">This direct access is however
error-prone! The user may have overridden these variables on
the command line or through the environment. Some other
makefile loaded before this <br>
one may have made the variable global or target specific. In
these cases you would not find the value of the variable, or
when assigning it, might take away its property <br>
(equivalent to an &quot;override&quot; modifier, except for
target specifics.)</p>

<p style="margin-top: 1em">With direct access you also
bypass the expansion of these variables, if they are of type
&quot;=&quot; or &quot;;=&quot;. Special variables like
&quot;$(CC)&quot; start out as functions, until they are
<br>
assigned to. So in many cases you won&rsquo;t see their
value.</p>

<p style="margin-top: 1em">For these reasons it is better
to let makepp determine the correct value. You can use the
&quot;makeperl&quot; variant, in which the variable has been
evaluated before the Perl code gets <br>
interpreted:</p>

<p style="margin-top: 1em">makeperl { $$current_value =
&rsquo;$(MAKEFILE_VAR)&rsquo; }</p>

<p style="margin-top: 1em">If you need a variable in
makefile perl blocks this is achieved via the Perl variable
$makefile as follows:</p>

<p style="margin-top: 1em">perl { $current_value =
$makefile-&gt;expand_variable( &rsquo;MAKE_VAR&rsquo; )
}</p>

<p style="margin-top: 1em">Functions always get the
makefile object passed in as the second argument $_[1]:</p>

<p style="margin-top: 1em">sub f_f { $current_value =
$_[1]-&gt;expand_variable( &rsquo;MAKE_VAR&rsquo; ) }</p>

<p style="margin-top: 1em">Commands are supposed to be
called within a rule action, where the makefile object is
accessible via
&quot;$Mpp::Subs::rule-&gt;{MAKEFILE}&quot;:</p>

<p style="margin-top: 1em">sub c_cmd { $current_value =
$Mpp::Subs::rule-&gt;{MAKEFILE}-&gt;expand_variable(
&rsquo;MAKE_VAR&rsquo; ) }</p>

<p style="margin-top: 1em">AUTHOR <br>
Gary Holt (holt-makepp@gholt.net)</p>

<p style="margin-top: 1em">perl v5.24.1 2016-11-28
MAKEPP_VARIABLES(1)</p>
<hr>
</body>
</html>
