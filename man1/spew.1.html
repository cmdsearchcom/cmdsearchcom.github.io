<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:38:41 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>SPEW(1) User Commands SPEW(1)</p>

<p style="margin-top: 1em">NAME <br>
spew - measures I/O performance and/or generates I/O
load</p>

<p style="margin-top: 1em">SYNOPSIS <br>
spew --write|--read|--read-after-write [OPTION]...
TRANSFER_SIZE[kKmMgG] FILE</p>

<p style="margin-top: 1em">DESCRIPTION <br>
An I/O performance measurement and load generation tool.
Writes and/or reads generated data to or from a character
device, block device, or regular file.</p>

<p style="margin-top: 1em">-B,
--max-buffer-size=BUFFER_SIZE <br>
Each read(2)/write(2) call uses a maximum buffer of size
BUFFER_SIZE.</p>

<p style="margin-top: 1em">-b,
--min-buffer-size=BUFFER_SIZE <br>
Each read(2)/write(2) call uses a minimum buffer of size
BUFFER_SIZE.</p>

<p style="margin-top: 1em">-c, --continue-after-error <br>
Continue after data integrity errors.</p>

<p style="margin-top: 1em">-d, --direct <br>
Use direct I/O. Should only be used on block device files.
Not all operating systems support direct I/O</p>

<p style="margin-top: 1em">-g, --generate-load <br>
Equivalent to: -v -t -P -p random -i 0.</p>

<p style="margin-top: 1em">-i, --iterations=COUNT <br>
Write/read data COUNT times. If count is 0, repeats
forever.</p>

<p style="margin-top: 1em">-l, --logfile=LOGFILE <br>
Send log messages to LOGFILE.</p>

<p style="margin-top: 1em">--no-progress <br>
Don&rsquo;t show progress (default).</p>

<p style="margin-top: 1em">--no-rcfiles <br>
Don&rsquo;t use standard rcfiles.</p>

<p style="margin-top: 1em">-q, --no-statistics <br>
Don&rsquo;t output statistics.</p>

<p style="margin-top: 1em">--no-tui <br>
Don&rsquo;t use TUI interface.</p>

<p style="margin-top: 1em">-o, --offset=OFFSET <br>
Seek to OFFSET before starting I/O.</p>

<p style="margin-top: 1em">-P, --progress <br>
Show progress.</p>

<p style="margin-top: 1em">-p, --pattern=PATTERN <br>
Use data pattern PATTERN when reading or writing data.</p>

<p style="margin-top: 1em">-r, --random <br>
Read/Write buffers to random offsets.</p>

<p style="margin-top: 1em">--raw An alias for
--read-after-write.</p>

<p style="margin-top: 1em">--rcfile=RCFILE <br>
Read command-line options from RCFILE.</p>

<p style="margin-top: 1em">--read Read date from FILE.</p>

<p style="margin-top: 1em">--read-after-write <br>
Read back data after writing to FILE.</p>

<p style="margin-top: 1em">-S, --seed=SEED <br>
Use SEED for random number seed.</p>

<p style="margin-top: 1em">-s, --sync <br>
Use synchronous I/O.</p>

<p style="margin-top: 1em">--statistics <br>
Output statistics (default).</p>

<p style="margin-top: 1em">-t, --tui <br>
Use curses-based, terminal user interface.</p>

<p style="margin-top: 1em">-u, --units=UNITS <br>
Show transfer rate in UNITS units.</p>

<p style="margin-top: 1em">--usage <br>
Show brief usage message and exit.</p>

<p style="margin-top: 1em">-V, --version <br>
Output version information and exit.</p>

<p style="margin-top: 1em">-v, --detailed-statistics <br>
Output detailed statistics.</p>

<p style="margin-top: 1em">--write <br>
Write data to FILE.</p>

<p style="margin-top: 1em">-?, --help <br>
Show this help and exit.</p>

<p style="margin-top: 1em">FILE Regular or device file to
write data to.</p>

<p style="margin-top: 1em">LOGFILE <br>
Path to a file used for logging.</p>

<p style="margin-top: 1em">MAX_BUFFER_SIZE <br>
Minimum buffer size used in each read(2)/write(2) call
(default is MIN_BUFFER_SIZE bytes). MAX_BUFFER_SIZE. Must be
an even multiple of 512 bytes and can be specified in <br>
bytes, kibibytes(k), kilobytes(K), mebibytes(m),
megabytes(M), gibibytes(g), gigabytes(G). tebibytes(t), or
terabytes(T). MAX_BUFFER_SIZE defaults to MIN_BUFFER_SIZE.
<br>
If MAX_BUFFER_SIZE &gt; MIN_BUFFER_SIZE, random buffers
sizes between the two limits are used. MAX_BUFFER_SIZE must
be an even multiple of MIN_BUFFER_SIZE.</p>

<p style="margin-top: 1em">MIN_BUFFER_SIZE <br>
Minimum buffer size used in each read(2)/write(2) call
(default is 512 bytes). MIN_BUFFER_SIZE. Must be an even
multiple of 512 bytes and can be specified in bytes, <br>
kibibytes(k), kilobytes(K), mebibytes(m), megabytes(M),
gibibytes(g), gigabytes(G). tebibytes(t), or
terabytes(T).</p>

<p style="margin-top: 1em">OFFSET Position to seek to in
the file before starting I/O (default is 0). OFFSET must be
an even multiple of 512 bytes and can be specified in bytes,
kibibytes(k), kilobytes(K), <br>
mebibytes(m), megabytes(M), gibibytes(g), gigabytes(G).
tebibytes(t), or terabytes(T).</p>

<p style="margin-top: 1em">PATTERN <br>
Data pattern used when writing/reading data. Available
patterns are: none, zeros, ones, alt, random, numbers, and
&quot;#&quot; (where &quot;#&quot; is a number between
0-255). The default <br>
pattern is &quot;none&quot;.</p>

<p style="margin-top: 1em">RCFILE Read additional
command-line options from RCFILE. Other options on the
command-line will override options in RCFILE.</p>

<p style="margin-top: 1em">SEED Used to seed the random
number generator Must be &gt;= 1 and &lt;= 2^32.</p>

<p style="margin-top: 1em">TRANSFER_SIZE <br>
Total number of bytes to transfer (must be an even multiple
of both MIN_BUFFER_SIZE and MAX_BUFFER)SIZE). TRANSFER_SIZE
can be specified in bytes, kilobytes, megabytes, <br>
or gigabytes.</p>

<p style="margin-top: 1em">UNITS Kibibytes(k),
kilobytes(K), mebibytes(m), megabytes(M), gibibytes(g),
gigabytes(G). tebibytes(t), or terabytes(T).</p>

<p style="margin-top: 1em">EXAMPLES <br>
spew --write -b 16k 1m /tmp/bigfile</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">spew -b 16k 1m /tmp/bigfile</p>

<p style="margin-top: 1em">Writes 1 mebibyte (1 mebibyte =
1024*1024 bytes) using 16 kibibytes (1 kibibyte = 1024
bytes) requests to the file /tmp/bigfile using the default
pattern (random). Displays the <br>
write transfer rate in kibibytes per second and the write
transfer time in seconds.</p>

<p style="margin-top: 1em">spew --write -u m -i 10 -b 1k
256k /dev/sda1</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">spew -u m -i 10 -b 1k 256k
/dev/sda1</p>

<p style="margin-top: 1em">Writes 256 kibibytes using 1
kibibyte requests to the block device file /dev/sda1 10
times using the default pattern (random). The iteration and
cumulative write transfer rates <br>
are displayed in mebibytes per second and the iteration and
cumulative write transfer times are displayed in
seconds.</p>

<p style="margin-top: 1em">spew --raw -d -o 1m -b 16m 1g
/tmp/bigfile</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">regorge -s -o 1m -b 16m 1g
/tmp/bigfile</p>

<p style="margin-top: 1em">Write 1 gibibyte (1 gibibyte =
1024*1024*1024 bytes) starting at an offset of 1 mebibyte
using 16 mebibyte requests to the file /tmp/bigfile using
the default pattern (random). <br>
The data is written synchronously and flushed at file close.
Then read in the same data using the same request size and
offset. The data is checked to ensure that the data read
<br>
in matches the data read out. Write and read tranfer rates
are displayed in kibibytes/second. Read are write transfer
times are displayed in seconds.</p>

<p style="margin-top: 1em">spew --read -i 0 -u M -p zeros
-b 512 1m /dev/zero</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">gorge -i 0 -u M -p zeros -b 512
1m /dev/zero</p>

<p style="margin-top: 1em">Read 1 mebibyte of data using
512 byte requests from the file /dev/zero an infinite number
of times using the zeros pattern (don&rsquo;t check the
data). The iteration and cumulative <br>
read transfer rates are displayed in megabytes (1 megabyte =
1,000,000 bytes) per second and the iteration and cumulative
read transfer times are displayed in seconds.</p>

<p style="margin-top: 1em">spew --raw -g -r -b 1k -B 256K
1t /dev/md1</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">regorge -g -r -b 1k -B 256K 1t
/dev/md1</p>

<p style="margin-top: 1em">Write 1 tebibyte (1 tebibyte =
1024*1024*1024*1024 bytes) using 1-256 kibibyte requests to
the block device /dev/md1 using the random pattern. Random
seeks are performed before <br>
each transfer, but each block between the start and end of
the data is written exactly once. The request sizes are
chosen randomly. Then read in the same data using the same
<br>
request sizes and seeks in the same sequence. Repeat the
above sequence an infinite number of times until told to
quit (via signal or TUI command).</p>

<p style="margin-top: 1em">The data is checked to ensure
that the data read in matches the data read out. A
curses-based TUI is used to display iteration and cumulative
transfer rates, transfer times, and <br>
bytes transferred. Display verbose statistics after
quitting.</p>

<p style="margin-top: 1em">ALGORITHMS <br>
The following algorithm is used to determine blocksize when
MAX_BUFFER_SIZE &gt; MIN_BUFFER_SIZE:</p>

<p style="margin-top: 1em">Find the largest blocksize that
is a power of 2 and is &gt;= MAX_BUFFER_SIZE. Call this
maxbuffersize. Find the smallest buffersize that is a power
of 2 and is &gt;= MIN_BUFFER_SIZE. <br>
Call this minbuffersize. Chunksize = maxbuffersize *
(difference in number of bits between min and maxbuffersize
+ 1). The number of chunks is TRANSFER_SIZE/chunksize. Call
<br>
this numchunks. There will be numchunks number of
read/writes that are of size maxbuffersize, 2 * numchunks
number of read/writes that are of size maxbuffersize/2, 4 *
numchunks <br>
number of read/writes that are of size maxbuffersize/4, and
so on until minbuffersize is reached. MIN_BUFFER_SIZE is
used for any remaining transfers if TRANSFER_SIZE is not
<br>
evenly divisible by chunksize.</p>

<p style="margin-top: 1em">Example: Using a MIN_BLOCK_SIZE
of 1k, a MAX_BLOCK_SIZE of 8k and a TRANSFER_SIZE of 264k
results in 8 8k read/writes, 16 4k read/write, 32 2k
read/writes, and 64 + 8 1k <br>
read/writes.</p>

<p style="margin-top: 1em">PATTERNS <br>
Use the following od(1) command to examine spew generated
files where a data integrity problem has occurred:</p>

<p style="margin-top: 1em">od -A d --format=d8 --width=32
&lt;file&gt;</p>

<p style="margin-top: 1em">FILES <br>
$HOME/.spewrc or $SPEWRC <br>
Holds user default options. These options precede any
options included on the command-line.</p>

<p style="margin-top: 1em">/etc/spew.conf <br>
Holds system-wide default options. These options precede any
options included on the command-line and options included
from $HOME/.spewrc or $SPEWRC.</p>

<p style="margin-top: 1em">AUTHOR <br>
Written by Andrew Patterson
&lt;andrew.patterson@hp.com&gt;</p>

<p style="margin-top: 1em">REPORTING BUGS <br>
Report bugs to Andrew Patterson
&lt;andrew.patterson@hp.com&gt;.</p>

<p style="margin-top: 1em">Copyright 2007 Hewlett-Packard
Corp.</p>

<p style="margin-top: 1em">spew 1.0.8 May 2010 SPEW(1)</p>
<hr>
</body>
</html>
