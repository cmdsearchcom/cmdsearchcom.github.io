<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:16:02 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>guestfs-faq(1) Virtualization Support guestfs-faq(1)</p>

<p style="margin-top: 1em">NAME <br>
guestfs-faq - libguestfs Frequently Asked Questions
(FAQ)</p>

<p style="margin-top: 1em">ABOUT LIBGUESTFS <br>
What is libguestfs? <br>
libguestfs is a way to create, access and modify disk
images. You can look inside disk images, modify the files
they contain, create them from scratch, resize them, and
much <br>
more. It&rsquo;s especially useful from scripts and programs
and from the command line.</p>

<p style="margin-top: 1em">libguestfs is a C library (hence
&quot;lib-&quot;), and a set of tools built on this library,
and bindings for many common programming languages.</p>

<p style="margin-top: 1em">For more information about what
libguestfs can do read the introduction on the home page
(http://libguestfs.org).</p>

<p style="margin-top: 1em">What are the virt tools? <br>
Virt tools (website: http://virt-tools.org) are a whole set
of virtualization management tools aimed at system
administrators. Some of them come from libguestfs, some from
<br>
libvirt and many others from other open source projects. So
virt tools is a superset of libguestfs. However libguestfs
comes with many important tools. See <br>
http://libguestfs.org for a full list.</p>

<p style="margin-top: 1em">Does libguestfs need { libvirt /
KVM / Red Hat / Fedora }? <br>
No!</p>

<p style="margin-top: 1em">libvirt is not a requirement for
libguestfs.</p>

<p style="margin-top: 1em">libguestfs works with any disk
image, including ones created in VMware, KVM, qemu,
VirtualBox, Xen, and many other hypervisors, and ones which
you have created from scratch.</p>

<p style="margin-top: 1em">Red&Acirc;&nbsp;Hat sponsors
(ie. pays for) development of libguestfs and a huge number
of other open source projects. But you can run libguestfs
and the virt tools on many different Linux <br>
distros and Mac OS X. We try our best to support all Linux
distros as first-class citizens. Some virt tools have been
ported to Windows.</p>

<p style="margin-top: 1em">How does libguestfs compare to
other tools? <br>
vs. kpartx <br>
Libguestfs takes a different approach from kpartx. kpartx
needs root, and mounts filesystems on the host kernel (which
can be insecure - see guestfs-security(1)). <br>
Libguestfs isolates your host kernel from guests, is more
flexible, scriptable, supports LVM, doesn&rsquo;t require
root, is isolated from other processes, and cleans up after
<br>
itself. Libguestfs is more than just file access because you
can use it to create images from scratch.</p>

<p style="margin-top: 1em">vs. vdfuse <br>
vdfuse is like kpartx but for VirtualBox images. See the
kpartx comparison above. You can use libguestfs on the
partition files exposed by vdfuse, although it&rsquo;s not
<br>
necessary since libguestfs can access VirtualBox images
directly.</p>

<p style="margin-top: 1em">vs. qemu-nbd <br>
NBD (Network Block Device) is a protocol for exporting block
devices over the network. qemu-nbd is an NBD server which
can handle any disk format supported by qemu (eg. raw, <br>
qcow2). You can use libguestfs and qemu-nbd or nbdkit
together to access block devices over the network, for
example: &quot;guestfish -a nbd://remote&quot;</p>

<p style="margin-top: 1em">vs. mounting filesystems in the
host <br>
Mounting guest filesystems in the host is insecure and
should be avoided completely for untrusted guests. Use
libguestfs to provide a layer of protection against
filesystem <br>
exploits. See also guestmount(1).</p>

<p style="margin-top: 1em">vs. parted <br>
Libguestfs supports LVM. Libguestfs uses parted and provides
most parted features through the libguestfs API.</p>

<p style="margin-top: 1em">GETTING HELP AND REPORTING BUGS
<br>
How do I know what version I&rsquo;m using? <br>
The simplest method is:</p>

<p style="margin-top: 1em">guestfish --version</p>

<p style="margin-top: 1em">Libguestfs development happens
along an unstable branch and we periodically create a stable
branch which we backport stable patches to. To find out
more, read &quot;LIBGUESTFS <br>
VERSION NUMBERS&quot; in guestfs(3).</p>

<p style="margin-top: 1em">How can I get help? <br>
What mailing lists or chat rooms are available? <br>
If you are a Red&Acirc;&nbsp;Hat customer using Red Hat
Enterprise Linux, please contact
Red&Acirc;&nbsp;Hat&Acirc;&nbsp;Support:
http://redhat.com/support</p>

<p style="margin-top: 1em">There is a mailing list, mainly
for development, but users are also welcome to ask questions
about libguestfs and the virt tools: <br>
https://www.redhat.com/mailman/listinfo/libguestfs</p>

<p style="margin-top: 1em">You can also talk to us on IRC
channel &quot;#libguestfs&quot; on FreeNode. We&rsquo;re not
always around, so please stay in the channel after asking
your question and someone will get back to <br>
you.</p>

<p style="margin-top: 1em">For other virt tools (not ones
supplied with libguestfs) there is a general virt tools
mailing list:
https://www.redhat.com/mailman/listinfo/virt-tools-list</p>

<p style="margin-top: 1em">How do I report bugs? <br>
Please use the following link to enter a bug in
Bugzilla:</p>


<p style="margin-top: 1em">https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-top: 1em">Include as much detail as you
can and a way to reproduce the problem.</p>

<p style="margin-top: 1em">Include the full output of
libguestfs-test-tool(1).</p>

<p style="margin-top: 1em">COMMON PROBLEMS <br>
See also &quot;LIBGUESTFS GOTCHAS&quot; in guestfs(3) for
some &quot;gotchas&quot; with using the libguestfs API.</p>

<p style="margin-top: 1em">&quot;Could not allocate dynamic
translator buffer&quot; <br>
This obscure error is in fact an SELinux failure. You have
to enable the following SELinux boolean:</p>

<p style="margin-top: 1em">setsebool -P
virt_use_execmem=on</p>

<p style="margin-top: 1em">For more information see
https://bugzilla.redhat.com/show_bug.cgi?id=806106.</p>

<p style="margin-top: 1em">&quot;child process died
unexpectedly&quot; <br>
[This error message was changed in libguestfs 1.21.18 to
something more explanatory.]</p>

<p style="margin-top: 1em">This error indicates that qemu
failed or the host kernel could not boot. To get further
information about the failure, you have to run:</p>

<p style="margin-top: 1em">libguestfs-test-tool</p>

<p style="margin-top: 1em">If, after using this, you still
don&rsquo;t understand the failure, contact us (see previous
section).</p>

<p style="margin-top: 1em">libguestfs: error: cannot find
any suitable libguestfs supermin, fixed or old-style
appliance on LIBGUESTFS_PATH <br>
febootstrap-supermin-helper: ext2: parent directory not
found <br>
supermin-helper: ext2: parent directory not found <br>
[This issue is fixed permanently in libguestfs &acirc;&yen;
1.26.]</p>

<p style="margin-top: 1em">If you see any of these errors
on Debian/Ubuntu, you need to run the following command:</p>

<p style="margin-top: 1em">sudo
update-guestfs-appliance</p>

<p style="margin-top: 1em">&quot;Permission denied&quot;
when running libguestfs as root <br>
You get a permission denied error when opening a disk image,
even though you are running libguestfs as root.</p>

<p style="margin-top: 1em">This is caused by libvirt, and
so only happens when using the libvirt backend. When run as
root, libvirt decides to run the qemu appliance as user
&quot;qemu.qemu&quot;. Unfortunately <br>
this usually means that qemu cannot open disk images,
especially if those disk images are owned by root, or are
present in directories which require root access.</p>

<p style="margin-top: 1em">There is a bug open against
libvirt to fix this:
https://bugzilla.redhat.com/show_bug.cgi?id=1045069</p>

<p style="margin-top: 1em">You can work around this by one
of the following methods:</p>

<p style="margin-top: 1em">&Acirc;&middot; Switch to the
direct backend:</p>

<p style="margin-top: 1em">export
LIBGUESTFS_BACKEND=direct</p>

<p style="margin-top: 1em">&Acirc;&middot; Don&rsquo;t run
libguestfs as root.</p>

<p style="margin-top: 1em">&Acirc;&middot; Chmod the disk
image and any parent directories so that the qemu user can
access them.</p>

<p style="margin-top: 1em">&Acirc;&middot; (Nasty) Edit
/etc/libvirt/qemu.conf and change the &quot;user&quot;
setting.</p>

<p style="margin-top: 1em">execl: /init: Permission denied
<br>
Note: If this error happens when you are using a distro
package of libguestfs (eg. from Fedora, Debian, etc) then
file a bug against the distro. This is not an error which
<br>
normal users should ever see if the distro package has been
prepared correctly.</p>

<p style="margin-top: 1em">This error happens during the
supermin boot phase of starting the appliance:</p>

<p style="margin-top: 1em">supermin: mounting new root on
/root <br>
supermin: chroot <br>
execl: /init: Permission denied <br>
supermin: debug: listing directory / <br>
[...followed by a lot of debug output...]</p>

<p style="margin-top: 1em">This is a complicated bug
related to supermin(1) appliances. The appliance is
constructed by copying files like /bin/bash and many
libraries from the host. The file &quot;hostfiles&quot; <br>
lists the files that should be copied from the host into the
appliance. If some files don&rsquo;t exist on the host then
they are missed out, but if these files are needed in order
to <br>
(eg) run /bin/bash then you&rsquo;ll see the above
error.</p>

<p style="margin-top: 1em">Diagnosing the problem involves
studying the libraries needed by /bin/bash, ie:</p>

<p style="margin-top: 1em">ldd /bin/bash</p>

<p style="margin-top: 1em">comparing that with
&quot;hostfiles&quot;, with the files actually available in
the host filesystem, and with the debug output printed in
the error message. Once you&rsquo;ve worked out which <br>
file is missing, install that file using your package
manager and try again.</p>

<p style="margin-top: 1em">You should also check that files
like /init and /bin/bash (in the appliance) are executable.
The debug output shows file modes.</p>

<p style="margin-top: 1em">DOWNLOADING, INSTALLING,
COMPILING LIBGUESTFS <br>
Where can I get the latest binaries for ...? <br>
Fedora &acirc;&yen; 11 <br>
Use:</p>

<p style="margin-top: 1em">yum install
&rsquo;*guestf*&rsquo;</p>

<p style="margin-top: 1em">For the latest builds, see:
http://koji.fedoraproject.org/koji/packageinfo?packageID=8391</p>

<p style="margin-top: 1em">Red Hat Enterprise Linux <br>
RHEL 5 <br>
The version shipped in official RHEL 5 is very old and
should not be used except in conjunction with virt-v2v. Use
the up-to-date libguestfs 1.20 package in EPEL 5: <br>
https://fedoraproject.org/wiki/EPEL</p>

<p style="margin-top: 1em">RHEL 6 <br>
RHEL 7 <br>
It is part of the default install. On RHEL 6 and 7 (only)
you have to install &quot;libguestfs-winsupport&quot; to get
Windows guest support.</p>

<p style="margin-top: 1em">Debian and Ubuntu <br>
For libguestfs &lt; 1.26, after installing libguestfs you
need to do:</p>

<p style="margin-top: 1em">sudo
update-guestfs-appliance</p>

<p style="margin-top: 1em">(This script has been removed on
Debian/Ubuntu with libguestfs &acirc;&yen; 1.26 and instead
the appliance is built on demand.)</p>

<p style="margin-top: 1em">On Ubuntu only:</p>

<p style="margin-top: 1em">sudo chmod 0644
/boot/vmlinuz*</p>

<p style="margin-top: 1em">You may need to add yourself to
the &quot;kvm&quot; group:</p>

<p style="margin-top: 1em">sudo usermod -a -G kvm
yourlogin</p>

<p style="margin-top: 1em">Debian Squeeze (6) <br>
Hilko Bengen has built libguestfs in squeeze backports:
http://packages.debian.org/search?keywords=guestfs&amp;searchon=names&amp;section=all&amp;suite=squeeze-backports</p>

<p style="margin-top: 1em">Debian Wheezy and later (7+)
<br>
Hilko Bengen supports libguestfs on Debian. Official Debian
packages are available:
http://packages.debian.org/search?keywords=libguestfs</p>

<p style="margin-top: 1em">Ubuntu <br>
We don&rsquo;t have a full time Ubuntu maintainer, and the
packages supplied by Canonical (which are outside our
control) are sometimes broken.</p>

<p style="margin-top: 1em">Canonical decided to change the
permissions on the kernel so that it&rsquo;s not readable
except by root. This is completely stupid, but they
won&rsquo;t change it <br>

(https://bugs.launchpad.net/ubuntu/+source/linux/+bug/759725).
So every user should do this:</p>

<p style="margin-top: 1em">sudo chmod 0644
/boot/vmlinuz*</p>

<p style="margin-top: 1em">Ubuntu 12.04 <br>
libguestfs in this version of Ubuntu works, but you need to
update febootstrap and seabios to the latest versions.</p>

<p style="margin-top: 1em">You need febootstrap
&acirc;&yen; 3.14-2 from:
http://packages.ubuntu.com/precise/febootstrap</p>

<p style="margin-top: 1em">After installing or updating
febootstrap, rebuild the appliance:</p>

<p style="margin-top: 1em">sudo
update-guestfs-appliance</p>

<p style="margin-top: 1em">You need seabios &acirc;&yen;
0.6.2-0ubuntu2.1 or &acirc;&yen; 0.6.2-0ubuntu3 from:
http://packages.ubuntu.com/precise-updates/seabios or
http://packages.ubuntu.com/quantal/seabios</p>

<p style="margin-top: 1em">Also you need to do (see
above):</p>

<p style="margin-top: 1em">sudo chmod 0644
/boot/vmlinuz*</p>

<p style="margin-top: 1em">Gentoo <br>
Libguestfs was added to Gentoo in 2012-07 by Andreis
Vinogradovs (libguestfs) and Maxim Koltsov (mainly hivex).
Do:</p>

<p style="margin-top: 1em">emerge libguestfs</p>

<p style="margin-top: 1em">SuSE <br>
Libguestfs was added to SuSE in 2012 by Olaf Hering.</p>

<p style="margin-top: 1em">ArchLinux <br>
Libguestfs was added to the AUR in 2010.</p>

<p style="margin-top: 1em">Other Linux distro <br>
Compile from source (next section).</p>

<p style="margin-top: 1em">Other non-Linux distro <br>
You&rsquo;ll have to compile from source, and port it.</p>

<p style="margin-top: 1em">How can I compile and install
libguestfs from source? <br>
You can compile libguestfs from git or a source tarball.
Read the README file before starting.</p>

<p style="margin-top: 1em">Git:
https://github.com/libguestfs/libguestfs Source tarballs:
http://libguestfs.org/download</p>

<p style="margin-top: 1em">Don&rsquo;t run &quot;make
install&quot;! Use the &quot;./run&quot; script instead (see
README).</p>

<p style="margin-top: 1em">How can I compile and install
libguestfs if my distro doesn&rsquo;t have new enough
qemu/supermin/kernel? <br>
Libguestfs needs supermin 5. If supermin 5 hasn&rsquo;t been
ported to your distro, then see the question below.</p>

<p style="margin-top: 1em">First compile qemu, supermin
and/or the kernel from source. You do not need to &quot;make
install&quot; them.</p>

<p style="margin-top: 1em">In the libguestfs source
directory, create two files. &quot;localconfigure&quot;
should contain:</p>

<p style="margin-top: 1em">source localenv <br>
#export PATH=/tmp/qemu/x86_64-softmmu:$PATH <br>
./autogen.sh --prefix /usr &quot;$@&quot;</p>

<p style="margin-top: 1em">Make &quot;localconfigure&quot;
executable.</p>

<p style="margin-top: 1em">&quot;localenv&quot; should
contain:</p>

<p style="margin-top: 1em">#export
SUPERMIN=/tmp/supermin/src/supermin <br>
#export
LIBGUESTFS_HV=/tmp/qemu/x86_64-softmmu/qemu-system-x86_64
<br>
#export SUPERMIN_KERNEL=/tmp/linux/arch/x86/boot/bzImage
<br>
#export SUPERMIN_KERNEL_VERSION=4.XX.0 <br>
#export SUPERMIN_MODULES=/tmp/lib/modules/4.XX.0</p>

<p style="margin-top: 1em">Uncomment and adjust these lines
as required to use the alternate programs you have
compiled.</p>

<p style="margin-top: 1em">Use &quot;./localconfigure&quot;
instead of &quot;./configure&quot;, but otherwise you
compile libguestfs as usual.</p>

<p style="margin-top: 1em">Don&rsquo;t run &quot;make
install&quot;! Use the &quot;./run&quot; script instead (see
README).</p>

<p style="margin-top: 1em">How can I compile and install
libguestfs without supermin? <br>
If supermin 5 supports your distro, but you don&rsquo;t
happen to have a new enough supermin installed, then see the
previous question.</p>

<p style="margin-top: 1em">If supermin 5 doesn&rsquo;t
support your distro at all, you will need to use the
&quot;fixed appliance method&quot; where you use a
pre-compiled binary appliance. To build libguestfs without
<br>
supermin, you need to pass &quot;--disable-appliance
--disable-daemon&quot; to either ./autogen.sh or ./configure
(depending whether you are building respectively from git or
from <br>
tarballs). Then, when using libguestfs, you must set the
&quot;LIBGUESTFS_PATH&quot; environment variable to the
directory of a pre-compiled appliance, as also described in
&quot;FIXED <br>
APPLIANCE&quot; in guestfs-internals(1).</p>

<p style="margin-top: 1em">For pre-compiled appliances, see
also:
http://libguestfs.org/download/binaries/appliance/.</p>

<p style="margin-top: 1em">Patches to port supermin to more
Linux distros are welcome.</p>

<p style="margin-top: 1em">How can I add support for sVirt?
<br>
Note for Fedora/RHEL users: This configuration is the
default starting with Fedora&Acirc;&nbsp;18 and
RHEL&Acirc;&nbsp;7. If you find any problems, please let us
know or file a bug.</p>

<p style="margin-top: 1em">SVirt provides a hardened
appliance using SELinux, making it very hard for a rogue
disk image to &quot;escape&quot; from the confinement of
libguestfs and damage the host (it&rsquo;s fair to say <br>
that even in standard libguestfs this would be hard, but
sVirt provides an extra layer of protection for the host and
more importantly protects virtual machines on the same host
<br>
from each other).</p>

<p style="margin-top: 1em">Currently to enable sVirt you
will need libvirt &acirc;&yen; 0.10.2 (1.0 or later
preferred), libguestfs &acirc;&yen; 1.20, and the SELinux
policies from recent Fedora. If you are not running <br>
Fedora&Acirc;&nbsp;18+, you will need to make changes to
your SELinux policy - contact us on the mailing list.</p>

<p style="margin-top: 1em">Once you have the requirements,
do:</p>

<p style="margin-top: 1em">./configure
--with-default-backend=libvirt # libguestfs &gt;= 1.22 <br>
./configure --with-default-attach-method=libvirt #
libguestfs &lt;= 1.20 <br>
make</p>

<p style="margin-top: 1em">Set SELinux to Enforcing mode,
and sVirt should be used automatically.</p>

<p style="margin-top: 1em">All, or almost all, features of
libguestfs should work under sVirt. There is one known
shortcoming: virt-rescue(1) will not use libvirt (hence
sVirt), but falls back to direct <br>
launch of qemu. So you won&rsquo;t currently get the benefit
of sVirt protection when using virt-rescue.</p>

<p style="margin-top: 1em">You can check if sVirt is being
used by enabling libvirtd logging (see
/etc/libvirt/libvirtd.log), killing and restarting libvirtd,
and checking the log files for <br>

&quot;Setting&Acirc;&nbsp;SELinux&Acirc;&nbsp;context&Acirc;&nbsp;on&Acirc;&nbsp;...&quot;
messages.</p>

<p style="margin-top: 1em">In theory sVirt should support
AppArmor, but we have not tried it. It will almost certainly
require patching libvirt and writing an AppArmor policy.</p>

<p style="margin-top: 1em">Libguestfs has a really long
list of dependencies! <br>
The base library doesn&rsquo;t depend on very much, but
there are three causes of the long list of other
dependencies:</p>

<p style="margin-top: 1em">1. Libguestfs has to be able to
read and edit many different disk formats. For example, XFS
support requires XFS tools.</p>

<p style="margin-top: 1em">2. There are language bindings
for many different languages, all requiring their own
development tools. All language bindings (except C) are
optional.</p>

<p style="margin-top: 1em">3. There are some optional
library features which can be disabled.</p>

<p style="margin-top: 1em">Since libguestfs &acirc;&yen;
1.26 it is possible to split up the appliance dependencies
(item 1 in the list above) and thus have (eg)
&quot;libguestfs-xfs&quot; as a separate subpackage for <br>
processing XFS disk images. We encourage downstream
packagers to start splitting the base libguestfs package
into smaller subpackages.</p>

<p style="margin-top: 1em">Errors during launch on Fedora
&acirc;&yen; 18, RHEL &acirc;&yen; 7 <br>
In Fedora &acirc;&yen; 18 and RHEL &acirc;&yen; 7,
libguestfs uses libvirt to manage the appliance. Previously
(and upstream) libguestfs runs qemu directly:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; libguestfs &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc; direct backend &acirc; libvirt backend &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; qemu &acirc; &acirc; libvirtd &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; qemu &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">upstream Fedora 18+ <br>
non-Fedora RHEL 7+ <br>
non-RHEL</p>

<p style="margin-top: 1em">The libvirt backend is more
sophisticated, supporting SELinux/sVirt (see above),
hotplugging and more. It is, however, more complex and so
less robust.</p>

<p style="margin-top: 1em">If you have permissions problems
using the libvirt backend, you can switch to the direct
backend by setting this environment variable:</p>

<p style="margin-top: 1em">export
LIBGUESTFS_BACKEND=direct</p>

<p style="margin-top: 1em">before running any libguestfs
program or virt tool.</p>

<p style="margin-top: 1em">How can I switch to a fixed /
prebuilt appliance? <br>
This may improve the stability and performance of libguestfs
on Fedora and RHEL.</p>

<p style="margin-top: 1em">Any time after installing
libguestfs, run the following commands as root:</p>

<p style="margin-top: 1em">mkdir -p
/usr/local/lib/guestfs/appliance <br>
libguestfs-make-fixed-appliance
/usr/local/lib/guestfs/appliance <br>
ls -l /usr/local/lib/guestfs/appliance</p>

<p style="margin-top: 1em">Now set the following
environment variable before using libguestfs or any virt
tool:</p>

<p style="margin-top: 1em">export
LIBGUESTFS_PATH=/usr/local/lib/guestfs/appliance</p>

<p style="margin-top: 1em">Of course you can change the
path to any directory you want. You can share the appliance
across machines that have the same architecture (eg. all
x86-64), but note that libvirt <br>
will prevent you from sharing the appliance across NFS
because of permissions problems (so either switch to the
direct backend or don&rsquo;t use NFS).</p>

<p style="margin-top: 1em">How can I speed up libguestfs
builds? <br>
By far the most important thing you can do is to install and
properly configure Squid. Note that the default
configuration that ships with Squid is rubbish, so
configuring it is <br>
not optional.</p>

<p style="margin-top: 1em">A very good place to start with
Squid configuration is here:
https://fedoraproject.org/wiki/Extras/MockTricks#Using_Squid_to_Speed_Up_Mock_package_downloads</p>

<p style="margin-top: 1em">Make sure Squid is running, and
that the environment variables $http_proxy and $ftp_proxy
are pointing to it.</p>

<p style="margin-top: 1em">With Squid running and correctly
configured, appliance builds should be reduced to a few
minutes.</p>

<p style="margin-top: 1em">How can I speed up libguestfs
builds (Debian)?</p>

<p style="margin-top: 1em">Hilko Bengen suggests using
&quot;approx&quot; which is a Debian archive proxy
(http://packages.debian.org/approx). This tool is documented
on Debian in the approx(8) manual page.</p>

<p style="margin-top: 1em">SPEED, DISK SPACE USED BY
LIBGUESTFS <br>
Note: Most of the information in this section has moved:
guestfs-performance(1).</p>

<p style="margin-top: 1em">Upload or write seem very slow.
<br>
If the underlying disk is not fully allocated (eg. sparse
raw or qcow2) then writes can be slow because the host
operating system has to do costly disk allocations while you
are <br>
writing. The solution is to use a fully allocated format
instead, ie. non-sparse raw, or qcow2 with the
&quot;preallocation=metadata&quot; option.</p>

<p style="margin-top: 1em">Libguestfs uses too much disk
space! <br>
libguestfs caches a large-ish appliance in:</p>


<p style="margin-top: 1em">/var/tmp/.guestfs-&lt;UID&gt;</p>

<p style="margin-top: 1em">If the environment variable
&quot;TMPDIR&quot; is defined, then
$TMPDIR/.guestfs-&lt;UID&gt; is used instead.</p>

<p style="margin-top: 1em">It is safe to delete this
directory when you are not using libguestfs.</p>

<p style="margin-top: 1em">virt-sparsify seems to make the
image grow to the full size of the virtual disk <br>
If the input to virt-sparsify(1) is raw, then the output
will be raw sparse. Make sure you are measuring the output
with a tool which understands sparseness such as &quot;du
-sh&quot;. <br>
It can make a huge difference:</p>

<p style="margin-top: 1em">$ ls -lh test1.img <br>
-rw-rw-r--. 1 rjones rjones 100M Aug 8 08:08 test1.img <br>
$ du -sh test1.img <br>
3.6M test1.img</p>

<p style="margin-top: 1em">(Compare the apparent size 100M
vs the actual size 3.6M)</p>

<p style="margin-top: 1em">If all this confuses you, use a
non-sparse output format by specifying the --convert option,
eg:</p>

<p style="margin-top: 1em">virt-sparsify --convert qcow2
disk.raw disk.qcow2</p>

<p style="margin-top: 1em">Why doesn&rsquo;t virt-resize
work on the disk image in-place? <br>
Resizing a disk image is very tricky -- especially making
sure that you don&rsquo;t lose data or break the bootloader.
The current method effectively creates a new disk image and
<br>
copies the data plus bootloader from the old one. If
something goes wrong, you can always go back to the
original.</p>

<p style="margin-top: 1em">If we were to make virt-resize
work in-place then there would have to be limitations: for
example, you wouldn&rsquo;t be allowed to move existing
partitions (because moving data across <br>
the same disk is most likely to corrupt data in the event of
a power failure or crash), and LVM would be very difficult
to support (because of the almost arbitrary mapping <br>
between LV content and underlying disk blocks).</p>

<p style="margin-top: 1em">Another method we have
considered is to place a snapshot over the original disk
image, so that the original data is untouched and only
differences are recorded in the snapshot. <br>
You can do this today using &quot;qemu-img create&quot; +
&quot;virt-resize&quot;, but qemu currently isn&rsquo;t
smart enough to recognize when the same block is written
back to the snapshot as already <br>
exists in the backing disk, so you will find that this
doesn&rsquo;t save you any space or time.</p>

<p style="margin-top: 1em">In summary, this is a hard
problem, and what we have now mostly works so we are
reluctant to change it.</p>

<p style="margin-top: 1em">Why doesn&rsquo;t virt-sparsify
work on the disk image in-place? <br>
In libguestfs &acirc;&yen; 1.26, virt-sparsify can now work
on disk images in place. Use:</p>

<p style="margin-top: 1em">virt-sparsify --in-place
disk.img</p>

<p style="margin-top: 1em">But first you should read
&quot;IN-PLACE SPARSIFICATION&quot; in virt-sparsify(1).</p>

<p style="margin-top: 1em">PROBLEMS OPENING DISK IMAGES
<br>
Remote libvirt guests cannot be opened. <br>
Opening remote libvirt guests is not supported at this time.
For example this won&rsquo;t work:</p>

<p style="margin-top: 1em">guestfish -c
qemu://remote/system -d Guest</p>

<p style="margin-top: 1em">To open remote disks you have to
export them somehow, then connect to the export. For example
if you decided to use NBD:</p>

<p style="margin-top: 1em">remote$ qemu-nbd -t -p 10809
guest.img <br>
local$ guestfish -a nbd://remote:10809 -i</p>

<p style="margin-top: 1em">Other possibilities include ssh
(if qemu is recent enough), NFS or iSCSI. See &quot;REMOTE
STORAGE&quot; in guestfs(3).</p>

<p style="margin-top: 1em">How can I open this strange disk
source? <br>
You have a disk image located inside another system that
requires access via a library / HTTP / REST / proprietary
API, or is compressed or archived in some way. (One example
<br>
would be remote access to OpenStack glance images without
actually downloading them.)</p>

<p style="margin-top: 1em">We have a sister project called
nbdkit (https://github.com/libguestfs/nbdkit). This project
lets you turn any disk source into an NBD server. Libguestfs
can access NBD servers <br>
directly, eg:</p>

<p style="margin-top: 1em">guestfish -a nbd://remote</p>

<p style="margin-top: 1em">nbdkit is liberally licensed, so
you can link it to or include it in proprietary libraries
and code. It also has a simple, stable plugin API so you can
easily write plugins <br>
against the API which will continue to work in future.</p>

<p style="margin-top: 1em">Error opening VMDK disks:
&quot;uses a vmdk feature which is not supported by this
qemu version: VMDK version 3&quot; <br>
Qemu (and hence libguestfs) only supports certain VMDK disk
images. Others won&rsquo;t work, giving this or similar
errors.</p>

<p style="margin-top: 1em">Ideally someone would fix qemu
to support the latest VMDK features, but in the meantime you
have three options:</p>

<p style="margin-top: 1em">1. If the guest is hosted on a
live, reachable ESX server, then locate and download the
disk image called somename-flat.vmdk. Despite the name, this
is a raw disk image, and <br>
can be opened by anything.</p>

<p style="margin-top: 1em">If you have a recent enough
version of qemu and libguestfs, then you may be able to
access this disk image remotely using either HTTPS or ssh.
See &quot;REMOTE STORAGE&quot; in <br>
guestfs(3).</p>

<p style="margin-top: 1em">2. Use VMware&rsquo;s
proprietary vdiskmanager tool to convert the image to raw
format.</p>

<p style="margin-top: 1em">3. Use nbdkit with the
proprietary VDDK plugin to live export the disk image as an
NBD source. This should allow you to read and write the VMDK
file.</p>

<p style="margin-top: 1em">UFS disks (as used by BSD)
cannot be opened. <br>
The UFS filesystem format has many variants, and these are
not self-identifying. The Linux kernel has to be told which
variant of UFS it has to use, which libguestfs cannot <br>
know.</p>

<p style="margin-top: 1em">You have to pass the right
&quot;ufstype&quot; mount option when mounting these
filesystems.</p>

<p style="margin-top: 1em">See
https://www.kernel.org/doc/Documentation/filesystems/ufs.txt</p>

<p style="margin-top: 1em">Windows ReFS <br>
Windows ReFS is Microsoft&rsquo;s ZFS/Btrfs copy. This
filesystem has not yet been reverse engineered and
implemented in the Linux kernel, and therefore libguestfs
doesn&rsquo;t support it. <br>
At the moment it seems to be very rare &quot;in the
wild&quot;.</p>

<p style="margin-top: 1em">Non-ASCII characters don&rsquo;t
appear on VFAT filesystems. <br>
Typical symptoms of this problem:</p>

<p style="margin-top: 1em">&Acirc;&middot; You get an error
when you create a file where the filename contains non-ASCII
characters, particularly non 8-bit characters from Asian
languages (Chinese, Japanese, etc). <br>
The filesystem is VFAT.</p>

<p style="margin-top: 1em">&Acirc;&middot; When you list a
directory from a VFAT filesystem, filenames appear as
question marks.</p>

<p style="margin-top: 1em">This is a design flaw of the
GNU/Linux system.</p>

<p style="margin-top: 1em">VFAT stores long filenames as
UTF-16 characters. When opening or returning filenames, the
Linux kernel has to translate these to some form of 8 bit
string. UTF-8 would be the <br>
obvious choice, except for Linux users who persist in using
non-UTF-8 locales (the user&rsquo;s locale is not known to
the kernel because it&rsquo;s a function of libc).</p>

<p style="margin-top: 1em">Therefore you have to tell the
kernel what translation you want done when you mount the
filesystem. The two methods are the &quot;iocharset&quot;
parameter (which is not relevant to <br>
libguestfs) and the &quot;utf8&quot; flag.</p>

<p style="margin-top: 1em">So to use a VFAT filesystem you
must add the &quot;utf8&quot; flag when mounting. From
guestfish, use:</p>

<p style="margin-top: 1em">&gt;&lt;fs&gt; mount-options
utf8 /dev/sda1 /</p>

<p style="margin-top: 1em">or on the guestfish command
line:</p>

<p style="margin-top: 1em">guestfish [...] -m
/dev/sda1:/:utf8</p>

<p style="margin-top: 1em">or from the API:</p>

<p style="margin-top: 1em">guestfs_mount_options (g,
&quot;utf8&quot;, &quot;/dev/sda1&quot;, &quot;/&quot;);</p>

<p style="margin-top: 1em">The kernel will then translate
filenames to and from UTF-8 strings.</p>

<p style="margin-top: 1em">We considered adding this mount
option transparently, but unfortunately there are several
problems with doing that:</p>

<p style="margin-top: 1em">&Acirc;&middot; On some Linux
systems, the &quot;utf8&quot; mount option doesn&rsquo;t
work. We don&rsquo;t precisely understand what systems or
why, but this was reliably reported by one user.</p>

<p style="margin-top: 1em">&Acirc;&middot; It would prevent
you from using the &quot;iocharset&quot; parameter because
it is incompatible with &quot;utf8&quot;. It is probably not
a good idea to use this parameter, but we don&rsquo;t want
to <br>
prevent it.</p>

<p style="margin-top: 1em">Non-ASCII characters appear as
underscore (_) on ISO9660 filesystems. <br>
The filesystem was not prepared correctly with mkisofs or
genisoimage. Make sure the filesystem was created using
Joliet and/or Rock Ridge extensions. libguestfs does not
<br>
require any special mount options to handle the
filesystem.</p>

<p style="margin-top: 1em">Cannot open Windows guests which
use NTFS. <br>
You see errors like:</p>

<p style="margin-top: 1em">mount: unknown filesystem type
&rsquo;ntfs&rsquo;</p>

<p style="margin-top: 1em">On Red Hat Enterprise Linux or
CentOS &lt; 7.2, you have to install the
libguestfs-winsupport package. In RHEL &acirc;&yen; 7.2,
&quot;libguestfs-winsupport&quot; is part of the base RHEL
distribution, <br>
but see the next question.</p>

<p style="margin-top: 1em">&quot;mount: unsupported
filesystem type&quot; with NTFS in RHEL &acirc;&yen; 7.2
<br>
In RHEL 7.2 we were able to add
&quot;libguestfs-winsupport&quot; to the base RHEL
distribution, but we had to disable the ability to use it
for opening and editing filesystems. It is <br>
only supported when used with virt-v2v(1). If you try to use
guestfish(1) or guestmount(1) or some other programs on an
NTFS filesystem, you will see the error:</p>

<p style="margin-top: 1em">mount: unsupported filesystem
type</p>

<p style="margin-top: 1em">This is not a supported
configuration, and it will not be made to work in RHEL.
Don&rsquo;t bother to open a bug about it, as it will be
immediately &quot;CLOSED -&gt; WONTFIX&quot;.</p>

<p style="margin-top: 1em">You may compile your own
libguestfs removing this restriction, but that won&rsquo;t
be endorsed or supported by Red Hat.</p>

<p style="margin-top: 1em">Cannot open or inspect RHEL 7
guests. <br>
Cannot open Linux guests which use XFS. <br>
RHEL 7 guests, and any other guests that use XFS, can be
opened by libguestfs, but you have to install the
&quot;libguestfs-xfs&quot; package.</p>

<p style="margin-top: 1em">USING LIBGUESTFS IN YOUR OWN
PROGRAMS <br>
The API has hundreds of methods, where do I start? <br>
We recommend you start by reading the API overview:
&quot;API OVERVIEW&quot; in guestfs(3).</p>

<p style="margin-top: 1em">Although the API overview covers
the C API, it is still worth reading even if you are going
to use another programming language, because the API is the
same, just with simple <br>
logical changes to the names of the calls:</p>

<p style="margin-top: 1em">C guestfs_ln_sf (g, target,
linkname); <br>
Python g.ln_sf (target, linkname); <br>
OCaml g#ln_sf target linkname; <br>
Perl $g-&gt;ln_sf (target, linkname); <br>
Shell (guestfish) ln-sf target linkname <br>
PHP guestfs_ln_sf ($g, $target, $linkname);</p>

<p style="margin-top: 1em">Once you&rsquo;re familiar with
the API overview, you should look at this list of starting
points for other language bindings: &quot;USING LIBGUESTFS
WITH OTHER PROGRAMMING LANGUAGES&quot; in <br>
guestfs(3).</p>

<p style="margin-top: 1em">Can I use libguestfs in my
proprietary / closed source / commercial program? <br>
In general, yes. However this is not legal advice - read the
license that comes with libguestfs, and if you have specific
questions contact a lawyer.</p>

<p style="margin-top: 1em">In the source tree the license
is in the file &quot;COPYING.LIB&quot; (LGPLv2+ for the
library and bindings) and &quot;COPYING&quot; (GPLv2+ for
the standalone programs).</p>

<p style="margin-top: 1em">DEBUGGING LIBGUESTFS <br>
Help, it&rsquo;s not working! <br>
If no libguestfs program seems to work at all, run the
program below and paste the complete, unedited output into
an email to &quot;libguestfs&quot; @
&quot;redhat.com&quot;:</p>

<p style="margin-top: 1em">libguestfs-test-tool</p>

<p style="margin-top: 1em">If a particular operation fails,
supply all the information in this checklist, in an email to
&quot;libguestfs&quot; @ &quot;redhat.com&quot;:</p>

<p style="margin-top: 1em">1. What are you trying to
do?</p>

<p style="margin-top: 1em">2. What exact command(s) did you
run?</p>

<p style="margin-top: 1em">3. What was the precise error or
output of these commands?</p>

<p style="margin-top: 1em">4. Enable debugging, run the
commands again, and capture the complete output. Do not edit
the output.</p>

<p style="margin-top: 1em">export LIBGUESTFS_DEBUG=1 <br>
export LIBGUESTFS_TRACE=1</p>

<p style="margin-top: 1em">5. Include the version of
libguestfs, the operating system version, and how you
installed libguestfs (eg. from source, &quot;yum
install&quot;, etc.)</p>

<p style="margin-top: 1em">How do I debug when using any
libguestfs program or tool (eg. virt-v2v or virt-df)? <br>
There are two &quot;LIBGUESTFS_*&quot; environment variables
you can set in order to get more information from
libguestfs.</p>

<p style="margin-top: 1em">&quot;LIBGUESTFS_TRACE&quot;
<br>
Set this to 1 and libguestfs will print out each command /
API call in a format which is similar to guestfish
commands.</p>

<p style="margin-top: 1em">&quot;LIBGUESTFS_DEBUG&quot;
<br>
Set this to 1 in order to enable massive amounts of debug
messages. If you think there is some problem inside the
libguestfs appliance, then you should use this option.</p>

<p style="margin-top: 1em">To set these from the shell, do
this before running the program:</p>

<p style="margin-top: 1em">export LIBGUESTFS_TRACE=1 <br>
export LIBGUESTFS_DEBUG=1</p>

<p style="margin-top: 1em">For csh/tcsh the equivalent
commands would be:</p>

<p style="margin-top: 1em">setenv LIBGUESTFS_TRACE 1 <br>
setenv LIBGUESTFS_DEBUG 1</p>

<p style="margin-top: 1em">For further information, see:
&quot;ENVIRONMENT VARIABLES&quot; in guestfs(3).</p>

<p style="margin-top: 1em">How do I debug when using
guestfish? <br>
You can use the same environment variables above.
Alternatively use the guestfish options -x (to trace
commands) or -v (to get the full debug output), or both.</p>

<p style="margin-top: 1em">For further information, see:
guestfish(1).</p>

<p style="margin-top: 1em">How do I debug when using the
API? <br>
Call &quot;guestfs_set_trace&quot; in guestfs(3) to enable
command traces, and/or &quot;guestfs_set_verbose&quot; in
guestfs(3) to enable debug messages.</p>

<p style="margin-top: 1em">For best results, call these
functions as early as possible, just after creating the
guestfs handle if you can, and definitely before calling
launch.</p>

<p style="margin-top: 1em">How do I capture debug output
and put it into my logging system? <br>
Use the event API. For examples, see: &quot;SETTING
CALLBACKS TO HANDLE EVENTS&quot; in guestfs(3) and the
examples/debug-logging.c program in the libguestfs
sources.</p>

<p style="margin-top: 1em">Digging deeper into the
appliance boot process. <br>
Enable debugging and then read this documentation on the
appliance boot process: guestfs-internals(1).</p>

<p style="margin-top: 1em">libguestfs hangs or fails during
run/launch. <br>
Enable debugging and look at the full output. If you cannot
work out what is going on, file a bug report, including the
complete output of libguestfs-test-tool(1).</p>

<p style="margin-top: 1em">Debugging libvirt <br>
If you are using the libvirt backend, and libvirt is
failing, then you can enable debugging by editing
/etc/libvirt/libvirtd.conf.</p>

<p style="margin-top: 1em">If you are running as non-root,
then you have to edit a different file. Create
~/.config/libvirt/libvirtd.conf containing:</p>

<p style="margin-top: 1em">log_level=1 <br>
log_outputs=&quot;1:file:/tmp/libvirtd.log&quot;</p>

<p style="margin-top: 1em">Kill any session (non-root)
libvirtd that is running, and next time you run the
libguestfs command, you should see a large amount of useful
debugging information from libvirtd in <br>
/tmp/libvirtd.log</p>

<p style="margin-top: 1em">DESIGN/INTERNALS OF LIBGUESTFS
<br>
See also guestfs-internals(1).</p>

<p style="margin-top: 1em">Why don&rsquo;t you do
everything through the FUSE / filesystem interface? <br>
We offer a command called guestmount(1) which lets you mount
guest filesystems on the host. This is implemented as a FUSE
module. Why don&rsquo;t we just implement the whole of <br>
libguestfs using this mechanism, instead of having the large
and rather complicated API?</p>

<p style="margin-top: 1em">The reasons are twofold.
Firstly, libguestfs offers API calls for doing things like
creating and deleting partitions and logical volumes, which
don&rsquo;t fit into a filesystem model <br>
very easily. Or rather, you could fit them in: for example,
creating a partition could be mapped to &quot;mkdir
/fs/hda1&quot; but then you&rsquo;d have to specify some
method to choose the <br>
size of the partition (maybe &quot;echo 100M &gt;
/fs/hda1/.size&quot;), and the partition type, start and end
sectors etc., but once you&rsquo;ve done that the
filesystem-based API starts to look <br>
more complicated than the call-based API we currently
have.</p>

<p style="margin-top: 1em">The second reason is for
efficiency. FUSE itself is reasonably efficient, but it does
make lots of small, independent calls into the FUSE module.
In guestmount these have to be <br>
translated into messages to the libguestfs appliance which
has a big overhead (in time and round trips). For example,
reading a file in 64 KB chunks is inefficient because each
<br>
chunk would turn into a single round trip. In the libguestfs
API it is much more efficient to download an entire file or
directory through one of the streaming calls like <br>
&quot;guestfs_download&quot; or
&quot;guestfs_tar_out&quot;.</p>

<p style="margin-top: 1em">Why don&rsquo;t you do
everything through GVFS? <br>
The problems are similar to the problems with FUSE.</p>

<p style="margin-top: 1em">GVFS is a better abstraction
than POSIX/FUSE. There is an FTP backend for GVFS, which is
encouraging because FTP is conceptually similar to the
libguestfs API. However the GVFS <br>
FTP backend makes multiple simultaneous connections in order
to keep interactivity, which we can&rsquo;t easily do with
libguestfs.</p>

<p style="margin-top: 1em">Why can I write to the disk,
even though I added it read-only? <br>
Why does &quot;--ro&quot; appear to have no effect? <br>
When you add a disk read-only, libguestfs places a writable
overlay on top of the underlying disk. Writes go into this
overlay, and are discarded when the handle is closed (or
<br>
&quot;guestfish&quot; etc. exits).</p>

<p style="margin-top: 1em">There are two reasons for doing
it this way: Firstly read-only disks aren&rsquo;t possible
in many cases (eg. IDE simply doesn&rsquo;t support them, so
you couldn&rsquo;t have an IDE-emulated <br>
read-only disk, although this is not common in real
libguestfs installations).</p>

<p style="margin-top: 1em">Secondly and more importantly,
even if read-only disks were possible, you wouldn&rsquo;t
want them. Mounting any filesystem that has a journal, even
&quot;mount -o ro&quot;, causes writes to <br>
the filesystem because the journal has to be replayed and
metadata updated. If the disk was truly read-only, you
wouldn&rsquo;t be able to mount a dirty filesystem.</p>

<p style="margin-top: 1em">To make it usable, we create the
overlay as a place to temporarily store these writes, and
then we discard it afterwards. This ensures that the
underlying disk is always <br>
untouched.</p>

<p style="margin-top: 1em">Note also that there is a
regression test for this when building libguestfs (in
&quot;tests/qemu&quot;). This is one reason why it&rsquo;s
important for packagers to run the test suite.</p>

<p style="margin-top: 1em">Does &quot;--ro&quot; make all
disks read-only? <br>
No! The &quot;--ro&quot; option only affects disks added on
the command line, ie. using &quot;-a&quot; and
&quot;-d&quot; options.</p>

<p style="margin-top: 1em">In guestfish, if you use the
&quot;add&quot; command, then disk is added read-write
(unless you specify the &quot;readonly:true&quot; flag
explicitly with the command).</p>

<p style="margin-top: 1em">Can I use &quot;guestfish
--ro&quot; as a way to backup my virtual machines? <br>
Usually this is not a good idea. The question is answered in
more detail in this mailing list posting:
https://www.redhat.com/archives/libguestfs/2010-August/msg00024.html</p>

<p style="margin-top: 1em">See also the next question.</p>

<p style="margin-top: 1em">Why can&rsquo;t I run fsck on a
live filesystem using &quot;guestfish --ro&quot;? <br>
This command will usually not work:</p>

<p style="margin-top: 1em">guestfish --ro -a
/dev/vg/my_root_fs run : fsck /dev/sda</p>

<p style="margin-top: 1em">The reason for this is that qemu
creates a snapshot over the original filesystem, but it
doesn&rsquo;t create a strict point-in-time snapshot. Blocks
of data on the underlying <br>
filesystem are read by qemu at different times as the fsck
operation progresses, with host writes in between. The
result is that fsck sees massive corruption (imaginary, not
<br>
real!) and fails.</p>

<p style="margin-top: 1em">What you have to do is to create
a point-in-time snapshot. If it&rsquo;s a logical volume,
use an LVM2 snapshot. If the filesystem is located inside
something like a btrfs/ZFS file, <br>
use a btrfs/ZFS snapshot, and then run the fsck on the
snapshot. In practice you don&rsquo;t need to use libguestfs
for this -- just run /sbin/fsck directly.</p>

<p style="margin-top: 1em">Creating point-in-time snapshots
of host devices and files is outside the scope of
libguestfs, although libguestfs can operate on them once
they are created.</p>

<p style="margin-top: 1em">What&rsquo;s the difference
between guestfish and virt-rescue? <br>
A lot of people are confused by the two superficially
similar tools we provide:</p>

<p style="margin-top: 1em">$ guestfish --ro -a guest.img
<br>
&gt;&lt;fs&gt; run <br>
&gt;&lt;fs&gt; fsck /dev/sda1</p>

<p style="margin-top: 1em">$ virt-rescue --ro guest.img
<br>
&gt;&lt;rescue&gt; /sbin/fsck /dev/sda1</p>

<p style="margin-top: 1em">And the related question which
then arises is why you can&rsquo;t type in full shell
commands with all the --options in guestfish (but you can in
virt-rescue(1)).</p>

<p style="margin-top: 1em">guestfish(1) is a program
providing structured access to the guestfs(3) API. It
happens to be a nice interactive shell too, but its primary
purpose is structured access from <br>
shell scripts. Think of it more like a language binding,
like Python and other bindings, but for shell. The key
differentiating factor of guestfish (and the libguestfs API
in <br>
general) is the ability to automate changes.</p>

<p style="margin-top: 1em">virt-rescue(1) is a free-for-all
freeform way to boot the libguestfs appliance and make
arbitrary changes to your VM. It&rsquo;s not structured, you
can&rsquo;t automate it, but for making <br>
quick ad-hoc fixes to your guests, it can be quite
useful.</p>

<p style="margin-top: 1em">But, libguestfs also has a
&quot;backdoor&quot; into the appliance allowing you to send
arbitrary shell commands. It&rsquo;s not as flexible as
virt-rescue, because you can&rsquo;t interact with the <br>
shell commands, but here it is anyway:</p>

<p style="margin-top: 1em">&gt;&lt;fs&gt; debug sh
&quot;cmd arg1 arg2 ...&quot;</p>

<p style="margin-top: 1em">Note that you should not rely on
this. It could be removed or changed in future. If your
program needs some operation, please add it to the
libguestfs API instead.</p>

<p style="margin-top: 1em">What&rsquo;s the deal with
&quot;guestfish -i&quot;? <br>
Why does virt-cat only work on a real VM image, but virt-df
works on any disk image? <br>
What does &quot;no root device found in this operating
system image&quot; mean? <br>
These questions are all related at a fundamental level which
may not be immediately obvious.</p>

<p style="margin-top: 1em">At the guestfs(3) API level, a
&quot;disk image&quot; is just a pile of partitions and
filesystems.</p>

<p style="margin-top: 1em">In contrast, when the virtual
machine boots, it mounts those filesystems into a consistent
hierarchy such as:</p>

<p style="margin-top: 1em">/ (/dev/sda2) <br>
&acirc; <br>
&acirc;&acirc;&acirc; /boot (/dev/sda1) <br>
&acirc; <br>
&acirc;&acirc;&acirc; /home (/dev/vg_external/Homes) <br>
&acirc; <br>
&acirc;&acirc;&acirc; /usr (/dev/vg_os/lv_usr) <br>
&acirc; <br>
&acirc;&acirc;&acirc; /var (/dev/vg_os/lv_var)</p>

<p style="margin-top: 1em">(or drive letters on
Windows).</p>

<p style="margin-top: 1em">The API first of all sees the
disk image at the &quot;pile of filesystems&quot; level. But
it also has a way to inspect the disk image to see if it
contains an operating system, and how <br>
the disks are mounted when the operating system boots:
&quot;INSPECTION&quot; in guestfs(3).</p>

<p style="margin-top: 1em">Users expect some tools (like
virt-cat(1)) to work with VM paths:</p>

<p style="margin-top: 1em">virt-cat fedora.img
/var/log/messages</p>

<p style="margin-top: 1em">How does virt-cat know that /var
is a separate partition? The trick is that virt-cat performs
inspection on the disk image, and uses that to translate the
path correctly.</p>

<p style="margin-top: 1em">Some tools (including
virt-cat(1), virt-edit(1), virt-ls(1)) use inspection to map
VM paths. Other tools, such as virt-df(1) and
virt-filesystems(1) operate entirely at the raw <br>
&quot;big pile of filesystems&quot; level of the libguestfs
API, and don&rsquo;t use inspection.</p>

<p style="margin-top: 1em">guestfish(1) is in an
interesting middle ground. If you use the -a and -m command
line options, then you have to tell guestfish exactly how to
add disk images and where to mount <br>
partitions. This is the raw API level.</p>

<p style="margin-top: 1em">If you use the -i option,
libguestfs performs inspection and mounts the filesystems
for you.</p>

<p style="margin-top: 1em">The error &quot;no root device
found in this operating system image&quot; is related to
this. It means inspection was unable to locate an operating
system within the disk image you gave <br>
it. You might see this from programs like virt-cat if you
try to run them on something which is just a disk image, not
a virtual machine disk image.</p>

<p style="margin-top: 1em">What do these &quot;debug*&quot;
and &quot;internal-*&quot; functions do? <br>
There are some functions which are used for debugging and
internal purposes which are not part of the stable API.</p>

<p style="margin-top: 1em">The &quot;debug*&quot; (or
&quot;guestfs_debug*&quot;) functions, primarily
&quot;guestfs_debug&quot; in guestfs(3) and a handful of
others, are used for debugging libguestfs. Although they are
not part of <br>
the stable API and thus may change or be removed at any
time, some programs may want to call these while waiting for
features to be added to libguestfs.</p>

<p style="margin-top: 1em">The &quot;internal-*&quot; (or
&quot;guestfs_internal_*&quot;) functions are purely to be
used by libguestfs itself. There is no reason for programs
to call them, and programs should not try to use <br>
them. Using them will often cause bad things to happen, as
well as not being part of the documented stable API.</p>

<p style="margin-top: 1em">DEVELOPERS <br>
Where do I send patches? <br>
Please send patches to the libguestfs mailing list
https://www.redhat.com/mailman/listinfo/libguestfs. You
don&rsquo;t have to be subscribed, but there will be a delay
until your <br>
posting is manually approved.</p>

<p style="margin-top: 1em">Please don&rsquo;t use github
pull requests - they will be ignored. The reasons are (a) we
want to discuss and dissect patches on the mailing list, and
(b) github pull requests turn <br>
into merge commits but we prefer to have a linear
history.</p>

<p style="margin-top: 1em">How do I propose a feature? <br>
Large new features that you intend to contribute should be
discussed on the mailing list first
(https://www.redhat.com/mailman/listinfo/libguestfs). This
avoids disappointment <br>
and wasted work if we don&rsquo;t think the feature would
fit into the libguestfs project.</p>

<p style="margin-top: 1em">If you want to suggest a useful
feature but don&rsquo;t want to write the code, you can file
a bug (see &quot;GETTING HELP AND REPORTING BUGS&quot;) with
&quot;RFE: &quot; at the beginning of the Summary <br>
line.</p>

<p style="margin-top: 1em">Who can commit to libguestfs
git? <br>
About 5 people have commit access to github. Patches should
be posted on the list first and ACKed. The policy for ACKing
and pushing patches is outlined here:</p>


<p style="margin-top: 1em">https://www.redhat.com/archives/libguestfs/2012-January/msg00023.html</p>

<p style="margin-top: 1em">Can I fork libguestfs? <br>
Of course you can. Git makes it easy to fork libguestfs.
Github makes it even easier. It&rsquo;s nice if you tell us
on the mailing list about forks and the reasons for
them.</p>

<p style="margin-top: 1em">MISCELLANEOUS QUESTIONS <br>
Can I monitor the live disk activity of a virtual machine
using libguestfs? <br>
A common request is to be able to use libguestfs to monitor
the live disk activity of a guest, for example, to get
notified every time a guest creates a new file. Libguestfs
<br>
does not work in the way some people imagine, as you can see
from this diagram:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; monitoring program using libguestfs &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; live VM &acirc; &acirc; libguestfs appliance &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc; kernel (1)&acirc; &acirc; appliance kernel (2)
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; &acirc; (r/o connection) <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
| disk image | <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">This scenario is safe (as long
as you set the &quot;readonly&quot; flag when adding the
drive). However the libguestfs appliance kernel (2) does not
see all the changes made to the disk <br>
image, for two reasons:</p>

<p style="margin-top: 1em">i. The VM kernel (1) can cache
data in memory, so it doesn&rsquo;t appear in the disk
image.</p>

<p style="margin-top: 1em">ii. The libguestfs appliance
kernel (2) doesn&rsquo;t expect that the disk image is
changing underneath it, so its own cache is not magically
updated even when the VM kernel (1) does <br>
update the disk image.</p>

<p style="margin-top: 1em">The only supported solution is
to restart the entire libguestfs appliance whenever you want
to look at changes in the disk image. At the API level that
corresponds to calling <br>
&quot;guestfs_shutdown&quot; followed by
&quot;guestfs_launch&quot;, which is a heavyweight operation
(see also guestfs-performance(3)).</p>

<p style="margin-top: 1em">There are some unsupported hacks
you can try if relaunching the appliance is really too
costly:</p>

<p style="margin-top: 1em">&Acirc;&middot; Call
&quot;guestfs_drop_caches (g, 3)&quot;. This causes all
cached data help by the libguestfs appliance kernel (2) to
be discarded, so it goes back to the disk image.</p>

<p style="margin-top: 1em">However this on its own is not
sufficient, because qemu also caches some data. You will
also need to patch libguestfs to (re-)enable the
&quot;cache=none&quot; mode. See: <br>

https://rwmj.wordpress.com/2013/09/02/new-in-libguestfs-allow-cache-mode-to-be-selected/</p>

<p style="margin-top: 1em">&Acirc;&middot; Use a tool like
virt-bmap instead.</p>

<p style="margin-top: 1em">&Acirc;&middot; Run an agent
inside the guest.</p>

<p style="margin-top: 1em">Nothing helps if the guest is
making more fundamental changes (eg. deleting filesystems).
For those kinds of things you must relaunch the
appliance.</p>

<p style="margin-top: 1em">(Note there is a third problem
that you need to use consistent snapshots to really examine
live disk images, but that&rsquo;s a general problem with
using libguestfs against any live <br>
disk image.)</p>

<p style="margin-top: 1em">SEE ALSO <br>
guestfish(1), guestfs(3), http://libguestfs.org/.</p>

<p style="margin-top: 1em">AUTHORS <br>
Richard W.M. Jones (&quot;rjones at redhat dot
com&quot;)</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (C) 2012-2016 Red Hat Inc.</p>

<p style="margin-top: 1em">LICENSE <br>
This library is free software; you can redistribute it
and/or modify it under the terms of the GNU Lesser General
Public License as published by the Free Software Foundation;
<br>
either version 2 of the License, or (at your option) any
later version.</p>

<p style="margin-top: 1em">This library is distributed in
the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR <br>
PURPOSE. See the GNU Lesser General Public License for more
details.</p>

<p style="margin-top: 1em">You should have received a copy
of the GNU Lesser General Public License along with this
library; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth <br>
Floor, Boston, MA 02110-1301 USA</p>

<p style="margin-top: 1em">BUGS <br>
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-top: 1em">To report a new bug against
libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-top: 1em">When reporting a bug, please
supply:</p>

<p style="margin-top: 1em">&Acirc;&middot; The version of
libguestfs.</p>

<p style="margin-top: 1em">&Acirc;&middot; Where you got
libguestfs (eg. which Linux distro, compiled from source,
etc)</p>

<p style="margin-top: 1em">&Acirc;&middot; Describe the bug
accurately and give a way to reproduce it.</p>

<p style="margin-top: 1em">&Acirc;&middot; Run
libguestfs-test-tool(1) and paste the complete, unedited
output into the bug report.</p>

<p style="margin-top: 1em">libguestfs-1.32.7 2016-08-08
guestfs-faq(1)</p>
<hr>
</body>
</html>
