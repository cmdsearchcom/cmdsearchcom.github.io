<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>XSDCXX(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XSDCXX(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">XSDCXX(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
xsdcxx - W3C XML Schema to C++ Compiler
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>xsdcxx</b> <i>command</i> <b>[</b> <i>options</i> <b>]</b> <i>file</i>
  <b>[</b> <i>file</i> <b>...]</b>
<br/>
<b>xsdcxx help</b> <b>[</b> <i>command</i> <b>]</b>
<br/>
<b>xsdcxx version</b>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>xsdcxx</b> generates vocabulary-specific, statically-typed C++ mapping from
  W3C XML Schema definitions. Particular mapping to produce is selected by a
  <i>command</i>. Each mapping has a number of mapping-specific <i>options</i>
  that should appear, if any, after the <i>command</i>. Input files should be
  W3C XML Schema definitions. The exact set of the generated files depends on
  the selected mapping and options.
<h1 class="Sh" title="Sh" id="COMMANDS"><a class="selflink" href="#COMMANDS">COMMANDS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cxx-tree</b></dt>
  <dd class="It-tag">Generate the C++/Tree mapping. For each input file in the
      form <b>name.xsd</b> the following C++ files are generated:
      <b>name.hxx</b> (header file), <b>name.ixx</b> (inline file, generated
      only if the <b>--generate-inline</b> option is specified), <b>name.cxx</b>
      (source file), and <b>name-fwd.hxx</b> (forward declaration file,
      generated only if the <b>--generate-forward</b> option is specified).
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cxx-parser</b></dt>
  <dd class="It-tag">Generate the C++/Parser mapping. For each input file in the
      form <b>name.xsd</b> the following C++ files are generated:
      <b>name-pskel.hxx</b> (parser skeleton header file), <b>name-pskel.ixx</b>
      (parser skeleton inline file, generated only if the
      <b>--generate-inline</b> option is specified), and <b>name-pskel.cxx</b>
      (parser skeleton source file). If the <b>--generate-noop-impl</b> or
      <b>--generate-print-impl</b> option is specified, the following additional
      sample implementation files are generated: <b>name-pimpl.hxx</b> (parser
      implementation header file) and <b>name-pimpl.cxx</b> (parser
      implementation source file). If the <b>--generate-test-driver</b> option
      is specified, the additional <b>name-driver.cxx</b> test driver file is
      generated.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>help</b></dt>
  <dd class="It-tag">Print usage information and exit. Use</dd>
</dl>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="margin-left: 3.00ex;"><b>xsdcxx help</b> <i>command</i></div>
<div class="Pp"></div>
for command-specific help.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>version</b></dt>
  <dd class="It-tag">Print version and exit.</dd>
</dl>
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
Command-specific <i>options</i>, if any, should appear after the corresponding
  <i>command</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="common_options"><a class="selflink" href="#common_options">common
  options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--std</b> <i>version</i></dt>
  <dd class="It-tag">Specify the C++ standard that the generated code should
      conform to. Valid values are <b>c++98</b> (default) and <b>c++11</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The C++ standard affects various aspects of the generated code that are
      discussed in more detail in various mapping-specific documentation.
      Overall, when C++11 is selected, the generated code relies on the move
      semantics and uses <b>std::unique_ptr</b> instead of deprecated
      <b>std::auto_ptr</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    When the C++11 mode is selected, you normally don't need to perform any
      extra steps other than enable C++11 in your C++ compiler, if required. The
      XSDCXX compiler will automatically add the necessary macro defines to the
      generated header files that will switch the header-only XSDCXX runtime
      library ( <b>libxsd</b>) to the C++11 mode. However, if you include any of
      the XSDCXX runtime headers directly in your application (normally you just
      include the generated headers), then you will need to define the
      <b>XSD_CXX11</b> macro for your entire project.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--char-type</b> <i>type</i></dt>
  <dd class="It-tag">Generate code using the provided character <i>type</i>
      instead of the default <b>char</b>. Valid values are <b>char</b> and
      <b>wchar_t</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--char-encoding</b> <i>enc</i></dt>
  <dd class="It-tag">Specify the character encoding that should be used in the
      generated code. Valid values for the <b>char</b> character type are
      <b>utf8</b> (default), <b>iso8859-1</b>, <b>lcp</b> (Xerces-C++ local code
      page), and <b>custom</b>. If you pass <b>custom</b> as the value then you
      will need to include the transcoder implementation header for your
      encoding at the beginning of the generated header files (see the
      <b>--hxx-prologue</b> option).
    <div style="height: 1.00em;">&#x00A0;</div>
    For the <b>wchar_t</b> character type the only valid value is <b>auto</b>
      and the encoding is automatically selected between UTF-16 and
      UTF-32/UCS-4, depending on the <b>wchar_t</b> type size.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--output-dir</b> <i>dir</i></dt>
  <dd class="It-tag">Write generated files to <i>dir</i> instead of the current
      directory.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-inline</b></dt>
  <dd class="It-tag">Generate simple functions inline. This option triggers
      creation of the inline file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-xml-schema</b></dt>
  <dd class="It-tag">Generate a C++ header file as if the schema being compiled
      defines the XML Schema namespace. For the C++/Tree mapping, the resulting
      file will contain definitions for all XML Schema built-in types. For the
      C++/Parser mapping, the resulting file will contain definitions for all
      the parser skeletons and implementations corresponding to the XML Schema
      built-in types.
    <div style="height: 1.00em;">&#x00A0;</div>
    The schema file provided to the compiler need not exist and is only used to
      derive the name of the resulting header file. Use the
      <b>--extern-xml-schema</b> option to include this file in the generated
      files for other schemas.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--extern-xml-schema</b> <i>file</i></dt>
  <dd class="It-tag">Include a header file derived from <i>file</i> instead of
      generating the XML Schema namespace mapping inline. The provided file need
      not exist and is only used to derive the name of the included header file.
      Use the <b>--generate-xml-schema</b> option to generate this header file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--namespace-map</b> <i>xns</i>=<i>cns</i></dt>
  <dd class="It-tag">Map XML Schema namespace <i>xns</i> to C++ namespace
      <i>cns</i>. Repeat this option to specify mapping for more than one XML
      Schema namespace. For example, the following option:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--namespace-map http://example.com/foo/bar=foo::bar</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    Will map the <b>http://example.com/foo/bar</b> XML Schema namespace to the
      <b>foo::bar</b> C++ namespace.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--namespace-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema namespace names to C++ namespace names. <i>regex</i>
      is a Perl-like regular expression in the form
      <b>/</b><i>pattern</i><b>/</b> <i>replacement</i><b>/</b>. Any character
      can be used as a delimiter instead of <b>/</b>. Escaping of the delimiter
      character in <i>pattern</i> or <i>replacement</i> is not supported.
    <div style="height: 1.00em;">&#x00A0;</div>
    All the regular expressions are pushed into a stack with the last specified
      expression considered first. The first match that succeeds is used.
      Regular expressions are applied to a string in the form
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>filename</i> <i>namespace</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, if you have file <b>hello.xsd</b> with namespace
      <b>http://example.com/hello</b> and you run <b>xsd</b> on this file, then
      the string in question will be:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>hello.xsd. http://example.com/hello</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    For the built-in XML Schema namespace the string is:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>XMLSchema.xsd http://www.w3.org/2001/XMLSchema</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    The following three steps are performed for each regular expression until
      the match is found:
    <div style="height: 1.00em;">&#x00A0;</div>
    1. The expression is applied and if the result is empty the next expression
      is considered.
    <div style="height: 1.00em;">&#x00A0;</div>
    2. All <b>/</b> are replaced with <b>::</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    3. The result is verified to be a valid C++ scope name (e.g.,
      <b>foo::bar</b>). If this test succeeds, the result is used as a C++
      namespace name.
    <div style="height: 1.00em;">&#x00A0;</div>
    As an example, the following expression maps XML Schema namespaces in the
      form <b>http://example.com/foo/bar</b> to C++ namespaces in the form
      <b>foo::bar</b>:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>%.* http://example.com/(.+)%$1%</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also the REGEX AND SHELL QUOTING section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--namespace-regex-trace</b></dt>
  <dd class="It-tag">Trace the process of applying regular expressions specified
      with the <b>--namespace-regex</b> option. Use this option to find out why
      your regular expressions don't do what you expected them to do.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--reserved-name</b> <i>n</i>[=<i>r</i>]</dt>
  <dd class="It-tag">Add name <i>n</i> to the list of names that should not be
      used as identifiers. The name can optionally be followed by <b>=</b> and
      the replacement name <i>r</i> that should be used instead. All the C++
      keywords are already in this list.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--include-with-brackets</b></dt>
  <dd class="It-tag">Use angle brackets (&lt;&gt;) instead of quotes
      (&quot;&quot;) in generated <b>#include</b> directives.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--include-prefix</b> <i>prefix</i></dt>
  <dd class="It-tag">Add <i>prefix</i> to generated <b>#include</b> directive
      paths.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, if you had the following import element in your schema
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>&lt;import namespace=&quot;...&quot;
      schemaLocation=&quot;base.xsd&quot;/&gt;</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    and compiled this fragment with <b>--include-prefix schemas/</b>, then the
      include directive in the generated code would be:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>#include &quot;schemas/base.hxx&quot;</b>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--include-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      transform <b>#include</b> directive paths. <i>regex</i> is a Perl-like
      regular expression in the form
      <b>/</b><i>pattern</i><b>/</b><i>replacement</i> <b>/</b>. Any character
      can be used as a delimiter instead of <b>/</b>. Escaping of the delimiter
      character in <i>pattern</i> or <i>replacement</i> is not supported.
    <div style="height: 1.00em;">&#x00A0;</div>
    All the regular expressions are pushed into a stack with the last specified
      expression considered first. The first match that succeeds is used.
    <div style="height: 1.00em;">&#x00A0;</div>
    As an example, the following expression transforms paths in the form
      <b>schemas/foo/bar</b> to paths in the form <b>generated/foo/bar</b>:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>%schemas/(.+)%generated/$1%</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also the REGEX AND SHELL QUOTING section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--include-regex-trace</b></dt>
  <dd class="It-tag">Trace the process of applying regular expressions specified
      with the <b>--include-regex</b> option. Use this option to find out why
      your regular expressions don't do what you expected them to do.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--guard-prefix</b> <i>prefix</i></dt>
  <dd class="It-tag">Add <i>prefix</i> to generated header inclusion guards. The
      prefix is transformed to upper case and characters that are illegal in a
      preprocessor macro name are replaced with underscores. If this option is
      not specified then the directory part of the input schema file is used as
      a prefix.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hxx-suffix</b> <i>suffix</i></dt>
  <dd class="It-tag">Use the provided <i>suffix</i> instead of the default
      <b>.hxx</b> to construct the name of the header file. Note that this
      suffix is also used to construct names of header files corresponding to
      included/imported schemas.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ixx-suffix</b> <i>suffix</i></dt>
  <dd class="It-tag">Use the provided <i>suffix</i> instead of the default
      <b>.ixx</b> to construct the name of the inline file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cxx-suffix</b> <i>suffix</i></dt>
  <dd class="It-tag">Use the provided <i>suffix</i> instead of the default
      <b>.cxx</b> to construct the name of the source file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fwd-suffix</b> <i>suffix</i></dt>
  <dd class="It-tag">Use the provided <i>suffix</i> instead of the default
      <b>-fwd.hxx</b> to construct the name of the forward declaration file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hxx-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Use the provided expression to construct the name of the
      header file. <i>regex</i> is a Perl-like regular expression in the form
      <b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b>. Note that this
      expression is also used to construct names of header files corresponding
      to included/imported schemas. See also the REGEX AND SHELL QUOTING section
      below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ixx-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Use the provided expression to construct the name of the
      inline file. <i>regex</i> is a Perl-like regular expression in the form
      <b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b>. See also the
      REGEX AND SHELL QUOTING section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cxx-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Use the provided expression to construct the name of the
      source file. <i>regex</i> is a Perl-like regular expression in the form
      <b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b>. See also the
      REGEX AND SHELL QUOTING section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fwd-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Use the provided expression to construct the name of the
      forward declaration file. <i>regex</i> is a Perl-like regular expression
      in the form <b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b>. See
      also the REGEX AND SHELL QUOTING section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hxx-prologue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the beginning of the header file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ixx-prologue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the beginning of the inline file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cxx-prologue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the beginning of the source file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fwd-prologue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the beginning of the forward
      declaration file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--prologue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the beginning of each generated file
      for which there is no file-specific prologue.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hxx-epilogue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the end of the header file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ixx-epilogue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the end of the inline file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cxx-epilogue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the end of the source file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fwd-epilogue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the end of the forward declaration
      file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--epilogue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the end of each generated file for
      which there is no file-specific epilogue.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hxx-prologue-file</b> <i>file</i></dt>
  <dd class="It-tag">Insert the content of the <i>file</i> at the beginning of
      the header file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ixx-prologue-file</b> <i>file</i></dt>
  <dd class="It-tag">Insert the content of the <i>file</i> at the beginning of
      the inline file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cxx-prologue-file</b> <i>file</i></dt>
  <dd class="It-tag">Insert the content of the <i>file</i> at the beginning of
      the source file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fwd-prologue-file</b> <i>file</i></dt>
  <dd class="It-tag">Insert the content of the <i>file</i> at the beginning of
      the forward declaration file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--prologue-file</b> <i>file</i></dt>
  <dd class="It-tag">Insert the content of the <i>file</i> at the beginning of
      each generated file for which there is no file-specific prologue file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--hxx-epilogue-file</b> <i>file</i></dt>
  <dd class="It-tag">Insert the content of the <i>file</i> at the end of the
      header file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ixx-epilogue-file</b> <i>file</i></dt>
  <dd class="It-tag">Insert the content of the <i>file</i> at the end of the
      inline file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cxx-epilogue-file</b> <i>file</i></dt>
  <dd class="It-tag">Insert the content of the <i>file</i> at the end of the
      source file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fwd-epilogue-file</b> <i>file</i></dt>
  <dd class="It-tag">Insert the content of the <i>file</i> at the end of the
      forward declaration file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--epilogue-file</b> <i>file</i></dt>
  <dd class="It-tag">Insert the content of the <i>file</i> at the end of each
      generated file for which there is no file-specific epilogue file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--export-symbol</b> <i>symbol</i></dt>
  <dd class="It-tag">Insert <i>symbol</i> in places where DLL export/import
      control statements ( <b>__declspec(dllexport/dllimport)</b>) are
      necessary.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--export-xml-schema</b></dt>
  <dd class="It-tag">Export/import types in the XML Schema namespace using the
      export symbol provided with the <b>--export-symbol</b> option. The
      <b>XSD_NO_EXPORT</b> macro can be used to omit this code during C++
      compilation, which may be useful if you would like to use the same
      generated code across multiple platforms.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--export-maps</b></dt>
  <dd class="It-tag">Export polymorphism support maps from a Win32 DLL into
      which this generated code is placed. This is necessary when your type
      hierarchy is split across several DLLs since otherwise each DLL will have
      its own set of maps. In this situation the generated code for the DLL
      which contains base types and/or substitution group heads should be
      compiled with this option and the generated code for all other DLLs should
      be compiled with <b>--import-maps</b>. This option is only valid together
      with <b>--generate-polymorphic</b>. The <b>XSD_NO_EXPORT</b> macro can be
      used to omit this code during C++ compilation, which may be useful if you
      would like to use the same generated code across multiple platforms.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--import-maps</b></dt>
  <dd class="It-tag">Import polymorphism support maps to a Win32 DLL or
      executable into which this generated code is linked. See the
      <b>--export-maps</b> option documentation for details. This options is
      only valid together with <b>--generate-polymorphic</b>. The
      <b>XSD_NO_EXPORT</b> macro can be used to omit this code during C++
      compilation, which may be useful if you would like to use the same
      generated code across multiple platforms.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-dep</b></dt>
  <dd class="It-tag">Generate <b>make</b> dependency information. This option
      triggers the creation of the <b>.d</b> file containing the dependencies of
      the generated files on the main schema file as well as all the schema
      files that it includes/imports, transitively. This dependency file is then
      normally included into the main <b>makefile</b> to implement automatic
      dependency tracking.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note also that automatic dependency generation is not supported in the
      file-per-type mode ( <b>--file-per-type</b>). In this case, all the
      generated files are produced with a single compiler invocation and depend
      on all the schemas. As a result, it is easier to establish such a
      dependency manually, perhaps with the help of the <b>--file-list*</b>
      options.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-dep-only</b></dt>
  <dd class="It-tag">Generate <b>make</b> dependency information only.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dep-phony</b></dt>
  <dd class="It-tag">Generate phony targets for included/imported schema files,
      causing each to depend on nothing. Such dummy rules work around
      <b>make</b> errors caused by the removal of schema files without also
      updating the dependency file to match.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dep-target</b> <i>target</i></dt>
  <dd class="It-tag">Change the target of the dependency rule. By default it
      contains all the generated C++ files as well as the dependency file
      itself, without any directory prefixes. If you require multiple targets,
      then you can specify them as a single, space-separated argument or you can
      repeat this option multiple times.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dep-suffix</b> <i>suffix</i></dt>
  <dd class="It-tag">Use the provided <i>suffix</i> instead of the default
      <b>.d</b> to construct the name of the dependency file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dep-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Use the provided expression to construct the name of the
      dependency file. <i>regex</i> is a Perl-like regular expression in the
      form <b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b>. See also
      the REGEX AND SHELL QUOTING section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--disable-warning</b> <i>warn</i></dt>
  <dd class="It-tag">Disable printing warning with id <i>warn</i>. If <b>all</b>
      is specified for the warning id then all warnings are disabled.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--options-file</b> <i>file</i></dt>
  <dd class="It-tag">Read additional options from <i>file</i>. Each option
      should appearing on a separate line optionally followed by space and an
      option value. Empty lines and lines starting with <b>#</b> are ignored.
      Option values can be enclosed in double ( <b>&quot;</b>) or single
      (<b>'</b>) quotes to preserve leading and trailing whitespaces as well as
      to specify empty values. If the value itself contains trailing or leading
      quotes, enclose it with an extra pair of quotes, for example
      <b>'&quot;x&quot;'</b>. Non-leading and non-trailing quotes are
      interpreted as being part of the option value.
    <div style="height: 1.00em;">&#x00A0;</div>
    The semantics of providing options in a file is equivalent to providing the
      same set of options in the same order on the command line at the point
      where the <b>--options-file</b> option is specified except that the shell
      escaping and quoting is not required. You can repeat this option to
      specify more than one options file.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--show-sloc</b></dt>
  <dd class="It-tag">Show the number of generated physical source lines of code
      (SLOC).
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--sloc-limit</b> <i>num</i></dt>
  <dd class="It-tag">Check that the number of generated physical source lines of
      code (SLOC) does not exceed <i>num</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--proprietary-license</b></dt>
  <dd class="It-tag">Indicate that the generated code is licensed under a
      proprietary license instead of the GPL.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--custom-literals</b> <i>file</i></dt>
  <dd class="It-tag">Load custom XML string to C++ literal mappings from
      <i>file</i>. This mechanism can be useful if you are using a custom
      character encoding and some of the strings in your schemas, for example
      element/attribute names or enumeration values, contain non-ASCII
      characters. In this case you will need to provide a custom mapping to C++
      literals for such strings. The format of this file is specified in the
      <b>custom-literals.xsd</b> XML Schema file that can be found in the
      documentation directory.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--preserve-anonymous</b></dt>
  <dd class="It-tag">Preserve anonymous types. By default anonymous types are
      automatically named with names derived from the enclosing
      elements/attributes. Because mappings implemented by this compiler require
      all types to be named, this option is only useful if you want to make sure
      your schemas don't have anonymous types.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--show-anonymous</b></dt>
  <dd class="It-tag">Show elements and attributes that are of anonymous types.
      This option only makes sense together with the <b>--preserve-anonymous</b>
      option.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--anonymous-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      derive names for anonymous types from the enclosing attributes/elements.
      <i>regex</i> is a Perl-like regular expression in the form
      <b>/</b><i>pattern</i> <b>/</b><i>replacement</i><b>/</b>. Any character
      can be used as a delimiter instead of <b>/</b>. Escaping of the delimiter
      character in <i>pattern</i> or <i>replacement</i> is not supported.
    <div style="height: 1.00em;">&#x00A0;</div>
    All the regular expressions are pushed into a stack with the last specified
      expression considered first. The first match that succeeds is used.
      Regular expressions are applied to a string in the form
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>filename</i> <i>namespace</i> <i>xpath</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    For instance:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>hello.xsd http://example.com/hello element</b>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>hello.xsd http://example.com/hello type/element</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    As an example, the following expression makes all the derived names start
      with capital letters. This could be useful when your naming convention
      requires type names to start with capital letters:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>%.* .* (.+/)*(.+)%\u$2%</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also the REGEX AND SHELL QUOTING section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--anonymous-regex-trace</b></dt>
  <dd class="It-tag">Trace the process of applying regular expressions specified
      with the <b>--anonymous-regex</b> option. Use this option to find out why
      your regular expressions don't do what you expected them to do.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--location-map</b> <i>ol</i>=<i>nl</i></dt>
  <dd class="It-tag">Map the original schema location <i>ol</i> that is
      specified in the XML Schema include or import elements to new schema
      location <i>nl</i>. Repeat this option to map more than one schema
      location. For example, the following option maps the
      <b>http://example.com/foo.xsd</b> URL to the <b>foo.xsd</b> local file.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>--location-map http://example.com/foo.xsd=foo.xsd</b>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--location-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      map schema locations that are specified in the XML Schema include or
      import elements. <i>regex</i> is a Perl-like regular expression in the
      form <b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b>. Any
      character can be used as a delimiter instead of <b>/</b>. Escaping of the
      delimiter character in <i>pattern</i> or <i>replacement</i> is not
      supported. All the regular expressions are pushed into a stack with the
      last specified expression considered first. The first match that succeeds
      is used.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, the following expression maps URL locations in the form
      <b>http://example.com/foo/bar.xsd</b> to local files in the form
      <b>bar.xsd</b>:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>%http://.+/(.+)%$1%</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also the REGEX AND SHELL QUOTING section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--location-regex-trace</b></dt>
  <dd class="It-tag">Trace the process of applying regular expressions specified
      with the <b>--location-regex</b> option. Use this option to find out why
      your regular expressions don't do what you expected them to do.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--file-per-type</b></dt>
  <dd class="It-tag">Generate a separate set of C++ files for each type defined
      in XML Schema. Note that in this mode you only need to compile the root
      schema(s) and the code will be generated for all included and imported
      schemas. This compilation mode is primarily useful when some of your
      schemas cannot be compiled separately or have cyclic dependencies which
      involve type inheritance. Other options related to this mode are:
      <b>--type-file-regex</b>, <b>--schema-file-regex</b>,
      <b>--fat-type-file</b>, and <b>--file-list</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--type-file-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate type names to file names when the <b>--file-per-type</b> option
      is specified. <i>regex</i> is a Perl-like regular expression in the form
      <b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b>. Any character
      can be used as a delimiter instead of <b>/</b>. Escaping of the delimiter
      character in <i>pattern</i> or <i>replacement</i> is not supported. All
      the regular expressions are pushed into a stack with the last specified
      expression considered first. The first match that succeeds is used.
      Regular expressions are applied to a string in the form
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>namespace</i> <i>type-name</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, the following expression maps type <b>foo</b> that is defined
      in the <b>http://example.com/bar</b> namespace to file name
      <b>bar-foo</b>:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>%http://example.com/(.+) (.+)%$1-$2%</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also the REGEX AND SHELL QUOTING section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--type-file-regex-trace</b></dt>
  <dd class="It-tag">Trace the process of applying regular expressions specified
      with the <b>--type-file-regex</b> option. Use this option to find out why
      your regular expressions don't do what you expected them to do.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--schema-file-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate schema file names when the <b>--file-per-type</b> option is
      specified. <i>regex</i> is a Perl-like regular expression in the form
      <b>/</b> <i>pattern</i><b>/</b><i>replacement</i><b>/</b>. Any character
      can be used as a delimiter instead of <b>/</b>. Escaping of the delimiter
      character in <i>pattern</i> or <i>replacement</i> is not supported. All
      the regular expressions are pushed into a stack with the last specified
      expression considered first. The first match that succeeds is used.
      Regular Expressions are applied to the absolute filesystem path of a
      schema file and the result, including the directory part, if any, is used
      to derive the <b>#include</b> directive paths as well as the generated C++
      file paths. This option, along with <b>--type-file-regex</b> are primarily
      useful to place the generated files into subdirectories or to resolve file
      name conflicts.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, the following expression maps schema files in the
      <b>foo/1.0.0/</b> subdirectory to the files in the <b>foo/</b>
      subdirectory. As a result, the <b>#include</b> directive paths for such
      schemas will be in the <b>foo/schema.hxx</b> form and the generated C++
      files will be placed into the <b>foo/</b> subdirectory:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>%.*/foo/1.0.0/(.+)%foo/$1%</b>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also the REGEX AND SHELL QUOTING section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--schema-file-regex-trace</b></dt>
  <dd class="It-tag">Trace the process of applying regular expressions specified
      with the <b>--schema-file-regex</b> option. Use this option to find out
      why your regular expressions don't do what you expected them to do.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fat-type-file</b></dt>
  <dd class="It-tag">Generate code corresponding to global elements into type
      files instead of schema files when the <b>--type-file-regex</b> option is
      specified. This option is primarily useful when trying to minimize the
      amount of object code that is linked to an executable by packaging
      compiled generated code into a static (archive) library.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--file-list</b> <i>file</i></dt>
  <dd class="It-tag">Write a list of generated C++ files to <i>file</i>. This
      option is primarily useful in the file-per-type compilation mode (
      <b>--file-per-type</b>) to create a list of generated C++ files, for
      example, as a makefile fragment.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--file-list-prologue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the beginning of the file list. As a
      convenience, all occurrences of the <b>\n</b> character sequence in
      <i>text</i> are replaced with new lines. This option can, for example, be
      used to assign the generated file list to a makefile variable.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--file-list-epilogue</b> <i>text</i></dt>
  <dd class="It-tag">Insert <i>text</i> at the end of the file list. As a
      convenience, all occurrences of the <b>\n</b> character sequence in
      <i>text</i> are replaced with new lines.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--file-list-delim</b> <i>text</i></dt>
  <dd class="It-tag">Delimit file names written to the file list with
      <i>text</i> instead of new lines. As a convenience, all occurrences of the
      <b>\n</b> character sequence in <i>text</i> are replaced with new lines.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="cxx-tree_command_options"><a class="selflink" href="#cxx-tree_command_options">cxx-tree
  command options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-polymorphic</b></dt>
  <dd class="It-tag">Generate polymorphism-aware code. Specify this option if
      you use substitution groups or <b>xsi:type</b>. Use the
      <b>--polymorphic-type</b> or <b>--polymorphic-type-all</b> option to
      specify which type hierarchies are polymorphic.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--polymorphic-type</b> <i>type</i></dt>
  <dd class="It-tag">Indicate that <i>type</i> is a root of a polymorphic type
      hierarchy. The compiler can often automatically determine which types are
      polymorphic based on the substitution group declarations. However, you may
      need to use this option if you are not using substitution groups or if
      substitution groups are defined in another schema. You need to specify
      this option when compiling every schema file that references <i>type</i>.
      The <i>type</i> argument is an XML Schema type name that can be optionally
      qualified with a namespace in the <i>namespace</i><b>#</b><i>name</i>
      form.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--polymorphic-type-all</b></dt>
  <dd class="It-tag">Indicate that all types should be treated as polymorphic.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--polymorphic-plate</b> <i>num</i></dt>
  <dd class="It-tag">Specify the polymorphic map plate the generated code should
      register on. This functionality is primarily useful to segregate multiple
      schemas that define the same polymorphic types.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ordered-type</b> <i>type</i></dt>
  <dd class="It-tag">Indicate that element order in <i>type</i> is significant.
      An example would be a complex type with unbounded choice as a content
      model where the element order in XML has application-specific semantics.
      For ordered types the compiler generates a special container data member
      and a corresponding set of accessors and modifiers that are used to
      capture the order of elements and, for mixed content, of text.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>type</i> argument is an XML Schema type name that can be optionally
      qualified with a namespace in the <i>namespace</i><b>#</b><i>name</i>
      form. Note also that you will need to specify this option when compiling
      every schema file that has other ordered types derived from this type.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ordered-type-derived</b></dt>
  <dd class="It-tag">Automatically treat types derived from ordered bases as
      also ordered. This is primarily useful if you would like to be able to
      iterate over the complete content using the content order container.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ordered-type-mixed</b></dt>
  <dd class="It-tag">Automatically treat complex types with mixed content as
      ordered.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ordered-type-all</b></dt>
  <dd class="It-tag">Indicate that element order in all types is significant.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--order-container</b> <i>type</i></dt>
  <dd class="It-tag">Specify a custom class template that should be used as a
      container for the content order in ordered types instead of the default
      <b>std::vector</b>. See <b>--ordered-type</b> for more information on
      ordered type. This option is primarily useful if you need to perform more
      complex lookups in the content order container, for example by element id.
      In this case, a container like Boost multi-index may be more convenient.
      Note that if using a custom container, you will also most likely need to
      include the relevant headers using the <b>--hxx-prologue*</b> options.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-serialization</b></dt>
  <dd class="It-tag">Generate serialization functions. Serialization functions
      convert the object model back to XML.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-ostream</b></dt>
  <dd class="It-tag">Generate ostream insertion operators
      (<b>operator&lt;&lt;</b>) for generated types. This allows one to easily
      print a fragment or the whole object model for debugging or logging.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-doxygen</b></dt>
  <dd class="It-tag">Generate documentation comments suitable for extraction by
      the Doxygen documentation system. Documentation from annotations is added
      to the comments if present in the schema.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-comparison</b></dt>
  <dd class="It-tag">Generate comparison operators (<b>operator==</b> and
      <b>operator!=</b>) for complex types. Comparison is performed member-wise.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-default-ctor</b></dt>
  <dd class="It-tag">Generate default constructors even for types that have
      required members. Required members of an instance constructed using such a
      constructor are not initialized and accessing them results in undefined
      behavior.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-from-base-ctor</b></dt>
  <dd class="It-tag">Generate constructors that expect an instance of a base
      type followed by all required members.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--suppress-assignment</b></dt>
  <dd class="It-tag">Suppress the generation of copy assignment operators for
      complex types. If this option is specified, the copy assignment operators
      for such types are declared private and left unimplemented.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-detach</b></dt>
  <dd class="It-tag">Generate detach functions for required elements and
      attributes. Detach functions for optional and sequence cardinalities are
      provided by the respective containers. These functions, for example, allow
      you to move sub-trees in the object model either within the same tree or
      between different trees.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-wildcard</b></dt>
  <dd class="It-tag">Generate accessors and modifiers as well as parsing and
      serialization code for XML Schema wildcards ( <b>any</b> and
      <b>anyAttribute</b>). XML content matched by wildcards is presented as DOM
      fragments. Note that you need to initialize the Xerces-C++ runtime if you
      are using this option.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-any-type</b></dt>
  <dd class="It-tag">Extract and store content of the XML Schema <b>anyType</b>
      type as a DOM fragment. Note that you need to initialize the Xerces-C++
      runtime if you are using this option.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-insertion</b> <i>os</i></dt>
  <dd class="It-tag">Generate data representation stream insertion operators for
      the <i>os</i> output stream type. Repeat this option to specify more than
      one stream type. The ACE CDR stream ( <b>ACE_OutputCDR</b>) and RPC XDR
      are recognized by the compiler and the necessary <b>#include</b>
      directives are automatically generated. For custom stream types use the
      <b>--hxx-prologue*</b> options to provide the necessary declarations.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-extraction</b> <i>is</i></dt>
  <dd class="It-tag">Generate data representation stream extraction constructors
      for the <i>is</i> input stream type. Repeat this option to specify more
      than one stream type. The ACE CDR stream ( <b>ACE_InputCDR</b>) and RPC
      XDR are recognized by the compiler and the necessary <b>#include</b>
      directives are automatically generated. For custom stream types use the
      <b>--hxx-prologue*</b> options to provide the necessary declarations.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-forward</b></dt>
  <dd class="It-tag">Generate a separate header file with forward declarations
      for the types being generated.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--suppress-parsing</b></dt>
  <dd class="It-tag">Suppress the generation of the parsing functions and
      constructors. Use this option to reduce the generated code size when
      parsing from XML is not needed.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-element-type</b></dt>
  <dd class="It-tag">Generate types instead of parsing and serialization
      functions for root elements. This is primarily useful to distinguish
      object models with the same root type but with different root elements.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-element-map</b></dt>
  <dd class="It-tag">Generate a root element map that allows uniform parsing and
      serialization of multiple root elements. This option is only valid
      together with <b>--generate-element-type</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-intellisense</b></dt>
  <dd class="It-tag">Generate workarounds for IntelliSense bugs in Visual Studio
      2005 (8.0). When this option is used, the resulting code is slightly more
      verbose. IntelliSense in Visual Studio 2008 (9.0) and later does not
      require these workarounds. Support for IntelliSense in Visual Studio 2003
      (7.1) is improved with this option but is still incomplete.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--omit-default-attributes</b></dt>
  <dd class="It-tag">Omit attributes with default and fixed values from
      serialized XML documents.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--type-naming</b> <i>style</i></dt>
  <dd class="It-tag">Specify the type naming convention that should be used in
      the generated code. Valid styles are <b>knr</b> (default), <b>ucc</b>, and
      <b>java</b>. See the NAMING CONVENTION section below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--function-naming</b> <i>style</i></dt>
  <dd class="It-tag">Specify the function naming convention that should be used
      in the generated code. Valid styles are <b>knr</b> (default), <b>lcc</b>,
      and <b>java</b>. See the NAMING CONVENTION section below for more
      information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--type-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema type names to C++ type names. See the NAMING
      CONVENTION section below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--accessor-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema names of elements/attributes to C++ accessor function
      names. See the NAMING CONVENTION section below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--one-accessor-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema names of elements/attributes with cardinality one to
      C++ accessor function names. See the NAMING CONVENTION section below for
      more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--opt-accessor-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema names of elements/attributes with cardinality
      optional to C++ accessor function names. See the NAMING CONVENTION section
      below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seq-accessor-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema names of elements/attributes with cardinality
      sequence to C++ accessor function names. See the NAMING CONVENTION section
      below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--modifier-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema names of elements/attributes to C++ modifier function
      names. See the NAMING CONVENTION section below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--one-modifier-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema names of elements/attributes with cardinality one to
      C++ modifier function names. See the NAMING CONVENTION section below for
      more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--opt-modifier-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema names of elements/attributes with cardinality
      optional to C++ modifier function names. See the NAMING CONVENTION section
      below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--seq-modifier-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema names of elements/attributes with cardinality
      sequence to C++ modifier function names. See the NAMING CONVENTION section
      below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--parser-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema element names to C++ parsing function names. See the
      NAMING CONVENTION section below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--serializer-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema element names to C++ serialization function names.
      See the NAMING CONVENTION section below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--const-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema-derived names to C++ constant names. See the NAMING
      CONVENTION section below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--enumerator-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema enumeration values to C++ enumerator names. See the
      NAMING CONVENTION section below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--element-type-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Add <i>regex</i> to the list of regular expressions used to
      translate XML Schema element names to C++ element type names. See the
      NAMING CONVENTION section below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--name-regex-trace</b></dt>
  <dd class="It-tag">Trace the process of applying regular expressions specified
      with the name transformation options. Use this option to find out why your
      regular expressions don't do what you expected them to do.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root-element-first</b></dt>
  <dd class="It-tag">Treat only the first global element as a document root. By
      default all global elements are considered document roots.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root-element-last</b></dt>
  <dd class="It-tag">Treat only the last global element as a document root. By
      default all global elements are considered document roots.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root-element-all</b></dt>
  <dd class="It-tag">Treat all global elements as document roots. This is the
      default behavior. By explicitly specifying this option you can suppress
      the warning that is issued if more than one global element is defined.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root-element-none</b></dt>
  <dd class="It-tag">Do not treat any global elements as document roots. By
      default all global elements are considered document roots.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root-element</b> <i>element</i></dt>
  <dd class="It-tag">Treat only <i>element</i> as a document root. Repeat this
      option to specify more than one root element.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--custom-type</b> <i>map</i></dt>
  <dd class="It-tag">Use a custom C++ type instead of the generated class. The
      <i>map</i> argument is in the form
      <i>name</i>[<b>=</b><i>type</i>[<b>/</b> <i>base</i>]], where <i>name</i>
      is a type name as defined in XML Schema and <i>type</i> is a C++ type name
      that should be used instead. If <i>type</i> is not present or empty then
      the custom type is assumed to have the same name and be defined in the
      same namespace as the generated class would have. If <i>base</i> is
      specified then the generated class is still generated but with that name.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--custom-type-regex</b> <i>regex</i></dt>
  <dd class="It-tag">Use custom C++ types instead of the generated classes. The
      <i>regex</i> argument is in the form
      <b>/</b><i>name-pat</i><b>/</b>[<i>type-sub</i>
      <b>/</b>[<i>base-sub</i><b>/</b>]], where <i>name-pat</i> is a regex
      pattern that will be matched against type names as defined in XML Schema
      and <i>type-sub</i> is a C++ type name substitution that should be used
      instead. If <i>type-sub</i> is not present or its substitution results in
      an empty string then the custom type is assumed to have the same name and
      be defined in the same namespace as the generated class would have. If
      <i>base-sub</i> is present and its substitution results in a non-empty
      string then the generated class is still generated but with the result of
      this substitution as its name. The pattern and substitutions are in the
      Perl regular expression format. See also the REGEX AND SHELL QUOTING
      section below.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--parts</b> <i>num</i></dt>
  <dd class="It-tag">Split generated source code into <i>num</i> parts. This is
      useful when translating large, monolithic schemas and a C++ compiler is
      not able to compile the resulting source code at once (usually due to
      insufficient memory).
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--parts-suffix</b> <i>suffix</i></dt>
  <dd class="It-tag">Use <i>suffix</i> instead of the default '<b>-</b>' to
      separate the file name from the part number.
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="cxx-parser_command_options"><a class="selflink" href="#cxx-parser_command_options">cxx-parser
  command options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--type-map</b> <i>mapfile</i></dt>
  <dd class="It-tag">Read XML Schema to C++ type mapping information from
      <i>mapfile</i>. Repeat this option to specify several type maps. Type maps
      are considered in order of appearance and the first match is used. By
      default all user-defined types are mapped to <b>void</b>. See the TYPE MAP
      section below for more information.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--xml-parser</b> <i>parser</i></dt>
  <dd class="It-tag">Use <i>parser</i> as the underlying XML parser. Valid
      values are <b>xerces</b> for Xerces-C++ (default) and <b>expat</b> for
      Expat.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-validation</b></dt>
  <dd class="It-tag">Generate validation code. The validation code
      (&quot;perfect parser&quot;) ensures that instance documents conform to
      the schema. Validation code is generated by default when the selected
      underlying XML parser is non-validating ( <b>expat</b>).
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--suppress-validation</b></dt>
  <dd class="It-tag">Suppress the generation of validation code. Validation is
      suppressed by default when the selected underlying XML parser is
      validating ( <b>xerces</b>).
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-polymorphic</b></dt>
  <dd class="It-tag">Generate polymorphism-aware code. Specify this option if
      you use substitution groups or <b>xsi:type</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-noop-impl</b></dt>
  <dd class="It-tag">Generate a sample parser implementation that does nothing
      (no operation). The sample implementation can then be filled with the
      application-specific code. For an input file in the form <b>name.xsd</b>
      this option triggers the generation of two additional C++ files in the
      form: <b>name-pimpl.hxx</b> (parser implementation header file) and
      <b>name-pimpl.cxx</b> (parser implementation source file).
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-print-impl</b></dt>
  <dd class="It-tag">Generate a sample parser implementation that prints the XML
      data to STDOUT. For an input file in the form <b>name.xsd</b> this option
      triggers the generation of two additional C++ files in the form:
      <b>name-pimpl.hxx</b> (parser implementation header file) and
      <b>name-pimpl.cxx</b> (parser implementation source file).
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generate-test-driver</b></dt>
  <dd class="It-tag">Generate a test driver for the sample parser
      implementation. For an input file in the form <b>name.xsd</b> this option
      triggers the generation of an additional C++ file in the form
      <b>name-driver.cxx</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--force-overwrite</b></dt>
  <dd class="It-tag">Force overwriting of the existing implementation and test
      driver files. Use this option only if you do not mind loosing the changes
      you have made in the sample implementation or test driver files.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root-element-first</b></dt>
  <dd class="It-tag">Indicate that the first global element is the document
      root. This information is used to generate the test driver for the sample
      implementation.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root-element-last</b></dt>
  <dd class="It-tag">Indicate that the last global element is the document root.
      This information is used to generate the test driver for the sample
      implementation.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root-element</b> <i>element</i></dt>
  <dd class="It-tag">Indicate that <i>element</i> is the document root. This
      information is used to generate the test driver for the sample
      implementation.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--skel-type-suffix</b> <i>suffix</i></dt>
  <dd class="It-tag">Use the provided <i>suffix</i> instead of the default
      <b>_pskel</b> to construct the names of the generated parser skeletons.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--skel-file-suffix</b> <i>suffix</i></dt>
  <dd class="It-tag">Use the provided <i>suffix</i> instead of the default
      <b>-pskel</b> to construct the names of the generated parser skeleton
      files.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--impl-type-suffix</b> <i>suffix</i></dt>
  <dd class="It-tag">Use the provided <i>suffix</i> instead of the default
      <b>_pimpl</b> to construct the names of the parser implementations for the
      built-in XML Schema types as well as sample parser implementations.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--impl-file-suffix</b> <i>suffix</i></dt>
  <dd class="It-tag">Use the provided <i>suffix</i> instead of the default
      <b>-pimpl</b> to construct the names of the generated sample parser
      implementation files.
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="NAMING_CONVENTION"><a class="selflink" href="#NAMING_CONVENTION">NAMING
  CONVENTION</a></h1>
The compiler can be instructed to use a particular naming convention in the
  generated code. A number of widely-used conventions can be selected using the
  <b>--type-naming</b> and <b>--function-naming</b> options. A custom naming
  convention can be achieved using the <b>--type-regex</b>,
  <b>--accessor-regex</b>, <b>--one-accessor-regex</b>,
  <b>--opt-accessor-regex</b>, <b>--seq-accessor-regex</b>,
  <b>--modifier-regex</b>, <b>--one-modifier-regex</b>,
  <b>--opt-modifier-regex</b>, <b>--seq-modifier-regex</b>,
  <b>--parser-regex</b>, <b>--serializer-regex</b>, <b>--const-regex</b>,
  <b>--enumerator-regex</b>, and <b>--element-type-regex</b> options.
<div style="height: 1.00em;">&#x00A0;</div>
The <b>--type-naming</b> option specifies the convention that should be used for
  naming C++ types. Possible values for this option are <b>knr</b> (default),
  <b>ucc</b>, and <b>java</b>. The <b>knr</b> value (stands for K&amp;R)
  signifies the standard, lower-case naming convention with the underscore used
  as a word delimiter, for example: foo, foo_bar. The <b>ucc</b> (stands for
  upper-camel-case) and <b>java</b> values a synonyms for the same naming
  convention where the first letter of each word in the name is capitalized, for
  example: Foo, FooBar.
<div style="height: 1.00em;">&#x00A0;</div>
Similarly, the <b>--function-naming</b> option specifies the convention that
  should be used for naming C++ functions. Possible values for this option are
  <b>knr</b> (default), <b>lcc</b>, and <b>java</b>. The <b>knr</b> value
  (stands for K&amp;R) signifies the standard, lower-case naming convention with
  the underscore used as a word delimiter, for example: foo(), foo_bar(). The
  <b>lcc</b> value (stands for lower-camel-case) signifies a naming convention
  where the first letter of each word except the first is capitalized, for
  example: foo(), fooBar(). The <b>java</b> naming convention is similar to the
  lower-camel-case one except that accessor functions are prefixed with get,
  modifier functions are prefixed with set, parsing functions are prefixed with
  parse, and serialization functions are prefixed with serialize, for example:
  getFoo(), setFooBar(), parseRoot(), serializeRoot().
<div style="height: 1.00em;">&#x00A0;</div>
Note that the naming conventions specified with the <b>--type-naming</b> and
  <b>--function-naming</b> options perform only limited transformations on the
  names that come from the schema in the form of type, attribute, and element
  names. In other words, to get consistent results, your schemas should follow a
  similar naming convention as the one you would like to have in the generated
  code. Alternatively, you can use the <b>--*-regex</b> options (discussed
  below) to perform further transformations on the names that come from the
  schema.
<div style="height: 1.00em;">&#x00A0;</div>
The <b>--type-regex</b>, <b>--accessor-regex</b>, <b>--one-accessor-regex</b>,
  <b>--opt-accessor-regex</b>, <b>--seq-accessor-regex</b>,
  <b>--modifier-regex</b>, <b>--one-modifier-regex</b>,
  <b>--opt-modifier-regex</b>, <b>--seq-modifier-regex</b>,
  <b>--parser-regex</b>, <b>--serializer-regex</b>, <b>--const-regex</b>,
  <b>--enumerator-regex</b>, and <b>--element-type-regex</b> options allow you
  to specify extra regular expressions for each name category in addition to the
  predefined set that is added depending on the <b>--type-naming</b> and
  <b>--function-naming</b> options. Expressions that are provided with the
  <b>--*-regex</b> options are evaluated prior to any predefined expressions.
  This allows you to selectively override some or all of the predefined
  transformations. When debugging your own expressions, it is often useful to
  see which expressions match which names. The <b>--name-regex-trace</b> option
  allows you to trace the process of applying regular expressions to names.
<div style="height: 1.00em;">&#x00A0;</div>
The value for the <b>--*-regex</b> options should be a perl-like regular
  expression in the form
  <b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/.</b> Any character can be
  used as a delimiter instead of <b>/</b>. Escaping of the delimiter character
  in <i>pattern</i> or <i>replacement</i> is not supported. All the regular
  expressions for each category are pushed into a category-specific stack with
  the last specified expression considered first. The first match that succeeds
  is used. For the <b>--one-accessor-regex</b> (accessors with cardinality one),
  <b>--opt-accessor-regex</b> (accessors with cardinality optional), and
  <b>--seq-accessor-regex</b> (accessors with cardinality sequence) categories
  the <b>--accessor-regex</b> expressions are used as a fallback. For the
  <b>--one-modifier-regex</b>, <b>--opt-modifier-regex</b>, and
  <b>--seq-modifier-regex</b> categories the <b>--modifier-regex</b> expressions
  are used as a fallback. For the <b>--element-type-regex</b> category the
  <b>--type-regex</b> expressions are used as a fallback.
<div style="height: 1.00em;">&#x00A0;</div>
The type name expressions (<b>--type-regex</b>) are evaluated on the name string
  that has the following format:
<div style="height: 1.00em;">&#x00A0;</div>
[ <i>namespace
  </i>]<i>name</i>[<b>,</b><i>name</i>][<b>,</b><i>name</i>][<b>,</b>
  <i>name</i>]
<div style="height: 1.00em;">&#x00A0;</div>
The element type name expressions (<b>--element-type-regex</b>), effective only
  when the <b>--generate-element-type</b> option is specified, are evaluated on
  the name string that has the following format:
<div style="height: 1.00em;">&#x00A0;</div>
<i>namespace name</i>
<div style="height: 1.00em;">&#x00A0;</div>
In the type name format the <i>namespace</i> part followed by a space is only
  present for global type names. For global types and elements defined in
  schemas without a target namespace, the <i>namespace</i> part is empty but the
  space is still present. In the type name format after the initial <i>name</i>
  component, up to three additional <i>name</i> components can be present,
  separated by commas. For example:
<div style="height: 1.00em;">&#x00A0;</div>
<b>http://example.com/hello type</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>foo</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>foo,iterator</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>foo,const,iterator</b>
<div style="height: 1.00em;">&#x00A0;</div>
The following set of predefined regular expressions is used to transform type
  names when the upper-camel-case naming convention is selected:
<div style="height: 1.00em;">&#x00A0;</div>
<b>/(?:[^ ]* )?([^,]+)/\u$1/</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>/(?:[^ ]* )?([^,]+),([^,]+)/\u$1\u$2/</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>/(?:[^ ]* )?([^,]+),([^,]+),([^,]+)/\u$1\u$2\u$3/</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>/(?:[^ ]* )?([^,]+),([^,]+),([^,]+),([^,]+)/\u$1\u$2\u$3\u$4/</b>
<div style="height: 1.00em;">&#x00A0;</div>
The accessor and modifier expressions (<b>--*accessor-regex</b> and
  <b>--*modifier-regex</b>) are evaluated on the name string that has the
  following format:
<div style="height: 1.00em;">&#x00A0;</div>
<i>name</i>[<b>,</b><i>name</i>][<b>,</b><i>name</i>]
<div style="height: 1.00em;">&#x00A0;</div>
After the initial <i>name</i> component, up to two additional <i>name</i>
  components can be present, separated by commas. For example:
<div style="height: 1.00em;">&#x00A0;</div>
<b>foo</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>dom,document</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>foo,default,value</b>
<div style="height: 1.00em;">&#x00A0;</div>
The following set of predefined regular expressions is used to transform
  accessor names when the <b>java</b> naming convention is selected:
<div style="height: 1.00em;">&#x00A0;</div>
<b>/([^,]+)/get\u$1/</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>/([^,]+),([^,]+)/get\u$1\u$2/</b>
<div style="height: 1.00em;">&#x00A0;</div>
<b>/([^,]+),([^,]+),([^,]+)/get\u$1\u$2\u$3/</b>
<div style="height: 1.00em;">&#x00A0;</div>
For the parser, serializer, and enumerator categories, the corresponding regular
  expressions are evaluated on local names of elements and on enumeration
  values, respectively. For example, the following predefined regular expression
  is used to transform parsing function names when the <b>java</b> naming
  convention is selected:
<div style="height: 1.00em;">&#x00A0;</div>
<b>/(.+)/parse\u$1/</b>
<div style="height: 1.00em;">&#x00A0;</div>
The const category is used to create C++ constant names for the
  element/wildcard/text content ids in ordered types.
<div style="height: 1.00em;">&#x00A0;</div>
See also the REGEX AND SHELL QUOTING section below.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="TYPE_MAP"><a class="selflink" href="#TYPE_MAP">TYPE
  MAP</a></h1>
Type map files are used in C++/Parser to define a mapping between XML Schema and
  C++ types. The compiler uses this information to determine the return types of
  <b>post_*</b> functions in parser skeletons corresponding to XML Schema types
  as well as argument types for callbacks corresponding to elements and
  attributes of these types.
<div style="height: 1.00em;">&#x00A0;</div>
The compiler has a set of predefined mapping rules that map built-in XML Schema
  types to suitable C++ types (discussed below) and all other types to
  <b>void</b>. By providing your own type maps you can override these predefined
  rules. The format of the type map file is presented below:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;"><b>namespace</b> <i>schema-namespace</i> [
  <i>cxx-namespace</i> ]
<div>&#x00A0;</div>
<b>{</b>
<div>&#x00A0;</div>
<br/>
 ( <b>include</b> <i>file-name</i><b>;</b> )*
<div>&#x00A0;</div>
<br/>
 ([ <b>type</b> ] <i>schema-type cxx-ret-type</i> [ <i>cxx-arg-type</i>
  ]<b>;</b> )*
<div>&#x00A0;</div>
<b>}</b>
<div>&#x00A0;</div>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
Both <i>schema-namespace</i> and <i>schema-type</i> are regex patterns while
  <i>cxx-namespace</i>, <i>cxx-ret-type</i>, and <i>cxx-arg-type</i> are regex
  pattern substitutions. All names can be optionally enclosed in &quot; &quot;,
  for example, to include white-spaces.
<div style="height: 1.00em;">&#x00A0;</div>
<i>schema-namespace</i> determines XML Schema namespace. Optional
  <i>cxx-namespace</i> is prefixed to every C++ type name in this namespace
  declaration. <i>cxx-ret-type</i> is a C++ type name that is used as a return
  type for the <b>post_*</b> functions. Optional <i>cxx-arg-type</i> is an
  argument type for callback functions corresponding to elements and attributes
  of this type. If <i>cxx-arg-type</i> is not specified, it defaults to
  <i>cxx-ret-type</i> if <i>cxx-ret-type</i> ends with <b>*</b> or <b>&amp;</b>
  (that is, it is a pointer or a reference) and <b>const</b>
  <i>cxx-ret-type</i><b>&amp;</b> otherwise. <i>file-name</i> is a file name
  either in the &quot; &quot; or &lt; &gt; format and is added with the
  <b>#include</b> directive to the generated code.
<div style="height: 1.00em;">&#x00A0;</div>
The <b>#</b> character starts a comment that ends with a new line or end of
  file. To specify a name that contains <b>#</b> enclose it in &quot; &quot;.
  For example:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">namespace http://www.example.com/xmlns/my my
<div>&#x00A0;</div>
{
<div>&#x00A0;</div>
<br/>
 include &quot;my.hxx&quot;;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 # Pass apples by value.
<br/>
 #
<br/>
 apple apple;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 # Pass oranges as pointers.
<br/>
 #
<br/>
 orange orange_t*;
<div>&#x00A0;</div>
}
<div>&#x00A0;</div>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
In the example above, for the <b>http://www.example.com/xmlns/my#orange</b> XML
  Schema type, the <b>my::orange_t*</b> C++ type will be used as both return and
  argument types.
<div style="height: 1.00em;">&#x00A0;</div>
Several namespace declarations can be specified in a single file. The namespace
  declaration can also be completely omitted to map types in a schema without a
  namespace. For instance:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">include &quot;my.hxx&quot;;
<div>&#x00A0;</div>
apple apple;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
namespace http://www.example.com/xmlns/my
<div>&#x00A0;</div>
{
<div>&#x00A0;</div>
<br/>
 orange &quot;const orange_t*&quot;;
<div>&#x00A0;</div>
}
<div>&#x00A0;</div>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
The compiler has a number of predefined mapping rules that can be presented as
  the following map files. The string-based XML Schema built-in types are mapped
  to either <b>std::string</b> or <b>std::wstring</b> depending on the character
  type selected with the <b>--char-type</b> option (<b>char</b> by default).
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">namespace http://www.w3.org/2001/XMLSchema
<div>&#x00A0;</div>
{
<div>&#x00A0;</div>
<br/>
 boolean bool bool;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 byte &quot;signed char&quot; &quot;signed char&quot;;
<div>&#x00A0;</div>
<br/>
 unsignedByte &quot;unsigned char&quot; &quot;unsigned char&quot;;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 short short short;
<div>&#x00A0;</div>
<br/>
 unsignedShort &quot;unsigned short&quot; &quot;unsigned short&quot;;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 int int int;
<div>&#x00A0;</div>
<br/>
 unsignedInt &quot;unsigned int&quot; &quot;unsigned int&quot;;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 long &quot;long long&quot; &quot;long long&quot;;
<div>&#x00A0;</div>
<br/>
 unsignedLong &quot;unsigned long long&quot; &quot;unsigned long long&quot;;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 integer &quot;long long&quot; &quot;long long&quot;;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 negativeInteger &quot;long long&quot; &quot;long long&quot;;
<div>&#x00A0;</div>
<br/>
 nonPositiveInteger &quot;long long&quot; &quot;long long&quot;;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 positiveInteger &quot;unsigned long long&quot; &quot;unsigned long long&quot;;
<div>&#x00A0;</div>
<br/>
 nonNegativeInteger &quot;unsigned long long&quot; &quot;unsigned long
  long&quot;;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 float float float;
<div>&#x00A0;</div>
<br/>
 double double double;
<div>&#x00A0;</div>
<br/>
 decimal double double;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 string std::string;
<div>&#x00A0;</div>
<br/>
 normalizedString std::string;
<div>&#x00A0;</div>
<br/>
 token std::string;
<div>&#x00A0;</div>
<br/>
 Name std::string;
<div>&#x00A0;</div>
<br/>
 NMTOKEN std::string;
<div>&#x00A0;</div>
<br/>
 NCName std::string;
<div>&#x00A0;</div>
<br/>
 ID std::string;
<div>&#x00A0;</div>
<br/>
 IDREF std::string;
<div>&#x00A0;</div>
<br/>
 language std::string;
<div>&#x00A0;</div>
<br/>
 anyURI std::string;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 NMTOKENS xml_schema::string_sequence;
<div>&#x00A0;</div>
<br/>
 IDREFS xml_schema::string_sequence;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 QName xml_schema::qname;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 base64Binary std::auto_ptr&lt;xml_schema::buffer&gt;
<div>&#x00A0;</div>
<br/>
 std::auto_ptr&lt;xml_schema::buffer&gt;;
<div>&#x00A0;</div>
<br/>
 hexBinary std::auto_ptr&lt;xml_schema::buffer&gt;
<div>&#x00A0;</div>
<br/>
 std::auto_ptr&lt;xml_schema::buffer&gt;;
<div>&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 date xml_schema::date;
<div>&#x00A0;</div>
<br/>
 dateTime xml_schema::date_time;
<div>&#x00A0;</div>
<br/>
 duration xml_schema::duration;
<div>&#x00A0;</div>
<br/>
 gDay xml_schema::gday;
<div>&#x00A0;</div>
<br/>
 gMonth xml_schema::gmonth;
<div>&#x00A0;</div>
<br/>
 gMonthDay xml_schema::gmonth_day;
<div>&#x00A0;</div>
<br/>
 gYear xml_schema::gyear;
<div>&#x00A0;</div>
<br/>
 gYearMonth xml_schema::gyear_month;
<div>&#x00A0;</div>
<br/>
 time xml_schema::time;
<div>&#x00A0;</div>
}
<div>&#x00A0;</div>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
The last predefined rule maps anything that wasn't mapped by previous rules to
  <b>void</b>:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">namespace .*
<div>&#x00A0;</div>
{
<div>&#x00A0;</div>
<br/>
 .* void void;
<div>&#x00A0;</div>
}
<div>&#x00A0;</div>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
When you provide your own type maps with the <b>--type-map</b> option, they are
  evaluated first. This allows you to selectively override predefined rules.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="REGEX_AND_SHELL_QUOTING"><a class="selflink" href="#REGEX_AND_SHELL_QUOTING">REGEX
  AND SHELL QUOTING</a></h1>
When entering a regular expression argument in the shell command line it is
  often necessary to use quoting (enclosing the argument in &quot; &quot; or '
  ') in order to prevent the shell from interpreting certain characters, for
  example, spaces as argument separators and $ as variable expansions.
<div style="height: 1.00em;">&#x00A0;</div>
Unfortunately it is hard to achieve this in a manner that is portable across
  POSIX shells, such as those found on GNU/Linux and UNIX, and Windows shell.
  For example, if you use &quot; &quot; for quoting you will get a wrong result
  with POSIX shells if your expression contains $. The standard way of dealing
  with this on POSIX systems is to use ' ' instead. Unfortunately, Windows shell
  does not remove ' ' from arguments when they are passed to applications. As a
  result you may have to use ' ' for POSIX and &quot; &quot; for Windows ($ is
  not treated as a special character on Windows).
<div style="height: 1.00em;">&#x00A0;</div>
Alternatively, you can save regular expression options into a file, one option
  per line, and use this file with the <b>--options-file</b> option. With this
  approach you don't need to worry about shell quoting.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DIAGNOSTICS"><a class="selflink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
If the input file is not a valid W3C XML Schema definition, <b>xsdcxx</b> will
  issue diagnostic messages to <b>STDERR</b> and exit with non-zero exit code.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
Send bug reports to the xsd-users@codesynthesis.com mailing list.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2005-2014 Code Synthesis Tools CC.
<div style="height: 1.00em;">&#x00A0;</div>
Permission is granted to copy, distribute and/or modify this document under the
  terms of the GNU Free Documentation License, version 1.2; with no Invariant
  Sections, no Front-Cover Texts and no Back-Cover Texts. Copy of the license
  can be obtained from http://codesynthesis.com/licenses/fdl-1.2.txt</div>
<table class="foot">
  <tr>
    <td class="foot-date">July 2014</td>
    <td class="foot-os">XSDCXX 4.0.0</td>
  </tr>
</table>
</body>
</html>
