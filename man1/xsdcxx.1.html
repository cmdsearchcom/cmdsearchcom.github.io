<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:44:28 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>XSDCXX(1) General Commands Manual XSDCXX(1)</p>

<p style="margin-top: 1em">NAME <br>
xsdcxx - W3C XML Schema to C++ Compiler</p>

<p style="margin-top: 1em">SYNOPSIS <br>
xsdcxx command [ options ] file [ file ...] <br>
xsdcxx help [ command ] <br>
xsdcxx version</p>

<p style="margin-top: 1em">DESCRIPTION <br>
xsdcxx generates vocabulary-specific, statically-typed C++
mapping from W3C XML Schema definitions. Particular mapping
to produce is selected by a command. Each mapping has a <br>
number of mapping-specific options that should appear, if
any, after the command. Input files should be W3C XML Schema
definitions. The exact set of the generated files depends
<br>
on the selected mapping and options.</p>

<p style="margin-top: 1em">COMMANDS <br>
cxx-tree <br>
Generate the C++/Tree mapping. For each input file in the
form name.xsd the following C++ files are generated:
name.hxx (header file), name.ixx (inline file, generated
<br>
only if the --generate-inline option is specified), name.cxx
(source file), and name-fwd.hxx (forward declaration file,
generated only if the --generate-forward option is <br>
specified).</p>

<p style="margin-top: 1em">cxx-parser <br>
Generate the C++/Parser mapping. For each input file in the
form name.xsd the following C++ files are generated:
name-pskel.hxx (parser skeleton header file), name- <br>
pskel.ixx (parser skeleton inline file, generated only if
the --generate-inline option is specified), and
name-pskel.cxx (parser skeleton source file). If the
--generate- <br>
noop-impl or --generate-print-impl option is specified, the
following additional sample implementation files are
generated: name-pimpl.hxx (parser implementation header <br>
file) and name-pimpl.cxx (parser implementation source
file). If the --generate-test-driver option is specified,
the additional name-driver.cxx test driver file is
gener&acirc; <br>
ated.</p>

<p style="margin-top: 1em">help Print usage information and
exit. Use</p>

<p style="margin-top: 1em">xsdcxx help command</p>

<p style="margin-top: 1em">for command-specific help.</p>

<p style="margin-top: 1em">version <br>
Print version and exit.</p>

<p style="margin-top: 1em">OPTIONS <br>
Command-specific options, if any, should appear after the
corresponding command.</p>

<p style="margin-top: 1em">common options <br>
--std version <br>
Specify the C++ standard that the generated code should
conform to. Valid values are c++98 (default) and c++11.</p>

<p style="margin-top: 1em">The C++ standard affects various
aspects of the generated code that are discussed in more
detail in various mapping-specific documentation. Overall,
when C++11 is <br>
selected, the generated code relies on the move semantics
and uses std::unique_ptr instead of deprecated
std::auto_ptr.</p>

<p style="margin-top: 1em">When the C++11 mode is selected,
you normally don&rsquo;t need to perform any extra steps
other than enable C++11 in your C++ compiler, if required.
The XSDCXX compiler will <br>
automatically add the necessary macro defines to the
generated header files that will switch the header-only
XSDCXX runtime library (libxsd) to the C++11 mode. However,
if <br>
you include any of the XSDCXX runtime headers directly in
your application (normally you just include the generated
headers), then you will need to define the XSD_CXX11 <br>
macro for your entire project.</p>

<p style="margin-top: 1em">--char-type type <br>
Generate code using the provided character type instead of
the default char. Valid values are char and wchar_t.</p>

<p style="margin-top: 1em">--char-encoding enc <br>
Specify the character encoding that should be used in the
generated code. Valid values for the char character type are
utf8 (default), iso8859-1, lcp (Xerces-C++ local <br>
code page), and custom. If you pass custom as the value then
you will need to include the transcoder implementation
header for your encoding at the beginning of the gen&acirc;
<br>
erated header files (see the --hxx-prologue option).</p>

<p style="margin-top: 1em">For the wchar_t character type
the only valid value is auto and the encoding is
automatically selected between UTF-16 and UTF-32/UCS-4,
depending on the wchar_t type size.</p>

<p style="margin-top: 1em">--output-dir dir <br>
Write generated files to dir instead of the current
directory.</p>

<p style="margin-top: 1em">--generate-inline <br>
Generate simple functions inline. This option triggers
creation of the inline file.</p>

<p style="margin-top: 1em">--generate-xml-schema <br>
Generate a C++ header file as if the schema being compiled
defines the XML Schema namespace. For the C++/Tree mapping,
the resulting file will contain definitions for all <br>
XML Schema built-in types. For the C++/Parser mapping, the
resulting file will contain definitions for all the parser
skeletons and implementations corresponding to the <br>
XML Schema built-in types.</p>

<p style="margin-top: 1em">The schema file provided to the
compiler need not exist and is only used to derive the name
of the resulting header file. Use the --extern-xml-schema
option to include <br>
this file in the generated files for other schemas.</p>

<p style="margin-top: 1em">--extern-xml-schema file <br>
Include a header file derived from file instead of
generating the XML Schema namespace mapping inline. The
provided file need not exist and is only used to derive the
name <br>
of the included header file. Use the --generate-xml-schema
option to generate this header file.</p>

<p style="margin-top: 1em">--namespace-map xns=cns <br>
Map XML Schema namespace xns to C++ namespace cns. Repeat
this option to specify mapping for more than one XML Schema
namespace. For example, the following option:</p>

<p style="margin-top: 1em">--namespace-map
http://example.com/foo/bar=foo::bar</p>

<p style="margin-top: 1em">Will map the
http://example.com/foo/bar XML Schema namespace to the
foo::bar C++ namespace.</p>

<p style="margin-top: 1em">--namespace-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema namespace names to C++ namespace names.
regex is a Perl-like regular expression in the form
/pat&acirc; <br>
tern/replacement/. Any character can be used as a delimiter
instead of /. Escaping of the delimiter character in pattern
or replacement is not supported.</p>

<p style="margin-top: 1em">All the regular expressions are
pushed into a stack with the last specified expression
considered first. The first match that succeeds is used.
Regular expressions are <br>
applied to a string in the form</p>

<p style="margin-top: 1em">filename namespace</p>

<p style="margin-top: 1em">For example, if you have file
hello.xsd with namespace http://example.com/hello and you
run xsd on this file, then the string in question will
be:</p>

<p style="margin-top: 1em">hello.xsd.
http://example.com/hello</p>

<p style="margin-top: 1em">For the built-in XML Schema
namespace the string is:</p>

<p style="margin-top: 1em">XMLSchema.xsd
http://www.w3.org/2001/XMLSchema</p>

<p style="margin-top: 1em">The following three steps are
performed for each regular expression until the match is
found:</p>

<p style="margin-top: 1em">1. The expression is applied and
if the result is empty the next expression is
considered.</p>

<p style="margin-top: 1em">2. All / are replaced with
::.</p>

<p style="margin-top: 1em">3. The result is verified to be
a valid C++ scope name (e.g., foo::bar). If this test
succeeds, the result is used as a C++ namespace name.</p>

<p style="margin-top: 1em">As an example, the following
expression maps XML Schema namespaces in the form
http://example.com/foo/bar to C++ namespaces in the form
foo::bar:</p>

<p style="margin-top: 1em">%.*
http://example.com/(.+)%$1%</p>

<p style="margin-top: 1em">See also the REGEX AND SHELL
QUOTING section below.</p>

<p style="margin-top: 1em">--namespace-regex-trace <br>
Trace the process of applying regular expressions specified
with the --namespace-regex option. Use this option to find
out why your regular expressions don&rsquo;t do what you
<br>
expected them to do.</p>

<p style="margin-top: 1em">--reserved-name n[=r] <br>
Add name n to the list of names that should not be used as
identifiers. The name can optionally be followed by = and
the replacement name r that should be used instead. <br>
All the C++ keywords are already in this list.</p>

<p style="margin-top: 1em">--include-with-brackets <br>
Use angle brackets (&lt;&gt;) instead of quotes
(&quot;&quot;) in generated #include directives.</p>

<p style="margin-top: 1em">--include-prefix prefix <br>
Add prefix to generated #include directive paths.</p>

<p style="margin-top: 1em">For example, if you had the
following import element in your schema</p>

<p style="margin-top: 1em">&lt;import
namespace=&quot;...&quot;
schemaLocation=&quot;base.xsd&quot;/&gt;</p>

<p style="margin-top: 1em">and compiled this fragment with
--include-prefix schemas/, then the include directive in the
generated code would be:</p>

<p style="margin-top: 1em">#include
&quot;schemas/base.hxx&quot;</p>

<p style="margin-top: 1em">--include-regex regex <br>
Add regex to the list of regular expressions used to
transform #include directive paths. regex is a Perl-like
regular expression in the form /pattern/replacement/. Any
<br>
character can be used as a delimiter instead of /. Escaping
of the delimiter character in pattern or replacement is not
supported.</p>

<p style="margin-top: 1em">All the regular expressions are
pushed into a stack with the last specified expression
considered first. The first match that succeeds is used.</p>

<p style="margin-top: 1em">As an example, the following
expression transforms paths in the form schemas/foo/bar to
paths in the form generated/foo/bar:</p>

<p style="margin-top: 1em">%schemas/(.+)%generated/$1%</p>

<p style="margin-top: 1em">See also the REGEX AND SHELL
QUOTING section below.</p>

<p style="margin-top: 1em">--include-regex-trace <br>
Trace the process of applying regular expressions specified
with the --include-regex option. Use this option to find out
why your regular expressions don&rsquo;t do what you <br>
expected them to do.</p>

<p style="margin-top: 1em">--guard-prefix prefix <br>
Add prefix to generated header inclusion guards. The prefix
is transformed to upper case and characters that are illegal
in a preprocessor macro name are replaced with <br>
underscores. If this option is not specified then the
directory part of the input schema file is used as a
prefix.</p>

<p style="margin-top: 1em">--hxx-suffix suffix <br>
Use the provided suffix instead of the default .hxx to
construct the name of the header file. Note that this suffix
is also used to construct names of header files corre&acirc;
<br>
sponding to included/imported schemas.</p>

<p style="margin-top: 1em">--ixx-suffix suffix <br>
Use the provided suffix instead of the default .ixx to
construct the name of the inline file.</p>

<p style="margin-top: 1em">--cxx-suffix suffix <br>
Use the provided suffix instead of the default .cxx to
construct the name of the source file.</p>

<p style="margin-top: 1em">--fwd-suffix suffix <br>
Use the provided suffix instead of the default -fwd.hxx to
construct the name of the forward declaration file.</p>

<p style="margin-top: 1em">--hxx-regex regex <br>
Use the provided expression to construct the name of the
header file. regex is a Perl-like regular expression in the
form /pattern/replacement/. Note that this expression <br>
is also used to construct names of header files
corresponding to included/imported schemas. See also the
REGEX AND SHELL QUOTING section below.</p>

<p style="margin-top: 1em">--ixx-regex regex <br>
Use the provided expression to construct the name of the
inline file. regex is a Perl-like regular expression in the
form /pattern/replacement/. See also the REGEX AND <br>
SHELL QUOTING section below.</p>

<p style="margin-top: 1em">--cxx-regex regex <br>
Use the provided expression to construct the name of the
source file. regex is a Perl-like regular expression in the
form /pattern/replacement/. See also the REGEX AND <br>
SHELL QUOTING section below.</p>

<p style="margin-top: 1em">--fwd-regex regex <br>
Use the provided expression to construct the name of the
forward declaration file. regex is a Perl-like regular
expression in the form /pattern/replacement/. See also the
<br>
REGEX AND SHELL QUOTING section below.</p>

<p style="margin-top: 1em">--hxx-prologue text <br>
Insert text at the beginning of the header file.</p>

<p style="margin-top: 1em">--ixx-prologue text <br>
Insert text at the beginning of the inline file.</p>

<p style="margin-top: 1em">--cxx-prologue text <br>
Insert text at the beginning of the source file.</p>

<p style="margin-top: 1em">--fwd-prologue text <br>
Insert text at the beginning of the forward declaration
file.</p>

<p style="margin-top: 1em">--prologue text <br>
Insert text at the beginning of each generated file for
which there is no file-specific prologue.</p>

<p style="margin-top: 1em">--hxx-epilogue text <br>
Insert text at the end of the header file.</p>

<p style="margin-top: 1em">--ixx-epilogue text <br>
Insert text at the end of the inline file.</p>

<p style="margin-top: 1em">--cxx-epilogue text <br>
Insert text at the end of the source file.</p>

<p style="margin-top: 1em">--fwd-epilogue text <br>
Insert text at the end of the forward declaration file.</p>

<p style="margin-top: 1em">--epilogue text <br>
Insert text at the end of each generated file for which
there is no file-specific epilogue.</p>

<p style="margin-top: 1em">--hxx-prologue-file file <br>
Insert the content of the file at the beginning of the
header file.</p>

<p style="margin-top: 1em">--ixx-prologue-file file <br>
Insert the content of the file at the beginning of the
inline file.</p>

<p style="margin-top: 1em">--cxx-prologue-file file <br>
Insert the content of the file at the beginning of the
source file.</p>

<p style="margin-top: 1em">--fwd-prologue-file file <br>
Insert the content of the file at the beginning of the
forward declaration file.</p>

<p style="margin-top: 1em">--prologue-file file <br>
Insert the content of the file at the beginning of each
generated file for which there is no file-specific prologue
file.</p>

<p style="margin-top: 1em">--hxx-epilogue-file file <br>
Insert the content of the file at the end of the header
file.</p>

<p style="margin-top: 1em">--ixx-epilogue-file file <br>
Insert the content of the file at the end of the inline
file.</p>

<p style="margin-top: 1em">--cxx-epilogue-file file <br>
Insert the content of the file at the end of the source
file.</p>

<p style="margin-top: 1em">--fwd-epilogue-file file <br>
Insert the content of the file at the end of the forward
declaration file.</p>

<p style="margin-top: 1em">--epilogue-file file <br>
Insert the content of the file at the end of each generated
file for which there is no file-specific epilogue file.</p>

<p style="margin-top: 1em">--export-symbol symbol <br>
Insert symbol in places where DLL export/import control
statements (__declspec(dllexport/dllimport)) are
necessary.</p>

<p style="margin-top: 1em">--export-xml-schema <br>
Export/import types in the XML Schema namespace using the
export symbol provided with the --export-symbol option. The
XSD_NO_EXPORT macro can be used to omit this code <br>
during C++ compilation, which may be useful if you would
like to use the same generated code across multiple
platforms.</p>

<p style="margin-top: 1em">--export-maps <br>
Export polymorphism support maps from a Win32 DLL into which
this generated code is placed. This is necessary when your
type hierarchy is split across several DLLs since <br>
otherwise each DLL will have its own set of maps. In this
situation the generated code for the DLL which contains base
types and/or substitution group heads should be com&acirc;
<br>
piled with this option and the generated code for all other
DLLs should be compiled with --import-maps. This option is
only valid together with --generate-polymorphic. The <br>
XSD_NO_EXPORT macro can be used to omit this code during C++
compilation, which may be useful if you would like to use
the same generated code across multiple platforms.</p>

<p style="margin-top: 1em">--import-maps <br>
Import polymorphism support maps to a Win32 DLL or
executable into which this generated code is linked. See the
--export-maps option documentation for details. This <br>
options is only valid together with --generate-polymorphic.
The XSD_NO_EXPORT macro can be used to omit this code during
C++ compilation, which may be useful if you would <br>
like to use the same generated code across multiple
platforms.</p>

<p style="margin-top: 1em">--generate-dep <br>
Generate make dependency information. This option triggers
the creation of the .d file containing the dependencies of
the generated files on the main schema file as well <br>
as all the schema files that it includes/imports,
transitively. This dependency file is then normally included
into the main makefile to implement automatic dependency
<br>
tracking.</p>

<p style="margin-top: 1em">Note also that automatic
dependency generation is not supported in the file-per-type
mode (--file-per-type). In this case, all the generated
files are produced with a sin&acirc; <br>
gle compiler invocation and depend on all the schemas. As a
result, it is easier to establish such a dependency
manually, perhaps with the help of the --file-list* <br>
options.</p>

<p style="margin-top: 1em">--generate-dep-only <br>
Generate make dependency information only.</p>

<p style="margin-top: 1em">--dep-phony <br>
Generate phony targets for included/imported schema files,
causing each to depend on nothing. Such dummy rules work
around make errors caused by the removal of schema <br>
files without also updating the dependency file to
match.</p>

<p style="margin-top: 1em">--dep-target target <br>
Change the target of the dependency rule. By default it
contains all the generated C++ files as well as the
dependency file itself, without any directory prefixes. If
you <br>
require multiple targets, then you can specify them as a
single, space-separated argument or you can repeat this
option multiple times.</p>

<p style="margin-top: 1em">--dep-suffix suffix <br>
Use the provided suffix instead of the default .d to
construct the name of the dependency file.</p>

<p style="margin-top: 1em">--dep-regex regex <br>
Use the provided expression to construct the name of the
dependency file. regex is a Perl-like regular expression in
the form /pattern/replacement/. See also the REGEX <br>
AND SHELL QUOTING section below.</p>

<p style="margin-top: 1em">--disable-warning warn <br>
Disable printing warning with id warn. If all is specified
for the warning id then all warnings are disabled.</p>

<p style="margin-top: 1em">--options-file file <br>
Read additional options from file. Each option should
appearing on a separate line optionally followed by space
and an option value. Empty lines and lines starting with #
<br>
are ignored. Option values can be enclosed in double
(&quot;) or single (&rsquo;) quotes to preserve leading and
trailing whitespaces as well as to specify empty values. If
the <br>
value itself contains trailing or leading quotes, enclose it
with an extra pair of quotes, for example
&rsquo;&quot;x&quot;&rsquo;. Non-leading and non-trailing
quotes are interpreted as being <br>
part of the option value.</p>

<p style="margin-top: 1em">The semantics of providing
options in a file is equivalent to providing the same set of
options in the same order on the command line at the point
where the --options-file <br>
option is specified except that the shell escaping and
quoting is not required. You can repeat this option to
specify more than one options file.</p>

<p style="margin-top: 1em">--show-sloc <br>
Show the number of generated physical source lines of code
(SLOC).</p>

<p style="margin-top: 1em">--sloc-limit num <br>
Check that the number of generated physical source lines of
code (SLOC) does not exceed num.</p>

<p style="margin-top: 1em">--proprietary-license <br>
Indicate that the generated code is licensed under a
proprietary license instead of the GPL.</p>

<p style="margin-top: 1em">--custom-literals file <br>
Load custom XML string to C++ literal mappings from file.
This mechanism can be useful if you are using a custom
character encoding and some of the strings in your <br>
schemas, for example element/attribute names or enumeration
values, contain non-ASCII characters. In this case you will
need to provide a custom mapping to C++ literals <br>
for such strings. The format of this file is specified in
the custom-literals.xsd XML Schema file that can be found in
the documentation directory.</p>

<p style="margin-top: 1em">--preserve-anonymous <br>
Preserve anonymous types. By default anonymous types are
automatically named with names derived from the enclosing
elements/attributes. Because mappings implemented by <br>
this compiler require all types to be named, this option is
only useful if you want to make sure your schemas
don&rsquo;t have anonymous types.</p>

<p style="margin-top: 1em">--show-anonymous <br>
Show elements and attributes that are of anonymous types.
This option only makes sense together with the
--preserve-anonymous option.</p>

<p style="margin-top: 1em">--anonymous-regex regex <br>
Add regex to the list of regular expressions used to derive
names for anonymous types from the enclosing
attributes/elements. regex is a Perl-like regular expression
in <br>
the form /pattern/replacement/. Any character can be used as
a delimiter instead of /. Escaping of the delimiter
character in pattern or replacement is not supported.</p>

<p style="margin-top: 1em">All the regular expressions are
pushed into a stack with the last specified expression
considered first. The first match that succeeds is used.
Regular expressions are <br>
applied to a string in the form</p>

<p style="margin-top: 1em">filename namespace xpath</p>

<p style="margin-top: 1em">For instance:</p>

<p style="margin-top: 1em">hello.xsd
http://example.com/hello element</p>

<p style="margin-top: 1em">hello.xsd
http://example.com/hello type/element</p>

<p style="margin-top: 1em">As an example, the following
expression makes all the derived names start with capital
letters. This could be useful when your naming convention
requires type names to <br>
start with capital letters:</p>

<p style="margin-top: 1em">%.* .* (.+/)*(.+)%$2%</p>

<p style="margin-top: 1em">See also the REGEX AND SHELL
QUOTING section below.</p>

<p style="margin-top: 1em">--anonymous-regex-trace <br>
Trace the process of applying regular expressions specified
with the --anonymous-regex option. Use this option to find
out why your regular expressions don&rsquo;t do what you
<br>
expected them to do.</p>

<p style="margin-top: 1em">--location-map ol=nl <br>
Map the original schema location ol that is specified in the
XML Schema include or import elements to new schema location
nl. Repeat this option to map more than one <br>
schema location. For example, the following option maps the
http://example.com/foo.xsd URL to the foo.xsd local
file.</p>

<p style="margin-top: 1em">--location-map
http://example.com/foo.xsd=foo.xsd</p>

<p style="margin-top: 1em">--location-regex regex <br>
Add regex to the list of regular expressions used to map
schema locations that are specified in the XML Schema
include or import elements. regex is a Perl-like regular
<br>
expression in the form /pattern/replacement/. Any character
can be used as a delimiter instead of /. Escaping of the
delimiter character in pattern or replacement is not <br>
supported. All the regular expressions are pushed into a
stack with the last specified expression considered first.
The first match that succeeds is used.</p>

<p style="margin-top: 1em">For example, the following
expression maps URL locations in the form
http://example.com/foo/bar.xsd to local files in the form
bar.xsd:</p>

<p style="margin-top: 1em">%http://.+/(.+)%$1%</p>

<p style="margin-top: 1em">See also the REGEX AND SHELL
QUOTING section below.</p>

<p style="margin-top: 1em">--location-regex-trace <br>
Trace the process of applying regular expressions specified
with the --location-regex option. Use this option to find
out why your regular expressions don&rsquo;t do what you
<br>
expected them to do.</p>

<p style="margin-top: 1em">--file-per-type <br>
Generate a separate set of C++ files for each type defined
in XML Schema. Note that in this mode you only need to
compile the root schema(s) and the code will be gener&acirc;
<br>
ated for all included and imported schemas. This compilation
mode is primarily useful when some of your schemas cannot be
compiled separately or have cyclic dependencies <br>
which involve type inheritance. Other options related to
this mode are: --type-file-regex, --schema-file-regex,
--fat-type-file, and --file-list.</p>

<p style="margin-top: 1em">--type-file-regex regex <br>
Add regex to the list of regular expressions used to
translate type names to file names when the --file-per-type
option is specified. regex is a Perl-like regular
expres&acirc; <br>
sion in the form /pattern/replacement/. Any character can be
used as a delimiter instead of /. Escaping of the delimiter
character in pattern or replacement is not sup&acirc; <br>
ported. All the regular expressions are pushed into a stack
with the last specified expression considered first. The
first match that succeeds is used. Regular expressions <br>
are applied to a string in the form</p>

<p style="margin-top: 1em">namespace type-name</p>

<p style="margin-top: 1em">For example, the following
expression maps type foo that is defined in the
http://example.com/bar namespace to file name bar-foo:</p>

<p style="margin-top: 1em">%http://example.com/(.+)
(.+)%$1-$2%</p>

<p style="margin-top: 1em">See also the REGEX AND SHELL
QUOTING section below.</p>

<p style="margin-top: 1em">--type-file-regex-trace <br>
Trace the process of applying regular expressions specified
with the --type-file-regex option. Use this option to find
out why your regular expressions don&rsquo;t do what you
<br>
expected them to do.</p>

<p style="margin-top: 1em">--schema-file-regex regex <br>
Add regex to the list of regular expressions used to
translate schema file names when the --file-per-type option
is specified. regex is a Perl-like regular expression in
<br>
the form /pattern/replacement/. Any character can be used as
a delimiter instead of /. Escaping of the delimiter
character in pattern or replacement is not supported. All
<br>
the regular expressions are pushed into a stack with the
last specified expression considered first. The first match
that succeeds is used. Regular Expressions are applied <br>
to the absolute filesystem path of a schema file and the
result, including the directory part, if any, is used to
derive the #include directive paths as well as the
gener&acirc; <br>
ated C++ file paths. This option, along with
--type-file-regex are primarily useful to place the
generated files into subdirectories or to resolve file name
conflicts.</p>

<p style="margin-top: 1em">For example, the following
expression maps schema files in the foo/1.0.0/ subdirectory
to the files in the foo/ subdirectory. As a result, the
#include directive paths for <br>
such schemas will be in the foo/schema.hxx form and the
generated C++ files will be placed into the foo/
subdirectory:</p>

<p style="margin-top: 1em">%.*/foo/1.0.0/(.+)%foo/$1%</p>

<p style="margin-top: 1em">See also the REGEX AND SHELL
QUOTING section below.</p>

<p style="margin-top: 1em">--schema-file-regex-trace <br>
Trace the process of applying regular expressions specified
with the --schema-file-regex option. Use this option to find
out why your regular expressions don&rsquo;t do what you
<br>
expected them to do.</p>

<p style="margin-top: 1em">--fat-type-file <br>
Generate code corresponding to global elements into type
files instead of schema files when the --type-file-regex
option is specified. This option is primarily useful when
<br>
trying to minimize the amount of object code that is linked
to an executable by packaging compiled generated code into a
static (archive) library.</p>

<p style="margin-top: 1em">--file-list file <br>
Write a list of generated C++ files to file. This option is
primarily useful in the file-per-type compilation mode
(--file-per-type) to create a list of generated C++ <br>
files, for example, as a makefile fragment.</p>

<p style="margin-top: 1em">--file-list-prologue text <br>
Insert text at the beginning of the file list. As a
convenience, all occurrences of the character sequence in
text are replaced with new lines. This option can, for <br>
example, be used to assign the generated file list to a
makefile variable.</p>

<p style="margin-top: 1em">--file-list-epilogue text <br>
Insert text at the end of the file list. As a convenience,
all occurrences of the character sequence in text are
replaced with new lines.</p>

<p style="margin-top: 1em">--file-list-delim text <br>
Delimit file names written to the file list with text
instead of new lines. As a convenience, all occurrences of
the character sequence in text are replaced with new <br>
lines.</p>

<p style="margin-top: 1em">cxx-tree command options <br>
--generate-polymorphic <br>
Generate polymorphism-aware code. Specify this option if you
use substitution groups or xsi:type. Use the
--polymorphic-type or --polymorphic-type-all option to
specify <br>
which type hierarchies are polymorphic.</p>

<p style="margin-top: 1em">--polymorphic-type type <br>
Indicate that type is a root of a polymorphic type
hierarchy. The compiler can often automatically determine
which types are polymorphic based on the substitution group
<br>
declarations. However, you may need to use this option if
you are not using substitution groups or if substitution
groups are defined in another schema. You need to
spec&acirc; <br>
ify this option when compiling every schema file that
references type. The type argument is an XML Schema type
name that can be optionally qualified with a namespace in
<br>
the namespace#name form.</p>

<p style="margin-top: 1em">--polymorphic-type-all <br>
Indicate that all types should be treated as
polymorphic.</p>

<p style="margin-top: 1em">--polymorphic-plate num <br>
Specify the polymorphic map plate the generated code should
register on. This functionality is primarily useful to
segregate multiple schemas that define the same poly&acirc;
<br>
morphic types.</p>

<p style="margin-top: 1em">--ordered-type type <br>
Indicate that element order in type is significant. An
example would be a complex type with unbounded choice as a
content model where the element order in XML has
applica&acirc; <br>
tion-specific semantics. For ordered types the compiler
generates a special container data member and a
corresponding set of accessors and modifiers that are used
to cap&acirc; <br>
ture the order of elements and, for mixed content, of
text.</p>

<p style="margin-top: 1em">The type argument is an XML
Schema type name that can be optionally qualified with a
namespace in the namespace#name form. Note also that you
will need to specify this <br>
option when compiling every schema file that has other
ordered types derived from this type.</p>

<p style="margin-top: 1em">--ordered-type-derived <br>
Automatically treat types derived from ordered bases as also
ordered. This is primarily useful if you would like to be
able to iterate over the complete content using the <br>
content order container.</p>

<p style="margin-top: 1em">--ordered-type-mixed <br>
Automatically treat complex types with mixed content as
ordered.</p>

<p style="margin-top: 1em">--ordered-type-all <br>
Indicate that element order in all types is significant.</p>

<p style="margin-top: 1em">--order-container type <br>
Specify a custom class template that should be used as a
container for the content order in ordered types instead of
the default std::vector. See --ordered-type for more <br>
information on ordered type. This option is primarily useful
if you need to perform more complex lookups in the content
order container, for example by element id. In this <br>
case, a container like Boost multi-index may be more
convenient. Note that if using a custom container, you will
also most likely need to include the relevant headers <br>
using the --hxx-prologue* options.</p>

<p style="margin-top: 1em">--generate-serialization <br>
Generate serialization functions. Serialization functions
convert the object model back to XML.</p>

<p style="margin-top: 1em">--generate-ostream <br>
Generate ostream insertion operators (operator&lt;&lt;) for
generated types. This allows one to easily print a fragment
or the whole object model for debugging or logging.</p>

<p style="margin-top: 1em">--generate-doxygen <br>
Generate documentation comments suitable for extraction by
the Doxygen documentation system. Documentation from
annotations is added to the comments if present in the <br>
schema.</p>

<p style="margin-top: 1em">--generate-comparison <br>
Generate comparison operators (operator== and operator!=)
for complex types. Comparison is performed member-wise.</p>

<p style="margin-top: 1em">--generate-default-ctor <br>
Generate default constructors even for types that have
required members. Required members of an instance
constructed using such a constructor are not initialized and
<br>
accessing them results in undefined behavior.</p>

<p style="margin-top: 1em">--generate-from-base-ctor <br>
Generate constructors that expect an instance of a base type
followed by all required members.</p>

<p style="margin-top: 1em">--suppress-assignment <br>
Suppress the generation of copy assignment operators for
complex types. If this option is specified, the copy
assignment operators for such types are declared private and
<br>
left unimplemented.</p>

<p style="margin-top: 1em">--generate-detach <br>
Generate detach functions for required elements and
attributes. Detach functions for optional and sequence
cardinalities are provided by the respective containers.
These <br>
functions, for example, allow you to move sub-trees in the
object model either within the same tree or between
different trees.</p>

<p style="margin-top: 1em">--generate-wildcard <br>
Generate accessors and modifiers as well as parsing and
serialization code for XML Schema wildcards (any and
anyAttribute). XML content matched by wildcards is presented
<br>
as DOM fragments. Note that you need to initialize the
Xerces-C++ runtime if you are using this option.</p>

<p style="margin-top: 1em">--generate-any-type <br>
Extract and store content of the XML Schema anyType type as
a DOM fragment. Note that you need to initialize the
Xerces-C++ runtime if you are using this option.</p>

<p style="margin-top: 1em">--generate-insertion os <br>
Generate data representation stream insertion operators for
the os output stream type. Repeat this option to specify
more than one stream type. The ACE CDR stream <br>
(ACE_OutputCDR) and RPC XDR are recognized by the compiler
and the necessary #include directives are automatically
generated. For custom stream types use the --hxx-pro&acirc;
<br>
logue* options to provide the necessary declarations.</p>

<p style="margin-top: 1em">--generate-extraction is <br>
Generate data representation stream extraction constructors
for the is input stream type. Repeat this option to specify
more than one stream type. The ACE CDR stream <br>
(ACE_InputCDR) and RPC XDR are recognized by the compiler
and the necessary #include directives are automatically
generated. For custom stream types use the --hxx-pro&acirc;
<br>
logue* options to provide the necessary declarations.</p>

<p style="margin-top: 1em">--generate-forward <br>
Generate a separate header file with forward declarations
for the types being generated.</p>

<p style="margin-top: 1em">--suppress-parsing <br>
Suppress the generation of the parsing functions and
constructors. Use this option to reduce the generated code
size when parsing from XML is not needed.</p>

<p style="margin-top: 1em">--generate-element-type <br>
Generate types instead of parsing and serialization
functions for root elements. This is primarily useful to
distinguish object models with the same root type but with
<br>
different root elements.</p>

<p style="margin-top: 1em">--generate-element-map <br>
Generate a root element map that allows uniform parsing and
serialization of multiple root elements. This option is only
valid together with --generate-element-type.</p>

<p style="margin-top: 1em">--generate-intellisense <br>
Generate workarounds for IntelliSense bugs in Visual Studio
2005 (8.0). When this option is used, the resulting code is
slightly more verbose. IntelliSense in Visual <br>
Studio 2008 (9.0) and later does not require these
workarounds. Support for IntelliSense in Visual Studio 2003
(7.1) is improved with this option but is still
incomplete.</p>

<p style="margin-top: 1em">--omit-default-attributes <br>
Omit attributes with default and fixed values from
serialized XML documents.</p>

<p style="margin-top: 1em">--type-naming style <br>
Specify the type naming convention that should be used in
the generated code. Valid styles are knr (default), ucc, and
java. See the NAMING CONVENTION section below for <br>
more information.</p>

<p style="margin-top: 1em">--function-naming style <br>
Specify the function naming convention that should be used
in the generated code. Valid styles are knr (default), lcc,
and java. See the NAMING CONVENTION section below <br>
for more information.</p>

<p style="margin-top: 1em">--type-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema type names to C++ type names. See the
NAMING CONVENTION section below for more information.</p>

<p style="margin-top: 1em">--accessor-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema names of elements/attributes to C++
accessor function names. See the NAMING CONVENTION section
<br>
below for more information.</p>

<p style="margin-top: 1em">--one-accessor-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema names of elements/attributes with
cardinality one to C++ accessor function names. See the
NAMING <br>
CONVENTION section below for more information.</p>

<p style="margin-top: 1em">--opt-accessor-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema names of elements/attributes with
cardinality optional to C++ accessor function names. See the
<br>
NAMING CONVENTION section below for more information.</p>

<p style="margin-top: 1em">--seq-accessor-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema names of elements/attributes with
cardinality sequence to C++ accessor function names. See the
<br>
NAMING CONVENTION section below for more information.</p>

<p style="margin-top: 1em">--modifier-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema names of elements/attributes to C++
modifier function names. See the NAMING CONVENTION section
<br>
below for more information.</p>

<p style="margin-top: 1em">--one-modifier-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema names of elements/attributes with
cardinality one to C++ modifier function names. See the
NAMING <br>
CONVENTION section below for more information.</p>

<p style="margin-top: 1em">--opt-modifier-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema names of elements/attributes with
cardinality optional to C++ modifier function names. See the
<br>
NAMING CONVENTION section below for more information.</p>

<p style="margin-top: 1em">--seq-modifier-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema names of elements/attributes with
cardinality sequence to C++ modifier function names. See the
<br>
NAMING CONVENTION section below for more information.</p>

<p style="margin-top: 1em">--parser-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema element names to C++ parsing function
names. See the NAMING CONVENTION section below for more <br>
information.</p>

<p style="margin-top: 1em">--serializer-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema element names to C++ serialization
function names. See the NAMING CONVENTION section below for
<br>
more information.</p>

<p style="margin-top: 1em">--const-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema-derived names to C++ constant names.
See the NAMING CONVENTION section below for more
informa&acirc; <br>
tion.</p>

<p style="margin-top: 1em">--enumerator-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema enumeration values to C++ enumerator
names. See the NAMING CONVENTION section below for more <br>
information.</p>

<p style="margin-top: 1em">--element-type-regex regex <br>
Add regex to the list of regular expressions used to
translate XML Schema element names to C++ element type
names. See the NAMING CONVENTION section below for more
infor&acirc; <br>
mation.</p>

<p style="margin-top: 1em">--name-regex-trace <br>
Trace the process of applying regular expressions specified
with the name transformation options. Use this option to
find out why your regular expressions don&rsquo;t do what
<br>
you expected them to do.</p>

<p style="margin-top: 1em">--root-element-first <br>
Treat only the first global element as a document root. By
default all global elements are considered document
roots.</p>

<p style="margin-top: 1em">--root-element-last <br>
Treat only the last global element as a document root. By
default all global elements are considered document
roots.</p>

<p style="margin-top: 1em">--root-element-all <br>
Treat all global elements as document roots. This is the
default behavior. By explicitly specifying this option you
can suppress the warning that is issued if more than <br>
one global element is defined.</p>

<p style="margin-top: 1em">--root-element-none <br>
Do not treat any global elements as document roots. By
default all global elements are considered document
roots.</p>

<p style="margin-top: 1em">--root-element element <br>
Treat only element as a document root. Repeat this option to
specify more than one root element.</p>

<p style="margin-top: 1em">--custom-type map <br>
Use a custom C++ type instead of the generated class. The
map argument is in the form name[=type[/base]], where name
is a type name as defined in XML Schema and type is a <br>
C++ type name that should be used instead. If type is not
present or empty then the custom type is assumed to have the
same name and be defined in the same namespace as <br>
the generated class would have. If base is specified then
the generated class is still generated but with that
name.</p>

<p style="margin-top: 1em">--custom-type-regex regex <br>
Use custom C++ types instead of the generated classes. The
regex argument is in the form
/name-pat/[type-sub/[base-sub/]], where name-pat is a regex
pattern that will be <br>
matched against type names as defined in XML Schema and
type-sub is a C++ type name substitution that should be used
instead. If type-sub is not present or its substitu&acirc;
<br>
tion results in an empty string then the custom type is
assumed to have the same name and be defined in the same
namespace as the generated class would have. If base-sub
<br>
is present and its substitution results in a non-empty
string then the generated class is still generated but with
the result of this substitution as its name. The pattern
<br>
and substitutions are in the Perl regular expression format.
See also the REGEX AND SHELL QUOTING section below.</p>

<p style="margin-top: 1em">--parts num <br>
Split generated source code into num parts. This is useful
when translating large, monolithic schemas and a C++
compiler is not able to compile the resulting source code
<br>
at once (usually due to insufficient memory).</p>

<p style="margin-top: 1em">--parts-suffix suffix <br>
Use suffix instead of the default &rsquo;-&rsquo; to
separate the file name from the part number.</p>

<p style="margin-top: 1em">cxx-parser command options <br>
--type-map mapfile <br>
Read XML Schema to C++ type mapping information from
mapfile. Repeat this option to specify several type maps.
Type maps are considered in order of appearance and the <br>
first match is used. By default all user-defined types are
mapped to void. See the TYPE MAP section below for more
information.</p>

<p style="margin-top: 1em">--xml-parser parser <br>
Use parser as the underlying XML parser. Valid values are
xerces for Xerces-C++ (default) and expat for Expat.</p>

<p style="margin-top: 1em">--generate-validation <br>
Generate validation code. The validation code (&quot;perfect
parser&quot;) ensures that instance documents conform to the
schema. Validation code is generated by default when the
<br>
selected underlying XML parser is non-validating
(expat).</p>

<p style="margin-top: 1em">--suppress-validation <br>
Suppress the generation of validation code. Validation is
suppressed by default when the selected underlying XML
parser is validating (xerces).</p>

<p style="margin-top: 1em">--generate-polymorphic <br>
Generate polymorphism-aware code. Specify this option if you
use substitution groups or xsi:type.</p>

<p style="margin-top: 1em">--generate-noop-impl <br>
Generate a sample parser implementation that does nothing
(no operation). The sample implementation can then be filled
with the application-specific code. For an input <br>
file in the form name.xsd this option triggers the
generation of two additional C++ files in the form:
name-pimpl.hxx (parser implementation header file) and name-
<br>
pimpl.cxx (parser implementation source file).</p>

<p style="margin-top: 1em">--generate-print-impl <br>
Generate a sample parser implementation that prints the XML
data to STDOUT. For an input file in the form name.xsd this
option triggers the generation of two additional <br>
C++ files in the form: name-pimpl.hxx (parser implementation
header file) and name-pimpl.cxx (parser implementation
source file).</p>

<p style="margin-top: 1em">--generate-test-driver <br>
Generate a test driver for the sample parser implementation.
For an input file in the form name.xsd this option triggers
the generation of an additional C++ file in the <br>
form name-driver.cxx.</p>

<p style="margin-top: 1em">--force-overwrite <br>
Force overwriting of the existing implementation and test
driver files. Use this option only if you do not mind
loosing the changes you have made in the sample
implementa&acirc; <br>
tion or test driver files.</p>

<p style="margin-top: 1em">--root-element-first <br>
Indicate that the first global element is the document root.
This information is used to generate the test driver for the
sample implementation.</p>

<p style="margin-top: 1em">--root-element-last <br>
Indicate that the last global element is the document root.
This information is used to generate the test driver for the
sample implementation.</p>

<p style="margin-top: 1em">--root-element element <br>
Indicate that element is the document root. This information
is used to generate the test driver for the sample
implementation.</p>

<p style="margin-top: 1em">--skel-type-suffix suffix <br>
Use the provided suffix instead of the default _pskel to
construct the names of the generated parser skeletons.</p>

<p style="margin-top: 1em">--skel-file-suffix suffix <br>
Use the provided suffix instead of the default -pskel to
construct the names of the generated parser skeleton
files.</p>

<p style="margin-top: 1em">--impl-type-suffix suffix <br>
Use the provided suffix instead of the default _pimpl to
construct the names of the parser implementations for the
built-in XML Schema types as well as sample parser <br>
implementations.</p>

<p style="margin-top: 1em">--impl-file-suffix suffix <br>
Use the provided suffix instead of the default -pimpl to
construct the names of the generated sample parser
implementation files.</p>

<p style="margin-top: 1em">NAMING CONVENTION <br>
The compiler can be instructed to use a particular naming
convention in the generated code. A number of widely-used
conventions can be selected using the --type-naming and <br>
--function-naming options. A custom naming convention can be
achieved using the --type-regex, --accessor-regex,
--one-accessor-regex, --opt-accessor-regex,
--seq-accessor-regex, <br>
--modifier-regex, --one-modifier-regex,
--opt-modifier-regex, --seq-modifier-regex, --parser-regex,
--serializer-regex, --const-regex, --enumerator-regex, and
--element-type- <br>
regex options.</p>

<p style="margin-top: 1em">The --type-naming option
specifies the convention that should be used for naming C++
types. Possible values for this option are knr (default),
ucc, and java. The knr value <br>
(stands for K&amp;R) signifies the standard, lower-case
naming convention with the underscore used as a word
delimiter, for example: foo, foo_bar. The ucc (stands for
upper-camel- <br>
case) and java values a synonyms for the same naming
convention where the first letter of each word in the name
is capitalized, for example: Foo, FooBar.</p>

<p style="margin-top: 1em">Similarly, the --function-naming
option specifies the convention that should be used for
naming C++ functions. Possible values for this option are
knr (default), lcc, and java. <br>
The knr value (stands for K&amp;R) signifies the standard,
lower-case naming convention with the underscore used as a
word delimiter, for example: foo(), foo_bar(). The lcc value
<br>
(stands for lower-camel-case) signifies a naming convention
where the first letter of each word except the first is
capitalized, for example: foo(), fooBar(). The java naming
<br>
convention is similar to the lower-camel-case one except
that accessor functions are prefixed with get, modifier
functions are prefixed with set, parsing functions are
prefixed <br>
with parse, and serialization functions are prefixed with
serialize, for example: getFoo(), setFooBar(), parseRoot(),
serializeRoot().</p>

<p style="margin-top: 1em">Note that the naming conventions
specified with the --type-naming and --function-naming
options perform only limited transformations on the names
that come from the schema in the <br>
form of type, attribute, and element names. In other words,
to get consistent results, your schemas should follow a
similar naming convention as the one you would like to have
in <br>
the generated code. Alternatively, you can use the --*-regex
options (discussed below) to perform further transformations
on the names that come from the schema.</p>

<p style="margin-top: 1em">The --type-regex,
--accessor-regex, --one-accessor-regex,
--opt-accessor-regex, --seq-accessor-regex,
--modifier-regex, --one-modifier-regex,
--opt-modifier-regex, --seq-modi&acirc; <br>
fier-regex, --parser-regex, --serializer-regex,
--const-regex, --enumerator-regex, and --element-type-regex
options allow you to specify extra regular expressions for
each name <br>
category in addition to the predefined set that is added
depending on the --type-naming and --function-naming
options. Expressions that are provided with the --*-regex
options <br>
are evaluated prior to any predefined expressions. This
allows you to selectively override some or all of the
predefined transformations. When debugging your own
expressions, it <br>
is often useful to see which expressions match which names.
The --name-regex-trace option allows you to trace the
process of applying regular expressions to names.</p>

<p style="margin-top: 1em">The value for the --*-regex
options should be a perl-like regular expression in the form
/pattern/replacement/. Any character can be used as a
delimiter instead of /. Escaping <br>
of the delimiter character in pattern or replacement is not
supported. All the regular expressions for each category are
pushed into a category-specific stack with the last
spec&acirc; <br>
ified expression considered first. The first match that
succeeds is used. For the --one-accessor-regex (accessors
with cardinality one), --opt-accessor-regex (accessors with
car&acirc; <br>
dinality optional), and --seq-accessor-regex (accessors with
cardinality sequence) categories the --accessor-regex
expressions are used as a fallback. For the --one-modifier-
<br>
regex, --opt-modifier-regex, and --seq-modifier-regex
categories the --modifier-regex expressions are used as a
fallback. For the --element-type-regex category the
--type-regex <br>
expressions are used as a fallback.</p>

<p style="margin-top: 1em">The type name expressions
(--type-regex) are evaluated on the name string that has the
following format:</p>

<p style="margin-top: 1em">[namespace
]name[,name][,name][,name]</p>

<p style="margin-top: 1em">The element type name
expressions (--element-type-regex), effective only when the
--generate-element-type option is specified, are evaluated
on the name string that has the fol&acirc; <br>
lowing format:</p>

<p style="margin-top: 1em">namespace name</p>

<p style="margin-top: 1em">In the type name format the
namespace part followed by a space is only present for
global type names. For global types and elements defined in
schemas without a target namespace, <br>
the namespace part is empty but the space is still present.
In the type name format after the initial name component, up
to three additional name components can be present,
sepa&acirc; <br>
rated by commas. For example:</p>

<p style="margin-top: 1em">http://example.com/hello
type</p>

<p style="margin-top: 1em">foo</p>

<p style="margin-top: 1em">foo,iterator</p>

<p style="margin-top: 1em">foo,const,iterator</p>

<p style="margin-top: 1em">The following set of predefined
regular expressions is used to transform type names when the
upper-camel-case naming convention is selected:</p>

<p style="margin-top: 1em">/(?:[^ ]* )?([^,]+)/$1/</p>

<p style="margin-top: 1em">/(?:[^ ]*
)?([^,]+),([^,]+)/$1$2/</p>

<p style="margin-top: 1em">/(?:[^ ]*
)?([^,]+),([^,]+),([^,]+)/$1$2$3/</p>

<p style="margin-top: 1em">/(?:[^ ]*
)?([^,]+),([^,]+),([^,]+),([^,]+)/$1$2$3$4/</p>

<p style="margin-top: 1em">The accessor and modifier
expressions (--*accessor-regex and --*modifier-regex) are
evaluated on the name string that has the following
format:</p>

<p style="margin-top: 1em">name[,name][,name]</p>

<p style="margin-top: 1em">After the initial name
component, up to two additional name components can be
present, separated by commas. For example:</p>

<p style="margin-top: 1em">foo</p>

<p style="margin-top: 1em">dom,document</p>

<p style="margin-top: 1em">foo,default,value</p>

<p style="margin-top: 1em">The following set of predefined
regular expressions is used to transform accessor names when
the java naming convention is selected:</p>

<p style="margin-top: 1em">/([^,]+)/get$1/</p>

<p style="margin-top: 1em">/([^,]+),([^,]+)/get$1$2/</p>


<p style="margin-top: 1em">/([^,]+),([^,]+),([^,]+)/get$1$2$3/</p>

<p style="margin-top: 1em">For the parser, serializer, and
enumerator categories, the corresponding regular expressions
are evaluated on local names of elements and on enumeration
values, respectively. For <br>
example, the following predefined regular expression is used
to transform parsing function names when the java naming
convention is selected:</p>

<p style="margin-top: 1em">/(.+)/parse$1/</p>

<p style="margin-top: 1em">The const category is used to
create C++ constant names for the element/wildcard/text
content ids in ordered types.</p>

<p style="margin-top: 1em">See also the REGEX AND SHELL
QUOTING section below.</p>

<p style="margin-top: 1em">TYPE MAP <br>
Type map files are used in C++/Parser to define a mapping
between XML Schema and C++ types. The compiler uses this
information to determine the return types of post_*
functions <br>
in parser skeletons corresponding to XML Schema types as
well as argument types for callbacks corresponding to
elements and attributes of these types.</p>

<p style="margin-top: 1em">The compiler has a set of
predefined mapping rules that map built-in XML Schema types
to suitable C++ types (discussed below) and all other types
to void. By providing your own <br>
type maps you can override these predefined rules. The
format of the type map file is presented below:</p>

<p style="margin-top: 1em">namespace schema-namespace [
cxx-namespace ] <br>
{ <br>
( include file-name; )* <br>
([ type ] schema-type cxx-ret-type [ cxx-arg-type ]; )* <br>
}</p>

<p style="margin-top: 1em">Both schema-namespace and
schema-type are regex patterns while cxx-namespace,
cxx-ret-type, and cxx-arg-type are regex pattern
substitutions. All names can be optionally enclosed <br>
in &quot; &quot;, for example, to include white-spaces.</p>

<p style="margin-top: 1em">schema-namespace determines XML
Schema namespace. Optional cxx-namespace is prefixed to
every C++ type name in this namespace declaration.
cxx-ret-type is a C++ type name that <br>
is used as a return type for the post_* functions. Optional
cxx-arg-type is an argument type for callback functions
corresponding to elements and attributes of this type. If
cxx- <br>
arg-type is not specified, it defaults to cxx-ret-type if
cxx-ret-type ends with * or &amp; (that is, it is a pointer
or a reference) and const cxx-ret-type&amp; otherwise.
file-name is <br>
a file name either in the &quot; &quot; or &lt; &gt; format
and is added with the #include directive to the generated
code.</p>

<p style="margin-top: 1em">The # character starts a comment
that ends with a new line or end of file. To specify a name
that contains # enclose it in &quot; &quot;. For
example:</p>

<p style="margin-top: 1em">namespace
http://www.example.com/xmlns/my my <br>
{ <br>
include &quot;my.hxx&quot;;</p>

<p style="margin-top: 1em"># Pass apples by value. <br>
# <br>
apple apple;</p>

<p style="margin-top: 1em"># Pass oranges as pointers. <br>
# <br>
orange orange_t*; <br>
}</p>

<p style="margin-top: 1em">In the example above, for the
http://www.example.com/xmlns/my#orange XML Schema type, the
my::orange_t* C++ type will be used as both return and
argument types.</p>

<p style="margin-top: 1em">Several namespace declarations
can be specified in a single file. The namespace declaration
can also be completely omitted to map types in a schema
without a namespace. For <br>
instance:</p>

<p style="margin-top: 1em">include &quot;my.hxx&quot;; <br>
apple apple;</p>

<p style="margin-top: 1em">namespace
http://www.example.com/xmlns/my <br>
{ <br>
orange &quot;const orange_t*&quot;; <br>
}</p>

<p style="margin-top: 1em">The compiler has a number of
predefined mapping rules that can be presented as the
following map files. The string-based XML Schema built-in
types are mapped to either <br>
std::string or std::wstring depending on the character type
selected with the --char-type option (char by default).</p>

<p style="margin-top: 1em">namespace
http://www.w3.org/2001/XMLSchema <br>
{ <br>
boolean bool bool;</p>

<p style="margin-top: 1em">byte &quot;signed char&quot;
&quot;signed char&quot;; <br>
unsignedByte &quot;unsigned char&quot; &quot;unsigned
char&quot;;</p>

<p style="margin-top: 1em">short short short; <br>
unsignedShort &quot;unsigned short&quot; &quot;unsigned
short&quot;;</p>

<p style="margin-top: 1em">int int int; <br>
unsignedInt &quot;unsigned int&quot; &quot;unsigned
int&quot;;</p>

<p style="margin-top: 1em">long &quot;long long&quot;
&quot;long long&quot;; <br>
unsignedLong &quot;unsigned long long&quot; &quot;unsigned
long long&quot;;</p>

<p style="margin-top: 1em">integer &quot;long long&quot;
&quot;long long&quot;;</p>

<p style="margin-top: 1em">negativeInteger &quot;long
long&quot; &quot;long long&quot;; <br>
nonPositiveInteger &quot;long long&quot; &quot;long
long&quot;;</p>

<p style="margin-top: 1em">positiveInteger &quot;unsigned
long long&quot; &quot;unsigned long long&quot;; <br>
nonNegativeInteger &quot;unsigned long long&quot;
&quot;unsigned long long&quot;;</p>

<p style="margin-top: 1em">float float float; <br>
double double double; <br>
decimal double double;</p>

<p style="margin-top: 1em">string std::string; <br>
normalizedString std::string; <br>
token std::string; <br>
Name std::string; <br>
NMTOKEN std::string; <br>
NCName std::string; <br>
ID std::string; <br>
IDREF std::string; <br>
language std::string; <br>
anyURI std::string;</p>

<p style="margin-top: 1em">NMTOKENS
xml_schema::string_sequence; <br>
IDREFS xml_schema::string_sequence;</p>

<p style="margin-top: 1em">QName xml_schema::qname;</p>

<p style="margin-top: 1em">base64Binary
std::auto_ptr&lt;xml_schema::buffer&gt; <br>
std::auto_ptr&lt;xml_schema::buffer&gt;; <br>
hexBinary std::auto_ptr&lt;xml_schema::buffer&gt; <br>
std::auto_ptr&lt;xml_schema::buffer&gt;;</p>

<p style="margin-top: 1em">date xml_schema::date; <br>
dateTime xml_schema::date_time; <br>
duration xml_schema::duration; <br>
gDay xml_schema::gday; <br>
gMonth xml_schema::gmonth; <br>
gMonthDay xml_schema::gmonth_day; <br>
gYear xml_schema::gyear; <br>
gYearMonth xml_schema::gyear_month; <br>
time xml_schema::time; <br>
}</p>

<p style="margin-top: 1em">The last predefined rule maps
anything that wasn&rsquo;t mapped by previous rules to
void:</p>

<p style="margin-top: 1em">namespace .* <br>
{ <br>
.* void void; <br>
}</p>

<p style="margin-top: 1em">When you provide your own type
maps with the --type-map option, they are evaluated first.
This allows you to selectively override predefined
rules.</p>

<p style="margin-top: 1em">REGEX AND SHELL QUOTING <br>
When entering a regular expression argument in the shell
command line it is often necessary to use quoting (enclosing
the argument in &quot; &quot; or &rsquo; &rsquo;) in order
to prevent the shell <br>
from interpreting certain characters, for example, spaces as
argument separators and $ as variable expansions.</p>

<p style="margin-top: 1em">Unfortunately it is hard to
achieve this in a manner that is portable across POSIX
shells, such as those found on GNU/Linux and UNIX, and
Windows shell. For example, if you use &quot; <br>
&quot; for quoting you will get a wrong result with POSIX
shells if your expression contains $. The standard way of
dealing with this on POSIX systems is to use &rsquo; &rsquo;
instead. Unfortu&acirc; <br>
nately, Windows shell does not remove &rsquo; &rsquo; from
arguments when they are passed to applications. As a result
you may have to use &rsquo; &rsquo; for POSIX and &quot;
&quot; for Windows ($ is not <br>
treated as a special character on Windows).</p>

<p style="margin-top: 1em">Alternatively, you can save
regular expression options into a file, one option per line,
and use this file with the --options-file option. With this
approach you don&rsquo;t need to <br>
worry about shell quoting.</p>

<p style="margin-top: 1em">DIAGNOSTICS <br>
If the input file is not a valid W3C XML Schema definition,
xsdcxx will issue diagnostic messages to STDERR and exit
with non-zero exit code.</p>

<p style="margin-top: 1em">BUGS <br>
Send bug reports to the xsd-users@codesynthesis.com mailing
list.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (c) 2005-2014 Code Synthesis Tools CC.</p>

<p style="margin-top: 1em">Permission is granted to copy,
distribute and/or modify this document under the terms of
the GNU Free Documentation License, version 1.2; with no
Invariant Sections, no Front- <br>
Cover Texts and no Back-Cover Texts. Copy of the license can
be obtained from
http://codesynthesis.com/licenses/fdl-1.2.txt</p>

<p style="margin-top: 1em">XSDCXX 4.0.0 July 2014
XSDCXX(1)</p>
<hr>
</body>
</html>
