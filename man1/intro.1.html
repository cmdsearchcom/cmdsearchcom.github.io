<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:18:50 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>INTRO(1) Linux User&rsquo;s Manual INTRO(1)</p>

<p style="margin-top: 1em">NAME <br>
intro - introduction to user commands</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Section 1 of the manual describes user commands and tools,
for example, file manipulation tools, shells, compilers, web
browsers, file and image viewers and editors, and so on.</p>

<p style="margin-top: 1em">All commands yield a status
value on termination. This value can be tested (e.g., in
most shells the variable $? contains the status of the last
executed command) to see <br>
whether the command completed successfully. A zero exit
status is conventionally used to indicate success, and a
nonzero status means that the command was unsuccessful. <br>
(Details of the exit status can be found in wait(2).) A
nonzero exit status can be in the range 1 to 255, and some
commands use different nonzero status values to indicate the
<br>
reason why the command failed.</p>

<p style="margin-top: 1em">NOTES <br>
Linux is a flavor of UNIX, and as a first approximation all
user commands under UNIX work precisely the same under Linux
(and FreeBSD and lots of other UNIX-like systems).</p>

<p style="margin-top: 1em">Under Linux there are GUIs
(graphical user interfaces), where you can point and click
and drag, and hopefully get work done without first reading
lots of documentation. The tra&acirc; <br>
ditional UNIX environment is a CLI (command line interface),
where you type commands to tell the computer what to do.
That is faster and more powerful, but requires finding out
<br>
what the commands are. Below a bare minimum, to get
started.</p>

<p style="margin-top: 1em">Login <br>
In order to start working, you probably first have to login,
that is, give your username and password. See also login(1).
The program login now starts a shell (command inter&acirc;
<br>
preter) for you. In case of a graphical login, you get a
screen with menus or icons and a mouse click will start a
shell in a window. See also xterm(1).</p>

<p style="margin-top: 1em">The shell <br>
One types commands to the shell, the command interpreter. It
is not built-in, but is just a program and you can change
your shell. Everybody has her own favorite one. The <br>
standard one is called sh. See also ash(1), bash(1), csh(1),
zsh(1), chsh(1).</p>

<p style="margin-top: 1em">A session might go like</p>

<p style="margin-top: 1em">knuth login: aeb <br>
Password: ******** <br>
% date <br>
Tue Aug 6 23:50:44 CEST 2002 <br>
% cal <br>
August 2002 <br>
Su Mo Tu We Th Fr Sa <br>
1 2 3 <br>
4 5 6 7 8 9 10 <br>
11 12 13 14 15 16 17 <br>
18 19 20 21 22 23 24 <br>
25 26 27 28 29 30 31</p>

<p style="margin-top: 1em">% ls <br>
bin tel <br>
% ls -l <br>
total 2 <br>
drwxrwxr-x 2 aeb 1024 Aug 6 23:51 bin <br>
-rw-rw-r-- 1 aeb 37 Aug 6 23:52 tel <br>
% cat tel <br>
maja 0501-1136285 <br>
peter 0136-7399214 <br>
% cp tel tel2 <br>
% ls -l <br>
total 3 <br>
drwxr-xr-x 2 aeb 1024 Aug 6 23:51 bin <br>
-rw-r--r-- 1 aeb 37 Aug 6 23:52 tel <br>
-rw-r--r-- 1 aeb 37 Aug 6 23:53 tel2 <br>
% mv tel tel1 <br>
% ls -l <br>
total 3 <br>
drwxr-xr-x 2 aeb 1024 Aug 6 23:51 bin <br>
-rw-r--r-- 1 aeb 37 Aug 6 23:52 tel1 <br>
-rw-r--r-- 1 aeb 37 Aug 6 23:53 tel2 <br>
% diff tel1 tel2 <br>
% rm tel1 <br>
% grep maja tel2 <br>
maja 0501-1136285 <br>
% <br>
and here typing Control-D ended the session. The % here was
the command prompt&acirc;it is the shell&rsquo;s way of
indicating that it is ready for the next command. The prompt
can be cus&acirc; <br>
tomized in lots of ways, and one might include stuff like
username, machine name, current directory, time, and so on.
An assignment PS1=&quot;What next, master? &quot; would
change the <br>
prompt as indicated.</p>

<p style="margin-top: 1em">We see that there are commands
date (that gives date and time), and cal (that gives a
calendar).</p>

<p style="margin-top: 1em">The command ls lists the
contents of the current directory&acirc;it tells you what
files you have. With a -l option it gives a long listing,
that includes the owner and size and date <br>
of the file, and the permissions people have for reading
and/or changing the file. For example, the file
&quot;tel&quot; here is 37 bytes long, owned by aeb and the
owner can read and <br>
write it, others can only read it. Owner and permissions can
be changed by the commands chown and chmod.</p>

<p style="margin-top: 1em">The command cat will show the
contents of a file. (The name is from &quot;concatenate and
print&quot;: all files given as parameters are concatenated
and sent to &quot;standard output&quot;, here <br>
the terminal screen.)</p>

<p style="margin-top: 1em">The command cp (from
&quot;copy&quot;) will copy a file. On the other hand, the
command mv (from &quot;move&quot;) only renames it.</p>

<p style="margin-top: 1em">The command diff lists the
differences between two files. Here there was no output
because there were no differences.</p>

<p style="margin-top: 1em">The command rm (from
&quot;remove&quot;) deletes the file, and be careful! it is
gone. No wastepaper basket or anything. Deleted means
lost.</p>

<p style="margin-top: 1em">The command grep (from
&quot;g/re/p&quot;) finds occurrences of a string in one or
more files. Here it finds Maja&rsquo;s telephone number.</p>

<p style="margin-top: 1em">Pathnames and the current
directory <br>
Files live in a large tree, the file hierarchy. Each has a
pathname describing the path from the root of the tree
(which is called /) to the file. For example, such a full
<br>
pathname might be /home/aeb/tel. Always using full pathnames
would be inconvenient, and the name of a file in the current
directory may be abbreviated by giving only the last <br>
component. That is why &quot;/home/aeb/tel&quot; can be
abbreviated to &quot;tel&quot; when the current directory is
&quot;/home/aeb&quot;.</p>

<p style="margin-top: 1em">The command pwd prints the
current directory.</p>

<p style="margin-top: 1em">The command cd changes the
current directory. Try &quot;cd /&quot; and &quot;pwd&quot;
and &quot;cd&quot; and &quot;pwd&quot;.</p>

<p style="margin-top: 1em">Directories <br>
The command mkdir makes a new directory.</p>

<p style="margin-top: 1em">The command rmdir removes a
directory if it is empty, and complains otherwise.</p>

<p style="margin-top: 1em">The command find (with a rather
baroque syntax) will find files with given name or other
properties. For example, &quot;find . -name tel&quot; would
find the file &quot;tel&quot; starting in the <br>
present directory (which is called &quot;.&quot;). And
&quot;find / -name tel&quot; would do the same, but starting
at the root of the tree. Large searches on a multi-GB disk
will be time-consum&acirc; <br>
ing, and it may be better to use locate(1).</p>

<p style="margin-top: 1em">Disks and filesystems <br>
The command mount will attach the file system found on some
disk (or floppy, or CDROM or so) to the big file system
hierarchy. And umount detaches it again. The command df will
<br>
tell you how much of your disk is still free.</p>

<p style="margin-top: 1em">Processes <br>
On a UNIX system many user and system processes run
simultaneously. The one you are talking to runs in the
foreground, the others in the background. The command ps
will show <br>
you which processes are active and what numbers these
processes have. The command kill allows you to get rid of
them. Without option this is a friendly request: please go
away. <br>
And &quot;kill -9&quot; followed by the number of the
process is an immediate kill. Foreground processes can often
be killed by typing Control-C.</p>

<p style="margin-top: 1em">Getting information <br>
There are thousands of commands, each with many options.
Traditionally commands are documented on man pages, (like
this one), so that the command &quot;man kill&quot; will
document the <br>
use of the command &quot;kill&quot; (and &quot;man man&quot;
document the command &quot;man&quot;). The program man sends
the text through some pager, usually less. Hit the space bar
to get the next page, <br>
hit q to quit.</p>

<p style="margin-top: 1em">In documentation it is customary
to refer to man pages by giving the name and section number,
as in man(1). Man pages are terse, and allow you to find
quickly some forgotten <br>
detail. For newcomers an introductory text with more
examples and explanations is useful.</p>

<p style="margin-top: 1em">A lot of GNU/FSF software is
provided with info files. Type &quot;info info&quot; for an
introduction on the use of the program &quot;info&quot;.</p>

<p style="margin-top: 1em">Special topics are often treated
in HOWTOs. Look in /usr/share/doc/howto/en and use a browser
if you find HTML files there.</p>

<p style="margin-top: 1em">SEE ALSO <br>
standards(7)</p>

<p style="margin-top: 1em">COLOPHON <br>
This page is part of release 3.53 of the Linux man-pages
project. A description of the project, and information about
reporting bugs, can be found at <br>
http://www.kernel.org/doc/man-pages/.</p>

<p style="margin-top: 1em">Linux 2007-11-15 INTRO(1)</p>
<hr>
</body>
</html>
