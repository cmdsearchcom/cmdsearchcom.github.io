<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:45:00 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>ZSH-LOVERS(1) ZSH-LOVERS(1)</p>

<p style="margin-top: 1em">NAME <br>
zsh-lovers - tips, tricks and examples for the Z shell</p>

<p style="margin-top: 1em">SYNOPSIS <br>
Just read it. ;-)</p>

<p style="margin-top: 1em">OVERVIEW <br>
Whenever we look at the zsh manual we wonder why there are
no examples or those simply things in (shell) life. The zsh
contains many features, but there was no manpage with some
<br>
examples (like procmailex(5)). That&acirc;s why we wrote
this manpage.</p>

<p style="margin-top: 1em">Most of the tricks and oneliner
come from the mailinglists zsh-users, zsh-workers, google,
newsgroups and from ourself. See section LINKS for
details.</p>

<p style="margin-top: 1em">Note: This manpage
(zsh-lovers(1)) is not an offical part of the Z shell!
It&acirc;s just a just for fun - manpage ;) For comments,
bugreports and feedback take a quick look at the <br>
section BUGS.</p>

<p style="margin-top: 1em">SHELL-SCRIPTING <br>
This section provides some examples for often needed
shellscript-stuff. Notice that you should not use otherwise
most examples won&acirc;t work. Parse options in
shellscripts. Example <br>
taken from ZWS by Adam Chodorowski
(http://www.chodorowski.com/projects/zws/):</p>

<p style="margin-top: 1em">parse_options() <br>
{ <br>
o_port=(-p 9999) <br>
o_root=(-r WWW) <br>
o_log=(-d ZWS.log)</p>

<p style="margin-top: 1em">zparseopts -K -- p:=o_port
r:=o_root l:=o_log h=o_help <br>
if [[ $? != 0 || &quot;$o_help&quot; != &quot;&quot; ]];
then <br>
echo Usage: $(basename &quot;$0&quot;) &quot;[-p PORT] [-r
DIRECTORY]&quot; <br>
exit 1 <br>
fi</p>

<p style="margin-top: 1em">port=$o_port[2] <br>
root=$o_root[2] <br>
log=$o_log[2]</p>

<p style="margin-top: 1em">if [[ $root[1] !=
&rsquo;/&rsquo; ]]; then root=&quot;$PWD/$root&quot;; fi
<br>
} <br>
# now use the function: <br>
parse_options $*</p>

<p style="margin-top: 1em">EXAMPLES <br>
Available subsections are Aliases, Completion, Unsorted/Misc
examples, (Recursive) Globbing - Examples, Modifiers usage,
Redirection-Examples, ZMV-Examples and Module-Examples.</p>

<p style="margin-top: 1em">ALIASES <br>
Suffix aliases are supported in zsh since version 4.2.0.
Some examples:</p>

<p style="margin-top: 1em">alias -s tex=vim <br>
alias -s html=w3m <br>
alias -s org=w3m</p>

<p style="margin-top: 1em">Now pressing return-key after
entering foobar.tex starts vim with foobar.tex. Calling a
html-file runs browser w3m. www.zsh.org and pressing enter
starts w3m with argument <br>
www.zsh.org. Global aliases can be used anywhere in the
command line. Example:</p>

<p style="margin-top: 1em">$ alias -g C=&rsquo;| wc
-l&rsquo; <br>
$ grep alias ~/.zsh/* C <br>
443</p>

<p style="margin-top: 1em">Some more or less useful global
aliases (choose whether they are useful or not for you on
your own):</p>

<p style="margin-top: 1em">alias -g ...=&rsquo;../..&rsquo;
<br>
alias -g ....=&rsquo;../../..&rsquo; <br>
alias -g .....=&rsquo;../../../..&rsquo; <br>
alias -g CA=&quot;2&gt;&amp;1 | cat -A&quot; <br>
alias -g C=&rsquo;| wc -l&rsquo; <br>
alias -g D=&quot;DISPLAY=:0.0&quot; <br>
alias -g DN=/dev/null <br>
alias -g ED=&quot;export DISPLAY=:0.0&quot; <br>
alias -g EG=&rsquo;|&amp; egrep&rsquo; <br>
alias -g EH=&rsquo;|&amp; head&rsquo; <br>
alias -g EL=&rsquo;|&amp; less&rsquo; <br>
alias -g ELS=&rsquo;|&amp; less -S&rsquo; <br>
alias -g ETL=&rsquo;|&amp; tail -20&rsquo; <br>
alias -g ET=&rsquo;|&amp; tail&rsquo; <br>
alias -g F=&rsquo; | fmt -&rsquo; <br>
alias -g G=&rsquo;| egrep&rsquo; <br>
alias -g H=&rsquo;| head&rsquo; <br>
alias -g HL=&rsquo;|&amp; head -20&rsquo; <br>
alias -g Sk=&quot;*~(*.bz2|*.gz|*.tgz|*.zip|*.z)&quot; <br>
alias -g LL=&quot;2&gt;&amp;1 | less&quot; <br>
alias -g L=&quot;| less&quot; <br>
alias -g LS=&rsquo;| less -S&rsquo; <br>
alias -g MM=&rsquo;| most&rsquo; <br>
alias -g M=&rsquo;| more&rsquo; <br>
alias -g NE=&quot;2&gt; /dev/null&quot; <br>
alias -g NS=&rsquo;| sort -n&rsquo; <br>
alias -g NUL=&quot;&gt; /dev/null 2&gt;&amp;1&quot; <br>
alias -g PIPE=&rsquo;|&rsquo; <br>
alias -g R=&rsquo; &gt; /c/aaa/tee.txt &rsquo; <br>
alias -g RNS=&rsquo;| sort -nr&rsquo; <br>
alias -g S=&rsquo;| sort&rsquo; <br>
alias -g TL=&rsquo;| tail -20&rsquo; <br>
alias -g T=&rsquo;| tail&rsquo; <br>
alias -g US=&rsquo;| sort -u&rsquo; <br>
alias -g VM=/var/log/messages <br>
alias -g X0G=&rsquo;| xargs -0 egrep&rsquo; <br>
alias -g X0=&rsquo;| xargs -0&rsquo; <br>
alias -g XG=&rsquo;| xargs egrep&rsquo; <br>
alias -g X=&rsquo;| xargs&rsquo;</p>

<p style="margin-top: 1em">COMPLETION <br>
See also man 1 zshcompctl zshcompsys zshcompwid. zshcompctl
is the old style of zsh programmable completion, zshcompsys
is the new completion system, zshcompwid are the zsh <br>
completion widgets.</p>

<p style="margin-top: 1em">Some functions, like _apt and
_dpkg, are very slow. You can use a cache in order to proxy
the list of results (like the list of available debian
packages) Use a cache:</p>

<p style="margin-top: 1em">zstyle
&rsquo;:completion:*&rsquo; use-cache on <br>
zstyle &rsquo;:completion:*&rsquo; cache-path
~/.zsh/cache</p>

<p style="margin-top: 1em">Prevent CVS files/directories
from being completed:</p>

<p style="margin-top: 1em">zstyle
&rsquo;:completion:*:(all-|)files&rsquo; ignored-patterns
&rsquo;(|*/)CVS&rsquo; <br>
zstyle &rsquo;:completion:*:cd:*&rsquo; ignored-patterns
&rsquo;(*/)#CVS&rsquo;</p>

<p style="margin-top: 1em">Fuzzy matching of completions
for when you mistype them:</p>

<p style="margin-top: 1em">zstyle
&rsquo;:completion:*&rsquo; completer _complete _match
_approximate <br>
zstyle &rsquo;:completion:*:match:*&rsquo; original only
<br>
zstyle &rsquo;:completion:*:approximate:*&rsquo; max-errors
1 numeric</p>

<p style="margin-top: 1em">And if you want the number of
errors allowed by _approximate to increase with the length
of what you have typed so far:</p>

<p style="margin-top: 1em">zstyle -e
&rsquo;:completion:*:approximate:*&rsquo; max-errors
&rsquo;reply=($((($#PREFIX+$#SUFFIX)/3))numeric)&rsquo;</p>

<p style="margin-top: 1em">Ignore completion functions for
commands you don&acirc;t have:</p>

<p style="margin-top: 1em">zstyle
&rsquo;:completion:*:functions&rsquo; ignored-patterns
&rsquo;_*&rsquo;</p>

<p style="margin-top: 1em">With helper functions like:</p>

<p style="margin-top: 1em">xdvi() { command xdvi
${*:-*.dvi(om[1])} }</p>

<p style="margin-top: 1em">you can avoid having to complete
at all in many cases, but if you do, you might want to fall
into menu selection immediately and to have the words sorted
by time:</p>

<p style="margin-top: 1em">zstyle
&rsquo;:completion:*:*:xdvi:*&rsquo; menu yes select <br>
zstyle &rsquo;:completion:*:*:xdvi:*&rsquo; file-sort
time</p>

<p style="margin-top: 1em">Completing process IDs with menu
selection:</p>

<p style="margin-top: 1em">zstyle
&rsquo;:completion:*:*:kill:*&rsquo; menu yes select <br>
zstyle &rsquo;:completion:*:kill:*&rsquo; force-list
always</p>

<p style="margin-top: 1em">If you end up using a directory
as argument, this will remove the trailing slash (usefull in
ln)</p>

<p style="margin-top: 1em">zstyle
&rsquo;:completion:*&rsquo; squeeze-slashes true</p>

<p style="margin-top: 1em">cd will never select the parent
directory (e.g.: cd ../&lt;TAB&gt;):</p>

<p style="margin-top: 1em">zstyle
&rsquo;:completion:*:cd:*&rsquo; ignore-parents parent
pwd</p>

<p style="margin-top: 1em">Another method for quick change
directories. Add this to your ~/.zshrc, then just enter
&acirc;cd ..../dir&acirc;</p>

<p style="margin-top: 1em">rationalise-dot() { <br>
if [[ $LBUFFER = *.. ]]; then <br>
LBUFFER+=/.. <br>
else <br>
LBUFFER+=. <br>
fi <br>
} <br>
zle -N rationalise-dot <br>
bindkey . rationalise-dot</p>

<p style="margin-top: 1em">UNSORTED/MISC examples <br>
Hint: A list of valid glob Qualifiers can be found in
zshexpn(1). See &acirc;man 1 zshexpn | less -p&acirc;
Qualifiers for details.</p>

<p style="margin-top: 1em"># Get the names of all files
that *don&rsquo;t* match a pattern *anywhere* on the <br>
# file (and without &lsquo;&lsquo;-L&rsquo;&rsquo; because
its GNUish) <br>
$ print -rl -- *(.^e{&rsquo;grep -q pattern $REPLY&rsquo;})
<br>
# or <br>
$ : *(.e{&rsquo;grep -q pattern $REPLY || print -r --
$REPLY&rsquo;})</p>

<p style="margin-top: 1em"># random numbers <br>
$ echo $[${RANDOM}%1000] # random between 0-999 <br>
$ echo $[${RANDOM}%11+10] # random between 10-20 <br>
$ echo ${(l:3::0:)${RANDOM}} # N digits long (3 digits)</p>

<p style="margin-top: 1em"># reverse a word <br>
$ echo &quot;${(j::)${(@Oa)${(s::):-hello}}}&quot;</p>

<p style="margin-top: 1em"># Show newest directory <br>
$ ls -ld *(/om[1])</p>

<p style="margin-top: 1em"># random array element <br>
$ FILES=( .../files/* ) <br>
$ feh $FILES[$RANDOM%$#FILES+1]</p>

<p style="margin-top: 1em"># cat first line in all files in
this dir <br>
$ for file (*(ND-.)) IFS= read -re &lt; $file</p>

<p style="margin-top: 1em"># test if a parameter is numeric
<br>
$ if [[ $1 == &lt;-&gt; ]] ; then <br>
echo numeric <br>
else <br>
echo non-numeric <br>
fi</p>

<p style="margin-top: 1em"># Show me all the .c files for
which there doesn&rsquo;t exist a .o file. <br>
$ print *.c(e_&rsquo;[[ ! -e $REPLY:r.o ]]&rsquo;_)</p>

<p style="margin-top: 1em"># All files in /var/ that are
not owned by root <br>
$ ls -ld /var/*(^u:root)</p>

<p style="margin-top: 1em"># All files for which the owner
hat read and execute permissions <br>
$ echo *(f:u+rx:)</p>

<p style="margin-top: 1em"># The same, but also others dont
have execute permissions <br>
$ echo *(f:u+rx,o-x:)</p>

<p style="margin-top: 1em"># brace expansion - example <br>
$ X=(A B C) <br>
$ Y=(+ -) <br>
$ print -r -- $^X.$^Y <br>
A.+ A.- B.+ B.- C.+ C.-</p>

<p style="margin-top: 1em"># Fetch the newest file
containing the string &rsquo;fgractg*.log&rsquo; in the <br>
# filename and contains the string &rsquo;ORA-&rsquo; in it
<br>
$ file=(fgractg*.log(Nm0om[1])) <br>
$ (($#file)) &amp;&amp; grep -l ORA- $file <br>
# without Zsh <br>
$ files=$( find . -name . -o -prune -name
&rsquo;fgractg*&gt;log&rsquo; -mtime 0 -print ) <br>
&gt; if [ -n &quot;$files&quot; ]; then <br>
&gt; IFS=&rsquo; <br>
&gt; &rsquo; <br>
&gt; set -f <br>
&gt; file=$(ls -td $files | head -1) <br>
&gt; grep -l ORA- &quot;$file&quot; <br>
&gt; fi</p>

<p style="margin-top: 1em"># keep specified number of child
processes running until entire task finished <br>
$ zsh -c &rsquo;sleep 1 &amp; sleep 3 &amp; sleep 2&amp;
print -rl -- $jobtexts&rsquo;</p>

<p style="margin-top: 1em"># Remove zero length and .bak
files in a directory <br>
$ rm -i *(.L0) *.bak(.)</p>

<p style="margin-top: 1em"># print out files that dont have
extensions <br>
$ printf &rsquo;%s0 ^?*.* <br>
$ printf &rsquo;%s0 ^?*.[^.]*(D) <br>
$ ls -d -- ^?*.*(D)</p>

<p style="margin-top: 1em"># Finding files which does not
contain a specific string <br>
$ print -rl file* | comm -2 -3 - &lt;(grep -l string
file*)&rsquo; <br>
$ for f (file*(N)) grep -q string $f || print -r
$f&rsquo;</p>

<p style="margin-top: 1em"># Show/Check whether a option is
set or not. It works both with $options as <br>
# with $builtins <br>
$ echo $options[correct] <br>
off <br>
$ $options[zle] <br>
on</p>

<p style="margin-top: 1em"># Count the number of
directories on the stack <br>
$ print $((${${(z)${(f)&quot;$(dirs -v)&quot;}[-1]}[1]} +
1)) # or <br>
$ dirs -v | awk &rsquo;{n=$1}END{print n+1}&rsquo;</p>

<p style="margin-top: 1em"># Matching all files which do
not have a dot in filename <br>
$ ls *~*.*(.)</p>

<p style="margin-top: 1em"># Show only the ip-address from
&lsquo;&lsquo;ifconfig device&rsquo;&rsquo; <br>
# ifconfig from net-tools (Linux) <br>
$ print ${${$(LC_ALL=C /sbin/ifconfig eth0)[7]}:gs/addr://}
<br>
# ifconfig from 4.2BSD {Free,Net,Open}BSD <br>
$ print ${$(/sbin/ifconfig tun0)[6]}</p>

<p style="margin-top: 1em"># Ping all the IP addresses in a
couple of class C&rsquo;s or all hosts <br>
# into /etc/hosts <br>
$ for i in {1..254}; do ping -c 1 192.168.13.$i; done <br>
or <br>
$ I=1 <br>
$ while ( [[ $I -le 255 ]] ) ; do ping -1 2 150.150.150.$I;
let I++; done <br>
or <br>
$ for i in $(sed &rsquo;s/#.*//&rsquo; &gt; /etc/hosts | awk
&rsquo;{print $2}&rsquo;) <br>
: do <br>
: echo &quot;Trying $i ... &quot; <br>
: ping -c 1 $i ; <br>
: echo &rsquo;=============================&rsquo; <br>
: done</p>

<p style="margin-top: 1em"># load all available modules at
startup <br>
$ typeset -U m <br>
$ m=() <br>
$ for md ($module_path) m=($m
$md/**/*(*e:&rsquo;REPLY=${REPLY#$md/}&rsquo;::r)) <br>
$ zmodload -i $m</p>

<p style="margin-top: 1em"># Rename all files within a
directory such that their names get a numeral <br>
# prefix in the default sort order. <br>
$ i=1; for j in *; do mv $j $i.$j; ((i++)); done <br>
$ i=1; for f in *; do mv $f $(echo $i | awk &rsquo;{
printf(&quot;%03d&quot;, $0)}&rsquo;).$f; ((i++)); done <br>
$ integer i=0; for f in *; do mv $f $[i+=1].$f; done</p>

<p style="margin-top: 1em"># Find (and print) all symbolic
links without a target within the current <br>
# dirtree. <br>
$ $ file **/*(D@) | fgrep broken <br>
$ for i in **/*(D@); [[ -f $i || -d $i ]] || echo $i <br>
$ echo **/*(@-^./=%p) <br>
$ print -l **/*(-@)</p>

<p style="margin-top: 1em"># List all plain files that do
not have extensions listed in &lsquo;fignore&rsquo; <br>
$ ls **/*~*(${~${(j/|/)fignore}})(.) <br>
# see above, but now omit executables <br>
$ ls **/*~*(${~${(j/|/)fignore}})(.^*)</p>

<p style="margin-top: 1em"># Print out files that dont have
extensions (require *setopt extendedglob* <br>
# and *setopt dotglob*) <br>
$ printf &rsquo;%s0 ^?*.*</p>

<p style="margin-top: 1em"># List files in reverse order
sorted by name <br>
$ print -rl -- *(On) <br>
or <br>
$ print -rl -- *(^on)</p>

<p style="margin-top: 1em"># Synonymic to &lsquo;&lsquo;ps
ax | awk &rsquo;{print $1}&rsquo;&rsquo;&rsquo; <br>
$ print -l /proc/*/cwd(:h:t:s/self//)</p>

<p style="margin-top: 1em"># Get the PID of a process
(without &lsquo;&lsquo;ps&rsquo;&rsquo;,
&lsquo;&lsquo;sed&rsquo;&rsquo;,
&lsquo;&lsquo;pgrep&rsquo;&rsquo;, .. <br>
# (under Linux) <br>
$ pid2 () { <br>
&gt; local i <br>
&gt; for i in /proc/&lt;-&gt;/stat <br>
&gt; do <br>
&gt; [[ &quot;$(&lt; $i)&quot; = *{(j:|:)~@})* ]] &amp;&amp;
echo $i:h:t <br>
&gt; done <br>
&gt; }</p>

<p style="margin-top: 1em"># for X in &rsquo;n&rsquo;
&rsquo;o&rsquo; &rsquo;p&rsquo; &rsquo;q&rsquo;
&rsquo;r&rsquo; &rsquo;s&rsquo; &rsquo;t&rsquo;
&rsquo;u&rsquo; &rsquo;v&rsquo; &rsquo;w&rsquo;
&rsquo;x&rsquo; &rsquo;y&rsquo;; do ... <br>
$ for (( i = 36#n; i &lt;= 36#y; i++ )); do <br>
&gt; print ${$(([##36]i)):l} <br>
&gt; done <br>
# or in combination with &lsquo;&lsquo;dc&rsquo;&rsquo; <br>
$ print {$((##n))..$((##y))}P&nbsp;10P | dc <br>
# or with &lsquo;&lsquo;eval&rsquo;&rsquo; <br>
$ eval print
&rsquo;${$(([##36]&rsquo;{$((36#n))..$((36#y))}&rsquo;)):l}&rsquo;</p>

<p style="margin-top: 1em"># foreach in one line of shell
<br>
$ for f (*) print -r -- $f</p>

<p style="margin-top: 1em"># copy a directory recursively
without data/files <br>
$ dirs=(**/*(/)) <br>
$ cd -- $dest_root <br>
$ mkdir -p -- $dirs <br>
# or without zsh <br>
$ find . -type d -exec env d=&quot;$dest_root&quot; sh -c
&rsquo; exec mkdir -p -- &quot;$d/$1&quot;&rsquo;
&rsquo;{}&rsquo; &rsquo;{}&rsquo; ;</p>

<p style="margin-top: 1em"># If
&lsquo;foo=23&rsquo;&rsquo;, then print with 10 digit with
leading &rsquo;0&rsquo;. <br>
$ foo=23 <br>
$ print ${(r:10::0:)foo}</p>

<p style="margin-top: 1em"># find the name of all the files
in their home directory that have <br>
# more than 20 characters in their file names <br>
print -rl $HOME/${(l:20::?:)~:-}*</p>

<p style="margin-top: 1em"># Save arrays <br>
$ print -r -- ${(qq)m} &gt; $nameoffile # save it <br>
$ eval &quot;m=($(cat -- $nameoffile)&quot; # or use <br>
$ m=(&quot;${(@Q)${(z)&quot;$(cat --
$nameoffile)&quot;}}&quot;) # to restore it</p>

<p style="margin-top: 1em"># get a &quot;ls -l&quot; on all
the files in the tree that are younger than a <br>
# specified age (e.g &quot;ls -l&quot; all the files in the
tree that where <br>
# modified in the last 2 days) <br>
$ ls -tld **/*(m-2) <br>
# This will give you a listing 1 file perl line (not
&Atilde;&nbsp; la ls -R). <br>
# Think of an easy way to have a &quot;ls -R&quot; style
output with <br>
# only files newer than 2 day old. <br>
$ for d (. ./**/*(/)) { <br>
&gt; print -r -- $&rsquo;0${d}: <br>
&gt; cd $d &amp;&amp; { <br>
&gt; l=(*(Nm-2)) <br>
&gt; (($#l)) &amp;&amp; ls -ltd -- $l <br>
&gt; cd ~- <br>
&gt; } <br>
&gt; } <br>
# If you also want directories to be included even if their
mtime <br>
# is more than 2 days old: <br>
$ for d (. ./**/*(/)) { <br>
&gt; print -r -- $&rsquo;0${d}: <br>
&gt; cd $d &amp;&amp; { <br>
&gt; l=(*(N/,m-2)) <br>
&gt; (($#l)) &amp;&amp; ls -ltd -- $l <br>
&gt; cd ~- <br>
&gt; } <br>
&gt; } <br>
# And if you want only the directories with mtime &lt; 2
days to be listed: <br>
$ for d (. ./**/*(N/m-2)) { <br>
&gt; print -r -- $&rsquo;0${d}: <br>
&gt; cd $d &amp;&amp; { <br>
&gt; l=(*(Nm-2)) <br>
&gt; (($#l)) &amp;&amp; ls -ltd -- $l <br>
&gt; cd ~- <br>
&gt; } <br>
&gt; }</p>

<p style="margin-top: 1em"># print 42
&lsquo;&lsquo;-&rsquo;&rsquo; <br>
$ echo ${(l:42::-:)} <br>
# or use &lsquo;&lsquo;$COLUMS&rsquo;&rsquo; <br>
$ echo ${(l:$COLUMNS::-:)} <br>
# and now with colors (require autoload colors ;colors) <br>
$ echo &quot;$bg[red]$fg[black]${(l:42::-:)}&quot;</p>

<p style="margin-top: 1em"># Redirect STDERR to a command
like xless without redirecting STDOUT as well. <br>
$ foo 2&gt;&gt;(xless) <br>
# but this executes the command asynchronously. To do it
synchronously: <br>
$ { { foo 1&gt;&amp;3 } 2&gt;&amp;1 | xless }
3&gt;&amp;1</p>

<p style="margin-top: 1em"># Rename all MP3-Files from name
with spaces.mp3 to Name With Spaces.mp3 <br>
$ for i in *.mp3; do <br>
&gt; mv $i ${${(C)i}:s/Mp3/mp3/} <br>
&gt; done</p>

<p style="margin-top: 1em"># Match file names containing
only digits and ending with .xml (require <br>
# *setopt kshglob*) <br>
$ ls -l [0-9]##.xml <br>
$ ls -l &lt;0-&gt;.xml</p>

<p style="margin-top: 1em"># Remove all &quot;non txt&quot;
files <br>
$ rm ./^*.txt</p>

<p style="margin-top: 1em"># Move 200 files from a
directory into another <br>
$ mv -- *([1,200]) /another/Dir</p>

<p style="margin-top: 1em"># Convert images (foo.gif =&gt;
foo.png): <br>
$ for i in **/*.gif; convert $i $i:r.png</p>

<p style="margin-top: 1em"># convert a collection of mp3
files to wave or cdr, <br>
# e.g. file.wav -&gt; file.mp3) <br>
$ for i (./*.mp3){mpg321 --w - $i &gt; ${i:r}.wav}</p>

<p style="margin-top: 1em"># Download with LaTeX2HTML
created Files (for example the ZSH-Guide): <br>
$ for f in
http://zsh.sunsite.dk/Guide/zshguide{,{01..08}}.html; do
<br>
&gt; lynx -source $f &gt;${f:t} <br>
&gt; done</p>

<p style="margin-top: 1em"># Move all files in dir1 and
dir2 that have line counts greater than 10 to <br>
# another directory say &quot;/more10&quot; <br>
$ mv dir[12]/**/*.cr(-.e{&rsquo;((&lsquo;wc -l &lt;
$REPLY&lsquo; &gt; 10))&rsquo;}) /more10</p>

<p style="margin-top: 1em"># Make with dpkg a master-list
of everyfile that it has installed <br>
$ diff &lt;(find / | sort) &lt;(cat
/var/lib/dpkg/info/*.list | sort)</p>

<p style="margin-top: 1em"># Replace this fucking
Escape-Sequences: <br>
$ autoload colors ; colors <br>
$ print &quot;$bg[cyan]$fg[blue]You are a idiot&quot;
&gt;&gt; /dev/pts/3</p>

<p style="margin-top: 1em"># Get ASCII value of a character
<br>
$ char=N ; print $((#char))</p>

<p style="margin-top: 1em"># Filename
&quot;Erweiterung&quot; <br>
# Note: The (N) says to use the nullglob option for this
particular <br>
# glob pattern. <br>
$ for i in *.o(N); do <br>
&gt; rm $i <br>
&gt; done</p>

<p style="margin-top: 1em"># Rename files; i. e. FOO to foo
and bar to BAR <br>
$ for i in *(.); mv $i ${i:l} # &lsquo;FOO&rsquo; to
&lsquo;foo&rsquo; <br>
$ for i in *(.); mv $i ${i:u} # &lsquo;bar to
&lsquo;BAR&rsquo;</p>

<p style="margin-top: 1em"># Show all suid-files in $PATH
<br>
$ ls -latg ${(s.:.)PATH} | grep &rsquo;^...s&rsquo; <br>
# or more complex ;) <br>
$ print -l ${^path}/*(Ns,S) <br>
# or show only executables with a user given pattern <br>
$ print -l ${^path}/*vim*(*N)</p>

<p style="margin-top: 1em"># gzip files when containing a
certain string <br>
$ gzip ${(ps: :)&quot;$(grep -lZ foobar
./*.txt(.))&quot;}</p>

<p style="margin-top: 1em"># A small one-liner, that reads
from stdin and prints to stdout the first <br>
# unique line i. e. does not print lines that have been
printed before <br>
# (this is similar to the unique command, but unique can
only handle <br>
# adjacent lines). <br>
$ IFS=$&rsquo;0; print -rl -- ${(Oau)${(Oa)$(cat file;echo
.)[1,-2]}}</p>

<p style="margin-top: 1em"># Lists every executable in PATH
<br>
$ print -l ${^path}/*(-*N)</p>

<p style="margin-top: 1em"># Match all .c files in all
subdirectories, _except_ any SCCS subdirectories? <br>
$ ls **/*.c~(*/)#SCCS/*</p>

<p style="margin-top: 1em"># List all &lsquo;README&rsquo;
- files case-insensitive with max. one typo <br>
$ ls **/*(#ia2)readme</p>

<p style="margin-top: 1em"># case insensitive checking for
variables <br>
$ if [[ $OSTYPE == (#i)LINUX*(#I) ]]; then <br>
&gt; echo &quot;Penguin on board.&quot; <br>
&gt; else <br>
&gt; echo &quot;Not a Linux.&quot; <br>
&gt; fi</p>

<p style="margin-top: 1em">(Recursive) Globbing - Examples
<br>
A list of valid glob Qualifiers can be found in zshexpn(1).
Note: **/ is equivalent to (*/)#! For example:</p>

<p style="margin-top: 1em">$ print (*/)#zsh_us.ps <br>
zsh-4.2.3/Doc/zsh_us.ps <br>
$ print **/zsh_us.ps <br>
zsh-4.2.3/Doc/zsh_us.ps</p>

<p style="margin-top: 1em"># Search for
&lsquo;README&rsquo; in all Subdirectories <br>
$ ls -l **/README</p>

<p style="margin-top: 1em"># find directories that contain
both &quot;index.php&quot; and &quot;index.html&quot;, or in
<br>
# general, directories that contain more than one file
matching &quot;index.*&quot; <br>
$ ls **/*(D/e:&rsquo;[[ -e $REPLY/index.php &amp;&amp; -e
$REPLY/index.html ]]&rsquo;:) <br>
# or <br>
$ ls **/*(D/e:&rsquo;l=($REPLY/index.*(N)); (( $#l &gt;= 2
))&rsquo;:)</p>

<p style="margin-top: 1em"># Find command to search for
directory name instead of basename <br>
$ print -rl /**/*~^*/path(|/*) <br>
# or - without Zsh <br>
$ find / | grep -e /path/ -e &rsquo;/path$&rsquo;</p>

<p style="margin-top: 1em"># Print he path of the
directories holding the ten biggest C regular files <br>
# in the current directory and subdirectories. <br>
$ print -rl -- **/*.c(D.OL[1,10]:h) | sort -u</p>

<p style="margin-top: 1em"># Find files with size == 0 and
send a mail <br>
$ files=(**/*(ND.L0m+0m-2)) <br>
&gt; (( $#files &gt; 0 )) &amp;&amp; print -rl -- $files |
mailx -s &quot;empty files&quot; foo@bar.tdl</p>

<p style="margin-top: 1em"># recursive chmod <br>
$ chmod 700 **/(.) # Only files <br>
$ chmod 700 **/(/) # Only directories</p>

<p style="margin-top: 1em"># print out all of the files in
that directory in 2 columns <br>
$ print -rC2 -- ${1:[...]}/*(D:t) <br>
# ^- number ob columns <br>
# or - if you feel concerned about special characters - use
<br>
$ list=(${1:[...]}/*(ND:t)) <br>
$ (($#list)) &amp;&amp; print -rC2 -- ${(V)list}</p>

<p style="margin-top: 1em"># Search all files in
/home/*/*-mail/ with a setting &lsquo;&lsquo;chmod
-s&rsquo;&rsquo; flag <br>
# (recursive, include dotfiles) remove the setgid/setuid
flag and print <br>
# a message <br>
$ chmod -s /home/*/*-mail(DNs,S) /home/*/*-mail/**/*(DNs,S))
<br>
# or with a small script <br>
$ for file (/home/*/*-mail(DNs,S)
/home/*/*-mail/**/*(DNs,S)) { <br>
&gt; print -r -- $file <br>
&gt; chmod -s $file &amp;&amp; print -r fixed $file <br>
&gt; } <br>
# or use &lsquo;&lsquo;zargs&rsquo;&rsquo; (require autoload
zargs) prevent the arg list too <br>
# long error <br>
$ zargs /home/*/*-mail(DNs,S) /home/*/*-mail/**/*(DNs,S)) --
chmod -s</p>

<p style="margin-top: 1em"># List files beginning at
&lsquo;foo23&rsquo; upwards (foo23, foo24, foo25, ..) <br>
$ ls -l foo&lt;23-&gt;</p>

<p style="margin-top: 1em"># get all files that begin with
the date strings from June 4 through <br>
# June 9 of 2004 <br>
$ ls -l 200406{04..10}*(N) <br>
# or if they are of the form 200406XX (require
&lsquo;&lsquo;setopt extended_glob&rsquo;&rsquo; <br>
$ ls -l 200306&lt;4-10&gt;.*</p>

<p style="margin-top: 1em"># remove spaces from filenames
<br>
$ for a in ./**/*&nbsp;*(Dod); do mv $a ${a:h}/${a:t:gs/
/_}; done</p>

<p style="margin-top: 1em"># Show only all *.c and *.h -
Files <br>
$ ls -l *.(c|h)</p>

<p style="margin-top: 1em"># Show only all *.c - files and
ignore &lsquo;foo.c&rsquo; <br>
$ ls *.c~foo.c</p>

<p style="margin-top: 1em"># show data to *really* binary
format <br>
$ zsh -ec &rsquo;while {} {printf %.8x $n;repeat 8 &gt;
{read -ku0 a printf &nbsp;%.8d
$(([##2]#a))};print;((n+=8))}&rsquo; &lt; binary</p>

<p style="margin-top: 1em"># Show only world-readable files
<br>
$ ls -l *(R)</p>

<p style="margin-top: 1em"># List files in the current
directory are not writable by the owner <br>
$ print -l ~/*(ND.^w)</p>

<p style="margin-top: 1em"># find and delete the files
which are older than a given parameter <br>
# (seconds/minutes/hours) <br>
# deletes all regular file in /Dir that are older than 3
hours <br>
$ rm -f /Dir/**/*(.mh+3) <br>
# deletes all symlinks in /Dir that are older than 3 minutes
<br>
$ rm -f /Dir/**/*(@mm+3) <br>
# deletes all non dirs in /Dir that are older than 30
seconds <br>
$ rm -f /Dir/**/*(ms+30^/) <br>
# deletes all folders, sub-folders and files older than one
hour <br>
$ rm ./**/*(.Dmh+1,.DL0) <br>
# deletes all files more than 6 hours old <br>
$ rm -f **/*(mh+6) <br>
# removes all files but the ten newer ones (delete all but
last 10 <br>
# files in a directory) <br>
$ rm ./*(Om[1,-11]) <br>
Note: If you get a arg list too long, you use the builtin
rm. For <br>
example: <br>
$ zmodload zsh/files ; rm -f **/*(mh+6) <br>
or use the zargs function: <br>
$ autoload zargs ; zargs **/*(mh+6) -- rm -f</p>

<p style="margin-top: 1em"># A User&rsquo;s Guide to the
Z-Shell /5.9: Filename Generation and Pattern <br>
# Matching find all files in all subdirectories, searching
recursively, <br>
# which have a given name, case insensitive, are at least 50
KB large, <br>
# no more than a week old and owned by the root user, and
allowing up <br>
# to a single error in the spelling of the name. In fact,
the required <br>
# expression looks like this: <br>
$ ls **/(#ia1)name(LK+50mw-1u0)</p>

<p style="margin-top: 1em"># Change the UID from 102 to 666
<br>
$ chown 666 **/*(u102)</p>

<p style="margin-top: 1em"># List all files which have not
been updated since last 10 hours <br>
$ print -rl -- *(Dmh+10^/)</p>

<p style="margin-top: 1em"># delete only the oldest file in
a directory <br>
$ rm ./*filename*(Om[1])</p>

<p style="margin-top: 1em"># Sort the output from &lsquo;ls
-l&rsquo; by file size <br>
$ ls -fld *(OL)</p>

<p style="margin-top: 1em"># find most recent file in a
directory <br>
$ setopt dotglob ; print directory/**/*(om[1])</p>

<p style="margin-top: 1em"># Show only empty files which
nor &lsquo;group&rsquo; or &lsquo;world writable&rsquo; <br>
$ ls *(L0f.go-w.)</p>

<p style="margin-top: 1em"># Find - and list - the ten
newest files in directories and subdirs. <br>
# (recursive) <br>
$ print -rl -- **/*(Dom[1,10])</p>

<p style="margin-top: 1em"># Print only 5 lines by
&quot;ls&quot; command (like &lsquo;&lsquo;ls -laS | head -n
5&rsquo;&rsquo;). <br>
$ ls -fl *(DOL[1,5])</p>

<p style="margin-top: 1em"># Display the 5-10 last modified
files. <br>
$ print -rl -- /path/to/dir/**/*(D.om[5,10])</p>

<p style="margin-top: 1em"># Find all files without a valid
owner. <br>
$ chmod someuser
/**/*(D^u:${(j.:u:.)${(f)&quot;$(&lt;/etc/passwd)&quot;}%%:*}:)</p>

<p style="margin-top: 1em"># Find all the empty directories
in a tree. <br>
$ for f in ***/*(/l2); do foo=($f/*(N)); [[ -z $foo ]]
&amp;&amp; print $f; done <br>
# Note:Since Zsh 4.2.1 the glob qualifier F indicates a
non-empty directory. <br>
# Hence *(F) indicates all subdirectories with entries,
*(/^F) means all <br>
# subdirectories with no entries. <br>
$ ls -ld *(/^F)</p>

<p style="margin-top: 1em"># Remove empty directories
afterwards. <br>
$ rmdir ./**/*(/od) 2&gt; /dev/null</p>

<p style="margin-top: 1em"># Show only files which are
owned by group &lsquo;users&rsquo;. <br>
$ ls -l *(G[users])</p>

<p style="margin-top: 1em">Modifiers usage <br>
Modifiers are a powerful mechanism that let you modify the
results returned by parameter, filename and history
expansion. See zshexpn(1) for details.</p>

<p style="margin-top: 1em"># NOTE: Zsh 4.3.4 needed! <br>
$ autoload -U age <br>
# files modified today <br>
$ print *(e:age today now:) <br>
# files modified since 5 pm <br>
$ print *(e-age 17:00 now-) <br>
# ... since 5 o&rsquo;clock yesterda <br>
$ print *(e-age yesterday,17:00 now-) <br>
# ... from last Christmas before today <br>
$ print *(e-age 2006/12/25 today-) <br>
# ... before yesterday <br>
$ print *(e-age 1970/01/01 yesterday-) <br>
# all files modified between the start of those dates <br>
$ print *(e:age 2006/10/04 2006/10/09:) <br>
# all files modified on that date <br>
$ print *(e:age 2006/10/04:) <br>
# Supply times. <br>
$ print *(e-age 2006/10/04:10:15 2006/10/04:10:45-)</p>

<p style="margin-top: 1em"># Remove a trailing pathname
component, leaving the head. This works like <br>
# &lsquo;dirname&rsquo;. <br>
$ echo =ls(:h) <br>
/bin</p>

<p style="margin-top: 1em"># Remove all leading pathname
components, leaving the tail. This works <br>
# like &lsquo;basename&rsquo;. <br>
$ echo =ls(:t) <br>
ls</p>

<p style="margin-top: 1em"># Remove the suffix from each
file (*.sh in this example) <br>
$f:e is $f file extension <br>
:h --&gt; head (dirname) <br>
:t --&gt; tail (basename) <br>
:r --&gt; rest (extension removed) <br>
$ for f (*.sh) mv $f $f:r</p>

<p style="margin-top: 1em"># Remove a filename extension of
the form &lsquo;.xxx&rsquo;, leaving the root name. <br>
$ echo $PWD <br>
/usr/src/linux <br>
$ echo $PWD:t <br>
linux</p>

<p style="margin-top: 1em"># Remove all but the extension.
<br>
$ foo=23.42 <br>
$ echo $foo <br>
23.42 <br>
$ echo $foo:e <br>
42</p>

<p style="margin-top: 1em"># Print the new command but do
not execute it. Only works with history <br>
# expansion. <br>
$ echo =ls(:h) <br>
/bin <br>
$ !echo:p <br>
$ echo =ls(:h)</p>

<p style="margin-top: 1em"># Quote the substituted words,
escaping further substitutions. <br>
$ bar=&quot;23&rsquo;42&quot; <br>
$ echo $bar <br>
23&rsquo;42 <br>
$ echo $bar:q <br>
23&acute;42</p>

<p style="margin-top: 1em"># Convert the words to all
lowercase. <br>
$ bar=FOOBAR <br>
$ echo $bar <br>
FOOBAR <br>
$ echo $bar:l <br>
foobar</p>

<p style="margin-top: 1em"># Convert the words to all
uppercase. <br>
$ bar=foobar <br>
$ echo $bar <br>
foobar <br>
$ echo $bar:u <br>
FOOBAR</p>

<p style="margin-top: 1em"># convert 1st char of a word to
uppercase <br>
$ foo=&quot;one two three four&quot; <br>
$ print -r -- &quot;${(C)foo}&quot; <br>
One Two Three Four</p>

<p style="margin-top: 1em">Redirection-Examples <br>
See zshmisc(1) for more informations (or less
${^fpath}/zmv(N))</p>

<p style="margin-top: 1em"># Append &lsquo;exit 1&rsquo; at
the end of all *.sh - files <br>
$ echo &quot;exit 1&quot; &gt;&gt; *.sh</p>

<p style="margin-top: 1em"># adding files to foobar.tar.gz
<br>
$ eval set =(gunzip &lt; foobar.tar.gz) &rsquo; <br>
tar rf $1 additional.txt &amp;&amp;gzip &lt; $1 &gt;
foobar.tar.gz&rsquo;</p>

<p style="margin-top: 1em"># Redirect output to a file AND
display on screen <br>
$ foobar &gt;&amp;1 &gt; file1 &gt; file2 &gt; ..</p>

<p style="margin-top: 1em"># pipe single output to multiple
inputs <br>
$ zcat foobar.Z &gt;&gt; (gzip -9 &gt; file1.gz) &gt;&gt;
(bzip2 -9 &gt; file1.bz2) &gt;&gt; (acb --best &gt;
file1.acb)</p>

<p style="margin-top: 1em"># Append /etc/services at the
end of file &lsquo;foo&rsquo; and &lsquo;bar&rsquo; <br>
$ cat /etc/services &gt;&gt; foo &gt;&gt; bar</p>

<p style="margin-top: 1em"># Pipe STDERR <br>
$ echo An error &gt;&amp;2 2&gt;&amp;1 | sed -e
&rsquo;s/A/I/&rsquo;</p>

<p style="margin-top: 1em"># send standard output of one
process to standard input of several processes <br>
# in the pipeline <br>
$ setopt multios <br>
$ process1 &gt; &gt;(process1) &gt; &gt;(process2)</p>

<p style="margin-top: 1em"># initializing a variable and
simultaneously keeping terminal output <br>
$ setopt multios <br>
$ { a=$(command &gt;&amp;1 &gt;&amp; 3 3 &gt; &amp;-
2&gt;&amp;1);} 3&gt;&amp;1</p>

<p style="margin-top: 1em"># redirect stderr two times <br>
$ setopt multios ; program 2&gt; file2 &gt; file1
2&gt;&amp;1</p>

<p style="margin-top: 1em"># Duplicating stdout and stderr
to a logfile <br>
$ exec 3&gt;&amp;1 &gt; logfile 2&gt;&amp;2 2&gt;&amp;1
&gt;&amp;3 3&gt;&amp;-</p>

<p style="margin-top: 1em"># redirect stderr (only) to a
file and to orig. stderr: <br>
$ command 2&gt;&amp;2 2&gt;stderr <br>
# redirect stderr and stdout to separate files and both to
orig. stdout: <br>
$ command 2&gt;&amp;1 1&gt;&amp;1 2&gt;stderr 1&gt;stdout
<br>
# redirect stderr and stdout to separate files and stdout to
orig. stdout <br>
# AND stderr to orig. stderr: <br>
$ command 2&gt;&amp;2 1&gt;&amp;1 2&gt;stderr
1&gt;stdout</p>

<p style="margin-top: 1em"># More fun with STDERR ;) <br>
$ ./my-script.sh 2&gt; &gt;(grep -v moron
&gt;error.log)|process-output &gt;output.log <br>
$ echo &quot;Thats STDOUT&quot; &gt;&gt;(sed
&rsquo;s/stdout/another example/&rsquo; &gt; foobar)</p>

<p style="margin-top: 1em">ZMV-Examples (require autoload
zmv) <br>
Note: -n means no execution (just print what would happen).
At</p>

<p style="margin-top: 1em"># Remove illegal characters in a
fat32 file system. Illegal characters are <br>
# / : ; * ? &quot; &lt; &gt; | <br>
# NOTE: &lsquo;&lsquo;-Q&rsquo;&rsquo; and (D) is to include
hidden files. <br>
$ unwanted=&rsquo;[:;*? <br>
$ zmv -Q &quot;(**/)(*$~unwanted*)(D)&quot;
&rsquo;$1${2//$~unwanted/}&rsquo;</p>

<p style="margin-top: 1em"># Changing part of a filename
(i. e. &quot;file-hell.name&quot; -&gt;
&quot;file-heaven.name&quot;) <br>
$ zmv &rsquo;(*)hell(*)&rsquo; &rsquo;${1}heaven${2}&rsquo;
<br>
# or <br>
$ zmv &rsquo;*&rsquo; &rsquo;$f:s/hell/heaven/&rsquo;</p>

<p style="margin-top: 1em"># remove round bracket within
filenames <br>
# i. e. foo-(bar).avi -&gt; foo-bar.avi <br>
$ zmv &rsquo;*&rsquo; &rsquo;${f//[()]/}&rsquo;</p>

<p style="margin-top: 1em"># serially all files (foo.foo
&gt; 1.foo, fnord.foo &gt; 2.foo, ..) <br>
$ autoload zmv <br>
$ ls * <br>
1.c asd.foo bla.foo fnord.foo foo.fnord foo.foo <br>
$ c=1 zmv &rsquo;*.foo&rsquo; &rsquo;$((c++)).foo&rsquo;
<br>
$ ls * <br>
1.c 1.foo 2.foo 3.foo 4.foo foo.fnord</p>

<p style="margin-top: 1em"># Rename
&quot;file.with.many.dots.txt&quot; by substituting dots
(exept for the last <br>
# one!) with a space <br>
$ touch {1..20}-file.with.many.dots.txt <br>
$ zmv &rsquo;(*.*)(.*)&rsquo; &rsquo;${1//./ }$2&rsquo;</p>

<p style="margin-top: 1em"># Remove the first 4 chars from
a filename <br>
$ zmv -n &rsquo;*&rsquo; &rsquo;$f[5,-1]&rsquo; # NOTE: The
&quot;5&quot; is NOT a mistake in writing!</p>

<p style="margin-top: 1em"># Rename names of all files
under the current Dir to lower case, but keep <br>
# dirnames as-is. <br>
$ zmv -Qv &rsquo;(**/)(*)(.D)&rsquo;
&rsquo;$1${(L)2}&rsquo;</p>

<p style="margin-top: 1em"># replace all 4th character,
which is &quot;1&quot;, with &quot;2&quot; and so on <br>
$ autoload -U zmv <br>
$ zmv &rsquo;(???)1(???[1-4].txt)&rsquo;
&rsquo;${1}2${2}&rsquo;</p>

<p style="margin-top: 1em"># Remove the first 15 characters
from a string <br>
$ touch 111111111111111{a-z} <br>
$ autoload zmv <br>
$ zmv &rsquo;*&rsquo; &rsquo;$f[16,-1]&rsquo;</p>

<p style="margin-top: 1em"># Replace spaces (any number of
them) with a single dash in file names <br>
$ autload zmv <br>
$ zmv -n &rsquo;(**/)(* *)&rsquo; &rsquo;$1${2//( #-## #|
##)/-}&rsquo; <br>
# or - with Bash <br>
$ find . -depth -name &rsquo;* *&rsquo; -exec bash -c
&rsquo; <br>
&gt; shopt -s extglob <br>
&gt; file=$1 <br>
&gt; dir=${file%/*} <br>
&gt; name=${file##*/} <br>
&gt; newname=${name//*([ -]) *([ -])/-} <br>
&gt; mv -i -- &quot;$file&quot;
&quot;$Dir/$newname&quot;&rsquo; {} {} ;</p>

<p style="margin-top: 1em"># Clean up file names and remove
special characters <br>
$ autoload zmv <br>
$ zmv -n &rsquo;(**/)(*)&rsquo;
&rsquo;$1${2//[^A-Za-z0-9._]/_}&rsquo;</p>

<p style="margin-top: 1em"># Add *.py to a bunch of python
scripts in a directory (some of them end <br>
# in *.py and give them all a proper extension <br>
$ autoload zmv <br>
$ zmv -n &rsquo;(**/)(con*)(#qe,file $REPLY | grep
&quot;python script&quot;,)&rsquo; &rsquo;$1$2.py&rsquo;</p>

<p style="margin-top: 1em"># lowercase all extensions (i.
e. *.JPG) incl. subfolders <br>
$ autoload zmv <br>
$ zmv &rsquo;(**/)(*).(#i)jpg&rsquo; &rsquo;$1$2.jpg&rsquo;
<br>
# Or - without Zsh <br>
$ find Dir -name &rsquo;*.[jJ][pP][gG]&rsquo; -print | while
read f <br>
&gt; do <br>
&gt; case $f in <br>
&gt; *.jpg) ; <br>
&gt; *) mv &quot;$f&quot; &quot;${f%.*}.jpg&quot; ; <br>
&gt; esac <br>
&gt; done</p>

<p style="margin-top: 1em"># remove leading zeros from file
extension <br>
$ autoload zmv <br>
$ ls <br>
filename.001 filename.003 filename.005 filename.007
filename.009 <br>
filename.002 filename.004 filename.006 filename.008
filename.010 <br>
$ zmv &rsquo;(filename.)0##(?*)&rsquo; &rsquo;$1$2&rsquo;
<br>
$ ls <br>
filename.1 filename.10 filename.2 filename.3 filename.4
filename.5 ..</p>

<p style="margin-top: 1em"># renumber files. <br>
$ autoload zmv <br>
$ ls * <br>
foo_10.jpg foo_2.jpg foo_3.jpg foo_4.jpg foo_5.jpg foo_6.jpg
.. <br>
$ zmv -fQ &rsquo;foo_(&lt;0-&gt;).jpg(.nOn)&rsquo;
&rsquo;foo_$(($1 + 1)).jpg&rsquo; <br>
$ ls * <br>
foo_10.jpg foo_11.jpg foo_3.jpg foo_4.jpg foo_5.jpg ...</p>

<p style="margin-top: 1em"># adding leading zeros to a
filename (1.jpg -&gt; 001.jpg, .. <br>
$ autoload zmv <br>
$ zmv &rsquo;(&lt;1-&gt;).jpg&rsquo;
&rsquo;${(l:3::0:)1}.jpg&rsquo;</p>

<p style="margin-top: 1em"># See above, but now only files
with a filename &gt;= 30 chars <br>
$ autoload zmv <br>
$ c=1 zmv &quot;${(l:30-4::?:)}*.foo&quot;
&rsquo;$((c++)).foo&rsquo;</p>

<p style="margin-top: 1em"># Replace spaces in filenames
with a underline <br>
$ autoload zmv <br>
$ zmv &rsquo;* *&rsquo; &rsquo;$f:gs/ /_&rsquo;</p>

<p style="margin-top: 1em"># Change the suffix from *.sh to
*.pl <br>
$ autoload zmv <br>
$ zmv -W &rsquo;*.sh&rsquo; &rsquo;*.pl&rsquo;</p>

<p style="margin-top: 1em"># Add a &quot;&quot;.txt&quot;
extension to all the files within ${HOME} <br>
# &lsquo;&lsquo;-.&rsquo;&rsquo; is to only rename regular
files or symlinks to regular files, <br>
# &lsquo;&lsquo;D&rsquo;&rsquo; is to also rename hidden
files (dotfiles)) <br>
$ autoload zmv <br>
$ zmv -Q &rsquo;/home/**/*(D-.)&rsquo; &rsquo;$f.txt&rsquo;
<br>
# Or to only rename files that don&rsquo;t have an
extension: <br>
$ zmv -Q &rsquo;/home/**/^?*.*(D-.)&rsquo;
&rsquo;$f.txt&rsquo;</p>

<p style="margin-top: 1em"># Recursively change filenames
with characters ? [ ] / = + &lt; &gt; ; : &quot; , - * <br>
$ autoload zmv <br>
$ chars=&rsquo;[][?=+&lt;&gt;;&quot;,*-]&rsquo; <br>
$ zmv &rsquo;(**/)(*)&rsquo;
&rsquo;$1${2//$~chars/%}&rsquo;</p>

<p style="margin-top: 1em"># Removing single quote from
filenames (recursively) <br>
$ autoload zmv <br>
$ zmv -Q &quot;(**/)(*&rsquo;*)(D)&quot;
&quot;2//&rsquo;/}&quot;</p>

<p style="margin-top: 1em"># When a new file arrives (named
file.txt) rename all files in order to <br>
# get (e. g. file119.txt becomes file120.txt, file118.txt
becomes <br>
# file119.txt and so on ending with file.txt becoming
file1.txt <br>
$ autoload zmv <br>
$ zmv -fQ &rsquo;file([0-9]##).txt(On)&rsquo;
&rsquo;file$(($1 + 1)).txt&rsquo;</p>

<p style="margin-top: 1em"># lowercase/uppercase all
files/directories <br>
$ autoload zmv <br>
$ zmv &rsquo;(*)&rsquo; &rsquo;${(L)1}&rsquo; # lowercase
<br>
$ zmv &rsquo;(*)&rsquo; &rsquo;${(U)1}&rsquo; #
uppercase</p>

<p style="margin-top: 1em"># Remove the suffix *.c from all
C-Files <br>
$ autoload zmv <br>
$ zmv &rsquo;(*).c&rsquo; &rsquo;$1&rsquo;</p>

<p style="margin-top: 1em"># Uppercase only the first
letter of all *.mp3 - files <br>
$ autoload zmv <br>
$ zmv &rsquo;([a-z])(*).mp3&rsquo;
&rsquo;${(C)1}$2.mp3&rsquo;</p>

<p style="margin-top: 1em"># Copy the target
&lsquo;README&rsquo; in same directory as each
&lsquo;Makefile&rsquo; <br>
$ autoload zmv <br>
$ zmv -C &rsquo;(**/)Makefile&rsquo;
&rsquo;${1}README&rsquo;</p>

<p style="margin-top: 1em"># Removing single quote from
filenames (recursively) <br>
$ autoload zmv <br>
$ zmv -Q &quot;(**/)(*&rsquo;*)(D)&quot;
&quot;2//&rsquo;/}&quot;</p>

<p style="margin-top: 1em"># Rename pic1.jpg, pic2.jpg, ..
to pic0001.jpg, pic0002.jpg, .. <br>
$ autoload zmv <br>
$ zmv &rsquo;pic(*).jpg&rsquo;
&rsquo;pic${(l:4::0:)1}.jpg&rsquo; <br>
$ zmv &rsquo;(**/)pic(*).jpg&rsquo;
&rsquo;$1/pic${(l:4::0:)2}.jpg&rsquo; # recursively</p>

<p style="margin-top: 1em">Module-Examples <br>
Please read zshmodules(1) first!</p>

<p style="margin-top: 1em">zsh/pcre (require zmodload
zsh/pcre) <br>
# Copy files of a certain period (date indicated in the
filenames) <br>
$ zmodload zsh/pcre <br>
$ ls -d -- *(e:&rsquo;[[ $REPLY -pcre-match pcre-regexp
]]&rsquo;:) <br>
# or <br>
$ m() { [[ $1 -pcre-match pcre-regexp ]] } <br>
$ ls -d -- *(+m)</p>

<p style="margin-top: 1em">zsh/clone (require zmodload
zsh/clone) <br>
# Creates a forked instance of the current shell ($! is set
to zero) and <br>
# execute &lsquo;&lsquo;command&rsquo;&rsquo; on /dev/tty8
(for this example). <br>
$ zmodload zsh/clone <br>
$ clone /dev/tty8 &amp;&amp; (($! == 0)) &amp;&amp; exec
command</p>

<p style="margin-top: 1em">zsh/datetime (require zmodload
zsh/datetime) <br>
$ zmodload zsh/datetime <br>
$ alias datereplacement=&rsquo;strftime &quot;%Y-%m-%d&quot;
$EPOCHSECONDS&rsquo; <br>
$ export DATE=&lsquo;datereplacement&lsquo; <br>
$ echo $DATE</p>

<p style="margin-top: 1em"># strip date from filename <br>
$ $ zmodload zsh/datetime <br>
$ setopt extendedglob <br>
$ touch aaa_bbb_20041212_c.dat eee_fff_20051019_g.dat <br>
$ strftime -s pattern
&rsquo;???_???_&lt;0-%Y%m%d&gt;_?.dat&rsquo; $((EPOCHSECONDS
- 365 * 24 * 60 * 60 / 2)) <br>
$ print -rl -- $~pattern <br>
aaa_bbb_20041212_c.dat <br>
$ print -rl -- $pattern <br>
???_???_&lt;0-20050815&gt;_?.dat</p>

<p style="margin-top: 1em"># Search files size == 0, to be
based on the file name containing a date <br>
# rather than the &quot;last modified&quot; date of the file
<br>
$ zmodload -i zsh/datetime <br>
$ strftime -s file &quot;abc_de_%m%d%Y.dat&quot;
$((EPOCHSECONDS - 24 * 60 * 60 )) <br>
$ files=(**/$file(N.L0)) <br>
$ (( $#files &gt; 0 )) &amp;&amp; print -rl -- $files |
mailx -s &quot;empty files&quot; foo@bar.tdl</p>

<p style="margin-top: 1em">zsh/stat (require zmodload
zsh/stat) <br>
# test if a symbolic link links to a certain file <br>
$ zmodload -i zsh/stat <br>
$ ! stat -LH s foo.ln || [[ $s[link] != &quot;foo.exe&quot;
]] || ln -sf foo.exe foo.ln</p>

<p style="margin-top: 1em"># comparing file dates <br>
$ zmodload zsh/stat <br>
$ file1=foo <br>
$ file2=bar <br>
$ touch bar &amp; sleep 5 &amp; touch foo <br>
$ echo $file1 is $(($(stat +mtime $file2) - $(stat +mtime
$file1))) seconds older than $file2. <br>
bar is 5 seconds older than foo</p>

<p style="margin-top: 1em"># list the files of a disk
smaller than some other file <br>
$ zmodload zsh/stat <br>
$ stat -A max +size some-other-file <br>
$ print -rl ./**/*(D.L-$max)</p>

<p style="margin-top: 1em"># List the top 100 biggest files
in a disk <br>
$ zmodload zsh/stat <br>
$ ls -fld ./**/*(d&lsquo;stat +device .&lsquo;OL[1,100])</p>

<p style="margin-top: 1em"># Get only the user name and the
file names from (like <br>
# ls -l * | awk &rsquo;{print $3&quot; &quot; $8}&rsquo;)
<br>
$ zmodload zsh/stat <br>
$ for file; do <br>
&gt; stat -sA user +uid -- &quot;$file&quot; &amp;&amp; <br>
&gt; print -r -- &quot;$user&quot; &quot;$file&quot; <br>
&gt; done</p>

<p style="margin-top: 1em"># get the difference between
actual bytes of file and allocated bytes of file <br>
$ zmodload zsh/stat <br>
$ print $(($(stat +block -- file) * 512 - $(stat +size --
file)))</p>

<p style="margin-top: 1em"># Find largest file <br>
# &lsquo;&lsquo;D&rsquo;&rsquo; : to include dot files (d
lowercase is for device) <br>
# &lsquo;&lsquo;O&rsquo;&rsquo; : reverse Ordered (o
lowercase for non-reverse order) <br>
# &lsquo;&lsquo;L&rsquo;&rsquo; : by file Length (l is for
number of links) <br>
# &lsquo;&lsquo;[1]&rsquo;&rsquo;: return only first one
<br>
$ zmodload zsh/stat <br>
$ stat +size ./*(DOL[1])</p>

<p style="margin-top: 1em"># file size in bytes <br>
$ zmodload zsh/stat <br>
$ stat -L +size ~/.zshrc <br>
4707</p>

<p style="margin-top: 1em"># Delete files in a directory
that hasn&rsquo;t been accessed in the last ten days <br>
# and send ONE mail to the owner of the files informing
him/her of the files&rsquo; <br>
# deletion. <br>
$ zmodload zsh/stat zsh/files <br>
$ typeset -A f; f=() <br>
$ rm -f /path/**/*(.a+10e{&rsquo;stat -sA u +uidr $REPLY;
f[$u]=&quot;$f[$u]$REPLY&quot;&rsquo;}) <br>
$ for user (${(k)f}) {print -rn $f[$user]|mailx -s
&quot;...&quot; $user}</p>

<p style="margin-top: 1em"># Get a &quot;ls -l&quot; on all
the files in the tree that are younger than a <br>
# specified age <br>
$ zmodload zsh/stat <br>
$ for d (. ./**/*(N/m-2)) <br>
&gt; print -r -- $&rsquo;0$d: &amp;&amp; cd $d &amp;&amp; {
<br>
&gt; for f (*(Nm-2om)) <br>
&gt; stat -F &rsquo;%b %d %H:%M&rsquo; -LsAs -- $f
&amp;&amp; <br>
&gt; print -r -- $s[3] ${(l:4:)s[4]} ${(l:8:)s[5]} &gt;
${(l:8:)s[6]} ${(l:8:)s[8]} $s[10] $f ${s[14]:+-&gt; $s[14]}
<br>
&gt; cd ~- <br>
&gt; }</p>

<p style="margin-top: 1em"># get file creation date <br>
$ zmodload zsh/stat <br>
$ stat -F &rsquo;%d %m %Y&rsquo; +mtime ~/.zshrc <br>
30 06 2004 <br>
$ stat -F &rsquo;%D&rsquo; +mtime ~/.zshrc <br>
06/30/04</p>

<p style="margin-top: 1em">zsh/files (require zmodload
zsh/files) <br>
# search a directory for files containing a certain string
then copy those <br>
# files to another directory. <br>
$ zmodload zsh/files <br>
$ IFS=$&rsquo; &rsquo; <br>
$ cp $(grep -lZr foobar .) otherdirectory</p>

<p style="margin-top: 1em">zsh/mapfile (require zmodload
zsh/mapfile) <br>
# grepping for two patterns <br>
$ zmodload zsh/mapfile <br>
$ pattern1=&quot;foo&quot; <br>
$ pattern2=&quot;bar foo&quot; <br>
$ print -l ./**/*(DN.e{&rsquo;z=$mapfile[$REPLY] &amp;&amp;
[[ $z = *$pattern1* &amp;&amp; $z = *$pattern2* ]]&rsquo;})
<br>
# or a solution in combination with zsh/pcre <br>
$ zmodload -i zsh/mapfile zsh/pcre <br>
$ pattern1=&quot;foo&quot; <br>
$ pattern2=&quot;bar foo&quot; <br>
$ pcre_compile &quot;(?s)(?=.*?$pattern1).*?$pattern2&quot;
<br>
$ pcre_study <br>
$ print -l ./**/*(DN.e{&rsquo;pcre_match
$mapfile[$REPLY]&rsquo;})</p>

<p style="margin-top: 1em"># equivalent for
&lsquo;&lsquo;less /etc/passwd | grep -v root&rsquo;&rsquo;
<br>
$ zmodload zsh/mapfile <br>
$ IFS=$&rsquo;0 <br>
$ print -rl -- ${${=mapfile[/etc/passwd]}:#*root*} <br>
# or - for case insensitive <br>
$ setopt extendedglob <br>
$ print -rl -- ${${=mapfile[/etc/passwd]}:#*(#i)root*}</p>

<p style="margin-top: 1em"># If a XML-file contains stuff
like &lsquo;&lsquo;&lt;TAGA/&gt;&rsquo;&rsquo; and
&lsquo;&lsquo;&lt;TAGB/&gt;&rsquo;&rsquo;, number <br>
# this empty tags (ones ending in &rsquo;/&gt;&rsquo;) so if
encountered in the same <br>
# order, the preceeding tags would become
&lsquo;&lsquo;&lt;TAGA/&gt;1&lt;/TAGA&gt;&rsquo;&rsquo; and
<br>
# &lsquo;&lsquo;&lt;TAGB/&gt;2&lt;/TAGB&gt;&rsquo;&rsquo;
<br>
$ zmodload zsh/mapfile <br>
$ cnt=0 <br>
$ apfile[data.xml.new]=${(S)mapfile[data.xml]// &gt;
(#im)&lt;TAGA&gt;*&lt;TAGA&gt;/&lt;TAGA&gt;$((++cnt))&lt;TAGA&gt;}</p>

<p style="margin-top: 1em"># removing all files in users
Maildir/new that contain
&lsquo;&lsquo;filename=&quot;gone.src&rsquo;&rsquo; <br>
$ zmodload zsh/{files,mapfile} <br>
$ rm -f /u1/??/*/Maildir/new/100*(.e{&rsquo;[[
$mapfile[$REPLY] == *filename=</p>

<p style="margin-top: 1em"># Grep out the Title from a
postscript file and append that value to the <br>
# end of the filename <br>
$ autoload -U zmv <br>
$ zmodload zsh/mapfile <br>
$ zmv &rsquo;(*).ps&rsquo;
&rsquo;$1-${${${mapfile[$f]##*%%Title: }%%
*}//[^a-zA-Z0-9_]/}.ps&rsquo;</p>

<p style="margin-top: 1em">zsh/mathfunc (require zmodload
zsh/mathfunc) <br>
$ zmodload zsh/mathfunc <br>
$ echo $(( sin(1/4.0)**2 + cos(1/4.0)**2 - 1 )) <br>
-1.1102230246251565e-16 <br>
$ echo $(( pi = 4.0 * atan(1.0) )) <br>
3.1415926535897931 <br>
$ echo $(( f = sin(0.3) )) <br>
0.29552020666133955 <br>
$ print $((1e12 * rand48())) <br>
847909677310.23413 <br>
$ print $(( rand48(seed) )) <br>
0.01043488334700271</p>

<p style="margin-top: 1em">zsh/termcap (require zmodload
zsh/termcap) <br>
$ zmodload -ab zsh/termcap echotc <br>
$ GREEN=&lsquo;echotc AF 2&lsquo; <br>
$ YELLOW=&lsquo;echotc AF 3&lsquo; <br>
$ RED=&lsquo;echotc AF 1&lsquo; <br>
$ BRIGHTRED=&lsquo;echotc md ; echotc AF 1&lsquo; <br>
$ print -l ${GREEN}green ${YELLOW}yellow ${RED}red
${BRIGHTRED}brightred</p>

<p style="margin-top: 1em">zsh/zpty (require zmodload
zsh/zpty) <br>
$ zmodload zsh/zpty <br>
$ zpty PW passwd $1 <br>
$ zpty PW passwd $1 <br>
# &lsquo;&lsquo;-r&rsquo;&rsquo;: read the output of the
command name. <br>
# &lsquo;&lsquo;z&rsquo;&rsquo; : Parameter <br>
$ zpty -r PW z &rsquo;*password:&rsquo; <br>
# send the to command name the given strings as input <br>
$ zpty -w PW $2 <br>
$ zpty -r PW z &rsquo;*password:&rsquo; <br>
$ zpty -w PW $2 <br>
# The second form, with the -d option, is used to delete
commands <br>
# previously started, by supplying a list of their names. If
no names <br>
# are given, all commands are deleted. Deleting a command
causes the HUP <br>
# signal to be sent to the corresponding process. <br>
$ zpty -d PW</p>

<p style="margin-top: 1em">zsh/net/socket (require zmodload
zsh/net/socket) <br>
# &lsquo;&lsquo;-l&rsquo;&rsquo;: open a socket listening on
filename <br>
# &lsquo;&lsquo;-d&rsquo;&rsquo;: argument will be taken as
the target file descriptor for the <br>
# connection <br>
# &lsquo;&lsquo;3&rsquo;&rsquo; : file descriptor. See
&lsquo;&lsquo;A User&rsquo;s Guide to the
Z-Shell&rsquo;&rsquo; <br>
# (3.7.2: File descriptors) <br>
$ zmodload zsh/net/socket <br>
$ zsocket -l -d 3 <br>
# &lsquo;&lsquo;-a&rsquo;&rsquo;: accept an incoming
connection to the socket <br>
$ zsocket -a -d 4 3 <br>
$ zsocket -a -d 5 3 # accept a connection <br>
$ echo foobar &gt;&amp;4 <br>
$ echo barfoo &gt;&amp;5 <br>
$ 4&gt;&amp;- 5&gt;&amp;- 3&gt;&amp;</p>

<p style="margin-top: 1em">zsh/zftp (require zmodload
zsh/zftp) <br>
$ autoload -U zfinit <br>
$ zfinit <br>
$ zfparams www.example.invalid myuserid mypassword <br>
$ zfopen <br>
$ zfcd tips <br>
$ zfls -l zshtips.html <br>
$ zfput zshtips.html <br>
$ zfls -l zshtips.html</p>

<p style="margin-top: 1em"># Automatically transfer files
using FTP with error checking <br>
$ autoload -U zfinit ; zfinit <br>
$ zftp open host.name.invalid user passwd || exit <br>
$ zftp get /remote/file &gt; /local/file; r=$? <br>
$ zftp close &amp;&amp; exit r</p>

<p style="margin-top: 1em"># compress and ftp on the fly
<br>
$ autoload -U zfinit ; zfinit <br>
$ zftp open host.name.invalid user password <br>
$ zftp get $file | bzip2 &gt; ${file}.bz2 <br>
$ zftp close</p>

<p style="margin-top: 1em"># Recursice
&lsquo;&lsquo;get&rsquo;&rsquo; <br>
$ autoload -U zfinit ; zfinit <br>
$ zfanon cr.yp.to <br>
$ zfcd daemontools <br>
$ for file in &lsquo;zfls&lsquo; ; do <br>
&gt; zfget $file <br>
$ done <br>
$ zfclose</p>

<p style="margin-top: 1em"># Upload all regular files in
$HOME/foobar (recursive) that are newer than <br>
# two hours to ftp.foobar.invalid/path/to/upload <br>
$ autoload -U zfinit ; zfinit <br>
$ zfopen ftp.foobar.invalid/path/to/upload <br>
$ cd $HOME/foobar <br>
$ zfput -r **/*(.mh-2) <br>
$ zfclose</p>

<p style="margin-top: 1em"># long list of files on a ftp
<br>
$ autoload -U zfinit ; zfinit <br>
$ zfopen some-host <br>
$ zfcd /some/remote/Dir <br>
$ cd /some/local/Dir <br>
# If the list.txt is located on the remote host, change to
<br>
# zfget ${(f)&quot;$(zftp get
/path/to/remote/list.txt)&quot;} <br>
$ zfget ${(f)&quot;$(cat list.txt)&quot;} <br>
$ zfclose</p>

<p style="margin-top: 1em">zsh/zselect (require zmodload
zsh/zselect) <br>
# It&rsquo;s similar to <br>
,---- <br>
| $ sg=$(stty -g) <br>
| $ stty -icanon min 0 time 50 <br>
| $ read yesno <br>
| $ stty &quot;$sg&quot; <br>
| $ case &quot;$yesno&quot; in <br>
| &gt; yes) command1;; <br>
| &gt; *) command2;; <br>
| &gt; esac <br>
&lsquo;---- <br>
$ zmodload zsh/zselect <br>
$ if zselect -t 500 -r 0 &amp;&amp; read yesno &amp;&amp; [
yes = &quot;$yesno&quot; ]; then <br>
&gt; command1 <br>
&gt; else <br>
&gt; command1 <br>
&gt; fi</p>

<p style="margin-top: 1em">OPTIONS <br>
Navigation options <br>
auto_cd (allow one to change to a directory by entering it
as a command). auto_pushd (automatically append dirs to the
push/pop list) pushd_ignore_dups (and don&acirc;t duplicate
<br>
them).</p>

<p style="margin-top: 1em">Misc <br>
no_hup (don&acirc;t send HUP signal to background jobs when
exiting ZSH). print_exit_value (show a message with the exit
code when a command returns with a non-zero exit code)</p>

<p style="margin-top: 1em">History options <br>
hist_verify (let the user edit the command line after
history expansion (e.g. !ls) instead of immediately running
it) Use the same history file for all sessions : setopt <br>
SHARE_HISTORY</p>

<p style="margin-top: 1em">Privacy / Security <br>
no_clobber (or set -C; prevent &gt; redirection from
truncating the given file if it already exists)</p>

<p style="margin-top: 1em">Spelling correction <br>
correct (automatically correct the spelling of commands).
correct_all (automatically correct the spelling of each word
on the command line) dvorak (dvorak layout)</p>

<p style="margin-top: 1em">UNSORTED/MISC <br>
Mailpath: simple multiple mailpath:</p>


<p style="margin-top: 1em">mailpath=($HOME/Mail/mbox&rsquo;?new
mail in mbox&rsquo; <br>
$HOME/Mail/tux.u-strasbg&rsquo;?new mail in tux&rsquo; <br>
$HOME/Mail/lilo&rsquo;?new mail in lilo&rsquo; <br>
$HOME/Mail/ldap-fr&rsquo;?new mail in ldap-fr&rsquo;)</p>

<p style="margin-top: 1em">Mailpath: dynamic mailpath:</p>

<p style="margin-top: 1em">typeset -a mailpath <br>
for i in ~/Mail/Lists/*(.); do <br>
mailpath[$#mailpath+1]=&quot;${i}?You have new mail in
${i:t}.&quot; <br>
done</p>

<p style="margin-top: 1em">Avoid globbing on special
commands:</p>

<p style="margin-top: 1em">for com in alias expr find
mattrib mcopy mdir mdel which; <br>
alias $com=&quot;noglob $com&quot;</p>

<p style="margin-top: 1em">For migrating your bashprompt to
zsh use the script bash2zshprompt located in the zsh source
distribution under Misc.</p>

<p style="margin-top: 1em">For migration from (t)csh to zsh
use the c2z tool that converts csh aliases and environment
and shell variables to zsh. It does this by running csh, and
having csh report on <br>
aliases and variables. The script then converts these to zsh
startup files. It has some issues and usage information that
are documented at the top of this script.</p>

<p style="margin-top: 1em">Here are functions to set the
title and hardstatus of an XTerm or of GNU Screen to zsh and
the current directory, respectively, when the prompt is
displayed, and to the command <br>
name and rest of the command line, respectively, when a
command is executed:</p>

<p style="margin-top: 1em">function title { <br>
if [[ $TERM == &quot;screen&quot; ]]; then <br>
# Use these two for GNU Screen: <br>
print -nR $&rsquo; 33k&rsquo;$1$&rsquo; 33&rsquo; print -nR
$&rsquo; 33]0;&rsquo;$2$&rsquo;&rsquo; <br>
elif [[ $TERM == &quot;xterm&quot; || $TERM ==
&quot;rxvt&quot; ]]; then <br>
# Use this one instead for XTerms: <br>
print -nR $&rsquo; 33]0;&rsquo;$*$&rsquo;&rsquo; <br>
fi <br>
} <br>
function precmd { title zsh &quot;$PWD&quot; } <br>
function preexec { <br>
emulate -L zsh <br>
local -a cmd; cmd=(${(z)1}) <br>
title $cmd[1]:t &quot;$cmd[2,-1]&quot; <br>
}</p>

<p style="margin-top: 1em">Put the following line into your
~/.screenrc to see this fancy hardstatus:</p>

<p style="margin-top: 1em">caption always &quot;%3n %t%?
(%u)%?%?: %h%?&quot;</p>

<p style="margin-top: 1em">Special variables which are
assigned:</p>

<p style="margin-top: 1em">$LINENO $RANDOM $SECONDS
$COLUMNS $HISTCHARS $UID <br>
$EUID $GID $EGID $USERNAME $fignore $mailpath $cdpath</p>

<p style="margin-top: 1em">LINKS <br>
Primary site <br>
http://www.zsh.org/</p>

<p style="margin-top: 1em">Project-page <br>
http://sourceforge.net/projects/zsh/</p>

<p style="margin-top: 1em">Z shell page at sunsite.dk <br>
http://zsh.sunsite.dk/</p>

<p style="margin-top: 1em">From Bash to Z Shell: Conquering
the Command Line - the book <br>
http://www.bash2zsh.com/</p>

<p style="margin-top: 1em">&quot;Zsh - die magische
Shell&quot; (german book about Zsh) by Sven Guckes and
Julius Plenz <br>
http://zshbuch.org/</p>

<p style="margin-top: 1em">Mailinglistarchive <br>
http://www.zsh.org/mla/</p>

<p style="margin-top: 1em">ZSH-FAQ <br>
http://zsh.dotsrc.org/FAQ/</p>

<p style="margin-top: 1em">Userguide <br>
http://zsh.sunsite.dk/Guide/</p>

<p style="margin-top: 1em">ZSH-Wiki <br>
http://zshwiki.org/home/</p>

<p style="margin-top: 1em">A short introduction from BYU
<br>
http://docs.cs.byu.edu/linux/advanced/zsh.html</p>

<p style="margin-top: 1em">Mouse-Support ;) <br>
http://stchaz.free.fr/mouse.zsh</p>

<p style="margin-top: 1em">Curtains up: introducing the Z
shell <br>

http://www-128.ibm.com/developerworks/linux/library/l-z.html?dwzone=linux</p>

<p style="margin-top: 1em">ZSH-Liebhaberseite (german) <br>

http://michael-prokop.at/computer/tools_zsh_liebhaber.html</p>

<p style="margin-top: 1em">ZSH-Seite von Michael Prokop
(german) <br>
http://michael-prokop.at/computer/tools_zsh.html</p>

<p style="margin-top: 1em">ZSH Prompt introduction <br>
http://aperiodic.net/phil/prompt/</p>

<p style="margin-top: 1em">ft&acirc;s zsh configuration
<br>
http://ft.bewatermyfriend.org/comp/zsh.html</p>

<p style="margin-top: 1em">Adam&acirc;s ZSH page <br>
http://www.adamspiers.org/computing/zsh/</p>

<p style="margin-top: 1em">Zzappers Best of ZSH Tips <br>
http://www.rayninfo.co.uk/tips/zshtips.html</p>

<p style="margin-top: 1em">Zsh Webpage by Christian
Schneider <br>
http://www.strcat.de/zsh/</p>

<p style="margin-top: 1em">The zsh-lovers webpage <br>
http://grml.org/zsh/</p>

<p style="margin-top: 1em">IRC channel <br>
#zsh at irc.freenode.org</p>

<p style="margin-top: 1em">The Z shell reference-card
(included in the zsh-lovers debian-package) <br>
http://www.bash2zsh.com/zsh_refcard/refcard.pdf</p>

<p style="margin-top: 1em">AUTHORS <br>
This manpage was written by Michael Prokop, Christian strcat
Schneider and Matthias Kopfermann. But many ideas have been
taken from zsh-geeks e.g. from the zsh-mailinglists <br>
(zsh-users and zsh-workers), google, newsgroups and the
zsh-Wiki. Thanks for your cool and incredible tips. We
learned much from you!</p>

<p style="margin-top: 1em">In alphabetic order:</p>

<p style="margin-top: 1em">Andrew &rsquo;zefram&rsquo; Main
- http://www.fysh.org/~zefram/ <br>
Barton E. Schaefer - http://www.well.com/user/barts/ <br>
Matthias Kopfermann - http://www.infodrom.north.de/~matthi/
<br>
Oliver Kiddle - http://people.freenet.de/opk/ <br>
Paul Falstad - http://www.falstad.com/ <br>
Peter Stephenson -
http://homepage.ntlworld.com/p.w.stephenson/ <br>
Richard Coleman <br>
Stephane Chazelas - http://stephane.chazelas.free.fr/ <br>
Sven Guckes - http://www.guckes.net/ <br>
Sven Wischnowsky - http://w9y.de/zsh/zshrc</p>

<p style="margin-top: 1em">SEE ALSO <br>
Manpages of zsh:</p>

<p style="margin-top: 1em">zsh Zsh overview <br>
zshall Tthe Z shell meta-man page <br>
zshbuiltins Zsh built-in commands <br>
zshcalsys zsh calendar system <br>
zshcompctl zsh programmable completion <br>
zshcompsys Zsh completion system <br>
zshcompwid Zsh completion widgets <br>
zshcontrib User contributions to zsh <br>
zshexpn Zsh expansion and substitution <br>
zshmisc Anything not fitting into the other sections <br>
zshmodules Zsh loadable modules <br>
zshoptions Zsh options <br>
zshparam Zsh parameters <br>
zshroadmap Informal introduction to the zsh manual <br>
zshtcpsys Zsh tcp system <br>
zshzle Zsh command line editing <br>
zshzftpsys Zsh built-in FTP client <br>
zshall Meta-man page containing all of the above</p>

<p style="margin-top: 1em">Note: especially man zshcontrib
covers very useful topics! Book: From Bash to Z Shell by
Oliver Kiddle, Jerry Peck and Peter Stephenson. ISBN:
1590593766. - bash2zsh.com Also <br>
take a look at the section LINKS in this manpage.</p>

<p style="margin-top: 1em">BUGS <br>
Probably. This manpage might be never complete. So please
report bugs, feedback and suggestions to
&lt;zsh-lovers@michael-prokop.at&gt;. Thank you!</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (C) Michael Prokop, Christian Schneider and
Matthias Kopfermann.</p>

<p style="margin-top: 1em">02/12/2017 ZSH-LOVERS(1)</p>
<hr>
</body>
</html>
