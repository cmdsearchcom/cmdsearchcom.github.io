<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:39:08 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>STAPREF(1) General Commands Manual STAPREF(1)</p>

<p style="margin-top: 1em">NAME <br>
stapref - systemtap language reference</p>

<p style="margin-top: 1em">SYNOPSIS <br>
stapref</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The reference for the systemtap scripting language.</p>

<p style="margin-top: 1em">LANGUAGE <br>
Keywords <br>
&Acirc;&middot; break <br>
&Acirc;&middot; continue <br>
&Acirc;&middot; delete <br>
&Acirc;&middot; else <br>
&Acirc;&middot; exit <br>
&Acirc;&middot; foreach <br>
&Acirc;&middot; for <br>
&Acirc;&middot; function <br>
&Acirc;&middot; global <br>
&Acirc;&middot; private <br>
&Acirc;&middot; if <br>
&Acirc;&middot; in <br>
&Acirc;&middot; next <br>
&Acirc;&middot; probe <br>
&Acirc;&middot; return <br>
&Acirc;&middot; try/catch <br>
&Acirc;&middot; while</p>

<p style="margin-top: 1em">Data Types and Operators <br>
Integers <br>
&Acirc;&middot; var1 = 5 <br>
&Acirc;&middot; global var2 = 10</p>

<p style="margin-top: 1em">Strings <br>
&Acirc;&middot; var1 = &quot;string1&quot; <br>
&Acirc;&middot; global var2 = &quot;string2&quot;</p>

<p style="margin-top: 1em">Associative Arrays <br>
&Acirc;&middot; global array1[] <br>
&Acirc;&middot; global array2[SIZE] <br>
&Acirc;&middot; array[index] = 5</p>

<p style="margin-top: 1em">Context Variables <br>
&Acirc;&middot; $var <br>
&Acirc;&middot; $var$ (pretty printed string form)</p>

<p style="margin-top: 1em">Binary numeric operators <br>
&Acirc;&middot; * / % + - &lt;&lt; &gt;&gt; &amp; ^ |
&amp;&amp; ||</p>

<p style="margin-top: 1em">Binary string operators <br>
&Acirc;&middot; . (string concatenation)</p>

<p style="margin-top: 1em">Numeric assignment operators
<br>
&Acirc;&middot; = += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;=
^= |=</p>

<p style="margin-top: 1em">String assignment operators <br>
&Acirc;&middot; = .=</p>

<p style="margin-top: 1em">Unary numeric operators <br>
&Acirc;&middot; + - ! ~ ++ --</p>

<p style="margin-top: 1em">Numeric &amp; string comparison
operators <br>
&Acirc;&middot; &lt; &gt; &lt;= &gt;= == !=</p>

<p style="margin-top: 1em">Regular expression matching
operators <br>
&Acirc;&middot; =~ !~</p>

<p style="margin-top: 1em">Ternary operator <br>
&Acirc;&middot; cond ? exp1 : exp2</p>

<p style="margin-top: 1em">Grouping operator <br>
&Acirc;&middot; ( expression )</p>

<p style="margin-top: 1em">Array operators <br>
&Acirc;&middot; array[index] (array read/write) <br>
&Acirc;&middot; [index] in array</p>

<p style="margin-top: 1em">Aggregation operator <br>
&Acirc;&middot; var &lt;&lt;&lt; value</p>

<p style="margin-top: 1em">Statements <br>
Jump Statements <br>
&Acirc;&middot; continue <br>
&Acirc;&middot; break <br>
&Acirc;&middot; next <br>
&Acirc;&middot; return expression <br>
&Acirc;&middot; try statement catch (message)</p>

<p style="margin-top: 1em">Selection Statements <br>
&Acirc;&middot; if (expression) statement <br>
&Acirc;&middot; else statement</p>

<p style="margin-top: 1em">Iteration Statements <br>
&Acirc;&middot; foreach (variable in array) statement <br>
&Acirc;&middot; foreach ([var1,var2,...] in array) statement
<br>
&Acirc;&middot; for (expression; expression; expression)
statement <br>
&Acirc;&middot; while (expression) statement</p>

<p style="margin-top: 1em">Declaration Statements <br>
&Acirc;&middot; function name (variable : type, ...) {
statement } <br>
&Acirc;&middot; function name : type (variable : type, ...)
{ statement } <br>
&Acirc;&middot; function name : type (variable : type, ...)
%{ c_statement %} <br>
&Acirc;&middot; probe probepoint { statement } <br>
&Acirc;&middot; probe label = probepoint { statement }</p>

<p style="margin-top: 1em">Lexical Structure <br>
Comments <br>
&Acirc;&middot; # ... comment <br>
&Acirc;&middot; // ... comment <br>
&Acirc;&middot; /* ... comment ... */</p>

<p style="margin-top: 1em">Preprocessor <br>
&Acirc;&middot; %( expression %? true_tokens %: false_tokens
%) <br>
&Acirc;&middot; @define label (variable, ...) %{ statement
%}</p>

<p style="margin-top: 1em">Builtin Functions <br>
Aggregation Builtin Functions <br>
&Acirc;&middot; @avg (variable) <br>
&Acirc;&middot; @count (variable) <br>
&Acirc;&middot; @hist_linear (variable, N, N, N) <br>
&Acirc;&middot; @hist_log (variable) <br>
&Acirc;&middot; @max (variable) <br>
&Acirc;&middot; @min (variable) <br>
&Acirc;&middot; @sum (variable)</p>

<p style="margin-top: 1em">Output Builtin Functions <br>
&Acirc;&middot; print (variable) <br>
&Acirc;&middot; printf (format:string, variable, ...) <br>
where format is of the form:
%[flags][width][.precision][length]specifier <br>
&Acirc;&middot; printd (delimiter:string, variable, ...)
<br>
&Acirc;&middot; printdln (delimiter:string, variable, ...)
<br>
&Acirc;&middot; println () <br>
&Acirc;&middot; sprint:string (variable) <br>
&Acirc;&middot; sprintf:string (format:string, variable,
...)</p>

<p style="margin-top: 1em">Variable Access Builtin
Functions <br>
&Acirc;&middot; @cast (variable, &quot;type_name&quot;[,
&quot;module&quot;]) <br>
&Acirc;&middot; @defined (variable)</p>

<p style="margin-top: 1em">Probepoints <br>
Some of the more commonly used probepoints <br>
&Acirc;&middot; kernel.function(PATTERN)
kernel.function(PATTERN).call <br>
&Acirc;&middot; kernel.function(PATTERN).return <br>
&Acirc;&middot; kernel.FUNCTION
(PATTERN).return.maxactive(VALUE) <br>
&Acirc;&middot; kernel.FUNCTION (PATTERN).inline <br>
&Acirc;&middot; kernel.FUNCTION (PATTERN).label(LPATTERN)
<br>
&Acirc;&middot; module(MPATTERN).FUNCTION (PATTERN) <br>
&Acirc;&middot; module(MPATTERN).FUNCTION (PATTERN).call
<br>
&Acirc;&middot; module(MPATTERN).FUNCTION
(PATTERN).return.maxactive(VALUE) <br>
&Acirc;&middot; module(MPATTERN).FUNCTION (PATTERN).inline
<br>
&Acirc;&middot; kernel.statement(PATTERN) <br>
&Acirc;&middot; kernel.statement(ADDRESS).absolute <br>
&Acirc;&middot; module(MPATTERN).statement(PATTERN) <br>
&Acirc;&middot; kprobe.FUNCTION (FUNCTION) <br>
&Acirc;&middot; kprobe.FUNCTION (FUNCTION).return <br>
&Acirc;&middot; kprobe.module(NAME).FUNCTION (FUNCTION) <br>
&Acirc;&middot; kprobe.module(NAME).FUNCTION
(FUNCTION).return <br>
&Acirc;&middot; kprobe.statement(ADDRESS).absolute <br>
&Acirc;&middot; process.begin
process(&quot;PATH&quot;).begin <br>
&Acirc;&middot; process(PID).begin process.thread.begin <br>
&Acirc;&middot; process(&quot;PATH&quot;).thread.begin <br>
&Acirc;&middot; process(PID).thread.begin <br>
&Acirc;&middot; process.end <br>
&Acirc;&middot; process(&quot;PATH&quot;).end <br>
&Acirc;&middot; process(PID).end <br>
&Acirc;&middot; process.thread.end <br>
&Acirc;&middot; process(&quot;PATH&quot;).thread.end <br>
&Acirc;&middot; process(PID).thread.end <br>
&Acirc;&middot; process(&quot;PATH&quot;).syscall <br>
&Acirc;&middot; process(PID).syscall <br>
&Acirc;&middot; process.syscall.return <br>
&Acirc;&middot; process(&quot;PATH&quot;).syscall.return
<br>
&Acirc;&middot; process(PID).syscall.return <br>
&Acirc;&middot; process(&quot;PATH&quot;).FUNCTION
(&quot;NAME&quot;) <br>
&Acirc;&middot;
process(&quot;PATH&quot;).statement(&quot;*@FILE.c:123&quot;)
<br>
&Acirc;&middot; process(&quot;PATH&quot;).FUNCTION
(&quot;*&quot;).return <br>
&Acirc;&middot; process(&quot;PATH&quot;).FUNCTION
(&quot;myfun&quot;).label(&quot;foo&quot;) <br>
&Acirc;&middot;
process(&quot;PATH&quot;).mark(&quot;LABEL&quot;) <br>
&Acirc;&middot;
java(&quot;PNAME&quot;).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;)
<br>
&Acirc;&middot;
java(&quot;PNAME&quot;).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;).return
<br>
&Acirc;&middot;
java(PID).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;)
<br>
&Acirc;&middot;
java(PID).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;).return</p>

<p style="margin-top: 1em">Tapset Functions <br>
Some of the more commonly used tapset functions <br>
&Acirc;&middot; addr:long () <br>
&Acirc;&middot; backtrace:string () <br>
&Acirc;&middot; caller:string () <br>
&Acirc;&middot; caller_addr:long () <br>
&Acirc;&middot; cmdline_arg:string (N:long) <br>
&Acirc;&middot; cmdline_args:string
(N:long,m:long,delim:string) <br>
&Acirc;&middot; cmdline_str:string () <br>
&Acirc;&middot; env_var:string (name:string) <br>
&Acirc;&middot; execname:string () <br>
&Acirc;&middot; int_arg:long (N:long) <br>
&Acirc;&middot; isinstr:long(s1:string,s2:string) <br>
&Acirc;&middot; long_arg:long (N:long) <br>
&Acirc;&middot; modname:string () <br>
&Acirc;&middot; module_name:string () <br>
&Acirc;&middot; pid:long () <br>
&Acirc;&middot; pn:string () <br>
&Acirc;&middot; pointer_arg:string (N:long) <br>
&Acirc;&middot; pp:string () <br>
&Acirc;&middot; print_backtrace () <br>
&Acirc;&middot; probefunc:string () <br>
&Acirc;&middot; register:long(name:string) <br>
&Acirc;&middot;
str_replace:string(prnt_str:string,srch_str:string,rplc_str:string)
<br>
&Acirc;&middot; stringat:long(str:string,pos:long) <br>
&Acirc;&middot; strlen:long(str:string) <br>
&Acirc;&middot; strtol:long(str:string,base:long) <br>
&Acirc;&middot;
substr:string(str:string,start:long,length:long) <br>
&Acirc;&middot; user_long:long(addr:long) <br>
&Acirc;&middot; user_string:string(addr:long)</p>

<p style="margin-top: 1em">SEE ALSO <br>
stap(1)</p>

<p style="margin-top: 1em">BUGS <br>
Use the Bugzilla link of the project web page or our mailing
list.
http://sourceware.org/systemtap/,&lt;systemtap@sourceware.org&gt;.</p>
 
<p style="margin-top: 1em">STAPREF(1)</p>
<hr>
</body>
</html>
