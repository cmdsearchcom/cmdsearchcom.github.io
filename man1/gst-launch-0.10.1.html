<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:15:42 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GStreamer(1) General Commands Manual GStreamer(1)</p>

<p style="margin-top: 1em">NAME <br>
gst-launch - build and run a GStreamer pipeline</p>

<p style="margin-top: 1em">SYNOPSIS <br>
gst-launch [OPTION...] PIPELINE-DESCRIPTION</p>

<p style="margin-top: 1em">DESCRIPTION <br>
gst-launch is a tool that builds and runs basic GStreamer
pipelines.</p>

<p style="margin-top: 1em">In simple form, a
PIPELINE-DESCRIPTION is a list of elements separated by
exclamation marks (!). Properties may be appended to
elements, in the form property=value.</p>

<p style="margin-top: 1em">For a complete description of
possible PIPELINE-DESCRIPTIONS see the section pipeline
description below or consult the GStreamer
documentation.</p>

<p style="margin-top: 1em">Please note that gst-launch is
primarily a debugging tool for developers and users. You
should not build applications on top of it. For
applications, use the gst_parse_launch() <br>
function of the GStreamer API as an easy way to construct
pipelines from pipeline descriptions.</p>

<p style="margin-top: 1em">OPTIONS <br>
gst-launch accepts the following options:</p>

<p style="margin-top: 1em">--help Print help synopsis and
available FLAGS</p>

<p style="margin-top: 1em">-v, --verbose <br>
Output status information and property notifications</p>

<p style="margin-top: 1em">-q, --quiet <br>
Do not print any progress information</p>

<p style="margin-top: 1em">-m, --messages <br>
Output messages posted on the pipeline&rsquo;s bus</p>

<p style="margin-top: 1em">-t, --tags <br>
Output tags (also known as metadata)</p>

<p style="margin-top: 1em">-e, --eos-on-shutdown <br>
Force an EOS event on sources before shutting the pipeline
down. This is useful to make sure muxers create readable
files when a muxing pipeline is shut down forcefully <br>
via Control-C.</p>

<p style="margin-top: 1em">-i, --index <br>
Gather and print index statistics. This is mostly useful for
playback or recording pipelines.</p>

<p style="margin-top: 1em">-o FILE, --output=FILE <br>
Save XML representation of pipeline to FILE and exit
(DEPRECATED, DO NOT USE)</p>

<p style="margin-top: 1em">-f, --no-fault <br>
Do not install a fault handler</p>

<p style="margin-top: 1em">--no-sigusr-handler <br>
Do not install signal handlers for SIGUSR1 (play) and
SIGUSR2 (stop)</p>

<p style="margin-top: 1em">-T, --trace <br>
Print memory allocation traces. The feature must be enabled
at compile time to work.</p>

<p style="margin-top: 1em">GSTREAMER OPTIONS <br>
gst-launch also accepts the following options that are
common to all GStreamer applications:</p>

<p style="margin-top: 1em">--gst-version <br>
Prints the version string of the GStreamer core library.</p>

<p style="margin-top: 1em">--gst-fatal-warnings <br>
Causes GStreamer to abort if a warning message occurs. This
is equivalent to setting the environment variable G_DEBUG to
&rsquo;fatal_warnings&rsquo; (see the section environment
<br>
variables below for further information).</p>

<p style="margin-top: 1em">--gst-debug=STRING <br>
A comma separated list of category_name:level pairs to
specify debugging levels for each category. Level is in the
range 0-5 where 0 will show no messages, and 5 will <br>
show all messages. The wildcard * can be used to match
category names.</p>

<p style="margin-top: 1em">Use --gst-debug-help to show
category names</p>

<p style="margin-top: 1em">Example:
GST_CAT:5,GST_ELEMENT_*:3,oggdemux:5</p>

<p style="margin-top: 1em">--gst-debug-level=LEVEL <br>
Sets the threshold for printing debugging messages. A higher
level will print more messages. The useful range is 0-5,
with the default being 0.</p>

<p style="margin-top: 1em">--gst-debug-no-color <br>
GStreamer normally prints debugging messages so that the
messages are color-coded when printed to a terminal that
handles ANSI escape sequences. Using this option causes <br>
GStreamer to print messages without color. Setting the
GST_DEBUG_NO_COLOR environment variable will achieve the
same thing.</p>

<p style="margin-top: 1em">--gst-debug-disable <br>
Disables debugging.</p>

<p style="margin-top: 1em">--gst-debug-help <br>
Prints a list of available debug categories and their
default debugging level.</p>

<p style="margin-top: 1em">--gst-plugin-spew <br>
GStreamer info flags to set Enable printout of errors while
loading GStreamer plugins</p>

<p style="margin-top: 1em">--gst-plugin-path=PATH <br>
Add directories separated with &rsquo;:&rsquo; to the plugin
search path</p>

<p style="margin-top: 1em">--gst-plugin-load=PLUGINS <br>
Preload plugins specified in a comma-separated list. Another
way to specify plugins to preload is to use the environment
variable GST_PLUGIN_PATH</p>

<p style="margin-top: 1em">PIPELINE DESCRIPTION <br>
A pipeline consists elements and links. Elements can be put
into bins of different sorts. Elements, links and bins can
be specified in a pipeline description in any order.</p>

<p style="margin-top: 1em">Elements</p>

<p style="margin-top: 1em">ELEMENTTYPE [PROPERTY1 ...]</p>

<p style="margin-top: 1em">Creates an element of type
ELEMENTTYPE and sets the PROPERTIES.</p>

<p style="margin-top: 1em">Properties</p>

<p style="margin-top: 1em">PROPERTY=VALUE ...</p>

<p style="margin-top: 1em">Sets the property to the
specified value. You can use gst-inspect(1) to find out
about properties and allowed values of different elements.
<br>
Enumeration properties can be set by name, nick or
value.</p>

<p style="margin-top: 1em">Bins</p>

<p style="margin-top: 1em">[BINTYPE.] ( [PROPERTY1 ...]
PIPELINE-DESCRIPTION )</p>

<p style="margin-top: 1em">Specifies that a bin of type
BINTYPE is created and the given properties are set. Every
element between the braces is put into the bin. Please note
the dot that has to be used <br>
after the BINTYPE. You will almost never need this
functionality, it is only really useful for applications
using the gst_launch_parse() API with &rsquo;bin&rsquo; as
bintype. That way it is <br>
possible to build partial pipelines instead of a
full-fledged top-level pipeline.</p>

<p style="margin-top: 1em">Links</p>

<p style="margin-top: 1em">[[SRCELEMENT].[PAD1,...]] !
[[SINKELEMENT].[PAD1,...]] [[SRCELEMENT].[PAD1,...]] ! CAPS
! [[SINKELEMENT].[PAD1,...]]</p>

<p style="margin-top: 1em">Links the element with name
SRCELEMENT to the element with name SINKELEMENT, using the
caps specified in CAPS as a filter. Names can be set on
elements with the name property. <br>
If the name is omitted, the element that was specified
directly in front of or after the link is used. This works
across bins. If a padname is given, the link is done with
these <br>
pads. If no pad names are given all possibilities are tried
and a matching pad is used. If multiple padnames are given,
both sides must have the same number of pads specified <br>
and multiple links are done in the given order. <br>
So the simplest link is a simple exclamation mark, that
links the element to the left of it to the element right of
it.</p>

<p style="margin-top: 1em">Caps</p>

<p style="margin-top: 1em">MIMETYPE [, PROPERTY[, PROPERTY
...]]] [; CAPS[; CAPS ...]]</p>

<p style="margin-top: 1em">Creates a capability with the
given mimetype and optionally with given properties. The
mimetype can be escaped using &quot; or &rsquo;. If you want
to chain caps, you can add more caps in <br>
the same format afterwards.</p>

<p style="margin-top: 1em">Properties</p>

<p style="margin-top: 1em">NAME=[(TYPE)]VALUE <br>
in lists and ranges: [(TYPE)]VALUE</p>

<p style="margin-top: 1em">Sets the requested property in
capabilities. The name is an alphanumeric value and the type
can have the following case-insensitive values: <br>
- i or int for integer values or ranges <br>
- f or float for float values or ranges <br>
- 4 or fourcc for FOURCC values <br>
- b, bool or boolean for boolean values <br>
- s, str or string for strings <br>
- fraction for fractions (framerate, pixel-aspect-ratio)
<br>
- l or list for lists <br>
If no type was given, the following order is tried: integer,
float, boolean, string. <br>
Integer values must be parsable by strtol(), floats by
strtod(). FOURCC values may either be integers or strings.
Boolean values are (case insensitive) yes, no, true or false
and <br>
may like strings be escaped with &quot; or &rsquo;. <br>
Ranges are in this format: [ VALUE, VALUE ] <br>
Lists use this format: ( VALUE [, VALUE ...] )</p>

<p style="margin-top: 1em">PIPELINE CONTROL <br>
A pipeline can be controlled by signals. SIGUSR2 will stop
the pipeline (GST_STATE_NULL); SIGUSR1 will put it back to
play (GST_STATE_PLAYING). By default, the pipeline will <br>
start in the playing state. <br>
There are currently no signals defined to go into the ready
or pause (GST_STATE_READY and GST_STATE_PAUSED) state
explicitly.</p>

<p style="margin-top: 1em">PIPELINE EXAMPLES <br>
The examples below assume that you have the correct plug-ins
available. In general, &quot;osssink&quot; can be
substituted with another audio output plug-in such as
&quot;esdsink&quot;, &quot;alsasink&quot;, <br>
&quot;osxaudiosink&quot;, or &quot;artsdsink&quot;.
Likewise, &quot;xvimagesink&quot; can be substituted with
&quot;ximagesink&quot;, &quot;sdlvideosink&quot;,
&quot;osxvideosink&quot;, or &quot;aasink&quot;. Keep in
mind though that different <br>
sinks might accept different formats and even the same sink
might accept different formats on different machines, so you
might need to add converter elements like audioconvert <br>
and audioresample (for audio) or ffmpegcolorspace (for
video) in front of the sink to make things work.</p>

<p style="margin-top: 1em">Audio playback</p>

<p style="margin-top: 1em">gst-launch filesrc
location=music.mp3 ! mad ! audioconvert ! audioresample !
osssink <br>
Play the mp3 music file &quot;music.mp3&quot; using a
libmad-based plug-in and output to an OSS device</p>

<p style="margin-top: 1em">gst-launch filesrc
location=music.ogg ! oggdemux ! vorbisdec ! audioconvert !
audioresample ! osssink <br>
Play an Ogg Vorbis format file</p>

<p style="margin-top: 1em">gst-launch gnomevfssrc
location=music.mp3 ! mad ! osssink <br>
gst-launch gnomevfssrc location=http://domain.com/music.mp3
! mad ! audioconvert ! audioresample ! osssink <br>
Play an mp3 file or an http stream using GNOME-VFS</p>

<p style="margin-top: 1em">gst-launch gnomevfssrc
location=smb://computer/music.mp3 ! mad ! audioconvert !
audioresample ! osssink <br>
Use GNOME-VFS to play an mp3 file located on an SMB
server</p>

<p style="margin-top: 1em">Format conversion</p>

<p style="margin-top: 1em">gst-launch filesrc
location=music.mp3 ! mad ! audioconvert ! vorbisenc ! oggmux
! filesink location=music.ogg <br>
Convert an mp3 music file to an Ogg Vorbis file</p>

<p style="margin-top: 1em">gst-launch filesrc
location=music.mp3 ! mad ! audioconvert ! flacenc ! filesink
location=test.flac <br>
Convert to the FLAC format</p>

<p style="margin-top: 1em">Other</p>

<p style="margin-top: 1em">gst-launch filesrc
location=music.wav ! wavparse ! audioconvert ! audioresample
! osssink <br>
Plays a .WAV file that contains raw audio data (PCM).</p>

<p style="margin-top: 1em">gst-launch filesrc
location=music.wav ! wavparse ! audioconvert ! vorbisenc !
oggmux ! filesink location=music.ogg <br>
gst-launch filesrc location=music.wav ! wavparse !
audioconvert ! lame ! filesink location=music.mp3 <br>
Convert a .WAV file containing raw audio data into an Ogg
Vorbis or mp3 file</p>

<p style="margin-top: 1em">gst-launch cdparanoiasrc
mode=continuous ! audioconvert ! lame ! id3v2mux ! filesink
location=cd.mp3 <br>
rips all tracks from compact disc and convert them into a
single mp3 file</p>

<p style="margin-top: 1em">gst-launch cdparanoiasrc track=5
! audioconvert ! lame ! id3v2mux ! filesink
location=track5.mp3 <br>
rips track 5 from the CD and converts it into a single mp3
file</p>

<p style="margin-top: 1em">Using gst-inspect(1), it is
possible to discover settings like the above for
cdparanoiasrc that will tell it to rip the entire cd or only
tracks of it. Alternatively, you can <br>
use an URI and gst-launch-0.10 will find an element (such as
cdparanoia) that supports that protocol for you, e.g.: <br>
gst-launch cdda://5 ! lame vbr=new vbr-quality=6 ! filesink
location=track5.mp3</p>

<p style="margin-top: 1em">gst-launch osssrc ! audioconvert
! vorbisenc ! oggmux ! filesink location=input.ogg <br>
records sound from your audio input and encodes it into an
ogg file</p>

<p style="margin-top: 1em">Video</p>

<p style="margin-top: 1em">gst-launch filesrc
location=JB_FF9_TheGravityOfLove.mpg ! dvddemux ! mpeg2dec !
xvimagesink <br>
Display only the video portion of an MPEG-1 video file,
outputting to an X display window</p>

<p style="margin-top: 1em">gst-launch filesrc
location=/flflfj.vob ! dvddemux ! mpeg2dec ! sdlvideosink
<br>
Display the video portion of a .vob file (used on DVDs),
outputting to an SDL window</p>

<p style="margin-top: 1em">gst-launch filesrc
location=movie.mpg ! dvddemux name=demuxer demuxer. ! queue
! mpeg2dec ! sdlvideosink demuxer. ! queue ! mad !
audioconvert ! audioresample ! osssink <br>
Play both video and audio portions of an MPEG movie</p>

<p style="margin-top: 1em">gst-launch filesrc
location=movie.mpg ! mpegdemux name=demuxer demuxer. ! queue
! mpeg2dec ! ffmpegcolorspace ! sdlvideosink demuxer. !
queue ! mad ! audioconvert ! <br>
audioresample ! osssink <br>
Play an AVI movie with an external text subtitle stream</p>

<p style="margin-top: 1em">This example also shows how to
refer to specific pads by name if an element (here:
textoverlay) has multiple sink or source pads.</p>

<p style="margin-top: 1em">gst-launch textoverlay
name=overlay ! ffmpegcolorspace ! videoscale ! autovideosink
filesrc location=movie.avi ! decodebin2 ! ffmpegcolorspace !
overlay.video_sink <br>
filesrc location=movie.srt ! subparse !
overlay.text_sink</p>

<p style="margin-top: 1em">Play an AVI movie with an
external text subtitle stream using playbin2</p>

<p style="margin-top: 1em">gst-launch playbin2
uri=file:///path/to/movie.avi
suburi=file:///path/to/movie.srt</p>

<p style="margin-top: 1em">Network streaming</p>

<p style="margin-top: 1em">Stream video using RTP and
network elements.</p>

<p style="margin-top: 1em">gst-launch v4l2src !
video/x-raw-yuv,width=128,height=96,format=&rsquo;(fourcc)&rsquo;UYVY
! ffmpegcolorspace ! ffenc_h263 ! video/x-h263 ! rtph263ppay
pt=96 ! udpsink <br>
host=192.168.1.1 port=5000 sync=false <br>
This command would be run on the transmitter</p>

<p style="margin-top: 1em">gst-launch udpsrc port=5000 !
application/x-rtp, clock-rate=90000,payload=96 !
rtph263pdepay queue-delay=0 ! ffdec_h263 ! xvimagesink <br>
Use this command on the receiver</p>

<p style="margin-top: 1em">Diagnostic</p>

<p style="margin-top: 1em">gst-launch -v fakesrc
num-buffers=16 ! fakesink <br>
Generate a null stream and ignore it (and print out
details).</p>

<p style="margin-top: 1em">gst-launch audiotestsrc !
audioconvert ! audioresample ! osssink <br>
Generate a pure sine tone to test the audio output</p>

<p style="margin-top: 1em">gst-launch videotestsrc !
xvimagesink <br>
gst-launch videotestsrc ! ximagesink <br>
Generate a familiar test pattern to test the video
output</p>

<p style="margin-top: 1em">Automatic linking</p>

<p style="margin-top: 1em">You can use the decodebin
element to automatically select the right elements to get a
working pipeline.</p>

<p style="margin-top: 1em">gst-launch filesrc
location=musicfile ! decodebin ! audioconvert !
audioresample ! osssink <br>
Play any supported audio format</p>

<p style="margin-top: 1em">gst-launch filesrc
location=videofile ! decodebin name=decoder decoder. ! queue
! audioconvert ! audioresample ! osssink decoder. !
ffmpegcolorspace ! xvimagesink <br>
Play any supported video format with video and audio output.
Threads are used automatically. To make this even easier,
you can use the playbin element:</p>

<p style="margin-top: 1em">gst-launch playbin
uri=file:///home/joe/foo.avi</p>

<p style="margin-top: 1em">Filtered connections</p>

<p style="margin-top: 1em">These examples show you how to
use filtered caps.</p>

<p style="margin-top: 1em">gst-launch videotestsrc !
&rsquo;video/x-raw-yuv,format=(fourcc)YUY2;video/x-raw-yuv,format=(fourcc)YV12&rsquo;
! xvimagesink <br>
Show a test image and use the YUY2 or YV12 video format for
this.</p>

<p style="margin-top: 1em">gst-launch osssrc !
&rsquo;audio/x-raw-int,rate=[32000,64000],width=[16,32],depth={16,24,32},signed=(boolean)true&rsquo;
! wavenc ! filesink location=recording.wav <br>
record audio and write it to a .wav file. Force usage of
signed 16 to 32 bit samples and a sample rate between 32kHz
and 64KHz.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
GST_DEBUG <br>
Comma-separated list of debug categories and levels, e.g.
GST_DEBUG=totem:4,typefind:5</p>

<p style="margin-top: 1em">GST_DEBUG_NO_COLOR <br>
When this environment variable is set, coloured debug output
is disabled.</p>

<p style="margin-top: 1em">GST_DEBUG_DUMP_DOT_DIR <br>
When set to a filesystem path, store dot files of pipeline
graphs there.</p>

<p style="margin-top: 1em">GST_REGISTRY <br>
Path of the plugin registry file. Default is
~/.gstreamer-0.10/registry-CPU.xml where CPU is the
machine/cpu type GStreamer was compiled for, e.g.
&rsquo;i486&rsquo;, &rsquo;i686&rsquo;, <br>
&rsquo;x86-64&rsquo;, &rsquo;ppc&rsquo;, etc. (check the
output of &quot;uname -i&quot; and &quot;uname -m&quot; for
details).</p>

<p style="margin-top: 1em">GST_REGISTRY_UPDATE <br>
Set to &quot;no&quot; to force GStreamer to assume that no
plugins have changed, been added or been removed. This will
make GStreamer skip the initial check whether a rebuild of
the <br>
registry cache is required or not. This may be useful in
embedded environments where the installed plugins never
change. Do not use this option in any other setup.</p>

<p style="margin-top: 1em">GST_PLUGIN_PATH <br>
Specifies a list of directories to scan for additional
plugins. These take precedence over the system plugins.</p>

<p style="margin-top: 1em">GST_PLUGIN_SYSTEM_PATH <br>
Specifies a list of plugins that are always loaded by
default. If not set, this defaults to the system-installed
path, and the plugins installed in the user&rsquo;s home
direc&acirc; <br>
tory</p>

<p style="margin-top: 1em">ORC_CODE <br>
Useful Orc environment variable. Set ORC_CODE=debug to
enable debuggers such as gdb to create useful backtraces
from Orc-generated code. Set ORC_CODE=backup or <br>
ORC_CODE=emulate if you suspect Orc&rsquo;s SIMD code
generator is producing incorrect code. (Quite a few
important GStreamer plugins like videotestsrc, audioconvert
or <br>
audioresample use Orc).</p>

<p style="margin-top: 1em">G_DEBUG <br>
Useful GLib environment variable. Set G_DEBUG=fatal_warnings
to make GStreamer programs abort when a critical warning
such as an assertion failure occurs. This is useful <br>
if you want to find out which part of the code caused that
warning to be triggered and under what circumstances. Simply
set G_DEBUG as mentioned above and run the program <br>
in gdb (or let it core dump). Then get a stack trace in the
usual way.</p>

<p style="margin-top: 1em">FILES <br>
~/.gstreamer-0.10/registry-*.xml <br>
The xml plugin database; can be deleted at any time, will be
re-created automatically when it does not exist yet or
plugins change.</p>

<p style="margin-top: 1em">SEE ALSO <br>
gst-feedback(1), gst-inspect(1), gst-typefind(1)</p>

<p style="margin-top: 1em">AUTHOR <br>
The GStreamer team at http://gstreamer.freedesktop.org/</p>

<p style="margin-top: 1em">May 2007 GStreamer(1)</p>
<hr>
</body>
</html>
