<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:14 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PCRETEST(1) General Commands Manual PCRETEST(1)</p>

<p style="margin-top: 1em">NAME <br>
pcretest - a program for testing Perl-compatible regular
expressions.</p>

<p style="margin-top: 1em">SYNOPSIS</p>

<p style="margin-top: 1em">pcretest [options] [input file
[output file]]</p>

<p style="margin-top: 1em">pcretest was written as a test
program for the PCRE regular expression library itself, but
it can also be used for experimenting with regular
expressions. This document describes <br>
the features of the test program; for details of the regular
expressions themselves, see the pcrepattern documentation.
For details of the PCRE library function calls and their
<br>
options, see the pcreapi , pcre16 and pcre32
documentation.</p>

<p style="margin-top: 1em">The input for pcretest is a
sequence of regular expression patterns and strings to be
matched, as described below. The output shows the result of
each match. Options on the com&acirc; <br>
mand line and the patterns control PCRE options and exactly
what is output.</p>

<p style="margin-top: 1em">As PCRE has evolved, it has
acquired many different features, and as a result, pcretest
now has rather a lot of obscure options for testing every
possible feature. Some of these <br>
options are specifically designed for use in conjunction
with the test script and data files that are distributed as
part of PCRE, and are unlikely to be of use otherwise. They
<br>
are all documented here, but without much justification.</p>

<p style="margin-top: 1em">PCRE&rsquo;s 8-BIT, 16-BIT AND
32-BIT LIBRARIES</p>

<p style="margin-top: 1em">From release 8.30, two separate
PCRE libraries can be built. The original one supports 8-bit
character strings, whereas the newer 16-bit library supports
character strings <br>
encoded in 16-bit units. From release 8.32, a third library
can be built, supporting character strings encoded in 32-bit
units. The pcretest program can be used to test all <br>
three libraries. However, it is itself still an 8-bit
program, reading 8-bit input and writing 8-bit output. When
testing the 16-bit or 32-bit library, the patterns and data
<br>
strings are converted to 16- or 32-bit format before being
passed to the PCRE library functions. Results are converted
to 8-bit for output.</p>

<p style="margin-top: 1em">References to functions and
structures of the form pcre[16|32]_xx below mean
&quot;pcre_xx when using the 8-bit library or pcre16_xx when
using the 16-bit library&quot;.</p>

<p style="margin-top: 1em">COMMAND LINE OPTIONS</p>

<p style="margin-top: 1em">-8 If both the 8-bit library has
been built, this option causes the 8-bit library to be used
(which is the default); if the 8-bit library has not been
built, this option <br>
causes an error.</p>

<p style="margin-top: 1em">-16 If both the 8-bit or the
32-bit, and the 16-bit libraries have been built, this
option causes the 16-bit library to be used. If only the
16-bit library has been built, <br>
this is the default (so has no effect). If only the 8-bit or
the 32-bit library has been built, this option causes an
error.</p>

<p style="margin-top: 1em">-32 If both the 8-bit or the
16-bit, and the 32-bit libraries have been built, this
option causes the 32-bit library to be used. If only the
32-bit library has been built, <br>
this is the default (so has no effect). If only the 8-bit or
the 16-bit library has been built, this option causes an
error.</p>

<p style="margin-top: 1em">-b Behave as if each pattern has
the /B (show byte code) modifier; the internal form is
output after compilation.</p>

<p style="margin-top: 1em">-C Output the version number of
the PCRE library, and all available information about the
optional features that are included, and then exit. All
other options are <br>
ignored.</p>

<p style="margin-top: 1em">-C option Output information
about a specific build-time option, then exit. This
functionality is intended for use in scripts such as
RunTest. The following options output the <br>
value indicated:</p>

<p style="margin-top: 1em">ebcdic-nl the code for LF (= NL)
in an EBCDIC environment: <br>
0x15 or 0x25 <br>
0 if used in an ASCII environment <br>
linksize the internal link size (2, 3, or 4) <br>
newline the default newline setting: <br>
CR, LF, CRLF, ANYCRLF, or ANY</p>

<p style="margin-top: 1em">The following options output 1
for true or zero for false:</p>

<p style="margin-top: 1em">ebcdic compiled for an EBCDIC
environment <br>
jit just-in-time support is available <br>
pcre16 the 16-bit library was built <br>
pcre32 the 32-bit library was built <br>
pcre8 the 8-bit library was built <br>
ucp Unicode property support is available <br>
utf UTF-8 and/or UTF-16 and/or UTF-32 support is
available</p>

<p style="margin-top: 1em">-d Behave as if each pattern has
the /D (debug) modifier; the internal form and information
about the compiled pattern is output after compilation; -d
is equivalent to -b <br>
-i.</p>

<p style="margin-top: 1em">-dfa Behave as if each data line
contains the sequence; this causes the alternative matching
function, pcre[16|32]_dfa_exec(), to be used instead of the
standard <br>
pcre[16|32]_exec() function (more detail is given
below).</p>

<p style="margin-top: 1em">-help Output a brief summary
these options and then exit.</p>

<p style="margin-top: 1em">-i Behave as if each pattern has
the /I modifier; information about the compiled pattern is
given after compilation.</p>

<p style="margin-top: 1em">-M Behave as if each data line
contains the escape sequence; this causes PCRE to discover
the minimum MATCH_LIMIT and MATCH_LIMIT_RECURSION settings
by calling <br>
pcre[16|32]_exec() repeatedly with different limits.</p>

<p style="margin-top: 1em">-m Output the size of each
compiled pattern after it has been compiled. This is
equivalent to adding /M to each regular expression. The size
is given in bytes for both <br>
libraries.</p>

<p style="margin-top: 1em">-o osize Set the number of
elements in the output vector that is used when calling
pcre[16|32]_exec() or pcre[16|32]_dfa_exec() to be osize.
The default value is 45, which is <br>
enough for 14 capturing subexpressions for
pcre[16|32]_exec() or 22 different matches for
pcre[16|32]_dfa_exec(). The vector size can be changed for
individual match&acirc; <br>
ing calls by including in the data line (see below).</p>

<p style="margin-top: 1em">-p Behave as if each pattern has
the /P modifier; the POSIX wrapper API is used to call PCRE.
None of the other options has any effect when -p is set.
This option can be <br>
used only with the 8-bit library.</p>

<p style="margin-top: 1em">-q Do not output the version
number of pcretest at the start of execution.</p>

<p style="margin-top: 1em">-S size On Unix-like systems,
set the size of the run-time stack to size megabytes.</p>

<p style="margin-top: 1em">-s or -s+ Behave as if each
pattern has the /S modifier; in other words, force each
pattern to be studied. If -s+ is used, all the JIT compile
options are passed to <br>
pcre[16|32]_study(), causing just-in-time optimization to be
set up if it is available, for both full and partial
matching. Specific JIT compile options can be selected <br>
by following -s+ with a digit in the range 1 to 7, which
selects the JIT compile modes as follows:</p>

<p style="margin-top: 1em">1 normal match only <br>
2 soft partial match only <br>
3 normal match and soft partial match <br>
4 hard partial match only <br>
6 soft and hard partial match <br>
7 all three modes (default)</p>

<p style="margin-top: 1em">If -s++ is used instead of -s+
(with or without a following digit), the text
&quot;(JIT)&quot; is added to the first output line after a
match or no match when JIT-compiled code <br>
was actually used.</p>

<p style="margin-top: 1em">Note that there are pattern
options that can override -s, either specifying no studying
at all, or suppressing JIT compilation.</p>

<p style="margin-top: 1em">If the /I or /D option is
present on a pattern (requesting output about the compiled
pattern), information about the result of studying is not
included when studying is <br>
caused only by -s and neither -i nor -d is present on the
command line. This behaviour means that the output from
tests that are run with and without -s should be iden&acirc;
<br>
tical, except when options that output information about the
actual running of a match are set.</p>

<p style="margin-top: 1em">The -M, -t, and -tm options,
which give information about resources used, are likely to
produce different output with and without -s. Output may
also differ if the /C <br>
option is present on an individual pattern. This uses
callouts to trace the the matching process, and this may be
different between studied and non-studied patterns. If <br>
the pattern contains (*MARK) items there may also be
differences, for the same reason. The -s command line option
can be overridden for specific patterns that should <br>
never be studied (see the /S pattern modifier below).</p>

<p style="margin-top: 1em">-t Run each compile, study, and
match many times with a timer, and output resulting time per
compile or match (in milliseconds). Do not set -m with -t,
because you will <br>
then get the size output a zillion times, and the timing
will be distorted. You can control the number of iterations
that are used for timing by following -t with a <br>
number (as a separate item on the command line). For
example, &quot;-t 1000&quot; would iterate 1000 times. The
default is to iterate 500000 times.</p>

<p style="margin-top: 1em">-tm This is like -t except that
it times only the matching phase, not the compile or study
phases.</p>

<p style="margin-top: 1em">DESCRIPTION</p>

<p style="margin-top: 1em">If pcretest is given two
filename arguments, it reads from the first and writes to
the second. If it is given only one filename argument, it
reads from that file and writes to <br>
stdout. Otherwise, it reads from stdin and writes to stdout,
and prompts for each line of input, using &quot;re&gt;&quot;
to prompt for regular expressions, and &quot;data&gt;&quot;
to prompt for data <br>
lines.</p>

<p style="margin-top: 1em">When pcretest is built, a
configuration option can specify that it should be linked
with the libreadline library. When this is done, if the
input is from a terminal, it is read <br>
using the readline() function. This provides line-editing
and history facilities. The output from the -help option
states whether or not readline() will be used.</p>

<p style="margin-top: 1em">The program handles any number
of sets of input on a single input file. Each set starts
with a regular expression, and continues with any number of
data lines to be matched <br>
against the pattern.</p>

<p style="margin-top: 1em">Each data line is matched
separately and independently. If you want to do multi-line
matches, you have to use the escape 0 etc., depending on the
new&acirc; or sequence (or <br>
line setting) in a single line of input to encode the
newline sequences. There is no limit on the length of data
lines; the input buffer is automatically extended if it is
too <br>
small.</p>

<p style="margin-top: 1em">An empty line signals the end of
the data lines, at which point a new regular expression is
read. The regular expressions are given enclosed in any
non-alphanumeric delimiters <br>
other than backslash, for example:</p>

<p style="margin-top: 1em">/(a|bc)x+yz/</p>

<p style="margin-top: 1em">White space before the initial
delimiter is ignored. A regular expression may be continued
over several input lines, in which case the newline
characters are included within it. <br>
It is possible to include the delimiter within the pattern
by escaping it, for example</p>

<p style="margin-top: 1em">/abcdef/</p>

<p style="margin-top: 1em">If you do so, the escape and the
delimiter form part of the pattern, but since delimiters are
always non-alphanumeric, this does not affect its
interpretation. If the terminat&acirc; <br>
ing delimiter is immediately followed by a backslash, for
example,</p>

<p style="margin-top: 1em">/abc/ <br>
then a backslash is added to the end of the pattern. This is
done to provide a way of testing the error condition that
arises if a pattern finishes with a backslash, because</p>

<p style="margin-top: 1em">/abc</p>

<p style="margin-top: 1em">is interpreted as the first line
of a pattern that starts with &quot;abc/&quot;, causing
pcretest to read the next line as a continuation of the
regular expression.</p>

<p style="margin-top: 1em">PATTERN MODIFIERS</p>

<p style="margin-top: 1em">A pattern may be followed by any
number of modifiers, which are mostly single characters,
though some of these can be qualified by further characters.
Following Perl usage, <br>
these are referred to below as, for example, &quot;the /i
modifier&quot;, even though the delimiter of the pattern
need not always be a slash, and no slash is used when
writing modifiers. <br>
White space may appear between the final pattern delimiter
and the first modifier, and between the modifiers
themselves. For reference, here is a complete list of
modifiers. They <br>
fall into several groups that are described in detail in the
following sections.</p>

<p style="margin-top: 1em">/8 set UTF mode <br>
/? disable UTF validity check <br>
/+ show remainder of subject after match <br>
/= show all captures (not just those that are set)</p>

<p style="margin-top: 1em">/A set PCRE_ANCHORED <br>
/B show compiled code <br>
/C set PCRE_AUTO_CALLOUT <br>
/D same as /B plus /I <br>
/E set PCRE_DOLLAR_ENDONLY <br>
/F flip byte order in compiled pattern <br>
/f set PCRE_FIRSTLINE <br>
/G find all matches (shorten string) <br>
/g find all matches (use startoffset) <br>
/I show information about pattern <br>
/i set PCRE_CASELESS <br>
/J set PCRE_DUPNAMES <br>
/K show backtracking control names <br>
/L set locale <br>
/M show compiled memory size <br>
/m set PCRE_MULTILINE <br>
/N set PCRE_NO_AUTO_CAPTURE <br>
/P use the POSIX wrapper <br>
/S study the pattern after compilation <br>
/s set PCRE_DOTALL <br>
/T select character tables <br>
/U set PCRE_UNGREEDY <br>
/W set PCRE_UCP <br>
/X set PCRE_EXTRA <br>
/x set PCRE_EXTENDED <br>
/Y set PCRE_NO_START_OPTIMIZE <br>
/Z don&rsquo;t show lengths in /B output</p>

<p style="margin-top: 1em">/&lt;any&gt; set
PCRE_NEWLINE_ANY <br>
/&lt;anycrlf&gt; set PCRE_NEWLINE_ANYCRLF <br>
/&lt;cr&gt; set PCRE_NEWLINE_CR <br>
/&lt;crlf&gt; set PCRE_NEWLINE_CRLF <br>
/&lt;lf&gt; set PCRE_NEWLINE_LF <br>
/&lt;bsr_anycrlf&gt; set PCRE_BSR_ANYCRLF <br>
/&lt;bsr_unicode&gt; set PCRE_BSR_UNICODE <br>
/&lt;JS&gt; set PCRE_JAVASCRIPT_COMPAT</p>

<p style="margin-top: 1em">Perl-compatible modifiers</p>

<p style="margin-top: 1em">The /i, /m, /s, and /x modifiers
set the PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, or
PCRE_EXTENDED options, respectively, when
pcre[16|32]_compile() is called. These four mod&acirc; <br>
ifier letters have the same effect as they do in Perl. For
example:</p>

<p style="margin-top: 1em">/caseless/i</p>

<p style="margin-top: 1em">Modifiers for other PCRE
options</p>

<p style="margin-top: 1em">The following table shows
additional modifiers for setting PCRE compile-time options
that do not correspond to anything in Perl:</p>

<p style="margin-top: 1em">/8 PCRE_UTF8 ) when using the
8-bit <br>
/? PCRE_NO_UTF8_CHECK ) library</p>

<p style="margin-top: 1em">/8 PCRE_UTF16 ) when using the
16-bit <br>
/? PCRE_NO_UTF16_CHECK ) library</p>

<p style="margin-top: 1em">/8 PCRE_UTF32 ) when using the
32-bit <br>
/? PCRE_NO_UTF32_CHECK ) library</p>

<p style="margin-top: 1em">/A PCRE_ANCHORED <br>
/C PCRE_AUTO_CALLOUT <br>
/E PCRE_DOLLAR_ENDONLY <br>
/f PCRE_FIRSTLINE <br>
/J PCRE_DUPNAMES <br>
/N PCRE_NO_AUTO_CAPTURE <br>
/U PCRE_UNGREEDY <br>
/W PCRE_UCP <br>
/X PCRE_EXTRA <br>
/Y PCRE_NO_START_OPTIMIZE <br>
/&lt;any&gt; PCRE_NEWLINE_ANY <br>
/&lt;anycrlf&gt; PCRE_NEWLINE_ANYCRLF <br>
/&lt;cr&gt; PCRE_NEWLINE_CR <br>
/&lt;crlf&gt; PCRE_NEWLINE_CRLF <br>
/&lt;lf&gt; PCRE_NEWLINE_LF <br>
/&lt;bsr_anycrlf&gt; PCRE_BSR_ANYCRLF <br>
/&lt;bsr_unicode&gt; PCRE_BSR_UNICODE <br>
/&lt;JS&gt; PCRE_JAVASCRIPT_COMPAT</p>

<p style="margin-top: 1em">The modifiers that are enclosed
in angle brackets are literal strings as shown, including
the angle brackets, but the letters within can be in either
case. This example sets <br>
multiline matching with CRLF as the line ending
sequence:</p>

<p style="margin-top: 1em">/^abc/m&lt;CRLF&gt;</p>

<p style="margin-top: 1em">As well as turning on the
PCRE_UTF8/16/32 option, the /8 modifier causes all
non-printing characters in output strings to be printed
using the h...} notation. Otherwise, <br>
those less than 0x100 are output in hex without the curly
brackets.</p>

<p style="margin-top: 1em">Full details of the PCRE options
are given in the pcreapi documentation.</p>

<p style="margin-top: 1em">Finding all matches in a
string</p>

<p style="margin-top: 1em">Searching for all possible
matches within each subject string can be requested by the
/g or /G modifier. After finding a match, PCRE is called
again to search the remainder of <br>
the subject string. The difference between /g and /G is that
the former uses the startoffset argument to
pcre[16|32]_exec() to start searching at a new point within
the entire <br>
string (which is in effect what Perl does), whereas the
latter passes over a shortened substring. This makes a
difference to the matching process if the pattern begins
with ao <br>
lookbehind assertion (including r0.</p>

<p style="margin-top: 1em">If any call to
pcre[16|32]_exec() in a /g or /G sequence matches an empty
string, the next call is done with the PCRE_NOTEMPTY_ATSTART
and PCRE_ANCHORED flags set in order to <br>
search for another, non-empty, match at the same point. If
this second match fails, the start offset is advanced, and
the normal match is retried. This imitates the way Perl
han&acirc; <br>
dles such cases when using the /g modifier or the split()
function. Normally, the start offset is advanced by one
character, but if the newline convention recognizes CRLF as
a <br>
newline, and the current character is CR followed by LF, an
advance of two is used.</p>

<p style="margin-top: 1em">Other modifiers</p>

<p style="margin-top: 1em">There are yet more modifiers for
controlling the way pcretest operates.</p>

<p style="margin-top: 1em">The /+ modifier requests that as
well as outputting the substring that matched the entire
pattern, pcretest should in addition output the remainder of
the subject string. This is <br>
useful for tests where the subject contains multiple copies
of the same substring. If the + modifier appears twice, the
same action is taken for captured substrings. In each case
<br>
the remainder is output on the following line with a plus
character following the capture number. Note that this
modifier must not immediately follow the /S modifier because
/S+ <br>
and /S++ have other meanings.</p>

<p style="margin-top: 1em">The /= modifier requests that
the values of all potential captured parentheses be output
after a match. By default, only those up to the highest one
actually used in the match <br>
are output (corresponding to the return code from
pcre[16|32]_exec()). Values in the offsets vector
corresponding to higher numbers should be set to -1, and
these are output as <br>
&quot;&lt;unset&gt;&quot;. This modifier gives a way of
checking that this is happening.</p>

<p style="margin-top: 1em">The /B modifier is a debugging
feature. It requests that pcretest output a representation
of the compiled code after compilation. Normally this
information contains length and <br>
offset values; however, if /Z is also present, this data is
replaced by spaces. This is a special feature for use in the
automatic test scripts; it ensures that the same output <br>
is generated for different internal link sizes.</p>

<p style="margin-top: 1em">The /D modifier is a PCRE
debugging feature, and is equivalent to /BI, that is, both
the /B and the /I modifiers.</p>

<p style="margin-top: 1em">The /F modifier causes pcretest
to flip the byte order of the 2-byte and 4-byte fields in
the compiled pattern. This facility is for testing the
feature in PCRE that allows it to <br>
execute patterns that were compiled on a host with a
different endianness. This feature is not available when the
POSIX interface to PCRE is being used, that is, when the /P
pat&acirc; <br>
tern modifier is specified. See also the section about
saving and reloading compiled patterns below.</p>

<p style="margin-top: 1em">The /I modifier requests that
pcretest output information about the compiled pattern
(whether it is anchored, has a fixed first character, and so
on). It does this by calling <br>
pcre[16|32]_fullinfo() after compiling a pattern. If the
pattern is studied, the results of that are also output.</p>

<p style="margin-top: 1em">The /K modifier requests
pcretest to show names from backtracking control verbs that
are returned from calls to pcre[16|32]_exec(). It causes
pcretest to create a <br>
pcre[16|32]_extra block if one has not already been created
by a call to pcre[16|32]_study(), and to set the
PCRE_EXTRA_MARK flag and the mark field within it, every
time that <br>
pcre[16|32]_exec() is called. If the variable that the mark
field points to is non-NULL for a match, non-match, or
partial match, pcretest prints the string to which it
points. <br>
For a match, this is shown on a line by itself, tagged with
&quot;MK:&quot;. For a non-match it is added to the
message.</p>

<p style="margin-top: 1em">The /L modifier must be followed
directly by the name of a locale, for example,</p>

<p style="margin-top: 1em">/pattern/Lfr_FR</p>

<p style="margin-top: 1em">For this reason, it must be the
last modifier. The given locale is set,
pcre[16|32]_maketables() is called to build a set of
character tables for the locale, and this is then <br>
passed to pcre[16|32]_compile() when compiling the regular
expression. Without an /L (or /T) modifier, NULL is passed
as the tables pointer; that is, /L applies only to the <br>
expression on which it appears.</p>

<p style="margin-top: 1em">The /M modifier causes the size
in bytes of the memory block used to hold the compiled
pattern to be output. This does not include the size of the
pcre[16|32] block; it is just <br>
the actual compiled data. If the pattern is successfully
studied with the PCRE_STUDY_JIT_COMPILE option, the size of
the JIT compiled code is also output.</p>

<p style="margin-top: 1em">The /S modifier causes
pcre[16|32]_study() to be called after the expression has
been compiled, and the results used when the expression is
matched. There are a number of quali&acirc; <br>
fying characters that may follow /S. They may appear in any
order.</p>

<p style="margin-top: 1em">If S is followed by an
exclamation mark, pcre[16|32]_study() is called with the
PCRE_STUDY_EXTRA_NEEDED option, causing it always to return
a pcre_extra block, even when studying <br>
discovers no useful information.</p>

<p style="margin-top: 1em">If /S is followed by a second S
character, it suppresses studying, even if it was requested
externally by the -s command line option. This makes it
possible to specify that cer&acirc; <br>
tain patterns are always studied, and others are never
studied, independently of -s. This feature is used in the
test files in a few cases where the output is different when
the <br>
pattern is studied.</p>

<p style="margin-top: 1em">If the /S modifier is followed
by a + character, the call to pcre[16|32]_study() is made
with all the JIT study options, requesting just-in-time
optimization support if it is <br>
available, for both normal and partial matching. If you want
to restrict the JIT compiling modes, you can follow /S+ with
a digit in the range 1 to 7:</p>

<p style="margin-top: 1em">1 normal match only <br>
2 soft partial match only <br>
3 normal match and soft partial match <br>
4 hard partial match only <br>
6 soft and hard partial match <br>
7 all three modes (default)</p>

<p style="margin-top: 1em">If /S++ is used instead of /S+
(with or without a following digit), the text
&quot;(JIT)&quot; is added to the first output line after a
match or no match when JIT-compiled code was actu&acirc;
<br>
ally used.</p>

<p style="margin-top: 1em">Note that there is also an
independent /+ modifier; it must not be given immediately
after /S or /S+ because this will be misinterpreted.</p>

<p style="margin-top: 1em">If JIT studying is successful,
the compiled JIT code will automatically be used when
pcre[16|32]_exec() is run, except when incompatible run-time
options are specified. For more <br>
details, see the pcrejit documentation. See also the J
escape sequence below for a way of setting the size of the
JIT stack.</p>

<p style="margin-top: 1em">Finally, if /S is followed by a
minus character, JIT compilation is suppressed, even if it
was requested externally by the -s command line option. This
makes it possible to spec&acirc; <br>
ify that JIT is never to be used for certain patterns.</p>

<p style="margin-top: 1em">The /T modifier must be followed
by a single digit. It causes a specific set of built-in
character tables to be passed to pcre[16|32]_compile(). It
is used in the standard PCRE <br>
tests to check behaviour with different character tables.
The digit specifies the tables as follows:</p>

<p style="margin-top: 1em">0 the default ASCII tables, as
distributed in <br>
pcre_chartables.c.dist <br>
1 a set of tables defining ISO 8859 characters</p>

<p style="margin-top: 1em">In table 1, some characters
whose codes are greater than 128 are identified as letters,
digits, spaces, etc.</p>

<p style="margin-top: 1em">Using the POSIX wrapper API</p>

<p style="margin-top: 1em">The /P modifier causes pcretest
to call PCRE via the POSIX wrapper API rather than its
native API. This supports only the 8-bit library. When /P is
set, the following modifiers <br>
set options for the regcomp() function:</p>

<p style="margin-top: 1em">/i REG_ICASE <br>
/m REG_NEWLINE <br>
/N REG_NOSUB <br>
/s REG_DOTALL ) <br>
/U REG_UNGREEDY ) These options are not part of <br>
/W REG_UCP ) the POSIX standard <br>
/8 REG_UTF8 )</p>

<p style="margin-top: 1em">The /+ modifier works as
described above. All other modifiers are ignored.</p>

<p style="margin-top: 1em">DATA LINES</p>

<p style="margin-top: 1em">Before each data line is passed
to pcre[16|32]_exec(), leading and trailing white space is
removed, and it is then scanned for &nbsp;escapes. Some of
these are pretty esoteric fea&acirc; <br>
tures, intended for checking out some of the more
complicated features of PCRE. If you are just testing
&quot;ordinary&quot; regular expressions, you probably
don&rsquo;t need any of these. The <br>
following escapes are recognized:</p>

<p style="margin-top: 1em">alarm (BEL, 7) <br>
backspace (8) <br>
\ escape (7) <br>
form feed (c) <br>
newline (a) <br>
qdd set the PCRE_MATCH_LIMIT limit to dd <br>
(any number of digits) <br>
carriage return (d) <br>
tab (9) <br>
vertical tab (b) <br>
0n octal character (up to 3 octal digits); always <br>
a byte unless &gt; 255 in UTF-8 or 16-bit or 32-bit mode
<br>
hexadecimal byte (up to 2 hex digits) <br>
h...} hexadecimal character (any number of hex digits) <br>
0 pass the PCRE_ANCHORED option to pcre[16|32]_exec() <br>
or pcre[16|32]_dfa_exec() <br>
0 pass the PCRE_NOTBOL option to pcre[16|32]_exec() <br>
or pcre[16|32]_dfa_exec() <br>
call pcre[16|32]_copy_substring() for substring dd <br>
after a successful match (number less than 32) <br>
call pcre[16|32]_copy_named_substring() for substring <br>
&quot;name&quot; after a successful match (name terminated
<br>
by next non alphanumeric character) <br>
show the current captured substrings at callout <br>
time <br>
do not supply a callout function <br>
return 1 instead of 0 when callout number n is <br>
reached <br>
m return 1 instead of 0 when callout number n is <br>
reached for the nth time <br>
pass the number n (may be negative) as callout <br>
data; this is used as the callout return value <br>
use the pcre[16|32]_dfa_exec() match function <br>
only shortest match for pcre[16|32]_dfa_exec() <br>
Gdd call pcre[16|32]_get_substring() for substring dd <br>
after a successful match (number less than 32) <br>
Gname call pcre[16|32]_get_named_substring() for substring
<br>
&quot;name&quot; after a successful match (name terminated
<br>
by next non-alphanumeric character) <br>
Jdd set up a JIT stack of dd kilobytes maximum (any <br>
number of digits) <br>
call pcre[16|32]_get_substringlist() after a <br>
successful match <br>
discover the minimum MATCH_LIMIT and <br>
MATCH_LIMIT_RECURSION settings <br>
pass the PCRE_NOTEMPTY option to pcre[16|32]_exec() <br>
or pcre[16|32]_dfa_exec(); if used twice, pass the <br>
PCRE_NOTEMPTY_ATSTART option <br>
d set the size of the output vector passed to <br>
pcre[16|32]_exec() to dd (any number of digits) <br>
P pass the PCRE_PARTIAL_SOFT option to pcre[16|32]_exec()
<br>
or pcre[16|32]_dfa_exec(); if used twice, pass the <br>
PCRE_PARTIAL_HARD option <br>
Qdd set the PCRE_MATCH_LIMIT_RECURSION limit to dd <br>
(any number of digits) <br>
pass the PCRE_DFA_RESTART option to pcre[16|32]_dfa_exec()
<br>
output details of memory get/free calls during matching <br>
pass the PCRE_NO_START_OPTIMIZE option to pcre[16|32]_exec()
<br>
or pcre[16|32]_dfa_exec() <br>
pass the PCRE_NOTEOL option to pcre[16|32]_exec() <br>
or pcre[16|32]_dfa_exec() <br>
pcre[16|32]_exec() or pcre[16|32]_dfa_exec() <br>
&gt;dd start the match at offset dd (optional &quot;-&quot;;
then <br>
any number of digits); this sets the startoffset <br>
argument for pcre[16|32]_exec() or pcre[16|32]_dfa_exec()
<br>
&lt;cr&gt; pass the PCRE_NEWLINE_CR option to
pcre[16|32]_exec() <br>
or pcre[16|32]_dfa_exec() <br>
&lt;lf&gt; pass the PCRE_NEWLINE_LF option to
pcre[16|32]_exec() <br>
or pcre[16|32]_dfa_exec() <br>
&lt;crlf&gt; pass the PCRE_NEWLINE_CRLF option to
pcre[16|32]_exec() <br>
or pcre[16|32]_dfa_exec() <br>
&lt;anycrlf&gt; pass the PCRE_NEWLINE_ANYCRLF option to
pcre[16|32]_exec() <br>
or pcre[16|32]_dfa_exec() <br>
&lt;any&gt; pass the PCRE_NEWLINE_ANY option to
pcre[16|32]_exec() <br>
or pcre[16|32]_dfa_exec()</p>

<p style="margin-top: 1em">The use of h...} is not
dependent on the use of the /8 modifier on the pattern. It
is recognized always. There may be any number of hexadecimal
digits inside the braces; <br>
invalid values provoke error messages.</p>

<p style="margin-top: 1em">Note that specifies one byte
rather than one character in UTF-8 mode; this makes it
possible to construct invalid UTF-8 sequences for testing
purposes. On the other hand, <br>
h} is interpreted as a UTF-8 character in UTF-8 mode,
generating more than one byte if the value is greater than
127. When testing the 8-bit library not in UTF-8 mode, <br>
h} generates one byte for values less than 256, and causes
an error for greater values.</p>

<p style="margin-top: 1em">In UTF-16 mode, all 4-digit hhh}
values are accepted. This makes it possible to construct
invalid UTF-16 sequences for testing purposes.</p>

<p style="margin-top: 1em">In UTF-32 mode, all 4- to
8-digit .} values are accepted. This makes it possible to
construct invalid UTF-32 sequences for testing purposes.</p>

<p style="margin-top: 1em">The escapes that specify line
ending sequences are literal strings, exactly as shown. No
more than one newline setting should be present in any data
line.</p>

<p style="margin-top: 1em">A backslash followed by anything
else just escapes the anything else. If the very last
character is a backslash, it is ignored. This gives a way of
passing an empty line as data, <br>
since a real empty line terminates the data input.</p>

<p style="margin-top: 1em">The J escape provides a way of
setting the maximum stack size that is used by the
just-in-time optimization code. It is ignored if JIT
optimization is not being used. Providing <br>
a stack that is larger than the default 32K is necessary
only for very complicated patterns.</p>

<p style="margin-top: 1em">If is present, pcretest calls
pcre[16|32]_exec() several times, with different values in
the match_limit and match_limit_recursion fields of the
pcre[16|32]_extra data struc&acirc; <br>
ture, until it finds the minimum numbers for each parameter
that allow pcre[16|32]_exec() to complete without error.
Because this is testing a specific feature of the normal
<br>
interpretive pcre[16|32]_exec() execution, the use of any
JIT optimization that might have been set up by the /S+
qualifier of -s+ option is disabled.</p>

<p style="margin-top: 1em">The match_limit number is a
measure of the amount of backtracking that takes place, and
checking it out can be instructive. For most simple matches,
the number is quite small, <br>
but for patterns with very large numbers of matching
possibilities, it can become large very quickly with
increasing length of subject string. The
match_limit_recursion number is <br>
a measure of how much stack (or, if PCRE is compiled with
NO_RECURSE, how much heap) memory is needed to complete the
match attempt.</p>

<p style="margin-top: 1em">When is used, the value
specified may be higher or lower than the size set by the -O
command line option (or defaulted to 45); applies only to
the call of <br>
pcre[16|32]_exec() for the line in which it appears.</p>

<p style="margin-top: 1em">If the /P modifier was present
on the pattern, causing the POSIX wrapper API to be used,
the only option-setting sequences that have any effect are 0
<br>
REG_NOTBOL, REG_NOTEMPTY, and REG_NOTEOL, respectively, to
be passed to regexec().</p>

<p style="margin-top: 1em">THE ALTERNATIVE MATCHING
FUNCTION</p>

<p style="margin-top: 1em">By default, pcretest uses the
standard PCRE matching function, pcre[16|32]_exec() to match
each data line. PCRE also supports an alternative matching
function, <br>
pcre[16|32]_dfa_test(), which operates in a different way,
and has some restrictions. The differences between the two
functions are described in the pcrematching
documentation.</p>

<p style="margin-top: 1em">If a data line contains the
sequence, or if the command line contains the -dfa option,
the alternative matching function is used. This function
finds all possible <br>
matches at a given point. If, however, the escape sequence
is present in the data line, it stops after the first match
is found. This is always the shortest possible match.</p>

<p style="margin-top: 1em">DEFAULT OUTPUT FROM PCRETEST</p>

<p style="margin-top: 1em">This section describes the
output when the normal matching function,
pcre[16|32]_exec(), is being used.</p>

<p style="margin-top: 1em">When a match succeeds, pcretest
outputs the list of captured substrings that
pcre[16|32]_exec() returns, starting with number 0 for the
string that matched the whole pattern. <br>
Otherwise, it outputs &quot;No match&quot; when the return
is PCRE_ERROR_NOMATCH, and &quot;Partial match:&quot;
followed by the partially matching substring when
pcre[16|32]_exec() returns <br>
PCRE_ERROR_PARTIAL. (Note that this is the entire substring
that was inspected during the partial match; it may include
characters before the actual match start if a lookbehind o r
0 w a s i n v o l v e d . ) <br>
assertion, K, F pcretest outputs the PCRE negative error o r
a n y o t h e r r e t u r n number and a short descriptive
phrase. If the error is a failed UTF string <br>
check, the offset of the start of the failing character and
the reason code are also output, provided that the size of
the output vector is at least two. Here is an example of an
<br>
interactive pcretest run.</p>

<p style="margin-top: 1em">$ pcretest <br>
PCRE version 8.13 2011-04-30</p>

<p style="margin-top: 1em">re&gt; /^abc(+)/ <br>
data&gt; abc123 <br>
0: abc123 <br>
1: 123 <br>
data&gt; xyz <br>
No match</p>

<p style="margin-top: 1em">Unset capturing substrings that
are not followed by one that is set are not returned by
pcre[16|32]_exec(), and are not shown by pcretest. In the
following example, there are two <br>
capturing substrings, but when the first data line is
matched, the second, unset substring is not shown. An
&quot;internal&quot; unset substring is shown as
&quot;&lt;unset&gt;&quot;, as for the second <br>
data line.</p>

<p style="margin-top: 1em">re&gt; /(a)|(b)/ <br>
data&gt; a <br>
0: a <br>
1: a <br>
data&gt; b <br>
0: b <br>
1: &lt;unset&gt; <br>
2: b</p>

<p style="margin-top: 1em">If the strings contain any
non-printing characters, they are output as escapes if the
value is less than 256 and UTF mode is not set. Otherwise
they are output as h...} <br>
escapes. See below for the definition of non-printing
characters. If the pattern has the /+ modifier, the output
for substring 0 is followed by the the rest of the subject
<br>
string, identified by &quot;0+&quot; like this:</p>

<p style="margin-top: 1em">re&gt; /cat/+ <br>
data&gt; cataract <br>
0: cat <br>
0+ aract</p>

<p style="margin-top: 1em">If the pattern has the /g or /G
modifier, the results of successive matching attempts are
output in sequence, like this:</p>

<p style="margin-top: 1em">re&gt; /0ssissippi <br>
0: iss <br>
1: ss <br>
0: iss <br>
1: ss <br>
0: ipp <br>
1: pp</p>

<p style="margin-top: 1em">&quot;No match&quot; is output
only if the first match attempt fails. Here is an example of
a failure message (the offset 4 that is specified by &gt;4
is past the end of the subject string):</p>

<p style="margin-top: 1em">re&gt; /xyz/ <br>
data&gt; xyz&gt;4 <br>
Error -24 (bad offset value)</p>

<p style="margin-top: 1em">If any of the sequences G, or
are present in a data line that is successfully matched, the
substrings extracted by the convenience functions are output
with C, G, or L <br>
after the string number instead of a colon. This is in
addition to the normal full list. The string length (that
is, the return from the extraction function) is given in
paren&acirc; <br>
theses after each string for G.</p>

<p style="margin-top: 1em">Note that whereas patterns can
be continued over several lines (a plain &quot;&gt;&quot;
prompt is used for continuations), data lines may not.
However newlines can be included in data by 0 etc.,
depending on the newline , <br>
means of the escape (or sequence setting).</p>

<p style="margin-top: 1em">OUTPUT FROM THE ALTERNATIVE
MATCHING FUNCTION</p>

<p style="margin-top: 1em">When the alternative matching
function, pcre[16|32]_dfa_exec(), is used (by means of the
sequence or the -dfa command line option), the output
consists of a list of all <br>
the matches that start at the first point in the subject
where there is at least one match. For example:</p>

<p style="margin-top: 1em">re&gt; /(tang|tangerine|tan)/
<br>
data&gt; yellow tangerine 1: tang <br>
2: tan</p>

<p style="margin-top: 1em">(Using the normal matching
function on this data finds only &quot;tang&quot;.) The
longest matching string is always given first (and numbered
zero). After a PCRE_ERROR_PARTIAL return, the <br>
output is &quot;Partial match:&quot;, followed by the
partially matching substring. (Note that this is the entire
substring that was inspected during the partial match; it
may include <br>
characters before the actual match start if a lookbehind o r
0 w a s i n assertion, K, v o l v e d . )</p>

<p style="margin-top: 1em">If /g is present on the pattern,
the search for further matches resumes at the end of the
longest match. For example:</p>

<p style="margin-top: 1em">re&gt; /(tang|tangerine|tan)/g
<br>
data&gt; yellow tangerine and tangy sultana 1: tang <br>
2: tan <br>
0: tang <br>
1: tan <br>
0: tan</p>

<p style="margin-top: 1em">Since the matching function does
not support substring capture, the escape sequences that are
concerned with captured substrings are not relevant.</p>

<p style="margin-top: 1em">RESTARTING AFTER A PARTIAL
MATCH</p>

<p style="margin-top: 1em">When the alternative matching
function has given the PCRE_ERROR_PARTIAL return, indicating
that the subject partially matched the pattern, you can
restart the match with addi&acirc; <br>
tional subject data by means of the escape sequence. For
example:</p>

<p style="margin-top: 1em">re&gt;
/^?(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)$/ <br>
data&gt; 23jaP data&gt; n05 For further information about
partial matching, see the pcrepartial documentation.</p>

<p style="margin-top: 1em">CALLOUTS</p>

<p style="margin-top: 1em">If the pattern contains any
callout requests, pcretest&rsquo;s callout function is
called during matching. This works with both matching
functions. By default, the called function dis&acirc; <br>
plays the callout number, the start and current positions in
the text at the callout time, and the next pattern item to
be tested. For example:</p>

<p style="margin-top: 1em">---&gt;pqrabcdef <br>
0 ^ ^</p>

<p style="margin-top: 1em">This output indicates that
callout number 0 occurred for a match attempt starting at
the fourth character of the subject string, when the pointer
was at the seventh character of <br>
the data, and when the next pattern item was . Just one
circumflex is output if the start and current positions are
the same.</p>

<p style="margin-top: 1em">Callouts numbered 255 are
assumed to be automatic callouts, inserted as a result of
the /C pattern modifier. In this case, instead of showing
the callout number, the offset in <br>
the pattern, preceded by a plus, is output. For example:</p>

<p style="margin-top: 1em">re&gt; /?[A-E]C <br>
data&gt; E* <br>
---&gt;E* <br>
+0 ^ ? <br>
+3 ^ [A-E] <br>
+8 ^^ <br>
+10 ^ ^ <br>
0: E*</p>

<p style="margin-top: 1em">If a pattern contains (*MARK)
items, an additional line is output whenever a change of
latest mark is passed to the callout function. For
example:</p>

<p style="margin-top: 1em">re&gt; /a(*MARK:X)bc/C <br>
data&gt; abc <br>
---&gt;abc <br>
+0 ^ a <br>
+1 ^^ (*MARK:X) <br>
+10 ^^ b <br>
Latest Mark: X <br>
+11 ^ ^ c <br>
+12 ^ ^ <br>
0: abc</p>

<p style="margin-top: 1em">The mark changes between
matching &quot;a&quot; and &quot;b&quot;, but stays the same
for the rest of the match, so nothing more is output. If, as
a result of backtracking, the mark reverts to being <br>
unset, the text &quot;&lt;unset&gt;&quot; is output.</p>

<p style="margin-top: 1em">The callout function in pcretest
returns zero (carry on matching) by default, but you can use
a in a data line (as described above) to change this and
other parameters of <br>
the callout.</p>

<p style="margin-top: 1em">Inserting callouts can be
helpful when using pcretest to check complicated regular
expressions. For further information about callouts, see the
pcrecallout documentation.</p>

<p style="margin-top: 1em">NON-PRINTING CHARACTERS</p>

<p style="margin-top: 1em">When pcretest is outputting text
in the compiled version of a pattern, bytes other than
32-126 are always treated as non-printing characters are are
therefore shown as hex <br>
escapes.</p>

<p style="margin-top: 1em">When pcretest is outputting text
that is a matched part of a subject string, it behaves in
the same way, unless a different locale has been set for the
pattern (using the /L mod&acirc; <br>
ifier). In this case, the isprint() function to distinguish
printing and non-printing characters.</p>

<p style="margin-top: 1em">SAVING AND RELOADING COMPILED
PATTERNS</p>

<p style="margin-top: 1em">The facilities described in this
section are not available when the POSIX interface to PCRE
is being used, that is, when the /P pattern modifier is
specified.</p>

<p style="margin-top: 1em">When the POSIX interface is not
in use, you can cause pcretest to write a compiled pattern
to a file, by following the modifiers with &gt; and a file
name. For example:</p>

<p style="margin-top: 1em">/pattern/im &gt;/some/file</p>

<p style="margin-top: 1em">See the pcreprecompile
documentation for a discussion about saving and re-using
compiled patterns. Note that if the pattern was successfully
studied with JIT optimization, the <br>
JIT data cannot be saved.</p>

<p style="margin-top: 1em">The data that is written is
binary. The first eight bytes are the length of the compiled
pattern data followed by the length of the optional study
data, each written as four <br>
bytes in big-endian order (most significant byte first). If
there is no study data (either the pattern was not studied,
or studying did not return any data), the second length is
<br>
zero. The lengths are followed by an exact copy of the
compiled pattern. If there is additional study data, this
(excluding any JIT data) follows immediately after the
compiled <br>
pattern. After writing the file, pcretest expects to read a
new pattern.</p>

<p style="margin-top: 1em">A saved pattern can be reloaded
into pcretest by specifying &lt; and a file name instead of
a pattern. The name of the file must not contain a &lt;
character, as otherwise pcretest <br>
will interpret the line as a pattern delimited by &lt;
characters. For example:</p>

<p style="margin-top: 1em">re&gt; &lt;/some/file <br>
Compiled pattern loaded from /some/file <br>
No study data</p>

<p style="margin-top: 1em">If the pattern was previously
studied with the JIT optimization, the JIT information
cannot be saved and restored, and so is lost. When the
pattern has been loaded, pcretest pro&acirc; <br>
ceeds to read data lines in the usual way.</p>

<p style="margin-top: 1em">You can copy a file written by
pcretest to a different host and reload it there, even if
the new host has opposite endianness to the one on which the
pattern was compiled. For <br>
example, you can compile on an i86 machine and run on a
SPARC machine. When a pattern is reloaded on a host with
different endianness, the confirmation message is changed
to:</p>

<p style="margin-top: 1em">Compiled pattern (byte-inverted)
loaded from /some/file</p>

<p style="margin-top: 1em">The test suite contains some
saved pre-compiled patterns with different endianness. These
are reloaded using &quot;&lt;!&quot; instead of just
&quot;&lt;&quot;. This suppresses the
&quot;(byte-inverted)&quot; text <br>
so that the output is the same on all hosts. It also forces
debugging output once the pattern has been reloaded.</p>

<p style="margin-top: 1em">File names for saving and
reloading can be absolute or relative, but note that the
shell facility of expanding a file name that starts with a
tilde (~) is not available.</p>

<p style="margin-top: 1em">The ability to save and reload
files in pcretest is intended for testing and
experimentation. It is not intended for production use
because only a single pattern can be written <br>
to a file. Furthermore, there is no facility for supplying
custom character tables for use with a reloaded pattern. If
the original pattern was compiled with custom tables, an
<br>
attempt to match a subject string using a reloaded pattern
is likely to cause pcretest to crash. Finally, if you
attempt to load a file that is not in the correct format,
the <br>
result is undefined.</p>

<p style="margin-top: 1em">SEE ALSO</p>

<p style="margin-top: 1em">pcre(3), pcre16(3), pcre32(3),
pcreapi(3), pcrecallout(3), pcrejit, pcrematching(3),
pcrepartial(d), pcrepattern(3), pcreprecompile(3).</p>

<p style="margin-top: 1em">AUTHOR</p>

<p style="margin-top: 1em">Philip Hazel <br>
University Computing Service <br>
Cambridge CB2 3QH, England.</p>

<p style="margin-top: 1em">REVISION</p>

<p style="margin-top: 1em">Last updated: 10 September 2012
<br>
Copyright (c) 1997-2012 University of Cambridge.</p>

<p style="margin-top: 1em">PCRE 8.32 10 September 2012
PCRETEST(1)</p>
<hr>
</body>
</html>
