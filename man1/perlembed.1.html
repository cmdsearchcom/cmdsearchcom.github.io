<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:49 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLEMBED(1) Perl Programmers Reference Guide
PERLEMBED(1)</p>

<p style="margin-top: 1em">NAME <br>
perlembed - how to embed perl in your C program</p>

<p style="margin-top: 1em">DESCRIPTION <br>
PREAMBLE <br>
Do you want to:</p>

<p style="margin-top: 1em">Use C from Perl? <br>
Read perlxstut, perlxs, h2xs, perlguts, and perlapi.</p>

<p style="margin-top: 1em">Use a Unix program from Perl?
<br>
Read about back-quotes and about &quot;system&quot; and
&quot;exec&quot; in perlfunc.</p>

<p style="margin-top: 1em">Use Perl from Perl? <br>
Read about &quot;do&quot; in perlfunc and &quot;eval&quot;
in perlfunc and &quot;require&quot; in perlfunc and
&quot;use&quot; in perlfunc.</p>

<p style="margin-top: 1em">Use C from C? <br>
Rethink your design.</p>

<p style="margin-top: 1em">Use Perl from C? <br>
Read on...</p>

<p style="margin-top: 1em">ROADMAP <br>
&Acirc;&middot; Compiling your C program</p>

<p style="margin-top: 1em">&Acirc;&middot; Adding a Perl
interpreter to your C program</p>

<p style="margin-top: 1em">&Acirc;&middot; Calling a Perl
subroutine from your C program</p>

<p style="margin-top: 1em">&Acirc;&middot; Evaluating a
Perl statement from your C program</p>

<p style="margin-top: 1em">&Acirc;&middot; Performing Perl
pattern matches and substitutions from your C program</p>

<p style="margin-top: 1em">&Acirc;&middot; Fiddling with
the Perl stack from your C program</p>

<p style="margin-top: 1em">&Acirc;&middot; Maintaining a
persistent interpreter</p>

<p style="margin-top: 1em">&Acirc;&middot; Maintaining
multiple interpreter instances</p>

<p style="margin-top: 1em">&Acirc;&middot; Using Perl
modules, which themselves use C libraries, from your C
program</p>

<p style="margin-top: 1em">&Acirc;&middot; Embedding Perl
under Win32</p>

<p style="margin-top: 1em">Compiling your C program <br>
If you have trouble compiling the scripts in this
documentation, you&rsquo;re not alone. The cardinal rule:
COMPILE THE PROGRAMS IN EXACTLY THE SAME WAY THAT YOUR PERL
WAS COMPILED. <br>
(Sorry for yelling.)</p>

<p style="margin-top: 1em">Also, every C program that uses
Perl must link in the perl library. What&rsquo;s that, you
ask? Perl is itself written in C; the perl library is the
collection of compiled C programs <br>
that were used to create your perl executable (/usr/bin/perl
or equivalent). (Corollary: you can&rsquo;t use Perl from
your C program unless Perl has been compiled on your
machine, or <br>
installed properly--that&rsquo;s why you shouldn&rsquo;t
blithely copy Perl executables from machine to machine
without also copying the lib directory.)</p>

<p style="margin-top: 1em">When you use Perl from C, your C
program will--usually--allocate, &quot;run&quot;, and
deallocate a PerlInterpreter object, which is defined by the
perl library.</p>

<p style="margin-top: 1em">If your copy of Perl is recent
enough to contain this documentation (version 5.002 or
later), then the perl library (and EXTERN.h and perl.h,
which you&rsquo;ll also need) will reside <br>
in a directory that looks like this:</p>


<p style="margin-top: 1em">/usr/local/lib/perl5/your_architecture_here/CORE</p>

<p style="margin-top: 1em">or perhaps just</p>

<p style="margin-top: 1em">/usr/local/lib/perl5/CORE</p>

<p style="margin-top: 1em">or maybe something like</p>

<p style="margin-top: 1em">/usr/opt/perl5/CORE</p>

<p style="margin-top: 1em">Execute this statement for a
hint about where to find CORE:</p>

<p style="margin-top: 1em">perl -MConfig -e &rsquo;print
$Config{archlib}&rsquo;</p>

<p style="margin-top: 1em">Here&rsquo;s how you&rsquo;d
compile the example in the next section, &quot;Adding a Perl
interpreter to your C program&quot;, on my Linux box:</p>

<p style="margin-top: 1em">% gcc -O2 -Dbool=char -DHAS_BOOL
-I/usr/local/include <br>
-I/usr/local/lib/perl5/i586-linux/5.003/CORE <br>
-L/usr/local/lib/perl5/i586-linux/5.003/CORE <br>
-o interp interp.c -lperl -lm</p>

<p style="margin-top: 1em">(That&rsquo;s all one line.) On
my DEC Alpha running old 5.003_05, the incantation is a bit
different:</p>

<p style="margin-top: 1em">% cc -O2 -Olimit 2900
-DSTANDARD_C -I/usr/local/include <br>
-I/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE <br>
-L/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE
-L/usr/local/lib <br>
-D__LANGUAGE_C__ -D_NO_PROTO -o interp interp.c -lperl
-lm</p>

<p style="margin-top: 1em">How can you figure out what to
add? Assuming your Perl is post-5.001, execute a &quot;perl
-V&quot; command and pay special attention to the
&quot;cc&quot; and &quot;ccflags&quot; information.</p>

<p style="margin-top: 1em">You&rsquo;ll have to choose the
appropriate compiler (cc, gcc, et al.) for your machine:
&quot;perl -MConfig -e &rsquo;print $Config{cc}&rsquo;&quot;
will tell you what to use.</p>

<p style="margin-top: 1em">You&rsquo;ll also have to choose
the appropriate library directory (/usr/local/lib/...) for
your machine. If your compiler complains that certain
functions are undefined, or that it <br>
can&rsquo;t locate -lperl, then you need to change the path
following the &quot;-L&quot;. If it complains that it
can&rsquo;t find EXTERN.h and perl.h, you need to change the
path following the &quot;-I&quot;.</p>

<p style="margin-top: 1em">You may have to add extra
libraries as well. Which ones? Perhaps those printed by</p>

<p style="margin-top: 1em">perl -MConfig -e &rsquo;print
$Config{libs}&rsquo;</p>

<p style="margin-top: 1em">Provided your perl binary was
properly configured and installed the ExtUtils::Embed module
will determine all of this information for you:</p>

<p style="margin-top: 1em">% cc -o interp interp.c
&lsquo;perl -MExtUtils::Embed -e ccopts -e ldopts&lsquo;</p>

<p style="margin-top: 1em">If the ExtUtils::Embed module
isn&rsquo;t part of your Perl distribution, you can retrieve
it from
http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/
(If this documentation came <br>
from your Perl distribution, then you&rsquo;re running 5.004
or better and you already have it.)</p>

<p style="margin-top: 1em">The ExtUtils::Embed kit on CPAN
also contains all source code for the examples in this
document, tests, additional examples and other information
you may find useful.</p>

<p style="margin-top: 1em">Adding a Perl interpreter to
your C program <br>
In a sense, perl (the C program) is a good example of
embedding Perl (the language), so I&rsquo;ll demonstrate
embedding with miniperlmain.c, included in the source
distribution. <br>
Here&rsquo;s a bastardized, non-portable version of
miniperlmain.c containing the essentials of embedding:</p>

<p style="margin-top: 1em">#include &lt;EXTERN.h&gt; /*
from the Perl distribution */ <br>
#include &lt;perl.h&gt; /* from the Perl distribution */</p>

<p style="margin-top: 1em">static PerlInterpreter *my_perl;
/*** The Perl interpreter ***/</p>

<p style="margin-top: 1em">int main(int argc, char **argv,
char **env) <br>
{ <br>
PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env); <br>
my_perl = perl_alloc(); <br>
perl_construct(my_perl); <br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END; <br>
perl_parse(my_perl, NULL, argc, argv, (char **)NULL); <br>
perl_run(my_perl); <br>
perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
}</p>

<p style="margin-top: 1em">Notice that we don&rsquo;t use
the &quot;env&quot; pointer. Normally handed to
&quot;perl_parse&quot; as its final argument,
&quot;env&quot; here is replaced by &quot;NULL&quot;, which
means that the current environment <br>
will be used.</p>

<p style="margin-top: 1em">The macros PERL_SYS_INIT3() and
PERL_SYS_TERM() provide system-specific tune up of the C
runtime environment necessary to run Perl interpreters; they
should only be called once <br>
regardless of how many interpreters you create or destroy.
Call PERL_SYS_INIT3() before you create your first
interpreter, and PERL_SYS_TERM() after you free your last
<br>
interpreter.</p>

<p style="margin-top: 1em">Since PERL_SYS_INIT3() may
change &quot;env&quot;, it may be more appropriate to
provide &quot;env&quot; as an argument to perl_parse().</p>

<p style="margin-top: 1em">Also notice that no matter what
arguments you pass to perl_parse(), PERL_SYS_INIT3() must be
invoked on the C main() argc, argv and env and only
once.</p>

<p style="margin-top: 1em">Now compile this program
(I&rsquo;ll call it interp.c) into an executable:</p>

<p style="margin-top: 1em">% cc -o interp interp.c
&lsquo;perl -MExtUtils::Embed -e ccopts -e ldopts&lsquo;</p>

<p style="margin-top: 1em">After a successful compilation,
you&rsquo;ll be able to use interp just like perl
itself:</p>

<p style="margin-top: 1em">% interp <br>
print &quot;Pretty Good Perl 0; <br>
print &quot;10890 - 9801 is &quot;, 10890 - 9801; <br>
&lt;CTRL-D&gt; <br>
Pretty Good Perl <br>
10890 - 9801 is 1089</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">% interp -e
&rsquo;printf(&quot;%x&quot;, 3735928559)&rsquo; <br>
deadbeef</p>

<p style="margin-top: 1em">You can also read and execute
Perl statements from a file while in the midst of your C
program, by placing the filename in argv[1] before calling
perl_run.</p>

<p style="margin-top: 1em">Calling a Perl subroutine from
your C program <br>
To call individual Perl subroutines, you can use any of the
call_* functions documented in perlcall. In this example
we&rsquo;ll use &quot;call_argv&quot;.</p>

<p style="margin-top: 1em">That&rsquo;s shown below, in a
program I&rsquo;ll call showtime.c.</p>

<p style="margin-top: 1em">#include &lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt;</p>

<p style="margin-top: 1em">static PerlInterpreter
*my_perl;</p>

<p style="margin-top: 1em">int main(int argc, char **argv,
char **env) <br>
{ <br>
char *args[] = { NULL }; <br>
PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env); <br>
my_perl = perl_alloc(); <br>
perl_construct(my_perl);</p>

<p style="margin-top: 1em">perl_parse(my_perl, NULL, argc,
argv, NULL); <br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END;</p>

<p style="margin-top: 1em">/*** skipping perl_run()
***/</p>

<p style="margin-top: 1em">call_argv(&quot;showtime&quot;,
G_DISCARD | G_NOARGS, args);</p>

<p style="margin-top: 1em">perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
}</p>

<p style="margin-top: 1em">where showtime is a Perl
subroutine that takes no arguments (that&rsquo;s the
G_NOARGS) and for which I&rsquo;ll ignore the return value
(that&rsquo;s the G_DISCARD). Those flags, and others, are
<br>
discussed in perlcall.</p>

<p style="margin-top: 1em">I&rsquo;ll define the showtime
subroutine in a file called showtime.pl:</p>

<p style="margin-top: 1em">print &quot;I shan&rsquo;t be
printed.&quot;;</p>

<p style="margin-top: 1em">sub showtime { <br>
print time; <br>
}</p>

<p style="margin-top: 1em">Simple enough. Now compile and
run:</p>

<p style="margin-top: 1em">% cc -o showtime showtime.c
&lsquo;perl -MExtUtils::Embed -e ccopts -e ldopts&lsquo;</p>

<p style="margin-top: 1em">% showtime showtime.pl <br>
818284590</p>

<p style="margin-top: 1em">yielding the number of seconds
that elapsed between January 1, 1970 (the beginning of the
Unix epoch), and the moment I began writing this
sentence.</p>

<p style="margin-top: 1em">In this particular case we
don&rsquo;t have to call perl_run, as we set the
PL_exit_flag PERL_EXIT_DESTRUCT_END which executes END
blocks in perl_destruct.</p>

<p style="margin-top: 1em">If you want to pass arguments to
the Perl subroutine, you can add strings to the
&quot;NULL&quot;-terminated &quot;args&quot; list passed to
call_argv. For other data types, or to examine return <br>
values, you&rsquo;ll need to manipulate the Perl stack.
That&rsquo;s demonstrated in &quot;Fiddling with the Perl
stack from your C program&quot;.</p>

<p style="margin-top: 1em">Evaluating a Perl statement from
your C program <br>
Perl provides two API functions to evaluate pieces of Perl
code. These are &quot;eval_sv&quot; in perlapi and
&quot;eval_pv&quot; in perlapi.</p>

<p style="margin-top: 1em">Arguably, these are the only
routines you&rsquo;ll ever need to execute snippets of Perl
code from within your C program. Your code can be as long as
you wish; it can contain multiple <br>
statements; it can employ &quot;use&quot; in perlfunc,
&quot;require&quot; in perlfunc, and &quot;do&quot; in
perlfunc to include external Perl files.</p>

<p style="margin-top: 1em">eval_pv lets us evaluate
individual Perl strings, and then extract variables for
coercion into C types. The following program, string.c,
executes three Perl strings, extracting <br>
an &quot;int&quot; from the first, a &quot;float&quot; from
the second, and a &quot;char *&quot; from the third.</p>

<p style="margin-top: 1em">#include &lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt;</p>

<p style="margin-top: 1em">static PerlInterpreter
*my_perl;</p>

<p style="margin-top: 1em">main (int argc, char **argv,
char **env) <br>
{ <br>
char *embedding[] = { &quot;&quot;, &quot;-e&quot;,
&quot;0&quot; };</p>


<p style="margin-top: 1em">PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
<br>
my_perl = perl_alloc(); <br>
perl_construct( my_perl );</p>

<p style="margin-top: 1em">perl_parse(my_perl, NULL, 3,
embedding, NULL); <br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END; <br>
perl_run(my_perl);</p>

<p style="margin-top: 1em">/** Treat $a as an integer **/
<br>
eval_pv(&quot;$a = 3; $a **= 2&quot;, TRUE); <br>
printf(&quot;a = %d0, SvIV(get_sv(&quot;a&quot;, 0)));</p>

<p style="margin-top: 1em">/** Treat $a as a float **/ <br>
eval_pv(&quot;$a = 3.14; $a **= 2&quot;, TRUE); <br>
printf(&quot;a = %f0, SvNV(get_sv(&quot;a&quot;, 0)));</p>

<p style="margin-top: 1em">/** Treat $a as a string **/
<br>
eval_pv(&quot;$a = &rsquo;rekcaH lreP rehtonA tsuJ&rsquo;;
$a = reverse($a);&quot;, TRUE); <br>
printf(&quot;a = %s0, SvPV_nolen(get_sv(&quot;a&quot;,
0)));</p>

<p style="margin-top: 1em">perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
}</p>

<p style="margin-top: 1em">All of those strange functions
with sv in their names help convert Perl scalars to C types.
They&rsquo;re described in perlguts and perlapi.</p>

<p style="margin-top: 1em">If you compile and run string.c,
you&rsquo;ll see the results of using SvIV() to create an
&quot;int&quot;, SvNV() to create a &quot;float&quot;, and
SvPV() to create a string:</p>

<p style="margin-top: 1em">a = 9 <br>
a = 9.859600 <br>
a = Just Another Perl Hacker</p>

<p style="margin-top: 1em">In the example above,
we&rsquo;ve created a global variable to temporarily store
the computed value of our eval&rsquo;ed expression. It is
also possible and in most cases a better strategy <br>
to fetch the return value from eval_pv() instead.
Example:</p>

<p style="margin-top: 1em">... <br>
SV *val = eval_pv(&quot;reverse &rsquo;rekcaH lreP rehtonA
tsuJ&rsquo;&quot;, TRUE); <br>
printf(&quot;%s0, SvPV_nolen(val)); <br>
...</p>

<p style="margin-top: 1em">This way, we avoid namespace
pollution by not creating global variables and we&rsquo;ve
simplified our code as well.</p>

<p style="margin-top: 1em">Performing Perl pattern matches
and substitutions from your C program <br>
The eval_sv() function lets us evaluate strings of Perl
code, so we can define some functions that use it to
&quot;specialize&quot; in matches and substitutions:
match(), substitute(), and <br>
matches().</p>

<p style="margin-top: 1em">I32 match(SV *string, char
*pattern); 2 0 \ b / &quot; ) , m a t c h ( ) r e t u r n s
1 i f t h</p>

<p style="margin-top: 1em">Given a string and a pattern
(e.g., &quot;m/clasp/&quot; or &quot;/e s t r i n g m a t c
h e s t h e p a t t e r n a n d 0 <br>
otherwise.</p>

<p style="margin-top: 1em">int substitute(SV **string, char
*pattern);</p>

<p style="margin-top: 1em">Given a pointer to an
&quot;SV&quot; and an &quot;=~&quot; operation (e.g.,
&quot;s/bob/robert/g&quot; or &quot;tr[A-Z][a-z]&quot;),
substitute() modifies the string within the &quot;SV&quot;
as according to the operation, <br>
returning the number of substitutions made.</p>

<p style="margin-top: 1em">int matches(SV *string, char
*pattern, AV **matches);</p>

<p style="margin-top: 1em">Given an &quot;SV&quot;, a
pattern, and a pointer to an empty &quot;AV&quot;, matches()
evaluates &quot;$string =~ $pattern&quot; in a list context,
and fills in matches with the array elements, returning the
<br>
number of matches found.</p>

<p style="margin-top: 1em">Here&rsquo;s a sample program,
match.c, that uses all three (long lines have been wrapped
here):</p>

<p style="margin-top: 1em">#include &lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt;</p>

<p style="margin-top: 1em">static PerlInterpreter
*my_perl;</p>

<p style="margin-top: 1em">/** my_eval_sv(code,
error_check) <br>
** kinda like eval_sv(), <br>
** but we pop the return value off the stack <br>
**/ <br>
SV* my_eval_sv(SV *sv, I32 croak_on_error) <br>
{ <br>
dSP; <br>
SV* retval;</p>

<p style="margin-top: 1em">PUSHMARK(SP); <br>
eval_sv(sv, G_SCALAR);</p>

<p style="margin-top: 1em">SPAGAIN; <br>
retval = POPs; <br>
PUTBACK;</p>

<p style="margin-top: 1em">if (croak_on_error &amp;&amp;
SvTRUE(ERRSV)) <br>
croak(SvPVx_nolen(ERRSV));</p>

<p style="margin-top: 1em">return retval; <br>
}</p>

<p style="margin-top: 1em">/** match(string, pattern) <br>
** <br>
** Used for matches in a scalar context. <br>
** <br>
** Returns 1 if the match was successful; 0 otherwise. <br>
**/</p>

<p style="margin-top: 1em">I32 match(SV *string, char
*pattern) <br>
{ <br>
SV *command = newSV(0), *retval;</p>

<p style="margin-top: 1em">sv_setpvf(command, &quot;my
$string = &rsquo;%s&rsquo;; $string =~ %s&quot;, <br>
SvPV_nolen(string), pattern);</p>

<p style="margin-top: 1em">retval = my_eval_sv(command,
TRUE); <br>
SvREFCNT_dec(command);</p>

<p style="margin-top: 1em">return SvIV(retval); <br>
}</p>

<p style="margin-top: 1em">/** substitute(string, pattern)
<br>
** <br>
** Used for =~ operations that modify their left-hand side
(s/// and tr///) <br>
** <br>
** Returns the number of successful matches, and <br>
** modifies the input string if there were any. <br>
**/</p>

<p style="margin-top: 1em">I32 substitute(SV **string, char
*pattern) <br>
{ <br>
SV *command = newSV(0), *retval;</p>

<p style="margin-top: 1em">sv_setpvf(command, &quot;$string
= &rsquo;%s&rsquo;; ($string =~ %s)&quot;, <br>
SvPV_nolen(*string), pattern);</p>

<p style="margin-top: 1em">retval = my_eval_sv(command,
TRUE); <br>
SvREFCNT_dec(command);</p>

<p style="margin-top: 1em">*string =
get_sv(&quot;string&quot;, 0); <br>
return SvIV(retval); <br>
}</p>

<p style="margin-top: 1em">/** matches(string, pattern,
matches) <br>
** <br>
** Used for matches in a list context. <br>
** <br>
** Returns the number of matches, <br>
** and fills in **matches with the matching substrings <br>
**/</p>

<p style="margin-top: 1em">I32 matches(SV *string, char
*pattern, AV **match_list) <br>
{ <br>
SV *command = newSV(0); <br>
I32 num_matches;</p>

<p style="margin-top: 1em">sv_setpvf(command, &quot;my
$string = &rsquo;%s&rsquo;; @array = ($string =~ %s)&quot;,
<br>
SvPV_nolen(string), pattern);</p>

<p style="margin-top: 1em">my_eval_sv(command, TRUE); <br>
SvREFCNT_dec(command);</p>

<p style="margin-top: 1em">*match_list =
get_av(&quot;array&quot;, 0); <br>
num_matches = av_len(*match_list) + 1;</p>

<p style="margin-top: 1em">return num_matches; <br>
}</p>

<p style="margin-top: 1em">main (int argc, char **argv,
char **env) <br>
{ <br>
char *embedding[] = { &quot;&quot;, &quot;-e&quot;,
&quot;0&quot; }; <br>
AV *match_list; <br>
I32 num_matches, i; <br>
SV *text;</p>


<p style="margin-top: 1em">PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
<br>
my_perl = perl_alloc(); <br>
perl_construct(my_perl); <br>
perl_parse(my_perl, NULL, 3, embedding, NULL); <br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END;</p>

<p style="margin-top: 1em">text = newSV(0); <br>
sv_setpv(text, &quot;When he is at a convenience store and
the &quot; <br>
&quot;bill comes to some amount like 76 cents, Maynard is
&quot; <br>
&quot;aware that there is something he *should* do,
something &quot; <br>
&quot;that will enable him to get back a quarter, but he has
&quot; <br>
&quot;no idea *what*. He fumbles through his red squeezey
&quot; <br>
&quot;changepurse and gives the boy three extra pennies with
&quot; <br>
&quot;his dollar, hoping that he might luck into the correct
&quot; <br>
&quot;amount. The boy gives him back two of his own pennies
&quot; <br>
&quot;and then the big shiny quarter that is his prize.
&quot; <br>
&quot;-RICHH&quot;);</p>

<p style="margin-top: 1em">if (match(text,
&quot;m/quarter/&quot;)) /** Does text contain
&rsquo;quarter&rsquo;? **/ <br>
printf(&quot;match: Text contains the word
&rsquo;quarter&rsquo;.0); <br>
else <br>
printf(&quot;match: Text doesn&rsquo;t contain the word
&rsquo;quarter&rsquo;.0);</p>

<p style="margin-top: 1em">if (match(text,
&quot;m/eighth/&quot;)) /** Does text contain
&rsquo;eighth&rsquo;? **/ <br>
printf(&quot;match: Text contains the word
&rsquo;eighth&rsquo;.0); <br>
else <br>
printf(&quot;match: Text doesn&rsquo;t contain the word
&rsquo;eighth&rsquo;.0);</p>

<p style="margin-top: 1em">/** Match all occurrences of
/wi../ **/ <br>
num_matches = matches(text, &quot;m/(wi..)/g&quot;,
&amp;match_list); <br>
printf(&quot;matches: m/(wi..)/g found %d matches...0,
num_matches);</p>

<p style="margin-top: 1em">for (i = 0; i &lt; num_matches;
i++) <br>
printf(&quot;match: %s0, SvPV_nolen(*av_fetch(match_list, i,
FALSE))); <br>
printf(&quot;0);</p>

<p style="margin-top: 1em">/** Remove all vowels from text
**/ <br>
num_matches = substitute(&amp;text,
&quot;s/[aeiou]//gi&quot;); <br>
if (num_matches) { <br>
printf(&quot;substitute: s/[aeiou]//gi...%d substitutions
made.0, <br>
num_matches); <br>
printf(&quot;Now text is: %s0, SvPV_nolen(text)); <br>
}</p>

<p style="margin-top: 1em">/** Attempt a substitution **/
<br>
if (!substitute(&amp;text, &quot;s/Perl/C/&quot;)) { <br>
printf(&quot;substitute: s/Perl/C...No substitution made.0);
<br>
}</p>

<p style="margin-top: 1em">SvREFCNT_dec(text); <br>
PL_perl_destruct_level = 1; <br>
perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
}</p>

<p style="margin-top: 1em">which produces the output
(again, long lines have been wrapped here)</p>

<p style="margin-top: 1em">match: Text contains the word
&rsquo;quarter&rsquo;.</p>

<p style="margin-top: 1em">match: Text doesn&rsquo;t
contain the word &rsquo;eighth&rsquo;.</p>

<p style="margin-top: 1em">matches: m/(wi..)/g found 2
matches... <br>
match: will <br>
match: with</p>

<p style="margin-top: 1em">substitute: s/[aeiou]//gi...139
substitutions made. <br>
Now text is: Whn h s t cnvnnc str nd th bll cms t sm mnt lk
76 cnts, <br>
Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl
hm t gt bck <br>
qrtr, bt h hs n d *wht*. H fmbls thrgh hs rd sqzy chngprs nd
gvs th by <br>
thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct
mnt. Th by gvs <br>
hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz.
-RCHH</p>

<p style="margin-top: 1em">substitute: s/Perl/C...No
substitution made.</p>

<p style="margin-top: 1em">Fiddling with the Perl stack
from your C program <br>
When trying to explain stacks, most computer science
textbooks mumble something about spring-loaded columns of
cafeteria plates: the last thing you pushed on the stack is
the <br>
first thing you pop off. That&rsquo;ll do for our purposes:
your C program will push some arguments onto &quot;the Perl
stack&quot;, shut its eyes while some magic happens, and
then pop the <br>
results--the return value of your Perl subroutine--off the
stack.</p>

<p style="margin-top: 1em">First you&rsquo;ll need to know
how to convert between C types and Perl types, with
newSViv() and sv_setnv() and newAV() and all their friends.
They&rsquo;re described in perlguts and <br>
perlapi.</p>

<p style="margin-top: 1em">Then you&rsquo;ll need to know
how to manipulate the Perl stack. That&rsquo;s described in
perlcall.</p>

<p style="margin-top: 1em">Once you&rsquo;ve understood
those, embedding Perl in C is easy.</p>

<p style="margin-top: 1em">Because C has no builtin
function for integer exponentiation, let&rsquo;s make
Perl&rsquo;s ** operator available to it (this is less
useful than it sounds, because Perl implements ** with <br>
C&rsquo;s pow() function). First I&rsquo;ll create a stub
exponentiation function in power.pl:</p>

<p style="margin-top: 1em">sub expo { <br>
my ($a, $b) = @_; <br>
return $a ** $b; <br>
}</p>

<p style="margin-top: 1em">Now I&rsquo;ll create a C
program, power.c, with a function PerlPower() that contains
all the perlguts necessary to push the two arguments into
expo() and to pop the return value out. <br>
Take a deep breath...</p>

<p style="margin-top: 1em">#include &lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt;</p>

<p style="margin-top: 1em">static PerlInterpreter
*my_perl;</p>

<p style="margin-top: 1em">static void <br>
PerlPower(int a, int b) <br>
{ <br>
dSP; /* initialize stack pointer */ <br>
ENTER; /* everything created after here */ <br>
SAVETMPS; /* ...is a temporary variable. */ <br>
PUSHMARK(SP); /* remember the stack pointer */ <br>
XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the
stack */ <br>
XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto
stack */ <br>
PUTBACK; /* make local stack pointer global */ <br>
call_pv(&quot;expo&quot;, G_SCALAR); /* call the function */
<br>
SPAGAIN; /* refresh stack pointer */ <br>
/* pop the return value from stack */ <br>
printf (&quot;%d to the %dth power is %d.0, a, b, POPi);
<br>
PUTBACK; <br>
FREETMPS; /* free that return value */ <br>
LEAVE; /* ...and the XPUSHed &quot;mortal&quot; args.*/ <br>
}</p>

<p style="margin-top: 1em">int main (int argc, char **argv,
char **env) <br>
{ <br>
char *my_argv[] = { &quot;&quot;, &quot;power.pl&quot;
};</p>


<p style="margin-top: 1em">PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
<br>
my_perl = perl_alloc(); <br>
perl_construct( my_perl );</p>

<p style="margin-top: 1em">perl_parse(my_perl, NULL, 2,
my_argv, (char **)NULL); <br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END; <br>
perl_run(my_perl);</p>

<p style="margin-top: 1em">PerlPower(3, 4); /*** Compute 3
** 4 ***/</p>

<p style="margin-top: 1em">perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
}</p>

<p style="margin-top: 1em">Compile and run:</p>

<p style="margin-top: 1em">% cc -o power power.c
&lsquo;perl -MExtUtils::Embed -e ccopts -e ldopts&lsquo;</p>

<p style="margin-top: 1em">% power <br>
3 to the 4th power is 81.</p>

<p style="margin-top: 1em">Maintaining a persistent
interpreter <br>
When developing interactive and/or potentially long-running
applications, it&rsquo;s a good idea to maintain a
persistent interpreter rather than allocating and
constructing a new <br>
interpreter multiple times. The major reason is speed: since
Perl will only be loaded into memory once.</p>

<p style="margin-top: 1em">However, you have to be more
cautious with namespace and variable scoping when using a
persistent interpreter. In previous examples we&rsquo;ve
been using global variables in the <br>
default package &quot;main&quot;. We knew exactly what code
would be run, and assumed we could avoid variable collisions
and outrageous symbol table growth.</p>

<p style="margin-top: 1em">Let&rsquo;s say your application
is a server that will occasionally run Perl code from some
arbitrary file. Your server has no way of knowing what code
it&rsquo;s going to run. Very <br>
dangerous.</p>

<p style="margin-top: 1em">If the file is pulled in by
&quot;perl_parse()&quot;, compiled into a newly constructed
interpreter, and subsequently cleaned out with
&quot;perl_destruct()&quot; afterwards, you&rsquo;re
shielded from <br>
most namespace troubles.</p>

<p style="margin-top: 1em">One way to avoid namespace
collisions in this scenario is to translate the filename
into a guaranteed-unique package name, and then compile the
code into that package using <br>
&quot;eval&quot; in perlfunc. In the example below, each
file will only be compiled once. Or, the application might
choose to clean out the symbol table associated with the
file after <br>
it&rsquo;s no longer needed. Using &quot;call_argv&quot; in
perlapi, We&rsquo;ll call the subroutine
&quot;Embed::Persistent::eval_file&quot; which lives in the
file &quot;persistent.pl&quot; and pass the filename and
<br>
boolean cleanup/cache flag as arguments.</p>

<p style="margin-top: 1em">Note that the process will
continue to grow for each file that it uses. In addition,
there might be &quot;AUTOLOAD&quot;ed subroutines and other
conditions that cause Perl&rsquo;s symbol table <br>
to grow. You might want to add some logic that keeps track
of the process size, or restarts itself after a certain
number of requests, to ensure that memory consumption is
<br>
minimized. You&rsquo;ll also want to scope your variables
with &quot;my&quot; in perlfunc whenever possible.</p>

<p style="margin-top: 1em">package Embed::Persistent; <br>
#persistent.pl</p>

<p style="margin-top: 1em">use strict; <br>
our %Cache; <br>
use Symbol qw(delete_package);</p>

<p style="margin-top: 1em">sub valid_package_name { <br>
my($string) = @_; <br>
$string =~
s/([^A-Za-z0-9])/sprintf(&quot;_%2x&quot;,unpack(&quot;C&quot;,$1))/eg;
<br>
# second pass only for words starting with a digit <br>
$string =~
s|/()|sprintf(&quot;/_%2x&quot;,unpack(&quot;C&quot;,$1))|eg;</p>

<p style="margin-top: 1em"># Dress it up as a real package
name <br>
$string =~ s|/|::|g; <br>
return &quot;Embed&quot; . $string; <br>
}</p>

<p style="margin-top: 1em">sub eval_file { <br>
my($filename, $delete) = @_; <br>
my $package = valid_package_name($filename); <br>
my $mtime = -M $filename; <br>
if(defined $Cache{$package}{mtime} <br>
&amp;&amp; <br>
$Cache{$package}{mtime} &lt;= $mtime) <br>
{ <br>
# we have compiled this subroutine already, <br>
# it has not been updated on disk, nothing left to do <br>
print STDERR &quot;already compiled $package-&gt;handler0;
<br>
} <br>
else { <br>
local *FH; <br>
open FH, $filename or die &quot;open &rsquo;$filename&rsquo;
$!&quot;; <br>
local($/) = undef; <br>
my $sub = &lt;FH&gt;; <br>
close FH;</p>

<p style="margin-top: 1em">#wrap the code into a subroutine
inside our unique package <br>
my $eval = qq{package $package; sub handler { $sub; }}; <br>
{ <br>
# hide our variables within this block <br>
my($filename,$mtime,$package,$sub); <br>
eval $eval; <br>
} <br>
die $@ if $@;</p>

<p style="margin-top: 1em">#cache it unless we&rsquo;re
cleaning out each time <br>
$Cache{$package}{mtime} = $mtime unless $delete; <br>
}</p>

<p style="margin-top: 1em">eval {$package-&gt;handler;};
<br>
die $@ if $@;</p>

<p style="margin-top: 1em">delete_package($package) if
$delete;</p>

<p style="margin-top: 1em">#take a look if you want <br>
#print Devel::Symdump-&gt;rnew($package)-&gt;as_string, $/;
<br>
}</p>

<p style="margin-top: 1em">1;</p>

<p style="margin-top: 1em">__END__</p>

<p style="margin-top: 1em">/* persistent.c */ <br>
#include &lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt;</p>

<p style="margin-top: 1em">/* 1 = clean out
filename&rsquo;s symbol table after each request, 0 =
don&rsquo;t */ <br>
#ifndef DO_CLEAN <br>
#define DO_CLEAN 0 <br>
#endif</p>

<p style="margin-top: 1em">#define BUFFER_SIZE 1024</p>

<p style="margin-top: 1em">static PerlInterpreter *my_perl
= NULL;</p>

<p style="margin-top: 1em">int <br>
main(int argc, char **argv, char **env) <br>
{ <br>
char *embedding[] = { &quot;&quot;,
&quot;persistent.pl&quot; }; <br>
char *args[] = { &quot;&quot;, DO_CLEAN, NULL }; <br>
char filename[BUFFER_SIZE]; <br>
int exitstatus = 0;</p>


<p style="margin-top: 1em">PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
<br>
if((my_perl = perl_alloc()) == NULL) { <br>
fprintf(stderr, &quot;no memory!&quot;); <br>
exit(1); <br>
} <br>
perl_construct(my_perl);</p>

<p style="margin-top: 1em">PL_origalen = 1; /* don&rsquo;t
let $0 assignment update the proctitle or embedding[0] */
<br>
exitstatus = perl_parse(my_perl, NULL, 2, embedding, NULL);
<br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END; <br>
if(!exitstatus) { <br>
exitstatus = perl_run(my_perl);</p>

<p style="margin-top: 1em">while(printf(&quot;Enter file
name: &quot;) &amp;&amp; <br>
fgets(filename, BUFFER_SIZE, stdin)) {</p>

<p style="margin-top: 1em">filename[strlen(filename)-1] =
&rsquo; &rsquo;; /* strip */ <br>
/* call the subroutine, passing it the filename as an
argument */ <br>
args[0] = filename; <br>
call_argv(&quot;Embed::Persistent::eval_file&quot;, <br>
G_DISCARD | G_EVAL, args);</p>

<p style="margin-top: 1em">/* check $@ */ <br>
if(SvTRUE(ERRSV)) <br>
fprintf(stderr, &quot;eval error: %s0, SvPV_nolen(ERRSV));
<br>
} <br>
}</p>

<p style="margin-top: 1em">PL_perl_destruct_level = 0; <br>
perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
exit(exitstatus); <br>
}</p>

<p style="margin-top: 1em">Now compile:</p>

<p style="margin-top: 1em">% cc -o persistent persistent.c
&lsquo;perl -MExtUtils::Embed -e ccopts -e ldopts&lsquo;</p>

<p style="margin-top: 1em">Here&rsquo;s an example script
file:</p>

<p style="margin-top: 1em">#test.pl <br>
my $string = &quot;hello&quot;; <br>
foo($string);</p>

<p style="margin-top: 1em">sub foo { <br>
print &quot;foo says: @_0; <br>
}</p>

<p style="margin-top: 1em">Now run:</p>

<p style="margin-top: 1em">% persistent <br>
Enter file name: test.pl <br>
foo says: hello <br>
Enter file name: test.pl <br>
already compiled Embed::test_2epl-&gt;handler <br>
foo says: hello <br>
Enter file name: ^C</p>

<p style="margin-top: 1em">Execution of END blocks <br>
Traditionally END blocks have been executed at the end of
the perl_run. This causes problems for applications that
never call perl_run. Since perl 5.7.2 you can specify <br>
&quot;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&quot; to get
the new behaviour. This also enables the running of END
blocks if the perl_parse fails and &quot;perl_destruct&quot;
will return the exit <br>
value.</p>

<p style="margin-top: 1em">$0 assignments <br>
When a perl script assigns a value to $0 then the perl
runtime will try to make this value show up as the program
name reported by &quot;ps&quot; by updating the memory
pointed to by the <br>
argv passed to perl_parse() and also calling API functions
like setproctitle() where available. This behaviour might
not be appropriate when embedding perl and can be disabled
<br>
by assigning the value 1 to the variable
&quot;PL_origalen&quot; before perl_parse() is called.</p>

<p style="margin-top: 1em">The persistent.c example above
is for instance likely to segfault when $0 is assigned to if
the &quot;PL_origalen = 1;&quot; assignment is removed. This
because perl will try to write to <br>
the read only memory of the &quot;embedding[]&quot;
strings.</p>

<p style="margin-top: 1em">Maintaining multiple interpreter
instances <br>
Some rare applications will need to create more than one
interpreter during a session. Such an application might
sporadically decide to release any resources associated with
the <br>
interpreter.</p>

<p style="margin-top: 1em">The program must take care to
ensure that this takes place before the next interpreter is
constructed. By default, when perl is not built with any
special options, the global <br>
variable &quot;PL_perl_destruct_level&quot; is set to 0,
since extra cleaning isn&rsquo;t usually needed when a
program only ever creates a single interpreter in its entire
lifetime.</p>

<p style="margin-top: 1em">Setting
&quot;PL_perl_destruct_level&quot; to 1 makes everything
squeaky clean:</p>

<p style="margin-top: 1em">while(1) { <br>
... <br>
/* reset global variables here with PL_perl_destruct_level =
1 */ <br>
PL_perl_destruct_level = 1; <br>
perl_construct(my_perl); <br>
... <br>
/* clean and reset _everything_ during perl_destruct */ <br>
PL_perl_destruct_level = 1; <br>
perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
... <br>
/* let&rsquo;s go do it again! */ <br>
}</p>

<p style="margin-top: 1em">When perl_destruct() is called,
the interpreter&rsquo;s syntax parse tree and symbol tables
are cleaned up, and global variables are reset. The second
assignment to <br>
&quot;PL_perl_destruct_level&quot; is needed because
perl_construct resets it to 0.</p>

<p style="margin-top: 1em">Now suppose we have more than
one interpreter instance running at the same time. This is
feasible, but only if you used the Configure option
&quot;-Dusemultiplicity&quot; or the options <br>
&quot;-Dusethreads -Duseithreads&quot; when building perl.
By default, enabling one of these Configure options sets the
per-interpreter global variable
&quot;PL_perl_destruct_level&quot; to 1, so <br>
that thorough cleaning is automatic and interpreter
variables are initialized correctly. Even if you don&rsquo;t
intend to run two or more interpreters at the same time, but
to run <br>
them sequentially, like in the above example, it is
recommended to build perl with the
&quot;-Dusemultiplicity&quot; option otherwise some
interpreter variables may not be initialized <br>
correctly between consecutive runs and your application may
crash.</p>

<p style="margin-top: 1em">See also &quot;Thread-aware
system interfaces&quot; in perlxs.</p>

<p style="margin-top: 1em">Using &quot;-Dusethreads
-Duseithreads&quot; rather than
&quot;-Dusemultiplicity&quot; is more appropriate if you
intend to run multiple interpreters concurrently in
different threads, because it <br>
enables support for linking in the thread libraries of your
system with the interpreter.</p>

<p style="margin-top: 1em">Let&rsquo;s give it a try:</p>

<p style="margin-top: 1em">#include &lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt;</p>

<p style="margin-top: 1em">/* we&rsquo;re going to embed
two interpreters */</p>

<p style="margin-top: 1em">#define SAY_HELLO
&quot;-e&quot;, &quot;print qq(Hi, I&rsquo;m $^X0&quot;</p>

<p style="margin-top: 1em">int main(int argc, char **argv,
char **env) <br>
{ <br>
PerlInterpreter *one_perl, *two_perl; <br>
char *one_args[] = { &quot;one_perl&quot;, SAY_HELLO }; <br>
char *two_args[] = { &quot;two_perl&quot;, SAY_HELLO };</p>


<p style="margin-top: 1em">PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
<br>
one_perl = perl_alloc(); <br>
two_perl = perl_alloc();</p>

<p style="margin-top: 1em">PERL_SET_CONTEXT(one_perl); <br>
perl_construct(one_perl); <br>
PERL_SET_CONTEXT(two_perl); <br>
perl_construct(two_perl);</p>

<p style="margin-top: 1em">PERL_SET_CONTEXT(one_perl); <br>
perl_parse(one_perl, NULL, 3, one_args, (char **)NULL); <br>
PERL_SET_CONTEXT(two_perl); <br>
perl_parse(two_perl, NULL, 3, two_args, (char **)NULL);</p>

<p style="margin-top: 1em">PERL_SET_CONTEXT(one_perl); <br>
perl_run(one_perl); <br>
PERL_SET_CONTEXT(two_perl); <br>
perl_run(two_perl);</p>

<p style="margin-top: 1em">PERL_SET_CONTEXT(one_perl); <br>
perl_destruct(one_perl); <br>
PERL_SET_CONTEXT(two_perl); <br>
perl_destruct(two_perl);</p>

<p style="margin-top: 1em">PERL_SET_CONTEXT(one_perl); <br>
perl_free(one_perl); <br>
PERL_SET_CONTEXT(two_perl); <br>
perl_free(two_perl); <br>
PERL_SYS_TERM(); <br>
}</p>

<p style="margin-top: 1em">Note the calls to
PERL_SET_CONTEXT(). These are necessary to initialize the
global state that tracks which interpreter is the
&quot;current&quot; one on the particular process or thread
<br>
that may be running it. It should always be used if you have
more than one interpreter and are making perl API calls on
both interpreters in an interleaved fashion.</p>

<p style="margin-top: 1em">PERL_SET_CONTEXT(interp) should
also be called whenever &quot;interp&quot; is used by a
thread that did not create it (using either perl_alloc(), or
the more esoteric perl_clone()).</p>

<p style="margin-top: 1em">Compile as usual:</p>

<p style="margin-top: 1em">% cc -o multiplicity
multiplicity.c &lsquo;perl -MExtUtils::Embed -e ccopts -e
ldopts&lsquo;</p>

<p style="margin-top: 1em">Run it, Run it:</p>

<p style="margin-top: 1em">% multiplicity <br>
Hi, I&rsquo;m one_perl <br>
Hi, I&rsquo;m two_perl</p>

<p style="margin-top: 1em">Using Perl modules, which
themselves use C libraries, from your C program <br>
If you&rsquo;ve played with the examples above and tried to
embed a script that use()s a Perl module (such as Socket)
which itself uses a C or C++ library, this probably
happened:</p>

<p style="margin-top: 1em">Can&rsquo;t load module Socket,
dynamic loading not available in this perl. <br>
(You may need to build a new perl executable which either
supports <br>
dynamic loading or has the Socket module statically linked
into it.)</p>

<p style="margin-top: 1em">What&rsquo;s wrong?</p>

<p style="margin-top: 1em">Your interpreter doesn&rsquo;t
know how to communicate with these extensions on its own. A
little glue will help. Up until now you&rsquo;ve been
calling perl_parse(), handing it NULL for <br>
the second argument:</p>

<p style="margin-top: 1em">perl_parse(my_perl, NULL, argc,
my_argv, NULL);</p>

<p style="margin-top: 1em">That&rsquo;s where the glue code
can be inserted to create the initial contact between Perl
and linked C/C++ routines. Let&rsquo;s take a look some
pieces of perlmain.c to see how Perl does <br>
this:</p>

<p style="margin-top: 1em">static void xs_init (pTHX);</p>

<p style="margin-top: 1em">EXTERN_C void boot_DynaLoader
(pTHX_ CV* cv); <br>
EXTERN_C void boot_Socket (pTHX_ CV* cv);</p>

<p style="margin-top: 1em">EXTERN_C void <br>
xs_init(pTHX) <br>
{ <br>
char *file = __FILE__; <br>
/* DynaLoader is a special case */ <br>
newXS(&quot;DynaLoader::boot_DynaLoader&quot;,
boot_DynaLoader, file); <br>
newXS(&quot;Socket::bootstrap&quot;, boot_Socket, file);
<br>
}</p>

<p style="margin-top: 1em">Simply put: for each extension
linked with your Perl executable (determined during its
initial configuration on your computer or when adding a new
extension), a Perl subroutine <br>
is created to incorporate the extension&rsquo;s routines.
Normally, that subroutine is named Module::bootstrap() and
is invoked when you say use Module. In turn, this hooks into
an <br>
XSUB, boot_Module, which creates a Perl counterpart for each
of the extension&rsquo;s XSUBs. Don&rsquo;t worry about this
part; leave that to the xsubpp and extension authors. If
your <br>
extension is dynamically loaded, DynaLoader creates
Module::bootstrap() for you on the fly. In fact, if you have
a working DynaLoader then there is rarely any need to link
in <br>
any other extensions statically.</p>

<p style="margin-top: 1em">Once you have this code, slap it
into the second argument of perl_parse():</p>

<p style="margin-top: 1em">perl_parse(my_perl, xs_init,
argc, my_argv, NULL);</p>

<p style="margin-top: 1em">Then compile:</p>

<p style="margin-top: 1em">% cc -o interp interp.c
&lsquo;perl -MExtUtils::Embed -e ccopts -e ldopts&lsquo;</p>

<p style="margin-top: 1em">% interp <br>
use Socket; <br>
use SomeDynamicallyLoadedModule;</p>

<p style="margin-top: 1em">print &quot;Now I can use
extensions!0&rsquo;</p>

<p style="margin-top: 1em">ExtUtils::Embed can also
automate writing the xs_init glue code.</p>

<p style="margin-top: 1em">% perl -MExtUtils::Embed -e
xsinit -- -o perlxsi.c <br>
% cc -c perlxsi.c &lsquo;perl -MExtUtils::Embed -e
ccopts&lsquo; <br>
% cc -c interp.c &lsquo;perl -MExtUtils::Embed -e
ccopts&lsquo; <br>
% cc -o interp perlxsi.o interp.o &lsquo;perl
-MExtUtils::Embed -e ldopts&lsquo;</p>

<p style="margin-top: 1em">Consult perlxs, perlguts, and
perlapi for more details.</p>

<p style="margin-top: 1em">Hiding Perl_ <br>
If you completely hide the short forms of the Perl public
API, add -DPERL_NO_SHORT_NAMES to the compilation flags.
This means that for example instead of writing</p>

<p style="margin-top: 1em">warn(&quot;%d bottles of beer on
the wall&quot;, bottlecount);</p>

<p style="margin-top: 1em">you will have to write the
explicit full form</p>

<p style="margin-top: 1em">Perl_warn(aTHX_ &quot;%d bottles
of beer on the wall&quot;, bottlecount);</p>

<p style="margin-top: 1em">(See &quot;Background and
PERL_IMPLICIT_CONTEXT&quot; in perlguts for the explanation
of the &quot;aTHX_&quot;. ) Hiding the short forms is very
useful for avoiding all sorts of nasty (C <br>
preprocessor or otherwise) conflicts with other software
packages (Perl defines about 2400 APIs with these short
names, take or leave few hundred, so there certainly is room
for <br>
conflict.)</p>

<p style="margin-top: 1em">MORAL <br>
You can sometimes write faster code in C, but you can always
write code faster in Perl. Because you can use each from the
other, combine them as you wish.</p>

<p style="margin-top: 1em">AUTHOR <br>
Jon Orwant &lt;orwant@media.mit.edu&gt; and Doug MacEachern
&lt;dougm@covalent.net&gt;, with small contributions from
Tim Bunce, Tom Christiansen, Guy Decoux, Hallvard Furuseth,
Dov <br>
Grobgeld, and Ilya Zakharevich.</p>

<p style="margin-top: 1em">Doug MacEachern has an article
on embedding in Volume 1, Issue 4 of The Perl Journal (
http://www.tpj.com/ ). Doug is also the developer of the
most widely-used Perl embedding: <br>
the mod_perl system (perl.apache.org), which embeds Perl in
the Apache web server. Oracle, Binary Evolution,
ActiveState, and Ben Sugars&rsquo;s nsapi_perl have used
this model for <br>
Oracle, Netscape and Internet Information Server Perl
plugins.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon
Orwant. All Rights Reserved.</p>

<p style="margin-top: 1em">This document may be distributed
under the same terms as Perl itself.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLEMBED(1)</p>
<hr>
</body>
</html>
