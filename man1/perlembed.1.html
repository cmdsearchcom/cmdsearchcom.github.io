<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLEMBED(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLEMBED(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLEMBED(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlembed - how to embed perl in your C program
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<h2 class="Ss" title="Ss" id="PREAMBLE"><a class="selflink" href="#PREAMBLE">PREAMBLE</a></h2>
Do you want to:
<dl class="Bl-tag">
  <dt class="It-tag"><b>Use C from Perl?</b></dt>
  <dd class="It-tag">Read perlxstut, perlxs, h2xs, perlguts, and perlapi.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Use a Unix program from Perl?</b></dt>
  <dd class="It-tag">Read about back-quotes and about &quot;system&quot; and
      &quot;exec&quot; in perlfunc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Use Perl from Perl?</b></dt>
  <dd class="It-tag">Read about &quot;do&quot; in perlfunc and &quot;eval&quot;
      in perlfunc and &quot;require&quot; in perlfunc and &quot;use&quot; in
      perlfunc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Use C from C?</b></dt>
  <dd class="It-tag">Rethink your design.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Use Perl from C?</b></dt>
  <dd class="It-tag">Read on...</dd>
</dl>
<h2 class="Ss" title="Ss" id="ROADMAP"><a class="selflink" href="#ROADMAP">ROADMAP</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Compiling your C program</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Adding a Perl interpreter to your C program</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Calling a Perl subroutine from your C program</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Evaluating a Perl statement from your C program</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Performing Perl pattern matches and substitutions from your
      C program</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Fiddling with the Perl stack from your C program</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Maintaining a persistent interpreter</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Maintaining multiple interpreter instances</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Using Perl modules, which themselves use C libraries, from
      your C program</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Embedding Perl under Win32</dd>
</dl>
<h2 class="Ss" title="Ss" id="Compiling_your_C_program"><a class="selflink" href="#Compiling_your_C_program">Compiling
  your C program</a></h2>
If you have trouble compiling the scripts in this documentation, you're not
  alone. The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY THE SAME WAY THAT
  YOUR PERL WAS COMPILED. (Sorry for yelling.)
<div class="Pp"></div>
Also, every C program that uses Perl must link in the <i>perl library</i>.
  What's that, you ask? Perl is itself written in C; the perl library is the
  collection of compiled C programs that were used to create your perl
  executable ( <i>/usr/bin/perl</i> or equivalent). (Corollary: you can't use
  Perl from your C program unless Perl has been compiled on your machine, or
  installed properly--that's why you shouldn't blithely copy Perl executables
  from machine to machine without also copying the <i>lib</i> directory.)
<div class="Pp"></div>
When you use Perl from C, your C program will--usually--allocate,
  &quot;run&quot;, and deallocate a <i>PerlInterpreter</i> object, which is
  defined by the perl library.
<div class="Pp"></div>
If your copy of Perl is recent enough to contain this documentation (version
  5.002 or later), then the perl library (and <i>EXTERN.h</i> and <i>perl.h</i>,
  which you'll also need) will reside in a directory that looks like this:
<div class="Pp"></div>
<pre>
    /usr/local/lib/perl5/your_architecture_here/CORE
</pre>
<div class="Pp"></div>
or perhaps just
<div class="Pp"></div>
<pre>
    /usr/local/lib/perl5/CORE
</pre>
<div class="Pp"></div>
or maybe something like
<div class="Pp"></div>
<pre>
    /usr/opt/perl5/CORE
</pre>
<div class="Pp"></div>
Execute this statement for a hint about where to find CORE:
<div class="Pp"></div>
<pre>
    perl -MConfig -e 'print $Config{archlib}'
</pre>
<div class="Pp"></div>
Here's how you'd compile the example in the next section, &quot;Adding a Perl
  interpreter to your C program&quot;, on my Linux box:
<div class="Pp"></div>
<pre>
    % gcc -O2 -Dbool=char -DHAS_BOOL -I/usr/local/include
    -I/usr/local/lib/perl5/i586-linux/5.003/CORE
    -L/usr/local/lib/perl5/i586-linux/5.003/CORE
    -o interp interp.c -lperl -lm
</pre>
<div class="Pp"></div>
(That's all one line.) On my DEC Alpha running old 5.003_05, the incantation is
  a bit different:
<div class="Pp"></div>
<pre>
    % cc -O2 -Olimit 2900 -DSTANDARD_C -I/usr/local/include
    -I/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE
    -L/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE -L/usr/local/lib
    -D__LANGUAGE_C__ -D_NO_PROTO -o interp interp.c -lperl -lm
</pre>
<div class="Pp"></div>
How can you figure out what to add? Assuming your Perl is post-5.001, execute a
  &quot;perl -V&quot; command and pay special attention to the &quot;cc&quot;
  and &quot;ccflags&quot; information.
<div class="Pp"></div>
You'll have to choose the appropriate compiler ( <i>cc</i>, <i>gcc</i>, et al.)
  for your machine: &quot;perl -MConfig -e 'print $Config{cc}'&quot; will tell
  you what to use.
<div class="Pp"></div>
You'll also have to choose the appropriate library directory (
  <i>/usr/local/lib/...</i>) for your machine. If your compiler complains that
  certain functions are undefined, or that it can't locate <i>-lperl</i>, then
  you need to change the path following the &quot;-L&quot;. If it complains that
  it can't find <i>EXTERN.h</i> and <i>perl.h</i>, you need to change the path
  following the &quot;-I&quot;.
<div class="Pp"></div>
You may have to add extra libraries as well. Which ones? Perhaps those printed
  by
<div class="Pp"></div>
<pre>
   perl -MConfig -e 'print $Config{libs}'
</pre>
<div class="Pp"></div>
Provided your perl binary was properly configured and installed the
  <b>ExtUtils::Embed</b> module will determine all of this information for you:
<div class="Pp"></div>
<pre>
   % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
</pre>
<div class="Pp"></div>
If the <b>ExtUtils::Embed</b> module isn't part of your Perl distribution, you
  can retrieve it from http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/
  (If this documentation came from your Perl distribution, then you're running
  5.004 or better and you already have it.)
<div class="Pp"></div>
The <b>ExtUtils::Embed</b> kit on CPAN also contains all source code for the
  examples in this document, tests, additional examples and other information
  you may find useful.
<h2 class="Ss" title="Ss" id="Adding_a_Perl_interpreter_to_your_C_program"><a class="selflink" href="#Adding_a_Perl_interpreter_to_your_C_program">Adding
  a Perl interpreter to your C program</a></h2>
In a sense, perl (the C program) is a good example of embedding Perl (the
  language), so I'll demonstrate embedding with <i>miniperlmain.c</i>, included
  in the source distribution. Here's a bastardized, non-portable version of
  <i>miniperlmain.c</i> containing the essentials of embedding:
<div class="Pp"></div>
<pre>
    #include &lt;EXTERN.h&gt;               /* from the Perl distribution     */
    #include &lt;perl.h&gt;                 /* from the Perl distribution     */
    static PerlInterpreter *my_perl;  /***    The Perl interpreter    ***/
    int main(int argc, char **argv, char **env)
    {
        PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
        my_perl = perl_alloc();
        perl_construct(my_perl);
        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
        perl_parse(my_perl, NULL, argc, argv, (char **)NULL);
        perl_run(my_perl);
        perl_destruct(my_perl);
        perl_free(my_perl);
        PERL_SYS_TERM();
    }
</pre>
<div class="Pp"></div>
Notice that we don't use the &quot;env&quot; pointer. Normally handed to
  &quot;perl_parse&quot; as its final argument, &quot;env&quot; here is replaced
  by &quot;NULL&quot;, which means that the current environment will be used.
<div class="Pp"></div>
The macros <i>PERL_SYS_INIT3()</i> and <i>PERL_SYS_TERM()</i> provide
  system-specific tune up of the C runtime environment necessary to run Perl
  interpreters; they should only be called once regardless of how many
  interpreters you create or destroy. Call <i>PERL_SYS_INIT3()</i> before you
  create your first interpreter, and <i>PERL_SYS_TERM()</i> after you free your
  last interpreter.
<div class="Pp"></div>
Since <i>PERL_SYS_INIT3()</i> may change &quot;env&quot;, it may be more
  appropriate to provide &quot;env&quot; as an argument to <i>perl_parse()</i>.
<div class="Pp"></div>
Also notice that no matter what arguments you pass to <i>perl_parse()</i>,
  <i>PERL_SYS_INIT3()</i> must be invoked on the C <i>main()</i> argc, argv and
  env and only once.
<div class="Pp"></div>
Now compile this program (I'll call it <i>interp.c</i>) into an executable:
<div class="Pp"></div>
<pre>
    % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
</pre>
<div class="Pp"></div>
After a successful compilation, you'll be able to use <i>interp</i> just like
  perl itself:
<div class="Pp"></div>
<pre>
    % interp
    print &quot;Pretty Good Perl \n&quot;;
    print &quot;10890 - 9801 is &quot;, 10890 - 9801;
    &lt;CTRL-D&gt;
    Pretty Good Perl
    10890 - 9801 is 1089
</pre>
<div class="Pp"></div>
or
<div class="Pp"></div>
<pre>
    % interp -e 'printf(&quot;%x&quot;, 3735928559)'
    deadbeef
</pre>
<div class="Pp"></div>
You can also read and execute Perl statements from a file while in the midst of
  your C program, by placing the filename in <i>argv[1]</i> before calling
  <i>perl_run</i>.
<h2 class="Ss" title="Ss" id="Calling_a_Perl_subroutine_from_your_C_program"><a class="selflink" href="#Calling_a_Perl_subroutine_from_your_C_program">Calling
  a Perl subroutine from your C program</a></h2>
To call individual Perl subroutines, you can use any of the <b>call_*</b>
  functions documented in perlcall. In this example we'll use
  &quot;call_argv&quot;.
<div class="Pp"></div>
That's shown below, in a program I'll call <i>showtime.c</i>.
<div class="Pp"></div>
<pre>
    #include &lt;EXTERN.h&gt;
    #include &lt;perl.h&gt;
    static PerlInterpreter *my_perl;
    int main(int argc, char **argv, char **env)
    {
        char *args[] = { NULL };
        PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
        my_perl = perl_alloc();
        perl_construct(my_perl);
        perl_parse(my_perl, NULL, argc, argv, NULL);
        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
        /*** skipping perl_run() ***/
        call_argv(&quot;showtime&quot;, G_DISCARD | G_NOARGS, args);
        perl_destruct(my_perl);
        perl_free(my_perl);
        PERL_SYS_TERM();
    }
</pre>
<div class="Pp"></div>
where <i>showtime</i> is a Perl subroutine that takes no arguments (that's the
  <i>G_NOARGS</i>) and for which I'll ignore the return value (that's the
  <i>G_DISCARD</i>). Those flags, and others, are discussed in perlcall.
<div class="Pp"></div>
I'll define the <i>showtime</i> subroutine in a file called <i>showtime.pl</i>:
<div class="Pp"></div>
<pre>
    print &quot;I shan't be printed.&quot;;
    sub showtime {
        print time;
    }
</pre>
<div class="Pp"></div>
Simple enough. Now compile and run:
<div class="Pp"></div>
<pre>
    % cc -o showtime showtime.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
    % showtime showtime.pl
    818284590
</pre>
<div class="Pp"></div>
yielding the number of seconds that elapsed between January 1, 1970 (the
  beginning of the Unix epoch), and the moment I began writing this sentence.
<div class="Pp"></div>
In this particular case we don't have to call <i>perl_run</i>, as we set the
  PL_exit_flag PERL_EXIT_DESTRUCT_END which executes END blocks in
  perl_destruct.
<div class="Pp"></div>
If you want to pass arguments to the Perl subroutine, you can add strings to the
  &quot;NULL&quot;-terminated &quot;args&quot; list passed to <i>call_argv</i>.
  For other data types, or to examine return values, you'll need to manipulate
  the Perl stack. That's demonstrated in &quot;Fiddling with the Perl stack from
  your C program&quot;.
<h2 class="Ss" title="Ss" id="Evaluating_a_Perl_statement_from_your_C_program"><a class="selflink" href="#Evaluating_a_Perl_statement_from_your_C_program">Evaluating
  a Perl statement from your C program</a></h2>
Perl provides two API functions to evaluate pieces of Perl code. These are
  &quot;eval_sv&quot; in perlapi and &quot;eval_pv&quot; in perlapi.
<div class="Pp"></div>
Arguably, these are the only routines you'll ever need to execute snippets of
  Perl code from within your C program. Your code can be as long as you wish; it
  can contain multiple statements; it can employ &quot;use&quot; in perlfunc,
  &quot;require&quot; in perlfunc, and &quot;do&quot; in perlfunc to include
  external Perl files.
<div class="Pp"></div>
<i>eval_pv</i> lets us evaluate individual Perl strings, and then extract
  variables for coercion into C types. The following program, <i>string.c</i>,
  executes three Perl strings, extracting an &quot;int&quot; from the first, a
  &quot;float&quot; from the second, and a &quot;char *&quot; from the third.
<div class="Pp"></div>
<pre>
   #include &lt;EXTERN.h&gt;
   #include &lt;perl.h&gt;
   static PerlInterpreter *my_perl;
   main (int argc, char **argv, char **env)
   {
       char *embedding[] = { &quot;&quot;, &quot;-e&quot;, &quot;0&quot; };
       PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
       my_perl = perl_alloc();
       perl_construct( my_perl );
       perl_parse(my_perl, NULL, 3, embedding, NULL);
       PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
       perl_run(my_perl);
       /** Treat $a as an integer **/
       eval_pv(&quot;$a = 3; $a **= 2&quot;, TRUE);
       printf(&quot;a = %d\n&quot;, SvIV(get_sv(&quot;a&quot;, 0)));
       /** Treat $a as a float **/
       eval_pv(&quot;$a = 3.14; $a **= 2&quot;, TRUE);
       printf(&quot;a = %f\n&quot;, SvNV(get_sv(&quot;a&quot;, 0)));
       /** Treat $a as a string **/
       eval_pv(&quot;$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a);&quot;, TRUE);
       printf(&quot;a = %s\n&quot;, SvPV_nolen(get_sv(&quot;a&quot;, 0)));
       perl_destruct(my_perl);
       perl_free(my_perl);
       PERL_SYS_TERM();
   }
</pre>
<div class="Pp"></div>
All of those strange functions with <i>sv</i> in their names help convert Perl
  scalars to C types. They're described in perlguts and perlapi.
<div class="Pp"></div>
If you compile and run <i>string.c</i>, you'll see the results of using
  <i></i><i>SvIV()</i><i></i> to create an &quot;int&quot;,
  <i></i><i>SvNV()</i><i></i> to create a &quot;float&quot;, and
  <i></i><i>SvPV()</i> <i></i> to create a string:
<div class="Pp"></div>
<pre>
   a = 9
   a = 9.859600
   a = Just Another Perl Hacker
</pre>
<div class="Pp"></div>
In the example above, we've created a global variable to temporarily store the
  computed value of our eval'ed expression. It is also possible and in most
  cases a better strategy to fetch the return value from
  <i></i><i>eval_pv()</i><i></i> instead. Example:
<div class="Pp"></div>
<pre>
   ...
   SV *val = eval_pv(&quot;reverse 'rekcaH lreP rehtonA tsuJ'&quot;, TRUE);
   printf(&quot;%s\n&quot;, SvPV_nolen(val));
   ...
</pre>
<div class="Pp"></div>
This way, we avoid namespace pollution by not creating global variables and
  we've simplified our code as well.
<h2 class="Ss" title="Ss" id="Performing_Perl_pattern_matches_and_substitutions_from_your_C_program"><a class="selflink" href="#Performing_Perl_pattern_matches_and_substitutions_from_your_C_program">Performing
  Perl pattern matches and substitutions from your C program</a></h2>
The <i></i><i>eval_sv()</i><i></i> function lets us evaluate strings of Perl
  code, so we can define some functions that use it to &quot;specialize&quot; in
  matches and substitutions: <i></i><i>match()</i><i></i>,
  <i></i><i>substitute()</i> <i></i>, and <i></i><i>matches()</i><i></i>.
<div class="Pp"></div>
<pre>
   I32 match(SV *string, char *pattern);
</pre>
<div class="Pp"></div>
Given a string and a pattern (e.g., &quot;m/clasp/&quot; or
  &quot;/\b\w*\b/&quot;, which in your C program might appear as
  &quot;/\\b\\w*\\b/&quot;), <i>match()</i> returns 1 if the string matches the
  pattern and 0 otherwise.
<div class="Pp"></div>
<pre>
   int substitute(SV **string, char *pattern);
</pre>
<div class="Pp"></div>
Given a pointer to an &quot;SV&quot; and an &quot;=~&quot; operation (e.g.,
  &quot;s/bob/robert/g&quot; or &quot;tr[A-Z][a-z]&quot;), <i>substitute()</i>
  modifies the string within the &quot;SV&quot; as according to the operation,
  returning the number of substitutions made.
<div class="Pp"></div>
<pre>
   int matches(SV *string, char *pattern, AV **matches);
</pre>
<div class="Pp"></div>
Given an &quot;SV&quot;, a pattern, and a pointer to an empty &quot;AV&quot;,
  <i>matches()</i> evaluates &quot;$string =~ $pattern&quot; in a list context,
  and fills in <i>matches</i> with the array elements, returning the number of
  matches found.
<div class="Pp"></div>
Here's a sample program, <i>match.c</i>, that uses all three (long lines have
  been wrapped here):
<div class="Pp"></div>
<pre>
 #include &lt;EXTERN.h&gt;
 #include &lt;perl.h&gt;
 static PerlInterpreter *my_perl;
 /** my_eval_sv(code, error_check)
 ** kinda like eval_sv(), 
 ** but we pop the return value off the stack 
 **/
 SV* my_eval_sv(SV *sv, I32 croak_on_error)
 {
     dSP;
     SV* retval;
     PUSHMARK(SP);
     eval_sv(sv, G_SCALAR);
     SPAGAIN;
     retval = POPs;
     PUTBACK;
     if (croak_on_error &amp;&amp; SvTRUE(ERRSV))
        croak(SvPVx_nolen(ERRSV));
     return retval;
 }
 /** match(string, pattern)
 **
 ** Used for matches in a scalar context.
 **
 ** Returns 1 if the match was successful; 0 otherwise.
 **/
 I32 match(SV *string, char *pattern)
 {
     SV *command = newSV(0), *retval;
     sv_setpvf(command, &quot;my $string = '%s'; $string =~ %s&quot;,
              SvPV_nolen(string), pattern);
     retval = my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);
     return SvIV(retval);
 }
 /** substitute(string, pattern)
 **
 ** Used for =~ operations that modify their left-hand side (s/// and tr///)
 **
 ** Returns the number of successful matches, and
 ** modifies the input string if there were any.
 **/
 I32 substitute(SV **string, char *pattern)
 {
     SV *command = newSV(0), *retval;
     sv_setpvf(command, &quot;$string = '%s'; ($string =~ %s)&quot;,
              SvPV_nolen(*string), pattern);
     retval = my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);
     *string = get_sv(&quot;string&quot;, 0);
     return SvIV(retval);
 }
 /** matches(string, pattern, matches)
 **
 ** Used for matches in a list context.
 **
 ** Returns the number of matches,
 ** and fills in **matches with the matching substrings
 **/
 I32 matches(SV *string, char *pattern, AV **match_list)
 {
     SV *command = newSV(0);
     I32 num_matches;
     sv_setpvf(command, &quot;my $string = '%s'; @array = ($string =~ %s)&quot;,
              SvPV_nolen(string), pattern);
     my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);
     *match_list = get_av(&quot;array&quot;, 0);
     num_matches = av_len(*match_list) + 1;
     return num_matches;
 }
 main (int argc, char **argv, char **env)
 {
     char *embedding[] = { &quot;&quot;, &quot;-e&quot;, &quot;0&quot; };
     AV *match_list;
     I32 num_matches, i;
     SV *text;
     PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
     my_perl = perl_alloc();
     perl_construct(my_perl);
     perl_parse(my_perl, NULL, 3, embedding, NULL);
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
     text = newSV(0);
     sv_setpv(text, &quot;When he is at a convenience store and the &quot;
        &quot;bill comes to some amount like 76 cents, Maynard is &quot;
        &quot;aware that there is something he *should* do, something &quot;
        &quot;that will enable him to get back a quarter, but he has &quot;
        &quot;no idea *what*.  He fumbles through his red squeezey &quot;
        &quot;changepurse and gives the boy three extra pennies with &quot;
        &quot;his dollar, hoping that he might luck into the correct &quot;
        &quot;amount.  The boy gives him back two of his own pennies &quot;
        &quot;and then the big shiny quarter that is his prize. &quot;
        &quot;-RICHH&quot;);
     if (match(text, &quot;m/quarter/&quot;)) /** Does text contain 'quarter'? **/
        printf(&quot;match: Text contains the word 'quarter'.\n\n&quot;);
     else
        printf(&quot;match: Text doesn't contain the word 'quarter'.\n\n&quot;);
     if (match(text, &quot;m/eighth/&quot;)) /** Does text contain 'eighth'? **/
        printf(&quot;match: Text contains the word 'eighth'.\n\n&quot;);
     else
        printf(&quot;match: Text doesn't contain the word 'eighth'.\n\n&quot;);
     /** Match all occurrences of /wi../ **/
     num_matches = matches(text, &quot;m/(wi..)/g&quot;, &amp;match_list);
     printf(&quot;matches: m/(wi..)/g found %d matches...\n&quot;, num_matches);
     for (i = 0; i &lt; num_matches; i++)
        printf(&quot;match: %s\n&quot;, SvPV_nolen(*av_fetch(match_list, i, FALSE)));
     printf(&quot;\n&quot;);
     /** Remove all vowels from text **/
     num_matches = substitute(&amp;text, &quot;s/[aeiou]//gi&quot;);
     if (num_matches) {
        printf(&quot;substitute: s/[aeiou]//gi...%d substitutions made.\n&quot;,
               num_matches);
        printf(&quot;Now text is: %s\n\n&quot;, SvPV_nolen(text));
     }
     /** Attempt a substitution **/
     if (!substitute(&amp;text, &quot;s/Perl/C/&quot;)) {
        printf(&quot;substitute: s/Perl/C...No substitution made.\n\n&quot;);
     }
     SvREFCNT_dec(text);
     PL_perl_destruct_level = 1;
     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
 }
</pre>
<div class="Pp"></div>
which produces the output (again, long lines have been wrapped here)
<div class="Pp"></div>
<pre>
   match: Text contains the word 'quarter'.
   match: Text doesn't contain the word 'eighth'.
   matches: m/(wi..)/g found 2 matches...
   match: will
   match: with
   substitute: s/[aeiou]//gi...139 substitutions made.
   Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
   Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck
   qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by
   thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs
   hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. -RCHH
   substitute: s/Perl/C...No substitution made.
</pre>
<h2 class="Ss" title="Ss" id="Fiddling_with_the_Perl_stack_from_your_C_program"><a class="selflink" href="#Fiddling_with_the_Perl_stack_from_your_C_program">Fiddling
  with the Perl stack from your C program</a></h2>
When trying to explain stacks, most computer science textbooks mumble something
  about spring-loaded columns of cafeteria plates: the last thing you pushed on
  the stack is the first thing you pop off. That'll do for our purposes: your C
  program will push some arguments onto &quot;the Perl stack&quot;, shut its
  eyes while some magic happens, and then pop the results--the return value of
  your Perl subroutine--off the stack.
<div class="Pp"></div>
First you'll need to know how to convert between C types and Perl types, with
  <i>newSViv()</i> and <i>sv_setnv()</i> and <i>newAV()</i> and all their
  friends. They're described in perlguts and perlapi.
<div class="Pp"></div>
Then you'll need to know how to manipulate the Perl stack. That's described in
  perlcall.
<div class="Pp"></div>
Once you've understood those, embedding Perl in C is easy.
<div class="Pp"></div>
Because C has no builtin function for integer exponentiation, let's make Perl's
  ** operator available to it (this is less useful than it sounds, because Perl
  implements ** with C's <i></i><i>pow()</i><i></i> function). First I'll create
  a stub exponentiation function in <i>power.pl</i>:
<div class="Pp"></div>
<pre>
    sub expo {
        my ($a, $b) = @_;
        return $a ** $b;
    }
</pre>
<div class="Pp"></div>
Now I'll create a C program, <i>power.c</i>, with a function
  <i></i><i>PerlPower()</i> <i></i> that contains all the perlguts necessary to
  push the two arguments into <i></i><i>expo()</i><i></i> and to pop the return
  value out. Take a deep breath...
<div class="Pp"></div>
<pre>
    #include &lt;EXTERN.h&gt;
    #include &lt;perl.h&gt;
    static PerlInterpreter *my_perl;
    static void
    PerlPower(int a, int b)
    {
      dSP;                            /* initialize stack pointer      */
      ENTER;                          /* everything created after here */
      SAVETMPS;                       /* ...is a temporary variable.   */
      PUSHMARK(SP);                   /* remember the stack pointer    */
      XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the stack  */
      XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto stack  */
      PUTBACK;                      /* make local stack pointer global */
      call_pv(&quot;expo&quot;, G_SCALAR);      /* call the function             */
      SPAGAIN;                        /* refresh stack pointer         */
                                    /* pop the return value from stack */
      printf (&quot;%d to the %dth power is %d.\n&quot;, a, b, POPi);
      PUTBACK;
      FREETMPS;                       /* free that return value        */
      LEAVE;                       /* ...and the XPUSHed &quot;mortal&quot; args.*/
    }
    int main (int argc, char **argv, char **env)
    {
      char *my_argv[] = { &quot;&quot;, &quot;power.pl&quot; };
      PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
      my_perl = perl_alloc();
      perl_construct( my_perl );
      perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
      PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
      perl_run(my_perl);
      PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/
      perl_destruct(my_perl);
      perl_free(my_perl);
      PERL_SYS_TERM();
    }
</pre>
<div class="Pp"></div>
Compile and run:
<div class="Pp"></div>
<pre>
    % cc -o power power.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
    % power
    3 to the 4th power is 81.
</pre>
<h2 class="Ss" title="Ss" id="Maintaining_a_persistent_interpreter"><a class="selflink" href="#Maintaining_a_persistent_interpreter">Maintaining
  a persistent interpreter</a></h2>
When developing interactive and/or potentially long-running applications, it's a
  good idea to maintain a persistent interpreter rather than allocating and
  constructing a new interpreter multiple times. The major reason is speed:
  since Perl will only be loaded into memory once.
<div class="Pp"></div>
However, you have to be more cautious with namespace and variable scoping when
  using a persistent interpreter. In previous examples we've been using global
  variables in the default package &quot;main&quot;. We knew exactly what code
  would be run, and assumed we could avoid variable collisions and outrageous
  symbol table growth.
<div class="Pp"></div>
Let's say your application is a server that will occasionally run Perl code from
  some arbitrary file. Your server has no way of knowing what code it's going to
  run. Very dangerous.
<div class="Pp"></div>
If the file is pulled in by &quot;perl_parse()&quot;, compiled into a newly
  constructed interpreter, and subsequently cleaned out with
  &quot;perl_destruct()&quot; afterwards, you're shielded from most namespace
  troubles.
<div class="Pp"></div>
One way to avoid namespace collisions in this scenario is to translate the
  filename into a guaranteed-unique package name, and then compile the code into
  that package using &quot;eval&quot; in perlfunc. In the example below, each
  file will only be compiled once. Or, the application might choose to clean out
  the symbol table associated with the file after it's no longer needed. Using
  &quot;call_argv&quot; in perlapi, We'll call the subroutine
  &quot;Embed::Persistent::eval_file&quot; which lives in the file
  &quot;persistent.pl&quot; and pass the filename and boolean cleanup/cache flag
  as arguments.
<div class="Pp"></div>
Note that the process will continue to grow for each file that it uses. In
  addition, there might be &quot;AUTOLOAD&quot;ed subroutines and other
  conditions that cause Perl's symbol table to grow. You might want to add some
  logic that keeps track of the process size, or restarts itself after a certain
  number of requests, to ensure that memory consumption is minimized. You'll
  also want to scope your variables with &quot;my&quot; in perlfunc whenever
  possible.
<div class="Pp"></div>
<pre>
 package Embed::Persistent;
 #persistent.pl
 use strict;
 our %Cache;
 use Symbol qw(delete_package);
 sub valid_package_name {
     my($string) = @_;
     $string =~ s/([^A-Za-z0-9\/])/sprintf(&quot;_%2x&quot;,unpack(&quot;C&quot;,$1))/eg;
     # second pass only for words starting with a digit
     $string =~ s|/(\d)|sprintf(&quot;/_%2x&quot;,unpack(&quot;C&quot;,$1))|eg;
     # Dress it up as a real package name
     $string =~ s|/|::|g;
     return &quot;Embed&quot; . $string;
 }
 sub eval_file {
     my($filename, $delete) = @_;
     my $package = valid_package_name($filename);
     my $mtime = -M $filename;
     if(defined $Cache{$package}{mtime}
        &amp;&amp;
        $Cache{$package}{mtime} &lt;= $mtime)
     {
        # we have compiled this subroutine already,
        # it has not been updated on disk, nothing left to do
        print STDERR &quot;already compiled $package-&gt;handler\n&quot;;
     }
     else {
        local *FH;
        open FH, $filename or die &quot;open '$filename' $!&quot;;
        local($/) = undef;
        my $sub = &lt;FH&gt;;
        close FH;
        #wrap the code into a subroutine inside our unique package
        my $eval = qq{package $package; sub handler { $sub; }};
        {
            # hide our variables within this block
            my($filename,$mtime,$package,$sub);
            eval $eval;
        }
        die $@ if $@;
        #cache it unless we're cleaning out each time
        $Cache{$package}{mtime} = $mtime unless $delete;
     }
     eval {$package-&gt;handler;};
     die $@ if $@;
     delete_package($package) if $delete;
     #take a look if you want
     #print Devel::Symdump-&gt;rnew($package)-&gt;as_string, $/;
 }
 1;
 __END__
 /* persistent.c */
 #include &lt;EXTERN.h&gt;
 #include &lt;perl.h&gt;
 /* 1 = clean out filename's symbol table after each request, 0 = don't */
 #ifndef DO_CLEAN
 #define DO_CLEAN 0
 #endif
 #define BUFFER_SIZE 1024
 static PerlInterpreter *my_perl = NULL;
 int
 main(int argc, char **argv, char **env)
 {
     char *embedding[] = { &quot;&quot;, &quot;persistent.pl&quot; };
     char *args[] = { &quot;&quot;, DO_CLEAN, NULL };
     char filename[BUFFER_SIZE];
     int exitstatus = 0;
     PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
     if((my_perl = perl_alloc()) == NULL) {
        fprintf(stderr, &quot;no memory!&quot;);
        exit(1);
     }
     perl_construct(my_perl);
     PL_origalen = 1; /* don't let $0 assignment update the proctitle or embedding[0] */
     exitstatus = perl_parse(my_perl, NULL, 2, embedding, NULL);
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
     if(!exitstatus) {
        exitstatus = perl_run(my_perl);
        while(printf(&quot;Enter file name: &quot;) &amp;&amp;
              fgets(filename, BUFFER_SIZE, stdin)) {
            filename[strlen(filename)-1] = '\0'; /* strip \n */
            /* call the subroutine, passing it the filename as an argument */
            args[0] = filename;
            call_argv(&quot;Embed::Persistent::eval_file&quot;,
                           G_DISCARD | G_EVAL, args);
            /* check $@ */
            if(SvTRUE(ERRSV))
                fprintf(stderr, &quot;eval error: %s\n&quot;, SvPV_nolen(ERRSV));
        }
     }
     PL_perl_destruct_level = 0;
     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
     exit(exitstatus);
 }
</pre>
<div class="Pp"></div>
Now compile:
<div class="Pp"></div>
<pre>
 % cc -o persistent persistent.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
</pre>
<div class="Pp"></div>
Here's an example script file:
<div class="Pp"></div>
<pre>
 #test.pl
 my $string = &quot;hello&quot;;
 foo($string);
 sub foo {
     print &quot;foo says: @_\n&quot;;
 }
</pre>
<div class="Pp"></div>
Now run:
<div class="Pp"></div>
<pre>
 % persistent
 Enter file name: test.pl
 foo says: hello
 Enter file name: test.pl
 already compiled Embed::test_2epl-&gt;handler
 foo says: hello
 Enter file name: ^C
</pre>
<h2 class="Ss" title="Ss" id="Execution_of_END_blocks"><a class="selflink" href="#Execution_of_END_blocks">Execution
  of END blocks</a></h2>
Traditionally END blocks have been executed at the end of the perl_run. This
  causes problems for applications that never call perl_run. Since perl 5.7.2
  you can specify &quot;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&quot; to get the
  new behaviour. This also enables the running of END blocks if the perl_parse
  fails and &quot;perl_destruct&quot; will return the exit value.
<h2 class="Ss" title="Ss" id="$0_assignments"><a class="selflink" href="#$0_assignments">$0
  assignments</a></h2>
When a perl script assigns a value to $0 then the perl runtime will try to make
  this value show up as the program name reported by &quot;ps&quot; by updating
  the memory pointed to by the argv passed to <i>perl_parse()</i> and also
  calling API functions like <i>setproctitle()</i> where available. This
  behaviour might not be appropriate when embedding perl and can be disabled by
  assigning the value 1 to the variable &quot;PL_origalen&quot; before
  <i>perl_parse()</i> is called.
<div class="Pp"></div>
The <i>persistent.c</i> example above is for instance likely to segfault when $0
  is assigned to if the &quot;PL_origalen = 1;&quot; assignment is removed. This
  because perl will try to write to the read only memory of the
  &quot;embedding[]&quot; strings.
<h2 class="Ss" title="Ss" id="Maintaining_multiple_interpreter_instances"><a class="selflink" href="#Maintaining_multiple_interpreter_instances">Maintaining
  multiple interpreter instances</a></h2>
Some rare applications will need to create more than one interpreter during a
  session. Such an application might sporadically decide to release any
  resources associated with the interpreter.
<div class="Pp"></div>
The program must take care to ensure that this takes place <i>before</i> the
  next interpreter is constructed. By default, when perl is not built with any
  special options, the global variable &quot;PL_perl_destruct_level&quot; is set
  to 0, since extra cleaning isn't usually needed when a program only ever
  creates a single interpreter in its entire lifetime.
<div class="Pp"></div>
Setting &quot;PL_perl_destruct_level&quot; to 1 makes everything squeaky clean:
<div class="Pp"></div>
<pre>
 while(1) {
     ...
     /* reset global variables here with PL_perl_destruct_level = 1 */
     PL_perl_destruct_level = 1;
     perl_construct(my_perl);
     ...
     /* clean and reset _everything_ during perl_destruct */
     PL_perl_destruct_level = 1;
     perl_destruct(my_perl);
     perl_free(my_perl);
     ...
     /* let's go do it again! */
 }
</pre>
<div class="Pp"></div>
When <i></i><i>perl_destruct()</i><i></i> is called, the interpreter's syntax
  parse tree and symbol tables are cleaned up, and global variables are reset.
  The second assignment to &quot;PL_perl_destruct_level&quot; is needed because
  perl_construct resets it to 0.
<div class="Pp"></div>
Now suppose we have more than one interpreter instance running at the same time.
  This is feasible, but only if you used the Configure option
  &quot;-Dusemultiplicity&quot; or the options &quot;-Dusethreads
  -Duseithreads&quot; when building perl. By default, enabling one of these
  Configure options sets the per-interpreter global variable
  &quot;PL_perl_destruct_level&quot; to 1, so that thorough cleaning is
  automatic and interpreter variables are initialized correctly. Even if you
  don't intend to run two or more interpreters at the same time, but to run them
  sequentially, like in the above example, it is recommended to build perl with
  the &quot;-Dusemultiplicity&quot; option otherwise some interpreter variables
  may not be initialized correctly between consecutive runs and your application
  may crash.
<div class="Pp"></div>
See also &quot;Thread-aware system interfaces&quot; in perlxs.
<div class="Pp"></div>
Using &quot;-Dusethreads -Duseithreads&quot; rather than
  &quot;-Dusemultiplicity&quot; is more appropriate if you intend to run
  multiple interpreters concurrently in different threads, because it enables
  support for linking in the thread libraries of your system with the
  interpreter.
<div class="Pp"></div>
Let's give it a try:
<div class="Pp"></div>
<pre>
 #include &lt;EXTERN.h&gt;
 #include &lt;perl.h&gt;
 /* we're going to embed two interpreters */
 #define SAY_HELLO &quot;-e&quot;, &quot;print qq(Hi, I'm $^X\n)&quot;
 int main(int argc, char **argv, char **env)
 {
     PerlInterpreter *one_perl, *two_perl;
     char *one_args[] = { &quot;one_perl&quot;, SAY_HELLO };
     char *two_args[] = { &quot;two_perl&quot;, SAY_HELLO };
     PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
     one_perl = perl_alloc();
     two_perl = perl_alloc();
     PERL_SET_CONTEXT(one_perl);
     perl_construct(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_construct(two_perl);
     PERL_SET_CONTEXT(one_perl);
     perl_parse(one_perl, NULL, 3, one_args, (char **)NULL);
     PERL_SET_CONTEXT(two_perl);
     perl_parse(two_perl, NULL, 3, two_args, (char **)NULL);
     PERL_SET_CONTEXT(one_perl);
     perl_run(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_run(two_perl);
     PERL_SET_CONTEXT(one_perl);
     perl_destruct(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_destruct(two_perl);
     PERL_SET_CONTEXT(one_perl);
     perl_free(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_free(two_perl);
     PERL_SYS_TERM();
 }
</pre>
<div class="Pp"></div>
Note the calls to <i>PERL_SET_CONTEXT()</i>. These are necessary to initialize
  the global state that tracks which interpreter is the &quot;current&quot; one
  on the particular process or thread that may be running it. It should always
  be used if you have more than one interpreter and are making perl API calls on
  both interpreters in an interleaved fashion.
<div class="Pp"></div>
PERL_SET_CONTEXT(interp) should also be called whenever &quot;interp&quot; is
  used by a thread that did not create it (using either <i>perl_alloc()</i>, or
  the more esoteric <i>perl_clone()</i>).
<div class="Pp"></div>
Compile as usual:
<div class="Pp"></div>
<pre>
 % cc -o multiplicity multiplicity.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
</pre>
<div class="Pp"></div>
Run it, Run it:
<div class="Pp"></div>
<pre>
 % multiplicity
 Hi, I'm one_perl
 Hi, I'm two_perl
</pre>
<h2 class="Ss" title="Ss" id="Using_Perl_modules,_which_themselves_use_C_libraries,_from_your_C_program"><a class="selflink" href="#Using_Perl_modules,_which_themselves_use_C_libraries,_from_your_C_program">Using
  Perl modules, which themselves use C libraries, from your C program</a></h2>
If you've played with the examples above and tried to embed a script that
  <i></i> <i>use()</i><i></i>s a Perl module (such as <i>Socket</i>) which
  itself uses a C or C++ library, this probably happened:
<div class="Pp"></div>
<pre>
 Can't load module Socket, dynamic loading not available in this perl.
  (You may need to build a new perl executable which either supports
  dynamic loading or has the Socket module statically linked into it.)
</pre>
<div class="Pp"></div>
What's wrong?
<div class="Pp"></div>
Your interpreter doesn't know how to communicate with these extensions on its
  own. A little glue will help. Up until now you've been calling
  <i></i><i>perl_parse()</i> <i></i>, handing it NULL for the second argument:
<div class="Pp"></div>
<pre>
 perl_parse(my_perl, NULL, argc, my_argv, NULL);
</pre>
<div class="Pp"></div>
That's where the glue code can be inserted to create the initial contact between
  Perl and linked C/C++ routines. Let's take a look some pieces of
  <i>perlmain.c</i> to see how Perl does this:
<div class="Pp"></div>
<pre>
 static void xs_init (pTHX);
 EXTERN_C void boot_DynaLoader (pTHX_ CV* cv);
 EXTERN_C void boot_Socket (pTHX_ CV* cv);
 EXTERN_C void
 xs_init(pTHX)
 {
        char *file = __FILE__;
        /* DynaLoader is a special case */
        newXS(&quot;DynaLoader::boot_DynaLoader&quot;, boot_DynaLoader, file);
        newXS(&quot;Socket::bootstrap&quot;, boot_Socket, file);
 }
</pre>
<div class="Pp"></div>
Simply put: for each extension linked with your Perl executable (determined
  during its initial configuration on your computer or when adding a new
  extension), a Perl subroutine is created to incorporate the extension's
  routines. Normally, that subroutine is named
  <i></i><i>Module::bootstrap()</i><i></i> and is invoked when you say <i>use
  Module</i>. In turn, this hooks into an XSUB, <i>boot_Module</i>, which
  creates a Perl counterpart for each of the extension's XSUBs. Don't worry
  about this part; leave that to the <i>xsubpp</i> and extension authors. If
  your extension is dynamically loaded, DynaLoader creates
  <i></i><i>Module::bootstrap()</i> <i></i> for you on the fly. In fact, if you
  have a working DynaLoader then there is rarely any need to link in any other
  extensions statically.
<div class="Pp"></div>
Once you have this code, slap it into the second argument of
  <i></i><i>perl_parse()</i> <i></i>:
<div class="Pp"></div>
<pre>
 perl_parse(my_perl, xs_init, argc, my_argv, NULL);
</pre>
<div class="Pp"></div>
Then compile:
<div class="Pp"></div>
<pre>
 % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
 % interp
   use Socket;
   use SomeDynamicallyLoadedModule;
   print &quot;Now I can use extensions!\n&quot;'
</pre>
<div class="Pp"></div>
<b>ExtUtils::Embed</b> can also automate writing the <i>xs_init</i> glue code.
<div class="Pp"></div>
<pre>
 % perl -MExtUtils::Embed -e xsinit -- -o perlxsi.c
 % cc -c perlxsi.c `perl -MExtUtils::Embed -e ccopts`
 % cc -c interp.c  `perl -MExtUtils::Embed -e ccopts`
 % cc -o interp perlxsi.o interp.o `perl -MExtUtils::Embed -e ldopts`
</pre>
<div class="Pp"></div>
Consult perlxs, perlguts, and perlapi for more details.
<h1 class="Sh" title="Sh" id="Hiding_Perl_"><a class="selflink" href="#Hiding_Perl_">Hiding
  Perl_</a></h1>
If you completely hide the short forms of the Perl public API, add
  -DPERL_NO_SHORT_NAMES to the compilation flags. This means that for example
  instead of writing
<div class="Pp"></div>
<pre>
    warn(&quot;%d bottles of beer on the wall&quot;, bottlecount);
</pre>
<div class="Pp"></div>
you will have to write the explicit full form
<div class="Pp"></div>
<pre>
    Perl_warn(aTHX_ &quot;%d bottles of beer on the wall&quot;, bottlecount);
</pre>
<div class="Pp"></div>
(See &quot;Background and PERL_IMPLICIT_CONTEXT&quot; in perlguts for the
  explanation of the &quot;aTHX_&quot;. ) Hiding the short forms is very useful
  for avoiding all sorts of nasty (C preprocessor or otherwise) conflicts with
  other software packages (Perl defines about 2400 APIs with these short names,
  take or leave few hundred, so there certainly is room for conflict.)
<h1 class="Sh" title="Sh" id="MORAL"><a class="selflink" href="#MORAL">MORAL</a></h1>
You can sometimes <i>write faster code</i> in C, but you can always <i>write
  code faster</i> in Perl. Because you can use each from the other, combine them
  as you wish.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Jon Orwant &lt; <i>orwant@media.mit.edu</i>&gt; and Doug MacEachern &lt;
  <i>dougm@covalent.net</i>&gt;, with small contributions from Tim Bunce, Tom
  Christiansen, Guy Decoux, Hallvard Furuseth, Dov Grobgeld, and Ilya
  Zakharevich.
<div class="Pp"></div>
Doug MacEachern has an article on embedding in Volume 1, Issue 4 of The Perl
  Journal ( http://www.tpj.com/ ). Doug is also the developer of the most
  widely-used Perl embedding: the mod_perl system (perl.apache.org), which
  embeds Perl in the Apache web server. Oracle, Binary Evolution, ActiveState,
  and Ben Sugars's nsapi_perl have used this model for Oracle, Netscape and
  Internet Information Server Perl plugins.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant. All Rights
  Reserved.
<div class="Pp"></div>
This document may be distributed under the same terms as Perl itself.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
