<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLUNICODE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLUNICODE(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLUNICODE(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlunicode - Unicode support in Perl
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<h2 class="Ss" title="Ss" id="Important_Caveats"><a class="selflink" href="#Important_Caveats">Important
  Caveats</a></h2>
Unicode support is an extensive requirement. While Perl does not implement the
  Unicode standard or the accompanying technical reports from cover to cover,
  Perl does support many Unicode features.
<div class="Pp"></div>
People who want to learn to use Unicode in Perl, should probably read the Perl
  Unicode tutorial, perlunitut and perluniintro, before reading this reference
  document.
<div class="Pp"></div>
Also, the use of Unicode may present security issues that aren't obvious. Read
  Unicode Security Considerations &lt;http://www.unicode.org/reports/tr36&gt;.
<dl class="Bl-tag">
  <dt class="It-tag">Safest if you &quot;use feature
    'unicode_strings'&quot;</dt>
  <dd class="It-tag">In order to preserve backward compatibility, Perl does not
      turn on full internal Unicode support unless the pragma &quot;use feature
      'unicode_strings'&quot; is specified. (This is automatically selected if
      you use &quot;use 5.012&quot; or higher.) Failure to do this can trigger
      unexpected surprises. See &quot;The &quot;Unicode Bug&quot;&quot; below.
    <div style="height: 1.00em;">&#x00A0;</div>
    This pragma doesn't affect I/O, and there are still several places where
      Unicode isn't fully supported, such as in filenames.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Input and Output Layers</dt>
  <dd class="It-tag">Perl knows when a filehandle uses Perl's internal Unicode
      encodings (UTF-8, or UTF-EBCDIC if in EBCDIC) if the filehandle is opened
      with the &quot;:encoding(utf8)&quot; layer. Other encodings can be
      converted to Perl's encoding on input or from Perl's encoding on output by
      use of the &quot;:encoding(...)&quot; layer. See open.
    <div style="height: 1.00em;">&#x00A0;</div>
    To indicate that Perl source itself is in UTF-8, use &quot;use
    utf8;&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;use utf8&quot; still needed to enable
    UTF-8/UTF-EBCDIC in scripts</dt>
  <dd class="It-tag">As a compatibility measure, the &quot;use utf8&quot; pragma
      must be explicitly included to enable recognition of UTF-8 in the Perl
      scripts themselves (in string or regular expression literals, or in
      identifier names) on ASCII-based machines or to recognize UTF-EBCDIC on
      EBCDIC-based machines. <b>These are the only times when an explicit
      </b><b>&quot;use utf8&quot;</b><b></b> <b>is needed.</b> See utf8.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">BOM-marked scripts and UTF-16 scripts autodetected</dt>
  <dd class="It-tag">If a Perl script begins marked with the Unicode BOM
      (UTF-16LE, UTF16-BE, or UTF-8), or if the script looks like non-BOM-marked
      UTF-16 of either endianness, Perl will correctly read in the script as
      Unicode. (BOMless UTF-8 cannot be effectively recognized or differentiated
      from ISO 8859-1 or other eight-bit encodings.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;use encoding&quot; needed to upgrade non-Latin-1 byte
    strings</dt>
  <dd class="It-tag">By default, there is a fundamental asymmetry in Perl's
      Unicode model: implicit upgrading from byte strings to Unicode strings
      assumes that they were encoded in <i>ISO 8859-1 (Latin-1)</i>, but Unicode
      strings are downgraded with UTF-8 encoding. This happens because the first
      256 codepoints in Unicode happens to agree with Latin-1.
    <div style="height: 1.00em;">&#x00A0;</div>
    See &quot;Byte and Character Semantics&quot; for more details.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Byte_and_Character_Semantics"><a class="selflink" href="#Byte_and_Character_Semantics">Byte
  and Character Semantics</a></h2>
Beginning with version 5.6, Perl uses logically-wide characters to represent
  strings internally.
<div class="Pp"></div>
Starting in Perl 5.14, Perl-level operations work with characters rather than
  bytes within the scope of a &quot;use feature 'unicode_strings'&quot; (or
  equivalently &quot;use 5.012&quot; or higher). (This is not true if bytes have
  been explicitly requested by &quot;use bytes&quot;, nor necessarily true for
  interactions with the platform's operating system.)
<div class="Pp"></div>
For earlier Perls, and when &quot;unicode_strings&quot; is not in effect, Perl
  provides a fairly safe environment that can handle both types of semantics in
  programs. For operations where Perl can unambiguously decide that the input
  data are characters, Perl switches to character semantics. For operations
  where this determination cannot be made without additional information from
  the user, Perl decides in favor of compatibility and chooses to use byte
  semantics.
<div class="Pp"></div>
When &quot;use locale&quot; (but not &quot;use locale ':not_characters'&quot;)
  is in effect, Perl uses the semantics associated with the current locale.
  (&quot;use locale&quot; overrides &quot;use feature 'unicode_strings'&quot; in
  the same scope; while &quot;use locale ':not_characters'&quot; effectively
  also selects &quot;use feature 'unicode_strings'&quot; in its scope; see
  perllocale.) Otherwise, Perl uses the platform's native byte semantics for
  characters whose code points are less than 256, and Unicode semantics for
  those greater than 255. On EBCDIC platforms, this is almost seamless, as the
  EBCDIC code pages that Perl handles are equivalent to Unicode's first 256 code
  points. (The exception is that EBCDIC regular expression case-insensitive
  matching rules are not as as robust as Unicode's.) But on ASCII platforms,
  Perl uses US-ASCII (or Basic Latin in Unicode terminology) byte semantics,
  meaning that characters whose ordinal numbers are in the range 128 - 255 are
  undefined except for their ordinal numbers. This means that none have case
  (upper and lower), nor are any a member of character classes, like
  &quot;[:alpha:]&quot; or &quot;\w&quot;. (But all do belong to the
  &quot;\W&quot; class or the Perl regular expression extension
  &quot;[:^alpha:]&quot;.)
<div class="Pp"></div>
This behavior preserves compatibility with earlier versions of Perl, which
  allowed byte semantics in Perl operations only if none of the program's inputs
  were marked as being a source of Unicode character data. Such data may come
  from filehandles, from calls to external programs, from information provided
  by the system (such as %ENV), or from literals and constants in the source
  text.
<div class="Pp"></div>
The &quot;utf8&quot; pragma is primarily a compatibility device that enables
  recognition of UTF-(8|EBCDIC) in literals encountered by the parser. Note that
  this pragma is only required while Perl defaults to byte semantics; when
  character semantics become the default, this pragma may become a no-op. See
  utf8.
<div class="Pp"></div>
If strings operating under byte semantics and strings with Unicode character
  data are concatenated, the new string will have character semantics. This can
  cause surprises: See &quot;BUGS&quot;, below. You can choose to be warned when
  this happens. See encoding::warnings.
<div class="Pp"></div>
Under character semantics, many operations that formerly operated on bytes now
  operate on characters. A character in Perl is logically just a number ranging
  from 0 to 2**31 or so. Larger characters may encode into longer sequences of
  bytes internally, but this internal detail is mostly hidden for Perl code. See
  perluniintro for more.
<h2 class="Ss" title="Ss" id="Effects_of_Character_Semantics"><a class="selflink" href="#Effects_of_Character_Semantics">Effects
  of Character Semantics</a></h2>
Character semantics have the following effects:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Strings--including hash keys--and regular expression
      patterns may contain characters that have an ordinal value larger than
      255.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you use a Unicode editor to edit your program, Unicode characters may
      occur directly within the literal strings in UTF-8 encoding, or UTF-16.
      (The former requires a BOM or &quot;use utf8&quot;, the latter requires a
      BOM.)
    <div style="height: 1.00em;">&#x00A0;</div>
    Unicode characters can also be added to a string by using the
      &quot;\N{U+...}&quot; notation. The Unicode code for the desired
      character, in hexadecimal, should be placed in the braces, after the
      &quot;U&quot;. For instance, a smiley face is &quot;\N{U+263A}&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Alternatively, you can use the &quot;\x{...}&quot; notation for characters
      0x100 and above. For characters below 0x100 you may get byte semantics
      instead of character semantics; see &quot;The &quot;Unicode
      Bug&quot;&quot;. On EBCDIC machines there is the additional problem that
      the value for such characters gives the EBCDIC character rather than the
      Unicode one, thus it is more portable to use &quot;\N{U+...}&quot;
      instead.
    <div style="height: 1.00em;">&#x00A0;</div>
    Additionally, you can use the &quot;\N{...}&quot; notation and put the
      official Unicode character name within the braces, such as &quot;\N{WHITE
      SMILING FACE}&quot;. This automatically loads the charnames module with
      the &quot;:full&quot; and &quot;:short&quot; options. If you prefer
      different options for this module, you can instead, before the
      &quot;\N{...}&quot;, explicitly load it with your desired options; for
      example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
   use charnames ':loose';
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If an appropriate encoding is specified, identifiers within
      the Perl script may contain Unicode alphanumeric characters, including
      ideographs. Perl does not currently attempt to canonicalize variable
      names.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Regular expressions match characters instead of bytes.
      &quot;.&quot; matches a character instead of a byte.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Bracketed character classes in regular expressions match
      characters instead of bytes and match against the character properties
      specified in the Unicode properties database. &quot;\w&quot; can be used
      to match a Japanese ideograph, for instance.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Named Unicode properties, scripts, and block ranges may be
      used (like bracketed character classes) by using the &quot;\p{}&quot;
      &quot;matches property&quot; construct and the &quot;\P{}&quot; negation,
      &quot;doesn't match property&quot;. See &quot;Unicode Character
      Properties&quot; for more details.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can define your own character properties and use them in the regular
      expression with the &quot;\p{}&quot; or &quot;\P{}&quot; construct. See
      &quot;User-Defined Character Properties&quot; for more details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The special pattern &quot;\X&quot; matches a logical
      character, an &quot;extended grapheme cluster&quot; in Standardese. In
      Unicode what appears to the user to be a single character, for example an
      accented &quot;G&quot;, may in fact be composed of a sequence of
      characters, in this case a &quot;G&quot; followed by an accent character.
      &quot;\X&quot; will match the entire sequence.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The &quot;tr///&quot; operator translates characters
      instead of bytes. Note that the &quot;tr///CU&quot; functionality has been
      removed. For similar functionality see pack('U0', ...) and pack('C0',
      ...).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Case translation operators use the Unicode case translation
      tables when character input is provided. Note that &quot;uc()&quot;, or
      &quot;\U&quot; in interpolated strings, translates to uppercase, while
      &quot;ucfirst&quot;, or &quot;\u&quot; in interpolated strings, translates
      to titlecase in languages that make the distinction (which is equivalent
      to uppercase in languages without the distinction).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Most operators that deal with positions or lengths in a
      string will automatically switch to using character positions, including
      &quot;chop()&quot;, &quot;chomp()&quot;, &quot;substr()&quot;,
      &quot;pos()&quot;, &quot;index()&quot;, &quot;rindex()&quot;,
      &quot;sprintf()&quot;, &quot;write()&quot;, and &quot;length()&quot;. An
      operator that specifically does not switch is &quot;vec()&quot;. Operators
      that really don't care include operators that treat strings as a bucket of
      bits such as &quot;sort()&quot;, and operators dealing with
    filenames.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The &quot;pack()&quot;/&quot;unpack()&quot; letter
      &quot;C&quot; does <i>not</i> change, since it is often used for
      byte-oriented formats. Again, think &quot;char&quot; in the C language.
    <div style="height: 1.00em;">&#x00A0;</div>
    There is a new &quot;U&quot; specifier that converts between Unicode
      characters and code points. There is also a &quot;W&quot; specifier that
      is the equivalent of &quot;chr&quot;/&quot;ord&quot; and properly handles
      character values even if they are above 255.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The &quot;chr()&quot; and &quot;ord()&quot; functions work
      on characters, similar to &quot;pack(&quot;W&quot;)&quot; and
      &quot;unpack(&quot;W&quot;)&quot;, <i>not</i>
      &quot;pack(&quot;C&quot;)&quot; and &quot;unpack(&quot;C&quot;)&quot;.
      &quot;pack(&quot;C&quot;)&quot; and &quot;unpack(&quot;C&quot;)&quot; are
      methods for emulating byte-oriented &quot;chr()&quot; and
      &quot;ord()&quot; on Unicode strings. While these methods reveal the
      internal encoding of Unicode strings, that is not something one normally
      needs to care about at all.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The bit string operators, &quot;&amp; | ^ ~&quot;, can
      operate on character data. However, for backward compatibility, such as
      when using bit string operations when characters are all less than 256 in
      ordinal value, one should not use &quot;~&quot; (the bit complement) with
      characters of both values less than 256 and values greater than 256. Most
      importantly, DeMorgan's laws (&quot;~($x|$y) eq ~$x&amp;~$y&quot; and
      &quot;~($x&amp;$y) eq ~$x|~$y&quot;) will not hold. The reason for this
      mathematical <i>faux pas</i> is that the complement cannot return
      <b>both</b> the 8-bit (byte-wide) bit complement <b>and</b> the full
      character-wide bit complement.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">There is a CPAN module, Unicode::Casing, which allows you
      to define your own mappings to be used in &quot;lc()&quot;,
      &quot;lcfirst()&quot;, &quot;uc()&quot;, &quot;ucfirst()&quot;, and
      &quot;fc&quot; (or their double-quoted string inlined versions such as
      &quot;\U&quot;). (Prior to Perl 5.16, this functionality was partially
      provided in the Perl core, but suffered from a number of insurmountable
      drawbacks, so the CPAN module was written instead.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">And finally, &quot;scalar reverse()&quot; reverses by
      character rather than by byte.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Unicode_Character_Properties"><a class="selflink" href="#Unicode_Character_Properties">Unicode
  Character Properties</a></h2>
(The only time that Perl considers a sequence of individual code points as a
  single logical character is in the &quot;\X&quot; construct, already mentioned
  above. Therefore &quot;character&quot; in this discussion means a single
  Unicode code point.)
<div class="Pp"></div>
Very nearly all Unicode character properties are accessible through regular
  expressions by using the &quot;\p{}&quot; &quot;matches property&quot;
  construct and the &quot;\P{}&quot; &quot;doesn't match property&quot; for its
  negation.
<div class="Pp"></div>
For instance, &quot;\p{Uppercase}&quot; matches any single character with the
  Unicode &quot;Uppercase&quot; property, while &quot;\p{L}&quot; matches any
  character with a General_Category of &quot;L&quot; (letter) property. Brackets
  are not required for single letter property names, so &quot;\p{L}&quot; is
  equivalent to &quot;\pL&quot;.
<div class="Pp"></div>
More formally, &quot;\p{Uppercase}&quot; matches any single character whose
  Unicode Uppercase property value is True, and &quot;\P{Uppercase}&quot;
  matches any character whose Uppercase property value is False, and they could
  have been written as &quot;\p{Uppercase=True}&quot; and
  &quot;\p{Uppercase=False}&quot;, respectively.
<div class="Pp"></div>
This formality is needed when properties are not binary; that is, if they can
  take on more values than just True and False. For example, the Bidi_Class (see
  &quot;Bidirectional Character Types&quot; below), can take on several
  different values, such as Left, Right, Whitespace, and others. To match these,
  one needs to specify both the property name (Bidi_Class), AND the value being
  matched against (Left, Right, etc.). This is done, as in the examples above,
  by having the two components separated by an equal sign (or interchangeably, a
  colon), like &quot;\p{Bidi_Class: Left}&quot;.
<div class="Pp"></div>
All Unicode-defined character properties may be written in these compound forms
  of &quot;\p{property=value}&quot; or &quot;\p{property:value}&quot;, but Perl
  provides some additional properties that are written only in the single form,
  as well as single-form short-cuts for all binary properties and certain others
  described below, in which you may omit the property name and the equals or
  colon separator.
<div class="Pp"></div>
Most Unicode character properties have at least two synonyms (or aliases if you
  prefer): a short one that is easier to type and a longer one that is more
  descriptive and hence easier to understand. Thus the &quot;L&quot; and
  &quot;Letter&quot; properties above are equivalent and can be used
  interchangeably. Likewise, &quot;Upper&quot; is a synonym for
  &quot;Uppercase&quot;, and we could have written &quot;\p{Uppercase}&quot;
  equivalently as &quot;\p{Upper}&quot;. Also, there are typically various
  synonyms for the values the property can be. For binary properties,
  &quot;True&quot; has 3 synonyms: &quot;T&quot;, &quot;Yes&quot;, and
  &quot;Y&quot;; and &quot;False has correspondingly &quot;F&quot;,
  &quot;No&quot;, and &quot;N&quot;. But be careful. A short form of a value for
  one property may not mean the same thing as the same short form for another.
  Thus, for the General_Category property, &quot;L&quot; means
  &quot;Letter&quot;, but for the Bidi_Class property, &quot;L&quot; means
  &quot;Left&quot;. A complete list of properties and synonyms is in
  perluniprops.
<div class="Pp"></div>
Upper/lower case differences in property names and values are irrelevant; thus
  &quot;\p{Upper}&quot; means the same thing as &quot;\p{upper}&quot; or even
  &quot;\p{UpPeR}&quot;. Similarly, you can add or subtract underscores anywhere
  in the middle of a word, so that these are also equivalent to
  &quot;\p{U_p_p_e_r}&quot;. And white space is irrelevant adjacent to non-word
  characters, such as the braces and the equals or colon separators, so
  &quot;\p{ Upper }&quot; and &quot;\p{ Upper_case : Y }&quot; are equivalent to
  these as well. In fact, white space and even hyphens can usually be added or
  deleted anywhere. So even &quot;\p{ Up-per case = Yes}&quot; is equivalent.
  All this is called &quot;loose-matching&quot; by Unicode. The few places where
  stricter matching is used is in the middle of numbers, and in the Perl
  extension properties that begin or end with an underscore. Stricter matching
  cares about white space (except adjacent to non-word characters), hyphens, and
  non-interior underscores.
<div class="Pp"></div>
You can also use negation in both &quot;\p{}&quot; and &quot;\P{}&quot; by
  introducing a caret (^) between the first brace and the property name:
  &quot;\p{^Tamil}&quot; is equal to &quot;\P{Tamil}&quot;.
<div class="Pp"></div>
Almost all properties are immune to case-insensitive matching. That is, adding a
  &quot;/i&quot; regular expression modifier does not change what they match.
  There are two sets that are affected. The first set is
  &quot;Uppercase_Letter&quot;, &quot;Lowercase_Letter&quot;, and
  &quot;Titlecase_Letter&quot;, all of which match &quot;Cased_Letter&quot;
  under &quot;/i&quot; matching. And the second set is &quot;Uppercase&quot;,
  &quot;Lowercase&quot;, and &quot;Titlecase&quot;, all of which match
  &quot;Cased&quot; under &quot;/i&quot; matching. This set also includes its
  subsets &quot;PosixUpper&quot; and &quot;PosixLower&quot; both of which under
  &quot;/i&quot; matching match &quot;PosixAlpha&quot;. (The difference between
  these sets is that some things, such as Roman numerals, come in both upper and
  lower case so they are &quot;Cased&quot;, but aren't considered letters, so
  they aren't &quot;Cased_Letter&quot;s.)
<div class="Pp"></div>
The result is undefined if you try to match a non-Unicode code point (that is,
  one above 0x10FFFF) against a Unicode property. Currently, a warning is
  raised, and the match will fail. In some cases, this is counterintuitive, as
  both these fail:
<div class="Pp"></div>
<pre>
 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Fails!
</pre>
<div class="Pp"></div>
<i></i><b><i>General_Category</i></b><i></i>
<div class="Pp"></div>
Every Unicode character is assigned a general category, which is the &quot;most
  usual categorization of a character&quot; (from
  &lt;http://www.unicode.org/reports/tr44&gt;).
<div class="Pp"></div>
The compound way of writing these is like
  &quot;\p{General_Category=Number}&quot; (short, &quot;\p{gc:n}&quot;). But
  Perl furnishes shortcuts in which everything up through the equal or colon
  separator is omitted. So you can instead just write &quot;\pN&quot;.
<div class="Pp"></div>
Here are the short and long forms of the General Category properties:
<div class="Pp"></div>
<pre>
    Short       Long
    L           Letter
    LC, L&amp;      Cased_Letter (that is: [\p{Ll}\p{Lu}\p{Lt}])
    Lu          Uppercase_Letter
    Ll          Lowercase_Letter
    Lt          Titlecase_Letter
    Lm          Modifier_Letter
    Lo          Other_Letter
    M           Mark
    Mn          Nonspacing_Mark
    Mc          Spacing_Mark
    Me          Enclosing_Mark
    N           Number
    Nd          Decimal_Number (also Digit)
    Nl          Letter_Number
    No          Other_Number
    P           Punctuation (also Punct)
    Pc          Connector_Punctuation
    Pd          Dash_Punctuation
    Ps          Open_Punctuation
    Pe          Close_Punctuation
    Pi          Initial_Punctuation
                (may behave like Ps or Pe depending on usage)
    Pf          Final_Punctuation
                (may behave like Ps or Pe depending on usage)
    Po          Other_Punctuation
    S           Symbol
    Sm          Math_Symbol
    Sc          Currency_Symbol
    Sk          Modifier_Symbol
    So          Other_Symbol
    Z           Separator
    Zs          Space_Separator
    Zl          Line_Separator
    Zp          Paragraph_Separator
    C           Other
    Cc          Control (also Cntrl)
    Cf          Format
    Cs          Surrogate
    Co          Private_Use
    Cn          Unassigned
</pre>
<div class="Pp"></div>
Single-letter properties match all characters in any of the two-letter
  sub-properties starting with the same letter. &quot;LC&quot; and
  &quot;L&amp;&quot; are special: both are aliases for the set consisting of
  everything matched by &quot;Ll&quot;, &quot;Lu&quot;, and &quot;Lt&quot;.
<div class="Pp"></div>
<i></i><b><i>Bidirectional Character Types</i></b><i></i>
<div class="Pp"></div>
Because scripts differ in their directionality (Hebrew and Arabic are written
  right to left, for example) Unicode supplies these properties in the
  Bidi_Class class:
<div class="Pp"></div>
<pre>
    Property    Meaning
    L           Left-to-Right
    LRE         Left-to-Right Embedding
    LRO         Left-to-Right Override
    R           Right-to-Left
    AL          Arabic Letter
    RLE         Right-to-Left Embedding
    RLO         Right-to-Left Override
    PDF         Pop Directional Format
    EN          European Number
    ES          European Separator
    ET          European Terminator
    AN          Arabic Number
    CS          Common Separator
    NSM         Non-Spacing Mark
    BN          Boundary Neutral
    B           Paragraph Separator
    S           Segment Separator
    WS          Whitespace
    ON          Other Neutrals
</pre>
<div class="Pp"></div>
This property is always written in the compound form. For example,
  &quot;\p{Bidi_Class:R}&quot; matches characters that are normally written
  right to left.
<div class="Pp"></div>
<i></i><b><i>Scripts</i></b><i></i>
<div class="Pp"></div>
The world's languages are written in many different scripts. This sentence
  (unless you're reading it in translation) is written in Latin, while Russian
  is written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly
  in Hiragana or Katakana. There are many more.
<div class="Pp"></div>
The Unicode Script and Script_Extensions properties give what script a given
  character is in. Either property can be specified with the compound form like
  &quot;\p{Script=Hebrew}&quot; (short: &quot;\p{sc=hebr}&quot;), or
  &quot;\p{Script_Extensions=Javanese}&quot; (short: &quot;\p{scx=java}&quot;).
  In addition, Perl furnishes shortcuts for all &quot;Script&quot; property
  names. You can omit everything up through the equals (or colon), and simply
  write &quot;\p{Latin}&quot; or &quot;\P{Cyrillic}&quot;. (This is not true for
  &quot;Script_Extensions&quot;, which is required to be written in the compound
  form.)
<div class="Pp"></div>
The difference between these two properties involves characters that are used in
  multiple scripts. For example the digits '0' through '9' are used in many
  parts of the world. These are placed in a script named &quot;Common&quot;.
  Other characters are used in just a few scripts. For example, the
  &quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot; is used in both Japanese scripts,
  Katakana and Hiragana, but nowhere else. The &quot;Script&quot; property
  places all characters that are used in multiple scripts in the
  &quot;Common&quot; script, while the &quot;Script_Extensions&quot; property
  places those that are used in only a few scripts into each of those scripts;
  while still using &quot;Common&quot; for those used in many scripts. Thus both
  these match:
<div class="Pp"></div>
<pre>
 &quot;0&quot; =~ /\p{sc=Common}/     # Matches
 &quot;0&quot; =~ /\p{scx=Common}/    # Matches
</pre>
<div class="Pp"></div>
and only the first of these match:
<div class="Pp"></div>
<pre>
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Common}  # Matches
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Common} # No match
</pre>
<div class="Pp"></div>
And only the last two of these match:
<div class="Pp"></div>
<pre>
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Hiragana}  # No match
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Katakana}  # No match
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Hiragana} # Matches
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Katakana} # Matches
</pre>
<div class="Pp"></div>
&quot;Script_Extensions&quot; is thus an improved &quot;Script&quot;, in which
  there are fewer characters in the &quot;Common&quot; script, and
  correspondingly more in other scripts. It is new in Unicode version 6.0, and
  its data are likely to change significantly in later releases, as things get
  sorted out.
<div class="Pp"></div>
(Actually, besides &quot;Common&quot;, the &quot;Inherited&quot; script,
  contains characters that are used in multiple scripts. These are modifier
  characters which modify other characters, and inherit the script value of the
  controlling character. Some of these are used in many scripts, and so go into
  &quot;Inherited&quot; in both &quot;Script&quot; and
  &quot;Script_Extensions&quot;. Others are used in just a few scripts, so are
  in &quot;Inherited&quot; in &quot;Script&quot;, but not in
  &quot;Script_Extensions&quot;.)
<div class="Pp"></div>
It is worth stressing that there are several different sets of digits in Unicode
  that are equivalent to 0-9 and are matchable by &quot;\d&quot; in a regular
  expression. If they are used in a single language only, they are in that
  language's &quot;Script&quot; and &quot;Script_Extension&quot;. If they are
  used in more than one script, they will be in &quot;sc=Common&quot;, but only
  if they are used in many scripts should they be in &quot;scx=Common&quot;.
<div class="Pp"></div>
A complete list of scripts and their shortcuts is in perluniprops.
<div class="Pp"></div>
<i></i><b><i>Use of &quot;Is&quot; Prefix</i></b><i></i>
<div class="Pp"></div>
For backward compatibility (with Perl 5.6), all properties mentioned so far may
  have &quot;Is&quot; or &quot;Is_&quot; prepended to their name, so
  &quot;\P{Is_Lu}&quot;, for example, is equal to &quot;\P{Lu}&quot;, and
  &quot;\p{IsScript:Arabic}&quot; is equal to &quot;\p{Arabic}&quot;.
<div class="Pp"></div>
<i></i><b><i>Blocks</i></b><i></i>
<div class="Pp"></div>
In addition to <b>scripts</b>, Unicode also defines <b>blocks</b> of characters.
  The difference between scripts and blocks is that the concept of scripts is
  closer to natural languages, while the concept of blocks is more of an
  artificial grouping based on groups of Unicode characters with consecutive
  ordinal values. For example, the &quot;Basic Latin&quot; block is all
  characters whose ordinals are between 0 and 127, inclusive; in other words,
  the ASCII characters. The &quot;Latin&quot; script contains some letters from
  this as well as several other blocks, like &quot;Latin-1 Supplement&quot;,
  &quot;Latin Extended-A&quot;, etc., but it does not contain all the characters
  from those blocks. It does not, for example, contain the digits 0-9, because
  those digits are shared across many scripts, and hence are in the
  &quot;Common&quot; script.
<div class="Pp"></div>
For more about scripts versus blocks, see UAX#24 &quot;Unicode Script
  Property&quot;: &lt;http://www.unicode.org/reports/tr24&gt;
<div class="Pp"></div>
The &quot;Script&quot; or &quot;Script_Extensions&quot; properties are likely to
  be the ones you want to use when processing natural language; the Block
  property may occasionally be useful in working with the nuts and bolts of
  Unicode.
<div class="Pp"></div>
Block names are matched in the compound form, like &quot;\p{Block: Arrows}&quot;
  or &quot;\p{Blk=Hebrew}&quot;. Unlike most other properties, only a few block
  names have a Unicode-defined short name. But Perl does provide a (slight)
  shortcut: You can say, for example &quot;\p{In_Arrows}&quot; or
  &quot;\p{In_Hebrew}&quot;. For backwards compatibility, the &quot;In&quot;
  prefix may be omitted if there is no naming conflict with a script or any
  other property, and you can even use an &quot;Is&quot; prefix instead in those
  cases. But it is not a good idea to do this, for a couple reasons:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">It is confusing. There are many naming conflicts, and you
      may forget some. For example, &quot;\p{Hebrew}&quot; means the
      <i>script</i> Hebrew, and NOT the <i>block</i> Hebrew. But would you
      remember that 6 months from now?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">It is unstable. A new version of Unicode may pre-empt the
      current meaning by creating a property with the same name. There was a
      time in very early Unicode releases when &quot;\p{Hebrew}&quot; would have
      matched the <i>block</i> Hebrew; now it doesn't.</dd>
</dl>
<div class="Pp"></div>
Some people prefer to always use &quot;\p{Block: foo}&quot; and &quot;\p{Script:
  bar}&quot; instead of the shortcuts, whether for clarity, because they can't
  remember the difference between 'In' and 'Is' anyway, or they aren't confident
  that those who eventually will read their code will know that difference.
<div class="Pp"></div>
A complete list of blocks and their shortcuts is in perluniprops.
<div class="Pp"></div>
<i></i><b><i>Other Properties</i></b><i></i>
<div class="Pp"></div>
There are many more properties than the very basic ones described here. A
  complete list is in perluniprops.
<div class="Pp"></div>
Unicode defines all its properties in the compound form, so all single-form
  properties are Perl extensions. Most of these are just synonyms for the
  Unicode ones, but some are genuine extensions, including several that are in
  the compound form. And quite a few of these are actually recommended by
  Unicode (in &lt;http://www.unicode.org/reports/tr18&gt;).
<div class="Pp"></div>
This section gives some details on all extensions that aren't just synonyms for
  compound-form Unicode properties (for those properties, you'll have to refer
  to the Unicode Standard &lt;http://www.unicode.org/reports/tr44&gt;.
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{All}&quot;</b><b></b></dt>
  <dd class="It-tag">This matches any of the 1_114_112 Unicode code points. It
      is a synonym for &quot;\p{Any}&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Alnum}&quot;</b><b></b></dt>
  <dd class="It-tag">This matches any &quot;\p{Alphabetic}&quot; or
      &quot;\p{Decimal_Number}&quot; character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Any}&quot;</b><b></b></dt>
  <dd class="It-tag">This matches any of the 1_114_112 Unicode code points. It
      is a synonym for &quot;\p{All}&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{ASCII}&quot;</b><b></b></dt>
  <dd class="It-tag">This matches any of the 128 characters in the US-ASCII
      character set, which is a subset of Unicode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Assigned}&quot;</b><b></b></dt>
  <dd class="It-tag">This matches any assigned code point; that is, any code
      point whose general category is not Unassigned (or equivalently, not
    Cn).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Blank}&quot;</b><b></b></dt>
  <dd class="It-tag">This is the same as &quot;\h&quot; and
      &quot;\p{HorizSpace}&quot;: A character that changes the spacing
      horizontally.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Decomposition_Type:
    Non_Canonical}&quot;</b> <b></b> (Short: &quot;\p{Dt=NonCanon}&quot;)</dt>
  <dd class="It-tag">Matches a character that has a non-canonical decomposition.
    <div style="height: 1.00em;">&#x00A0;</div>
    To understand the use of this rarely used property=value combination, it is
      necessary to know some basics about decomposition. Consider a character,
      say H. It could appear with various marks around it, such as an acute
      accent, or a circumflex, or various hooks, circles, arrows, <i>etc.</i>,
      above, below, to one side or the other, etc. There are many possibilities
      among the world's languages. The number of combinations is astronomical,
      and if there were a character for each combination, it would soon exhaust
      Unicode's more than a million possible characters. So Unicode took a
      different approach: there is a character for the base H, and a character
      for each of the possible marks, and these can be variously combined to get
      a final logical character. So a logical character--what appears to be a
      single character--can be a sequence of more than one individual
      characters. This is called an &quot;extended grapheme cluster&quot;; Perl
      furnishes the &quot;\X&quot; regular expression construct to match such
      sequences.
    <div style="height: 1.00em;">&#x00A0;</div>
    But Unicode's intent is to unify the existing character set standards and
      practices, and several pre-existing standards have single characters that
      mean the same thing as some of these combinations. An example is
      ISO-8859-1, which has quite a few of these in the Latin-1 range, an
      example being &quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;. Because this
      character was in this pre-existing standard, Unicode added it to its
      repertoire. But this character is considered by Unicode to be equivalent
      to the sequence consisting of the character &quot;LATIN CAPITAL LETTER
      E&quot; followed by the character &quot;COMBINING ACUTE ACCENT&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;LATIN CAPITAL LETTER E WITH ACUTE&quot; is called a
      &quot;pre-composed&quot; character, and its equivalence with the sequence
      is called canonical equivalence. All pre-composed characters are said to
      have a decomposition (into the equivalent sequence), and the decomposition
      type is also called canonical.
    <div style="height: 1.00em;">&#x00A0;</div>
    However, many more characters have a different type of decomposition, a
      &quot;compatible&quot; or &quot;non-canonical&quot; decomposition. The
      sequences that form these decompositions are not considered canonically
      equivalent to the pre-composed character. An example, again in the Latin-1
      range, is the &quot;SUPERSCRIPT ONE&quot;. It is somewhat like a regular
      digit 1, but not exactly; its decomposition into the digit 1 is called a
      &quot;compatible&quot; decomposition, specifically a &quot;super&quot;
      decomposition. There are several such compatibility decompositions (see
      &lt;http://www.unicode.org/reports/tr44&gt;), including one called
      &quot;compat&quot;, which means some miscellaneous type of decomposition
      that doesn't fit into the decomposition categories that Unicode has
      chosen.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that most Unicode characters don't have a decomposition, so their
      decomposition type is &quot;None&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    For your convenience, Perl has added the &quot;Non_Canonical&quot;
      decomposition type to mean any of the several compatibility
      decompositions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Graph}&quot;</b><b></b></dt>
  <dd class="It-tag">Matches any character that is graphic. Theoretically, this
      means a character that on a printer would cause ink to be used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{HorizSpace}&quot;</b><b></b></dt>
  <dd class="It-tag">This is the same as &quot;\h&quot; and
      &quot;\p{Blank}&quot;: a character that changes the spacing
    horizontally.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{In=*}&quot;</b><b></b></dt>
  <dd class="It-tag">This is a synonym for &quot;\p{Present_In=*}&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{PerlSpace}&quot;</b><b></b></dt>
  <dd class="It-tag">This is the same as &quot;\s&quot;, restricted to ASCII,
      namely &quot;[&#x00A0;\f\n\r\t]&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Mnemonic: Perl's (original) space</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{PerlWord}&quot;</b><b></b></dt>
  <dd class="It-tag">This is the same as &quot;\w&quot;, restricted to ASCII,
      namely &quot;[A-Za-z0-9_]&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Mnemonic: Perl's (original) word.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Posix...}&quot;</b><b></b></dt>
  <dd class="It-tag">There are several of these, which are equivalents using the
      &quot;\p&quot; notation for Posix classes and are described in &quot;POSIX
      Character Classes&quot; in perlrecharclass.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Present_In: *}&quot;</b><b></b> (Short:
    &quot;\p{In=*}&quot;)</dt>
  <dd class="It-tag">This property is used when you need to know in what Unicode
      version(s) a character is.
    <div style="height: 1.00em;">&#x00A0;</div>
    The &quot;*&quot; above stands for some two digit Unicode version number,
      such as 1.1 or 4.0; or the &quot;*&quot; can also be
      &quot;Unassigned&quot;. This property will match the code points whose
      final disposition has been settled as of the Unicode release given by the
      version number; &quot;\p{Present_In: Unassigned}&quot; will match those
      code points whose meaning has yet to be assigned.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, &quot;U+0041&quot; &quot;LATIN CAPITAL LETTER A&quot; was
      present in the very first Unicode release available, which is 1.1, so this
      property is true for all valid &quot;*&quot; versions. On the other hand,
      &quot;U+1EFF&quot; was not assigned until version 5.1 when it became
      &quot;LATIN SMALL LETTER Y WITH LOOP&quot;, so the only &quot;*&quot; that
      would match it are 5.1, 5.2, and later.
    <div style="height: 1.00em;">&#x00A0;</div>
    Unicode furnishes the &quot;Age&quot; property from which this is derived.
      The problem with Age is that a strict interpretation of it (which Perl
      takes) has it matching the precise release a code point's meaning is
      introduced in. Thus &quot;U+0041&quot; would match only 1.1; and
      &quot;U+1EFF&quot; only 5.1. This is not usually what you want.
    <div style="height: 1.00em;">&#x00A0;</div>
    Some non-Perl implementations of the Age property may change its meaning to
      be the same as the Perl Present_In property; just be aware of that.
    <div style="height: 1.00em;">&#x00A0;</div>
    Another confusion with both these properties is that the definition is not
      that the code point has been <i>assigned</i>, but that the meaning of the
      code point has been <i>determined</i>. This is because 66 code points will
      always be unassigned, and so the Age for them is the Unicode version in
      which the decision to make them so was made. For example,
      &quot;U+FDD0&quot; is to be permanently unassigned to a character, and the
      decision to do that was made in version 3.1, so &quot;\p{Age=3.1}&quot;
      matches this character, as also does &quot;\p{Present_In: 3.1}&quot; and
      up.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Print}&quot;</b><b></b></dt>
  <dd class="It-tag">This matches any character that is graphical or blank,
      except controls.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{SpacePerl}&quot;</b><b></b></dt>
  <dd class="It-tag">This is the same as &quot;\s&quot;, including beyond ASCII.
    <div style="height: 1.00em;">&#x00A0;</div>
    Mnemonic: Space, as modified by Perl. (It doesn't include the vertical tab
      which both the Posix standard and Unicode consider white space.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Title}&quot;</b><b></b> and
    <b></b><b>&quot;\p{Titlecase}&quot;</b> <b></b></dt>
  <dd class="It-tag">Under case-sensitive matching, these both match the same
      code points as &quot;\p{General Category=Titlecase_Letter}&quot;
      (&quot;\p{gc=lt}&quot;). The difference is that under &quot;/i&quot;
      caseless matching, these match the same as &quot;\p{Cased}&quot;, whereas
      &quot;\p{gc=lt}&quot; matches &quot;\p{Cased_Letter&quot;).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{VertSpace}&quot;</b><b></b></dt>
  <dd class="It-tag">This is the same as &quot;\v&quot;: A character that
      changes the spacing vertically.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{Word}&quot;</b><b></b></dt>
  <dd class="It-tag">This is the same as &quot;\w&quot;, including over 100_000
      characters beyond ASCII.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;\p{XPosix...}&quot;</b><b></b></dt>
  <dd class="It-tag">There are several of these, which are the standard Posix
      classes extended to the full Unicode range. They are described in
      &quot;POSIX Character Classes&quot; in perlrecharclass.</dd>
</dl>
<h2 class="Ss" title="Ss" id="User-Defined_Character_Properties"><a class="selflink" href="#User-Defined_Character_Properties">User-Defined
  Character Properties</a></h2>
You can define your own binary character properties by defining subroutines
  whose names begin with &quot;In&quot; or &quot;Is&quot;. The subroutines can
  be defined in any package. The user-defined properties can be used in the
  regular expression &quot;\p&quot; and &quot;\P&quot; constructs; if you are
  using a user-defined property from a package other than the one you are in,
  you must specify its package in the &quot;\p&quot; or &quot;\P&quot;
  construct.
<div class="Pp"></div>
<pre>
    # assuming property Is_Foreign defined in Lang::
    package main;  # property package name required
    if ($txt =~ /\p{Lang::IsForeign}+/) { ... }
    package Lang;  # property package name not required
    if ($txt =~ /\p{IsForeign}+/) { ... }
</pre>
<div class="Pp"></div>
Note that the effect is compile-time and immutable once defined. However, the
  subroutines are passed a single parameter, which is 0 if case-sensitive
  matching is in effect and non-zero if caseless matching is in effect. The
  subroutine may return different values depending on the value of the flag, and
  one set of values will immutably be in effect for all case-sensitive matches,
  and the other set for all case-insensitive matches.
<div class="Pp"></div>
Note that if the regular expression is tainted, then Perl will die rather than
  calling the subroutine, where the name of the subroutine is determined by the
  tainted data.
<div class="Pp"></div>
The subroutines must return a specially-formatted string, with one or more
  newline-separated lines. Each line must be one of the following:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A single hexadecimal number denoting a Unicode code point
      to include.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Two hexadecimal numbers separated by horizontal whitespace
      (space or tabular characters) denoting a range of Unicode code points to
      include.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Something to include, prefixed by &quot;+&quot;: a built-in
      character property (prefixed by &quot;utf8::&quot;) or a fully qualified
      (including package name) user-defined character property, to represent all
      the characters in that property; two hexadecimal code points for a range;
      or a single hexadecimal code point.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Something to exclude, prefixed by &quot;-&quot;: an
      existing character property (prefixed by &quot;utf8::&quot;) or a fully
      qualified (including package name) user-defined character property, to
      represent all the characters in that property; two hexadecimal code points
      for a range; or a single hexadecimal code point.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Something to negate, prefixed &quot;!&quot;: an existing
      character property (prefixed by &quot;utf8::&quot;) or a fully qualified
      (including package name) user-defined character property, to represent all
      the characters in that property; two hexadecimal code points for a range;
      or a single hexadecimal code point.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Something to intersect with, prefixed by &quot;&amp;&quot;:
      an existing character property (prefixed by &quot;utf8::&quot;) or a fully
      qualified (including package name) user-defined character property, for
      all the characters except the characters in the property; two hexadecimal
      code points for a range; or a single hexadecimal code point.</dd>
</dl>
<div class="Pp"></div>
For example, to define a property that covers both the Japanese syllabaries
  (hiragana and katakana), you can define
<div class="Pp"></div>
<pre>
    sub InKana {
        return &lt;&lt;END;
    3040\t309F
    30A0\t30FF
    END
    }
</pre>
<div class="Pp"></div>
Imagine that the here-doc end marker is at the beginning of the line. Now you
  can use &quot;\p{InKana}&quot; and &quot;\P{InKana}&quot;.
<div class="Pp"></div>
You could also have used the existing block property names:
<div class="Pp"></div>
<pre>
    sub InKana {
        return &lt;&lt;'END';
    +utf8::InHiragana
    +utf8::InKatakana
    END
    }
</pre>
<div class="Pp"></div>
Suppose you wanted to match only the allocated characters, not the raw block
  ranges: in other words, you want to remove the non-characters:
<div class="Pp"></div>
<pre>
    sub InKana {
        return &lt;&lt;'END';
    +utf8::InHiragana
    +utf8::InKatakana
    -utf8::IsCn
    END
    }
</pre>
<div class="Pp"></div>
The negation is useful for defining (surprise!) negated classes.
<div class="Pp"></div>
<pre>
    sub InNotKana {
        return &lt;&lt;'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    END
    }
</pre>
<div class="Pp"></div>
This will match all non-Unicode code points, since every one of them is not in
  Kana. You can use intersection to exclude these, if desired, as this modified
  example shows:
<div class="Pp"></div>
<pre>
    sub InNotKana {
        return &lt;&lt;'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    &amp;utf8::Any
    END
    }
</pre>
<div class="Pp"></div>
&amp;utf8::Any must be the last line in the definition.
<div class="Pp"></div>
Intersection is used generally for getting the common characters matched by two
  (or more) classes. It's important to remember not to use &quot;&amp;&quot; for
  the first set; that would be intersecting with nothing, resulting in an empty
  set.
<div class="Pp"></div>
(Note that official Unicode properties differ from these in that they
  automatically exclude non-Unicode code points and a warning is raised if a
  match is attempted on one of those.)
<h2 class="Ss" title="Ss" id="User-Defined_Case_Mappings_(for_serious_hackers_only)"><a class="selflink" href="#User-Defined_Case_Mappings_(for_serious_hackers_only)">User-Defined
  Case Mappings (for serious hackers only)</a></h2>
<b>This feature has been removed as of Perl 5.16.</b> The CPAN module
  Unicode::Casing provides better functionality without the drawbacks that this
  feature had. If you are using a Perl earlier than 5.16, this feature was most
  fully documented in the 5.14 version of this pod:
  http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29
  &lt;http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29&gt;
<h2 class="Ss" title="Ss" id="Character_Encodings_for_Input_and_Output"><a class="selflink" href="#Character_Encodings_for_Input_and_Output">Character
  Encodings for Input and Output</a></h2>
See Encode.
<h2 class="Ss" title="Ss" id="Unicode_Regular_Expression_Support_Level"><a class="selflink" href="#Unicode_Regular_Expression_Support_Level">Unicode
  Regular Expression Support Level</a></h2>
The following list of Unicode supported features for regular expressions
  describes all features currently directly supported by core Perl. The
  references to &quot;Level N&quot; and the section numbers refer to the Unicode
  Technical Standard #18, &quot;Unicode Regular Expressions&quot;, version 13,
  from August 2008.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Level 1 - Basic Unicode Support
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 RL1.1   Hex Notation                     - done          [1]
 RL1.2   Properties                       - done          [2][3]
 RL1.2a  Compatibility Properties         - done          [4]
 RL1.3   Subtraction and Intersection     - MISSING       [5]
 RL1.4   Simple Word Boundaries           - done          [6]
 RL1.5   Simple Loose Matches             - done          [7]
 RL1.6   Line Boundaries                  - MISSING       [8][9]
 RL1.7   Supplementary Code Points        - done          [10]
 [1]  \x{...}
 [2]  \p{...} \P{...}
 [3]  supports not only minimal list, but all Unicode character
      properties (see Unicode Character Properties above)
 [4]  \d \D \s \S \w \W \X [:prop:] [:^prop:]
 [5]  can use regular expression look-ahead [a] or
      user-defined character properties [b] to emulate set
      operations
 [6]  \b \B
 [7]  note that Perl does Full case-folding in matching (but with
      bugs), not Simple: for example U+1F88 is equivalent to
      U+1F00 U+03B9, instead of just U+1F80.  This difference
      matters mainly for certain Greek capital letters with certain
      modifiers: the Full case-folding decomposes the letter,
      while the Simple case-folding would map it to a single
      character.
 [8]  should do ^ and $ also on U+000B (\v in C), FF (\f), CR
      (\r), CRLF (\r\n), NEL (U+0085), LS (U+2028), and PS
      (U+2029); should also affect &lt;&gt;, $., and script line
      numbers; should not split lines within CRLF [c] (i.e. there
      is no empty line between \r and \n)
 [9]  Linebreaking conformant with UAX#14 &quot;Unicode Line Breaking
      Algorithm&quot; is available through the Unicode::LineBreaking
      module.
 [10] UTF-8/UTF-EBDDIC used in Perl allows not only U+10000 to
      U+10FFFF but also beyond U+10FFFF
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    [a] You can mimic class subtraction using lookahead. For example, what
      UTS#18 might write as
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    [{Greek}-[{UNASSIGNED}]]
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    in Perl can be written as:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    (?!\p{Unassigned})\p{InGreekAndCoptic}
    (?=\p{Assigned})\p{InGreekAndCoptic}
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    But in this particular example, you probably really want
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    \p{GreekAndCoptic}
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    which will match assigned characters known to be part of the Greek script.
    <div style="height: 1.00em;">&#x00A0;</div>
    Also see the Unicode::Regex::Set module; it does implement the full UTS#18
      grouping, intersection, union, and removal (subtraction) syntax.
    <div style="height: 1.00em;">&#x00A0;</div>
    [b] '+' for union, '-' for removal (set-difference), '&amp;' for
      intersection (see &quot;User-Defined Character Properties&quot;)
    <div style="height: 1.00em;">&#x00A0;</div>
    [c] Try the &quot;:crlf&quot; layer (see PerlIO).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Level 2 - Extended Unicode Support
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 RL2.1   Canonical Equivalents           - MISSING       [10][11]
 RL2.2   Default Grapheme Clusters       - MISSING       [12]
 RL2.3   Default Word Boundaries         - MISSING       [14]
 RL2.4   Default Loose Matches           - MISSING       [15]
 RL2.5   Name Properties                 - DONE
 RL2.6   Wildcard Properties             - MISSING
 [10] see UAX#15 &quot;Unicode Normalization Forms&quot;
 [11] have Unicode::Normalize but not integrated to regexes
 [12] have \X but we don't have a &quot;Grapheme Cluster Mode&quot;
 [14] see UAX#29, Word Boundaries
 [15] This is covered in Chapter 3.13 (in Unicode 6.0)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Level 3 - Tailored Support
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 RL3.1   Tailored Punctuation            - MISSING
 RL3.2   Tailored Grapheme Clusters      - MISSING       [17][18]
 RL3.3   Tailored Word Boundaries        - MISSING
 RL3.4   Tailored Loose Matches          - MISSING
 RL3.5   Tailored Ranges                 - MISSING
 RL3.6   Context Matching                - MISSING       [19]
 RL3.7   Incremental Matches             - MISSING
      ( RL3.8   Unicode Set Sharing )
 RL3.9   Possible Match Sets             - MISSING
 RL3.10  Folded Matching                 - MISSING       [20]
 RL3.11  Submatchers                     - MISSING
 [17] see UAX#10 &quot;Unicode Collation Algorithms&quot;
 [18] have Unicode::Collate but not integrated to regexes
 [19] have (?&lt;=x) and (?=x), but look-aheads or look-behinds
      should see outside of the target substring
 [20] need insensitive matching for linguistic features other
      than case; for example, hiragana to katakana, wide and
      narrow, simplified Han to traditional Han (see UTR#30
      &quot;Character Foldings&quot;)
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="Unicode_Encodings"><a class="selflink" href="#Unicode_Encodings">Unicode
  Encodings</a></h2>
Unicode characters are assigned to <i>code points</i>, which are abstract
  numbers. To use these numbers, various encodings are needed.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">UTF-8
    <div style="height: 1.00em;">&#x00A0;</div>
    UTF-8 is a variable-length (1 to 4 bytes), byte-order independent encoding.
      For ASCII (and we really do mean 7-bit ASCII, not another 8-bit encoding),
      UTF-8 is transparent.
    <div style="height: 1.00em;">&#x00A0;</div>
    The following table is from Unicode 3.2.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 Code Points            1st Byte  2nd Byte  3rd Byte 4th Byte
   U+0000..U+007F       00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF       E0      * A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       +++++ utf16 surrogates, not legal utf8 +++++
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF      F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note the gaps marked by &quot;*&quot; before several of the byte entries
      above. These are caused by legal UTF-8 avoiding non-shortest encodings: it
      is technically possible to UTF-8-encode a single code point in different
      ways, but that is explicitly forbidden, and the shortest possible encoding
      should always be used (and that is what Perl does).
    <div style="height: 1.00em;">&#x00A0;</div>
    Another way to look at it is via bits:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
                Code Points  1st Byte  2nd Byte  3rd Byte  4th Byte
                   0aaaaaaa  0aaaaaaa
           00000bbbbbaaaaaa  110bbbbb  10aaaaaa
           ccccbbbbbbaaaaaa  1110cccc  10bbbbbb  10aaaaaa
 00000dddccccccbbbbbbaaaaaa  11110ddd  10cccccc  10bbbbbb  10aaaaaa
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    As you can see, the continuation bytes all begin with &quot;10&quot;, and
      the leading bits of the start byte tell how many bytes there are in the
      encoded character.
    <div style="height: 1.00em;">&#x00A0;</div>
    The original UTF-8 specification allowed up to 6 bytes, to allow encoding of
      numbers up to 0x7FFF_FFFF. Perl continues to allow those, and has extended
      that up to 13 bytes to encode code points up to what can fit in a 64-bit
      word. However, Perl will warn if you output any of these as being
      non-portable; and under strict UTF-8 input protocols, they are forbidden.
    <div style="height: 1.00em;">&#x00A0;</div>
    The Unicode non-character code points are also disallowed in UTF-8 in
      &quot;open interchange&quot;. See &quot;Non-character code
    points&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">UTF-EBCDIC
    <div style="height: 1.00em;">&#x00A0;</div>
    Like UTF-8 but EBCDIC-safe, in the way that UTF-8 is ASCII-safe.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">UTF-16, UTF-16BE, UTF-16LE, Surrogates, and BOMs (Byte
      Order Marks)
    <div style="height: 1.00em;">&#x00A0;</div>
    The followings items are mostly for reference and general Unicode knowledge,
      Perl doesn't use these constructs internally.
    <div style="height: 1.00em;">&#x00A0;</div>
    Like UTF-8, UTF-16 is a variable-width encoding, but where UTF-8 uses 8-bit
      code units, UTF-16 uses 16-bit code units. All code points occupy either 2
      or 4 bytes in UTF-16: code points &quot;U+0000..U+FFFF&quot; are stored in
      a single 16-bit unit, and code points &quot;U+10000..U+10FFFF&quot; in two
      16-bit units. The latter case is using <i>surrogates</i>, the first 16-bit
      unit being the <i>high</i> <i>surrogate</i>, and the second being the
      <i>low surrogate</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Surrogates are code points set aside to encode the
      &quot;U+10000..U+10FFFF&quot; range of Unicode code points in pairs of
      16-bit units. The <i>high</i> <i>surrogates</i> are the range
      &quot;U+D800..U+DBFF&quot; and the <i>low surrogates</i> are the range
      &quot;U+DC00..U+DFFF&quot;. The surrogate encoding is
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and the decoding is
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can
      be used for in-memory computations, but if storage or transfer is required
      either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be
      chosen.
    <div style="height: 1.00em;">&#x00A0;</div>
    This introduces another problem: what if you just know that your data is
      UTF-16, but you don't know which endianness? Byte Order Marks, or BOMs,
      are a solution to this. A special character has been reserved in Unicode
      to function as a byte order marker: the character with the code point
      &quot;U+FEFF&quot; is the BOM.
    <div style="height: 1.00em;">&#x00A0;</div>
    The trick is that if you read a BOM, you will know the byte order, since if
      it was written on a big-endian platform, you will read the bytes
      &quot;0xFE 0xFF&quot;, but if it was written on a little-endian platform,
      you will read the bytes &quot;0xFF 0xFE&quot;. (And if the originating
      platform was writing in UTF-8, you will read the bytes &quot;0xEF 0xBB
      0xBF&quot;.)
    <div style="height: 1.00em;">&#x00A0;</div>
    The way this trick works is that the character with the code point
      &quot;U+FFFE&quot; is not supposed to be in input streams, so the sequence
      of bytes &quot;0xFF 0xFE&quot; is unambiguously &quot;BOM, represented in
      little-endian format&quot; and cannot be &quot;U+FFFE&quot;, represented
      in big-endian format&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Surrogates have no meaning in Unicode outside their use in pairs to
      represent other code points. However, Perl allows them to be represented
      individually internally, for example by saying &quot;chr(0xD801)&quot;, so
      that all code points, not just those valid for open interchange, are
      representable. Unicode does define semantics for them, such as their
      General Category is &quot;Cs&quot;. But because their use is somewhat
      dangerous, Perl will warn (using the warning category
      &quot;surrogate&quot;, which is a sub-category of &quot;utf8&quot;) if an
      attempt is made to do things like take the lower case of one, or match
      case-insensitively, or to output them. (But don't try this on Perls before
      5.14.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">UTF-32, UTF-32BE, UTF-32LE
    <div style="height: 1.00em;">&#x00A0;</div>
    The UTF-32 family is pretty much like the UTF-16 family, expect that the
      units are 32-bit, and therefore the surrogate scheme is not needed. UTF-32
      is a fixed-width encoding. The BOM signatures are &quot;0x00 0x00 0xFE
      0xFF&quot; for BE and &quot;0xFF 0xFE 0x00 0x00&quot; for LE.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">UCS-2, UCS-4
    <div style="height: 1.00em;">&#x00A0;</div>
    Legacy, fixed-width encodings defined by the ISO 10646 standard. UCS-2 is a
      16-bit encoding. Unlike UTF-16, UCS-2 is not extensible beyond
      &quot;U+FFFF&quot;, because it does not use surrogates. UCS-4 is a 32-bit
      encoding, functionally identical to UTF-32 (the difference being that
      UCS-4 forbids neither surrogates nor code points larger than
    0x10_FFFF).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">UTF-7
    <div style="height: 1.00em;">&#x00A0;</div>
    A seven-bit safe (non-eight-bit) encoding, which is useful if the transport
      or storage is not eight-bit safe. Defined by RFC 2152.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Non-character_code_points"><a class="selflink" href="#Non-character_code_points">Non-character
  code points</a></h2>
66 code points are set aside in Unicode as &quot;non-character code
  points&quot;. These all have the Unassigned (Cn) General Category, and they
  never will be assigned. These are never supposed to be in legal Unicode input
  streams, so that code can use them as sentinels that can be mixed in with
  character data, and they always will be distinguishable from that data. To
  keep them out of Perl input streams, strict UTF-8 should be specified, such as
  by using the layer &quot;:encoding('UTF-8')&quot;. The non-character code
  points are the 32 between U+FDD0 and U+FDEF, and the 34 code points U+FFFE,
  U+FFFF, U+1FFFE, U+1FFFF, ... U+10FFFE, U+10FFFF. Some people are under the
  mistaken impression that these are &quot;illegal&quot;, but that is not true.
  An application or cooperating set of applications can legally use them at will
  internally; but these code points are &quot;illegal for open
  interchange&quot;. Therefore, Perl will not accept these from input streams
  unless lax rules are being used, and will warn (using the warning category
  &quot;nonchar&quot;, which is a sub-category of &quot;utf8&quot;) if an
  attempt is made to output them.
<h2 class="Ss" title="Ss" id="Beyond_Unicode_code_points"><a class="selflink" href="#Beyond_Unicode_code_points">Beyond
  Unicode code points</a></h2>
The maximum Unicode code point is U+10FFFF. But Perl accepts code points up to
  the maximum permissible unsigned number available on the platform. However,
  Perl will not accept these from input streams unless lax rules are being used,
  and will warn (using the warning category &quot;non_unicode&quot;, which is a
  sub-category of &quot;utf8&quot;) if an attempt is made to operate on or
  output them. For example, &quot;uc(0x11_0000)&quot; will generate this
  warning, returning the input parameter as its result, as the upper case of
  every non-Unicode code point is the code point itself.
<h2 class="Ss" title="Ss" id="Security_Implications_of_Unicode"><a class="selflink" href="#Security_Implications_of_Unicode">Security
  Implications of Unicode</a></h2>
Read Unicode Security Considerations
  &lt;http://www.unicode.org/reports/tr36&gt;. Also, note the following:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Malformed UTF-8
    <div style="height: 1.00em;">&#x00A0;</div>
    Unfortunately, the original specification of UTF-8 leaves some room for
      interpretation of how many bytes of encoded output one should generate
      from one input Unicode character. Strictly speaking, the shortest possible
      sequence of UTF-8 bytes should be generated, because otherwise there is
      potential for an input buffer overflow at the receiving end of a UTF-8
      connection. Perl always generates the shortest length UTF-8, and with
      warnings on, Perl will warn about non-shortest length UTF-8 along with
      other malformations, such as the surrogates, which are not Unicode code
      points valid for interchange.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Regular expression pattern matching may surprise you if
      you're not accustomed to Unicode. Starting in Perl 5.14, several pattern
      modifiers are available to control this, called the character set
      modifiers. Details are given in &quot;Character set modifiers&quot; in
      perlre.</dd>
</dl>
<div class="Pp"></div>
As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two
  worlds: the old world of bytes and the new world of characters, upgrading from
  bytes to characters when necessary. If your legacy code does not explicitly
  use Unicode, no automatic switch-over to characters should happen. Characters
  shouldn't get downgraded to bytes, either. It is possible to accidentally mix
  bytes and characters, however (see perluniintro), in which case &quot;\w&quot;
  in regular expressions might start behaving differently (unless the
  &quot;/a&quot; modifier is in effect). Review your code. Use warnings and the
  &quot;strict&quot; pragma.
<h2 class="Ss" title="Ss" id="Unicode_in_Perl_on_EBCDIC"><a class="selflink" href="#Unicode_in_Perl_on_EBCDIC">Unicode
  in Perl on EBCDIC</a></h2>
The way Unicode is handled on EBCDIC platforms is still experimental. On such
  platforms, references to UTF-8 encoding in this document and elsewhere should
  be read as meaning the UTF-EBCDIC specified in Unicode Technical Report 16,
  unless ASCII vs. EBCDIC issues are specifically discussed. There is no
  &quot;utfebcdic&quot; pragma or &quot;:utfebcdic&quot; layer; rather,
  &quot;utf8&quot; and &quot;:utf8&quot; are reused to mean the platform's
  &quot;natural&quot; 8-bit encoding of Unicode. See perlebcdic for more
  discussion of the issues.
<h2 class="Ss" title="Ss" id="Locales"><a class="selflink" href="#Locales">Locales</a></h2>
See &quot;Unicode and UTF-8&quot; in perllocale
<h2 class="Ss" title="Ss" id="When_Unicode_Does_Not_Happen"><a class="selflink" href="#When_Unicode_Does_Not_Happen">When
  Unicode Does Not Happen</a></h2>
While Perl does have extensive ways to input and output in Unicode, and a few
  other &quot;entry points&quot; like the @ARGV array (which can sometimes be
  interpreted as UTF-8), there are still many places where Unicode (in some
  encoding or another) could be given as arguments or received as results, or
  both, but it is not.
<div class="Pp"></div>
The following are such interfaces. Also, see &quot;The &quot;Unicode
  Bug&quot;&quot;. For all of these interfaces Perl currently (as of 5.8.3)
  simply assumes byte strings both as arguments and results, or UTF-8 strings if
  the (problematic) &quot;encoding&quot; pragma has been used.
<div class="Pp"></div>
One reason that Perl does not attempt to resolve the role of Unicode in these
  situations is that the answers are highly dependent on the operating system
  and the file system(s). For example, whether filenames can be in Unicode and
  in exactly what kind of encoding, is not exactly a portable concept. Similarly
  for &quot;qx&quot; and &quot;system&quot;: how well will the
  &quot;command-line interface&quot; (and which of them?) handle Unicode?
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">chdir, chmod, chown, chroot, exec, link, lstat, mkdir,
      rename, rmdir, stat, symlink, truncate, unlink, utime, -X</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">%ENV</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">glob (aka the &lt;*&gt;)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">open, opendir, sysopen</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">qx (aka the backtick operator), system</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">readdir, readlink</dd>
</dl>
<h2 class="Ss" title="Ss" id="The_&quot;Unicode_Bug&quot;"><a class="selflink" href="#The_&quot;Unicode_Bug&quot;">The
  &quot;Unicode Bug&quot;</a></h2>
The term, &quot;Unicode bug&quot; has been applied to an inconsistency on ASCII
  platforms with the Unicode code points in the Latin-1 Supplement block, that
  is, between 128 and 255. Without a locale specified, unlike all other
  characters or code points, these characters have very different semantics in
  byte semantics versus character semantics, unless &quot;use feature
  'unicode_strings'&quot; is specified, directly or indirectly. (It is
  indirectly specified by a &quot;use v5.12&quot; or higher.)
<div class="Pp"></div>
In character semantics these upper-Latin1 characters are interpreted as Unicode
  code points, which means they have the same semantics as Latin-1 (ISO-8859-1).
<div class="Pp"></div>
In byte semantics (without &quot;unicode_strings&quot;), they are considered to
  be unassigned characters, meaning that the only semantics they have is their
  ordinal numbers, and that they are not members of various character classes.
  None are considered to match &quot;\w&quot; for example, but all match
  &quot;\W&quot;.
<div class="Pp"></div>
Perl 5.12.0 added &quot;unicode_strings&quot; to force character semantics on
  these code points in some circumstances, which fixed portions of the bug; Perl
  5.14.0 fixed almost all of it; and Perl 5.16.0 fixed the remainder (so far as
  we know, anyway). The lesson here is to enable &quot;unicode_strings&quot; to
  avoid the headaches described below.
<div class="Pp"></div>
The old, problematic behavior affects these areas:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Changing the case of a scalar, that is, using
      &quot;uc()&quot;, &quot;ucfirst()&quot;, &quot;lc()&quot;, and
      &quot;lcfirst()&quot;, or &quot;\L&quot;, &quot;\U&quot;, &quot;\u&quot;
      and &quot;\l&quot; in double-quotish contexts, such as regular expression
      substitutions. Under &quot;unicode_strings&quot; starting in Perl 5.12.0,
      character semantics are generally used. See &quot;lc&quot; in perlfunc for
      details on how this works in combination with various other pragmas.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Using caseless (&quot;/i&quot;) regular expression
      matching. Starting in Perl 5.14.0, regular expressions compiled within the
      scope of &quot;unicode_strings&quot; use character semantics even when
      executed or compiled into larger regular expressions outside the
    scope.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Matching any of several properties in regular expressions,
      namely &quot;\b&quot;, &quot;\B&quot;, &quot;\s&quot;, &quot;\S&quot;,
      &quot;\w&quot;, &quot;\W&quot;, and all the Posix character classes
      <i>except</i> &quot;[[:ascii:]]&quot;. Starting in Perl 5.14.0, regular
      expressions compiled within the scope of &quot;unicode_strings&quot; use
      character semantics even when executed or compiled into larger regular
      expressions outside the scope.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">In &quot;quotemeta&quot; or its inline equivalent
      &quot;\Q&quot;, no code points above 127 are quoted in UTF-8 encoded
      strings, but in byte encoded strings, code points between 128-255 are
      always quoted. Starting in Perl 5.16.0, consistent quoting rules are used
      within the scope of &quot;unicode_strings&quot;, as described in
      &quot;quotemeta&quot; in perlfunc.</dd>
</dl>
<div class="Pp"></div>
This behavior can lead to unexpected results in which a string's semantics
  suddenly change if a code point above 255 is appended to or removed from it,
  which changes the string's semantics from byte to character or vice versa. As
  an example, consider the following program and its output:
<div class="Pp"></div>
<pre>
 $ perl -le'
     no feature 'unicode_strings';
     $s1 = &quot;\xC2&quot;;
     $s2 = &quot;\x{2660}&quot;;
     for ($s1, $s2, $s1.$s2) {
         print /\w/ || 0;
     }
 '
 0
 0
 1
</pre>
<div class="Pp"></div>
If there's no &quot;\w&quot; in &quot;s1&quot; or in &quot;s2&quot;, why does
  their concatenation have one?
<div class="Pp"></div>
This anomaly stems from Perl's attempt to not disturb older programs that didn't
  use Unicode, and hence had no semantics for characters outside of the ASCII
  range (except in a locale), along with Perl's desire to add Unicode support
  seamlessly. The result wasn't seamless: these characters were orphaned.
<div class="Pp"></div>
For Perls earlier than those described above, or when a string is passed to a
  function outside the subpragma's scope, a workaround is to always call
  &quot;utf8::upgrade($string)&quot;, or to use the standard module Encode.
  Also, a scalar that has any characters whose ordinal is above 0x100, or which
  were specified using either of the &quot;\N{...}&quot; notations, will
  automatically have character semantics.
<h2 class="Ss" title="Ss" id="Forcing_Unicode_in_Perl_(Or_Unforcing_Unicode_in_Perl)"><a class="selflink" href="#Forcing_Unicode_in_Perl_(Or_Unforcing_Unicode_in_Perl)">Forcing
  Unicode in Perl (Or Unforcing Unicode in Perl)</a></h2>
Sometimes (see &quot;When Unicode Does Not Happen&quot; or &quot;The
  &quot;Unicode Bug&quot;&quot;) there are situations where you simply need to
  force a byte string into UTF-8, or vice versa. The low-level calls
  utf8::upgrade($bytestring) and utf8::downgrade($utf8string[, FAIL_OK]) are the
  answers.
<div class="Pp"></div>
Note that <i>utf8::downgrade()</i> can fail if the string contains characters
  that don't fit into a byte.
<div class="Pp"></div>
Calling either function on a string that already is in the desired state is a
  no-op.
<h2 class="Ss" title="Ss" id="Using_Unicode_in_XS"><a class="selflink" href="#Using_Unicode_in_XS">Using
  Unicode in XS</a></h2>
If you want to handle Perl Unicode in XS extensions, you may find the following
  C APIs useful. See also &quot;Unicode Support&quot; in perlguts for an
  explanation about Unicode at the XS level, and perlapi for the API details.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;DO_UTF8(sv)&quot; returns true if the
      &quot;UTF8&quot; flag is on and the bytes pragma is not in effect.
      &quot;SvUTF8(sv)&quot; returns true if the &quot;UTF8&quot; flag is on;
      the bytes pragma is ignored. The &quot;UTF8&quot; flag being on does
      <b>not</b> mean that there are any characters of code points greater than
      255 (or 127) in the scalar or that there are even any characters in the
      scalar. What the &quot;UTF8&quot; flag means is that the sequence of
      octets in the representation of the scalar is the sequence of UTF-8
      encoded code points of the characters of a string. The &quot;UTF8&quot;
      flag being off means that each octet in this representation encodes a
      single character with code point 0..255 within the string. Perl's Unicode
      model is not to use UTF-8 until it is absolutely necessary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;uvchr_to_utf8(buf, chr)&quot; writes a Unicode
      character code point into a buffer encoding the code point as UTF-8, and
      returns a pointer pointing after the UTF-8 bytes. It works appropriately
      on EBCDIC machines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;utf8_to_uvchr_buf(buf, bufend, lenp)&quot; reads
      UTF-8 encoded bytes from a buffer and returns the Unicode character code
      point and, optionally, the length of the UTF-8 byte sequence. It works
      appropriately on EBCDIC machines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;utf8_length(start, end)&quot; returns the length of
      the UTF-8 encoded buffer in characters. &quot;sv_len_utf8(sv)&quot;
      returns the length of the UTF-8 encoded scalar.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;sv_utf8_upgrade(sv)&quot; converts the string of the
      scalar to its UTF-8 encoded form. &quot;sv_utf8_downgrade(sv)&quot; does
      the opposite, if possible. &quot;sv_utf8_encode(sv)&quot; is like
      sv_utf8_upgrade except that it does not set the &quot;UTF8&quot; flag.
      &quot;sv_utf8_decode()&quot; does the opposite of
      &quot;sv_utf8_encode()&quot;. Note that none of these are to be used as
      general-purpose encoding or decoding interfaces: &quot;use Encode&quot;
      for that. &quot;sv_utf8_upgrade()&quot; is affected by the encoding pragma
      but &quot;sv_utf8_downgrade()&quot; is not (since the encoding pragma is
      designed to be a one-way street).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;is_utf8_string(buf, len)&quot; returns true if
      &quot;len&quot; bytes of the buffer are valid UTF-8.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">is_utf8_char(s) returns true if the pointer points to a
      valid UTF-8 character. However, this function should not be used because
      of security concerns. Instead, use &quot;is_utf8_string()&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;UTF8SKIP(buf)&quot; will return the number of bytes
      in the UTF-8 encoded character in the buffer. &quot;UNISKIP(chr)&quot;
      will return the number of bytes required to UTF-8-encode the Unicode
      character code point. &quot;UTF8SKIP()&quot; is useful for example for
      iterating over the characters of a UTF-8 encoded buffer;
      &quot;UNISKIP()&quot; is useful, for example, in computing the size
      required for a UTF-8 encoded buffer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;utf8_distance(a, b)&quot; will tell the distance in
      characters between the two pointers pointing to the same UTF-8 encoded
      buffer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;utf8_hop(s, off)&quot; will return a pointer to a
      UTF-8 encoded buffer that is &quot;off&quot; (positive or negative)
      Unicode characters displaced from the UTF-8 buffer &quot;s&quot;. Be
      careful not to overstep the buffer: &quot;utf8_hop()&quot; will merrily
      run off the end or the beginning of the buffer if told to do so.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;pv_uni_display(dsv, spv, len, pvlim, flags)&quot; and
      &quot;sv_uni_display(dsv, ssv, pvlim, flags)&quot; are useful for
      debugging the output of Unicode strings and scalars. By default they are
      useful only for debugging--they display <b>all</b> characters as
      hexadecimal code points--but with the flags
      &quot;UNI_DISPLAY_ISPRINT&quot;, &quot;UNI_DISPLAY_BACKSLASH&quot;, and
      &quot;UNI_DISPLAY_QQ&quot; you can make the output more readable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2)&quot;
      can be used to compare two strings case-insensitively in Unicode. For
      case-sensitive comparisons you can just use &quot;memEQ()&quot; and
      &quot;memNE()&quot; as usual, except if one string is in utf8 and the
      other isn't.</dd>
</dl>
<div class="Pp"></div>
For more information, see perlapi, and <i>utf8.c</i> and <i>utf8.h</i> in the
  Perl source code distribution.
<h2 class="Ss" title="Ss" id="Hacking_Perl_to_work_on_earlier_Unicode_versions_(for_very_serious_hackers_only)"><a class="selflink" href="#Hacking_Perl_to_work_on_earlier_Unicode_versions_(for_very_serious_hackers_only)">Hacking
  Perl to work on earlier Unicode versions (for very serious hackers
  only)</a></h2>
Perl by default comes with the latest supported Unicode version built in, but
  you can change to use any earlier one.
<div class="Pp"></div>
Download the files in the desired version of Unicode from the Unicode web site
  &lt;http://www.unicode.org&gt;). These should replace the existing files in
  <i>lib/unicore</i> in the Perl source tree. Follow the instructions in
  <i>README.perl</i> in that directory to change some of their names, and then
  build perl (see INSTALL).
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
<h2 class="Ss" title="Ss" id="Interaction_with_Locales"><a class="selflink" href="#Interaction_with_Locales">Interaction
  with Locales</a></h2>
See &quot;Unicode and UTF-8&quot; in perllocale
<h2 class="Ss" title="Ss" id="Problems_with_characters_in_the_Latin-1_Supplement_range"><a class="selflink" href="#Problems_with_characters_in_the_Latin-1_Supplement_range">Problems
  with characters in the Latin-1 Supplement range</a></h2>
See &quot;The &quot;Unicode Bug&quot;&quot;
<h2 class="Ss" title="Ss" id="Interaction_with_Extensions"><a class="selflink" href="#Interaction_with_Extensions">Interaction
  with Extensions</a></h2>
When Perl exchanges data with an extension, the extension should be able to
  understand the UTF8 flag and act accordingly. If the extension doesn't
  recognize that flag, it's likely that the extension will return
  incorrectly-flagged data.
<div class="Pp"></div>
So if you're working with Unicode data, consult the documentation of every
  module you're using if there are any issues with Unicode data exchange. If the
  documentation does not talk about Unicode at all, suspect the worst and
  probably look at the source to learn how the module is implemented. Modules
  written completely in Perl shouldn't cause problems. Modules that directly or
  indirectly access code written in other programming languages are at risk.
<div class="Pp"></div>
For affected functions, the simple strategy to avoid data corruption is to
  always make the encoding of the exchanged data explicit. Choose an encoding
  that you know the extension can handle. Convert arguments passed to the
  extensions to that encoding and convert results back from that encoding. Write
  wrapper functions that do the conversions for you, so you can later change the
  functions when the extension catches up.
<div class="Pp"></div>
To provide an example, let's say the popular Foo::Bar::escape_html function
  doesn't deal with Unicode data yet. The wrapper function would convert the
  argument to raw UTF-8 and convert the result back to Perl's internal
  representation like so:
<div class="Pp"></div>
<pre>
    sub my_escape_html ($) {
        my($what) = shift;
        return unless defined $what;
        Encode::decode_utf8(Foo::Bar::escape_html(
                                         Encode::encode_utf8($what)));
    }
</pre>
<div class="Pp"></div>
Sometimes, when the extension does not convert data but just stores and
  retrieves them, you will be able to use the otherwise dangerous
  <i>Encode::_utf8_on()</i> function. Let's say the popular &quot;Foo::Bar&quot;
  extension, written in C, provides a &quot;param&quot; method that lets you
  store and retrieve data according to these prototypes:
<div class="Pp"></div>
<pre>
    $self-&gt;param($name, $value);            # set a scalar
    $value = $self-&gt;param($name);           # retrieve a scalar
</pre>
<div class="Pp"></div>
If it does not yet provide support for any encoding, one could write a derived
  class with such a &quot;param&quot; method:
<div class="Pp"></div>
<pre>
    sub param {
      my($self,$name,$value) = @_;
      utf8::upgrade($name);     # make sure it is UTF-8 encoded
      if (defined $value) {
        utf8::upgrade($value);  # make sure it is UTF-8 encoded
        return $self-&gt;SUPER::param($name,$value);
      } else {
        my $ret = $self-&gt;SUPER::param($name);
        Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
        return $ret;
      }
    }
</pre>
<div class="Pp"></div>
Some extensions provide filters on data entry/exit points, such as
  DB_File::filter_store_key and family. Look out for such filters in the
  documentation of your extensions, they can make the transition to Unicode data
  much easier.
<h2 class="Ss" title="Ss" id="Speed"><a class="selflink" href="#Speed">Speed</a></h2>
Some functions are slower when working on UTF-8 encoded strings than on byte
  encoded strings. All functions that need to hop over characters such as
  <i>length()</i>, <i>substr()</i> or <i>index()</i>, or matching regular
  expressions can work <b>much</b> faster when the underlying data are
  byte-encoded.
<div class="Pp"></div>
In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1 a caching
  scheme was introduced which will hopefully make the slowness somewhat less
  spectacular, at least for some operations. In general, operations with UTF-8
  encoded strings are still slower. As an example, the Unicode properties
  (character classes) like &quot;\p{Nd}&quot; are known to be quite a bit slower
  (5-20 times) than their simpler counterparts like &quot;\d&quot; (then again,
  there are hundreds of Unicode characters matching &quot;Nd&quot; compared with
  the 10 ASCII characters matching &quot;d&quot;).
<h2 class="Ss" title="Ss" id="Problems_on_EBCDIC_platforms"><a class="selflink" href="#Problems_on_EBCDIC_platforms">Problems
  on EBCDIC platforms</a></h2>
There are several known problems with Perl on EBCDIC platforms. If you want to
  use Perl there, send email to perlbug@perl.org.
<div class="Pp"></div>
In earlier versions, when byte and character data were concatenated, the new
  string was sometimes created by decoding the byte strings as <i>ISO 8859-1
  (Latin-1)</i>, even if the old Unicode string used EBCDIC.
<div class="Pp"></div>
If you find any of these, please report them as bugs.
<h2 class="Ss" title="Ss" id="Porting_code_from_perl-5.6.X"><a class="selflink" href="#Porting_code_from_perl-5.6.X">Porting
  code from perl-5.6.X</a></h2>
Perl 5.8 has a different Unicode model from 5.6. In 5.6 the programmer was
  required to use the &quot;utf8&quot; pragma to declare that a given scope
  expected to deal with Unicode data and had to make sure that only Unicode data
  were reaching that scope. If you have code that is working with 5.6, you will
  need some of the following adjustments to your code. The examples are written
  such that the code will continue to work under 5.6, so you should be safe to
  try them out.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A filehandle that should read or write UTF-8
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  if ($] &gt; 5.007) {
    binmode $fh, &quot;:encoding(utf8)&quot;;
  }
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A scalar that is going to be passed to some extension
    <div style="height: 1.00em;">&#x00A0;</div>
    Be it Compress::Zlib, Apache::Request or any extension that has no mention
      of Unicode in the manpage, you need to make sure that the UTF8 flag is
      stripped off. Note that at the time of this writing (October 2002) the
      mentioned modules are not UTF-8-aware. Please check the documentation to
      verify if this is still true.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  if ($] &gt; 5.007) {
    require Encode;
    $val = Encode::encode_utf8($val); # make octets
  }
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A scalar we got back from an extension
    <div style="height: 1.00em;">&#x00A0;</div>
    If you believe the scalar comes back as UTF-8, you will most likely want the
      UTF8 flag restored:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  if ($] &gt; 5.007) {
    require Encode;
    $val = Encode::decode_utf8($val);
  }
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Same thing, if you are really sure it is UTF-8
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  if ($] &gt; 5.007) {
    require Encode;
    Encode::_utf8_on($val);
  }
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A wrapper for fetchrow_array and fetchrow_hashref
    <div style="height: 1.00em;">&#x00A0;</div>
    When the database contains only UTF-8, a wrapper function or method is a
      convenient way to replace all your fetchrow_array and fetchrow_hashref
      calls. A wrapper function will also make it easier to adapt to future
      enhancements in your database driver. Note that at the time of this
      writing (October 2002), the DBI has no standardized way to deal with UTF-8
      data. Please check the documentation to verify if that is still true.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  sub fetchrow {
    # $what is one of fetchrow_{array,hashref}
    my($self, $sth, $what) = @_;
    if ($] &lt; 5.007) {
      return $sth-&gt;$what;
    } else {
      require Encode;
      if (wantarray) {
        my @arr = $sth-&gt;$what;
        for (@arr) {
          defined &amp;&amp; /[^\000-\177]/ &amp;&amp; Encode::_utf8_on($_);
        }
        return @arr;
      } else {
        my $ret = $sth-&gt;$what;
        if (ref $ret) {
          for my $k (keys %$ret) {
            defined
            &amp;&amp; /[^\000-\177]/
            &amp;&amp; Encode::_utf8_on($_) for $ret-&gt;{$k};
          }
          return $ret;
        } else {
          defined &amp;&amp; /[^\000-\177]/ &amp;&amp; Encode::_utf8_on($_) for $ret;
          return $ret;
        }
      }
    }
  }
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A large scalar that you know can only contain ASCII
    <div style="height: 1.00em;">&#x00A0;</div>
    Scalars that contain only ASCII and are marked as UTF-8 are sometimes a drag
      to your program. If you recognize such a situation, just remove the UTF8
      flag:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  utf8::downgrade($val) if $] &gt; 5.007;
    </pre>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlunitut, perluniintro, perluniprops, Encode, open, utf8, bytes, perlretut,
  &quot;${^UNICODE}&quot; in perlvar
  &lt;http://www.unicode.org/reports/tr44&gt;).</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
