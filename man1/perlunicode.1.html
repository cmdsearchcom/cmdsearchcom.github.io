<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:12 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLUNICODE(1) Perl Programmers Reference Guide
PERLUNICODE(1)</p>

<p style="margin-top: 1em">NAME <br>
perlunicode - Unicode support in Perl</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Important Caveats <br>
Unicode support is an extensive requirement. While Perl does
not implement the Unicode standard or the accompanying
technical reports from cover to cover, Perl does support
many <br>
Unicode features.</p>

<p style="margin-top: 1em">People who want to learn to use
Unicode in Perl, should probably read the Perl Unicode
tutorial, perlunitut and perluniintro, before reading this
reference document.</p>

<p style="margin-top: 1em">Also, the use of Unicode may
present security issues that aren&rsquo;t obvious. Read
Unicode Security Considerations
&lt;http://www.unicode.org/reports/tr36&gt;.</p>

<p style="margin-top: 1em">Safest if you &quot;use feature
&rsquo;unicode_strings&rsquo;&quot; <br>
In order to preserve backward compatibility, Perl does not
turn on full internal Unicode support unless the pragma
&quot;use feature &rsquo;unicode_strings&rsquo;&quot; is
specified. (This is <br>
automatically selected if you use &quot;use 5.012&quot; or
higher.) Failure to do this can trigger unexpected
surprises. See &quot;The &quot;Unicode Bug&quot;&quot;
below.</p>

<p style="margin-top: 1em">This pragma doesn&rsquo;t affect
I/O, and there are still several places where Unicode
isn&rsquo;t fully supported, such as in filenames.</p>

<p style="margin-top: 1em">Input and Output Layers <br>
Perl knows when a filehandle uses Perl&rsquo;s internal
Unicode encodings (UTF-8, or UTF-EBCDIC if in EBCDIC) if the
filehandle is opened with the &quot;:encoding(utf8)&quot;
layer. Other <br>
encodings can be converted to Perl&rsquo;s encoding on input
or from Perl&rsquo;s encoding on output by use of the
&quot;:encoding(...)&quot; layer. See open.</p>

<p style="margin-top: 1em">To indicate that Perl source
itself is in UTF-8, use &quot;use utf8;&quot;.</p>

<p style="margin-top: 1em">&quot;use utf8&quot; still
needed to enable UTF-8/UTF-EBCDIC in scripts <br>
As a compatibility measure, the &quot;use utf8&quot; pragma
must be explicitly included to enable recognition of UTF-8
in the Perl scripts themselves (in string or regular
expression <br>
literals, or in identifier names) on ASCII-based machines or
to recognize UTF-EBCDIC on EBCDIC-based machines. These are
the only times when an explicit &quot;use utf8&quot; is <br>
needed. See utf8.</p>

<p style="margin-top: 1em">BOM-marked scripts and UTF-16
scripts autodetected <br>
If a Perl script begins marked with the Unicode BOM
(UTF-16LE, UTF16-BE, or UTF-8), or if the script looks like
non-BOM-marked UTF-16 of either endianness, Perl will <br>
correctly read in the script as Unicode. (BOMless UTF-8
cannot be effectively recognized or differentiated from ISO
8859-1 or other eight-bit encodings.)</p>

<p style="margin-top: 1em">&quot;use encoding&quot; needed
to upgrade non-Latin-1 byte strings <br>
By default, there is a fundamental asymmetry in Perl&rsquo;s
Unicode model: implicit upgrading from byte strings to
Unicode strings assumes that they were encoded in ISO 8859-1
<br>
(Latin-1), but Unicode strings are downgraded with UTF-8
encoding. This happens because the first 256 codepoints in
Unicode happens to agree with Latin-1.</p>

<p style="margin-top: 1em">See &quot;Byte and Character
Semantics&quot; for more details.</p>

<p style="margin-top: 1em">Byte and Character Semantics
<br>
Beginning with version 5.6, Perl uses logically-wide
characters to represent strings internally.</p>

<p style="margin-top: 1em">Starting in Perl 5.14,
Perl-level operations work with characters rather than bytes
within the scope of a &quot;use feature
&rsquo;unicode_strings&rsquo;&quot; (or equivalently
&quot;use 5.012&quot; or higher). <br>
(This is not true if bytes have been explicitly requested by
&quot;use bytes&quot;, nor necessarily true for interactions
with the platform&rsquo;s operating system.)</p>

<p style="margin-top: 1em">For earlier Perls, and when
&quot;unicode_strings&quot; is not in effect, Perl provides
a fairly safe environment that can handle both types of
semantics in programs. For operations where <br>
Perl can unambiguously decide that the input data are
characters, Perl switches to character semantics. For
operations where this determination cannot be made without
additional <br>
information from the user, Perl decides in favor of
compatibility and chooses to use byte semantics.</p>

<p style="margin-top: 1em">When &quot;use locale&quot; (but
not &quot;use locale &rsquo;:not_characters&rsquo;&quot;) is
in effect, Perl uses the semantics associated with the
current locale. (&quot;use locale&quot; overrides &quot;use
feature <br>
&rsquo;unicode_strings&rsquo;&quot; in the same scope; while
&quot;use locale &rsquo;:not_characters&rsquo;&quot;
effectively also selects &quot;use feature
&rsquo;unicode_strings&rsquo;&quot; in its scope; see
perllocale.) Otherwise, <br>
Perl uses the platform&rsquo;s native byte semantics for
characters whose code points are less than 256, and Unicode
semantics for those greater than 255. On EBCDIC platforms,
this is <br>
almost seamless, as the EBCDIC code pages that Perl handles
are equivalent to Unicode&rsquo;s first 256 code points.
(The exception is that EBCDIC regular expression
case-insensitive <br>
matching rules are not as as robust as Unicode&rsquo;s.) But
on ASCII platforms, Perl uses US-ASCII (or Basic Latin in
Unicode terminology) byte semantics, meaning that characters
<br>
whose ordinal numbers are in the range 128 - 255 are
undefined except for their ordinal numbers. This means that
none have case (upper and lower), nor are any a member of
<br>
character classes, like &quot;[:alpha:]&quot; or
&quot;696W&quot; class or the Perl regular expression
extension &quot;[:^alpha:]&quot;.)</p>

<p style="margin-top: 1em">This behavior preserves
compatibility with earlier versions of Perl, which allowed
byte semantics in Perl operations only if none of the
program&rsquo;s inputs were marked as being a <br>
source of Unicode character data. Such data may come from
filehandles, from calls to external programs, from
information provided by the system (such as %ENV), or from
literals <br>
and constants in the source text.</p>

<p style="margin-top: 1em">The &quot;utf8&quot; pragma is
primarily a compatibility device that enables recognition of
UTF-(8|EBCDIC) in literals encountered by the parser. Note
that this pragma is only required <br>
while Perl defaults to byte semantics; when character
semantics become the default, this pragma may become a
no-op. See utf8.</p>

<p style="margin-top: 1em">If strings operating under byte
semantics and strings with Unicode character data are
concatenated, the new string will have character semantics.
This can cause surprises: See <br>
&quot;BUGS&quot;, below. You can choose to be warned when
this happens. See encoding::warnings.</p>

<p style="margin-top: 1em">Under character semantics, many
operations that formerly operated on bytes now operate on
characters. A character in Perl is logically just a number
ranging from 0 to 2**31 or <br>
so. Larger characters may encode into longer sequences of
bytes internally, but this internal detail is mostly hidden
for Perl code. See perluniintro for more.</p>

<p style="margin-top: 1em">Effects of Character Semantics
<br>
Character semantics have the following effects:</p>

<p style="margin-top: 1em">&Acirc;&middot;
Strings--including hash keys--and regular expression
patterns may contain characters that have an ordinal value
larger than 255.</p>

<p style="margin-top: 1em">If you use a Unicode editor to
edit your program, Unicode characters may occur directly
within the literal strings in UTF-8 encoding, or UTF-16.
(The former requires a BOM <br>
or &quot;use utf8&quot;, the latter requires a BOM.)</p>

<p style="margin-top: 1em">Unicode characters can also be
added to a string by using the &quot;+...}&quot; notation.
The Unicode code for the desired character, in hexadecimal,
should be placed in the <br>
braces, after the &quot;U&quot;. For instance, a smiley face
is &quot;+263A}&quot;.</p>

<p style="margin-top: 1em">Alternatively, you can use the
&quot;.}&quot; notation for characters 0x100 and above. For
characters below 0x100 you may get byte semantics instead of
character semantics; see <br>
&quot;The &quot;Unicode Bug&quot;&quot;. On EBCDIC machines
there is the additional problem that the value for such
characters gives the EBCDIC character rather than the
Unicode one, thus it is <br>
more portable to use &quot;+...}&quot; instead.</p>

<p style="margin-top: 1em">Additionally, you can use the
&quot; notation and put the official Unicode
character name within the braces, such as &quot;HITE SMILING
FACE}&quot;. This automatically loads <br>
the charnames module with the &quot;:full&quot; and
&quot;:short&quot; options. If you prefer different options
for this module, you can instead, before the
&quot; explicitly load it with <br>
your desired options; for example,</p>

<p style="margin-top: 1em">use charnames
&rsquo;:loose&rsquo;;</p>

<p style="margin-top: 1em">&Acirc;&middot; If an
appropriate encoding is specified, identifiers within the
Perl script may contain Unicode alphanumeric characters,
including ideographs. Perl does not currently <br>
attempt to canonicalize variable names.</p>

<p style="margin-top: 1em">&Acirc;&middot; Regular
expressions match characters instead of bytes. &quot;.&quot;
matches a character instead of a byte.</p>

<p style="margin-top: 1em">&Acirc;&middot; Bracketed
character classes in regular expressions match characters
instead of bytes and match against the character properties
specified in the Unicode properties database. <br>
&quot;1368</p>

<p style="margin-top: 1em">&Acirc;&middot; Named Unicode
properties, scripts, and block ranges may be used (like
bracketed character classes) by using the &quot;{}&quot;
&quot;matches property&quot; construct and the
&quot;P{}&quot; negation, <br>
&quot;doesn&rsquo;t match property&quot;. See &quot;Unicode
Character Properties&quot; for more details.</p>

<p style="margin-top: 1em">You can define your own
character properties and use them in the regular expression
with the &quot;{}&quot; or &quot;P{}&quot; construct. See
&quot;User-Defined Character Properties&quot; for more <br>
details.</p>

<p style="margin-top: 1em">&Acirc;&middot; The special
pattern &quot;extended grapheme cluster&quot; in
Standardese. In Unicode what appears to the user to be a
single character, for <br>
example an accented &quot;G&quot;, may in fact be composed
of a sequence of characters, in this case a &quot;G&quot;
followed by an accent character. &quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; The
&quot;tr///&quot; operator translates characters instead of
bytes. Note that the &quot;tr///CU&quot; functionality has
been removed. For similar functionality see
pack(&rsquo;U0&rsquo;, ...) and <br>
pack(&rsquo;C0&rsquo;, ...).</p>

<p style="margin-top: 1em">&Acirc;&middot; Case translation
operators use the Unicode case translation tables when
character input is provided. Note that &quot;uc()&quot;, or
&quot;U&quot; in interpolated strings, translates to <br>
uppercase, while &quot;ucfirst&quot;, or &quot;&quot; in
interpolated strings, translates to titlecase in languages
that make the distinction (which is equivalent to uppercase
in languages <br>
without the distinction).</p>

<p style="margin-top: 1em">&Acirc;&middot; Most operators
that deal with positions or lengths in a string will
automatically switch to using character positions, including
&quot;chop()&quot;, &quot;chomp()&quot;,
&quot;substr()&quot;, &quot;pos()&quot;, <br>
&quot;index()&quot;, &quot;rindex()&quot;,
&quot;sprintf()&quot;, &quot;write()&quot;, and
&quot;length()&quot;. An operator that specifically does not
switch is &quot;vec()&quot;. Operators that really
don&rsquo;t care include operators <br>
that treat strings as a bucket of bits such as
&quot;sort()&quot;, and operators dealing with
filenames.</p>

<p style="margin-top: 1em">&Acirc;&middot; The
&quot;pack()&quot;/&quot;unpack()&quot; letter &quot;C&quot;
does not change, since it is often used for byte-oriented
formats. Again, think &quot;char&quot; in the C
language.</p>

<p style="margin-top: 1em">There is a new &quot;U&quot;
specifier that converts between Unicode characters and code
points. There is also a &quot;W&quot; specifier that is the
equivalent of &quot;chr&quot;/&quot;ord&quot; and properly
<br>
handles character values even if they are above 255.</p>

<p style="margin-top: 1em">&Acirc;&middot; The
&quot;chr()&quot; and &quot;ord()&quot; functions work on
characters, similar to &quot;pack(&quot;W&quot;)&quot; and
&quot;unpack(&quot;W&quot;)&quot;, not
&quot;pack(&quot;C&quot;)&quot; and
&quot;unpack(&quot;C&quot;)&quot;.
&quot;pack(&quot;C&quot;)&quot; and
&quot;unpack(&quot;C&quot;)&quot; are methods <br>
for emulating byte-oriented &quot;chr()&quot; and
&quot;ord()&quot; on Unicode strings. While these methods
reveal the internal encoding of Unicode strings, that is not
something one normally <br>
needs to care about at all.</p>

<p style="margin-top: 1em">&Acirc;&middot; The bit string
operators, &quot;&amp; | ^ ~&quot;, can operate on character
data. However, for backward compatibility, such as when
using bit string operations when characters are all <br>
less than 256 in ordinal value, one should not use
&quot;~&quot; (the bit complement) with characters of both
values less than 256 and values greater than 256. Most
importantly, <br>
DeMorgan&rsquo;s laws (&quot;~($x|$y) eq ~$x&amp;~$y&quot;
and &quot;~($x&amp;$y) eq ~$x|~$y&quot;) will not hold. The
reason for this mathematical faux pas is that the complement
cannot return both the <br>
8-bit (byte-wide) bit complement and the full character-wide
bit complement.</p>

<p style="margin-top: 1em">&Acirc;&middot; There is a CPAN
module, Unicode::Casing, which allows you to define your own
mappings to be used in &quot;lc()&quot;,
&quot;lcfirst()&quot;, &quot;uc()&quot;,
&quot;ucfirst()&quot;, and &quot;fc&quot; (or their
double-quoted <br>
string inlined versions such as &quot;U&quot;). (Prior to
Perl 5.16, this functionality was partially provided in the
Perl core, but suffered from a number of insurmountable <br>
drawbacks, so the CPAN module was written instead.)</p>

<p style="margin-top: 1em">&Acirc;&middot; And finally,
&quot;scalar reverse()&quot; reverses by character rather
than by byte.</p>

<p style="margin-top: 1em">Unicode Character Properties
<br>
(The only time that Perl considers a sequence of individual
code points as a single logical character is in the
&quot;character&quot; <br>
in this discussion means a single Unicode code point.)</p>

<p style="margin-top: 1em">Very nearly all Unicode
character properties are accessible through regular
expressions by using the &quot;{}&quot; &quot;matches
property&quot; construct and the &quot;P{}&quot;
&quot;doesn&rsquo;t match property&quot; <br>
for its negation.</p>

<p style="margin-top: 1em">For instance,
&quot;{Uppercase}&quot; matches any single character with
the Unicode &quot;Uppercase&quot; property, while
&quot;{L}&quot; matches any character with a
General_Category of &quot;L&quot; (letter) <br>
property. Brackets are not required for single letter
property names, so &quot;{L}&quot; is equivalent to
&quot;L&quot;.</p>

<p style="margin-top: 1em">More formally,
&quot;{Uppercase}&quot; matches any single character whose
Unicode Uppercase property value is True, and
&quot;P{Uppercase}&quot; matches any character whose
Uppercase property <br>
value is False, and they could have been written as
&quot;{Uppercase=True}&quot; and
&quot;{Uppercase=False}&quot;, respectively.</p>

<p style="margin-top: 1em">This formality is needed when
properties are not binary; that is, if they can take on more
values than just True and False. For example, the Bidi_Class
(see &quot;Bidirectional <br>
Character Types&quot; below), can take on several different
values, such as Left, Right, Whitespace, and others. To
match these, one needs to specify both the property name
<br>
(Bidi_Class), AND the value being matched against (Left,
Right, etc.). This is done, as in the examples above, by
having the two components separated by an equal sign (or
<br>
interchangeably, a colon), like &quot;{Bidi_Class:
Left}&quot;.</p>

<p style="margin-top: 1em">All Unicode-defined character
properties may be written in these compound forms of
&quot;{property=value}&quot; or
&quot;{property:value}&quot;, but Perl provides some
additional properties that <br>
are written only in the single form, as well as single-form
short-cuts for all binary properties and certain others
described below, in which you may omit the property name and
<br>
the equals or colon separator.</p>

<p style="margin-top: 1em">Most Unicode character
properties have at least two synonyms (or aliases if you
prefer): a short one that is easier to type and a longer one
that is more descriptive and hence <br>
easier to understand. Thus the &quot;L&quot; and
&quot;Letter&quot; properties above are equivalent and can
be used interchangeably. Likewise, &quot;Upper&quot; is a
synonym for &quot;Uppercase&quot;, and we could <br>
have written &quot;{Uppercase}&quot; equivalently as
&quot;{Upper}&quot;. Also, there are typically various
synonyms for the values the property can be. For binary
properties, &quot;True&quot; has 3 <br>
synonyms: &quot;T&quot;, &quot;Yes&quot;, and &quot;Y&quot;;
and &quot;False has correspondingly &quot;F&quot;,
&quot;No&quot;, and &quot;N&quot;. But be careful. A short
form of a value for one property may not mean the same thing
as the <br>
same short form for another. Thus, for the General_Category
property, &quot;L&quot; means &quot;Letter&quot;, but for
the Bidi_Class property, &quot;L&quot; means
&quot;Left&quot;. A complete list of properties and <br>
synonyms is in perluniprops.</p>

<p style="margin-top: 1em">Upper/lower case differences in
property names and values are irrelevant; thus
&quot;{Upper}&quot; means the same thing as
&quot;{upper}&quot; or even &quot;{UpPeR}&quot;. Similarly,
you can add or <br>
subtract underscores anywhere in the middle of a word, so
that these are also equivalent to &quot;{U_p_p_e_r}&quot;.
And white space is irrelevant adjacent to non-word
characters, such <br>
as the braces and the equals or colon separators, so &quot;{
Upper }&quot; and &quot;{ Upper_case : Y }&quot; are
equivalent to these as well. In fact, white space and even
hyphens can <br>
usually be added or deleted anywhere. So even &quot;{ Up-per
case = Yes}&quot; is equivalent. All this is called
&quot;loose-matching&quot; by Unicode. The few places where
stricter matching is <br>
used is in the middle of numbers, and in the Perl extension
properties that begin or end with an underscore. Stricter
matching cares about white space (except adjacent to non-
<br>
word characters), hyphens, and non-interior underscores.</p>

<p style="margin-top: 1em">You can also use negation in
both &quot;{}&quot; and &quot;P{}&quot; by introducing a
caret (^) between the first brace and the property name:
&quot;{^Tamil}&quot; is equal to &quot;P{Tamil}&quot;.</p>

<p style="margin-top: 1em">Almost all properties are immune
to case-insensitive matching. That is, adding a
&quot;/i&quot; regular expression modifier does not change
what they match. There are two sets that are <br>
affected. The first set is &quot;Uppercase_Letter&quot;,
&quot;Lowercase_Letter&quot;, and
&quot;Titlecase_Letter&quot;, all of which match
&quot;Cased_Letter&quot; under &quot;/i&quot; matching. And
the second set is <br>
&quot;Uppercase&quot;, &quot;Lowercase&quot;, and
&quot;Titlecase&quot;, all of which match &quot;Cased&quot;
under &quot;/i&quot; matching. This set also includes its
subsets &quot;PosixUpper&quot; and &quot;PosixLower&quot;
both of which under <br>
&quot;/i&quot; matching match &quot;PosixAlpha&quot;. (The
difference between these sets is that some things, such as
Roman numerals, come in both upper and lower case so they
are &quot;Cased&quot;, but <br>
aren&rsquo;t considered letters, so they aren&rsquo;t
&quot;Cased_Letter&quot;s.)</p>

<p style="margin-top: 1em">The result is undefined if you
try to match a non-Unicode code point (that is, one above
0x10FFFF) against a Unicode property. Currently, a warning
is raised, and the match will <br>
fail. In some cases, this is counterintuitive, as both these
fail:</p>

<p style="margin-top: 1em">chr(0x110000) =~
{ASCII_Hex_Digit=True} # Fails. <br>
chr(0x110000) =~ {ASCII_Hex_Digit=False} # Fails!</p>

<p style="margin-top: 1em">General_Category</p>

<p style="margin-top: 1em">Every Unicode character is
assigned a general category, which is the &quot;most usual
categorization of a character&quot; (from
&lt;http://www.unicode.org/reports/tr44&gt;).</p>

<p style="margin-top: 1em">The compound way of writing
these is like &quot;{General_Category=Number}&quot; (short,
&quot;{gc:n}&quot;). But Perl furnishes shortcuts in which
everything up through the equal or colon <br>
separator is omitted. So you can instead just write
&quot;N&quot;.</p>

<p style="margin-top: 1em">Here are the short and long
forms of the General Category properties:</p>

<p style="margin-top: 1em">Short Long</p>

<p style="margin-top: 1em">L Letter <br>
LC, L&amp; Cased_Letter (that is: [{Ll}{Lu}{Lt}]) <br>
Lu Uppercase_Letter <br>
Ll Lowercase_Letter <br>
Lt Titlecase_Letter <br>
Lm Modifier_Letter <br>
Lo Other_Letter</p>

<p style="margin-top: 1em">M Mark <br>
Mn Nonspacing_Mark <br>
Mc Spacing_Mark <br>
Me Enclosing_Mark</p>

<p style="margin-top: 1em">N Number <br>
Nd Decimal_Number (also Digit) <br>
Nl Letter_Number <br>
No Other_Number</p>

<p style="margin-top: 1em">P Punctuation (also Punct) <br>
Pc Connector_Punctuation <br>
Pd Dash_Punctuation <br>
Ps Open_Punctuation <br>
Pe Close_Punctuation <br>
Pi Initial_Punctuation <br>
(may behave like Ps or Pe depending on usage) <br>
Pf Final_Punctuation <br>
(may behave like Ps or Pe depending on usage) <br>
Po Other_Punctuation</p>

<p style="margin-top: 1em">S Symbol <br>
Sm Math_Symbol <br>
Sc Currency_Symbol <br>
Sk Modifier_Symbol <br>
So Other_Symbol</p>

<p style="margin-top: 1em">Z Separator <br>
Zs Space_Separator <br>
Zl Line_Separator <br>
Zp Paragraph_Separator</p>

<p style="margin-top: 1em">C Other <br>
Cc Control (also Cntrl) <br>
Cf Format <br>
Cs Surrogate <br>
Co Private_Use <br>
Cn Unassigned</p>

<p style="margin-top: 1em">Single-letter properties match
all characters in any of the two-letter sub-properties
starting with the same letter. &quot;LC&quot; and
&quot;L&amp;&quot; are special: both are aliases for the set
<br>
consisting of everything matched by &quot;Ll&quot;,
&quot;Lu&quot;, and &quot;Lt&quot;.</p>

<p style="margin-top: 1em">Bidirectional Character
Types</p>

<p style="margin-top: 1em">Because scripts differ in their
directionality (Hebrew and Arabic are written right to left,
for example) Unicode supplies these properties in the
Bidi_Class class:</p>

<p style="margin-top: 1em">Property Meaning</p>

<p style="margin-top: 1em">L Left-to-Right <br>
LRE Left-to-Right Embedding <br>
LRO Left-to-Right Override <br>
R Right-to-Left <br>
AL Arabic Letter <br>
RLE Right-to-Left Embedding <br>
RLO Right-to-Left Override <br>
PDF Pop Directional Format <br>
EN European Number <br>
ES European Separator <br>
ET European Terminator <br>
AN Arabic Number <br>
CS Common Separator <br>
NSM Non-Spacing Mark <br>
BN Boundary Neutral <br>
B Paragraph Separator <br>
S Segment Separator <br>
WS Whitespace <br>
ON Other Neutrals</p>

<p style="margin-top: 1em">This property is always written
in the compound form. For example,
&quot;{Bidi_Class:R}&quot; matches characters that are
normally written right to left.</p>

<p style="margin-top: 1em">Scripts</p>

<p style="margin-top: 1em">The world&rsquo;s languages are
written in many different scripts. This sentence (unless
you&rsquo;re reading it in translation) is written in Latin,
while Russian is written in Cyrillic, <br>
and Greek is written in, well, Greek; Japanese mainly in
Hiragana or Katakana. There are many more.</p>

<p style="margin-top: 1em">The Unicode Script and
Script_Extensions properties give what script a given
character is in. Either property can be specified with the
compound form like &quot;{Script=Hebrew}&quot; <br>
(short: &quot;{sc=hebr}&quot;), or
&quot;{Script_Extensions=Javanese}&quot; (short:
&quot;{scx=java}&quot;). In addition, Perl furnishes
shortcuts for all &quot;Script&quot; property names. You can
omit <br>
everything up through the equals (or colon), and simply
write &quot;{Latin}&quot; or &quot;P{Cyrillic}&quot;. (This
is not true for &quot;Script_Extensions&quot;, which is
required to be written in the <br>
compound form.)</p>

<p style="margin-top: 1em">The difference between these two
properties involves characters that are used in multiple
scripts. For example the digits &rsquo;0&rsquo; through
&rsquo;9&rsquo; are used in many parts of the world. <br>
These are placed in a script named &quot;Common&quot;. Other
characters are used in just a few scripts. For example, the
&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot; is used in both
Japanese <br>
scripts, Katakana and Hiragana, but nowhere else. The
&quot;Script&quot; property places all characters that are
used in multiple scripts in the &quot;Common&quot; script,
while the <br>
&quot;Script_Extensions&quot; property places those that are
used in only a few scripts into each of those scripts; while
still using &quot;Common&quot; for those used in many
scripts. Thus both <br>
these match:</p>

<p style="margin-top: 1em">&quot;0&quot; =~ /{sc=Common}/ #
Matches <br>
&quot;0&quot; =~ /{scx=Common}/ # Matches</p>

<p style="margin-top: 1em">and only the first of these
match:</p>

<p style="margin-top: 1em">&quot;ATAKANA-HIRAGANA DOUBLE
HYPHEN}&quot; =~ /{sc=Common} # Matches <br>
&quot;ATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /{scx=Common}
# No match</p>

<p style="margin-top: 1em">And only the last two of these
match:</p>

<p style="margin-top: 1em">&quot;ATAKANA-HIRAGANA DOUBLE
HYPHEN}&quot; =~ /{sc=Hiragana} # No match <br>
&quot;ATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~
/{sc=Katakana} # No match <br>
&quot;ATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~
/{scx=Hiragana} # Matches <br>
&quot;ATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~
/{scx=Katakana} # Matches</p>

<p style="margin-top: 1em">&quot;Script_Extensions&quot; is
thus an improved &quot;Script&quot;, in which there are
fewer characters in the &quot;Common&quot; script, and
correspondingly more in other scripts. It is new in Unicode
<br>
version 6.0, and its data are likely to change significantly
in later releases, as things get sorted out.</p>

<p style="margin-top: 1em">(Actually, besides
&quot;Common&quot;, the &quot;Inherited&quot; script,
contains characters that are used in multiple scripts. These
are modifier characters which modify other characters, and
<br>
inherit the script value of the controlling character. Some
of these are used in many scripts, and so go into
&quot;Inherited&quot; in both &quot;Script&quot; and
&quot;Script_Extensions&quot;. Others are <br>
used in just a few scripts, so are in &quot;Inherited&quot;
in &quot;Script&quot;, but not in
&quot;Script_Extensions&quot;.)</p>

<p style="margin-top: 1em">It is worth stressing that there
are several different sets of digits in Unicode that are
equivalent to 0-9 and are matchable by &quot;&quot; in a
regular expression. If they are used <br>
in a single language only, they are in that language&rsquo;s
&quot;Script&quot; and &quot;Script_Extension&quot;. If they
are used in more than one script, they will be in
&quot;sc=Common&quot;, but only if they <br>
are used in many scripts should they be in
&quot;scx=Common&quot;.</p>

<p style="margin-top: 1em">A complete list of scripts and
their shortcuts is in perluniprops.</p>

<p style="margin-top: 1em">Use of &quot;Is&quot; Prefix</p>

<p style="margin-top: 1em">For backward compatibility (with
Perl 5.6), all properties mentioned so far may have
&quot;Is&quot; or &quot;Is_&quot; prepended to their name,
so &quot;P{Is_Lu}&quot;, for example, is equal to
&quot;P{Lu}&quot;, and <br>
&quot;{IsScript:Arabic}&quot; is equal to
&quot;{Arabic}&quot;.</p>

<p style="margin-top: 1em">Blocks</p>

<p style="margin-top: 1em">In addition to scripts, Unicode
also defines blocks of characters. The difference between
scripts and blocks is that the concept of scripts is closer
to natural languages, while <br>
the concept of blocks is more of an artificial grouping
based on groups of Unicode characters with consecutive
ordinal values. For example, the &quot;Basic Latin&quot;
block is all <br>
characters whose ordinals are between 0 and 127, inclusive;
in other words, the ASCII characters. The &quot;Latin&quot;
script contains some letters from this as well as several
other <br>
blocks, like &quot;Latin-1 Supplement&quot;, &quot;Latin
Extended-A&quot;, etc., but it does not contain all the
characters from those blocks. It does not, for example,
contain the digits 0-9, <br>
because those digits are shared across many scripts, and
hence are in the &quot;Common&quot; script.</p>

<p style="margin-top: 1em">For more about scripts versus
blocks, see UAX#24 &quot;Unicode Script Property&quot;:
&lt;http://www.unicode.org/reports/tr24&gt;</p>

<p style="margin-top: 1em">The &quot;Script&quot; or
&quot;Script_Extensions&quot; properties are likely to be
the ones you want to use when processing natural language;
the Block property may occasionally be useful in <br>
working with the nuts and bolts of Unicode.</p>

<p style="margin-top: 1em">Block names are matched in the
compound form, like &quot;{Block: Arrows}&quot; or
&quot;{Blk=Hebrew}&quot;. Unlike most other properties, only
a few block names have a Unicode-defined short <br>
name. But Perl does provide a (slight) shortcut: You can
say, for example &quot;{In_Arrows}&quot; or
&quot;{In_Hebrew}&quot;. For backwards compatibility, the
&quot;In&quot; prefix may be omitted if <br>
there is no naming conflict with a script or any other
property, and you can even use an &quot;Is&quot; prefix
instead in those cases. But it is not a good idea to do
this, for a couple <br>
reasons:</p>

<p style="margin-top: 1em">1. It is confusing. There are
many naming conflicts, and you may forget some. For example,
&quot;{Hebrew}&quot; means the script Hebrew, and NOT the
block Hebrew. But would you <br>
remember that 6 months from now?</p>

<p style="margin-top: 1em">2. It is unstable. A new version
of Unicode may pre-empt the current meaning by creating a
property with the same name. There was a time in very early
Unicode releases when <br>
&quot;{Hebrew}&quot; would have matched the block Hebrew;
now it doesn&rsquo;t.</p>

<p style="margin-top: 1em">Some people prefer to always use
&quot;{Block: foo}&quot; and &quot;{Script: bar}&quot;
instead of the shortcuts, whether for clarity, because they
can&rsquo;t remember the difference between &rsquo;In&rsquo;
and <br>
&rsquo;Is&rsquo; anyway, or they aren&rsquo;t confident that
those who eventually will read their code will know that
difference.</p>

<p style="margin-top: 1em">A complete list of blocks and
their shortcuts is in perluniprops.</p>

<p style="margin-top: 1em">Other Properties</p>

<p style="margin-top: 1em">There are many more properties
than the very basic ones described here. A complete list is
in perluniprops.</p>

<p style="margin-top: 1em">Unicode defines all its
properties in the compound form, so all single-form
properties are Perl extensions. Most of these are just
synonyms for the Unicode ones, but some are <br>
genuine extensions, including several that are in the
compound form. And quite a few of these are actually
recommended by Unicode (in
&lt;http://www.unicode.org/reports/tr18&gt;).</p>

<p style="margin-top: 1em">This section gives some details
on all extensions that aren&rsquo;t just synonyms for
compound-form Unicode properties (for those properties,
you&rsquo;ll have to refer to the Unicode <br>
Standard &lt;http://www.unicode.org/reports/tr44&gt;.</p>

<p style="margin-top: 1em">&quot;{All}&quot; <br>
This matches any of the 1_114_112 Unicode code points. It is
a synonym for &quot;{Any}&quot;.</p>

<p style="margin-top: 1em">&quot;{Alnum}&quot; <br>
This matches any &quot;{Alphabetic}&quot; or
&quot;{Decimal_Number}&quot; character.</p>

<p style="margin-top: 1em">&quot;{Any}&quot; <br>
This matches any of the 1_114_112 Unicode code points. It is
a synonym for &quot;{All}&quot;.</p>

<p style="margin-top: 1em">&quot;{ASCII}&quot; <br>
This matches any of the 128 characters in the US-ASCII
character set, which is a subset of Unicode.</p>

<p style="margin-top: 1em">&quot;{Assigned}&quot; <br>
This matches any assigned code point; that is, any code
point whose general category is not Unassigned (or
equivalently, not Cn).</p>

<p style="margin-top: 1em">&quot;{Blank}&quot; <br>
This is the same as &quot;nd &quot;{HorizSpace}&quot;: A
character that changes the spacing horizontally.</p>

<p style="margin-top: 1em">&quot;{Decomposition_Type:
Non_Canonical}&quot; (Short: &quot;{Dt=NonCanon}&quot;) <br>
Matches a character that has a non-canonical
decomposition.</p>

<p style="margin-top: 1em">To understand the use of this
rarely used property=value combination, it is necessary to
know some basics about decomposition. Consider a character,
say H. It could appear <br>
with various marks around it, such as an acute accent, or a
circumflex, or various hooks, circles, arrows, etc., above,
below, to one side or the other, etc. There are many <br>
possibilities among the world&rsquo;s languages. The number
of combinations is astronomical, and if there were a
character for each combination, it would soon exhaust
Unicode&rsquo;s <br>
more than a million possible characters. So Unicode took a
different approach: there is a character for the base H, and
a character for each of the possible marks, and these <br>
can be variously combined to get a final logical character.
So a logical character--what appears to be a single
character--can be a sequence of more than one individual
<br>
characters. This is called an &quot;extended grapheme
cluster&quot;; Perl furnishes the &quot;</p>

<p style="margin-top: 1em">But Unicode&rsquo;s intent is to
unify the existing character set standards and practices,
and several pre-existing standards have single characters
that mean the same thing as <br>
some of these combinations. An example is ISO-8859-1, which
has quite a few of these in the Latin-1 range, an example
being &quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;. Because
<br>
this character was in this pre-existing standard, Unicode
added it to its repertoire. But this character is considered
by Unicode to be equivalent to the sequence consisting <br>
of the character &quot;LATIN CAPITAL LETTER E&quot; followed
by the character &quot;COMBINING ACUTE ACCENT&quot;.</p>

<p style="margin-top: 1em">&quot;LATIN CAPITAL LETTER E
WITH ACUTE&quot; is called a &quot;pre-composed&quot;
character, and its equivalence with the sequence is called
canonical equivalence. All pre-composed characters <br>
are said to have a decomposition (into the equivalent
sequence), and the decomposition type is also called
canonical.</p>

<p style="margin-top: 1em">However, many more characters
have a different type of decomposition, a
&quot;compatible&quot; or &quot;non-canonical&quot;
decomposition. The sequences that form these decompositions
are not <br>
considered canonically equivalent to the pre-composed
character. An example, again in the Latin-1 range, is the
&quot;SUPERSCRIPT ONE&quot;. It is somewhat like a regular
digit 1, <br>
but not exactly; its decomposition into the digit 1 is
called a &quot;compatible&quot; decomposition, specifically
a &quot;super&quot; decomposition. There are several such
compatibility <br>
decompositions (see
&lt;http://www.unicode.org/reports/tr44&gt;), including one
called &quot;compat&quot;, which means some miscellaneous
type of decomposition that doesn&rsquo;t fit into the <br>
decomposition categories that Unicode has chosen.</p>

<p style="margin-top: 1em">Note that most Unicode
characters don&rsquo;t have a decomposition, so their
decomposition type is &quot;None&quot;.</p>

<p style="margin-top: 1em">For your convenience, Perl has
added the &quot;Non_Canonical&quot; decomposition type to
mean any of the several compatibility decompositions.</p>

<p style="margin-top: 1em">&quot;{Graph}&quot; <br>
Matches any character that is graphic. Theoretically, this
means a character that on a printer would cause ink to be
used.</p>

<p style="margin-top: 1em">&quot;{HorizSpace}&quot; <br>
This is the same as &quot;nd &quot;{Blank}&quot;: a
character that changes the spacing horizontally.</p>

<p style="margin-top: 1em">&quot;{In=*}&quot; <br>
This is a synonym for &quot;{Present_In=*}&quot;</p>

<p style="margin-top: 1em">&quot;{PerlSpace}&quot; <br>
This is the same as &quot; restricted to ASCII, namely
&quot;[ r]&quot;.</p>

<p style="margin-top: 1em">Mnemonic: Perl&rsquo;s
(original) space</p>

<p style="margin-top: 1em">&quot;{PerlWord}&quot; <br>
This is the same as &quot;720[A-Za-z0-9_]&quot;</p>

<p style="margin-top: 1em">Mnemonic: Perl&rsquo;s
(original) word.</p>

<p style="margin-top: 1em">&quot;{Posix...}&quot; <br>
There are several of these, which are equivalents using the
&quot;&quot; notation for Posix classes and are described in
&quot;POSIX Character Classes&quot; in perlrecharclass.</p>

<p style="margin-top: 1em">&quot;{Present_In: *}&quot;
(Short: &quot;{In=*}&quot;) <br>
This property is used when you need to know in what Unicode
version(s) a character is.</p>

<p style="margin-top: 1em">The &quot;*&quot; above stands
for some two digit Unicode version number, such as 1.1 or
4.0; or the &quot;*&quot; can also be
&quot;Unassigned&quot;. This property will match the code
points whose final <br>
disposition has been settled as of the Unicode release given
by the version number; &quot;{Present_In: Unassigned}&quot;
will match those code points whose meaning has yet to be
<br>
assigned.</p>

<p style="margin-top: 1em">For example, &quot;U+0041&quot;
&quot;LATIN CAPITAL LETTER A&quot; was present in the very
first Unicode release available, which is 1.1, so this
property is true for all valid &quot;*&quot; versions. On
<br>
the other hand, &quot;U+1EFF&quot; was not assigned until
version 5.1 when it became &quot;LATIN SMALL LETTER Y WITH
LOOP&quot;, so the only &quot;*&quot; that would match it
are 5.1, 5.2, and later.</p>

<p style="margin-top: 1em">Unicode furnishes the
&quot;Age&quot; property from which this is derived. The
problem with Age is that a strict interpretation of it
(which Perl takes) has it matching the precise <br>
release a code point&rsquo;s meaning is introduced in. Thus
&quot;U+0041&quot; would match only 1.1; and
&quot;U+1EFF&quot; only 5.1. This is not usually what you
want.</p>

<p style="margin-top: 1em">Some non-Perl implementations of
the Age property may change its meaning to be the same as
the Perl Present_In property; just be aware of that.</p>

<p style="margin-top: 1em">Another confusion with both
these properties is that the definition is not that the code
point has been assigned, but that the meaning of the code
point has been determined. <br>
This is because 66 code points will always be unassigned,
and so the Age for them is the Unicode version in which the
decision to make them so was made. For example, <br>
&quot;U+FDD0&quot; is to be permanently unassigned to a
character, and the decision to do that was made in version
3.1, so &quot;{Age=3.1}&quot; matches this character, as
also does <br>
&quot;{Present_In: 3.1}&quot; and up.</p>

<p style="margin-top: 1em">&quot;{Print}&quot; <br>
This matches any character that is graphical or blank,
except controls.</p>

<p style="margin-top: 1em">&quot;{SpacePerl}&quot; <br>
This is the same as &quot; including beyond ASCII.</p>

<p style="margin-top: 1em">Mnemonic: Space, as modified by
Perl. (It doesn&rsquo;t include the vertical tab which both
the Posix standard and Unicode consider white space.)</p>

<p style="margin-top: 1em">&quot;{Title}&quot; and
&quot;{Titlecase}&quot; <br>
Under case-sensitive matching, these both match the same
code points as &quot;{General
Category=Titlecase_Letter}&quot; (&quot;{gc=lt}&quot;). The
difference is that under &quot;/i&quot; caseless <br>
matching, these match the same as &quot;{Cased}&quot;,
whereas &quot;{gc=lt}&quot; matches
&quot;{Cased_Letter&quot;).</p>

<p style="margin-top: 1em">&quot;{VertSpace}&quot; <br>
This is the same as &quot; A character that changes the
spacing vertically.</p>

<p style="margin-top: 1em">&quot;{Word}&quot; <br>
This is the same as &quot;1176</p>

<p style="margin-top: 1em">&quot;{XPosix...}&quot; <br>
There are several of these, which are the standard Posix
classes extended to the full Unicode range. They are
described in &quot;POSIX Character Classes&quot; in
perlrecharclass.</p>

<p style="margin-top: 1em">User-Defined Character
Properties <br>
You can define your own binary character properties by
defining subroutines whose names begin with &quot;In&quot;
or &quot;Is&quot;. The subroutines can be defined in any
package. The user-defined <br>
properties can be used in the regular expression
&quot;&quot; and &quot;P&quot; constructs; if you are using
a user-defined property from a package other than the one
you are in, you must specify <br>
its package in the &quot;&quot; or &quot;P&quot;
construct.</p>

<p style="margin-top: 1em"># assuming property Is_Foreign
defined in Lang:: <br>
package main; # property package name required <br>
if ($txt =~ /{Lang::IsForeign}+/) { ... }</p>

<p style="margin-top: 1em">package Lang; # property package
name not required <br>
if ($txt =~ /{IsForeign}+/) { ... }</p>

<p style="margin-top: 1em">Note that the effect is
compile-time and immutable once defined. However, the
subroutines are passed a single parameter, which is 0 if
case-sensitive matching is in effect and <br>
non-zero if caseless matching is in effect. The subroutine
may return different values depending on the value of the
flag, and one set of values will immutably be in effect for
<br>
all case-sensitive matches, and the other set for all
case-insensitive matches.</p>

<p style="margin-top: 1em">Note that if the regular
expression is tainted, then Perl will die rather than
calling the subroutine, where the name of the subroutine is
determined by the tainted data.</p>

<p style="margin-top: 1em">The subroutines must return a
specially-formatted string, with one or more
newline-separated lines. Each line must be one of the
following:</p>

<p style="margin-top: 1em">&Acirc;&middot; A single
hexadecimal number denoting a Unicode code point to
include.</p>

<p style="margin-top: 1em">&Acirc;&middot; Two hexadecimal
numbers separated by horizontal whitespace (space or tabular
characters) denoting a range of Unicode code points to
include.</p>

<p style="margin-top: 1em">&Acirc;&middot; Something to
include, prefixed by &quot;+&quot;: a built-in character
property (prefixed by &quot;utf8::&quot;) or a fully
qualified (including package name) user-defined character
property, to <br>
represent all the characters in that property; two
hexadecimal code points for a range; or a single hexadecimal
code point.</p>

<p style="margin-top: 1em">&Acirc;&middot; Something to
exclude, prefixed by &quot;-&quot;: an existing character
property (prefixed by &quot;utf8::&quot;) or a fully
qualified (including package name) user-defined character
property, to <br>
represent all the characters in that property; two
hexadecimal code points for a range; or a single hexadecimal
code point.</p>

<p style="margin-top: 1em">&Acirc;&middot; Something to
negate, prefixed &quot;!&quot;: an existing character
property (prefixed by &quot;utf8::&quot;) or a fully
qualified (including package name) user-defined character
property, to <br>
represent all the characters in that property; two
hexadecimal code points for a range; or a single hexadecimal
code point.</p>

<p style="margin-top: 1em">&Acirc;&middot; Something to
intersect with, prefixed by &quot;&amp;&quot;: an existing
character property (prefixed by &quot;utf8::&quot;) or a
fully qualified (including package name) user-defined
character <br>
property, for all the characters except the characters in
the property; two hexadecimal code points for a range; or a
single hexadecimal code point.</p>

<p style="margin-top: 1em">For example, to define a
property that covers both the Japanese syllabaries (hiragana
and katakana), you can define</p>

<p style="margin-top: 1em">sub InKana { <br>
return &lt;&lt;END; <br>
3040309F <br>
30A030FF <br>
END <br>
}</p>

<p style="margin-top: 1em">Imagine that the here-doc end
marker is at the beginning of the line. Now you can use
&quot;{InKana}&quot; and &quot;P{InKana}&quot;.</p>

<p style="margin-top: 1em">You could also have used the
existing block property names:</p>

<p style="margin-top: 1em">sub InKana { <br>
return &lt;&lt;&rsquo;END&rsquo;; <br>
+utf8::InHiragana <br>
+utf8::InKatakana <br>
END <br>
}</p>

<p style="margin-top: 1em">Suppose you wanted to match only
the allocated characters, not the raw block ranges: in other
words, you want to remove the non-characters:</p>

<p style="margin-top: 1em">sub InKana { <br>
return &lt;&lt;&rsquo;END&rsquo;; <br>
+utf8::InHiragana <br>
+utf8::InKatakana <br>
-utf8::IsCn <br>
END <br>
}</p>

<p style="margin-top: 1em">The negation is useful for
defining (surprise!) negated classes.</p>

<p style="margin-top: 1em">sub InNotKana { <br>
return &lt;&lt;&rsquo;END&rsquo;; <br>
!utf8::InHiragana <br>
-utf8::InKatakana <br>
+utf8::IsCn <br>
END <br>
}</p>

<p style="margin-top: 1em">This will match all non-Unicode
code points, since every one of them is not in Kana. You can
use intersection to exclude these, if desired, as this
modified example shows:</p>

<p style="margin-top: 1em">sub InNotKana { <br>
return &lt;&lt;&rsquo;END&rsquo;; <br>
!utf8::InHiragana <br>
-utf8::InKatakana <br>
+utf8::IsCn <br>
&amp;utf8::Any <br>
END <br>
}</p>

<p style="margin-top: 1em">&amp;utf8::Any must be the last
line in the definition.</p>

<p style="margin-top: 1em">Intersection is used generally
for getting the common characters matched by two (or more)
classes. It&rsquo;s important to remember not to use
&quot;&amp;&quot; for the first set; that would be <br>
intersecting with nothing, resulting in an empty set.</p>

<p style="margin-top: 1em">(Note that official Unicode
properties differ from these in that they automatically
exclude non-Unicode code points and a warning is raised if a
match is attempted on one of <br>
those.)</p>

<p style="margin-top: 1em">User-Defined Case Mappings (for
serious hackers only) <br>
This feature has been removed as of Perl 5.16. The CPAN
module Unicode::Casing provides better functionality without
the drawbacks that this feature had. If you are using a <br>
Perl earlier than 5.16, this feature was most fully
documented in the 5.14 version of this pod: <br>

http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29
&lt;http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-
<br>
Mappings-%28for-serious-hackers-only%29&gt;</p>

<p style="margin-top: 1em">Character Encodings for Input
and Output <br>
See Encode.</p>

<p style="margin-top: 1em">Unicode Regular Expression
Support Level <br>
The following list of Unicode supported features for regular
expressions describes all features currently directly
supported by core Perl. The references to &quot;Level
N&quot; and the <br>
section numbers refer to the Unicode Technical Standard #18,
&quot;Unicode Regular Expressions&quot;, version 13, from
August 2008.</p>

<p style="margin-top: 1em">&Acirc;&middot; Level 1 - Basic
Unicode Support</p>

<p style="margin-top: 1em">RL1.1 Hex Notation - done [1]
<br>
RL1.2 Properties - done [2][3] <br>
RL1.2a Compatibility Properties - done [4] <br>
RL1.3 Subtraction and Intersection - MISSING [5] <br>
RL1.4 Simple Word Boundaries - done [6] <br>
RL1.5 Simple Loose Matches - done [7] <br>
RL1.6 Line Boundaries - MISSING [8][9] <br>
RL1.7 Supplementary Code Points - done [10]</p>

<p style="margin-top: 1em">[1] .} <br>
[2] {...} P{...} <br>
[3] supports not only minimal list, but all Unicode
character <br>
properties (see Unicode Character Properties above) <br>
[4] [5] can use regular expression look-ahead [a] or <br>
user-defined character properties [b] to emulate set <br>
operations <br>
[6] 0 [7] note that Perl does Full case-folding in matching
(but with <br>
bugs), not Simple: for example U+1F88 is equivalent to <br>
U+1F00 U+03B9, instead of just U+1F80. This difference <br>
matters mainly for certain Greek capital letters with
certain <br>
modifiers: the Full case-folding decomposes the letter, <br>
while the Simple case-folding would map it to a single <br>
character. <br>
[8] should do ^ and $ also on U+000B (in C), FF (, CR 0, NEL
(U+0085), LS (U+2028), and PS ), CRLF ( <br>
( <br>
(U+2029); should also affect &lt;&gt;, $., and script line
<br>
numbers; should not split lines within CRLF [c] (i.e. there
and 0 <br>
is no empty line between <br>
[9] Linebreaking conformant with UAX#14 &quot;Unicode Line
Breaking <br>
Algorithm&quot; is available through the
Unicode::LineBreaking <br>
module. <br>
[10] UTF-8/UTF-EBDDIC used in Perl allows not only U+10000
to <br>
U+10FFFF but also beyond U+10FFFF</p>

<p style="margin-top: 1em">[a] You can mimic class
subtraction using lookahead. For example, what UTS#18 might
write as</p>

<p style="margin-top: 1em">[{Greek}-[{UNASSIGNED}]]</p>

<p style="margin-top: 1em">in Perl can be written as:</p>


<p style="margin-top: 1em">(?!{Unassigned}){InGreekAndCoptic}
<br>
(?={Assigned}){InGreekAndCoptic}</p>

<p style="margin-top: 1em">But in this particular example,
you probably really want</p>

<p style="margin-top: 1em">{GreekAndCoptic}</p>

<p style="margin-top: 1em">which will match assigned
characters known to be part of the Greek script.</p>

<p style="margin-top: 1em">Also see the Unicode::Regex::Set
module; it does implement the full UTS#18 grouping,
intersection, union, and removal (subtraction) syntax.</p>

<p style="margin-top: 1em">[b] &rsquo;+&rsquo; for union,
&rsquo;-&rsquo; for removal (set-difference),
&rsquo;&amp;&rsquo; for intersection (see &quot;User-Defined
Character Properties&quot;)</p>

<p style="margin-top: 1em">[c] Try the &quot;:crlf&quot;
layer (see PerlIO).</p>

<p style="margin-top: 1em">&Acirc;&middot; Level 2 -
Extended Unicode Support</p>

<p style="margin-top: 1em">RL2.1 Canonical Equivalents -
MISSING [10][11] <br>
RL2.2 Default Grapheme Clusters - MISSING [12] <br>
RL2.3 Default Word Boundaries - MISSING [14] <br>
RL2.4 Default Loose Matches - MISSING [15] <br>
RL2.5 Name Properties - DONE <br>
RL2.6 Wildcard Properties - MISSING</p>

<p style="margin-top: 1em">[10] see UAX#15 &quot;Unicode
Normalization Forms&quot; <br>
[11] have Unicode::Normalize but not integrated to regexes
<br>
[12] have we don&rsquo;t have a &quot;Grapheme Cluster
Mode&quot; <br>
[14] see UAX#29, Word Boundaries <br>
[15] This is covered in Chapter 3.13 (in Unicode 6.0)</p>

<p style="margin-top: 1em">&Acirc;&middot; Level 3 -
Tailored Support</p>

<p style="margin-top: 1em">RL3.1 Tailored Punctuation -
MISSING <br>
RL3.2 Tailored Grapheme Clusters - MISSING [17][18] <br>
RL3.3 Tailored Word Boundaries - MISSING <br>
RL3.4 Tailored Loose Matches - MISSING <br>
RL3.5 Tailored Ranges - MISSING <br>
RL3.6 Context Matching - MISSING [19] <br>
RL3.7 Incremental Matches - MISSING <br>
( RL3.8 Unicode Set Sharing ) <br>
RL3.9 Possible Match Sets - MISSING <br>
RL3.10 Folded Matching - MISSING [20] <br>
RL3.11 Submatchers - MISSING</p>

<p style="margin-top: 1em">[17] see UAX#10 &quot;Unicode
Collation Algorithms&quot; <br>
[18] have Unicode::Collate but not integrated to regexes
<br>
[19] have (?&lt;=x) and (?=x), but look-aheads or
look-behinds <br>
should see outside of the target substring <br>
[20] need insensitive matching for linguistic features other
<br>
than case; for example, hiragana to katakana, wide and <br>
narrow, simplified Han to traditional Han (see UTR#30 <br>
&quot;Character Foldings&quot;)</p>

<p style="margin-top: 1em">Unicode Encodings <br>
Unicode characters are assigned to code points, which are
abstract numbers. To use these numbers, various encodings
are needed.</p>

<p style="margin-top: 1em">&Acirc;&middot; UTF-8</p>

<p style="margin-top: 1em">UTF-8 is a variable-length (1 to
4 bytes), byte-order independent encoding. For ASCII (and we
really do mean 7-bit ASCII, not another 8-bit encoding),
UTF-8 is transparent.</p>

<p style="margin-top: 1em">The following table is from
Unicode 3.2.</p>

<p style="margin-top: 1em">Code Points 1st Byte 2nd Byte
3rd Byte 4th Byte</p>

<p style="margin-top: 1em">U+0000..U+007F 00..7F <br>
U+0080..U+07FF * C2..DF 80..BF <br>
U+0800..U+0FFF E0 * A0..BF 80..BF <br>
U+1000..U+CFFF E1..EC 80..BF 80..BF <br>
U+D000..U+D7FF ED 80..9F 80..BF <br>
U+D800..U+DFFF +++++ utf16 surrogates, not legal utf8 +++++
<br>
U+E000..U+FFFF EE..EF 80..BF 80..BF <br>
U+10000..U+3FFFF F0 * 90..BF 80..BF 80..BF <br>
U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF <br>
U+100000..U+10FFFF F4 80..8F 80..BF 80..BF</p>

<p style="margin-top: 1em">Note the gaps marked by
&quot;*&quot; before several of the byte entries above.
These are caused by legal UTF-8 avoiding non-shortest
encodings: it is technically possible to <br>
UTF-8-encode a single code point in different ways, but that
is explicitly forbidden, and the shortest possible encoding
should always be used (and that is what Perl does).</p>

<p style="margin-top: 1em">Another way to look at it is via
bits:</p>

<p style="margin-top: 1em">Code Points 1st Byte 2nd Byte
3rd Byte 4th Byte</p>

<p style="margin-top: 1em">0aaaaaaa 0aaaaaaa <br>
00000bbbbbaaaaaa 110bbbbb 10aaaaaa <br>
ccccbbbbbbaaaaaa 1110cccc 10bbbbbb 10aaaaaa <br>
00000dddccccccbbbbbbaaaaaa 11110ddd 10cccccc 10bbbbbb
10aaaaaa</p>

<p style="margin-top: 1em">As you can see, the continuation
bytes all begin with &quot;10&quot;, and the leading bits of
the start byte tell how many bytes there are in the encoded
character.</p>

<p style="margin-top: 1em">The original UTF-8 specification
allowed up to 6 bytes, to allow encoding of numbers up to
0x7FFF_FFFF. Perl continues to allow those, and has extended
that up to 13 bytes <br>
to encode code points up to what can fit in a 64-bit word.
However, Perl will warn if you output any of these as being
non-portable; and under strict UTF-8 input protocols, <br>
they are forbidden.</p>

<p style="margin-top: 1em">The Unicode non-character code
points are also disallowed in UTF-8 in &quot;open
interchange&quot;. See &quot;Non-character code
points&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; UTF-EBCDIC</p>

<p style="margin-top: 1em">Like UTF-8 but EBCDIC-safe, in
the way that UTF-8 is ASCII-safe.</p>

<p style="margin-top: 1em">&Acirc;&middot; UTF-16,
UTF-16BE, UTF-16LE, Surrogates, and BOMs (Byte Order
Marks)</p>

<p style="margin-top: 1em">The followings items are mostly
for reference and general Unicode knowledge, Perl
doesn&rsquo;t use these constructs internally.</p>

<p style="margin-top: 1em">Like UTF-8, UTF-16 is a
variable-width encoding, but where UTF-8 uses 8-bit code
units, UTF-16 uses 16-bit code units. All code points occupy
either 2 or 4 bytes in UTF-16: <br>
code points &quot;U+0000..U+FFFF&quot; are stored in a
single 16-bit unit, and code points
&quot;U+10000..U+10FFFF&quot; in two 16-bit units. The
latter case is using surrogates, the first <br>
16-bit unit being the high surrogate, and the second being
the low surrogate.</p>

<p style="margin-top: 1em">Surrogates are code points set
aside to encode the &quot;U+10000..U+10FFFF&quot; range of
Unicode code points in pairs of 16-bit units. The high
surrogates are the range <br>
&quot;U+D800..U+DBFF&quot; and the low surrogates are the
range &quot;U+DC00..U+DFFF&quot;. The surrogate encoding
is</p>

<p style="margin-top: 1em">$hi = ($uni - 0x10000) / 0x400 +
0xD800; <br>
$lo = ($uni - 0x10000) % 0x400 + 0xDC00;</p>

<p style="margin-top: 1em">and the decoding is</p>

<p style="margin-top: 1em">$uni = 0x10000 + ($hi - 0xD800)
* 0x400 + ($lo - 0xDC00);</p>

<p style="margin-top: 1em">Because of the 16-bitness,
UTF-16 is byte-order dependent. UTF-16 itself can be used
for in-memory computations, but if storage or transfer is
required either UTF-16BE (big- <br>
endian) or UTF-16LE (little-endian) encodings must be
chosen.</p>

<p style="margin-top: 1em">This introduces another problem:
what if you just know that your data is UTF-16, but you
don&rsquo;t know which endianness? Byte Order Marks, or
BOMs, are a solution to this. A <br>
special character has been reserved in Unicode to function
as a byte order marker: the character with the code point
&quot;U+FEFF&quot; is the BOM.</p>

<p style="margin-top: 1em">The trick is that if you read a
BOM, you will know the byte order, since if it was written
on a big-endian platform, you will read the bytes &quot;0xFE
0xFF&quot;, but if it was <br>
written on a little-endian platform, you will read the bytes
&quot;0xFF 0xFE&quot;. (And if the originating platform was
writing in UTF-8, you will read the bytes &quot;0xEF 0xBB
0xBF&quot;.)</p>

<p style="margin-top: 1em">The way this trick works is that
the character with the code point &quot;U+FFFE&quot; is not
supposed to be in input streams, so the sequence of bytes
&quot;0xFF 0xFE&quot; is unambiguously <br>
&quot;BOM, represented in little-endian format&quot; and
cannot be &quot;U+FFFE&quot;, represented in big-endian
format&quot;.</p>

<p style="margin-top: 1em">Surrogates have no meaning in
Unicode outside their use in pairs to represent other code
points. However, Perl allows them to be represented
individually internally, for <br>
example by saying &quot;chr(0xD801)&quot;, so that all code
points, not just those valid for open interchange, are
representable. Unicode does define semantics for them, such
as their <br>
General Category is &quot;Cs&quot;. But because their use is
somewhat dangerous, Perl will warn (using the warning
category &quot;surrogate&quot;, which is a sub-category of
&quot;utf8&quot;) if an <br>
attempt is made to do things like take the lower case of
one, or match case-insensitively, or to output them. (But
don&rsquo;t try this on Perls before 5.14.)</p>

<p style="margin-top: 1em">&Acirc;&middot; UTF-32,
UTF-32BE, UTF-32LE</p>

<p style="margin-top: 1em">The UTF-32 family is pretty much
like the UTF-16 family, expect that the units are 32-bit,
and therefore the surrogate scheme is not needed. UTF-32 is
a fixed-width <br>
encoding. The BOM signatures are &quot;0x00 0x00 0xFE
0xFF&quot; for BE and &quot;0xFF 0xFE 0x00 0x00&quot; for
LE.</p>

<p style="margin-top: 1em">&Acirc;&middot; UCS-2, UCS-4</p>

<p style="margin-top: 1em">Legacy, fixed-width encodings
defined by the ISO 10646 standard. UCS-2 is a 16-bit
encoding. Unlike UTF-16, UCS-2 is not extensible beyond
&quot;U+FFFF&quot;, because it does not use <br>
surrogates. UCS-4 is a 32-bit encoding, functionally
identical to UTF-32 (the difference being that UCS-4 forbids
neither surrogates nor code points larger than
0x10_FFFF).</p>

<p style="margin-top: 1em">&Acirc;&middot; UTF-7</p>

<p style="margin-top: 1em">A seven-bit safe (non-eight-bit)
encoding, which is useful if the transport or storage is not
eight-bit safe. Defined by RFC 2152.</p>

<p style="margin-top: 1em">Non-character code points <br>
66 code points are set aside in Unicode as
&quot;non-character code points&quot;. These all have the
Unassigned (Cn) General Category, and they never will be
assigned. These are never <br>
supposed to be in legal Unicode input streams, so that code
can use them as sentinels that can be mixed in with
character data, and they always will be distinguishable from
that <br>
data. To keep them out of Perl input streams, strict UTF-8
should be specified, such as by using the layer
&quot;:encoding(&rsquo;UTF-8&rsquo;)&quot;. The
non-character code points are the 32 <br>
between U+FDD0 and U+FDEF, and the 34 code points U+FFFE,
U+FFFF, U+1FFFE, U+1FFFF, ... U+10FFFE, U+10FFFF. Some
people are under the mistaken impression that these are <br>
&quot;illegal&quot;, but that is not true. An application or
cooperating set of applications can legally use them at will
internally; but these code points are &quot;illegal for open
<br>
interchange&quot;. Therefore, Perl will not accept these
from input streams unless lax rules are being used, and will
warn (using the warning category &quot;nonchar&quot;, which
is a sub- <br>
category of &quot;utf8&quot;) if an attempt is made to
output them.</p>

<p style="margin-top: 1em">Beyond Unicode code points <br>
The maximum Unicode code point is U+10FFFF. But Perl accepts
code points up to the maximum permissible unsigned number
available on the platform. However, Perl will not accept
<br>
these from input streams unless lax rules are being used,
and will warn (using the warning category
&quot;non_unicode&quot;, which is a sub-category of
&quot;utf8&quot;) if an attempt is made to <br>
operate on or output them. For example,
&quot;uc(0x11_0000)&quot; will generate this warning,
returning the input parameter as its result, as the upper
case of every non-Unicode code <br>
point is the code point itself.</p>

<p style="margin-top: 1em">Security Implications of Unicode
<br>
Read Unicode Security Considerations
&lt;http://www.unicode.org/reports/tr36&gt;. Also, note the
following:</p>

<p style="margin-top: 1em">&Acirc;&middot; Malformed
UTF-8</p>

<p style="margin-top: 1em">Unfortunately, the original
specification of UTF-8 leaves some room for interpretation
of how many bytes of encoded output one should generate from
one input Unicode <br>
character. Strictly speaking, the shortest possible sequence
of UTF-8 bytes should be generated, because otherwise there
is potential for an input buffer overflow at the <br>
receiving end of a UTF-8 connection. Perl always generates
the shortest length UTF-8, and with warnings on, Perl will
warn about non-shortest length UTF-8 along with other <br>
malformations, such as the surrogates, which are not Unicode
code points valid for interchange.</p>

<p style="margin-top: 1em">&Acirc;&middot; Regular
expression pattern matching may surprise you if you&rsquo;re
not accustomed to Unicode. Starting in Perl 5.14, several
pattern modifiers are available to control this, <br>
called the character set modifiers. Details are given in
&quot;Character set modifiers&quot; in perlre.</p>

<p style="margin-top: 1em">As discussed elsewhere, Perl has
one foot (two hooves?) planted in each of two worlds: the
old world of bytes and the new world of characters,
upgrading from bytes to characters <br>
when necessary. If your legacy code does not explicitly use
Unicode, no automatic switch-over to characters should
happen. Characters shouldn&rsquo;t get downgraded to bytes,
either. <br>
It is possible to accidentally mix bytes and characters,
however (see perluniintro), in which case &quot;1656/a&quot;
<br>
modifier is in effect). Review your code. Use warnings and
the &quot;strict&quot; pragma.</p>

<p style="margin-top: 1em">Unicode in Perl on EBCDIC <br>
The way Unicode is handled on EBCDIC platforms is still
experimental. On such platforms, references to UTF-8
encoding in this document and elsewhere should be read as
meaning <br>
the UTF-EBCDIC specified in Unicode Technical Report 16,
unless ASCII vs. EBCDIC issues are specifically discussed.
There is no &quot;utfebcdic&quot; pragma or
&quot;:utfebcdic&quot; layer; rather, <br>
&quot;utf8&quot; and &quot;:utf8&quot; are reused to mean
the platform&rsquo;s &quot;natural&quot; 8-bit encoding of
Unicode. See perlebcdic for more discussion of the
issues.</p>

<p style="margin-top: 1em">Locales <br>
See &quot;Unicode and UTF-8&quot; in perllocale</p>

<p style="margin-top: 1em">When Unicode Does Not Happen
<br>
While Perl does have extensive ways to input and output in
Unicode, and a few other &quot;entry points&quot; like the
@ARGV array (which can sometimes be interpreted as UTF-8),
there are <br>
still many places where Unicode (in some encoding or
another) could be given as arguments or received as results,
or both, but it is not.</p>

<p style="margin-top: 1em">The following are such
interfaces. Also, see &quot;The &quot;Unicode
Bug&quot;&quot;. For all of these interfaces Perl currently
(as of 5.8.3) simply assumes byte strings both as arguments
and <br>
results, or UTF-8 strings if the (problematic)
&quot;encoding&quot; pragma has been used.</p>

<p style="margin-top: 1em">One reason that Perl does not
attempt to resolve the role of Unicode in these situations
is that the answers are highly dependent on the operating
system and the file system(s). <br>
For example, whether filenames can be in Unicode and in
exactly what kind of encoding, is not exactly a portable
concept. Similarly for &quot;qx&quot; and
&quot;system&quot;: how well will the <br>
&quot;command-line interface&quot; (and which of them?)
handle Unicode?</p>

<p style="margin-top: 1em">&Acirc;&middot; chdir, chmod,
chown, chroot, exec, link, lstat, mkdir, rename, rmdir,
stat, symlink, truncate, unlink, utime, -X</p>

<p style="margin-top: 1em">&Acirc;&middot; %ENV</p>

<p style="margin-top: 1em">&Acirc;&middot; glob (aka the
&lt;*&gt;)</p>

<p style="margin-top: 1em">&Acirc;&middot; open, opendir,
sysopen</p>

<p style="margin-top: 1em">&Acirc;&middot; qx (aka the
backtick operator), system</p>

<p style="margin-top: 1em">&Acirc;&middot; readdir,
readlink</p>

<p style="margin-top: 1em">The &quot;Unicode Bug&quot; <br>
The term, &quot;Unicode bug&quot; has been applied to an
inconsistency on ASCII platforms with the Unicode code
points in the Latin-1 Supplement block, that is, between 128
and 255. <br>
Without a locale specified, unlike all other characters or
code points, these characters have very different semantics
in byte semantics versus character semantics, unless
&quot;use <br>
feature &rsquo;unicode_strings&rsquo;&quot; is specified,
directly or indirectly. (It is indirectly specified by a
&quot;use v5.12&quot; or higher.)</p>

<p style="margin-top: 1em">In character semantics these
upper-Latin1 characters are interpreted as Unicode code
points, which means they have the same semantics as Latin-1
(ISO-8859-1).</p>

<p style="margin-top: 1em">In byte semantics (without
&quot;unicode_strings&quot;), they are considered to be
unassigned characters, meaning that the only semantics they
have is their ordinal numbers, and that they <br>
are not members of various character classes. None are
considered to match &quot;672W&quot;.</p>

<p style="margin-top: 1em">Perl 5.12.0 added
&quot;unicode_strings&quot; to force character semantics on
these code points in some circumstances, which fixed
portions of the bug; Perl 5.14.0 fixed almost all of it;
<br>
and Perl 5.16.0 fixed the remainder (so far as we know,
anyway). The lesson here is to enable
&quot;unicode_strings&quot; to avoid the headaches described
below.</p>

<p style="margin-top: 1em">The old, problematic behavior
affects these areas:</p>

<p style="margin-top: 1em">&Acirc;&middot; Changing the
case of a scalar, that is, using &quot;uc()&quot;,
&quot;ucfirst()&quot;, &quot;lc()&quot;, and
&quot;lcfirst()&quot;, or &quot; &quot;U&quot;, &quot;&quot;
and &quot;n double-quotish contexts, such as regular <br>
expression substitutions. Under &quot;unicode_strings&quot;
starting in Perl 5.12.0, character semantics are generally
used. See &quot;lc&quot; in perlfunc for details on how this
works in <br>
combination with various other pragmas.</p>

<p style="margin-top: 1em">&Acirc;&middot; Using caseless
(&quot;/i&quot;) regular expression matching. Starting in
Perl 5.14.0, regular expressions compiled within the scope
of &quot;unicode_strings&quot; use character semantics even
<br>
when executed or compiled into larger regular expressions
outside the scope.</p>

<p style="margin-top: 1em">&Acirc;&middot; Matching any of
several properties in regular expressions, namely &quot;,0
&quot; &quot;48W&quot;, and all the Posix character classes
except &quot;[[:ascii:]]&quot;. Starting in <br>
Perl 5.14.0, regular expressions compiled within the scope
of &quot;unicode_strings&quot; use character semantics even
when executed or compiled into larger regular expressions
outside <br>
the scope.</p>

<p style="margin-top: 1em">&Acirc;&middot; In
&quot;quotemeta&quot; or its inline equivalent
&quot;Q&quot;, no code points above 127 are quoted in UTF-8
encoded strings, but in byte encoded strings, code points
between 128-255 are <br>
always quoted. Starting in Perl 5.16.0, consistent quoting
rules are used within the scope of
&quot;unicode_strings&quot;, as described in
&quot;quotemeta&quot; in perlfunc.</p>

<p style="margin-top: 1em">This behavior can lead to
unexpected results in which a string&rsquo;s semantics
suddenly change if a code point above 255 is appended to or
removed from it, which changes the string&rsquo;s <br>
semantics from byte to character or vice versa. As an
example, consider the following program and its output:</p>

<p style="margin-top: 1em">$ perl -le&rsquo; <br>
no feature &rsquo;unicode_strings&rsquo;; <br>
$s1 = &quot;; <br>
$s2 = &quot;&quot;; <br>
for ($s1, $s2, $s1.$s2) { <br>
print /144 <br>
} <br>
&rsquo; <br>
0 <br>
0 <br>
1</p>

<p style="margin-top: 1em">If there&rsquo;s no
&quot;96s1&quot; or in &quot;s2&quot;, why does their
concatenation have one?</p>

<p style="margin-top: 1em">This anomaly stems from
Perl&rsquo;s attempt to not disturb older programs that
didn&rsquo;t use Unicode, and hence had no semantics for
characters outside of the ASCII range (except in a <br>
locale), along with Perl&rsquo;s desire to add Unicode
support seamlessly. The result wasn&rsquo;t seamless: these
characters were orphaned.</p>

<p style="margin-top: 1em">For Perls earlier than those
described above, or when a string is passed to a function
outside the subpragma&rsquo;s scope, a workaround is to
always call &quot;utf8::upgrade($string)&quot;, or <br>
to use the standard module Encode. Also, a scalar that has
any characters whose ordinal is above 0x100, or which were
specified using either of the &quot; notations,
will <br>
automatically have character semantics.</p>

<p style="margin-top: 1em">Forcing Unicode in Perl (Or
Unforcing Unicode in Perl) <br>
Sometimes (see &quot;When Unicode Does Not Happen&quot; or
&quot;The &quot;Unicode Bug&quot;&quot;) there are
situations where you simply need to force a byte string into
UTF-8, or vice versa. The low-level <br>
calls utf8::upgrade($bytestring) and
utf8::downgrade($utf8string[, FAIL_OK]) are the answers.</p>

<p style="margin-top: 1em">Note that utf8::downgrade() can
fail if the string contains characters that don&rsquo;t fit
into a byte.</p>

<p style="margin-top: 1em">Calling either function on a
string that already is in the desired state is a no-op.</p>

<p style="margin-top: 1em">Using Unicode in XS <br>
If you want to handle Perl Unicode in XS extensions, you may
find the following C APIs useful. See also &quot;Unicode
Support&quot; in perlguts for an explanation about Unicode
at the XS <br>
level, and perlapi for the API details.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;DO_UTF8(sv)&quot; returns true if the &quot;UTF8&quot;
flag is on and the bytes pragma is not in effect.
&quot;SvUTF8(sv)&quot; returns true if the &quot;UTF8&quot;
flag is on; the bytes pragma is ignored. <br>
The &quot;UTF8&quot; flag being on does not mean that there
are any characters of code points greater than 255 (or 127)
in the scalar or that there are even any characters in the
<br>
scalar. What the &quot;UTF8&quot; flag means is that the
sequence of octets in the representation of the scalar is
the sequence of UTF-8 encoded code points of the characters
of a <br>
string. The &quot;UTF8&quot; flag being off means that each
octet in this representation encodes a single character with
code point 0..255 within the string. Perl&rsquo;s Unicode
model is <br>
not to use UTF-8 until it is absolutely necessary.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;uvchr_to_utf8(buf, chr)&quot; writes a Unicode
character code point into a buffer encoding the code point
as UTF-8, and returns a pointer pointing after the UTF-8
bytes. It <br>
works appropriately on EBCDIC machines.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;utf8_to_uvchr_buf(buf, bufend, lenp)&quot; reads UTF-8
encoded bytes from a buffer and returns the Unicode
character code point and, optionally, the length of the
UTF-8 byte <br>
sequence. It works appropriately on EBCDIC machines.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;utf8_length(start, end)&quot; returns the length of
the UTF-8 encoded buffer in characters.
&quot;sv_len_utf8(sv)&quot; returns the length of the UTF-8
encoded scalar.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;sv_utf8_upgrade(sv)&quot; converts the string of the
scalar to its UTF-8 encoded form.
&quot;sv_utf8_downgrade(sv)&quot; does the opposite, if
possible. &quot;sv_utf8_encode(sv)&quot; is like <br>
sv_utf8_upgrade except that it does not set the
&quot;UTF8&quot; flag. &quot;sv_utf8_decode()&quot; does the
opposite of &quot;sv_utf8_encode()&quot;. Note that none of
these are to be used as general- <br>
purpose encoding or decoding interfaces: &quot;use
Encode&quot; for that. &quot;sv_utf8_upgrade()&quot; is
affected by the encoding pragma but
&quot;sv_utf8_downgrade()&quot; is not (since the encoding
<br>
pragma is designed to be a one-way street).</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;is_utf8_string(buf, len)&quot; returns true if
&quot;len&quot; bytes of the buffer are valid UTF-8.</p>

<p style="margin-top: 1em">&Acirc;&middot; is_utf8_char(s)
returns true if the pointer points to a valid UTF-8
character. However, this function should not be used because
of security concerns. Instead, use <br>
&quot;is_utf8_string()&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;UTF8SKIP(buf)&quot; will return the number of bytes in
the UTF-8 encoded character in the buffer.
&quot;UNISKIP(chr)&quot; will return the number of bytes
required to UTF-8-encode the <br>
Unicode character code point. &quot;UTF8SKIP()&quot; is
useful for example for iterating over the characters of a
UTF-8 encoded buffer; &quot;UNISKIP()&quot; is useful, for
example, in <br>
computing the size required for a UTF-8 encoded buffer.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;utf8_distance(a, b)&quot; will tell the distance in
characters between the two pointers pointing to the same
UTF-8 encoded buffer.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;utf8_hop(s, off)&quot; will return a pointer to a
UTF-8 encoded buffer that is &quot;off&quot; (positive or
negative) Unicode characters displaced from the UTF-8 buffer
&quot;s&quot;. Be careful <br>
not to overstep the buffer: &quot;utf8_hop()&quot; will
merrily run off the end or the beginning of the buffer if
told to do so.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;pv_uni_display(dsv, spv, len, pvlim, flags)&quot; and
&quot;sv_uni_display(dsv, ssv, pvlim, flags)&quot; are
useful for debugging the output of Unicode strings and
scalars. By default <br>
they are useful only for debugging--they display all
characters as hexadecimal code points--but with the flags
&quot;UNI_DISPLAY_ISPRINT&quot;,
&quot;UNI_DISPLAY_BACKSLASH&quot;, and <br>
&quot;UNI_DISPLAY_QQ&quot; you can make the output more
readable.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2)&quot;
can be used to compare two strings case-insensitively in
Unicode. For case-sensitive comparisons you can just use
&quot;memEQ()&quot; <br>
and &quot;memNE()&quot; as usual, except if one string is in
utf8 and the other isn&rsquo;t.</p>

<p style="margin-top: 1em">For more information, see
perlapi, and utf8.c and utf8.h in the Perl source code
distribution.</p>

<p style="margin-top: 1em">Hacking Perl to work on earlier
Unicode versions (for very serious hackers only) <br>
Perl by default comes with the latest supported Unicode
version built in, but you can change to use any earlier
one.</p>

<p style="margin-top: 1em">Download the files in the
desired version of Unicode from the Unicode web site
&lt;http://www.unicode.org&gt;). These should replace the
existing files in lib/unicore in the Perl <br>
source tree. Follow the instructions in README.perl in that
directory to change some of their names, and then build perl
(see INSTALL).</p>

<p style="margin-top: 1em">BUGS <br>
Interaction with Locales <br>
See &quot;Unicode and UTF-8&quot; in perllocale</p>

<p style="margin-top: 1em">Problems with characters in the
Latin-1 Supplement range <br>
See &quot;The &quot;Unicode Bug&quot;&quot;</p>

<p style="margin-top: 1em">Interaction with Extensions <br>
When Perl exchanges data with an extension, the extension
should be able to understand the UTF8 flag and act
accordingly. If the extension doesn&rsquo;t recognize that
flag, it&rsquo;s <br>
likely that the extension will return incorrectly-flagged
data.</p>

<p style="margin-top: 1em">So if you&rsquo;re working with
Unicode data, consult the documentation of every module
you&rsquo;re using if there are any issues with Unicode data
exchange. If the documentation does not <br>
talk about Unicode at all, suspect the worst and probably
look at the source to learn how the module is implemented.
Modules written completely in Perl shouldn&rsquo;t cause
problems. <br>
Modules that directly or indirectly access code written in
other programming languages are at risk.</p>

<p style="margin-top: 1em">For affected functions, the
simple strategy to avoid data corruption is to always make
the encoding of the exchanged data explicit. Choose an
encoding that you know the extension <br>
can handle. Convert arguments passed to the extensions to
that encoding and convert results back from that encoding.
Write wrapper functions that do the conversions for you, so
<br>
you can later change the functions when the extension
catches up.</p>

<p style="margin-top: 1em">To provide an example,
let&rsquo;s say the popular Foo::Bar::escape_html function
doesn&rsquo;t deal with Unicode data yet. The wrapper
function would convert the argument to raw UTF-8 and <br>
convert the result back to Perl&rsquo;s internal
representation like so:</p>

<p style="margin-top: 1em">sub my_escape_html ($) { <br>
my($what) = shift; <br>
return unless defined $what; <br>
Encode::decode_utf8(Foo::Bar::escape_html( <br>
Encode::encode_utf8($what))); <br>
}</p>

<p style="margin-top: 1em">Sometimes, when the extension
does not convert data but just stores and retrieves them,
you will be able to use the otherwise dangerous
Encode::_utf8_on() function. Let&rsquo;s say the <br>
popular &quot;Foo::Bar&quot; extension, written in C,
provides a &quot;param&quot; method that lets you store and
retrieve data according to these prototypes:</p>

<p style="margin-top: 1em">$self-&gt;param($name, $value);
# set a scalar <br>
$value = $self-&gt;param($name); # retrieve a scalar</p>

<p style="margin-top: 1em">If it does not yet provide
support for any encoding, one could write a derived class
with such a &quot;param&quot; method:</p>

<p style="margin-top: 1em">sub param { <br>
my($self,$name,$value) = @_; <br>
utf8::upgrade($name); # make sure it is UTF-8 encoded <br>
if (defined $value) { <br>
utf8::upgrade($value); # make sure it is UTF-8 encoded <br>
return $self-&gt;SUPER::param($name,$value); <br>
} else { <br>
my $ret = $self-&gt;SUPER::param($name); <br>
Encode::_utf8_on($ret); # we know, it is UTF-8 encoded <br>
return $ret; <br>
} <br>
}</p>

<p style="margin-top: 1em">Some extensions provide filters
on data entry/exit points, such as DB_File::filter_store_key
and family. Look out for such filters in the documentation
of your extensions, they <br>
can make the transition to Unicode data much easier.</p>

<p style="margin-top: 1em">Speed <br>
Some functions are slower when working on UTF-8 encoded
strings than on byte encoded strings. All functions that
need to hop over characters such as length(), substr() or
<br>
index(), or matching regular expressions can work much
faster when the underlying data are byte-encoded.</p>

<p style="margin-top: 1em">In Perl 5.8.0 the slowness was
often quite spectacular; in Perl 5.8.1 a caching scheme was
introduced which will hopefully make the slowness somewhat
less spectacular, at least <br>
for some operations. In general, operations with UTF-8
encoded strings are still slower. As an example, the Unicode
properties (character classes) like &quot;{Nd}&quot; are
known to be <br>
quite a bit slower (5-20 times) than their simpler
counterparts like &quot;&quot; (then again, there are
hundreds of Unicode characters matching &quot;Nd&quot;
compared with the 10 ASCII <br>
characters matching &quot;d&quot;).</p>

<p style="margin-top: 1em">Problems on EBCDIC platforms
<br>
There are several known problems with Perl on EBCDIC
platforms. If you want to use Perl there, send email to
perlbug@perl.org.</p>

<p style="margin-top: 1em">In earlier versions, when byte
and character data were concatenated, the new string was
sometimes created by decoding the byte strings as ISO 8859-1
(Latin-1), even if the old <br>
Unicode string used EBCDIC.</p>

<p style="margin-top: 1em">If you find any of these, please
report them as bugs.</p>

<p style="margin-top: 1em">Porting code from perl-5.6.X
<br>
Perl 5.8 has a different Unicode model from 5.6. In 5.6 the
programmer was required to use the &quot;utf8&quot; pragma
to declare that a given scope expected to deal with Unicode
data and <br>
had to make sure that only Unicode data were reaching that
scope. If you have code that is working with 5.6, you will
need some of the following adjustments to your code. The
<br>
examples are written such that the code will continue to
work under 5.6, so you should be safe to try them out.</p>

<p style="margin-top: 1em">&Acirc;&middot; A filehandle
that should read or write UTF-8</p>

<p style="margin-top: 1em">if ($] &gt; 5.007) { <br>
binmode $fh, &quot;:encoding(utf8)&quot;; <br>
}</p>

<p style="margin-top: 1em">&Acirc;&middot; A scalar that is
going to be passed to some extension</p>

<p style="margin-top: 1em">Be it Compress::Zlib,
Apache::Request or any extension that has no mention of
Unicode in the manpage, you need to make sure that the UTF8
flag is stripped off. Note that at <br>
the time of this writing (October 2002) the mentioned
modules are not UTF-8-aware. Please check the documentation
to verify if this is still true.</p>

<p style="margin-top: 1em">if ($] &gt; 5.007) { <br>
require Encode; <br>
$val = Encode::encode_utf8($val); # make octets <br>
}</p>

<p style="margin-top: 1em">&Acirc;&middot; A scalar we got
back from an extension</p>

<p style="margin-top: 1em">If you believe the scalar comes
back as UTF-8, you will most likely want the UTF8 flag
restored:</p>

<p style="margin-top: 1em">if ($] &gt; 5.007) { <br>
require Encode; <br>
$val = Encode::decode_utf8($val); <br>
}</p>

<p style="margin-top: 1em">&Acirc;&middot; Same thing, if
you are really sure it is UTF-8</p>

<p style="margin-top: 1em">if ($] &gt; 5.007) { <br>
require Encode; <br>
Encode::_utf8_on($val); <br>
}</p>

<p style="margin-top: 1em">&Acirc;&middot; A wrapper for
fetchrow_array and fetchrow_hashref</p>

<p style="margin-top: 1em">When the database contains only
UTF-8, a wrapper function or method is a convenient way to
replace all your fetchrow_array and fetchrow_hashref calls.
A wrapper function will <br>
also make it easier to adapt to future enhancements in your
database driver. Note that at the time of this writing
(October 2002), the DBI has no standardized way to deal with
<br>
UTF-8 data. Please check the documentation to verify if that
is still true.</p>

<p style="margin-top: 1em">sub fetchrow { <br>
# $what is one of fetchrow_{array,hashref} <br>
my($self, $sth, $what) = @_; <br>
if ($] &lt; 5.007) { <br>
return $sth-&gt;$what; <br>
} else { <br>
require Encode; <br>
if (wantarray) { <br>
my @arr = $sth-&gt;$what; <br>
for (@arr) { <br>
defined &amp;&amp; /[^ 00-177]/ &amp;&amp;
Encode::_utf8_on($_); <br>
} <br>
return @arr; <br>
} else { <br>
my $ret = $sth-&gt;$what; <br>
if (ref $ret) { <br>
for my $k (keys %$ret) { <br>
defined <br>
&amp;&amp; /[^ 00-177]/ <br>
&amp;&amp; Encode::_utf8_on($_) for $ret-&gt;{$k}; <br>
} <br>
return $ret; <br>
} else { <br>
defined &amp;&amp; /[^ 00-177]/ &amp;&amp;
Encode::_utf8_on($_) for $ret; <br>
return $ret; <br>
} <br>
} <br>
} <br>
}</p>

<p style="margin-top: 1em">&Acirc;&middot; A large scalar
that you know can only contain ASCII</p>

<p style="margin-top: 1em">Scalars that contain only ASCII
and are marked as UTF-8 are sometimes a drag to your
program. If you recognize such a situation, just remove the
UTF8 flag:</p>

<p style="margin-top: 1em">utf8::downgrade($val) if $] &gt;
5.007;</p>

<p style="margin-top: 1em">SEE ALSO <br>
perlunitut, perluniintro, perluniprops, Encode, open, utf8,
bytes, perlretut, &quot;${^UNICODE}&quot; in perlvar
&lt;http://www.unicode.org/reports/tr44&gt;).</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLUNICODE(1)</p>
<hr>
</body>
</html>
