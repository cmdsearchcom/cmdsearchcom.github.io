<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 15:53:36 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>AVRDUDE(1) BSD General Commands Manual AVRDUDE(1)</p>

<p style="margin-top: 1em">NAME <br>
avrdude &acirc; driver program for
&lsquo;&lsquo;simple&rsquo;&rsquo; Atmel AVR MCU
programmer</p>

<p style="margin-top: 1em">SYNOPSIS <br>
avrdude -p partno [-b baudrate] [-B bitclock] [-c
programmer-id] [-C config-file] [-D] [-e] [-E
exitspec[,exitspec]] [-F] [-i delay] [-n -logfile] [-n] [-O]
[-P port] [-q] [-s] <br>
[-t] [-u] [-U memtype:op:filename:filefmt] [-v] [-x
extended_param] [-V]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Avrdude is a program for downloading code and data to Atmel
AVR microcontrollers. Avrdude supports Atmel&rsquo;s STK500
programmer, Atmel&rsquo;s AVRISP and AVRISP mkII devices,
Atmel&rsquo;s <br>
STK600, Atmel&rsquo;s JTAG ICE (mkI, mkII and 3, the latter
two also in ISP mode), programmers complying to AppNote
AVR910 and AVR109 (including the Butterfly), as well as a
simple hard- <br>
wired programmer connected directly to a ppi(4) or
parport(4) parallel port, or to a standard serial port. In
the simplest case, the hardware consists just of a cable
connecting <br>
the respective AVR signal lines to the parallel port.</p>

<p style="margin-top: 1em">The MCU is programmed in serial
programming mode, so, for the ppi(4) based programmer, the
MCU signals &acirc;/RESET&acirc;, &acirc;SCK&acirc;,
&acirc;MISO&acirc; and &acirc;MOSI&acirc; need to be
connected to the parallel port. <br>
Optionally, some otherwise unused output pins of the
parallel port can be used to supply power for the MCU part,
so it is also possible to construct a passive stand-alone
program&acirc; <br>
ming device. Some status LEDs indicating the current
operating state of the programmer can be connected, and a
signal is available to control a buffer/driver IC 74LS367
(or <br>
74HCT367). The latter can be useful to decouple the parallel
port from the MCU when in-system programming is used.</p>

<p style="margin-top: 1em">A number of equally simple
bit-bang programming adapters that connect to a serial port
are supported as well, among them the popular Ponyprog
serial adapter, and the DASA and DASA3 <br>
adapters that used to be supported by uisp(1). Note that
these adapters are meant to be attached to a physical serial
port. Connecting to a serial port emulated on top of USB is
<br>
likely to not work at all, or to work abysmally slow.</p>

<p style="margin-top: 1em">If you happen to have a Linux
system with at least 4 hardware GPIOs available (like almost
all embedded Linux boards) you can do without any additional
hardware - just connect them <br>
to the MOSI, MISO, RESET and SCK pins on the AVR and use the
linuxgpio programmer type. It bitbangs the lines using the
Linux sysfs GPIO interface. Of course, care should be taken
<br>
about voltage level compatibility. Also, although not
strictrly required, it is strongly advisable to protect the
GPIO pins from overcurrent situations in some way. The
simplest <br>
would be to just put some resistors in series or better yet
use a 3-state buffer driver like the 74HC244. Have a look at
http://kolev.info/avrdude-linuxgpio for a more detailed <br>
tutorial about using this programmer type.</p>

<p style="margin-top: 1em">Atmel&rsquo;s STK500 programmer
is also supported and connects to a serial port. Both,
firmware versions 1.x and 2.x can be handled, but require a
different programmer type specifica&acirc; <br>
tion (by now). Using firmware version 2, high-voltage
programming is also supported, both parallel and serial
(programmer types stk500pp and stk500hvsp).</p>

<p style="margin-top: 1em">Wiring boards are supported,
utilizing STK500 V2.x protocol, but a simple DTR/RTS toggle
is used to set the boards into programming mode. The
programmer type is &lsquo;&lsquo;wiring&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">The Arduino (which is very
similar to the STK500 1.x) is supported via its own
programmer type specification
&lsquo;&lsquo;arduino&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">The BusPirate is a versatile
tool that can also be used as an AVR programmer. A single
BusPirate can be connected to up to 3 independent AVRs. See
the section on extended <br>
parameters below for details.</p>

<p style="margin-top: 1em">Atmel&rsquo;s STK600 programmer
is supported in ISP and high-voltage programming modes, and
connects through the USB. For ATxmega devices, the STK600 is
supported in PDI mode. For <br>
ATtiny4/5/9/10 devices, the STK600 and AVRISP mkII are
supported in TPI mode.</p>

<p style="margin-top: 1em">The simple serial programmer
described in Atmel&rsquo;s application note AVR910, and the
bootloader described in Atmel&rsquo;s application note
AVR109 (which is also used by the AVR Butterfly <br>
evaluation board), are supported on a serial port.</p>

<p style="margin-top: 1em">Atmel&rsquo;s JTAG ICE (mkI,
mkII, and 3) is supported as well to up- or download memory
areas from/to an AVR target (no support for on-chip
debugging). For the JTAG ICE mkII, JTAG, <br>
debugWire and ISP mode are supported, provided it has a
firmware revision of at least 4.14 (decimal). JTAGICE3 also
supports all of JTAG, debugWIRE, and ISP mode. See below for
<br>
the limitations of debugWire. For ATxmega devices, the JTAG
ICE mkII is supported in PDI mode, provided it has a
revision 1 hardware and firmware version of at least 5.37
(deci&acirc; <br>
mal). For ATxmega devices, the JTAGICE3 is supported in PDI
mode.</p>

<p style="margin-top: 1em">Atmel-ICE (ARM/AVR) is supported
in all modes (JTAG, PDI for Xmega, debugWIRE, ISP).</p>

<p style="margin-top: 1em">Atmel&rsquo;s XplainedPro
boards, using the EDBG protocol (CMSIS-DAP compatible), are
supported using the &quot;jtag3&quot; programmer type.</p>

<p style="margin-top: 1em">Atmel&rsquo;s XplainedMini
boards, using the mEDBG protocol, are also supported using
the &quot;jtag3&quot; programmer type.</p>

<p style="margin-top: 1em">The AVR Dragon is supported in
all modes (ISP, JTAG, HVSP, PP, debugWire). When used in
JTAG and debugWire mode, the AVR Dragon behaves similar to a
JTAG ICE mkII, so all device- <br>
specific comments for that device will apply as well. When
used in ISP mode, the AVR Dragon behaves similar to an
AVRISP mkII (or JTAG ICE mkII in ISP mode), so all
device-spe&acirc; <br>
cific comments will apply there. In particular, the Dragon
starts out with a rather fast ISP clock frequency, so the -B
bitclock option might be required to achieve a stable ISP
<br>
communication. For ATxmega devices, the AVR Dragon is
supported in PDI mode, provided it has a firmware version of
at least 6.11 (decimal).</p>

<p style="margin-top: 1em">The avrftdi, USBasp ISP and
USBtinyISP adapters are also supported, provided avrdude has
been compiled with libusb support. USBasp ISP and USBtinyISP
both feature simple firmware- <br>
only USB implementations, running on an ATmega8 (or
ATmega88), or ATtiny2313, respectively. If libftdi has has
been compiled in avrdude, the avrftdi device adds support
for many <br>
programmers using FTDI&rsquo;s 2232C/D/H and 4232H parts
running in MPSSE mode, which hard-codes (in the chip) SCK to
bit 1, MOSI to bit 2, and MISO to bit 3. Reset is usually
bit 4.</p>

<p style="margin-top: 1em">The Atmel DFU bootloader is
supported in both, FLIP protocol version 1 (AT90USB* and
ATmega*U* devices), as well as version 2 (Xmega devices).
See below for some hints about FLIP <br>
version 1 protocol behaviour.</p>

<p style="margin-top: 1em">Input files can be provided, and
output files can be written in different file formats, such
as raw binary files containing the data to download to the
chip, Intel hex format, or <br>
Motorola S-record format. There are a number of tools
available to produce those files, like asl(1) as a
standalone assembler, or avr-objcopy(1) for the final stage
of the GNU <br>
toolchain for the AVR microcontroller.</p>

<p style="margin-top: 1em">Provided libelf(3) was present
when compiling avrdude, the input file can also be the final
ELF file as produced by the linker. The appropriate ELF
section(s) will be examined, <br>
according to the memory area to write to.</p>

<p style="margin-top: 1em">Avrdude can program the EEPROM
and flash ROM memory cells of supported AVR parts. Where
supported by the serial instruction set, fuse bits and lock
bits can be programmed as well. <br>
These are implemented within avrdude as separate memory
types and can be programmed using data from a file (see the
-m option) or from terminal mode (see the dump and write
com&acirc; <br>
mands). It is also possible to read the chip (provided it
has not been code-protected previously, of course) and store
the data in a file. Finally, a
&lsquo;&lsquo;terminal&rsquo;&rsquo; mode is avail&acirc;
<br>
able that allows one to interactively communicate with the
MCU, and to display or program individual memory cells. On
the STK500 and STK600 programmer, several operational
parame&acirc; <br>
ters (target supply voltage, target Aref voltage, master
clock) can be examined and changed from within terminal mode
as well.</p>

<p style="margin-top: 1em">Options <br>
In order to control all the different operation modi, a
number of options need to be specified to avrdude.</p>

<p style="margin-top: 1em">-p partno <br>
This is the only option that is mandatory for every
invocation of avrdude. It specifies the type of the MCU
connected to the programmer. These are read from the <br>
config file. For currently supported MCU types use ? as
partno, this will print a list of partno ids and official
part names on the terminal. (Both can be used with <br>
the -p option.)</p>

<p style="margin-top: 1em">Following parts need special
attention:</p>

<p style="margin-top: 1em">AT90S1200 The ISP programming
protocol of the AT90S1200 differs in subtle ways from that
of other AVRs. Thus, not all programmers support this
device. Known to <br>
work are all direct bitbang programmers, and all programmers
talking the STK500v2 protocol.</p>

<p style="margin-top: 1em">AT90S2343 The AT90S2323 and
ATtiny22 use the same algorithm.</p>

<p style="margin-top: 1em">ATmega2560, ATmega2561 <br>
Flash addressing above 128 KB is not supported by all
programming hardware. Known to work are jtag2, stk500v2, and
bit-bang programmers.</p>

<p style="margin-top: 1em">ATtiny11 The ATtiny11 can only
be programmed in high-voltage serial mode.</p>

<p style="margin-top: 1em">-b baudrate <br>
Override the RS-232 connection baud rate specified in the
respective programmer&rsquo;s entry of the configuration
file.</p>

<p style="margin-top: 1em">-B bitclock <br>
Specify the bit clock period for the JTAG interface or the
ISP clock (JTAG ICE only). The value is a floating-point
number in microseconds. Alternatively, the value <br>
might be suffixed with &quot;Hz&quot;, &quot;kHz&quot;, or
&quot;MHz&quot;, in order to specify the bit clock
frequency, rather than a period. The default value of the
JTAG ICE results in about 1 <br>
microsecond bit clock period, suitable for target MCUs
running at 4 MHz clock and above. Unlike certain parameters
in the STK500, the JTAG ICE resets all its parame&acirc;
<br>
ters to default values when the programming software signs
off from the ICE, so for MCUs running at lower clock speeds,
this parameter must be specified on the com&acirc; <br>
mand-line. You can use the &rsquo;default_bitclock&rsquo;
keyword in your ${HOME}/.avrduderc file to assign a default
value to keep from having to specify this option on every
<br>
invocation.</p>

<p style="margin-top: 1em">-c programmer-id <br>
Use the programmer specified by the argument. Programmers
and their pin configurations are read from the config file
(see the -C option). New pin configurations can <br>
be easily added or modified through the use of a config file
to make avrdude work with different programmers as long as
the programmer supports the Atmel AVR serial <br>
program method. You can use the
&rsquo;default_programmer&rsquo; keyword in your
${HOME}/.avrduderc file to assign a default programmer to
keep from having to specify this <br>
option on every invocation. A full list of all supported
programmers is output to the terminal by using ? as
programmer-id.</p>

<p style="margin-top: 1em">-C config-file <br>
Use the specified config file to load configuration data.
This file contains all programmer and part definitions that
avrdude knows about. See the config file, <br>
located at /etc/avrdude.conf, which contains a description
of the format.</p>

<p style="margin-top: 1em">If config-file is written as
+filename then this file is read after the system wide and
user configuration files. This can be used to add entries to
the configuration <br>
without patching your system wide configuration file. It can
be used several times, the files are read in same order as
given on the command line.</p>

<p style="margin-top: 1em">-D Disable auto erase for flash.
When the -U option with flash memory is specified, avrdude
will perform a chip erase before starting any of the
programming operations, <br>
since it generally is a mistake to program the flash without
performing an erase first. This option disables that. Auto
erase is not used for ATxmega devices as <br>
these devices can use page erase before writing each page so
no explicit chip erase is required. Note however that any
page not affected by the current operation <br>
will retain its previous contents.</p>

<p style="margin-top: 1em">-e Causes a chip erase to be
executed. This will reset the contents of the flash ROM and
EEPROM to the value &acirc;0xff&acirc;, and clear all lock
bits. Except for ATxmega <br>
devices which can use page erase, it is basically a
prerequisite command before the flash ROM can be
reprogrammed again. The only exception would be if the new
con&acirc; <br>
tents would exclusively cause bits to be programmed from the
value &acirc;1&acirc; to &acirc;0&acirc;. Note that in order
to reprogram EERPOM cells, no explicit prior chip erase is
required <br>
since the MCU provides an auto-erase cycle in that case
before programming the cell.</p>

<p style="margin-top: 1em">-E exitspec[,exitspec] <br>
By default, avrdude leaves the parallel port in the same
state at exit as it has been found at startup. This option
modifies the state of the &acirc;/RESET&acirc; and
&acirc;Vcc&acirc; <br>
lines the parallel port is left at, according to the
exitspec arguments provided, as follows:</p>

<p style="margin-top: 1em">reset The &acirc;/RESET&acirc;
signal will be left activated at program exit, that is it
will be held low, in order to keep the MCU in reset state
afterwards. Note in partic&acirc; <br>
ular that the programming algorithm for the AT90S1200 device
mandates that the &acirc;/RESET&acirc; signal is active
before powering up the MCU, so in case an external <br>
power supply is used for this MCU type, a previous
invocation of avrdude with this option specified is one of
the possible ways to guarantee this condition.</p>

<p style="margin-top: 1em">noreset The &acirc;/RESET&acirc;
line will be deactivated at program exit, thus allowing the
MCU target program to run while the programming hardware
remains connected.</p>

<p style="margin-top: 1em">vcc This option will leave those
parallel port pins active (i. e. high) that can be used to
supply &acirc;Vcc&acirc; power to the MCU.</p>

<p style="margin-top: 1em">novcc This option will pull the
&acirc;Vcc&acirc; pins of the parallel port down at program
exit.</p>

<p style="margin-top: 1em">d_high This option will leave
the 8 data pins on the parallel port active. (i. e.
high)</p>

<p style="margin-top: 1em">d_low This option will leave the
8 data pins on the parallel port inactive. (i. e. low)</p>

<p style="margin-top: 1em">Multiple exitspec arguments can
be separated with commas.</p>

<p style="margin-top: 1em">-F Normally, avrdude tries to
verify that the device signature read from the part is
reasonable before continuing. Since it can happen from time
to time that a device <br>
has a broken (erased or overwritten) device signature but is
otherwise operating normally, this options is provided to
override the check. Also, for programmers like <br>
the Atmel STK500 and STK600 which can adjust parameters
local to the programming tool (independent of an actual
connection to a target controller), this option can be <br>
used together with -t to continue in terminal mode.</p>

<p style="margin-top: 1em">-i delay <br>
For bitbang-type programmers, delay for approximately delay
microseconds between each bit state change. If the host
system is very fast, or the target runs off a <br>
slow clock (like a 32 kHz crystal, or the 128 kHz internal
RC oscillator), this can become necessary to satisfy the
requirement that the ISP clock frequency must not <br>
be higher than 1/4 of the CPU clock frequency. This is
implemented as a spin-loop delay to allow even for very
short delays. On Unix-style operating systems, the <br>
spin loop is initially calibrated against a system timer, so
the number of microseconds might be rather realistic,
assuming a constant system load while avrdude is <br>
running. On Win32 operating systems, a preconfigured number
of cycles per microsecond is assumed that might be off a bit
for very fast or very slow machines.</p>

<p style="margin-top: 1em">-l logfile <br>
Use logfile rather than stderr for diagnostics output. Note
that initial diagnostic messages (during option parsing) are
still written to stderr anyway.</p>

<p style="margin-top: 1em">-n No-write - disables actually
writing data to the MCU (useful for debugging avrdude ).</p>

<p style="margin-top: 1em">-O Perform a RC oscillator
run-time calibration according to Atmel application note
AVR053. This is only supported on the STK500v2, AVRISP mkII,
and JTAG ICE mkII hard&acirc; <br>
ware. Note that the result will be stored in the EEPROM cell
at address 0.</p>

<p style="margin-top: 1em">-P port <br>
Use port to identify the device to which the programmer is
attached. By default the /dev/ppi0 port is used, but if the
programmer type normally connects to the <br>
serial port, the /dev/cuaa0 port is the default. If you need
to use a different parallel or serial port, use this option
to specify the alternate port name.</p>

<p style="margin-top: 1em">On Win32 operating systems, the
parallel ports are referred to as lpt1 through lpt3,
referring to the addresses 0x378, 0x278, and 0x3BC,
respectively. If the paral&acirc; <br>
lel port can be accessed through a different address, this
address can be specified directly, using the common C
language notation (i. e., hexadecimal values are pre&acirc;
<br>
fixed by &acirc;0x&acirc; ).</p>

<p style="margin-top: 1em">For the JTAG ICE mkII and
JTAGICE3, if avrdude has been configured with libusb
support, port can alternatively be specified as
usb[:serialno]. This will cause <br>
avrdude to search the programmer on USB. If serialno is also
specified, it will be matched against the serial number read
from any JTAG ICE mkII found on USB. The <br>
match is done after stripping any existing colons from the
given serial number, and right-to-left, so only the least
significant bytes from the serial number need to <br>
be given.</p>

<p style="margin-top: 1em">As the AVRISP mkII device can
only be talked to over USB, the very same method of
specifying the port is required there.</p>

<p style="margin-top: 1em">For the USB programmer
&quot;AVR-Doper&quot; running in HID mode, the port must be
specified as avrdoper. Libusb support is required on Unix
but not on Windows. For more infor&acirc; <br>
mation about AVR-Doper see
http://www.obdev.at/avrusb/avrdoper.html.</p>

<p style="margin-top: 1em">For the USBtinyISP, which is a
simplicistic device not implementing serial numbers,
multiple devices can be distinguished by their location in
the USB hierarchy. See <br>
the the respective Troubleshooting entry in the detailed
documentation for examples.</p>

<p style="margin-top: 1em">For programmers that attach to a
serial port using some kind of higher level protocol (as
opposed to bit-bang style programmers), port can be
specified as <br>
net:host:port. In this case, instead of trying to open a
local device, a TCP network connection to (TCP) port on host
is established. The remote endpoint is assumed <br>
to be a terminal or console server that connects the network
stream to a local serial port where the actual programmer
has been attached to. The port is assumed to <br>
be properly configured, for example using a transparent
8-bit data connection without parity at 115200 Baud for a
STK500.</p>

<p style="margin-top: 1em">-q Disable (or quell) output of
the progress bar while reading or writing to the device.
Specify it a second time for even quieter operation.</p>

<p style="margin-top: 1em">-s Disable safemode prompting.
When safemode discovers that one or more fuse bits have
unintentionally changed, it will prompt for confirmation
regarding whether or not <br>
it should attempt to recover the fuse bit(s). Specifying
this flag disables the prompt and assumes that the fuse
bit(s) should be recovered without asking for con&acirc;
<br>
firmation first.</p>

<p style="margin-top: 1em">-t Tells avrdude to enter the
interactive &lsquo;&lsquo;terminal&rsquo;&rsquo; mode
instead of up- or downloading files. See below for a
detailed description of the terminal mode.</p>

<p style="margin-top: 1em">-u Disable the safemode fuse bit
checks. Safemode is enabled by default and is intended to
prevent unintentional fuse bit changes. When enabled,
safemode will issue a <br>
warning if the any fuse bits are found to be different at
program exit than they were when avrdude was invoked.
Safemode won&rsquo;t alter fuse bits itself, but rather <br>
will prompt for instructions, unless the terminal is
non-interactive, in which case safemode is disabled. See the
-s option to disable safemode prompting.</p>

<p style="margin-top: 1em">If one of the configuration
files has a line <br>
default_safemode = no; <br>
safemode is disabled by default. The -u option&rsquo;s
effect is negated in that case, i. e. it enables
safemode.</p>

<p style="margin-top: 1em">Safemode is always disabled for
AVR32, Xmega and TPI devices.</p>

<p style="margin-top: 1em">-U memtype:op:filename[:format]
<br>
Perform a memory operation as indicated. The memtype field
specifies the memory type to operate on. The available
memory types are device-dependent, the actual con&acirc;
<br>
figuration can be viewed with the part command in terminal
mode. Typically, a device&rsquo;s memory configuration at
least contains the memory types flash and eeprom. All <br>
memory types currently known are: <br>
calibration One or more bytes of RC oscillator calibration
data. <br>
eeprom The EEPROM of the device. <br>
efuse The extended fuse byte. <br>
flash The flash ROM of the device. <br>
fuse The fuse byte in devices that have only a single fuse
byte. <br>
hfuse The high fuse byte. <br>
lfuse The low fuse byte. <br>
lock The lock byte. <br>
signature The three device signature bytes (device ID). <br>
fuseN The fuse bytes of ATxmega devices, N is an integer
number for each fuse supported by the device. <br>
application The application flash area of ATxmega devices.
<br>
apptable The application table flash area of ATxmega
devices. <br>
boot The boot flash area of ATxmega devices. <br>
prodsig The production signature (calibration) area of
ATxmega devices. <br>
usersig The user signature area of ATxmega devices.</p>

<p style="margin-top: 1em">The op field specifies what
operation to perform:</p>

<p style="margin-top: 1em">r read device memory and write
to the specified file</p>

<p style="margin-top: 1em">w read data from the specified
file and write to the device memory</p>

<p style="margin-top: 1em">v read data from both the device
and the specified file and perform a verify</p>

<p style="margin-top: 1em">The filename field indicates the
name of the file to read or write. The format field is
optional and contains the format of the file to read or
write. Format can be <br>
one of:</p>

<p style="margin-top: 1em">i Intel Hex</p>

<p style="margin-top: 1em">s Motorola S-record</p>

<p style="margin-top: 1em">r raw binary; little-endian byte
order, in the case of the flash ROM data</p>

<p style="margin-top: 1em">e ELF (Executable and Linkable
Format)</p>

<p style="margin-top: 1em">m immediate; actual byte values
specified on the command line, separated by commas or
spaces. This is good for programming fuse bytes without
having to create a <br>
single-byte file or enter terminal mode.</p>

<p style="margin-top: 1em">a auto detect; valid for input
only, and only if the input is not provided at stdin.</p>

<p style="margin-top: 1em">d decimal; this and the
following formats are only valid on output. They generate
one line of output for the respective memory section,
forming a comma-separated <br>
list of the values. This can be particularly useful for
subsequent processing, like for fuse bit settings.</p>

<p style="margin-top: 1em">h hexadecimal; each value will
get the string 0x prepended.</p>

<p style="margin-top: 1em">o octal; each value will get a 0
prepended unless it is less than 8 in which case it gets no
prefix.</p>

<p style="margin-top: 1em">b binary; each value will get
the string 0b prepended.</p>

<p style="margin-top: 1em">The default is to use auto
detection for input files, and raw binary format for output
files. Note that if filename contains a colon, the format
field is no longer <br>
optional since the filename part following the colon would
otherwise be misinterpreted as format.</p>

<p style="margin-top: 1em">When reading any kind of flash
memory area (including the various sub-areas in Xmega
devices), the resulting output file will be truncated to not
contain trailing <br>
0xFF bytes which indicate unprogrammed (erased) memory.
Thus, if the entire memory is unprogrammed, this will result
in an output file that has no contents at all.</p>

<p style="margin-top: 1em">As an abbreviation, the form -U
filename is equivalent to specifying -U flash:w:filename:a.
This will only work if filename does not have a colon in
it.</p>

<p style="margin-top: 1em">-v Enable verbose output. More
-v options increase verbosity level.</p>

<p style="margin-top: 1em">-V Disable automatic verify
check when uploading data.</p>

<p style="margin-top: 1em">-x extended_param <br>
Pass extended_param to the chosen programmer implementation
as an extended parameter. The interpretation of the extended
parameter depends on the programmer itself. <br>
See below for a list of programmers accepting extended
parameters.</p>

<p style="margin-top: 1em">Terminal mode <br>
In this mode, avrdude only initializes communication with
the MCU, and then awaits user commands on standard input.
Commands and parameters may be abbreviated to the shortest
<br>
unambiguous form. Terminal mode provides a command history
using readline(3), so previously entered command lines can
be recalled and edited. The following commands are currently
<br>
implemented:</p>

<p style="margin-top: 1em">dump memtype addr nbytes <br>
Read nbytes bytes from the specified memory area, and
display them in the usual hexadecimal and ASCII form.</p>

<p style="margin-top: 1em">dump Continue dumping the memory
contents for another nbytes where the previous dump command
left off.</p>

<p style="margin-top: 1em">write memtype addr byte1 ...
byteN <br>
Manually program the respective memory cells, starting at
address addr, using the values byte1 through byteN. This
feature is not implemented for bank-addressed mem&acirc;
<br>
ories such as the flash memory of ATMega devices.</p>

<p style="margin-top: 1em">erase Perform a chip erase.</p>

<p style="margin-top: 1em">send b1 b2 b3 b4 <br>
Send raw instruction codes to the AVR device. If you need
access to a feature of an AVR part that is not directly
supported by avrdude, this command allows you to <br>
use it, even though avrdude does not implement the command.
When using direct SPI mode, up to 3 bytes can be
omitted.</p>

<p style="margin-top: 1em">sig Display the device signature
bytes.</p>

<p style="margin-top: 1em">spi Enter direct SPI mode. The
pgmled pin acts as slave select. Only supported on parallel
bitbang programmers.</p>

<p style="margin-top: 1em">part Display the current part
settings and parameters. Includes chip specific information
including all memory types supported by the device,
read/write timing, etc.</p>

<p style="margin-top: 1em">pgm Return to programming mode
(from direct SPI mode).</p>

<p style="margin-top: 1em">vtarg voltage <br>
Set the target&rsquo;s supply voltage to voltage Volts. Only
supported on the STK500 and STK600 programmer.</p>

<p style="margin-top: 1em">varef [channel] voltage <br>
Set the adjustable voltage source to voltage Volts. This
voltage is normally used to drive the target&rsquo;s Aref
input on the STK500. On the Atmel STK600, two reference <br>
voltages are available, which can be selected by the
optional channel argument (either 0 or 1). Only supported on
the STK500 and STK600 programmer.</p>

<p style="margin-top: 1em">fosc freq[M|k] <br>
Set the master oscillator to freq Hz. An optional trailing
letter M multiplies by 1E6, a trailing letter k by 1E3. Only
supported on the STK500 and STK600 <br>
programmer.</p>

<p style="margin-top: 1em">fosc off <br>
Turn the master oscillator off. Only supported on the STK500
and STK600 programmer.</p>

<p style="margin-top: 1em">sck period <br>
STK500 and STK600 programmer only: Set the SCK clock period
to period microseconds.</p>

<p style="margin-top: 1em">JTAG ICE only: Set the JTAG ICE
bit clock period to period microseconds. Note that unlike
STK500 settings, this setting will be reverted to its
default value <br>
(approximately 1 microsecond) when the programming software
signs off from the JTAG ICE. This parameter can also be used
on the JTAG ICE mkII, JTAGICE3, and Atmel- <br>
ICE to specify the ISP clock period when operating the ICE
in ISP mode.</p>

<p style="margin-top: 1em">parms STK500 and STK600
programmer only: Display the current voltage and master
oscillator parameters.</p>

<p style="margin-top: 1em">JTAG ICE only: Display the
current target supply voltage and JTAG bit clock
rate/period.</p>

<p style="margin-top: 1em">verbose [level] <br>
Change (when level is provided), or display the verbosity
level. The initial verbosity level is controlled by the
number of -v options given on the commandline.</p>

<p style="margin-top: 1em">?</p>

<p style="margin-top: 1em">help Give a short on-line
summary of the available commands.</p>

<p style="margin-top: 1em">quit Leave terminal mode and
thus avrdude.</p>

<p style="margin-top: 1em">Default Parallel port pin
connections <br>
(these can be changed, see the -c option) <br>
Pin number Function <br>
2-5 Vcc (optional power supply to MCU) <br>
7 /RESET (to MCU) <br>
8 SCK (to MCU) <br>
9 MOSI (to MCU) <br>
10 MISO (from MCU) <br>
18-25 GND</p>

<p style="margin-top: 1em">debugWire limitations <br>
The debugWire protocol is Atmel&rsquo;s proprietary one-wire
(plus ground) protocol to allow an in-circuit emulation of
the smaller AVR devices, using the &acirc;/RESET&acirc;
line. DebugWire mode <br>
is initiated by activating the &acirc;DWEN&acirc; fuse, and
then power-cycling the target. While this mode is mainly
intended for debugging/emulation, it also offers limited
programming capa&acirc; <br>
bilities. Effectively, the only memory areas that can be
read or programmed in this mode are flash ROM and EEPROM. It
is also possible to read out the signature. All other
mem&acirc; <br>
ory areas cannot be accessed. There is no chip erase
functionality in debugWire mode; instead, while
reprogramming the flash ROM, each flash ROM page is erased
right before updat&acirc; <br>
ing it. This is done transparently by the JTAG ICE mkII (or
AVR Dragon). The only way back from debugWire mode is to
initiate a special sequence of commands to the JTAG ICE mkII
<br>
(or AVR Dragon), so the debugWire mode will be temporarily
disabled, and the target can be accessed using normal ISP
programming. This sequence is automatically initiated by
using <br>
the JTAG ICE mkII or AVR Dragon in ISP mode, when they
detect that ISP mode cannot be entered.</p>

<p style="margin-top: 1em">FLIP version 1 idiosyncrasies
<br>
Bootloaders using the FLIP protocol version 1 experience
some very specific behaviour.</p>

<p style="margin-top: 1em">These bootloaders have no option
to access memory areas other than Flash and EEPROM.</p>

<p style="margin-top: 1em">When the bootloader is started,
it enters a security mode where the only acceptable access
is to query the device configuration parameters (which are
used for the signature on AVR <br>
devices). The only way to leave this mode is a chip erase.
As a chip erase is normally implied by the -U option when
reprogramming the flash, this peculiarity might not be very
<br>
obvious immediately.</p>

<p style="margin-top: 1em">Sometimes, a bootloader with
security mode already disabled seems to no longer respond
with sensible configuration data, but only 0xFF for all
queries. As these queries are used <br>
to obtain the equivalent of a signature, avrdude can only
continue in that situation by forcing the signature check to
be overridden with the -F option.</p>

<p style="margin-top: 1em">A chip erase might leave the
EEPROM unerased, at least on some versions of the
bootloader.</p>

<p style="margin-top: 1em">Programmers accepting extended
parameters <br>
JTAG ICE mkII</p>

<p style="margin-top: 1em">JTAGICE3</p>

<p style="margin-top: 1em">Atmel-ICE</p>

<p style="margin-top: 1em">AVR Dragon <br>
When using the JTAG ICE mkII, JTAGICE3, Atmel-ICE or AVR
Dragon in JTAG mode, the following extended parameter is
accepted:</p>

<p style="margin-top: 1em">jtagchain=UB,UA,BB,BA <br>
Setup the JTAG scan chain for UB units before, UA units
after, BB bits before, and BA bits after the target AVR,
respectively. Each AVR unit within the <br>
chain shifts by 4 bits. Other JTAG units might require a
different bit shift count.</p>

<p style="margin-top: 1em">AVR910</p>

<p style="margin-top: 1em">devcode=VALUE <br>
Override the device code selection by using VALUE as the
device code. The programmer is not queried for the list of
supported device codes, and the <br>
specified VALUE is not verified but used directly within the
&acirc;T&acirc; command sent to the programmer. VALUE can be
specified using the conventional number <br>
notation of the C programming language.</p>

<p style="margin-top: 1em">no_blockmode <br>
Disables the default checking for block transfer capability.
Use no_blockmode only if your AVR910 programmer creates
errors during initial sequence.</p>

<p style="margin-top: 1em">buspirate</p>

<p style="margin-top: 1em">reset={cs,aux,aux2} <br>
The default setup assumes the BusPirate&rsquo;s CS output
pin connected to the RESET pin on AVR side. It is however
possible to have multiple AVRs connected <br>
to the same BP with MISO, MOSI and SCK lines common for all
of them. In such a case one AVR should have its RESET
connected to BusPirate&rsquo;s CS pin, sec&acirc; <br>
ond AVR&rsquo;s RESET connected to BusPirate&rsquo;s AUX pin
and if your BusPirate has an AUX2 pin (only available on
BusPirate version v1a with firmware 3.0 or <br>
newer) use that to activate RESET on the third AVR.</p>

<p style="margin-top: 1em">It may be a good idea to
decouple the BusPirate and the AVR&rsquo;s SPI buses from
each other using a 3-state bus buffer. For example 74HC125
or 74HC244 are <br>
some good candidates with the latches driven by the
appropriate reset pin (cs, aux or aux2). Otherwise the SPI
traffic in one active circuit may inter&acirc; <br>
fere with programming the AVR in the other design.</p>

<p style="margin-top: 1em">spifreq=&lt;0..7&gt; <br>
The SPI speed for the Bus Pirate&rsquo;s binary SPI
mode:</p>

<p style="margin-top: 1em">0 .. 30 kHz (default) <br>
1 .. 125 kHz <br>
2 .. 250 kHz <br>
3 .. 1 MHz <br>
4 .. 2 MHz <br>
5 .. 2.6 MHz <br>
6 .. 4 MHz <br>
7 .. 8 MHz</p>

<p style="margin-top: 1em">rawfreq=&lt;0..3&gt; <br>
Sets the SPI speed and uses the Bus Pirate&rsquo;s binary
&quot;raw-wire&quot; mode:</p>

<p style="margin-top: 1em">0 .. 5 kHz <br>
1 .. 50 kHz <br>
2 .. 100 kHz (Firmware v4.2+ only) <br>
3 .. 400 kHz (v4.2+)</p>

<p style="margin-top: 1em">The only advantage of the
&quot;raw-wire&quot; mode is the different SPI frequencies
available. Paged writing is not implemented in this
mode.</p>

<p style="margin-top: 1em">ascii Attempt to use ASCII mode
even when the firmware supports BinMode (binary mode).
BinMode is supported in firmware 2.7 and newer, older
FW&rsquo;s either <br>
don&rsquo;t have BinMode or their BinMode is buggy. ASCII
mode is slower and makes the above reset=, spifreq= and
rawfreq= parameters unavailable. Be aware <br>
that ASCII mode is not guaranteed to work with newer
firmware versions, and is retained only to maintain
compatibility with older firmware versions.</p>

<p style="margin-top: 1em">nopagedwrite <br>
Firmware versions 5.10 and newer support a binary mode SPI
command that enables whole pages to be written to AVR flash
memory at once, resulting in a <br>
significant write speed increase. If use of this mode is not
desirable for some reason, this option disables it.</p>

<p style="margin-top: 1em">nopagedread <br>
Newer firmware versions support in binary mode SPI command
some AVR Extended Commands. Using the &quot;Bulk Memory Read
from Flash&quot; results in a significant <br>
read speed increase. If use of this mode is not desirable
for some reason, this option disables it.</p>

<p style="margin-top: 1em">cpufreq=&lt;125..4000&gt; <br>
This sets the AUX pin to output a frequency of n kHz.
Connecting the AUX pin to the XTAL1 pin of your MCU, you can
provide it a clock, for example when <br>
it needs an external clock because of wrong fuses settings.
Make sure the CPU frequency is at least four times the SPI
frequency.</p>


<p style="margin-top: 1em">serial_recv_timeout=&lt;1...&gt;
<br>
This sets the serial receive timeout to the given value. The
timeout happens every time avrdude waits for the BusPirate
prompt. Especially in ascii <br>
mode this happens very often, so setting a smaller value can
speed up programming a lot. The default value is 100ms.
Using 10ms might work in most <br>
cases.</p>

<p style="margin-top: 1em">Wiring When using the Wiring
programmer type, the following optional extended parameter
is accepted:</p>

<p style="margin-top: 1em">snooze=&lt;0..32767&gt; <br>
After performing the port open phase, AVRDUDE will
wait/snooze for snooze milliseconds before continuing to the
protocol sync phase. No toggling of <br>
DTR/RTS is performed if snooze is greater than 0.</p>

<p style="margin-top: 1em">PICkit2 <br>
Connection to the PICkit2 programmer:</p>

<p style="margin-top: 1em">(AVR) (PICkit2) <br>
RST - VPP/MCLR (1) <br>
VDD - VDD Target (2) -- possibly optional if AVR self
powered <br>
GND - GND (3) <br>
MISO - PGD (4) <br>
SCLK - PDC (5) <br>
MOSI - AUX (6)</p>

<p style="margin-top: 1em">Extended commandline
parameters:</p>

<p style="margin-top: 1em">clockrate=&lt;rate&gt; <br>
Sets the SPI clocking rate in Hz (default is 100kHz).
Alternately the -B or -i options can be used to set the
period.</p>


<p style="margin-top: 1em">timeout=&lt;usb-transaction-timeout&gt;
<br>
Sets the timeout for USB reads and writes in milliseconds
(default is 1500 ms).</p>

<p style="margin-top: 1em">FILES <br>
/dev/ppi0 default device to be used for communication with
the programming hardware</p>

<p style="margin-top: 1em">/etc/avrdude.conf <br>
programmer and parts configuration file</p>

<p style="margin-top: 1em">${HOME}/.avrduderc <br>
programmer and parts configuration file (per-user
overrides)</p>

<p style="margin-top: 1em">~/.inputrc Initialization file
for the readline(3) library</p>


<p style="margin-top: 1em">/usr/share/doc/avrdude-doc/avrdude.pdf
<br>
Schematic of programming hardware</p>

<p style="margin-top: 1em">DIAGNOSTICS <br>
avrdude: jtagmkII_setparm(): bad response to set parameter
command: RSP_FAILED <br>
avrdude: jtagmkII_getsync(): ISP activation failed, trying
debugWire <br>
avrdude: Target prepared for ISP, signed off. <br>
avrdude: Please restart avrdude without power-cycling the
target.</p>

<p style="margin-top: 1em">If the target AVR has been set
up for debugWire mode (i. e. the DWEN fuse is programmed),
normal ISP connection attempts will fail as the /RESET pin
is not available. When using <br>
the JTAG ICE mkII in ISP mode, the message shown indicates
that avrdude has guessed this condition, and tried to
initiate a debugWire reset to the target. When successful,
this <br>
will leave the target AVR in a state where it can respond to
normal ISP communication again (until the next power cycle).
Typically, the same command is going to be retried again
<br>
immediately afterwards, and will then succeed connecting to
the target using normal ISP communication.</p>

<p style="margin-top: 1em">SEE ALSO <br>
avr-objcopy(1), ppi(4), libelf(3,) readline(3)</p>

<p style="margin-top: 1em">The AVR microcontroller product
description can be found at</p>


<p style="margin-top: 1em">http://www.atmel.com/products/AVR/</p>

<p style="margin-top: 1em">AUTHORS <br>
Avrdude was written by Brian S. Dean
&lt;bsd@bsdhome.com&gt;.</p>

<p style="margin-top: 1em">This man page by Joerg
Wunsch.</p>

<p style="margin-top: 1em">BUGS <br>
Please report bugs via <br>
http://savannah.nongnu.org/bugs/?group=avrdude.</p>

<p style="margin-top: 1em">The JTAG ICE programmers
currently cannot write to the flash ROM one byte at a time.
For that reason, updating the flash ROM from terminal mode
does not work.</p>

<p style="margin-top: 1em">Page-mode programming the EEPROM
through JTAG (i.e. through an -U option) requires a prior
chip erase. This is an inherent feature of the way JTAG
EEPROM programming works. This <br>
also applies to the STK500 and STK600 in parallel
programming mode.</p>

<p style="margin-top: 1em">The USBasp and USBtinyISP
drivers do not offer any option to distinguish multiple
devices connected simultaneously, so effectively only a
single device is supported.</p>

<p style="margin-top: 1em">The avrftdi driver allows one to
select specific devices using any combination of vid,pid
serial number (usbsn) vendor description (usbvendoror part
description (usbproduct) as <br>
seen with lsusb or whatever tool used to view USB device
information. Multiple devices can be on the bus at the same
time. For the H parts, which have multiple MPSSE interfaces,
<br>
the interface can also be selected. It defaults to interface
&rsquo;A&rsquo;.</p>

<p style="margin-top: 1em">BSD August 27, 2017 BSD</p>
<hr>
</body>
</html>
