<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>AVRDUDE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">AVRDUDE(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">AVRDUDE(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
<b class="Nm" title="Nm">avrdude</b> &#x2014; <span class="Nd" title="Nd">driver
  program for ``simple'' Atmel AVR MCU programmer</span>
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<table class="Nm">
  <tr>
    <td><b class="Nm" title="Nm">avrdude</b></td>
    <td><b class="Fl" title="Fl">-p</b> <var class="Ar" title="Ar">partno</var>
      [<span class="Op"><b class="Fl" title="Fl">-b</b>
      <var class="Ar" title="Ar">baudrate</var></span>]
      [<span class="Op"><b class="Fl" title="Fl">-B</b>
      <var class="Ar" title="Ar">bitclock</var></span>]
      [<span class="Op"><b class="Fl" title="Fl">-c</b>
      <var class="Ar" title="Ar">programmer-id</var></span>]
      [<span class="Op"><b class="Fl" title="Fl">-C</b>
      <var class="Ar" title="Ar">config-file</var></span>]
      [<span class="Op"><b class="Fl" title="Fl">-D</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-e</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-E</b>
      <var class="Ar" title="Ar">exitspec</var>[<span class="Op">,<var class="Ar" title="Ar">exitspec</var></span>]</span>]
      [<span class="Op"><b class="Fl" title="Fl">-F</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-i</b>
      <var class="Ar" title="Ar">delay</var></span>]
      [<span class="Op"><b class="Fl" title="Fl">-n</b>
      <b class="Fl" title="Fl">-logfile</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-n</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-O</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-P</b>
      <var class="Ar" title="Ar">port</var></span>]
      [<span class="Op"><b class="Fl" title="Fl">-q</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-s</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-t</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-u</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-U</b>
      <var class="Ar" title="Ar">memtype:op:filename:filefmt</var></span>]
      [<span class="Op"><b class="Fl" title="Fl">-v</b></span>]
      [<span class="Op"><b class="Fl" title="Fl">-x</b>
      <var class="Ar" title="Ar">extended_param</var></span>]
      [<span class="Op"><b class="Fl" title="Fl">-V</b></span>]</td>
  </tr>
</table>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b class="Nm" title="Nm">Avrdude</b> is a program for downloading code and data
  to Atmel AVR microcontrollers. <b class="Nm" title="Nm">Avrdude</b> supports
  Atmel's STK500 programmer, Atmel's AVRISP and AVRISP mkII devices, Atmel's
  STK600, Atmel's JTAG ICE (mkI, mkII and 3, the latter two also in ISP mode),
  programmers complying to AppNote AVR910 and AVR109 (including the Butterfly),
  as well as a simple hard-wired programmer connected directly to a
  <a class="Xr" title="Xr">ppi(4)</a> or <a class="Xr" title="Xr">parport(4)</a>
  parallel port, or to a standard serial port. In the simplest case, the
  hardware consists just of a cable connecting the respective AVR signal lines
  to the parallel port.
<div class="Pp"></div>
The MCU is programmed in <i class="Em" title="Em">serial programming mode</i>,
  so, for the <a class="Xr" title="Xr">ppi(4)</a> based programmer, the MCU
  signals &#x2018;<code class="Li">/RESET</code>&#x2019;,
  &#x2018;<code class="Li">SCK</code>&#x2019;,
  &#x2018;<code class="Li">MISO</code>&#x2019; and
  &#x2018;<code class="Li">MOSI</code>&#x2019; need to be connected to the
  parallel port. Optionally, some otherwise unused output pins of the parallel
  port can be used to supply power for the MCU part, so it is also possible to
  construct a passive stand-alone programming device. Some status LEDs
  indicating the current operating state of the programmer can be connected, and
  a signal is available to control a buffer/driver IC 74LS367 (or 74HCT367). The
  latter can be useful to decouple the parallel port from the MCU when in-system
  programming is used.
<div class="Pp"></div>
A number of equally simple bit-bang programming adapters that connect to a
  serial port are supported as well, among them the popular Ponyprog serial
  adapter, and the DASA and DASA3 adapters that used to be supported by uisp(1).
  Note that these adapters are meant to be attached to a physical serial port.
  Connecting to a serial port emulated on top of USB is likely to not work at
  all, or to work abysmally slow.
<div class="Pp"></div>
If you happen to have a Linux system with at least 4 hardware GPIOs available
  (like almost all embedded Linux boards) you can do without any additional
  hardware - just connect them to the MOSI, MISO, RESET and SCK pins on the AVR
  and use the linuxgpio programmer type. It bitbangs the lines using the Linux
  sysfs GPIO interface. Of course, care should be taken about voltage level
  compatibility. Also, although not strictrly required, it is strongly advisable
  to protect the GPIO pins from overcurrent situations in some way. The simplest
  would be to just put some resistors in series or better yet use a 3-state
  buffer driver like the 74HC244. Have a look at
  http://kolev.info/avrdude-linuxgpio for a more detailed tutorial about using
  this programmer type.
<div class="Pp"></div>
Atmel's STK500 programmer is also supported and connects to a serial port. Both,
  firmware versions 1.x and 2.x can be handled, but require a different
  programmer type specification (by now). Using firmware version 2, high-voltage
  programming is also supported, both parallel and serial (programmer types
  stk500pp and stk500hvsp).
<div class="Pp"></div>
Wiring boards are supported, utilizing STK500 V2.x protocol, but a simple
  DTR/RTS toggle is used to set the boards into programming mode. The programmer
  type is ``wiring''.
<div class="Pp"></div>
The Arduino (which is very similar to the STK500 1.x) is supported via its own
  programmer type specification ``arduino''.
<div class="Pp"></div>
The BusPirate is a versatile tool that can also be used as an AVR programmer. A
  single BusPirate can be connected to up to 3 independent AVRs. See the section
  on <i class="Em" title="Em">extended parameters</i> below for details.
<div class="Pp"></div>
Atmel's STK600 programmer is supported in ISP and high-voltage programming
  modes, and connects through the USB. For ATxmega devices, the STK600 is
  supported in PDI mode. For ATtiny4/5/9/10 devices, the STK600 and AVRISP mkII
  are supported in TPI mode.
<div class="Pp"></div>
The simple serial programmer described in Atmel's application note AVR910, and
  the bootloader described in Atmel's application note AVR109 (which is also
  used by the AVR Butterfly evaluation board), are supported on a serial port.
<div class="Pp"></div>
Atmel's JTAG ICE (mkI, mkII, and 3) is supported as well to up- or download
  memory areas from/to an AVR target (no support for on-chip debugging). For the
  JTAG ICE mkII, JTAG, debugWire and ISP mode are supported, provided it has a
  firmware revision of at least 4.14 (decimal). JTAGICE3 also supports all of
  JTAG, debugWIRE, and ISP mode. See below for the limitations of debugWire. For
  ATxmega devices, the JTAG ICE mkII is supported in PDI mode, provided it has a
  revision 1 hardware and firmware version of at least 5.37 (decimal). For
  ATxmega devices, the JTAGICE3 is supported in PDI mode.
<div class="Pp"></div>
Atmel-ICE (ARM/AVR) is supported in all modes (JTAG, PDI for Xmega, debugWIRE,
  ISP).
<div class="Pp"></div>
Atmel's XplainedPro boards, using the EDBG protocol (CMSIS-DAP compatible), are
  supported using the &quot;jtag3&quot; programmer type.
<div class="Pp"></div>
Atmel's XplainedMini boards, using the mEDBG protocol, are also supported using
  the &quot;jtag3&quot; programmer type.
<div class="Pp"></div>
The AVR Dragon is supported in all modes (ISP, JTAG, HVSP, PP, debugWire). When
  used in JTAG and debugWire mode, the AVR Dragon behaves similar to a JTAG ICE
  mkII, so all device-specific comments for that device will apply as well. When
  used in ISP mode, the AVR Dragon behaves similar to an AVRISP mkII (or JTAG
  ICE mkII in ISP mode), so all device-specific comments will apply there. In
  particular, the Dragon starts out with a rather fast ISP clock frequency, so
  the <b class="Fl" title="Fl">-B</b> <var class="Ar" title="Ar">bitclock</var>
  option might be required to achieve a stable ISP communication. For ATxmega
  devices, the AVR Dragon is supported in PDI mode, provided it has a firmware
  version of at least 6.11 (decimal).
<div class="Pp"></div>
The avrftdi, USBasp ISP and USBtinyISP adapters are also supported, provided
  <b class="Nm" title="Nm">avrdude</b> has been compiled with libusb support.
  USBasp ISP and USBtinyISP both feature simple firmware-only USB
  implementations, running on an ATmega8 (or ATmega88), or ATtiny2313,
  respectively. If libftdi has has been compiled in
  <b class="Nm" title="Nm">avrdude</b>, the avrftdi device adds support for many
  programmers using FTDI's 2232C/D/H and 4232H parts running in MPSSE mode,
  which hard-codes (in the chip) SCK to bit 1, MOSI to bit 2, and MISO to bit 3.
  Reset is usually bit 4.
<div class="Pp"></div>
The Atmel DFU bootloader is supported in both, FLIP protocol version 1 (AT90USB*
  and ATmega*U* devices), as well as version 2 (Xmega devices). See below for
  some hints about FLIP version 1 protocol behaviour.
<div class="Pp"></div>
Input files can be provided, and output files can be written in different file
  formats, such as raw binary files containing the data to download to the chip,
  Intel hex format, or Motorola S-record format. There are a number of tools
  available to produce those files, like <a class="Xr" title="Xr">asl(1)</a> as
  a standalone assembler, or <a class="Xr" title="Xr">avr-objcopy(1)</a> for the
  final stage of the GNU toolchain for the AVR microcontroller.
<div class="Pp"></div>
Provided <a class="Xr" title="Xr">libelf(3)</a> was present when compiling
  <b class="Nm" title="Nm">avrdude</b>, the input file can also be the final ELF
  file as produced by the linker. The appropriate ELF section(s) will be
  examined, according to the memory area to write to.
<div class="Pp"></div>
<b class="Nm" title="Nm">Avrdude</b> can program the EEPROM and flash ROM memory
  cells of supported AVR parts. Where supported by the serial instruction set,
  fuse bits and lock bits can be programmed as well. These are implemented
  within <b class="Nm" title="Nm">avrdude</b> as separate memory types and can
  be programmed using data from a file (see the <b class="Fl" title="Fl">-m</b>
  option) or from terminal mode (see the <var class="Ar" title="Ar">dump</var>
  and <var class="Ar" title="Ar">write</var> commands). It is also possible to
  read the chip (provided it has not been code-protected previously, of course)
  and store the data in a file. Finally, a ``terminal'' mode is available that
  allows one to interactively communicate with the MCU, and to display or
  program individual memory cells. On the STK500 and STK600 programmer, several
  operational parameters (target supply voltage, target Aref voltage, master
  clock) can be examined and changed from within terminal mode as well.
<h2 class="Ss" title="Ss" id="Options"><a class="selflink" href="#Options">Options</a></h2>
In order to control all the different operation modi, a number of options need
  to be specified to <b class="Nm" title="Nm">avrdude</b>.
<div class="Bl-tag" style="margin-left: 6.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><a class="selflink" href="#p"><b class="Fl" title="Fl" id="p">-p</b></a>
    <var class="Ar" title="Ar">partno</var></dt>
  <dd class="It-tag">This is the only option that is mandatory for every
      invocation of <b class="Nm" title="Nm">avrdude</b>. It specifies the type
      of the MCU connected to the programmer. These are read from the config
      file. For currently supported MCU types use ? as partno, this will print a
      list of partno ids and official part names on the terminal. (Both can be
      used with the -p option.)
    <div class="Pp"></div>
    Following parts need special attention:
    <dl class="Bl-tag" style="margin-left: 15.00ex;">
      <dt class="It-tag" style="margin-left: -15.00ex;">AT90S1200</dt>
      <dd class="It-tag">The ISP programming protocol of the AT90S1200 differs
          in subtle ways from that of other AVRs. Thus, not all programmers
          support this device. Known to work are all direct bitbang programmers,
          and all programmers talking the STK500v2 protocol.</dd>
      <dt class="It-tag" style="margin-left: -15.00ex;">AT90S2343</dt>
      <dd class="It-tag">The AT90S2323 and ATtiny22 use the same algorithm.</dd>
      <dt class="It-tag" style="margin-left: -15.00ex;">ATmega2560,
        ATmega2561</dt>
      <dd class="It-tag">Flash addressing above 128 KB is not supported by all
          programming hardware. Known to work are jtag2, stk500v2, and bit-bang
          programmers.</dd>
      <dt class="It-tag" style="margin-left: -15.00ex;">ATtiny11</dt>
      <dd class="It-tag">The ATtiny11 can only be programmed in high-voltage
          serial mode.</dd>
    </dl>
  </dd>
  <dt class="It-tag"><a class="selflink" href="#b"><b class="Fl" title="Fl" id="b">-b</b></a>
    <var class="Ar" title="Ar">baudrate</var></dt>
  <dd class="It-tag">Override the RS-232 connection baud rate specified in the
      respective programmer's entry of the configuration file.</dd>
  <dt class="It-tag"><a class="selflink" href="#B"><b class="Fl" title="Fl" id="B">-B</b></a>
    <var class="Ar" title="Ar">bitclock</var></dt>
  <dd class="It-tag">Specify the bit clock period for the JTAG interface or the
      ISP clock (JTAG ICE only). The value is a floating-point number in
      microseconds. Alternatively, the value might be suffixed with
      &quot;Hz&quot;, &quot;kHz&quot;, or &quot;MHz&quot;, in order to specify
      the bit clock frequency, rather than a period. The default value of the
      JTAG ICE results in about 1 microsecond bit clock period, suitable for
      target MCUs running at 4 MHz clock and above. Unlike certain parameters in
      the STK500, the JTAG ICE resets all its parameters to default values when
      the programming software signs off from the ICE, so for MCUs running at
      lower clock speeds, this parameter must be specified on the command-line.
      You can use the 'default_bitclock' keyword in your
      <i class="Pa" title="Pa">${HOME}/.avrduderc</i> file to assign a default
      value to keep from having to specify this option on every invocation.</dd>
  <dt class="It-tag"><a class="selflink" href="#c"><b class="Fl" title="Fl" id="c">-c</b></a>
    <var class="Ar" title="Ar">programmer-id</var></dt>
  <dd class="It-tag">Use the programmer specified by the argument. Programmers
      and their pin configurations are read from the config file (see the
      <b class="Fl" title="Fl">-C</b> option). New pin configurations can be
      easily added or modified through the use of a config file to make
      <b class="Nm" title="Nm">avrdude</b> work with different programmers as
      long as the programmer supports the Atmel AVR serial program method. You
      can use the 'default_programmer' keyword in your
      <i class="Pa" title="Pa">${HOME}/.avrduderc</i> file to assign a default
      programmer to keep from having to specify this option on every invocation.
      A full list of all supported programmers is output to the terminal by
      using ? as programmer-id.</dd>
  <dt class="It-tag"><a class="selflink" href="#C"><b class="Fl" title="Fl" id="C">-C</b></a>
    <var class="Ar" title="Ar">config-file</var></dt>
  <dd class="It-tag">Use the specified config file to load configuration data.
      This file contains all programmer and part definitions that
      <b class="Nm" title="Nm">avrdude</b> knows about. See the config file,
      located at <i class="Pa" title="Pa">/etc/avrdude.conf</i>, which contains
      a description of the format.
    <div class="Pp"></div>
    If <var class="Ar" title="Ar">config-file</var> is written as
      <i class="Pa" title="Pa">+filename</i> then this file is read after the
      system wide and user configuration files. This can be used to add entries
      to the configuration without patching your system wide configuration file.
      It can be used several times, the files are read in same order as given on
      the command line.</dd>
  <dt class="It-tag"><a class="selflink" href="#D"><b class="Fl" title="Fl" id="D">-D</b></a></dt>
  <dd class="It-tag">Disable auto erase for flash. When the
      <b class="Fl" title="Fl">-U</b> option with flash memory is specified,
      <b class="Nm" title="Nm">avrdude</b> will perform a chip erase before
      starting any of the programming operations, since it generally is a
      mistake to program the flash without performing an erase first. This
      option disables that. Auto erase is not used for ATxmega devices as these
      devices can use page erase before writing each page so no explicit chip
      erase is required. Note however that any page not affected by the current
      operation will retain its previous contents.</dd>
  <dt class="It-tag"><a class="selflink" href="#e"><b class="Fl" title="Fl" id="e">-e</b></a></dt>
  <dd class="It-tag">Causes a chip erase to be executed. This will reset the
      contents of the flash ROM and EEPROM to the value
      &#x2018;<code class="Li">0xff</code>&#x2019;, and clear all lock bits.
      Except for ATxmega devices which can use page erase, it is basically a
      prerequisite command before the flash ROM can be reprogrammed again. The
      only exception would be if the new contents would exclusively cause bits
      to be programmed from the value &#x2018;<code class="Li">1</code>&#x2019;
      to &#x2018;<code class="Li">0</code>&#x2019;. Note that in order to
      reprogram EERPOM cells, no explicit prior chip erase is required since the
      MCU provides an auto-erase cycle in that case before programming the
    cell.</dd>
  <dt class="It-tag"><a class="selflink" href="#E"><b class="Fl" title="Fl" id="E">-E</b></a>
    <var class="Ar" title="Ar">exitspec</var>[<span class="Op">,<var class="Ar" title="Ar">exitspec</var></span>]</dt>
  <dd class="It-tag">By default, <b class="Nm" title="Nm">avrdude</b> leaves the
      parallel port in the same state at exit as it has been found at startup.
      This option modifies the state of the
      &#x2018;<code class="Li">/RESET</code>&#x2019; and
      &#x2018;<code class="Li">Vcc</code>&#x2019; lines the parallel port is
      left at, according to the <var class="Ar" title="Ar">exitspec</var>
      arguments provided, as follows:
    <dl class="Bl-tag" style="margin-left: 11.40ex;">
      <dt class="It-tag" style="margin-left: -11.40ex;"><var class="Ar" title="Ar">reset</var></dt>
      <dd class="It-tag">The &#x2018;<code class="Li">/RESET</code>&#x2019;
          signal will be left activated at program exit, that is it will be held
          <i class="Em" title="Em">low</i>, in order to keep the MCU in reset
          state afterwards. Note in particular that the programming algorithm
          for the AT90S1200 device mandates that the
          &#x2018;<code class="Li">/RESET</code>&#x2019; signal is active
          <i class="Em" title="Em">before</i> powering up the MCU, so in case an
          external power supply is used for this MCU type, a previous invocation
          of <b class="Nm" title="Nm">avrdude</b> with this option specified is
          one of the possible ways to guarantee this condition.</dd>
      <dt class="It-tag" style="margin-left: -11.40ex;"><var class="Ar" title="Ar">noreset</var></dt>
      <dd class="It-tag">The &#x2018;<code class="Li">/RESET</code>&#x2019; line
          will be deactivated at program exit, thus allowing the MCU target
          program to run while the programming hardware remains connected.</dd>
      <dt class="It-tag" style="margin-left: -11.40ex;"><var class="Ar" title="Ar">vcc</var></dt>
      <dd class="It-tag">This option will leave those parallel port pins active
          (i. e. <i class="Em" title="Em">high</i>) that can be used to supply
          &#x2018;<code class="Li">Vcc</code>&#x2019; power to the MCU.</dd>
      <dt class="It-tag" style="margin-left: -11.40ex;"><var class="Ar" title="Ar">novcc</var></dt>
      <dd class="It-tag">This option will pull the
          &#x2018;<code class="Li">Vcc</code>&#x2019; pins of the parallel port
          down at program exit.</dd>
      <dt class="It-tag" style="margin-left: -11.40ex;"><var class="Ar" title="Ar">d_high</var></dt>
      <dd class="It-tag">This option will leave the 8 data pins on the parallel
          port active. (i. e. <i class="Em" title="Em">high</i>)</dd>
      <dt class="It-tag" style="margin-left: -11.40ex;"><var class="Ar" title="Ar">d_low</var></dt>
      <dd class="It-tag">This option will leave the 8 data pins on the parallel
          port inactive. (i. e. <i class="Em" title="Em">low</i>)</dd>
    </dl>
    <div class="Pp"></div>
    Multiple <var class="Ar" title="Ar">exitspec</var> arguments can be
      separated with commas.</dd>
  <dt class="It-tag"><a class="selflink" href="#F"><b class="Fl" title="Fl" id="F">-F</b></a></dt>
  <dd class="It-tag">Normally, <b class="Nm" title="Nm">avrdude</b> tries to
      verify that the device signature read from the part is reasonable before
      continuing. Since it can happen from time to time that a device has a
      broken (erased or overwritten) device signature but is otherwise operating
      normally, this options is provided to override the check. Also, for
      programmers like the Atmel STK500 and STK600 which can adjust parameters
      local to the programming tool (independent of an actual connection to a
      target controller), this option can be used together with
      <b class="Fl" title="Fl">-t</b> to continue in terminal mode.</dd>
  <dt class="It-tag"><a class="selflink" href="#i"><b class="Fl" title="Fl" id="i">-i</b></a>
    <var class="Ar" title="Ar">delay</var></dt>
  <dd class="It-tag">For bitbang-type programmers, delay for approximately
      <var class="Ar" title="Ar">delay</var> microseconds between each bit state
      change. If the host system is very fast, or the target runs off a slow
      clock (like a 32 kHz crystal, or the 128 kHz internal RC oscillator), this
      can become necessary to satisfy the requirement that the ISP clock
      frequency must not be higher than 1/4 of the CPU clock frequency. This is
      implemented as a spin-loop delay to allow even for very short delays. On
      Unix-style operating systems, the spin loop is initially calibrated
      against a system timer, so the number of microseconds might be rather
      realistic, assuming a constant system load while
      <b class="Nm" title="Nm">avrdude</b> is running. On Win32 operating
      systems, a preconfigured number of cycles per microsecond is assumed that
      might be off a bit for very fast or very slow machines.</dd>
  <dt class="It-tag"><a class="selflink" href="#l"><b class="Fl" title="Fl" id="l">-l</b></a>
    <var class="Ar" title="Ar">logfile</var></dt>
  <dd class="It-tag">Use <var class="Ar" title="Ar">logfile</var> rather than
      <var class="Va" title="Va">stderr</var> for diagnostics output. Note that
      initial diagnostic messages (during option parsing) are still written to
      <var class="Va" title="Va">stderr</var> anyway.</dd>
  <dt class="It-tag"><a class="selflink" href="#n"><b class="Fl" title="Fl" id="n">-n</b></a></dt>
  <dd class="It-tag">No-write - disables actually writing data to the MCU
      (useful for debugging <b class="Nm" title="Nm">avrdude</b> ).</dd>
  <dt class="It-tag"><a class="selflink" href="#O"><b class="Fl" title="Fl" id="O">-O</b></a></dt>
  <dd class="It-tag">Perform a RC oscillator run-time calibration according to
      Atmel application note AVR053. This is only supported on the STK500v2,
      AVRISP mkII, and JTAG ICE mkII hardware. Note that the result will be
      stored in the EEPROM cell at address 0.</dd>
  <dt class="It-tag"><a class="selflink" href="#P"><b class="Fl" title="Fl" id="P">-P</b></a>
    <var class="Ar" title="Ar">port</var></dt>
  <dd class="It-tag">Use <var class="Ar" title="Ar">port</var> to identify the
      device to which the programmer is attached. By default the
      <i class="Pa" title="Pa">/dev/ppi0</i> port is used, but if the programmer
      type normally connects to the serial port, the
      <i class="Pa" title="Pa">/dev/cuaa0</i> port is the default. If you need
      to use a different parallel or serial port, use this option to specify the
      alternate port name.
    <div class="Pp"></div>
    On Win32 operating systems, the parallel ports are referred to as lpt1
      through lpt3, referring to the addresses 0x378, 0x278, and 0x3BC,
      respectively. If the parallel port can be accessed through a different
      address, this address can be specified directly, using the common C
      language notation (i. e., hexadecimal values are prefixed by
      &#x2018;<code class="Li">0x</code>&#x2019; ).
    <div class="Pp"></div>
    For the JTAG ICE mkII and JTAGICE3, if <b class="Nm" title="Nm">avrdude</b>
      has been configured with libusb support,
      <var class="Ar" title="Ar">port</var> can alternatively be specified as
      <i class="Pa" title="Pa">usb</i>[<span class="Op">:<var class="Ar" title="Ar">serialno</var></span>].
      This will cause <b class="Nm" title="Nm">avrdude</b> to search the
      programmer on USB. If <var class="Ar" title="Ar">serialno</var> is also
      specified, it will be matched against the serial number read from any JTAG
      ICE mkII found on USB. The match is done after stripping any existing
      colons from the given serial number, and right-to-left, so only the least
      significant bytes from the serial number need to be given.
    <div class="Pp"></div>
    As the AVRISP mkII device can only be talked to over USB, the very same
      method of specifying the port is required there.
    <div class="Pp"></div>
    For the USB programmer &quot;AVR-Doper&quot; running in HID mode, the port
      must be specified as <var class="Ar" title="Ar">avrdoper.</var> Libusb
      support is required on Unix but not on Windows. For more information about
      AVR-Doper see http://www.obdev.at/avrusb/avrdoper.html.
    <div class="Pp"></div>
    For the USBtinyISP, which is a simplicistic device not implementing serial
      numbers, multiple devices can be distinguished by their location in the
      USB hierarchy. See the the respective
      <i class="Em" title="Em">Troubleshooting</i> entry in the detailed
      documentation for examples.
    <div class="Pp"></div>
    For programmers that attach to a serial port using some kind of higher level
      protocol (as opposed to bit-bang style programmers),
      <var class="Ar" title="Ar">port</var> can be specified as
      <i class="Pa" title="Pa">net</i>:<var class="Ar" title="Ar">host</var>:<var class="Ar" title="Ar">port</var>.
      In this case, instead of trying to open a local device, a TCP network
      connection to (TCP) <var class="Ar" title="Ar">port</var> on
      <var class="Ar" title="Ar">host</var> is established. The remote endpoint
      is assumed to be a terminal or console server that connects the network
      stream to a local serial port where the actual programmer has been
      attached to. The port is assumed to be properly configured, for example
      using a transparent 8-bit data connection without parity at 115200 Baud
      for a STK500.</dd>
  <dt class="It-tag"><a class="selflink" href="#q"><b class="Fl" title="Fl" id="q">-q</b></a></dt>
  <dd class="It-tag">Disable (or quell) output of the progress bar while reading
      or writing to the device. Specify it a second time for even quieter
      operation.</dd>
  <dt class="It-tag"><a class="selflink" href="#s"><b class="Fl" title="Fl" id="s">-s</b></a></dt>
  <dd class="It-tag">Disable safemode prompting. When safemode discovers that
      one or more fuse bits have unintentionally changed, it will prompt for
      confirmation regarding whether or not it should attempt to recover the
      fuse bit(s). Specifying this flag disables the prompt and assumes that the
      fuse bit(s) should be recovered without asking for confirmation
    first.</dd>
  <dt class="It-tag"><a class="selflink" href="#t"><b class="Fl" title="Fl" id="t">-t</b></a></dt>
  <dd class="It-tag">Tells <b class="Nm" title="Nm">avrdude</b> to enter the
      interactive ``terminal'' mode instead of up- or downloading files. See
      below for a detailed description of the terminal mode.</dd>
  <dt class="It-tag"><a class="selflink" href="#u"><b class="Fl" title="Fl" id="u">-u</b></a></dt>
  <dd class="It-tag">Disable the safemode fuse bit checks. Safemode is enabled
      by default and is intended to prevent unintentional fuse bit changes. When
      enabled, safemode will issue a warning if the any fuse bits are found to
      be different at program exit than they were when
      <b class="Nm" title="Nm">avrdude</b> was invoked. Safemode won't alter
      fuse bits itself, but rather will prompt for instructions, unless the
      terminal is non-interactive, in which case safemode is disabled. See the
      <b class="Fl" title="Fl">-s</b> option to disable safemode prompting.
    <div class="Pp"></div>
    If one of the configuration files has a line
    <div class="D1"><code class="Li">default_safemode = no;</code></div>
    safemode is disabled by default. The <b class="Fl" title="Fl">-u</b>
      option's effect is negated in that case, i. e. it
      <i class="Em" title="Em">enables</i> safemode.
    <div class="Pp"></div>
    Safemode is always disabled for AVR32, Xmega and TPI devices.</dd>
  <dt class="It-tag"><a class="selflink" href="#U"><b class="Fl" title="Fl" id="U">-U</b></a>
    <var class="Ar" title="Ar">memtype</var><var class="Ar" title="Ar">:</var><var class="Ar" title="Ar">op</var><var class="Ar" title="Ar">:</var><var class="Ar" title="Ar">filename</var>[<span class="Op">:<var class="Ar" title="Ar">format</var></span>]</dt>
  <dd class="It-tag">Perform a memory operation as indicated. The
      <var class="Ar" title="Ar">memtype</var> field specifies the memory type
      to operate on. The available memory types are device-dependent, the actual
      configuration can be viewed with the <b class="Cm" title="Cm">part</b>
      command in terminal mode. Typically, a device's memory configuration at
      least contains the memory types <var class="Ar" title="Ar">flash</var> and
      <var class="Ar" title="Ar">eeprom</var>. All memory types currently known
      are:
    <dl class="Bl-tag Bl-compact" style="margin-left: 16.20ex;">
      <dt class="It-tag" style="margin-left: -16.20ex;">calibration</dt>
      <dd class="It-tag">One or more bytes of RC oscillator calibration
        data.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">eeprom</dt>
      <dd class="It-tag">The EEPROM of the device.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">efuse</dt>
      <dd class="It-tag">The extended fuse byte.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">flash</dt>
      <dd class="It-tag">The flash ROM of the device.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">fuse</dt>
      <dd class="It-tag">The fuse byte in devices that have only a single fuse
          byte.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">hfuse</dt>
      <dd class="It-tag">The high fuse byte.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">lfuse</dt>
      <dd class="It-tag">The low fuse byte.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">lock</dt>
      <dd class="It-tag">The lock byte.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">signature</dt>
      <dd class="It-tag">The three device signature bytes (device ID).</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">fuse<i class="Em" title="Em">N</i></dt>
      <dd class="It-tag">The fuse bytes of ATxmega devices,
          <i class="Em" title="Em">N</i> is an integer number for each fuse
          supported by the device.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">application</dt>
      <dd class="It-tag">The application flash area of ATxmega devices.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">apptable</dt>
      <dd class="It-tag">The application table flash area of ATxmega
        devices.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">boot</dt>
      <dd class="It-tag">The boot flash area of ATxmega devices.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">prodsig</dt>
      <dd class="It-tag">The production signature (calibration) area of ATxmega
          devices.</dd>
      <dt class="It-tag" style="margin-left: -16.20ex;">usersig</dt>
      <dd class="It-tag">The user signature area of ATxmega devices.</dd>
    </dl>
    <div class="Pp"></div>
    The <var class="Ar" title="Ar">op</var> field specifies what operation to
      perform:
    <dl class="Bl-tag" style="margin-left: 11.40ex;">
      <dt class="It-tag" style="margin-left: -11.40ex;"><var class="Ar" title="Ar">r</var></dt>
      <dd class="It-tag">read device memory and write to the specified file</dd>
      <dt class="It-tag" style="margin-left: -11.40ex;"><var class="Ar" title="Ar">w</var></dt>
      <dd class="It-tag">read data from the specified file and write to the
          device memory</dd>
      <dt class="It-tag" style="margin-left: -11.40ex;"><var class="Ar" title="Ar">v</var></dt>
      <dd class="It-tag">read data from both the device and the specified file
          and perform a verify</dd>
    </dl>
    <div class="Pp"></div>
    The <var class="Ar" title="Ar">filename</var> field indicates the name of
      the file to read or write. The <var class="Ar" title="Ar">format</var>
      field is optional and contains the format of the file to read or write.
      <var class="Ar" title="Ar">Format</var> can be one of:
    <dl class="Bl-tag" style="margin-left: 6.60ex;">
      <dt class="It-tag" style="margin-left: -6.60ex;"><var class="Ar" title="Ar">i</var></dt>
      <dd class="It-tag">Intel Hex</dd>
      <dt class="It-tag" style="margin-left: -6.60ex;"><var class="Ar" title="Ar">s</var></dt>
      <dd class="It-tag">Motorola S-record</dd>
      <dt class="It-tag" style="margin-left: -6.60ex;"><var class="Ar" title="Ar">r</var></dt>
      <dd class="It-tag">raw binary; little-endian byte order, in the case of
          the flash ROM data</dd>
      <dt class="It-tag" style="margin-left: -6.60ex;"><var class="Ar" title="Ar">e</var></dt>
      <dd class="It-tag">ELF (Executable and Linkable Format)</dd>
      <dt class="It-tag" style="margin-left: -6.60ex;"><var class="Ar" title="Ar">m</var></dt>
      <dd class="It-tag">immediate; actual byte values specified on the command
          line, separated by commas or spaces. This is good for programming fuse
          bytes without having to create a single-byte file or enter terminal
          mode.</dd>
      <dt class="It-tag" style="margin-left: -6.60ex;"><var class="Ar" title="Ar">a</var></dt>
      <dd class="It-tag">auto detect; valid for input only, and only if the
          input is not provided at <i class="Em" title="Em">stdin</i>.</dd>
      <dt class="It-tag" style="margin-left: -6.60ex;"><var class="Ar" title="Ar">d</var></dt>
      <dd class="It-tag">decimal; this and the following formats are only valid
          on output. They generate one line of output for the respective memory
          section, forming a comma-separated list of the values. This can be
          particularly useful for subsequent processing, like for fuse bit
          settings.</dd>
      <dt class="It-tag" style="margin-left: -6.60ex;"><var class="Ar" title="Ar">h</var></dt>
      <dd class="It-tag">hexadecimal; each value will get the string
          <i class="Em" title="Em">0x</i> prepended.</dd>
      <dt class="It-tag" style="margin-left: -6.60ex;"><var class="Ar" title="Ar">o</var></dt>
      <dd class="It-tag">octal; each value will get a
          <i class="Em" title="Em">0</i> prepended unless it is less than 8 in
          which case it gets no prefix.</dd>
      <dt class="It-tag" style="margin-left: -6.60ex;"><var class="Ar" title="Ar">b</var></dt>
      <dd class="It-tag">binary; each value will get the string
          <i class="Em" title="Em">0b</i> prepended.</dd>
    </dl>
    <div class="Pp"></div>
    The default is to use auto detection for input files, and raw binary format
      for output files. Note that if <var class="Ar" title="Ar">filename</var>
      contains a colon, the <var class="Ar" title="Ar">format</var> field is no
      longer optional since the filename part following the colon would
      otherwise be misinterpreted as <var class="Ar" title="Ar">format</var>.
    <div class="Pp"></div>
    When reading any kind of flash memory area (including the various sub-areas
      in Xmega devices), the resulting output file will be truncated to not
      contain trailing 0xFF bytes which indicate unprogrammed (erased) memory.
      Thus, if the entire memory is unprogrammed, this will result in an output
      file that has no contents at all.
    <div class="Pp"></div>
    As an abbreviation, the form <b class="Fl" title="Fl">-U</b>
      <var class="Ar" title="Ar">filename</var> is equivalent to specifying
      <b class="Fl" title="Fl">-U</b>
      <i class="Em" title="Em">flash:w:</i><var class="Ar" title="Ar">filename</var>:a.
      This will only work if <var class="Ar" title="Ar">filename</var> does not
      have a colon in it.</dd>
  <dt class="It-tag"><a class="selflink" href="#v"><b class="Fl" title="Fl" id="v">-v</b></a></dt>
  <dd class="It-tag">Enable verbose output. More <b class="Fl" title="Fl">-v</b>
      options increase verbosity level.</dd>
  <dt class="It-tag"><a class="selflink" href="#V"><b class="Fl" title="Fl" id="V">-V</b></a></dt>
  <dd class="It-tag">Disable automatic verify check when uploading data.</dd>
  <dt class="It-tag"><a class="selflink" href="#x"><b class="Fl" title="Fl" id="x">-x</b></a>
    <var class="Ar" title="Ar">extended_param</var></dt>
  <dd class="It-tag">Pass <var class="Ar" title="Ar">extended_param</var> to the
      chosen programmer implementation as an extended parameter. The
      interpretation of the extended parameter depends on the programmer itself.
      See below for a list of programmers accepting extended parameters.</dd>
</dl>
</div>
<h2 class="Ss" title="Ss" id="Terminal_mode"><a class="selflink" href="#Terminal_mode">Terminal
  mode</a></h2>
In this mode, <b class="Nm" title="Nm">avrdude</b> only initializes
  communication with the MCU, and then awaits user commands on standard input.
  Commands and parameters may be abbreviated to the shortest unambiguous form.
  Terminal mode provides a command history using
  <a class="Xr" title="Xr">readline(3)</a>, so previously entered command lines
  can be recalled and edited. The following commands are currently implemented:
<div class="Bl-tag" style="margin-left: 6.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><var class="Ar" title="Ar">dump memtype addr
    nbytes</var></dt>
  <dd class="It-tag">Read <var class="Ar" title="Ar">nbytes</var> bytes from the
      specified memory area, and display them in the usual hexadecimal and ASCII
      form.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">dump</var></dt>
  <dd class="It-tag">Continue dumping the memory contents for another
      <var class="Ar" title="Ar">nbytes</var> where the previous
      <var class="Ar" title="Ar">dump</var> command left off.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">write memtype addr byte1 ...
    byteN</var></dt>
  <dd class="It-tag">Manually program the respective memory cells, starting at
      address <var class="Ar" title="Ar">addr</var>, using the values
      <var class="Ar" title="Ar">byte1</var> through
      <var class="Ar" title="Ar">byteN</var>. This feature is not implemented
      for bank-addressed memories such as the flash memory of ATMega
    devices.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">erase</var></dt>
  <dd class="It-tag">Perform a chip erase.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">send b1 b2 b3 b4</var></dt>
  <dd class="It-tag">Send raw instruction codes to the AVR device. If you need
      access to a feature of an AVR part that is not directly supported by
      <b class="Nm" title="Nm">avrdude</b>, this command allows you to use it,
      even though <b class="Nm" title="Nm">avrdude</b> does not implement the
      command. When using direct SPI mode, up to 3 bytes can be omitted.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">sig</var></dt>
  <dd class="It-tag">Display the device signature bytes.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">spi</var></dt>
  <dd class="It-tag">Enter direct SPI mode. The
      <i class="Em" title="Em">pgmled</i> pin acts as slave select.
      <i class="Em" title="Em">Only supported on parallel bitbang
      programmers.</i></dd>
  <dt class="It-tag"><var class="Ar" title="Ar">part</var></dt>
  <dd class="It-tag">Display the current part settings and parameters. Includes
      chip specific information including all memory types supported by the
      device, read/write timing, etc.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">pgm</var></dt>
  <dd class="It-tag">Return to programming mode (from direct SPI mode).</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">vtarg voltage</var></dt>
  <dd class="It-tag">Set the target's supply voltage to
      <var class="Ar" title="Ar">voltage</var> Volts.
      <i class="Em" title="Em">Only supported on the STK500 and STK600
      programmer.</i></dd>
  <dt class="It-tag"><var class="Ar" title="Ar">varef</var>
    [<span class="Op"><var class="Ar" title="Ar">channel</var></span>]
    <var class="Ar" title="Ar">voltage</var></dt>
  <dd class="It-tag">Set the adjustable voltage source to
      <var class="Ar" title="Ar">voltage</var> Volts. This voltage is normally
      used to drive the target's <i class="Em" title="Em">Aref</i> input on the
      STK500. On the Atmel STK600, two reference voltages are available, which
      can be selected by the optional <var class="Ar" title="Ar">channel</var>
      argument (either 0 or 1). <i class="Em" title="Em">Only supported on the
      STK500 and STK600 programmer.</i></dd>
  <dt class="It-tag"><var class="Ar" title="Ar">fosc
    freq</var>[<span class="Op">M|k</span>]</dt>
  <dd class="It-tag">Set the master oscillator to
      <var class="Ar" title="Ar">freq</var> Hz. An optional trailing letter
      <var class="Ar" title="Ar">M</var> multiplies by 1E6, a trailing letter
      <var class="Ar" title="Ar">k</var> by 1E3. <i class="Em" title="Em">Only
      supported on the STK500 and STK600 programmer.</i></dd>
  <dt class="It-tag"><var class="Ar" title="Ar">fosc off</var></dt>
  <dd class="It-tag">Turn the master oscillator off.
      <i class="Em" title="Em">Only supported on the STK500 and STK600
      programmer.</i></dd>
  <dt class="It-tag"><var class="Ar" title="Ar">sck period</var></dt>
  <dd class="It-tag"><i class="Em" title="Em">STK500 and STK600 programmer
      only:</i> Set the SCK clock period to
      <var class="Ar" title="Ar">period</var> microseconds.
    <div class="Pp"></div>
    <i class="Em" title="Em">JTAG ICE only:</i> Set the JTAG ICE bit clock
      period to <var class="Ar" title="Ar">period</var> microseconds. Note that
      unlike STK500 settings, this setting will be reverted to its default value
      (approximately 1 microsecond) when the programming software signs off from
      the JTAG ICE. This parameter can also be used on the JTAG ICE mkII,
      JTAGICE3, and Atmel-ICE to specify the ISP clock period when operating the
      ICE in ISP mode.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">parms</var></dt>
  <dd class="It-tag"><i class="Em" title="Em">STK500 and STK600 programmer
      only:</i> Display the current voltage and master oscillator parameters.
    <div class="Pp"></div>
    <i class="Em" title="Em">JTAG ICE only:</i> Display the current target
      supply voltage and JTAG bit clock rate/period.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">verbose</var>
    [<span class="Op"><var class="Ar" title="Ar">level</var></span>]</dt>
  <dd class="It-tag">Change (when <var class="Ar" title="Ar">level</var> is
      provided), or display the verbosity level. The initial verbosity level is
      controlled by the number of <b class="Fl" title="Fl">-v</b> options given
      on the commandline.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">?</var></dt>
  <dd class="It-tag" style="width: auto;">&#x00A0;</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">help</var></dt>
  <dd class="It-tag">Give a short on-line summary of the available
    commands.</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">quit</var></dt>
  <dd class="It-tag">Leave terminal mode and thus
      <b class="Nm" title="Nm">avrdude</b>.</dd>
</dl>
</div>
<h2 class="Ss" title="Ss" id="Default_Parallel_port_pin_connections"><a class="selflink" href="#Default_Parallel_port_pin_connections">Default
  Parallel port pin connections</a></h2>
(these can be changed, see the <b class="Fl" title="Fl">-c</b> option)
<table class="tbl">
  <colgroup>
    <col style="width: 16.00ex;"/>
    <col style="width: 34.00ex;"/>
  </colgroup>
  <tr>
    <td><b>Pin number</b></td>
    <td><b>Function</b></td>
  </tr>
  <tr>
    <td>2-5</td>
    <td>Vcc (optional power supply to MCU)</td>
  </tr>
  <tr>
    <td>7</td>
    <td>/RESET (to MCU)</td>
  </tr>
  <tr>
    <td>8</td>
    <td>SCK (to MCU)</td>
  </tr>
  <tr>
    <td>9</td>
    <td>MOSI (to MCU)</td>
  </tr>
  <tr>
    <td>10</td>
    <td>MISO (from MCU)</td>
  </tr>
  <tr>
    <td>18-25</td>
    <td>GND</td>
  </tr>
</table>
<h2 class="Ss" title="Ss" id="debugWire_limitations"><a class="selflink" href="#debugWire_limitations">debugWire
  limitations</a></h2>
The debugWire protocol is Atmel's proprietary one-wire (plus ground) protocol to
  allow an in-circuit emulation of the smaller AVR devices, using the
  &#x2018;<code class="Li">/RESET</code>&#x2019; line. DebugWire mode is
  initiated by activating the &#x2018;<code class="Li">DWEN</code>&#x2019; fuse,
  and then power-cycling the target. While this mode is mainly intended for
  debugging/emulation, it also offers limited programming capabilities.
  Effectively, the only memory areas that can be read or programmed in this mode
  are flash ROM and EEPROM. It is also possible to read out the signature. All
  other memory areas cannot be accessed. There is no
  <i class="Em" title="Em">chip erase</i> functionality in debugWire mode;
  instead, while reprogramming the flash ROM, each flash ROM page is erased
  right before updating it. This is done transparently by the JTAG ICE mkII (or
  AVR Dragon). The only way back from debugWire mode is to initiate a special
  sequence of commands to the JTAG ICE mkII (or AVR Dragon), so the debugWire
  mode will be temporarily disabled, and the target can be accessed using normal
  ISP programming. This sequence is automatically initiated by using the JTAG
  ICE mkII or AVR Dragon in ISP mode, when they detect that ISP mode cannot be
  entered.
<h2 class="Ss" title="Ss" id="FLIP_version_1_idiosyncrasies"><a class="selflink" href="#FLIP_version_1_idiosyncrasies">FLIP
  version 1 idiosyncrasies</a></h2>
Bootloaders using the FLIP protocol version 1 experience some very specific
  behaviour.
<div class="Pp"></div>
These bootloaders have no option to access memory areas other than Flash and
  EEPROM.
<div class="Pp"></div>
When the bootloader is started, it enters a <i class="Em" title="Em">security
  mode</i> where the only acceptable access is to query the device configuration
  parameters (which are used for the signature on AVR devices). The only way to
  leave this mode is a <i class="Em" title="Em">chip erase</i>. As a chip erase
  is normally implied by the <b class="Fl" title="Fl">-U</b> option when
  reprogramming the flash, this peculiarity might not be very obvious
  immediately.
<div class="Pp"></div>
Sometimes, a bootloader with security mode already disabled seems to no longer
  respond with sensible configuration data, but only 0xFF for all queries. As
  these queries are used to obtain the equivalent of a signature,
  <b class="Nm" title="Nm">avrdude</b> can only continue in that situation by
  forcing the signature check to be overridden with the
  <b class="Fl" title="Fl">-F</b> option.
<div class="Pp"></div>
A <i class="Em" title="Em">chip erase</i> might leave the EEPROM unerased, at
  least on some versions of the bootloader.
<h2 class="Ss" title="Ss" id="Programmers_accepting_extended_parameters"><a class="selflink" href="#Programmers_accepting_extended_parameters">Programmers
  accepting extended parameters</a></h2>
<div class="Bl-tag" style="margin-left: 6.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><var class="Ar" title="Ar">JTAG ICE mkII</var></dt>
  <dd class="It-tag" style="width: auto;">&#x00A0;</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">JTAGICE3</var></dt>
  <dd class="It-tag" style="width: auto;">&#x00A0;</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">Atmel-ICE</var></dt>
  <dd class="It-tag" style="width: auto;">&#x00A0;</dd>
  <dt class="It-tag"><var class="Ar" title="Ar">AVR Dragon</var></dt>
  <dd class="It-tag">When using the JTAG ICE mkII, JTAGICE3, Atmel-ICE or AVR
      Dragon in JTAG mode, the following extended parameter is accepted:
    <div class="Bl-tag" style="margin-left: 6.00ex;">
    <dl class="Bl-tag">
      <dt class="It-tag"><var class="Ar" title="Ar">jtagchain=UB,UA,BB,BA</var></dt>
      <dd class="It-tag">Setup the JTAG scan chain for
          <var class="Ar" title="Ar">UB</var> units before,
          <var class="Ar" title="Ar">UA</var> units after,
          <var class="Ar" title="Ar">BB</var> bits before, and
          <var class="Ar" title="Ar">BA</var> bits after the target AVR,
          respectively. Each AVR unit within the chain shifts by 4 bits. Other
          JTAG units might require a different bit shift count.</dd>
    </dl>
    </div>
  </dd>
  <dt class="It-tag"><var class="Ar" title="Ar">AVR910</var></dt>
  <dd class="It-tag">
    <div class="Bl-tag" style="margin-left: 6.00ex;">
    <dl class="Bl-tag">
      <dt class="It-tag"><var class="Ar" title="Ar">devcode=VALUE</var></dt>
      <dd class="It-tag">Override the device code selection by using
          <var class="Ar" title="Ar">VALUE</var> as the device code. The
          programmer is not queried for the list of supported device codes, and
          the specified <var class="Ar" title="Ar">VALUE</var> is not verified
          but used directly within the &#x2018;<code class="Li">T</code>&#x2019;
          command sent to the programmer. <var class="Ar" title="Ar">VALUE</var>
          can be specified using the conventional number notation of the C
          programming language.</dd>
    </dl>
    </div>
    <div class="Bl-tag" style="margin-left: 6.00ex;">
    <dl class="Bl-tag">
      <dt class="It-tag"><var class="Ar" title="Ar">no_blockmode</var></dt>
      <dd class="It-tag">Disables the default checking for block transfer
          capability. Use <var class="Ar" title="Ar">no_blockmode</var> only if
          your <var class="Ar" title="Ar">AVR910</var> programmer creates errors
          during initial sequence.</dd>
    </dl>
    </div>
  </dd>
  <dt class="It-tag"><var class="Ar" title="Ar">buspirate</var></dt>
  <dd class="It-tag">
    <div class="Bl-tag" style="margin-left: 6.00ex;">
    <dl class="Bl-tag">
      <dt class="It-tag"><var class="Ar" title="Ar">reset={cs,aux,aux2}</var></dt>
      <dd class="It-tag">The default setup assumes the BusPirate's CS output pin
          connected to the RESET pin on AVR side. It is however possible to have
          multiple AVRs connected to the same BP with MISO, MOSI and SCK lines
          common for all of them. In such a case one AVR should have its RESET
          connected to BusPirate's <i class="Pa" title="Pa">CS</i> pin, second
          AVR's RESET connected to BusPirate's <i class="Pa" title="Pa">AUX</i>
          pin and if your BusPirate has an <i class="Pa" title="Pa">AUX2</i> pin
          (only available on BusPirate version v1a with firmware 3.0 or newer)
          use that to activate RESET on the third AVR.
        <div class="Pp"></div>
        It may be a good idea to decouple the BusPirate and the AVR's SPI buses
          from each other using a 3-state bus buffer. For example 74HC125 or
          74HC244 are some good candidates with the latches driven by the
          appropriate reset pin (cs, aux or aux2). Otherwise the SPI traffic in
          one active circuit may interfere with programming the AVR in the other
          design.</dd>
      <dt class="It-tag"><var class="Ar" title="Ar">spifreq=&lt;0..7&gt;</var></dt>
      <dd class="It-tag">The SPI speed for the Bus Pirate's binary SPI mode:
        <div class="Pp"></div>
        <div class="Bd" style="margin-left: 0.00ex;">
        <pre class="Li">
0 ..  30 kHz   (default) 
1 .. 125 kHz 
2 .. 250 kHz 
3 ..   1 MHz 
4 ..   2 MHz 
5 ..   2.6 MHz 
6 ..   4 MHz 
7 ..   8 MHz
        </pre>
        </div>
      </dd>
      <dt class="It-tag"><var class="Ar" title="Ar">rawfreq=&lt;0..3&gt;</var></dt>
      <dd class="It-tag">Sets the SPI speed and uses the Bus Pirate's binary
          &quot;raw-wire&quot; mode:
        <div class="Pp"></div>
        <div class="Bd" style="margin-left: 0.00ex;">
        <pre class="Li">
0 ..   5 kHz 
1 ..  50 kHz 
2 .. 100 kHz   (Firmware v4.2+ only) 
3 .. 400 kHz   (v4.2+)
        </pre>
        </div>
        <div class="Pp"></div>
        The only advantage of the &quot;raw-wire&quot; mode is the different SPI
          frequencies available. Paged writing is not implemented in this
        mode.</dd>
      <dt class="It-tag"><var class="Ar" title="Ar">ascii</var></dt>
      <dd class="It-tag">Attempt to use ASCII mode even when the firmware
          supports BinMode (binary mode). BinMode is supported in firmware 2.7
          and newer, older FW's either don't have BinMode or their BinMode is
          buggy. ASCII mode is slower and makes the above
          <var class="Ar" title="Ar">reset=</var>,
          <var class="Ar" title="Ar">spifreq=</var> and
          <var class="Ar" title="Ar">rawfreq=</var> parameters unavailable. Be
          aware that ASCII mode is not guaranteed to work with newer firmware
          versions, and is retained only to maintain compatibility with older
          firmware versions.</dd>
      <dt class="It-tag"><var class="Ar" title="Ar">nopagedwrite</var></dt>
      <dd class="It-tag">Firmware versions 5.10 and newer support a binary mode
          SPI command that enables whole pages to be written to AVR flash memory
          at once, resulting in a significant write speed increase. If use of
          this mode is not desirable for some reason, this option disables
        it.</dd>
      <dt class="It-tag"><var class="Ar" title="Ar">nopagedread</var></dt>
      <dd class="It-tag">Newer firmware versions support in binary mode SPI
          command some AVR Extended Commands. Using the &quot;Bulk Memory Read
          from Flash&quot; results in a significant read speed increase. If use
          of this mode is not desirable for some reason, this option disables
          it.</dd>
      <dt class="It-tag"><var class="Ar" title="Ar">cpufreq=&lt;125..4000&gt;</var></dt>
      <dd class="It-tag">This sets the AUX pin to output a frequency of
          <var class="Ar" title="Ar">n</var> kHz. Connecting the AUX pin to the
          XTAL1 pin of your MCU, you can provide it a clock, for example when it
          needs an external clock because of wrong fuses settings. Make sure the
          CPU frequency is at least four times the SPI frequency.</dd>
      <dt class="It-tag"><var class="Ar" title="Ar">serial_recv_timeout=&lt;1...&gt;</var></dt>
      <dd class="It-tag">This sets the serial receive timeout to the given
          value. The timeout happens every time avrdude waits for the BusPirate
          prompt. Especially in ascii mode this happens very often, so setting a
          smaller value can speed up programming a lot. The default value is
          100ms. Using 10ms might work in most cases.</dd>
    </dl>
    </div>
  </dd>
  <dt class="It-tag"><var class="Ar" title="Ar">Wiring</var></dt>
  <dd class="It-tag">When using the Wiring programmer type, the following
      optional extended parameter is accepted:
    <div class="Bl-tag" style="margin-left: 6.00ex;">
    <dl class="Bl-tag">
      <dt class="It-tag"><var class="Ar" title="Ar">snooze=&lt;0..32767&gt;</var></dt>
      <dd class="It-tag">After performing the port open phase, AVRDUDE will
          wait/snooze for <var class="Ar" title="Ar">snooze</var> milliseconds
          before continuing to the protocol sync phase. No toggling of DTR/RTS
          is performed if <var class="Ar" title="Ar">snooze</var> is greater
          than 0.</dd>
    </dl>
    </div>
  </dd>
  <dt class="It-tag"><var class="Ar" title="Ar">PICkit2</var></dt>
  <dd class="It-tag">Connection to the PICkit2 programmer:
    <div class="Pp"></div>
    <div class="Bd" style="margin-left: 0.00ex;">
    <pre class="Li">
(AVR)    (PICkit2) 
RST  -   VPP/MCLR (1) 
VDD  -   VDD Target (2) -- possibly optional if AVR self powered 
GND  -   GND (3) 
MISO -   PGD (4) 
SCLK -   PDC (5) 
MOSI -   AUX (6) 

    </pre>
    </div>
    Extended commandline parameters:
    <div class="Bl-tag" style="margin-left: 6.00ex;">
    <dl class="Bl-tag">
      <dt class="It-tag"><var class="Ar" title="Ar">clockrate=&lt;rate&gt;</var></dt>
      <dd class="It-tag">Sets the SPI clocking rate in Hz (default is 100kHz).
          Alternately the -B or -i options can be used to set the period.</dd>
      <dt class="It-tag"><var class="Ar" title="Ar">timeout=&lt;usb-transaction-timeout&gt;</var></dt>
      <dd class="It-tag">Sets the timeout for USB reads and writes in
          milliseconds (default is 1500 ms).</dd>
    </dl>
    </div>
  </dd>
</dl>
</div>
<h1 class="Sh" title="Sh" id="FILES"><a class="selflink" href="#FILES">FILES</a></h1>
<div class="Bl-tag" style="margin-left: 6.00ex;">
<dl class="Bl-tag" style="margin-left: 17.40ex;">
  <dt class="It-tag" style="margin-left: -17.40ex;"><i class="Pa" title="Pa">/dev/ppi0</i></dt>
  <dd class="It-tag">default device to be used for communication with the
      programming hardware</dd>
  <dt class="It-tag" style="margin-left: -17.40ex;"><i class="Pa" title="Pa">/etc/avrdude.conf</i></dt>
  <dd class="It-tag">programmer and parts configuration file</dd>
  <dt class="It-tag" style="margin-left: -17.40ex;"><i class="Pa" title="Pa">${HOME}/.avrduderc</i></dt>
  <dd class="It-tag">programmer and parts configuration file (per-user
      overrides)</dd>
  <dt class="It-tag" style="margin-left: -17.40ex;"><i class="Pa" title="Pa">~/.inputrc</i></dt>
  <dd class="It-tag">Initialization file for the
      <a class="Xr" title="Xr">readline(3)</a> library</dd>
  <dt class="It-tag" style="margin-left: -17.40ex;"><i class="Pa" title="Pa">/usr/share/doc/avrdude-doc/avrdude.pdf</i></dt>
  <dd class="It-tag">Schematic of programming hardware</dd>
</dl>
</div>
<h1 class="Sh" title="Sh" id="DIAGNOSTICS"><a class="selflink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<div class="Bd" style="margin-left: 0.00ex;">
<pre class="Li">
avrdude: jtagmkII_setparm(): bad response to set parameter command: RSP_FAILED 
avrdude: jtagmkII_getsync(): ISP activation failed, trying debugWire 
avrdude: Target prepared for ISP, signed off. 
avrdude: Please restart avrdude without power-cycling the target.
</pre>
</div>
<div class="Pp"></div>
If the target AVR has been set up for debugWire mode (i. e. the
  <i class="Em" title="Em">DWEN</i> fuse is programmed), normal ISP connection
  attempts will fail as the <i class="Em" title="Em">/RESET</i> pin is not
  available. When using the JTAG ICE mkII in ISP mode, the message shown
  indicates that <b class="Nm" title="Nm">avrdude</b> has guessed this
  condition, and tried to initiate a debugWire reset to the target. When
  successful, this will leave the target AVR in a state where it can respond to
  normal ISP communication again (until the next power cycle). Typically, the
  same command is going to be retried again immediately afterwards, and will
  then succeed connecting to the target using normal ISP communication.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr" title="Xr">avr-objcopy(1)</a>,
  <a class="Xr" title="Xr">ppi(4)</a>, <a class="Xr" title="Xr">libelf(3,)</a>
  <a class="Xr" title="Xr">readline(3)</a>
<div class="Pp"></div>
The AVR microcontroller product description can be found at
<div class="Pp"></div>
<div class="D1"><code class="Li">http://www.atmel.com/products/AVR/</code></div>
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
<b class="Nm" title="Nm">Avrdude</b> was written by Brian S. Dean
  &lt;bsd@bsdhome.com&gt;.
<div class="Pp"></div>
This man page by Joerg Wunsch.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
Please report bugs via
<div class="D1"><code class="Li">http://savannah.nongnu.org/bugs/?group=avrdude.</code></div>
<div class="Pp"></div>
The JTAG ICE programmers currently cannot write to the flash ROM one byte at a
  time. For that reason, updating the flash ROM from terminal mode does not
  work.
<div class="Pp"></div>
Page-mode programming the EEPROM through JTAG (i.e. through an
  <b class="Fl" title="Fl">-U</b> option) requires a prior chip erase. This is
  an inherent feature of the way JTAG EEPROM programming works. This also
  applies to the STK500 and STK600 in parallel programming mode.
<div class="Pp"></div>
The USBasp and USBtinyISP drivers do not offer any option to distinguish
  multiple devices connected simultaneously, so effectively only a single device
  is supported.
<div class="Pp"></div>
The avrftdi driver allows one to select specific devices using any combination
  of vid,pid serial number (usbsn) vendor description (usbvendoror part
  description (usbproduct) as seen with lsusb or whatever tool used to view USB
  device information. Multiple devices can be on the bus at the same time. For
  the H parts, which have multiple MPSSE interfaces, the interface can also be
  selected. It defaults to interface 'A'.</div>
<table class="foot">
  <tr>
    <td class="foot-date">DATE February 15, 2016</td>
    <td class="foot-os">Linux 4.12.14-300.fc26.x86_64</td>
  </tr>
</table>
</body>
</html>
