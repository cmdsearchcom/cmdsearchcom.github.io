<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>MAKEPP_COOKBOOK(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MAKEPP_COOKBOOK(1)</td>
    <td class="head-vol">Makepp</td>
    <td class="head-rtitle">MAKEPP_COOKBOOK(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
makepp_cookbook -- The best way to set up makefiles for various situations
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
I discovered that practically no one ever reads a manual for a make tool,
  because frankly no one really is interested in the make process itself--we are
  only interested in results. So this cookbook was put together in hopes that
  people will be able to get what they need quickly from the examples without
  wading through the manual. This shows howto type questions, whereas
  installation instructions and stumbling blocks will be found in the frequently
  asked questions.
<h2 class="Ss" title="Ss" id="Building_libraries"><a class="selflink" href="#Building_libraries">Building
  libraries</a></h2>
<i>Do you really need a library?</i>
<div class="Pp"></div>
I have seen a number of large programs which consist of a large number of
  modules, each of which lives in its own directory. Commonly, each directory is
  put into its own library, and then the final program links with all of the
  libraries.
<div class="Pp"></div>
In many cases, I think rather than use a library, there is a better approach.
  Libraries are not really the right solution if each module cannot or will not
  be reused in any other program, because then you get all of the drawbacks of
  libraries and none of the advantages. Libraries are useful in the following
  cases:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">When you have a bunch of subroutines which have to be
      linked with several different programs, and no program actually uses 100%
      of the subroutines--each program uses a different subset. In this case, it
      probably is a good idea to use a static library (a <i>.a</i> file, or an
      archive file).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">When you have a module which should be linked into several
      different programs, and you want to load it dynamically so each program
      doesn't have to have a separate copy of the library. Dynamic libraries can
      save executable file space and sometimes enhance system performance
      because there is only one copy of the library loaded for all of the
      different programs that use it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">When your link time is prohibitively long, using shared
      libraries for large pieces of the program can significantly speed up the
      link.</dd>
</dl>
<div class="Pp"></div>
Using static libraries has one main disadvantage: on some systems (e.g. Linux),
  the order in which you link the libraries is critically important. The linker
  processes libraries in the order specified on its command line. It grabs
  everything it thinks it needs from each library, then moves on to the next
  library. If some subsequent library refers to a symbol which hasn't yet been
  incorporated from a previous library, the linker does not know to go back and
  grab it from the previous library. As a result, it can be necessary to list
  the library multiple times on the linker command line. (I worked on a project
  where we had to repeat the whole list of libraries three times. This project
  is what made me prefer the alternative approach suggested below, that of
  incremental linking.)
<div class="Pp"></div>
Using dynamic libraries has several disadvantages. First, your program can be
  slightly slower to start up if the library isn't already being used by some
  other program, because it has to be found and loaded. Second, it can be a real
  hassle to get all the dynamic libraries installed in the correct locations;
  you can't just copy the program executable, you also have to make sure that
  you copy all of its libraries. Third, on some systems, it is difficult to
  debug code inside shared libraries because the debuggers do not support them
  well.
<div class="Pp"></div>
If your module will never be used in any other program, then there is little
  reason to use a library: you get all of the disadvantages of using libraries
  and none of the advantages. The technique I prefer is to use incremental
  linking, where it is available.
<div class="Pp"></div>
Here is how you can do this on Linux:
<div class="Pp"></div>
<pre>
    my_module.o : $(filter_out my_module.o, $(wildcard *.o))
        ld -r -o $(output) $(inputs)
</pre>
<div class="Pp"></div>
What this will do is to create another <i>.o</i> file called <i>my_module.o</i>,
  which will consist of all of the <i>.o</i> files in this subdirectory. The
  linker will resolve as many of the references as it can, and will leave the
  remaining references to be resolved in a subsequent stage of linking. At the
  top level, when you finally build your program, instead of linking with
  <i>libmy_module.a</i> or <i>libmy_module.so</i>, you would simply link with
  <i>my_module.o</i>. When you link <i>.o</i> files, you don't have problems
  with order-dependency in the linker command line.
<div class="Pp"></div>
<i>Letting makepp figure out which library modules are needed</i>
<div class="Pp"></div>
Even if you have a true library, where a given program needs only a few files
  from it (rather than every single module), makepp might be able to figure out
  which modules are needed from the library and include only those in the build.
  This can save compilation time if you are developing the library along with a
  program, because you don't bother to compile library modules that aren't
  needed for the particular program you are working on.
<div class="Pp"></div>
If your library strictly observes the convention that all functions or classes
  declared in a file <i>xyz.h</i> are completely implemented in a source file
  that compiles to <i>xyz.o</i> (i.e., you don't split up the implementation
  into <i>xyz1.o</i> and <i>xyz2.o</i>), then you can use the
  &quot;$(infer_objects)&quot; function to tell makepp to pull out only the
  relevant modules from the library. This can work surprisingly well for
  libraries with even dozens of include files. Basically,
  &quot;$(infer_objects)&quot; examines the list of <i>.h</i> files that are
  included, and looks for corresponding <i>.o</i> files. If you're rapidly
  developing a library and a program together, this can save compilation time,
  because you never bother to compile modules of the library that the program
  doesn't use.
<div class="Pp"></div>
Here's an example of the way I use it:
<div class="Pp"></div>
<pre>
    my_program: $(infer_objects *.o, $(LIB1)/*.o $(LIB2)/*.o)
        $(CXX) $(inputs) -o $(output) $(SYSTEM_LIBRARIES)
</pre>
<div class="Pp"></div>
The &quot;$(infer_objects&#x00A0;)&quot; function returns its first argument
  (after doing wildcard expansion on it), and also looks through the list of
  files in its second argument, for files whose name is the same as the name of
  any <i>.h</i> files included by any file in its first argument. If any such
  files are found, these are added to the list.
<div class="Pp"></div>
<i>Building a static library</i>
<div class="Pp"></div>
If you are sure you actually need a library and incremental linking isn't
  available or isn't what you want to do, there are a couple of ways to do it.
  First, here is an example where all the files are explicitly listed:
<div class="Pp"></div>
<pre>
    LIBRARY_FILES = a b c d e
 
    libmine.a: $(LIBRARY_FILES).o
        &amp;rm -f $(output)
        $(AR) cr $(output) $(inputs)
        ranlib $(output)     # May not be necessary, depending on your OS.
</pre>
<div class="Pp"></div>
The &amp;rm is makepp's builtin &quot;rm&quot; command. If you're used to
  writing makefiles, you may be a little suprised by this command; you may be
  used to something more like this:
<div class="Pp"></div>
<pre>
    libmine.a: $(LIBRARY_FILES).o
        $(AR) ru $@ $?      # Not recommended!!!!!!!
        ranlib $(output)
</pre>
<div class="Pp"></div>
where $? (also known as &quot;$(changed_inputs)&quot;) is an automatic variable
  that means any files which have changed since the last time the library was
  built, and $@ is roughly the same as &quot;$(output)&quot;.
<div class="Pp"></div>
This approach is not recommended for several reasons:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Suppose you remove a source file from the current
      directory. It's still in the library, because you didn't rebuild the
      library from scratch. As a result, anything that links with this library
      will have the stale <i>.o</i> file, and that can screw up your builds. (I
      once got thoroughly confused by this when I was trying to remove dead code
      from a project: I kept deleting files and it still linked, so I thought
      the code was dead. However, when someone else rebuilt the project from
      scratch, it didn't link any more! The problem was that the old <i>.o</i>
      files were still in the archive.)
    <div style="height: 1.00em;">&#x00A0;</div>
    Also, depending on your options to &quot;ar&quot; and your implementation of
      &quot;ar&quot; (e.g., if you use the &quot;q&quot; option instead of
      &quot;r&quot;), you can wind up having several versions of the same
      <i>.o</i> inside the <i>.a</i> file. If the different versions define
      different globals, the linker may try to pull in both of them. This is
      probably a bad thing.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is why we first remove the library file, and create it from scratch.
      This will take slightly longer than just updating modules in a library,
      but not much longer; on a modern computer, the amount of time consumed by
      the <i>ar</i> program is minuscule compared to what the C compiler takes
      up in a typical build, so it's just not worth worrying about.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">One of the ways that makepp attempts to guarantee correct
      builds is that it will automatically rebuild if the command line to build
      a given target has changed. But using the $? variable can cause problems,
      because each time the library is updated, the build command is different.
      (You can suppress this using
      &quot;:build_check&#x00A0;ignore_action&quot;; see makepp_build_check for
      details.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Updating the archive rather than rebuilding it will make it
      impossible for makepp to put the file properly into a build cache (see
      makepp_build_cache for details).</dd>
</dl>
<div class="Pp"></div>
Sometimes you may find that listing all the files is a bit if a pain, especially
  if a project is undergoing rapid development and the list of files is
  constantly changing. It may be easier to build the library using wildcards,
  like this:
<div class="Pp"></div>
<pre>
    libmine.a: $(only_targets *.o)
        &amp;rm $(output)
        $(AR) cr $(output) $(inputs)
</pre>
<div class="Pp"></div>
This puts all the <i>.o</i> files in the current directory into the library. The
  wildcard matches any <i>.o</i> file which exists or can be built, so it will
  work even if the files don't exist yet.
<div class="Pp"></div>
The &quot;only_targets&quot; function is used to exclude <i>.o</i> files which
  don't have corresponding source files any more. Suppose you had a file called
  <i>xyz.c</i> that you used to put into your library. This means that there's
  an <i>xyz.o</i> file lying around. Now you delete <i>xyz.c</i> because it's
  obsolete, but you forget to delete <i>xyz.o</i>. Without the
  &quot;only_targets&quot; function, <i>xyz.o</i> would still be included in the
  list of <i>.o</i> files included in the library.
<div class="Pp"></div>
<i>Building a dynamic library</i>
<div class="Pp"></div>
The process of building dynamic libraries is entirely system dependent. I would
  highly recommend using libtool to build a dynamic library (see
  &lt;http://www.gnu.org/software/libtool/&gt;), so you don't have to figure out
  how to do it on your platform, and so that your makefile will continue to work
  even when you switch to a different OS. See the libtool documentation for
  details. Here's a sample Makefile:
<div class="Pp"></div>
<pre>
    LIBTOOL := libtool
 
    libflick.la : $(only_targets *.lo)
        $(LIBTOOL) --mode=link $(CC) $(inputs) -o $(output)
 
    %.lo : %.c
        $(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(INCLUDES) -c $(input) -o $(output)
</pre>
<h2 class="Ss" title="Ss" id="Building_on_several_different_machines_or_networks"><a class="selflink" href="#Building_on_several_different_machines_or_networks">Building
  on several different machines or networks</a></h2>
One of the most annoying problems with makefiles is that they almost never work
  when you switch to a different machine or a different network. If your
  makefiles have to work on every possible machine on the planet, then you
  probably need some sort of a configure script. But if you only have to work on
  a few different machines, there are several ways you can approach this
  problem:
<div class="Pp"></div>
<i>Use a different include file in all the environments</i>
<div class="Pp"></div>
At the beginning of each makefile, you can include a line like this:
<div class="Pp"></div>
<pre>
    include system_defs.mk
</pre>
<div class="Pp"></div>
The file <i>system_defs.mk</i> would normally be located in a different place
  for each environment. If you want your build directories to be identical on
  all machines, then put <i>system_defs.mk</i> in a directory above the build
  directories, or else supply an include path to makepp using the &quot;-I&quot;
  command line option.
<div class="Pp"></div>
This is usually kind of painful to do, but it works well if there are a huge
  number of differences.
<div class="Pp"></div>
<i>Use if statements</i>
<div class="Pp"></div>
This is the ugliest way to do it, but it will usually work.
<div class="Pp"></div>
<pre>
    ifsys i386
      CC := gcc
    else ifsys sun4u
      CC := cc
    else ifsys hpux11
      CC = c89
    endif
</pre>
<div class="Pp"></div>
If all you need to do is to find a few programs or libraries or include files in
  different places, there may be better ways (see below).
<div class="Pp"></div>
<i>find_program, first_available, findfile</i>
<div class="Pp"></div>
These functions can search various different directories in your system to find
  the appropriate files. This isn't as powerful as a configure script, of
  course, but I find it useful. For example, I do the following:
<div class="Pp"></div>
<pre>
    CXX ;= $(find_program g++ c++ pg++ cxx CC aCC)
                    # Pick first C++ compiler which is available in PATH.
                    # (Incidentally, if you don't define CXX at all, this
                    # is the way it's defined.)
    TCL_INCLUDE ;= -I$(dir_noslash $(findfile tcl.h, \
           /usr/local/stow/tcl-8.4.5-nothread/include \
           /usr/include/tcl8.4 /usr/include/tcl \
           /net/na1/tcl8.4a3/include /net/na1/tcl8.4a3/include))
                    # $(findfile ) looks for tcl.h in each of the indicated
                    # directories and returns the full path.  This is then
                    # converted into a compilation option by stripping the
                    # filename (leaving the directory) and prefixing with -I.
    %.o : %.cpp
        $(CXX) $(CXXFLAGS) $(TCL_INCLUDE) $(input) -o $(output)
 
    TCL_LIB ;= $((first_available
           /usr/local/stow/tcl-8.4.5-nothread/lib/libtcl8.4.so
           /usr/lib/libtcl8.4.so /usr/lib/libtcl.so
           /net/na1/tcl8.4a3/lib/libtcl8.4.a
           /net/na1/tcl8.4a3/lib/libtcl8.4.sl))
                    # Find where the Tcl library is.  This is then explicitly
                    # listed on the link command:
    my_program : *.o
        $(CXX) $(CXXFLAGS) $(inputs) -o $(output) $(TCL_LIB)
</pre>
<div class="Pp"></div>
<i>Take advantage of Perl's config information</i>
<div class="Pp"></div>
The above techniques may not be sufficient if you need some additional
  information about your system, such as whether a long double exists, or what
  the byte order is. However, perl has already computed these things, so you can
  just use its answers.
<div class="Pp"></div>
Perl's autoconfigure script makes all of its configuration information available
  through the %Config hash. There's no syntax to access a Perl hash directly in
  makepp, but you can drop into Perl and set scalar variables, which are
  directly accessible from makepp:
<div class="Pp"></div>
<pre>
    perl_begin
    # Fetch values out of the config hash.
    use Config;
    $CC = $Config{'cc'};   # C compiler that perl used;
    $byteorder_flags = &quot;-DBYTEORDER=$Config{'byteorder'}&quot;;
    $longdouble_defined = $Config{'d_longdbl'} eq 'define';
    $CFLAGS_for_shared_libs = $Config{'cccdlflags'};
    $LDFLAGS_for_shared_libs = $Config{'ccdlflags'};
    perl_end
</pre>
<div class="Pp"></div>
Also, once you have done the 'use Config', you can use the
  &quot;$(perl&#x00A0;)&quot; statement, like this:
<div class="Pp"></div>
<pre>
    SHARED_LIB_EXTENSION := $(perl $Config{'dlext'})
</pre>
<div class="Pp"></div>
Type &quot;perldoc&#x00A0;Config&quot; to see what information is available via
  the %Config hash.
<div class="Pp"></div>
Perl's config is a good place to get things like information about integer
  types, byte order, and other things which usually require a separate config
  script to locate. Some of its information that relates to the presence of
  things in the file system might not be valid. For example, $Config{'cc'}
  refers to the C compiler that perl was built with, which might not be the same
  C compiler you want to use. In fact, it might not even exist on your system,
  since you probably installed Perl via a binary package.
<h2 class="Ss" title="Ss" id="Tips_for_using_wildcards"><a class="selflink" href="#Tips_for_using_wildcards">Tips
  for using wildcards</a></h2>
<i>Matching all files except a certain subset</i>
<div class="Pp"></div>
Makepp's wildcards do not have any way at present of matching all files
  <i>except</i> a certain set, but you can do it with a combination of
  functions.
<div class="Pp"></div>
For example, suppose you have a test program for each module in a library, but
  you don't want to include the test programs in the library. If all the test
  programs begin with <i>test</i>, then you can exclude them like this:
<div class="Pp"></div>
<pre>
    libproduction.a: $(filter_out test*, $(wildcard *.o))
</pre>
<div class="Pp"></div>
The &quot;$(filter&#x00A0;)&quot; and &quot;$(filter_out&#x00A0;)&quot;
  functions are a very powerful set of filters to do all kinds of set
  intersection and difference operations. For example,
<div class="Pp"></div>
<pre>
    SUBDIRS ;= $(filter_out *test* *$(ARCH)*, $(shell find . -type d -print))
                            # Returns all subdirectories that don't have
                            # &quot;test&quot; or $(ARCH) in them.
 
    $(filter $(patsubst test_dir/test_%.o, %.o, $(wildcard test_dir/*.o)), \
             $(wildcard *.o))
                            # Returns a list of .o files in the current
                            # directory for which there is a corresponding
                            # test_*.o file in the test_dir subdirectory.
    $(filter_out $(patsubst man/man3/%.3, %.o, $(wildcard man/man3/*.3)), \
                 $(wildcard *.o))
                            # Returns a list of .o files in the current
                            # directory for which there is not a manual page
                            # with the same filename in the man/man3 subdirectory.
</pre>
<div class="Pp"></div>
<i>Using the </i><i>&quot;$(only_targets&#x00A0;)&quot;</i><i> function to
  eliminate stale </i> <i>.o</i><i> files</i>
<div class="Pp"></div>
Suppose you are building a program or a library with a build command like this:
<div class="Pp"></div>
<pre>
    program: *.o
        $(CC) $(inputs) -o $(output)
</pre>
<div class="Pp"></div>
Suppose you now delete a source file. If you forget to delete the corresponding
  <i>.o</i> file, it will still be linked in even though there is no way to
  build it any more. In the future, makepp will probably recognize this
  situation automatically and exclude it from the wildcard list, but at present,
  you have to tell it to exclude it manually:
<div class="Pp"></div>
<pre>
    program: $(only_targets *.o)
        $(CC) $(inputs) -o $(outputs)
</pre>
<div class="Pp"></div>
Makepp does not know any way to build the stale <i>.o</i> file any more since
  its source file is gone, so the &quot;$(only_targets&#x00A0;)&quot; function
  will exclude it from the dependency list.
<h2 class="Ss" title="Ss" id="Tips_for_multiple_directories"><a class="selflink" href="#Tips_for_multiple_directories">Tips
  for multiple directories</a></h2>
One of the main reasons for writing makepp was to simplify handling of multiple
  directories. Makepp is able to combine build commands from multiple makefiles,
  so it can properly deal with a rule in one makefile that depends on a file
  which is built by a different makefile.
<div class="Pp"></div>
<i>What to do in place of recursive make</i>
<div class="Pp"></div>
Makepp supports recursive make for backward compatibility, but it is highly
  recommended that you <b>not</b> use it. If you don't know what it is, good.
<div class="Pp"></div>
See &quot;Better system for hierarchical builds&quot; in makepp for details on
  why you don't want to use recursive make, or else search on the web for
  &quot;recursive make considered harmful&quot;.
<div class="Pp"></div>
Instead of doing a recursive make to make the &quot;all&quot; target in every
  makefile, it is usually easier to let makepp figure out which targets will
  actually need to be built. Furthermore, if you put all of your <i>.o</i> and
  library files in the same directory as the makefiles, then makepp will
  automatically figure out which makefiles are needed too--the only thing that's
  needed is the have your top level make list the files that are needed for the
  final linking step. See the examples below.
<div class="Pp"></div>
<i>One makefile for each directory: with implicit loading</i>
<div class="Pp"></div>
The most common way to handle multiple directories is to put a makefile in each
  directory which describes how to build everything in or from that directory.
  If you put <i>.o</i> files in the same directory as the source files, then
  implicit loading (see &quot;Implicit loading&quot; in makepp_build_algorithm)
  will automatically find all the makefiles. If you put your <i>.o</i> files in
  a different directory (e.g., in an architecture-dependent subdirectory), then
  you will probably have to load all the relevant makefiles using the
  &quot;load_makefile&quot; statement.
<div class="Pp"></div>
Here is a sample top-level makefile for a directory hierarchy that uses implicit
  loading to build a program that consists of many shared libraries (but see
  &quot;Do you really need a library?&quot; in makepp_cookbook, because making a
  program out of a bunch of shared libraries is not necessarily a good idea):
<div class="Pp"></div>
<pre>
    # Top level makefile:
    program : main.o **/*.la  # Link in shared libraries from all subdirectories.
        $(LIBTOOL) --mode=link $(CC) $(CFLAGS) $(inputs) -o $(output) $(LIBS)
</pre>
<div class="Pp"></div>
That's pretty much all you need in the top level makefile. In each subdirectory,
  you would probably do something like this:
<div class="Pp"></div>
<pre>
    # Makefile in each subdirectory:
    include standard_defs.mk   # Searches ., .., ../.., etc. until it
                              # finds the indicated include file.
    # override some variable definitions here
    SPECIAL_FLAGS := -do_something_different
</pre>
<div class="Pp"></div>
Each makefile can probably be pretty much the same if the commands to build the
  targets are quite similar.
<div class="Pp"></div>
Finally, you would put the following into the <i>standard_defs.mk</i> file
  (which should probably be located in the top-level directory):
<div class="Pp"></div>
<pre>
    # Common variable settings and build rules for all directories.
    CFLAGS := -g -O2
    INCLUDE_DIR := $(find_upwards includes)
                              # Searches ., .., ../.., etc. for a file or
                              # directory called includes, so if you put
                              # all your include files in there, this will
                              # find them.
    INCLUDES := -I$(INCLUDE_DIR)
 
    %.lo : %.c
        $(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(INCLUDES) -c $(input) -o $(output)
 
    lib$(relative_to ., ..).la: $(only_targets *.lo)
        $(LIBTOOL) --mode=link $(CC) $(CFLAGS) -o $(output) $(inputs)
                      # $(relative_to ., ..) returns the name of the current
                      # subdirectory relative to the upper level
                      # subdirectory.  So if this makefile is xyz/Makefile,
                      # this rule will build xyz/libxyz.la.
 
    # Publish public include files into the top-level include directory:
    $(INCLUDE_DIR)/public_%.h : public_%.h
        :build_check symlnk
        &amp;ln -fr $(input) $(output)
</pre>
<div class="Pp"></div>
<i>One makefile for each directory: explicit loading</i>
<div class="Pp"></div>
If you want to put all of your <i>.o</i> files into an architecture-dependent
  subdirectory, then the above example should be modified to be something like
  this:
<div class="Pp"></div>
<pre>
    # Top level makefile:
    MAKEFILES := $(wildcard **/Makeppfile)  # List of all subdirectories to
                                           # get makefiles from.
 
    load_makefile $(MAKEFILES)       # Load them all in.
 
    include standard_defs.mk         # Get compile command for main.o.
 
    program : $(ARCH)/main.o */**/$(ARCH)/*.la
        $(LIBTOOL) --mode=link $(CC) $(CFLAGS) $(inputs) -o $(output) $(LIBS)
                                    # */**/$(ARCH) excludes the subdirectory
                                    # $(ARCH), where we don't want to build
                                    # a shared library.
</pre>
<div class="Pp"></div>
Each makefile would be exactly the same as before:
<div class="Pp"></div>
<pre>
    # Makefile in each subdirectory:
    include standard_defs.mk
    # ... variable overrides here
</pre>
<div class="Pp"></div>
And finally, <i>standard_defs.mk</i> would contain something like the following:
<div class="Pp"></div>
<pre>
    # Common variable settings and build rules for all directories.
    ARCH        ;= $(shell uname -s)-$(shell uname -m)-$(shell uname -r)
                        # Sometimes people use only $(shell uname -m), but
                        # this will be the same for FreeBSD and Linux on
                        # an x86.  The -r is not really useful on Linux,
                        # but is important for other OSes: binaries for
                        # SunOS 5.8 typically won't run on SunOS 5.7.
    &amp;mkdir -p $(ARCH)   # Make sure the output directory exists.
    CFLAGS := -g -O2
    INCLUDE_DIR := $(find_upwards includes)
                        # Searches ., .., ../.., etc. for a file or
                        # directory called includes, so if you put
                        # all your include files in there, this will
                        # find them.
    INCLUDES := -I$(INCLUDE_DIR)
 
    $(ARCH)/%.lo : %.c
        $(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(INCLUDES) -c $(input) -o $(output)
 
    $(ARCH)/lib$(relative_to ., ..).la: $(only_targets *.lo)
        $(LIBTOOL) --mode=link $(CC) $(CFLAGS) -o $(output) $(inputs)
                      # $(relative_to ., ..) returns the name of the current
                      # subdirectory relative to the upper level
                      # subdirectory.  So if this makefile is xyz/Makefile,
                      # this rule will build xyz/$(ARCH)/libxyz.la.
 
    # Copy public include files into the top-level include directory:
    $(INCLUDE_DIR)/public_%.h : public_%.h
        &amp;cp $(input) $(output)
</pre>
<div class="Pp"></div>
<i>Automatically making the makefiles</i>
<div class="Pp"></div>
If your makefiles are all extremely similar (as in the above example), you can
  tell Makepp to build them automatically if they don't exist. Just add the
  following to your top-level makefile:
<div class="Pp"></div>
<pre>
    SUBDIRS := $(filter_out unwanted_dir1 unwanted_dir2, $(wildcard */**))
    $(foreach)/Makeppfile: : foreach $(SUBDIRS)
        &amp;echo &quot;include standard_defs.mk&quot; -o $(output)
        &amp;echo &quot;_include additional_defs.mk&quot; -o &gt;&gt;$(output)
                             # If the file additional_defs.mk exists, then
                             # it will be included, but if it doesn't exist,
                             # the _include statement will be ignored.
</pre>
<div class="Pp"></div>
Now the makefiles themselves will be automatically built.
<div class="Pp"></div>
<i>One makefile only at the top level</i>
<div class="Pp"></div>
If all your makefiles are identical, you may ask: why should I have a makefile
  at each level? Why not put that all into the top-level makefile?
<div class="Pp"></div>
Yes, this can be done. The main disadvantage is that it becomes harder to
  specify different build options for each subdirectory. A second disadvantage
  is that your makefile will probably become a bit harder to read.
<div class="Pp"></div>
Here's an example of doing just that:
<div class="Pp"></div>
<pre>
    # Top-level makefile for directory hierarchy.  Builds the program
    # out of a set of shared libraries as an example.  (See caveats above
    # for why you might want to use incremental linking or some other
    # approach rather than shared libraries.)
    makepp_percent_subdirs := 1     # Allow % to match multiple directories.
    SUBDIRS := $(filter_out *CVS* other-unwanted_dirs $(wildcard **))
    CFLAGS := -g -O2
    INCLUDES := -Iincludes
 
    %.lo: %.c
        $(LIBTOOL) --mode=compile $(CC) $(INCLUDES) $(CFLAGS) -c $(input) -o $(output)
 
    $(foreach)/lib$(notdir $(foreach)).la: $(foreach)/*.lo : foreach $(SUBDIRS)
        $(LIBTOOL) --mode=link $(CC) $(CFLAGS) -o $(output) $(inputs)
                               # Rule to make all of the libraries.
 
    program : main.o **/*.la
        $(LIBTOOL) --mode=link $(CC) $(CFLAGS) -o $(output) $(inputs)
 
    includes/$(notdir $(foreach)) : $(foreach) : foreach **/public_*.h
        &amp;cp $(input) $(output)
                               # Sample rule for copying the publically
                               # accessible .h files to the right place.
</pre>
<div class="Pp"></div>
<i>A clean target</i>
<div class="Pp"></div>
Traditional makefiles contain a clean target, which allows removing everything
  that was built. There are three reasons why you should not do this with
  makepp:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Makepp goes to great lengths to ensure a correct build. So
      the desperate &quot;I don't know what's wrong&quot;, making you want to
      start from scratch is a thing of the past.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">People will sometimes try to save time by doing two
      contradictory things at once: &quot;make clean all&quot;. This can confuse
      makepp's smart wildcard system, because it will first get the facts before
      doing anything. Then comes the clean action, which does not tell makepp
      what it does (indeed it can't, because it undoes something -- the contrary
      of what a build tool is for). Then comes &quot;all&quot;, but the up to
      date files, which where there, are mysteriously gone.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">There is the &quot;makeppclean&quot; command, which does
      the same thing, and more efficiently.</dd>
</dl>
<div class="Pp"></div>
Nevertheless we retain this historical section, as it does tell you something
  about the way makepp works: A phony target called &quot;clean&quot; is just a
  name for a set of commands to remove all files that result from the make
  process. Usually a clean target looks something like this:
<div class="Pp"></div>
<pre>
    $(phony clean):
        &amp;rm -fm $(wildcard *.o .makepp_log)
        # -m and .makepp_log gets rid of all of makepp's junk.
</pre>
<div class="Pp"></div>
Instead of explicitly listing the files you want to delete, you can also tell
  makepp to remove everything it knows how to build, like this:
<div class="Pp"></div>
<pre>
    $(phony clean):
        &amp;rm -fm .makepp_log $(only_targets *)
</pre>
<div class="Pp"></div>
This has the advantage that if any of your source files can be built from other
  files, they will be deleted too; on the other hand, stale <i>.o</i> files
  (files which used to be buildable but whose source file has since been
  removed) will not be deleted.
<div class="Pp"></div>
If you have a build that involves makefiles in several different directories,
  your top-level makefile may reference the &quot;clean&quot; target (or any
  other phony target) in a different makefile:
<div class="Pp"></div>
<pre>
    # Top-level makefile
    SUBDIRS := sub1 sub2
 
    # build rules here
 
    # Clean up after the build:
    $(phony clean): $(SUBDIRS)/clean
        &amp;rm -fm .makepp_log $(only_targets *)
</pre>
<div class="Pp"></div>
Alternatively, you can put your &quot;clean&quot; target only in the top-level
  makefile, and have it process all of the directories, like this:
<div class="Pp"></div>
<pre>
    $(phony clean):
        &amp;rm -fm $(only_targets **/*)
</pre>
<h2 class="Ss" title="Ss" id="Using_Qt's_moc_preprocessor"><a class="selflink" href="#Using_Qt's_moc_preprocessor">Using
  Qt's moc preprocessor</a></h2>
This example shows a makefile for a utility that uses Nokia's Qt GUI library
  (see &lt;http://qt.nokia.com&gt;). The only thing that's slightly unusual
  about this is that you must run a preprocessor called &quot;moc&quot; on most
  &quot;.h&quot; files that contain widget definitions, but you don't want to
  run &quot;moc&quot; on any &quot;.h&quot; files that don't use the
  &quot;Q_OBJECT&quot; macro.
<div class="Pp"></div>
<i>Automatically determining which files need moc files</i>
<div class="Pp"></div>
You could, of course, just list all of the &quot;.h&quot; files that need to
  have &quot;moc&quot; run on them. If you're rapidly developing new widgets,
  however, it may be something of a nuisance to keep updating the list in the
  makefile. You can get around the need to list the moc modules explicitly with
  something like this:
<div class="Pp"></div>
<pre>
    MOC := $(QTDIR)/bin/moc
    MODULES     := whatever modules you happen to have in your program
    MOC_MODULES := $(patsubst %.h, moc_%, $(&amp;grep -l /Q_OBJECT/ *.h))
                        # Scans all the .h files for the Q_OBJECT macro.
 
    my_program: $(MODULES).o $(MOC_MODULES).o
        $(CXX) $(inputs) -o $(output)
 
    moc_%.cxx: %.h              # Makes the moc files from the .h files.
        $(MOC) $(input) -o $(output)
 
    %.o: %.cxx
        $(CXX) $(CXXFLAGS) -c $(input) -o $(output)
</pre>
<div class="Pp"></div>
This approach scans each of your <i>.h</i> files every time makepp is run,
  looking for the &quot;Q_OBJECT&quot; macro. This sounds expensive, but it
  probably won't take long at all. (The <i>.h</i> files will all have to be
  loaded from disk anyway by the compilation process, so they will be cached.)
<div class="Pp"></div>
<i>#include the </i><i>.moc</i><i> file</i>
<div class="Pp"></div>
Another approach is to &quot;#include&quot; the output from the &quot;moc&quot;
  preprocessor in your widget implementation file. This means you have to
  remember to write the &quot;#include&quot;, but it has the advantage that
  there are fewer modules to compile, and so compilation goes faster. (For most
  C++ compilation, the majority of the time is spent reading the header files,
  and the output from the preprocessor needs to include almost as many files as
  your widget anyway.) For example:
<div class="Pp"></div>
<pre>
    // my_widget.h
    class MyWidget : public QWidget {
      Q_OBJECT
    // ...
    }
 
    // my_widget.cpp
 
    #include &quot;my_widget.h&quot;
    #include &quot;my_widget.moc&quot;    // my_widget.moc is the output from the
                                // moc preprocessor.
    // Other implementation things here.
    MyWidget::MyWidget(QWidget * parent, const char * name) :
      QWidget(parent, name)
    {
     // ...
    }
</pre>
<div class="Pp"></div>
Now you need to have a rule in your makefile to make all the &quot;.moc&quot;
  files, like this:
<div class="Pp"></div>
<pre>
    MOC := $(QTDIR)/bin/moc
    # Rule to make .moc files:
    %.moc: %.h
        $(MOC) $(input) -o $(output)
</pre>
<div class="Pp"></div>
Makepp is smart enough to realize that it needs to make
  &quot;my_widget.moc&quot; if it doesn't already exist, or if it's out of date.
<div class="Pp"></div>
This second approach is the one that I usually use because it speeds up
  compilation.
<h2 class="Ss" title="Ss" id="Replacements_for_deprecated_make_idioms"><a class="selflink" href="#Replacements_for_deprecated_make_idioms">Replacements
  for deprecated make idioms</a></h2>
<i>MAKECMDGOALS</i>
<div class="Pp"></div>
Sometimes people have rules in their makefile depend on what target they are
  building, using the special variable &quot;MAKECMDGOALS&quot;. For example,
  one sometimes sees things like this:
<div class="Pp"></div>
<pre>
    ifneq ($(filter production, $(MAKECMDGOALS)),)
      CFLAGS := -O2
    else
      CFLAGS := -g
    endif
</pre>
<div class="Pp"></div>
This will work fine with makepp. However, I recommend not to use
  &quot;MAKECMDGOALS&quot; for such cases (and so does the GNU make manual). You
  are better off putting your optimized and debug-compiled <i>.o</i> files in
  separate directories, or giving them different prefixes or suffixes, or using
  repositories, to keep them separate.
<div class="Pp"></div>
Probably the only time when you might actually want to reference
  &quot;MAKECMDGOALS&quot; is if it takes a long time to load your makefiles,
  and you don't need that for your &quot;clean&quot; target (but you don't need
  a clean target). For example,
<div class="Pp"></div>
<pre>
    ifneq ($(MAKECMDGOALS),clean)
      load_makefile $(wildcard **/Makeppfile)
    else
      no_implicit_load . # Prevent automatic loading of any other makefiles.
    endif
 
    $(phony clean):
        &amp;rm -f $(wildcard **/*.o)
</pre>
<div class="Pp"></div>
<i>Recursive make to build in different directories</i>
<div class="Pp"></div>
See &quot;Tips for multiple directories&quot; in makepp_cookbook.
<div class="Pp"></div>
<i>Recursive make to change value of a variable</i>
<div class="Pp"></div>
Some makefiles reinvoke themselves with a different value of a variable, e.g.,
  the debug target in the following makefile fragment
<div class="Pp"></div>
<pre>
    .PHONY: all debug
 
    optimized:
        $(MAKE) program CFLAGS=-O2
 
    debug:
        $(MAKE) program CFLAGS=-g
 
    program: a.o b.o
        $(CC) $(CFLAGS) $^ -o $@
 
    %.o : %.c
        $(CC) $(CFLAGS) -c $&lt; -o $@
</pre>
<div class="Pp"></div>
If the user types &quot;make debug&quot;, it builds the program in default mode
  with debug enabled instead of with optimization.
<div class="Pp"></div>
A better way to do it is to build two different programs, with two different
  sets of object files, like this:
<div class="Pp"></div>
<pre>
    CFLAGS := -O2
    DEBUG_FLAGS := -g
    MODULES := a b
 
    program: $(MODULES).o
         $(CC) $(CFLAGS) $(inputs) -o $(output)
 
    debug/program: debug/$(MODULES).o
         $(CC) $(DEBUG_FLAGS) $(inputs) -o $(output)
 
    %.o : %.c
         $(CC) $(CFLAGS) -c $(input) -o $(output)
 
    debug/%.o : %.c
         $(CC) $(DEBUG_FLAGS) -c $(input) -o $(output)
 
    $(phony debug): debug/program
</pre>
<div class="Pp"></div>
The advantage of doing it this way is (a) you don't need to rebuild everything
  when you switch from debug to optimized and back again; (b)
<div class="Pp"></div>
The above can be written somewhat more concisely using repositories. The
  following makefile is exactly equivalent:
<div class="Pp"></div>
<pre>
    repository debug=.     # Makes the debug subdirectory look like a copy of
                           # the current subdirectory.
    load_makefile debug CFLAGS=-g
                           # Override CFLAGS when invoked in debug subdirectory
    CFLAGS := -O2          # Value of CFLAGS when invoked in this subdirectory
 
    program: a.o b.o
        $(CC) $(CFLAGS) $^ -o $@
 
    %.o : %.c
        $(CC) $(CFLAGS) -c $&lt; -o $@
 
    $(phony debug): debug/program
                           # If user types &quot;makepp debug&quot;, builds
                           # debug/program instead of program.
</pre>
<h2 class="Ss" title="Ss" id="Miscellaneous_tips"><a class="selflink" href="#Miscellaneous_tips">Miscellaneous
  tips</a></h2>
<i>How do I build one part differently just once?</i>
<div class="Pp"></div>
Makepp makes this hard to do because the result is inconsistent with regard to
  the rules. But there are situations where you may need this, e.g. to compile
  just one module with heavy debugging information. You can achieve this in two
  steps by first building the dependency separately, and then excluding it from
  the link phase:
<div class="Pp"></div>
<pre>
    makepp DEBUG=3 buggy.o            # Build it with other option.
    makepp --dont-build=buggy.o buggy # Use it, despite &quot;wrong&quot; build option.
</pre>
<div class="Pp"></div>
<i>How do I make sure my output directories exist?</i>
<div class="Pp"></div>
You can specify a rule to build the output directory, then make sure that each
  file that goes in the output directory depends on it. But it's usually easier
  to do something like this:
<div class="Pp"></div>
<pre>
    # The classical way
    dummy := $(shell test -d $(OUTPUT_DIRECTORY) || mkdir -p $(OUTPUT_DIRECTORY))
                # This is usually easier than making all files depend on
                # $(OUTPUT_DIRECTORY) and having a rule to make it.
                # Note that you must use := instead of = to force it to
                # execute immediately.
    # An alternative approach: using Perl code, OUTPUT_DIRECTORY local var
    perl_begin
      -d $OUTPUT_DIRECTORY or mkdir $OUTPUT_DIRECTORY;
    perl_end
    # The modern way, does nothing for existing directories
    &amp;mkdir -p $(OUTPUT_DIRECTORY)
</pre>
<div class="Pp"></div>
One of these statements should be near the top of your makefile, so they are
  executed before anything that could possibly need the directory.
<div class="Pp"></div>
<i>How do I force a command to execute on every build?</i>
<div class="Pp"></div>
The easiest way is not to use the rule mechanism at all, but simply to execute
  it, like this:
<div class="Pp"></div>
<pre>
    dummy := $(shell date &gt; last_build_timestamp)
</pre>
<div class="Pp"></div>
Or put it in a perl block, like this:
<div class="Pp"></div>
<pre>
    perl_begin
      system(&quot;command to execute&quot;);
    perl_end
</pre>
<div class="Pp"></div>
This approach has the disadvantage that it will be executed even if an unrelated
  target is being run.
<div class="Pp"></div>
A second approach is to declare the file as a phony target, even if it is a real
  file. This will force makepp to reexecute the command to build it every time,
  but only if it appears in the dependency list of some rule.
<div class="Pp"></div>
<i>How do I shorten the displayed build commands?</i>
<div class="Pp"></div>
Often there are so many options to compilation commands that what is displayed
  on the screen is unreadable. You can change what is displayed by suppressing
  display of the entire command, and then explicitly print out the interesting
  part of the command. It's easy to print out only the relevant part of the
  command by using &quot;$(filter_out&#x00A0;)&quot;, like this:
<div class="Pp"></div>
<pre>
    ALL_CFLAGS = $(CFLAGS) $(INCLUDES) $(ADDL_CXX_FLAGS) $(DEBUG_FLAGS)
 
    %.o : %.c
        @&amp;echo $(notdir $(CC)) ... \
             $(filter_out -I* $(ADDL_CXX_FLAGS), $(ALL_CFLAGS)) \
             -c $(input)
        @$(CC) $(ALL_CFLAGS) -c $(input) -o $(output)
</pre>
<div class="Pp"></div>
(The &quot;@&quot; in front of the command suppresses printing out the command.)
<div class="Pp"></div>
This will allow you to see most of the interesting options but won't display all
  of the include directories (of which there are often very many!). If the part
  you are interested in is contiguous in your command, you can also use the
  &quot;print&quot; function (which adds a newline, so you don't want several of
  them):
<div class="Pp"></div>
<pre>
    target:
        @... $(print interesting part) ...
</pre>
<div class="Pp"></div>
<i>How do I convert a file into dependencies?</i>
<div class="Pp"></div>
For some obscure file formats it's not worthwhile to implement a scanner. In one
  project we have xml files, say <i>foobar.xml</i> which contains the
  dependencies for <i>foobar.out</i>:
<div class="Pp"></div>
<pre>
    &lt;files&gt;
      &lt;file&gt;a&lt;/file&gt;
      &lt;file&gt;b&lt;/file&gt;
      &lt;file&gt;c&lt;/file&gt;
    &lt;/files&gt;
</pre>
<div class="Pp"></div>
We decided to adhere to this simple layout, so we don't need to parse xml. With
  the builtin &amp;sed, here's what we do with three simple substitutions for
  the three kinds of lines:
<div class="Pp"></div>
<pre>
    %.d: %.xml
        &amp;sed 's!&lt;files&gt;!$(stem).out: \\! || s!&lt;file&gt;(.+)&lt;/file&gt;!$$1 \\! || s!&lt;/files&gt;!# Empty!' \
            $(input) -o $(output)
 
    include foobar.d
</pre>
<div class="Pp"></div>
Attempting to include this, produces &quot;foobar.d&quot; first:
<div class="Pp"></div>
<pre>
    foobar.out: \
      a \
      b \
      c \
    # Empty
</pre>
<div class="Pp"></div>
Empty (just a comment or really empty) line avoids having to worry about the
  trailing backslash. An alternative producing a multiline list is:
<div class="Pp"></div>
<pre>
    %.d: %.xml
        &amp;sed 's!&lt;files&gt;!$(stem).out: \$$((! || s!&lt;/files&gt;!))! || s!&lt;.+?&gt;!!g' \
            $(input) -o $(output)
 
    include foobar.d
</pre>
<div class="Pp"></div>
This produces an equivalent:
<div class="Pp"></div>
<pre>
    foobar.out: $((
      a
      b
      c
    ))
</pre>
<div class="Pp"></div>
If you have more complex rewriting to do, define a function within the makefile
  or in a module which you include. E.g. undefining $_ will skip input lines:
<div class="Pp"></div>
<pre>
    sub myfilter {
      return undef $_ if /&lt;!--/;        # skip comment lines
      my $stem = f_stem;
      s!&lt;files&gt;!$stem.out: \$((! || s!&lt;/files&gt;!))! || s!&lt;.+?&gt;!!g;
    }
 
    %.d: %.xml
        &amp;sed 's!&lt;files&gt;!$(stem).out: \$$((! || s!&lt;/files&gt;!))! || s!&lt;.+?&gt;!!g' \
            $(input) -o $(output)
 
    include foobar.d
</pre>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-28</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
