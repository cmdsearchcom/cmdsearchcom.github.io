<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>hashrat(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">hashrat(1)</td>
    <td class="head-vol">hashing tool supporting several hashes and
      recursivity</td>
    <td class="head-rtitle">hashrat(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
<b>hashrat </b>- hashing tool supporting several hashes and recursivity <b></b>
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
<b>hashrat</b> [<i>options</i>] [<i>paths</i> <i>to</i> <i>hash</i>]
<div class="Pp"></div>
<b>hashrat</b> <b>-c</b> [<i>options</i>] [<i>input</i> <i>file</i> <i>of</i> <i>hashes</i>]
<div class="Pp"></div>
</pre>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Hashrat is a <i>hash</i>-generation utility that supports the md5, sha1, sha256,
  sha512, whirlpool, jh-224, jh256, jh-384 and jh-512 <i>hash</i> functions, and
  also the HMAC versions <i>of</i> those functions. It can output in traditional
  format (same as md5sum and shasum and the like) or it's own format.
<div class="Pp"></div>
Hashes can be output in octal, decimal, hexadecimal, uppercase hexadecimal or
  base64.
<div class="Pp"></div>
Hashrat also supports directory recursion, hashing entire devices, and
  generating a <i>hash</i> for an entire directory. It has a CGI mode that can
  be used as a web-page <i>to</i> lookup <i>hashes</i>.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-?, <b>-help</b>, <b>--help</b></b></dt>
  <dd class="It-tag">Print this help.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-version</b>, <b>--version</b></b></dt>
  <dd class="It-tag">Print program version.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-type &lt;type&gt;</b></b></dt>
  <dd class="It-tag">Use <i>hash</i> algorithm &lt;type&gt;. Hash types can be
      chained as a comma-seperated list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-md5</b></b></dt>
  <dd class="It-tag">Use md5 <i>hash</i> algorithm. This is the default
      <i>hash</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-sha1</b></b></dt>
  <dd class="It-tag">Use sha1 <i>hash</i> algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-sha256</b></b></dt>
  <dd class="It-tag">Use sha256 <i>hash</i> algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-sha512</b></b></dt>
  <dd class="It-tag">Use sha512 <i>hash</i> algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-whirl</b></b></dt>
  <dd class="It-tag">Use whirlpool <i>hash</i> algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-whirlpool</b></b></dt>
  <dd class="It-tag">Use whirlpool <i>hash</i> algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-jh224</b></b></dt>
  <dd class="It-tag">Use jh-224 <i>hash</i> algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-jh256</b></b></dt>
  <dd class="It-tag">Use jh-256 <i>hash</i> algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-jh384</b></b></dt>
  <dd class="It-tag">Use jh-384 <i>hash</i> algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-jh512</b></b></dt>
  <dd class="It-tag">Use jh-512 <i>hash</i> algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-hmac</b></b></dt>
  <dd class="It-tag">HMAC using specified <i>hash</i> algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-8</b></b></dt>
  <dd class="It-tag">Encode with octal instead <i>of</i> hex.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-10</b></b></dt>
  <dd class="It-tag">Encode with decimal instead <i>of</i> hex.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-H</b>, <b>-HEX</b></b></dt>
  <dd class="It-tag">Encode with UPPERCASE hexadecimal.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-64</b>, <b>-base64</b></b></dt>
  <dd class="It-tag">Encode with base64.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-i64</b>, <b>-i64</b></b></dt>
  <dd class="It-tag">Encode with base64, with rearranged characters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-p64</b>, <b>-p64</b></b></dt>
  <dd class="It-tag">Encode with base64 with a-z,A-Z and _-, for best
      compatibility with 'allowed characters' in websites.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-x64</b>, <b>-x64</b></b></dt>
  <dd class="It-tag">Encode with XXencode style base64.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-u64</b>, <b>-u64</b></b></dt>
  <dd class="It-tag">Encode with UUencode style base64.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-g64</b>, <b>-g64</b></b></dt>
  <dd class="It-tag">Encode with GEDCOM style base64.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-a85</b>, <b>-a85</b></b></dt>
  <dd class="It-tag">Encode with ASCII85.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-z85</b>, <b>-z85</b></b></dt>
  <dd class="It-tag">Encode with ZEROMQ variant of ASCII85. <b>-t</b>,
      <b>-trad</b> Output <i>hashes</i> in traditional md5sum, shaXsum
    format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-tag</b>, <b>--tag</b> <b>-bsd</b></b></dt>
  <dd class="It-tag">Output <i>hashes</i> in bsdsum format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-r</b></b></dt>
  <dd class="It-tag">Recurse into directories when hashing files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-f</b> &lt;listfile&gt;</b></dt>
  <dd class="It-tag">Hash files listed in &lt;listfile&gt;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-i</b> &lt;pattern&gt;</b></dt>
  <dd class="It-tag">Only <i>hash</i> items matching &lt;pattern&gt;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-x</b> &lt;pattern&gt;</b></dt>
  <dd class="It-tag">Exclude items matching &lt;pattern&gt;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-n</b> &lt;length&gt;</b></dt>
  <dd class="It-tag">Truncate <i>hashes</i> <i>to</i> &lt;length&gt; bytes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-c</b></b></dt>
  <dd class="It-tag">CHECK <i>hashes</i> against list from <i>file</i> (or
      stdin).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-cf</b></b></dt>
  <dd class="It-tag">CHECK <i>hashes</i> but only show failures.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-C &lt;dir&gt;</b></b></dt>
  <dd class="It-tag">CHECK <i>files</i> under dir recursively against a list
      from <i>file</i> (or stdin). This can detect 'new' files</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-Cf &lt;dir&gt;</b></b></dt>
  <dd class="It-tag">CHECK <i>files</i> under dir recursively against a list
      from <i>file</i> (or stdin). This can detect 'new' files. Only show
      failures.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-m</b></b></dt>
  <dd class="It-tag">MATCH files from a list read from stdin.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-lm</b></b></dt>
  <dd class="It-tag">Read <i>hashes</i> from stdin, upload them <i>to</i> a
      memcached server (requires the <b>-memcached</b> option).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-X</b>, <b>-exec</b></b></dt>
  <dd class="It-tag">In CHECK or MATCH mode only examine executable files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-dups</b></b></dt>
  <dd class="It-tag">Search for duplicate files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-memcached</b> &lt;server&gt;, <b>-mcd</b>
    &lt;server&gt;</b></dt>
  <dd class="It-tag">Specify memcached server. This option overrides reading
      list from stdin if used with <b>-m</b>, <b>-c</b> or <b>-cf</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-h</b> &lt;script&gt;</b></dt>
  <dd class="It-tag">Script <i>to</i> run when a <i>file</i> fails CHECK mode,
      or is found in MATCH mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-hook</b> &lt;script&gt;</b></dt>
  <dd class="It-tag">Script <i>to</i> run when a <i>file</i> fails CHECK mode,
      or is found in FIND mode</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-color</b></b></dt>
  <dd class="It-tag">Use ANSI color codes on output when checking
    <i>hashes</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-S</b>, <b>-strict</b></b></dt>
  <dd class="It-tag">Strict mode: when checking, check <i>file</i> mtime, owner,
      group, and inode as well as it's <i>hash</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-d</b></b></dt>
  <dd class="It-tag">Dereference (follow) symlinks.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-fs</b></b></dt>
  <dd class="It-tag">Stay one filesystem.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-dir</b></b></dt>
  <dd class="It-tag"><b>-dirmode</b> DirMode: read all files in directory and
      create one <i>hash</i> for them (implies -r).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-devmode</b></b></dt>
  <dd class="It-tag">DevMode: read from a <i>file</i> EVEN OF IT'S A
    DEVNODE.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-lines</b></b></dt>
  <dd class="It-tag">Read lines from stdin and <i>hash</i> each line
      independently.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-rl</b>, <b>-rawlines</b></b></dt>
  <dd class="It-tag">Read lines from stdin and <i>hash</i> each line
      independently, INCLUDING any trailing whitespace. This is compatible with
      'echo text | md5sum'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-cgi</b></b></dt>
  <dd class="It-tag">Run in HTTP CGI mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-net</b></b></dt>
  <dd class="It-tag">Treat '<i>file</i>' arguments as either ssh or http URLs,
      and pull files over the network and then <i>hash</i> them (allows hashing
      <i>of</i> files on remote machines). URLs are in the format
      ssh://[username]:[password]@[host]:[port] or
      http://[username]:[password]@[host]:[port].</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-idfile</b> &lt;path&gt;</b></dt>
  <dd class="It-tag">Path <i>to</i> a ssh private key <i>file</i> <i>to</i> use
      <i>to</i> authenticate INSTEAD OF A PASSWORD when pulling files via
    ssh.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-xattr</b></b></dt>
  <dd class="It-tag">Use eXtended <i>file</i> ATTRibutes. In <i>hash</i> mode,
      store <i>hashes</i> in the <i>file</i> attributes. In check mode compare
      against <i>hashes</i> stored in <i>file</i> attributes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-txattr</b></b></dt>
  <dd class="It-tag">Use TRUSTED eXtended <i>file</i> ATTRibutes. In <i>hash</i>
      mode, store <i>hashes</i> in trusted <i>file</i> attributes. The trusted
      attributes can only be read and written by root. Under FreeBSD this means
      'SYSTEM' attributes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-cache</b></b></dt>
  <dd class="It-tag">Use <i>hashes</i> stored in user xattr if they're younger
      than the mtime <i>of</i> the <i>file</i>. This speeds up outputting
      <i>hashes</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-u</b> &lt;types&gt;</b></dt>
  <dd class="It-tag">Update. In checking mode, update <i>hashes</i> for the
      files as you go. The &lt;types&gt; is a comma-separated list <i>of</i>
      things <i>to</i> update, which can be xattr memcached or a <i>file</i>
      name. This will update these targets with the <i>hash</i> that was found
      at the time <i>of</i> checking.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-hide</b>-<i>input</i></b></dt>
  <dd class="It-tag">When reading data from stdin in linemode, set the terminal
      <i>to</i> not echo characters, thus hiding typed <i>input</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-xsel</b></b></dt>
  <dd class="It-tag">Update X11 clipboard and primary selections to the current
      hash. This works using Xterm command sequences. The xterm resource
      'allowWindowOps' must be set to 'true' for this to work.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>-star</b>-<i>input</i></b></dt>
  <dd class="It-tag">When reading data from stdin in linemode replace characters
      with stars.</dd>
</dl>
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
Hashrat can also detect if it's being run under any <i>of</i> the following
  names (e.g., via symlinks):
<dl class="Bl-tag">
  <dt class="It-tag"><b>md5sum</b></dt>
  <dd class="It-tag">Run with '<b>-trad</b> <b>-md5</b>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>shasum</b></dt>
  <dd class="It-tag">Run with '<b>-trad</b> <b>-sha1</b>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sha1sum</b></dt>
  <dd class="It-tag">Run with '<b>-trad</b> <b>-sha1</b>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sha256sum</b></dt>
  <dd class="It-tag">Run with '<b>-trad</b> <b>-sha256</b>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sha512sum</b></dt>
  <dd class="It-tag">Run with '<b>-trad</b> <b>-sha512</b>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>jh224sum</b></dt>
  <dd class="It-tag">Run with '<b>-trad</b> <b>-jh224</b>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>jh256sum</b></dt>
  <dd class="It-tag">Run with '<b>-trad</b> <b>-jh256</b>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>jh384sum</b></dt>
  <dd class="It-tag">Run with '<b>-trad</b> <b>-jh384</b>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>jh512sum</b></dt>
  <dd class="It-tag">Run with '<b>-trad</b> <b>-jh512</b>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>whirlpoolsum</b></dt>
  <dd class="It-tag">Run with '<b>-trad</b> <b>-whirl</b>'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hashrat.cgi</b></dt>
  <dd class="It-tag">Run in web-enabled 'cgi mode'.</dd>
</dl>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b></b></dt>
  <dd class="It-tag">Generate a md5 <i>hash</i> <i>of</i> data read from stdin
      (default <i>hash</i> type is md5).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-jh256</b></b></dt>
  <dd class="It-tag">Generate a jh-256 <i>hash</i> <i>of</i> data read from
      stdin.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-sha256</b> <b>-64</b></b></dt>
  <dd class="It-tag">Generate a sha-256 <i>hash</i> <i>of</i> data read from
      stdin, output with base64 encoding.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-sha256</b> <b>-64</b>
    <b>-lines</b></b></dt>
  <dd class="It-tag">Read lines from stdin, and generate a sha-256 with base64
      encoding FOR EVERY LINE. This strips any whitespace from the end <i>of</i>
      the line (including \r and/or \n line terminators).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-md5</b> <b>-trad</b>
    <b>-rawlines</b></b></dt>
  <dd class="It-tag">Read lines from stdin, and generate a md5 <i>hash</i> in
      traditional format for every line INCLUDING TRAILING WHITESPACE. This is
      compatible with 'echo text | md5sum', where text is one line, as echo adds
      a newline <i>to</i> the end <i>of</i> the text it outputs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-type sha256,whirl,md5</b>
    <b>-64</b></b></dt>
  <dd class="It-tag">Generate a sha-256 <i>hash</i> <i>of</i> data read from
      stdin, then hash the result with whirlpool, then with md5.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> *</b></dt>
  <dd class="It-tag">Generate a list <i>of</i> <i>hashes</i> for files in the
      current directory (default <i>hash</i> type is md5).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-r</b> <b>-sha1</b> * &gt;
    hashes.sha1</b></dt>
  <dd class="It-tag">Generate a list <i>of</i> <i>hashes</i> for files in the
      current directory, AND ALL SUBDIRECTORIES, using sha1 hashing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cat hashes.sha1 &gt; <b>hashrat</b> <b>-c</b></b></dt>
  <dd class="It-tag">Check <i>hashes</i> listed in hashes.sha1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cat hashes.sha1 &gt; <b>hashrat</b> <b>-c</b>
    <b>-strict</b></b></dt>
  <dd class="It-tag">Check <i>hashes</i> listed in hashes.sha1. If <i>hashes</i>
      are NOT in traditional format than the <b>-strict</b> flag will cause
      <b>hashrat</b> <i>to</i> check the files uid, gid, size, mtime and inode
      and print a failure message if any <i>of</i> those don't match.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cat hashes.sha1 &gt; <b>hashrat</b> <b>-cf</b></b></dt>
  <dd class="It-tag">Check <i>hashes</i> listed in hashes.sha1 but only output
      failures.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cat APT1.md5 | <b>hashrat</b> <b>-m</b> <b>-r</b>
    /</b></dt>
  <dd class="It-tag">Read a list <i>of</i> <i>hashes</i> from stdin and search
      recursively for files matching them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cat APT1.md5 | <b>hashrat</b> <b>-lm</b>
    <b>-memcached</b> 127.0.0.1</b></dt>
  <dd class="It-tag">Read a list <i>of</i> <i>hashes</i> from stdin, and
      register them in a memcached server.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-m</b> <b>-memcached</b> 127.0.0.1
    <b>-r</b> /</b></dt>
  <dd class="It-tag">Search recursively for files whose <i>hashes</i> are stored
      in a memcached server.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-devmode</b> <b>-whirlpool</b>
    <b>-64</b> /dev/sda1</b></dt>
  <dd class="It-tag">Generate a whirlpool <i>hash</i> <i>of</i> the entire
      device /dev/sda1. Output result in base 64.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-sha1</b> <b>-net</b>
    ssh:user:password@myhost/bin/*</b></dt>
  <dd class="It-tag">Generate sha1 <i>hashes</i> <i>of</i> files in /bin/* on
      the remote machine 'myhost'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-whirlpool</b> <b>-net</b>
    http://myhost.com/webpage.html</b></dt>
  <dd class="It-tag">Generate whirlpool <i>hash</i> for the listed URL. Note,
      many webpages have dynamic content that changes every time, so this will
      only return the same <i>hash</i> over and over if the page is static and
      doesn't change.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><b>hashrat</b> <b>-dups</b> <b>-r</b> /home <b>-u</b>
    xattr</b></dt>
  <dd class="It-tag">Search for duplicate files under /home. Update
      <i>hashes</i> stored in filesystem attributes as you go.</dd>
</dl>
<h1 class="Sh" title="Sh" id="USES_FOR_HASHRAT"><a class="selflink" href="#USES_FOR_HASHRAT">USES
  FOR HASHRAT</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">1)</dt>
  <dd class="It-tag">Strong Passwords</dd>
</dl>
<div class="Pp"></div>
Hashrat can be used <i>to</i> generate strong passwords for websites. So, you
  don't have <i>to</i> remember the strong password, if it be always regenerate
  with <b>hashrat</b>. You need <i>to</i> remember a handful <i>of</i>
  moderately decent passwords, i.e., things that I can't find by grepping in the
  '10,000 most popular passwords' list[1], and an additional personal pin. Now,
  you need <i>to</i> combine the website name, one <i>of</i> passwords, and the
  personal pin, into a string and feed them into <b>hashrat</b>:
<div class="Pp"></div>
<pre>
    $ echo &quot;facebook.com password 1234&quot; | hashrat -sha1 -64
<div class="Pp"></div>
</pre>
Obviously, a good password isn't 'password' and a good pin isn't '1234', but you
  get the idea. This gives a 28-character string that should take &quot;8.02
  trillion centuries&quot; <i>to</i> crack with a &quot;massive cracking
  array&quot;, according <i>to</i> Steve Gibson's Password haystacks utility[2].
  This is what I then use as my password. Unfortunately some websites won't take
  a 28-character password, and for these you can truncate <i>to</i> the
  appropriate length (using the <b>-n</b> flag), but the results are still
  stronger than anything you could remember, and nothing needs storing on disk
  (as with password managers).
<div class="Pp"></div>
There are some dangers <i>to</i> using the 'echo' method shown above if you are
  on a shared machine, or if someone gets hold <i>of</i> your
  computer/harddrive. On a shared machine someone could type 'ps ax' <i>to</i>
  see all commands running, and if they time it right, they might see your
  command-line with your password in it. Another danger lies in using a shell
  (like bash) that will record your typed commands so you can recall them later.
  Bash stores this information on disk in the <i>file</i> .bash_history, so if
  you use the 'echo' method shown above your password will be saved on disk. To
  combat this <b>hashrat</b> has line mode:
<div class="Pp"></div>
<pre>
    $ hashrat -sha1 -64 -lines
<div class="Pp"></div>
</pre>
This reads lines from stdin, so type into <b>hashrat</b> and then press ENTER,
  and you'll be given the <i>hash</i> <i>of</i> the line you typed. By this
  method your password is neither visible in 'ps ax', nor is ever stored on
  disk.
<div class="Pp"></div>
A <b>-lines</b> will produce a different <i>hash</i> <i>to</i> the 'echo' method
  listed above, because it strips any trailing whiespace off the lines read. If
  you want strict compatibility with 'echo' (by default echo adds a newline
  <i>to</i> the end <i>of</i> the text <i>to</i> output) then use rawlines mode:
<div class="Pp"></div>
<pre>
    $ hashrat -sha1 -64 -rawlines
<div class="Pp"></div>
</pre>
Finally, you can prevent shoulder-surfers seeing you type your password by using
  the <b>-hide</b>-<i>input</i> or <b>-star</b>-<i>input</i> <i>options</i>
  <i>to</i> hide what you type.
<div class="Pp"></div>
<pre>
    [1] https://github.com/discourse/discourse/blob/master/lib/common_passwords/10k-common-passwords.txt
<div class="Pp"></div>
    [2] https://www.grc.com/haystack.htm
<div class="Pp"></div>
</pre>
<dl class="Bl-tag">
  <dt class="It-tag">2)</dt>
  <dd class="It-tag">Watching for <i>file</i> changes</dd>
</dl>
<div class="Pp"></div>
Like md5sum/shasum etc, <b>hashrat</b> can be used <i>to</i> detect changes in
  files that might indicate malicious activity. For instance, in order <i>to</i>
  get early warning <i>of</i> malware like cryptolocker (that encrypts files on
  a users disk, or on network shares, and then demands a ransom for <i>file</i>
  recovery) you can scatter about the disk a number <i>of</i> Canary files that
  should not change. You need record their <i>hashes</i> and regularly check
  them. If they change, you will know something is going on.
<div class="Pp"></div>
Hashes generated by <b>hashrat</b> can be output <i>to</i> a <i>file</i>, or
  stored in extended <i>file</i> attributes, or in a memcached server.
<div class="Pp"></div>
<pre>
    $ hashrat -sha256 -r . &gt; /tmp/files.sha256
<div class="Pp"></div>
    $ hashrat -sha256 -r . -xattr
<div class="Pp"></div>
    $ hashrat -sha256 -r . -memcached
<div class="Pp"></div>
</pre>
Similarly these can then be used <i>to</i> check files later:
<div class="Pp"></div>
<pre>
    $ cat /tmp/files.sha256 | hashrat -c -sha256
<div class="Pp"></div>
    $ hashrat -C . -sha256  -xattr
<div class="Pp"></div>
    $ hashrat -C /tmp -sha256  -memcached
<div class="Pp"></div>
</pre>
Note that -c checks only check the files in the supplied list. The -C flag
  instead checks all files in a directory (supplied on command line) and expects
  to find those in the list. This means that -C can find new files that aren't
  in the list, whereas -c can't.
<br/>
There is a slight difference between xattr/memcached checks and checks where a
  list is read from stdin. Currently when reading from stdin <b>hashrat</b> will
  ONLY check the files in the list. However, in <b>-xattr</b> and
  <b>-memcached</b> mode, it will check all files, outputting and error for
  those where no stored <i>hash</i> can be found. This is likely <i>to</i>
  change in the a future release, with the stdin method being brought into line
  with the others.
<dl class="Bl-tag">
  <dt class="It-tag">3)</dt>
  <dd class="It-tag">Finding files that match <i>hashes</i></dd>
</dl>
<div class="Pp"></div>
Using the <b>-m</b> flag <b>hashrat</b> can be told <i>to</i> read a range
  <i>of</i> <i>hashes</i> from stdin, and then search for files matching those
  <i>hashes</i>. For Example:
<div class="Pp"></div>
<pre>
    $ cat APT1-AppendixE-MD5s.txt | hashrat -r -m /usr
<div class="Pp"></div>
</pre>
The last command will search recursively under /usr for files with <i>hashes</i>
  matching those in APT1-AppendixE-MD5s.txt. The <i>input</i> on stdin must
  begin with a <i>hash</i>, anything written after the <i>hash</i> will be
  treated as a comment <i>to</i> be displayed if a <i>file</i> matching the
  <i>hash</i> is found.
<div class="Pp"></div>
Hashtypes other than md5 can be used thusly:
<div class="Pp"></div>
<pre>
    $ cat sha1-list.lst | hashrat -r -sha1 -m /usr
<div class="Pp"></div>
</pre>
Hashes can also be loaded into a memcached server, so that the same <i>file</i>
  list can be checked on a number <i>of</i> machines, without needing <i>to</i>
  store the hashlist on those machines. First you need load the <i>hashes</i>:
<div class="Pp"></div>
<pre>
    $ cat APT1-AppendixE-MD5s.txt | hashrat -lm -memcached 192.168.1.5
<div class="Pp"></div>
</pre>
The last line loads the <i>hashes</i> <i>to</i> a memcached server at
  192.168.1.5. You can then search against the memcached server by:
<div class="Pp"></div>
<pre>
    $ hashrat -r -m -memcached 192.168.1.5 /usr
<div class="Pp"></div>
</pre>
<dl class="Bl-tag">
  <dt class="It-tag">4)</dt>
  <dd class="It-tag">Find duplicate files</dd>
</dl>
<div class="Pp"></div>
Using the <b>-dups</b> flag (usually in combination with the <b>-r</b> recursive
  flag) <b>hashrat</b> can be set <i>to</i> search for duplicate files and
  output any found <i>to</i> stdout.
<dl class="Bl-tag">
  <dt class="It-tag">5)</dt>
  <dd class="It-tag">CGI Mode</dd>
</dl>
<div class="Pp"></div>
If <b>hashrat</b> is run with the <b>-cgi</b> flag, or if it's run with a name
  <i>of</i> hashrat.cgi (either by renaming the <b>hashrat</b> executable, or
  via a symbolic link) it will output a webpage that allows users <i>to</i> look
  up <i>hashes</i> over the web. This allows <i>to</i> look-up your strong
  passwords even if you don't have access <i>to</i> a local version <i>of</i>
  <b>hashrat</b>.
<h1 class="Sh" title="Sh" id="EXTENDED_FILESYSTEM_ATTRIBUTES"><a class="selflink" href="#EXTENDED_FILESYSTEM_ATTRIBUTES">EXTENDED
  FILESYSTEM ATTRIBUTES</a></h1>
Hashrat can use extended filesystem attributes where these are supported. This
  allows a <i>hash</i> <i>to</i> be stored in the filesystem metadata <i>of</i>
  the target <i>file</i>. This can then be used for checking <i>hashes</i>, or
  for caching <i>hashes</i> <i>to</i> produce faster output during hashing runs.
  There are two types <i>of</i> filesystem attribute, trusted attributes, which
  can only be set and read by root, and user attributes, which can be set and
  read by any user that has the appropriate permissions for the <i>file</i>.
<div class="Pp"></div>
Hashes can be stored against files by using the <b>-xattr</b> option <i>to</i>
  set user attributes:
<div class="Pp"></div>
<pre>
    $ hashrat -sha256 -r . -xattr
<div class="Pp"></div>
</pre>
And using the <b>-txattr</b> flag <i>to</i> set trusted attributes (you must be
  root <i>to</i> set trusted attributes):
<div class="Pp"></div>
<pre>
    # hashrat -sha256 -r . -txattr
<div class="Pp"></div>
</pre>
When checking either flag can be used, but <b>hashrat</b> will always use
  trusted attributes when running as root, if those are available, otherwise it
  will fall back <i>to</i> user attributes.
<div class="Pp"></div>
<pre>
    $ hashrat -c -sha256 -r . -xattr
<div class="Pp"></div>
</pre>
The <b>-cache</b> option allows using stored <i>hashes</i> rather than
  regenerating <i>hashes</i>. It only considers <i>hashes</i> stored in user
  attributes at current.
<div class="Pp"></div>
<pre>
    $ hashrat -r . -cache
<div class="Pp"></div>
</pre>
This makes getting a report <i>of</i> <i>hashes</i> considerably faster, but it
  runs the risk that the <i>hashes</i> may not be accurate. Hashrat will only
  output a <i>hash</i> stored in <i>file</i> attributes if the storage time
  <i>of</i> the <i>hash</i> is younger than the modify time (mtime) <i>of</i>
  the <i>file</i>, however, this means an attacker could change the modify time
  <i>of</i> the <i>file</i> <i>to</i> hide changes they've made. Thus this
  feature should not be used for security checking purposes (but should be safe
  for uses like finding files that have changed and need <i>to</i> be backed up,
  for instance).
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
The <b>hashrat</b> was written by Colum Paget &lt;colums.projects@gmail.com&gt;.
<div class="Pp"></div>
This manual page was written by Joao Eriberto Mota Filho
  &lt;eriberto@debian.org&gt; for the Debian project (but may be used by
  others).</div>
<table class="foot">
  <tr>
    <td class="foot-date">Jan 2015</td>
    <td class="foot-os">HASHRAT 1.5</td>
  </tr>
</table>
</body>
</html>
