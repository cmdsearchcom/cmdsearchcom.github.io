<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:16:26 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>hashrat(1) hashing tool supporting several hashes and
recursivity hashrat(1)</p>

<p style="margin-top: 1em">NAME <br>
hashrat - hashing tool supporting several hashes and
recursivity</p>

<p style="margin-top: 1em">SYNOPSIS <br>
hashrat [options] [paths to hash]</p>

<p style="margin-top: 1em">hashrat -c [options] [input file
of hashes]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Hashrat is a hash-generation utility that supports the md5,
sha1, sha256, sha512, whirlpool, jh-224, jh256, jh-384 and
jh-512 hash functions, and also the HMAC versions of those
<br>
functions. It can output in traditional format (same as
md5sum and shasum and the like) or it&rsquo;s own
format.</p>

<p style="margin-top: 1em">Hashes can be output in octal,
decimal, hexadecimal, uppercase hexadecimal or base64.</p>

<p style="margin-top: 1em">Hashrat also supports directory
recursion, hashing entire devices, and generating a hash for
an entire directory. It has a CGI mode that can be used as a
web-page to lookup <br>
hashes.</p>

<p style="margin-top: 1em">OPTIONS <br>
-?, -help, --help <br>
Print this help.</p>

<p style="margin-top: 1em">-version, --version <br>
Print program version.</p>

<p style="margin-top: 1em">-type &lt;type&gt; <br>
Use hash algorithm &lt;type&gt;. Hash types can be chained
as a comma-seperated list.</p>

<p style="margin-top: 1em">-md5 Use md5 hash algorithm.
This is the default hash.</p>

<p style="margin-top: 1em">-sha1 Use sha1 hash
algorithm.</p>

<p style="margin-top: 1em">-sha256 <br>
Use sha256 hash algorithm.</p>

<p style="margin-top: 1em">-sha512 <br>
Use sha512 hash algorithm.</p>

<p style="margin-top: 1em">-whirl Use whirlpool hash
algorithm.</p>

<p style="margin-top: 1em">-whirlpool <br>
Use whirlpool hash algorithm.</p>

<p style="margin-top: 1em">-jh224 Use jh-224 hash
algorithm.</p>

<p style="margin-top: 1em">-jh256 Use jh-256 hash
algorithm.</p>

<p style="margin-top: 1em">-jh384 Use jh-384 hash
algorithm.</p>

<p style="margin-top: 1em">-jh512 Use jh-512 hash
algorithm.</p>

<p style="margin-top: 1em">-hmac HMAC using specified hash
algorithm.</p>

<p style="margin-top: 1em">-8 Encode with octal instead of
hex.</p>

<p style="margin-top: 1em">-10 Encode with decimal instead
of hex.</p>

<p style="margin-top: 1em">-H, -HEX <br>
Encode with UPPERCASE hexadecimal.</p>

<p style="margin-top: 1em">-64, -base64 <br>
Encode with base64.</p>

<p style="margin-top: 1em">-i64, -i64 <br>
Encode with base64, with rearranged characters.</p>

<p style="margin-top: 1em">-p64, -p64 <br>
Encode with base64 with a-z,A-Z and _-, for best
compatibility with &rsquo;allowed characters&rsquo; in
websites.</p>

<p style="margin-top: 1em">-x64, -x64 <br>
Encode with XXencode style base64.</p>

<p style="margin-top: 1em">-u64, -u64 <br>
Encode with UUencode style base64.</p>

<p style="margin-top: 1em">-g64, -g64 <br>
Encode with GEDCOM style base64.</p>

<p style="margin-top: 1em">-a85, -a85 <br>
Encode with ASCII85.</p>

<p style="margin-top: 1em">-z85, -z85 <br>
Encode with ZEROMQ variant of ASCII85. -t, -trad Output
hashes in traditional md5sum, shaXsum format.</p>

<p style="margin-top: 1em">-tag, --tag -bsd <br>
Output hashes in bsdsum format.</p>

<p style="margin-top: 1em">-r Recurse into directories when
hashing files.</p>

<p style="margin-top: 1em">-f &lt;listfile&gt; <br>
Hash files listed in &lt;listfile&gt;.</p>

<p style="margin-top: 1em">-i &lt;pattern&gt; <br>
Only hash items matching &lt;pattern&gt;.</p>

<p style="margin-top: 1em">-x &lt;pattern&gt; <br>
Exclude items matching &lt;pattern&gt;.</p>

<p style="margin-top: 1em">-n &lt;length&gt; <br>
Truncate hashes to &lt;length&gt; bytes.</p>

<p style="margin-top: 1em">-c CHECK hashes against list
from file (or stdin).</p>

<p style="margin-top: 1em">-cf CHECK hashes but only show
failures.</p>

<p style="margin-top: 1em">-C &lt;dir&gt; <br>
CHECK files under dir recursively against a list from file
(or stdin). This can detect &rsquo;new&rsquo; files</p>

<p style="margin-top: 1em">-Cf &lt;dir&gt; <br>
CHECK files under dir recursively against a list from file
(or stdin). This can detect &rsquo;new&rsquo; files. Only
show failures.</p>

<p style="margin-top: 1em">-m MATCH files from a list read
from stdin.</p>

<p style="margin-top: 1em">-lm Read hashes from stdin,
upload them to a memcached server (requires the -memcached
option).</p>

<p style="margin-top: 1em">-X, -exec <br>
In CHECK or MATCH mode only examine executable files.</p>

<p style="margin-top: 1em">-dups Search for duplicate
files.</p>

<p style="margin-top: 1em">-memcached &lt;server&gt;, -mcd
&lt;server&gt; <br>
Specify memcached server. This option overrides reading list
from stdin if used with -m, -c or -cf.</p>

<p style="margin-top: 1em">-h &lt;script&gt; <br>
Script to run when a file fails CHECK mode, or is found in
MATCH mode.</p>

<p style="margin-top: 1em">-hook &lt;script&gt; <br>
Script to run when a file fails CHECK mode, or is found in
FIND mode</p>

<p style="margin-top: 1em">-color Use ANSI color codes on
output when checking hashes.</p>

<p style="margin-top: 1em">-S, -strict <br>
Strict mode: when checking, check file mtime, owner, group,
and inode as well as it&rsquo;s hash.</p>

<p style="margin-top: 1em">-d Dereference (follow)
symlinks.</p>

<p style="margin-top: 1em">-fs Stay one filesystem.</p>

<p style="margin-top: 1em">-dir -dirmode DirMode: read all
files in directory and create one hash for them (implies
-r).</p>

<p style="margin-top: 1em">-devmode <br>
DevMode: read from a file EVEN OF IT&rsquo;S A DEVNODE.</p>

<p style="margin-top: 1em">-lines Read lines from stdin and
hash each line independently.</p>

<p style="margin-top: 1em">-rl, -rawlines <br>
Read lines from stdin and hash each line independently,
INCLUDING any trailing whitespace. This is compatible with
&rsquo;echo text | md5sum&rsquo;.</p>

<p style="margin-top: 1em">-cgi Run in HTTP CGI mode.</p>

<p style="margin-top: 1em">-net Treat &rsquo;file&rsquo;
arguments as either ssh or http URLs, and pull files over
the network and then hash them (allows hashing of files on
remote machines). URLs are in the format <br>
ssh://[username]:[password]@[host]:[port] or
http://[username]:[password]@[host]:[port].</p>

<p style="margin-top: 1em">-idfile &lt;path&gt; <br>
Path to a ssh private key file to use to authenticate
INSTEAD OF A PASSWORD when pulling files via ssh.</p>

<p style="margin-top: 1em">-xattr Use eXtended file
ATTRibutes. In hash mode, store hashes in the file
attributes. In check mode compare against hashes stored in
file attributes.</p>

<p style="margin-top: 1em">-txattr <br>
Use TRUSTED eXtended file ATTRibutes. In hash mode, store
hashes in trusted file attributes. The trusted attributes
can only be read and written by root. Under FreeBSD <br>
this means &rsquo;SYSTEM&rsquo; attributes.</p>

<p style="margin-top: 1em">-cache Use hashes stored in user
xattr if they&rsquo;re younger than the mtime of the file.
This speeds up outputting hashes.</p>

<p style="margin-top: 1em">-u &lt;types&gt; <br>
Update. In checking mode, update hashes for the files as you
go. The &lt;types&gt; is a comma-separated list of things to
update, which can be xattr memcached or a file name. <br>
This will update these targets with the hash that was found
at the time of checking.</p>

<p style="margin-top: 1em">-hide-input <br>
When reading data from stdin in linemode, set the terminal
to not echo characters, thus hiding typed input.</p>

<p style="margin-top: 1em">-xsel Update X11 clipboard and
primary selections to the current hash. This works using
Xterm command sequences. The xterm resource
&rsquo;allowWindowOps&rsquo; must be set to
&rsquo;true&rsquo; for <br>
this to work.</p>

<p style="margin-top: 1em">-star-input <br>
When reading data from stdin in linemode replace characters
with stars.</p>

<p style="margin-top: 1em">NOTES <br>
Hashrat can also detect if it&rsquo;s being run under any of
the following names (e.g., via symlinks):</p>

<p style="margin-top: 1em">md5sum Run with &rsquo;-trad
-md5&rsquo;.</p>

<p style="margin-top: 1em">shasum Run with &rsquo;-trad
-sha1&rsquo;.</p>

<p style="margin-top: 1em">sha1sum <br>
Run with &rsquo;-trad -sha1&rsquo;.</p>

<p style="margin-top: 1em">sha256sum <br>
Run with &rsquo;-trad -sha256&rsquo;.</p>

<p style="margin-top: 1em">sha512sum <br>
Run with &rsquo;-trad -sha512&rsquo;.</p>

<p style="margin-top: 1em">jh224sum <br>
Run with &rsquo;-trad -jh224&rsquo;.</p>

<p style="margin-top: 1em">jh256sum <br>
Run with &rsquo;-trad -jh256&rsquo;.</p>

<p style="margin-top: 1em">jh384sum <br>
Run with &rsquo;-trad -jh384&rsquo;.</p>

<p style="margin-top: 1em">jh512sum <br>
Run with &rsquo;-trad -jh512&rsquo;.</p>

<p style="margin-top: 1em">whirlpoolsum <br>
Run with &rsquo;-trad -whirl&rsquo;.</p>

<p style="margin-top: 1em">hashrat.cgi <br>
Run in web-enabled &rsquo;cgi mode&rsquo;.</p>

<p style="margin-top: 1em">EXAMPLES <br>
hashrat <br>
Generate a md5 hash of data read from stdin (default hash
type is md5).</p>

<p style="margin-top: 1em">hashrat -jh256 <br>
Generate a jh-256 hash of data read from stdin.</p>

<p style="margin-top: 1em">hashrat -sha256 -64 <br>
Generate a sha-256 hash of data read from stdin, output with
base64 encoding.</p>

<p style="margin-top: 1em">hashrat -sha256 -64 -lines <br>
Read lines from stdin, and generate a sha-256 with base64
encoding FOR EVERY LINE. This strips any whitespace
fromand/or line termi&acirc; the end of the line (including
<br>
nators).</p>

<p style="margin-top: 1em">hashrat -md5 -trad -rawlines
<br>
Read lines from stdin, and generate a md5 hash in
traditional format for every line INCLUDING TRAILING
WHITESPACE. This is compatible with &rsquo;echo text |
md5sum&rsquo;, where <br>
text is one line, as echo adds a newline to the end of the
text it outputs.</p>

<p style="margin-top: 1em">hashrat -type sha256,whirl,md5
-64 <br>
Generate a sha-256 hash of data read from stdin, then hash
the result with whirlpool, then with md5.</p>

<p style="margin-top: 1em">hashrat * <br>
Generate a list of hashes for files in the current directory
(default hash type is md5).</p>

<p style="margin-top: 1em">hashrat -r -sha1 * &gt;
hashes.sha1 <br>
Generate a list of hashes for files in the current
directory, AND ALL SUBDIRECTORIES, using sha1 hashing.</p>

<p style="margin-top: 1em">cat hashes.sha1 &gt; hashrat -c
<br>
Check hashes listed in hashes.sha1.</p>

<p style="margin-top: 1em">cat hashes.sha1 &gt; hashrat -c
-strict <br>
Check hashes listed in hashes.sha1. If hashes are NOT in
traditional format than the -strict flag will cause hashrat
to check the files uid, gid, size, mtime and inode and <br>
print a failure message if any of those don&rsquo;t
match.</p>

<p style="margin-top: 1em">cat hashes.sha1 &gt; hashrat -cf
<br>
Check hashes listed in hashes.sha1 but only output
failures.</p>

<p style="margin-top: 1em">cat APT1.md5 | hashrat -m -r /
<br>
Read a list of hashes from stdin and search recursively for
files matching them.</p>

<p style="margin-top: 1em">cat APT1.md5 | hashrat -lm
-memcached 127.0.0.1 <br>
Read a list of hashes from stdin, and register them in a
memcached server.</p>

<p style="margin-top: 1em">hashrat -m -memcached 127.0.0.1
-r / <br>
Search recursively for files whose hashes are stored in a
memcached server.</p>

<p style="margin-top: 1em">hashrat -devmode -whirlpool -64
/dev/sda1 <br>
Generate a whirlpool hash of the entire device /dev/sda1.
Output result in base 64.</p>

<p style="margin-top: 1em">hashrat -sha1 -net
ssh:user:password@myhost/bin/* <br>
Generate sha1 hashes of files in /bin/* on the remote
machine &rsquo;myhost&rsquo;.</p>

<p style="margin-top: 1em">hashrat -whirlpool -net
http://myhost.com/webpage.html <br>
Generate whirlpool hash for the listed URL. Note, many
webpages have dynamic content that changes every time, so
this will only return the same hash over and over if the
<br>
page is static and doesn&rsquo;t change.</p>

<p style="margin-top: 1em">hashrat -dups -r /home -u xattr
<br>
Search for duplicate files under /home. Update hashes stored
in filesystem attributes as you go.</p>

<p style="margin-top: 1em">USES FOR HASHRAT <br>
1) Strong Passwords</p>

<p style="margin-top: 1em">Hashrat can be used to generate
strong passwords for websites. So, you don&rsquo;t have to
remember the strong password, if it be always regenerate
with hashrat. You need to remember <br>
a handful of moderately decent passwords, i.e., things that
I can&rsquo;t find by grepping in the &rsquo;10,000 most
popular passwords&rsquo; list[1], and an additional personal
pin. Now, you need <br>
to combine the website name, one of passwords, and the
personal pin, into a string and feed them into hashrat:</p>

<p style="margin-top: 1em">$ echo &quot;facebook.com
password 1234&quot; | hashrat -sha1 -64</p>

<p style="margin-top: 1em">Obviously, a good password
isn&rsquo;t &rsquo;password&rsquo; and a good pin
isn&rsquo;t &rsquo;1234&rsquo;, but you get the idea. This
gives a 28-character string that should take &quot;8.02
trillion centuries&quot; to <br>
crack with a &quot;massive cracking array&quot;, according
to Steve Gibson&rsquo;s Password haystacks utility[2]. This
is what I then use as my password. Unfortunately some
websites won&rsquo;t take a <br>
28-character password, and for these you can truncate to the
appropriate length (using the -n flag), but the results are
still stronger than anything you could remember, and <br>
nothing needs storing on disk (as with password
managers).</p>

<p style="margin-top: 1em">There are some dangers to using
the &rsquo;echo&rsquo; method shown above if you are on a
shared machine, or if someone gets hold of your
computer/harddrive. On a shared machine someone <br>
could type &rsquo;ps ax&rsquo; to see all commands running,
and if they time it right, they might see your command-line
with your password in it. Another danger lies in using a
shell (like <br>
bash) that will record your typed commands so you can recall
them later. Bash stores this information on disk in the file
.bash_history, so if you use the &rsquo;echo&rsquo; method
shown <br>
above your password will be saved on disk. To combat this
hashrat has line mode:</p>

<p style="margin-top: 1em">$ hashrat -sha1 -64 -lines</p>

<p style="margin-top: 1em">This reads lines from stdin, so
type into hashrat and then press ENTER, and you&rsquo;ll be
given the hash of the line you typed. By this method your
password is neither visible in &rsquo;ps <br>
ax&rsquo;, nor is ever stored on disk.</p>

<p style="margin-top: 1em">A -lines will produce a
different hash to the &rsquo;echo&rsquo; method listed
above, because it strips any trailing whiespace off the
lines read. If you want strict compatibility with <br>
&rsquo;echo&rsquo; (by default echo adds a newline to the
end of the text to output) then use rawlines mode:</p>

<p style="margin-top: 1em">$ hashrat -sha1 -64
-rawlines</p>

<p style="margin-top: 1em">Finally, you can prevent
shoulder-surfers seeing you type your password by using the
-hide-input or -star-input options to hide what you
type.</p>

<p style="margin-top: 1em">[1]
https://github.com/discourse/discourse/blob/master/lib/common_passwords/10k-common-passwords.txt</p>

<p style="margin-top: 1em">[2]
https://www.grc.com/haystack.htm</p>

<p style="margin-top: 1em">2) Watching for file changes</p>

<p style="margin-top: 1em">Like md5sum/shasum etc, hashrat
can be used to detect changes in files that might indicate
malicious activity. For instance, in order to get early
warning of malware like cryp&acirc; <br>
tolocker (that encrypts files on a users disk, or on network
shares, and then demands a ransom for file recovery) you can
scatter about the disk a number of Canary files that <br>
should not change. You need record their hashes and
regularly check them. If they change, you will know
something is going on.</p>

<p style="margin-top: 1em">Hashes generated by hashrat can
be output to a file, or stored in extended file attributes,
or in a memcached server.</p>

<p style="margin-top: 1em">$ hashrat -sha256 -r . &gt;
/tmp/files.sha256</p>

<p style="margin-top: 1em">$ hashrat -sha256 -r .
-xattr</p>

<p style="margin-top: 1em">$ hashrat -sha256 -r .
-memcached</p>

<p style="margin-top: 1em">Similarly these can then be used
to check files later:</p>

<p style="margin-top: 1em">$ cat /tmp/files.sha256 |
hashrat -c -sha256</p>

<p style="margin-top: 1em">$ hashrat -C . -sha256
-xattr</p>

<p style="margin-top: 1em">$ hashrat -C /tmp -sha256
-memcached</p>

<p style="margin-top: 1em">Note that -c checks only check
the files in the supplied list. The -C flag instead checks
all files in a directory (supplied on command line) and
expects to find those in the <br>
list. This means that -C can find new files that
aren&rsquo;t in the list, whereas -c can&rsquo;t. <br>
There is a slight difference between xattr/memcached checks
and checks where a list is read from stdin. Currently when
reading from stdin hashrat will ONLY check the files in the
<br>
list. However, in -xattr and -memcached mode, it will check
all files, outputting and error for those where no stored
hash can be found. This is likely to change in the a future
<br>
release, with the stdin method being brought into line with
the others.</p>

<p style="margin-top: 1em">3) Finding files that match
hashes</p>

<p style="margin-top: 1em">Using the -m flag hashrat can be
told to read a range of hashes from stdin, and then search
for files matching those hashes. For Example:</p>

<p style="margin-top: 1em">$ cat APT1-AppendixE-MD5s.txt |
hashrat -r -m /usr</p>

<p style="margin-top: 1em">The last command will search
recursively under /usr for files with hashes matching those
in APT1-AppendixE-MD5s.txt. The input on stdin must begin
with a hash, anything written <br>
after the hash will be treated as a comment to be displayed
if a file matching the hash is found.</p>

<p style="margin-top: 1em">Hashtypes other than md5 can be
used thusly:</p>

<p style="margin-top: 1em">$ cat sha1-list.lst | hashrat -r
-sha1 -m /usr</p>

<p style="margin-top: 1em">Hashes can also be loaded into a
memcached server, so that the same file list can be checked
on a number of machines, without needing to store the
hashlist on those machines. <br>
First you need load the hashes:</p>

<p style="margin-top: 1em">$ cat APT1-AppendixE-MD5s.txt |
hashrat -lm -memcached 192.168.1.5</p>

<p style="margin-top: 1em">The last line loads the hashes
to a memcached server at 192.168.1.5. You can then search
against the memcached server by:</p>

<p style="margin-top: 1em">$ hashrat -r -m -memcached
192.168.1.5 /usr</p>

<p style="margin-top: 1em">4) Find duplicate files</p>

<p style="margin-top: 1em">Using the -dups flag (usually in
combination with the -r recursive flag) hashrat can be set
to search for duplicate files and output any found to
stdout.</p>

<p style="margin-top: 1em">5) CGI Mode</p>

<p style="margin-top: 1em">If hashrat is run with the -cgi
flag, or if it&rsquo;s run with a name of hashrat.cgi
(either by renaming the hashrat executable, or via a
symbolic link) it will output a webpage that <br>
allows users to look up hashes over the web. This allows to
look-up your strong passwords even if you don&rsquo;t have
access to a local version of hashrat.</p>

<p style="margin-top: 1em">EXTENDED FILESYSTEM ATTRIBUTES
<br>
Hashrat can use extended filesystem attributes where these
are supported. This allows a hash to be stored in the
filesystem metadata of the target file. This can then be
used for <br>
checking hashes, or for caching hashes to produce faster
output during hashing runs. There are two types of
filesystem attribute, trusted attributes, which can only be
set and <br>
read by root, and user attributes, which can be set and read
by any user that has the appropriate permissions for the
file.</p>

<p style="margin-top: 1em">Hashes can be stored against
files by using the -xattr option to set user attributes:</p>

<p style="margin-top: 1em">$ hashrat -sha256 -r .
-xattr</p>

<p style="margin-top: 1em">And using the -txattr flag to
set trusted attributes (you must be root to set trusted
attributes):</p>

<p style="margin-top: 1em"># hashrat -sha256 -r .
-txattr</p>

<p style="margin-top: 1em">When checking either flag can be
used, but hashrat will always use trusted attributes when
running as root, if those are available, otherwise it will
fall back to user <br>
attributes.</p>

<p style="margin-top: 1em">$ hashrat -c -sha256 -r .
-xattr</p>

<p style="margin-top: 1em">The -cache option allows using
stored hashes rather than regenerating hashes. It only
considers hashes stored in user attributes at current.</p>

<p style="margin-top: 1em">$ hashrat -r . -cache</p>

<p style="margin-top: 1em">This makes getting a report of
hashes considerably faster, but it runs the risk that the
hashes may not be accurate. Hashrat will only output a hash
stored in file attributes if <br>
the storage time of the hash is younger than the modify time
(mtime) of the file, however, this means an attacker could
change the modify time of the file to hide changes
they&rsquo;ve <br>
made. Thus this feature should not be used for security
checking purposes (but should be safe for uses like finding
files that have changed and need to be backed up, for <br>
instance).</p>

<p style="margin-top: 1em">AUTHOR <br>
The hashrat was written by Colum Paget
&lt;colums.projects@gmail.com&gt;.</p>

<p style="margin-top: 1em">This manual page was written by
Joao Eriberto Mota Filho &lt;eriberto@debian.org&gt; for the
Debian project (but may be used by others).</p>

<p style="margin-top: 1em">HASHRAT 1.5 Jan 2015
hashrat(1)</p>
<hr>
</body>
</html>
