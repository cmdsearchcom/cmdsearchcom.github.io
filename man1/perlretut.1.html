<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLRETUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLRETUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLRETUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlretut - Perl regular expressions tutorial
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This page provides a basic tutorial on understanding, creating and using regular
  expressions in Perl. It serves as a complement to the reference page on
  regular expressions perlre. Regular expressions are an integral part of the
  &quot;m//&quot;, &quot;s///&quot;, &quot;qr//&quot; and &quot;split&quot;
  operators and so this tutorial also overlaps with &quot;Regexp Quote-Like
  Operators&quot; in perlop and &quot;split&quot; in perlfunc.
<div class="Pp"></div>
Perl is widely renowned for excellence in text processing, and regular
  expressions are one of the big factors behind this fame. Perl regular
  expressions display an efficiency and flexibility unknown in most other
  computer languages. Mastering even the basics of regular expressions will
  allow you to manipulate text with surprising ease.
<div class="Pp"></div>
What is a regular expression? A regular expression is simply a string that
  describes a pattern. Patterns are in common use these days; examples are the
  patterns typed into a search engine to find web pages and the patterns used to
  list files in a directory, e.g., &quot;ls *.txt&quot; or &quot;dir *.*&quot;.
  In Perl, the patterns described by regular expressions are used to search
  strings, extract desired parts of strings, and to do search and replace
  operations.
<div class="Pp"></div>
Regular expressions have the undeserved reputation of being abstract and
  difficult to understand. Regular expressions are constructed using simple
  concepts like conditionals and loops and are no more difficult to understand
  than the corresponding &quot;if&quot; conditionals and &quot;while&quot; loops
  in the Perl language itself. In fact, the main challenge in learning regular
  expressions is just getting used to the terse notation used to express these
  concepts.
<div class="Pp"></div>
This tutorial flattens the learning curve by discussing regular expression
  concepts, along with their notation, one at a time and with many examples. The
  first part of the tutorial will progress from the simplest word searches to
  the basic regular expression concepts. If you master the first part, you will
  have all the tools needed to solve about 98% of your needs. The second part of
  the tutorial is for those comfortable with the basics and hungry for more
  power tools. It discusses the more advanced regular expression operators and
  introduces the latest cutting-edge innovations.
<div class="Pp"></div>
A note: to save time, 'regular expression' is often abbreviated as regexp or
  regex. Regexp is a more natural abbreviation than regex, but is harder to
  pronounce. The Perl pod documentation is evenly split on regexp vs regex; in
  Perl, there is more than one way to abbreviate it. We'll use regexp in this
  tutorial.
<h1 class="Sh" title="Sh" id="Part_1:_The_basics"><a class="selflink" href="#Part_1:_The_basics">Part
  1: The basics</a></h1>
<h2 class="Ss" title="Ss" id="Simple_word_matching"><a class="selflink" href="#Simple_word_matching">Simple
  word matching</a></h2>
The simplest regexp is simply a word, or more generally, a string of characters.
  A regexp consisting of a word matches any string that contains that word:
<div class="Pp"></div>
<pre>
    &quot;Hello World&quot; =~ /World/;  # matches
</pre>
<div class="Pp"></div>
What is this Perl statement all about? &quot;Hello World&quot; is a simple
  double-quoted string. &quot;World&quot; is the regular expression and the
  &quot;//&quot; enclosing &quot;/World/&quot; tells Perl to search a string for
  a match. The operator &quot;=~&quot; associates the string with the regexp
  match and produces a true value if the regexp matched, or false if the regexp
  did not match. In our case, &quot;World&quot; matches the second word in
  &quot;Hello World&quot;, so the expression is true. Expressions like this are
  useful in conditionals:
<div class="Pp"></div>
<pre>
    if (&quot;Hello World&quot; =~ /World/) {
        print &quot;It matches\n&quot;;
    }
    else {
        print &quot;It doesn't match\n&quot;;
    }
</pre>
<div class="Pp"></div>
There are useful variations on this theme. The sense of the match can be
  reversed by using the &quot;!~&quot; operator:
<div class="Pp"></div>
<pre>
    if (&quot;Hello World&quot; !~ /World/) {
        print &quot;It doesn't match\n&quot;;
    }
    else {
        print &quot;It matches\n&quot;;
    }
</pre>
<div class="Pp"></div>
The literal string in the regexp can be replaced by a variable:
<div class="Pp"></div>
<pre>
    $greeting = &quot;World&quot;;
    if (&quot;Hello World&quot; =~ /$greeting/) {
        print &quot;It matches\n&quot;;
    }
    else {
        print &quot;It doesn't match\n&quot;;
    }
</pre>
<div class="Pp"></div>
If you're matching against the special default variable $_, the &quot;$_
  =~&quot; part can be omitted:
<div class="Pp"></div>
<pre>
    $_ = &quot;Hello World&quot;;
    if (/World/) {
        print &quot;It matches\n&quot;;
    }
    else {
        print &quot;It doesn't match\n&quot;;
    }
</pre>
<div class="Pp"></div>
And finally, the &quot;//&quot; default delimiters for a match can be changed to
  arbitrary delimiters by putting an 'm' out front:
<div class="Pp"></div>
<pre>
    &quot;Hello World&quot; =~ m!World!;   # matches, delimited by '!'
    &quot;Hello World&quot; =~ m{World};   # matches, note the matching '{}'
    &quot;/usr/bin/perl&quot; =~ m&quot;/perl&quot;; # matches after '/usr/bin',
                                 # '/' becomes an ordinary char
</pre>
<div class="Pp"></div>
&quot;/World/&quot;, &quot;m!World!&quot;, and &quot;m{World}&quot; all
  represent the same thing. When, e.g., the quote (&quot;&quot;&quot;) is used
  as a delimiter, the forward slash '/' becomes an ordinary character and can be
  used in this regexp without trouble.
<div class="Pp"></div>
Let's consider how different regexps would match &quot;Hello World&quot;:
<div class="Pp"></div>
<pre>
    &quot;Hello World&quot; =~ /world/;  # doesn't match
    &quot;Hello World&quot; =~ /o W/;    # matches
    &quot;Hello World&quot; =~ /oW/;     # doesn't match
    &quot;Hello World&quot; =~ /World /; # doesn't match
</pre>
<div class="Pp"></div>
The first regexp &quot;world&quot; doesn't match because regexps are
  case-sensitive. The second regexp matches because the substring 'o&#x00A0;W'
  occurs in the string &quot;Hello&#x00A0;World&quot;. The space character ' '
  is treated like any other character in a regexp and is needed to match in this
  case. The lack of a space character is the reason the third regexp 'oW'
  doesn't match. The fourth regexp 'World ' doesn't match because there is a
  space at the end of the regexp, but not at the end of the string. The lesson
  here is that regexps must match a part of the string <i>exactly</i> in order
  for the statement to be true.
<div class="Pp"></div>
If a regexp matches in more than one place in the string, Perl will always match
  at the earliest possible point in the string:
<div class="Pp"></div>
<pre>
    &quot;Hello World&quot; =~ /o/;       # matches 'o' in 'Hello'
    &quot;That hat is red&quot; =~ /hat/; # matches 'hat' in 'That'
</pre>
<div class="Pp"></div>
With respect to character matching, there are a few more points you need to know
  about. First of all, not all characters can be used 'as is' in a match. Some
  characters, called <i>metacharacters</i>, are reserved for use in regexp
  notation. The metacharacters are
<div class="Pp"></div>
<pre>
    {}[]()^$.|*+?\
</pre>
<div class="Pp"></div>
The significance of each of these will be explained in the rest of the tutorial,
  but for now, it is important only to know that a metacharacter can be matched
  by putting a backslash before it:
<div class="Pp"></div>
<pre>
    &quot;2+2=4&quot; =~ /2+2/;    # doesn't match, + is a metacharacter
    &quot;2+2=4&quot; =~ /2\+2/;   # matches, \+ is treated like an ordinary +
    &quot;The interval is [0,1).&quot; =~ /[0,1)./     # is a syntax error!
    &quot;The interval is [0,1).&quot; =~ /\[0,1\)\./  # matches
    &quot;#!/usr/bin/perl&quot; =~ /#!\/usr\/bin\/perl/;  # matches
</pre>
<div class="Pp"></div>
In the last regexp, the forward slash '/' is also backslashed, because it is
  used to delimit the regexp. This can lead to LTS (leaning toothpick syndrome),
  however, and it is often more readable to change delimiters.
<div class="Pp"></div>
<pre>
    &quot;#!/usr/bin/perl&quot; =~ m!#\!/usr/bin/perl!;  # easier to read
</pre>
<div class="Pp"></div>
The backslash character '\' is a metacharacter itself and needs to be
  backslashed:
<div class="Pp"></div>
<pre>
    'C:\WIN32' =~ /C:\\WIN/;   # matches
</pre>
<div class="Pp"></div>
In addition to the metacharacters, there are some ASCII characters which don't
  have printable character equivalents and are instead represented by <i>escape
  sequences</i>. Common examples are &quot;\t&quot; for a tab, &quot;\n&quot;
  for a newline, &quot;\r&quot; for a carriage return and &quot;\a&quot; for a
  bell (or alert). If your string is better thought of as a sequence of
  arbitrary bytes, the octal escape sequence, e.g., &quot;\033&quot;, or
  hexadecimal escape sequence, e.g., &quot;\x1B&quot; may be a more natural
  representation for your bytes. Here are some examples of escapes:
<div class="Pp"></div>
<pre>
    &quot;1000\t2000&quot; =~ m(0\t2)   # matches
    &quot;1000\n2000&quot; =~ /0\n20/   # matches
    &quot;1000\t2000&quot; =~ /\000\t2/ # doesn't match, &quot;0&quot; ne &quot;\000&quot;
    &quot;cat&quot;   =~ /\o{143}\x61\x74/ # matches in ASCII, but a weird way
                                 # to spell cat
</pre>
<div class="Pp"></div>
If you've been around Perl a while, all this talk of escape sequences may seem
  familiar. Similar escape sequences are used in double-quoted strings and in
  fact the regexps in Perl are mostly treated as double-quoted strings. This
  means that variables can be used in regexps as well. Just like double-quoted
  strings, the values of the variables in the regexp will be substituted in
  before the regexp is evaluated for matching purposes. So we have:
<div class="Pp"></div>
<pre>
    $foo = 'house';
    'housecat' =~ /$foo/;      # matches
    'cathouse' =~ /cat$foo/;   # matches
    'housecat' =~ /${foo}cat/; # matches
</pre>
<div class="Pp"></div>
So far, so good. With the knowledge above you can already perform searches with
  just about any literal string regexp you can dream up. Here is a <i>very
  simple</i> emulation of the Unix grep program:
<div class="Pp"></div>
<pre>
    % cat &gt; simple_grep
    #!/usr/bin/perl
    $regexp = shift;
    while (&lt;&gt;) {
        print if /$regexp/;
    }
    ^D
    % chmod +x simple_grep
    % simple_grep abba /usr/dict/words
    Babbage
    cabbage
    cabbages
    sabbath
    Sabbathize
    Sabbathizes
    sabbatical
    scabbard
    scabbards
</pre>
<div class="Pp"></div>
This program is easy to understand. &quot;#!/usr/bin/perl&quot; is the standard
  way to invoke a perl program from the shell.
  &quot;$regexp&#x00A0;=&#x00A0;shift;&quot; saves the first command line
  argument as the regexp to be used, leaving the rest of the command line
  arguments to be treated as files. &quot;while&#x00A0;(&lt;&gt;)&quot; loops
  over all the lines in all the files. For each line,
  &quot;print&#x00A0;if&#x00A0;/$regexp/;&quot; prints the line if the regexp
  matches the line. In this line, both &quot;print&quot; and
  &quot;/$regexp/&quot; use the default variable $_ implicitly.
<div class="Pp"></div>
With all of the regexps above, if the regexp matched anywhere in the string, it
  was considered a match. Sometimes, however, we'd like to specify <i>where</i>
  in the string the regexp should try to match. To do this, we would use the
  <i>anchor</i> metacharacters &quot;^&quot; and &quot;$&quot;. The anchor
  &quot;^&quot; means match at the beginning of the string and the anchor
  &quot;$&quot; means match at the end of the string, or before a newline at the
  end of the string. Here is how they are used:
<div class="Pp"></div>
<pre>
    &quot;housekeeper&quot; =~ /keeper/;    # matches
    &quot;housekeeper&quot; =~ /^keeper/;   # doesn't match
    &quot;housekeeper&quot; =~ /keeper$/;   # matches
    &quot;housekeeper\n&quot; =~ /keeper$/; # matches
</pre>
<div class="Pp"></div>
The second regexp doesn't match because &quot;^&quot; constrains
  &quot;keeper&quot; to match only at the beginning of the string, but
  &quot;housekeeper&quot; has keeper starting in the middle. The third regexp
  does match, since the &quot;$&quot; constrains &quot;keeper&quot; to match
  only at the end of the string.
<div class="Pp"></div>
When both &quot;^&quot; and &quot;$&quot; are used at the same time, the regexp
  has to match both the beginning and the end of the string, i.e., the regexp
  matches the whole string. Consider
<div class="Pp"></div>
<pre>
    &quot;keeper&quot; =~ /^keep$/;      # doesn't match
    &quot;keeper&quot; =~ /^keeper$/;    # matches
    &quot;&quot;       =~ /^$/;          # ^$ matches an empty string
</pre>
<div class="Pp"></div>
The first regexp doesn't match because the string has more to it than
  &quot;keep&quot;. Since the second regexp is exactly the string, it matches.
  Using both &quot;^&quot; and &quot;$&quot; in a regexp forces the complete
  string to match, so it gives you complete control over which strings match and
  which don't. Suppose you are looking for a fellow named bert, off in a string
  by himself:
<div class="Pp"></div>
<pre>
    &quot;dogbert&quot; =~ /bert/;   # matches, but not what you want
    &quot;dilbert&quot; =~ /^bert/;  # doesn't match, but ..
    &quot;bertram&quot; =~ /^bert/;  # matches, so still not good enough
    &quot;bertram&quot; =~ /^bert$/; # doesn't match, good
    &quot;dilbert&quot; =~ /^bert$/; # doesn't match, good
    &quot;bert&quot;    =~ /^bert$/; # matches, perfect
</pre>
<div class="Pp"></div>
Of course, in the case of a literal string, one could just as easily use the
  string comparison &quot;$string&#x00A0;eq&#x00A0;'bert'&quot; and it would be
  more efficient. The &quot;^...$&quot; regexp really becomes useful when we add
  in the more powerful regexp tools below.
<h2 class="Ss" title="Ss" id="Using_character_classes"><a class="selflink" href="#Using_character_classes">Using
  character classes</a></h2>
Although one can already do quite a lot with the literal string regexps above,
  we've only scratched the surface of regular expression technology. In this and
  subsequent sections we will introduce regexp concepts (and associated
  metacharacter notations) that will allow a regexp to represent not just a
  single character sequence, but a <i>whole</i> <i>class</i> of them.
<div class="Pp"></div>
One such concept is that of a <i>character class</i>. A character class allows a
  set of possible characters, rather than just a single character, to match at a
  particular point in a regexp. Character classes are denoted by brackets
  &quot;[...]&quot;, with the set of characters to be possibly matched inside.
  Here are some examples:
<div class="Pp"></div>
<pre>
    /cat/;       # matches 'cat'
    /[bcr]at/;   # matches 'bat, 'cat', or 'rat'
    /item[0123456789]/;  # matches 'item0' or ... or 'item9'
    &quot;abc&quot; =~ /[cab]/;    # matches 'a'
</pre>
<div class="Pp"></div>
In the last statement, even though 'c' is the first character in the class, 'a'
  matches because the first character position in the string is the earliest
  point at which the regexp can match.
<div class="Pp"></div>
<pre>
    /[yY][eE][sS]/;      # match 'yes' in a case-insensitive way
                         # 'yes', 'Yes', 'YES', etc.
</pre>
<div class="Pp"></div>
This regexp displays a common task: perform a case-insensitive match. Perl
  provides a way of avoiding all those brackets by simply appending an 'i' to
  the end of the match. Then &quot;/[yY][eE][sS]/;&quot; can be rewritten as
  &quot;/yes/i;&quot;. The 'i' stands for case-insensitive and is an example of
  a <i>modifier</i> of the matching operation. We will meet other modifiers
  later in the tutorial.
<div class="Pp"></div>
We saw in the section above that there were ordinary characters, which
  represented themselves, and special characters, which needed a backslash
  &quot;\&quot; to represent themselves. The same is true in a character class,
  but the sets of ordinary and special characters inside a character class are
  different than those outside a character class. The special characters for a
  character class are &quot;-]\^$&quot; (and the pattern delimiter, whatever it
  is). &quot;]&quot; is special because it denotes the end of a character class.
  &quot;$&quot; is special because it denotes a scalar variable. &quot;\&quot;
  is special because it is used in escape sequences, just like above. Here is
  how the special characters &quot;]$\&quot; are handled:
<div class="Pp"></div>
<pre>
   /[\]c]def/; # matches ']def' or 'cdef'
   $x = 'bcr';
   /[$x]at/;   # matches 'bat', 'cat', or 'rat'
   /[\$x]at/;  # matches '$at' or 'xat'
   /[\\$x]at/; # matches '\at', 'bat, 'cat', or 'rat'
</pre>
<div class="Pp"></div>
The last two are a little tricky. In &quot;[\$x]&quot;, the backslash protects
  the dollar sign, so the character class has two members &quot;$&quot; and
  &quot;x&quot;. In &quot;[\\$x]&quot;, the backslash is protected, so $x is
  treated as a variable and substituted in double quote fashion.
<div class="Pp"></div>
The special character '-' acts as a range operator within character classes, so
  that a contiguous set of characters can be written as a range. With ranges,
  the unwieldy &quot;[0123456789]&quot; and &quot;[abc...xyz]&quot; become the
  svelte &quot;[0-9]&quot; and &quot;[a-z]&quot;. Some examples are
<div class="Pp"></div>
<pre>
    /item[0-9]/;  # matches 'item0' or ... or 'item9'
    /[0-9bx-z]aa/;  # matches '0aa', ..., '9aa',
                    # 'baa', 'xaa', 'yaa', or 'zaa'
    /[0-9a-fA-F]/;  # matches a hexadecimal digit
    /[0-9a-zA-Z_]/; # matches a &quot;word&quot; character,
                    # like those in a Perl variable name
</pre>
<div class="Pp"></div>
If '-' is the first or last character in a character class, it is treated as an
  ordinary character; &quot;[-ab]&quot;, &quot;[ab-]&quot; and
  &quot;[a\-b]&quot; are all equivalent.
<div class="Pp"></div>
The special character &quot;^&quot; in the first position of a character class
  denotes a <i>negated character class</i>, which matches any character but
  those in the brackets. Both &quot;[...]&quot; and &quot;[^...]&quot; must
  match a character, or the match fails. Then
<div class="Pp"></div>
<pre>
    /[^a]at/;  # doesn't match 'aat' or 'at', but matches
               # all other 'bat', 'cat, '0at', '%at', etc.
    /[^0-9]/;  # matches a non-numeric character
    /[a^]at/;  # matches 'aat' or '^at'; here '^' is ordinary
</pre>
<div class="Pp"></div>
Now, even &quot;[0-9]&quot; can be a bother to write multiple times, so in the
  interest of saving keystrokes and making regexps more readable, Perl has
  several abbreviations for common character classes, as shown below. Since the
  introduction of Unicode, unless the &quot;//a&quot; modifier is in effect,
  these character classes match more than just a few characters in the ASCII
  range.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">\d matches a digit, not just [0-9] but also digits from
      non-roman scripts</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">\s matches a whitespace character, the set [\ \t\r\n\f] and
      others</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">\w matches a word character (alphanumeric or _), not just
      [0-9a-zA-Z_] but also digits and characters from non-roman scripts</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">\D is a negated \d; it represents any other character than
      a digit, or [^\d]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">\S is a negated \s; it represents any non-whitespace
      character [^\s]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">\W is a negated \w; it represents any non-word character
      [^\w]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The period '.' matches any character but &quot;\n&quot;
      (unless the modifier &quot;//s&quot; is in effect, as explained
    below).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">\N, like the period, matches any character but
      &quot;\n&quot;, but it does so regardless of whether the modifier
      &quot;//s&quot; is in effect.</dd>
</dl>
<div class="Pp"></div>
The &quot;//a&quot; modifier, available starting in Perl 5.14, is used to
  restrict the matches of \d, \s, and \w to just those in the ASCII range. It is
  useful to keep your program from being needlessly exposed to full Unicode (and
  its accompanying security considerations) when all you want is to process
  English-like text. (The &quot;a&quot; may be doubled, &quot;//aa&quot;, to
  provide even more restrictions, preventing case-insensitive matching of ASCII
  with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would
  caselessly match a &quot;k&quot; or &quot;K&quot;.)
<div class="Pp"></div>
The &quot;\d\s\w\D\S\W&quot; abbreviations can be used both inside and outside
  of character classes. Here are some in use:
<div class="Pp"></div>
<pre>
    /\d\d:\d\d:\d\d/; # matches a hh:mm:ss time format
    /[\d\s]/;         # matches any digit or whitespace character
    /\w\W\w/;         # matches a word char, followed by a
                      # non-word char, followed by a word char
    /..rt/;           # matches any two chars, followed by 'rt'
    /end\./;          # matches 'end.'
    /end[.]/;         # same thing, matches 'end.'
</pre>
<div class="Pp"></div>
Because a period is a metacharacter, it needs to be escaped to match as an
  ordinary period. Because, for example, &quot;\d&quot; and &quot;\w&quot; are
  sets of characters, it is incorrect to think of &quot;[^\d\w]&quot; as
  &quot;[\D\W]&quot;; in fact &quot;[^\d\w]&quot; is the same as
  &quot;[^\w]&quot;, which is the same as &quot;[\W]&quot;. Think DeMorgan's
  laws.
<div class="Pp"></div>
An anchor useful in basic regexps is the <i>word anchor</i> &quot;\b&quot;. This
  matches a boundary between a word character and a non-word character
  &quot;\w\W&quot; or &quot;\W\w&quot;:
<div class="Pp"></div>
<pre>
    $x = &quot;Housecat catenates house and cat&quot;;
    $x =~ /cat/;    # matches cat in 'housecat'
    $x =~ /\bcat/;  # matches cat in 'catenates'
    $x =~ /cat\b/;  # matches cat in 'housecat'
    $x =~ /\bcat\b/;  # matches 'cat' at end of string
</pre>
<div class="Pp"></div>
Note in the last example, the end of the string is considered a word boundary.
<div class="Pp"></div>
You might wonder why '.' matches everything but &quot;\n&quot; - why not every
  character? The reason is that often one is matching against lines and would
  like to ignore the newline characters. For instance, while the string
  &quot;\n&quot; represents one line, we would like to think of it as empty.
  Then
<div class="Pp"></div>
<pre>
    &quot;&quot;   =~ /^$/;    # matches
    &quot;\n&quot; =~ /^$/;    # matches, $ anchors before &quot;\n&quot;
    &quot;&quot;   =~ /./;      # doesn't match; it needs a char
    &quot;&quot;   =~ /^.$/;    # doesn't match; it needs a char
    &quot;\n&quot; =~ /^.$/;    # doesn't match; it needs a char other than &quot;\n&quot;
    &quot;a&quot;  =~ /^.$/;    # matches
    &quot;a\n&quot;  =~ /^.$/;  # matches, $ anchors before &quot;\n&quot;
</pre>
<div class="Pp"></div>
This behavior is convenient, because we usually want to ignore newlines when we
  count and match characters in a line. Sometimes, however, we want to keep
  track of newlines. We might even want &quot;^&quot; and &quot;$&quot; to
  anchor at the beginning and end of lines within the string, rather than just
  the beginning and end of the string. Perl allows us to choose between ignoring
  and paying attention to newlines by using the &quot;//s&quot; and
  &quot;//m&quot; modifiers. &quot;//s&quot; and &quot;//m&quot; stand for
  single line and multi-line and they determine whether a string is to be
  treated as one continuous string, or as a set of lines. The two modifiers
  affect two aspects of how the regexp is interpreted: 1) how the '.' character
  class is defined, and 2) where the anchors &quot;^&quot; and &quot;$&quot; are
  able to match. Here are the four possible combinations:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">no modifiers (//): Default behavior. '.' matches any
      character except &quot;\n&quot;. &quot;^&quot; matches only at the
      beginning of the string and &quot;$&quot; matches only at the end or
      before a newline at the end.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">s modifier (//s): Treat string as a single long line. '.'
      matches any character, even &quot;\n&quot;. &quot;^&quot; matches only at
      the beginning of the string and &quot;$&quot; matches only at the end or
      before a newline at the end.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">m modifier (//m): Treat string as a set of multiple lines.
      '.' matches any character except &quot;\n&quot;. &quot;^&quot; and
      &quot;$&quot; are able to match at the start or end of <i>any</i> line
      within the string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">both s and m modifiers (//sm): Treat string as a single
      long line, but detect multiple lines. '.' matches any character, even
      &quot;\n&quot;. &quot;^&quot; and &quot;$&quot;, however, are able to
      match at the start or end of <i>any</i> line within the string.</dd>
</dl>
<div class="Pp"></div>
Here are examples of &quot;//s&quot; and &quot;//m&quot; in action:
<div class="Pp"></div>
<pre>
    $x = &quot;There once was a girl\nWho programmed in Perl\n&quot;;
    $x =~ /^Who/;   # doesn't match, &quot;Who&quot; not at start of string
    $x =~ /^Who/s;  # doesn't match, &quot;Who&quot; not at start of string
    $x =~ /^Who/m;  # matches, &quot;Who&quot; at start of second line
    $x =~ /^Who/sm; # matches, &quot;Who&quot; at start of second line
    $x =~ /girl.Who/;   # doesn't match, &quot;.&quot; doesn't match &quot;\n&quot;
    $x =~ /girl.Who/s;  # matches, &quot;.&quot; matches &quot;\n&quot;
    $x =~ /girl.Who/m;  # doesn't match, &quot;.&quot; doesn't match &quot;\n&quot;
    $x =~ /girl.Who/sm; # matches, &quot;.&quot; matches &quot;\n&quot;
</pre>
<div class="Pp"></div>
Most of the time, the default behavior is what is wanted, but &quot;//s&quot;
  and &quot;//m&quot; are occasionally very useful. If &quot;//m&quot; is being
  used, the start of the string can still be matched with &quot;\A&quot; and the
  end of the string can still be matched with the anchors &quot;\Z&quot;
  (matches both the end and the newline before, like &quot;$&quot;), and
  &quot;\z&quot; (matches only the end):
<div class="Pp"></div>
<pre>
    $x =~ /^Who/m;   # matches, &quot;Who&quot; at start of second line
    $x =~ /\AWho/m;  # doesn't match, &quot;Who&quot; is not at start of string
    $x =~ /girl$/m;  # matches, &quot;girl&quot; at end of first line
    $x =~ /girl\Z/m; # doesn't match, &quot;girl&quot; is not at end of string
    $x =~ /Perl\Z/m; # matches, &quot;Perl&quot; is at newline before end
    $x =~ /Perl\z/m; # doesn't match, &quot;Perl&quot; is not at end of string
</pre>
<div class="Pp"></div>
We now know how to create choices among classes of characters in a regexp. What
  about choices among words or character strings? Such choices are described in
  the next section.
<h2 class="Ss" title="Ss" id="Matching_this_or_that"><a class="selflink" href="#Matching_this_or_that">Matching
  this or that</a></h2>
Sometimes we would like our regexp to be able to match different possible words
  or character strings. This is accomplished by using the <i>alternation</i>
  metacharacter &quot;|&quot;. To match &quot;dog&quot; or &quot;cat&quot;, we
  form the regexp &quot;dog|cat&quot;. As before, Perl will try to match the
  regexp at the earliest possible point in the string. At each character
  position, Perl will first try to match the first alternative, &quot;dog&quot;.
  If &quot;dog&quot; doesn't match, Perl will then try the next alternative,
  &quot;cat&quot;. If &quot;cat&quot; doesn't match either, then the match fails
  and Perl moves to the next position in the string. Some examples:
<div class="Pp"></div>
<pre>
    &quot;cats and dogs&quot; =~ /cat|dog|bird/;  # matches &quot;cat&quot;
    &quot;cats and dogs&quot; =~ /dog|cat|bird/;  # matches &quot;cat&quot;
</pre>
<div class="Pp"></div>
Even though &quot;dog&quot; is the first alternative in the second regexp,
  &quot;cat&quot; is able to match earlier in the string.
<div class="Pp"></div>
<pre>
    &quot;cats&quot;          =~ /c|ca|cat|cats/; # matches &quot;c&quot;
    &quot;cats&quot;          =~ /cats|cat|ca|c/; # matches &quot;cats&quot;
</pre>
<div class="Pp"></div>
Here, all the alternatives match at the first string position, so the first
  alternative is the one that matches. If some of the alternatives are
  truncations of the others, put the longest ones first to give them a chance to
  match.
<div class="Pp"></div>
<pre>
    &quot;cab&quot; =~ /a|b|c/ # matches &quot;c&quot;
                     # /a|b|c/ == /[abc]/
</pre>
<div class="Pp"></div>
The last example points out that character classes are like alternations of
  characters. At a given character position, the first alternative that allows
  the regexp match to succeed will be the one that matches.
<h2 class="Ss" title="Ss" id="Grouping_things_and_hierarchical_matching"><a class="selflink" href="#Grouping_things_and_hierarchical_matching">Grouping
  things and hierarchical matching</a></h2>
Alternation allows a regexp to choose among alternatives, but by itself it is
  unsatisfying. The reason is that each alternative is a whole regexp, but
  sometime we want alternatives for just part of a regexp. For instance, suppose
  we want to search for housecats or housekeepers. The regexp
  &quot;housecat|housekeeper&quot; fits the bill, but is inefficient because we
  had to type &quot;house&quot; twice. It would be nice to have parts of the
  regexp be constant, like &quot;house&quot;, and some parts have alternatives,
  like &quot;cat|keeper&quot;.
<div class="Pp"></div>
The <i>grouping</i> metacharacters &quot;()&quot; solve this problem. Grouping
  allows parts of a regexp to be treated as a single unit. Parts of a regexp are
  grouped by enclosing them in parentheses. Thus we could solve the
  &quot;housecat|housekeeper&quot; by forming the regexp as
  &quot;house(cat|keeper)&quot;. The regexp &quot;house(cat|keeper)&quot; means
  match &quot;house&quot; followed by either &quot;cat&quot; or
  &quot;keeper&quot;. Some more examples are
<div class="Pp"></div>
<pre>
    /(a|b)b/;    # matches 'ab' or 'bb'
    /(ac|b)b/;   # matches 'acb' or 'bb'
    /(^a|b)c/;   # matches 'ac' at start of string or 'bc' anywhere
    /(a|[bc])d/; # matches 'ad', 'bd', or 'cd'
    /house(cat|)/;  # matches either 'housecat' or 'house'
    /house(cat(s|)|)/;  # matches either 'housecats' or 'housecat' or
                        # 'house'.  Note groups can be nested.
    /(19|20|)\d\d/;  # match years 19xx, 20xx, or the Y2K problem, xx
    &quot;20&quot; =~ /(19|20|)\d\d/;  # matches the null alternative '()\d\d',
                             # because '20\d\d' can't match
</pre>
<div class="Pp"></div>
Alternations behave the same way in groups as out of them: at a given string
  position, the leftmost alternative that allows the regexp to match is taken.
  So in the last example at the first string position, &quot;20&quot; matches
  the second alternative, but there is nothing left over to match the next two
  digits &quot;\d\d&quot;. So Perl moves on to the next alternative, which is
  the null alternative and that works, since &quot;20&quot; is two digits.
<div class="Pp"></div>
The process of trying one alternative, seeing if it matches, and moving on to
  the next alternative, while going back in the string from where the previous
  alternative was tried, if it doesn't, is called <i>backtracking</i>. The term
  'backtracking' comes from the idea that matching a regexp is like a walk in
  the woods. Successfully matching a regexp is like arriving at a destination.
  There are many possible trailheads, one for each string position, and each one
  is tried in order, left to right. From each trailhead there may be many paths,
  some of which get you there, and some which are dead ends. When you walk along
  a trail and hit a dead end, you have to backtrack along the trail to an
  earlier point to try another trail. If you hit your destination, you stop
  immediately and forget about trying all the other trails. You are persistent,
  and only if you have tried all the trails from all the trailheads and not
  arrived at your destination, do you declare failure. To be concrete, here is a
  step-by-step analysis of what Perl does when it tries to match the regexp
<div class="Pp"></div>
<pre>
    &quot;abcde&quot; =~ /(abd|abc)(df|d|de)/;
</pre>
<dl class="Bl-tag">
  <dt class="It-tag">0</dt>
  <dd class="It-tag">Start with the first letter in the string 'a'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">1</dt>
  <dd class="It-tag">Try the first alternative in the first group 'abd'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2</dt>
  <dd class="It-tag">Match 'a' followed by 'b'. So far so good.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3</dt>
  <dd class="It-tag">'d' in the regexp doesn't match 'c' in the string - a dead
      end. So backtrack two characters and pick the second alternative in the
      first group 'abc'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4</dt>
  <dd class="It-tag">Match 'a' followed by 'b' followed by 'c'. We are on a roll
      and have satisfied the first group. Set $1 to 'abc'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5</dt>
  <dd class="It-tag">Move on to the second group and pick the first alternative
      'df'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">6</dt>
  <dd class="It-tag">Match the 'd'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">7</dt>
  <dd class="It-tag">'f' in the regexp doesn't match 'e' in the string, so a
      dead end. Backtrack one character and pick the second alternative in the
      second group 'd'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">8</dt>
  <dd class="It-tag">'d' matches. The second grouping is satisfied, so set $2 to
      'd'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">9</dt>
  <dd class="It-tag">We are at the end of the regexp, so we are done! We have
      matched 'abcd' out of the string &quot;abcde&quot;.</dd>
</dl>
<div class="Pp"></div>
There are a couple of things to note about this analysis. First, the third
  alternative in the second group 'de' also allows a match, but we stopped
  before we got to it - at a given character position, leftmost wins. Second, we
  were able to get a match at the first character position of the string 'a'. If
  there were no matches at the first position, Perl would move to the second
  character position 'b' and attempt the match all over again. Only when all
  possible paths at all possible character positions have been exhausted does
  Perl give up and declare
  &quot;$string&#x00A0;=~&#x00A0;/(abd|abc)(df|d|de)/;&quot; to be false.
<div class="Pp"></div>
Even with all this work, regexp matching happens remarkably fast. To speed
  things up, Perl compiles the regexp into a compact sequence of opcodes that
  can often fit inside a processor cache. When the code is executed, these
  opcodes can then run at full throttle and search very quickly.
<h2 class="Ss" title="Ss" id="Extracting_matches"><a class="selflink" href="#Extracting_matches">Extracting
  matches</a></h2>
The grouping metacharacters &quot;()&quot; also serve another completely
  different function: they allow the extraction of the parts of a string that
  matched. This is very useful to find out what matched and for text processing
  in general. For each grouping, the part that matched inside goes into the
  special variables $1, $2, etc. They can be used just as ordinary variables:
<div class="Pp"></div>
<pre>
    # extract hours, minutes, seconds
    if ($time =~ /(\d\d):(\d\d):(\d\d)/) {    # match hh:mm:ss format
        $hours = $1;
        $minutes = $2;
        $seconds = $3;
    }
</pre>
<div class="Pp"></div>
Now, we know that in scalar context,
  &quot;$time&#x00A0;=~&#x00A0;/(\d\d):(\d\d):(\d\d)/&quot; returns a true or
  false value. In list context, however, it returns the list of matched values
  &quot;($1,$2,$3)&quot;. So we could write the code more compactly as
<div class="Pp"></div>
<pre>
    # extract hours, minutes, seconds
    ($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);
</pre>
<div class="Pp"></div>
If the groupings in a regexp are nested, $1 gets the group with the leftmost
  opening parenthesis, $2 the next opening parenthesis, etc. Here is a regexp
  with nested groups:
<div class="Pp"></div>
<pre>
    /(ab(cd|ef)((gi)|j))/;
     1  2      34
</pre>
<div class="Pp"></div>
If this regexp matches, $1 contains a string starting with 'ab', $2 is either
  set to 'cd' or 'ef', $3 equals either 'gi' or 'j', and $4 is either set to
  'gi', just like $3, or it remains undefined.
<div class="Pp"></div>
For convenience, Perl sets $+ to the string held by the highest numbered $1,
  $2,... that got assigned (and, somewhat related, $^N to the value of the $1,
  $2,... most-recently assigned; i.e. the $1, $2,... associated with the
  rightmost closing parenthesis used in the match).
<h2 class="Ss" title="Ss" id="Backreferences"><a class="selflink" href="#Backreferences">Backreferences</a></h2>
Closely associated with the matching variables $1, $2, ... are the
  <i>backreferences</i> &quot;\g1&quot;, &quot;\g2&quot;,... Backreferences are
  simply matching variables that can be used <i>inside</i> a regexp. This is a
  really nice feature; what matches later in a regexp is made to depend on what
  matched earlier in the regexp. Suppose we wanted to look for doubled words in
  a text, like 'the the'. The following regexp finds all 3-letter doubles with a
  space in between:
<div class="Pp"></div>
<pre>
    /\b(\w\w\w)\s\g1\b/;
</pre>
<div class="Pp"></div>
The grouping assigns a value to \g1, so that the same 3-letter sequence is used
  for both parts.
<div class="Pp"></div>
A similar task is to find words consisting of two identical parts:
<div class="Pp"></div>
<pre>
    % simple_grep '^(\w\w\w\w|\w\w\w|\w\w|\w)\g1$' /usr/dict/words
    beriberi
    booboo
    coco
    mama
    murmur
    papa
</pre>
<div class="Pp"></div>
The regexp has a single grouping which considers 4-letter combinations, then
  3-letter combinations, etc., and uses &quot;\g1&quot; to look for a repeat.
  Although $1 and &quot;\g1&quot; represent the same thing, care should be taken
  to use matched variables $1, $2,... only <i>outside</i> a regexp and
  backreferences &quot;\g1&quot;, &quot;\g2&quot;,... only <i>inside</i> a
  regexp; not doing so may lead to surprising and unsatisfactory results.
<h2 class="Ss" title="Ss" id="Relative_backreferences"><a class="selflink" href="#Relative_backreferences">Relative
  backreferences</a></h2>
Counting the opening parentheses to get the correct number for a backreference
  is error-prone as soon as there is more than one capturing group. A more
  convenient technique became available with Perl 5.10: relative backreferences.
  To refer to the immediately preceding capture group one now may write
  &quot;\g{-1}&quot;, the next but last is available via &quot;\g{-2}&quot;, and
  so on.
<div class="Pp"></div>
Another good reason in addition to readability and maintainability for using
  relative backreferences is illustrated by the following example, where a
  simple pattern for matching peculiar strings is used:
<div class="Pp"></div>
<pre>
    $a99a = '([a-z])(\d)\g2\g1';   # matches a11a, g22g, x33x, etc.
</pre>
<div class="Pp"></div>
Now that we have this pattern stored as a handy string, we might feel tempted to
  use it as a part of some other pattern:
<div class="Pp"></div>
<pre>
    $line = &quot;code=e99e&quot;;
    if ($line =~ /^(\w+)=$a99a$/){   # unexpected behavior!
        print &quot;$1 is valid\n&quot;;
    } else {
        print &quot;bad line: '$line'\n&quot;;
    }
</pre>
<div class="Pp"></div>
But this doesn't match, at least not the way one might expect. Only after
  inserting the interpolated $a99a and looking at the resulting full text of the
  regexp is it obvious that the backreferences have backfired. The subexpression
  &quot;(\w+)&quot; has snatched number 1 and demoted the groups in $a99a by one
  rank. This can be avoided by using relative backreferences:
<div class="Pp"></div>
<pre>
    $a99a = '([a-z])(\d)\g{-1}\g{-2}';  # safe for being interpolated
</pre>
<h2 class="Ss" title="Ss" id="Named_backreferences"><a class="selflink" href="#Named_backreferences">Named
  backreferences</a></h2>
Perl 5.10 also introduced named capture groups and named backreferences. To
  attach a name to a capturing group, you write either
  &quot;(?&lt;name&gt;...)&quot; or &quot;(?'name'...)&quot;. The backreference
  may then be written as &quot;\g{name}&quot;. It is permissible to attach the
  same name to more than one group, but then only the leftmost one of the
  eponymous set can be referenced. Outside of the pattern a named capture group
  is accessible through the &quot;%+&quot; hash.
<div class="Pp"></div>
Assuming that we have to match calendar dates which may be given in one of the
  three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three
  suitable patterns where we use 'd', 'm' and 'y' respectively as the names of
  the groups capturing the pertaining components of a date. The matching
  operation combines the three patterns as alternatives:
<div class="Pp"></div>
<pre>
    $fmt1 = '(?&lt;y&gt;\d\d\d\d)-(?&lt;m&gt;\d\d)-(?&lt;d&gt;\d\d)';
    $fmt2 = '(?&lt;m&gt;\d\d)/(?&lt;d&gt;\d\d)/(?&lt;y&gt;\d\d\d\d)';
    $fmt3 = '(?&lt;d&gt;\d\d)\.(?&lt;m&gt;\d\d)\.(?&lt;y&gt;\d\d\d\d)';
    for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
        if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
            print &quot;day=$+{d} month=$+{m} year=$+{y}\n&quot;;
        }
    }
</pre>
<div class="Pp"></div>
If any of the alternatives matches, the hash &quot;%+&quot; is bound to contain
  the three key-value pairs.
<h2 class="Ss" title="Ss" id="Alternative_capture_group_numbering"><a class="selflink" href="#Alternative_capture_group_numbering">Alternative
  capture group numbering</a></h2>
Yet another capturing group numbering technique (also as from Perl 5.10) deals
  with the problem of referring to groups within a set of alternatives. Consider
  a pattern for matching a time of the day, civil or military style:
<div class="Pp"></div>
<pre>
    if ( $time =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/ ){
        # process hour and minute
    }
</pre>
<div class="Pp"></div>
Processing the results requires an additional if statement to determine whether
  $1 and $2 or $3 and $4 contain the goodies. It would be easier if we could use
  group numbers 1 and 2 in second alternative as well, and this is exactly what
  the parenthesized construct &quot;(?|...)&quot;, set around an alternative
  achieves. Here is an extended version of the previous pattern:
<div class="Pp"></div>
<pre>
    if ( $time =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))\s+([A-Z][A-Z][A-Z])/ ){
        print &quot;hour=$1 minute=$2 zone=$3\n&quot;;
    }
</pre>
<div class="Pp"></div>
Within the alternative numbering group, group numbers start at the same position
  for each alternative. After the group, numbering continues with one higher
  than the maximum reached across all the alternatives.
<h2 class="Ss" title="Ss" id="Position_information"><a class="selflink" href="#Position_information">Position
  information</a></h2>
In addition to what was matched, Perl (since 5.6.0) also provides the positions
  of what was matched as contents of the &quot;@-&quot; and &quot;@+&quot;
  arrays. &quot;$-[0]&quot; is the position of the start of the entire match and
  $+[0] is the position of the end. Similarly, &quot;$-[n]&quot; is the position
  of the start of the $n match and $+[n] is the position of the end. If $n is
  undefined, so are &quot;$-[n]&quot; and $+[n]. Then this code
<div class="Pp"></div>
<pre>
    $x = &quot;Mmm...donut, thought Homer&quot;;
    $x =~ /^(Mmm|Yech)\.\.\.(donut|peas)/; # matches
    foreach $expr (1..$#-) {
        print &quot;Match $expr: '${$expr}' at position ($-[$expr],$+[$expr])\n&quot;;
    }
</pre>
<div class="Pp"></div>
prints
<div class="Pp"></div>
<pre>
    Match 1: 'Mmm' at position (0,3)
    Match 2: 'donut' at position (6,11)
</pre>
<div class="Pp"></div>
Even if there are no groupings in a regexp, it is still possible to find out
  what exactly matched in a string. If you use them, Perl will set
  &quot;$`&quot; to the part of the string before the match, will set $&amp; to
  the part of the string that matched, and will set &quot;$'&quot; to the part
  of the string after the match. An example:
<div class="Pp"></div>
<pre>
    $x = &quot;the cat caught the mouse&quot;;
    $x =~ /cat/;  # $` = 'the ', $&amp; = 'cat', $' = ' caught the mouse'
    $x =~ /the/;  # $` = '', $&amp; = 'the', $' = ' cat caught the mouse'
</pre>
<div class="Pp"></div>
In the second match, &quot;$`&quot; equals '' because the regexp matched at the
  first character position in the string and stopped; it never saw the second
  'the'. It is important to note that using &quot;$`&quot; and &quot;$'&quot;
  slows down regexp matching quite a bit, while $&amp; slows it down to a lesser
  extent, because if they are used in one regexp in a program, they are
  generated for <i>all</i> regexps in the program. So if raw performance is a
  goal of your application, they should be avoided. If you need to extract the
  corresponding substrings, use &quot;@-&quot; and &quot;@+&quot; instead:
<div class="Pp"></div>
<pre>
    $` is the same as substr( $x, 0, $-[0] )
    $&amp; is the same as substr( $x, $-[0], $+[0]-$-[0] )
    $' is the same as substr( $x, $+[0] )
</pre>
<div class="Pp"></div>
As of Perl 5.10, the &quot;${^PREMATCH}&quot;, &quot;${^MATCH}&quot; and
  &quot;${^POSTMATCH}&quot; variables may be used. These are only set if the
  &quot;/p&quot; modifier is present. Consequently they do not penalize the rest
  of the program.
<h2 class="Ss" title="Ss" id="Non-capturing_groupings"><a class="selflink" href="#Non-capturing_groupings">Non-capturing
  groupings</a></h2>
A group that is required to bundle a set of alternatives may or may not be
  useful as a capturing group. If it isn't, it just creates a superfluous
  addition to the set of available capture group values, inside as well as
  outside the regexp. Non-capturing groupings, denoted by
  &quot;(?:regexp)&quot;, still allow the regexp to be treated as a single unit,
  but don't establish a capturing group at the same time. Both capturing and
  non-capturing groupings are allowed to co-exist in the same regexp. Because
  there is no extraction, non-capturing groupings are faster than capturing
  groupings. Non-capturing groupings are also handy for choosing exactly which
  parts of a regexp are to be extracted to matching variables:
<div class="Pp"></div>
<pre>
    # match a number, $1-$4 are set, but we only want $1
    /([+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?)/;
    # match a number faster , only $1 is set
    /([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?)/;
    # match a number, get $1 = whole number, $2 = exponent
    /([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE]([+-]?\d+))?)/;
</pre>
<div class="Pp"></div>
Non-capturing groupings are also useful for removing nuisance elements gathered
  from a split operation where parentheses are required for some reason:
<div class="Pp"></div>
<pre>
    $x = '12aba34ba5';
    @num = split /(a|b)+/, $x;    # @num = ('12','a','34','a','5')
    @num = split /(?:a|b)+/, $x;  # @num = ('12','34','5')
</pre>
<h2 class="Ss" title="Ss" id="Matching_repetitions"><a class="selflink" href="#Matching_repetitions">Matching
  repetitions</a></h2>
The examples in the previous section display an annoying weakness. We were only
  matching 3-letter words, or chunks of words of 4 letters or less. We'd like to
  be able to match words or, more generally, strings of any length, without
  writing out tedious alternatives like &quot;\w\w\w\w|\w\w\w|\w\w|\w&quot;.
<div class="Pp"></div>
This is exactly the problem the <i>quantifier</i> metacharacters &quot;?&quot;,
  &quot;*&quot;, &quot;+&quot;, and &quot;{}&quot; were created for. They allow
  us to delimit the number of repeats for a portion of a regexp we consider to
  be a match. Quantifiers are put immediately after the character, character
  class, or grouping that we want to specify. They have the following meanings:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a?&quot; means: match 'a' 1 or 0 times</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a*&quot; means: match 'a' 0 or more times, i.e., any
      number of times</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a+&quot; means: match 'a' 1 or more times, i.e., at
      least once</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a{n,m}&quot; means: match at least &quot;n&quot;
      times, but not more than &quot;m&quot; times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a{n,}&quot; means: match at least &quot;n&quot; or
      more times</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a{n}&quot; means: match exactly &quot;n&quot;
    times</dd>
</dl>
<div class="Pp"></div>
Here are some examples:
<div class="Pp"></div>
<pre>
    /[a-z]+\s+\d*/;  # match a lowercase word, at least one space, and
                     # any number of digits
    /(\w+)\s+\g1/;    # match doubled words of arbitrary length
    /y(es)?/i;       # matches 'y', 'Y', or a case-insensitive 'yes'
    $year =~ /^\d{2,4}$/;  # make sure year is at least 2 but not more
                           # than 4 digits
    $year =~ /^\d{4}$|^\d{2}$/;    # better match; throw out 3-digit dates
    $year =~ /^\d{2}(\d{2})?$/;  # same thing written differently. However,
                                 # this captures the last two digits in $1
                                 # and the other does not.
    % simple_grep '^(\w+)\g1$' /usr/dict/words   # isn't this easier?
    beriberi
    booboo
    coco
    mama
    murmur
    papa
</pre>
<div class="Pp"></div>
For all of these quantifiers, Perl will try to match as much of the string as
  possible, while still allowing the regexp to succeed. Thus with
  &quot;/a?.../&quot;, Perl will first try to match the regexp with the
  &quot;a&quot; present; if that fails, Perl will try to match the regexp
  without the &quot;a&quot; present. For the quantifier &quot;*&quot;, we get
  the following:
<div class="Pp"></div>
<pre>
    $x = &quot;the cat in the hat&quot;;
    $x =~ /^(.*)(cat)(.*)$/; # matches,
                             # $1 = 'the '
                             # $2 = 'cat'
                             # $3 = ' in the hat'
</pre>
<div class="Pp"></div>
Which is what we might expect, the match finds the only &quot;cat&quot; in the
  string and locks onto it. Consider, however, this regexp:
<div class="Pp"></div>
<pre>
    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 characters match)
</pre>
<div class="Pp"></div>
One might initially guess that Perl would find the &quot;at&quot; in
  &quot;cat&quot; and stop there, but that wouldn't give the longest possible
  string to the first quantifier &quot;.*&quot;. Instead, the first quantifier
  &quot;.*&quot; grabs as much of the string as possible while still having the
  regexp match. In this example, that means having the &quot;at&quot; sequence
  with the final &quot;at&quot; in the string. The other important principle
  illustrated here is that, when there are two or more elements in a regexp, the
  <i>leftmost</i> quantifier, if there is one, gets to grab as much of the
  string as possible, leaving the rest of the regexp to fight over scraps. Thus
  in our example, the first quantifier &quot;.*&quot; grabs most of the string,
  while the second quantifier &quot;.*&quot; gets the empty string. Quantifiers
  that grab as much of the string as possible are called <i>maximal match</i> or
  <i>greedy</i> quantifiers.
<div class="Pp"></div>
When a regexp can match a string in several different ways, we can use the
  principles above to predict which way the regexp will match:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Principle 0: Taken as a whole, any regexp will be matched
      at the earliest possible position in the string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Principle 1: In an alternation &quot;a|b|c...&quot;, the
      leftmost alternative that allows a match for the whole regexp will be the
      one used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Principle 2: The maximal matching quantifiers
      &quot;?&quot;, &quot;*&quot;, &quot;+&quot; and &quot;{n,m}&quot; will in
      general match as much of the string as possible while still allowing the
      whole regexp to match.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Principle 3: If there are two or more elements in a regexp,
      the leftmost greedy quantifier, if any, will match as much of the string
      as possible while still allowing the whole regexp to match. The next
      leftmost greedy quantifier, if any, will try to match as much of the
      string remaining available to it as possible, while still allowing the
      whole regexp to match. And so on, until all the regexp elements are
      satisfied.</dd>
</dl>
<div class="Pp"></div>
As we have seen above, Principle 0 overrides the others. The regexp will be
  matched as early as possible, with the other principles determining how the
  regexp matches at that earliest character position.
<div class="Pp"></div>
Here is an example of these principles in action:
<div class="Pp"></div>
<pre>
    $x = &quot;The programming republic of Perl&quot;;
    $x =~ /^(.+)(e|r)(.*)$/;  # matches,
                              # $1 = 'The programming republic of Pe'
                              # $2 = 'r'
                              # $3 = 'l'
</pre>
<div class="Pp"></div>
This regexp matches at the earliest string position, 'T'. One might think that
  &quot;e&quot;, being leftmost in the alternation, would be matched, but
  &quot;r&quot; produces the longest string in the first quantifier.
<div class="Pp"></div>
<pre>
    $x =~ /(m{1,2})(.*)$/;  # matches,
                            # $1 = 'mm'
                            # $2 = 'ing republic of Perl'
</pre>
<div class="Pp"></div>
Here, The earliest possible match is at the first 'm' in
  &quot;programming&quot;. &quot;m{1,2}&quot; is the first quantifier, so it
  gets to match a maximal &quot;mm&quot;.
<div class="Pp"></div>
<pre>
    $x =~ /.*(m{1,2})(.*)$/;  # matches,
                              # $1 = 'm'
                              # $2 = 'ing republic of Perl'
</pre>
<div class="Pp"></div>
Here, the regexp matches at the start of the string. The first quantifier
  &quot;.*&quot; grabs as much as possible, leaving just a single 'm' for the
  second quantifier &quot;m{1,2}&quot;.
<div class="Pp"></div>
<pre>
    $x =~ /(.?)(m{1,2})(.*)$/;  # matches,
                                # $1 = 'a'
                                # $2 = 'mm'
                                # $3 = 'ing republic of Perl'
</pre>
<div class="Pp"></div>
Here, &quot;.?&quot; eats its maximal one character at the earliest possible
  position in the string, 'a' in &quot;programming&quot;, leaving
  &quot;m{1,2}&quot; the opportunity to match both &quot;m&quot;'s. Finally,
<div class="Pp"></div>
<pre>
    &quot;aXXXb&quot; =~ /(X*)/; # matches with $1 = ''
</pre>
<div class="Pp"></div>
because it can match zero copies of 'X' at the beginning of the string. If you
  definitely want to match at least one 'X', use &quot;X+&quot;, not
  &quot;X*&quot;.
<div class="Pp"></div>
Sometimes greed is not good. At times, we would like quantifiers to match a
  <i>minimal</i> piece of string, rather than a maximal piece. For this purpose,
  Larry Wall created the <i>minimal match</i> or <i>non-greedy</i> quantifiers
  &quot;??&quot;, &quot;*?&quot;, &quot;+?&quot;, and &quot;{}?&quot;. These are
  the usual quantifiers with a &quot;?&quot; appended to them. They have the
  following meanings:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a??&quot; means: match 'a' 0 or 1 times. Try 0 first,
      then 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a*?&quot; means: match 'a' 0 or more times, i.e., any
      number of times, but as few times as possible</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a+?&quot; means: match 'a' 1 or more times, i.e., at
      least once, but as few times as possible</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a{n,m}?&quot; means: match at least &quot;n&quot;
      times, not more than &quot;m&quot; times, as few times as possible</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a{n,}?&quot; means: match at least &quot;n&quot;
      times, but as few times as possible</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a{n}?&quot; means: match exactly &quot;n&quot; times.
      Because we match exactly &quot;n&quot; times, &quot;a{n}?&quot; is
      equivalent to &quot;a{n}&quot; and is just there for notational
      consistency.</dd>
</dl>
<div class="Pp"></div>
Let's look at the example above, but with minimal quantifiers:
<div class="Pp"></div>
<pre>
    $x = &quot;The programming republic of Perl&quot;;
    $x =~ /^(.+?)(e|r)(.*)$/; # matches,
                              # $1 = 'Th'
                              # $2 = 'e'
                              # $3 = ' programming republic of Perl'
</pre>
<div class="Pp"></div>
The minimal string that will allow both the start of the string &quot;^&quot;
  and the alternation to match is &quot;Th&quot;, with the alternation
  &quot;e|r&quot; matching &quot;e&quot;. The second quantifier &quot;.*&quot;
  is free to gobble up the rest of the string.
<div class="Pp"></div>
<pre>
    $x =~ /(m{1,2}?)(.*?)$/;  # matches,
                              # $1 = 'm'
                              # $2 = 'ming republic of Perl'
</pre>
<div class="Pp"></div>
The first string position that this regexp can match is at the first 'm' in
  &quot;programming&quot;. At this position, the minimal &quot;m{1,2}?&quot;
  matches just one 'm'. Although the second quantifier &quot;.*?&quot; would
  prefer to match no characters, it is constrained by the end-of-string anchor
  &quot;$&quot; to match the rest of the string.
<div class="Pp"></div>
<pre>
    $x =~ /(.*?)(m{1,2}?)(.*)$/;  # matches,
                                  # $1 = 'The progra'
                                  # $2 = 'm'
                                  # $3 = 'ming republic of Perl'
</pre>
<div class="Pp"></div>
In this regexp, you might expect the first minimal quantifier &quot;.*?&quot; to
  match the empty string, because it is not constrained by a &quot;^&quot;
  anchor to match the beginning of the word. Principle 0 applies here, however.
  Because it is possible for the whole regexp to match at the start of the
  string, it <i>will</i> match at the start of the string. Thus the first
  quantifier has to match everything up to the first &quot;m&quot;. The second
  minimal quantifier matches just one &quot;m&quot; and the third quantifier
  matches the rest of the string.
<div class="Pp"></div>
<pre>
    $x =~ /(.??)(m{1,2})(.*)$/;  # matches,
                                 # $1 = 'a'
                                 # $2 = 'mm'
                                 # $3 = 'ing republic of Perl'
</pre>
<div class="Pp"></div>
Just as in the previous regexp, the first quantifier &quot;.??&quot; can match
  earliest at position 'a', so it does. The second quantifier is greedy, so it
  matches &quot;mm&quot;, and the third matches the rest of the string.
<div class="Pp"></div>
We can modify principle 3 above to take into account non-greedy quantifiers:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Principle 3: If there are two or more elements in a regexp,
      the leftmost greedy (non-greedy) quantifier, if any, will match as much
      (little) of the string as possible while still allowing the whole regexp
      to match. The next leftmost greedy (non-greedy) quantifier, if any, will
      try to match as much (little) of the string remaining available to it as
      possible, while still allowing the whole regexp to match. And so on, until
      all the regexp elements are satisfied.</dd>
</dl>
<div class="Pp"></div>
Just like alternation, quantifiers are also susceptible to backtracking. Here is
  a step-by-step analysis of the example
<div class="Pp"></div>
<pre>
    $x = &quot;the cat in the hat&quot;;
    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 matches)
</pre>
<dl class="Bl-tag">
  <dt class="It-tag">0</dt>
  <dd class="It-tag">Start with the first letter in the string 't'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">1</dt>
  <dd class="It-tag">The first quantifier '.*' starts out by matching the whole
      string 'the cat in the hat'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2</dt>
  <dd class="It-tag">'a' in the regexp element 'at' doesn't match the end of the
      string. Backtrack one character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3</dt>
  <dd class="It-tag">'a' in the regexp element 'at' still doesn't match the last
      letter of the string 't', so backtrack one more character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4</dt>
  <dd class="It-tag">Now we can match the 'a' and the 't'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5</dt>
  <dd class="It-tag">Move on to the third element '.*'. Since we are at the end
      of the string and '.*' can match 0 times, assign it the empty string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">6</dt>
  <dd class="It-tag">We are done!</dd>
</dl>
<div class="Pp"></div>
Most of the time, all this moving forward and backtracking happens quickly and
  searching is fast. There are some pathological regexps, however, whose
  execution time exponentially grows with the size of the string. A typical
  structure that blows up in your face is of the form
<div class="Pp"></div>
<pre>
    /(a|b+)*/;
</pre>
<div class="Pp"></div>
The problem is the nested indeterminate quantifiers. There are many different
  ways of partitioning a string of length n between the &quot;+&quot; and
  &quot;*&quot;: one repetition with &quot;b+&quot; of length n, two repetitions
  with the first &quot;b+&quot; length k and the second with length n-k, m
  repetitions whose bits add up to length n, etc. In fact there are an
  exponential number of ways to partition a string as a function of its length.
  A regexp may get lucky and match early in the process, but if there is no
  match, Perl will try <i>every</i> possibility before giving up. So be careful
  with nested &quot;*&quot;'s, &quot;{n,m}&quot;'s, and &quot;+&quot;'s. The
  book <i>Mastering Regular Expressions</i> by Jeffrey Friedl gives a wonderful
  discussion of this and other efficiency issues.
<h2 class="Ss" title="Ss" id="Possessive_quantifiers"><a class="selflink" href="#Possessive_quantifiers">Possessive
  quantifiers</a></h2>
Backtracking during the relentless search for a match may be a waste of time,
  particularly when the match is bound to fail. Consider the simple pattern
<div class="Pp"></div>
<pre>
    /^\w+\s+\w+$/; # a word, spaces, a word
</pre>
<div class="Pp"></div>
Whenever this is applied to a string which doesn't quite meet the pattern's
  expectations such as &quot;abc&#x00A0;&#x00A0;&quot; or
  &quot;abc&#x00A0;&#x00A0;def&#x00A0;&quot;, the regex engine will backtrack,
  approximately once for each character in the string. But we know that there is
  no way around taking <i>all</i> of the initial word characters to match the
  first repetition, that <i>all</i> spaces must be eaten by the middle part, and
  the same goes for the second word.
<div class="Pp"></div>
With the introduction of the <i>possessive quantifiers</i> in Perl 5.10, we have
  a way of instructing the regex engine not to backtrack, with the usual
  quantifiers with a &quot;+&quot; appended to them. This makes them greedy as
  well as stingy; once they succeed they won't give anything back to permit
  another solution. They have the following meanings:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a{n,m}+&quot; means: match at least &quot;n&quot;
      times, not more than &quot;m&quot; times, as many times as possible, and
      don't give anything up. &quot;a?+&quot; is short for
    &quot;a{0,1}+&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a{n,}+&quot; means: match at least &quot;n&quot;
      times, but as many times as possible, and don't give anything up.
      &quot;a*+&quot; is short for &quot;a{0,}+&quot; and &quot;a++&quot; is
      short for &quot;a{1,}+&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;a{n}+&quot; means: match exactly &quot;n&quot; times.
      It is just there for notational consistency.</dd>
</dl>
<div class="Pp"></div>
These possessive quantifiers represent a special case of a more general concept,
  the <i>independent subexpression</i>, see below.
<div class="Pp"></div>
As an example where a possessive quantifier is suitable we consider matching a
  quoted string, as it appears in several programming languages. The backslash
  is used as an escape character that indicates that the next character is to be
  taken literally, as another character for the string. Therefore, after the
  opening quote, we expect a (possibly empty) sequence of alternatives: either
  some character except an unescaped quote or backslash or an escaped character.
<div class="Pp"></div>
<pre>
    /&quot;(?:[^&quot;\\]++|\\.)*+&quot;/;
</pre>
<h2 class="Ss" title="Ss" id="Building_a_regexp"><a class="selflink" href="#Building_a_regexp">Building
  a regexp</a></h2>
At this point, we have all the basic regexp concepts covered, so let's give a
  more involved example of a regular expression. We will build a regexp that
  matches numbers.
<div class="Pp"></div>
The first task in building a regexp is to decide what we want to match and what
  we want to exclude. In our case, we want to match both integers and floating
  point numbers and we want to reject any string that isn't a number.
<div class="Pp"></div>
The next task is to break the problem down into smaller problems that are easily
  converted into a regexp.
<div class="Pp"></div>
The simplest case is integers. These consist of a sequence of digits, with an
  optional sign in front. The digits we can represent with &quot;\d+&quot; and
  the sign can be matched with &quot;[+-]&quot;. Thus the integer regexp is
<div class="Pp"></div>
<pre>
    /[+-]?\d+/;  # matches integers
</pre>
<div class="Pp"></div>
A floating point number potentially has a sign, an integral part, a decimal
  point, a fractional part, and an exponent. One or more of these parts is
  optional, so we need to check out the different possibilities. Floating point
  numbers which are in proper form include 123., 0.345, .34, -1e6, and 25.4E-72.
  As with integers, the sign out front is completely optional and can be matched
  by &quot;[+-]?&quot;. We can see that if there is no exponent, floating point
  numbers must have a decimal point, otherwise they are integers. We might be
  tempted to model these with &quot;\d*\.\d*&quot;, but this would also match
  just a single decimal point, which is not a number. So the three cases of
  floating point number without exponent are
<div class="Pp"></div>
<pre>
   /[+-]?\d+\./;  # 1., 321., etc.
   /[+-]?\.\d+/;  # .1, .234, etc.
   /[+-]?\d+\.\d+/;  # 1.0, 30.56, etc.
</pre>
<div class="Pp"></div>
These can be combined into a single regexp with a three-way alternation:
<div class="Pp"></div>
<pre>
   /[+-]?(\d+\.\d+|\d+\.|\.\d+)/;  # floating point, no exponent
</pre>
<div class="Pp"></div>
In this alternation, it is important to put '\d+\.\d+' before '\d+\.'. If
  '\d+\.' were first, the regexp would happily match that and ignore the
  fractional part of the number.
<div class="Pp"></div>
Now consider floating point numbers with exponents. The key observation here is
  that <i>both</i> integers and numbers with decimal points are allowed in front
  of an exponent. Then exponents, like the overall sign, are independent of
  whether we are matching numbers with or without decimal points, and can be
  'decoupled' from the mantissa. The overall form of the regexp now becomes
  clear:
<div class="Pp"></div>
<pre>
    /^(optional sign)(integer | f.p. mantissa)(optional exponent)$/;
</pre>
<div class="Pp"></div>
The exponent is an &quot;e&quot; or &quot;E&quot;, followed by an integer. So
  the exponent regexp is
<div class="Pp"></div>
<pre>
   /[eE][+-]?\d+/;  # exponent
</pre>
<div class="Pp"></div>
Putting all the parts together, we get a regexp that matches numbers:
<div class="Pp"></div>
<pre>
   /^[+-]?(\d+\.\d+|\d+\.|\.\d+|\d+)([eE][+-]?\d+)?$/;  # Ta da!
</pre>
<div class="Pp"></div>
Long regexps like this may impress your friends, but can be hard to decipher. In
  complex situations like this, the &quot;//x&quot; modifier for a match is
  invaluable. It allows one to put nearly arbitrary whitespace and comments into
  a regexp without affecting their meaning. Using it, we can rewrite our
  'extended' regexp in the more pleasing form
<div class="Pp"></div>
<pre>
   /^
      [+-]?         # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+\.\d+  # mantissa of the form a.b
         |\d+\.     # mantissa of the form a.
         |\.\d+     # mantissa of the form .b
         |\d+       # integer of the form a
      )
      ([eE][+-]?\d+)?  # finally, optionally match an exponent
   $/x;
</pre>
<div class="Pp"></div>
If whitespace is mostly irrelevant, how does one include space characters in an
  extended regexp? The answer is to backslash it '\&#x00A0;' or put it in a
  character class &quot;[&#x00A0;]&quot;. The same thing goes for pound signs:
  use &quot;\#&quot; or &quot;[#]&quot;. For instance, Perl allows a space
  between the sign and the mantissa or integer, and we could add this to our
  regexp as follows:
<div class="Pp"></div>
<pre>
   /^
      [+-]?\ *      # first, match an optional sign *and space*
      (             # then match integers or f.p. mantissas:
          \d+\.\d+  # mantissa of the form a.b
         |\d+\.     # mantissa of the form a.
         |\.\d+     # mantissa of the form .b
         |\d+       # integer of the form a
      )
      ([eE][+-]?\d+)?  # finally, optionally match an exponent
   $/x;
</pre>
<div class="Pp"></div>
In this form, it is easier to see a way to simplify the alternation.
  Alternatives 1, 2, and 4 all start with &quot;\d+&quot;, so it could be
  factored out:
<div class="Pp"></div>
<pre>
   /^
      [+-]?\ *      # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+       # start out with a ...
          (
              \.\d* # mantissa of the form a.b or a.
          )?        # ? takes care of integers of the form a
         |\.\d+     # mantissa of the form .b
      )
      ([eE][+-]?\d+)?  # finally, optionally match an exponent
   $/x;
</pre>
<div class="Pp"></div>
or written in the compact form,
<div class="Pp"></div>
<pre>
    /^[+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$/;
</pre>
<div class="Pp"></div>
This is our final regexp. To recap, we built a regexp by
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">specifying the task in detail,</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">breaking down the problem into smaller parts,</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">translating the small parts into regexps,</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">combining the regexps,</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">and optimizing the final combined regexp.</dd>
</dl>
<div class="Pp"></div>
These are also the typical steps involved in writing a computer program. This
  makes perfect sense, because regular expressions are essentially programs
  written in a little computer language that specifies patterns.
<h2 class="Ss" title="Ss" id="Using_regular_expressions_in_Perl"><a class="selflink" href="#Using_regular_expressions_in_Perl">Using
  regular expressions in Perl</a></h2>
The last topic of Part 1 briefly covers how regexps are used in Perl programs.
  Where do they fit into Perl syntax?
<div class="Pp"></div>
We have already introduced the matching operator in its default
  &quot;/regexp/&quot; and arbitrary delimiter &quot;m!regexp!&quot; forms. We
  have used the binding operator &quot;=~&quot; and its negation &quot;!~&quot;
  to test for string matches. Associated with the matching operator, we have
  discussed the single line &quot;//s&quot;, multi-line &quot;//m&quot;,
  case-insensitive &quot;//i&quot; and extended &quot;//x&quot; modifiers. There
  are a few more things you might want to know about matching operators.
<div class="Pp"></div>
<i>Prohibiting substitution</i>
<div class="Pp"></div>
If you change $pattern after the first substitution happens, Perl will ignore
  it. If you don't want any substitutions at all, use the special delimiter
  &quot;m''&quot;:
<div class="Pp"></div>
<pre>
    @pattern = ('Seuss');
    while (&lt;&gt;) {
        print if m'@pattern';  # matches literal '@pattern', not 'Seuss'
    }
</pre>
<div class="Pp"></div>
Similar to strings, &quot;m''&quot; acts like apostrophes on a regexp; all other
  &quot;m&quot; delimiters act like quotes. If the regexp evaluates to the empty
  string, the regexp in the <i>last successful match</i> is used instead. So we
  have
<div class="Pp"></div>
<pre>
    &quot;dog&quot; =~ /d/;  # 'd' matches
    &quot;dogbert =~ //;  # this matches the 'd' regexp used before
</pre>
<div class="Pp"></div>
<i>Global matching</i>
<div class="Pp"></div>
The final two modifiers we will discuss here, &quot;//g&quot; and
  &quot;//c&quot;, concern multiple matches. The modifier &quot;//g&quot; stands
  for global matching and allows the matching operator to match within a string
  as many times as possible. In scalar context, successive invocations against a
  string will have &quot;//g&quot; jump from match to match, keeping track of
  position in the string as it goes along. You can get or set the position with
  the &quot;pos()&quot; function.
<div class="Pp"></div>
The use of &quot;//g&quot; is shown in the following example. Suppose we have a
  string that consists of words separated by spaces. If we know how many words
  there are in advance, we could extract the words using groupings:
<div class="Pp"></div>
<pre>
    $x = &quot;cat dog house&quot;; # 3 words
    $x =~ /^\s*(\w+)\s+(\w+)\s+(\w+)\s*$/; # matches,
                                           # $1 = 'cat'
                                           # $2 = 'dog'
                                           # $3 = 'house'
</pre>
<div class="Pp"></div>
But what if we had an indeterminate number of words? This is the sort of task
  &quot;//g&quot; was made for. To extract all words, form the simple regexp
  &quot;(\w+)&quot; and loop over all matches with &quot;/(\w+)/g&quot;:
<div class="Pp"></div>
<pre>
    while ($x =~ /(\w+)/g) {
        print &quot;Word is $1, ends at position &quot;, pos $x, &quot;\n&quot;;
    }
</pre>
<div class="Pp"></div>
prints
<div class="Pp"></div>
<pre>
    Word is cat, ends at position 3
    Word is dog, ends at position 7
    Word is house, ends at position 13
</pre>
<div class="Pp"></div>
A failed match or changing the target string resets the position. If you don't
  want the position reset after failure to match, add the &quot;//c&quot;, as in
  &quot;/regexp/gc&quot;. The current position in the string is associated with
  the string, not the regexp. This means that different strings have different
  positions and their respective positions can be set or read independently.
<div class="Pp"></div>
In list context, &quot;//g&quot; returns a list of matched groupings, or if
  there are no groupings, a list of matches to the whole regexp. So if we wanted
  just the words, we could use
<div class="Pp"></div>
<pre>
    @words = ($x =~ /(\w+)/g);  # matches,
                                # $words[0] = 'cat'
                                # $words[1] = 'dog'
                                # $words[2] = 'house'
</pre>
<div class="Pp"></div>
Closely associated with the &quot;//g&quot; modifier is the &quot;\G&quot;
  anchor. The &quot;\G&quot; anchor matches at the point where the previous
  &quot;//g&quot; match left off. &quot;\G&quot; allows us to easily do
  context-sensitive matching:
<div class="Pp"></div>
<pre>
    $metric = 1;  # use metric units
    ...
    $x = &lt;FILE&gt;;  # read in measurement
    $x =~ /^([+-]?\d+)\s*/g;  # get magnitude
    $weight = $1;
    if ($metric) { # error checking
        print &quot;Units error!&quot; unless $x =~ /\Gkg\./g;
    }
    else {
        print &quot;Units error!&quot; unless $x =~ /\Glbs\./g;
    }
    $x =~ /\G\s+(widget|sprocket)/g;  # continue processing
</pre>
<div class="Pp"></div>
The combination of &quot;//g&quot; and &quot;\G&quot; allows us to process the
  string a bit at a time and use arbitrary Perl logic to decide what to do next.
  Currently, the &quot;\G&quot; anchor is only fully supported when used to
  anchor to the start of the pattern.
<div class="Pp"></div>
&quot;\G&quot; is also invaluable in processing fixed-length records with
  regexps. Suppose we have a snippet of coding region DNA, encoded as base pair
  letters &quot;ATCGTTGAAT...&quot; and we want to find all the stop codons
  &quot;TGA&quot;. In a coding region, codons are 3-letter sequences, so we can
  think of the DNA snippet as a sequence of 3-letter records. The naive regexp
<div class="Pp"></div>
<pre>
    # expanded, this is &quot;ATC GTT GAA TGC AAA TGA CAT GAC&quot;
    $dna = &quot;ATCGTTGAATGCAAATGACATGAC&quot;;
    $dna =~ /TGA/;
</pre>
<div class="Pp"></div>
doesn't work; it may match a &quot;TGA&quot;, but there is no guarantee that the
  match is aligned with codon boundaries, e.g., the substring
  &quot;GTT&#x00A0;GAA&quot; gives a match. A better solution is
<div class="Pp"></div>
<pre>
    while ($dna =~ /(\w\w\w)*?TGA/g) {  # note the minimal *?
        print &quot;Got a TGA stop codon at position &quot;, pos $dna, &quot;\n&quot;;
    }
</pre>
<div class="Pp"></div>
which prints
<div class="Pp"></div>
<pre>
    Got a TGA stop codon at position 18
    Got a TGA stop codon at position 23
</pre>
<div class="Pp"></div>
Position 18 is good, but position 23 is bogus. What happened?
<div class="Pp"></div>
The answer is that our regexp works well until we get past the last real match.
  Then the regexp will fail to match a synchronized &quot;TGA&quot; and start
  stepping ahead one character position at a time, not what we want. The
  solution is to use &quot;\G&quot; to anchor the match to the codon alignment:
<div class="Pp"></div>
<pre>
    while ($dna =~ /\G(\w\w\w)*?TGA/g) {
        print &quot;Got a TGA stop codon at position &quot;, pos $dna, &quot;\n&quot;;
    }
</pre>
<div class="Pp"></div>
This prints
<div class="Pp"></div>
<pre>
    Got a TGA stop codon at position 18
</pre>
<div class="Pp"></div>
which is the correct answer. This example illustrates that it is important not
  only to match what is desired, but to reject what is not desired.
<div class="Pp"></div>
(There are other regexp modifiers that are available, such as &quot;//o&quot;,
  but their specialized uses are beyond the scope of this introduction. )
<div class="Pp"></div>
<i>Search and replace</i>
<div class="Pp"></div>
Regular expressions also play a big role in <i>search and replace</i> operations
  in Perl. Search and replace is accomplished with the &quot;s///&quot;
  operator. The general form is &quot;s/regexp/replacement/modifiers&quot;, with
  everything we know about regexps and modifiers applying in this case as well.
  The &quot;replacement&quot; is a Perl double-quoted string that replaces in
  the string whatever is matched with the &quot;regexp&quot;. The operator
  &quot;=~&quot; is also used here to associate a string with &quot;s///&quot;.
  If matching against $_, the &quot;$_&#x00A0;=~&quot; can be dropped. If there
  is a match, &quot;s///&quot; returns the number of substitutions made;
  otherwise it returns false. Here are a few examples:
<div class="Pp"></div>
<pre>
    $x = &quot;Time to feed the cat!&quot;;
    $x =~ s/cat/hacker/;   # $x contains &quot;Time to feed the hacker!&quot;
    if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
        $more_insistent = 1;
    }
    $y = &quot;'quoted words'&quot;;
    $y =~ s/^'(.*)'$/$1/;  # strip single quotes,
                           # $y contains &quot;quoted words&quot;
</pre>
<div class="Pp"></div>
In the last example, the whole string was matched, but only the part inside the
  single quotes was grouped. With the &quot;s///&quot; operator, the matched
  variables $1, $2, etc. are immediately available for use in the replacement
  expression, so we use $1 to replace the quoted string with just what was
  quoted. With the global modifier, &quot;s///g&quot; will search and replace
  all occurrences of the regexp in the string:
<div class="Pp"></div>
<pre>
    $x = &quot;I batted 4 for 4&quot;;
    $x =~ s/4/four/;   # doesn't do it all:
                       # $x contains &quot;I batted four for 4&quot;
    $x = &quot;I batted 4 for 4&quot;;
    $x =~ s/4/four/g;  # does it all:
                       # $x contains &quot;I batted four for four&quot;
</pre>
<div class="Pp"></div>
If you prefer 'regex' over 'regexp' in this tutorial, you could use the
  following program to replace it:
<div class="Pp"></div>
<pre>
    % cat &gt; simple_replace
    #!/usr/bin/perl
    $regexp = shift;
    $replacement = shift;
    while (&lt;&gt;) {
        s/$regexp/$replacement/g;
        print;
    }
    ^D
    % simple_replace regexp regex perlretut.pod
</pre>
<div class="Pp"></div>
In &quot;simple_replace&quot; we used the &quot;s///g&quot; modifier to replace
  all occurrences of the regexp on each line. (Even though the regular
  expression appears in a loop, Perl is smart enough to compile it only once.)
  As with &quot;simple_grep&quot;, both the &quot;print&quot; and the
  &quot;s/$regexp/$replacement/g&quot; use $_ implicitly.
<div class="Pp"></div>
If you don't want &quot;s///&quot; to change your original variable you can use
  the non-destructive substitute modifier, &quot;s///r&quot;. This changes the
  behavior so that &quot;s///r&quot; returns the final substituted string
  (instead of the number of substitutions):
<div class="Pp"></div>
<pre>
    $x = &quot;I like dogs.&quot;;
    $y = $x =~ s/dogs/cats/r;
    print &quot;$x $y\n&quot;;
</pre>
<div class="Pp"></div>
That example will print &quot;I like dogs. I like cats&quot;. Notice the
  original $x variable has not been affected. The overall result of the
  substitution is instead stored in $y. If the substitution doesn't affect
  anything then the original string is returned:
<div class="Pp"></div>
<pre>
    $x = &quot;I like dogs.&quot;;
    $y = $x =~ s/elephants/cougars/r;
    print &quot;$x $y\n&quot;; # prints &quot;I like dogs. I like dogs.&quot;
</pre>
<div class="Pp"></div>
One other interesting thing that the &quot;s///r&quot; flag allows is chaining
  substitutions:
<div class="Pp"></div>
<pre>
    $x = &quot;Cats are great.&quot;;
    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, &quot;\n&quot;;
    # prints &quot;Hedgehogs are great.&quot;
</pre>
<div class="Pp"></div>
A modifier available specifically to search and replace is the &quot;s///e&quot;
  evaluation modifier. &quot;s///e&quot; treats the replacement text as Perl
  code, rather than a double-quoted string. The value that the code returns is
  substituted for the matched substring. &quot;s///e&quot; is useful if you need
  to do a bit of computation in the process of replacing text. This example
  counts character frequencies in a line:
<div class="Pp"></div>
<pre>
    $x = &quot;Bill the cat&quot;;
    $x =~ s/(.)/$chars{$1}++;$1/eg;  # final $1 replaces char with itself
    print &quot;frequency of '$_' is $chars{$_}\n&quot;
        foreach (sort {$chars{$b} &lt;=&gt; $chars{$a}} keys %chars);
</pre>
<div class="Pp"></div>
This prints
<div class="Pp"></div>
<pre>
    frequency of ' ' is 2
    frequency of 't' is 2
    frequency of 'l' is 2
    frequency of 'B' is 1
    frequency of 'c' is 1
    frequency of 'e' is 1
    frequency of 'h' is 1
    frequency of 'i' is 1
    frequency of 'a' is 1
</pre>
<div class="Pp"></div>
As with the match &quot;m//&quot; operator, &quot;s///&quot; can use other
  delimiters, such as &quot;s!!!&quot; and &quot;s{}{}&quot;, and even
  &quot;s{}//&quot;. If single quotes are used &quot;s'''&quot;, then the regexp
  and replacement are treated as single-quoted strings and there are no variable
  substitutions. &quot;s///&quot; in list context returns the same thing as in
  scalar context, i.e., the number of matches.
<div class="Pp"></div>
<i>The split function</i>
<div class="Pp"></div>
The &quot;split()&quot; function is another place where a regexp is used.
  &quot;split /regexp/, string, limit&quot; separates the &quot;string&quot;
  operand into a list of substrings and returns that list. The regexp must be
  designed to match whatever constitutes the separators for the desired
  substrings. The &quot;limit&quot;, if present, constrains splitting into no
  more than &quot;limit&quot; number of strings. For example, to split a string
  into words, use
<div class="Pp"></div>
<pre>
    $x = &quot;Calvin and Hobbes&quot;;
    @words = split /\s+/, $x;  # $word[0] = 'Calvin'
                               # $word[1] = 'and'
                               # $word[2] = 'Hobbes'
</pre>
<div class="Pp"></div>
If the empty regexp &quot;//&quot; is used, the regexp always matches and the
  string is split into individual characters. If the regexp has groupings, then
  the resulting list contains the matched substrings from the groupings as well.
  For instance,
<div class="Pp"></div>
<pre>
    $x = &quot;/usr/bin/perl&quot;;
    @dirs = split m!/!, $x;  # $dirs[0] = ''
                             # $dirs[1] = 'usr'
                             # $dirs[2] = 'bin'
                             # $dirs[3] = 'perl'
    @parts = split m!(/)!, $x;  # $parts[0] = ''
                                # $parts[1] = '/'
                                # $parts[2] = 'usr'
                                # $parts[3] = '/'
                                # $parts[4] = 'bin'
                                # $parts[5] = '/'
                                # $parts[6] = 'perl'
</pre>
<div class="Pp"></div>
Since the first character of $x matched the regexp, &quot;split&quot; prepended
  an empty initial element to the list.
<div class="Pp"></div>
If you have read this far, congratulations! You now have all the basic tools
  needed to use regular expressions to solve a wide range of text processing
  problems. If this is your first time through the tutorial, why not stop here
  and play around with regexps a while.... Part&#x00A0;2 concerns the more
  esoteric aspects of regular expressions and those concepts certainly aren't
  needed right at the start.
<h1 class="Sh" title="Sh" id="Part_2:_Power_tools"><a class="selflink" href="#Part_2:_Power_tools">Part
  2: Power tools</a></h1>
OK, you know the basics of regexps and you want to know more. If matching
  regular expressions is analogous to a walk in the woods, then the tools
  discussed in Part 1 are analogous to topo maps and a compass, basic tools we
  use all the time. Most of the tools in part 2 are analogous to flare guns and
  satellite phones. They aren't used too often on a hike, but when we are stuck,
  they can be invaluable.
<div class="Pp"></div>
What follows are the more advanced, less used, or sometimes esoteric
  capabilities of Perl regexps. In Part 2, we will assume you are comfortable
  with the basics and concentrate on the advanced features.
<h2 class="Ss" title="Ss" id="More_on_characters,_strings,_and_character_classes"><a class="selflink" href="#More_on_characters,_strings,_and_character_classes">More
  on characters, strings, and character classes</a></h2>
There are a number of escape sequences and character classes that we haven't
  covered yet.
<div class="Pp"></div>
There are several escape sequences that convert characters or strings between
  upper and lower case, and they are also available within patterns.
  &quot;\l&quot; and &quot;\u&quot; convert the next character to lower or upper
  case, respectively:
<div class="Pp"></div>
<pre>
    $x = &quot;perl&quot;;
    $string =~ /\u$x/;  # matches 'Perl' in $string
    $x = &quot;M(rs?|s)\\.&quot;; # note the double backslash
    $string =~ /\l$x/;  # matches 'mr.', 'mrs.', and 'ms.',
</pre>
<div class="Pp"></div>
A &quot;\L&quot; or &quot;\U&quot; indicates a lasting conversion of case, until
  terminated by &quot;\E&quot; or thrown over by another &quot;\U&quot; or
  &quot;\L&quot;:
<div class="Pp"></div>
<pre>
    $x = &quot;This word is in lower case:\L SHOUT\E&quot;;
    $x =~ /shout/;       # matches
    $x = &quot;I STILL KEYPUNCH CARDS FOR MY 360&quot;
    $x =~ /\Ukeypunch/;  # matches punch card string
</pre>
<div class="Pp"></div>
If there is no &quot;\E&quot;, case is converted until the end of the string.
  The regexps &quot;\L\u$word&quot; or &quot;\u\L$word&quot; convert the first
  character of $word to uppercase and the rest of the characters to lowercase.
<div class="Pp"></div>
Control characters can be escaped with &quot;\c&quot;, so that a control-Z
  character would be matched with &quot;\cZ&quot;. The escape sequence
  &quot;\Q&quot;...&quot;\E&quot; quotes, or protects most non-alphabetic
  characters. For instance,
<div class="Pp"></div>
<pre>
    $x = &quot;\QThat !^*&amp;%~&amp; cat!&quot;;
    $x =~ /\Q!^*&amp;%~&amp;\E/;  # check for rough language
</pre>
<div class="Pp"></div>
It does not protect &quot;$&quot; or &quot;@&quot;, so that variables can still
  be substituted.
<div class="Pp"></div>
&quot;\Q&quot;, &quot;\L&quot;, &quot;\l&quot;, &quot;\U&quot;, &quot;\u&quot;
  and &quot;\E&quot; are actually part of double-quotish syntax, and not part of
  regexp syntax proper. They will work if they appear in a regular expression
  embedded directly in a program, but not when contained in a string that is
  interpolated in a pattern.
<div class="Pp"></div>
With the advent of 5.6.0, Perl regexps can handle more than just the standard
  ASCII character set. Perl now supports <i>Unicode</i>, a standard for
  representing the alphabets from virtually all of the world's written
  languages, and a host of symbols. Perl's text strings are Unicode strings, so
  they can contain characters with a value (codepoint or character number)
  higher than 255.
<div class="Pp"></div>
What does this mean for regexps? Well, regexp users don't need to know much
  about Perl's internal representation of strings. But they do need to know 1)
  how to represent Unicode characters in a regexp and 2) that a matching
  operation will treat the string to be searched as a sequence of characters,
  not bytes. The answer to 1) is that Unicode characters greater than
  &quot;chr(255)&quot; are represented using the &quot;\x{hex}&quot; notation,
  because \x hex (without curly braces) doesn't go further than 255. (Starting
  in Perl 5.14, if you're an octal fan, you can also use &quot;\o{oct}&quot;.)
<div class="Pp"></div>
<pre>
    /\x{263a}/;  # match a Unicode smiley face :)
</pre>
<div class="Pp"></div>
<b>NOTE</b>: In Perl 5.6.0 it used to be that one needed to say &quot;use
  utf8&quot; to use any Unicode features. This is no more the case: for almost
  all Unicode processing, the explicit &quot;utf8&quot; pragma is not needed.
  (The only case where it matters is if your Perl script is in Unicode and
  encoded in UTF-8, then an explicit &quot;use utf8&quot; is needed.)
<div class="Pp"></div>
Figuring out the hexadecimal sequence of a Unicode character you want or
  deciphering someone else's hexadecimal Unicode regexp is about as much fun as
  programming in machine code. So another way to specify Unicode characters is
  to use the <i>named character</i> escape sequence &quot;\N{
  <i>name</i>}&quot;. <i>name</i> is a name for the Unicode character, as
  specified in the Unicode standard. For instance, if we wanted to represent or
  match the astrological sign for the planet Mercury, we could use
<div class="Pp"></div>
<pre>
    $x = &quot;abc\N{MERCURY}def&quot;;
    $x =~ /\N{MERCURY}/;   # matches
</pre>
<div class="Pp"></div>
One can also use &quot;short&quot; names:
<div class="Pp"></div>
<pre>
    print &quot;\N{GREEK SMALL LETTER SIGMA} is called sigma.\n&quot;;
    print &quot;\N{greek:Sigma} is an upper-case sigma.\n&quot;;
</pre>
<div class="Pp"></div>
You can also restrict names to a certain alphabet by specifying the charnames
  pragma:
<div class="Pp"></div>
<pre>
    use charnames qw(greek);
    print &quot;\N{sigma} is Greek sigma\n&quot;;
</pre>
<div class="Pp"></div>
An index of character names is available on-line from the Unicode Consortium,
  &lt;http://www.unicode.org/charts/charindex.html&gt;; explanatory material
  with links to other resources at
  &lt;http://www.unicode.org/standard/where&gt;.
<div class="Pp"></div>
The answer to requirement 2) is, as of 5.6.0, that a regexp (mostly) uses
  Unicode characters. (The &quot;mostly&quot; is for messy backward
  compatibility reasons, but starting in Perl 5.14, any regex compiled in the
  scope of a &quot;use feature 'unicode_strings'&quot; (which is automatically
  turned on within the scope of a &quot;use 5.012&quot; or higher) will turn
  that &quot;mostly&quot; into &quot;always&quot;. If you want to handle Unicode
  properly, you should ensure that 'unicode_strings' is turned on.) Internally,
  this is encoded to bytes using either UTF-8 or a native 8 bit encoding,
  depending on the history of the string, but conceptually it is a sequence of
  characters, not bytes. See perlunitut for a tutorial about that.
<div class="Pp"></div>
Let us now discuss Unicode character classes. Just as with Unicode characters,
  there are named Unicode character classes represented by the
  &quot;\p{name}&quot; escape sequence. Closely associated is the
  &quot;\P{name}&quot; character class, which is the negation of the
  &quot;\p{name}&quot; class. For example, to match lower and uppercase
  characters,
<div class="Pp"></div>
<pre>
    $x = &quot;BOB&quot;;
    $x =~ /^\p{IsUpper}/;   # matches, uppercase char class
    $x =~ /^\P{IsUpper}/;   # doesn't match, char class sans uppercase
    $x =~ /^\p{IsLower}/;   # doesn't match, lowercase char class
    $x =~ /^\P{IsLower}/;   # matches, char class sans lowercase
</pre>
<div class="Pp"></div>
(The &quot;Is&quot; is optional.)
<div class="Pp"></div>
Here is the association between some Perl named classes and the traditional
  Unicode classes:
<div class="Pp"></div>
<pre>
    Perl class name  Unicode class name or regular expression
    IsAlpha          /^[LM]/
    IsAlnum          /^[LMN]/
    IsASCII          $code &lt;= 127
    IsCntrl          /^C/
    IsBlank          $code =~ /^(0020|0009)$/ || /^Z[^lp]/
    IsDigit          Nd
    IsGraph          /^([LMNPS]|Co)/
    IsLower          Ll
    IsPrint          /^([LMNPS]|Co|Zs)/
    IsPunct          /^P/
    IsSpace          /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/
    IsSpacePerl      /^Z/ || ($code =~ /^(0009|000A|000C|000D|0085|2028|2029)$/
    IsUpper          /^L[ut]/
    IsWord           /^[LMN]/ || $code eq &quot;005F&quot;
    IsXDigit         $code =~ /^00(3[0-9]|[46][1-6])$/
</pre>
<div class="Pp"></div>
You can also use the official Unicode class names with &quot;\p&quot; and
  &quot;\P&quot;, like &quot;\p{L}&quot; for Unicode 'letters',
  &quot;\p{Lu}&quot; for uppercase letters, or &quot;\P{Nd}&quot; for
  non-digits. If a &quot;name&quot; is just one letter, the braces can be
  dropped. For instance, &quot;\pM&quot; is the character class of Unicode
  'marks', for example accent marks. For the full list see perlunicode.
<div class="Pp"></div>
Unicode has also been separated into various sets of characters which you can
  test with &quot;\p{...}&quot; (in) and &quot;\P{...}&quot; (not in). To test
  whether a character is (or is not) an element of a script you would use the
  script name, for example &quot;\p{Latin}&quot;, &quot;\p{Greek}&quot;, or
  &quot;\P{Katakana}&quot;.
<div class="Pp"></div>
What we have described so far is the single form of the &quot;\p{...}&quot;
  character classes. There is also a compound form which you may run into. These
  look like &quot;\p{name=value}&quot; or &quot;\p{name:value}&quot; (the equals
  sign and colon can be used interchangeably). These are more general than the
  single form, and in fact most of the single forms are just Perl-defined
  shortcuts for common compound forms. For example, the script examples in the
  previous paragraph could be written equivalently as
  &quot;\p{Script=Latin}&quot;, &quot;\p{Script:Greek}&quot;, and
  &quot;\P{script=katakana}&quot; (case is irrelevant between the &quot;{}&quot;
  braces). You may never have to use the compound forms, but sometimes it is
  necessary, and their use can make your code easier to understand.
<div class="Pp"></div>
&quot;\X&quot; is an abbreviation for a character class that comprises a Unicode
  <i>extended grapheme cluster</i>. This represents a &quot;logical
  character&quot;: what appears to be a single character, but may be represented
  internally by more than one. As an example, using the Unicode full names,
  e.g., &quot;A&#x00A0;+&#x00A0;COMBINING&#x00A0;RING&quot; is a grapheme
  cluster with base character &quot;A&quot; and combining character
  &quot;COMBINING&#x00A0;RING&quot;, which translates in Danish to A with the
  circle atop it, as in the word Angstrom.
<div class="Pp"></div>
For the full and latest information about Unicode see the latest Unicode
  standard, or the Unicode Consortium's website &lt;http://www.unicode.org&gt;
<div class="Pp"></div>
As if all those classes weren't enough, Perl also defines POSIX-style character
  classes. These have the form &quot;[:name:]&quot;, with &quot;name&quot; the
  name of the POSIX class. The POSIX classes are &quot;alpha&quot;,
  &quot;alnum&quot;, &quot;ascii&quot;, &quot;cntrl&quot;, &quot;digit&quot;,
  &quot;graph&quot;, &quot;lower&quot;, &quot;print&quot;, &quot;punct&quot;,
  &quot;space&quot;, &quot;upper&quot;, and &quot;xdigit&quot;, and two
  extensions, &quot;word&quot; (a Perl extension to match &quot;\w&quot;), and
  &quot;blank&quot; (a GNU extension). The &quot;//a&quot; modifier restricts
  these to matching just in the ASCII range; otherwise they can match the same
  as their corresponding Perl Unicode classes: &quot;[:upper:]&quot; is the same
  as &quot;\p{IsUpper}&quot;, etc. (There are some exceptions and gotchas with
  this; see perlrecharclass for a full discussion.) The &quot;[:digit:]&quot;,
  &quot;[:word:]&quot;, and &quot;[:space:]&quot; correspond to the familiar
  &quot;\d&quot;, &quot;\w&quot;, and &quot;\s&quot; character classes. To
  negate a POSIX class, put a &quot;^&quot; in front of the name, so that, e.g.,
  &quot;[:^digit:]&quot; corresponds to &quot;\D&quot; and, under Unicode,
  &quot;\P{IsDigit}&quot;. The Unicode and POSIX character classes can be used
  just like &quot;\d&quot;, with the exception that POSIX character classes can
  only be used inside of a character class:
<div class="Pp"></div>
<pre>
    /\s+[abc[:digit:]xyz]\s*/;  # match a,b,c,x,y,z, or a digit
    /^=item\s[[:digit:]]/;      # match '=item',
                                # followed by a space and a digit
    /\s+[abc\p{IsDigit}xyz]\s+/;  # match a,b,c,x,y,z, or a digit
    /^=item\s\p{IsDigit}/;        # match '=item',
                                  # followed by a space and a digit
</pre>
<div class="Pp"></div>
Whew! That is all the rest of the characters and character classes.
<h2 class="Ss" title="Ss" id="Compiling_and_saving_regular_expressions"><a class="selflink" href="#Compiling_and_saving_regular_expressions">Compiling
  and saving regular expressions</a></h2>
In Part 1 we mentioned that Perl compiles a regexp into a compact sequence of
  opcodes. Thus, a compiled regexp is a data structure that can be stored once
  and used again and again. The regexp quote &quot;qr//&quot; does exactly that:
  &quot;qr/string/&quot; compiles the &quot;string&quot; as a regexp and
  transforms the result into a form that can be assigned to a variable:
<div class="Pp"></div>
<pre>
    $reg = qr/foo+bar?/;  # reg contains a compiled regexp
</pre>
<div class="Pp"></div>
Then $reg can be used as a regexp:
<div class="Pp"></div>
<pre>
    $x = &quot;fooooba&quot;;
    $x =~ $reg;     # matches, just like /foo+bar?/
    $x =~ /$reg/;   # same thing, alternate form
</pre>
<div class="Pp"></div>
$reg can also be interpolated into a larger regexp:
<div class="Pp"></div>
<pre>
    $x =~ /(abc)?$reg/;  # still matches
</pre>
<div class="Pp"></div>
As with the matching operator, the regexp quote can use different delimiters,
  e.g., &quot;qr!!&quot;, &quot;qr{}&quot; or &quot;qr~~&quot;. Apostrophes as
  delimiters (&quot;qr''&quot;) inhibit any interpolation.
<div class="Pp"></div>
Pre-compiled regexps are useful for creating dynamic matches that don't need to
  be recompiled each time they are encountered. Using pre-compiled regexps, we
  write a &quot;grep_step&quot; program which greps for a sequence of patterns,
  advancing to the next pattern as soon as one has been satisfied.
<div class="Pp"></div>
<pre>
    % cat &gt; grep_step
    #!/usr/bin/perl
    # grep_step - match &lt;number&gt; regexps, one after the other
    # usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2 ...
    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
    @compiled = map qr/$_/, @regexp;
    while ($line = &lt;&gt;) {
        if ($line =~ /$compiled[0]/) {
            print $line;
            shift @compiled;
            last unless @compiled;
        }
    }
    ^D
    % grep_step 3 shift print last grep_step
    $number = shift;
            print $line;
            last unless @compiled;
</pre>
<div class="Pp"></div>
Storing pre-compiled regexps in an array @compiled allows us to simply loop
  through the regexps without any recompilation, thus gaining flexibility
  without sacrificing speed.
<h2 class="Ss" title="Ss" id="Composing_regular_expressions_at_runtime"><a class="selflink" href="#Composing_regular_expressions_at_runtime">Composing
  regular expressions at runtime</a></h2>
Backtracking is more efficient than repeated tries with different regular
  expressions. If there are several regular expressions and a match with any of
  them is acceptable, then it is possible to combine them into a set of
  alternatives. If the individual expressions are input data, this can be done
  by programming a join operation. We'll exploit this idea in an improved
  version of the &quot;simple_grep&quot; program: a program that matches
  multiple patterns:
<div class="Pp"></div>
<pre>
    % cat &gt; multi_grep
    #!/usr/bin/perl
    # multi_grep - match any of &lt;number&gt; regexps
    # usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2 ...
    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
    $pattern = join '|', @regexp;
    while ($line = &lt;&gt;) {
        print $line if $line =~ /$pattern/;
    }
    ^D
    % multi_grep 2 shift for multi_grep
    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
</pre>
<div class="Pp"></div>
Sometimes it is advantageous to construct a pattern from the <i>input</i> that
  is to be analyzed and use the permissible values on the left hand side of the
  matching operations. As an example for this somewhat paradoxical situation,
  let's assume that our input contains a command verb which should match one out
  of a set of available command verbs, with the additional twist that commands
  may be abbreviated as long as the given string is unique. The program below
  demonstrates the basic algorithm.
<div class="Pp"></div>
<pre>
    % cat &gt; keymatch
    #!/usr/bin/perl
    $kwds = 'copy compare list print';
    while( $command = &lt;&gt; ){
        $command =~ s/^\s+|\s+$//g;  # trim leading and trailing spaces
        if( ( @matches = $kwds =~ /\b$command\w*/g ) == 1 ){
            print &quot;command: '@matches'\n&quot;;
        } elsif( @matches == 0 ){
            print &quot;no such command: '$command'\n&quot;;
        } else {
            print &quot;not unique: '$command' (could be one of: @matches)\n&quot;;
        }
    }
    ^D
    % keymatch
    li
    command: 'list'
    co
    not unique: 'co' (could be one of: copy compare)
    printer
    no such command: 'printer'
</pre>
<div class="Pp"></div>
Rather than trying to match the input against the keywords, we match the
  combined set of keywords against the input. The pattern matching operation
  &quot;$kwds&#x00A0;=~&#x00A0;/\b($command\w*)/g&quot; does several things at
  the same time. It makes sure that the given command begins where a keyword
  begins (&quot;\b&quot;). It tolerates abbreviations due to the added
  &quot;\w*&quot;. It tells us the number of matches (&quot;scalar
  @matches&quot;) and all the keywords that were actually matched. You could
  hardly ask for more.
<h2 class="Ss" title="Ss" id="Embedding_comments_and_modifiers_in_a_regular_expression"><a class="selflink" href="#Embedding_comments_and_modifiers_in_a_regular_expression">Embedding
  comments and modifiers in a regular expression</a></h2>
Starting with this section, we will be discussing Perl's set of <i>extended
  patterns</i>. These are extensions to the traditional regular expression
  syntax that provide powerful new tools for pattern matching. We have already
  seen extensions in the form of the minimal matching constructs &quot;??&quot;,
  &quot;*?&quot;, &quot;+?&quot;, &quot;{n,m}?&quot;, and &quot;{n,}?&quot;.
  Most of the extensions below have the form &quot;(?char...)&quot;, where the
  &quot;char&quot; is a character that determines the type of extension.
<div class="Pp"></div>
The first extension is an embedded comment &quot;(?#text)&quot;. This embeds a
  comment into the regular expression without affecting its meaning. The comment
  should not have any closing parentheses in the text. An example is
<div class="Pp"></div>
<pre>
    /(?# Match an integer:)[+-]?\d+/;
</pre>
<div class="Pp"></div>
This style of commenting has been largely superseded by the raw, freeform
  commenting that is allowed with the &quot;//x&quot; modifier.
<div class="Pp"></div>
Most modifiers, such as &quot;//i&quot;, &quot;//m&quot;, &quot;//s&quot; and
  &quot;//x&quot; (or any combination thereof) can also be embedded in a regexp
  using &quot;(?i)&quot;, &quot;(?m)&quot;, &quot;(?s)&quot;, and
  &quot;(?x)&quot;. For instance,
<div class="Pp"></div>
<pre>
    /(?i)yes/;  # match 'yes' case insensitively
    /yes/i;     # same thing
    /(?x)(          # freeform version of an integer regexp
             [+-]?  # match an optional sign
             \d+    # match a sequence of digits
         )
    /x;
</pre>
<div class="Pp"></div>
Embedded modifiers can have two important advantages over the usual modifiers.
  Embedded modifiers allow a custom set of modifiers to <i>each</i> regexp
  pattern. This is great for matching an array of regexps that must have
  different modifiers:
<div class="Pp"></div>
<pre>
    $pattern[0] = '(?i)doctor';
    $pattern[1] = 'Johnson';
    ...
    while (&lt;&gt;) {
        foreach $patt (@pattern) {
            print if /$patt/;
        }
    }
</pre>
<div class="Pp"></div>
The second advantage is that embedded modifiers (except &quot;//p&quot;, which
  modifies the entire regexp) only affect the regexp inside the group the
  embedded modifier is contained in. So grouping can be used to localize the
  modifier's effects:
<div class="Pp"></div>
<pre>
    /Answer: ((?i)yes)/;  # matches 'Answer: yes', 'Answer: YES', etc.
</pre>
<div class="Pp"></div>
Embedded modifiers can also turn off any modifiers already present by using,
  e.g., &quot;(?-i)&quot;. Modifiers can also be combined into a single
  expression, e.g., &quot;(?s-i)&quot; turns on single line mode and turns off
  case insensitivity.
<div class="Pp"></div>
Embedded modifiers may also be added to a non-capturing grouping.
  &quot;(?i-m:regexp)&quot; is a non-capturing grouping that matches
  &quot;regexp&quot; case insensitively and turns off multi-line mode.
<h2 class="Ss" title="Ss" id="Looking_ahead_and_looking_behind"><a class="selflink" href="#Looking_ahead_and_looking_behind">Looking
  ahead and looking behind</a></h2>
This section concerns the lookahead and lookbehind assertions. First, a little
  background.
<div class="Pp"></div>
In Perl regular expressions, most regexp elements 'eat up' a certain amount of
  string when they match. For instance, the regexp element &quot;[abc}]&quot;
  eats up one character of the string when it matches, in the sense that Perl
  moves to the next character position in the string after the match. There are
  some elements, however, that don't eat up characters (advance the character
  position) if they match. The examples we have seen so far are the anchors. The
  anchor &quot;^&quot; matches the beginning of the line, but doesn't eat any
  characters. Similarly, the word boundary anchor &quot;\b&quot; matches
  wherever a character matching &quot;\w&quot; is next to a character that
  doesn't, but it doesn't eat up any characters itself. Anchors are examples of
  <i>zero-width assertions</i>: zero-width, because they consume no characters,
  and assertions, because they test some property of the string. In the context
  of our walk in the woods analogy to regexp matching, most regexp elements move
  us along a trail, but anchors have us stop a moment and check our
  surroundings. If the local environment checks out, we can proceed forward. But
  if the local environment doesn't satisfy us, we must backtrack.
<div class="Pp"></div>
Checking the environment entails either looking ahead on the trail, looking
  behind, or both. &quot;^&quot; looks behind, to see that there are no
  characters before. &quot;$&quot; looks ahead, to see that there are no
  characters after. &quot;\b&quot; looks both ahead and behind, to see if the
  characters on either side differ in their &quot;word-ness&quot;.
<div class="Pp"></div>
The lookahead and lookbehind assertions are generalizations of the anchor
  concept. Lookahead and lookbehind are zero-width assertions that let us
  specify which characters we want to test for. The lookahead assertion is
  denoted by &quot;(?=regexp)&quot; and the lookbehind assertion is denoted by
  &quot;(?&lt;=fixed-regexp)&quot;. Some examples are
<div class="Pp"></div>
<pre>
    $x = &quot;I catch the housecat 'Tom-cat' with catnip&quot;;
    $x =~ /cat(?=\s)/;   # matches 'cat' in 'housecat'
    @catwords = ($x =~ /(?&lt;=\s)cat\w+/g);  # matches,
                                           # $catwords[0] = 'catch'
                                           # $catwords[1] = 'catnip'
    $x =~ /\bcat\b/;  # matches 'cat' in 'Tom-cat'
    $x =~ /(?&lt;=\s)cat(?=\s)/; # doesn't match; no isolated 'cat' in
                              # middle of $x
</pre>
<div class="Pp"></div>
Note that the parentheses in &quot;(?=regexp)&quot; and
  &quot;(?&lt;=regexp)&quot; are non-capturing, since these are zero-width
  assertions. Thus in the second regexp, the substrings captured are those of
  the whole regexp itself. Lookahead &quot;(?=regexp)&quot; can match arbitrary
  regexps, but lookbehind &quot;(?&lt;=fixed-regexp)&quot; only works for
  regexps of fixed width, i.e., a fixed number of characters long. Thus
  &quot;(?&lt;=(ab|bc))&quot; is fine, but &quot;(?&lt;=(ab)*)&quot; is not. The
  negated versions of the lookahead and lookbehind assertions are denoted by
  &quot;(?!regexp)&quot; and &quot;(?&lt;!fixed-regexp)&quot; respectively. They
  evaluate true if the regexps do <i>not</i> match:
<div class="Pp"></div>
<pre>
    $x = &quot;foobar&quot;;
    $x =~ /foo(?!bar)/;  # doesn't match, 'bar' follows 'foo'
    $x =~ /foo(?!baz)/;  # matches, 'baz' doesn't follow 'foo'
    $x =~ /(?&lt;!\s)foo/;  # matches, there is no \s before 'foo'
</pre>
<div class="Pp"></div>
The &quot;\C&quot; is unsupported in lookbehind, because the already treacherous
  definition of &quot;\C&quot; would become even more so when going backwards.
<div class="Pp"></div>
Here is an example where a string containing blank-separated words, numbers and
  single dashes is to be split into its components. Using &quot;/\s+/&quot;
  alone won't work, because spaces are not required between dashes, or a word or
  a dash. Additional places for a split are established by looking ahead and
  behind:
<div class="Pp"></div>
<pre>
    $str = &quot;one two - --6-8&quot;;
    @toks = split / \s+              # a run of spaces
                  | (?&lt;=\S) (?=-)    # any non-space followed by '-'
                  | (?&lt;=-)  (?=\S)   # a '-' followed by any non-space
                  /x, $str;          # @toks = qw(one two - - - 6 - 8)
</pre>
<h2 class="Ss" title="Ss" id="Using_independent_subexpressions_to_prevent_backtracking"><a class="selflink" href="#Using_independent_subexpressions_to_prevent_backtracking">Using
  independent subexpressions to prevent backtracking</a></h2>
<i>Independent subexpressions</i> are regular expressions, in the context of a
  larger regular expression, that function independently of the larger regular
  expression. That is, they consume as much or as little of the string as they
  wish without regard for the ability of the larger regexp to match. Independent
  subexpressions are represented by &quot;(?&gt;regexp)&quot;. We can illustrate
  their behavior by first considering an ordinary regexp:
<div class="Pp"></div>
<pre>
    $x = &quot;ab&quot;;
    $x =~ /a*ab/;  # matches
</pre>
<div class="Pp"></div>
This obviously matches, but in the process of matching, the subexpression
  &quot;a*&quot; first grabbed the &quot;a&quot;. Doing so, however, wouldn't
  allow the whole regexp to match, so after backtracking, &quot;a*&quot;
  eventually gave back the &quot;a&quot; and matched the empty string. Here,
  what &quot;a*&quot; matched was <i>dependent</i> on what the rest of the
  regexp matched.
<div class="Pp"></div>
Contrast that with an independent subexpression:
<div class="Pp"></div>
<pre>
    $x =~ /(?&gt;a*)ab/;  # doesn't match!
</pre>
<div class="Pp"></div>
The independent subexpression &quot;(?&gt;a*)&quot; doesn't care about the rest
  of the regexp, so it sees an &quot;a&quot; and grabs it. Then the rest of the
  regexp &quot;ab&quot; cannot match. Because &quot;(?&gt;a*)&quot; is
  independent, there is no backtracking and the independent subexpression does
  not give up its &quot;a&quot;. Thus the match of the regexp as a whole fails.
  A similar behavior occurs with completely independent regexps:
<div class="Pp"></div>
<pre>
    $x = &quot;ab&quot;;
    $x =~ /a*/g;   # matches, eats an 'a'
    $x =~ /\Gab/g; # doesn't match, no 'a' available
</pre>
<div class="Pp"></div>
Here &quot;//g&quot; and &quot;\G&quot; create a 'tag team' handoff of the
  string from one regexp to the other. Regexps with an independent subexpression
  are much like this, with a handoff of the string to the independent
  subexpression, and a handoff of the string back to the enclosing regexp.
<div class="Pp"></div>
The ability of an independent subexpression to prevent backtracking can be quite
  useful. Suppose we want to match a non-empty string enclosed in parentheses up
  to two levels deep. Then the following regexp matches:
<div class="Pp"></div>
<pre>
    $x = &quot;abc(de(fg)h&quot;;  # unbalanced parentheses
    $x =~ /\( ( [^()]+ | \([^()]*\) )+ \)/x;
</pre>
<div class="Pp"></div>
The regexp matches an open parenthesis, one or more copies of an alternation,
  and a close parenthesis. The alternation is two-way, with the first
  alternative &quot;[^()]+&quot; matching a substring with no parentheses and
  the second alternative &quot;\([^()]*\)&quot; matching a substring delimited
  by parentheses. The problem with this regexp is that it is pathological: it
  has nested indeterminate quantifiers of the form &quot;(a+|b)+&quot;. We
  discussed in Part 1 how nested quantifiers like this could take an
  exponentially long time to execute if there was no match possible. To prevent
  the exponential blowup, we need to prevent useless backtracking at some point.
  This can be done by enclosing the inner quantifier as an independent
  subexpression:
<div class="Pp"></div>
<pre>
    $x =~ /\( ( (?&gt;[^()]+) | \([^()]*\) )+ \)/x;
</pre>
<div class="Pp"></div>
Here, &quot;(?&gt;[^()]+)&quot; breaks the degeneracy of string partitioning by
  gobbling up as much of the string as possible and keeping it. Then match
  failures fail much more quickly.
<h2 class="Ss" title="Ss" id="Conditional_expressions"><a class="selflink" href="#Conditional_expressions">Conditional
  expressions</a></h2>
A <i>conditional expression</i> is a form of if-then-else statement that allows
  one to choose which patterns are to be matched, based on some condition. There
  are two types of conditional expression: &quot;(?(condition)yes-regexp)&quot;
  and &quot;(?(condition)yes-regexp|no-regexp)&quot;.
  &quot;(?(condition)yes-regexp)&quot; is like an 'if&#x00A0;()&#x00A0;{}'
  statement in Perl. If the &quot;condition&quot; is true, the
  &quot;yes-regexp&quot; will be matched. If the &quot;condition&quot; is false,
  the &quot;yes-regexp&quot; will be skipped and Perl will move onto the next
  regexp element. The second form is like an
  'if&#x00A0;()&#x00A0;{}&#x00A0;else&#x00A0;{}' statement in Perl. If the
  &quot;condition&quot; is true, the &quot;yes-regexp&quot; will be matched,
  otherwise the &quot;no-regexp&quot; will be matched.
<div class="Pp"></div>
The &quot;condition&quot; can have several forms. The first form is simply an
  integer in parentheses &quot;(integer)&quot;. It is true if the corresponding
  backreference &quot;\integer&quot; matched earlier in the regexp. The same
  thing can be done with a name associated with a capture group, written as
  &quot;(&lt;name&gt;)&quot; or &quot;('name')&quot;. The second form is a bare
  zero-width assertion &quot;(?...)&quot;, either a lookahead, a lookbehind, or
  a code assertion (discussed in the next section). The third set of forms
  provides tests that return true if the expression is executed within a
  recursion (&quot;(R)&quot;) or is being called from some capturing group,
  referenced either by number (&quot;(R1)&quot;, &quot;(R2)&quot;,...) or by
  name (&quot;(R&amp;name)&quot;).
<div class="Pp"></div>
The integer or name form of the &quot;condition&quot; allows us to choose, with
  more flexibility, what to match based on what matched earlier in the regexp.
  This searches for words of the form &quot;$x$x&quot; or &quot;$x$y$y$x&quot;:
<div class="Pp"></div>
<pre>
    % simple_grep '^(\w+)(\w+)?(?(2)\g2\g1|\g1)$' /usr/dict/words
    beriberi
    coco
    couscous
    deed
    ...
    toot
    toto
    tutu
</pre>
<div class="Pp"></div>
The lookbehind &quot;condition&quot; allows, along with backreferences, an
  earlier part of the match to influence a later part of the match. For
  instance,
<div class="Pp"></div>
<pre>
    /[ATGC]+(?(?&lt;=AA)G|C)$/;
</pre>
<div class="Pp"></div>
matches a DNA sequence such that it either ends in &quot;AAG&quot;, or some
  other base pair combination and &quot;C&quot;. Note that the form is
  &quot;(?(?&lt;=AA)G|C)&quot; and not &quot;(?((?&lt;=AA))G|C)&quot;; for the
  lookahead, lookbehind or code assertions, the parentheses around the
  conditional are not needed.
<h2 class="Ss" title="Ss" id="Defining_named_patterns"><a class="selflink" href="#Defining_named_patterns">Defining
  named patterns</a></h2>
Some regular expressions use identical subpatterns in several places. Starting
  with Perl 5.10, it is possible to define named subpatterns in a section of the
  pattern so that they can be called up by name anywhere in the pattern. This
  syntactic pattern for this definition group is
  &quot;(?(DEFINE)(?&lt;name&gt;pattern)...)&quot;. An insertion of a named
  pattern is written as &quot;(?&amp;name)&quot;.
<div class="Pp"></div>
The example below illustrates this feature using the pattern for floating point
  numbers that was presented earlier on. The three subpatterns that are used
  more than once are the optional sign, the digit sequence for an integer and
  the decimal fraction. The DEFINE group at the end of the pattern contains
  their definition. Notice that the decimal fraction pattern is the first place
  where we can reuse the integer pattern.
<div class="Pp"></div>
<pre>
   /^ (?&amp;osg)\ * ( (?&amp;int)(?&amp;dec)? | (?&amp;dec) )
      (?: [eE](?&amp;osg)(?&amp;int) )?
    $
    (?(DEFINE)
      (?&lt;osg&gt;[-+]?)         # optional sign
      (?&lt;int&gt;\d++)          # integer
      (?&lt;dec&gt;\.(?&amp;int))     # decimal fraction
    )/x
</pre>
<h2 class="Ss" title="Ss" id="Recursive_patterns"><a class="selflink" href="#Recursive_patterns">Recursive
  patterns</a></h2>
This feature (introduced in Perl 5.10) significantly extends the power of Perl's
  pattern matching. By referring to some other capture group anywhere in the
  pattern with the construct &quot;(?group-ref)&quot;, the <i>pattern</i> within
  the referenced group is used as an independent subpattern in place of the
  group reference itself. Because the group reference may be contained
  <i>within</i> the group it refers to, it is now possible to apply pattern
  matching to tasks that hitherto required a recursive parser.
<div class="Pp"></div>
To illustrate this feature, we'll design a pattern that matches if a string
  contains a palindrome. (This is a word or a sentence that, while ignoring
  spaces, interpunctuation and case, reads the same backwards as forwards. We
  begin by observing that the empty string or a string containing just one word
  character is a palindrome. Otherwise it must have a word character up front
  and the same at its end, with another palindrome in between.
<div class="Pp"></div>
<pre>
    /(?: (\w) (?...Here be a palindrome...) \g{-1} | \w? )/x
</pre>
<div class="Pp"></div>
Adding &quot;\W*&quot; at either end to eliminate what is to be ignored, we
  already have the full pattern:
<div class="Pp"></div>
<pre>
    my $pp = qr/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix;
    for $s ( &quot;saippuakauppias&quot;, &quot;A man, a plan, a canal: Panama!&quot; ){
        print &quot;'$s' is a palindrome\n&quot; if $s =~ /$pp/;
    }
</pre>
<div class="Pp"></div>
In &quot;(?...)&quot; both absolute and relative backreferences may be used. The
  entire pattern can be reinserted with &quot;(?R)&quot; or &quot;(?0)&quot;. If
  you prefer to name your groups, you can use &quot;(?&amp;name)&quot; to
  recurse into that group.
<h2 class="Ss" title="Ss" id="A_bit_of_magic:_executing_Perl_code_in_a_regular_expression"><a class="selflink" href="#A_bit_of_magic:_executing_Perl_code_in_a_regular_expression">A
  bit of magic: executing Perl code in a regular expression</a></h2>
Normally, regexps are a part of Perl expressions. <i>Code evaluation</i>
  expressions turn that around by allowing arbitrary Perl code to be a part of a
  regexp. A code evaluation expression is denoted &quot;(?{code})&quot;, with
  <i>code</i> a string of Perl statements.
<div class="Pp"></div>
Be warned that this feature is considered experimental, and may be changed
  without notice.
<div class="Pp"></div>
Code expressions are zero-width assertions, and the value they return depends on
  their environment. There are two possibilities: either the code expression is
  used as a conditional in a conditional expression
  &quot;(?(condition)...)&quot;, or it is not. If the code expression is a
  conditional, the code is evaluated and the result (i.e., the result of the
  last statement) is used to determine truth or falsehood. If the code
  expression is not used as a conditional, the assertion always evaluates true
  and the result is put into the special variable $^R. The variable $^R can then
  be used in code expressions later in the regexp. Here are some silly examples:
<div class="Pp"></div>
<pre>
    $x = &quot;abcdef&quot;;
    $x =~ /abc(?{print &quot;Hi Mom!&quot;;})def/; # matches,
                                         # prints 'Hi Mom!'
    $x =~ /aaa(?{print &quot;Hi Mom!&quot;;})def/; # doesn't match,
                                         # no 'Hi Mom!'
</pre>
<div class="Pp"></div>
Pay careful attention to the next example:
<div class="Pp"></div>
<pre>
    $x =~ /abc(?{print &quot;Hi Mom!&quot;;})ddd/; # doesn't match,
                                         # no 'Hi Mom!'
                                         # but why not?
</pre>
<div class="Pp"></div>
At first glance, you'd think that it shouldn't print, because obviously the
  &quot;ddd&quot; isn't going to match the target string. But look at this
  example:
<div class="Pp"></div>
<pre>
    $x =~ /abc(?{print &quot;Hi Mom!&quot;;})[dD]dd/; # doesn't match,
                                            # but _does_ print
</pre>
<div class="Pp"></div>
Hmm. What happened here? If you've been following along, you know that the above
  pattern should be effectively (almost) the same as the last one; enclosing the
  &quot;d&quot; in a character class isn't going to change what it matches. So
  why does the first not print while the second one does?
<div class="Pp"></div>
The answer lies in the optimizations the regex engine makes. In the first case,
  all the engine sees are plain old characters (aside from the &quot;?{}&quot;
  construct). It's smart enough to realize that the string 'ddd' doesn't occur
  in our target string before actually running the pattern through. But in the
  second case, we've tricked it into thinking that our pattern is more
  complicated. It takes a look, sees our character class, and decides that it
  will have to actually run the pattern to determine whether or not it matches,
  and in the process of running it hits the print statement before it discovers
  that we don't have a match.
<div class="Pp"></div>
To take a closer look at how the engine does optimizations, see the section
  &quot;Pragmas and debugging&quot; below.
<div class="Pp"></div>
More fun with &quot;?{}&quot;:
<div class="Pp"></div>
<pre>
    $x =~ /(?{print &quot;Hi Mom!&quot;;})/;       # matches,
                                         # prints 'Hi Mom!'
    $x =~ /(?{$c = 1;})(?{print &quot;$c&quot;;})/;  # matches,
                                           # prints '1'
    $x =~ /(?{$c = 1;})(?{print &quot;$^R&quot;;})/; # matches,
                                           # prints '1'
</pre>
<div class="Pp"></div>
The bit of magic mentioned in the section title occurs when the regexp
  backtracks in the process of searching for a match. If the regexp backtracks
  over a code expression and if the variables used within are localized using
  &quot;local&quot;, the changes in the variables produced by the code
  expression are undone! Thus, if we wanted to count how many times a character
  got matched inside a group, we could use, e.g.,
<div class="Pp"></div>
<pre>
    $x = &quot;aaaa&quot;;
    $count = 0;  # initialize 'a' count
    $c = &quot;bob&quot;;  # test if $c gets clobbered
    $x =~ /(?{local $c = 0;})         # initialize count
           ( a                        # match 'a'
             (?{local $c = $c + 1;})  # increment count
           )*                         # do this any number of times,
           aa                         # but match 'aa' at the end
           (?{$count = $c;})          # copy local $c var into $count
          /x;
    print &quot;'a' count is $count, \$c variable is '$c'\n&quot;;
</pre>
<div class="Pp"></div>
This prints
<div class="Pp"></div>
<pre>
    'a' count is 2, $c variable is 'bob'
</pre>
<div class="Pp"></div>
If we replace the
  &quot;&#x00A0;(?{local&#x00A0;$c&#x00A0;=&#x00A0;$c&#x00A0;+&#x00A0;1;})&quot;
  with &quot;&#x00A0;(?{$c&#x00A0;=&#x00A0;$c&#x00A0;+&#x00A0;1;})&quot;, the
  variable changes are <i>not</i> undone during backtracking, and we get
<div class="Pp"></div>
<pre>
    'a' count is 4, $c variable is 'bob'
</pre>
<div class="Pp"></div>
Note that only localized variable changes are undone. Other side effects of code
  expression execution are permanent. Thus
<div class="Pp"></div>
<pre>
    $x = &quot;aaaa&quot;;
    $x =~ /(a(?{print &quot;Yow\n&quot;;}))*aa/;
</pre>
<div class="Pp"></div>
produces
<div class="Pp"></div>
<pre>
   Yow
   Yow
   Yow
   Yow
</pre>
<div class="Pp"></div>
The result $^R is automatically localized, so that it will behave properly in
  the presence of backtracking.
<div class="Pp"></div>
This example uses a code expression in a conditional to match a definite
  article, either 'the' in English or 'der|die|das' in German:
<div class="Pp"></div>
<pre>
    $lang = 'DE';  # use German
    ...
    $text = &quot;das&quot;;
    print &quot;matched\n&quot;
        if $text =~ /(?(?{
                          $lang eq 'EN'; # is the language English?
                         })
                       the |             # if so, then match 'the'
                       (der|die|das)     # else, match 'der|die|das'
                     )
                    /xi;
</pre>
<div class="Pp"></div>
Note that the syntax here is &quot;(?(?{...})yes-regexp|no-regexp)&quot;, not
  &quot;(?((?{...}))yes-regexp|no-regexp)&quot;. In other words, in the case of
  a code expression, we don't need the extra parentheses around the conditional.
<div class="Pp"></div>
If you try to use code expressions with interpolating variables, Perl may
  surprise you:
<div class="Pp"></div>
<pre>
    $bar = 5;
    $pat = '(?{ 1 })';
    /foo(?{ $bar })bar/; # compiles ok, $bar not interpolated
    /foo(?{ 1 })$bar/;   # compile error!
    /foo${pat}bar/;      # compile error!
    $pat = qr/(?{ $foo = 1 })/;  # precompile code regexp
    /foo${pat}bar/;      # compiles ok
</pre>
<div class="Pp"></div>
If a regexp has (1) code expressions and interpolating variables, or (2) a
  variable that interpolates a code expression, Perl treats the regexp as an
  error. If the code expression is precompiled into a variable, however,
  interpolating is ok. The question is, why is this an error?
<div class="Pp"></div>
The reason is that variable interpolation and code expressions together pose a
  security risk. The combination is dangerous because many programmers who write
  search engines often take user input and plug it directly into a regexp:
<div class="Pp"></div>
<pre>
    $regexp = &lt;&gt;;       # read user-supplied regexp
    $chomp $regexp;     # get rid of possible newline
    $text =~ /$regexp/; # search $text for the $regexp
</pre>
<div class="Pp"></div>
If the $regexp variable contains a code expression, the user could then execute
  arbitrary Perl code. For instance, some joker could search for
  &quot;system('rm&#x00A0;-rf&#x00A0;*');&quot; to erase your files. In this
  sense, the combination of interpolation and code expressions <i>taints</i>
  your regexp. So by default, using both interpolation and code expressions in
  the same regexp is not allowed. If you're not concerned about malicious users,
  it is possible to bypass this security check by invoking
  &quot;use&#x00A0;re&#x00A0;'eval'&quot;:
<div class="Pp"></div>
<pre>
    use re 'eval';       # throw caution out the door
    $bar = 5;
    $pat = '(?{ 1 })';
    /foo(?{ 1 })$bar/;   # compiles ok
    /foo${pat}bar/;      # compiles ok
</pre>
<div class="Pp"></div>
Another form of code expression is the <i>pattern code expression</i>. The
  pattern code expression is like a regular code expression, except that the
  result of the code evaluation is treated as a regular expression and matched
  immediately. A simple example is
<div class="Pp"></div>
<pre>
    $length = 5;
    $char = 'a';
    $x = 'aaaaabb';
    $x =~ /(??{$char x $length})/x; # matches, there are 5 of 'a'
</pre>
<div class="Pp"></div>
This final example contains both ordinary and pattern code expressions. It
  detects whether a binary string 1101010010001... has a Fibonacci spacing
  0,1,1,2,3,5,... of the 1's:
<div class="Pp"></div>
<pre>
    $x = &quot;1101010010001000001&quot;;
    $z0 = ''; $z1 = '0';   # initial conditions
    print &quot;It is a Fibonacci sequence\n&quot;
        if $x =~ /^1         # match an initial '1'
                    (?:
                       ((??{ $z0 })) # match some '0'
                       1             # and then a '1'
                       (?{ $z0 = $z1; $z1 .= $^N; })
                    )+   # repeat as needed
                  $      # that is all there is
                 /x;
    printf &quot;Largest sequence matched was %d\n&quot;, length($z1)-length($z0);
</pre>
<div class="Pp"></div>
Remember that $^N is set to whatever was matched by the last completed capture
  group. This prints
<div class="Pp"></div>
<pre>
    It is a Fibonacci sequence
    Largest sequence matched was 5
</pre>
<div class="Pp"></div>
Ha! Try that with your garden variety regexp package...
<div class="Pp"></div>
Note that the variables $z0 and $z1 are not substituted when the regexp is
  compiled, as happens for ordinary variables outside a code expression. Rather,
  the code expressions are evaluated when Perl encounters them during the search
  for a match.
<div class="Pp"></div>
The regexp without the &quot;//x&quot; modifier is
<div class="Pp"></div>
<pre>
    /^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/
</pre>
<div class="Pp"></div>
which shows that spaces are still possible in the code parts. Nevertheless, when
  working with code and conditional expressions, the extended form of regexps is
  almost necessary in creating and debugging regexps.
<h2 class="Ss" title="Ss" id="Backtracking_control_verbs"><a class="selflink" href="#Backtracking_control_verbs">Backtracking
  control verbs</a></h2>
Perl 5.10 introduced a number of control verbs intended to provide detailed
  control over the backtracking process, by directly influencing the regexp
  engine and by providing monitoring techniques. As all the features in this
  group are experimental and subject to change or removal in a future version of
  Perl, the interested reader is referred to &quot;Special Backtracking Control
  Verbs&quot; in perlre for a detailed description.
<div class="Pp"></div>
Below is just one example, illustrating the control verb &quot;(*FAIL)&quot;,
  which may be abbreviated as &quot;(*F)&quot;. If this is inserted in a regexp
  it will cause it to fail, just as it would at some mismatch between the
  pattern and the string. Processing of the regexp continues as it would after
  any &quot;normal&quot; failure, so that, for instance, the next position in
  the string or another alternative will be tried. As failing to match doesn't
  preserve capture groups or produce results, it may be necessary to use this in
  combination with embedded code.
<div class="Pp"></div>
<pre>
   %count = ();
   &quot;supercalifragilisticexpialidocious&quot; =~
       /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
   printf &quot;%3d '%s'\n&quot;, $count{$_}, $_ for (sort keys %count);
</pre>
<div class="Pp"></div>
The pattern begins with a class matching a subset of letters. Whenever this
  matches, a statement like &quot;$count{'a'}++;&quot; is executed, incrementing
  the letter's counter. Then &quot;(*FAIL)&quot; does what it says, and the
  regexp engine proceeds according to the book: as long as the end of the string
  hasn't been reached, the position is advanced before looking for another
  vowel. Thus, match or no match makes no difference, and the regexp engine
  proceeds until the entire string has been inspected. (It's remarkable that an
  alternative solution using something like
<div class="Pp"></div>
<pre>
   $count{lc($_)}++ for split('', &quot;supercalifragilisticexpialidocious&quot;);
   printf &quot;%3d '%s'\n&quot;, $count2{$_}, $_ for ( qw{ a e i o u } );
</pre>
<div class="Pp"></div>
is considerably slower.)
<h2 class="Ss" title="Ss" id="Pragmas_and_debugging"><a class="selflink" href="#Pragmas_and_debugging">Pragmas
  and debugging</a></h2>
Speaking of debugging, there are several pragmas available to control and debug
  regexps in Perl. We have already encountered one pragma in the previous
  section, &quot;use&#x00A0;re&#x00A0;'eval';&quot;, that allows variable
  interpolation and code expressions to coexist in a regexp. The other pragmas
  are
<div class="Pp"></div>
<pre>
    use re 'taint';
    $tainted = &lt;&gt;;
    @parts = ($tainted =~ /(\w+)\s+(\w+)/; # @parts is now tainted
</pre>
<div class="Pp"></div>
The &quot;taint&quot; pragma causes any substrings from a match with a tainted
  variable to be tainted as well. This is not normally the case, as regexps are
  often used to extract the safe bits from a tainted variable. Use
  &quot;taint&quot; when you are not extracting safe bits, but are performing
  some other processing. Both &quot;taint&quot; and &quot;eval&quot; pragmas are
  lexically scoped, which means they are in effect only until the end of the
  block enclosing the pragmas.
<div class="Pp"></div>
<pre>
    use re '/m';  # or any other flags
    $multiline_string =~ /^foo/; # /m is implied
</pre>
<div class="Pp"></div>
The &quot;re '/flags'&quot; pragma (introduced in Perl 5.14) turns on the given
  regular expression flags until the end of the lexical scope. See
  &quot;'/flags' mode&quot; in re for more detail.
<div class="Pp"></div>
<pre>
    use re 'debug';
    /^(.*)$/s;       # output debugging info
    use re 'debugcolor';
    /^(.*)$/s;       # output debugging info in living color
</pre>
<div class="Pp"></div>
The global &quot;debug&quot; and &quot;debugcolor&quot; pragmas allow one to get
  detailed debugging info about regexp compilation and execution.
  &quot;debugcolor&quot; is the same as debug, except the debugging information
  is displayed in color on terminals that can display termcap color sequences.
  Here is example output:
<div class="Pp"></div>
<pre>
    % perl -e 'use re &quot;debug&quot;; &quot;abc&quot; =~ /a*b+c/;'
    Compiling REx 'a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT &lt;a&gt;(0)
       4: PLUS(7)
       5:   EXACT &lt;b&gt;(0)
       7: EXACT &lt;c&gt;(9)
       9: END(0)
    floating 'bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx 'a*b+c' against 'abc'...
    Found floating substr 'bc' at offset 1...
    Guessed: match at offset 0
    Matching REx 'a*b+c' against 'abc'
      Setting an EVAL scope, savestack=3
       0 &lt;&gt; &lt;abc&gt;             |  1:  STAR
                               EXACT &lt;a&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 &lt;a&gt; &lt;bc&gt;             |  4:    PLUS
                               EXACT &lt;b&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 &lt;ab&gt; &lt;c&gt;             |  7:      EXACT &lt;c&gt;
       3 &lt;abc&gt; &lt;&gt;             |  9:      END
    Match successful!
    Freeing REx: 'a*b+c'
</pre>
<div class="Pp"></div>
If you have gotten this far into the tutorial, you can probably guess what the
  different parts of the debugging output tell you. The first part
<div class="Pp"></div>
<pre>
    Compiling REx 'a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT &lt;a&gt;(0)
       4: PLUS(7)
       5:   EXACT &lt;b&gt;(0)
       7: EXACT &lt;c&gt;(9)
       9: END(0)
</pre>
<div class="Pp"></div>
describes the compilation stage. STAR(4) means that there is a starred object,
  in this case 'a', and if it matches, goto line 4, i.e., PLUS(7). The middle
  lines describe some heuristics and optimizations performed before a match:
<div class="Pp"></div>
<pre>
    floating 'bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx 'a*b+c' against 'abc'...
    Found floating substr 'bc' at offset 1...
    Guessed: match at offset 0
</pre>
<div class="Pp"></div>
Then the match is executed and the remaining lines describe the process:
<div class="Pp"></div>
<pre>
    Matching REx 'a*b+c' against 'abc'
      Setting an EVAL scope, savestack=3
       0 &lt;&gt; &lt;abc&gt;             |  1:  STAR
                               EXACT &lt;a&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 &lt;a&gt; &lt;bc&gt;             |  4:    PLUS
                               EXACT &lt;b&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 &lt;ab&gt; &lt;c&gt;             |  7:      EXACT &lt;c&gt;
       3 &lt;abc&gt; &lt;&gt;             |  9:      END
    Match successful!
    Freeing REx: 'a*b+c'
</pre>
<div class="Pp"></div>
Each step is of the form &quot;n&#x00A0;&lt;x&gt;&#x00A0;&lt;y&gt;&quot;, with
  &quot;&lt;x&gt;&quot; the part of the string matched and &quot;&lt;y&gt;&quot;
  the part not yet matched. The
  &quot;|&#x00A0;&#x00A0;1:&#x00A0;&#x00A0;STAR&quot; says that Perl is at line
  number 1 in the compilation list above. See &quot;Debugging Regular
  Expressions&quot; in perldebguts for much more detail.
<div class="Pp"></div>
An alternative method of debugging regexps is to embed &quot;print&quot;
  statements within the regexp. This provides a blow-by-blow account of the
  backtracking in an alternation:
<div class="Pp"></div>
<pre>
    &quot;that this&quot; =~ m@(?{print &quot;Start at position &quot;, pos, &quot;\n&quot;;})
                     t(?{print &quot;t1\n&quot;;})
                     h(?{print &quot;h1\n&quot;;})
                     i(?{print &quot;i1\n&quot;;})
                     s(?{print &quot;s1\n&quot;;})
                         |
                     t(?{print &quot;t2\n&quot;;})
                     h(?{print &quot;h2\n&quot;;})
                     a(?{print &quot;a2\n&quot;;})
                     t(?{print &quot;t2\n&quot;;})
                     (?{print &quot;Done at position &quot;, pos, &quot;\n&quot;;})
                    @x;
</pre>
<div class="Pp"></div>
prints
<div class="Pp"></div>
<pre>
    Start at position 0
    t1
    h1
    t2
    h2
    a2
    t2
    Done at position 4
</pre>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
Code expressions, conditional expressions, and independent expressions are
  <i>experimental</i>. Don't use them in production code. Yet.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
This is just a tutorial. For the full story on Perl regular expressions, see the
  perlre regular expressions reference page.
<div class="Pp"></div>
For more information on the matching &quot;m//&quot; and substitution
  &quot;s///&quot; operators, see &quot;Regexp Quote-Like Operators&quot; in
  perlop. For information on the &quot;split&quot; operation, see
  &quot;split&quot; in perlfunc.
<div class="Pp"></div>
For an excellent all-around resource on the care and feeding of regular
  expressions, see the book <i>Mastering Regular Expressions</i> by Jeffrey
  Friedl (published by O'Reilly, ISBN 1556592-257-3).
<h1 class="Sh" title="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="selflink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
Copyright (c) 2000 Mark Kvale All rights reserved.
<div class="Pp"></div>
This document may be distributed under the same terms as Perl itself.
<h2 class="Ss" title="Ss" id="Acknowledgments"><a class="selflink" href="#Acknowledgments">Acknowledgments</a></h2>
The inspiration for the stop codon DNA example came from the ZIP code example in
  chapter 7 of <i>Mastering Regular Expressions</i>.
<div class="Pp"></div>
The author would like to thank Jeff Pinyan, Andrew Johnson, Peter Haworth,
  Ronald J Kimball, and Joe Smith for all their helpful comments.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
