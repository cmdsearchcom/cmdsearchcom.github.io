<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:05 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLRETUT(1) Perl Programmers Reference Guide
PERLRETUT(1)</p>

<p style="margin-top: 1em">NAME <br>
perlretut - Perl regular expressions tutorial</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This page provides a basic tutorial on understanding,
creating and using regular expressions in Perl. It serves as
a complement to the reference page on regular expressions
<br>
perlre. Regular expressions are an integral part of the
&quot;m//&quot;, &quot;s///&quot;, &quot;qr//&quot; and
&quot;split&quot; operators and so this tutorial also
overlaps with &quot;Regexp Quote-Like Operators&quot; in
<br>
perlop and &quot;split&quot; in perlfunc.</p>

<p style="margin-top: 1em">Perl is widely renowned for
excellence in text processing, and regular expressions are
one of the big factors behind this fame. Perl regular
expressions display an efficiency <br>
and flexibility unknown in most other computer languages.
Mastering even the basics of regular expressions will allow
you to manipulate text with surprising ease.</p>

<p style="margin-top: 1em">What is a regular expression? A
regular expression is simply a string that describes a
pattern. Patterns are in common use these days; examples are
the patterns typed into a <br>
search engine to find web pages and the patterns used to
list files in a directory, e.g., &quot;ls *.txt&quot; or
&quot;dir *.*&quot;. In Perl, the patterns described by
regular expressions are <br>
used to search strings, extract desired parts of strings,
and to do search and replace operations.</p>

<p style="margin-top: 1em">Regular expressions have the
undeserved reputation of being abstract and difficult to
understand. Regular expressions are constructed using simple
concepts like conditionals and <br>
loops and are no more difficult to understand than the
corresponding &quot;if&quot; conditionals and
&quot;while&quot; loops in the Perl language itself. In
fact, the main challenge in learning <br>
regular expressions is just getting used to the terse
notation used to express these concepts.</p>

<p style="margin-top: 1em">This tutorial flattens the
learning curve by discussing regular expression concepts,
along with their notation, one at a time and with many
examples. The first part of the <br>
tutorial will progress from the simplest word searches to
the basic regular expression concepts. If you master the
first part, you will have all the tools needed to solve
about <br>
98% of your needs. The second part of the tutorial is for
those comfortable with the basics and hungry for more power
tools. It discusses the more advanced regular expression
<br>
operators and introduces the latest cutting-edge
innovations.</p>

<p style="margin-top: 1em">A note: to save time,
&rsquo;regular expression&rsquo; is often abbreviated as
regexp or regex. Regexp is a more natural abbreviation than
regex, but is harder to pronounce. The Perl pod <br>
documentation is evenly split on regexp vs regex; in Perl,
there is more than one way to abbreviate it. We&rsquo;ll use
regexp in this tutorial.</p>

<p style="margin-top: 1em">Part 1: The basics <br>
Simple word matching <br>
The simplest regexp is simply a word, or more generally, a
string of characters. A regexp consisting of a word matches
any string that contains that word:</p>

<p style="margin-top: 1em">&quot;Hello World&quot; =~
/World/; # matches</p>

<p style="margin-top: 1em">What is this Perl statement all
about? &quot;Hello World&quot; is a simple double-quoted
string. &quot;World&quot; is the regular expression and the
&quot;//&quot; enclosing &quot;/World/&quot; tells Perl to
search a <br>
string for a match. The operator &quot;=~&quot; associates
the string with the regexp match and produces a true value
if the regexp matched, or false if the regexp did not match.
In our <br>
case, &quot;World&quot; matches the second word in
&quot;Hello World&quot;, so the expression is true.
Expressions like this are useful in conditionals:</p>

<p style="margin-top: 1em">if (&quot;Hello World&quot; =~
/World/) { <br>
print &quot;It matches0; <br>
} <br>
else { <br>
print &quot;It doesn&rsquo;t match0; <br>
}</p>

<p style="margin-top: 1em">There are useful variations on
this theme. The sense of the match can be reversed by using
the &quot;!~&quot; operator:</p>

<p style="margin-top: 1em">if (&quot;Hello World&quot; !~
/World/) { <br>
print &quot;It doesn&rsquo;t match0; <br>
} <br>
else { <br>
print &quot;It matches0; <br>
}</p>

<p style="margin-top: 1em">The literal string in the regexp
can be replaced by a variable:</p>

<p style="margin-top: 1em">$greeting = &quot;World&quot;;
<br>
if (&quot;Hello World&quot; =~ /$greeting/) { <br>
print &quot;It matches0; <br>
} <br>
else { <br>
print &quot;It doesn&rsquo;t match0; <br>
}</p>

<p style="margin-top: 1em">If you&rsquo;re matching against
the special default variable $_, the &quot;$_ =~&quot; part
can be omitted:</p>

<p style="margin-top: 1em">$_ = &quot;Hello World&quot;;
<br>
if (/World/) { <br>
print &quot;It matches0; <br>
} <br>
else { <br>
print &quot;It doesn&rsquo;t match0; <br>
}</p>

<p style="margin-top: 1em">And finally, the &quot;//&quot;
default delimiters for a match can be changed to arbitrary
delimiters by putting an &rsquo;m&rsquo; out front:</p>

<p style="margin-top: 1em">&quot;Hello World&quot; =~
m!World!; # matches, delimited by &rsquo;!&rsquo; <br>
&quot;Hello World&quot; =~ m{World}; # matches, note the
matching &rsquo;{}&rsquo; <br>
&quot;/usr/bin/perl&quot; =~ m&quot;/perl&quot;; # matches
after &rsquo;/usr/bin&rsquo;, <br>
# &rsquo;/&rsquo; becomes an ordinary char</p>

<p style="margin-top: 1em">&quot;/World/&quot;,
&quot;m!World!&quot;, and &quot;m{World}&quot; all represent
the same thing. When, e.g., the quote (&quot;&quot;&quot;)
is used as a delimiter, the forward slash &rsquo;/&rsquo;
becomes an ordinary character and <br>
can be used in this regexp without trouble.</p>

<p style="margin-top: 1em">Let&rsquo;s consider how
different regexps would match &quot;Hello World&quot;:</p>

<p style="margin-top: 1em">&quot;Hello World&quot; =~
/world/; # doesn&rsquo;t match <br>
&quot;Hello World&quot; =~ /o W/; # matches <br>
&quot;Hello World&quot; =~ /oW/; # doesn&rsquo;t match <br>
&quot;Hello World&quot; =~ /World /; # doesn&rsquo;t
match</p>

<p style="margin-top: 1em">The first regexp
&quot;world&quot; doesn&rsquo;t match because regexps are
case-sensitive. The second regexp matches because the
substring &rsquo;o W&rsquo; occurs in the string &quot;Hello
World&quot;. The space <br>
character &rsquo; &rsquo; is treated like any other
character in a regexp and is needed to match in this case.
The lack of a space character is the reason the third regexp
&rsquo;oW&rsquo; doesn&rsquo;t <br>
match. The fourth regexp &rsquo;World &rsquo; doesn&rsquo;t
match because there is a space at the end of the regexp, but
not at the end of the string. The lesson here is that
regexps must match <br>
a part of the string exactly in order for the statement to
be true.</p>

<p style="margin-top: 1em">If a regexp matches in more than
one place in the string, Perl will always match at the
earliest possible point in the string:</p>

<p style="margin-top: 1em">&quot;Hello World&quot; =~ /o/;
# matches &rsquo;o&rsquo; in &rsquo;Hello&rsquo; <br>
&quot;That hat is red&quot; =~ /hat/; # matches
&rsquo;hat&rsquo; in &rsquo;That&rsquo;</p>

<p style="margin-top: 1em">With respect to character
matching, there are a few more points you need to know
about. First of all, not all characters can be used
&rsquo;as is&rsquo; in a match. Some characters, <br>
called metacharacters, are reserved for use in regexp
notation. The metacharacters are</p>

<p style="margin-top: 1em">{}[]()^$.|*+? <br>
The significance of each of these will be explained in the
rest of the tutorial, but for now, it is important only to
know that a metacharacter can be matched by putting a <br>
backslash before it:</p>

<p style="margin-top: 1em">&quot;2+2=4&quot; =~ /2+2/; #
doesn&rsquo;t match, + is a metacharacter <br>
&quot;2+2=4&quot; =~ /2+2/; # matches, + is treated like an
ordinary + <br>
&quot;The interval is [0,1).&quot; =~ /[0,1)./ # is a syntax
error! <br>
&quot;The interval is [0,1).&quot; =~ /./ # matches <br>
&quot;#!/usr/bin/perl&quot; =~ /#!usrbinperl/; # matches</p>

<p style="margin-top: 1em">In the last regexp, the forward
slash &rsquo;/&rsquo; is also backslashed, because it is
used to delimit the regexp. This can lead to LTS (leaning
toothpick syndrome), however, and it is <br>
often more readable to change delimiters.</p>

<p style="margin-top: 1em">&quot;#!/usr/bin/perl&quot; =~
m!#/usr/bin/perl!; # easier to read</p>

<p style="margin-top: 1em">The backslash character
&rsquo;&acute; is a metacharacter itself and needs to be
backslashed:</p>

<p style="margin-top: 1em">&rsquo;C:WIN32&rsquo; =~
/C:\WIN/; # matches</p>

<p style="margin-top: 1em">In addition to the
metacharacters, there are some ASCII characters which
don&rsquo;t have printable character equivalents and are
instead represented by escape sequences. Common &quot; for a
<br>
examples are &quot;&quot; for a tab, &quot;0 for a newline,
&quot; carriage return and &quot;&quot; for a bell (or
alert). If your string is better thought of as a sequence of
arbitrary bytes, <br>
the octal escape sequence, e.g., &quot; 33&quot;, or
hexadecimal escape sequence, e.g., &quot;B&quot; may be a
more natural representation for your bytes. Here are some
examples of escapes:</p>

<p style="margin-top: 1em">&quot;10002000&quot; =~ m(02) #
matches <br>
&quot;10000000&quot; =~ /000/ # matches <br>
&quot;10002000&quot; =~ / 002/ # doesn&rsquo;t match,
&quot;0&quot; ne &quot; 00&quot; <br>
&quot;cat&quot; =~ /y <br>
# to spell cat</p>

<p style="margin-top: 1em">If you&rsquo;ve been around Perl
a while, all this talk of escape sequences may seem
familiar. Similar escape sequences are used in double-quoted
strings and in fact the regexps in <br>
Perl are mostly treated as double-quoted strings. This means
that variables can be used in regexps as well. Just like
double-quoted strings, the values of the variables in the
<br>
regexp will be substituted in before the regexp is evaluated
for matching purposes. So we have:</p>

<p style="margin-top: 1em">$foo = &rsquo;house&rsquo;; <br>
&rsquo;housecat&rsquo; =~ /$foo/; # matches <br>
&rsquo;cathouse&rsquo; =~ /cat$foo/; # matches <br>
&rsquo;housecat&rsquo; =~ /${foo}cat/; # matches</p>

<p style="margin-top: 1em">So far, so good. With the
knowledge above you can already perform searches with just
about any literal string regexp you can dream up. Here is a
very simple emulation of the <br>
Unix grep program:</p>

<p style="margin-top: 1em">% cat &gt; simple_grep <br>
#!/usr/bin/perl <br>
$regexp = shift; <br>
while (&lt;&gt;) { <br>
print if /$regexp/; <br>
} <br>
^D</p>

<p style="margin-top: 1em">% chmod +x simple_grep</p>

<p style="margin-top: 1em">% simple_grep abba
/usr/dict/words <br>
Babbage <br>
cabbage <br>
cabbages <br>
sabbath <br>
Sabbathize <br>
Sabbathizes <br>
sabbatical <br>
scabbard <br>
scabbards</p>

<p style="margin-top: 1em">This program is easy to
understand. &quot;#!/usr/bin/perl&quot; is the standard way
to invoke a perl program from the shell. &quot;$regexp =
shift;&quot; saves the first command line argument as <br>
the regexp to be used, leaving the rest of the command line
arguments to be treated as files. &quot;while
(&lt;&gt;)&quot; loops over all the lines in all the files.
For each line, <br>
&quot;print if /$regexp/;&quot; prints the line if the
regexp matches the line. In this line, both
&quot;print&quot; and &quot;/$regexp/&quot; use the default
variable $_ implicitly.</p>

<p style="margin-top: 1em">With all of the regexps above,
if the regexp matched anywhere in the string, it was
considered a match. Sometimes, however, we&rsquo;d like to
specify where in the string the regexp <br>
should try to match. To do this, we would use the anchor
metacharacters &quot;^&quot; and &quot;$&quot;. The anchor
&quot;^&quot; means match at the beginning of the string and
the anchor &quot;$&quot; means match at <br>
the end of the string, or before a newline at the end of the
string. Here is how they are used:</p>

<p style="margin-top: 1em">&quot;housekeeper&quot; =~
/keeper/; # matches <br>
&quot;housekeeper&quot; =~ /^keeper/; # doesn&rsquo;t match
<br>
&quot;housekeeper&quot; =~ /keeper$/; # matches <br>
&quot;housekeeper0 =~ /keeper$/; # matches</p>

<p style="margin-top: 1em">The second regexp doesn&rsquo;t
match because &quot;^&quot; constrains &quot;keeper&quot; to
match only at the beginning of the string, but
&quot;housekeeper&quot; has keeper starting in the middle.
The third <br>
regexp does match, since the &quot;$&quot; constrains
&quot;keeper&quot; to match only at the end of the
string.</p>

<p style="margin-top: 1em">When both &quot;^&quot; and
&quot;$&quot; are used at the same time, the regexp has to
match both the beginning and the end of the string, i.e.,
the regexp matches the whole string. Consider</p>

<p style="margin-top: 1em">&quot;keeper&quot; =~ /^keep$/;
# doesn&rsquo;t match <br>
&quot;keeper&quot; =~ /^keeper$/; # matches <br>
&quot;&quot; =~ /^$/; # ^$ matches an empty string</p>

<p style="margin-top: 1em">The first regexp doesn&rsquo;t
match because the string has more to it than
&quot;keep&quot;. Since the second regexp is exactly the
string, it matches. Using both &quot;^&quot; and
&quot;$&quot; in a regexp <br>
forces the complete string to match, so it gives you
complete control over which strings match and which
don&rsquo;t. Suppose you are looking for a fellow named
bert, off in a string <br>
by himself:</p>

<p style="margin-top: 1em">&quot;dogbert&quot; =~ /bert/; #
matches, but not what you want</p>

<p style="margin-top: 1em">&quot;dilbert&quot; =~ /^bert/;
# doesn&rsquo;t match, but .. <br>
&quot;bertram&quot; =~ /^bert/; # matches, so still not good
enough</p>

<p style="margin-top: 1em">&quot;bertram&quot; =~ /^bert$/;
# doesn&rsquo;t match, good <br>
&quot;dilbert&quot; =~ /^bert$/; # doesn&rsquo;t match, good
<br>
&quot;bert&quot; =~ /^bert$/; # matches, perfect</p>

<p style="margin-top: 1em">Of course, in the case of a
literal string, one could just as easily use the string
comparison &quot;$string eq &rsquo;bert&rsquo;&quot; and it
would be more efficient. The &quot;^...$&quot; regexp really
<br>
becomes useful when we add in the more powerful regexp tools
below.</p>

<p style="margin-top: 1em">Using character classes <br>
Although one can already do quite a lot with the literal
string regexps above, we&rsquo;ve only scratched the surface
of regular expression technology. In this and subsequent
sections <br>
we will introduce regexp concepts (and associated
metacharacter notations) that will allow a regexp to
represent not just a single character sequence, but a whole
class of them.</p>

<p style="margin-top: 1em">One such concept is that of a
character class. A character class allows a set of possible
characters, rather than just a single character, to match at
a particular point in a <br>
regexp. Character classes are denoted by brackets
&quot;[...]&quot;, with the set of characters to be possibly
matched inside. Here are some examples:</p>

<p style="margin-top: 1em">/cat/; # matches
&rsquo;cat&rsquo; <br>
/[bcr]at/; # matches &rsquo;bat, &rsquo;cat&rsquo;, or
&rsquo;rat&rsquo; <br>
/item[0123456789]/; # matches &rsquo;item0&rsquo; or ... or
&rsquo;item9&rsquo; <br>
&quot;abc&quot; =~ /[cab]/; # matches &rsquo;a&rsquo;</p>

<p style="margin-top: 1em">In the last statement, even
though &rsquo;c&rsquo; is the first character in the class,
&rsquo;a&rsquo; matches because the first character position
in the string is the earliest point at which the <br>
regexp can match.</p>

<p style="margin-top: 1em">/[yY][eE][sS]/; # match
&rsquo;yes&rsquo; in a case-insensitive way <br>
# &rsquo;yes&rsquo;, &rsquo;Yes&rsquo;, &rsquo;YES&rsquo;,
etc.</p>

<p style="margin-top: 1em">This regexp displays a common
task: perform a case-insensitive match. Perl provides a way
of avoiding all those brackets by simply appending an
&rsquo;i&rsquo; to the end of the match. <br>
Then &quot;/[yY][eE][sS]/;&quot; can be rewritten as
&quot;/yes/i;&quot;. The &rsquo;i&rsquo; stands for
case-insensitive and is an example of a modifier of the
matching operation. We will meet other <br>
modifiers later in the tutorial.</p>

<p style="margin-top: 1em">We saw in the section above that
there were ordinary characters, which represented
themselves, and special characters, which needed a backslash
&quot; <br>
same is true in a character class, but the sets of ordinary
and special characters inside a character class are
different than those outside a character class. The special
<br>
characters for a character class are &quot;-]$&quot; (and
the pattern delimiter, whatever it is). &quot;]&quot; is
special because it denotes the end of a character class.
&quot;$&quot; is special because <br>
it denotes a scalar variable. &quot;</p>

<p style="margin-top: 1em">/[]c]def/; # matches
&rsquo;]def&rsquo; or &rsquo;cdef&rsquo; <br>
$x = &rsquo;bcr&rsquo;; <br>
/[$x]at/; # matches &rsquo;bat&rsquo;, &rsquo;cat&rsquo;, or
&rsquo;rat&rsquo; <br>
/[]at/; # matches &rsquo;$at&rsquo; or &rsquo;xat&rsquo;
<br>
/[\$x]at/; # matches &rsquo;t&rsquo;, &rsquo;bat,
&rsquo;cat&rsquo;, or &rsquo;rat&rsquo;</p>

<p style="margin-top: 1em">The last two are a little
tricky. In &quot;[]&quot;, the backslash protects the dollar
sign, so the character class has two members &quot;$&quot;
and &quot;x&quot;. In &quot;[\$x]&quot;, the backslash is
<br>
protected, so $x is treated as a variable and substituted in
double quote fashion.</p>

<p style="margin-top: 1em">The special character
&rsquo;-&rsquo; acts as a range operator within character
classes, so that a contiguous set of characters can be
written as a range. With ranges, the unwieldy <br>
&quot;[0123456789]&quot; and &quot;[abc...xyz]&quot; become
the svelte &quot;[0-9]&quot; and &quot;[a-z]&quot;. Some
examples are</p>

<p style="margin-top: 1em">/item[0-9]/; # matches
&rsquo;item0&rsquo; or ... or &rsquo;item9&rsquo; <br>
/[0-9bx-z]aa/; # matches &rsquo;0aa&rsquo;, ...,
&rsquo;9aa&rsquo;, <br>
# &rsquo;baa&rsquo;, &rsquo;xaa&rsquo;, &rsquo;yaa&rsquo;,
or &rsquo;zaa&rsquo; <br>
/[0-9a-fA-F]/; # matches a hexadecimal digit <br>
/[0-9a-zA-Z_]/; # matches a &quot;word&quot; character, <br>
# like those in a Perl variable name</p>

<p style="margin-top: 1em">If &rsquo;-&rsquo; is the first
or last character in a character class, it is treated as an
ordinary character; &quot;[-ab]&quot;, &quot;[ab-]&quot; and
&quot;[a&minus;b]&quot; are all equivalent.</p>

<p style="margin-top: 1em">The special character
&quot;^&quot; in the first position of a character class
denotes a negated character class, which matches any
character but those in the brackets. Both &quot;[...]&quot;
and <br>
&quot;[^...]&quot; must match a character, or the match
fails. Then</p>

<p style="margin-top: 1em">/[^a]at/; # doesn&rsquo;t match
&rsquo;aat&rsquo; or &rsquo;at&rsquo;, but matches <br>
# all other &rsquo;bat&rsquo;, &rsquo;cat,
&rsquo;0at&rsquo;, &rsquo;%at&rsquo;, etc. <br>
/[^0-9]/; # matches a non-numeric character <br>
/[a^]at/; # matches &rsquo;aat&rsquo; or &rsquo;^at&rsquo;;
here &rsquo;^&rsquo; is ordinary</p>

<p style="margin-top: 1em">Now, even &quot;[0-9]&quot; can
be a bother to write multiple times, so in the interest of
saving keystrokes and making regexps more readable, Perl has
several abbreviations for common <br>
character classes, as shown below. Since the introduction of
Unicode, unless the &quot;//a&quot; modifier is in effect,
these character classes match more than just a few
characters in <br>
the ASCII range.</p>

<p style="margin-top: 1em">&Acirc;&middot; matches a digit,
not just [0-9] but also digits from non-roman scripts 0f]
and</p>

<p style="margin-top: 1em">&Acirc;&middot; matches a
whitespace character, the set [&nbsp; others</p>

<p style="margin-top: 1em">&Acirc;&middot; 168a word
character (alphanumeric or _), not just [0-9a-zA-Z_] but
also digits and characters from non-roman scripts</p>

<p style="margin-top: 1em">&Acirc;&middot; a negated ; it
represents any other character than a digit, or [^]</p>

<p style="margin-top: 1em">&Acirc;&middot; is a negated t
represents any non-whitespace character [^ <br>
&Acirc;&middot; W is a negated 984</p>

<p style="margin-top: 1em">&Acirc;&middot; The period
&rsquo;.&rsquo; matches any character but &quot;0 (unless
the modifier &quot;//s&quot; is in effect, as explained
below).</p>

<p style="margin-top: 1em">&Acirc;&middot; ike the period,
matches any character but &quot;0, but it does so regardless
of whether the modifier &quot;//s&quot; is in effect.</p>

<p style="margin-top: 1em">The &quot;//a&quot; modifier,
available starting in Perl 5.14, is used to restrict the
matches of , nd 48just those in the ASCII range. It is
useful to keep your program from <br>
being needlessly exposed to full Unicode (and its
accompanying security considerations) when all you want is
to process English-like text. (The &quot;a&quot; may be
doubled, &quot;//aa&quot;, to <br>
provide even more restrictions, preventing case-insensitive
matching of ASCII with non-ASCII characters; otherwise a
Unicode &quot;Kelvin Sign&quot; would caselessly match a
&quot;k&quot; or &quot;K&quot;.)</p>

<p style="margin-top: 1em">The &quot; <small>12haracter
classes. Here are some in use:</small></p>

<p style="margin-top: 1em"><small>/::/; # matches a
hh:mm:ss time format <br>
/[ # matches any digit or whitespace character <br>
/96 <br>
# non-word char, followed by a word char <br>
/..rt/; # matches any two chars, followed by
&rsquo;rt&rsquo; <br>
/end./; # matches &rsquo;end.&rsquo; <br>
/end[.]/; # same thing, matches
&rsquo;end.&rsquo;</small></p>

<p style="margin-top: 1em"><small>Because a period is a
metacharacter, it needs to be escaped to match as an
ordinary period. Because, for example, &quot;&quot; and
&quot;1176 <br>
of &quot;[^168 <br>
An anchor useful in basic regexps is the word anchor . T h i
s m a t c h e s a b o u n d a r y b e t w e e n a w o
&quot;r14424 d c h a r a c t e r a n d a n o n - w o r d c h
a r a c t e r</small></p>

<p style="margin-top: 1em"><small>$x = &quot;Housecat
catenates house and cat&quot;; <br>
$x =~ /cat/; # matches cat in &rsquo;housecat&rsquo; a t / ;
<br>
$x =~ /#hes cat in &rsquo;catenates&rsquo; m a t ; # m a t c
h e s c a t <br>
$x =~ /cati n &rsquo; h o u s e c a t &rsquo; a <br>
$x =~ /t</small></p>

<p style="margin-top: 1em"><small>Note in the last example,
the end of the string is considered a word
boundary.</small></p>

<p style="margin-top: 1em"><small>You might wonder why
&rsquo;.&rsquo; matches everything but &quot;0 - why not
every character? The reason is that often one is matching
against lines and would like to ignore the newline <br>
characters. For instance, while the string &quot;0
represents one line, we would like to think of it as empty.
Then</small></p>

<p style="margin-top: 1em"><small>&quot;&quot; =~ /^$/; #
matches <br>
&quot;0 =~ /^$/; # matches, $ anchors before
&quot;0</small></p>

<p style="margin-top: 1em"><small>&quot;&quot; =~ /./; #
doesn&rsquo;t match; it needs a char <br>
&quot;&quot; =~ /^.$/; # doesn&rsquo;t match; it needs a
char <br>
&quot;0 =~ /^.$/; # doesn&rsquo;t match; it needs a char
other than &quot;0 <br>
&quot;a&quot; =~ /^.$/; # matches <br>
&quot;a0 =~ /^.$/; # matches, $ anchors before
&quot;0</small></p>

<p style="margin-top: 1em"><small>This behavior is
convenient, because we usually want to ignore newlines when
we count and match characters in a line. Sometimes, however,
we want to keep track of newlines. We <br>
might even want &quot;^&quot; and &quot;$&quot; to anchor at
the beginning and end of lines within the string, rather
than just the beginning and end of the string. Perl allows
us to choose between <br>
ignoring and paying attention to newlines by using the
&quot;//s&quot; and &quot;//m&quot; modifiers.
&quot;//s&quot; and &quot;//m&quot; stand for single line
and multi-line and they determine whether a string is to
<br>
be treated as one continuous string, or as a set of lines.
The two modifiers affect two aspects of how the regexp is
interpreted: 1) how the &rsquo;.&rsquo; character class is
defined, and <br>
2) where the anchors &quot;^&quot; and &quot;$&quot; are
able to match. Here are the four possible
combinations:</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; no
modifiers (//): Default behavior. &rsquo;.&rsquo; matches
any character except &quot;0. &quot;^&quot; matches only at
the beginning of the string and &quot;$&quot; matches only
at the end or before a <br>
newline at the end.</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; s
modifier (//s): Treat string as a single long line.
&rsquo;.&rsquo; matches any character, even &quot;0.
&quot;^&quot; matches only at the beginning of the string
and &quot;$&quot; matches only at the end <br>
or before a newline at the end.</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; m
modifier (//m): Treat string as a set of multiple lines.
&rsquo;.&rsquo; matches any character except &quot;0.
&quot;^&quot; and &quot;$&quot; are able to match at the
start or end of any line within the <br>
string.</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; both s
and m modifiers (//sm): Treat string as a single long line,
but detect multiple lines. &rsquo;.&rsquo; matches any
character, even &quot;0. &quot;^&quot; and &quot;$&quot;,
however, are able to match <br>
at the start or end of any line within the
string.</small></p>

<p style="margin-top: 1em"><small>Here are examples of
&quot;//s&quot; and &quot;//m&quot; in action:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;There once was
a girl0ho programmed in Perl0;</small></p>

<p style="margin-top: 1em"><small>$x =~ /^Who/; #
doesn&rsquo;t match, &quot;Who&quot; not at start of string
<br>
$x =~ /^Who/s; # doesn&rsquo;t match, &quot;Who&quot; not at
start of string <br>
$x =~ /^Who/m; # matches, &quot;Who&quot; at start of second
line <br>
$x =~ /^Who/sm; # matches, &quot;Who&quot; at start of
second line</small></p>

<p style="margin-top: 1em"><small>$x =~ /girl.Who/; #
doesn&rsquo;t match, &quot;.&quot; doesn&rsquo;t match
&quot;0 <br>
$x =~ /girl.Who/s; # matches, &quot;.&quot; matches &quot;0
<br>
$x =~ /girl.Who/m; # doesn&rsquo;t match, &quot;.&quot;
doesn&rsquo;t match &quot;0 <br>
$x =~ /girl.Who/sm; # matches, &quot;.&quot; matches
&quot;0</small></p>

<p style="margin-top: 1em"><small>Most of the time, the
default behavior is what is wanted, but &quot;//s&quot; and
&quot;//m&quot; are occasionally very useful. If
&quot;//m&quot; is being used, the start of the string can
still be matched <br>
with &quot;0 (matchesand &quot;&quot;(matchesboth the
endonlyandthetheend):newline before,
lik$&quot;),</small></p>

<p style="margin-top: 1em"><small>$x =~ /^Who/m; # matches,
&quot;Who&quot; at start of second line <br>
$x =~ /0ho&quot; is not at start of string</small></p>

<p style="margin-top: 1em"><small>$x =~ /girl$/m; #
matches, &quot;girl&quot; at end of first line <br>
$x =~ /girlm; # doesn&rsquo;t match, &quot;girl&quot; is not
at end of string</small></p>

<p style="margin-top: 1em"><small>$x =~ /Perlm; # matches,
&quot;Perl&quot; is at newline before end <br>
$x =~ /Perlm; # doesn&rsquo;t match, &quot;Perl&quot; is not
at end of string</small></p>

<p style="margin-top: 1em"><small>We now know how to create
choices among classes of characters in a regexp. What about
choices among words or character strings? Such choices are
described in the next section.</small></p>

<p style="margin-top: 1em"><small>Matching this or that
<br>
Sometimes we would like our regexp to be able to match
different possible words or character strings. This is
accomplished by using the alternation metacharacter
&quot;|&quot;. To match <br>
&quot;dog&quot; or &quot;cat&quot;, we form the regexp
&quot;dog|cat&quot;. As before, Perl will try to match the
regexp at the earliest possible point in the string. At each
character position, Perl will <br>
first try to match the first alternative, &quot;dog&quot;.
If &quot;dog&quot; doesn&rsquo;t match, Perl will then try
the next alternative, &quot;cat&quot;. If &quot;cat&quot;
doesn&rsquo;t match either, then the match fails and <br>
Perl moves to the next position in the string. Some
examples:</small></p>

<p style="margin-top: 1em"><small>&quot;cats and dogs&quot;
=~ /cat|dog|bird/; # matches &quot;cat&quot; <br>
&quot;cats and dogs&quot; =~ /dog|cat|bird/; # matches
&quot;cat&quot;</small></p>

<p style="margin-top: 1em"><small>Even though
&quot;dog&quot; is the first alternative in the second
regexp, &quot;cat&quot; is able to match earlier in the
string.</small></p>

<p style="margin-top: 1em"><small>&quot;cats&quot; =~
/c|ca|cat|cats/; # matches &quot;c&quot; <br>
&quot;cats&quot; =~ /cats|cat|ca|c/; # matches
&quot;cats&quot;</small></p>

<p style="margin-top: 1em"><small>Here, all the
alternatives match at the first string position, so the
first alternative is the one that matches. If some of the
alternatives are truncations of the others, put <br>
the longest ones first to give them a chance to
match.</small></p>

<p style="margin-top: 1em"><small>&quot;cab&quot; =~
/a|b|c/ # matches &quot;c&quot; <br>
# /a|b|c/ == /[abc]/</small></p>

<p style="margin-top: 1em"><small>The last example points
out that character classes are like alternations of
characters. At a given character position, the first
alternative that allows the regexp match to <br>
succeed will be the one that matches.</small></p>

<p style="margin-top: 1em"><small>Grouping things and
hierarchical matching <br>
Alternation allows a regexp to choose among alternatives,
but by itself it is unsatisfying. The reason is that each
alternative is a whole regexp, but sometime we want <br>
alternatives for just part of a regexp. For instance,
suppose we want to search for housecats or housekeepers. The
regexp &quot;housecat|housekeeper&quot; fits the bill, but
is <br>
inefficient because we had to type &quot;house&quot; twice.
It would be nice to have parts of the regexp be constant,
like &quot;house&quot;, and some parts have alternatives,
like &quot;cat|keeper&quot;.</small></p>

<p style="margin-top: 1em"><small>The grouping
metacharacters &quot;()&quot; solve this problem. Grouping
allows parts of a regexp to be treated as a single unit.
Parts of a regexp are grouped by enclosing them in <br>
parentheses. Thus we could solve the
&quot;housecat|housekeeper&quot; by forming the regexp as
&quot;house(cat|keeper)&quot;. The regexp
&quot;house(cat|keeper)&quot; means match &quot;house&quot;
followed by either <br>
&quot;cat&quot; or &quot;keeper&quot;. Some more examples
are</small></p>

<p style="margin-top: 1em"><small>/(a|b)b/; # matches
&rsquo;ab&rsquo; or &rsquo;bb&rsquo; <br>
/(ac|b)b/; # matches &rsquo;acb&rsquo; or &rsquo;bb&rsquo;
<br>
/(^a|b)c/; # matches &rsquo;ac&rsquo; at start of string or
&rsquo;bc&rsquo; anywhere <br>
/(a|[bc])d/; # matches &rsquo;ad&rsquo;, &rsquo;bd&rsquo;,
or &rsquo;cd&rsquo;</small></p>

<p style="margin-top: 1em"><small>/house(cat|)/; # matches
either &rsquo;housecat&rsquo; or &rsquo;house&rsquo; <br>
/house(cat(s|)|)/; # matches either &rsquo;housecats&rsquo;
or &rsquo;housecat&rsquo; or <br>
# &rsquo;house&rsquo;. Note groups can be
nested.</small></p>

<p style="margin-top: 1em"><small>/(19|20|)/; # match years
19xx, 20xx, or the Y2K problem, xx <br>
&quot;20&quot; =~ /(19|20|)/; # matches the null alternative
&rsquo;()&rsquo;, <br>
# because &rsquo;20&rsquo; can&rsquo;t match</small></p>

<p style="margin-top: 1em"><small>Alternations behave the
same way in groups as out of them: at a given string
position, the leftmost alternative that allows the regexp to
match is taken. So in the last example <br>
at the first string position, &quot;20&quot; matches the
second alternative, but there is nothing left over to match
the next two digits &quot;&quot;. So Perl moves on to the
next alternative, <br>
which is the null alternative and that works, since
&quot;20&quot; is two digits.</small></p>

<p style="margin-top: 1em"><small>The process of trying one
alternative, seeing if it matches, and moving on to the next
alternative, while going back in the string from where the
previous alternative was tried, <br>
if it doesn&rsquo;t, is called backtracking. The term
&rsquo;backtracking&rsquo; comes from the idea that matching
a regexp is like a walk in the woods. Successfully matching
a regexp is like <br>
arriving at a destination. There are many possible
trailheads, one for each string position, and each one is
tried in order, left to right. From each trailhead there may
be <br>
many paths, some of which get you there, and some which are
dead ends. When you walk along a trail and hit a dead end,
you have to backtrack along the trail to an earlier point
<br>
to try another trail. If you hit your destination, you stop
immediately and forget about trying all the other trails.
You are persistent, and only if you have tried all the <br>
trails from all the trailheads and not arrived at your
destination, do you declare failure. To be concrete, here is
a step-by-step analysis of what Perl does when it tries to
<br>
match the regexp</small></p>

<p style="margin-top: 1em"><small>&quot;abcde&quot; =~
/(abd|abc)(df|d|de)/;</small></p>

<p style="margin-top: 1em"><small>0 Start with the first
letter in the string &rsquo;a&rsquo;.</small></p>

<p style="margin-top: 1em"><small>1 Try the first
alternative in the first group
&rsquo;abd&rsquo;.</small></p>

<p style="margin-top: 1em"><small>2 Match &rsquo;a&rsquo;
followed by &rsquo;b&rsquo;. So far so good.</small></p>

<p style="margin-top: 1em"><small>3 &rsquo;d&rsquo; in the
regexp doesn&rsquo;t match &rsquo;c&rsquo; in the string - a
dead end. So backtrack two characters and pick the second
alternative in the first group
&rsquo;abc&rsquo;.</small></p>

<p style="margin-top: 1em"><small>4 Match &rsquo;a&rsquo;
followed by &rsquo;b&rsquo; followed by &rsquo;c&rsquo;. We
are on a roll and have satisfied the first group. Set $1 to
&rsquo;abc&rsquo;.</small></p>

<p style="margin-top: 1em"><small>5 Move on to the second
group and pick the first alternative
&rsquo;df&rsquo;.</small></p>

<p style="margin-top: 1em"><small>6 Match the
&rsquo;d&rsquo;.</small></p>

<p style="margin-top: 1em"><small>7 &rsquo;f&rsquo; in the
regexp doesn&rsquo;t match &rsquo;e&rsquo; in the string, so
a dead end. Backtrack one character and pick the second
alternative in the second group &rsquo;d&rsquo;.</small></p>

<p style="margin-top: 1em"><small>8 &rsquo;d&rsquo;
matches. The second grouping is satisfied, so set $2 to
&rsquo;d&rsquo;.</small></p>

<p style="margin-top: 1em"><small>9 We are at the end of
the regexp, so we are done! We have matched
&rsquo;abcd&rsquo; out of the string
&quot;abcde&quot;.</small></p>

<p style="margin-top: 1em"><small>There are a couple of
things to note about this analysis. First, the third
alternative in the second group &rsquo;de&rsquo; also allows
a match, but we stopped before we got to it - at a <br>
given character position, leftmost wins. Second, we were
able to get a match at the first character position of the
string &rsquo;a&rsquo;. If there were no matches at the
first position, <br>
Perl would move to the second character position
&rsquo;b&rsquo; and attempt the match all over again. Only
when all possible paths at all possible character positions
have been exhausted <br>
does Perl give up and declare &quot;$string =~
/(abd|abc)(df|d|de)/;&quot; to be false.</small></p>

<p style="margin-top: 1em"><small>Even with all this work,
regexp matching happens remarkably fast. To speed things up,
Perl compiles the regexp into a compact sequence of opcodes
that can often fit inside a <br>
processor cache. When the code is executed, these opcodes
can then run at full throttle and search very
quickly.</small></p>

<p style="margin-top: 1em"><small>Extracting matches <br>
The grouping metacharacters &quot;()&quot; also serve
another completely different function: they allow the
extraction of the parts of a string that matched. This is
very useful to find <br>
out what matched and for text processing in general. For
each grouping, the part that matched inside goes into the
special variables $1, $2, etc. They can be used just as <br>
ordinary variables:</small></p>

<p style="margin-top: 1em"><small># extract hours, minutes,
seconds <br>
if ($time =~ /():():()/) { # match hh:mm:ss format <br>
$hours = $1; <br>
$minutes = $2; <br>
$seconds = $3; <br>
}</small></p>

<p style="margin-top: 1em"><small>Now, we know that in
scalar context, &quot;$time =~ /():():()/&quot; returns a
true or false value. In list context, however, it returns
the list of matched values <br>
&quot;($1,$2,$3)&quot;. So we could write the code more
compactly as</small></p>

<p style="margin-top: 1em"><small># extract hours, minutes,
seconds <br>
($hours, $minutes, $second) = ($time =~
/():():()/);</small></p>

<p style="margin-top: 1em"><small>If the groupings in a
regexp are nested, $1 gets the group with the leftmost
opening parenthesis, $2 the next opening parenthesis, etc.
Here is a regexp with nested groups:</small></p>

<p style="margin-top: 1em"><small>/(ab(cd|ef)((gi)|j))/;
<br>
1 2 34</small></p>

<p style="margin-top: 1em"><small>If this regexp matches,
$1 contains a string starting with &rsquo;ab&rsquo;, $2 is
either set to &rsquo;cd&rsquo; or &rsquo;ef&rsquo;, $3
equals either &rsquo;gi&rsquo; or &rsquo;j&rsquo;, and $4 is
either set to &rsquo;gi&rsquo;, just like $3, or it <br>
remains undefined.</small></p>

<p style="margin-top: 1em"><small>For convenience, Perl
sets $+ to the string held by the highest numbered $1,
$2,... that got assigned (and, somewhat related, $^N to the
value of the $1, $2,... most-recently <br>
assigned; i.e. the $1, $2,... associated with the rightmost
closing parenthesis used in the match).</small></p>

<p style="margin-top: 1em"><small>Backreferences <br>
Closely associated with the matching variables $1, $2, ...
are the backreferences &quot;&quot;, &quot;0&quot;,...
Backreferences are simply matching variables that can be
used inside a regexp. <br>
This is a really nice feature; what matches later in a
regexp is made to depend on what matched earlier in the
regexp. Suppose we wanted to look for doubled words in a
text, <br>
like &rsquo;the the&rsquo;. The following regexp finds all
3-letter doubles with a space in between:</small></p>

<p style="margin-top: 1em"><small>/0</small></p>

<p style="margin-top: 1em"><small>The grouping assigns a
value to , so that the same 3-letter sequence is used for
both parts.</small></p>

<p style="margin-top: 1em"><small>A similar task is to find
words consisting of two identical parts:</small></p>

<p style="margin-top: 1em"><small>% simple_grep &rsquo;^(24
<br>
beriberi <br>
booboo <br>
coco <br>
mama <br>
murmur <br>
papa</small></p>

<p style="margin-top: 1em"><small>The regexp has a single
grouping which considers 4-letter combinations, then
3-letter combinations, etc., and uses &quot;&quot; to look
for a repeat. Although $1 and &quot;&quot; represent <br>
the same thing, care should be taken to use matched
variables $1, $2,... only outside a regexp and
backreferences &quot;&quot;, &quot;0&quot;,... only inside a
regexp; not doing so may lead to <br>
surprising and unsatisfactory results.</small></p>

<p style="margin-top: 1em"><small>Relative backreferences
<br>
Counting the opening parentheses to get the correct number
for a backreference is error-prone as soon as there is more
than one capturing group. A more convenient technique <br>
became available with Perl 5.10: relative backreferences. To
refer to the immediately preceding capture group one now may
write &quot;-1}&quot;, the next but last is available via
<br>
&quot;-2}&quot;, and so on.</small></p>

<p style="margin-top: 1em"><small>Another good reason in
addition to readability and maintainability for using
relative backreferences is illustrated by the following
example, where a simple pattern for matching <br>
peculiar strings is used:</small></p>

<p style="margin-top: 1em"><small>$a99a =
&rsquo;([a-z])()0&rsquo;; # matches a11a, g22g, x33x,
etc.</small></p>

<p style="margin-top: 1em"><small>Now that we have this
pattern stored as a handy string, we might feel tempted to
use it as a part of some other pattern:</small></p>

<p style="margin-top: 1em"><small>$line =
&quot;code=e99e&quot;; <br>
if ($line =~ /^(864 <br>
print &quot;$1 is valid0; <br>
} else { <br>
print &quot;bad line: &rsquo;$line&rsquo;0; <br>
}</small></p>

<p style="margin-top: 1em"><small>But this doesn&rsquo;t
match, at least not the way one might expect. Only after
inserting the interpolated $a99a and looking at the
resulting full text of the regexp is it obvious that <br>
the backreferences have backfired. The subexpression
&quot;(2568 <br>
backreferences:</small></p>

<p style="margin-top: 1em"><small>$a99a =
&rsquo;([a-z])()-1}-2}&rsquo;; # safe for being
interpolated</small></p>

<p style="margin-top: 1em"><small>Named backreferences <br>
Perl 5.10 also introduced named capture groups and named
backreferences. To attach a name to a capturing group, you
write either &quot;(?&lt;name&gt;...)&quot; or
&quot;(?&rsquo;name&rsquo;...)&quot;. The <br>
backreference may then be written as &quot;name}&quot;. It
is permissible to attach the same name to more than one
group, but then only the leftmost one of the eponymous set
can be <br>
referenced. Outside of the pattern a named capture group is
accessible through the &quot;%+&quot; hash.</small></p>

<p style="margin-top: 1em"><small>Assuming that we have to
match calendar dates which may be given in one of the three
formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write
three suitable patterns where we <br>
use &rsquo;d&rsquo;, &rsquo;m&rsquo; and &rsquo;y&rsquo;
respectively as the names of the groups capturing the
pertaining components of a date. The matching operation
combines the three patterns as alternatives:</small></p>

<p style="margin-top: 1em"><small>$fmt1 =
&rsquo;(?&lt;y&gt;)-(?&lt;m&gt;)-(?&lt;d&gt;)&rsquo;; <br>
$fmt2 =
&rsquo;(?&lt;m&gt;)/(?&lt;d&gt;)/(?&lt;y&gt;)&rsquo;; <br>
$fmt3 =
&rsquo;(?&lt;d&gt;).(?&lt;m&gt;).(?&lt;y&gt;)&rsquo;; <br>
for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){ <br>
if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){ <br>
print &quot;day=$+{d} month=$+{m} year=$+{y}0; <br>
} <br>
}</small></p>

<p style="margin-top: 1em"><small>If any of the
alternatives matches, the hash &quot;%+&quot; is bound to
contain the three key-value pairs.</small></p>

<p style="margin-top: 1em"><small>Alternative capture group
numbering <br>
Yet another capturing group numbering technique (also as
from Perl 5.10) deals with the problem of referring to
groups within a set of alternatives. Consider a pattern for
<br>
matching a time of the day, civil or military
style:</small></p>

<p style="margin-top: 1em"><small>if ( $time =~
/(|):()|()()/ ){ <br>
# process hour and minute <br>
}</small></p>

<p style="margin-top: 1em"><small>Processing the results
requires an additional if statement to determine whether $1
and $2 or $3 and $4 contain the goodies. It would be easier
if we could use group numbers 1 and <br>
2 in second alternative as well, and this is exactly what
the parenthesized construct &quot;(?|...)&quot;, set around
an alternative achieves. Here is an extended version of the
previous <br>
pattern:</small></p>

<p style="margin-top: 1em"><small>if ( $time =~
/(?|(|):()|()())A-Z][A-Z][A-Z])/ ){ <br>
print &quot;hour=$1 minute=$2 zone=$30; <br>
}</small></p>

<p style="margin-top: 1em"><small>Within the alternative
numbering group, group numbers start at the same position
for each alternative. After the group, numbering continues
with one higher than the maximum <br>
reached across all the alternatives.</small></p>

<p style="margin-top: 1em"><small>Position information <br>
In addition to what was matched, Perl (since 5.6.0) also
provides the positions of what was matched as contents of
the &quot;@-&quot; and &quot;@+&quot; arrays.
&quot;$-[0]&quot; is the position of the start <br>
of the entire match and $+[0] is the position of the end.
Similarly, &quot;$-[n]&quot; is the position of the start of
the $n match and $+[n] is the position of the end. If $n is
<br>
undefined, so are &quot;$-[n]&quot; and $+[n]. Then this
code</small></p>

<p style="margin-top: 1em"><small>$x = &quot;Mmm...donut,
thought Homer&quot;; <br>
$x =~ /^(Mmm|Yech)...(donut|peas)/; # matches <br>
foreach $expr (1..$#-) { <br>
print &quot;Match $expr: &rsquo;${$expr}&rsquo; at position
($-[$expr],$+[$expr])0; <br>
}</small></p>

<p style="margin-top: 1em"><small>prints</small></p>

<p style="margin-top: 1em"><small>Match 1:
&rsquo;Mmm&rsquo; at position (0,3) <br>
Match 2: &rsquo;donut&rsquo; at position (6,11)</small></p>

<p style="margin-top: 1em"><small>Even if there are no
groupings in a regexp, it is still possible to find out what
exactly matched in a string. If you use them, Perl will set
&quot;$&lsquo;&quot; to the part of the string <br>
before the match, will set $&amp; to the part of the string
that matched, and will set &quot;$&rsquo;&quot; to the part
of the string after the match. An example:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;the cat caught
the mouse&quot;; <br>
$x =~ /cat/; # $&lsquo; = &rsquo;the &rsquo;, $&amp; =
&rsquo;cat&rsquo;, $&rsquo; = &rsquo; caught the
mouse&rsquo; <br>
$x =~ /the/; # $&lsquo; = &rsquo;&rsquo;, $&amp; =
&rsquo;the&rsquo;, $&rsquo; = &rsquo; cat caught the
mouse&rsquo;</small></p>

<p style="margin-top: 1em"><small>In the second match,
&quot;$&lsquo;&quot; equals &rsquo;&rsquo; because the
regexp matched at the first character position in the string
and stopped; it never saw the second &rsquo;the&rsquo;. It
is important to note <br>
that using &quot;$&lsquo;&quot; and &quot;$&rsquo;&quot;
slows down regexp matching quite a bit, while $&amp; slows
it down to a lesser extent, because if they are used in one
regexp in a program, they are <br>
generated for all regexps in the program. So if raw
performance is a goal of your application, they should be
avoided. If you need to extract the corresponding
substrings, use <br>
&quot;@-&quot; and &quot;@+&quot; instead:</small></p>

<p style="margin-top: 1em"><small>$&lsquo; is the same as
substr( $x, 0, $-[0] ) <br>
$&amp; is the same as substr( $x, $-[0], $+[0]-$-[0] ) <br>
$&rsquo; is the same as substr( $x, $+[0] )</small></p>

<p style="margin-top: 1em"><small>As of Perl 5.10, the
&quot;${^PREMATCH}&quot;, &quot;${^MATCH}&quot; and
&quot;${^POSTMATCH}&quot; variables may be used. These are
only set if the &quot;/p&quot; modifier is present.
Consequently they do not penalize <br>
the rest of the program.</small></p>

<p style="margin-top: 1em"><small>Non-capturing groupings
<br>
A group that is required to bundle a set of alternatives may
or may not be useful as a capturing group. If it
isn&rsquo;t, it just creates a superfluous addition to the
set of <br>
available capture group values, inside as well as outside
the regexp. Non-capturing groupings, denoted by
&quot;(?:regexp)&quot;, still allow the regexp to be treated
as a single unit, <br>
but don&rsquo;t establish a capturing group at the same
time. Both capturing and non-capturing groupings are allowed
to co-exist in the same regexp. Because there is no
extraction, <br>
non-capturing groupings are faster than capturing groupings.
Non-capturing groupings are also handy for choosing exactly
which parts of a regexp are to be extracted to matching <br>
variables:</small></p>

<p style="margin-top: 1em"><small># match a number, $1-$4
are set, but we only want $1 <br>
/([+-]?&nbsp;*(+(.*)?|.+)([eE][+-]?+)?)/;</small></p>

<p style="margin-top: 1em"><small># match a number faster ,
only $1 is set <br>
/([+-]?&nbsp;*(?:+(?:.*)?|.+)(?:[eE][+-]?+)?)/;</small></p>

<p style="margin-top: 1em"><small># match a number, get $1
= whole number, $2 = exponent <br>

/([+-]?&nbsp;*(?:+(?:.*)?|.+)(?:[eE]([+-]?+))?)/;</small></p>

<p style="margin-top: 1em"><small>Non-capturing groupings
are also useful for removing nuisance elements gathered from
a split operation where parentheses are required for some
reason:</small></p>

<p style="margin-top: 1em"><small>$x =
&rsquo;12aba34ba5&rsquo;; <br>
@num = split /(a|b)+/, $x; # @num =
(&rsquo;12&rsquo;,&rsquo;a&rsquo;,&rsquo;34&rsquo;,&rsquo;a&rsquo;,&rsquo;5&rsquo;)
<br>
@num = split /(?:a|b)+/, $x; # @num =
(&rsquo;12&rsquo;,&rsquo;34&rsquo;,&rsquo;5&rsquo;)</small></p>

<p style="margin-top: 1em"><small>Matching repetitions <br>
The examples in the previous section display an annoying
weakness. We were only matching 3-letter words, or chunks of
words of 4 letters or less. We&rsquo;d like to be able to
match <br>
words or, more generally, strings of any length, without
writing out tedious alternatives like &quot;24</small></p>

<p style="margin-top: 1em"><small>This is exactly the
problem the quantifier metacharacters &quot;?&quot;,
&quot;*&quot;, &quot;+&quot;, and &quot;{}&quot; were
created for. They allow us to delimit the number of repeats
for a portion of a regexp we <br>
consider to be a match. Quantifiers are put immediately
after the character, character class, or grouping that we
want to specify. They have the following
meanings:</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a?&quot; means: match &rsquo;a&rsquo; 1 or 0
times</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a*&quot; means: match &rsquo;a&rsquo; 0 or more times,
i.e., any number of times</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a+&quot; means: match &rsquo;a&rsquo; 1 or more times,
i.e., at least once</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a{n,m}&quot; means: match at least &quot;n&quot;
times, but not more than &quot;m&quot; times.</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a{n,}&quot; means: match at least &quot;n&quot; or
more times</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a{n}&quot; means: match exactly &quot;n&quot;
times</small></p>

<p style="margin-top: 1em"><small>Here are some
examples:</small></p>

<p style="margin-top: 1em"><small>/[a-z]+*/; # match a
lowercase word, at least one space, and <br>
# any number of digits <br>
/(1128 <br>
/y(es)?/i; # matches &rsquo;y&rsquo;, &rsquo;Y&rsquo;, or a
case-insensitive &rsquo;yes&rsquo; <br>
$year =~ /^{2,4}$/; # make sure year is at least 2 but not
more <br>
# than 4 digits <br>
$year =~ /^{4}$|^{2}$/; # better match; throw out 3-digit
dates <br>
$year =~ /^{2}({2})?$/; # same thing written differently.
However, <br>
# this captures the last two digits in $1 <br>
# and the other does not.</small></p>

<p style="margin-top: 1em"><small>% simple_grep
&rsquo;^(1008 <br>
beriberi <br>
booboo <br>
coco <br>
mama <br>
murmur <br>
papa</small></p>

<p style="margin-top: 1em"><small>For all of these
quantifiers, Perl will try to match as much of the string as
possible, while still allowing the regexp to succeed. Thus
with &quot;/a?.../&quot;, Perl will first try to <br>
match the regexp with the &quot;a&quot; present; if that
fails, Perl will try to match the regexp without the
&quot;a&quot; present. For the quantifier &quot;*&quot;, we
get the following:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;the cat in the
hat&quot;; <br>
$x =~ /^(.*)(cat)(.*)$/; # matches, <br>
# $1 = &rsquo;the &rsquo; <br>
# $2 = &rsquo;cat&rsquo; <br>
# $3 = &rsquo; in the hat&rsquo;</small></p>

<p style="margin-top: 1em"><small>Which is what we might
expect, the match finds the only &quot;cat&quot; in the
string and locks onto it. Consider, however, this
regexp:</small></p>

<p style="margin-top: 1em"><small>$x =~ /^(.*)(at)(.*)$/; #
matches, <br>
# $1 = &rsquo;the cat in the h&rsquo; <br>
# $2 = &rsquo;at&rsquo; <br>
# $3 = &rsquo;&rsquo; (0 characters match)</small></p>

<p style="margin-top: 1em"><small>One might initially guess
that Perl would find the &quot;at&quot; in &quot;cat&quot;
and stop there, but that wouldn&rsquo;t give the longest
possible string to the first quantifier &quot;.*&quot;.
Instead, the <br>
first quantifier &quot;.*&quot; grabs as much of the string
as possible while still having the regexp match. In this
example, that means having the &quot;at&quot; sequence with
the final &quot;at&quot; in <br>
the string. The other important principle illustrated here
is that, when there are two or more elements in a regexp,
the leftmost quantifier, if there is one, gets to grab as
<br>
much of the string as possible, leaving the rest of the
regexp to fight over scraps. Thus in our example, the first
quantifier &quot;.*&quot; grabs most of the string, while
the second <br>
quantifier &quot;.*&quot; gets the empty string. Quantifiers
that grab as much of the string as possible are called
maximal match or greedy quantifiers.</small></p>

<p style="margin-top: 1em"><small>When a regexp can match a
string in several different ways, we can use the principles
above to predict which way the regexp will
match:</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; Principle
0: Taken as a whole, any regexp will be matched at the
earliest possible position in the string.</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; Principle
1: In an alternation &quot;a|b|c...&quot;, the leftmost
alternative that allows a match for the whole regexp will be
the one used.</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; Principle
2: The maximal matching quantifiers &quot;?&quot;,
&quot;*&quot;, &quot;+&quot; and &quot;{n,m}&quot; will in
general match as much of the string as possible while still
allowing the whole regexp to <br>
match.</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; Principle
3: If there are two or more elements in a regexp, the
leftmost greedy quantifier, if any, will match as much of
the string as possible while still allowing the <br>
whole regexp to match. The next leftmost greedy quantifier,
if any, will try to match as much of the string remaining
available to it as possible, while still allowing the <br>
whole regexp to match. And so on, until all the regexp
elements are satisfied.</small></p>

<p style="margin-top: 1em"><small>As we have seen above,
Principle 0 overrides the others. The regexp will be matched
as early as possible, with the other principles determining
how the regexp matches at that <br>
earliest character position.</small></p>

<p style="margin-top: 1em"><small>Here is an example of
these principles in action:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;The
programming republic of Perl&quot;; <br>
$x =~ /^(.+)(e|r)(.*)$/; # matches, <br>
# $1 = &rsquo;The programming republic of Pe&rsquo; <br>
# $2 = &rsquo;r&rsquo; <br>
# $3 = &rsquo;l&rsquo;</small></p>

<p style="margin-top: 1em"><small>This regexp matches at
the earliest string position, &rsquo;T&rsquo;. One might
think that &quot;e&quot;, being leftmost in the alternation,
would be matched, but &quot;r&quot; produces the longest
string in <br>
the first quantifier.</small></p>

<p style="margin-top: 1em"><small>$x =~ /(m{1,2})(.*)$/; #
matches, <br>
# $1 = &rsquo;mm&rsquo; <br>
# $2 = &rsquo;ing republic of Perl&rsquo;</small></p>

<p style="margin-top: 1em"><small>Here, The earliest
possible match is at the first &rsquo;m&rsquo; in
&quot;programming&quot;. &quot;m{1,2}&quot; is the first
quantifier, so it gets to match a maximal
&quot;mm&quot;.</small></p>

<p style="margin-top: 1em"><small>$x =~ /.*(m{1,2})(.*)$/;
# matches, <br>
# $1 = &rsquo;m&rsquo; <br>
# $2 = &rsquo;ing republic of Perl&rsquo;</small></p>

<p style="margin-top: 1em"><small>Here, the regexp matches
at the start of the string. The first quantifier
&quot;.*&quot; grabs as much as possible, leaving just a
single &rsquo;m&rsquo; for the second quantifier
&quot;m{1,2}&quot;.</small></p>

<p style="margin-top: 1em"><small>$x =~
/(.?)(m{1,2})(.*)$/; # matches, <br>
# $1 = &rsquo;a&rsquo; <br>
# $2 = &rsquo;mm&rsquo; <br>
# $3 = &rsquo;ing republic of Perl&rsquo;</small></p>

<p style="margin-top: 1em"><small>Here, &quot;.?&quot; eats
its maximal one character at the earliest possible position
in the string, &rsquo;a&rsquo; in &quot;programming&quot;,
leaving &quot;m{1,2}&quot; the opportunity to match both
&quot;m&quot;&rsquo;s. Finally,</small></p>

<p style="margin-top: 1em"><small>&quot;aXXXb&quot; =~
/(X*)/; # matches with $1 = &rsquo;&rsquo;</small></p>

<p style="margin-top: 1em"><small>because it can match zero
copies of &rsquo;X&rsquo; at the beginning of the string. If
you definitely want to match at least one &rsquo;X&rsquo;,
use &quot;X+&quot;, not &quot;X*&quot;.</small></p>

<p style="margin-top: 1em"><small>Sometimes greed is not
good. At times, we would like quantifiers to match a minimal
piece of string, rather than a maximal piece. For this
purpose, Larry Wall created the <br>
minimal match or non-greedy quantifiers &quot;??&quot;,
&quot;*?&quot;, &quot;+?&quot;, and &quot;{}?&quot;. These
are the usual quantifiers with a &quot;?&quot; appended to
them. They have the following meanings:</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a??&quot; means: match &rsquo;a&rsquo; 0 or 1 times.
Try 0 first, then 1.</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a*?&quot; means: match &rsquo;a&rsquo; 0 or more
times, i.e., any number of times, but as few times as
possible</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a+?&quot; means: match &rsquo;a&rsquo; 1 or more
times, i.e., at least once, but as few times as
possible</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a{n,m}?&quot; means: match at least &quot;n&quot;
times, not more than &quot;m&quot; times, as few times as
possible</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a{n,}?&quot; means: match at least &quot;n&quot;
times, but as few times as possible</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a{n}?&quot; means: match exactly &quot;n&quot; times.
Because we match exactly &quot;n&quot; times,
&quot;a{n}?&quot; is equivalent to &quot;a{n}&quot; and is
just there for notational consistency.</small></p>

<p style="margin-top: 1em"><small>Let&rsquo;s look at the
example above, but with minimal quantifiers:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;The
programming republic of Perl&quot;; <br>
$x =~ /^(.+?)(e|r)(.*)$/; # matches, <br>
# $1 = &rsquo;Th&rsquo; <br>
# $2 = &rsquo;e&rsquo; <br>
# $3 = &rsquo; programming republic of
Perl&rsquo;</small></p>

<p style="margin-top: 1em"><small>The minimal string that
will allow both the start of the string &quot;^&quot; and
the alternation to match is &quot;Th&quot;, with the
alternation &quot;e|r&quot; matching &quot;e&quot;. The
second quantifier &quot;.*&quot; is <br>
free to gobble up the rest of the string.</small></p>

<p style="margin-top: 1em"><small>$x =~ /(m{1,2}?)(.*?)$/;
# matches, <br>
# $1 = &rsquo;m&rsquo; <br>
# $2 = &rsquo;ming republic of Perl&rsquo;</small></p>

<p style="margin-top: 1em"><small>The first string position
that this regexp can match is at the first &rsquo;m&rsquo;
in &quot;programming&quot;. At this position, the minimal
&quot;m{1,2}?&quot; matches just one &rsquo;m&rsquo;.
Although the second <br>
quantifier &quot;.*?&quot; would prefer to match no
characters, it is constrained by the end-of-string anchor
&quot;$&quot; to match the rest of the string.</small></p>

<p style="margin-top: 1em"><small>$x =~
/(.*?)(m{1,2}?)(.*)$/; # matches, <br>
# $1 = &rsquo;The progra&rsquo; <br>
# $2 = &rsquo;m&rsquo; <br>
# $3 = &rsquo;ming republic of Perl&rsquo;</small></p>

<p style="margin-top: 1em"><small>In this regexp, you might
expect the first minimal quantifier &quot;.*?&quot; to match
the empty string, because it is not constrained by a
&quot;^&quot; anchor to match the beginning of the word.
<br>
Principle 0 applies here, however. Because it is possible
for the whole regexp to match at the start of the string, it
will match at the start of the string. Thus the first <br>
quantifier has to match everything up to the first
&quot;m&quot;. The second minimal quantifier matches just
one &quot;m&quot; and the third quantifier matches the rest
of the string.</small></p>

<p style="margin-top: 1em"><small>$x =~
/(.??)(m{1,2})(.*)$/; # matches, <br>
# $1 = &rsquo;a&rsquo; <br>
# $2 = &rsquo;mm&rsquo; <br>
# $3 = &rsquo;ing republic of Perl&rsquo;</small></p>

<p style="margin-top: 1em"><small>Just as in the previous
regexp, the first quantifier &quot;.??&quot; can match
earliest at position &rsquo;a&rsquo;, so it does. The second
quantifier is greedy, so it matches &quot;mm&quot;, and the
third <br>
matches the rest of the string.</small></p>

<p style="margin-top: 1em"><small>We can modify principle 3
above to take into account non-greedy
quantifiers:</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; Principle
3: If there are two or more elements in a regexp, the
leftmost greedy (non-greedy) quantifier, if any, will match
as much (little) of the string as possible while <br>
still allowing the whole regexp to match. The next leftmost
greedy (non-greedy) quantifier, if any, will try to match as
much (little) of the string remaining available to <br>
it as possible, while still allowing the whole regexp to
match. And so on, until all the regexp elements are
satisfied.</small></p>

<p style="margin-top: 1em"><small>Just like alternation,
quantifiers are also susceptible to backtracking. Here is a
step-by-step analysis of the example</small></p>

<p style="margin-top: 1em"><small>$x = &quot;the cat in the
hat&quot;; <br>
$x =~ /^(.*)(at)(.*)$/; # matches, <br>
# $1 = &rsquo;the cat in the h&rsquo; <br>
# $2 = &rsquo;at&rsquo; <br>
# $3 = &rsquo;&rsquo; (0 matches)</small></p>

<p style="margin-top: 1em"><small>0 Start with the first
letter in the string &rsquo;t&rsquo;.</small></p>

<p style="margin-top: 1em"><small>1 The first quantifier
&rsquo;.*&rsquo; starts out by matching the whole string
&rsquo;the cat in the hat&rsquo;.</small></p>

<p style="margin-top: 1em"><small>2 &rsquo;a&rsquo; in the
regexp element &rsquo;at&rsquo; doesn&rsquo;t match the end
of the string. Backtrack one character.</small></p>

<p style="margin-top: 1em"><small>3 &rsquo;a&rsquo; in the
regexp element &rsquo;at&rsquo; still doesn&rsquo;t match
the last letter of the string &rsquo;t&rsquo;, so backtrack
one more character.</small></p>

<p style="margin-top: 1em"><small>4 Now we can match the
&rsquo;a&rsquo; and the &rsquo;t&rsquo;.</small></p>

<p style="margin-top: 1em"><small>5 Move on to the third
element &rsquo;.*&rsquo;. Since we are at the end of the
string and &rsquo;.*&rsquo; can match 0 times, assign it the
empty string.</small></p>

<p style="margin-top: 1em"><small>6 We are
done!</small></p>

<p style="margin-top: 1em"><small>Most of the time, all
this moving forward and backtracking happens quickly and
searching is fast. There are some pathological regexps,
however, whose execution time exponentially <br>
grows with the size of the string. A typical structure that
blows up in your face is of the form</small></p>

<p style="margin-top: 1em"><small>/(a|b+)*/;</small></p>

<p style="margin-top: 1em"><small>The problem is the nested
indeterminate quantifiers. There are many different ways of
partitioning a string of length n between the &quot;+&quot;
and &quot;*&quot;: one repetition with &quot;b+&quot; of
<br>
length n, two repetitions with the first &quot;b+&quot;
length k and the second with length n-k, m repetitions whose
bits add up to length n, etc. In fact there are an
exponential number <br>
of ways to partition a string as a function of its length. A
regexp may get lucky and match early in the process, but if
there is no match, Perl will try every possibility <br>
before giving up. So be careful with nested
&quot;*&quot;&rsquo;s, &quot;{n,m}&quot;&rsquo;s, and
&quot;+&quot;&rsquo;s. The book Mastering Regular
Expressions by Jeffrey Friedl gives a wonderful discussion
of this and other <br>
efficiency issues.</small></p>

<p style="margin-top: 1em"><small>Possessive quantifiers
<br>
Backtracking during the relentless search for a match may be
a waste of time, particularly when the match is bound to
fail. Consider the simple pattern</small></p>

<p style="margin-top: 1em"><small>/^48</small></p>

<p style="margin-top: 1em"><small>Whenever this is applied
to a string which doesn&rsquo;t quite meet the
pattern&rsquo;s expectations such as &quot;abc &quot; or
&quot;abc def &quot;, the regex engine will backtrack,
approximately once for <br>
each character in the string. But we know that there is no
way around taking all of the initial word characters to
match the first repetition, that all spaces must be eaten by
<br>
the middle part, and the same goes for the second
word.</small></p>

<p style="margin-top: 1em"><small>With the introduction of
the possessive quantifiers in Perl 5.10, we have a way of
instructing the regex engine not to backtrack, with the
usual quantifiers with a &quot;+&quot; appended <br>
to them. This makes them greedy as well as stingy; once they
succeed they won&rsquo;t give anything back to permit
another solution. They have the following
meanings:</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a{n,m}+&quot; means: match at least &quot;n&quot;
times, not more than &quot;m&quot; times, as many times as
possible, and don&rsquo;t give anything up. &quot;a?+&quot;
is short for &quot;a{0,1}+&quot;</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a{n,}+&quot; means: match at least &quot;n&quot;
times, but as many times as possible, and don&rsquo;t give
anything up. &quot;a*+&quot; is short for &quot;a{0,}+&quot;
and &quot;a++&quot; is short for
&quot;a{1,}+&quot;.</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
&quot;a{n}+&quot; means: match exactly &quot;n&quot; times.
It is just there for notational consistency.</small></p>

<p style="margin-top: 1em"><small>These possessive
quantifiers represent a special case of a more general
concept, the independent subexpression, see
below.</small></p>

<p style="margin-top: 1em"><small>As an example where a
possessive quantifier is suitable we consider matching a
quoted string, as it appears in several programming
languages. The backslash is used as an escape <br>
character that indicates that the next character is to be
taken literally, as another character for the string.
Therefore, after the opening quote, we expect a (possibly
empty) <br>
sequence of alternatives: either some character except an
unescaped quote or backslash or an escaped
character.</small></p>


<p style="margin-top: 1em"><small>/&quot;(?:[^&quot;\]++|\.)*+&quot;/;</small></p>

<p style="margin-top: 1em"><small>Building a regexp <br>
At this point, we have all the basic regexp concepts
covered, so let&rsquo;s give a more involved example of a
regular expression. We will build a regexp that matches
numbers.</small></p>

<p style="margin-top: 1em"><small>The first task in
building a regexp is to decide what we want to match and
what we want to exclude. In our case, we want to match both
integers and floating point numbers and we <br>
want to reject any string that isn&rsquo;t a
number.</small></p>

<p style="margin-top: 1em"><small>The next task is to break
the problem down into smaller problems that are easily
converted into a regexp.</small></p>

<p style="margin-top: 1em"><small>The simplest case is
integers. These consist of a sequence of digits, with an
optional sign in front. The digits we can represent with
&quot;+&quot; and the sign can be matched with <br>
&quot;[+-]&quot;. Thus the integer regexp is</small></p>

<p style="margin-top: 1em"><small>/[+-]?+/; # matches
integers</small></p>

<p style="margin-top: 1em"><small>A floating point number
potentially has a sign, an integral part, a decimal point, a
fractional part, and an exponent. One or more of these parts
is optional, so we need to <br>
check out the different possibilities. Floating point
numbers which are in proper form include 123., 0.345, .34,
-1e6, and 25.4E-72. As with integers, the sign out front is
<br>
completely optional and can be matched by &quot;[+-]?&quot;.
We can see that if there is no exponent, floating point
numbers must have a decimal point, otherwise they are
integers. We <br>
might be tempted to model these with &quot;*.*&quot;, but
this would also match just a single decimal point, which is
not a number. So the three cases of floating point number
<br>
without exponent are</small></p>

<p style="margin-top: 1em"><small>/[+-]?+./; # 1., 321.,
etc. <br>
/[+-]?.+/; # .1, .234, etc. <br>
/[+-]?+.+/; # 1.0, 30.56, etc.</small></p>

<p style="margin-top: 1em"><small>These can be combined
into a single regexp with a three-way
alternation:</small></p>

<p style="margin-top: 1em"><small>/[+-]?(+.+|+.|.+)/; #
floating point, no exponent</small></p>

<p style="margin-top: 1em"><small>In this alternation, it
is important to put &rsquo;+.+&rsquo; before
&rsquo;+.&rsquo;. If &rsquo;+.&rsquo; were first, the regexp
would happily match that and ignore the fractional part of
the number.</small></p>

<p style="margin-top: 1em"><small>Now consider floating
point numbers with exponents. The key observation here is
that both integers and numbers with decimal points are
allowed in front of an exponent. Then <br>
exponents, like the overall sign, are independent of whether
we are matching numbers with or without decimal points, and
can be &rsquo;decoupled&rsquo; from the mantissa. The
overall form <br>
of the regexp now becomes clear:</small></p>

<p style="margin-top: 1em"><small>/^(optional sign)(integer
| f.p. mantissa)(optional exponent)$/;</small></p>

<p style="margin-top: 1em"><small>The exponent is an
&quot;e&quot; or &quot;E&quot;, followed by an integer. So
the exponent regexp is</small></p>

<p style="margin-top: 1em"><small>/[eE][+-]?+/; #
exponent</small></p>

<p style="margin-top: 1em"><small>Putting all the parts
together, we get a regexp that matches numbers:</small></p>


<p style="margin-top: 1em"><small>/^[+-]?(+.+|+.|.+|+)([eE][+-]?+)?$/;
# Ta da!</small></p>

<p style="margin-top: 1em"><small>Long regexps like this
may impress your friends, but can be hard to decipher. In
complex situations like this, the &quot;//x&quot; modifier
for a match is invaluable. It allows one to <br>
put nearly arbitrary whitespace and comments into a regexp
without affecting their meaning. Using it, we can rewrite
our &rsquo;extended&rsquo; regexp in the more pleasing
form</small></p>

<p style="margin-top: 1em"><small>/^ <br>
[+-]? # first, match an optional sign <br>
( # then match integers or f.p. mantissas: <br>
+.+ # mantissa of the form a.b <br>
|+. # mantissa of the form a. <br>
|.+ # mantissa of the form .b <br>
|+ # integer of the form a <br>
) <br>
([eE][+-]?+)? # finally, optionally match an exponent <br>
$/x;</small></p>

<p style="margin-top: 1em"><small>If whitespace is mostly
irrelevant, how does one include space characters in an
extended regexp? The answer is to backslash it
&rsquo;&nbsp;&rsquo; or put it in a character class &quot;[
]&quot;. The <br>
same thing goes for pound signs: use &quot;
follows:</small></p>

<p style="margin-top: 1em"><small>/^ <br>
[+-]?&nbsp;* # first, match an optional sign *and space*
<br>
( # then match integers or f.p. mantissas: <br>
+.+ # mantissa of the form a.b <br>
|+. # mantissa of the form a. <br>
|.+ # mantissa of the form .b <br>
|+ # integer of the form a <br>
) <br>
([eE][+-]?+)? # finally, optionally match an exponent <br>
$/x;</small></p>

<p style="margin-top: 1em"><small>In this form, it is
easier to see a way to simplify the alternation.
Alternatives 1, 2, and 4 all start with &quot;+&quot;, so it
could be factored out:</small></p>

<p style="margin-top: 1em"><small>/^ <br>
[+-]?&nbsp;* # first, match an optional sign <br>
( # then match integers or f.p. mantissas: <br>
+ # start out with a ... <br>
( <br>
.* # mantissa of the form a.b or a. <br>
)? # ? takes care of integers of the form a <br>
|.+ # mantissa of the form .b <br>
) <br>
([eE][+-]?+)? # finally, optionally match an exponent <br>
$/x;</small></p>

<p style="margin-top: 1em"><small>or written in the compact
form,</small></p>


<p style="margin-top: 1em"><small>/^[+-]?&nbsp;*(+(.*)?|.+)([eE][+-]?+)?$/;</small></p>

<p style="margin-top: 1em"><small>This is our final regexp.
To recap, we built a regexp by</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
specifying the task in detail,</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; breaking
down the problem into smaller parts,</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot;
translating the small parts into regexps,</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; combining
the regexps,</small></p>

<p style="margin-top: 1em"><small>&Acirc;&middot; and
optimizing the final combined regexp.</small></p>

<p style="margin-top: 1em"><small>These are also the
typical steps involved in writing a computer program. This
makes perfect sense, because regular expressions are
essentially programs written in a little <br>
computer language that specifies patterns.</small></p>

<p style="margin-top: 1em"><small>Using regular expressions
in Perl <br>
The last topic of Part 1 briefly covers how regexps are used
in Perl programs. Where do they fit into Perl
syntax?</small></p>

<p style="margin-top: 1em"><small>We have already
introduced the matching operator in its default
&quot;/regexp/&quot; and arbitrary delimiter
&quot;m!regexp!&quot; forms. We have used the binding
operator &quot;=~&quot; and its negation <br>
&quot;!~&quot; to test for string matches. Associated with
the matching operator, we have discussed the single line
&quot;//s&quot;, multi-line &quot;//m&quot;,
case-insensitive &quot;//i&quot; and extended
&quot;//x&quot; <br>
modifiers. There are a few more things you might want to
know about matching operators.</small></p>

<p style="margin-top: 1em"><small>Prohibiting
substitution</small></p>

<p style="margin-top: 1em"><small>If you change $pattern
after the first substitution happens, Perl will ignore it.
If you don&rsquo;t want any substitutions at all, use the
special delimiter &quot;m&rsquo;&rsquo;&quot;:</small></p>

<p style="margin-top: 1em"><small>@pattern =
(&rsquo;Seuss&rsquo;); <br>
while (&lt;&gt;) { <br>
print if m&rsquo;@pattern&rsquo;; # matches literal
&rsquo;@pattern&rsquo;, not &rsquo;Seuss&rsquo; <br>
}</small></p>

<p style="margin-top: 1em"><small>Similar to strings,
&quot;m&rsquo;&rsquo;&quot; acts like apostrophes on a
regexp; all other &quot;m&quot; delimiters act like quotes.
If the regexp evaluates to the empty string, the regexp in
the last <br>
successful match is used instead. So we have</small></p>

<p style="margin-top: 1em"><small>&quot;dog&quot; =~ /d/; #
&rsquo;d&rsquo; matches <br>
&quot;dogbert =~ //; # this matches the &rsquo;d&rsquo;
regexp used before</small></p>

<p style="margin-top: 1em"><small>Global
matching</small></p>

<p style="margin-top: 1em"><small>The final two modifiers
we will discuss here, &quot;//g&quot; and &quot;//c&quot;,
concern multiple matches. The modifier &quot;//g&quot;
stands for global matching and allows the matching operator
to match <br>
within a string as many times as possible. In scalar
context, successive invocations against a string will have
&quot;//g&quot; jump from match to match, keeping track of
position in the <br>
string as it goes along. You can get or set the position
with the &quot;pos()&quot; function.</small></p>

<p style="margin-top: 1em"><small>The use of
&quot;//g&quot; is shown in the following example. Suppose
we have a string that consists of words separated by spaces.
If we know how many words there are in advance, we <br>
could extract the words using groupings:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;cat dog
house&quot;; # 3 words <br>
$x =~ /^(24 <br>
# $1 = &rsquo;cat&rsquo; <br>
# $2 = &rsquo;dog&rsquo; <br>
# $3 = &rsquo;house&rsquo;</small></p>

<p style="margin-top: 1em"><small>But what if we had an
indeterminate number of words? This is the sort of task
&quot;//g&quot; was made for. To extract all words, form the
simple regexp &quot;(672 <br>
with &quot;/(120</small></p>

<p style="margin-top: 1em"><small>while ($x =~ /(144 <br>
print &quot;Word is $1, ends at position &quot;, pos $x,
&quot;0; <br>
}</small></p>

<p style="margin-top: 1em"><small>prints</small></p>

<p style="margin-top: 1em"><small>Word is cat, ends at
position 3 <br>
Word is dog, ends at position 7 <br>
Word is house, ends at position 13</small></p>

<p style="margin-top: 1em"><small>A failed match or
changing the target string resets the position. If you
don&rsquo;t want the position reset after failure to match,
add the &quot;//c&quot;, as in &quot;/regexp/gc&quot;. The
current <br>
position in the string is associated with the string, not
the regexp. This means that different strings have different
positions and their respective positions can be set or <br>
read independently.</small></p>

<p style="margin-top: 1em"><small>In list context,
&quot;//g&quot; returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole
regexp. So if we wanted just the words, we could
use</small></p>

<p style="margin-top: 1em"><small>@words = ($x =~ /(408
<br>
# $words[0] = &rsquo;cat&rsquo; <br>
# $words[1] = &rsquo;dog&rsquo; <br>
# $words[2] = &rsquo;house&rsquo;</small></p>

<p style="margin-top: 1em"><small>Closely associated with
the &quot;//g&quot; modifier is the &quot;G&quot; anchor.
The &quot;G&quot; anchor matches at the point where the
previous &quot;//g&quot; match left off. &quot;G&quot;
allows us to easily do <br>
context-sensitive matching:</small></p>

<p style="margin-top: 1em"><small>$metric = 1; # use metric
units <br>
... <br>
$x = &lt;FILE&gt;; # read in measurement <br>
$x =~ /^([+-]?+)/g; # get magnitude <br>
$weight = $1; <br>
if ($metric) { # error checking <br>
print &quot;Units error!&quot; unless $x =~ /Gkg./g; <br>
} <br>
else { <br>
print &quot;Units error!&quot; unless $x =~ /Glbs./g; <br>
} <br>
$x =~ /Gidget|sprocket)/g; # continue processing</small></p>

<p style="margin-top: 1em"><small>The combination of
&quot;//g&quot; and &quot;G&quot; allows us to process the
string a bit at a time and use arbitrary Perl logic to
decide what to do next. Currently, the &quot;G&quot; anchor
is only <br>
fully supported when used to anchor to the start of the
pattern.</small></p>

<p style="margin-top: 1em"><small>&quot;G&quot; is also
invaluable in processing fixed-length records with regexps.
Suppose we have a snippet of coding region DNA, encoded as
base pair letters &quot;ATCGTTGAAT...&quot; and we want <br>
to find all the stop codons &quot;TGA&quot;. In a coding
region, codons are 3-letter sequences, so we can think of
the DNA snippet as a sequence of 3-letter records. The naive
regexp</small></p>

<p style="margin-top: 1em"><small># expanded, this is
&quot;ATC GTT GAA TGC AAA TGA CAT GAC&quot; <br>
$dna = &quot;ATCGTTGAATGCAAATGACATGAC&quot;; <br>
$dna =~ /TGA/;</small></p>

<p style="margin-top: 1em"><small>doesn&rsquo;t work; it
may match a &quot;TGA&quot;, but there is no guarantee that
the match is aligned with codon boundaries, e.g., the
substring &quot;GTT GAA&quot; gives a match. A better
solution is</small></p>

<p style="margin-top: 1em"><small>while ($dna =~ /(48 <br>
print &quot;Got a TGA stop codon at position &quot;, pos
$dna, &quot;0; <br>
}</small></p>

<p style="margin-top: 1em"><small>which prints</small></p>

<p style="margin-top: 1em"><small>Got a TGA stop codon at
position 18 <br>
Got a TGA stop codon at position 23</small></p>

<p style="margin-top: 1em"><small>Position 18 is good, but
position 23 is bogus. What happened?</small></p>

<p style="margin-top: 1em"><small>The answer is that our
regexp works well until we get past the last real match.
Then the regexp will fail to match a synchronized
&quot;TGA&quot; and start stepping ahead one character <br>
position at a time, not what we want. The solution is to use
&quot;G&quot; to anchor the match to the codon
alignment:</small></p>

<p style="margin-top: 1em"><small>while ($dna =~ /G(24 <br>
print &quot;Got a TGA stop codon at position &quot;, pos
$dna, &quot;0; <br>
}</small></p>

<p style="margin-top: 1em"><small>This prints</small></p>

<p style="margin-top: 1em"><small>Got a TGA stop codon at
position 18</small></p>

<p style="margin-top: 1em"><small>which is the correct
answer. This example illustrates that it is important not
only to match what is desired, but to reject what is not
desired.</small></p>

<p style="margin-top: 1em"><small>(There are other regexp
modifiers that are available, such as &quot;//o&quot;, but
their specialized uses are beyond the scope of this
introduction. )</small></p>

<p style="margin-top: 1em"><small>Search and
replace</small></p>

<p style="margin-top: 1em"><small>Regular expressions also
play a big role in search and replace operations in Perl.
Search and replace is accomplished with the &quot;s///&quot;
operator. The general form is <br>
&quot;s/regexp/replacement/modifiers&quot;, with everything
we know about regexps and modifiers applying in this case as
well. The &quot;replacement&quot; is a Perl double-quoted
string that <br>
replaces in the string whatever is matched with the
&quot;regexp&quot;. The operator &quot;=~&quot; is also used
here to associate a string with &quot;s///&quot;. If
matching against $_, the &quot;$_ =~&quot; can be <br>
dropped. If there is a match, &quot;s///&quot; returns the
number of substitutions made; otherwise it returns false.
Here are a few examples:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;Time to feed
the cat!&quot;; <br>
$x =~ s/cat/hacker/; # $x contains &quot;Time to feed the
hacker!&quot; <br>
if ($x =~ s/^(Time.*hacker)!$/$1 now!/) { <br>
$more_insistent = 1; <br>
} <br>
$y = &quot;&rsquo;quoted words&rsquo;&quot;; <br>
$y =~ s/^&rsquo;(.*)&rsquo;$/$1/; # strip single quotes,
<br>
# $y contains &quot;quoted words&quot;</small></p>

<p style="margin-top: 1em"><small>In the last example, the
whole string was matched, but only the part inside the
single quotes was grouped. With the &quot;s///&quot;
operator, the matched variables $1, $2, etc. are <br>
immediately available for use in the replacement expression,
so we use $1 to replace the quoted string with just what was
quoted. With the global modifier, &quot;s///g&quot; will
search <br>
and replace all occurrences of the regexp in the
string:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;I batted 4 for
4&quot;; <br>
$x =~ s/4/four/; # doesn&rsquo;t do it all: <br>
# $x contains &quot;I batted four for 4&quot; <br>
$x = &quot;I batted 4 for 4&quot;; <br>
$x =~ s/4/four/g; # does it all: <br>
# $x contains &quot;I batted four for four&quot;</small></p>

<p style="margin-top: 1em"><small>If you prefer
&rsquo;regex&rsquo; over &rsquo;regexp&rsquo; in this
tutorial, you could use the following program to replace
it:</small></p>

<p style="margin-top: 1em"><small>% cat &gt; simple_replace
<br>
#!/usr/bin/perl <br>
$regexp = shift; <br>
$replacement = shift; <br>
while (&lt;&gt;) { <br>
s/$regexp/$replacement/g; <br>
print; <br>
} <br>
^D</small></p>

<p style="margin-top: 1em"><small>% simple_replace regexp
regex perlretut.pod</small></p>

<p style="margin-top: 1em"><small>In
&quot;simple_replace&quot; we used the &quot;s///g&quot;
modifier to replace all occurrences of the regexp on each
line. (Even though the regular expression appears in a loop,
Perl is smart <br>
enough to compile it only once.) As with
&quot;simple_grep&quot;, both the &quot;print&quot; and the
&quot;s/$regexp/$replacement/g&quot; use $_
implicitly.</small></p>

<p style="margin-top: 1em"><small>If you don&rsquo;t want
&quot;s///&quot; to change your original variable you can
use the non-destructive substitute modifier,
&quot;s///r&quot;. This changes the behavior so that
&quot;s///r&quot; returns the <br>
final substituted string (instead of the number of
substitutions):</small></p>

<p style="margin-top: 1em"><small>$x = &quot;I like
dogs.&quot;; <br>
$y = $x =~ s/dogs/cats/r; <br>
print &quot;$x $y0;</small></p>

<p style="margin-top: 1em"><small>That example will print
&quot;I like dogs. I like cats&quot;. Notice the original $x
variable has not been affected. The overall result of the
substitution is instead stored in $y. If the <br>
substitution doesn&rsquo;t affect anything then the original
string is returned:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;I like
dogs.&quot;; <br>
$y = $x =~ s/elephants/cougars/r; <br>
print &quot;$x $y0; # prints &quot;I like dogs. I like
dogs.&quot;</small></p>

<p style="margin-top: 1em"><small>One other interesting
thing that the &quot;s///r&quot; flag allows is chaining
substitutions:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;Cats are
great.&quot;; <br>
print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~
s/Frogs/Hedgehogs/r, &quot;0; <br>
# prints &quot;Hedgehogs are great.&quot;</small></p>

<p style="margin-top: 1em"><small>A modifier available
specifically to search and replace is the &quot;s///e&quot;
evaluation modifier. &quot;s///e&quot; treats the
replacement text as Perl code, rather than a double-quoted
string. <br>
The value that the code returns is substituted for the
matched substring. &quot;s///e&quot; is useful if you need
to do a bit of computation in the process of replacing text.
This <br>
example counts character frequencies in a line:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;Bill the
cat&quot;; <br>
$x =~ s/(.)/$chars{$1}++;$1/eg; # final $1 replaces char
with itself <br>
print &quot;frequency of &rsquo;$_&rsquo; is $chars{$_}0
<br>
foreach (sort {$chars{$b} &lt;=&gt; $chars{$a}} keys
%chars);</small></p>

<p style="margin-top: 1em"><small>This prints</small></p>

<p style="margin-top: 1em"><small>frequency of &rsquo;
&rsquo; is 2 <br>
frequency of &rsquo;t&rsquo; is 2 <br>
frequency of &rsquo;l&rsquo; is 2 <br>
frequency of &rsquo;B&rsquo; is 1 <br>
frequency of &rsquo;c&rsquo; is 1 <br>
frequency of &rsquo;e&rsquo; is 1 <br>
frequency of &rsquo;h&rsquo; is 1 <br>
frequency of &rsquo;i&rsquo; is 1 <br>
frequency of &rsquo;a&rsquo; is 1</small></p>

<p style="margin-top: 1em"><small>As with the match
&quot;m//&quot; operator, &quot;s///&quot; can use other
delimiters, such as &quot;s!!!&quot; and &quot;s{}{}&quot;,
and even &quot;s{}//&quot;. If single quotes are used
&quot;s&rsquo;&rsquo;&rsquo;&quot;, then the regexp and <br>
replacement are treated as single-quoted strings and there
are no variable substitutions. &quot;s///&quot; in list
context returns the same thing as in scalar context, i.e.,
the number of <br>
matches.</small></p>

<p style="margin-top: 1em"><small>The split
function</small></p>

<p style="margin-top: 1em"><small>The &quot;split()&quot;
function is another place where a regexp is used.
&quot;split /regexp/, string, limit&quot; separates the
&quot;string&quot; operand into a list of substrings and
returns that list. <br>
The regexp must be designed to match whatever constitutes
the separators for the desired substrings. The
&quot;limit&quot;, if present, constrains splitting into no
more than &quot;limit&quot; <br>
number of strings. For example, to split a string into
words, use</small></p>

<p style="margin-top: 1em"><small>$x = &quot;Calvin and
Hobbes&quot;; <br>
@words = split /, $x; # $word[0] = &rsquo;Calvin&rsquo; <br>
# $word[1] = &rsquo;and&rsquo; <br>
# $word[2] = &rsquo;Hobbes&rsquo;</small></p>

<p style="margin-top: 1em"><small>If the empty regexp
&quot;//&quot; is used, the regexp always matches and the
string is split into individual characters. If the regexp
has groupings, then the resulting list contains the <br>
matched substrings from the groupings as well. For
instance,</small></p>

<p style="margin-top: 1em"><small>$x =
&quot;/usr/bin/perl&quot;; <br>
@dirs = split m!/!, $x; # $dirs[0] = &rsquo;&rsquo; <br>
# $dirs[1] = &rsquo;usr&rsquo; <br>
# $dirs[2] = &rsquo;bin&rsquo; <br>
# $dirs[3] = &rsquo;perl&rsquo; <br>
@parts = split m!(/)!, $x; # $parts[0] = &rsquo;&rsquo; <br>
# $parts[1] = &rsquo;/&rsquo; <br>
# $parts[2] = &rsquo;usr&rsquo; <br>
# $parts[3] = &rsquo;/&rsquo; <br>
# $parts[4] = &rsquo;bin&rsquo; <br>
# $parts[5] = &rsquo;/&rsquo; <br>
# $parts[6] = &rsquo;perl&rsquo;</small></p>

<p style="margin-top: 1em"><small>Since the first character
of $x matched the regexp, &quot;split&quot; prepended an
empty initial element to the list.</small></p>

<p style="margin-top: 1em"><small>If you have read this
far, congratulations! You now have all the basic tools
needed to use regular expressions to solve a wide range of
text processing problems. If this is your <br>
first time through the tutorial, why not stop here and play
around with regexps a while.... Part 2 concerns the more
esoteric aspects of regular expressions and those concepts
<br>
certainly aren&rsquo;t needed right at the
start.</small></p>

<p style="margin-top: 1em"><small>Part 2: Power tools <br>
OK, you know the basics of regexps and you want to know
more. If matching regular expressions is analogous to a walk
in the woods, then the tools discussed in Part 1 are <br>
analogous to topo maps and a compass, basic tools we use all
the time. Most of the tools in part 2 are analogous to flare
guns and satellite phones. They aren&rsquo;t used too often
<br>
on a hike, but when we are stuck, they can be
invaluable.</small></p>

<p style="margin-top: 1em"><small>What follows are the more
advanced, less used, or sometimes esoteric capabilities of
Perl regexps. In Part 2, we will assume you are comfortable
with the basics and concentrate <br>
on the advanced features.</small></p>

<p style="margin-top: 1em"><small>More on characters,
strings, and character classes <br>
There are a number of escape sequences and character classes
that we haven&rsquo;t covered yet.</small></p>

<p style="margin-top: 1em"><small>There are several escape
sequences that convert characters or strings between upper
and lower case, and they are also available within patterns.
&quot;nd &quot;&quot; convert the next <br>
character to lower or upper case, respectively:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;perl&quot;;
<br>
$string =~ /$x/; # matches &rsquo;Perl&rsquo; in $string
<br>
$x = &quot;M(rs?|s)\.&quot;; # note the double backslash
<br>
$string =~ //; # matches &rsquo;mr.&rsquo;,
&rsquo;mrs.&rsquo;, and &rsquo;ms.&rsquo;,</small></p>

<p style="margin-top: 1em"><small>A &quot;r &quot;U&quot;
indicates a lasting conversion of case, until terminated by
&quot;</small></p>

<p style="margin-top: 1em"><small>$x = &quot;This word is
in lower case:SHOUT <br>
$x =~ /shout/; # matches <br>
$x = &quot;I STILL KEYPUNCH CARDS FOR MY 360&quot; <br>
$x =~ /Ukeypunch/; # matches punch card string</small></p>

<p style="margin-top: 1em"><small>If there is no &quot;
<br>
characters to lowercase.</small></p>

<p style="margin-top: 1em"><small>Control characters can be
escaped with &quot; characters. For instance,</small></p>

<p style="margin-top: 1em"><small>$x = &quot;QThat
!^*&amp;%~&amp; cat!&quot;; <br>
$x =~ /Q!^*&amp;%~&amp;; # check for rough
language</small></p>

<p style="margin-top: 1em"><small>It does not protect
&quot;$&quot; or &quot;@&quot;, so that variables can still
be substituted.</small></p>

<p style="margin-top: 1em"><small>&quot;Q&quot;, &quot;
&quot; &quot;U&quot;, &quot;&quot; and &quot; <br>
embedded directly in a program, but not when contained in a
string that is interpolated in a pattern.</small></p>

<p style="margin-top: 1em"><small>With the advent of 5.6.0,
Perl regexps can handle more than just the standard ASCII
character set. Perl now supports Unicode, a standard for
representing the alphabets from <br>
virtually all of the world&rsquo;s written languages, and a
host of symbols. Perl&rsquo;s text strings are Unicode
strings, so they can contain characters with a value
(codepoint or <br>
character number) higher than 255.</small></p>

<p style="margin-top: 1em"><small>What does this mean for
regexps? Well, regexp users don&rsquo;t need to know much
about Perl&rsquo;s internal representation of strings. But
they do need to know 1) how to represent Unicode <br>
characters in a regexp and 2) that a matching operation will
treat the string to be searched as a sequence of characters,
not bytes. The answer to 1) is that Unicode characters <br>
greater than &quot;chr(255)&quot; are represented using the
&quot;ex}&quot; notation, because hex (without curly braces)
doesn&rsquo;t go further than 255. (Starting in Perl 5.14,
if you&rsquo;re an <br>
octal fan, you can also use &quot;)</small></p>

<p style="margin-top: 1em"><small>/}/; # match a Unicode
smiley face :)</small></p>

<p style="margin-top: 1em"><small>NOTE: In Perl 5.6.0 it
used to be that one needed to say &quot;use utf8&quot; to
use any Unicode features. This is no more the case: for
almost all Unicode processing, the explicit &quot;utf8&quot;
<br>
pragma is not needed. (The only case where it matters is if
your Perl script is in Unicode and encoded in UTF-8, then an
explicit &quot;use utf8&quot; is needed.)</small></p>

<p style="margin-top: 1em"><small>Figuring out the
hexadecimal sequence of a Unicode character you want or
deciphering someone else&rsquo;s hexadecimal Unicode regexp
is about as much fun as programming in machine <br>
code. So another way to specify Unicode characters is to use
the named character escape sequence &quot;ame}&quot;. name
is a name for the Unicode character, as specified in the
<br>
Unicode standard. For instance, if we wanted to represent or
match the astrological sign for the planet Mercury, we could
use</small></p>

<p style="margin-top: 1em"><small>$x =
&quot;abcERCURY}def&quot;; <br>
$x =~ /ERCURY}/; # matches</small></p>

<p style="margin-top: 1em"><small>One can also use
&quot;short&quot; names:</small></p>

<p style="margin-top: 1em"><small>print &quot;REEK SMALL
LETTER SIGMA} is called sigma.0; <br>
print &quot;reek:Sigma} is an upper-case
sigma.0;</small></p>

<p style="margin-top: 1em"><small>You can also restrict
names to a certain alphabet by specifying the charnames
pragma:</small></p>

<p style="margin-top: 1em"><small>use charnames qw(greek);
<br>
print &quot;igma} is Greek sigma0;</small></p>

<p style="margin-top: 1em"><small>An index of character
names is available on-line from the Unicode Consortium,
&lt;http://www.unicode.org/charts/charindex.html&gt;;
explanatory material with links to other resources <br>
at
&lt;http://www.unicode.org/standard/where&gt;.</small></p>

<p style="margin-top: 1em"><small>The answer to requirement
2) is, as of 5.6.0, that a regexp (mostly) uses Unicode
characters. (The &quot;mostly&quot; is for messy backward
compatibility reasons, but starting in Perl <br>
5.14, any regex compiled in the scope of a &quot;use feature
&rsquo;unicode_strings&rsquo;&quot; (which is automatically
turned on within the scope of a &quot;use 5.012&quot; or
higher) will turn that &quot;mostly&quot; <br>
into &quot;always&quot;. If you want to handle Unicode
properly, you should ensure that
&rsquo;unicode_strings&rsquo; is turned on.) Internally,
this is encoded to bytes using either UTF-8 or a <br>
native 8 bit encoding, depending on the history of the
string, but conceptually it is a sequence of characters, not
bytes. See perlunitut for a tutorial about that.</small></p>

<p style="margin-top: 1em"><small>Let us now discuss
Unicode character classes. Just as with Unicode characters,
there are named Unicode character classes represented by the
&quot;{name}&quot; escape sequence. Closely <br>
associated is the &quot;P{name}&quot; character class, which
is the negation of the &quot;{name}&quot; class. For
example, to match lower and uppercase
characters,</small></p>

<p style="margin-top: 1em"><small>$x = &quot;BOB&quot;;
<br>
$x =~ /^{IsUpper}/; # matches, uppercase char class <br>
$x =~ /^P{IsUpper}/; # doesn&rsquo;t match, char class sans
uppercase <br>
$x =~ /^{IsLower}/; # doesn&rsquo;t match, lowercase char
class <br>
$x =~ /^P{IsLower}/; # matches, char class sans
lowercase</small></p>

<p style="margin-top: 1em"><small>(The &quot;Is&quot; is
optional.)</small></p>

<p style="margin-top: 1em"><small>Here is the association
between some Perl named classes and the traditional Unicode
classes:</small></p>

<p style="margin-top: 1em"><small>Perl class name Unicode
class name or regular expression</small></p>

<p style="margin-top: 1em"><small>IsAlpha /^[LM]/ <br>
IsAlnum /^[LMN]/ <br>
IsASCII $code &lt;= 127 <br>
IsCntrl /^C/ <br>
IsBlank $code =~ /^(0020|0009)$/ || /^Z[^lp]/ <br>
IsDigit Nd <br>
IsGraph /^([LMNPS]|Co)/ <br>
IsLower Ll <br>
IsPrint /^([LMNPS]|Co|Zs)/ <br>
IsPunct /^P/ <br>
IsSpace /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/
<br>
IsSpacePerl /^Z/ || ($code =~
/^(0009|000A|000C|000D|0085|2028|2029)$/ <br>
IsUpper /^L[ut]/ <br>
IsWord /^[LMN]/ || $code eq &quot;005F&quot; <br>
IsXDigit $code =~ /^00(3[0-9]|[46][1-6])$/</small></p>

<p style="margin-top: 1em"><small>You can also use the
official Unicode class names with &quot;&quot; and
&quot;P&quot;, like &quot;{L}&quot; for Unicode
&rsquo;letters&rsquo;, &quot;{Lu}&quot; for uppercase
letters, or &quot;P{Nd}&quot; for non-digits. If a
&quot;name&quot; <br>
is just one letter, the braces can be dropped. For instance,
&quot;M&quot; is the character class of Unicode
&rsquo;marks&rsquo;, for example accent marks. For the full
list see perlunicode.</small></p>

<p style="margin-top: 1em"><small>Unicode has also been
separated into various sets of characters which you can test
with &quot;{...}&quot; (in) and &quot;P{...}&quot; (not in).
To test whether a character is (or is not) an <br>
element of a script you would use the script name, for
example &quot;{Latin}&quot;, &quot;{Greek}&quot;, or
&quot;P{Katakana}&quot;.</small></p>

<p style="margin-top: 1em"><small>What we have described so
far is the single form of the &quot;{...}&quot; character
classes. There is also a compound form which you may run
into. These look like &quot;{name=value}&quot; or <br>
&quot;{name:value}&quot; (the equals sign and colon can be
used interchangeably). These are more general than the
single form, and in fact most of the single forms are just
Perl-defined <br>
shortcuts for common compound forms. For example, the script
examples in the previous paragraph could be written
equivalently as &quot;{Script=Latin}&quot;,
&quot;{Script:Greek}&quot;, and <br>
&quot;P{script=katakana}&quot; (case is irrelevant between
the &quot;{}&quot; braces). You may never have to use the
compound forms, but sometimes it is necessary, and their use
can make your code <br>
easier to understand.</small></p>

<p style="margin-top: 1em"><small>&quot;logical
character&quot;: what appears to be a single character, <br>
but may be represented internally by more than one. As an
example, using the Unicode full names, e.g., &quot;A +
COMBINING RING&quot; is a grapheme cluster with base
character &quot;A&quot; and <br>
combining character &quot;COMBINING RING&quot;, which
translates in Danish to A with the circle atop it, as in the
word Angstrom.</small></p>

<p style="margin-top: 1em"><small>For the full and latest
information about Unicode see the latest Unicode standard,
or the Unicode Consortium&rsquo;s website
&lt;http://www.unicode.org&gt;</small></p>

<p style="margin-top: 1em"><small>As if all those classes
weren&rsquo;t enough, Perl also defines POSIX-style
character classes. These have the form &quot;[:name:]&quot;,
with &quot;name&quot; the name of the POSIX class. The POSIX
<br>
classes are &quot;alpha&quot;, &quot;alnum&quot;,
&quot;ascii&quot;, &quot;cntrl&quot;, &quot;digit&quot;,
&quot;graph&quot;, &quot;lower&quot;, &quot;print&quot;,
&quot;punct&quot;, &quot;space&quot;, &quot;upper&quot;, and
&quot;xdigit&quot;, and two extensions, &quot;word&quot; (a
Perl extension to match <br>
&quot;168blank&quot; (a GNU extension). The &quot;//a&quot;
modifier restricts these to matching just in the ASCII
range; otherwise they can match the same as their
corresponding Perl <br>
Unicode classes: &quot;[:upper:]&quot; is the same as
&quot;{IsUpper}&quot;, etc. (There are some exceptions and
gotchas with this; see perlrecharclass for a full
discussion.) The &quot;[:digit:]&quot;, <br>
&quot;[:word:]&quot;, and &quot;[:space:]&quot; correspond
to the familiar &quot;&quot;, &quot;144haracter classes. To
negate a POSIX class, put a &quot;^&quot; in front of the
name, so that, e.g., <br>
&quot;[:^digit:]&quot; corresponds to
&quot;P{IsDigit}&quot;. The Unicode and POSIX character
classes can be used just like &quot;&quot;, with the
exception that POSIX character <br>
classes can only be used inside of a character
class:</small></p>

<p style="margin-top: 1em"><small>/bc[:digit:]xyz]/; #
match a,b,c,x,y,z, or a digit <br>
/^=item:digit:]]/; # match &rsquo;=item&rsquo;, <br>
# followed by a space and a digit <br>
/bc{IsDigit}xyz]; # match a,b,c,x,y,z, or a digit <br>
/^=itemIsDigit}/; # match &rsquo;=item&rsquo;, <br>
# followed by a space and a digit</small></p>

<p style="margin-top: 1em"><small>Whew! That is all the
rest of the characters and character classes.</small></p>

<p style="margin-top: 1em"><small>Compiling and saving
regular expressions <br>
In Part 1 we mentioned that Perl compiles a regexp into a
compact sequence of opcodes. Thus, a compiled regexp is a
data structure that can be stored once and used again and
<br>
again. The regexp quote &quot;qr//&quot; does exactly that:
&quot;qr/string/&quot; compiles the &quot;string&quot; as a
regexp and transforms the result into a form that can be
assigned to a variable:</small></p>

<p style="margin-top: 1em"><small>$reg = qr/foo+bar?/; #
reg contains a compiled regexp</small></p>

<p style="margin-top: 1em"><small>Then $reg can be used as
a regexp:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;fooooba&quot;;
<br>
$x =~ $reg; # matches, just like /foo+bar?/ <br>
$x =~ /$reg/; # same thing, alternate form</small></p>

<p style="margin-top: 1em"><small>$reg can also be
interpolated into a larger regexp:</small></p>

<p style="margin-top: 1em"><small>$x =~ /(abc)?$reg/; #
still matches</small></p>

<p style="margin-top: 1em"><small>As with the matching
operator, the regexp quote can use different delimiters,
e.g., &quot;qr!!&quot;, &quot;qr{}&quot; or
&quot;qr~~&quot;. Apostrophes as delimiters
(&quot;qr&rsquo;&rsquo;&quot;) inhibit any
interpolation.</small></p>

<p style="margin-top: 1em"><small>Pre-compiled regexps are
useful for creating dynamic matches that don&rsquo;t need to
be recompiled each time they are encountered. Using
pre-compiled regexps, we write a &quot;grep_step&quot; <br>
program which greps for a sequence of patterns, advancing to
the next pattern as soon as one has been
satisfied.</small></p>

<p style="margin-top: 1em"><small>% cat &gt; grep_step <br>
#!/usr/bin/perl <br>
# grep_step - match &lt;number&gt; regexps, one after the
other <br>
# usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1
file2 ...</small></p>

<p style="margin-top: 1em"><small>$number = shift; <br>
$regexp[$_] = shift foreach (0..$number-1); <br>
@compiled = map qr/$_/, @regexp; <br>
while ($line = &lt;&gt;) { <br>
if ($line =~ /$compiled[0]/) { <br>
print $line; <br>
shift @compiled; <br>
last unless @compiled; <br>
} <br>
} <br>
^D</small></p>

<p style="margin-top: 1em"><small>% grep_step 3 shift print
last grep_step <br>
$number = shift; <br>
print $line; <br>
last unless @compiled;</small></p>

<p style="margin-top: 1em"><small>Storing pre-compiled
regexps in an array @compiled allows us to simply loop
through the regexps without any recompilation, thus gaining
flexibility without sacrificing speed.</small></p>

<p style="margin-top: 1em"><small>Composing regular
expressions at runtime <br>
Backtracking is more efficient than repeated tries with
different regular expressions. If there are several regular
expressions and a match with any of them is acceptable, then
<br>
it is possible to combine them into a set of alternatives.
If the individual expressions are input data, this can be
done by programming a join operation. We&rsquo;ll exploit
this <br>
idea in an improved version of the &quot;simple_grep&quot;
program: a program that matches multiple
patterns:</small></p>

<p style="margin-top: 1em"><small>% cat &gt; multi_grep
<br>
#!/usr/bin/perl <br>
# multi_grep - match any of &lt;number&gt; regexps <br>
# usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1
file2 ...</small></p>

<p style="margin-top: 1em"><small>$number = shift; <br>
$regexp[$_] = shift foreach (0..$number-1); <br>
$pattern = join &rsquo;|&rsquo;, @regexp;</small></p>

<p style="margin-top: 1em"><small>while ($line = &lt;&gt;)
{ <br>
print $line if $line =~ /$pattern/; <br>
} <br>
^D</small></p>

<p style="margin-top: 1em"><small>% multi_grep 2 shift for
multi_grep <br>
$number = shift; <br>
$regexp[$_] = shift foreach (0..$number-1);</small></p>

<p style="margin-top: 1em"><small>Sometimes it is
advantageous to construct a pattern from the input that is
to be analyzed and use the permissible values on the left
hand side of the matching operations. As an <br>
example for this somewhat paradoxical situation, let&rsquo;s
assume that our input contains a command verb which should
match one out of a set of available command verbs, with the
<br>
additional twist that commands may be abbreviated as long as
the given string is unique. The program below demonstrates
the basic algorithm.</small></p>

<p style="margin-top: 1em"><small>% cat &gt; keymatch <br>
#!/usr/bin/perl <br>
$kwds = &rsquo;copy compare list print&rsquo;; <br>
while( $command = &lt;&gt; ){ <br>
$command =~ s/^; # trim leading and trailing spaces c o m m
a <br>
if( ( @matches = $kwds =~ /n d 2 8 8 <br>
print &quot;command: &rsquo;@matches&rsquo;0; <br>
} elsif( @matches == 0 ){ <br>
print &quot;no such command: &rsquo;$command&rsquo;0; <br>
} else { <br>
print &quot;not unique: &rsquo;$command&rsquo; (could be one
of: @matches)0; <br>
} <br>
} <br>
^D</small></p>

<p style="margin-top: 1em"><small>% keymatch <br>
li <br>
command: &rsquo;list&rsquo; <br>
co <br>
not unique: &rsquo;co&rsquo; (could be one of: copy compare)
<br>
printer <br>
no such command: &rsquo;printer&rsquo;</small></p>

<p style="margin-top: 1em"><small>Rather than trying to
match the input against the keywords, we match the combined
set of keywords against the $ c o m m input. The pattern
matching operation &quot;$kwds =~ /a n d 9 6 <br>
does several things at the same time. It makes sure that ) .
I t t o l e r a t e s a b b r e v the given command begins
where a keyword begins (&quot;i336 a t i o n s d u e t o t h
e a d d e d <br>
the number of matches (&quot;scalar @matches&quot;) and all
the keywords that were actually matched. You could hardly
ask for more.</small></p>

<p style="margin-top: 1em"><small>Embedding comments and
modifiers in a regular expression <br>
Starting with this section, we will be discussing
Perl&rsquo;s set of extended patterns. These are extensions
to the traditional regular expression syntax that provide
powerful new <br>
tools for pattern matching. We have already seen extensions
in the form of the minimal matching constructs
&quot;??&quot;, &quot;*?&quot;, &quot;+?&quot;,
&quot;{n,m}?&quot;, and &quot;{n,}?&quot;. Most of the
extensions below <br>
have the form &quot;(?char...)&quot;, where the
&quot;char&quot; is a character that determines the type of
extension.</small></p>

<p style="margin-top: 1em"><small>The first extension is an
embedded comment &quot;(?#text)&quot;. This embeds a comment
into the regular expression without affecting its meaning.
The comment should not have any closing <br>
parentheses in the text. An example is</small></p>

<p style="margin-top: 1em"><small>/(?# Match an
integer:)[+-]?+/;</small></p>

<p style="margin-top: 1em"><small>This style of commenting
has been largely superseded by the raw, freeform commenting
that is allowed with the &quot;//x&quot;
modifier.</small></p>

<p style="margin-top: 1em"><small>Most modifiers, such as
&quot;//i&quot;, &quot;//m&quot;, &quot;//s&quot; and
&quot;//x&quot; (or any combination thereof) can also be
embedded in a regexp using &quot;(?i)&quot;,
&quot;(?m)&quot;, &quot;(?s)&quot;, and &quot;(?x)&quot;.
For instance,</small></p>

<p style="margin-top: 1em"><small>/(?i)yes/; # match
&rsquo;yes&rsquo; case insensitively <br>
/yes/i; # same thing <br>
/(?x)( # freeform version of an integer regexp <br>
[+-]? # match an optional sign <br>
+ # match a sequence of digits <br>
) <br>
/x;</small></p>

<p style="margin-top: 1em"><small>Embedded modifiers can
have two important advantages over the usual modifiers.
Embedded modifiers allow a custom set of modifiers to each
regexp pattern. This is great for <br>
matching an array of regexps that must have different
modifiers:</small></p>

<p style="margin-top: 1em"><small>$pattern[0] =
&rsquo;(?i)doctor&rsquo;; <br>
$pattern[1] = &rsquo;Johnson&rsquo;; <br>
... <br>
while (&lt;&gt;) { <br>
foreach $patt (@pattern) { <br>
print if /$patt/; <br>
} <br>
}</small></p>

<p style="margin-top: 1em"><small>The second advantage is
that embedded modifiers (except &quot;//p&quot;, which
modifies the entire regexp) only affect the regexp inside
the group the embedded modifier is contained in. <br>
So grouping can be used to localize the modifier&rsquo;s
effects:</small></p>

<p style="margin-top: 1em"><small>/Answer: ((?i)yes)/; #
matches &rsquo;Answer: yes&rsquo;, &rsquo;Answer:
YES&rsquo;, etc.</small></p>

<p style="margin-top: 1em"><small>Embedded modifiers can
also turn off any modifiers already present by using, e.g.,
&quot;(?-i)&quot;. Modifiers can also be combined into a
single expression, e.g., &quot;(?s-i)&quot; turns on <br>
single line mode and turns off case
insensitivity.</small></p>

<p style="margin-top: 1em"><small>Embedded modifiers may
also be added to a non-capturing grouping.
&quot;(?i-m:regexp)&quot; is a non-capturing grouping that
matches &quot;regexp&quot; case insensitively and turns off
multi-line <br>
mode.</small></p>

<p style="margin-top: 1em"><small>Looking ahead and looking
behind <br>
This section concerns the lookahead and lookbehind
assertions. First, a little background.</small></p>

<p style="margin-top: 1em"><small>In Perl regular
expressions, most regexp elements &rsquo;eat up&rsquo; a
certain amount of string when they match. For instance, the
regexp element &quot;[abc}]&quot; eats up one character of
the <br>
string when it matches, in the sense that Perl moves to the
next character position in the string after the match. There
are some elements, however, that don&rsquo;t eat up
characters <br>
(advance the character position) if they match. The examples
we have seen so far are the anchors. The anchor
&quot;^&quot; matches the beginning of the line, but
doesn&rsquo;t eat any m a t c h e s w h e r e v e r a <br>
characters. Similarly, the word boundary anchor &quot;c1968
h a r a c t e r m a t c h i n g <br>
Anchors are examples of zero-width assertions: zero-width,
because they consume no characters, and assertions, because
they test some property of the string. In the context of
<br>
our walk in the woods analogy to regexp matching, most
regexp elements move us along a trail, but anchors have us
stop a moment and check our surroundings. If the local <br>
environment checks out, we can proceed forward. But if the
local environment doesn&rsquo;t satisfy us, we must
backtrack.</small></p>

<p style="margin-top: 1em"><small>Checking the environment
entails either looking ahead on the trail, looking behind,
or both. &quot;^&quot; looks behind, to see that there are
no characters before. &quot;$&quot; looks ahead, to l o o k
s b o t h a h e a d a n d b e h i n d , t o s e e i f t h e
<br>
see that there are no characters after.
&quot;cword-ness&quot;. h a r a c t e r s o n e i t h e r s
i d e d i f f e r i n t h e i r</small></p>

<p style="margin-top: 1em"><small>The lookahead and
lookbehind assertions are generalizations of the anchor
concept. Lookahead and lookbehind are zero-width assertions
that let us specify which characters we <br>
want to test for. The lookahead assertion is denoted by
&quot;(?=regexp)&quot; and the lookbehind assertion is
denoted by &quot;(?&lt;=fixed-regexp)&quot;. Some examples
are</small></p>

<p style="margin-top: 1em"><small>$x = &quot;I catch the
housecat &rsquo;Tom-cat&rsquo; with catnip&quot;; <br>
$x =~ /cat(?=/; # matches &rsquo;cat&rsquo; in
&rsquo;housecat&rsquo; <br>
@catwords = ($x =~ /(?&lt;=cat384 <br>
# $catwords[0] = &rsquo;catch&rsquo; <br>
# $catwords[1] = &rsquo;catnip&rsquo; a <br>
$x =~ /t <br>
$x =~ /(?&lt;=cat(?=/; # doesn&rsquo;t match; no isolated
&rsquo;cat&rsquo; in <br>
# middle of $x</small></p>

<p style="margin-top: 1em"><small>Note that the parentheses
in &quot;(?=regexp)&quot; and &quot;(?&lt;=regexp)&quot; are
non-capturing, since these are zero-width assertions. Thus
in the second regexp, the substrings captured are <br>
those of the whole regexp itself. Lookahead
&quot;(?=regexp)&quot; can match arbitrary regexps, but
lookbehind &quot;(?&lt;=fixed-regexp)&quot; only works for
regexps of fixed width, i.e., a fixed <br>
number of characters long. Thus &quot;(?&lt;=(ab|bc))&quot;
is fine, but &quot;(?&lt;=(ab)*)&quot; is not. The negated
versions of the lookahead and lookbehind assertions are
denoted by &quot;(?!regexp)&quot; and <br>
&quot;(?&lt;!fixed-regexp)&quot; respectively. They evaluate
true if the regexps do not match:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;foobar&quot;;
<br>
$x =~ /foo(?!bar)/; # doesn&rsquo;t match, &rsquo;bar&rsquo;
follows &rsquo;foo&rsquo; <br>
$x =~ /foo(?!baz)/; # matches, &rsquo;baz&rsquo;
doesn&rsquo;t follow &rsquo;foo&rsquo; <br>
$x =~ /(?&lt;!foo/; # matches, there is no before
&rsquo;foo&rsquo;</small></p>

<p style="margin-top: 1em"><small>The &quot;is unsupported
in lookbehind, because the already treacherous definition of
&quot;would become even more so when going
backwards.</small></p>

<p style="margin-top: 1em"><small>Here is an example where
a string containing blank-separated words, numbers and
single dashes is to be split into its components. Using
&quot;/&quot; alone won&rsquo;t work, because spaces <br>
are not required between dashes, or a word or a dash.
Additional places for a split are established by looking
ahead and behind:</small></p>

<p style="margin-top: 1em"><small>$str = &quot;one two -
--6-8&quot;; <br>
@toks = split / # a run of spaces <br>
| (?&lt;= (?=-) # any non-space followed by &rsquo;-&rsquo;
<br>
| (?&lt;=-) (?= # a &rsquo;-&rsquo; followed by any
non-space <br>
/x, $str; # @toks = qw(one two - - - 6 - 8)</small></p>

<p style="margin-top: 1em"><small>Using independent
subexpressions to prevent backtracking <br>
Independent subexpressions are regular expressions, in the
context of a larger regular expression, that function
independently of the larger regular expression. That is,
they <br>
consume as much or as little of the string as they wish
without regard for the ability of the larger regexp to
match. Independent subexpressions are represented by
&quot;(?&gt;regexp)&quot;. <br>
We can illustrate their behavior by first considering an
ordinary regexp:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;ab&quot;; <br>
$x =~ /a*ab/; # matches</small></p>

<p style="margin-top: 1em"><small>This obviously matches,
but in the process of matching, the subexpression
&quot;a*&quot; first grabbed the &quot;a&quot;. Doing so,
however, wouldn&rsquo;t allow the whole regexp to match, so
after <br>
backtracking, &quot;a*&quot; eventually gave back the
&quot;a&quot; and matched the empty string. Here, what
&quot;a*&quot; matched was dependent on what the rest of the
regexp matched.</small></p>

<p style="margin-top: 1em"><small>Contrast that with an
independent subexpression:</small></p>

<p style="margin-top: 1em"><small>$x =~ /(?&gt;a*)ab/; #
doesn&rsquo;t match!</small></p>

<p style="margin-top: 1em"><small>The independent
subexpression &quot;(?&gt;a*)&quot; doesn&rsquo;t care about
the rest of the regexp, so it sees an &quot;a&quot; and
grabs it. Then the rest of the regexp &quot;ab&quot; cannot
match. Because <br>
&quot;(?&gt;a*)&quot; is independent, there is no
backtracking and the independent subexpression does not give
up its &quot;a&quot;. Thus the match of the regexp as a
whole fails. A similar behavior <br>
occurs with completely independent regexps:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;ab&quot;; <br>
$x =~ /a*/g; # matches, eats an &rsquo;a&rsquo; <br>
$x =~ /Gab/g; # doesn&rsquo;t match, no &rsquo;a&rsquo;
available</small></p>

<p style="margin-top: 1em"><small>Here &quot;//g&quot; and
&quot;G&quot; create a &rsquo;tag team&rsquo; handoff of the
string from one regexp to the other. Regexps with an
independent subexpression are much like this, with a handoff
of the <br>
string to the independent subexpression, and a handoff of
the string back to the enclosing regexp.</small></p>

<p style="margin-top: 1em"><small>The ability of an
independent subexpression to prevent backtracking can be
quite useful. Suppose we want to match a non-empty string
enclosed in parentheses up to two levels <br>
deep. Then the following regexp matches:</small></p>

<p style="margin-top: 1em"><small>$x =
&quot;abc(de(fg)h&quot;; # unbalanced parentheses <br>
$x =~ /( [^()]+ | ()]* )+ /x;</small></p>

<p style="margin-top: 1em"><small>The regexp matches an
open parenthesis, one or more copies of an alternation, and
a close parenthesis. The alternation is two-way, with the
first alternative &quot;[^()]+&quot; matching a <br>
substring with no parentheses and the second alternative
&quot;()]*&quot; matching a substring delimited by
parentheses. The problem with this regexp is that it is
pathological: it <br>
has nested indeterminate quantifiers of the form
&quot;(a+|b)+&quot;. We discussed in Part 1 how nested
quantifiers like this could take an exponentially long time
to execute if there was <br>
no match possible. To prevent the exponential blowup, we
need to prevent useless backtracking at some point. This can
be done by enclosing the inner quantifier as an <br>
independent subexpression:</small></p>

<p style="margin-top: 1em"><small>$x =~ /( (?&gt;[^()]+) |
()]* )+ /x;</small></p>

<p style="margin-top: 1em"><small>Here,
&quot;(?&gt;[^()]+)&quot; breaks the degeneracy of string
partitioning by gobbling up as much of the string as
possible and keeping it. Then match failures fail much more
quickly.</small></p>

<p style="margin-top: 1em"><small>Conditional expressions
<br>
A conditional expression is a form of if-then-else statement
that allows one to choose which patterns are to be matched,
based on some condition. There are two types of <br>
conditional expression: &quot;(?(condition)yes-regexp)&quot;
and &quot;(?(condition)yes-regexp|no-regexp)&quot;.
&quot;(?(condition)yes-regexp)&quot; is like an &rsquo;if ()
{}&rsquo; statement in Perl. If the <br>
&quot;condition&quot; is true, the &quot;yes-regexp&quot;
will be matched. If the &quot;condition&quot; is false, the
&quot;yes-regexp&quot; will be skipped and Perl will move
onto the next regexp element. The second <br>
form is like an &rsquo;if () {} else {}&rsquo; statement in
Perl. If the &quot;condition&quot; is true, the
&quot;yes-regexp&quot; will be matched, otherwise the
&quot;no-regexp&quot; will be matched.</small></p>

<p style="margin-top: 1em"><small>The &quot;condition&quot;
can have several forms. The first form is simply an integer
in parentheses &quot;(integer)&quot;. It is true if the
corresponding backreference &quot;integer&quot; matched
earlier <br>
in the regexp. The same thing can be done with a name
associated with a capture group, written as
&quot;(&lt;name&gt;)&quot; or
&quot;(&rsquo;name&rsquo;)&quot;. The second form is a bare
zero-width assertion <br>
&quot;(?...)&quot;, either a lookahead, a lookbehind, or a
code assertion (discussed in the next section). The third
set of forms provides tests that return true if the
expression is <br>
executed within a recursion (&quot;(R)&quot;) or is being
called from some capturing group, referenced either by
number (&quot;(R1)&quot;, &quot;(R2)&quot;,...) or by name
(&quot;(R&amp;name)&quot;).</small></p>

<p style="margin-top: 1em"><small>The integer or name form
of the &quot;condition&quot; allows us to choose, with more
flexibility, what to match based on what matched earlier in
the regexp. This searches for words of the <br>
form &quot;$x$x&quot; or &quot;$x$y$y$x&quot;:</small></p>

<p style="margin-top: 1em"><small>% simple_grep
&rsquo;^(120 <br>
beriberi <br>
coco <br>
couscous <br>
deed <br>
... <br>
toot <br>
toto <br>
tutu</small></p>

<p style="margin-top: 1em"><small>The lookbehind
&quot;condition&quot; allows, along with backreferences, an
earlier part of the match to influence a later part of the
match. For instance,</small></p>


<p style="margin-top: 1em"><small>/[ATGC]+(?(?&lt;=AA)G|C)$/;</small></p>

<p style="margin-top: 1em"><small>matches a DNA sequence
such that it either ends in &quot;AAG&quot;, or some other
base pair combination and &quot;C&quot;. Note that the form
is &quot;(?(?&lt;=AA)G|C)&quot; and not
&quot;(?((?&lt;=AA))G|C)&quot;; for the <br>
lookahead, lookbehind or code assertions, the parentheses
around the conditional are not needed.</small></p>

<p style="margin-top: 1em"><small>Defining named patterns
<br>
Some regular expressions use identical subpatterns in
several places. Starting with Perl 5.10, it is possible to
define named subpatterns in a section of the pattern so that
<br>
they can be called up by name anywhere in the pattern. This
syntactic pattern for this definition group is
&quot;(?(DEFINE)(?&lt;name&gt;pattern)...)&quot;. An
insertion of a named pattern is <br>
written as &quot;(?&amp;name)&quot;.</small></p>

<p style="margin-top: 1em"><small>The example below
illustrates this feature using the pattern for floating
point numbers that was presented earlier on. The three
subpatterns that are used more than once are the <br>
optional sign, the digit sequence for an integer and the
decimal fraction. The DEFINE group at the end of the pattern
contains their definition. Notice that the decimal <br>
fraction pattern is the first place where we can reuse the
integer pattern.</small></p>

<p style="margin-top: 1em"><small>/^ (?&amp;osg)&nbsp;* (
(?&amp;int)(?&amp;dec)? | (?&amp;dec) ) <br>
(?: [eE](?&amp;osg)(?&amp;int) )? <br>
$ <br>
(?(DEFINE) <br>
(?&lt;osg&gt;[-+]?) # optional sign <br>
(?&lt;int&gt;++) # integer <br>
(?&lt;dec&gt;.(?&amp;int)) # decimal fraction <br>
)/x</small></p>

<p style="margin-top: 1em"><small>Recursive patterns <br>
This feature (introduced in Perl 5.10) significantly extends
the power of Perl&rsquo;s pattern matching. By referring to
some other capture group anywhere in the pattern with the
<br>
construct &quot;(?group-ref)&quot;, the pattern within the
referenced group is used as an independent subpattern in
place of the group reference itself. Because the group
reference may be <br>
contained within the group it refers to, it is now possible
to apply pattern matching to tasks that hitherto required a
recursive parser.</small></p>

<p style="margin-top: 1em"><small>To illustrate this
feature, we&rsquo;ll design a pattern that matches if a
string contains a palindrome. (This is a word or a sentence
that, while ignoring spaces, interpunctuation and <br>
case, reads the same backwards as forwards. We begin by
observing that the empty string or a string containing just
one word character is a palindrome. Otherwise it must have a
<br>
word character up front and the same at its end, with
another palindrome in between.</small></p>

<p style="margin-top: 1em"><small>/(?: (696 -1} |
96</small></p>

<p style="margin-top: 1em"><small>Adding &quot;W*&quot; at
either end to eliminate what is to be ignored, we already
have the full pattern:</small></p>

<p style="margin-top: 1em"><small>my $pp = qr/^(W* (?: (96
-1} | 264 <br>
for $s ( &quot;saippuakauppias&quot;, &quot;A man, a plan, a
canal: Panama!&quot; ){ <br>
print &quot;&rsquo;$s&rsquo; is a palindrome0 if $s =~
/$pp/; <br>
}</small></p>

<p style="margin-top: 1em"><small>In &quot;(?...)&quot;
both absolute and relative backreferences may be used. The
entire pattern can be reinserted with &quot;(?R)&quot; or
&quot;(?0)&quot;. If you prefer to name your groups, you can
use <br>
&quot;(?&amp;name)&quot; to recurse into that
group.</small></p>

<p style="margin-top: 1em"><small>A bit of magic: executing
Perl code in a regular expression <br>
Normally, regexps are a part of Perl expressions. Code
evaluation expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp. A code
evaluation <br>
expression is denoted &quot;(?{code})&quot;, with code a
string of Perl statements.</small></p>

<p style="margin-top: 1em"><small>Be warned that this
feature is considered experimental, and may be changed
without notice.</small></p>

<p style="margin-top: 1em"><small>Code expressions are
zero-width assertions, and the value they return depends on
their environment. There are two possibilities: either the
code expression is used as a <br>
conditional in a conditional expression
&quot;(?(condition)...)&quot;, or it is not. If the code
expression is a conditional, the code is evaluated and the
result (i.e., the result of the <br>
last statement) is used to determine truth or falsehood. If
the code expression is not used as a conditional, the
assertion always evaluates true and the result is put into
the <br>
special variable $^R. The variable $^R can then be used in
code expressions later in the regexp. Here are some silly
examples:</small></p>

<p style="margin-top: 1em"><small>$x = &quot;abcdef&quot;;
<br>
$x =~ /abc(?{print &quot;Hi Mom!&quot;;})def/; # matches,
<br>
# prints &rsquo;Hi Mom!&rsquo; <br>
$x =~ /aaa(?{print &quot;Hi Mom!&quot;;})def/; #
doesn&rsquo;t match, <br>
# no &rsquo;Hi Mom!&rsquo;</small></p>

<p style="margin-top: 1em"><small>Pay careful attention to
the next example:</small></p>

<p style="margin-top: 1em"><small>$x =~ /abc(?{print
&quot;Hi Mom!&quot;;})ddd/; # doesn&rsquo;t match, <br>
# no &rsquo;Hi Mom!&rsquo; <br>
# but why not?</small></p>

<p style="margin-top: 1em"><small>At first glance,
you&rsquo;d think that it shouldn&rsquo;t print, because
obviously the &quot;ddd&quot; isn&rsquo;t going to match the
target string. But look at this example:</small></p>

<p style="margin-top: 1em"><small>$x =~ /abc(?{print
&quot;Hi Mom!&quot;;})[dD]dd/; # doesn&rsquo;t match, <br>
# but _does_ print</small></p>

<p style="margin-top: 1em"><small>Hmm. What happened here?
If you&rsquo;ve been following along, you know that the
above pattern should be effectively (almost) the same as the
last one; enclosing the &quot;d&quot; in a character <br>
class isn&rsquo;t going to change what it matches. So why
does the first not print while the second one
does?</small></p>

<p style="margin-top: 1em"><small>The answer lies in the
optimizations the regex engine makes. In the first case, all
the engine sees are plain old characters (aside from the
&quot;?{}&quot; construct). It&rsquo;s smart enough <br>
to realize that the string &rsquo;ddd&rsquo; doesn&rsquo;t
occur in our target string before actually running the
pattern through. But in the second case, we&rsquo;ve tricked
it into thinking that our <br>
pattern is more complicated. It takes a look, sees our
character class, and decides that it will have to actually
run the pattern to determine whether or not it matches, and
in <br>
the process of running it hits the print statement before it
discovers that we don&rsquo;t have a match.</small></p>

<p style="margin-top: 1em"><small>To take a closer look at
how the engine does optimizations, see the section
&quot;Pragmas and debugging&quot; below.</small></p>

<p style="margin-top: 1em"><small>More fun with
&quot;?{}&quot;:</small></p>

<p style="margin-top: 1em"><small>$x =~ /(?{print &quot;Hi
Mom!&quot;;})/; # matches, <br>
# prints &rsquo;Hi Mom!&rsquo; <br>
$x =~ /(?{$c = 1;})(?{print &quot;$c&quot;;})/; # matches,
<br>
# prints &rsquo;1&rsquo; <br>
$x =~ /(?{$c = 1;})(?{print &quot;$^R&quot;;})/; # matches,
<br>
# prints &rsquo;1&rsquo;</small></p>

<p style="margin-top: 1em"><small>The bit of magic
mentioned in the section title occurs when the regexp
backtracks in the process of searching for a match. If the
regexp backtracks over a code expression and if <br>
the variables used within are localized using
&quot;local&quot;, the changes in the variables produced by
the code expression are undone! Thus, if we wanted to count
how many times a <br>
character got matched inside a group, we could use,
e.g.,</small></p>

<p style="margin-top: 1em"><small>$x = &quot;aaaa&quot;;
<br>
$count = 0; # initialize &rsquo;a&rsquo; count <br>
$c = &quot;bob&quot;; # test if $c gets clobbered <br>
$x =~ /(?{local $c = 0;}) # initialize count <br>
( a # match &rsquo;a&rsquo; <br>
(?{local $c = $c + 1;}) # increment count <br>
)* # do this any number of times, <br>
aa # but match &rsquo;aa&rsquo; at the end <br>
(?{$count = $c;}) # copy local $c var into $count <br>
/x; <br>
print &quot;&rsquo;a&rsquo; count is $count, variable is
&rsquo;$c&rsquo;0;</small></p>

<p style="margin-top: 1em"><small>This prints</small></p>

<p style="margin-top: 1em"><small>&rsquo;a&rsquo; count is
2, $c variable is &rsquo;bob&rsquo;</small></p>

<p style="margin-top: 1em"><small>If we replace the &quot;
(?{local $c = $c + 1;})&quot; with &quot; (?{$c = $c +
1;})&quot;, the variable changes are not undone during
backtracking, and we get</small></p>

<p style="margin-top: 1em"><small>&rsquo;a&rsquo; count is
4, $c variable is &rsquo;bob&rsquo;</small></p>

<p style="margin-top: 1em"><small>Note that only localized
variable changes are undone. Other side effects of code
expression execution are permanent. Thus</small></p>

<p style="margin-top: 1em"><small>$x = &quot;aaaa&quot;;
<br>
$x =~ /(a(?{print &quot;Yow0;}))*aa/;</small></p>

<p style="margin-top: 1em"><small>produces</small></p>

<p style="margin-top: 1em"><small>Yow <br>
Yow <br>
Yow <br>
Yow</small></p>

<p style="margin-top: 1em"><small>The result $^R is
automatically localized, so that it will behave properly in
the presence of backtracking.</small></p>

<p style="margin-top: 1em"><small>This example uses a code
expression in a conditional to match a definite article,
either &rsquo;the&rsquo; in English or
&rsquo;der|die|das&rsquo; in German:</small></p>

<p style="margin-top: 1em"><small>$lang = &rsquo;DE&rsquo;;
# use German <br>
... <br>
$text = &quot;das&quot;; <br>
print &quot;matched0 <br>
if $text =~ /(?(?{ <br>
$lang eq &rsquo;EN&rsquo;; # is the language English? <br>
}) <br>
the | # if so, then match &rsquo;the&rsquo; <br>
(der|die|das) # else, match &rsquo;der|die|das&rsquo; <br>
) <br>
/xi;</small></p>

<p style="margin-top: 1em"><small>Note that the syntax here
is &quot;(?(?{...})yes-regexp|no-regexp)&quot;, not
&quot;(?((?{...}))yes-regexp|no-regexp)&quot;. In other
words, in the case of a code expression, we don&rsquo;t need
the <br>
extra parentheses around the conditional.</small></p>

<p style="margin-top: 1em"><small>If you try to use code
expressions with interpolating variables, Perl may surprise
you:</small></p>

<p style="margin-top: 1em"><small>$bar = 5; <br>
$pat = &rsquo;(?{ 1 })&rsquo;; <br>
/foo(?{ $bar })bar/; # compiles ok, $bar not interpolated
<br>
/foo(?{ 1 })$bar/; # compile error! <br>
/foo${pat}bar/; # compile error!</small></p>

<p style="margin-top: 1em"><small>$pat = qr/(?{ $foo = 1
})/; # precompile code regexp <br>
/foo${pat}bar/; # compiles ok</small></p>

<p style="margin-top: 1em"><small>If a regexp has (1) code
expressions and interpolating variables, or (2) a variable
that interpolates a code expression, Perl treats the regexp
as an error. If the code <br>
expression is precompiled into a variable, however,
interpolating is ok. The question is, why is this an
error?</small></p>

<p style="margin-top: 1em"><small>The reason is that
variable interpolation and code expressions together pose a
security risk. The combination is dangerous because many
programmers who write search engines <br>
often take user input and plug it directly into a
regexp:</small></p>

<p style="margin-top: 1em"><small>$regexp = &lt;&gt;; #
read user-supplied regexp <br>
$chomp $regexp; # get rid of possible newline <br>
$text =~ /$regexp/; # search $text for the
$regexp</small></p>

<p style="margin-top: 1em"><small>If the $regexp variable
contains a code expression, the user could then execute
arbitrary Perl code. For instance, some joker could search
for &quot;system(&rsquo;rm -rf *&rsquo;);&quot; to erase
<br>
your files. In this sense, the combination of interpolation
and code expressions taints your regexp. So by default,
using both interpolation and code expressions in the same
<br>
regexp is not allowed. If you&rsquo;re not concerned about
malicious users, it is possible to bypass this security
check by invoking &quot;use re
&rsquo;eval&rsquo;&quot;:</small></p>

<p style="margin-top: 1em"><small>use re
&rsquo;eval&rsquo;; # throw caution out the door <br>
$bar = 5; <br>
$pat = &rsquo;(?{ 1 })&rsquo;; <br>
/foo(?{ 1 })$bar/; # compiles ok <br>
/foo${pat}bar/; # compiles ok</small></p>

<p style="margin-top: 1em"><small>Another form of code
expression is the pattern code expression. The pattern code
expression is like a regular code expression, except that
the result of the code evaluation is <br>
treated as a regular expression and matched immediately. A
simple example is</small></p>

<p style="margin-top: 1em"><small>$length = 5; <br>
$char = &rsquo;a&rsquo;; <br>
$x = &rsquo;aaaaabb&rsquo;; <br>
$x =~ /(??{$char x $length})/x; # matches, there are 5 of
&rsquo;a&rsquo;</small></p>

<p style="margin-top: 1em"><small>This final example
contains both ordinary and pattern code expressions. It
detects whether a binary string 1101010010001... has a
Fibonacci spacing 0,1,1,2,3,5,... of the
1&rsquo;s:</small></p>

<p style="margin-top: 1em"><small>$x =
&quot;1101010010001000001&quot;; <br>
$z0 = &rsquo;&rsquo;; $z1 = &rsquo;0&rsquo;; # initial
conditions <br>
print &quot;It is a Fibonacci sequence0 <br>
if $x =~ /^1 # match an initial &rsquo;1&rsquo; <br>
(?: <br>
((??{ $z0 })) # match some &rsquo;0&rsquo; <br>
1 # and then a &rsquo;1&rsquo; <br>
(?{ $z0 = $z1; $z1 .= $^N; }) <br>
)+ # repeat as needed <br>
$ # that is all there is <br>
/x; <br>
printf &quot;Largest sequence matched was %d0,
length($z1)-length($z0);</small></p>

<p style="margin-top: 1em"><small>Remember that $^N is set
to whatever was matched by the last completed capture group.
This prints</small></p>

<p style="margin-top: 1em"><small>It is a Fibonacci
sequence <br>
Largest sequence matched was 5</small></p>

<p style="margin-top: 1em"><small>Ha! Try that with your
garden variety regexp package...</small></p>

<p style="margin-top: 1em"><small>Note that the variables
$z0 and $z1 are not substituted when the regexp is compiled,
as happens for ordinary variables outside a code expression.
Rather, the code expressions <br>
are evaluated when Perl encounters them during the search
for a match.</small></p>

<p style="margin-top: 1em"><small>The regexp without the
&quot;//x&quot; modifier is</small></p>

<p style="margin-top: 1em"><small>/^1(?:((??{ $z0 }))1(?{
$z0 = $z1; $z1 .= $^N; }))+$/</small></p>

<p style="margin-top: 1em"><small>which shows that spaces
are still possible in the code parts. Nevertheless, when
working with code and conditional expressions, the extended
form of regexps is almost necessary <br>
in creating and debugging regexps.</small></p>

<p style="margin-top: 1em"><small>Backtracking control
verbs <br>
Perl 5.10 introduced a number of control verbs intended to
provide detailed control over the backtracking process, by
directly influencing the regexp engine and by providing <br>
monitoring techniques. As all the features in this group are
experimental and subject to change or removal in a future
version of Perl, the interested reader is referred to <br>
&quot;Special Backtracking Control Verbs&quot; in perlre for
a detailed description.</small></p>

<p style="margin-top: 1em"><small>Below is just one
example, illustrating the control verb &quot;(*FAIL)&quot;,
which may be abbreviated as &quot;(*F)&quot;. If this is
inserted in a regexp it will cause it to fail, just as it
would <br>
at some mismatch between the pattern and the string.
Processing of the regexp continues as it would after any
&quot;normal&quot; failure, so that, for instance, the next
position in the <br>
string or another alternative will be tried. As failing to
match doesn&rsquo;t preserve capture groups or produce
results, it may be necessary to use this in combination with
embedded <br>
code.</small></p>

<p style="margin-top: 1em"><small>%count = (); <br>
&quot;supercalifragilisticexpialidocious&quot; =~ <br>
/([aeiou])(?{ $count{$1}++; })(*FAIL)/i; <br>
printf &quot;%3d &rsquo;%s&rsquo;0, $count{$_}, $_ for (sort
keys %count);</small></p>

<p style="margin-top: 1em"><small>The pattern begins with a
class matching a subset of letters. Whenever this matches, a
statement like &quot;$count{&rsquo;a&rsquo;}++;&quot; is
executed, incrementing the letter&rsquo;s counter. Then <br>
&quot;(*FAIL)&quot; does what it says, and the regexp engine
proceeds according to the book: as long as the end of the
string hasn&rsquo;t been reached, the position is advanced
before looking <br>
for another vowel. Thus, match or no match makes no
difference, and the regexp engine proceeds until the entire
string has been inspected. (It&rsquo;s remarkable that an
alternative <br>
solution using something like</small></p>

<p style="margin-top: 1em"><small>$count{lc($_)}++ for
split(&rsquo;&rsquo;,
&quot;supercalifragilisticexpialidocious&quot;); <br>
printf &quot;%3d &rsquo;%s&rsquo;0, $count2{$_}, $_ for (
qw{ a e i o u } );</small></p>

<p style="margin-top: 1em"><small>is considerably
slower.)</small></p>

<p style="margin-top: 1em"><small>Pragmas and debugging
<br>
Speaking of debugging, there are several pragmas available
to control and debug regexps in Perl. We have already
encountered one pragma in the previous section, <br>
&quot;use re &rsquo;eval&rsquo;;&quot;, that allows variable
interpolation and code expressions to coexist in a regexp.
The other pragmas are</small></p>

<p style="margin-top: 1em"><small>use re
&rsquo;taint&rsquo;; <br>
$tainted = &lt;&gt;; <br>
@parts = ($tainted =~ /(48</small></p>

<p style="margin-top: 1em"><small>The &quot;taint&quot;
pragma causes any substrings from a match with a tainted
variable to be tainted as well. This is not normally the
case, as regexps are often used to extract the safe <br>
bits from a tainted variable. Use &quot;taint&quot; when you
are not extracting safe bits, but are performing some other
processing. Both &quot;taint&quot; and &quot;eval&quot;
pragmas are lexically scoped, <br>
which means they are in effect only until the end of the
block enclosing the pragmas.</small></p>

<p style="margin-top: 1em"><small>use re &rsquo;/m&rsquo;;
# or any other flags <br>
$multiline_string =~ /^foo/; # /m is implied</small></p>

<p style="margin-top: 1em"><small>The &quot;re
&rsquo;/flags&rsquo;&quot; pragma (introduced in Perl 5.14)
turns on the given regular expression flags until the end of
the lexical scope. See &quot;&rsquo;/flags&rsquo; mode&quot;
in re for more detail.</small></p>

<p style="margin-top: 1em"><small>use re
&rsquo;debug&rsquo;; <br>
/^(.*)$/s; # output debugging info</small></p>

<p style="margin-top: 1em"><small>use re
&rsquo;debugcolor&rsquo;; <br>
/^(.*)$/s; # output debugging info in living
color</small></p>

<p style="margin-top: 1em"><small>The global
&quot;debug&quot; and &quot;debugcolor&quot; pragmas allow
one to get detailed debugging info about regexp compilation
and execution. &quot;debugcolor&quot; is the same as debug,
except the <br>
debugging information is displayed in color on terminals
that can display termcap color sequences. Here is example
output:</small></p>

<p style="margin-top: 1em"><small>% perl -e &rsquo;use re
&quot;debug&quot;; &quot;abc&quot; =~ /a*b+c/;&rsquo; <br>
Compiling REx &rsquo;a*b+c&rsquo; <br>
size 9 first at 1 <br>
1: STAR(4) <br>
2: EXACT &lt;a&gt;(0) <br>
4: PLUS(7) <br>
5: EXACT &lt;b&gt;(0) <br>
7: EXACT &lt;c&gt;(9) <br>
9: END(0) <br>
floating &rsquo;bc&rsquo; at 0..2147483647 (checking
floating) minlen 2 <br>
Guessing start of match, REx &rsquo;a*b+c&rsquo; against
&rsquo;abc&rsquo;... <br>
Found floating substr &rsquo;bc&rsquo; at offset 1... <br>
Guessed: match at offset 0 <br>
Matching REx &rsquo;a*b+c&rsquo; against &rsquo;abc&rsquo;
<br>
Setting an EVAL scope, savestack=3 <br>
0 &lt;&gt; &lt;abc&gt; | 1: STAR <br>
EXACT &lt;a&gt; can match 1 times out of 32767... <br>
Setting an EVAL scope, savestack=3 <br>
1 &lt;a&gt; &lt;bc&gt; | 4: PLUS <br>
EXACT &lt;b&gt; can match 1 times out of 32767... <br>
Setting an EVAL scope, savestack=3 <br>
2 &lt;ab&gt; &lt;c&gt; | 7: EXACT &lt;c&gt; <br>
3 &lt;abc&gt; &lt;&gt; | 9: END <br>
Match successful! <br>
Freeing REx: &rsquo;a*b+c&rsquo;</small></p>

<p style="margin-top: 1em"><small>If you have gotten this
far into the tutorial, you can probably guess what the
different parts of the debugging output tell you. The first
part</small></p>

<p style="margin-top: 1em"><small>Compiling REx
&rsquo;a*b+c&rsquo; <br>
size 9 first at 1 <br>
1: STAR(4) <br>
2: EXACT &lt;a&gt;(0) <br>
4: PLUS(7) <br>
5: EXACT &lt;b&gt;(0) <br>
7: EXACT &lt;c&gt;(9) <br>
9: END(0)</small></p>

<p style="margin-top: 1em"><small>describes the compilation
stage. STAR(4) means that there is a starred object, in this
case &rsquo;a&rsquo;, and if it matches, goto line 4, i.e.,
PLUS(7). The middle lines describe some <br>
heuristics and optimizations performed before a
match:</small></p>

<p style="margin-top: 1em"><small>floating &rsquo;bc&rsquo;
at 0..2147483647 (checking floating) minlen 2 <br>
Guessing start of match, REx &rsquo;a*b+c&rsquo; against
&rsquo;abc&rsquo;... <br>
Found floating substr &rsquo;bc&rsquo; at offset 1... <br>
Guessed: match at offset 0</small></p>

<p style="margin-top: 1em"><small>Then the match is
executed and the remaining lines describe the
process:</small></p>

<p style="margin-top: 1em"><small>Matching REx
&rsquo;a*b+c&rsquo; against &rsquo;abc&rsquo; <br>
Setting an EVAL scope, savestack=3 <br>
0 &lt;&gt; &lt;abc&gt; | 1: STAR <br>
EXACT &lt;a&gt; can match 1 times out of 32767... <br>
Setting an EVAL scope, savestack=3 <br>
1 &lt;a&gt; &lt;bc&gt; | 4: PLUS <br>
EXACT &lt;b&gt; can match 1 times out of 32767... <br>
Setting an EVAL scope, savestack=3 <br>
2 &lt;ab&gt; &lt;c&gt; | 7: EXACT &lt;c&gt; <br>
3 &lt;abc&gt; &lt;&gt; | 9: END <br>
Match successful! <br>
Freeing REx: &rsquo;a*b+c&rsquo;</small></p>

<p style="margin-top: 1em"><small>Each step is of the form
&quot;n &lt;x&gt; &lt;y&gt;&quot;, with
&quot;&lt;x&gt;&quot; the part of the string matched and
&quot;&lt;y&gt;&quot; the part not yet matched. The &quot;|
1: STAR&quot; says that Perl is at line number 1 in the <br>
compilation list above. See &quot;Debugging Regular
Expressions&quot; in perldebguts for much more
detail.</small></p>

<p style="margin-top: 1em"><small>An alternative method of
debugging regexps is to embed &quot;print&quot; statements
within the regexp. This provides a blow-by-blow account of
the backtracking in an alternation:</small></p>

<p style="margin-top: 1em"><small>&quot;that this&quot; =~
m@(?{print &quot;Start at position &quot;, pos, &quot;0;})
<br>
t(?{print &quot;t10;}) <br>
h(?{print &quot;h10;}) <br>
i(?{print &quot;i10;}) <br>
s(?{print &quot;s10;}) <br>
| <br>
t(?{print &quot;t20;}) <br>
h(?{print &quot;h20;}) <br>
a(?{print &quot;a20;}) <br>
t(?{print &quot;t20;}) <br>
(?{print &quot;Done at position &quot;, pos, &quot;0;}) <br>
@x;</small></p>

<p style="margin-top: 1em"><small>prints</small></p>

<p style="margin-top: 1em"><small>Start at position 0 <br>
t1 <br>
h1 <br>
t2 <br>
h2 <br>
a2 <br>
t2 <br>
Done at position 4</small></p>

<p style="margin-top: 1em"><small>BUGS <br>
Code expressions, conditional expressions, and independent
expressions are experimental. Don&rsquo;t use them in
production code. Yet.</small></p>

<p style="margin-top: 1em"><small>SEE ALSO <br>
This is just a tutorial. For the full story on Perl regular
expressions, see the perlre regular expressions reference
page.</small></p>

<p style="margin-top: 1em"><small>For more information on
the matching &quot;m//&quot; and substitution
&quot;s///&quot; operators, see &quot;Regexp Quote-Like
Operators&quot; in perlop. For information on the
&quot;split&quot; operation, see &quot;split&quot; <br>
in perlfunc.</small></p>

<p style="margin-top: 1em"><small>For an excellent
all-around resource on the care and feeding of regular
expressions, see the book Mastering Regular Expressions by
Jeffrey Friedl (published by O&rsquo;Reilly, ISBN <br>
1556592-257-3).</small></p>

<p style="margin-top: 1em"><small>AUTHOR AND COPYRIGHT <br>
Copyright (c) 2000 Mark Kvale All rights
reserved.</small></p>

<p style="margin-top: 1em"><small>This document may be
distributed under the same terms as Perl itself.</small></p>

<p style="margin-top: 1em"><small>Acknowledgments <br>
The inspiration for the stop codon DNA example came from the
ZIP code example in chapter 7 of Mastering Regular
Expressions.</small></p>

<p style="margin-top: 1em"><small>The author would like to
thank Jeff Pinyan, Andrew Johnson, Peter Haworth, Ronald J
Kimball, and Joe Smith for all their helpful
comments.</small></p>

<p style="margin-top: 1em"><small>perl v5.16.3 2013-03-04
PERLRETUT(1)</small></p>
<hr>
</body>
</html>
