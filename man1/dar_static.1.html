<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:02:12 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DAR(1) General Commands Manual DAR(1)</p>

<p style="margin-top: 1em">NAME <br>
dar - creates, tests, lists, extracts, compares, merges,
isolates dar archives</p>

<p style="margin-top: 1em">SYNOPSIS <br>
dar [-c | -t | -l | -x | -d | -+ | -C]
[&lt;path&gt;/]&lt;basename&gt; [&lt;options&gt;] [&lt;user
targets&gt;]</p>

<p style="margin-top: 1em">dar -h</p>

<p style="margin-top: 1em">dar -V</p>

<p style="margin-top: 1em">DESCRIPTION <br>
dar is a full featured backup tool, aimed for disks (floppy,
CD-R(W), DVD-R(W), zip, jazz, hard-disks, usb keys, etc.)
and since release 2.4.0 also adapted to tapes.</p>

<p style="margin-top: 1em">dar can store a backup in
several files (called &quot;slices&quot; in the following)
of a given size, eventually pausing or running a user
command/script before starting the next slice. <br>
This can allow for example, the burning of the last
generated slice on a DVD-R(W), Blue-ray Disk, or changing of
usb key before continuing on the next one. Like its grand-
<br>
brother, the great &quot;tar&quot; command, dar may also use
compression, at the difference that compression is used
inside the archive to be able to have compressed slices of
the defined <br>
size.</p>

<p style="margin-top: 1em">But the most important feature
of dar is its ability to make differential and decremental
backups. In other words, backups that contain only new files
or files that have changed <br>
from a backup of reference. Moreover with differential
backup, dar also stores files that have been deleted since
the backup of reference. Thus, when restoring, first a full
<br>
backup, then additional differential backups, at each
restoration you get the exact state of the filesystem at the
time the differential backup was made. And of course, the
ref&acirc; <br>
erence backup may be a full or a differential backup itself,
so you can make the same way incremental backups.</p>

<p style="margin-top: 1em">dar is the first backup program
I know that can also remove files during restoration! By the
way, in this document, &quot;archive&quot; and
&quot;backup&quot; mean the same thing, and are used <br>
interchangeably.</p>

<p style="margin-top: 1em">Unlike the tar command, dar has
not to read a whole archive nor to stick together the
different parts (the slices) to get its contents: dar
archive contains a table of contents <br>
(aka &quot;catalogue&quot;) located at the end of the
archive, so it seeks into the archive forth and backward to
extract only the required files, which is much faster than
what tar is <br>
used to do. The &quot;catalogue&quot; can be copied out of
the archive (operation called isolation) to be used as
reference for further backup and as backup of the internal
catalogue in <br>
case of archive corruption.</p>

<p style="margin-top: 1em">Dar can also use a sequential
reading mode, in which dar acts like tar, just reading byte
by byte the whole archive to know its contents and
eventually extracting file at each <br>
step. In other words, the archive contents is located at
both locations, all along the archive used for tar-like
behavior suitable for sequential access media (tapes) and at
the <br>
end for faster access, suitable for random access media
(disks). However note that tar archive and dar archive are
not compatible. Dar does not know anything about tar archive
<br>
structure, neither tar knows anything about dar archive
structure. So keep using tar if you are used to it or find
no advantage in using dar. Note also that the sequential
read&acirc; <br>
ing mode let you extract data from a partially written
archive (those that failed to complete due to a lack of disk
space for example).</p>

<p style="margin-top: 1em">Dar format is quite robust
against corruption: Only the file where the corruption took
place in the archive will not be possible to restore. To
have the possibility to repair a <br>
corrupted archive dar can work with par2 seamlessly just
specifying &quot;par2&quot; on command-line (see
/etc/darrc). Last a &quot;relax&quot; reading mode is
available which let dar to either <br>
ignore some incoherence in archive structure, use internal
redundant information to overcome data corruption or in last
resort asking the user on what to do when some archive <br>
structure information is missing (-al option). This relax
mode can be used with both sequential and direct access read
modes. Note that you should rather use Parchive to protect
<br>
your data rather than just relying on the &quot;relax&quot;
mode, which has to be seen as a the last chance
solution.</p>

<p style="margin-top: 1em">dar takes care of POSIX Extended
Attributes (EA in short) that are used in particular under
Linux to carry File Access Control List (FACL) as well as
security attributes for <br>
SELinux, and also under MacOS X EA they are used to store
file forks. EA also have room for user to add any key /
value paire to any file, this is known as user EA. These
<br>
attributes are not specific to any particular filesystem,
they exist the same way under ext3/4, HFS+ and any other
filesystem.</p>

<p style="margin-top: 1em">dar also takes care of
Filesystem Specific Attributes (FSA in short) which are, as
you can guess, specific to one or several filesystem(s). For
example the Birth date of a file <br>
exists for HFS+ and NTFS but not for ext2/3/4 filesystem.
The immutable attribute exists for ext2/3/4 but not for NTFS
while the nodump files does not exists for NTFS but exists
<br>
for HFS+, ext2/3/4 and many other Unix filesystems.</p>

<p style="margin-top: 1em">Sparse files (files with holes
that system reports using several hundred gigabytes while
they effectively use a few kilobytes on disk) are also well
managed by dar: they are <br>
detected, stored and restored to filesystem properly.</p>

<p style="margin-top: 1em">dar is also able to properly
save and restore hard-links</p>

<p style="margin-top: 1em">A few words about slice before
going deeper in detail: a slice is just a simple file which
name is composed of a &quot;basename&quot; followed by a
dot, then a number, again a dot and the <br>
extension (dar) to form the filename of that slice. On the
command line you will never have to give the full file name
of a slice, just the basename. The number between the dots
<br>
is the slice number, which starts from 1 and may be
arbitrary large (as large as your system can support the
corresponding filename).</p>

<p style="margin-top: 1em">Let&rsquo;s take an example:
<br>
considering the basename &quot;joe&quot;, dar will make one
or several slices during backup process (depending on your
choice). The filenames of these slices will be: <br>
joe.1.dar joe.2.dar ... joe.10.dar ... etc. If you want to
extract, list, or use this backup as reference, you will
only have to use the basename, which is <br>
the string &quot;joe&quot; in this example.</p>

<p style="margin-top: 1em">The rest of this document is
organized that way:</p>

<p style="margin-top: 1em">COMMANDS <br>
The seven actions you can performs with dar</p>

<p style="margin-top: 1em">GENERAL OPTIONS <br>
A set of options common to all actions</p>

<p style="margin-top: 1em">SAVING, ISOLATING AND MERGING
SPECIFIC OPTIONS <br>
A set of options that are specific to the operation of
backup, catalogue isolation and archive merging</p>

<p style="margin-top: 1em">RESTORATION SPECIFIC OPTIONS
<br>
A set of options that are specific to the restoration
operation</p>

<p style="margin-top: 1em">TESTING AND DIFFERENCE SPECIFIC
OPTIONS <br>
A set of options that are specific to the operation of
archive testing and archive comparison with a filesystem</p>

<p style="margin-top: 1em">LISTING OPTIONS <br>
A set of options that are specific to archive listing
operation</p>

<p style="margin-top: 1em">EXPICIT OPTIONAL ARGUMENTS <br>
Some system do not allow optional arguments to options, this
chapter explain how to overcome this restriction</p>

<p style="margin-top: 1em">EXIT CODES <br>
List of values dar returns at end of execution. This chapter
should be read if you intend to create scripts relying on
dar</p>

<p style="margin-top: 1em">SIGNALS <br>
details the signal and their action on a running dar
process</p>

<p style="margin-top: 1em">FILES <br>
List configuration files that dar checks for</p>

<p style="margin-top: 1em">CONDITIONAL SYNTAX <br>
Over command line, command and options can be passed to dar
thanks to a plain file (known as DCF file). This plain file
can also contain a specific syntax that will <br>
let you pass an option to dar only under certain
situation/condition. This chapter describes this simple
syntax and the different available conditions.</p>

<p style="margin-top: 1em">USER TARGETS <br>
User can add their own conditions known as user targets.
This chapter describes what they are and how to use them</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
Dar may rely on environment variables to look for DCF files
and DUC files</p>

<p style="margin-top: 1em">OPTIONS <br>
COMMANDS:</p>

<p style="margin-top: 1em">Only seven commands define what
action will be done by dar: Archive creation, archive
extraction, archive listing, archive testing, archive
comparison with filesystem, catalogue <br>
isolation and archive merging. These commands are described
here below.</p>

<p style="margin-top: 1em">Once defined, a large set of
options can be used to modify the way the command is
performed. These options are described just after the
commands chapter.</p>

<p style="margin-top: 1em">Important note: Not all system
actually support long options (Solaris, FreeBSD, ...). For
example --create will not be available on these systems, and
you will have to use -c <br>
instead. In the same way, not all system do support optional
arguments (FreeBSD without GNU getopt for example), you then
need to explicitly give the argument, for example in <br>
place of &quot;-z&quot; you will need to give &quot;-z
9&quot;, see &quot;EXPLICIT OPTIONAL ARGUMENTS&quot;
paragraph near the end of this document for details on that
point.</p>

<p style="margin-top: 1em">-c, --create
[&lt;path&gt;/]&lt;basename&gt; <br>
creates a backup with the name based on &lt;basename&gt;.
All the slices will be created in the directory &lt;path&gt;
if specified, else in the current directory. If the <br>
destination filesystem is too small to contain all the
slices of the backup, the -p option (pausing before starting
new slices) might be of interest. Else, in <br>
the case the filesystem is full, dar will suspend the
operation, asking for the user to make free space, then
continue its operation. To make free space, the <br>
only thing you cannot do is to touch the slice being
written. If the filename is &quot;-&quot; *and* no slicing
is asked for (no -s option) the archive is produced on <br>
the standard output allowing the user to send the resulting
archive through a pipe (or into a tape device directly or
using the dar_split command).</p>

<p style="margin-top: 1em">-x, --extract
[&lt;path&gt;/]&lt;basename&gt; <br>
extracts files from the given backup. Slices are expected to
be in the current directory or in the directory given by
&lt;path&gt;. It is also possible to use sym&acirc; <br>
bolic links to gather slices that are not in the same
directory. Path may also point to a removable device
(floppy, CD, USB key, etc.), in this case, to be <br>
able to mount/unmount the device, you must not launch dar
from that directory. In other words, the current directory
must not on the removable media you plan <br>
to unmount (see tutorial for details). The basename may be
set to &quot;-&quot;, in direct access mode (the default
historical mode), you will then need dar_slave to <br>
work with dar (see -i and -o options, as well as dar_slave
man page). However in sequential read mode
(--sequential-mode is used on command-line), dar will <br>
read the archive from standard input (see also -i option),
this can eventually be used in combination with
dar_split.</p>

<p style="margin-top: 1em">-l, --list
[&lt;path&gt;/]&lt;basename&gt; <br>
lists the contents of the given backup. dar will only
require the last slice of the archive in direct access mode.
If however sequential mode is used, dar <br>
will read the overall archive, from the first slice to the
last one. &quot;-&quot; can be used as basename, the
behavior is the same as with -x option (read just <br>
above).</p>

<p style="margin-top: 1em">-t, --test
[&lt;path&gt;/]&lt;basename&gt; <br>
checks the backup integrity. Even without compression, dar
is able to detect at least one error per file in the
archive, thanks to a variable length CRC <br>
recorded per file data, file EA and file FSA in the
catalogue. Archive structure (slice header, archive header,
catalogue) is also protected by CRC to be able <br>
to detect any kind of archive corruption. Same remark here,
&quot;-&quot; may be used as basename (see -x option above
for details).</p>

<p style="margin-top: 1em">-d, --diff
[&lt;path&gt;/]&lt;basename&gt; <br>
compares saved files in the backup with those on the
filesystem. &lt;basename&gt; may also be &quot;-&quot; (see
-x option above for details). Note that the target for this
<br>
operation is to be seen as a step further than archive
testing, where in addition to archive coherence, the archive
contents is verified to be the same as <br>
what is found on the filesystem. But if new files are
present on the filesystem, dar ignores them. If you want to
check for changes since a archive has been <br>
made, better use dry-run differential backup.</p>

<p style="margin-top: 1em">-C, --isolate
[&lt;path&gt;/]&lt;basename&gt; <br>
isolate a catalogue from its archive (that&rsquo;s to say
make a copy of the internal catalogue to its own archive
container). The argument is the basename of the <br>
file to create which will contain the catalogue&rsquo;s
copy. The -A option is mandatory here to give the name of
the archive to copy the catalogue from, this ar&acirc; <br>
chive is not modified at all. Slicing is available (-s -S -p
-b etc.). If the filename is &quot;-&quot; *and* no slice is
asked (no -s option) the isolated catalogue is <br>
produced on the standard output, allowing the user to send
the resulting archive through a pipe. Note that there is
quite no difference in concept between an <br>
isolated catalogue and an archive. Thus you can do all
operations on an isolated catalogue, in particular take it
in place of the original backup as reference <br>
for a differential archive, archive testing, archive
comparison. Note however that for comparison (-d option) as
data is not present in the isolated cata&acirc; <br>
logue, dar relies on embedded CRC rather than comparing data
byte by byte (what is done with a plain archive), and no
comparison can be performed concerning <br>
EA or FSA even if each of them have their own CRC in the
catalogue because different ordering as provided by the OS
of the items composing EA and FSA may lead <br>
the CRC to be different while the EA or FSA are exactly the
same, so CRC here is used only to dectect archive
corruption. Since release 2.4.0 you can use an <br>
isolated catalogue to rescue a corrupted internal catalogue
of the archive it has been based on (see -A option).</p>

<p style="margin-top: 1em">-+, --merge
[&lt;path&gt;/]&lt;basename&gt; <br>
create a subset archive from one or two existing archives
(the resulting archive name is the argument to this
command). The dar file selection mechanism (see <br>
GENERAL OPTIONS) let the user decide which files will be
present in the resulting archive and which one will be
ignored. This option thus let the user merge <br>
two archives in a single one (with a filtering mechanism
that accepts all files), as well as this option let the user
create a smaller archive which data is <br>
taken from one or two archives of reference. Note that at no
time the contents of the archives of reference is extracted
to real files and directories: this <br>
is an archive to archive transfer, thus you may lack support
for Extended Attribute while you will be able to fully
manipulate files with their Extended <br>
Attributes from one archive to the resulting one. If the
basename is &quot;-&quot; *and* no slice is asked (no -s
option), the archive is produced on standard output <br>
allowing the user to send the resulting archive through a
pipe. The first mandatory archive of reference is provided
thanks to the -A option, while the second <br>
&quot;auxiliary&quot; (and optional) archive of reference is
provided thanks to the -@ option. When a tie contention
occurs (same file names from both archive have to <br>
be merged), the overwriting policy (-/ option) is used to
define the one to keep in the resulting archive. By default,
archive data selected for merging is <br>
uncompressed, and re-compressed. Thus the merging operation
can be used to change compression algorithm of given archive
as well as change its encryption. <br>
But, for better performance it is also possible thanks to
the -ak option (see below the -ak option for usage
restrictions) to merge files keeping them com&acirc; <br>
pressed, thus no decompression/re-compression is performed
at all, which make the operation faster. Last it is not
possible to merge two isolated catalogues.</p>

<p style="margin-top: 1em">-h, --help displays help
usage.</p>

<p style="margin-top: 1em">-V, --version displays version
information.</p>

<p style="margin-top: 1em">GENERAL OPTIONS:</p>

<p style="margin-top: 1em">-v, --verbose For backward
compatibility, this is an alias to &quot;-vt -vm&quot; (both
options set).</p>

<p style="margin-top: 1em">-vs, --verbose=skipped <br>
Display files skipped because of file filtering exclusion
specified by the user</p>

<p style="margin-top: 1em">-vt, --verbose=treated <br>
Display treated files because of file filtering inclusion
specified by the user or no file filtering specified at all.
For each file a message is displayed <br>
*before* the file is treated. This option is not available
for archive isolation and is useless for archive listing as
it is always set, unless -q is used.</p>

<p style="margin-top: 1em">-vd, --verbose=dir Display the
directory under process. The messages shows *before*
entering a directory. You can have a less verbose output
than -vt while are still able to <br>
follow what&rsquo;s dar is doing. Note that -vt and -vd are
mutually exclusive.</p>

<p style="margin-top: 1em">-vm, --verbose=messages <br>
Display detailed messages about what dar is currently
performing but not related to currently treated or skipped
files and directories</p>

<p style="margin-top: 1em">-vf, --verbose=finished <br>
Issues a summary *after* each treated directory containing
the amount of data backed up in that directory as well as
the average compression ratio. This <br>
option is only available for archive creation.</p>

<p style="margin-top: 1em">-va, --verbose=all activates all
the previously described verbose options, see also -Q and -q
options below. Note: When using dar from a script better use
dar&rsquo;s exit status to <br>
know which way the operation has ended (seen EXIT CODES at
the end of this document).</p>

<p style="margin-top: 1em">-q, --quiet Suppress the final
statistics report. If no verbose output is asked beside this
option, nothing is displayed if the operation succeeds. When
using dar from a <br>
script better use dar&rsquo;s exit status to know which way
the operation has ended (seen EXIT CODES at the end of this
document)</p>

<p style="margin-top: 1em">-b, --beep makes the terminal
ring when user action is required (like for example the
creation of a new slice using the -p option)</p>

<p style="margin-top: 1em">-B, --batch &lt;filename&gt;
<br>
In the file which name is given in argument to this option,
You can put any option or argument as used on command line,
that will be parsed as if they were in <br>
place of the &quot;-B &lt;filename&gt;&quot; option. This
way you can overcome the command line size limitation.
Commands in the file may be disposed on several lines, and
-B <br>
option can also be used inside files, leading a file to
include other files. But an error occurs in case of loop (a
file that includes itself directly or not) <br>
and DAR aborts immediately. Comments are allowed, and must
start by a hash &lsquo;#&rsquo; character on each line. Note
that for a line to be considered as a comment the <br>
hash character must be the first character of the line
(space or tab can still precede the hash). See Conditional
Syntax below for a more rich syntax in this <br>
type of configuration files known as DCF file (Dar
Configuration File). See also the environment variable
DAR_DCF_PATH in the ENVIRONMENT section at the end <br>
of this document.</p>

<p style="margin-top: 1em">Note that you can use quotes
simple (&Acirc;&acute;arg&Acirc;&acute;) double
(&quot;arg&quot;) and back-quotes (&lsquo;arg&lsquo;) inside
such file, but they need to be balanced (have an ending
one). To use such character <br>
without the meaning of a quote, for example as an
apostrophe, you need to escape it using a back-slack
(&quot;That&acute;s an example&quot;). Of course to add a
single back-slash as a normal <br>
character in the file you will have to double it
(&quot;c:\windows&quot; for example)</p>

<p style="margin-top: 1em">-N, --noconf Do not try to read
neither ~/.darrc nor /etc/darrc configuration files. See
files section below.</p>

<p style="margin-top: 1em">-Q Do not display an initial
warning on stderr when not launched from a terminal (when
launched from a cronjob for example). This means that all
questions to the <br>
user will be answered by &rsquo;no&rsquo;, which most of the
time will abort the program. Please note that this option
cannot be used in a configuration file (-B option). <br>
Since version 2.2.2, giving this option also forces the
non-interactive mode, even if dar is launched from a
terminal. This makes it possible for dar to run <br>
in the background. When you do, it&rsquo;s recommended to
also redirect stdout and/or sterr to files: dar -Q ...
&amp;&gt; /dev/null &amp;</p>

<p style="margin-top: 1em">-n, --no-overwrite do not allow
overwriting</p>

<p style="margin-top: 1em">If an overwriting policy is
specified (see -/ option) -n option do only apply to slices
overwriting, the overwriting of files during restoration or
merging is <br>
handled by the overwriting policy. Without overwriting
policy, -n applies to restored files as well as generated
slices.</p>

<p style="margin-top: 1em">-w, --no-warn Do not warn before
overwriting (applied for slice overwriting and for
overwriting decision make by the overwriting policy). By
default overwriting is allowed <br>
but a warning is issued before proceeding. This option may
receive &rsquo;a&rsquo; as argument (see just below):</p>

<p style="margin-top: 1em">-wa, --no-warn=all This implies
the -w option, and means that over avoiding warning for file
overwriting, DAR also avoids signaling a file about to be
removed when its type is <br>
not the expected one. File are removed when they have been
recorded as deleted since the archive of reference. At
restoration of the differential archive, if <br>
a file of the given name exists, it is remove, but if the
type does not match the file that was present at the time of
the archive of reference (directory, <br>
plain file, fifo, socket, char or block device, etc.), a
warning is normally issued to prevent the accidental removal
of data that was not saved in the backup <br>
of reference. (See also -k option)</p>

<p style="margin-top: 1em">-A, --ref
[&lt;path&gt;]/&lt;basename&gt; <br>
Depending on the context, it specifies the archive to use as
reference, which is mandatory for archive isolation (-C
option) and merging operation (-+ <br>
option). Else it specifies the rescue catalogue to use when
restoring (-x command), testing (-t command) or comparing
(-d command) an archive. All slices of <br>
the reference backup are expected to be on the same
directory given by &lt;path&gt; or the current directory by
default. Usually only the last slice is required to <br>
extract the catalogue of reference. If necessary the use of
symbolic links is also possible here to gather slices that
do not reside in the same directory. <br>
You can also point &lt;path&gt; to a USB key, DVD-R(W) or
any other mounted directory, because dar will pause and ask
the user for required slices if they are not <br>
present. The argument to -A may be of four types:</p>

<p style="margin-top: 1em">- An existing archive basename,
which will be taken as reference</p>

<p style="margin-top: 1em">- a dash (&quot;-&quot;) in
direct access mode (default mode, when --senquential-read is
not used) it may imply the use of -o and -i options, this
allows the ar&acirc; <br>
chive of reference to be read from a pair of pipes with
dar_slave at the other ends. Dar_slave can be run through
ssh on a remote host for example. <br>
Note that this type of argument (&quot;-&quot;) is only
available when -A is used for isolation (-C option) and
merging (-+ options). In sequential mode <br>
(--sequential-mode is used), the archive of reference is
read from standard input or from the named pipe specified by
-i option. -o option has no use <br>
in sequential mode. Note that merging operation (-+ option)
cannot read archive of reference in sequential mode.</p>

<p style="margin-top: 1em">- a plus sign (&quot;+&quot;)
which makes the reference be the current directory status.
This argument is only available for archive creation (-c
option). In <br>
other word, no file&rsquo;s data will be saved, just the
current status of the inodes will be recorded in the
catalogue. This feature is known as the &quot;snap&acirc;
<br>
shot&quot; backup. A snapshot backup can be used as
reference later on to detect or save only the files that
have changed since the snapshot was made.</p>

<p style="margin-top: 1em">- a &lt;date&gt;, if -af option
has been placed before -A on the command-line or in a
included file (see -B option). For more about that feature
see -af <br>
option below. This form is only available for archive
creation (-c option).</p>

<p style="margin-top: 1em">During backup operation (-c
option) the archive of reference, given thanks to the -A
option, is used for comparison with existing files on the
filesystem. Dar <br>
will then backup only files that have changed since the
archive of reference was done. If no -A option is given, the
backup operation is a full backup. With <br>
-A option if the archive of reference is a full backup some
call it a differential backup, while if the archive of
reference is differential backup, some call <br>
this type of backup an incremental backup. For dar there is
no difference in structure between incremental and
differential backup, both are usually designed <br>
globally as &quot;differential&quot; backup in the
documentation.</p>

<p style="margin-top: 1em">During merging operation (-+
option), the contents of the -A given archive will been
taken eventually with the contents of the -@ auxiliary
archive if speci&acirc; <br>
fied (see below), to form a new archive from files of this
or these archives. Note that you can filter out files from
the operation and setup subset of the <br>
original archive(s).</p>

<p style="margin-top: 1em">During Catalogue isolation (-C
option), dar will create the isolated catalogue from the one
given with -A option.</p>

<p style="margin-top: 1em">During testing, diff or
extraction, (-t, -d or -x options respectively), the table
of contents (the catalogue) will be read from the archive
given with -A <br>
instead of using the internal catalogue of the archive. The
archive given for rescue must has been previously isolated
from this same archive (else the con&acirc; <br>
tents will not match and dar will refuse to proceed to this
operation). This acts as a backup solution to the case of
corruption inside an archive&rsquo;s cata&acirc; <br>
logue, while the best way is still to use Parchive to
protect your data against media error.</p>

<p style="margin-top: 1em">-af, --alter=fixed-date <br>
Modify the -A option behavior, making it receiving a
&lt;date&gt; as argument in place of the
[&lt;path&gt;]/&lt;basename&gt; default argument. The
&lt;date&gt; is used to define <br>
which file to save: file which modification is newer or
equal to &lt;date&gt;, and which to consider unchanged:
those older than &lt;date&gt;. This option has only a <br>
meaning when creating an archive (-c option) and must be
placed before -A option to have an effect.</p>

<p style="margin-top: 1em">&lt;date&gt; must be a date in
the two following possible formats:</p>

<p style="margin-top: 1em">- a number of second since Jan
1st, 1970</p>

<p style="margin-top: 1em">- a date in the following form
[[[year/]month/]day-]hour:minute[:second]</p>

<p style="margin-top: 1em">Here are some examples of date:
<br>
91836383927108078</p>

<p style="margin-top: 1em">2005/11/19-19:38:48 Which is 38
past 7 PM and 48 seconds, the 19th of November 2005</p>

<p style="margin-top: 1em">20:20 Which is 8 PM of the
current day</p>

<p style="margin-top: 1em">2-00:08 Which is 8 past noon,
the second day of the current month</p>

<p style="margin-top: 1em">2/2-14:59 Which is 1 to 3 PM,
the 2nd of February in the current year</p>

<p style="margin-top: 1em">-@, --aux
[&lt;path&gt;]/&lt;basename&gt;, --on-fly-isolate
[&lt;path&gt;]/&lt;basename&gt; <br>
specifies an auxiliary archive of reference (merging
context) or the name of the on-fly isolated catalogue
(creation context). This option is thus only avail&acirc;
<br>
able with -+ option (merging) and -c option (archive
creation). Note that --aux and --on-fly-isolate are really
aliases to the same option, this is the con&acirc; <br>
text of use (archive creation or merging) which lead it to
behave a way or another.</p>

<p style="margin-top: 1em">In a merging context, over -A
option which is mandatory, you may give a second archive of
reference thanks to the -@ option. This allows you to merge
two ar&acirc; <br>
chives into a single one. See also -$ option (encryption) -~
option (command execution) and -% (crypto block size) for
other options concerning auxiliary ar&acirc; <br>
chive of reference. They are the respective equivalent of
-J, -F and -* options relative to archive given thanks to -A
option.</p>

<p style="margin-top: 1em">In a backup context -@ option
let the user specify the archive name for an on-fly
isolation. With on-fly isolation, you can also use -$ option
(to define <br>
encryption algorithm and passphrase), -~ option (to execute
a command once the on-fly isolated catalogue is completed)
and -% option (crypto block size). On- <br>
fly isolated catalogue is always bzip2 if possible else gzip
else lzo compressed (using compression level 9) else not
compressed, and it is also always a sin&acirc; <br>
gle sliced archive. Due to command-line exiguity, it is not
possible to change compression algo nor slice size for the
on-fly isolation. If you need a more <br>
complicated isolation, either look for a GUI over libdar, or
do a normal (= not an on-fly) isolation operation (By the
way it is possible to isolate an <br>
already isolated catalogue, this is equivalent to doing a
copy, but you can change encryption, compression or slicing,
for example), you can also use <br>
dar_xform on an isolated catalogue if you only want to
change slices size (this is faster as no
decompression/re-compression nor encryption/decryption is
nec&acirc; <br>
essary). Using the merging operation on an isolated
catalogue instead of isolating the isolated catalogue, leads
the resulting archive to not be able to be <br>
used as a rescue for internal catalogue of the original
archive. --aux-ref is a synonym to --aux.</p>

<p style="margin-top: 1em">-R, --fs-root &lt;path&gt; <br>
The path points to the directory tree containing all the
files that will be enrolled in the operation (backup,
restoration or comparison). By default the cur&acirc; <br>
rent directory is used. All other paths used in -P or -g
options on the command line are and must be relative to this
path (or to current directory if -R is <br>
not present). Note that -R is useless for testing (-t
option) isolation (-C option) and merging (-+ option)</p>

<p style="margin-top: 1em">-X, --exclude &lt;mask&gt; <br>
The mask is a string with wildcards (like * and ? see
glob(7) for details) which is applied to filenames which are
not directories. If a given file matches <br>
the mask, it is excluded from the operation. By default (no
-X on the command line), no file is excluded from the
operation. -X may be present several times <br>
on the command line, in that case a file will not be
considered for the given operation if it matches at least
one -X mask. See also -ar and -am options.</p>

<p style="margin-top: 1em">-I, --include &lt;mask&gt; <br>
The mask is applied to filenames which are not directories
(see glob(7) for details on wildcard characters). If a given
file matches the mask and does not <br>
match any mask given with -X, the file is selected for the
operation. By default (no -I and no -X on the command line),
all files are included for the opera&acirc; <br>
tion. -I may be present several times on the command line,
in that case all file that match one of the -I mask will be
considered for the given operation, if <br>
they do not also match one of the -X mask. See also -ar and
-am options.</p>

<p style="margin-top: 1em">-P, --prune &lt;path&gt; Do not
consider file or directory sub-tree given by the path. -P
may be present several time on the command line. The
difference with -X is that the mask is <br>
not applied only to the filename, but also include the path.
Moreover it applies also to directories (-X does not). By
default (no -P on the command-line), no <br>
sub-tree or file is excluded from the operation, and all the
directory tree (as indicated by -R option) is considered.
Note that &lt;path&gt; may contains wildcards <br>
like * or ? see glob(7) man page for more information.</p>

<p style="margin-top: 1em">-g, --go-into &lt;path&gt; <br>
Files or directory to only take in account, as opposed to
-P. -g may be present several time on command-line. Same
thing here, the difference with -I is that <br>
the mask is applied to the path+filename and also concerns
directories. By default all files under the -R directory are
considered. Else, if one or more -g <br>
option is given, just those are selected (if they do not
match any -P option). All paths given this way must be
relative to the -R directory, which defaults <br>
to current directory. Warning, -g option cannot receive
wildcards, these would not be interpreted.</p>

<p style="margin-top: 1em">-[, --include-from-file
&lt;listing_file&gt; <br>
Files listed in the listing file are included for the
operation. No wildcard expression is interpreted in the
listing file, the null character is not allowed <br>
and the carriage return is used to separate file names (one
file name per line). Note that this option applies to any
files and directory exactly as -g does, <br>
with an important difference however: -g option only uses
relative paths to the root directory (the directory given
with the -R option), while -[ can use <br>
absolute path as well. Another difference is when the
argument is a directory -g will include all the
subdirectories under that directory, while when the same
<br>
entry is found in a listing file given to -[ only that
directory will be included, no subdirectory or subfile would
be enrolled in the backup, with -[ you <br>
need to list the exact set of file you want to backup. You
can thus generate a listing file with the &rsquo;find /
-print &gt; somefile&rsquo; command and give
&rsquo;somefile&rsquo; as <br>
argument to -[ option. Note that however, dar will never
save files out of the -R given root directory tree, even if
some are listed in the &rsquo;somefile&rsquo; file.</p>

<p style="margin-top: 1em">-], --exclude-from-file
&lt;listing_file&gt; <br>
Files listed in the listing file are excluded from the
operation. If a directory is listed in the file all its
contents is excluded. This option is the oppo&acirc; <br>
site of -[ and acts the same was as -P option does (in
particular it is compared to the whole path+filename and
applies to files and directories). As for -[ <br>
option, -] listing file can contain absolute paths, but
wildcards are not expanded, neither.</p>

<p style="margin-top: 1em">File selection in brief:</p>

<p style="margin-top: 1em">As seen above, -I -X -P, -g, -[
and -] options are used to select the files to operate on.
-I and -X only use the name of files and do not apply to
directories, while -P, -g -[ <br>
and -] use the filename *and* the path, they *do* apply to
directories.</p>

<p style="margin-top: 1em">since version 2.2.0 two modes of
interpretation of these options exist. The normal original
method and the ordered method:</p>

<p style="margin-top: 1em">the normal method is the default
and is the one that has been presented above: <br>
A directory is elected for operation if no -P or -] option
excludes it. If at least one -g or -[ option is given one
command line, one -g or -[ option must cover it, <br>
else it is not elected for operation. If a directory is not
selected, no recursion is done in it (the directory is
pruned). For non directories files, the same is <br>
true (P, -g, -[ and -] do apply) and a second test must also
be satisfied: no -X option must exclude the filename, and if
at least one -I option is given, one must <br>
match the given filename (using or not wildcards).</p>

<p style="margin-top: 1em">the ordered method (when -am
option is given on command-line): <br>
The ordered method takes care of the order of presence
between -X and -I in one hand and of -P, -g, -[ and -] in
the other hand (note that it has also the same action <br>
concerning EA selection when using -u and -U options, but
that&rsquo;s no more file selection). In the ordered method
the last argument take precedence over all the previ&acirc;
<br>
ous ones, let&rsquo;s take an example:</p>

<p style="margin-top: 1em">-X &quot;*.mp?&quot; -I
&quot;*.mp3&quot; -I &quot;toto*&quot; <br>
Here dar will include all files except file of name
&quot;*.mp?&quot; (those ending with &quot;mpX&quot; where X
is any character), but it will however include those ending
with <br>
&quot;.mp3&quot;. It will also include files which name
begin by &quot;toto&quot; whatever they end with. This way,
&quot;toto.mp2&quot; will be saved (while it matches
&quot;*.mp?&quot; it also begins <br>
by &quot;toto&quot;) as well as &quot;toto.txt&quot; as well
as &quot;joe.mp3&quot; (while it matches &quot;*.mp?&quot;
it also ends by &quot;mp3&quot;). But will not be saved
&quot;joe.mp2&quot; (because it does not <br>
begin by &quot;toto&quot;, nor ends by &quot;mp3&quot;, and
match &quot;*.mp?&quot; mask). As we see the last option (-I
or -X) overcomes the previous one. -P, -g, -[ and -] act
together the <br>
same but as seen above they do not only act on filename, but
on the whole path+filename. Note that (-g, -P, -[, -]) and
(-X , -I) are independent concerning <br>
their relative order. You can mix -X -I -g -P -] -[ in any
order, what will be important is the relative positions of
-X options compared to -I options, and the <br>
relative positions of -g -[ -] and -P options between
them.</p>

<p style="margin-top: 1em">In logical terms, if
&lt;prev_mask&gt; is the mask generated by all previous mask
on the command line, -I &lt;mask&gt; generates the new
following mask: &lt;prev_mask&gt; or &lt;mask&gt; . While
<br>
-X &lt;mask&gt; generates the new following mask:
&lt;prev_mask&gt; and not &lt;mask&gt;. This is recursive
each time you add a -I or -X option. Things work the same
with -P, -g, -[ and -] <br>
options. <br>
This ends the file selection explication let&rsquo;s
continue with other options.</p>

<p style="margin-top: 1em">-u, --exclude-ea &lt;mask&gt;
<br>
Do not consider the Extended Attributes (EA) that are
matched by the given mask. By default, no EA are excluded,
if the support for EA has been activated at <br>
compilation time. This option can be used multiple
times.</p>

<p style="margin-top: 1em">-U, --include-ea &lt;mask&gt;
<br>
Do only consider the EA that match the given mask. By
default, all EA are included if no -u or -U option is
present and if the support for EA has been acti&acirc; <br>
vated at compilation time. This option can be used multiple
times. See also the -am and -ae options, they also apply to
-U and -u options and read below the <br>
Note concerning EA.</p>

<p style="margin-top: 1em">Note concerning Extended
Attributes (EA)</p>

<p style="margin-top: 1em">Support for EA must be activated
at compilation time (the configure script tries to do so if
your system has all the required support for that). Thus you
can get two bina&acirc; <br>
ries of dar (of the same version), one supporting EA and
another which does not (dar -V to see whether EA support is
activated). The archives they produce are the same and <br>
can be read by each other. The only difference is that the
binary without EA support is not able to save or restore
EAs, but is still able to test them and list their <br>
presence.</p>

<p style="margin-top: 1em">In the following when we will
speak about Extended Attribute (EA) or EA entry, we will
only consider a particular Extended Attribute key and its
value. By opposition, the <br>
set of all EA associated to a file will be designated by
&quot;EA set&quot;.</p>

<p style="margin-top: 1em">Since version 2.3.x the name of
EA entries include the namespace for dar be able to consider
any type of EA (not only &quot;system&quot; and
&quot;user&quot; as previously). Thus the two pre&acirc;
<br>
vious options -u and -U have changed and now take an
argument which is a mask applied to EA entry names written
in the following form namespace.name where
&quot;namespace&quot; is <br>
for example &quot;user&quot;. Note that the mask may or may
not include the dot (.) and may match arbitrary part of the
EA namespace+name, just remind that masks will be applied to
<br>
the &quot;namespace.name&quot; global string.</p>

<p style="margin-top: 1em">the -am flag here also enables
the ordered method, for EA selection too. The ordered versus
normal method have been explained above in the file
selection note, with some <br>
examples using -X and -I. Here this is the same with -U and
-u, (just replace -X by -u and -I by -U, the corresponding
mask will apply to Extended Attribute selection in <br>
place of file selection).</p>

<p style="margin-top: 1em">Another point, independently of
the -am option the -ae option can be used at restoration
time only. If set, when a file is about to be overwritten,
all EA will be first <br>
erased before restoring those selected for restoration in
the archive (according to the -U and -u options given). If
not set, the EA of the existing file will be overwrit&acirc;
<br>
ten, those extra EA that are not in the archive or are not
selected for restoration in regard to the -u and -U options
will be preserved. If you have not used any -u/-U <br>
option at backup time and want to restore from a set of
full/differential backups the EA exactly as they were, you
have to use -ae for dar removes the EA before
overwrit&acirc; <br>
ing their set of EA as stored in the archive. Without -ae
option dar will simply add EA to existing ones, thus get a
different set of EA for a give file than those <br>
recorded at the time of the backup.</p>

<p style="margin-top: 1em">Last point the -acase and -an
options alters the case sensitivity of the -U and -u masks
that follow them on the command-line/included files as they
do for -I, -X, -P, <br>
-g, -[ and -] as well. Very last point ;-), if -ac option is
used during backup dar set back the atime after having read
each file (see -aa/-ac options), this has as side <br>
effect to modify the ctime date of each file. But ctime
change is used by dar to detect EA changes. In brief, the
next time you backup a file that had to be read (thus <br>
which contents changed), its EA will be saved even if they
had not changed. To avoid this side effect, don&rsquo;t use
the -ac option if not necessary. <br>
This ends the Extended Attribute selection explication
let&rsquo;s continue with other options.</p>

<p style="margin-top: 1em">-4 --fsa-scope
&lt;family&gt;[,&lt;family&gt;[, ...] <br>
Reduce the scope of Filesystem Specific Attribute (FSA) to
be considered for the operation. FSA are grouped by family.
Current available families are:</p>

<p style="margin-top: 1em">extX this family takes care of
Linux ext2/3/4 flag attributes set by chattr(1) and read by
lsattr(1). Dar only considers flags that are possible to set
or <br>
clear by users (or privileged user): append-only,
compressed, no_dump (Yes, dar can save files having the
nodump flag set and restore then afterward with <br>
that flag set!), immutable, data-journaling,
secure-deletion, no-tail-merging, undeletable,
noatime-update, synchronous-directory, synchronous-update,
<br>
top-of-directory-hierarchy. Note that &quot;extx&quot; and
&quot;ext&quot; are aliases for this FSA family. In spite of
its name, this family of attributes is not limited to <br>
ext2/3/4 filesystems.</p>

<p style="margin-top: 1em">HFS+ <br>
this family takes care of Mac OS X HFS+ birth date of files,
in addition of commonly found dates like atime (last access
time), ctime (last meta data <br>
change) and mtime (last data change).</p>

<p style="margin-top: 1em">none &quot;none&quot; is not a
FSA family but can be used alone to ignore all FSA
families.</p>

<p style="margin-top: 1em">By default no restriction is
done and FSA of all families are considered at restoration
time, but if a family has not been activated at compilation
time a <br>
warning is issued for each file that cannot have its FSA
restored completely (unless this family is excluded from the
scope thanks to the -4 option). At <br>
backup time, if an FSA family has not been activated at
compilation time, no warning is issued and FSA of that
family are ignored. Still at backup time, you <br>
can also ignore FSA that have compilation time support by
excluding them from the operation thanks to this -4
option.</p>

<p style="margin-top: 1em">Example of use: --fsa-scope
extX,HFS+</p>

<p style="margin-top: 1em">-am, --alter=mask set the
ordered mode for mask. This affects the way -I and -X
options are interpreted, as well as -g, -P, -[ and -]
options, -Z and -Y options and -U and -u <br>
options. It can take any place on the command-line and can
be placed only once. See the file selection in brief
paragraph above for a detailed explanation of <br>
this option. It has also an incidence on the
--backup-hook-exclude and --backup-hook-include options.</p>

<p style="margin-top: 1em">-an, --alter=no-case <br>
set the filters in case insensitive mode. This concerns only
masks specified after this option (see also -acase option
below). This changes the behavior of <br>
-I, -X, -g, -P, -Z, -Y, -u and -U options.</p>

<p style="margin-top: 1em">Warning: case insensitivity
requires interpreting filenames which depends on the locale
with which dar is run (defined by the LANG environment
variable). For example if you cre&acirc; <br>
ate files with LANG set to fr_FR.UTF-8 and use non plain
ASCII characters in filename, there is chances that these
non ASCII characters will be stored over several bytes in
that <br>
filename: so called &quot;wide characters&quot;. If then you
run dar with LANG set to another value like ru_RU.koi8r,
there is much chances that these wide characters do not
correspond to <br>
the same letter or worse, that they do not match any valid
wide character for that locale. A filename is always a
sequence of bytes and always saved as such, but using <br>
--alter=no-case implies interpreting that sequence in a way
that depends on the given locale (as defined by the LANG
environment variable). As such, dar cannot know if a given
<br>
file has to be read with fr_FR.UTF-8 locale or with
it_IT.iso88591 or ru_RU.koi8r and so on, because this
information is not stored in filenames. In consequence, if
different <br>
locales are used on your system and you are doing a system
wide backup, using --alter=no-case option may lead dar to
detect invalid wide character, in that case it falls back to
<br>
a byte by byte case sensitivity comparison (ASCII
characters), which may not be what you would expect at first
sight: Most of the time, an upper case wide character
(stored on <br>
several bytes) does not match the equivalent lower case wide
character (several bytes too), when case sensitivity
comparison is performed byte by byte.</p>

<p style="margin-top: 1em">-acase, --alter=case <br>
set back to case sensitive mode for filters. All following
masks are case sensitive, up to end of parsing or up to the
next -an option. This changes the <br>
behavior of -I, -X, -g, -P, -Z, -Y, -u and -U options.</p>

<p style="margin-top: 1em">-ar, --alter=regex set the
filters to be interpreted as regular expressions (man
regex(7) ) instead of the default glob expression (man
glob(7) ) This modifies the -I, -X, -g, <br>
-P, -Z, -Y, -u and -U options that follows up to an eventual
-ag option (see just below). Note that for -P option, the
given mask matches the relative path <br>
part of the files path: Let&rsquo;s take an example,
assuming you have provided /usr/local to the -R option, the
mask &quot;^foo$&quot; will replaced internally by <br>
&quot;^/usr/local/foo$&quot; while the mask &quot;foo$&quot;
will be replaced internally by
&quot;^/usr/local/.*foo$&quot;.</p>

<p style="margin-top: 1em">-ag, --alter=glob This option
returns to glob expressions mode (which is the default)
after an -ar option has been used, this applies to any -I,
-X, -g, -P, -Z, -Y, -u and -U <br>
options that follow up to an eventual new -ar option (see
just above).</p>

<p style="margin-top: 1em">-i, --input &lt;path&gt; is
available when reading from pipe (basename is &quot;-&quot;
for -x, -l, -t, -d or for -A when -c, -C or -+ is used).
When reading from pipe, standard input is used, <br>
but with this option, the file &lt;path&gt; (usually a named
pipe) is used instead. This option is to receive output from
dar_slave program (see <br>
doc/usage_notes.html for examples of use). Note that when
--sequential-read is used, dar uses a single pipe and does
no more rely on dar_slave, -i option can <br>
be used to tell dar which named pipe to read the archive
from, instead of the standard input.</p>

<p style="margin-top: 1em">-o, --output &lt;path&gt; is
available when reading from pipe (basename is &quot;-&quot;
for -x, -l, -t, -d or for -A when -c, -C or -+ is used).
When reading from pipe, standard output is used <br>
to send request to dar_slave, but with this option, the file
&lt;path&gt; (usually a named pipe) is used instead. When
standard output is used, all messages goes to <br>
standard error (not only interactive messages). See
doc/usage_notes.html for examples of use. This option is not
to be used in --sequential-read mode.</p>

<p style="margin-top: 1em">-O,
--comparison-field[=&lt;flag&gt;] <br>
When comparing with the archive of reference (-c -A) during
a differential backup, when extracting (-x) or when
comparing (-d) do only considers certain <br>
fields. The available flags are:</p>

<p style="margin-top: 1em">ignore-owner all fields are
considered except ownership. This is useful when dar is used
by a non-privileged user. It will not consider a file has
changed <br>
just because of a uid or gid mismatch and at restoration dar
will not even try to set the file ownership.</p>

<p style="margin-top: 1em">mtime only inode type and last
modification date is considered as well as inode specific
attributes like file size for plain files. Ownership is <br>
ignored, permission is ignored. During comparison,
difference on ownership or permission is ignored and at
restoration time dar will not try to <br>
set the inode permission and ownership.</p>

<p style="margin-top: 1em">inode-type Only the inode type
is considered. Ownership, permission and dates are ignored.
Inode specific attributes are still considered (like file
size <br>
for plain files). Thus comparison will ignore differences
for ownership, permission, and dates and at restoration dar
will not try to set the <br>
ownership, permission and dates.</p>

<p style="margin-top: 1em">When no flag is provided to this
option, -O option acts as if the &quot;ignore-owner&quot;
flag was set, which is the behavior in older releases (&lt;
2.3.0). Note also that for backward com&acirc; <br>
patibility, --ignore-owner option still exists and since
version 2.3.0 is just an alias to the
--comparison-field=ignore-owner option. Of course if this
option is not used, all <br>
fields are used for comparison or restoration.</p>

<p style="margin-top: 1em">-H[num], --hour[=num] <br>
if -H is used, two dates are considered equal if they differ
from a integer number of hours, and that number is less than
or equal to [num]. If not specified, <br>
num defaults to 1. This is used when making a differential
backup, to compare last_modification date of inodes, at
restoration or merging time if overwriting <br>
policy is based on file&rsquo;s data or EA being more recent
and last, when comparing an archive with a filesystem (-d
option). This is to workaround some filesys&acirc; <br>
tems (like Samba filesystem) that seems to change the dates
of files after having gone from or to daylight saving time
(winter/summer time). Note that -H <br>
option has influence on the overwriting policy (see -/
option) only if it is found before on command-line or in an
included file (using -B option).</p>

<p style="margin-top: 1em">-E, --execute &lt;string&gt;
<br>
the string is a user command-line to be launched between
slices. For reading an archive (thus using -t, -d, -l or -x
commands), the given string is executed <br>
before the slice is read or even asked, for writing an
archive instead (thus using -c, -C or -+ commands), the
given string is executed once the slice has <br>
been completed. Some substitution macros can be used in the
string:</p>

<p style="margin-top: 1em">%% will be replaced by %</p>

<p style="margin-top: 1em">%p will be replaced by the slice
path</p>

<p style="margin-top: 1em">%b will be replaced by the slice
basename</p>

<p style="margin-top: 1em">%n will be replaced by the slice
number (to be read or just written). For reading, dar often
needs the last slice, but initially it does not know its
<br>
number. If it cannot be found in the current directory, the
user command-line is then called with %n equal to 0. This is
a convenient way to inform <br>
the user command to provide the last slice. If after
executing the string the requested slice is still not
present, dar asks the user (as usually) <br>
with a message on the terminal. Once the last slice is
found, the user command-line is called a second time, with
%n equal to the value of the last <br>
slice number.</p>

<p style="margin-top: 1em">%N is the slice number with the
leading zero as defined by --min-digits option. If this
option is not used, %N is equivalent to %n.</p>

<p style="margin-top: 1em">%e will be replaced by the slice
extension (always substituted by &quot;dar&quot;)</p>

<p style="margin-top: 1em">%c will be replaced by the
context. Actually three possible values exist:
&quot;init&quot;, &quot;operation&quot; and
&quot;last_slice&quot;. When reading an archive for
(testing, <br>
extraction, diff, listing, or while reading the archive of
reference, see below the -F option), the &quot;init&quot;
context takes place from the beginning up <br>
to the time the catalogue is retrieved. On a multiple slice
archive this correspond to the last slice request. After,
that point comes the &quot;opera&acirc; <br>
tion&quot; context. While creating an archive, the context
is always &quot;operation&quot; except when the last slice
has been created, in which case the context <br>
is set to &quot;last_slice&quot;. <br>
Several -E option can be given, given commands will then be
called in the order they appear on the command line and -B
included files. Note that having &rsquo;-E script1 -E
script2&rsquo; is <br>
totally equivalent to &rsquo;-E &quot;script1 ;
script2&quot;&rsquo;. In other words if script1 fails,
script2 fill still be executed and dar will only be notified
of the exit status of the last -E <br>
option. Exit status of previous -E given commands wll be
ignored. If this does not match your need, consider using a
single -aduc option (see below). More generally you can use
<br>
any shell construction in the argument to -E, including
parenthesis, || and &amp;&amp;. Such files given to -E
option are known as DUC files (Dar User Command). See also
the environment <br>
variable DAR_DUC_PATH in the ENVIRONMENT section at the end
of this document.</p>

<p style="margin-top: 1em">-aduc, --alter=duc As described
above for -E option, several -E/-F/-~ options (aka DUC
commands) are combined using the shell &quot;;&quot;
operator, which ignores the exit status of the <br>
first commands and only reports to dar the exit status of
the last command, leading all command to always being
executed. --aduc option combines the different <br>
DUC commands using the shell &quot;&amp;&amp;&quot;
operator, which execute the next command if and only if the
previous command succeeded. In other words, dar get notified
of <br>
an error in any given DUC command but due to an error not
all DUC command may be executed.</p>

<p style="margin-top: 1em">--aduc modifies the way the next
DUC file is sticked to the previous command, in other
words:</p>

<p style="margin-top: 1em">dar --aduc -E script1 -E script2
... <br>
leads libdar to call a shell with the following line
&quot;script1 &amp;&amp; script2&quot;</p>

<p style="margin-top: 1em">dar -E script1 -script2 --aduc
-E script3 ... <br>
leads libdar to call a shell with the following line
&quot;script1 ; script2 &amp;&amp; script3&quot;. In other
words if you want to avoid the &quot;;&quot; use --aduc
before any -E/-F/-~ <br>
option.</p>

<p style="margin-top: 1em">-F, --ref-execute &lt;string&gt;
<br>
same as -E but is applied between slices of the reference
archive (-A option). --execute-ref is a synonym.</p>

<p style="margin-top: 1em">-~, --aux-execute &lt;string&gt;
<br>
same as -E and -F but is applied between slices of the
auxiliary archive (-@ option).</p>

<p style="margin-top: 1em">-K, --key
[[&lt;algo&gt;]:]&lt;string&gt;</p>

<p style="margin-top: 1em">-K, --key
gnupg:[&lt;algo&gt;]:email[,email[...]] <br>
In the first syntax, encrypt/decrypt the archive using the
&lt;algo&gt; cipher with the &lt;string&gt; as pass phrase.
An encrypted archive can only be read if the same <br>
pass phrase is given (symmetric encryption). Available
ciphers are &quot;blowfish&quot; (alias &quot;bf&quot;),
&quot;aes&quot;, &quot;twofish&quot;, &quot;serpent&quot;
and &quot;camellia&quot; for strong encryption <br>
and &quot;scrambling&quot; (alias &quot;scram&quot;) for a
very weak encryption. By default if no &lt;algo&gt; or no
&rsquo;:&rsquo; is given, the blowfish cipher is assumed. If
your password con&acirc; <br>
tains a column &rsquo;:&rsquo; you need to specify the
cipher to use (or at least use the initial &rsquo;:&rsquo;
which is equivalent to &rsquo;bf:&rsquo;). If the
&lt;string&gt; is empty the pass <br>
phrase will be asked at execution time. Thus, the smallest
argument that -K can receive is &rsquo;:&rsquo; which means
blowfish cipher with the pass phrase asked at exe&acirc;
<br>
cution time.</p>

<p style="margin-top: 1em">Note that giving the passphrase
as argument to -K (or -J or &rsquo;-$&rsquo; see below) may
let other users learn pass phrase (thanks to the ps, or top
program for exam&acirc; <br>
ples). It is thus wise to either use an empty pass which
will make dar ask the pass phrase when needed, or use -K (or
-J option) from a Dar Command File (see <br>
-B option), assuming it has the appropriated permission to
avoid other users reading it. For those paranoids that are
really concerned about security of their <br>
passwords, having a password read from a DCF is not that
secure, because while the file gets parsed, dar makes use of
&quot;unsecured&quot; memory (memory than can be <br>
swapped to disk under heavy memory load conditions). It is
only when the passphrase has been identified that locked
memory (aka secure memory) is used to <br>
store the parsed passphrase. So, the most secure way to
transmit a passphrase to dar, then to libdar, then to
libgcrypt, is having dar asking passphrase at <br>
execution time, dar then makes use of secured (locked)
memory from the beginning.</p>

<p style="margin-top: 1em">since archive format 9 (archive
generated by release 2.5.0 and following) at reading time,
it is not necessary to provide the encryption algorithm
used, just <br>
the passphrase is required, dar will figure out which
encryption algorithm had been used at archive creation time.
You can either ommit -K in which case dar <br>
will ask for the passphrase at execution time, or you can
use -K &lt;string&gt; in a DCF file as explained above
(avoid using -K directly on command-line).</p>

<p style="margin-top: 1em">The second syntax starts with
the word &quot;gnupg&quot; followed by a column
&rsquo;:&rsquo; . In that situation, the same set or
symmetric encryption algorithms as described <br>
above is available after the column, but the passphrase is
not given by the user but randomly chosen by libdar and
encrypted using the public key of the tar&acirc; <br>
get users which email is given in a comma separated list.
This random key (see also --key-length below), once
encrypted is placed at the beginning and at the <br>
end of the generated archive. At reading time only the
listed user will be able to read that archive thanks to
their respective private key. This feature <br>
implies that each user (the archive creator as well as the
target users) have their GnuPG keyring set properly. In
particular, the archive creator must have <br>
validated the public keys of the target users, and the
target users must own the corresponding private key in their
keyring. Example: using &quot;--key <br>
gnupg::bob@nowhere.org,joe@somewhere.com&quot; will generate
a blowfish encrypted archive which passprhase randomly
chosen by libdar will be encrypted with the <br>
public keys of bob@nowhere.org and joe@somewhere.com. To use
AES in place of blowfish one could use &quot;--key
gnupg:aes:bob@nowhere.org,joe@somewhere.com&quot;. Note <br>
that no check is done about the trust you have set in GPG
keyring that a particular public key is owned by the phyical
person you expect. See also --sign <br>
option below.</p>

<p style="margin-top: 1em">Note that if you have set a
passphrase on your private key, dar will ask it dynamically,
which requires dar to be run from a terminal. No other way
has been <br>
provided to transmit a private key&rsquo;s passphrase to
libdar. In consequence if you want to use dar/libdar in
scripts and make use of public key algorithm you <br>
should avoid setting a passphrase to the private key you
want to use. See also GNUPGHOME in the ENVIRONMENT section
at the end of this document.</p>

<p style="margin-top: 1em">Obvious but important! To read a
gnupg encrypted archive, you need your private key (not only
the passphrase to activate it, if set). Thus if you plan to
<br>
make backup of your system and encrypt the backup using
gnupg, you should have a copy of this private key available
out of the archive (usb key, floppy, <br>
CD/DVD, ...) in order to be able to restore your backup!</p>

<p style="margin-top: 1em">-J, --ref-key
[[&lt;algo&gt;]:]&lt;string&gt; <br>
same meaning/use as -K option&rsquo;s first syntax, but the
given key is used to decrypt the archive of reference (given
with -A option). --key-ref is a synonym. <br>
Note that for archives generated using dar release 2.5.0 and
above this option is no more necessary, unless you want to
give the passphrase on command-line <br>
(not recommended) or in DCF file (which file would be set
with restricted access permissions and/or ACL).</p>

<p style="margin-top: 1em">-$, --aux-key
[[&lt;algo&gt;]:]&lt;string&gt; <br>
same as -J but for the auxiliary archive of reference (given
with -@ option). Here too, this option is no more necessary
to read archives generated by dar <br>
release 2.5.0 and above.</p>

<p style="margin-top: 1em">-#, --crypto-block &lt;size&gt;
<br>
to be able to randomly access data in an archive, it is not
encrypted globally but block by block. You can define the
encryption block size thanks to this <br>
argument which default to 10240 bytes. Note that the syntax
used for -s option is also available here (k, M, G, etc.).
Note also that crypto-block is stored <br>
as a 32 bits integer thus value larger than 4GB will cause
an error. Note last, that the block size given here must be
provided when reading this resulting <br>
archive, using the -* option if the archive is the archive
of reference (given to -A option) using -% options if the
archive is the auxiliary archive of ref&acirc; <br>
erence (given to -@ option) or using this -# option if it is
the subject of the operation (listing, comparing, testing
that archive). If the value is not the <br>
default and the given value is not correct in regard to the
value given at archive creation time, the archive will not
be possible to decrypt, it is thus <br>
safer to keep the default value (and not using at all the
-#, -*, -% options).</p>

<p style="margin-top: 1em">-*, --ref-crypto-block
&lt;size&gt; <br>
same as --crypto-block but to read the archive of reference
(-A option). --crypto-block-ref is a synonym.</p>

<p style="margin-top: 1em">-%, --aux-crypto-block
&lt;size&gt; <br>
same as --crypto-block but to read the auxiliary archive of
reference (-@ option).</p>

<p style="margin-top: 1em">-e, --dry-run Do not perform any
action (backup, restoration or merging), displays all
messages as if it was for real (&quot;dry run&quot; action).
The --empty option is a synonym.</p>

<p style="margin-top: 1em">-aSI, --alter=SI[-unit[s]] <br>
when using k M G T E Z Y prefixes to define a size, use the
SI meaning: multiple of 10^3 (a Mega is 1,000,000).</p>

<p style="margin-top: 1em">-abinary,
--alter=binary[-unit[s]] <br>
when using k M G T E Z Y prefixes to define a size, use the
historical computer science meaning: multiple of 2^10 (a
Mega is 1,048,576).</p>

<p style="margin-top: 1em">The --alter=SI and
--alter=binary options can be used several times on the
command line. They affect all prefixes which follow, even
those found in files included by the -B <br>
option, up to the next --alter=binary or --alter=SI
occurrence. Note that if in a file included by the -B
option, an --alter=binary or --alter=SI is encountered, it
affects all <br>
the following prefixes, even those outside the included
files. For example, when running with the parameters
&quot;-B some.dcf -s 1K&quot;, 1K may be equal to 1000 or
1024, depending on <br>
--alter=binary or --alter=SI being present in the some.dcf
file. By default (before any --alter=SI/binary option is
reached), binary interpretation of prefixes is done, for
com&acirc; <br>
patibility with older versions.</p>

<p style="margin-top: 1em">-ac, --alter=ctime When reading
a filesystem (during a backup or comparison), restores the
atime of all files to what it was before the file was read.
This makes it appear as if <br>
it had not been read at all. However, because there is no
system call to let applications changing the ctime (last
inode change) of a file, setting back the <br>
atime results in the ctime being changed (hence the
alter=ctime). Some recent unix system allow an application
to get &rsquo;furtive read mode&rsquo; to the filesystem
<br>
(see below). On older systems, however, for most users,
having the atimes of the files changed shouldn&rsquo;t be a
problem, since they can be changed by any other <br>
program (running by any user!) as well (like the
content-index program Beagle). Ctimes on the other hand, are
the only way for security software to detect if <br>
files on your system have been replaced (by so called
root-kits mostly). This means, that should you run dar with
-ac, security software which uses ctimes to <br>
check, will mark every file on your system as compromised
after the backup. In short, this means this option should
only be used by people who know what they <br>
are doing. It&rsquo;s the opinion of this writer that any
software susceptible to atime changes is flakey or even
broken (because of the afore mentioned reasons why <br>
atimes can change). But, that doesn&rsquo;t take away that
there are programs who rely on atimes remaining the same,
like Leafnode NNTP caching software. Therefore <br>
this option exists.</p>

<p style="margin-top: 1em">-aa, --alter=atime When
specifying -aa (by opposition to -ac), the atime of every
read file and directory is updated, and the ctime remains
the same. In other words, Dar itself <br>
does nothing with atimes and ctimes, it only let the system
do its job to update atimes when files are accessed for
reading. This is in accordance with what <br>
atimes and ctimes were meant to represent. This is
Dar&rsquo;s default (since version 2.4.0), unless
&rsquo;furtive read mode&rsquo; (see below) is supported by
your system and <br>
dar has been compiled with this support activated.</p>

<p style="margin-top: 1em">Furtive read mode is a mode in
which neither atime nor ctime are modified while dar reads
each file and directory. This provides also better
performances as nothing has to be <br>
wrote back to disk. A known Unix kernel that supports this
feature is Linux 2.6.8 and above (support must also be
present in the standard C library of the system for dar to
be <br>
able to activate this feature at compilation time). When
this feature is activated, it becomes the default behavior
of dar for super user ; for other users the default is -aa.
<br>
If however as root user, you do not want to use
&quot;furtive read mode&quot; (while it has been activated
at compilation time), you can specify either -aa or -ac
option.</p>

<p style="margin-top: 1em">-at, --alter=tape-marks <br>
For archive creation and merging, the default behavior
(since release 2.4.0) is to add escape sequences (aka tape
marks) followed by inode information all <br>
along the archive. If -at is given, dar will not add this
information to the archive, resulting in a slightly smaller
archive and faster backup. When reading <br>
an archive, the default behavior is to ignore these escape
sequences and rather rely on the catalogue located at the
end of the archive. If instead --sequen&acirc; <br>
tial-read is given on command-line (see below), dar will
avoid using the catalogue at the end of the archive and will
rely on these escape sequences to know <br>
the contents of the archive, which will lead to a sequential
reading of the archive, operation suitable for tape media.
Note that it is not recommended to <br>
disable escape sequences (aka tape marks) by using -at
option except if you are more concerned by the resulting
size and execution speed of your backup (in <br>
particular if you have a lot of small files) than by the
possibility to recover your data in case of corrupted or
partially written archive. Without escape <br>
sequences, dar cannot sequential read an archive, which is
the only way beside using an isolated catalogue to use an
archive that has a corrupted catalogue or <br>
has no catalogue at all, thing that happens if a system
crash occurred during the archive creation or due to lack of
disk space to complete the archive.</p>

<p style="margin-top: 1em">-0, --sequential-read <br>
Change dar&rsquo;s behavior when reading an archive. By
default, the traditional way is used, which relies on the
table of contents (aka &quot;the catalogue&quot;) located at
<br>
the end of the archive. With the --sequential-read option
instead, dar will rely on escape sequences that are inserted
all along the archive with each file&rsquo;s <br>
inode information. This will lead to a sequential reading of
the archive, operation suitable for tape medium. However,
this feature is only available for ar&acirc; <br>
chive format starting revision &quot;08&quot; (i.e.: since
release 2.4.0) and if -at option has no been used during
archive creation or merging. This option is avail&acirc;
<br>
able for archive testing (-t), comparison (-d), restoration
(-x), listing (-l) and to read the archive of reference (-A
option) for isolation (-C) and archive <br>
creation (-c). The sequential reading of an archive is
always much slower than the usual reading method, so you
should not use this option unless you really <br>
need it.</p>

<p style="margin-top: 1em">-9, --min-digits
&lt;num&gt;[,&lt;num ref&gt;[,&lt;num aux&gt;]] <br>
By default slice number contained in filename do not have
any padded zeros, which, when sorting a directory contents
alphabetically leads to read all the <br>
slice starting by &rsquo;1&rsquo;, then by &rsquo;2&rsquo;.
for example, slice 1, 10, 11, 12, 13, ... 2, 20, 21, 23, ...
etc. While dar is absolutely not perturbed by this display
<br>
problem, some user shall like to have the slices sorted by
order. For that reason, the --min-digits option lets you ask
dar to prepend enough zeros in the <br>
slice number for it be as wide as the argument passed to
--min-digits. For example, if you provide 3 for that number,
dar will store the slice number as 001, <br>
002, 003, ... 999. Well, next slice will be 1000, thus it
will break again the alphabetical sorting order. You are
thus advised to use a number large enough <br>
to convert the number of slice you expect to use. Then, when
reading your archive, you will also need to provide this
same argument, else dar will fail find&acirc; <br>
ing the slice. In effect, when looking for slice 1 for
example, dar should try opening the file
&quot;basename.1.dar&quot;, but if it fails, it should try
opening the <br>
file &quot;basename.01.dar&quot;, then
&quot;basename.001.dar&quot;, ... up to infinity. If the
slice is just missing, dar would never ask you to provide
it, being still looking <br>
for a slice name with an additional leading zero. The
problem also arise when doing differential backup, merging
or on-fly isolation, dar must know the number <br>
of zero to prepend for each of these archive. This is why
the --min-digits option may receive up to three integer
values, the first for the archive to create <br>
or read, the second for the archive of reference (-A
option), the third for the auxiliary archive of reference
(-@ option). By default, no zero is added, and <br>
it is also well working this way. But you might well set for
example &quot;--min-digits 5,5,5&quot; in your
($HOME)/.darrc file to do it once and for all.</p>

<p style="margin-top: 1em">--pipe-fd &lt;num&gt; will read
further arguments from the file-descriptor &lt;num&gt;. The
arguments read through this file-descriptor must follow a
TLV (Type/Length/Value) list format. <br>
This option is not intended for human use, but for other
programs launching dar like dar_manager. This feature has
been added to overcome the command line <br>
length limit.</p>

<p style="margin-top: 1em">-al, --alter=lax When reading an
archive, dar will try to workaround data corruption of slice
header, archive header and catalogue. This option is to be
used as last resort <br>
solution when facing media corruption. It is rather and
still strongly encourage to test archives before relying on
them as well as using Parchive to do par&acirc; <br>
ity data of each slice to be able to recover data corruption
in a much more effective manner and with much more chance of
success. Dar also has the possibil&acirc; <br>
ity to backup a catalogue using an isolated catalogue, but
this does not face slice header corruption or even saved
file&rsquo;s data corruption (dar will detect <br>
but will not correct such event).</p>

<p style="margin-top: 1em">--single-thread, -G When libdar
is compiled against libthreadar, it can make use of several
threads. The number of thread is not settable but depends on
the number of features <br>
activated (compression, encryption, tape marks, sparse file,
etc.) that require CPU intensive operations. The
load-balancing type per thread used is called <br>
&quot;pipeline&quot;. As performance gain is little (not all
algorithms are adapted to parallel computing) this feature
is flagged as experimental: it has not been <br>
tested as intensively as other new features and it is not
encouraged for use. If you want better performance, use
several dar processes each for different <br>
directory trees. You&rsquo;ll get several archives instead
of one which isolated catalogues can be merged together (no
need to merge the backups, just the isolated <br>
catalogues) and used as base for the next differential
backup. Note: if you want to silent the initial warning
about the fact this feature is experimental use <br>
-Q option before -G option.</p>

<p style="margin-top: 1em">SAVING, ISOLATION AND MERGING
SPECIFIC OPTIONS (to use with -c, -C or -+)</p>

<p style="margin-top: 1em">-z[[algo:]level],
--compression[=[algo][:][level]] <br>
add compression within slices using gzip, bzip2, lzo or xz
algorithm (if -z is not specified, no compression is
performed). The compression level (an integer <br>
from 1 to 9) is optional, and is 9 by default. Be careful
when using xz algorithm better specify a compression ratio
less than or equal to 6 to avoid impor&acirc; <br>
tant memory requirements. A ratio of 1 means less
compression and faster processing, while at the opposite a
ratio of 9 gives the best compression but longest <br>
procesing time. &quot;Algo&quot; is optional, it specifies
the compression algorithm to use and can take the following
values &quot;gzip&quot;, &quot;bzip2&quot;, &quot;lzo&quot;
or &quot;xz&quot;. &quot;gzip&quot; <br>
algorithm is used by default (for historical reasons see
--gzip below). If both algorithm and compression are given,
a &rsquo;:&rsquo; must be placed between them. Valid <br>
usage of -z option is for example: -z, -z9, -zlzo, -zgzip,
-zbzip2, -zlzo:6, -zbzip2:2, -zgzip:1, -zxz:6 and so on.
Usage for long option is the same: --com&acirc; <br>
pression, --compression=9, --compression=lzo,
--compression=gzip, --compression=bzip2,
--compression=lzo:6, --compression=bzip2:2,
--compression=gzip:1 --com&acirc; <br>
pression=xz:9 and so on.</p>

<p style="margin-top: 1em">--gzip[=level] Same as -z (see
just above). This option is deprecated, please use
--compression or -z.</p>

<p style="margin-top: 1em">-s, --slice &lt;number&gt; <br>
Size of the slices in bytes. If the number is appended by k
(or K), M, G, T, P E, Z or Y the size is in kilobytes,
megabytes, gigabytes, terabytes, petabytes, <br>
exabytes, zettabytes or yottabytes respectively. Example:
&quot;20M&quot; means 20 megabytes, by default, it is the
same as giving 20971520 as argument (see also -aSI <br>
and -abinary options). If -s is not present the backup will
be written to a single slice whatever the size of the backup
may be (assuming your operating sys&acirc; <br>
tem can support arbitrarily large files).</p>

<p style="margin-top: 1em">-S, --first-slice &lt;number&gt;
<br>
-S gives the size of the first slice which may be chosen
independently of the size of following slices (either bigger
or smaller). This option needs -s option <br>
and by default of -S option, the size of the first slice is
the same as the one of the following slices.</p>

<p style="margin-top: 1em">-p [&lt;integer&gt;],
--pause[=&lt;integer&gt;] <br>
pauses before writing to a new slice (this requires -s). By
default there is no pause, all slices are written in the
same directory, up to the end of the <br>
backup or until the filesystem is full. In this later case,
the user is informed of the lack of disk space and dar stops
for user action. As soon as some disk <br>
space is available, the user can continue the backup. The
optional integer that this option can receive tells dar to
only pause very &rsquo;n&rsquo; slice. Giving 3 for <br>
&rsquo;n&rsquo; will make dar pause only after slices 3, 6,
9 and so on. If this integer is not specified, the behavior
is as if &rsquo;1&rsquo; was given as argument which makes
dar <br>
pause after each slice.</p>

<p style="margin-top: 1em">-D, --empty-dir At backup time,
when excluding directories either explicitly using -P or -]
options, or implicitly by giving a -g or -[ options (a
directory is excluded if it <br>
does not match mask given with -g options or -[ options) dar
does not store anything about these. But with -D option, dar
stores them as empty directories. <br>
This can be useful, if excluding a mount point (like /proc
or /dev/pts). At restoration time, dar will then recreate
these directories (if necessary). This <br>
option has no meaning with -C and is ignored in that case.
Independently of that, -D can also be used at restoration
time, but it activates a slightly differ&acirc; <br>
ent feature (see restoration options below).</p>

<p style="margin-top: 1em">-Z, --exclude-compression
&lt;mask&gt; <br>
Filenames covered by this mask are not compressed. It is
only useful in conjunction with -z option. By default, all
file are compressed (if compression is <br>
used). This option can be used several times, in that case a
file that matches one of the -Z mask will not be compressed.
Argument given to -Z must not be <br>
include any path, just the filename (eventually/probably
using wildcards).</p>

<p style="margin-top: 1em">-Y, --include-compression
&lt;mask&gt; <br>
Filenames covered by this mask (and not covered masks given
to -Z option(s)) are the only to be compressed. It is only
available with -z option. By default <br>
all files are compressed. This option can be used several
times, in that case all files that match one of the -Y will
be compressed, if they do not also match <br>
on of the -Z masks. The ordered method here applies too when
activated (with -am option), it works exactly the same as -I
and -X options, but apply to file <br>
compression, not file selection. In other word, it matches
only on the file name, not on the path of files.</p>

<p style="margin-top: 1em">-m, --mincompr &lt;number&gt;
<br>
files which size is below this value will not be compressed.
If -m is not specified it is equivalent to giving -m 100 as
argument. If you want to compress all <br>
file whatever their size is you thus need to type -m 0 on
the command line. The size unit is the byte (octet) and the
same number extensions as those used <br>
with -s or -S are available here, if you want to specify the
size in kilobyte, megabyte, gigabyte etc.</p>

<p style="margin-top: 1em">-1, --sparse-file-min-size
&lt;number&gt; <br>
Define the minimum length of zeroed bytes to replace by
&quot;holes&quot;. By default, this feature is activated
with a value of 15 bytes. To completely disable it, set <br>
the size to zero. Disabling this feature will bring some
noticeable speed improvement but will probably make the
archive slightly bigger (depending on the <br>
nature of the data). Sparse files are files that contain so
called holes. On a filesystem, the portion of zeroed bytes
is not stored on disk, thus an arbi&acirc; <br>
trary large file with huge portion of zeros may only require
a few bytes of disk storage. While dar cannot detect how is
allocated a given file because it <br>
makes a filesystem abstraction (it does not know the
implementation of any particular filesystem, where from its
portability), however when it finds a <br>
sequence of zeroed bytes larger than the given threshold it
can assume that it is in presence of a hole. Doing so, it
does not store the given zeroed bytes <br>
into the archive, but place a tag beside the saved data to
record the size of the hole and thus where to place the next
no zeroed bytes. This makes dar ar&acirc; <br>
chive disk space requirement much smaller when a sparse
files is met. At restoration time, dar will restore holes
writing normal data and seeking over the <br>
hole to write down the normal data after each hole. If the
underlying file system supports sparse files, this will
restore the holes. Note that there is no <br>
difference for applications whether a file is sparse or not,
thus dar may well transform normal files into sparse files
and viceversa, only the disk require&acirc; <br>
ment will change. Last point, if dar can reduce disk
requirement for archive with holes as small as 15 bytes
(smaller value works but the overhead cost more <br>
than what is required to store the zeroed bytes normally),
it may not be the same at restoration, because filesystem
allocation unit is usually several kilo&acirc; <br>
bytes, however restored file will never be larger than it
could be without holes. The only drawback of this feature is
the additional CPU cycle it requires.</p>

<p style="margin-top: 1em">-ak, --alter=keep-compressed
<br>
During merging operation, keep files compressed, this has
several restrictions : -z, -Z, -Y, -m are ignored, if two
archives have to be merged, both must use <br>
the same compression algorithm or one of them must not use
compression at all (this last restriction will probably
disappear in a next version). The advantage <br>
of this option is a greater speed of execution (compression
is usually CPU intensive).</p>

<p style="margin-top: 1em">-ah, --alter=holes-recheck <br>
For merging, the sparse file detection mechanism is disabled
by default. However if you want to activate it (assuming you
have an old archive you want to con&acirc; <br>
vert the current archive format taking care of sparse
files), you need to use -ah option to reactivate the sparse
file detection mechanism. Then for merging <br>
--sparse-file-min-size can be used as described above for
archive creation. In particular setting
--sparse-file-min-size to zero beside -ah during merging,
<br>
may also be used to convert file saved as sparse file into
plain normal files.</p>

<p style="margin-top: 1em">--nodump do not save files which
have the &rsquo;d&rsquo; flag set (see chattr(1) lsattr(1)
ext2 commands). This option may not be available if the
system dar has been compiled on <br>
did not provide support for ext2 flags. Note that this
option does nothing with -+ option (merging) as no
filesystem is used for that operation.</p>

<p style="margin-top: 1em">-5,
--exclude-by-ea[=&lt;extended attribute name&gt;] <br>
exclude inodes from backup that have been set with the EA
given in argument. If not argument is given to that option
the default EA used to exclude files from <br>
backup is &quot;user.libdar_no_backup&quot;. To set this
attribute to a given file, use the following command:
&quot;setfattr -n user.libdar_no_backup
&lt;filename&gt;&quot;, to remove <br>
it: &quot;setfattr -x user.libdar_no_backup
&lt;filename&gt;&quot;. Last, to check the presence this EA:
&quot;getfattr &lt;filename&gt;&quot;</p>

<p style="margin-top: 1em">-M, --no-mount-points <br>
stay in the same filesystem as the root directory (see -R
option), subdirectory that are mounting points for other
filesystems will not be saved (or saved <br>
empty if -D option is used). This option is useless and
ignored for merging operation.</p>

<p style="margin-top: 1em">-, , --cache-directory-tagging
<br>
don&rsquo;t save contents of directories that use the Cache
Directory Tagging Standard. See
http://www.brynosaurus.com/cachedir/spec.html for details.
(this option <br>
is useless with -+ option)</p>

<p style="margin-top: 1em">-/ , --overwriting-policy
&lt;policy&gt; <br>
This option let the user define when or how file overwriting
can occur at restoration or archive merging time. It does no
apply to slice overwriting which are <br>
driven by the -n option, it does instead apply to file
during extraction and files inside archives when merging two
of them. When considering overwriting, a <br>
file is said to be &rsquo;in place&rsquo; while an other is
known as &rsquo;new&rsquo; or &rsquo;to be added&rsquo;. At
restoration time, the &rsquo;in place&rsquo; is the one that
is present in filesystem <br>
while the &rsquo;to be added&rsquo; is the one from the
archive. At merging time, the &rsquo;in place&rsquo; is the
one of the &rsquo;-A&rsquo; archive of reference while the
&rsquo;to be added&rsquo; is <br>
the one from the auxiliary &rsquo;-@&rsquo; archive or
reference.</p>

<p style="margin-top: 1em">As soon as you use -/ option -n
only applies only to slice overwriting and the -r, -k and
-ae options are ignored (restoration options).</p>

<p style="margin-top: 1em">The given &lt;policy&gt;
argument is composed of actions and eventually of
conditional expressions. Actions do define how to solve
overwriting conflict about file&rsquo;s <br>
data on one side and file&rsquo;s Attributes (Extended and
Filesystem Specific) on the other side. An action is thus a
couple of action for Data and for EA+FSA. <br>
Actions for Data are represented by uppercase letters, while
action for EA+FSA are defined by lowercase letters. Both
actions are independent of each other:</p>

<p style="margin-top: 1em">P means &rsquo;Preserve&rsquo;.
When merging two archives, the data of the resulting archive
will be taken from the &rsquo;in place&rsquo; file. While
when extracting, the data of <br>
the inode in filesystem will be preserved (thus no
overwriting will occur for the data).</p>

<p style="margin-top: 1em">O means &rsquo;Overwrite&rsquo;.
When merging two archives, the data of the resulting archive
will be taken from the &rsquo;to be added&rsquo; file. While
when extracting, the <br>
data of the inode in filesystem will be overwritten by data
from the archive.</p>

<p style="margin-top: 1em">S means &rsquo;mark Saved and
preserve&rsquo;. When merging two archives, the data of the
resulting archive will be marked as already saved in the
archive of reference <br>
(making thus a differential archive, even if none of the
original archive were differential archives). All data will
be dropped in the resulting archive, <br>
but the last modification date [aka mtime] (used to detect
change in file&rsquo;s data) will be taken from the
&rsquo;in place&rsquo; file. This action does not apply when
<br>
extracting files, it is thus considered equal to
&quot;Preserve&quot; (P) in that situation.</p>

<p style="margin-top: 1em">T means &rsquo;mark Saved and
overwrite&rsquo;. When merging two archives, the data of the
resulting archive will be marked as already saved (same as
&rsquo;S&rsquo; action): all <br>
data will be dropped in the resulting archive, however the
last modification date [aka mtime] (used to detect changes
in a file&rsquo;s data) will be taken <br>
from the &rsquo;to be added&rsquo; file. This action does
not apply when extracting files, it is thus considered equal
to &quot;Overwrite&quot; (O) in that situation.</p>

<p style="margin-top: 1em">R means &rsquo;Remove&rsquo;.
When merging two archives, the resulting archive will not
contain any entry corresponding to the file that were in
conflict. This also <br>
implies that no EA will be stored for that particular entry
as the entry will no more exist in the resulting archive (as
if it had never yet existed). <br>
When extracting files, this will lead to file&rsquo;s
suppression.</p>

<p style="margin-top: 1em">p means &rsquo;Preserve&rsquo;,
same as &rsquo;P&rsquo; (but lowercase letter) preserve the
whole EA set and FSA. When merging two archives, the
Attributes set of the resulting <br>
file will be the ones of the &rsquo;in place&rsquo; file
(whatever is the overwriting action taken for its data).
While when extracting files to filesystem, the <br>
Attributes of the file in filesystem will not be changed
(whatever is the overwriting action taken for its data,
unless the file is removed using the &rsquo;R&rsquo; <br>
policy, which would remove the inode and thus also any
Attributes it had).</p>

<p style="margin-top: 1em">o means &rsquo;Overwrite&rsquo;,
same as &rsquo;O&rsquo; (but lowercase letter) overwrite the
whole EA set and FSA. When merging two archives, the
Attributes set of the resulting <br>
file will be taken from the &rsquo;to be added&rsquo; file.
While when extracting files, the Attributes set of the file
in the filesystem will have its Attributes <br>
erased and replaced by those of the file in the archive
(still independent of what overwriting action is taken for
file&rsquo;s data).</p>

<p style="margin-top: 1em">s means &rsquo;mark Saved and
preserve&rsquo;, same as &rsquo;S&rsquo; (but lowercase
letter) for EA and FSA instead of data. When merging two
archives, the EA and FSA of the <br>
resulting file are marked as already saved in the archive of
reference, thus they are dropped but the date of last inode
change [aka ctime] (used to <br>
detect changes in file&rsquo;s EA and FSA) will be taken
from the &rsquo;in place&rsquo; file. This action does not
apply when extracting files, it is thus considered <br>
equivalent to &quot;Preserve&quot; (p) in that
situation.</p>

<p style="margin-top: 1em">t means &rsquo;mark Saved and
overwrite&rsquo;, same as &rsquo;T&rsquo; (but lowercase
letter) for EA and FSA instead of data. When merging two
archives, the EA and FSA of the <br>
resulting file are marked as already saved in the archive of
reference, thus they are dropped but the date of last inode
change [aka ctime] (use to track <br>
changes in EA) will be taken from the &rsquo;to be
added&rsquo; file. This action does not apply when
extracting files, it is thus considered an equivalent to
&quot;Over&acirc; <br>
write&quot; (o) in that situation.</p>

<p style="margin-top: 1em">m means &rsquo;merge Attributes
and preserve&rsquo;. The resulting file in the merged
archive will have Attribute entries from both the &rsquo;in
place&rsquo; and the &rsquo;to be <br>
added&rsquo; files. If both files share a same Attribute
entry (same FSA or for EA the same key for a given
association) the one of the &rsquo;in place&rsquo; file is
kept <br>
(where from the &rsquo;preserve&rsquo; notion). When
extracting a file, the file in the filesystem will have its
EA and FSA set enriched by the ones of the file in <br>
the archive that do not exist on filesystem, but its already
existing Attributes will stay untouched.</p>

<p style="margin-top: 1em">n means &rsquo;merge Attributes
and overwrite&rsquo;. The resulting file in the merged
archive will have Attribute entries from both the &rsquo;in
place&rsquo; and the &rsquo;to be <br>
added&rsquo; files. If both files share a same Attribute
entry (same FSA or for EA the same key for a given
association) the one of the &rsquo;to be added&rsquo; file
will <br>
be kept (where from the &rsquo;overwrite&rsquo; notion).
When extracting file, the file in the filesystem will have
its Attributes set enriched by ones of the file <br>
in the archive with some of them possibly been
overwritten.</p>

<p style="margin-top: 1em">r means &rsquo;remove&rsquo;,
same as &rsquo;R&rsquo; but for the Attribute set (thus all
EA and FSA entries) of a given file (&rsquo;r&rsquo; is
lowercase letter here). The file of the <br>
resulting archive during merging operation will not own any
EA nor any FSA, even if the &rsquo;in place&rsquo; and/or
the &rsquo;to be added&rsquo; files did have some. For file
<br>
extraction, this means that the file in the filesystem will
loose all its EA set. The FSA cannot be
&rsquo;removed&rsquo; from a filesystem and may not always
have a <br>
default value, thus this action does not modify FSA at all
in case of archive extraction. But in case of merging the
FSA are removed as previously <br>
described. As for all the previous tests, this Attribute
operation is independent of the operation chosen for
file&rsquo;s data (uppercase letters).</p>

<p style="margin-top: 1em">d means &rsquo;delete&rsquo;.
When a same EA or FSA entry is found both in the &rsquo;in
place&rsquo; and &rsquo;to be added&rsquo; files, such entry
will be absent in the resulting archive. <br>
In other words, when merging, the EA set and FSA will only
contain EA and FSA entries specific to the &rsquo;in
place&rsquo; and those specific to the &rsquo;to be
added&rsquo; <br>
file. Entries in common will not be present. When extracting
a file from an archive, the file on filesystem will have its
EA set enriched by entries of <br>
the &rsquo;to be added&rsquo; file that are new to the
&rsquo;in place&rsquo; file. The other EA entries (which are
thus present in both archive and filesystem) will be removed
<br>
from the set, which the other FSA will stay untouched (FSA
cannot be &quot;removed&quot; from a filesystem, nor they
always have a default value).</p>

<p style="margin-top: 1em">* is valid for both EA and data.
It tells that the action is not yet defined at this step of
the evaluation and that further evaluation is required (see
<br>
the &rsquo;chain&rsquo; operator below).</p>

<p style="margin-top: 1em">A means &rsquo;Ask for user
decision&rsquo;. This uppercase letter concerns Data
overwriting. An application interaction let the user define
the action for each file <br>
in conflict. Note, that this action if used alone may become
very boring or painful. The idea is to use it in conditional
statements (which are described <br>
below) to have dar ask for only non obvious cases.</p>

<p style="margin-top: 1em">a means &rsquo;Ask for user
decision&rsquo;. This lowercase letter is the equivalent for
EA and FSA of the &rsquo;A&rsquo; action. It is intended to
be used in the same condi&acirc; <br>
tional statements described below.</p>

<p style="margin-top: 1em">An action is thus a couple of
letters, the first being uppercase (for file&rsquo;s data)
the second being lowercase (for file&rsquo;s EA and FSA).
When -/ option is not <br>
given, the action is equivalent to &rsquo;-/ Oo&rsquo;,
making dar proceed to file, EA and FSA overwriting. This is
to stay as close as possible to the former default <br>
action where neither -n nor -w where specified. Note that -w
option stays untouched, in consequences, in this default
condition for -/ option, a confirmation <br>
will be asked to the user before dar proceed to any
overwriting. The former -n option (still used to handle
slice overwriting) can be replaced by its equiva&acirc; <br>
lent &rsquo;-/ Pp&rsquo; for resolving file overwriting
conflict (never overwrite). Here follows some examples of
actions, all these are done for any entry found in
con&acirc; <br>
flict during archive merging or archive extraction, we will
see further how to define conditional actions.</p>

<p style="margin-top: 1em">-/ Rr <br>
will lead dar to remove any file from filesystem that ought
to be restored(!). Note the action for EA/FSA is useless,
the EA and FSA will always be <br>
erased as well as data using &rsquo;R&rsquo;. Thus &rsquo;-/
Rp&rsquo; would lead to the same result.</p>

<p style="margin-top: 1em">-/ Po <br>
will keep data of the &rsquo;in place&rsquo; file and EA and
FSA set from the &rsquo;to be added&rsquo; file.</p>

<p style="margin-top: 1em">-/ Ss <br>
Using this option when merging an archive with itself (used
both as archive of reference (-A option) and auxiliary
archive of reference (-@ option) ) <br>
will provide the same action as an archive isolation of the
archive of reference, but using twice more memory (so keep
using the isolation operation as <br>
before! Here this is just an illustration of the
possibility)</p>

<p style="margin-top: 1em">As seem previously -u and -U
options can be used to filter which EA entry to consider and
which to ignore. The question here is to explain how this
filtering <br>
mechanism interacts with the different policies we just
presented above. For files that are not in conflict (found
only as &rsquo;in place&rsquo; or as &rsquo;to be
added&rsquo;), <br>
only the EA entries matching the EA filter are kept. For
files in conflict, the overwriting policy is evaluated
first, then the filtering mechanism is applied <br>
*after* it. Thus for example, using the following [ -/
&quot;Po&quot; -u &quot;*test&quot; ], when merging two
archives, only EA ending with &quot;test&quot; will be
retained, and when a <br>
conflict takes place, this &quot;*test&quot; ending EA will
be taken from the &rsquo;to be added&rsquo; file if it has
some EA of that type, its other EA entry will be ignored as
<br>
well as any EA entry of the &rsquo;in place&rsquo; file even
those ending by &quot;test&quot;. At restoration in using
the same options, file without conflict will get restored
but <br>
only EA entry ending with &quot;test&quot; will be restored,
and for file with conflict (already present in filesystem),
EA set of file in filesystem will be removed <br>
and replaced the EA entries of the file in archive that ends
by &quot;test&quot;, if some exist.</p>

<p style="margin-top: 1em">the situation is similar with
FSA family scope and overwriting policy. Only FSA of a
family present in the scope will be retained, the
overwriting policy acts <br>
first then the FSA scope is applied. Note however that any
FSA present on filesystem and excluded from the FSA scope
are not touched.</p>

<p style="margin-top: 1em">Well, now let&rsquo;s see how to
bring some more fun using conditional statements in all
these actions. The structure to use is the following:</p>

<p style="margin-top: 1em">{&lt;condition&gt;}[&lt;action
if condition is true&gt;] <br>
This syntax let you place an action (as the ones we saw just
above) inside the brackets &rsquo;[&rsquo; and
&rsquo;]&rsquo; (for example [Pp]) that will take effect
only if the <br>
evaluation of the &lt;condition&gt; is true. Stated that a
such statement is a new type of action, you may have guessed
that you may use it recursively: <br>

{&lt;condition1&gt;}[{&lt;condition2&gt;}[&lt;action&gt;]).</p>

<p style="margin-top: 1em">Well so far it seems useless.
But instead of the &quot;if &lt;condition&gt; then
&lt;action&gt; else &lt;action&gt;&quot; paradigm common to
programming languages, due to the command <br>
line context it has been chosen to instead use and implicit
&quot;OR&quot; operator between actions. Thus you can
&quot;stack&quot; conditional statements this way:
{&lt;condi&acirc; <br>
tion1&gt;}[&lt;action1&gt;]
{&lt;condition2&gt;}[&lt;action2&gt;] &lt;action3&gt;. In
this example, if &lt;condition1&gt; is true then
&lt;action1&gt; will be used, ELSE if &lt;condition2&gt; is
true <br>
then &lt;action2&gt; will be used ELSE &lt;action3&gt; will
be used. This leads to the same possibilities as what is
available with programming languages, but with a <br>
slightly more simple syntax. Seen this, the recursion of
conditional syntax is more interesting. For readability, you
are allowed to add any space or tab in <br>
the overwriting policy, but the resulting overwriting policy
must be given as a single argument to dar, thus the use of
quotes (either simple &Acirc;&acute;arg&Acirc;&acute; or
double <br>
&quot;arg&quot;) is necessary.</p>

<p style="margin-top: 1em">The last operator we will see is
the &rsquo;chain&rsquo; operator. Once an expression is
evaluated, the resulting couple of action may contain an
&rsquo;*&rsquo; (undefined action <br>
for EA or data). Further evaluation must be done. The chain
operator which is represented by a semi-column
&rsquo;;&rsquo; let one to separate several independent
expres&acirc; <br>
sions that will be evaluated in turn up to the time the
couple of action is fully defined. Once an action (for EA or
for Data) is defined, it can be redefined <br>
by a subsequent evaluation in the chain, however if the
action is defined it cannot be set back to undefined, thus
&rsquo;*&rsquo; will never overwrite a previously <br>
defined action. If at the end of the policy the couple of
action is not fully defined, the &rsquo;preserve&rsquo;
action is used (&rsquo;P&rsquo; or &rsquo;p&rsquo; depending
on which of EA or <br>
Data is left undefined). Here follow a example of
syntax:</p>

<p style="margin-top: 1em">-/
&quot;{&lt;condition1&gt;}[P*] O* ; {&lt;condition2&gt;[*p]
*o} ; Rr&quot; <br>
The first expression will evaluate to either P* or O*. At
this step, as the action is not completely defined, the
second part of the chain is evaluated, <br>
It will end with either *p or *o. In any case, we have after
this second statement of the chain a fully defined action
for both data and EA (either Pp, <br>
Po, Op or Oo). Thus the evaluation stops here and the
&quot;Rr&quot; policy will never be evaluated.</p>

<p style="margin-top: 1em">We now have one last thing to
see: the available conditions (what to place between braces
&rsquo;{&rsquo; and &rsquo;}&rsquo;). Conditions are defined
each by a letter, eventually <br>
followed by an argument between parenthesis. The usual
logical operators are available: negation (!), conjunction
(&amp;) disjunction (|). These characters must <br>
be escaped or quoted to not be interpreted by the shell when
used on command-line. In particular the &rsquo;!&rsquo;
under most shell must be quoted and escaped (-/ <br>
&rsquo;{R}[..]..&rsquo;, The escape character &rsquo;&acute;
is not necessary inside DCF files (those given to -B option)
as no shell is used to interpret these files. To these <br>
usual operators has been added a new one: the
&quot;inversion&quot; operator, noted &rsquo;~&rsquo;. Like
the negation, it is an unary operator but unlike the
negation, it inverses <br>
the roles of &rsquo;in place&rsquo; and &rsquo;to be
added&rsquo; for the evaluation, which is slightly different
from taking the negation of the result of the evaluation.
All these <br>
operators follow the usual precedence: unary operators
(&rsquo;!&rsquo; and &rsquo;~&rsquo;) are evaluated first,
then the conjunction &rsquo;&amp;&rsquo; then the
disjunction &rsquo;|&rsquo;. To override this, <br>
you can use parenthesis &rsquo;(&rsquo; and &rsquo;)&rsquo;
inside the condition. Over these logical operators, the
conditions are based on atomic operator that compare the
&rsquo;in <br>
place&rsquo; file to the &rsquo;to be added&rsquo; file.
Here they follow:</p>

<p style="margin-top: 1em">I true only if the &rsquo;in
place&rsquo; entry is an inode (a &rsquo;detruit&rsquo;
which record the fact that a file has been removed since the
archive of reference is not an <br>
inode for example). This condition do not have any
consideration toward the to be added object. Note that ~I
can be used to check the nature of the &rsquo;to <br>
be added&rsquo; object.</p>

<p style="margin-top: 1em">D true only if the &rsquo;in
place&rsquo; entry is a directory. To know whether the
&rsquo;to be added&rsquo; is a directory or not, one would
use the &quot;inversion&quot; operator: ~D</p>

<p style="margin-top: 1em">F true only if the &rsquo;in
place&rsquo; entry is a plain file (true also if this plain
file is a &rsquo;hard link&rsquo;, that&rsquo;s it if its
inode is linked several times to the <br>
directory tree)</p>

<p style="margin-top: 1em">H true only if the &rsquo;in
place&rsquo; entry is an inode linked several times to the
directory tree (= hard link) it may be a plain file, a Unix
socket, a pipe, <br>
char device, a block device for example.</p>

<p style="margin-top: 1em">A same as H but the current
&rsquo;in place&rsquo; entry is the first link we meet
pointing to that hard linked inode.</p>

<p style="margin-top: 1em">R true if the &rsquo;in
place&rsquo; entry is more recent than or of same date as
the &rsquo;to be added&rsquo; entry. The last modification
date [aka mtime] is used for this com&acirc; <br>
parison. If the &rsquo;to be added&rsquo; entry is not an
inode (and thus has no mtime), the &rsquo;in place&rsquo; is
considered to be more recent than the &rsquo;to be
added&rsquo; entry. <br>
Same thing if the &rsquo;in place&rsquo; entry is not an
inode (ad has no mtime available for comparison), it is here
too assumed to be more recent.</p>

<p style="margin-top: 1em">R(&lt;date&gt;) <br>
true if the &rsquo;in place&rsquo; entry is more recent than
or of the same date as the fixed &lt;date&gt; given in
argument. No consideration is done toward the &rsquo;to be
<br>
added&rsquo; element. The &lt;date&gt; format is the same as
the one used with -af option. If an entry has no mtime (it
is not an inode for example) it is assumed an <br>
virtual mtime of zero.</p>

<p style="margin-top: 1em">B true only if both &rsquo;in
place&rsquo; and &rsquo;to be added&rsquo; are plain file
(hard linked or not) and if the &rsquo;in place&rsquo;
file&rsquo;s data is larger or equal to the &rsquo;to be
<br>
added&rsquo; file&rsquo;s data. If one or both entry are not
plain files (or hard link to plain file) and thus the file
size comparison is not possible, the &rsquo;in <br>
place&rsquo; entry is assumed to be &rsquo;bigger&rsquo;
than the &rsquo;to be added&rsquo; entry.</p>

<p style="margin-top: 1em">S true only if the &rsquo;in
place&rsquo; data is saved in the archive (not marked as
unchanged since the archive of reference). Note that while
extracting files from <br>
an archive, the &rsquo;in place&rsquo; file is the one in
the filesystem, which always has its data
&rsquo;saved&rsquo; (from libdar point of view). The
&rsquo;inversion&rsquo; of this <br>
atomic operator ~S may still be interesting in the context
of restoration.</p>

<p style="margin-top: 1em">Y true only if the &rsquo;in
place&rsquo; data is saved but dirty (plain file having its
data changed at the time it was read for backup). Note, that
restoring in <br>
sequential read mode, it is not possible to known whether a
file is dirty (it is possible to know it once having read
its data, but sequential reading <br>
does not allows then to skip forward to get the dirty state
of the file and skip backward to eventually restore that
file, depending on the overwriting <br>
policy result).</p>

<p style="margin-top: 1em">X true only if the &rsquo;in
place&rsquo; data is a sparse file</p>

<p style="margin-top: 1em">T true only if the &rsquo;in
place&rsquo; and &rsquo;to be added&rsquo; entries are of
same type (plain file, Unix socket, named pipe, block
device, char device, symlink, direc&acirc; <br>
tory, &rsquo;detruit&rsquo; (which stands for file deleted
since the archive of reference was done), and so on). Note
that the number of links to inode (i.e. whether <br>
this is a hard links or not) is not taken into account.</p>

<p style="margin-top: 1em">e true if the &rsquo;in
place&rsquo; entry has EA (may they be saved or just
recorded as existing).</p>

<p style="margin-top: 1em">r true if the &rsquo;in
place&rsquo; entry has more recent or equal dated EA to the
&rsquo;to be added&rsquo; entry. If &rsquo;to be
added&rsquo; has no EA or is even not an inode, true is <br>
returned. If &rsquo;in place&rsquo; has no EA or is even not
an inode, true is returned unless &rsquo;to be added&rsquo;
has some EA. The comparison is done on ctime dates.</p>

<p style="margin-top: 1em">r(&lt;date&gt;) <br>
true if the &rsquo;in place&rsquo; entry has more recent or
equal dated EA to the fixed &lt;date&gt; given in argument.
No consideration is done toward the &rsquo;to be
added&rsquo; <br>
element. The &lt;date&gt; format is the same as the one used
with -af option. If an entry has no date (ctime date) (when
it is not an inode for example) it is <br>
assumed an virtual ctime of value zero.</p>

<p style="margin-top: 1em">m true only if &rsquo;in
place&rsquo; has more or equal number of EA entry in its set
of EA than &rsquo;to be added&rsquo; has. If an entry has
not EA or is not even an inode, it <br>
is assumed it has zero entry. The comparison is done on this
number. Note that the number of EA entry is not the size
used to store these entries. For <br>
example, the EA entry &quot;user.test&quot; counts for 1,
whatever is the length of the value associated to it.</p>

<p style="margin-top: 1em">b true if the &rsquo;in
place&rsquo; entry has bigger EA set or equal size EA set
than the &rsquo;to be added&rsquo; entry. If an entry has no
EA or is even not an inode, it is <br>
assumed that it has a zero byte length EA set. The
comparison is done on this number in that case. Note that
the comparison is done on the bytes used to <br>
store the whole EA set associated to a given file.</p>

<p style="margin-top: 1em">s true if the &rsquo;in
place&rsquo; entry is an inode (or a hard linked inode) and
has its EA saved in the archive of reference, not only
marked present but unchanged <br>
since last backup. This test does not take the &rsquo;to be
added&rsquo; entry into account.</p>

<p style="margin-top: 1em">Well, you&rsquo;ve seen that
uppercase letter are kept when comparison is based on the
inode or data while lowercase letter is used for atomics
based on EA. Now <br>
that we have completed our tour of this feature let&rsquo;s
see some examples:</p>

<p style="margin-top: 1em">-/ Pp <br>
as seen previously this is what does -n option for files
when no overwriting policy is defined, which avoids any
overwriting for Data as well as for EA.</p>

<p style="margin-top: 1em">-/ &quot;{!T}[Pp] {R}[{r}[Pp]Po]
{r}[Op] Oo&quot; <br>
Space and tabs are allowed to ease readability. Here the
policy stands for: If files in conflicts are not of the same
type then keep Data and EA of the <br>
entry &rsquo;in place&rsquo;. Else if &rsquo;in place&rsquo;
has a more recent data then if &rsquo;in place&rsquo; has
more recent EA then keep both its Data and EA, else keep
only its Data <br>
and overwrite its EA. Else (if &rsquo;in place&rsquo; has
not the more recent data), if it has the more recent EA then
overwrite the data but keep its EA, else over&acirc; <br>
write both its data and EA. This policy tends to preserve
the most recent data or EA, but it does not take into
account the fact that EA or Data is <br>
effectively saved into the archive of just marked as
unchanged since the archive of reference.</p>

<p style="margin-top: 1em">-/ &quot;{!T}[{~D}[Oo] Pp]&quot;
<br>
If entries are not of the same type, if the &rsquo;to be
added&rsquo; entry is a directory then we keep it and
overwrite the &rsquo;in place&rsquo; entry, else we keep the
&rsquo;in <br>
place&rsquo; entry. If entry are of same type, the policy
does not provide any action, thus the default action is
used: &quot;Pp&quot;. You can change this default <br>
action easily using a chain operator:</p>

<p style="margin-top: 1em">-/ &quot;{!T}[{~D}[Oo] Pp] ;
Aa&quot; <br>
In this case instead, if entry are of the same type, the
user will be asked what to.</p>

<p style="margin-top: 1em">-/ &quot;{!T|!I}[{R}[Pp] Oo]
{S}[{~S}[{R}[P*] O*] P*] {~S}[O*] {R}[P*] O*] ;
{s}[{~s}[{r}[*p] *o] *p] {~s}[*o] {r}[*p] *o]&quot; <br>
Well this may seems a bit too complex but just see it as an
illustration of what is possible to do: If both &rsquo;in
place&rsquo; and &rsquo;to be added&rsquo; are not of the
<br>
same type we keep data and EA of the most recent file (last
modification date). Else, both are of the same type. If both
are inode we evaluate a two <br>
expressions chain (expressions are separated by a
semi-column &rsquo;;&rsquo;) we will see in detail further.
Else if they are of same type but are not inode we take <br>
the EA and data of the most recent entry (this is the last
10 chars of the string). Well, now let&rsquo;s see the case
of inode: The first expression in the <br>
chain sets the action for data and keep the action for EA
undefined. While the seconds, is the exact equivalent but
instead it leaves the action for data <br>
undefined &rsquo;*&rsquo; and set the action for EA. These
two expressions follow the same principle: If both entries
are saved (by opposition to be marked as <br>
unchanged since the archive of reference) in the archives,
the most recent EA/Data is kept, else, the one of the inode
that is saved is kept, but if none <br>
is saved in the archive the most recent entry (mtime/ctime)
is kept.</p>

<p style="margin-top: 1em">-^, --slice-mode
perm[:user[:group]] <br>
defines the permission and ownership to use for created
slices. By default, dar creates slices with read and write
available for anyone letting the umask <br>
variable disable some privileges according to user&rsquo;s
preferences. If you need some more restricted permissions,
you can provide the permission as an octal <br>
value (thus beginning by a zero), like 0600 to only grant
read and write access to the user. Be careful not to avoid
dar writing to its own slices, if for <br>
example you provide permission such as 0400. Note also that
the umask is always applied thus specifying -^ 0777 will not
grant word wide read-write access <br>
unless your umask is 0000.</p>

<p style="margin-top: 1em">-_, --retry-on-change
count[:max-byte] <br>
When a file has changed at the time it was read for backup,
you can ask dar to retry saving it again. By default a file
can be re-saved up to 3 times (this is <br>
the &rsquo;count&rsquo; field), you can set it to zero to
disable this feature. In option the overall maximum amount
of byte allowed to be wasted due to retry changing <br>
file&rsquo;s backup can be given after a column charactrer
(:), this is the &rsquo;max-byte&rsquo; field. By default
(no --retry-on-change option specified) a limit of 1 wasted
<br>
byte is allowed which is the mininum. Specifying zero for
max-byte set no limit on the amount of wasted bytes (same as
if no &rsquo;max-byte&rsquo; was specified), each <br>
changing file is then saved up to &rsquo;count&rsquo; times
if necessary.</p>

<p style="margin-top: 1em">A file is considered as changed
when the last modification time has changed between the time
the file has been opened for backup and the time it has been
com&acirc; <br>
pletely read. In some situation it is not possible to
replace the already saved data for a file (writing archive
to a pipe for example), in that situation <br>
only, a second copy of the file is added just after the
first previous try which leads that previous try to becomes
inaccessible, however it holds some place <br>
in the archive, where from the designation of &quot;wasted
bytes&quot;. You can remove all wasted bytes from an archive
using the merging/fitering feature: dar -+ <br>
new_arch -A old_arch -ak.</p>

<p style="margin-top: 1em">Note: since release 2.5.0, in
normal condition no byte is wasted when a file changed at
the time it was read for backup, except when doing a backup
to pipe <br>
(using &rsquo;-c -&rsquo; option), except if the beginning
of the modified file is located in a previous slice and
except if slice hashing or strong encryption is used.</p>

<p style="margin-top: 1em">-ad, --alter=decremental <br>
This flag is to be used only when merging two archives.
Instead of the usual merging where each files of both
archives are added to the resulting archive with <br>
eventually a tie using the overwriting policy (see -/
option), here the merging builds an archive which
corresponds to the decremental backup done based on <br>
two full backups. the -A backup is expected to receive the
older archive while the -@ is expected to point to the more
recent one. If this option is used, the <br>
eventually overwriting policy is ignored and replaced
internally by -/ &quot;{T&amp;R&amp;~R&amp;(A|!H)}[S*] P* ;
{(e&amp;~e&amp;r&amp;~r)|(!e&amp;!~e)}[*s] *p&quot;.
Additionally, files found int <br>
the newer archive that do not existed in the older are
replaced by a &rsquo;detruit&rsquo; entry, which marks them
to be remove at restoration time. For more information <br>
about decremental backups read the usage_notes.html file in
the documentation.</p>

<p style="margin-top: 1em">-asecu, --alter=secu <br>
This option disable the ctime check done by default during
an differential backup: If the ctime of an plain file has
changed since the archive of reference <br>
was done while all other values stay unchanged (inode type,
ownership, permission, last modification date), dar issues a
&quot;SECURITY WARNING&quot;, as this may be <br>
the sign of the presence of a rootkit. You should use the
-asecu option to disable this type of warning globally, if
you are doing a differential backup of a <br>
just restored data (a differential backup with the archive
used for restoration taken as reference). Effectively in
that situation, as it is not possible to <br>
restore ctime, the restored data&rsquo;s ctime will have
changed while other parameters will be unchanged for all
restored files, leading dar to issue a warning for <br>
all restored files. This security check is disabled
(implicitly) if dar is run with -ac option. Last, if a file
has only its EA changed since the archive of <br>
reference was done (new EA, removed EA, modified EA), the
security warning will show (false positive).</p>

<p style="margin-top: 1em">-., --user-comment
&quot;&lt;message&gt;&quot; <br>
This option let the user add an arbitrary message into the
archive header. Warning! this message is always stored in
clear text, even if the archive is <br>
encrypted. You can see the message inserted in an archive
displaying the archive summary (dar -l &lt;archive&gt; -q).
Some macro can be used inside the &lt;message&gt;:</p>

<p style="margin-top: 1em">%c is replaced by the command
line used. Note that for security, any option related to
archive encryption is removed (-K, -J, -$, -#, -*, -%). The
command <br>
included from a DCF file (see -B option) are never added by
this macro. As a consequence, if you do not want to see
--user-comment stored in user com&acirc; <br>
ments you can add the --user-comment definition in an
included file like ~/.darrc for example.</p>

<p style="margin-top: 1em">%d this is the current date and
time</p>

<p style="margin-top: 1em">%u this is the uid under which
dar has been run</p>

<p style="margin-top: 1em">%g this is the gid under which
dar has been run</p>

<p style="margin-top: 1em">%h the hostname on which the
archive has been created</p>

<p style="margin-top: 1em">%% the % character.</p>

<p style="margin-top: 1em">-3, --hash &lt;algo&gt; With
this option set, when creating, isolating or merging an
archive, beside each generated slices an on-fly hash file of
the slice is created using the spec&acirc; <br>
ified algorithm. Available algorithm are &quot;md5&quot;,
&quot;sha1&quot; and &quot;sha512&quot;. By default no hash
file is generated. The hash file generated is named based on
the name <br>
of the slice with the .md5, .sha1 or .sha512 extension added
to it at the end. These hash files can be processes by
md5sum, sha1sum and sha512sum usual com&acirc; <br>
mands (md5sum -c &lt;hash file&gt;) to verify that the slice
has not been corrupted. Note that the result is different
than generating the hash file using md5sum or <br>
sha1sum once the slice is created, in particular if the
media is faulty: calling md5sum or sha1sum on the written
slice will make you compute the hash result <br>
on a possibly already corrupted file, thus the corruption
will not be seen when testing the file against the hash at a
later time. Note also that the creation <br>
of a hash file is not available when producing the archive
on a pipe (&quot;dar -c -&quot;).</p>

<p style="margin-top: 1em">-7, --sign
email[,email[,...email]] <br>
When creating an archive with public key encryption (read -K
option) it is also possible to sign it with one or more of
your private key(s). At the difference <br>
of the hash feature above, only the randomly generated key
used to cipher the archive, key that is dropped at the
beginning and at the end of the archive, is <br>
signed. If the archive is modified at some place, that part
will not be possible to decipher, but signature verification
will stay quick and valid, unless the <br>
part that has been tempered is the key inside the archive in
which case signature check will report a failure and archive
will not be readable at all. If the <br>
signature is valid and the archive could be extracted
without error, the whole archive could be assumed to be
signed by the gnupg key owners, but read below <br>
the security note. See also GNUPGHOME in the ENVIRONMENT
section at the end of this document.</p>

<p style="margin-top: 1em">A summay information about the
signature information is displayed while listing an archive
in summary mode &quot;dar -l &lt;archive&gt; -q&quot;. For
any operation involving <br>
a signed archive, a short message only shows if the archive
is signed an one or more signature check failed, no message
is displayed in case of successful <br>
signature check. This warning may be disabled using the
--alter=blind-to-signatures command.</p>

<p style="margin-top: 1em">-ab, --alter=blind-to-signatures
<br>
do not check whether an encrypted archive with public key
that has also been signed have correct signatures.</p>

<p style="margin-top: 1em">-&lt;, --backup-hook-include
&lt;mask&gt; <br>
The mask is applied to path+filename during backup operation
only. If a given file matches the mask, a user command (see
-= option below) will be run before <br>
proceeding to the backup and once the backup will be
completed. See also -&gt; option below. IMPORTANT: if using
the short option, you need to enclose it between <br>
quotes: &rsquo;-&lt;&rsquo; for the shell not to interpret
the &lt; as a redirection.</p>

<p style="margin-top: 1em">-&gt; --backup-hook-exclude
&lt;mask&gt; <br>
The mask is applied to path+filename during backup operation
only. If a given file matches the mask, even if it matches a
mask given after -&lt; option, no user <br>
command will be executed before and after its backup. The
-&lt; and -&gt; options act like -g and -P, they can receive
wildcard expression and thus have their com&acirc; <br>
portment driven by the --alter=globe and --alter=regex
expressions seen above, as well as the --alter=mask option.
Last the --alter=case and --alter=no-case <br>
modify also the way case sensitivity is considered for these
masks. By default, no -&gt; or -&lt; option, no file get
selected for backup hook. IMPORTANT: if using <br>
the short option, you need to enclose it between quotes:
&rsquo;-&gt;&rsquo; for the shell not to interpret the &gt;
as a redirection.</p>

<p style="margin-top: 1em">-=, --backup-hook-execute
&lt;string&gt; <br>
for files covered by the mask provided thanks to the -&lt;
and -&gt; options, the given string is executed before the
backup of that file starts and once it has <br>
completed. Several macro can be used that are substituted at
run time:</p>

<p style="margin-top: 1em">%% will be replaced by a literal
%</p>

<p style="margin-top: 1em">%p will be replaced by the full
path under backup</p>

<p style="margin-top: 1em">%f will be replaced by the
filename (without the path)</p>

<p style="margin-top: 1em">%u will be replaced by the UID
of the file</p>

<p style="margin-top: 1em">%g will be replaced by the GID
of the file</p>

<p style="margin-top: 1em">%t will be replaced by a letter
corresponding to the type of inode: &rsquo;f&rsquo; for
plain file, &rsquo;l&rsquo; for symlink, &rsquo;d&rsquo; for
directory, &rsquo;c&rsquo; for char devices, &rsquo;b&rsquo;
<br>
for block devices, &rsquo;s&rsquo; for sockets,
&rsquo;p&rsquo; for pipes, &rsquo;o&rsquo; for doors.</p>

<p style="margin-top: 1em">%c and most interesting, %c (c
for context), will be replaced by &quot;start&quot; or by
&quot;end&quot; when the command is executed before or after
the backup respec&acirc; <br>
tively. <br>
This way, one can stop a database just before it is about to
be backed up, and restart it once the backup has completed.
Note that the masks seen above that drive the execution <br>
of this command can be applied to a directory or a plain
file for example. When a directory is selected for this
feature, the command is logically ran before starting (with
the <br>
context &quot;start&quot;) to backup any file located in
that directory or in a subdirectory of it, and once all file
in that directory or subdirectories have been saved, the
command is <br>
ran a second time (with the context &quot;end&quot;). During
that time, if any file do match the backup-hook masks, no
command will be executed for these. It is assumed that when
a direc&acirc; <br>
tory has been asked for a backup-hook to be executed this
hook (or user command) is prepare for backup all data
located in that directory. The environment variable
DAR_DUC_PATH <br>
also applies to these user commands (see -E above, or the
ENVIRONMENT paragraph below).</p>

<p style="margin-top: 1em">-ai,
--alter=ignore-unknown-inode-type <br>
When dar meets an inode type it is not aware about (some
times ago, it was the case for Door inode on Solaris for
example, Door inodes are handled by dar <br>
since release 2.4.0), it issues a warning about its
inability to handle such inode. This warning occurs even if
that entry is filtered out by mean of -X, -I, <br>
-P, -g, -[ or -] options, as soon as some other entry in
that same directory has to be considered for backup, leading
dar to read that directory contents and <br>
failing on that unknown inode type (filtering is done based
on the result of directory listing). This option is to avoid
dar issuing such warning in that sit&acirc; <br>
uation.</p>

<p style="margin-top: 1em">RESTORATION SPECIFIC OPTIONS (to
use with -x)</p>

<p style="margin-top: 1em">-k[{ignored|only}],
--deleted[={ignore|only}] <br>
Without argument or with the &quot;ignore&quot; argument,
this option leads dar at restoration time to not delete
files that have been deleted since the backup of ref&acirc;
<br>
erence (file overwriting can still occur). By default, files
that have been destroyed since the backup of reference are
deleted during restoration, but a <br>
warning is issued before proceeding, except if -w is used.
If -n is used, no file will be deleted (nor overwritten),
thus -k is useless when using -n. If -/ <br>
option is used, this option without argument is ignored!
With the &quot;only&quot; argument, this option only
consider files marked as to be removed in the archive to
<br>
restore, no file are restored but some file are removed.
When -konly (or --deleted=only) is used, the -/ option is
ignored (at the opposition of the &quot;--no- <br>
delete=ignore&quot; option which is ignored when the -/ is
used). Of course &quot;--no-delete=ignore&quot; and
&quot;--no-delete=only&quot; are mutually exclusive, because
if both of <br>
them were available at the same time dar would do nothing at
all.</p>

<p style="margin-top: 1em">-r, --recent only restore files
that are absent or more recent than those present in
filesystem. If -/ option is used, this option is
ignored!</p>

<p style="margin-top: 1em">-f, --flat do not restore
directory structure. All file will be restored in the
directory given to -R, if two files of the same name have to
be restored, the usual <br>
scheme for warning (-w option) and overwriting (-n option)
is used. No rename scheme is planned actually. When this
option is set, dar does not remove files <br>
that have been stored as deleted since last backup. (-f
implicitly implies -k).</p>

<p style="margin-top: 1em">-ae, --alter=erase_ea <br>
[DEPRECATED use -/ instead] Drop all existing EA of files
present in filesystem that will have to be restored. This
way, the restored files will have the <br>
exact set of EA they had at the time of the backup. If this
option is not given, a file to restore will have its EA
overwritten by those present in the backup <br>
and if some extra EAs are present they will remain
untouched. See the Note concerning Extended Attributes (EA)
above for a detailed explanation about this <br>
behavior. If -/ option is used, this option is ignored!</p>

<p style="margin-top: 1em">-D, --empty-dir At restoration
time, if -D is not specified (default) any file and
directory is restored in regard to the filtering mechanism
specified (see -I, -X, -P, -g, <br>
-[ and -] options). But if -D option is provided the
restoration skips directory trees that do not contain saved
files. This avoid having a huge empty tree <br>
with a few restored files especially when restoring a
differential archive in an empty place. Note: This feature
cannot work when --sequential-read is used, <br>
as it is not possible to know whether a directory contains
or not some saved files at the time the directory inode is
read from the archive in sequential <br>
reading mode.</p>

<p style="margin-top: 1em">-2, --dirty-behavior { ignore |
no-warn } <br>
At restoration time, if a file in the archive is flagged as
&quot;dirty&quot; (meaning that it had changed at the time
it was saved), user is asked for confirmation <br>
before restoring it. Specifying &quot;ignore&quot; will skip
those dirty files, while &quot;no-warn&quot; will restore
them without user confirmation. This feature is
incompati&acirc; <br>
ble with sequential reading mode, in this mode dar cannot
know whether a file is dirty before having restored it. In
consequences, in --sequential-read, once <br>
a file has been restored, if it is found to be dirty it will
be removed unless dirty-behavior is set to
&quot;no-warn&quot;.</p>

<p style="margin-top: 1em">-/, --overwriting-policy
&lt;policy&gt; <br>
Overwriting policy can be used for archive restoration to
define when and how file overwriting can occur. See above
the description of this option.</p>

<p style="margin-top: 1em">-A, --ref
[&lt;path&gt;]/&lt;basename&gt; <br>
The --ref option can be used with an isolated catalogue to
rescue an archive that has a corruption in the catalogue
part, see GENERAL OPTIONS above for more <br>
details.</p>

<p style="margin-top: 1em">TESTING AND DIFFERENCE SPECIFIC
OPTIONS (to use with -t or -d)</p>

<p style="margin-top: 1em">-ado-not-compare-symlink-mtime,
--alter=do-not-compare-symlink-mtime <br>
With this option set, when comparing a symlink, no message
shows when symlink in archive and symlink on filesystem do
only differ by their mtime. See also -O <br>
option.</p>

<p style="margin-top: 1em">No other specific option, but
all general options are available except for example -w
which is useless, as testing and comparing only read data.
-A option is available as <br>
described in GENERAL OPTIONS to backup of internal catalogue
of the archive (assuming you have a previously isolated
catalogue available).</p>

<p style="margin-top: 1em">Doing a difference in sequential
read mode is possible but hard linked inodes can only be
compared to the filesystem the first time they are met, next
hard links to this same <br>
inode cannot obtain the corresponding data because skipping
backward in sequential read mode is forbidden. In that
situation, the hard links are reported as skipped, meaning
that <br>
data comparison could not be performed.</p>

<p style="margin-top: 1em">LISTING OPTIONS (to use with
-l)</p>

<p style="margin-top: 1em">-T, --list-format=&lt;normal |
tree | xml | slicing&gt;, --tree-format <br>
By default, listing provides a tar-like output (the
&rsquo;normal&rsquo; output). You can however get a
tree-like output, an XML structured output or a output
focusing on <br>
slice(s) where each file&rsquo;s data, EA and FSA is located
in. Providing -T without argument gives the same as
providing the &rsquo;tree&rsquo; argument to it. The option
<br>
--tree-format is an alias to --list-format=tree (backward
compatibility). Note that the files doc/dar-catalog-*.dtd
define the format of the XML output list&acirc; <br>
ing (This file is also installed under
$PREFIX/share/doc)</p>

<p style="margin-top: 1em">the -Tslicing option can also be
used with isolated catalogue generated with dar 2.5.0 or
above, as isolated catalogues now contain a copy of the
slicing lay&acirc; <br>
out of the archive of reference. However, if the archive of
reference has been resliced (using dar_xform) after the
isolated catalogue has been built, the <br>
slicing information would not be correct. For that corner
case, you can use the -s and -S options with -Tslicing to
specify what are the new slice sizes of <br>
the archive of reference.</p>

<p style="margin-top: 1em">-as, --alter=saved list only
saved files</p>

<p style="margin-top: 1em">-alist-ea, --alter=list-ea <br>
list Extended Attributes name for each file that has
some.</p>

<p style="margin-top: 1em">-I, -X, -P, -g, -[, -] <br>
can be used to filter file to list base on their name or
path.</p>

<p style="margin-top: 1em">From the general options it
seems only -vm and -b stay useful here. Note that -vm
displays an archive summary first, where a detailed of
information about the archive can be <br>
obtained. If you want to display only this summary use -q
with -l option.</p>

<p style="margin-top: 1em">displayed fields</p>

<p style="margin-top: 1em">[data] possible values are [ ]
or [Saved] or [InRef] or[DIRTY]. [ ] means that the data has
not been saved because there is no change since backup of
refer&acirc; <br>
ence. [Saved] means that the data has been saved, and thus
this archive is able to restore the file. [InRef] was used
in archive generated by dar version <br>
2.3.x and before, when isolating a catalogue from an archive
and means that the file was saved in the reference archive.
Last, [DIRTY] means that data is <br>
saved (like [Saved]) but has changed at the time dar was
reading it for backup, leading dar to possibly store the
file in a state it never had.</p>

<p style="margin-top: 1em">[EA] possible values are &quot;
&quot; (empty string) or [ ] or [InRef], [Saved] or [Suppr].
It Shows whether Extended Attributes are present and saved
([Saved]), are <br>
present but not saved ([ ]) which means there is no change
since backup of reference, if there is no EA saved for this
file (empty string) or if some EA <br>
were present in the archive of reference but none is
currently available ([Suppr]). [InRef] was used when
isolating a catalogue (release 2.3.x and before) <br>
from an archive and means that the file was saved in the
reference archive.</p>

<p style="margin-top: 1em">[FSA] Each character represent a
FSA Family:</p>

<p style="margin-top: 1em">&quot;L&quot; is the first
character (L/l/-) representing ext2/3/4 FSA family</p>

<p style="margin-top: 1em">&quot;H&quot; is the second
character (H/h/-) representing HFS+ FSA family</p>

<p style="margin-top: 1em">&quot;-&quot; the third
character is reserved for future FSA family and is always a
dash for now.</p>

<p style="margin-top: 1em">Uppercase means the FSA set is
saved, lowercase means the FSA is present in the archive of
reference and has not changed since that time. Last a dash
(-) <br>
means no FSA of that family has been saved for that
file.</p>

<p style="margin-top: 1em">[compr] possible values are
[....%] or [-----] or [ ] or [worse]. Shows if the file has
been compressed ([...%]) and the compression ratio reached
&quot;(uncompressed- <br>
compressed)/uncompressed&quot;, for example [ 33%] means
that the compressed data uses only 66% of the space required
to store uncompressed data (33% of space <br>
saved thanks to compression), or if the file is stored
without compression ([ ] see -m, -Y and -Z options) or if
the file is not subject to compression <br>
because it is not a saved regular file ([----]), or if the
file takes more space compressed than its original size
([worse]), due to compression overhead. <br>
Note that 1% compression ratio brings quite no data
reduction, while obviously 98% is a very performant
compression (compressed file takes only 2% of the size <br>
required by the uncompressed date).</p>

<p style="margin-top: 1em">[S] possible values are [ ] or
[X]. [X] only applies to saved plain files, and tells that
the file is stored using sparse file data structure: not all
data is <br>
stored, long sequence of zeros are skipped. This also means
that at restoration time, if the filesystem supports it,
holes will be restored. To store hole <br>
information libdar uses escape sequence (special sequence of
byte), but to avoid real data to be considered as such
escape sequence, a special escape sequence <br>
is used when data looks like an escape sequence. So if a
data contains a such escape sequence, it must be read as if
it contains holes to be able to restore <br>
back the data in its original form. For that reason, in some
rare circumstances (saving an dar archive inside a dar
archive without compression or encryption, <br>
for example) a file without hole may be marked [X] as if it
had holes and will be longer by on byte for each data
sequence looking like an escape sequence.</p>

<p style="margin-top: 1em">permission <br>
see ls man page. Note that a star (*) is prepended to the
permission string if the corresponding inode is linked
several times to the directory structure <br>
(hard link).</p>

<p style="margin-top: 1em">user owner of the file</p>

<p style="margin-top: 1em">group group owner of the
file</p>

<p style="margin-top: 1em">size size in byte of the file
(if compression is enabled, the real size in the archive is
&quot;compression rate&quot; time smaller).</p>

<p style="margin-top: 1em">date the last modification date
of the file. The last access time is also saved and
restored, but not displayed.</p>

<p style="margin-top: 1em">filename The name of the
file.</p>

<p style="margin-top: 1em">Extended Attributes <br>
When using -alist-ea option, for hard linked inode, the
filename is followed by an integer between braces: Entries
with the same number do point the the same <br>
inode.</p>

<p style="margin-top: 1em">Slice(s) In -Tslice mode, each
file is given the range of slices it is located in. If slice
size is chosen particularily small, some slices may contain
no file, EA, <br>
FSA data but only tape marks or the internal catalogue,
leading the aggregation of reported slices not to cover all
available slices of the archive.</p>

<p style="margin-top: 1em">EXPLICIT OPTIONAL ARGUMENTS <br>
When dar has not been compiled with GNU getopt, which is not
present by default on some systems like FreeBSD, you may
lack the optional arguments syntax. For example
&quot;-z&quot; will <br>
create a parse error on command-line, or in -B configuration
files. The solution is to explicitly give the argument. Here
follows a list of explicit argument to use in place of <br>
optional ones:</p>

<p style="margin-top: 1em">-z must be replaced by -z 9</p>

<p style="margin-top: 1em">-w must be replaced by -w d or
-w default</p>

<p style="margin-top: 1em">-H must be replaced by -H 1</p>

<p style="margin-top: 1em">-0 must be replaced by -0
ref</p>

<p style="margin-top: 1em">-5 must be replaced by -5
&quot;&quot;</p>

<p style="margin-top: 1em">-p must be replaced by -p 1</p>

<p style="margin-top: 1em">-v must be replaced by -v
all</p>

<p style="margin-top: 1em">-k must be replaced by -k
ignore</p>

<p style="margin-top: 1em">-5 must be replaced by -5
user.libdar_no_backup</p>

<p style="margin-top: 1em">important ! When using GNU
getopt(), optional arguments are available by sticking the
argument to the short option: &quot;-z&quot; for example is
available as well as &quot;-z9&quot;. But &quot;-z 9&quot;
is <br>
wrong, it will be read as &quot;-z&quot; option and
&quot;9&quot;, a command line argument (not an argument to
the -z option). In the other side, when using a non GNU
getopt this time, &quot;-z&quot; becomes <br>
an option that always requires an argument, and thus
&quot;-z 9&quot; is read as &quot;-z&quot; option with
&quot;9&quot; as argument, while &quot;-z9&quot; will be
rejected as a unknown option, and &quot;-z&quot; alone will
<br>
generate an error as no argument is provided. In
consequences, you need a space between the option (like
&quot;-z&quot;) and its argument (like &quot;9&quot;), when
dar does not rely on a GNU <br>
getopt() call, which also imply you to explicitly use
arguments to options listed just above.</p>

<p style="margin-top: 1em">EXIT CODES <br>
dar exits with the following code:</p>

<p style="margin-top: 1em">0 Operation successful.</p>

<p style="margin-top: 1em">1 Syntax error on command-line
or DCF included file</p>

<p style="margin-top: 1em">2 Error due to a hardware
problem or a lack of memory.</p>

<p style="margin-top: 1em">3 Detection of a condition that
should never happen, and which is considered as a bug of the
application.</p>

<p style="margin-top: 1em">4 Code issued when the user has
aborted the program upon dar question from dar. This also
happens when dar is not run from a terminal (for example
launched from crontab) <br>
and dar has a question to the user. In that case, dar aborts
the same way as if the user pressed the escape key at the
question prompt.</p>

<p style="margin-top: 1em">5 is returned when an error
concerning the treated data has been detected. While saving,
this is the case when a file could not be opened or read.
While restoring, it is <br>
the case when a file could not be created or replaced. While
comparing, it is the case when a file in the archive does
not match the one in the filesystem. While test&acirc; <br>
ing, it is the case when a file is corrupted in the
archive.</p>

<p style="margin-top: 1em">6 an error occurred while
executing user command (given with -E or -F option). Mainly
because the creation of a new process is not possible
(process table is full) or the <br>
user command returned an error code (exit status different
from zero).</p>

<p style="margin-top: 1em">7 an error has occurred when
calling a libdar routine. This means the caller (dar
program), did not respect the specification of the API (and
this can be considered as a <br>
particular case of bug).</p>

<p style="margin-top: 1em">8 the version of dar used is
based in finite length integers (it has been compiled with
the option --enable-mode=...). This code is returned when an
integer overflow <br>
occurred. use the full version (based in the so called
&quot;infinint&quot; class) to avoid this error.</p>

<p style="margin-top: 1em">9 this code indicates an unknown
error. The exception caching code to take care of new
exceptions has probably been forgotten to be update ... this
is a minor bug you are <br>
welcome to report.</p>

<p style="margin-top: 1em">10 you have tried to use a
feature that has been disabled at compilation time.</p>

<p style="margin-top: 1em">11 some saved files have changed
while dar was reading them, this may lead the data saved for
this file not correspond to a valid state for this file. For
example, if the <br>
beginning and the end of the file have been modified at the
same time (while dar is reading it), only the change at the
end will be saved (the beginning has already <br>
been read), the resulting state of the file as recorded by
dar has never existed and may cause problem to the
application using it. This is known as a &quot;dirty&quot;
file in <br>
the archive.</p>

<p style="margin-top: 1em">SIGNALS <br>
If dar receives a signal (see kill(2) man page) it will take
the default behavior which most of the time will abruptly
abort the program, except for the following signals:</p>

<p style="margin-top: 1em">SIGINT This signal is generated
by the terminal when hitting CTRL-C (with the
terminal&rsquo;s default settings), it can also be generated
with the kill command</p>

<p style="margin-top: 1em">SIGTERM This signal is generated
by the system when changing of run-level in particular when
doing a shutdown, it can also be generated with the kill
command</p>

<p style="margin-top: 1em">SIGHUP Depending on the system,
this signal may be sent before the SIGTERM signal at
shutdown time, it can also be generated with the kill
command</p>

<p style="margin-top: 1em">SIGQUIT This signal is generated
by the terminal when hitting CTRL-&nbsp;(with the
terminal&rsquo;s default settings), it can also be generated
with the kill command</p>

<p style="margin-top: 1em">SIGUSR1 This signal can be
generated by the kill command</p>

<p style="margin-top: 1em">SIGUSR2 This signal can be
generated by the kill command</p>

<p style="margin-top: 1em">For those previous signals, two
behavior exit. For SIGHUP, SIGINT, SIGQUIT, SIGTERM and
SIGUSR1, a delayed termination is done: the backup or
isolation operation is stopped, the <br>
catalogue is appended to the archive and the archive is
properly completed with the correct terminator string, this
way the generated archive is usable, and can be used as
refer&acirc; <br>
ence for a differential backup at a later time. Note that if
an on-fly isolation had been asked, it will *not* be
performed, and no user command will be launched even if dar
has <br>
been configured for (-E option). For SIGUSR2 instead a fast
termination is done: in case of backup or isolation, the
archive is not completed at all, only memory and mutex are
<br>
released properly.</p>

<p style="margin-top: 1em">For both type of termination and
other operations than backup or isolation, dar&rsquo;s
behavior is the same: For restoration, all opened
directories are closed and permissions are set <br>
back to their original values (if they had to be changed for
restoration). For listing, comparison, testing, the program
aborts immediately.</p>

<p style="margin-top: 1em">Another point, when using one of
the previous signals, dar will return with the exist status
4 meaning that the user has aborted the operation. Note that
answering &quot;no&quot; to a <br>
question from dar may also lead dar to exit this way. last,
If before the end of the program the same signal is received
a second time, dar will abort immediately.</p>

<p style="margin-top: 1em">FILES <br>
$HOME/.darrc and /etc/darrc if present are read for
configuration option. They share the same syntax as file
given to -B option. If $HOME/.darrc is not present and only
in that <br>
case, /etc/darrc is consulted. You can still launch
/etc/darrc from .darrc using a statement like -B /etc/darrc.
None of these file need to be present, but if they are they
are <br>
parsed AFTER any option on the command line and AFTER
included files from the command line (files given to the -B
option). NOTE: if $HOME is not defined $HOME/.darrc default
to <br>
/.darrc (at the root of the filesystem).</p>

<p style="margin-top: 1em">Else you can see conditional
syntax below, and -N option above that leads dar to ignore
the /etc/darrc and $HOME/.darrc files.</p>

<p style="margin-top: 1em">CONDITIONAL SYNTAX <br>
configuration files (-B option, $HOME/.darrc and /etc/darrc)
usually contain a simple list of command-line arguments,
split or not over several lines, and eventually mixed with
<br>
comments (see -B option for more). But, you can also use
make-like targets to ask for a particular set of commands to
be used in certain conditions.</p>

<p style="margin-top: 1em">A condition takes the form of
reserved word immediately followed by a colon
&rsquo;:&rsquo;. This word + colon must stand alone on its
line, eventually with spaces or tabs beside it. The <br>
available conditions are:</p>

<p style="margin-top: 1em">extract: all option listed after
this condition get used if previously on command line or
file the -x option has been used</p>

<p style="margin-top: 1em">create: all option listed after
this condition get used if previously on command line or
file (-B option) the -c option has been used</p>

<p style="margin-top: 1em">list: (or listing:) if -l option
has been used</p>

<p style="margin-top: 1em">test: if -t option has been
used</p>

<p style="margin-top: 1em">diff: if -d option has been
used</p>

<p style="margin-top: 1em">isolate: if -C option has been
used</p>

<p style="margin-top: 1em">merge: if -+ option has been
used</p>

<p style="margin-top: 1em">reference: if -A option has been
used (except when -A is used for the snapshot feature or in
conjunction with -af)</p>

<p style="margin-top: 1em">auxiliary: if -@ option has been
used</p>

<p style="margin-top: 1em">all: in any case</p>

<p style="margin-top: 1em">default: if no -c, -d, -x, -t,
-C, -l or -+ option has been used at this point of the
parsing.</p>

<p style="margin-top: 1em">The condition stops when the
next condition starts, or at End of File. The commands
inserted before any condition are equivalent to those
inserted after the &quot;all:&quot; condition. <br>
Remark : -c -d -x -t -C and -l are mutual exclusive, only
one of them can be used while calling dar.</p>

<p style="margin-top: 1em">Here is an example of
conditional syntax</p>

<p style="margin-top: 1em">create: <br>
# upon creation exclude the <br>
# following files from compression <br>
-Z &quot;*.mp3&quot; -Z &quot;*.mpg&quot;</p>

<p style="margin-top: 1em">all: <br>
-b <br>
-p</p>

<p style="margin-top: 1em">default: <br>
# this will get read if not <br>
# command has been set yet <br>
-V <br>
# thus by default dar shows its version</p>

<p style="margin-top: 1em">all: <br>
-v <br>
# for any command we also ask to be verbose <br>
# this is added to the previous all: condition</p>

<p style="margin-top: 1em">Last point, you may have several
time the same condition (several all: ) for example. They
will be concatenated together.</p>

<p style="margin-top: 1em">USER TARGETS <br>
User targets are arbitrary words found on command line, that
do not start by a dash (&rsquo;-&rsquo;). On most system
they should be placed after command and options. They are
collected from <br>
command-line first, then comes the parsing of command and
optional arguments. Their use is to extend conditional
syntax described just above by having a set of options
activated <br>
by the user just adding a single word on command-line. Of
course user targets must not be equal to one of the reserved
words of the conditional syntax (extract, create, ... all,
<br>
default). A valid target is a word (thus without space)
composed of lowercase or uppercase letters (case is
sensitive) with eventually digits, dashes &rsquo;-&rsquo; or
underscores &rsquo;_&rsquo; char&acirc; <br>
acters.</p>

<p style="margin-top: 1em">Let&rsquo;s see an example of
use:</p>

<p style="margin-top: 1em">first a DCF file named
&rsquo;example.dcf&rsquo; that will be given on command
line:</p>

<p style="margin-top: 1em"># normal set of files considered
for backup</p>

<p style="margin-top: 1em">create: <br>
-R / <br>
-P proc <br>
-P sys <br>
-P mnt <br>
-D</p>

<p style="margin-top: 1em"># if the &quot;home&quot; user
target is applied on command line the following command get
added</p>

<p style="margin-top: 1em">home: <br>
-g home</p>

<p style="margin-top: 1em"># if the &quot;verbose&quot;
user target is used, we will have some more verbosity
...</p>

<p style="margin-top: 1em">verbose: <br>
-v <br>
-vs</p>

<p style="margin-top: 1em">Then we could run dar in the
following ways:</p>

<p style="margin-top: 1em">dar -c test -B example.dcf <br>
in that case only the command in the &quot;create:&quot;
section of example.dcf would be used.</p>

<p style="margin-top: 1em">dar -c test -B example.dcf
verbose <br>
here over the &quot;create:&quot; target the commands under
the &quot;verbose:&quot; target (-v and -vs) would be also
used</p>

<p style="margin-top: 1em">dar -c test -B example.dcf
verbose home <br>
last we use two user targets &quot;verbose:&quot; and
&quot;home:&quot; in addition the the &quot;create:&quot;
target of the usual conditional syntax.</p>

<p style="margin-top: 1em">Note that if the last option
*may* receive an argument, the first user target that
follows it will be assumed an argument to that option. To
avoid this, either change the order <br>
of options on command line for the last option been an
option that never or always uses an argument (for example -b
never has an argument while -s always has one). Or separate
<br>
the options from the user targets by the -- word. And of
course you can also use the explicit argument of the last
option (see EXPLICIT OPTIONAL ARGUMENT section, above).</p>

<p style="margin-top: 1em">Second point: It is allowed to
have user targets inside a DCF file. Note however that
targets are collected in a first phase, which leads some
part of the file to be hidden <br>
(because the corresponding conditional syntax or user target
is not present). Then, the remaining part of the file is
then parsed and actions for each option found is taken. At
<br>
that time, new user targets found are just recorded, but
they do not modify the current DCF file layout, in
particular, hidden part of the file stay hidden even if the
corre&acirc; <br>
sponding user target is read in this same file. Next DCF
parsing (which may be triggered by a second -B option on the
command line, or by a -B option inside the current parsed
<br>
DCF file) will thus be done with the additional targets
found in that first DCF file, so in a way you may have user
targets that activate other user targets, but they will be
<br>
activated in starting the next -B file. Here follows an
examples of two DCF files, first.dcf and second.dcf:</p>

<p style="margin-top: 1em"># cat first.dcf <br>
target3: <br>
-K toto</p>

<p style="margin-top: 1em">target1: <br>
target2 <br>
-B second.dcf <br>
target3</p>

<p style="margin-top: 1em">target2: <br>
#never reached <br>
-s 10k</p>

<p style="margin-top: 1em"># cat second.dcf <br>
target2: <br>
-v <br>
target3: <br>
-b</p>

<p style="margin-top: 1em">In that example, target1
activates both target2 and target3, but at the time of the
parsing of first.dcf, neither target2 nor target3 were yet
activated thus &rsquo;-K toto&rsquo; and &rsquo;-s <br>
10k&rsquo; will never be given to dar (unless activated
beside target1 before first.dcf get parsed), however when
comes the time to parse second.dcf, target2 *and* target3
are acti&acirc; <br>
vated, thus both &rsquo;-v&rsquo; and &rsquo;-b&rsquo; will
be passed to dar, even if &rsquo;target3&rsquo; is located
after &rsquo;-B second.dcf&rsquo; in the file first.dcf</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
DAR_DCF_PATH <br>
if set, dar looks for Dar Configuration File (DCF files, see
-B option) that do not have an fully qualified path in the
directories listed in DAR_DCF_PATH environment <br>
variable. This variable receives a column (:) separated list
of paths and look in each of them in turn, up to the first
file found under the requested name.</p>

<p style="margin-top: 1em">DAR_DUC_PATH <br>
if set, dar looks for Dar User Command (DUC files, see -E,
-F, -~, -= options) that do not have a fully qualified path
in the directories listed in DAR_DUC_PATH. This <br>
variable receives a column (:) separated list of paths and
looks in each of them in turn, up to the first file found
under the requested name.</p>

<p style="margin-top: 1em">GNUPGHOME for asymetric
encryption and signature, the keyring used is $HOME/.gnupg
by default. You can change this default by setting GNUPGHOME
to the directory containing the <br>
keyring. For example, if you are running dar as root and
want to use your unprivileged account keyring use the
following:</p>

<p style="margin-top: 1em">export
GNUPGHOME=~myaccount/.gnupg</p>

<p style="margin-top: 1em">dar -K gnupg:...@...,...@...
--sign:...@... etc.</p>

<p style="margin-top: 1em">EXAMPLES <br>
You can find some more examples of use in the tutorial,
mini-howto, sample scripts, and other related documentation.
All these are available in dar&rsquo;s source package, and
are also <br>
installed beside dar in the &lt;--prefix&gt;/share/dar
directory. This documentation is also available on-line at
http://dar.linux.free.fr/doc/index.html</p>

<p style="margin-top: 1em">SEE ALSO <br>
dar_xform(1), dar_slave(1), dar_manager(1), dar_cp(1),
dar_split(1), TUTORIAL and NOTES included in the source
package and also available at <br>
http://dar.linux.free.fr/doc/index.html</p>

<p style="margin-top: 1em">KNOWN LIMITATIONS <br>
dar saves and restores atime, mtime, birthtime but cannot
restore ctime (last inode change), there does not seems to
be a standard call to do that under UNIX.</p>

<p style="margin-top: 1em">KNOWN BUGS <br>
http://sourceforge.net/p/dar/bugs/</p>

<p style="margin-top: 1em">AUTHOR <br>
http://dar.linux.free.fr/ <br>
Denis Corbin <br>
France <br>
Europe</p>

<p style="margin-top: 1em">3rd Berkeley Distribution
January 2nd, 2017 DAR(1)</p>
<hr>
</body>
</html>
