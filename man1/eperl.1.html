<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:07:26 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>EPERL(1) Ralf S. Engelschall EPERL(1)</p>

<p style="margin-top: 1em">NAME <br>
ePerl - Embedded Perl 5 Language</p>

<p style="margin-top: 1em">VERSION <br>
@V@</p>

<p style="margin-top: 1em">SYNOPSIS <br>
eperl [-d name=value] [-D name=value] [-B begin_delimiter]
[-E end_delimiter] [-i] [-m mode] [-o outputfile] [-k] [-I
directory] [-P] [-C] [-L] [-x] [-T] [-w] [-c]
[inputfile]</p>

<p style="margin-top: 1em">eperl [-r] [-l] [-v] [-V]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Abstract <br>
ePerl interprets an ASCII file bristled with Perl 5 program
statements by evaluating the Perl 5 code while passing
through the plain ASCII data. It can operate in various
ways: <br>
As a stand-alone Unix filter or integrated Perl 5 module for
general file generation tasks and as a powerful Webserver
scripting language for dynamic HTML page programming.</p>

<p style="margin-top: 1em">Introduction <br>
The eperl program is the Embedded Perl 5 Language
interpreter. This really is a full-featured Perl 5
interpreter, but with a different calling environment and
source file layout <br>
than the default Perl interpreter (usually the executable
perl or perl5 on most systems). It is designed for general
ASCII file generation with the philosophy of embedding the
<br>
Perl 5 program code into the ASCII data instead of the usual
way where you embed the ASCII data into a Perl 5 program
(usually by quoting the data and using them via
&quot;print&quot; <br>
statements). So, instead of writing a plain Perl script
like</p>

<p style="margin-top: 1em">#!/path/to/perl <br>
print &quot;foo bar0; <br>
print &quot;baz quux0; <br>
for ($i = 0; $i &lt; 10; $i++) { print &quot;foo #${i}0; }
<br>
print &quot;foo bar0; <br>
print &quot;baz quux0;</p>

<p style="margin-top: 1em">you can write it now as an ePerl
script:</p>

<p style="margin-top: 1em">#!/path/to/eperl <br>
foo bar <br>
baz quux <br>
&lt;: for ($i = 0; $i &lt; 10; $i++) { print &quot;foo
#${i}0; } :&gt; <br>
foo bar <br>
baz quux</p>

<p style="margin-top: 1em">Although the ePerl variant has a
different source file layout, the semantic is the same, i.e.
both scripts create exactly the same resulting data on
&quot;STDOUT&quot;.</p>

<p style="margin-top: 1em">Intention <br>
ePerl is simply a glue code which combines the programming
power of the Perl 5 interpreter library with a tricky
embedding technique. The embedding trick is this: it
converts <br>
the source file into a valid Perl script which then gets
entirely evaluated by only one internal instance of the Perl
5 interpreter. To achieve this, ePerl translates all plain
<br>
code into (escaped) Perl 5 strings placed into print
constructs while passing through all embedded native Perl 5
code. As you can see, ePerl itself does exactly the same
<br>
internally, a silly programmer had to do when writing a
plain Perl generation script.</p>

<p style="margin-top: 1em">Due to the nature of such
bristled code, ePerl is really the better attempt when the
generated ASCII data contains really more static as dynamic
data. Or in other words: Use <br>
ePerl if you want to keep the most of the generated ASCII
data in plain format while just programming some bristled
stuff. Do not use it when generating pure dynamic data.
There <br>
it brings no advantage to the ordinary program code of a
plain Perl script. So, the static part should be at least
60% or the advantage becomes a disadvantage.</p>

<p style="margin-top: 1em">ePerl in its origin was actually
designed for an extreme situation: as a webserver
scripting-language for on-the-fly HTML page generation. Here
you have the typical case that <br>
usually 90% of the data consists of pure static HTML tags
and plain ASCII while just the remaining 10% are programming
constructs which dynamically generate more markup code. <br>
This is the reason why ePerl beside its standard Unix
filtering runtime-mode also supports the CGI/1.1 and
NPH-CGI/1.1 interfaces.</p>

<p style="margin-top: 1em">Embedded Perl Syntax <br>
Practically you can put any valid Perl constructs inside the
ePerl blocks the used Perl 5 interpreter library can
evaluate. But there are some important points you should
always <br>
remember and never forget when using ePerl:</p>

<p style="margin-top: 1em">1. Delimiters are always
discarded. <br>
Trivially to say, but should be mentioned at least once. The
ePerl block delimiters are always discarded and are only
necessary for ePerl to recognize the embedded Perl <br>
constructs. They are never passed to the final output.</p>

<p style="margin-top: 1em">2. Generated content has to go
to &quot;STDOUT&quot;. <br>
Although you can define subroutines, calculate some data,
etc. inside ePerl blocks only data which is explicitly
written to the &quot;STDOUT&quot; filehandle is expanded. In
other <br>
words: When an ePerl block does not generate content on
&quot;STDOUT&quot;, it is entirely replaced by an empty
string in the final output. But when content is generated it
is put at <br>
the point of the ePerl block in the final output. Usually
contents is generated via pure &quot;print&quot; constructs
which implicitly use &quot;STDOUT&quot; when no filehandle
is given.</p>

<p style="margin-top: 1em">3. Generated content on
&quot;STDERR&quot; always leads to an error. <br>
Whenever content is generated on the &quot;STDERR&quot;
filehandle, ePerl displays an error (including the STDERR
content). Use this to exit on errors while passing errors
from ePerl <br>
blocks to the calling environment.</p>

<p style="margin-top: 1em">4. Last semicolon. <br>
Because of the following point 6 (see below) and the fact
that most of the users don&rsquo;t have the internal ePerl
block translations in mind, ePerl is smart about the last
<br>
semicolon. Usually every ePerl block has to end with the
semicolon of the last command.</p>

<p style="margin-top: 1em">&lt;: cmd; ...; cmd; :&gt;</p>

<p style="margin-top: 1em">But when the last semicolon is
missing it is automatically added by ePerl, i.e.</p>

<p style="margin-top: 1em">&lt;: cmd; ...; cmd :&gt;</p>

<p style="margin-top: 1em">is also correct syntax. But
sometimes it is necessary to force ePerl not to add the
semicolon. Then you can add a
&lsquo;&lsquo;&quot;_&quot;&rsquo;&rsquo; (underscore) as
the last non-whitespace character <br>
in the block to force ePerl to leave the final semicolon.
Use this for constructs like the following</p>

<p style="margin-top: 1em">&lt;: if (...) { _:&gt; <br>
foo <br>
&lt;: } else { _:&gt; <br>
bar <br>
&lt;: } :&gt;</p>

<p style="margin-top: 1em">where you want to spread a Perl
directive over more ePerl blocks.</p>

<p style="margin-top: 1em">5. Shorthand for
&quot;print&quot;-only blocks. <br>
Because most of the time ePerl is used just to interpolate
variables, e.g.</p>

<p style="margin-top: 1em">&lt;: print $VARIABLE; :&gt;</p>

<p style="margin-top: 1em">it is useful to provide a
shortcut for this kind of constructs. So ePerl provides a
shortcut via the character &rsquo;=&rsquo;. When it
immediately (no whitespaces allowed here) follows <br>
the begin delimiter of an ePerl block a &quot;print&quot;
statement is implicitly generated, i.e. the above block is
equivalent to</p>

<p style="margin-top: 1em">&lt;:=$VARIABLE:&gt;</p>

<p style="margin-top: 1em">Notice that the semicolon was
also removed here, because it gets automatically added (see
above).</p>

<p style="margin-top: 1em">6. Special EndOfLine discard
command for ePerl blocks. <br>
ePerl provides a special discard command named
&lsquo;&lsquo;&quot;//&quot;&rsquo;&rsquo; which discards
all data up-to and including the following newline character
when directly followed an end block <br>
delimiter. Usually when you write</p>

<p style="margin-top: 1em">foo <br>
&lt;: $x = 1; :&gt; <br>
quux</p>

<p style="margin-top: 1em">the result is</p>

<p style="margin-top: 1em">foo</p>

<p style="margin-top: 1em">quux</p>

<p style="margin-top: 1em">because ePerl always preserves
code around ePerl blocks, even just newlines. But when you
write</p>

<p style="margin-top: 1em">foo <br>
&lt;: $x = 1; :&gt;// <br>
quux</p>

<p style="margin-top: 1em">the result is</p>

<p style="margin-top: 1em">foo <br>
quux</p>

<p style="margin-top: 1em">because the
&lsquo;&lsquo;&quot;//&quot;&rsquo;&rsquo; deleted all stuff
to the end of the line, including the newline.</p>

<p style="margin-top: 1em">7. Restrictions in parsing. <br>
Every program has its restrictions, ePerl too. Its handicap
is that Perl is not only a rich language, it is a horrible
one according to parsing its constructs. Perhaps you <br>
know the phrase ,,Only perl can parse Perl&rsquo;&rsquo;.
Think about it. The implication of this is that ePerl never
tries to parse the ePerl blocks itself. It entirely relies
on the <br>
Perl interpreter library, because it is the only instance
which can do this without errors. But the problem is that
ePerl at least has to recognize the begin and end <br>
positions of those ePerl blocks.</p>

<p style="margin-top: 1em">There are two ways: It can
either look for the end delimiter while parsing but at least
recognize quoted strings (where the end delimiter gets
treated as pure data). Or it <br>
can just move forward to the next end delimiter and say that
it have not occur inside Perl constructs. In ePerl 2.0 the
second one was used, while in ePerl 2.1 the first one <br>
was taken because a lot of users wanted it this way while
using bad end delimiters like
&lsquo;&lsquo;&quot;&gt;&quot;&rsquo;&rsquo;. But actually
the author has again revised its opinion and decided to
finally <br>
use the second approach which is used since ePerl 2.2 now.
Because while the first one allows more trivial delimiters
(which itself is not a really good idea), it fails when <br>
constructs like
&lsquo;&lsquo;&quot;m|&quot;[^&quot;]+&quot;|&quot;&rsquo;&rsquo;
etc. are used inside ePerl blocks. And it is easier to
escape end delimiters inside Perl constructs (for instance
via backslashes in quoted <br>
strings) than rewrite complex Perl constructs to use even
number of quotes.</p>

<p style="margin-top: 1em">So, whenever your end delimiter
also occurs inside Perl constructs you have to escape it in
any way.</p>

<p style="margin-top: 1em">8. HTML entity conversion. <br>
Because one of ePerl&rsquo;s usage is as a server-side
scripting-language for HTML pages, there is a common problem
in conjunction with HTML editors. They cannot know ePerl
<br>
blocks, so when you enter those blocks inside the editors
they usually encode some characters with the corresponding
HTML entities. The problem is that this encoding leads to
<br>
invalid Perl code. ePerl provides the option -C for decoding
these entities which is automatically turned on in CGI
modes. See description below under option -C for more <br>
details.</p>

<p style="margin-top: 1em">Runtime Modes <br>
ePerl can operate in three different runtime modes:</p>

<p style="margin-top: 1em">Stand-alone Unix filter mode
<br>
This is the default operation mode when used as a generation
tool from the Unix shell or as a batch-processing tool from
within other programs or scripts:</p>

<p style="margin-top: 1em">$ eperl [options] - &lt;
inputfile &gt; outputfile <br>
$ eperl [options] inputfile &gt; outputfile <br>
$ eperl [options] -o outputfile - &lt; inputfile <br>
$ eperl [options] -o outputfile inputfile</p>

<p style="margin-top: 1em">As you can see, ePerl can be
used in any combination of STDIO and external files.
Additionally there are two interesting variants of using
this mode. First you can use ePerl <br>
in conjunction with the Unix Shebang magic technique to
implicitly select it as the interpreter for your script
similar to the way you are used to with the plain Perl <br>
interpreter:</p>

<p style="margin-top: 1em">#!/path/to/eperl [options] <br>
foo <br>
&lt;: print &quot;bar&quot;; :&gt; <br>
quux</p>

<p style="margin-top: 1em">Second, you can use ePerl in
conjunction with the Bourne-Shell Here Document technique
from within you shell scripts:</p>

<p style="margin-top: 1em">#!/bin/sh <br>
... <br>
eperl [options] - &lt;&lt;EOS <br>
foo <br>
&lt;: print &quot;quux&quot;; :&gt; <br>
quux <br>
EOS <br>
...</p>

<p style="margin-top: 1em">If you need to generate shell or
other scripts with ePerl, i.e. you need a shebang line in
the output of eperl, you have to add a shebang line
containing e.g. <br>
&quot;#!/usr/bin/eperl&quot; first, because eperl will strip
the first line from the input if it is a shebang line.
Example:</p>

<p style="margin-top: 1em">#!/usr/bin/eperl <br>
#!/bin/sh <br>
echo &lt;: print &quot;quux&quot;; :&gt;</p>

<p style="margin-top: 1em">will result in the following
output:</p>

<p style="margin-top: 1em">#!/bin/sh <br>
echo quux</p>

<p style="margin-top: 1em">Alternatively you can add a
preprocessor comment in the first line, e.g. like this:</p>

<p style="margin-top: 1em">#c This is a comment to preserve
the shebang line in the following line <br>
#!/bin/sh <br>
echo &lt;: print &quot;quux&quot;; :&gt;</p>

<p style="margin-top: 1em">And finally you can use ePerl
directly from within Perl programs by the use of the
Parse::ePerl(3) package (assuming that you have installed
this also; see file INSTALL <br>
inside the ePerl distribution for more details):</p>

<p style="margin-top: 1em">#!/path/to/perl <br>
... <br>
use Parse::ePerl; <br>
... <br>
$script = &lt;&lt;EOT; <br>
foo <br>
&lt;: print &quot;quux&quot;; :&gt; <br>
quux <br>
EOT <br>
... <br>
$result = Parse::ePerl::Expand({ <br>
Script =&gt; $script, <br>
Result =&gt; esult, <br>
}); <br>
... <br>
print $result; <br>
...</p>

<p style="margin-top: 1em">See Parse::ePerl(3) for more
details.</p>

<p style="margin-top: 1em">CGI/1.1 compliant interface mode
<br>
This is the runtime mode where ePerl uses the CGI/1.1
interface of a webserver when used as a Server-Side
Scripting Language on the Web. ePerl enters this mode
automatically <br>
when the CGI/1.1 environment variable
&quot;PATH_TRANSLATED&quot; is set and its or the scripts
filename does not begin with the NPH prefix
&lsquo;&lsquo;nph-&rsquo;&rsquo;. In this runtime mode it
prefixes <br>
the resulting data with HTTP/1.0 (default) or HTTP/1.1 (if
identified by the webserver) compliant response header
lines.</p>

<p style="margin-top: 1em">ePerl also recognizes HTTP
header lines at the beginning of the scripts generated data,
i.e. for instance you can generate your own HTTP headers
like</p>

<p style="margin-top: 1em">&lt;? $url = &quot;..&quot;;
<br>
print &quot;Location: $url0; <br>
print &quot;URI: $url0; !&gt; <br>
&lt;html&gt; <br>
...</p>

<p style="margin-top: 1em">But notice that while you can
output arbitrary headers, most webservers restrict the
headers which are accepted via the CGI/1.1 interface.
Usually you can provide only a few <br>
specific HTTP headers like &quot;Location&quot; or
&quot;Status&quot;. If you need more control you have to use
the NPH-CGI/1.1 interface mode.</p>

<p style="margin-top: 1em">Additionally ePerl provides a
useful feature in this mode: It can switch its UID/GID to
the owner of the script if it runs as a Unix SetUID program
(see below under Security <br>
and the option &lsquo;&lsquo;u+s&rsquo;&rsquo; of
chmod(1)).</p>

<p style="margin-top: 1em">There are two commonly known
ways of using this CGI/1.1 interface mode on the Web. First,
you can use it to explicitly transform plain HTML files into
CGI/1.1 scripts via the <br>
Shebang technique (see above). For an Apache webserver just
put the following line as the first line of the file:</p>

<p style="margin-top: 1em">#!/path/to/eperl -mc</p>

<p style="margin-top: 1em">Then rename the script from
file.html to file.cgi and set its execution bit via</p>

<p style="margin-top: 1em">$ mv file.html file.cgi <br>
$ chmod a+rx file.cgi</p>

<p style="margin-top: 1em">Now make sure that Apache
accepts file.cgi as a CGI program by enabling CGI support
for the directory where file.cgi resides. For this add the
line</p>

<p style="margin-top: 1em">Options +ExecCGI</p>

<p style="margin-top: 1em">to the .htaccess file in this
directory. Finally make sure that Apache really recognizes
the extension .cgi. Perhaps you additionally have to add the
following line to your <br>
httpd.conf file:</p>

<p style="margin-top: 1em">AddHandler cgi-script .cgi</p>

<p style="margin-top: 1em">Now you can use file.cgi instead
of file.html and make advantage of the achieved programming
capability by bristling file.cgi with your Perl blocks (or
the transformation <br>
into a CGI script would be useless).</p>

<p style="margin-top: 1em">Alternatively (or even
additionally) a webmaster can enable ePerl support in a more
seamless way by configuring ePerl as a real implicit
server-side scripting language. This <br>
is done by assigning a MIME-type to the various valid ePerl
file extensions and forcing all files with this MIME-type to
be internally processed via the ePerl interpreter. <br>
You can accomplish this for Apache by adding the following
to your httpd.conf file</p>

<p style="margin-top: 1em">AddType
application/x-httpd-eperl .phtml .eperl .epl <br>
Action application/x-httpd-eperl /internal/cgi/eperl <br>
ScriptAlias /internal/cgi /path/to/apache/cgi-bin</p>

<p style="margin-top: 1em">and creating a copy of the eperl
program in your CGI-directory:</p>

<p style="margin-top: 1em">$ cp -p /path/to/eperl
/path/to/apache/cgi-bin/eperl</p>

<p style="margin-top: 1em">Now all files with the
extensions .phtml, .eperl and .epl are automatically
processed by the ePerl interpreter. There is no need for a
Shebang line or any locally enabled CGI <br>
mode.</p>

<p style="margin-top: 1em">One final hint: When you want to
test your scripts offline, just run them with forced CGI/1.1
mode from your shell. But make sure you prepare all
environment variables your <br>
script depends on, e.g. &quot;QUERY_STRING&quot; or
&quot;PATH_INFO&quot;.</p>

<p style="margin-top: 1em">$ export
QUERY_STRING=&quot;key1=value1&amp;key2=value2&quot; <br>
$ eperl -mc file.phtml</p>

<p style="margin-top: 1em">NPH-CGI/1.1 compliant interface
mode <br>
This runtime mode is a special variant of the CGI/1.1
interface mode, because most webservers (e.g. Apache)
provide it for special purposes. It is known as Non-Parsed-
<br>
Header (NPH) CGI/1.1 mode and is usually used by the
webserver when the filename of the CGI program is prefixed
with &lsquo;&lsquo;&quot;nph-&quot;&rsquo;&rsquo;. In this
mode the webserver does no <br>
processing on the HTTP response headers and no buffering of
the resulting data, i.e. the CGI program actually has to
provide a complete HTTP response itself. The advantage is
<br>
that the program can generate arbitrary HTTP headers or
MIME-encoded multi-block messages.</p>

<p style="margin-top: 1em">So, above we have renamed the
file to file.cgi which restricted us a little bit. When we
alternatively rename file.html to nph-file.cgi and force the
NPH-CGI/1.1 interface <br>
mode via option -mn then this file becomes a NPH-CGI/1.1
compliant program under Apache and other webservers. Now our
script can provide its own HTTP response (it need not, <br>
because when absent ePerl provides a default one for
it).</p>

<p style="margin-top: 1em">#!/path/to/bin/eperl -mn <br>
&lt;? print &quot;HTTP/1.0 200 Ok0; <br>
print &quot;X-MyHeader: Foo Bar Quux0; <br>
print &quot;Content-type: text/html0; <br>
&lt;html&gt; <br>
...</p>

<p style="margin-top: 1em">As you expect this can be also
used with the implicit Server-Side Scripting Language
technique. Put</p>

<p style="margin-top: 1em">AddType
application/x-httpd-eperl .phtml .eperl .epl <br>
Action application/x-httpd-eperl /internal/cgi/nph-eperl
<br>
ScriptAlias /internal/cgi /path/to/apache/cgi-bin</p>

<p style="margin-top: 1em">into your httpd.conf and run the
command</p>

<p style="margin-top: 1em">$ cp -p /path/to/eperl
/path/to/apache/cgi-bin/nph-eperl</p>

<p style="margin-top: 1em">from your shell. This is the
preferred way of using ePerl as a Server-Side Scripting
Language, because it provides most flexibility.</p>

<p style="margin-top: 1em">Security <br>
When you are installing ePerl as a CGI/1.1 or NPH-CGI/1.1
compliant program (see above for detailed description of
these modes) via</p>

<p style="margin-top: 1em">$ cp -p /path/to/eperl
/path/to/apache/cgi-bin/eperl <br>
$ chown root /path/to/apache/cgi-bin/eperl <br>
$ chmod u+s /path/to/apache/cgi-bin/eperl</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">$ cp -p /path/to/eperl
/path/to/apache/cgi-bin/nph-eperl <br>
$ chown root /path/to/apache/cgi-bin/nph-eperl <br>
$ chmod u+s /path/to/apache/cgi-bin/nph-eperl</p>

<p style="margin-top: 1em">i.e. with SetUID bit enabled for
the root user, ePerl can switch to the UID/GID of the
scripts owner. Although this is a very useful feature for
script programmers (because one <br>
no longer need to make auxiliary files world-readable and
temporary files world-writable!), it can be to risky for you
when you are paranoid about security of SetUID programs. If
<br>
so just don&rsquo;t install ePerl with enabled SetUID bit!
This is the reason why ePerl is per default only installed
as a Stand-Alone Unix filter which never needs this
feature.</p>

<p style="margin-top: 1em">For those of us who decided that
this feature is essential for them ePerl tries really hard
to make it secure. The following steps have to be
successfully passed before ePerl <br>
actually switches its UID/GID (in this order):</p>

<p style="margin-top: 1em">1. The script has to match the
following extensions: <br>
.html, .phtml, .ephtml, .epl, .pl, .cgi <br>
2. The UID of the calling process has to be a valid UID,
<br>
i.e. it has to be found in the systems password file <br>
3. The UID of the calling process has to match the <br>
following users: root, nobody <br>
4. The UID of the script owner has to be a valid UID, <br>
i.e. it has to be found in the systems password file <br>
5. The GID of the script group has to be a valid GID, <br>
i.e. it has to be found in the systems group file <br>
6. The script has to stay below or in the owners homedir</p>

<p style="margin-top: 1em">IF ONLY ONE OF THOSE STEPS FAIL,
NO UID/GID SWITCHING TAKES PLACE!. Additionally (if
&quot;DO_ON_FAILED_STEP&quot; was defined as
&quot;STOP_AND_ERROR&quot; in eperl_security.h - not per
default <br>
defined this way!) ePerl can totally stop processing and
display its error page. This is for the really paranoid
webmasters. Per default when any step failed the UID/GID
<br>
switching is just disabled, but ePerl goes on with
processing. Alternatively you can disable some steps at
compile time. See eperl_security.h.</p>

<p style="margin-top: 1em">Also remember that ePerl always
eliminates the effective UID/GID, independent of the runtime
mode and independent if ePerl has switched to the UID/GID of
the owner. For security <br>
reasons, the effective UID/GID is always destroyed before
the script is executed.</p>

<p style="margin-top: 1em">ePerl Preprocessor <br>
ePerl provides an own preprocessor similar to CPP in style
which is either enabled manually via option -P or
automatically when ePerl runs in (NPH-)CGI mode. The
following <br>
directives are supported:</p>

<p style="margin-top: 1em">&quot;#include path&quot; <br>
This directive is an include directive which can be used to
include really any stuff, but was actually designed to be
used to include other ePerl source files. The path can <br>
be either a relative or absolute path for the local
filesystem or a fully qualified HTTP URL.</p>

<p style="margin-top: 1em">In case of the absolute path the
file is directly accessed on the filesystem, while the
relative path is first searched in the current working
directory and then in all <br>
directories specified via option -I. In the third case (HTTP
URL) the file is retrieves via a HTTP/1.0 request on the
network. Here HTTP redirects (response codes 301 and <br>
302) are supported, too.</p>

<p style="margin-top: 1em">Notice: While ePerl strictly
preserves the line numbers when translating the bristled
ePerl format to plain Perl format, the ePerl preprocessor
can&rsquo;t do this (because its a <br>
preprocessor which expands) for this directive. So, whenever
you use &quot;#include&quot;, remember that line numbers in
error messages are wrong.</p>

<p style="margin-top: 1em">Also notice one important
security aspect: Because you can include any stuff as it is
provided with this directive, use it only for stuff which is
under your direct control. <br>
Don&rsquo;t use this directive to include foreign data, at
least not from external webservers. For instance say you
have a ePerl page with &quot;#include <br>
http://www.foreigner.com/nice-page.html&quot; and at the
next request of this page your filesystem is lost! Why?
Because the foreigner recognizes that you include his page
and are <br>
using ePerl and just put a simple &lsquo;&lsquo;&quot;&lt;?
system(&quot;rm -rf /&quot;); !&gt;&quot;&rsquo;&rsquo; in
his page. Think about it. NEVER USE #INCLUDE FOR ANY DATA
WHICH IS NOT UNDER YOUR OWN CONTROL. Instead <br>
always use &quot;#sinclude&quot; for such situations.</p>

<p style="margin-top: 1em">&quot;#sinclude path&quot; <br>
This is the secure variant of &quot;#include&quot; where
after reading the data from path all ePerl begin and end
delimiters are removed. So risky ePerl blocks lost their
meaning and <br>
are converted to plain text. Always use this directive when
you want to include data which is not under your own
control.</p>

<p style="margin-top: 1em">&quot;#if expr&quot;,
&quot;#elsif expr&quot;, &quot;#else&quot;,
&quot;#endif&quot; <br>
These implement a CPP-style &quot;#if-[#else-]#endif&quot;
construct, but with a Perl semantic. While the other
directives are real preprocessor commands which are
evaluated at the <br>
preprocessing step, this construct is actually just
transformed into a low-level ePerl construct, so it is not
actually evaluated at the preprocessing step. It is just a
<br>
handy shortcut for the following (where BD is the currently
used begin delimiter and ED the end delimiter):</p>

<p style="margin-top: 1em">&lsquo;&lsquo;#if
expr&rsquo;&rsquo; -&gt; &lsquo;&lsquo;BD if (expr) { _
ED//&rsquo;&rsquo; <br>
&lsquo;&lsquo;#elsif expr&rsquo;&rsquo; -&gt;
&lsquo;&lsquo;BD } elsif (expr) { _ ED//&rsquo;&rsquo; <br>
&lsquo;&lsquo;#else&rsquo;&rsquo; -&gt; &lsquo;&lsquo;BD }
else { _ ED//&rsquo;&rsquo; <br>
&lsquo;&lsquo;#endif&rsquo;&rsquo; -&gt; &lsquo;&lsquo;BD }
_ ED//&rsquo;&rsquo;</p>

<p style="margin-top: 1em">The advantage of this unusual
aproach is that the if-condition really can be any valid
Perl expression which provides maximum flexibility. The
disadvantage is that you cannot <br>
use the if-construct to make real preprocessing decisions.
As you can see, the design goal was just to provide a
shorthand for the more complicated Perl constructs.</p>

<p style="margin-top: 1em">&quot;#c&quot; <br>
This is the comment directive which just discards all data
up to and including the newline character. Use this one to
comment out any stuff, even other preprocessor <br>
directives.</p>

<p style="margin-top: 1em">Provided Functionality <br>
Up to know you&rsquo;ve understand that ePerl provides a
nice facility to embed Perl code into any ASCII data. But
now the typical question is: Which Perl code can be put into
these <br>
ePerl blocks and does ePerl provide any special
functionality inside these ePerl blocks?</p>

<p style="margin-top: 1em">The answers are: First, you can
put really any Perl code into the ePerl blocks which are
valid to the Perl interpreter ePerl was linked with. Second,
ePerl does not provide any <br>
special functionality inside these ePerl blocks, because
Perl is already sophisticated enough ;-)</p>

<p style="margin-top: 1em">The implication of this is:
Because you can use any valid Perl code you can make use of
all available Perl 5 modules, even those ones which use
shared objects (because ePerl is a <br>
Perl interpreter, including DynaLoader support). So, browse
to the Comprehensive Perl Archive Network (CPAN) via
http://www.perl.com/perl/CPAN and grab your favorite
packages <br>
which can make your life easier (both from within plain Perl
scripts and ePerl scripts) and just use the construct
&lsquo;&lsquo;&quot;use name;&quot;&rsquo;&rsquo; in any
ePerl block to use them from within <br>
ePerl.</p>

<p style="margin-top: 1em">When using ePerl as a
Server-Side-Scripting-Language I really recommend you to
install at least the packages CGI.pm (currently vers. 2.36),
HTML-Stream (1.40), libnet (1.0505) <br>
and libwww-perl (5.08). When you want to generate on-the-fly
images as well, I recommend you to additionally install at
least GD (1.14) and Image-Size (2.3). The ePerl <br>
interpreter in conjunction with these really sophisticated
Perl 5 modules will provide you with maximum flexibility and
functionality. In other words: Make use of maximum <br>
Software Leverage in the hackers world of Perl as great as
possible.</p>

<p style="margin-top: 1em">OPTIONS <br>
-d name=value <br>
Sets a Perl variable in the package &quot;main&quot; which
can be referenced via $name or more explicitly via
$main::name. The command</p>

<p style="margin-top: 1em">eperl -d name=value ..</p>

<p style="margin-top: 1em">is actually equivalent to
having</p>

<p style="margin-top: 1em">&lt;? $name = value; !&gt;</p>

<p style="margin-top: 1em">at the beginning of inputfile.
This option can occur more than once.</p>

<p style="margin-top: 1em">-D name=value <br>
Sets a environment variable which can be referenced via
$ENV{&rsquo;variable&rsquo;} inside the Perl blocks. The
command</p>

<p style="margin-top: 1em">eperl -D name=value ..</p>

<p style="margin-top: 1em">is actually equivalent to</p>

<p style="margin-top: 1em">export name=value; eperl ...</p>

<p style="margin-top: 1em">but the advantage of this option
is that it doesn&rsquo;t manipulate the callers environment.
This option can occur more than once.</p>

<p style="margin-top: 1em">-B begin_delimiter <br>
Sets the Perl block begin delimiter string. Use this in
conjunction with &quot;-E&quot; to set different delimiters
when using ePerl as an offline HTML creation-language while
still <br>
using it as an online HTML scripting-language. Default
delimiters are &quot;&lt;?&quot; and &quot;!&gt;&quot; for
CGI modes and &quot;&lt;:&quot; and &quot;:&gt;&quot; for
stand-alone Unix filtering mode.</p>

<p style="margin-top: 1em">There are a lot of possible
variations you could choose: &quot;&quot;&lt;:&quot;&quot;
and &quot;&quot;:&gt;&quot;&quot; (the default ePerl
stand-alone filtering mode delimiters),
&quot;&quot;&lt;?&quot;&quot; and
&quot;&quot;!&gt;&quot;&quot; (the default ePerl CGI <br>
interface mode delimiters), &quot;&quot;&lt;script
language=&rsquo;ePerl&rsquo;&gt;&quot;&quot; and
&quot;&quot;&lt;/script&gt;&quot;&quot; (standard HTML
scripting language style), &quot;&quot;&lt;script
type=&quot;text/eperl&quot;&gt;&quot;&quot; and
&quot;&quot;&lt;/script&gt;&quot;&quot; <br>
(forthcoming HTML3.2+ aka Cougar style),
&quot;&quot;&lt;eperl&gt;&quot;&quot; and
&quot;&quot;&lt;/eperl&gt;&quot;&quot; (HTML-like style),
&quot;&quot;&lt;!--#eperl code=&rsquo;&quot;&quot; and
&quot;&quot;&rsquo; --&gt;&quot;&quot; (NeoScript and SSI
style) or even &quot;&quot;&lt;?&quot;&quot; and <br>
&quot;&quot;&gt;&quot;&quot; (PHP/FI style; but this no
longer recommended because it can lead to parsing problems.
Should be used only for backward compatibility to old ePerl
versions 1.x).</p>

<p style="margin-top: 1em">The begin and end delimiters are
searched case-insensitive.</p>

<p style="margin-top: 1em">-E end_delimiter <br>
Sets the Perl block end delimiter string. See also option
-B.</p>

<p style="margin-top: 1em">-i Forces the begin and end
delimiters to be searched case-insensitive. Use this when
you are using delimiters like
&lsquo;&lsquo;&quot;&lt;ePerl&gt;&quot;...&quot;&lt;/ePerl&gt;&quot;&rsquo;&rsquo;
or other more textual ones.</p>

<p style="margin-top: 1em">-m mode <br>
This forces ePerl to act in a specific runtime mode. See
above for a detailed description of the three possible
modes: Stand-alone filter (mode=&quot;f&quot;, i.e. option
-mf), <br>
CGI/1.1 interface mode (mode=&quot;c&quot;, i.e. option -mc)
or the NPH-CGI/1.1 interface mode (mode=&quot;n&quot;, i.e.
option -mn).</p>

<p style="margin-top: 1em">-o outputfile <br>
Forces the output to be written to outputfile instead of
STDOUT. Use this option when using ePerl as a filter. The
outputfile &lsquo;&lsquo;-&rsquo;&rsquo; sets STDOUT as the
output handle <br>
explicitly. Notice that this file is relative to the source
file directory when the runtime mode is forced to CGI or
NPH-CGI.</p>

<p style="margin-top: 1em">-k Forces ePerl to keep the
current working directory from where it was started. Per
default ePerl will change to the directory where the file to
be executed stays. This option <br>
is useful if you use ePerl as an offline filter on a
temporary file.</p>

<p style="margin-top: 1em">-x This sets debug mode where
ePerl outputs the internally created Perl script to the
console (/dev/tty) before executing it. Only for debugging
problems with the inputfile <br>
conversion.</p>

<p style="margin-top: 1em">-I directory <br>
Specify a directory which is both used for
&quot;#include&quot; and &quot;#sinclude&quot; directives of
the ePerl preprocessor and added to @INC under runtime. This
option can occur more than <br>
once.</p>

<p style="margin-top: 1em">-P Manually enables the special
ePerl Preprocessor (see above). This option is enabled for
all CGI modes automatically.</p>

<p style="margin-top: 1em">-C This enables the HTML entity
conversion for ePerl blocks. This option is automatically
forced in CGI modes.</p>

<p style="margin-top: 1em">The solved problem here is the
following: When you use ePerl as a
Server-Side-Scripting-Language for HTML pages and you edit
your ePerl source files via a HTML editor, the <br>
chance is high that your editor translates some entered
characters to HTML entities, for instance
&lsquo;&lsquo;&quot;&lt;&quot;&rsquo;&rsquo; to
&lsquo;&lsquo;&quot;&amp;lt;&quot;&rsquo;&rsquo;. This leads
to invalid Perl code inside ePerl blocks, <br>
because the HTML editor has no knowledge about ePerl blocks.
Using this option the ePerl parser automatically converts
all entities found inside ePerl blocks back to plain <br>
characters, so the Perl interpreter again receives valid
code blocks.</p>

<p style="margin-top: 1em">-L This enables the line
continuation character &lsquo;&lsquo;&quot; <br>
option changes your data (outside ePerl blocks). Usually
ePerl really pass through all surrounding data as raw data.
With this option the newlines become new semantics.</p>

<p style="margin-top: 1em">-T This enabled Perl&rsquo;s
Tainting mode where the Perl interpreter takes special
precautions called taint checks to prevent both obvious and
subtle traps. See perlsec(1) for more <br>
details.</p>

<p style="margin-top: 1em">-w This enables Warnings where
the Perl interpreter produces some lovely diagnostics. See
perldiag(1) for more details.</p>

<p style="margin-top: 1em">-c This runs a pure syntax check
which is similar to &lsquo;&lsquo;&quot;perl
-c&quot;&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">-r This prints the internal
ePerl README file to the console.</p>

<p style="margin-top: 1em">-l This prints the internal
ePerl LICENSE file to the console.</p>

<p style="margin-top: 1em">-v This prints ePerl version
information to the console.</p>

<p style="margin-top: 1em">-V Same as option -v but
additionally shows the Perl compilation parameters.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
Used Variables <br>
&quot;PATH_TRANSLATED&quot; <br>
This CGI/1.1 variable is used to determine the source file
when ePerl operates as a NPH-CGI/1.1 program under the
environment of a webserver.</p>

<p style="margin-top: 1em">Provided Variables <br>
&quot;SCRIPT_SRC_PATH&quot; <br>
The absolute pathname of the script. Use this when you want
to directly access the script from within itself, for
instance to do &quot;stat()&quot; and other calls.</p>

<p style="margin-top: 1em">&quot;SCRIPT_SRC_PATH_DIR&quot;
<br>
The directory part of &quot;SCRIPT_SRC_PATH&quot;. Use this
one when you want to directly access other files residing in
the same directory as the script, for instance to read
config <br>
files, etc.</p>


<p style="margin-top: 1em">&quot;SCRIPT_SRC_PATH_FILE&quot;
<br>
The filename part of &quot;SCRIPT_SRC_PATH&quot;. Use this
one when you need the name of the script, for instance for
relative self-references through URLs.</p>

<p style="margin-top: 1em">&quot;SCRIPT_SRC_URL&quot; <br>
The fully-qualified URL of the script. Use this when you
need a URL for self-reference.</p>

<p style="margin-top: 1em">&quot;SCRIPT_SRC_URL_DIR&quot;
<br>
The directory part of &quot;SCRIPT_SRC_URL&quot;. Use this
one when you want to directly access other files residing in
the same directory as the script via the Web, for instance
to <br>
reference images, etc.</p>

<p style="margin-top: 1em">&quot;SCRIPT_SRC_URL_FILE&quot;
<br>
The filename part of &quot;SCRIPT_SRC_URL&quot;. Use this
one when you need the name of the script, for instance for
relative self-references through URLs. Actually the same as
<br>
&quot;SCRIPT_SRC_PATH_FILE&quot;, but provided for
consistency.</p>

<p style="margin-top: 1em">&quot;SCRIPT_SRC_SIZE&quot; <br>
The filesize of the script, in bytes.</p>

<p style="margin-top: 1em">&quot;SCRIPT_SRC_MODIFIED&quot;
<br>
The last modification time of the script, in seconds since 0
hours, 0 minutes, 0 seconds, January 1, 1970, Coordinated
Universal Time.</p>


<p style="margin-top: 1em">&quot;SCRIPT_SRC_MODIFIED_CTIME&quot;
<br>
The last modification time of the script, in ctime(3) format
(&lsquo;&lsquo;WDAY MMM DD HH:MM:SS YYYY0&rsquo;).</p>


<p style="margin-top: 1em">&quot;SCRIPT_SRC_MODIFIED_ISOTIME&quot;
<br>
The last modification time of the script, in ISO format
(&lsquo;&lsquo;DD-MM-YYYY HH:MM&rsquo;&rsquo;).</p>

<p style="margin-top: 1em">&quot;SCRIPT_SRC_OWNER&quot;
<br>
The username of the script owner.</p>

<p style="margin-top: 1em">&quot;VERSION_INTERPRETER&quot;
<br>
The ePerl identification string.</p>

<p style="margin-top: 1em">&quot;VERSION_LANGUAGE&quot;
<br>
The identification string of the used Perl interpreter
library.</p>

<p style="margin-top: 1em">Provided Built-In Images <br>
The following built-in images can be accessed via URL
&quot;/url/to/nph-eperl/&quot;NAME&quot;.gif&quot;:</p>

<p style="margin-top: 1em">&quot;logo.gif&quot; <br>
The standard ePerl logo. Please do not include this one on
your website.</p>

<p style="margin-top: 1em">&quot;powered.gif&quot; <br>
The &lsquo;&lsquo;powered by ePerl 2.2&rsquo;&rsquo; logo.
Feel free to use this on your website.</p>

<p style="margin-top: 1em">AUTHOR <br>
Ralf S. Engelschall <br>
rse@engelschall.com <br>
www.engelschall.com</p>

<p style="margin-top: 1em">SEEALSO <br>
Parse::ePerl(3), Apache::ePerl(3).</p>

<p style="margin-top: 1em">Web-References:</p>

<p style="margin-top: 1em">Perl: perl(1),
http://www.perl.com/ <br>
ePerl: eperl(1), http://www.ossp.org/pkg/tool/eperl/ <br>
Apache: httpd(8), http://www.apache.org/</p>

<p style="margin-top: 1em">EN 2016-10-24 EPERL(1)</p>
<hr>
</body>
</html>
