<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>NICKLE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">NICKLE(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">NICKLE(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
nickle - a desk calculator language
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
nickle [--help|--usage] [-f file] [-l library] [-e expr] [ script ] [--] [arg
  ...]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>Nickle</i> is a desk calculator language with powerful programming and
  scripting capabilities. Nickle supports a variety of datatypes, especially
  arbitrary precision integers, rationals, and imprecise reals. The input
  language vaguely resembles C. Some things in C which do not translate easily
  are different, some design choices have been made differently, and a very few
  features are simply missing.
<h1 class="Sh" title="Sh" id="USAGE"><a class="selflink" href="#USAGE">USAGE</a></h1>
An un-flagged argument is treated as a Nickle script, and replaces standard
  input. Any remaining arguments following the script are placed in the Nickle
  string array argv for programmatic inspection. When invoked without an
  expression or script argument, Nickle reads from standard input, and writes to
  standard output.
<div class="Pp"></div>
Options are as follows:
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help,--usage</b></dt>
  <dd class="It-tag">Print a help/usage message and exit. This is a built-in
      feature of Nickle's ParseArgs module, and thus will also be true of Nickle
      scripts that use this library.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f,--file </b><i>file</i></dt>
  <dd class="It-tag">Load <i>file</i> into Nickle before beginning
    execution.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l,--library </b><i>library</i></dt>
  <dd class="It-tag">Load <i>library</i> into Nickle before beginning execution.
      See below for a description of the library facility.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e,--expr </b><i>expr</i></dt>
  <dd class="It-tag">Evaluate <i>expr</i> before beginning execution.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--</b></dt>
  <dd class="It-tag">Quit parsing arguments and pass the remainder, unevaluated,
      to <i>argv</i>.</dd>
</dl>
<h1 class="Sh" title="Sh" id="SYNTAX"><a class="selflink" href="#SYNTAX">SYNTAX</a></h1>
To make the input language more useful in an interactive setting, <b>newline</b>
  only terminates statements at ``reasonable'' times. <b>Newline</b> terminates
  either expressions or single statements typed by the user (with the exception
  of a few statements which require lookahead: notably if() and twixt(), which
  have an optional else part). Inside compound statements or function
  definitions, only a <b>;</b> terminates statements. This approach is
  convenient and does not appear to cause problems in normal use.
<div class="Pp"></div>
The syntax of Nickle programs is as follows. In this description, <b>name</b>
  denotes any sequence of letters, digits and _ characters not starting with a
  digit; <b>E</b> denotes any expression; <b>S</b> denotes any statement; and
  <b>T</b> denotes any type. The syntax <b>X,X,...,X</b> denotes one or more
  comma-separated Xs, unless otherwise indicated.
<div class="Pp"></div>
<b>Comments:</b>
<div class="Pp"></div>
C-style comments are enclosed in /* and */, and shell-style comments are denoted
  by a leading # at the start of a line.
<div class="Pp"></div>
<b>Operands:</b>
<dl class="Bl-tag">
  <dt class="It-tag">real number</dt>
  <dd class="It-tag">Can include exponent, need not include decimal point or
      sign. Will be treated as exact rationals. If a trailing decimal part
      contains an opening curly brace, the brace is silently ignored; if it
      contains a curly-bracketed trailing portion, it is treated as a repeating
      decimal. `Floating point'' constants are currently represented internally
      as rationals: for floating constants with a given precision (and an
      infinite-precision exponent), use the imprecise() builtin function
      described below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">octal number</dt>
  <dd class="It-tag">Start with a 0 (e.g., 014 is the same as 12).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">hexidecimal number</dt>
  <dd class="It-tag">Start with &quot;0x&quot; (e.g., 0x1a is the same as
    26).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string</dt>
  <dd class="It-tag">As in C. String constants are surrounded by double-quotes.
      Backslashed characters (including double-quotes) stand for themselves,
      except &quot;\n&quot; stands for newline, &quot;\r&quot; for carriage
      return, &quot;\b&quot; for backspace, &quot;\t&quot; for tab and
      &quot;\f&quot; for formfeed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">name</dt>
  <dd class="It-tag">A variable reference.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">name() name(E,E,...,E)</dt>
  <dd class="It-tag">A function call with zero or more arguments. Functions are
      fully call-by-value: arrays and structures are copied rather than being
      referenced as in C.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">desc name T name = value</dt>
  <dd class="It-tag">Definition expressions: a new name is made available, with
      the value of the definition being the value of the initializer in the
      second form, and uninitialized in the first form. The descriptor desc is
      not optional: it consists of any combination of visibility, storage class
      or type (in that order). See QUALIFIERS immediately below for a
      description of these qualifiers. A structured value expression is also
      possible: see VALUES below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">In addition to being able to initialize a definition with a
      Nickle value, C-style array, structure, and union definitions are also
      allowed: For example, the following
    <pre>
  int[*,*] name = {{0,1},{2,3}}
  int[2,2] name = {{0...}...}
    </pre>
    are permitted with the obvious semantics. This is the context in which the
      dimensions in a type may be expressions: see the discussion of array types
      above. See the discussion of array and structure values for array and
      structure initializer syntax.</dd>
</dl>
<h1 class="Sh" title="Sh" id="QUALIFIERS"><a class="selflink" href="#QUALIFIERS">QUALIFIERS</a></h1>
A declaration or definition may be qualified, as in C, to indicate details of
  programmatic behavior. Unlike in C, these qualifiers, while optional, must
  appear in the given order.
<div class="Pp"></div>
<b>Visibility:</b>
<dl class="Bl-tag">
  <dt class="It-tag">public</dt>
  <dd class="It-tag">Any definition expression (function definition, variable
      definition, type definition) can be qualified with public to indicate that
      the name being defined should be visible outside the current namespace,
      and should be automatically imported. See Namespaces below for further
      info.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">protected</dt>
  <dd class="It-tag">Any definition expression (function definition, variable
      definition, type definition) can be qualified with protected to indicate
      that the name being defined should be visible outside the current
      namespace, but should not be made available by import declarations. See
      Namespaces below for further info.</dd>
</dl>
<div class="Pp"></div>
<b>Lifetime:</b>
<dl class="Bl-tag">
  <dt class="It-tag">auto</dt>
  <dd class="It-tag">An auto object is local to a particular block: its lifetime
      is at least the lifetime of that block. An auto object with an initializer
      will be re-initialized each time it is evaluated. This is the default
      lifetime for local objects.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">static</dt>
  <dd class="It-tag">A static object is local to a particular function
      definition: its lifetime is at least the lifetime of that definition. A
      new static object will be created each time its enclosing function
      definition is evaluated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">In Nickle, the keyword static has to do only with lifetime
      (like the use of static inside C functions), not with visibility (which is
      handled by separate qualifiers as described above, not like the use of
      static in global scope in C).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">global</dt>
  <dd class="It-tag">A global object is global to the entire program: its
      lifetime is the lifetime of the program. A global object will be created
      and initialized when its definition is first seen. This is the default
      lifetime for global objects.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The distinction between static and global lifetime in
      Nickle is not possible in C, because C functions are not first class
      objects with nested scope. When deciding which to use in a Nickle program,
      think about what should happen if a definition is re-evaluated.</dd>
</dl>
<h1 class="Sh" title="Sh" id="OPERATORS"><a class="selflink" href="#OPERATORS">OPERATORS</a></h1>
Here are the basic Nickle operators, grouped in order of decreasing precedence:
<dl class="Bl-tag">
  <dt class="It-tag">A[E,E,...,E]</dt>
  <dd class="It-tag">Refers to the E'th element of the array expression A, or
      the E1'th/E2'th/etc element of a multi-dimensional array. Both arrays of
      arrays ala C and multidimensional arrays ala NAWK are possible.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">struct.tag</dt>
  <dd class="It-tag">Structure dereference.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">struct-&gt;tag</dt>
  <dd class="It-tag">Structure pointer dereference ala C.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">=============</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">++ --</dt>
  <dd class="It-tag">Unary increment/decrement. May be either postfix or
    prefix.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Unary negate</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">! E</dt>
  <dd class="It-tag">Logical negation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">E !</dt>
  <dd class="It-tag">Factorial. Requires a non-negative integer argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">* E</dt>
  <dd class="It-tag">Pointer dereference.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp; E</dt>
  <dd class="It-tag">Reference construction.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">=============</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">(U) E</dt>
  <dd class="It-tag">Construct a value of union type with tag U and value
    E.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">=============</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">**</dt>
  <dd class="It-tag">Exponentiation. Both operands may be fractional. The left
      operand must be non-negative unless the right operand is integer. The
      result type is the type of the left operand if the right operand is
      integer, and real otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This is the only known type-unsound feature of Nickle: an
      expression like 2 ** -3 will statically be of type integer, but
      dynamically will generate a rational result. This may cause a runtime type
      error later on: consider
    <div>&#x00A0;</div>
    <br/>
     int x = 2 ** -3;
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">=============</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">* / // %</dt>
  <dd class="It-tag">Times, divide, integer divide, and remainder. The right
      operand of the last three operators must be nonzero. The result type of
      the division operator will always be at least rational: the result type of
      the integer division operator will always be int. This is a notable
      departure from C, where integer division is implied by integer operands.
      Integer division is defined by
    <div>&#x00A0;</div>
    <br/>
     x // y == y &gt; 0 ? floor (x / y) : ceil(x / y)
    <div>&#x00A0;</div>
    The remainder is always non-negative and is defined by: by
    <div>&#x00A0;</div>
    <br/>
     x % y = x - (x // y) * y
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">=============</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">+ -</dt>
  <dd class="It-tag">Addition and subtraction.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">=============</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;&lt; &gt;&gt;</dt>
  <dd class="It-tag">Bitwise left and right shift with integer operands.
      Negative right operands work as expected. These operators are defined by
    <div>&#x00A0;</div>
    <br/>
     x &lt;&lt; y = x * 2 ** y
    <div>&#x00A0;</div>
    <br/>
     x &gt;&gt; y = x // 2 ** y
    <div>&#x00A0;</div>
    Another way to look at this is that negative left operands are considered to
      be in an infinite twos-complement representation (i.e., sign-extended to
      infinity), with right shift sign-extending its left operand.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">=============</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;= &gt;= &lt; &gt;</dt>
  <dd class="It-tag">Relational operators.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">=============</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">== !=</dt>
  <dd class="It-tag">Equality operators.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">=============</dt>
  <dd class="It-tag">Finally, in order of decreasing precedence:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;</dt>
  <dd class="It-tag">Bitwise AND. Negative operands are considered to be in an
      infinite twos-complement representation (i.e., sign-extended to
    infinity).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">^</dt>
  <dd class="It-tag">Bitwise XOR. Negative operands as in bitwise AND.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">|</dt>
  <dd class="It-tag">Bitwise OR. Negative operands as in bitwise AND.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;&amp;</dt>
  <dd class="It-tag">Short-circuit logical AND.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">||</dt>
  <dd class="It-tag">Short-circuit logical OR.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">E ? E : E</dt>
  <dd class="It-tag">Conditional expression: if first expression is logical
      true, value is second expression, else third.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">fork E</dt>
  <dd class="It-tag">Create (and return) a thread. See Thread below for
    details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">= += -= *= /= //= %= **= &lt;&lt;= &gt;&gt;= ^= &amp;=
    |=</dt>
  <dd class="It-tag">Assignment operators. Left-hand-side must be assignable.
      <b>x </b><i>&lt;op&gt;=</i><b> y</b> is equivalent to <b>x </b><i>=</i><b>
      x </b><i>&lt;op&gt;</i><b> y</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">E , E</dt>
  <dd class="It-tag">Returns right-hand expression.</dd>
</dl>
<h1 class="Sh" title="Sh" id="TYPES"><a class="selflink" href="#TYPES">TYPES</a></h1>
The type declaration syntax of Nickle more strongly resembles the ``left''
  variant of the Java syntax than the C syntax. Essentially, a type consists of:
<dl class="Bl-tag">
  <dt class="It-tag">poly integer rational real string continuation void</dt>
  <dd class="It-tag">A base type of the language. Type void is actually only
      usable in certain contexts, notably function returns. It is currently
      implemented as a ``unit'' type ala ML, and thus has slightly different
      behavior than in C. Type poly is the supertype of all other types (i.e.,
      it can be used to inhibit static type checking), and is the default type
      in most situations where a type need not appear.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">file semaphore thread</dt>
  <dd class="It-tag">Also builtin base types, but integral to the File and
      Thread ADTs: see below.</dd>
</dl>
<div class="Pp"></div>
<b>More About Types:</b>
<div class="Pp"></div>
<i>Nickle</i> supports polymorphic data: As an expresion is evaluated, a data
  type is chosen to fit the result. Any Nickle object may be statically typed,
  in which case bounds violations will be flagged as errors at compile time.
  Polymorphic variables and functions do not place restrictions on the assigned
  data type; this is the default type for all objects.
<dl class="Bl-tag">
  <dt class="It-tag">poly</dt>
  <dd class="It-tag">This describes the union of all datatypes. A variable with
      this type can contain any data value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int</dt>
  <dd class="It-tag">Arbitrary precision integers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">rational</dt>
  <dd class="It-tag">Arbitrary precision rational numbers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real</dt>
  <dd class="It-tag">Arbitrary exponent precision floating point numbers. As
      many computations cannot be carried out exactly as rational numbers,
      Nickle implements non-precise arithmetic using its own machine-independent
      representation for floating point numbers. The builtin function
      imprecise(n) generates a real number with 256 bits of precision from the
      number n, while imprecise(n,p) generates a real number with p bits of
      precision.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T[]</dt>
  <dd class="It-tag">An array of type T, of one or more dimensions. There are no
      zero-dimensional arrays in Nickle.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T[*]</dt>
  <dd class="It-tag">A one-dimensional array of type T. Unlike in C, the
      dimension of an array is never part of its type in Nickle. Further, arrays
      and pointers are unrelated types in Nickle.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T[*,*,...,*]</dt>
  <dd class="It-tag">A two or more dimensional array of type T. The stars ``*''
      are not optional. As the previous paragraphs make clear, ``T[]'' is not a
      zero-dimensional array.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T[E,E,...,E]</dt>
  <dd class="It-tag">In definition contexts, integer values may be given for
      each dimension of an array context. These are strictly for value-creation
      purposes, and are not part of the type. An array type is determined only
      by the base type and number of dimensions of the array.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T0() T0(T,T,...,T)</dt>
  <dd class="It-tag">A function returning type T0. A function accepts 0 or more
      arguments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T0() T0(T,T,...,T <b>...</b>)</dt>
  <dd class="It-tag">A function accepting zero or more required arguments, plus
      an arbitrary number of optional arguments. The second sequence of three
      dots (ellipsis) is syntax, not metasyntax: see the description of varargs
      functions for details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*T</dt>
  <dd class="It-tag">A pointer to a location of type T. Pointer arithmetic in
      Nickle operates only upon pointers to arrays: the pointer must be of the
      correct type, and may never stray out of bounds. A pointer may either
      point to some location or be null (0). As in C, the precedence of ``*'' is
      lower than the precedence of ``[]'' or ``()'': use parenthesis as
    needed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">struct {T name; T name; ...}</dt>
  <dd class="It-tag">A structure with fields of the given name and type. The
      types T are optional: in their absence, the type of the field is
    poly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">union {T name; T name; ...}</dt>
  <dd class="It-tag">A ``disjoint union'' of the given types. This is more like
      the variant record type of Pascal or the datatype of ML than the C union
      type: the names are tags of the given type, exactly one of which applies
      to a given value at a given time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">(T)</dt>
  <dd class="It-tag">Parentheses for grouping.</dd>
</dl>
<div class="Pp"></div>
<b>Typedef:</b>
<div class="Pp"></div>
As in C, new type names may be created with the typedef statement. The syntax is
<div>&#x00A0;</div>
<br/>
 typedef T typename;
<div>&#x00A0;</div>
where T is a Nickle type. The resulting typename may be used anywhere a type is
  expected.
<h1 class="Sh" title="Sh" id="VALUES"><a class="selflink" href="#VALUES">VALUES</a></h1>
Values of the base types of Nickle are as expected. See the syntax for constants
  above. Values of type file, semaphore, and continuation may currently be
  created only by calls to builtin functions: no Nickle constants of these types
  exist.
<div class="Pp"></div>
As noted in TYPES above, Nickle has several kinds of ``structured value'':
  arrays, functions, pointers, structures and disjoint unions. All of these have
  some common properties. When created, all of the component values are
  uninitialized (unless otherwise specified). Attempts to use an uninitialized
  value will result in either a compile-time error or a runtime exception.
<div class="Pp"></div>
<b>Arrays:</b>
<dl class="Bl-tag">
  <dt class="It-tag">[E]</dt>
  <dd class="It-tag">creates a (zero-based) array with E elements. E must be
      non-negative.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[E]{V,V,...,V}</dt>
  <dd class="It-tag">Creates an array with E elements, initialized to the Vs. If
      there are too few initializers, remaining elements will remain
      uninitialized.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[E]{V,V,...,V<i>...</i>}</dt>
  <dd class="It-tag">The second ellipsis (three dots) is syntax, not metasyntax.
      Create an array with E elements. The first elements in the array will be
      initialized according to the Vs, with any remaining elements receiving the
      same value as the last V. This syntax may be used in the obvious fashion
      with any of the array initializers below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[*]{V,V,...,V}</dt>
  <dd class="It-tag">Creates an initialized array with exactly as many elements
      as initializers. There must be at least one initializer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">[E,E,...,E] [*,*,...,*]</dt>
  <dd class="It-tag">Creates multidimensional arrays. Integer expressions and
      &quot;*&quot; cannot be mixed: an array's dimensions are entirely either
      specified or unspecified by the definition. These arrays may also be
      created initialized: see next paragraph for initializer syntax.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">(T[E]) (T[E,E,...,E]) (T[E]){E,E,...,E}</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">(T[E,E,...,E]){{E,...},...,{E,...}}</dt>
  <dd class="It-tag">Alternate syntax for creating arrays of type T. The
      initializers, in curly braces, are optional. The number of initializers
      must be less than or equal to the given number of elements in each
      dimension. For multidimensional arrays, the extra curly braces per
      dimension in the initializer are required; this is unlike C, where they
      are optional.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">(T[*]){E,E,...,E} (T[*,*,...,*]){{E,...},...,{E,...}}</dt>
  <dd class="It-tag">Creates arrays of type T, with each dimension's size given
      by the maximum number of initializers in any subarray in that
    dimension.</dd>
</dl>
<div class="Pp"></div>
<b>Pointers:</b>
<dl class="Bl-tag">
  <dt class="It-tag">0</dt>
  <dd class="It-tag">The null pointer, in contexts where a pointer is
    required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;V &amp;A[E,E,...,E] &amp;S.N</dt>
  <dd class="It-tag">Creates a pointer to the given variable, array element, or
      structure member. The type of the pointer will be *T, where T is the type
      of the object pointed to.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*P</dt>
  <dd class="It-tag">The value pointed to by pointer P. This can be viewed or
      modified as in C.</dd>
</dl>
<div class="Pp"></div>
<b>Functions:</b>
<dl class="Bl-tag">
  <dt class="It-tag">(T func(){S;S;...S;}) (T func(T name,T name,...T
    name){S;S;...S;})</dt>
  <dd class="It-tag">Function expression: denotes a function of zero or more
      formal parameters with the given types and names, returning the given
      result type. The function body is given by the curly-brace-enclosed
      statement list. All types are optional, and default to poly. As noted
      above, functions are strictly call-by-value: in particular, arrays and
      structures are copied rather than referenced.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T function name(T name,T name,...,T name){S;S;...S;}</dt>
  <dd class="It-tag">Defines a function of zero or more arguments. Syntactic
      sugar for
    <div>&#x00A0;</div>
    <br/>
     T(T,T,...T) name = (T func(T name,T name,...T name){S;S;...S;});
    <div>&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">T function name(T name, T name <b>...</b>)</dt>
  <dd class="It-tag">The ellipsis here is syntax, not metasyntax: if the last
      formal argument to a function is followed by three dots, the function may
      be called with more actuals than formals. All ``extra'' actuals are
      packaged into the array formal of the given name, and typechecked against
      the optional type T of the last argument (default poly).</dd>
</dl>
<div class="Pp"></div>
<b>Structures:</b>
<dl class="Bl-tag">
  <dt class="It-tag">(struct { T name; T name; ...T name; }){name = E; name = E;
    ...name=E;}</dt>
  <dd class="It-tag">Create a value of a structured type. The named fields are
      initialized to the given values, with the remainder uninitialized. As
      indicated, initialization is by label rather than positional as in C.</dd>
</dl>
<div class="Pp"></div>
<b>Unions:</b>
<dl class="Bl-tag">
  <dt class="It-tag">(union { T name; T name; ...T name; }.name) E</dt>
  <dd class="It-tag">Create a value of the given union type, the variant given
      by .name, and the value given by E. E must be type-compatible with
    name.</dd>
</dl>
<h1 class="Sh" title="Sh" id="STATEMENTS"><a class="selflink" href="#STATEMENTS">STATEMENTS</a></h1>
The statement syntax very closely resembles that of C. Some additional syntax
  has been added to support Nickle's additional functionality.
<dl class="Bl-tag">
  <dt class="It-tag">E;</dt>
  <dd class="It-tag">Evaluates the expression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">{S ... S}</dt>
  <dd class="It-tag">Executes the enclosed statements in order.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">if (E) S</dt>
  <dd class="It-tag">Basic conditional.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">if (E) S</dt>
  <dd class="It-tag">Conditional execution.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">else S</dt>
  <dd class="It-tag">Else is allowed, with the usual syntax and semantics. In
      particular, an else binds to the most recent applicable if() or
    twixt().</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">while (E) S</dt>
  <dd class="It-tag">C-style while loop.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">do S while (E);</dt>
  <dd class="It-tag">C-style do loop.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">for (opt-E; opt-E; opt-E) S</dt>
  <dd class="It-tag">C-style for loop.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">switch (E) { case E: S-list case E: S-list ... default:
    S-list }</dt>
  <dd class="It-tag">C-style case statement. The case expressions are not
      required to be constant expressions, but may be arbitrary. The first case
      evaluating to the switch argument is taken, else the default if present,
      else the switch body is skipped.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">twixt(opt-E; opt-E) S</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">twixt(opt-E; opt-E) S else S</dt>
  <dd class="It-tag">If first argument expression evaluates to true, the body of
      the twixt() and then the second argument expression will be evaluated. If
      the first argument expression evaluates to false, the else statement will
      be executed if present. Otherwise, the entire twixt() statement will be
      skipped.</dd>
</dl>
<div class="Pp"></div>
The twixt() statement guarantees that all of these events will happen in the
  specified order regardless of the manner in which the twixt() is entered (from
  outside) or exited, including exceptions, continuations, and break. (Compare
  with Java's ``finally'' clause.)
<dl class="Bl-tag">
  <dt class="It-tag">try S;</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">try S catch name (T name, ...) { S; ... };</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">try S catch name (T name, ...) { S; ... } ... ;</dt>
  <dd class="It-tag">Execute the first statement S. If an exception is raised
      during execution, and the name matches the name in a catch block, bind the
      formal parameters in the catch block to the actual parameters of the
      exception, and execute the body of the catch block. There may be multiple
      catch blocks per try. Zero catches, while legal, is relatively useless.
      After completion of a catch block, execution continues after the try
      clause. As with else, a catch binds to the most recent applicable
      try-catch block.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">raise name(name, name, ..., name)</dt>
  <dd class="It-tag">Raise the named exception with zero or more arguments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">;</dt>
  <dd class="It-tag">The null statement</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">break;</dt>
  <dd class="It-tag">Discontinue execution of the nearest enclosing
      for/do/while/switch/twixt statement. The leave expression will be executed
      as the twixt statement is exited.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">continue;</dt>
  <dd class="It-tag">Branch directly to the conditional test of the nearest
      enclosing for/do/while statement.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">return E;</dt>
  <dd class="It-tag">Return value E from the nearest enclosing function.</dd>
</dl>
<div class="Pp"></div>
<b>Namespaces:</b>
<div class="Pp"></div>
Like Java and C++ Nickle has a notion of <i>namespace</i>, a collection of names
  with partially restricted visibility. In Nickle, namespaces are created with
  the <i>namespace</i> command.
<dl class="Bl-tag">
  <dt class="It-tag">opt-P namespace N { S ... }</dt>
  <dd class="It-tag">Places all names defined in the statements S into a
      namespace named N. The optional qualifier P may be the keyword public, but
      beware: this merely indicates that the name N itself is visible elsewhere
      in the current scope, and has nothing to do with the visibility of items
      inside the namespace.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">extend namespace N { S ... }</dt>
  <dd class="It-tag">Reopen the given namespace N, and extend it with the names
      defined as public in the given statements S.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Names defined inside the namespace are invisible outside
      the namespace unless they are qualified with the keyword public. Public
      names may be referred to using a path notation:
    <div>&#x00A0;</div>
    <br/>
     namespace::namespace::...::namespace::name
    <div>&#x00A0;</div>
    refers to the given name as defined inside the given set of namespaces. The
      double-colon syntax is unfortunate, as it is slightly different in meaning
      than in C++, but all the good symbols were taken, and it is believed to be
      a feature that the namespace separator is syntactically different than the
      structure operator. In Java, for example, the phrase
    <div>&#x00A0;</div>
    <br/>
     name.name.name
    <div>&#x00A0;</div>
    is syntactically ambiguous: the middle name may be either a structure or a
      namespace.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">import N;</dt>
  <dd class="It-tag">The name N must refer to a namespace: all public names in
      this namespace are brought into the current scope (scoping out conflicting
      names).</dd>
</dl>
<h1 class="Sh" title="Sh" id="BUILTINS"><a class="selflink" href="#BUILTINS">BUILTINS</a></h1>
<i>Nickle</i> has a collection of standard functions built in. Some of these are
  written in C, but many are written in Nickle. Several collections of functions
  have associated builtin datatypes: their namespaces, together with their
  types, should be viewed as ADTs.
<div class="Pp"></div>
<b>Top-Level Builtins:</b>
<dl class="Bl-tag">
  <dt class="It-tag">int printf(string fmt, poly args...)</dt>
  <dd class="It-tag">Calls File::fprintf(stdout, fmt, args ...) and returns its
      result.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string function gets ()</dt>
  <dd class="It-tag">Calls File::fgets(stdin) and returns its result.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string function scanf (string fmt, *poly args...)</dt>
  <dd class="It-tag">Calls File::vfscanf(stdin, fmt, args) and returns its
      result.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string function vscanf (string fmt, (*poly)[*] args)</dt>
  <dd class="It-tag">Calls File::vfscanf(stdin, fmt, args) and returns its
      result.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real imprecise(rational value)</dt>
  <dd class="It-tag">See the discussion of type real above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real imprecise(rational value, int prec)</dt>
  <dd class="It-tag">See the discussion of type real above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int string_to_integer(string s)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int atoi(string s)</dt>
  <dd class="It-tag">The argument s is a signed digit string, and the result is
      the integer it represents. If the string s is syntactically a hexadecimal,
      octal, binary, or explicit base-10 constant, treat it as such.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int string_to_integer(string s, int base)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int atoi(string s, int base)</dt>
  <dd class="It-tag">Treat s as a string of digits in the given base. A base of
      0 acts as with no base argument. Otherwise, base specification syntax in
      the string is ignored.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int putchar(int c)</dt>
  <dd class="It-tag">Place the given character on the standard output using
      File::putc(c, stdout), and return its result.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int sleep(int msecs)</dt>
  <dd class="It-tag">Try to suspend the current thread for at least msecs
      milliseconds. Return 1 on early return, and 0 otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int exit(int status)</dt>
  <dd class="It-tag">Exit Nickle with the given status code. Do not return
      anything.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int dim(poly[*] a)</dt>
  <dd class="It-tag">Given a one-dimensional array a, dim() returns the number
      of elements of a.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int[] dims(poly[] a)</dt>
  <dd class="It-tag">Given an arbitrary array a, dims() returns an array of
      integers giving the size of each dimension of a. Thus, dim(dims(a)) is the
      number of dimensions of a.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*poly reference(poly v)</dt>
  <dd class="It-tag">Given an arbitrary value v, ``box'' that value into storage
      and return a pointer to the box.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">rational string_to_real(string s)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">rational atof(string s)</dt>
  <dd class="It-tag">Convert the real constant string s into its associated real
      number.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">number abs(real v)</dt>
  <dd class="It-tag">Return the absolute value of v. The result type chosen will
      match the given context.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int floor(real v)</dt>
  <dd class="It-tag">Return the largest integer less than or equal to v. This
      will fail if v is a real and the precision is too low.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int ceil(real v)</dt>
  <dd class="It-tag">Return the smallest integer greater than or equal to v.
      This will fail if v is a real and the precision is too low.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int exponent(real v)</dt>
  <dd class="It-tag">Return the exponent of the imprecise real v.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">rational mantissa(real v)</dt>
  <dd class="It-tag">Return the mantissa of the imprecise real v, as a rational
      m with 0 &lt;= m &lt;= 0.5 .</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int numerator(rational v)</dt>
  <dd class="It-tag">Return the numerator of the rational number v: i.e., if v =
      n/d in reduced form, return n.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int denominator(rational v)</dt>
  <dd class="It-tag">Return the denominator of the rational number v: i.e., if v
      = n/d in reduced form, return d.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int precision(real v)</dt>
  <dd class="It-tag">Return the number of bits of precision of the mantissa of
      the imprecise real number v.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int sign(real v)</dt>
  <dd class="It-tag">Return -1 or 1 as v is negative or nonnegative.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int bit_width(int v)</dt>
  <dd class="It-tag">Return the number of bits required to represent abs(v)
      internally.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_int(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_rational(poly v)</dt>
  <dd class="It-tag">Numeric type predicates are inclusive: e.g., is_rational(1)
      returns 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_number(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_string(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_file(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_thread(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_semaphore(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_continuation(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_array(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_ref(poly v)</dt>
  <dd class="It-tag">Type predicate: checks for pointer type. This is arguably a
      misfeature, and may change.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_struct(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_func(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int is_void(poly v)</dt>
  <dd class="It-tag">Type predicate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int gcd(int p, int q)</dt>
  <dd class="It-tag">Return the GCD of p and q. The result is always
    positive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int xor(int a, int b)</dt>
  <dd class="It-tag">Return a ^ b . This is mostly a holdover from before Nickle
      had an xor operator.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">poly setjmp(continuation *c, poly retval)</dt>
  <dd class="It-tag">The setjmp() and longjmp() primitives together with the
      continuation type form an ADT useful for nearly arbitrary transfers of
      flow-of-control. The setjmp() and longjmp() builtins are like those of C,
      except that the restriction that longjmp() always jump upwards is
      removed(!): a continuation saved via setjmp() never becomes invalid during
      the program lifetime.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The setjmp() builtin saves the current location and context
      into its continuation pointer argument, and then returns its second
      argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">void longjmp(continuation c, poly retval)</dt>
  <dd class="It-tag">The longjmp() builtin never returns to the call site, but
      instead returns from the setjmp() that created the continuation, with
      return value equal to the second argument of longjmp().</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string prompt</dt>
  <dd class="It-tag">The prompt printed during interactive use when at
      top-level. Default &quot;&gt; &quot;. when waiting for the rest of a
      statement or expression, and when debugging, respectively. Default values
      are &quot;&gt; &quot;, &quot;+ &quot;, and &quot;- &quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string prompt2</dt>
  <dd class="It-tag">The prompt printed during interactive use when waiting for
      the rest of a statement or expression. Default &quot;+ &quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string prompt3</dt>
  <dd class="It-tag">The prompt printed during interactive use when debugging.
      Default &quot;- &quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string format</dt>
  <dd class="It-tag">The printf() format for printing top-level values. Default
      &quot;%g&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string version</dt>
  <dd class="It-tag">The version number of the Nickle implementation currently
      being executed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string build</dt>
  <dd class="It-tag">The build date of the Nickle implementation currently being
      executed, in the form &quot;yyyy/mm/dd&quot;, or &quot;?&quot; if the
      build date is unknown for some reason.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">file stdin</dt>
  <dd class="It-tag">Bound to the standard input stream.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">file stdout</dt>
  <dd class="It-tag">Bound to the standard output stream.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">file stderr</dt>
  <dd class="It-tag">Bound to the standard error stream.</dd>
</dl>
<div class="Pp"></div>
<b>Exceptions:</b>
<div class="Pp"></div>
A few standard exceptions are predeclared and used internally by Nickle.
<dl class="Bl-tag">
  <dt class="It-tag">exception uninitialized_value(string msg)</dt>
  <dd class="It-tag">Attempt to use an uninitialized value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">exception invalid_argument(string msg, int arg, poly
    val)</dt>
  <dd class="It-tag">The arg-th argument to a builtin function had invalid value
      val.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">exception readonly_box(string msg, poly val)</dt>
  <dd class="It-tag">Attempt to change the value of a read-only quantity to
    val.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">exception invalid_array_bounds(string msg, poly a, poly
    i)</dt>
  <dd class="It-tag">Attempt to access array a at index i is out of bounds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">exception divide_by_zero(string msg, real num, real
    den)</dt>
  <dd class="It-tag">Attempt to divide num by den with den == 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">exception invalid_struct_member(string msg, poly struct,
    string name)</dt>
  <dd class="It-tag">Attempt to refer to member name of the object struct, which
      does not exist.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">exception invalid_binop_values(string msg, poly arg1, poly
    arg2)</dt>
  <dd class="It-tag">Attempt to evaluate a binary operator with args arg1 and
      arg2, where at least one of these values is invalid.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">exception invalid_unop_values(string msg, poly arg)</dt>
  <dd class="It-tag">Attempt to evaluate a unary operator with invalid argument
      arg.</dd>
</dl>
<div class="Pp"></div>
<b>Builtin Namespaces:</b>
<dl class="Bl-tag">
  <dt class="It-tag">Math</dt>
  <dd class="It-tag">The math functions available in the Math namespace are
      implemented in a fashion intended to be compatible with the C library.
      Please consult the appropriate manuals for further details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real pi</dt>
  <dd class="It-tag">Imprecise constant giving the value of the
      circumference/diameter ratio of the circle to the default precision of 256
      bits.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">protected real e</dt>
  <dd class="It-tag">Imprecise constant giving the value of the base of natural
      logarithms to the default precision of 256 bits. Since e is protected, it
      must be referenced via Math::e, in order to avoid problems with using the
      fifth letter of the alphabet at top level.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function sqrt(real v)</dt>
  <dd class="It-tag">Returns the square root of v.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function cbrt(real v)</dt>
  <dd class="It-tag">Returns the cube root of v.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function exp(real v)</dt>
  <dd class="It-tag">Returns e**v.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function log(real a)</dt>
  <dd class="It-tag">Returns v such that e**v == a. Throws an invalid_argument
      exception if a is non-positive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function log10(real a)</dt>
  <dd class="It-tag">Returns v such that 10**v == a. Throws an invalid_argument
      exception if a is non-positive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function log2(real a)</dt>
  <dd class="It-tag">Returns v such that 2**v == a. Throws an invalid_argument
      exception if a is non-positive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function pi_value(int prec)</dt>
  <dd class="It-tag">Returns the ratio of the circumference of a circle to the
      diameter, with prec bits of precision.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function sin(real a)</dt>
  <dd class="It-tag">Returns the ratio of the opposite side to the hypotenuse of
      angle a of a right triangle, given in radians.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function cos(real a)</dt>
  <dd class="It-tag">Returns the ratio of the adjacent side to the hypotenuse of
      angle a of a right triangle, given in radians.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">void function sin_cos(real a, *real sinp, *real cosp)</dt>
  <dd class="It-tag">Returns with sin(a) and cos(a) stored in the locations
      pointed to by sinp and cosp respectively. If either pointer is 0, do not
      store into that location. May be slightly faster than calling both trig
      functions independently.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function tan(real a)</dt>
  <dd class="It-tag">Returns the ratio of the opposite side to the adjacent side
      of angle a of a right triangle, given in radians. Note that tan(pi/2) is
      not currently an error: it will return a very large number dependent on
      the precision of its input.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function asin(real v)</dt>
  <dd class="It-tag">Returns a such that sin(a) == v.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function acos(real v)</dt>
  <dd class="It-tag">Returns a such that cos(a) == v.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function atan(real v)</dt>
  <dd class="It-tag">Returns a such that tan(a) == v.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function atan2(real x, y)</dt>
  <dd class="It-tag">Returns a such that tan(a) == x / y. Deals correctly with y
      == 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">real function pow(real a, real b)</dt>
  <dd class="It-tag">The implementation of the ** operator.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">File</dt>
  <dd class="It-tag">The namespace File provides operations on file values.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function fprintf(file f, string s, ....)</dt>
  <dd class="It-tag">Print formatted values to a file, as with UNIX stdio
      library fprintf(). fprintf() and printf() accept a reasonable sub-set of
      the stdio library version: %c, %d, %e, %x, %o, %f, %s, %g work as
      expected, as does %v to smart-print a value. Format modifiers may be
      placed between the percent-sign and the format letter to modify
      formatting. There are a lot of known bugs with input and output
      formatting.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="Pp"></div>
<b>Format Letters:</b>
<dl class="Bl-tag">
  <dt class="It-tag">%c</dt>
  <dd class="It-tag">Requires a small integer argument (0..255), and formats as
      an ASCII character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%d</dt>
  <dd class="It-tag">Requires an integer argument, and formats as an
    integer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%x</dt>
  <dd class="It-tag">Requires an integer argument, and formats as a base-16
      (hexadecimal) integer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%o</dt>
  <dd class="It-tag">Requires an integer argument, and formats as a base-8
      (octal) integer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%e</dt>
  <dd class="It-tag">Requires a number argument, and formats in scientific
      notation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%f</dt>
  <dd class="It-tag">Requires a number argument, and formats in fixed-point
      notation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%s</dt>
  <dd class="It-tag">Requires a string argument, and emits the string
    literally.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%g</dt>
  <dd class="It-tag">Requires a number, and tries to pick a precise and readable
      representation to format it.</dd>
</dl>
<div class="Pp"></div>
<b>Format Modifiers:</b>
<dl class="Bl-tag">
  <dt class="It-tag">digits</dt>
  <dd class="It-tag">All format characters will take an integer format modifier
      indicating the number of blanks in the format field for the data to be
      formatted. The value will be printed right-justified in this space.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">digits.digits</dt>
  <dd class="It-tag">The real formats will take a pair of integer format
      modifiers indicating the field width and precision (number of chars after
      decimal point) of the formatted value. Either integer may be omitted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">A precision value indicating infinite precision.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">The next argument to fprintf() is an integer indicating the
      field width or precision of the formatted value.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">file function string_write()</dt>
  <dd class="It-tag">Return a file which collects written values into a
    string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function close(file f)</dt>
  <dd class="It-tag">Close file f and return an indication of success.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function flush(file f)</dt>
  <dd class="It-tag">Flush the buffers of file f and return an indication of
      success.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function getc(file f)</dt>
  <dd class="It-tag">Get the next character from file f and return it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function end(file f)</dt>
  <dd class="It-tag">Returns true if file f is at EOF, else false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function error(file f)</dt>
  <dd class="It-tag">Returns true if an error is pending on file f, else
    false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function clear_error(file f)</dt>
  <dd class="It-tag">Clears pending errors on file f, and returns an indication
      of success.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">file function string_read(string s)</dt>
  <dd class="It-tag">Returns a virtual file whose contents are the string
    s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string function string_string(file f)</dt>
  <dd class="It-tag">Return the string previously written into the file f, which
      should have been created by string_read() or string_write(). Behavior on
      other files is currently undefined.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">file function open(string path, string mode)</dt>
  <dd class="It-tag">Open the file at the given path with the given mode string,
      ala UNIX stdio fopen(). Permissible modes are as in stdio: &quot;r&quot;,
      &quot;w&quot;, &quot;x&quot;, &quot;r+&quot;, &quot;w+&quot; and
      &quot;x+&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">integer function fputc(integer c, file f)</dt>
  <dd class="It-tag">Output the character c to the output file f, and return an
      indication of success.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">integer function ungetc(integer c, file f)</dt>
  <dd class="It-tag">Push the character c back onto the input file f, and return
      an indication of success.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">integer function setbuf(file f, integer n)</dt>
  <dd class="It-tag">Set the size of the buffer associated with file f to n, and
      return n.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string function fgets (file f)</dt>
  <dd class="It-tag">Get a line of input from file f, and return the resulting
      string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">file function pipe(string path, string[*] argv, string
    mode)</dt>
  <dd class="It-tag">Start up the program at the given path, returning a file
      which is one end of a &quot;pipe&quot; to the given process. The mode
      argument can be &quot;r&quot; to read from the pipe or &quot;w&quot; to
      write to the pipe. The argv argument is an array of strings giving the
      arguments to be passed to the program, with argv[0] conventionally being
      the program name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function print (file f, poly v, string fmt, int base,
    int width, int prec, string fill)</dt>
  <dd class="It-tag">Print value v to file f in format fmt with the given base,
      width, prec, and fill. Used internally by File::fprintf();</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function fscanf(file f, string fmt, *poly args...)</dt>
  <dd class="It-tag">Fill the locations pointed to by the array args with values
      taken from file f according to string fmt. The format specifiers are much
      as in UNIX stdio scanf(): the &quot;%d&quot;, &quot;%e&quot;,
      &quot;%f&quot;, &quot;%c&quot; and &quot;%s&quot; specifiers are supported
      with the expected modifiers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function vfscanf (file f, string fmt, (*poly)[*]
    args)</dt>
  <dd class="It-tag">Given the file f, the format fmt, and the array of
      arguments args, fscanf() appropriately.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Thread</dt>
  <dd class="It-tag">The namespace Thread supports various operations useful for
      programming with <i>threads</i>, which provide concurrent flow of control
      in the shared address space. There is one piece of special syntax
      associated with threads.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">fork(E)</dt>
  <dd class="It-tag">Accepts an arbitrary expression, and evaluates it in a new
      child thread. The parent thread receives the thread as the value of the
      fork expression.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The remainder of the Thread functions are fairly
    standard.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function kill(thread list...)</dt>
  <dd class="It-tag">Kills every running thread in the array list. With no
      arguments, kills the currently running thread. Returns the number of
      threads killed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function trace(poly list...)</dt>
  <dd class="It-tag">Shows the state of every running thread in the array list.
      With no arguments, traces the default continuation. Returns the number of
      threads traced.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function cont()</dt>
  <dd class="It-tag">Continues execution of any interrupted threads, and returns
      the number of continued threads.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">thread function current()</dt>
  <dd class="It-tag">Return the current thread.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function list()</dt>
  <dd class="It-tag">Reports the currently running thread to stdout.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function get_priority(thread t)</dt>
  <dd class="It-tag">Reports the priority of the given thread.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">thread function id_to_thread(int id)</dt>
  <dd class="It-tag">Returns the thread with the given id, if found, and 0
      otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">poly function join(thread t)</dt>
  <dd class="It-tag">Waits for thread t to terminate, and returns whatever it
      returns.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function set_priority(thread t, int i)</dt>
  <dd class="It-tag">Attempts to set the priority of thread t to level i, and
      returns the new priority. Larger priorities mean more runtime: a task with
      higher priority will always run instead of a lower priority task. Threads
      of equal highest priority will be pre-emptively multitasked.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Semaphore</dt>
  <dd class="It-tag">The Semaphore namespace encapsulates operations on the
      semaphore built-in ADT. A semaphore is used for thread synchronization.
      Each signal() operation on the semaphore awakens the least-recent thread
      to wait() on that semaphore. The ``count'' of waiting processes may be set
      at semaphore creation time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">semaphore function new(int c)</dt>
  <dd class="It-tag">Create a new semaphore with an initial count c of waiting
      processes. If c is positive, it means that c threads may wait on the
      semaphore before one blocks. If c is negative, it sets a count of threads
      which must be waiting on the semaphore before further waits will not
      block.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">semaphore function new()</dt>
  <dd class="It-tag">Call semaphore(0) and return its result.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int signal(semaphore s)</dt>
  <dd class="It-tag">Increment semaphore s. If s is non-positive, and some
      thread is blocked on s, release the least-recently-blocked thread. Return
      1 on success.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int wait(semaphore s)</dt>
  <dd class="It-tag">Decrement semaphore s. If s is negative, block until
      released. Return 1 on success.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int test(semaphore s)</dt>
  <dd class="It-tag">Test whether wait() on semaphore s would cause the current
      thread to block. If so, return 0. Otherwise, attempt to decrement s, and
      return 1 if successful.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">String</dt>
  <dd class="It-tag">The String namespace contains a few basic operations on the
      string ADT.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function length(string s)</dt>
  <dd class="It-tag">Returns the number of characters in s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string function new(int c)</dt>
  <dd class="It-tag">Returns as a string the single character c.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string function new(int cv[*])</dt>
  <dd class="It-tag">Returns a string comprised of the characters of cv.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function index(string t, string p)</dt>
  <dd class="It-tag">Returns the integer index of the pattern string p in the
      target string t, or -1 if p is not a substring of t.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string function substr(string s, int i, int l)</dt>
  <dd class="It-tag">Returns the substring of string s starting with the
      character at offset i (zero-based) and continuing for a total of l
      characters. If l is negative, the substring will consist of characters
      preceding rather than succeeding i.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">PRNG</dt>
  <dd class="It-tag">The PRNG namespace provides pseudo-random number generation
      and manipulation. The core generator is the RC4 stream cipher generator,
      properly bootstrapped. This provide a stream of cryptographically-secure
      pseudo-random bits at reasonable amortized cost. (But beware,
      initialization is somewhat expensive.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">void function srandom(int s)</dt>
  <dd class="It-tag">Initialize the generator, using the (arbitrarily-large)
      integer as a seed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">void function dev_srandom(int nbits)</dt>
  <dd class="It-tag">Initialize the generator, using nbits bits of entropy
      obtained from some reasonable entropy source. On UNIX systems, this source
      is /dev/urandom. Asking for more initial entropy than the system has may
      lead either to bootstrapping (as on UNIX) or to hanging, so use
      cautiously.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function randbits(int n)</dt>
  <dd class="It-tag">Returns an n-<b>bit</b> pseudo-random number, in the range
      <i>0..(2**n)-1</i>. Useful for things like RSA.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function randint(int n)</dt>
  <dd class="It-tag">Returns a pseudo-random number in the range
    <i>0..n-1</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">void function shuffle(*(poly[*]) a)</dt>
  <dd class="It-tag">Performs an efficient in-place true shuffle (c.f. Knuth) of
      the array a.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Command</dt>
  <dd class="It-tag">The Command namespace is used by the top-level commands as
      described below. It is also occasionally useful in its own right.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string library_path</dt>
  <dd class="It-tag">Contains the current library search path, a colon-separated
      list of directories to be searched for library files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function undefine(string name)</dt>
  <dd class="It-tag">Implements the top-level undefine command. Remove the name
      denoted by string name from the namespace. This removes all visible
      definitions of the name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function undefine(string[*] names)</dt>
  <dd class="It-tag">Remove each of the names in the array names from the
      namespace. This removes all visible definitions of each name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function delete(string name)</dt>
  <dd class="It-tag">Attempt to remove the command with the given string name
      from the top-level command list, and return 1 if successful.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function lex_file(string path)</dt>
  <dd class="It-tag">Attempt to make the file at the given path the current
      source of Nickle code, and return 1 if successful. Note that this
      effectively ``includes'' the file by pushing it onto a stack of files to
      be processed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function lex_library(string filename)</dt>
  <dd class="It-tag">Like lex_file(), but searches the directories given by the
      <i>library_path</i> variable for the first file with the given
    filename.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function lex_string(string code)</dt>
  <dd class="It-tag">Attempt to make the Nickle code contained in the string
      code be the next input.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function edit(string[*] names)</dt>
  <dd class="It-tag">Implements the top-level edit command. The names in the
      array are a path of namespace names leading to the symbol name, which is
      last.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function new(string name, poly func)</dt>
  <dd class="It-tag">Binds function func to the top-level command string name:
      i.e., makes it part of the top-level command vocabulary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function new_names(string name, poly func)</dt>
  <dd class="It-tag">Binds function func to the top-level command string name:
      i.e., makes it part of the top-level command vocabulary. Unlike new(), the
      string names given to func at the top level are passed unevaluated as an
      array of string names or as a single string name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function pretty_print(file f, string[*] names)</dt>
  <dd class="It-tag">Implements the top-level print command. Each of the passed
      name strings is looked up and the corresponding code printed to file
    f.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function display(string fmt, poly val)</dt>
  <dd class="It-tag">Uses printf() to display the value val in format fmt.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">History</dt>
  <dd class="It-tag">Nickle maintains a top-level value history, useful as an
      adjunct to command-line editing when calculating. The History namespace
      contains functions to access this history.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function show(string fmt)</dt>
  <dd class="It-tag">Implements the history top-level command with no arguments.
      Show the most recent history values with format fmt.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function show(string fmt, int count)</dt>
  <dd class="It-tag">Implements the history top-level command with one argument.
      Show the last count history values with format fmt.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function show(string fmt, int first, int last)</dt>
  <dd class="It-tag">Implements the history top-level command with two
      arguments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">poly function insert(poly val)</dt>
  <dd class="It-tag">Insert val in the history list, and return it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Environ</dt>
  <dd class="It-tag">Many operating systems have some notion of ``environment
      variables.'' The Environ namespace contains functions to manipulate
    these.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function check(string name)</dt>
  <dd class="It-tag">Returns 1 if the variable with the given name is in the
      environment, and 0 otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string function get(string name)</dt>
  <dd class="It-tag">Attempts to retrieve and return the value of the
      environment variable with the given name. Throws an invalid_argument
      exception if the variable is not available.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">int function unset(string name)</dt>
  <dd class="It-tag">Attempts to unset the environment variable with the given
      name, and returns an indication of success.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string function set(string name, string value)</dt>
  <dd class="It-tag">Attempts to set the environment variable with the given
      name to the given value, and returns an indication of success.</dd>
</dl>
<h1 class="Sh" title="Sh" id="COMMANDS"><a class="selflink" href="#COMMANDS">COMMANDS</a></h1>
Nickle has a set of commands which may be given at the top level.
<dl class="Bl-tag">
  <dt class="It-tag">quit</dt>
  <dd class="It-tag">Exit Nickle.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">quit E</dt>
  <dd class="It-tag">Exit Nickle with integer status code E.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">undefine NAME {,NAME}</dt>
  <dd class="It-tag">Remove these names from the system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">load E</dt>
  <dd class="It-tag">Load a file given by the string name E.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">library E</dt>
  <dd class="It-tag">Load a library given by the string name E. See the
      discussion of the NICKLEPATH environment variable in ENVIRONMENT below,
      and the discussion of Command::library_path above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">E # E</dt>
  <dd class="It-tag">Print expr1 in base expr2 .</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">print NAME</dt>
  <dd class="It-tag">Display a formatted version of the object denoted by NAME.
      Comments and original formating are lost. If NAME is a variable, print the
      type as well as the value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">edit NAME</dt>
  <dd class="It-tag">Invoke $EDITOR on the named object, and re-incorporate the
      results of the edit. This is most useful with functions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">history</dt>
  <dd class="It-tag">Display the 10 most recently printed values. They can be
      accessed with <b>$</b><i>n</i> where <i>n</i> is the number displayed to
      the right of the value in this list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">history <i>E</i></dt>
  <dd class="It-tag">Display the E most recent history values.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">history <i>E</i>,<i>E</i></dt>
  <dd class="It-tag">Display history values from the first integer E through the
      second.</dd>
</dl>
<h1 class="Sh" title="Sh" id="DEBUGGER"><a class="selflink" href="#DEBUGGER">DEBUGGER</a></h1>
When an unhandled exception reaches top level during execution, the user
  receives a dash prompt, indicating that debug mode is active. In this mode,
  the command-line environment is that in which the unhandled exception was
  raised. In addition a number of debugging commands are available to the user:
<dl class="Bl-tag">
  <dt class="It-tag">trace</dt>
  <dd class="It-tag">Get a stack backtrace showing the current state, as with
      the GDB where command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">up</dt>
  <dd class="It-tag">Move up the stack (i.e., toward the top-level expression)
      ala GDB.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">down</dt>
  <dd class="It-tag">Move down the stack (i.e., toward the current context) ala
      GDB.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">done</dt>
  <dd class="It-tag">Leave debugging mode, abandoning execution.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">In addition, the Debug namespace is scoped in in debugging
      mode. This is primarily of use in debugging Nickle itself.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">collect()</dt>
  <dd class="It-tag">Run the garbage collector.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dump(function)</dt>
  <dd class="It-tag">Print the compiled byte code for function.</dd>
</dl>
<h1 class="Sh" title="Sh" id="ENVIRONMENT"><a class="selflink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">EDITOR</dt>
  <dd class="It-tag">The editor used by the edit command, described in COMMANDS
      above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">NICKLERC</dt>
  <dd class="It-tag">The location of the user's .nicklerc file, which will be
      loaded at the beginning of nickle execution if possible.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">HOME</dt>
  <dd class="It-tag">Used to find the user's .nicklerc if NICKLERC is not
    set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">NICKLEPATH</dt>
  <dd class="It-tag">A colon-separated path whose elements are directories
      containing Nickle code. The library command and the -l flag, described
      above, search this path for a filename matching the given file. The
      default library path in the absence of this variable is
    /usr/share/nickle.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">NICKLESTART</dt>
  <dd class="It-tag">The filename of the file that should be loaded as a
      bootstrap on Nickle startup. The default in the absence of this variable
      is to load /usr/share/nickle/builtin.5c.</dd>
</dl>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
An example (taken from the <i>bc</i> manual:
<pre>
<div class="Pp"></div>
  real function exponent(real x) {
      real a = 1;
      int b = 1;
      real s = 1;
      int i = 1;
      while (1) {
          a = a * x;
          b = b * i;
          real c = a / b;
          if (abs(c) &lt; 1e-6)
              return s;
          s = s + c;
          i++;
      }
  }
<div class="Pp"></div>
</pre>
defines a function to compute an approximate value of the exponential function e
  ** x and
<pre>
<div class="Pp"></div>
  for (i = 1; i &lt; 10; i++)
      printf (&quot;%g\n&quot;, exponent (i));
<div class="Pp"></div>
</pre>
prints approximate values of the exponential function of the first ten integers.
<h1 class="Sh" title="Sh" id="VERSION"><a class="selflink" href="#VERSION">VERSION</a></h1>
This document describes version 1.99.2 of nickle, as well as some newer
  features. It was distributed with version 2.77 of nickle.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
See the discussion of the type of the exponentiation operator ** above.
<div class="Pp"></div>
Due to a difficult-to-remove grammar ambiguity, it is not possible to use a bare
  assignment expression in an array initializer: it is confused with a structure
  initializer. For example:
<pre>
  &gt; int x = 0;
  &gt; (int[*]){x = 1}
  -&gt;     (int[*]) { x = 1 }
Non array initializer
</pre>
The workaround is to parenthesize the assignment expression:
<pre>
  &gt; (int[*]){(x = 1)}
  [1]{1}
</pre>
Because this is so rare, so hard to fix, and so easy to work around, this bug is
  unlikely to be fixed anytime soon.
<div class="Pp"></div>
There are a lot of known bugs with input and output formatting. The obvious
  stuff works, other stuff does not.
<div class="Pp"></div>
The semantics of division are unfortunately different from those of C. This is
  arguably because C is broken in this area: we cannot currently see any obvious
  fix. C allows automatic implicit coercion of floating to integral types, but
  we consider this a misfeature.
<div class="Pp"></div>
The implementation has not been thoroughly tested.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
<i>Nickle</i> is the work of Keith Packard &lt;keithp@keithp.com&gt; and Bart
  Massey &lt;bart_massey@iname.com&gt;.
<div class="Pp"></div>
Nickle is
<div>&#x00A0;</div>
Copyright 1988-2006 Keith Packard and Bart Massey. All Rights Reserved.
<div class="Pp"></div>
Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the &quot;Software&quot;),
  to deal in the Software without restriction, including without limitation the
  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  sell copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
<div class="Pp"></div>
The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
<div class="Pp"></div>
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
<div class="Pp"></div>
Except as contained in this notice, the names of the authors or their
  institutions shall not be used in advertising or otherwise to promote the
  sale, use or other dealings in this Software without prior written
  authorization from the authors.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017/02/11</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
