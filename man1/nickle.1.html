<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:27:19 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>NICKLE(1) General Commands Manual NICKLE(1)</p>

<p style="margin-top: 1em">NAME <br>
nickle - a desk calculator language</p>

<p style="margin-top: 1em">SYNOPSIS <br>
nickle [--help|--usage] [-f file] [-l library] [-e expr] [
script ] [--] [arg ...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Nickle is a desk calculator language with powerful
programming and scripting capabilities. Nickle supports a
variety of datatypes, especially arbitrary precision
integers, <br>
rationals, and imprecise reals. The input language vaguely
resembles C. Some things in C which do not translate easily
are different, some design choices have been made
differ&acirc; <br>
ently, and a very few features are simply missing.</p>

<p style="margin-top: 1em">USAGE <br>
An un-flagged argument is treated as a Nickle script, and
replaces standard input. Any remaining arguments following
the script are placed in the Nickle string array argv for
<br>
programmatic inspection. When invoked without an expression
or script argument, Nickle reads from standard input, and
writes to standard output.</p>

<p style="margin-top: 1em">Options are as follows:</p>

<p style="margin-top: 1em">--help,--usage <br>
Print a help/usage message and exit. This is a built-in
feature of Nickle&rsquo;s ParseArgs module, and thus will
also be true of Nickle scripts that use this library.</p>

<p style="margin-top: 1em">-f,--file file <br>
Load file into Nickle before beginning execution.</p>

<p style="margin-top: 1em">-l,--library library <br>
Load library into Nickle before beginning execution. See
below for a description of the library facility.</p>

<p style="margin-top: 1em">-e,--expr expr <br>
Evaluate expr before beginning execution.</p>

<p style="margin-top: 1em">-- Quit parsing arguments and
pass the remainder, unevaluated, to argv.</p>

<p style="margin-top: 1em">SYNTAX <br>
To make the input language more useful in an interactive
setting, newline only terminates statements at
&lsquo;&lsquo;reasonable&rsquo;&rsquo; times. Newline
terminates either expressions or single <br>
statements typed by the user (with the exception of a few
statements which require lookahead: notably if() and
twixt(), which have an optional else part). Inside compound
state&acirc; <br>
ments or function definitions, only a ; terminates
statements. This approach is convenient and does not appear
to cause problems in normal use.</p>

<p style="margin-top: 1em">The syntax of Nickle programs is
as follows. In this description, name denotes any sequence
of letters, digits and _ characters not starting with a
digit; E denotes any expres&acirc; <br>
sion; S denotes any statement; and T denotes any type. The
syntax X,X,...,X denotes one or more comma-separated Xs,
unless otherwise indicated.</p>

<p style="margin-top: 1em">Comments:</p>

<p style="margin-top: 1em">C-style comments are enclosed in
/* and */, and shell-style comments are denoted by a leading
# at the start of a line.</p>

<p style="margin-top: 1em">Operands:</p>

<p style="margin-top: 1em">real number <br>
Can include exponent, need not include decimal point or
sign. Will be treated as exact rationals. If a trailing
decimal part contains an opening curly brace, the brace <br>
is silently ignored; if it contains a curly-bracketed
trailing portion, it is treated as a repeating decimal.
&lsquo;Floating point&rsquo;&rsquo; constants are currently
represented inter&acirc; <br>
nally as rationals: for floating constants with a given
precision (and an infinite-precision exponent), use the
imprecise() builtin function described below.</p>

<p style="margin-top: 1em">octal number <br>
Start with a 0 (e.g., 014 is the same as 12).</p>

<p style="margin-top: 1em">hexidecimal number <br>
Start with &quot;0x&quot; (e.g., 0x1a is the same as
26).</p>

<p style="margin-top: 1em">string As in C. String constants
are surrounded by double-quotes. Backslashed characters
(including double-quotes)&quot; stand for themselves, except
&quot;0 stands for newline, &quot; f o r b a c <br>
for carriage return, &quot;k&quot; for tab and &quot; for s
p a c e , formfeed.</p>

<p style="margin-top: 1em">name A variable reference.</p>

<p style="margin-top: 1em">name() name(E,E,...,E) <br>
A function call with zero or more arguments. Functions are
fully call-by-value: arrays and structures are copied rather
than being referenced as in C.</p>

<p style="margin-top: 1em">desc name T name = value <br>
Definition expressions: a new name is made available, with
the value of the definition being the value of the
initializer in the second form, and uninitialized in the
<br>
first form. The descriptor desc is not optional: it consists
of any combination of visibility, storage class or type (in
that order). See QUALIFIERS immediately below <br>
for a description of these qualifiers. A structured value
expression is also possible: see VALUES below.</p>

<p style="margin-top: 1em">In addition to being able to
initialize a definition with a Nickle value, C-style array,
structure, and union definitions are also allowed: For
example, the following <br>
int[*,*] name = {{0,1},{2,3}} <br>
int[2,2] name = {{0...}...} <br>
are permitted with the obvious semantics. This is the
context in which the dimensions in a type may be
expressions: see the discussion of array types above. See
the dis&acirc; <br>
cussion of array and structure values for array and
structure initializer syntax.</p>

<p style="margin-top: 1em">QUALIFIERS <br>
A declaration or definition may be qualified, as in C, to
indicate details of programmatic behavior. Unlike in C,
these qualifiers, while optional, must appear in the given
<br>
order.</p>

<p style="margin-top: 1em">Visibility:</p>

<p style="margin-top: 1em">public Any definition expression
(function definition, variable definition, type definition)
can be qualified with public to indicate that the name being
defined should be visi&acirc; <br>
ble outside the current namespace, and should be
automatically imported. See Namespaces below for further
info.</p>

<p style="margin-top: 1em">protected <br>
Any definition expression (function definition, variable
definition, type definition) can be qualified with protected
to indicate that the name being defined should be <br>
visible outside the current namespace, but should not be
made available by import declarations. See Namespaces below
for further info.</p>

<p style="margin-top: 1em">Lifetime:</p>

<p style="margin-top: 1em">auto An auto object is local to
a particular block: its lifetime is at least the lifetime of
that block. An auto object with an initializer will be
re-initialized each time it <br>
is evaluated. This is the default lifetime for local
objects.</p>

<p style="margin-top: 1em">static A static object is local
to a particular function definition: its lifetime is at
least the lifetime of that definition. A new static object
will be created each time its <br>
enclosing function definition is evaluated.</p>

<p style="margin-top: 1em">In Nickle, the keyword static
has to do only with lifetime (like the use of static inside
C functions), not with visibility (which is handled by
separate qualifiers as <br>
described above, not like the use of static in global scope
in C).</p>

<p style="margin-top: 1em">global A global object is global
to the entire program: its lifetime is the lifetime of the
program. A global object will be created and initialized
when its definition is first <br>
seen. This is the default lifetime for global objects.</p>

<p style="margin-top: 1em">The distinction between static
and global lifetime in Nickle is not possible in C, because
C functions are not first class objects with nested scope.
When deciding which <br>
to use in a Nickle program, think about what should happen
if a definition is re-evaluated.</p>

<p style="margin-top: 1em">OPERATORS <br>
Here are the basic Nickle operators, grouped in order of
decreasing precedence:</p>

<p style="margin-top: 1em">A[E,E,...,E] <br>
Refers to the E&rsquo;th element of the array expression A,
or the E1&rsquo;th/E2&rsquo;th/etc element of a
multi-dimensional array. Both arrays of arrays ala C and
multidimensional arrays <br>
ala NAWK are possible.</p>

<p style="margin-top: 1em">struct.tag <br>
Structure dereference.</p>

<p style="margin-top: 1em">struct-&gt;tag <br>
Structure pointer dereference ala C.</p>

<p style="margin-top: 1em">=============</p>

<p style="margin-top: 1em">++ -- Unary increment/decrement.
May be either postfix or prefix.</p>

<p style="margin-top: 1em">- Unary negate</p>

<p style="margin-top: 1em">! E Logical negation.</p>

<p style="margin-top: 1em">E ! Factorial. Requires a
non-negative integer argument.</p>

<p style="margin-top: 1em">* E Pointer dereference.</p>

<p style="margin-top: 1em">&amp; E Reference
construction.</p>

<p style="margin-top: 1em">=============</p>

<p style="margin-top: 1em">(U) E Construct a value of union
type with tag U and value E.</p>

<p style="margin-top: 1em">=============</p>

<p style="margin-top: 1em">** Exponentiation. Both operands
may be fractional. The left operand must be non-negative
unless the right operand is integer. The result type is the
type of the left oper&acirc; <br>
and if the right operand is integer, and real otherwise.</p>

<p style="margin-top: 1em">This is the only known
type-unsound feature of Nickle: an expression like 2 ** -3
will statically be of type integer, but dynamically will
generate a rational result. <br>
This may cause a runtime type error later on: consider <br>
int x = 2 ** -3;</p>

<p style="margin-top: 1em">=============</p>

<p style="margin-top: 1em">* / // % <br>
Times, divide, integer divide, and remainder. The right
operand of the last three operators must be nonzero. The
result type of the division operator will always be at <br>
least rational: the result type of the integer division
operator will always be int. This is a notable departure
from C, where integer division is implied by integer
op&acirc; <br>
erands. Integer division is defined by <br>
x // y == y &gt; 0 ? floor (x / y) : ceil(x / y) <br>
The remainder is always non-negative and is defined by: by
<br>
x % y = x - (x // y) * y</p>

<p style="margin-top: 1em">=============</p>

<p style="margin-top: 1em">+ - Addition and
subtraction.</p>

<p style="margin-top: 1em">=============</p>

<p style="margin-top: 1em">&lt;&lt; &gt;&gt; Bitwise left
and right shift with integer operands. Negative right
operands work as expected. These operators are defined by
<br>
x &lt;&lt; y = x * 2 ** y <br>
x &gt;&gt; y = x // 2 ** y <br>
Another way to look at this is that negative left operands
are considered to be in an infinite twos-complement
representation (i.e., sign-extended to infinity), with right
<br>
shift sign-extending its left operand.</p>

<p style="margin-top: 1em">=============</p>

<p style="margin-top: 1em">&lt;= &gt;= &lt; &gt; <br>
Relational operators.</p>

<p style="margin-top: 1em">=============</p>

<p style="margin-top: 1em">== != Equality operators.</p>

<p style="margin-top: 1em">============= <br>
Finally, in order of decreasing precedence:</p>

<p style="margin-top: 1em">&amp; Bitwise AND. Negative
operands are considered to be in an infinite twos-complement
representation (i.e., sign-extended to infinity).</p>

<p style="margin-top: 1em">^ Bitwise XOR. Negative operands
as in bitwise AND.</p>

<p style="margin-top: 1em">| Bitwise OR. Negative operands
as in bitwise AND.</p>

<p style="margin-top: 1em">&amp;&amp; Short-circuit logical
AND.</p>

<p style="margin-top: 1em">|| Short-circuit logical OR.</p>

<p style="margin-top: 1em">E ? E : E <br>
Conditional expression: if first expression is logical true,
value is second expression, else third.</p>

<p style="margin-top: 1em">fork E Create (and return) a
thread. See Thread below for details.</p>

<p style="margin-top: 1em">= += -= *= /= //= %= **=
&lt;&lt;= &gt;&gt;= ^= &amp;= |= <br>
Assignment operators. Left-hand-side must be assignable. x
&lt;op&gt;= y is equivalent to x = x &lt;op&gt; y</p>

<p style="margin-top: 1em">E , E Returns right-hand
expression.</p>

<p style="margin-top: 1em">TYPES <br>
The type declaration syntax of Nickle more strongly
resembles the &lsquo;&lsquo;left&rsquo;&rsquo; variant of
the Java syntax than the C syntax. Essentially, a type
consists of:</p>

<p style="margin-top: 1em">poly integer rational real
string continuation void <br>
A base type of the language. Type void is actually only
usable in certain contexts, notably function returns. It is
currently implemented as a &lsquo;&lsquo;unit&rsquo;&rsquo;
type ala ML, and <br>
thus has slightly different behavior than in C. Type poly is
the supertype of all other types (i.e., it can be used to
inhibit static type checking), and is the default <br>
type in most situations where a type need not appear.</p>

<p style="margin-top: 1em">file semaphore thread <br>
Also builtin base types, but integral to the File and Thread
ADTs: see below.</p>

<p style="margin-top: 1em">More About Types:</p>

<p style="margin-top: 1em">Nickle supports polymorphic
data: As an expresion is evaluated, a data type is chosen to
fit the result. Any Nickle object may be statically typed,
in which case bounds viola&acirc; <br>
tions will be flagged as errors at compile time. Polymorphic
variables and functions do not place restrictions on the
assigned data type; this is the default type for all <br>
objects.</p>

<p style="margin-top: 1em">poly This describes the union of
all datatypes. A variable with this type can contain any
data value.</p>

<p style="margin-top: 1em">int Arbitrary precision
integers.</p>

<p style="margin-top: 1em">rational <br>
Arbitrary precision rational numbers.</p>

<p style="margin-top: 1em">real Arbitrary exponent
precision floating point numbers. As many computations
cannot be carried out exactly as rational numbers, Nickle
implements non-precise arithmetic <br>
using its own machine-independent representation for
floating point numbers. The builtin function imprecise(n)
generates a real number with 256 bits of precision from the
<br>
number n, while imprecise(n,p) generates a real number with
p bits of precision.</p>

<p style="margin-top: 1em">T[] An array of type T, of one
or more dimensions. There are no zero-dimensional arrays in
Nickle.</p>

<p style="margin-top: 1em">T[*] A one-dimensional array of
type T. Unlike in C, the dimension of an array is never part
of its type in Nickle. Further, arrays and pointers are
unrelated types in <br>
Nickle.</p>

<p style="margin-top: 1em">T[*,*,...,*] <br>
A two or more dimensional array of type T. The stars
&lsquo;&lsquo;*&rsquo;&rsquo; are not optional. As the
previous paragraphs make clear,
&lsquo;&lsquo;T[]&rsquo;&rsquo; is not a zero-dimensional
array.</p>

<p style="margin-top: 1em">T[E,E,...,E] <br>
In definition contexts, integer values may be given for each
dimension of an array context. These are strictly for
value-creation purposes, and are not part of the type. <br>
An array type is determined only by the base type and number
of dimensions of the array.</p>

<p style="margin-top: 1em">T0() T0(T,T,...,T) <br>
A function returning type T0. A function accepts 0 or more
arguments.</p>

<p style="margin-top: 1em">T0() T0(T,T,...,T ...) <br>
A function accepting zero or more required arguments, plus
an arbitrary number of optional arguments. The second
sequence of three dots (ellipsis) is syntax, not
metasyn&acirc; <br>
tax: see the description of varargs functions for
details.</p>

<p style="margin-top: 1em">*T A pointer to a location of
type T. Pointer arithmetic in Nickle operates only upon
pointers to arrays: the pointer must be of the correct type,
and may never stray out of <br>
bounds. A pointer may either point to some location or be
null (0). As in C, the precedence of
&lsquo;&lsquo;*&rsquo;&rsquo; is lower than the precedence
of &lsquo;&lsquo;[]&rsquo;&rsquo; or
&lsquo;&lsquo;()&rsquo;&rsquo;: use parenthesis as <br>
needed.</p>

<p style="margin-top: 1em">struct {T name; T name; ...}
<br>
A structure with fields of the given name and type. The
types T are optional: in their absence, the type of the
field is poly.</p>

<p style="margin-top: 1em">union {T name; T name; ...} <br>
A &lsquo;&lsquo;disjoint union&rsquo;&rsquo; of the given
types. This is more like the variant record type of Pascal
or the datatype of ML than the C union type: the names are
tags of the given <br>
type, exactly one of which applies to a given value at a
given time.</p>

<p style="margin-top: 1em">(T) Parentheses for
grouping.</p>

<p style="margin-top: 1em">Typedef:</p>

<p style="margin-top: 1em">As in C, new type names may be
created with the typedef statement. The syntax is <br>
typedef T typename; <br>
where T is a Nickle type. The resulting typename may be used
anywhere a type is expected.</p>

<p style="margin-top: 1em">VALUES <br>
Values of the base types of Nickle are as expected. See the
syntax for constants above. Values of type file, semaphore,
and continuation may currently be created only by calls <br>
to builtin functions: no Nickle constants of these types
exist.</p>

<p style="margin-top: 1em">As noted in TYPES above, Nickle
has several kinds of &lsquo;&lsquo;structured
value&rsquo;&rsquo;: arrays, functions, pointers, structures
and disjoint unions. All of these have some common
properties. <br>
When created, all of the component values are uninitialized
(unless otherwise specified). Attempts to use an
uninitialized value will result in either a compile-time
error or a <br>
runtime exception.</p>

<p style="margin-top: 1em">Arrays:</p>

<p style="margin-top: 1em">[E] creates a (zero-based) array
with E elements. E must be non-negative.</p>

<p style="margin-top: 1em">[E]{V,V,...,V} <br>
Creates an array with E elements, initialized to the Vs. If
there are too few initializers, remaining elements will
remain uninitialized.</p>

<p style="margin-top: 1em">[E]{V,V,...,V...} <br>
The second ellipsis (three dots) is syntax, not metasyntax.
Create an array with E elements. The first elements in the
array will be initialized according to the Vs, <br>
with any remaining elements receiving the same value as the
last V. This syntax may be used in the obvious fashion with
any of the array initializers below.</p>

<p style="margin-top: 1em">[*]{V,V,...,V} <br>
Creates an initialized array with exactly as many elements
as initializers. There must be at least one initializer.</p>

<p style="margin-top: 1em">[E,E,...,E] [*,*,...,*] <br>
Creates multidimensional arrays. Integer expressions and
&quot;*&quot; cannot be mixed: an array&rsquo;s dimensions
are entirely either specified or unspecified by the
definition. <br>
These arrays may also be created initialized: see next
paragraph for initializer syntax.</p>

<p style="margin-top: 1em">(T[E]) (T[E,E,...,E])
(T[E]){E,E,...,E}</p>


<p style="margin-top: 1em">(T[E,E,...,E]){{E,...},...,{E,...}}
<br>
Alternate syntax for creating arrays of type T. The
initializers, in curly braces, are optional. The number of
initializers must be less than or equal to the given
num&acirc; <br>
ber of elements in each dimension. For multidimensional
arrays, the extra curly braces per dimension in the
initializer are required; this is unlike C, where they are
<br>
optional.</p>

<p style="margin-top: 1em">(T[*]){E,E,...,E}
(T[*,*,...,*]){{E,...},...,{E,...}} <br>
Creates arrays of type T, with each dimension&rsquo;s size
given by the maximum number of initializers in any subarray
in that dimension.</p>

<p style="margin-top: 1em">Pointers:</p>

<p style="margin-top: 1em">0 The null pointer, in contexts
where a pointer is required.</p>

<p style="margin-top: 1em">&amp;V &amp;A[E,E,...,E]
&amp;S.N <br>
Creates a pointer to the given variable, array element, or
structure member. The type of the pointer will be *T, where
T is the type of the object pointed to.</p>

<p style="margin-top: 1em">*P The value pointed to by
pointer P. This can be viewed or modified as in C.</p>

<p style="margin-top: 1em">Functions:</p>

<p style="margin-top: 1em">(T func(){S;S;...S;}) (T func(T
name,T name,...T name){S;S;...S;}) <br>
Function expression: denotes a function of zero or more
formal parameters with the given types and names, returning
the given result type. The function body is given by <br>
the curly-brace-enclosed statement list. All types are
optional, and default to poly. As noted above, functions are
strictly call-by-value: in particular, arrays and <br>
structures are copied rather than referenced.</p>

<p style="margin-top: 1em">T function name(T name,T
name,...,T name){S;S;...S;} <br>
Defines a function of zero or more arguments. Syntactic
sugar for <br>
T(T,T,...T) name = (T func(T name,T name,...T
name){S;S;...S;});</p>

<p style="margin-top: 1em">T function name(T name, T name
...) <br>
The ellipsis here is syntax, not metasyntax: if the last
formal argument to a function is followed by three dots, the
function may be called with more actuals than for&acirc;
<br>
mals. All &lsquo;&lsquo;extra&rsquo;&rsquo; actuals are
packaged into the array formal of the given name, and
typechecked against the optional type T of the last argument
(default poly).</p>

<p style="margin-top: 1em">Structures:</p>

<p style="margin-top: 1em">(struct { T name; T name; ...T
name; }){name = E; name = E; ...name=E;} <br>
Create a value of a structured type. The named fields are
initialized to the given values, with the remainder
uninitialized. As indicated, initialization is by label <br>
rather than positional as in C.</p>

<p style="margin-top: 1em">Unions:</p>

<p style="margin-top: 1em">(union { T name; T name; ...T
name; }.name) E <br>
Create a value of the given union type, the variant given by
.name, and the value given by E. E must be type-compatible
with name.</p>

<p style="margin-top: 1em">STATEMENTS <br>
The statement syntax very closely resembles that of C. Some
additional syntax has been added to support Nickle&rsquo;s
additional functionality.</p>

<p style="margin-top: 1em">E; Evaluates the expression.</p>

<p style="margin-top: 1em">{S ... S} <br>
Executes the enclosed statements in order.</p>

<p style="margin-top: 1em">if (E) S <br>
Basic conditional.</p>

<p style="margin-top: 1em">if (E) S <br>
Conditional execution.</p>

<p style="margin-top: 1em">else S Else is allowed, with the
usual syntax and semantics. In particular, an else binds to
the most recent applicable if() or twixt().</p>

<p style="margin-top: 1em">while (E) S <br>
C-style while loop.</p>

<p style="margin-top: 1em">do S while (E); <br>
C-style do loop.</p>

<p style="margin-top: 1em">for (opt-E; opt-E; opt-E) S <br>
C-style for loop.</p>

<p style="margin-top: 1em">switch (E) { case E: S-list case
E: S-list ... default: S-list } <br>
C-style case statement. The case expressions are not
required to be constant expressions, but may be arbitrary.
The first case evaluating to the switch argument is <br>
taken, else the default if present, else the switch body is
skipped.</p>

<p style="margin-top: 1em">twixt(opt-E; opt-E) S</p>

<p style="margin-top: 1em">twixt(opt-E; opt-E) S else S
<br>
If first argument expression evaluates to true, the body of
the twixt() and then the second argument expression will be
evaluated. If the first argument expression evalu&acirc;
<br>
ates to false, the else statement will be executed if
present. Otherwise, the entire twixt() statement will be
skipped.</p>

<p style="margin-top: 1em">The twixt() statement guarantees
that all of these events will happen in the specified order
regardless of the manner in which the twixt() is entered
(from outside) or exited, <br>
including exceptions, continuations, and break. (Compare
with Java&rsquo;s &lsquo;&lsquo;finally&rsquo;&rsquo;
clause.)</p>

<p style="margin-top: 1em">try S;</p>

<p style="margin-top: 1em">try S catch name (T name, ...) {
S; ... };</p>

<p style="margin-top: 1em">try S catch name (T name, ...) {
S; ... } ... ; <br>
Execute the first statement S. If an exception is raised
during execution, and the name matches the name in a catch
block, bind the formal parameters in the catch block <br>
to the actual parameters of the exception, and execute the
body of the catch block. There may be multiple catch blocks
per try. Zero catches, while legal, is relatively <br>
useless. After completion of a catch block, execution
continues after the try clause. As with else, a catch binds
to the most recent applicable try-catch block.</p>

<p style="margin-top: 1em">raise name(name, name, ...,
name) <br>
Raise the named exception with zero or more arguments.</p>

<p style="margin-top: 1em">; The null statement</p>

<p style="margin-top: 1em">break; Discontinue execution of
the nearest enclosing for/do/while/switch/twixt statement.
The leave expression will be executed as the twixt statement
is exited.</p>

<p style="margin-top: 1em">continue; <br>
Branch directly to the conditional test of the nearest
enclosing for/do/while statement.</p>

<p style="margin-top: 1em">return E; <br>
Return value E from the nearest enclosing function.</p>

<p style="margin-top: 1em">Namespaces:</p>

<p style="margin-top: 1em">Like Java and C++ Nickle has a
notion of namespace, a collection of names with partially
restricted visibility. In Nickle, namespaces are created
with the namespace command.</p>

<p style="margin-top: 1em">opt-P namespace N { S ... } <br>
Places all names defined in the statements S into a
namespace named N. The optional qualifier P may be the
keyword public, but beware: this merely indicates that the
name <br>
N itself is visible elsewhere in the current scope, and has
nothing to do with the visibility of items inside the
namespace.</p>

<p style="margin-top: 1em">extend namespace N { S ... }
<br>
Reopen the given namespace N, and extend it with the names
defined as public in the given statements S.</p>

<p style="margin-top: 1em">Names defined inside the
namespace are invisible outside the namespace unless they
are qualified with the keyword public. Public names may be
referred to using a path <br>
notation: <br>
namespace::namespace::...::namespace::name <br>
refers to the given name as defined inside the given set of
namespaces. The double-colon syntax is unfortunate, as it is
slightly different in meaning than in C++, but <br>
all the good symbols were taken, and it is believed to be a
feature that the namespace separator is syntactically
different than the structure operator. In Java, for
exam&acirc; <br>
ple, the phrase <br>
name.name.name <br>
is syntactically ambiguous: the middle name may be either a
structure or a namespace.</p>

<p style="margin-top: 1em">import N; <br>
The name N must refer to a namespace: all public names in
this namespace are brought into the current scope (scoping
out conflicting names).</p>

<p style="margin-top: 1em">BUILTINS <br>
Nickle has a collection of standard functions built in. Some
of these are written in C, but many are written in Nickle.
Several collections of functions have associated builtin
<br>
datatypes: their namespaces, together with their types,
should be viewed as ADTs.</p>

<p style="margin-top: 1em">Top-Level Builtins:</p>

<p style="margin-top: 1em">int printf(string fmt, poly
args...) <br>
Calls File::fprintf(stdout, fmt, args ...) and returns its
result.</p>

<p style="margin-top: 1em">string function gets () <br>
Calls File::fgets(stdin) and returns its result.</p>

<p style="margin-top: 1em">string function scanf (string
fmt, *poly args...) <br>
Calls File::vfscanf(stdin, fmt, args) and returns its
result.</p>

<p style="margin-top: 1em">string function vscanf (string
fmt, (*poly)[*] args) <br>
Calls File::vfscanf(stdin, fmt, args) and returns its
result.</p>

<p style="margin-top: 1em">real imprecise(rational value)
<br>
See the discussion of type real above.</p>

<p style="margin-top: 1em">real imprecise(rational value,
int prec) <br>
See the discussion of type real above.</p>

<p style="margin-top: 1em">int string_to_integer(string
s)</p>

<p style="margin-top: 1em">int atoi(string s) <br>
The argument s is a signed digit string, and the result is
the integer it represents. If the string s is syntactically
a hexadecimal, octal, binary, or explicit base-10 <br>
constant, treat it as such.</p>

<p style="margin-top: 1em">int string_to_integer(string s,
int base)</p>

<p style="margin-top: 1em">int atoi(string s, int base)
<br>
Treat s as a string of digits in the given base. A base of 0
acts as with no base argument. Otherwise, base specification
syntax in the string is ignored.</p>

<p style="margin-top: 1em">int putchar(int c) <br>
Place the given character on the standard output using
File::putc(c, stdout), and return its result.</p>

<p style="margin-top: 1em">int sleep(int msecs) <br>
Try to suspend the current thread for at least msecs
milliseconds. Return 1 on early return, and 0 otherwise.</p>

<p style="margin-top: 1em">int exit(int status) <br>
Exit Nickle with the given status code. Do not return
anything.</p>

<p style="margin-top: 1em">int dim(poly[*] a) <br>
Given a one-dimensional array a, dim() returns the number of
elements of a.</p>

<p style="margin-top: 1em">int[] dims(poly[] a) <br>
Given an arbitrary array a, dims() returns an array of
integers giving the size of each dimension of a. Thus,
dim(dims(a)) is the number of dimensions of a.</p>

<p style="margin-top: 1em">*poly reference(poly v) <br>
Given an arbitrary value v, &lsquo;&lsquo;box&rsquo;&rsquo;
that value into storage and return a pointer to the box.</p>

<p style="margin-top: 1em">rational string_to_real(string
s)</p>

<p style="margin-top: 1em">rational atof(string s) <br>
Convert the real constant string s into its associated real
number.</p>

<p style="margin-top: 1em">number abs(real v) <br>
Return the absolute value of v. The result type chosen will
match the given context.</p>

<p style="margin-top: 1em">int floor(real v) <br>
Return the largest integer less than or equal to v. This
will fail if v is a real and the precision is too low.</p>

<p style="margin-top: 1em">int ceil(real v) <br>
Return the smallest integer greater than or equal to v. This
will fail if v is a real and the precision is too low.</p>

<p style="margin-top: 1em">int exponent(real v) <br>
Return the exponent of the imprecise real v.</p>

<p style="margin-top: 1em">rational mantissa(real v) <br>
Return the mantissa of the imprecise real v, as a rational m
with 0 &lt;= m &lt;= 0.5 .</p>

<p style="margin-top: 1em">int numerator(rational v) <br>
Return the numerator of the rational number v: i.e., if v =
n/d in reduced form, return n.</p>

<p style="margin-top: 1em">int denominator(rational v) <br>
Return the denominator of the rational number v: i.e., if v
= n/d in reduced form, return d.</p>

<p style="margin-top: 1em">int precision(real v) <br>
Return the number of bits of precision of the mantissa of
the imprecise real number v.</p>

<p style="margin-top: 1em">int sign(real v) <br>
Return -1 or 1 as v is negative or nonnegative.</p>

<p style="margin-top: 1em">int bit_width(int v) <br>
Return the number of bits required to represent abs(v)
internally.</p>

<p style="margin-top: 1em">int is_int(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int is_rational(poly v) <br>
Numeric type predicates are inclusive: e.g., is_rational(1)
returns 1.</p>

<p style="margin-top: 1em">int is_number(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int is_string(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int is_file(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int is_thread(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int is_semaphore(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int is_continuation(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int is_array(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int is_ref(poly v) <br>
Type predicate: checks for pointer type. This is arguably a
misfeature, and may change.</p>

<p style="margin-top: 1em">int is_struct(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int is_func(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int is_void(poly v) <br>
Type predicate.</p>

<p style="margin-top: 1em">int gcd(int p, int q) <br>
Return the GCD of p and q. The result is always
positive.</p>

<p style="margin-top: 1em">int xor(int a, int b) <br>
Return a ^ b . This is mostly a holdover from before Nickle
had an xor operator.</p>

<p style="margin-top: 1em">poly setjmp(continuation *c,
poly retval) <br>
The setjmp() and longjmp() primitives together with the
continuation type form an ADT useful for nearly arbitrary
transfers of flow-of-control. The setjmp() and longjmp()
<br>
builtins are like those of C, except that the restriction
that longjmp() always jump upwards is removed(!): a
continuation saved via setjmp() never becomes invalid during
<br>
the program lifetime.</p>

<p style="margin-top: 1em">The setjmp() builtin saves the
current location and context into its continuation pointer
argument, and then returns its second argument.</p>

<p style="margin-top: 1em">void longjmp(continuation c,
poly retval) <br>
The longjmp() builtin never returns to the call site, but
instead returns from the setjmp() that created the
continuation, with return value equal to the second argument
<br>
of longjmp().</p>

<p style="margin-top: 1em">string prompt <br>
The prompt printed during interactive use when at top-level.
Default &quot;&gt; &quot;. when waiting for the rest of a
statement or expression, and when debugging, respectively.
<br>
Default values are &quot;&gt; &quot;, &quot;+ &quot;, and
&quot;- &quot;.</p>

<p style="margin-top: 1em">string prompt2 <br>
The prompt printed during interactive use when waiting for
the rest of a statement or expression. Default &quot;+
&quot;.</p>

<p style="margin-top: 1em">string prompt3 <br>
The prompt printed during interactive use when debugging.
Default &quot;- &quot;.</p>

<p style="margin-top: 1em">string format <br>
The printf() format for printing top-level values. Default
&quot;%g&quot;.</p>

<p style="margin-top: 1em">string version <br>
The version number of the Nickle implementation currently
being executed.</p>

<p style="margin-top: 1em">string build <br>
The build date of the Nickle implementation currently being
executed, in the form &quot;yyyy/mm/dd&quot;, or
&quot;?&quot; if the build date is unknown for some
reason.</p>

<p style="margin-top: 1em">file stdin <br>
Bound to the standard input stream.</p>

<p style="margin-top: 1em">file stdout <br>
Bound to the standard output stream.</p>

<p style="margin-top: 1em">file stderr <br>
Bound to the standard error stream.</p>

<p style="margin-top: 1em">Exceptions:</p>

<p style="margin-top: 1em">A few standard exceptions are
predeclared and used internally by Nickle.</p>

<p style="margin-top: 1em">exception
uninitialized_value(string msg) <br>
Attempt to use an uninitialized value.</p>

<p style="margin-top: 1em">exception
invalid_argument(string msg, int arg, poly val) <br>
The arg-th argument to a builtin function had invalid value
val.</p>

<p style="margin-top: 1em">exception readonly_box(string
msg, poly val) <br>
Attempt to change the value of a read-only quantity to
val.</p>

<p style="margin-top: 1em">exception
invalid_array_bounds(string msg, poly a, poly i) <br>
Attempt to access array a at index i is out of bounds.</p>

<p style="margin-top: 1em">exception divide_by_zero(string
msg, real num, real den) <br>
Attempt to divide num by den with den == 0.</p>

<p style="margin-top: 1em">exception
invalid_struct_member(string msg, poly struct, string name)
<br>
Attempt to refer to member name of the object struct, which
does not exist.</p>

<p style="margin-top: 1em">exception
invalid_binop_values(string msg, poly arg1, poly arg2) <br>
Attempt to evaluate a binary operator with args arg1 and
arg2, where at least one of these values is invalid.</p>

<p style="margin-top: 1em">exception
invalid_unop_values(string msg, poly arg) <br>
Attempt to evaluate a unary operator with invalid argument
arg.</p>

<p style="margin-top: 1em">Builtin Namespaces:</p>

<p style="margin-top: 1em">Math The math functions
available in the Math namespace are implemented in a fashion
intended to be compatible with the C library. Please consult
the appropriate manuals for <br>
further details.</p>

<p style="margin-top: 1em">real pi <br>
Imprecise constant giving the value of the
circumference/diameter ratio of the circle to the default
precision of 256 bits.</p>

<p style="margin-top: 1em">protected real e <br>
Imprecise constant giving the value of the base of natural
logarithms to the default precision of 256 bits. Since e is
protected, it must be referenced via Math::e, in <br>
order to avoid problems with using the fifth letter of the
alphabet at top level.</p>

<p style="margin-top: 1em">real function sqrt(real v) <br>
Returns the square root of v.</p>

<p style="margin-top: 1em">real function cbrt(real v) <br>
Returns the cube root of v.</p>

<p style="margin-top: 1em">real function exp(real v) <br>
Returns e**v.</p>

<p style="margin-top: 1em">real function log(real a) <br>
Returns v such that e**v == a. Throws an invalid_argument
exception if a is non-positive.</p>

<p style="margin-top: 1em">real function log10(real a) <br>
Returns v such that 10**v == a. Throws an invalid_argument
exception if a is non-positive.</p>

<p style="margin-top: 1em">real function log2(real a) <br>
Returns v such that 2**v == a. Throws an invalid_argument
exception if a is non-positive.</p>

<p style="margin-top: 1em">real function pi_value(int prec)
<br>
Returns the ratio of the circumference of a circle to the
diameter, with prec bits of precision.</p>

<p style="margin-top: 1em">real function sin(real a) <br>
Returns the ratio of the opposite side to the hypotenuse of
angle a of a right triangle, given in radians.</p>

<p style="margin-top: 1em">real function cos(real a) <br>
Returns the ratio of the adjacent side to the hypotenuse of
angle a of a right triangle, given in radians.</p>

<p style="margin-top: 1em">void function sin_cos(real a,
*real sinp, *real cosp) <br>
Returns with sin(a) and cos(a) stored in the locations
pointed to by sinp and cosp respectively. If either pointer
is 0, do not store into that location. May be slightly <br>
faster than calling both trig functions independently.</p>

<p style="margin-top: 1em">real function tan(real a) <br>
Returns the ratio of the opposite side to the adjacent side
of angle a of a right triangle, given in radians. Note that
tan(pi/2) is not currently an error: it will <br>
return a very large number dependent on the precision of its
input.</p>

<p style="margin-top: 1em">real function asin(real v) <br>
Returns a such that sin(a) == v.</p>

<p style="margin-top: 1em">real function acos(real v) <br>
Returns a such that cos(a) == v.</p>

<p style="margin-top: 1em">real function atan(real v) <br>
Returns a such that tan(a) == v.</p>

<p style="margin-top: 1em">real function atan2(real x, y)
<br>
Returns a such that tan(a) == x / y. Deals correctly with y
== 0.</p>

<p style="margin-top: 1em">real function pow(real a, real
b) <br>
The implementation of the ** operator.</p>

<p style="margin-top: 1em">File The namespace File provides
operations on file values.</p>

<p style="margin-top: 1em">int function fprintf(file f,
string s, ....) <br>
Print formatted values to a file, as with UNIX stdio library
fprintf(). fprintf() and printf() accept a reasonable
sub-set of the stdio library version: %c, %d, %e, %x, <br>
%o, %f, %s, %g work as expected, as does %v to smart-print a
value. Format modifiers may be placed between the
percent-sign and the format letter to modify formatting.
<br>
There are a lot of known bugs with input and output
formatting.</p>

<p style="margin-top: 1em">Format Letters:</p>

<p style="margin-top: 1em">%c Requires a small integer
argument (0..255), and formats as an ASCII character.</p>

<p style="margin-top: 1em">%d Requires an integer argument,
and formats as an integer.</p>

<p style="margin-top: 1em">%x Requires an integer argument,
and formats as a base-16 (hexadecimal) integer.</p>

<p style="margin-top: 1em">%o Requires an integer argument,
and formats as a base-8 (octal) integer.</p>

<p style="margin-top: 1em">%e Requires a number argument,
and formats in scientific notation.</p>

<p style="margin-top: 1em">%f Requires a number argument,
and formats in fixed-point notation.</p>

<p style="margin-top: 1em">%s Requires a string argument,
and emits the string literally.</p>

<p style="margin-top: 1em">%g Requires a number, and tries
to pick a precise and readable representation to format
it.</p>

<p style="margin-top: 1em">Format Modifiers:</p>

<p style="margin-top: 1em">digits All format characters
will take an integer format modifier indicating the number
of blanks in the format field for the data to be formatted.
The value will be <br>
printed right-justified in this space.</p>

<p style="margin-top: 1em">digits.digits <br>
The real formats will take a pair of integer format
modifiers indicating the field width and precision (number
of chars after decimal point) of the formatted value. <br>
Either integer may be omitted.</p>

<p style="margin-top: 1em">- A precision value indicating
infinite precision.</p>

<p style="margin-top: 1em">* The next argument to fprintf()
is an integer indicating the field width or precision of the
formatted value.</p>

<p style="margin-top: 1em">file function string_write()
<br>
Return a file which collects written values into a
string.</p>

<p style="margin-top: 1em">int function close(file f) <br>
Close file f and return an indication of success.</p>

<p style="margin-top: 1em">int function flush(file f) <br>
Flush the buffers of file f and return an indication of
success.</p>

<p style="margin-top: 1em">int function getc(file f) <br>
Get the next character from file f and return it.</p>

<p style="margin-top: 1em">int function end(file f) <br>
Returns true if file f is at EOF, else false.</p>

<p style="margin-top: 1em">int function error(file f) <br>
Returns true if an error is pending on file f, else
false.</p>

<p style="margin-top: 1em">int function clear_error(file f)
<br>
Clears pending errors on file f, and returns an indication
of success.</p>

<p style="margin-top: 1em">file function string_read(string
s) <br>
Returns a virtual file whose contents are the string s.</p>

<p style="margin-top: 1em">string function
string_string(file f) <br>
Return the string previously written into the file f, which
should have been created by string_read() or string_write().
Behavior on other files is currently undefined.</p>

<p style="margin-top: 1em">file function open(string path,
string mode) <br>
Open the file at the given path with the given mode string,
ala UNIX stdio fopen(). Permissible modes are as in stdio:
&quot;r&quot;, &quot;w&quot;, &quot;x&quot;, &quot;r+&quot;,
&quot;w+&quot; and &quot;x+&quot;.</p>

<p style="margin-top: 1em">integer function fputc(integer
c, file f) <br>
Output the character c to the output file f, and return an
indication of success.</p>

<p style="margin-top: 1em">integer function ungetc(integer
c, file f) <br>
Push the character c back onto the input file f, and return
an indication of success.</p>

<p style="margin-top: 1em">integer function setbuf(file f,
integer n) <br>
Set the size of the buffer associated with file f to n, and
return n.</p>

<p style="margin-top: 1em">string function fgets (file f)
<br>
Get a line of input from file f, and return the resulting
string.</p>

<p style="margin-top: 1em">file function pipe(string path,
string[*] argv, string mode) <br>
Start up the program at the given path, returning a file
which is one end of a &quot;pipe&quot; to the given process.
The mode argument can be &quot;r&quot; to read from the pipe
or &quot;w&quot; to <br>
write to the pipe. The argv argument is an array of strings
giving the arguments to be passed to the program, with
argv[0] conventionally being the program name.</p>

<p style="margin-top: 1em">int function print (file f, poly
v, string fmt, int base, int width, int prec, string fill)
<br>
Print value v to file f in format fmt with the given base,
width, prec, and fill. Used internally by
File::fprintf();</p>

<p style="margin-top: 1em">int function fscanf(file f,
string fmt, *poly args...) <br>
Fill the locations pointed to by the array args with values
taken from file f according to string fmt. The format
specifiers are much as in UNIX stdio scanf(): the
&quot;%d&quot;, <br>
&quot;%e&quot;, &quot;%f&quot;, &quot;%c&quot; and
&quot;%s&quot; specifiers are supported with the expected
modifiers.</p>

<p style="margin-top: 1em">int function vfscanf (file f,
string fmt, (*poly)[*] args) <br>
Given the file f, the format fmt, and the array of arguments
args, fscanf() appropriately.</p>

<p style="margin-top: 1em">Thread The namespace Thread
supports various operations useful for programming with
threads, which provide concurrent flow of control in the
shared address space. There is one <br>
piece of special syntax associated with threads.</p>

<p style="margin-top: 1em">fork(E) <br>
Accepts an arbitrary expression, and evaluates it in a new
child thread. The parent thread receives the thread as the
value of the fork expression.</p>

<p style="margin-top: 1em">The remainder of the Thread
functions are fairly standard.</p>

<p style="margin-top: 1em">int function kill(thread
list...) <br>
Kills every running thread in the array list. With no
arguments, kills the currently running thread. Returns the
number of threads killed.</p>

<p style="margin-top: 1em">int function trace(poly list...)
<br>
Shows the state of every running thread in the array list.
With no arguments, traces the default continuation. Returns
the number of threads traced.</p>

<p style="margin-top: 1em">int function cont() <br>
Continues execution of any interrupted threads, and returns
the number of continued threads.</p>

<p style="margin-top: 1em">thread function current() <br>
Return the current thread.</p>

<p style="margin-top: 1em">int function list() <br>
Reports the currently running thread to stdout.</p>

<p style="margin-top: 1em">int function get_priority(thread
t) <br>
Reports the priority of the given thread.</p>

<p style="margin-top: 1em">thread function id_to_thread(int
id) <br>
Returns the thread with the given id, if found, and 0
otherwise.</p>

<p style="margin-top: 1em">poly function join(thread t)
<br>
Waits for thread t to terminate, and returns whatever it
returns.</p>

<p style="margin-top: 1em">int function set_priority(thread
t, int i) <br>
Attempts to set the priority of thread t to level i, and
returns the new priority. Larger priorities mean more
runtime: a task with higher priority will always run <br>
instead of a lower priority task. Threads of equal highest
priority will be pre-emptively multitasked.</p>

<p style="margin-top: 1em">Semaphore <br>
The Semaphore namespace encapsulates operations on the
semaphore built-in ADT. A semaphore is used for thread
synchronization. Each signal() operation on the semaphore
<br>
awakens the least-recent thread to wait() on that semaphore.
The &lsquo;&lsquo;count&rsquo;&rsquo; of waiting processes
may be set at semaphore creation time.</p>

<p style="margin-top: 1em">semaphore function new(int c)
<br>
Create a new semaphore with an initial count c of waiting
processes. If c is positive, it means that c threads may
wait on the semaphore before one blocks. If c is nega&acirc;
<br>
tive, it sets a count of threads which must be waiting on
the semaphore before further waits will not block.</p>

<p style="margin-top: 1em">semaphore function new() <br>
Call semaphore(0) and return its result.</p>

<p style="margin-top: 1em">int signal(semaphore s) <br>
Increment semaphore s. If s is non-positive, and some thread
is blocked on s, release the least-recently-blocked thread.
Return 1 on success.</p>

<p style="margin-top: 1em">int wait(semaphore s) <br>
Decrement semaphore s. If s is negative, block until
released. Return 1 on success.</p>

<p style="margin-top: 1em">int test(semaphore s) <br>
Test whether wait() on semaphore s would cause the current
thread to block. If so, return 0. Otherwise, attempt to
decrement s, and return 1 if successful.</p>

<p style="margin-top: 1em">String The String namespace
contains a few basic operations on the string ADT.</p>

<p style="margin-top: 1em">int function length(string s)
<br>
Returns the number of characters in s.</p>

<p style="margin-top: 1em">string function new(int c) <br>
Returns as a string the single character c.</p>

<p style="margin-top: 1em">string function new(int cv[*])
<br>
Returns a string comprised of the characters of cv.</p>

<p style="margin-top: 1em">int function index(string t,
string p) <br>
Returns the integer index of the pattern string p in the
target string t, or -1 if p is not a substring of t.</p>

<p style="margin-top: 1em">string function substr(string s,
int i, int l) <br>
Returns the substring of string s starting with the
character at offset i (zero-based) and continuing for a
total of l characters. If l is negative, the substring will
<br>
consist of characters preceding rather than succeeding
i.</p>

<p style="margin-top: 1em">PRNG The PRNG namespace provides
pseudo-random number generation and manipulation. The core
generator is the RC4 stream cipher generator, properly
bootstrapped. This provide <br>
a stream of cryptographically-secure pseudo-random bits at
reasonable amortized cost. (But beware, initialization is
somewhat expensive.)</p>

<p style="margin-top: 1em">void function srandom(int s)
<br>
Initialize the generator, using the (arbitrarily-large)
integer as a seed.</p>

<p style="margin-top: 1em">void function dev_srandom(int
nbits) <br>
Initialize the generator, using nbits bits of entropy
obtained from some reasonable entropy source. On UNIX
systems, this source is /dev/urandom. Asking for more
initial <br>
entropy than the system has may lead either to bootstrapping
(as on UNIX) or to hanging, so use cautiously.</p>

<p style="margin-top: 1em">int function randbits(int n)
<br>
Returns an n-bit pseudo-random number, in the range
0..(2**n)-1. Useful for things like RSA.</p>

<p style="margin-top: 1em">int function randint(int n) <br>
Returns a pseudo-random number in the range 0..n-1.</p>

<p style="margin-top: 1em">void function shuffle(*(poly[*])
a) <br>
Performs an efficient in-place true shuffle (c.f. Knuth) of
the array a.</p>

<p style="margin-top: 1em">Command <br>
The Command namespace is used by the top-level commands as
described below. It is also occasionally useful in its own
right.</p>

<p style="margin-top: 1em">string library_path <br>
Contains the current library search path, a colon-separated
list of directories to be searched for library files.</p>

<p style="margin-top: 1em">int function undefine(string
name) <br>
Implements the top-level undefine command. Remove the name
denoted by string name from the namespace. This removes all
visible definitions of the name.</p>

<p style="margin-top: 1em">int function undefine(string[*]
names) <br>
Remove each of the names in the array names from the
namespace. This removes all visible definitions of each
name.</p>

<p style="margin-top: 1em">int function delete(string name)
<br>
Attempt to remove the command with the given string name
from the top-level command list, and return 1 if
successful.</p>

<p style="margin-top: 1em">int function lex_file(string
path) <br>
Attempt to make the file at the given path the current
source of Nickle code, and return 1 if successful. Note that
this effectively &lsquo;&lsquo;includes&rsquo;&rsquo; the
file by pushing it <br>
onto a stack of files to be processed.</p>

<p style="margin-top: 1em">int function lex_library(string
filename) <br>
Like lex_file(), but searches the directories given by the
library_path variable for the first file with the given
filename.</p>

<p style="margin-top: 1em">int function lex_string(string
code) <br>
Attempt to make the Nickle code contained in the string code
be the next input.</p>

<p style="margin-top: 1em">int function edit(string[*]
names) <br>
Implements the top-level edit command. The names in the
array are a path of namespace names leading to the symbol
name, which is last.</p>

<p style="margin-top: 1em">int function new(string name,
poly func) <br>
Binds function func to the top-level command string name:
i.e., makes it part of the top-level command vocabulary.</p>

<p style="margin-top: 1em">int function new_names(string
name, poly func) <br>
Binds function func to the top-level command string name:
i.e., makes it part of the top-level command vocabulary.
Unlike new(), the string names given to func at the top <br>
level are passed unevaluated as an array of string names or
as a single string name.</p>

<p style="margin-top: 1em">int function pretty_print(file
f, string[*] names) <br>
Implements the top-level print command. Each of the passed
name strings is looked up and the corresponding code printed
to file f.</p>

<p style="margin-top: 1em">int function display(string fmt,
poly val) <br>
Uses printf() to display the value val in format fmt.</p>

<p style="margin-top: 1em">History <br>
Nickle maintains a top-level value history, useful as an
adjunct to command-line editing when calculating. The
History namespace contains functions to access this
his&acirc; <br>
tory.</p>

<p style="margin-top: 1em">int function show(string fmt)
<br>
Implements the history top-level command with no arguments.
Show the most recent history values with format fmt.</p>

<p style="margin-top: 1em">int function show(string fmt,
int count) <br>
Implements the history top-level command with one argument.
Show the last count history values with format fmt.</p>

<p style="margin-top: 1em">int function show(string fmt,
int first, int last) <br>
Implements the history top-level command with two
arguments.</p>

<p style="margin-top: 1em">poly function insert(poly val)
<br>
Insert val in the history list, and return it.</p>

<p style="margin-top: 1em">Environ <br>
Many operating systems have some notion of
&lsquo;&lsquo;environment variables.&rsquo;&rsquo; The
Environ namespace contains functions to manipulate
these.</p>

<p style="margin-top: 1em">int function check(string name)
<br>
Returns 1 if the variable with the given name is in the
environment, and 0 otherwise.</p>

<p style="margin-top: 1em">string function get(string name)
<br>
Attempts to retrieve and return the value of the environment
variable with the given name. Throws an invalid_argument
exception if the variable is not available.</p>

<p style="margin-top: 1em">int function unset(string name)
<br>
Attempts to unset the environment variable with the given
name, and returns an indication of success.</p>

<p style="margin-top: 1em">string function set(string name,
string value) <br>
Attempts to set the environment variable with the given name
to the given value, and returns an indication of
success.</p>

<p style="margin-top: 1em">COMMANDS <br>
Nickle has a set of commands which may be given at the top
level.</p>

<p style="margin-top: 1em">quit Exit Nickle.</p>

<p style="margin-top: 1em">quit E Exit Nickle with integer
status code E.</p>

<p style="margin-top: 1em">undefine NAME {,NAME} <br>
Remove these names from the system.</p>

<p style="margin-top: 1em">load E Load a file given by the
string name E.</p>

<p style="margin-top: 1em">library E <br>
Load a library given by the string name E. See the
discussion of the NICKLEPATH environment variable in
ENVIRONMENT below, and the discussion of
Command::library_path <br>
above.</p>

<p style="margin-top: 1em">E # E Print expr1 in base expr2
.</p>

<p style="margin-top: 1em">print NAME <br>
Display a formatted version of the object denoted by NAME.
Comments and original formating are lost. If NAME is a
variable, print the type as well as the value.</p>

<p style="margin-top: 1em">edit NAME <br>
Invoke $EDITOR on the named object, and re-incorporate the
results of the edit. This is most useful with functions.</p>

<p style="margin-top: 1em">history <br>
Display the 10 most recently printed values. They can be
accessed with $n where n is the number displayed to the
right of the value in this list.</p>

<p style="margin-top: 1em">history E <br>
Display the E most recent history values.</p>

<p style="margin-top: 1em">history E,E <br>
Display history values from the first integer E through the
second.</p>

<p style="margin-top: 1em">DEBUGGER <br>
When an unhandled exception reaches top level during
execution, the user receives a dash prompt, indicating that
debug mode is active. In this mode, the command-line
environment <br>
is that in which the unhandled exception was raised. In
addition a number of debugging commands are available to the
user:</p>

<p style="margin-top: 1em">trace Get a stack backtrace
showing the current state, as with the GDB where
command.</p>

<p style="margin-top: 1em">up Move up the stack (i.e.,
toward the top-level expression) ala GDB.</p>

<p style="margin-top: 1em">down Move down the stack (i.e.,
toward the current context) ala GDB.</p>

<p style="margin-top: 1em">done Leave debugging mode,
abandoning execution.</p>

<p style="margin-top: 1em">In addition, the Debug namespace
is scoped in in debugging mode. This is primarily of use in
debugging Nickle itself.</p>

<p style="margin-top: 1em">collect() <br>
Run the garbage collector.</p>

<p style="margin-top: 1em">dump(function) <br>
Print the compiled byte code for function.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
EDITOR The editor used by the edit command, described in
COMMANDS above.</p>

<p style="margin-top: 1em">NICKLERC <br>
The location of the user&rsquo;s .nicklerc file, which will
be loaded at the beginning of nickle execution if
possible.</p>

<p style="margin-top: 1em">HOME Used to find the
user&rsquo;s .nicklerc if NICKLERC is not set.</p>

<p style="margin-top: 1em">NICKLEPATH <br>
A colon-separated path whose elements are directories
containing Nickle code. The library command and the -l flag,
described above, search this path for a filename
match&acirc; <br>
ing the given file. The default library path in the absence
of this variable is /usr/share/nickle.</p>

<p style="margin-top: 1em">NICKLESTART <br>
The filename of the file that should be loaded as a
bootstrap on Nickle startup. The default in the absence of
this variable is to load /usr/share/nickle/builtin.5c.</p>

<p style="margin-top: 1em">EXAMPLES <br>
An example (taken from the bc manual:</p>

<p style="margin-top: 1em">real function exponent(real x) {
<br>
real a = 1; <br>
int b = 1; <br>
real s = 1; <br>
int i = 1; <br>
while (1) { <br>
a = a * x; <br>
b = b * i; <br>
real c = a / b; <br>
if (abs(c) &lt; 1e-6) <br>
return s; <br>
s = s + c; <br>
i++; <br>
} <br>
}</p>

<p style="margin-top: 1em">defines a function to compute an
approximate value of the exponential function e ** x and</p>

<p style="margin-top: 1em">for (i = 1; i &lt; 10; i++) <br>
printf (&quot;%g0, exponent (i));</p>

<p style="margin-top: 1em">prints approximate values of the
exponential function of the first ten integers.</p>

<p style="margin-top: 1em">VERSION <br>
This document describes version 1.99.2 of nickle, as well as
some newer features. It was distributed with version 2.77 of
nickle.</p>

<p style="margin-top: 1em">BUGS <br>
See the discussion of the type of the exponentiation
operator ** above.</p>

<p style="margin-top: 1em">Due to a difficult-to-remove
grammar ambiguity, it is not possible to use a bare
assignment expression in an array initializer: it is
confused with a structure initializer. For <br>
example: <br>
&gt; int x = 0; <br>
&gt; (int[*]){x = 1} <br>
-&gt; (int[*]) { x = 1 } <br>
Non array initializer <br>
The workaround is to parenthesize the assignment expression:
<br>
&gt; (int[*]){(x = 1)} <br>
[1]{1} <br>
Because this is so rare, so hard to fix, and so easy to work
around, this bug is unlikely to be fixed anytime soon.</p>

<p style="margin-top: 1em">There are a lot of known bugs
with input and output formatting. The obvious stuff works,
other stuff does not.</p>

<p style="margin-top: 1em">The semantics of division are
unfortunately different from those of C. This is arguably
because C is broken in this area: we cannot currently see
any obvious fix. C allows <br>
automatic implicit coercion of floating to integral types,
but we consider this a misfeature.</p>

<p style="margin-top: 1em">The implementation has not been
thoroughly tested.</p>

<p style="margin-top: 1em">AUTHOR <br>
Nickle is the work of Keith Packard
&lt;keithp@keithp.com&gt; and Bart Massey
&lt;bart_massey@iname.com&gt;.</p>

<p style="margin-top: 1em">Nickle is <br>
Copyright 1988-2006 Keith Packard and Bart Massey. All
Rights Reserved.</p>

<p style="margin-top: 1em">Permission is hereby granted,
free of charge, to any person obtaining a copy of this
software and associated documentation files (the
&quot;Software&quot;), to deal in the Software without <br>
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to <br>
whom the Software is furnished to do so, subject to the
following conditions:</p>

<p style="margin-top: 1em">The above copyright notice and
this permission notice shall be included in all copies or
substantial portions of the Software.</p>

<p style="margin-top: 1em">THE SOFTWARE IS PROVIDED
&quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PUR&acirc; <br>
POSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, <br>
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.</p>

<p style="margin-top: 1em">Except as contained in this
notice, the names of the authors or their institutions shall
not be used in advertising or otherwise to promote the sale,
use or other dealings in <br>
this Software without prior written authorization from the
authors.</p>

<p style="margin-top: 1em">2017/02/11 NICKLE(1)</p>
<hr>
</body>
</html>
