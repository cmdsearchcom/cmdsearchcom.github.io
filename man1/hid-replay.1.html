<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:16:47 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>HID-REPLAY(1) HID-REPLAY(1)</p>

<p style="margin-top: 1em">NAME <br>
hid-replay - HID Input device replay through uhid.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
hid-replay [OPTIONS] [FILENAME]</p>

<p style="margin-top: 1em">OPTIONS <br>
-i, --interactive <br>
interactive mode: This is the default mode. The device is
created and the program wait for the user to hit enter. Once
the enter key is pressed the whole events sequence in <br>
FILENAME is played in real time. Once it is done, the
program loops back to the wait of the user keypress on the
enter key.</p>

<p style="margin-top: 1em">Hit *Ctrl-C* to stop the
replay.</p>

<p style="margin-top: 1em">-1, --one <br>
one shot mode: the device is created and then the events are
replayed once in real time. The process exists at the end of
the replay.</p>

<p style="margin-top: 1em">-s, --sleep X: sleep X seconds
once the device is created before next step. Useful in
conjunction with --one.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
hid-replay requires the module uhid to be loaded (present in
kernels 3.6+).</p>

<p style="margin-top: 1em">If this kernel module is loaded,
hid-replay allows the user to create virtual HID devices as
if they were physically plugged to the system. Then, the
user has the possibility to <br>
replay the previously recorded HID events that are therefore
handled by the right HID kernel module.</p>

<p style="margin-top: 1em">hid-replay needs to be able to
write to /dev/uhid; in most cases this means it must be run
as root.</p>

<p style="margin-top: 1em">hid-recorder and hid-replay are
used to debug kernel issues with HID input devices.</p>

<p style="margin-top: 1em">INPUT FILE <br>
The input file of hid-replay has the following syntax:</p>

<p style="margin-top: 1em">&Acirc;&middot; # comments</p>

<p style="margin-top: 1em">&Acirc;&middot; D: tell which
device we are currently working with</p>

<p style="margin-top: 1em">&Acirc;&middot; R: size
dump_of_report_descriptor_in_hexadecimal</p>

<p style="margin-top: 1em">&Acirc;&middot; N:
common_name_of_the_device</p>

<p style="margin-top: 1em">&Acirc;&middot; P:
physical_path</p>

<p style="margin-top: 1em">&Acirc;&middot; I: bus vendor_id
product_id</p>

<p style="margin-top: 1em">&Acirc;&middot; E: timestamp
size report_in_hexadecimal</p>

<p style="margin-top: 1em">Any other starting characters
are just ignored.</p>

<p style="margin-top: 1em">CAUTION <br>
hid-replay is a very low level events injector. To have the
virtual device handled by the right HID kernel module,
hid-replay fakes that the device is on the original bus
(USB, <br>
I2C or BT). Thus, if the kernel module in use has to write
back to the device the kernel may oops if the module is
trying to direclty talk to the physical layer.</p>

<p style="margin-top: 1em">Be sure to use this program with
friendly HID modules that rely only on the generic hid
callbacks.</p>

<p style="margin-top: 1em">EXIT CODE <br>
hid-replay returns EXIT_FAILURE on error.</p>

<p style="margin-top: 1em">SEE ALSO <br>
hid-recorder(1)</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright 2012, Benjamin Tissoires. <br>
Copyright 2012, Red Hat, Inc.</p>

<p style="margin-top: 1em">AUTHOR <br>
Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;</p>

<p style="margin-top: 1em">02/10/2017 HID-REPLAY(1)</p>
<hr>
</body>
</html>
