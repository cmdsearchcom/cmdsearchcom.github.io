<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:35:43 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>rlwrap(1) General Commands Manual rlwrap(1)</p>

<p style="margin-top: 1em">NAME <br>
rlwrap - readline wrapper</p>

<p style="margin-top: 1em">SYNOPSIS <br>
rlwrap [rlwrap-options] command ...</p>

<p style="margin-top: 1em">DESCRIPTION <br>
rlwrap runs the specified command, intercepting user input
in order to provide readline&rsquo;s line editing,
persistent history and completion.</p>

<p style="margin-top: 1em">rlwrap tries to be completely
transparent - you (or your shell) shouldn&rsquo;t notice any
difference between command and rlwrap command - except the
added readline functionality, of <br>
course. This should even hold true when you are
re-directing, piping and sending signals from and to
command, or when command manipulates its terminal
settings.</p>

<p style="margin-top: 1em">There are many options to add
(programmable) completion, handle multi-line input, colour
and re-write prompts. If you don&rsquo;t need them (and you
probably don&rsquo;t), you can skip the <br>
rest of this manpage.</p>

<p style="margin-top: 1em">OPTIONS <br>
-a, --always-readline [password_prompt] <br>
Always remain in &quot;readline mode&quot;, regardless of
command&rsquo;s terminal settings. Use this option if you
want to use rlwrap with commands that already use readline.
NB: With <br>
this option, rlwrap will echo (and save) passwords, unless
you give command&rsquo;s password prompt as an argument. The
argument is optional; if given, it has to directly
fol&acirc; <br>
low the option without an intervening space.</p>

<p style="margin-top: 1em">On a linux machine you can use
the -N (--no-children) option to prevent the wrapping of
pagers and editors called from command; this should make
them much more usable</p>

<p style="margin-top: 1em">Many commands that need
--always-readline may also need -t dumb to prevent terminal
control sequences from confusing rlwrap (although this will
annoy the above-mentioned <br>
pagers and editors)</p>

<p style="margin-top: 1em">-A, --ansi-colour-aware <br>
Prompts that use colour will confuse rlwrap, especially at
the end of long input lines. This option will make rlwrap
better behaved in such cases. If the prompt contains <br>
anything fancier than ANSI colour codes, this option may
actually make things worse.</p>

<p style="margin-top: 1em">-b, --break-chars
list_of_characters <br>
Consider the specified characters word-breaking (whitespace
is always word-breaking). This determines what is considered
a &quot;word&quot;, both when completing and when building a
<br>
completion word list from files specified by -f options
following (not preceding!) it. Default list
(){}[],&rsquo;+-=&amp;^%$#@&quot;&quot;;|&nbsp;Unless -c is
specified, / and . (period) are <br>
included in the default list.</p>

<p style="margin-top: 1em">-c, --complete-filenames <br>
Complete filenames (filename completion is always
case-sensitive, even with the -i option) When doing this,
rlwrap keeps track of commands working directory.</p>

<p style="margin-top: 1em">-C, --command-name
command_name|N <br>
Use command_name instead of command to determine the names
of history and completion files, and to initialise readline
(as specified in ~/.inputrc). A numeric argument N &gt; <br>
0 means: use the Nth argument counting backwards from the
end of the argument list</p>

<p style="margin-top: 1em">-D, --history-no-dupes n <br>
How agressively to weed out duplicate entries from the input
history. If n = 0, all inputs are kept in the history list,
if n = 1 (this is the default) consecutive dupli&acirc; <br>
cates are dropped from the list, while n = 2 will make
rlwrap drop all previous occurrences of the current input
from the list.</p>

<p style="margin-top: 1em">-e,
--extra-char-after-completion char <br>
By default, rlwrap appends a space after any inserted
completion text. Use this option to change this to
&rsquo;&rsquo; (don&rsquo;t insert anything) or some other
character.</p>

<p style="margin-top: 1em">-f, --file file <br>
Split file into words and add them to the completion word
list. This option can be given more than once, and adds to
the default completion list in $RLWRAP_HOME or <br>
/usr/share/rlwrap/completions.</p>

<p style="margin-top: 1em">Specifying -f . will make rlwrap
use the current history file as a completion word list.</p>

<p style="margin-top: 1em">-g, --forget-matching regexp
<br>
Forget (i.e. drop from history list) all input lines that
match the POSIX 1003.2 regular expression regexp. The match
is always case-insensitive. regexp may be an ordi&acirc;
<br>
nary string. For more about regular expressions, see regex
(7)</p>

<p style="margin-top: 1em">-h, --help <br>
Print a short help message.</p>

<p style="margin-top: 1em">-H, --history-filename file <br>
Read command history from file (and write it back there if
--histsize &gt;= 0)</p>

<p style="margin-top: 1em">-i, --case-insensitive <br>
Ignore case when completing (filename completion remains
case-sensitive). This option has to come before any -f
options.</p>

<p style="margin-top: 1em">-I, --pass-sigint-as-sigterm
<br>
Send a TERM signal to command when an INT is received (e.g.
when you press CTRL-C).</p>

<p style="margin-top: 1em">-l, --logfile file <br>
When in readline mode, append command&rsquo;s output
(including echo&rsquo;ed user input) to file (creating file
when it doesn&rsquo;t exist).</p>

<p style="margin-top: 1em">-n, --no-warnings <br>
Don&rsquo;t print warnings.</p>

<p style="margin-top: 1em">-N, --no-children <br>
Don&rsquo;t rlwrap command&rsquo;s children: whenever rlwrap
notices that command is waiting for one of its children, it
switches to direct mode, handing down all keypresses
immedi&acirc; <br>
ately. With this option commands that need --always-readline
can call editors and pagers and still be usable.</p>

<p style="margin-top: 1em">This option needs
/proc/command_pid/wchan, so it only works with linux kernels
configured with CONFIG_KALLSYMS.</p>

<p style="margin-top: 1em">-m, --multi-line
[newline_substitute] <br>
Enable multi-line input using a &quot;newline
substitute&quot; character sequence (&quot; &nbsp;&quot;,
[space-backslash-space] by default). Newline substitutes are
translated to newlines before <br>
sending the input to command. With this option, you can call
an external editor $RLWRAP_EDITOR on the (expanded) current
input with the rlwrap_call_editor key (CTRL-^ by <br>
default) The argument is optional; if given, it has to
directly follow the option without an intervening space.</p>

<p style="margin-top: 1em">-M, --multi-line-ext .ext <br>
Call multi-line-editor on temporary files with filename
extension .ext (useful for e.g. automatic syntax
colouring)</p>

<p style="margin-top: 1em">-o, --one-shot <br>
Send an EOF to command after accepting the first line of
input</p>

<p style="margin-top: 1em">-O, --only-cook regexp <br>
Only ever &quot;cook&quot; prompts that match regexp</p>

<p style="margin-top: 1em">-p, --prompt-colour
[colour_name|Colour_name|colour_spec] <br>
Use one of the colour names black, red, green, yellow, blue,
cyan, purple (=magenta) or white, or an ANSI-conformant
&lt;colour_spec&gt; to colour any prompt displayed by
com&acirc; <br>
mand. An uppercase colour name (Yellow or YELLOW ) gives a
bold prompt. Prompts that already contain (colour) escape
sequences or one of the readline &quot;ignore markers&quot;
<br>
(ASCII 0x01 and 0x02) are not coloured. This option implies
--ansi-colour-aware. colour spec has the form
&lt;attr&gt;;&lt;fg&gt;[;&lt;bg&gt;] Example:
-p&rsquo;1;31&rsquo; will give a bold red prompt <br>
on the current background (this is the default when no
argument is given). Google for &rsquo;ANSI color&rsquo; to
learn more about colour codes. The argument is optional; if
given, <br>
it has to directly follow the option without an intervening
space.</p>

<p style="margin-top: 1em">-P, --pre-given text <br>
Start rlwrap with text in its edit buffer (this will
automatically set the --always-readline option).</p>

<p style="margin-top: 1em">-q, --quote-characters
list_of_characters <br>
Assume that the given characters act as quotes, e.g. when
matching parentheses. Take care to escape the list properly
for your shell (example: -q &quot; <br>
be the default, or -q &quot;</p>

<p style="margin-top: 1em">-r, --remember <br>
Put all words seen on in- and output on the completion
list.</p>

<p style="margin-top: 1em">-R, --renice <br>
Make rlwrap nicer than command (cf nice (1)). This may
prevent rlwrap from interrupting command to display a prompt
when command is still &quot;thinking&quot; about what to
output <br>
next.</p>

<p style="margin-top: 1em">-s, --histsize N <br>
Limit the history list to N entries, truncating the history
file (default: 300). A negative size -N means the same as N,
but treats the history file as read-only.</p>

<p style="margin-top: 1em">-S, --substitute-prompt prompt
<br>
Substitute the specified prompt for command&rsquo;s own
prompt. Mainly useful when command doesn&rsquo;t have a
prompt.</p>

<p style="margin-top: 1em">-t, --set-term-name name <br>
Set command&rsquo;s TERM to name. Programs that confuse
rlwrap with fancy screen control codes can sometimes be
tamed by specifying -t dumb</p>

<p style="margin-top: 1em">-U, --mirror-arguments <br>
(linux only) Keep track of command&rsquo;s arguments as seen
by the ps (1) command, and mirror them in rlwrap&rsquo;s own
arguments This is mainly useful for commands that overwrite
<br>
command-line password arguments that would be exposed by
rlwrap without this option.</p>

<p style="margin-top: 1em">-v, --version <br>
Print rlwrap version.</p>

<p style="margin-top: 1em">-w, --wait-before-prompt timeout
<br>
In order to determine if command&rsquo;s last output is a
prompt, rlwrap waits timeout millisecs after receiving it.
Only when no more output has arrived, it is cooked <br>
(coloured, filtered and/or replaced by a substitute prompt)
and displayed as a prompt. Before this the prompt is
displayed &quot;uncooked&quot;. Most users won&rsquo;t
notice, but heavy <br>
cookers can prepend the timeout with a minus sign, making
rlwrap hold back the prompt until it has been cooked
(&quot;patient mode&quot;). This will prevent flashing of
the prompt, <br>
but it will also interfere with long output lines and make
switches from direct to readline mode less reliable. Default
timeout: 40 ms</p>

<p style="margin-top: 1em">-W, --polling <br>
EXPERIMENTAL: Wake up every timeout millisecs, where timeout
is the same as for the -w (--wait-before-prompt) option, 40
ms by default. This is used to sense the slave&rsquo;s <br>
interrupt character and ISIG flag and to adjust
stdin&rsquo;s terminal settings accordingly, even before you
press a key. Try this option e.g. when CTRL-C acts
differently on <br>
command with, and without, rlwrap.</p>

<p style="margin-top: 1em">-z, --filter filter <br>
Use a filter to change rlwrap&rsquo;s behaviour. A filter
can be used to keep certain input out of the history, to
change the prompt, to implement simple macros or
programmable <br>
completion.. rlwrap comes with a special perl module (cf.
RlwrapFilter(3pm)) for easy filter writing. A number of
example filters are installed in the directory <br>
/usr/share/rlwrap/filters. &quot;rlwrap -z filter&quot;
displays information about a filter, &quot;rlwrap -z
listing&quot; lists all currently installed filters. If
filter needs arguments, <br>
you should quote the whole filter command line:</p>

<p style="margin-top: 1em">rlwrap -z &rsquo;filter
args&rsquo; command</p>

<p style="margin-top: 1em">If this command line contains
shell metacharacters, rlwrap passes it to the system shell
for parsing.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Run nc (netcat) with command-line editing and history <br>
rlwrap nc</p>

<p style="margin-top: 1em">Wrap smbclient (which uses
readline itself), keep passwords out of the history and
don&rsquo;t wrap commands launched from smbclient (like
more) <br>
rlwrap -aPassword: -N smbclient //PEANUT/C</p>

<p style="margin-top: 1em">Wrap gauche (a Scheme
interpreter) with a bold blue prompt, enable multi-line
editing (using .scm as filename extension) and don&rsquo;t
consider single quotes as quotes (so that the <br>
parentheses in e.g. (print &rsquo;q) match) <br>
rlwrap -pBlue -m -M .scm -q&rsquo;&quot;&rsquo; gosh</p>

<p style="margin-top: 1em">Get a list of all currently
installed filters <br>
rlwrap -z listing</p>

<p style="margin-top: 1em">Get help for the filter pipeto
<br>
rlwrap -z pipeto</p>

<p style="margin-top: 1em">Wrap sqlite3, use the pipeto
filter to be able to pipe the output of SQL commands through
grep and/or less, complete (case-insensitively) on the SQL
keywords in &rsquo;sql_words&rsquo; <br>
rlwrap -a -z pipeto -i -f sql_words sqlite3 contacts.db</p>

<p style="margin-top: 1em">In a shell script, use rlwrap in
&rsquo;one-shot&rsquo; mode as a replacement for read <br>
order=$(rlwrap -pYellow -S &rsquo;Your pizza? &rsquo; -H
past_orders -P Margherita -o cat)</p>

<p style="margin-top: 1em">DIRECT MODE AND READLINE MODE
<br>
Most simple console commands put your terminal either in
&quot;cooked&quot; or in &quot;raw&quot; mode. In cooked
mode the terminal will wait until you press the ENTER key
before handing the entire <br>
line to the program, in raw mode every key you press is
handed down immediately. In cooked mode you generally can
use the backspace key, but not the arrow keys, to edit your
<br>
input. Most simple console commands use cooked mode whenever
they want whole input lines, and raw mode when they want
single keypresses. More sophisticated commands tend to use
<br>
raw mode all the time; they may sometimes be rlwrappable
with the -a (and -N) options.</p>

<p style="margin-top: 1em">When you rlwrap command, rlwrap
will run it a in a separate session, with its own
&quot;pseudo-terminal&quot; (pty), and monitor this pty to
see whether the pty is in raw mode or in cooked <br>
mode. In the first case, rlwrap will copy all input and
output directly between command and your terminal
(&quot;direct mode&quot;). In the second case, rlwrap will
use readline to edit <br>
your input (&quot;readline mode&quot;), and monitor
command&rsquo;s output - every last line that doesn&rsquo;t
end with a newline is a potential prompt. How it handles
such a candidate prompt depends <br>
on its being in &quot;patient&quot; or &quot;impatient&quot;
mode:</p>

<p style="margin-top: 1em">PATIENT AND IMPATIENT MODE <br>
If command writes a lot of output, it tends to be written
(and read) in &quot;chunks&quot;. Not all chunks will end
with a newline, and we need to distinguish their last lines
from real <br>
prompts, especially if we want to re-write
(&quot;cook&quot;) prompts. rlwrap solves this (almost) by
waiting a little, to see if there is more to come. &quot;A
little&quot; is 40 msec by default, <br>
but this can be changed with the -w option. Normally rlwrap
writes the suspected prompt as soon as it is received,
replacing it with a &quot;cooked&quot; version afer the wait
time. This <br>
is called &quot;impatient&quot; mode. If you don&rsquo;t
like the flashing effect (which can become annoying when you
&quot;cook&quot; the prompt heavily) you can put rlwrap in
&quot;patient mode&quot; by specify&acirc; <br>
ing a negative value with -w (e.g. -w -40). Rlwrap will then
hold back the prompt and only print if after cooking.</p>

<p style="margin-top: 1em">COOKING PROMPTS <br>
If and when rlwrap decides that it has a prompt, it will
perform a number of actions on it, depending on the given
options: filtering (-z), substituting (-S) and colouring
(-p), <br>
in this order. The resulting &quot;cooked&quot; prompt is
then printed (after erasing the &quot;raw&quot; prompt, if
necessary)</p>

<p style="margin-top: 1em">SPECIAL KEYS <br>
Control + O <br>
Accept the current line, but don&rsquo;t put it in the
history list. This action has a readline command name
rlwrap-accept-line-and-forget</p>

<p style="margin-top: 1em">Control + ^ <br>
Use an external editor to edit the current input (this will
only work if the -m option is set). This action has a
readline command name rlwrap-call-editor</p>

<p style="margin-top: 1em">These special keys were chosen
for no other reason than that they are not currently bound
to any readline action. If you don&rsquo;t like them, (or
your window manager swallows them) <br>
they can be re-bound more sensibly by including lines like
the following in your ~/.inputrc:</p>


<p style="margin-top: 1em">&quot;rlwrap-accept-line-and-forget
# ESC-ENTER <br>
&quot; rlwrap-call-editor # CTRL-x e</p>

<p style="margin-top: 1em">cf. the readline(3) manpage</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
RLWRAP_HOME: <br>
directory in which the history and completion files are
kept.</p>

<p style="margin-top: 1em">RLWRAP_EDITOR (or else EDITOR,
or else VISUAL): <br>
editor to use for multi-line input. Example:</p>

<p style="margin-top: 1em">export RLWRAP_EDITOR=&quot;vi
+%L&quot; <br>
export RLWRAP_EDITOR=&quot;vim &rsquo;+call
cursor(%L,%C)&rsquo;&quot;</p>

<p style="margin-top: 1em">The first example above is the
default; %L and %C are replaced by line and column numbers
corresponding to the cursor position in rlwrap&rsquo;s edit
buffer</p>

<p style="margin-top: 1em">RLWRAP_FILTERDIR: <br>
Any executable along your PATH can in theory be used as a
filter, but because filters have to follow a rather
outlandish protocol (cf. RlwrapFilter (3)) it is a good idea
<br>
to keep them separate. This is why rlwrap adds a special
filter directory to $PATH just before launching a filter. By
default, this is /usr/share/rlwrap/filters, but <br>
$RLWRAP_FILTERDIR is used if set.</p>

<p style="margin-top: 1em">SIGNALS <br>
A number of signals are forwarded to command: HUP INT QUIT
USR1 USR2 TERM and (by way of resizing command&rsquo;s
terminal) WINCH. Some care is taken to handle TSTP (usually
a result <br>
of a CTRL-Z from the terminal) sensibly - for example, after
suspending rlwrap in the middle of a line edit, continuing
(by typing &rsquo;fg&rsquo;) will land you at the exact spot
where you <br>
suspended it.</p>

<p style="margin-top: 1em">Filters that take more than 1
second to respond can be interrupted by a CTRL-C from the
terminal (although rlwrap will not survive this)</p>

<p style="margin-top: 1em">If command changes the
keystrokes that send a particular signal from the keyboard
(like emacs, which uses CTRL-G instead of CTRL-C) rlwrap
will do the same (but only after the <br>
next keystroke - use the --polling option to make rlwrap
more transparent in this respect)</p>

<p style="margin-top: 1em">When command is killed by a
signal, rlwrap will clean up, reset its signal handlers an
then commit suicide by sending the same signal to itself.
This means that your shell sees <br>
the same exit status as it would have seen without
rlwrap.</p>

<p style="margin-top: 1em">REDIRECTION <br>
When the standard input is not a terminal, editing input
doesn&rsquo;t make sense, so rlwrap will ignore all options
and simply execute command. When stdout (or stderr) is not a
termi&acirc; <br>
nal, rlwrap will re-open it to /dev/tty (the users terminal)
after it has started command, so that command&rsquo;s output
is redirected as expected, but keyboard input and rlwrap
<br>
error messages are still visible.</p>

<p style="margin-top: 1em">The upshot of this is that
rlwrap command behaves more or less like command when
redirecting.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
non-zero after a rlwrap error, or else command&rsquo;s exit
status. rlwrap will always leave the terminal in a tidy
state, even after a crash.</p>

<p style="margin-top: 1em">FILES <br>
rlwrap expects its history and completion files in
$RLWRAP_HOME, but uses .dotfiles in the user&rsquo;s home
directory if this variable is not set. This will quickly
become messy if <br>
you use rlwrap for many different commands.</p>

<p style="margin-top: 1em">$RLWRAP_HOME/command_history,
~/.command_history <br>
History for command</p>


<p style="margin-top: 1em">$RLWRAP_HOME/command_completions,
~/.command_completions <br>
Per-user completion word list for command. rlwrap never
writes into this list, but one can combine -l and -f options
to to simulate the effect of a -r option that works <br>
across invocations.</p>


<p style="margin-top: 1em">/usr/share/rlwrap/completions/command
<br>
System-wide completion word list for command. This file is
only consulted if the per-user completion word list is not
found.</p>

<p style="margin-top: 1em">$INPUTRC, ~/.inputrc <br>
Individual readline initialisation file (See readline (3)
for its format). rlwrap sets its application name to command
(this can be overridden by the -C option), enabling <br>
different behaviours for different commands. One could e.g.
put the following lines in ~/.inputrc:</p>

<p style="margin-top: 1em">$if coqtop <br>
set show-all-if-ambiguous On <br>
$endif</p>

<p style="margin-top: 1em">making rlwrap show all
completions whenever it runs coqtop</p>

<p style="margin-top: 1em">BUGS and LIMITATIONS <br>
Though it is flexible, delivers the goods (readline
functionality), and adheres to the Unix &quot;many small
tools&quot; paradigm, rlwrap is a kludge. It cannot know
anything about com&acirc; <br>
mand&rsquo;s internal state, which makes context-sensitive
completion impossible. Using the readline library from
within command is still the best option.</p>

<p style="margin-top: 1em">Also, because &quot;it takes two
to tango&quot; there is no way for rlwrap to synchronise its
internal state with command, resulting in a number of subtle
race conditions, where e.g. com&acirc; <br>
mand may have changed the state of its terminal before
rlwrap has read command output that was written before the
state change. You will notice these races especially on a
busy <br>
machine and with heavy &quot;cooking&quot; and filtering,
when suddenly (and unpredictably) promtps or command output
are garbled or incorrectly coloured.</p>

<p style="margin-top: 1em">rlwrap can try, but often fails
to, handle prompts that contain control characters. A flter
may be used to clean up the prompt.</p>

<p style="margin-top: 1em">VERSION <br>
This manpage documents rlwrap version 0.42</p>

<p style="margin-top: 1em">AUTHORS <br>
The readline library (written by Brian Fox and Chet Ramey)
does all the hard work behind the scenes, the pty-handling
code has been taken practically unchanged from rxvt-2.7.10
<br>
(currently maintained by Geoff C. Wing), and completion word
lists are managed by Damian Ivereigh&rsquo;s libredblack
library. The few remaining lines of code were written by
Hans Lub <br>
(hanslub42@gmail.com).</p>

<p style="margin-top: 1em">SEE ALSO <br>
readline(3), RlwrapFilter(3pm)</p>

<p style="margin-top: 1em">November 14, 2014 rlwrap(1)</p>
<hr>
</body>
</html>
