<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>FFMPEG(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">FFMPEG(1)</td>
    <td class="head-vol"> </td>
    <td class="head-rtitle">FFMPEG(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
ffmpeg - ffmpeg video converter
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
ffmpeg [ <i>global_options</i>] {[<i>input_file_options</i>] -i
  <i>input_url</i>} ... {[ <i>output_file_options</i>] <i>output_url</i>} ...
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>ffmpeg</b> is a very fast video and audio converter that can also grab from a
  live audio/video source. It can also convert between arbitrary sample rates
  and resize video on the fly with a high quality polyphase filter.
<div class="Pp"></div>
<b>ffmpeg</b> reads from an arbitrary number of input &quot;files&quot; (which
  can be regular files, pipes, network streams, grabbing devices, etc.),
  specified by the &quot;-i&quot; option, and writes to an arbitrary number of
  output &quot;files&quot;, which are specified by a plain output url. Anything
  found on the command line which cannot be interpreted as an option is
  considered to be an output url.
<div class="Pp"></div>
Each input or output url can, in principle, contain any number of streams of
  different types (video/audio/subtitle/attachment/data). The allowed number
  and/or types of streams may be limited by the container format. Selecting
  which streams from which inputs will go into which output is either done
  automatically or with the &quot;-map&quot; option (see the Stream selection
  chapter).
<div class="Pp"></div>
To refer to input files in options, you must use their indices (0-based). E.g.
  the first input file is 0, the second is 1, etc. Similarly, streams within a
  file are referred to by their indices. E.g. &quot;2:3&quot; refers to the
  fourth stream in the third input file. Also see the Stream specifiers chapter.
<div class="Pp"></div>
As a general rule, options are applied to the next specified file. Therefore,
  order is important, and you can have the same option on the command line
  multiple times. Each occurrence is then applied to the next input or output
  file. Exceptions from this rule are the global options (e.g. verbosity level),
  which should be specified first.
<div class="Pp"></div>
Do not mix input and output files -- first specify all input files, then all
  output files. Also do not mix options which belong to different files. All
  options apply ONLY to the next input or output file and are reset between
  files.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">To set the video bitrate of the output file to 64 kbit/s:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i input.avi -b:v 64k -bufsize 64k output.avi
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">To force the frame rate of the output file to 24 fps:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i input.avi -r 24 output.avi
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">To force the frame rate of the input file (valid for raw
      formats only) to 1 fps and the frame rate of the output file to 24 fps:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -r 1 -i input.m2v -r 24 output.avi
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
The format option may be needed for raw input files.
<h1 class="Sh" title="Sh" id="DETAILED_DESCRIPTION"><a class="selflink" href="#DETAILED_DESCRIPTION">DETAILED
  DESCRIPTION</a></h1>
The transcoding process in <b>ffmpeg</b> for each output can be described by the
  following diagram:
<div class="Pp"></div>
<pre>
         _______              ______________
        |       |            |              |
        | input |  demuxer   | encoded data |   decoder
        | file  | ---------&gt; | packets      | -----+
        |_______|            |______________|      |
                                                   v
                                               _________
                                              |         |
                                              | decoded |
                                              | frames  |
                                              |_________|
         ________             ______________       |
        |        |           |              |      |
        | output | &lt;-------- | encoded data | &lt;----+
        | file   |   muxer   | packets      |   encoder
        |________|           |______________|
</pre>
<div class="Pp"></div>
<b>ffmpeg</b> calls the libavformat library (containing demuxers) to read input
  files and get packets containing encoded data from them. When there are
  multiple input files, <b>ffmpeg</b> tries to keep them synchronized by
  tracking lowest timestamp on any active input stream.
<div class="Pp"></div>
Encoded packets are then passed to the decoder (unless streamcopy is selected
  for the stream, see further for a description). The decoder produces
  uncompressed frames (raw video/PCM audio/...) which can be processed further
  by filtering (see next section). After filtering, the frames are passed to the
  encoder, which encodes them and outputs encoded packets. Finally those are
  passed to the muxer, which writes the encoded packets to the output file.
<h2 class="Ss" title="Ss" id="Filtering"><a class="selflink" href="#Filtering">Filtering</a></h2>
Before encoding, <b>ffmpeg</b> can process raw audio and video frames using
  filters from the libavfilter library. Several chained filters form a filter
  graph. <b>ffmpeg</b> distinguishes between two types of filtergraphs: simple
  and complex.
<div class="Pp"></div>
<i>Simple filtergraphs</i>
<div class="Pp"></div>
Simple filtergraphs are those that have exactly one input and output, both of
  the same type. In the above diagram they can be represented by simply
  inserting an additional step between decoding and encoding:
<div class="Pp"></div>
<pre>
         _________                        ______________
        |         |                      |              |
        | decoded |                      | encoded data |
        | frames  |\                   _ | packets      |
        |_________| \                  /||______________|
                     \   __________   /
          simple     _\||          | /  encoder
          filtergraph   | filtered |/
                        | frames   |
                        |__________|
</pre>
<div class="Pp"></div>
Simple filtergraphs are configured with the per-stream <b>-filter</b> option
  (with <b>-vf</b> and <b>-af</b> aliases for video and audio respectively). A
  simple filtergraph for video can look for example like this:
<div class="Pp"></div>
<pre>
         _______        _____________        _______        ________
        |       |      |             |      |       |      |        |
        | input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |
        |_______|      |_____________|      |_______|      |________|
</pre>
<div class="Pp"></div>
Note that some filters change frame properties but not frame contents. E.g. the
  &quot;fps&quot; filter in the example above changes number of frames, but does
  not touch the frame contents. Another example is the &quot;setpts&quot;
  filter, which only sets timestamps and otherwise passes the frames unchanged.
<div class="Pp"></div>
<i>Complex filtergraphs</i>
<div class="Pp"></div>
Complex filtergraphs are those which cannot be described as simply a linear
  processing chain applied to one stream. This is the case, for example, when
  the graph has more than one input and/or output, or when output stream type is
  different from input. They can be represented with the following diagram:
<div class="Pp"></div>
<pre>
         _________
        |         |
        | input 0 |\                    __________
        |_________| \                  |          |
                     \   _________    /| output 0 |
                      \ |         |  / |__________|
         _________     \| complex | /
        |         |     |         |/
        | input 1 |----&gt;| filter  |\
        |_________|     |         | \   __________
                       /| graph   |  \ |          |
                      / |         |   \| output 1 |
         _________   /  |_________|    |__________|
        |         | /
        | input 2 |/
        |_________|
</pre>
<div class="Pp"></div>
Complex filtergraphs are configured with the <b>-filter_complex</b> option. Note
  that this option is global, since a complex filtergraph, by its nature, cannot
  be unambiguously associated with a single stream or file.
<div class="Pp"></div>
The <b>-lavfi</b> option is equivalent to <b>-filter_complex</b>.
<div class="Pp"></div>
A trivial example of a complex filtergraph is the &quot;overlay&quot; filter,
  which has two video inputs and one video output, containing one video overlaid
  on top of the other. Its audio counterpart is the &quot;amix&quot; filter.
<h2 class="Ss" title="Ss" id="Stream_copy"><a class="selflink" href="#Stream_copy">Stream
  copy</a></h2>
Stream copy is a mode selected by supplying the &quot;copy&quot; parameter to
  the <b>-codec</b> option. It makes <b>ffmpeg</b> omit the decoding and
  encoding step for the specified stream, so it does only demuxing and muxing.
  It is useful for changing the container format or modifying container-level
  metadata. The diagram above will, in this case, simplify to this:
<div class="Pp"></div>
<pre>
         _______              ______________            ________
        |       |            |              |          |        |
        | input |  demuxer   | encoded data |  muxer   | output |
        | file  | ---------&gt; | packets      | -------&gt; | file   |
        |_______|            |______________|          |________|
</pre>
<div class="Pp"></div>
Since there is no decoding or encoding, it is very fast and there is no quality
  loss. However, it might not work in some cases because of many factors.
  Applying filters is obviously also impossible, since filters work on
  uncompressed data.
<h1 class="Sh" title="Sh" id="STREAM_SELECTION"><a class="selflink" href="#STREAM_SELECTION">STREAM
  SELECTION</a></h1>
By default, <b>ffmpeg</b> includes only one stream of each type (video, audio,
  subtitle) present in the input files and adds them to each output file. It
  picks the &quot;best&quot; of each based upon the following criteria: for
  video, it is the stream with the highest resolution, for audio, it is the
  stream with the most channels, for subtitles, it is the first subtitle stream.
  In the case where several streams of the same type rate equally, the stream
  with the lowest index is chosen.
<div class="Pp"></div>
You can disable some of those defaults by using the &quot;-vn/-an/-sn/-dn&quot;
  options. For full manual control, use the &quot;-map&quot; option, which
  disables the defaults just described.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
All the numerical options, if not specified otherwise, accept a string
  representing a number as input, which may be followed by one of the SI unit
  prefixes, for example: 'K', 'M', or 'G'.
<div class="Pp"></div>
If 'i' is appended to the SI unit prefix, the complete prefix will be
  interpreted as a unit prefix for binary multiples, which are based on powers
  of 1024 instead of powers of 1000. Appending 'B' to the SI unit prefix
  multiplies the value by 8. This allows using, for example: 'KB', 'MiB', 'G'
  and 'B' as number suffixes.
<div class="Pp"></div>
Options which do not take arguments are boolean options, and set the
  corresponding value to true. They can be set to false by prefixing the option
  name with &quot;no&quot;. For example using &quot;-nofoo&quot; will set the
  boolean option with name &quot;foo&quot; to false.
<h2 class="Ss" title="Ss" id="Stream_specifiers"><a class="selflink" href="#Stream_specifiers">Stream
  specifiers</a></h2>
Some options are applied per-stream, e.g. bitrate or codec. Stream specifiers
  are used to precisely specify which stream(s) a given option belongs to.
<div class="Pp"></div>
A stream specifier is a string generally appended to the option name and
  separated from it by a colon. E.g. &quot;-codec:a:1 ac3&quot; contains the
  &quot;a:1&quot; stream specifier, which matches the second audio stream.
  Therefore, it would select the ac3 codec for the second audio stream.
<div class="Pp"></div>
A stream specifier can match several streams, so that the option is applied to
  all of them. E.g. the stream specifier in &quot;-b:a 128k&quot; matches all
  audio streams.
<div class="Pp"></div>
An empty stream specifier matches all streams. For example, &quot;-codec
  copy&quot; or &quot;-codec: copy&quot; would copy all the streams without
  reencoding.
<div class="Pp"></div>
Possible forms of stream specifiers are:
<dl class="Bl-tag">
  <dt class="It-tag"><i>stream_index</i></dt>
  <dd class="It-tag">Matches the stream with this index. E.g. &quot;-threads:1
      4&quot; would set the thread count for the second stream to 4.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>stream_type</i><b>[:</b><i>stream_index</i><b>]</b></dt>
  <dd class="It-tag"><i>stream_type</i> is one of following: 'v' or 'V' for
      video, 'a' for audio, 's' for subtitle, 'd' for data, and 't' for
      attachments. 'v' matches all video streams, 'V' only matches video streams
      which are not attached pictures, video thumbnails or cover arts. If
      <i>stream_index</i> is given, then it matches stream number
      <i>stream_index</i> of this type. Otherwise, it matches all streams of
      this type.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>p:</b><i>program_id</i><b>[:</b><i>stream_index</i><b>]</b></dt>
  <dd class="It-tag">If <i>stream_index</i> is given, then it matches the stream
      with number <i>stream_index</i> in the program with the id
      <i>program_id</i>. Otherwise, it matches all streams in the program.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#</b><i>stream_id</i> <b>or i:</b><i>stream_id</i></dt>
  <dd class="It-tag">Match the stream by stream id (e.g. PID in MPEG-TS
      container).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>m:</b><i>key</i><b>[:</b><i>value</i><b>]</b></dt>
  <dd class="It-tag">Matches streams with the metadata tag <i>key</i> having the
      specified value. If <i>value</i> is not given, matches streams that
      contain the given tag with any value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>u</b></dt>
  <dd class="It-tag">Matches streams with usable configuration, the codec must
      be defined and the essential information such as video dimension or audio
      sample rate must be present.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that in <b>ffmpeg</b>, matching by metadata will only work properly for
      input files.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Generic_options"><a class="selflink" href="#Generic_options">Generic
  options</a></h2>
These options are shared amongst the ff* tools.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L</b></dt>
  <dd class="It-tag">Show license.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h, -?, -help, --help [</b><i>arg</i><b>]</b></dt>
  <dd class="It-tag">Show help. An optional parameter may be specified to print
      help about a specific item. If no argument is specified, only basic (non
      advanced) tool options are shown.
    <div style="height: 1.00em;">&#x00A0;</div>
    Possible values of <i>arg</i> are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>long</b></dt>
  <dd class="It-tag">Print advanced tool options in addition to the basic tool
      options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>full</b></dt>
  <dd class="It-tag">Print complete list of options, including shared and
      private options for encoders, decoders, demuxers, muxers, filters,
    etc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>decoder=</b><i>decoder_name</i></dt>
  <dd class="It-tag">Print detailed information about the decoder named
      <i>decoder_name</i>. Use the <b>-decoders</b> option to get a list of all
      decoders.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>encoder=</b><i>encoder_name</i></dt>
  <dd class="It-tag">Print detailed information about the encoder named
      <i>encoder_name</i>. Use the <b>-encoders</b> option to get a list of all
      encoders.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>demuxer=</b><i>demuxer_name</i></dt>
  <dd class="It-tag">Print detailed information about the demuxer named
      <i>demuxer_name</i>. Use the <b>-formats</b> option to get a list of all
      demuxers and muxers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>muxer=</b><i>muxer_name</i></dt>
  <dd class="It-tag">Print detailed information about the muxer named
      <i>muxer_name</i>. Use the <b>-formats</b> option to get a list of all
      muxers and demuxers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>filter=</b><i>filter_name</i></dt>
  <dd class="It-tag">Print detailed information about the filter name
      <i>filter_name</i>. Use the <b>-filters</b> option to get a list of all
      filters.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-version</b></dt>
  <dd class="It-tag">Show version.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-formats</b></dt>
  <dd class="It-tag">Show available formats (including devices).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-devices</b></dt>
  <dd class="It-tag">Show available devices.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-codecs</b></dt>
  <dd class="It-tag">Show all codecs known to libavcodec.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the term 'codec' is used throughout this documentation as a
      shortcut for what is more correctly called a media bitstream format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-decoders</b></dt>
  <dd class="It-tag">Show available decoders.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-encoders</b></dt>
  <dd class="It-tag">Show all available encoders.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bsfs</b></dt>
  <dd class="It-tag">Show available bitstream filters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-protocols</b></dt>
  <dd class="It-tag">Show available protocols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-filters</b></dt>
  <dd class="It-tag">Show available libavfilter filters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-pix_fmts</b></dt>
  <dd class="It-tag">Show available pixel formats.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sample_fmts</b></dt>
  <dd class="It-tag">Show available sample formats.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-layouts</b></dt>
  <dd class="It-tag">Show channel names and standard channel layouts.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-colors</b></dt>
  <dd class="It-tag">Show recognized color names.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sources</b>
    <i>device</i><b>[,</b><i>opt1</i><b>=</b><i>val1</i><b>[,</b><i>opt2</i><b>=</b><i>val2</i><b>]...]</b></dt>
  <dd class="It-tag">Show autodetected sources of the intput device. Some
      devices may provide system-dependent source names that cannot be
      autodetected. The returned list cannot be assumed to be always complete.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -sources pulse,server=192.168.0.4
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sinks</b>
    <i>device</i><b>[,</b><i>opt1</i><b>=</b><i>val1</i>
    <b>[,</b><i>opt2</i><b>=</b> <i>val2</i><b>]...]</b></dt>
  <dd class="It-tag">Show autodetected sinks of the output device. Some devices
      may provide system-dependent sink names that cannot be autodetected. The
      returned list cannot be assumed to be always complete.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -sinks pulse,server=192.168.0.4
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-loglevel [repeat+]</b><i>loglevel</i> <b>| -v
    [repeat+]</b> <i>loglevel</i></dt>
  <dd class="It-tag">Set the logging level used by the library. Adding
      &quot;repeat+&quot; indicates that repeated log output should not be
      compressed to the first line and the &quot;Last message repeated n
      times&quot; line will be omitted. &quot;repeat&quot; can also be used
      alone. If &quot;repeat&quot; is used alone, and with no prior loglevel
      set, the default loglevel will be used. If multiple loglevel parameters
      are given, using 'repeat' will not change the loglevel. <i>loglevel</i> is
      a string or a number containing one of the following values:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>quiet, -8</b></dt>
  <dd class="It-tag">Show nothing at all; be silent.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>panic, 0</b></dt>
  <dd class="It-tag">Only show fatal errors which could lead the process to
      crash, such as an assertion failure. This is not currently used for
      anything.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fatal, 8</b></dt>
  <dd class="It-tag">Only show fatal errors. These are errors after which the
      process absolutely cannot continue.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>error, 16</b></dt>
  <dd class="It-tag">Show all errors, including ones which can be recovered
      from.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>warning, 24</b></dt>
  <dd class="It-tag">Show all warnings and errors. Any message related to
      possibly incorrect or unexpected events will be shown.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>info, 32</b></dt>
  <dd class="It-tag">Show informative messages during processing. This is in
      addition to warnings and errors. This is the default value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>verbose, 40</b></dt>
  <dd class="It-tag">Same as &quot;info&quot;, except more verbose.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>debug, 48</b></dt>
  <dd class="It-tag">Show everything, including debugging information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>trace, 56</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
By default the program logs to stderr. If coloring is supported by the terminal,
  colors are used to mark errors and warnings. Log coloring can be disabled
  setting the environment variable <b>AV_LOG_FORCE_NOCOLOR</b> or
  <b>NO_COLOR</b>, or can be forced setting the environment variable
  <b>AV_LOG_FORCE_COLOR</b>. The use of the environment variable <b>NO_COLOR</b>
  is deprecated and will be dropped in a future FFmpeg version.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-report</b></dt>
  <dd class="It-tag">Dump full command line and console output to a file named
      &quot; <i>program</i>-<i>YYYYMMDD</i>-<i>HHMMSS</i>.log&quot; in the
      current directory. This file can be useful for bug reports. It also
      implies &quot;-loglevel verbose&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Setting the environment variable <b>FFREPORT</b> to any value has the same
      effect. If the value is a ':'-separated key=value sequence, these options
      will affect the report; option values must be escaped if they contain
      special characters or the options delimiter ':' (see the ``Quoting and
      escaping'' section in the ffmpeg-utils manual).
    <div style="height: 1.00em;">&#x00A0;</div>
    The following options are recognized:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>file</b></dt>
  <dd class="It-tag">set the file name to use for the report; %p is expanded to
      the name of the program, %t is expanded to a timestamp, &quot;%%&quot; is
      expanded to a plain &quot;%&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>level</b></dt>
  <dd class="It-tag">set the log verbosity level using a numerical value (see
      &quot;-loglevel&quot;).</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
For example, to output a report to a file named <i>ffreport.log</i> using a log
  level of 32 (alias for log level &quot;info&quot;):
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        FFREPORT=file=ffreport.log:level=32 ffmpeg -i input output
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Errors in parsing the environment variable are not fatal, and will not appear in
  the report.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hide_banner</b></dt>
  <dd class="It-tag">Suppress printing banner.
    <div style="height: 1.00em;">&#x00A0;</div>
    All FFmpeg tools will normally show a copyright notice, build options and
      library versions. This option can be used to suppress printing this
      information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-cpuflags flags (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Allows setting and clearing cpu flags. This option is
      intended for testing. Do not use it unless you know what you're doing.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -cpuflags -sse+mmx ...
        ffmpeg -cpuflags mmx ...
        ffmpeg -cpuflags 0 ...
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Possible flags for this option are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>x86</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>mmx</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mmxext</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sse</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sse2</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sse2slow</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sse3</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sse3slow</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ssse3</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>atom</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sse4.1</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sse4.2</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>avx</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>avx2</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>xop</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fma3</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fma4</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>3dnow</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>3dnowext</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bmi1</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bmi2</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cmov</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ARM</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>armv5te</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>armv6</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>armv6t2</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vfp</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vfpv3</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>neon</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>setend</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>AArch64</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>armv8</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vfp</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>neon</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>PowerPC</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>altivec</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Specific Processors</b></dt>
  <dd class="It-tag"></dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>pentium2</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pentium3</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pentium4</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>k6</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>k62</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>athlon</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>athlonxp</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>k8</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-opencl_bench</b></dt>
  <dd class="It-tag">This option is used to benchmark all available OpenCL
      devices and print the results. This option is only available when FFmpeg
      has been compiled with &quot;--enable-opencl&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    When FFmpeg is configured with &quot;--enable-opencl&quot;, the options for
      the global OpenCL context are set via <b>-opencl_options</b>. See the
      &quot;OpenCL Options&quot; section in the ffmpeg-utils manual for the
      complete list of supported options. Amongst others, these options include
      the ability to select a specific platform and device to run the OpenCL
      code on. By default, FFmpeg will run on the first device of the first
      platform. While the options for the global OpenCL context provide
      flexibility to the user in selecting the OpenCL device of their choice,
      most users would probably want to select the fastest OpenCL device for
      their system.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option assists the selection of the most efficient configuration by
      identifying the appropriate device for the user's system. The built-in
      benchmark is run on all the OpenCL devices and the performance is measured
      for each device. The devices in the results list are sorted based on their
      performance with the fastest device listed first. The user can
      subsequently invoke <b>ffmpeg</b> using the device deemed most appropriate
      via <b>-opencl_options</b> to obtain the best performance for the OpenCL
      accelerated code.
    <div style="height: 1.00em;">&#x00A0;</div>
    Typical usage to use the fastest OpenCL device involve the following steps.
    <div style="height: 1.00em;">&#x00A0;</div>
    Run the command:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -opencl_bench
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note down the platform ID ( <i>pidx</i>) and device ID (<i>didx</i>) of the
      first i.e. fastest device in the list. Select the platform and device
      using the command:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -opencl_options platform_idx=&lt;pidx&gt;:device_idx=&lt;didx&gt; ...
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-opencl_options options (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Set OpenCL environment options. This option is only
      available when FFmpeg has been compiled with &quot;--enable-opencl&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>options</i> must be a list of <i>key</i>=<i>value</i> option pairs
      separated by ':'. See the ``OpenCL Options'' section in the ffmpeg-utils
      manual for the list of supported options.</dd>
</dl>
<h2 class="Ss" title="Ss" id="AVOptions"><a class="selflink" href="#AVOptions">AVOptions</a></h2>
These options are provided directly by the libavformat, libavdevice and
  libavcodec libraries. To see the list of available AVOptions, use the
  <b>-help</b> option. They are separated into two categories:
<dl class="Bl-tag">
  <dt class="It-tag"><b>generic</b></dt>
  <dd class="It-tag">These options can be set for any container, codec or
      device. Generic options are listed under AVFormatContext options for
      containers/devices and under AVCodecContext options for codecs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>private</b></dt>
  <dd class="It-tag">These options are specific to the given container, device
      or codec. Private options are listed under their corresponding
      containers/devices/codecs.</dd>
</dl>
<div class="Pp"></div>
For example to write an ID3v2.3 header instead of a default ID3v2.4 to an MP3
  file, use the <b>id3v2_version</b> private option of the MP3 muxer:
<div class="Pp"></div>
<pre>
        ffmpeg -i input.flac -id3v2_version 3 out.mp3
</pre>
<div class="Pp"></div>
All codec AVOptions are per-stream, and thus a stream specifier should be
  attached to them.
<div class="Pp"></div>
Note: the <b>-nooption</b> syntax cannot be used for boolean AVOptions, use
  <b>-option 0</b>/ <b>-option 1</b>.
<div class="Pp"></div>
Note: the old undocumented way of specifying per-stream AVOptions by prepending
  v/a/s to the options name is now obsolete and will be removed soon.
<h2 class="Ss" title="Ss" id="Main_options"><a class="selflink" href="#Main_options">Main
  options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b> <i>fmt</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">Force input or output file format. The format is normally
      auto detected for input files and guessed from the file extension for
      output files, so this option is not needed in most cases.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b> <i>url</i> <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">input file url</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-y (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Overwrite output files without asking.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Do not overwrite output files, and exit immediately if a
      specified output file already exists.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-stream_loop</b> <i>number</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Set number of times input stream shall be looped. Loop 0
      means no loop, loop -1 means infinite loop.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c[:</b><i>stream_specifier</i><b>]</b> <i>codec</i>
    <b>(</b> <i>input/output,per-stream</i><b>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-codec[:</b><i>stream_specifier</i><b>]</b> <i>codec</i>
    <b>(</b><i>input/output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Select an encoder (when used before an output file) or a
      decoder (when used before an input file) for one or more streams.
      <i>codec</i> is the name of a decoder/encoder or a special value
      &quot;copy&quot; (output only) to indicate that the stream is not to be
      re-encoded.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    encodes all video streams with libx264 and copies all audio streams.
    <div style="height: 1.00em;">&#x00A0;</div>
    For each stream, the last matching &quot;c&quot; option is applied, so
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -map 0 -c copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will copy all the streams except the second video, which will be encoded
      with libx264, and the 138th audio, which will be encoded with
    libvorbis.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b> <i>duration</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">When used as an input option (before &quot;-i&quot;), limit
      the <i>duration</i> of data read from the input file.
    <div style="height: 1.00em;">&#x00A0;</div>
    When used as an output option (before an output url), stop writing the
      output after its duration reaches <i>duration</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>duration</i> must be a time duration specification, see <b>the Time
      duration section in the </b> <b><i>ffmpeg-utils</i></b><b>(1) manual</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    -to and -t are mutually exclusive and -t has priority.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-to</b> <i>position</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Stop writing the output at <i>position</i>. <i>position</i>
      must be a time duration specification, see <b>the Time duration section in
      the </b> <b><i>ffmpeg-utils</i></b><b>(1) manual</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    -to and -t are mutually exclusive and -t has priority.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-fs</b> <i>limit_size</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set the file size limit, expressed in bytes. No further
      chunk of bytes is written after the limit is exceeded. The size of the
      output file is slightly more than the requested file size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ss</b> <i>position</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">When used as an input option (before &quot;-i&quot;), seeks
      in this input file to <i>position</i>. Note that in most formats it is not
      possible to seek exactly, so <b>ffmpeg</b> will seek to the closest seek
      point before <i>position</i>. When transcoding and <b>-accurate_seek</b>
      is enabled (the default), this extra segment between the seek point and
      <i>position</i> will be decoded and discarded. When doing stream copy or
      when <b>-noaccurate_seek</b> is used, it will be preserved.
    <div style="height: 1.00em;">&#x00A0;</div>
    When used as an output option (before an output url), decodes but discards
      input until the timestamps reach <i>position</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>position</i> must be a time duration specification, see <b>the Time
      duration section in the </b> <b><i>ffmpeg-utils</i></b><b>(1)
    manual</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sseof</b> <i>position</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">Like the &quot;-ss&quot; option but relative to the
      &quot;end of file&quot;. That is negative values are earlier in the file,
      0 is at EOF.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-itsoffset</b> <i>offset</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Set the input time offset.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>offset</i> must be a time duration specification, see <b>the Time
      duration section in the </b> <b><i>ffmpeg-utils</i></b><b>(1) manual</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The offset is added to the timestamps of the input files. Specifying a
      positive offset means that the corresponding streams are delayed by the
      time duration specified in <i>offset</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-timestamp</b> <i>date</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set the recording timestamp in the container.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>date</i> must be a date specification, see <b>the Date section in the
      </b> <b><i>ffmpeg-utils</i></b><b>(1) manual</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-metadata[:metadata_specifier]</b>
    <i>key</i><b>=</b><i>value</i>
    <b>(</b><i>output,per-metadata</i><b>)</b></dt>
  <dd class="It-tag">Set a metadata key/value pair.
    <div style="height: 1.00em;">&#x00A0;</div>
    An optional <i>metadata_specifier</i> may be given to set metadata on
      streams, chapters or programs. See &quot;-map_metadata&quot; documentation
      for details.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option overrides metadata set with &quot;-map_metadata&quot;. It is
      also possible to delete metadata by using an empty value.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, for setting the title in the output file:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.avi -metadata title=&quot;my title&quot; out.flv
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    To set the language of the first audio stream:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -metadata:s:a:0 language=eng OUTPUT
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-program
    [title=</b><i>title</i><b>:][program_num=</b><i>program_num</i><b>:]st=</b><i>stream</i><b>[:st=</b><i>stream</i><b>...]
    (</b> <i>output</i><b>)</b></dt>
  <dd class="It-tag">Creates a program with the specified <i>title</i>,
      <i>program_num</i> and adds the specified <i>stream</i>(s) to it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-target</b> <i>type</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Specify target file type (&quot;vcd&quot;,
      &quot;svcd&quot;, &quot;dvd&quot;, &quot;dv&quot;, &quot;dv50&quot;).
      <i>type</i> may be prefixed with &quot;pal-&quot;, &quot;ntsc-&quot; or
      &quot;film-&quot; to use the corresponding standard. All the format
      options (bitrate, codecs, buffer sizes) are then set automatically. You
      can just type:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i myfile.avi -target vcd /tmp/vcd.mpg
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Nevertheless you can specify additional options as long as you know they do
      not conflict with the standard, as in:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i myfile.avi -target vcd -bf 2 /tmp/vcd.mpg
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-dframes</b> <i>number</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set the number of data frames to output. This is an alias
      for &quot;-frames:d&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-frames[:</b><i>stream_specifier</i><b>]</b>
    <i>framecount</i> <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Stop writing to the stream after <i>framecount</i>
    frames.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q[:</b><i>stream_specifier</i><b>]</b> <i>q</i>
    <b>(</b> <i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-qscale[:</b><i>stream_specifier</i><b>]</b> <i>q</i>
    <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Use fixed quality scale (VBR). The meaning of
      <i>q</i>/<i>qscale</i> is codec-dependent. If <i>qscale</i> is used
      without a <i>stream_specifier</i> then it applies only to the video
      stream, this is to maintain compatibility with previous behavior and as
      specifying the same codec specific value to 2 different codecs that is
      audio and video generally is not what is intended when no stream_specifier
      is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-filter[:</b><i>stream_specifier</i><b>]</b>
    <i>filtergraph</i> <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Create the filtergraph specified by <i>filtergraph</i> and
      use it to filter the stream.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>filtergraph</i> is a description of the filtergraph to apply to the
      stream, and must have a single input and a single output of the same type
      of the stream. In the filtergraph, the input is associated to the label
      &quot;in&quot;, and the output to the label &quot;out&quot;. See the
      ffmpeg-filters manual for more information about the filtergraph syntax.
    <div style="height: 1.00em;">&#x00A0;</div>
    See the <b>-filter_complex option</b> if you want to create filtergraphs
      with multiple inputs and/or outputs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-filter_script[:</b><i>stream_specifier</i><b>]</b>
    <i>filename</i> <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">This option is similar to <b>-filter</b>, the only
      difference is that its argument is the name of the file from which a
      filtergraph description is to be read.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-pre[:</b><i>stream_specifier</i><b>]</b>
    <i>preset_name</i> <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Specify the preset for matching stream(s).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-stats (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Print encoding progress/statistics. It is on by default, to
      explicitly disable it you need to specify &quot;-nostats&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-progress</b> <i>url</i>
    <b>(</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Send program-friendly progress information to <i>url</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Progress information is written approximately every second and at the end of
      the encoding process. It is made of &quot; <i>key</i>=<i>value</i>&quot;
      lines. <i>key</i> consists of only alphanumeric characters. The last key
      of a sequence of progress information is always &quot;progress&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-stdin</b></dt>
  <dd class="It-tag">Enable interaction on standard input. On by default unless
      standard input is used as an input. To explicitly disable interaction you
      need to specify &quot;-nostdin&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Disabling interaction on standard input is useful, for example, if ffmpeg is
      in the background process group. Roughly the same result can be achieved
      with &quot;ffmpeg ... &lt; /dev/null&quot; but it requires a shell.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-debug_ts (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Print timestamp information. It is off by default. This
      option is mostly useful for testing and debugging purposes, and the output
      format may change from one version to another, so it should not be
      employed by portable scripts.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also the option &quot;-fdebug ts&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-attach</b> <i>filename</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Add an attachment to the output file. This is supported by
      a few formats like Matroska for e.g. fonts used in rendering subtitles.
      Attachments are implemented as a specific type of stream, so this option
      will add a new stream to the file. It is then possible to use per-stream
      options on this stream in the usual way. Attachment streams created with
      this option will be created after all the other streams (i.e. those
      created with &quot;-map&quot; or automatic mappings).
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that for Matroska you also have to set the mimetype metadata tag:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -attach DejaVuSans.ttf -metadata:s:2 mimetype=application/x-truetype-font out.mkv
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    (assuming that the attachment stream will be third in the output file).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-dump_attachment[:</b><i>stream_specifier</i><b>]</b>
    <i>filename</i> <b>(</b><i>input,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Extract the matching attachment stream into a file named
      <i>filename</i>. If <i>filename</i> is empty, then the value of the
      &quot;filename&quot; metadata tag will be used.
    <div style="height: 1.00em;">&#x00A0;</div>
    E.g. to extract the first attachment to a file named 'out.ttf':
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -dump_attachment:t:0 out.ttf -i INPUT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    To extract all attachments to files determined by the &quot;filename&quot;
      tag:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -dump_attachment:t &quot;&quot; -i INPUT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Technical note -- attachments are implemented as codec extradata, so this
      option can actually be used to extract extradata from any stream, not just
      attachments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-noautorotate</b></dt>
  <dd class="It-tag">Disable automatically rotating video based on file
      metadata.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Video_Options"><a class="selflink" href="#Video_Options">Video
  Options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vframes</b> <i>number</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set the number of video frames to output. This is an alias
      for &quot;-frames:v&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r[:</b><i>stream_specifier</i><b>]</b> <i>fps</i>
    <b>(</b> <i>input/output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Set frame rate (Hz value, fraction or abbreviation).
    <div style="height: 1.00em;">&#x00A0;</div>
    As an input option, ignore any timestamps stored in the file and instead
      generate timestamps assuming constant frame rate <i>fps</i>. This is not
      the same as the <b>-framerate</b> option used for some input formats like
      image2 or v4l2 (it used to be the same in older versions of FFmpeg). If in
      doubt use <b>-framerate</b> instead of the input option <b>-r</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    As an output option, duplicate or drop input frames to achieve constant
      output frame rate <i>fps</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s[:</b><i>stream_specifier</i><b>]</b> <i>size</i>
    <b>(</b> <i>input/output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Set frame size.
    <div style="height: 1.00em;">&#x00A0;</div>
    As an input option, this is a shortcut for the <b>video_size</b> private
      option, recognized by some demuxers for which the frame size is either not
      stored in the file or is configurable -- e.g. raw video or video grabbers.
    <div style="height: 1.00em;">&#x00A0;</div>
    As an output option, this inserts the &quot;scale&quot; video filter to the
      <i>end</i> of the corresponding filtergraph. Please use the
      &quot;scale&quot; filter directly to insert it at the beginning or some
      other place.
    <div style="height: 1.00em;">&#x00A0;</div>
    The format is <b>wxh</b> (default - same as source).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-aspect[:</b><i>stream_specifier</i><b>]</b>
    <i>aspect</i> <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Set the video display aspect ratio specified by
      <i>aspect</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>aspect</i> can be a floating point number string, or a string of the
      form <i>num</i>:<i>den</i>, where <i>num</i> and <i>den</i> are the
      numerator and denominator of the aspect ratio. For example
      &quot;4:3&quot;, &quot;16:9&quot;, &quot;1.3333&quot;, and
      &quot;1.7777&quot; are valid argument values.
    <div style="height: 1.00em;">&#x00A0;</div>
    If used together with <b>-vcodec copy</b>, it will affect the aspect ratio
      stored at container level, but not the aspect ratio stored in encoded
      frames, if it exists.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vn (</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Disable video recording.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vcodec</b> <i>codec</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set the video codec. This is an alias for
      &quot;-codec:v&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-pass[:</b><i>stream_specifier</i><b>]</b> <i>n</i>
    <b>(</b> <i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Select the pass number (1 or 2). It is used to do two-pass
      video encoding. The statistics of the video are recorded in the first pass
      into a log file (see also the option -passlogfile), and in the second pass
      that log file is used to generate the video at the exact requested
      bitrate. On pass 1, you may just deactivate audio and set output to null,
      examples for Windows and Unix:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y NUL
        ffmpeg -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y /dev/null
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-passlogfile[:</b><i>stream_specifier</i><b>]</b>
    <i>prefix</i> <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Set two-pass log file name prefix to <i>prefix</i>, the
      default file name prefix is ``ffmpeg2pass''. The complete file name will
      be <i>PREFIX-N.log</i>, where N is a number specific to the output
    stream</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vf</b> <i>filtergraph</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Create the filtergraph specified by <i>filtergraph</i> and
      use it to filter the stream.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is an alias for &quot;-filter:v&quot;, see the <b>-filter
    option</b>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Advanced_Video_options"><a class="selflink" href="#Advanced_Video_options">Advanced
  Video options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-pix_fmt[:</b><i>stream_specifier</i><b>]</b>
    <i>format</i> <b>(</b><i>input/output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Set pixel format. Use &quot;-pix_fmts&quot; to show all the
      supported pixel formats. If the selected pixel format can not be selected,
      ffmpeg will print a warning and select the best pixel format supported by
      the encoder. If <i>pix_fmt</i> is prefixed by a &quot;+&quot;, ffmpeg will
      exit with an error if the requested pixel format can not be selected, and
      automatic conversions inside filtergraphs are disabled. If <i>pix_fmt</i>
      is a single &quot;+&quot;, ffmpeg selects the same pixel format as the
      input (or graph output) and automatic conversions are disabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sws_flags</b> <i>flags</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">Set SwScaler flags.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vdt</b> <i>n</i></dt>
  <dd class="It-tag">Discard threshold.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-rc_override[:</b><i>stream_specifier</i><b>]</b>
    <i>override</i> <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Rate control override for specific intervals, formatted as
      &quot;int,int,int&quot; list separated with slashes. Two first values are
      the beginning and end frame numbers, last one is quantizer to use if
      positive, or quality factor if negative.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ilme</b></dt>
  <dd class="It-tag">Force interlacing support in encoder (MPEG-2 and MPEG-4
      only). Use this option if your input file is interlaced and you want to
      keep the interlaced format for minimum losses. The alternative is to
      deinterlace the input stream with <b>-deinterlace</b>, but deinterlacing
      introduces losses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-psnr</b></dt>
  <dd class="It-tag">Calculate PSNR of compressed frames.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vstats</b></dt>
  <dd class="It-tag">Dump video coding statistics to
    <i>vstats_HHMMSS.log</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vstats_file</b> <i>file</i></dt>
  <dd class="It-tag">Dump video coding statistics to <i>file</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-top[:</b><i>stream_specifier</i><b>]</b> <i>n</i>
    <b>(</b> <i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">top=1/bottom=0/auto=-1 field first</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-dc</b> <i>precision</i></dt>
  <dd class="It-tag">Intra_dc_precision.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vtag</b> <i>fourcc/tag</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Force video tag/fourcc. This is an alias for
      &quot;-tag:v&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-qphist (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Show QP histogram</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vbsf</b> <i>bitstream_filter</i></dt>
  <dd class="It-tag">Deprecated see -bsf</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-force_key_frames[:</b><i>stream_specifier</i><b>]</b>
    <i>time</i><b>[,</b><i>time</i><b>...]
    (</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-force_key_frames[:</b><i>stream_specifier</i><b>]
    expr:</b> <i>expr</i> <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Force key frames at the specified timestamps, more
      precisely at the first frames after each specified time.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the argument is prefixed with &quot;expr:&quot;, the string <i>expr</i>
      is interpreted like an expression and is evaluated for each frame. A key
      frame is forced in case the evaluation is non-zero.
    <div style="height: 1.00em;">&#x00A0;</div>
    If one of the times is &quot;&quot;chapters&quot;[ <i>delta</i>]&quot;, it
      is expanded into the time of the beginning of all chapters in the file,
      shifted by <i>delta</i>, expressed as a time in seconds. This option can
      be useful to ensure that a seek point is present at a chapter mark or any
      other designated place in the output file.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, to insert a key frame at 5 minutes, plus key frames 0.1 second
      before the beginning of every chapter:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        -force_key_frames 0:05:00,chapters-0.1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The expression in <i>expr</i> can contain the following constants:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>n</b></dt>
  <dd class="It-tag">the number of current processed frame, starting from 0</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>n_forced</b></dt>
  <dd class="It-tag">the number of forced frames</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>prev_forced_n</b></dt>
  <dd class="It-tag">the number of the previous forced frame, it is
      &quot;NAN&quot; when no keyframe was forced yet</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>prev_forced_t</b></dt>
  <dd class="It-tag">the time of the previous forced frame, it is
      &quot;NAN&quot; when no keyframe was forced yet</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>t</b></dt>
  <dd class="It-tag">the time of the current processed frame</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
For example to force a key frame every 5 seconds, you can specify:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        -force_key_frames expr:gte(t,n_forced*5)
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
To force a key frame 5 seconds after the time of the last forced one, starting
  from second 13:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        -force_key_frames expr:if(isnan(prev_forced_t),gte(t,13),gte(t,prev_forced_t+5))
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Note that forcing too many keyframes is very harmful for the lookahead
  algorithms of certain encoders: using fixed-GOP options or similar would be
  more efficient.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-copyinkf[:</b><i>stream_specifier</i><b>]
    (</b><i>output,per-stream</i> <b>)</b></dt>
  <dd class="It-tag">When doing stream copy, copy also non-key frames found at
      the beginning.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hwaccel[:</b><i>stream_specifier</i><b>]</b>
    <i>hwaccel</i> <b>(</b><i>input,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Use hardware acceleration to decode the matching stream(s).
      The allowed values of <i>hwaccel</i> are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>none</b></dt>
  <dd class="It-tag">Do not use any hardware acceleration (the default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>auto</b></dt>
  <dd class="It-tag">Automatically select the hardware acceleration method.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vda</b></dt>
  <dd class="It-tag">Use Apple VDA hardware acceleration.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vdpau</b></dt>
  <dd class="It-tag">Use VDPAU (Video Decode and Presentation API for Unix)
      hardware acceleration.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dxva2</b></dt>
  <dd class="It-tag">Use DXVA2 (DirectX Video Acceleration) hardware
      acceleration.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>qsv</b></dt>
  <dd class="It-tag">Use the Intel QuickSync Video acceleration for video
      transcoding.
    <div style="height: 1.00em;">&#x00A0;</div>
    Unlike most other values, this option does not enable accelerated decoding
      (that is used automatically whenever a qsv decoder is selected), but
      accelerated transcoding, without copying the frames into the system
      memory.
    <div style="height: 1.00em;">&#x00A0;</div>
    For it to work, both the decoder and the encoder must support QSV
      acceleration and no filters must be used.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
This option has no effect if the selected hwaccel is not available or not
  supported by the chosen decoder.
<div style="height: 1.00em;">&#x00A0;</div>
Note that most acceleration methods are intended for playback and will not be
  faster than software decoding on modern CPUs. Additionally, <b>ffmpeg</b> will
  usually need to copy the decoded frames from the GPU memory into the system
  memory, resulting in further performance loss. This option is thus mainly
  useful for testing.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hwaccel_device[:</b><i>stream_specifier</i><b>]</b>
    <i>hwaccel_device</i> <b>(</b><i>input,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Select a device to use for hardware acceleration.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option only makes sense when the <b>-hwaccel</b> option is also
      specified. Its exact meaning depends on the specific hardware acceleration
      method chosen.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>vdpau</b></dt>
  <dd class="It-tag">For VDPAU, this option specifies the X11 display/screen to
      use. If this option is not specified, the value of the <i>DISPLAY</i>
      environment variable is used</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dxva2</b></dt>
  <dd class="It-tag">For DXVA2, this option should contain the number of the
      display adapter to use. If this option is not specified, the default
      adapter is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>qsv</b></dt>
  <dd class="It-tag">For QSV, this option corresponds to the values of
      MFX_IMPL_* . Allowed values are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>auto</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sw</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hw</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>auto_any</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hw_any</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hw2</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hw3</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hw4</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hwaccels</b></dt>
  <dd class="It-tag">List all hardware acceleration methods supported in this
      build of ffmpeg.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Audio_Options"><a class="selflink" href="#Audio_Options">Audio
  Options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-aframes</b> <i>number</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set the number of audio frames to output. This is an alias
      for &quot;-frames:a&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ar[:</b><i>stream_specifier</i><b>]</b> <i>freq</i>
    <b>(</b> <i>input/output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Set the audio sampling frequency. For output streams it is
      set by default to the frequency of the corresponding input stream. For
      input streams this option only makes sense for audio grabbing devices and
      raw demuxers and is mapped to the corresponding demuxer options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-aq</b> <i>q</i> <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set the audio quality (codec-specific, VBR). This is an
      alias for -q:a.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ac[:</b><i>stream_specifier</i><b>]</b> <i>channels</i>
    <b>(</b><i>input/output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Set the number of audio channels. For output streams it is
      set by default to the number of input audio channels. For input streams
      this option only makes sense for audio grabbing devices and raw demuxers
      and is mapped to the corresponding demuxer options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-an (</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Disable audio recording.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-acodec</b> <i>codec</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">Set the audio codec. This is an alias for
      &quot;-codec:a&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sample_fmt[:</b><i>stream_specifier</i><b>]</b>
    <i>sample_fmt</i> <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Set the audio sample format. Use &quot;-sample_fmts&quot;
      to get a list of supported sample formats.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-af</b> <i>filtergraph</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Create the filtergraph specified by <i>filtergraph</i> and
      use it to filter the stream.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is an alias for &quot;-filter:a&quot;, see the <b>-filter
    option</b>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Advanced_Audio_options"><a class="selflink" href="#Advanced_Audio_options">Advanced
  Audio options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-atag</b> <i>fourcc/tag</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Force audio tag/fourcc. This is an alias for
      &quot;-tag:a&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-absf</b> <i>bitstream_filter</i></dt>
  <dd class="It-tag">Deprecated, see -bsf</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-guess_layout_max</b> <i>channels</i>
    <b>(</b><i>input,per-stream</i> <b>)</b></dt>
  <dd class="It-tag">If some input channel layout is not known, try to guess
      only if it corresponds to at most the specified number of channels. For
      example, 2 tells to <b>ffmpeg</b> to recognize 1 channel as mono and 2
      channels as stereo but not 6 channels as 5.1. The default is to always try
      to guess. Use 0 to disable all guessing.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Subtitle_options"><a class="selflink" href="#Subtitle_options">Subtitle
  options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-scodec</b> <i>codec</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">Set the subtitle codec. This is an alias for
      &quot;-codec:s&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sn (</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Disable subtitle recording.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sbsf</b> <i>bitstream_filter</i></dt>
  <dd class="It-tag">Deprecated, see -bsf</dd>
</dl>
<h2 class="Ss" title="Ss" id="Advanced_Subtitle_options"><a class="selflink" href="#Advanced_Subtitle_options">Advanced
  Subtitle options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-fix_sub_duration</b></dt>
  <dd class="It-tag">Fix subtitles durations. For each subtitle, wait for the
      next packet in the same stream and adjust the duration of the first to
      avoid overlap. This is necessary with some subtitles codecs, especially
      DVB subtitles, because the duration in the original packet is only a rough
      estimate and the end is actually marked by an empty subtitle frame.
      Failing to use this option when necessary can result in exaggerated
      durations or muxing failures due to non-monotonic timestamps.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that this option will delay the output of all data until the next
      subtitle packet is decoded: it may increase memory consumption and latency
      a lot.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-canvas_size</b> <i>size</i></dt>
  <dd class="It-tag">Set the size of the canvas used to render subtitles.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Advanced_options"><a class="selflink" href="#Advanced_options">Advanced
  options</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-map
    [-]</b><i>input_file_id</i><b>[:</b><i>stream_specifier</i>
    <b>][,</b><i>sync_file_id</i> <b>[:</b><i>stream_specifier</i><b>]] |</b>
    <i>[linklabel]</i> <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Designate one or more input streams as a source for the
      output file. Each input stream is identified by the input file index
      <i>input_file_id</i> and the input stream index <i>input_stream_id</i>
      within the input file. Both indices start at 0. If specified,
      <i>sync_file_id</i>: <i>stream_specifier</i> sets which input stream is
      used as a presentation sync reference.
    <div style="height: 1.00em;">&#x00A0;</div>
    The first &quot;-map&quot; option on the command line specifies the source
      for output stream 0, the second &quot;-map&quot; option specifies the
      source for output stream 1, etc.
    <div style="height: 1.00em;">&#x00A0;</div>
    A &quot;-&quot; character before the stream identifier creates a
      &quot;negative&quot; mapping. It disables matching streams from already
      created mappings.
    <div style="height: 1.00em;">&#x00A0;</div>
    An alternative <i>[linklabel]</i> form will map outputs from complex filter
      graphs (see the <b>-filter_complex</b> option) to the output file.
      <i>linklabel</i> must correspond to a defined output link label in the
      graph.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, to map ALL streams from the first input file to output
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -map 0 output
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, if you have two audio streams in the first input file, these
      streams are identified by &quot;0:0&quot; and &quot;0:1&quot;. You can use
      &quot;-map&quot; to select which streams to place in an output file. For
      example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -map 0:1 out.wav
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will map the input stream in <i>INPUT</i> identified by &quot;0:1&quot; to
      the (single) output stream in <i>out.wav</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, to select the stream with index 2 from input file <i>a.mov</i>
      (specified by the identifier &quot;0:2&quot;), and stream with index 6
      from input <i>b.mov</i> (specified by the identifier &quot;1:6&quot;), and
      copy them to the output file <i>out.mov</i>:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i a.mov -i b.mov -c copy -map 0:2 -map 1:6 out.mov
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    To select all video and the third audio stream from an input file:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -map 0:v -map 0:a:2 OUTPUT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    To map all the streams except the second audio, use negative mappings
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -map 0 -map -0:a:1 OUTPUT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    To pick the English audio stream:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -map 0:m:language:eng OUTPUT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that using this option disables the default mappings for this output
      file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ignore_unknown</b></dt>
  <dd class="It-tag">Ignore input streams with unknown type instead of failing
      if copying such streams is attempted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-copy_unknown</b></dt>
  <dd class="It-tag">Allow input streams with unknown type to be copied instead
      of failing if copying such streams is attempted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-map_channel
    [</b><i>input_file_id</i><b>.</b><i>stream_specifier</i>
    <b>.</b><i>channel_id</i>
    <b>|-1][:</b><i>output_file_id</i><b>.</b><i>stream_specifier</i>
    <b>]</b></dt>
  <dd class="It-tag">Map an audio channel from a given input to an output. If
      <i>output_file_id</i>.<i>stream_specifier</i> is not set, the audio
      channel will be mapped on all the audio streams.
    <div style="height: 1.00em;">&#x00A0;</div>
    Using &quot;-1&quot; instead of
      <i>input_file_id</i>.<i>stream_specifier</i>. <i>channel_id</i> will map a
      muted channel.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, assuming <i>INPUT</i> is a stereo audio file, you can switch
      the two audio channels with the following command:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -map_channel 0.0.1 -map_channel 0.0.0 OUTPUT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you want to mute the first channel and keep the second:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -map_channel -1 -map_channel 0.0.1 OUTPUT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The order of the &quot;-map_channel&quot; option specifies the order of the
      channels in the output stream. The output channel layout is guessed from
      the number of channels mapped (mono if one &quot;-map_channel&quot;,
      stereo if two, etc.). Using &quot;-ac&quot; in combination of
      &quot;-map_channel&quot; makes the channel gain levels to be updated if
      input and output channel layouts don't match (for instance two
      &quot;-map_channel&quot; options and &quot;-ac 6&quot;).
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also extract each channel of an input to specific outputs; the
      following command extracts two channels of the <i>INPUT</i> audio stream
      (file 0, stream 0) to the respective <i>OUTPUT_CH0</i> and
      <i>OUTPUT_CH1</i> outputs:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i INPUT -map_channel 0.0.0 OUTPUT_CH0 -map_channel 0.0.1 OUTPUT_CH1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The following example splits the channels of a stereo input into two
      separate streams, which are put into the same output file:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i stereo.wav -map 0:0 -map 0:0 -map_channel 0.0.0:0.0 -map_channel 0.0.1:0.1 -y out.ogg
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that currently each output stream can only contain channels from a
      single input stream; you can't for example use &quot;-map_channel&quot; to
      pick multiple input audio channels contained in different streams (from
      the same or different files) and merge them into a single output stream.
      It is therefore not currently possible, for example, to turn two separate
      mono streams into a single stereo stream. However splitting a stereo
      stream into two single channel mono streams is possible.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you need this feature, a possible workaround is to use the <i>amerge</i>
      filter. For example, if you need to merge a media (here <i>input.mkv</i>)
      with 2 mono audio streams into one single stereo channel audio stream (and
      keep the video stream), you can use the following command:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i input.mkv -filter_complex &quot;[0:1] [0:2] amerge&quot; -c:a pcm_s16le -c:v copy output.mkv
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-map_metadata[:</b><i>metadata_spec_out</i><b>]</b>
    <i>infile</i> <b>[:</b><i>metadata_spec_in</i><b>]
    (</b><i>output,per-metadata</i> <b>)</b></dt>
  <dd class="It-tag">Set metadata information of the next output file from
      <i>infile</i>. Note that those are file indices (zero-based), not
      filenames. Optional <i>metadata_spec_in/out</i> parameters specify, which
      metadata to copy. A metadata specifier can have the following forms:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>g</i></dt>
  <dd class="It-tag">global metadata, i.e. metadata that applies to the whole
      file</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>s</i><b>[:</b><i>stream_spec</i><b>]</b></dt>
  <dd class="It-tag">per-stream metadata. <i>stream_spec</i> is a stream
      specifier as described in the <b>Stream specifiers</b> chapter. In an
      input metadata specifier, the first matching stream is copied from. In an
      output metadata specifier, all matching streams are copied to.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>c</i><b>:</b><i>chapter_index</i></dt>
  <dd class="It-tag">per-chapter metadata. <i>chapter_index</i> is the
      zero-based chapter index.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>p</i><b>:</b><i>program_index</i></dt>
  <dd class="It-tag">per-program metadata. <i>program_index</i> is the
      zero-based program index.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
If metadata specifier is omitted, it defaults to global.
<div style="height: 1.00em;">&#x00A0;</div>
By default, global metadata is copied from the first input file, per-stream and
  per-chapter metadata is copied along with streams/chapters. These default
  mappings are disabled by creating any mapping of the relevant type. A negative
  file index can be used to create a dummy mapping that just disables automatic
  copying.
<div style="height: 1.00em;">&#x00A0;</div>
For example to copy metadata from the first stream of the input file to global
  metadata of the output file:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        ffmpeg -i in.ogg -map_metadata 0:s:0 out.mp3
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
To do the reverse, i.e. copy global metadata to all audio streams:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        ffmpeg -i in.mkv -map_metadata:s:a 0:g out.mkv
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Note that simple 0 would work as well in this example, since global metadata is
  assumed by default.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-map_chapters</b> <i>input_file_index</i>
    <b>(</b><i>output</i> <b>)</b></dt>
  <dd class="It-tag">Copy chapters from input file with index
      <i>input_file_index</i> to the next output file. If no chapter mapping is
      specified, then chapters are copied from the first input file with at
      least one chapter. Use a negative file index to disable any chapter
      copying.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-benchmark (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Show benchmarking information at the end of an encode.
      Shows CPU time used and maximum memory consumption. Maximum memory
      consumption is not supported on all systems, it will usually display as 0
      if not supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-benchmark_all (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Show benchmarking information during the encode. Shows CPU
      time used in various steps (audio/video encode/decode).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-timelimit</b> <i>duration</i>
    <b>(</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Exit after ffmpeg has been running for <i>duration</i>
      seconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-dump (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Dump each input packet to stderr.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hex (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">When dumping packets, also dump the payload.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-re (</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Read input at native frame rate. Mainly used to simulate a
      grab device, or live input stream (e.g. when reading from a file). Should
      not be used with actual grab devices or live input streams (where it can
      cause packet loss). By default <b>ffmpeg</b> attempts to read the input(s)
      as fast as possible. This option will slow down the reading of the
      input(s) to the native frame rate of the input(s). It is useful for
      real-time output (e.g. live streaming).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-loop_input</b></dt>
  <dd class="It-tag">Loop over the input stream. Currently it works only for
      image streams. This option is used for automatic FFserver testing. This
      option is deprecated, use -loop 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-loop_output</b> <i>number_of_times</i></dt>
  <dd class="It-tag">Repeatedly loop output for formats that support looping
      such as animated GIF (0 will loop the output infinitely). This option is
      deprecated, use -loop.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vsync</b> <i>parameter</i></dt>
  <dd class="It-tag">Video sync method. For compatibility reasons old values can
      be specified as numbers. Newly added values will have to be specified as
      strings always.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>0, passthrough</b></dt>
  <dd class="It-tag">Each frame is passed with its timestamp from the demuxer to
      the muxer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>1, cfr</b></dt>
  <dd class="It-tag">Frames will be duplicated and dropped to achieve exactly
      the requested constant frame rate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>2, vfr</b></dt>
  <dd class="It-tag">Frames are passed through with their timestamp or dropped
      so as to prevent 2 frames from having the same timestamp.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>drop</b></dt>
  <dd class="It-tag">As passthrough but destroys all timestamps, making the
      muxer generate fresh timestamps based on frame-rate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-1, auto</b></dt>
  <dd class="It-tag">Chooses between 1 and 2 depending on muxer capabilities.
      This is the default method.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Note that the timestamps may be further modified by the muxer, after this. For
  example, in the case that the format option <b>avoid_negative_ts</b> is
  enabled.
<div style="height: 1.00em;">&#x00A0;</div>
With -map you can select from which stream the timestamps should be taken. You
  can leave either video or audio unchanged and sync the remaining stream(s) to
  the unchanged one.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-frame_drop_threshold</b> <i>parameter</i></dt>
  <dd class="It-tag">Frame drop threshold, which specifies how much behind video
      frames can be before they are dropped. In frame rate units, so 1.0 is one
      frame. The default is -1.1. One possible usecase is to avoid framedrops in
      case of noisy timestamps or to increase frame drop precision in case of
      exact timestamps.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-async</b> <i>samples_per_second</i></dt>
  <dd class="It-tag">Audio sync method. &quot;Stretches/squeezes&quot; the audio
      stream to match the timestamps, the parameter is the maximum samples per
      second by which the audio is changed. -async 1 is a special case where
      only the start of the audio stream is corrected without any later
      correction.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the timestamps may be further modified by the muxer, after this.
      For example, in the case that the format option <b>avoid_negative_ts</b>
      is enabled.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option has been deprecated. Use the &quot;aresample&quot; audio filter
      instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-copyts</b></dt>
  <dd class="It-tag">Do not process input timestamps, but keep their values
      without trying to sanitize them. In particular, do not remove the initial
      start time offset value.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that, depending on the <b>vsync</b> option or on specific muxer
      processing (e.g. in case the format option <b>avoid_negative_ts</b> is
      enabled) the output timestamps may mismatch with the input timestamps even
      when this option is selected.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-start_at_zero</b></dt>
  <dd class="It-tag">When used with <b>copyts</b>, shift input timestamps so
      they start at zero.
    <div style="height: 1.00em;">&#x00A0;</div>
    This means that using e.g. &quot;-ss 50&quot; will make output timestamps
      start at 50 seconds, regardless of what timestamp the input file started
      at.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-copytb</b> <i>mode</i></dt>
  <dd class="It-tag">Specify how to set the encoder timebase when stream
      copying. <i>mode</i> is an integer numeric value, and can assume one of
      the following values:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>1</b></dt>
  <dd class="It-tag">Use the demuxer timebase.
    <div style="height: 1.00em;">&#x00A0;</div>
    The time base is copied to the output encoder from the corresponding input
      demuxer. This is sometimes required to avoid non monotonically increasing
      timestamps when copying video streams with variable frame rate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>0</b></dt>
  <dd class="It-tag">Use the decoder timebase.
    <div style="height: 1.00em;">&#x00A0;</div>
    The time base is copied to the output encoder from the corresponding input
      decoder.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-1</b></dt>
  <dd class="It-tag">Try to make the choice automatically, in order to generate
      a sane output.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Default value is -1.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-shortest (</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Finish encoding when the shortest input stream ends.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-dts_delta_threshold</b></dt>
  <dd class="It-tag">Timestamp discontinuity delta threshold.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-muxdelay</b> <i>seconds</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Set the maximum demux-decode delay.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-muxpreload</b> <i>seconds</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Set the initial demux-decode delay.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-streamid</b>
    <i>output-stream-index</i><b>:</b><i>new-value</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Assign a new stream-id value to an output stream. This
      option should be specified prior to the output filename to which it
      applies. For the situation where multiple output files exist, a streamid
      may be reassigned to a different value.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, to set the stream 0 PID to 33 and the stream 1 PID to 36 for an
      output mpegts file:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i inurl -streamid 0:33 -streamid 1:36 out.ts
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bsf[:</b><i>stream_specifier</i><b>]</b>
    <i>bitstream_filters</i> <b>(</b><i>output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Set bitstream filters for matching streams.
      <i>bitstream_filters</i> is a comma-separated list of bitstream filters.
      Use the &quot;-bsfs&quot; option to get the list of bitstream filters.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i h264.mp4 -c:v copy -bsf:v h264_mp4toannexb -an out.h264
        
        ffmpeg -i file.mov -an -vn -bsf:s mov2textsub -c:s copy -f rawvideo sub.txt
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-tag[:</b><i>stream_specifier</i><b>]</b>
    <i>codec_tag</i> <b>(</b><i>input/output,per-stream</i><b>)</b></dt>
  <dd class="It-tag">Force a tag/fourcc for matching streams.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-timecode</b>
    <i>hh</i><b>:</b><i>mm</i><b>:</b><i>ss</i> <b>SEP</b><i>ff</i></dt>
  <dd class="It-tag">Specify Timecode for writing. <i>SEP</i> is ':' for non
      drop timecode and ';' (or '.') for drop.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i input.mpg -timecode 01:02:03.04 -r 30000/1001 -s ntsc output.mpg
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-filter_complex</b> <i>filtergraph</i>
    <b>(</b><i>global</i> <b>)</b></dt>
  <dd class="It-tag">Define a complex filtergraph, i.e. one with arbitrary
      number of inputs and/or outputs. For simple graphs -- those with one input
      and one output of the same type -- see the <b>-filter</b> options.
      <i>filtergraph</i> is a description of the filtergraph, as described in
      the ``Filtergraph syntax'' section of the ffmpeg-filters manual.
    <div style="height: 1.00em;">&#x00A0;</div>
    Input link labels must refer to input streams using the
      &quot;[file_index:stream_specifier]&quot; syntax (i.e. the same as
      <b>-map</b> uses). If <i>stream_specifier</i> matches multiple streams,
      the first one will be used. An unlabeled input will be connected to the
      first unused input stream of the matching type.
    <div style="height: 1.00em;">&#x00A0;</div>
    Output link labels are referred to with <b>-map</b>. Unlabeled outputs are
      added to the first output file.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that with this option it is possible to use only lavfi sources without
      normal input files.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, to overlay an image over video
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i video.mkv -i image.png -filter_complex '[0:v][1:v]overlay[out]' -map
        '[out]' out.mkv
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Here &quot;[0:v]&quot; refers to the first video stream in the first input
      file, which is linked to the first (main) input of the overlay filter.
      Similarly the first video stream in the second input is linked to the
      second (overlay) input of overlay.
    <div style="height: 1.00em;">&#x00A0;</div>
    Assuming there is only one video stream in each input file, we can omit
      input labels, so the above is equivalent to
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i video.mkv -i image.png -filter_complex 'overlay[out]' -map
        '[out]' out.mkv
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Furthermore we can omit the output label and the single output from the
      filter graph will be added to the output file automatically, so we can
      simply write
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i video.mkv -i image.png -filter_complex 'overlay' out.mkv
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    To generate 5 seconds of pure red video using lavfi &quot;color&quot;
      source:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -filter_complex 'color=c=red' -t 5 out.mkv
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-lavfi</b> <i>filtergraph</i>
    <b>(</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Define a complex filtergraph, i.e. one with arbitrary
      number of inputs and/or outputs. Equivalent to
    <b>-filter_complex</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-filter_complex_script</b> <i>filename</i>
    <b>(</b><i>global</i> <b>)</b></dt>
  <dd class="It-tag">This option is similar to <b>-filter_complex</b>, the only
      difference is that its argument is the name of the file from which a
      complex filtergraph description is to be read.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-accurate_seek (</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">This option enables or disables accurate seeking in input
      files with the <b>-ss</b> option. It is enabled by default, so seeking is
      accurate when transcoding. Use <b>-noaccurate_seek</b> to disable it,
      which may be useful e.g. when copying some streams and transcoding the
      others.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-seek_timestamp (</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">This option enables or disables seeking by timestamp in
      input files with the <b>-ss</b> option. It is disabled by default. If
      enabled, the argument to the <b>-ss</b> option is considered an actual
      timestamp, and is not offset by the start time of the file. This matters
      only for files which do not start from timestamp 0, such as transport
      streams.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-thread_queue_size</b> <i>size</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">This option sets the maximum number of queued packets when
      reading from the file or device. With low latency / high rate live
      streams, packets may be discarded if they are not read in a timely manner;
      raising this value can avoid it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-override_ffserver (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Overrides the input specifications from <b>ffserver</b>.
      Using this option you can map any input stream to <b>ffserver</b> and
      control many aspects of the encoding from <b>ffmpeg</b>. Without this
      option <b>ffmpeg</b> will transmit to <b>ffserver</b> what is requested by
      <b>ffserver</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The option is intended for cases where features are needed that cannot be
      specified to <b>ffserver</b> but can be to <b>ffmpeg</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sdp_file</b> <i>file</i>
    <b>(</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Print sdp information for an output stream to <i>file</i>.
      This allows dumping sdp information when at least one output isn't an rtp
      stream. (Requires at least one of the output formats to be rtp).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-discard (</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Allows discarding specific streams or frames of streams at
      the demuxer. Not all demuxers support this.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>none</b></dt>
  <dd class="It-tag">Discard no frame.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>default</b></dt>
  <dd class="It-tag">Default, which discards no frames.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>noref</b></dt>
  <dd class="It-tag">Discard all non-reference frames.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bidir</b></dt>
  <dd class="It-tag">Discard all bidirectional frames.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nokey</b></dt>
  <dd class="It-tag">Discard all frames excepts keyframes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>all</b></dt>
  <dd class="It-tag">Discard all frames.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-abort_on</b> <i>flags</i>
    <b>(</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Stop and abort on various conditions. The following flags
      are available:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>empty_output</b></dt>
  <dd class="It-tag">No packets were passed to the muxer, the output is
    empty.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-xerror (</b><i>global</i><b>)</b></dt>
  <dd class="It-tag">Stop and exit on error</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-max_muxing_queue_size</b> <i>packets</i>
    <b>(</b><i>output,per-stream</i> <b>)</b></dt>
  <dd class="It-tag">When transcoding audio and/or video streams, ffmpeg will
      not begin writing into the output until it has one packet for each such
      stream. While waiting for that to happen, packets for other streams are
      buffered. This option sets the size of this buffer, in packets, for the
      matching output stream.
    <div style="height: 1.00em;">&#x00A0;</div>
    The default value of this option should be high enough for most uses, so
      only touch this option if you are sure that you need it.</dd>
</dl>
<div class="Pp"></div>
As a special exception, you can use a bitmap subtitle stream as input: it will
  be converted into a video with the same size as the largest video in the file,
  or 720x576 if no video is present. Note that this is an experimental and
  temporary solution. It will be removed once libavfilter has proper support for
  subtitles.
<div class="Pp"></div>
For example, to hardcode subtitles on top of a DVB-T recording stored in MPEG-TS
  format, delaying the subtitles by 1 second:
<div class="Pp"></div>
<pre>
        ffmpeg -i input.ts -filter_complex \
          '[#0x2ef] setpts=PTS+1/TB [sub] ; [#0x2d0] [sub] overlay' \
          -sn -map '#0x2dc' output.mkv
</pre>
<div class="Pp"></div>
(0x2d0, 0x2dc and 0x2ef are the MPEG-TS PIDs of respectively the video, audio
  and subtitles streams; 0:0, 0:3 and 0:7 would have worked too)
<h2 class="Ss" title="Ss" id="Preset_files"><a class="selflink" href="#Preset_files">Preset
  files</a></h2>
A preset file contains a sequence of <i>option</i>=<i>value</i> pairs, one for
  each line, specifying a sequence of options which would be awkward to specify
  on the command line. Lines starting with the hash ('#') character are ignored
  and are used to provide comments. Check the <i>presets</i> directory in the
  FFmpeg source tree for examples.
<div class="Pp"></div>
There are two types of preset files: ffpreset and avpreset files.
<div class="Pp"></div>
<i>ffpreset files</i>
<div class="Pp"></div>
ffpreset files are specified with the &quot;vpre&quot;, &quot;apre&quot;,
  &quot;spre&quot;, and &quot;fpre&quot; options. The &quot;fpre&quot; option
  takes the filename of the preset instead of a preset name as input and can be
  used for any kind of codec. For the &quot;vpre&quot;, &quot;apre&quot;, and
  &quot;spre&quot; options, the options specified in a preset file are applied
  to the currently selected codec of the same type as the preset option.
<div class="Pp"></div>
The argument passed to the &quot;vpre&quot;, &quot;apre&quot;, and
  &quot;spre&quot; preset options identifies the preset file to use according to
  the following rules:
<div class="Pp"></div>
First ffmpeg searches for a file named <i>arg</i>.ffpreset in the directories
  <i></i><i>$FFMPEG_DATADIR</i><i></i> (if set), and
  <i></i><i>$HOME</i><i>/.ffmpeg</i>, and in the datadir defined at
  configuration time (usually <i>PREFIX/share/ffmpeg</i>) or in a
  <i>ffpresets</i> folder along the executable on win32, in that order. For
  example, if the argument is &quot;libvpx-1080p&quot;, it will search for the
  file <i>libvpx-1080p.ffpreset</i>.
<div class="Pp"></div>
If no such file is found, then ffmpeg will search for a file named
  <i>codec_name</i>- <i>arg</i>.ffpreset in the above-mentioned directories,
  where <i>codec_name</i> is the name of the codec to which the preset file
  options will be applied. For example, if you select the video codec with
  &quot;-vcodec libvpx&quot; and use &quot;-vpre 1080p&quot;, then it will
  search for the file <i>libvpx-1080p.ffpreset</i>.
<div class="Pp"></div>
<i>avpreset files</i>
<div class="Pp"></div>
avpreset files are specified with the &quot;pre&quot; option. They work similar
  to ffpreset files, but they only allow encoder- specific options. Therefore,
  an <i>option</i>=<i>value</i> pair specifying an encoder cannot be used.
<div class="Pp"></div>
When the &quot;pre&quot; option is specified, ffmpeg will look for files with
  the suffix .avpreset in the directories <i></i><i>$AVCONV_DATADIR</i><i></i>
  (if set), and <i></i><i>$HOME</i><i>/.avconv</i>, and in the datadir defined
  at configuration time (usually <i>PREFIX/share/ffmpeg</i>), in that order.
<div class="Pp"></div>
First ffmpeg searches for a file named <i>codec_name</i>-<i>arg</i>.avpreset in
  the above-mentioned directories, where <i>codec_name</i> is the name of the
  codec to which the preset file options will be applied. For example, if you
  select the video codec with &quot;-vcodec libvpx&quot; and use &quot;-pre
  1080p&quot;, then it will search for the file <i>libvpx-1080p.avpreset</i>.
<div class="Pp"></div>
If no such file is found, then ffmpeg will search for a file named
  <i>arg</i>.avpreset in the same directories.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<h2 class="Ss" title="Ss" id="Video_and_Audio_grabbing"><a class="selflink" href="#Video_and_Audio_grabbing">Video
  and Audio grabbing</a></h2>
If you specify the input format and device then ffmpeg can grab video and audio
  directly.
<div class="Pp"></div>
<pre>
        ffmpeg -f oss -i /dev/dsp -f video4linux2 -i /dev/video0 /tmp/out.mpg
</pre>
<div class="Pp"></div>
Or with an ALSA audio source (mono input, card id 1) instead of OSS:
<div class="Pp"></div>
<pre>
        ffmpeg -f alsa -ac 1 -i hw:1 -f video4linux2 -i /dev/video0 /tmp/out.mpg
</pre>
<div class="Pp"></div>
Note that you must activate the right video source and channel before launching
  ffmpeg with any TV viewer such as &lt;
  <b>http://linux.bytesex.org/xawtv/</b>&gt; by Gerd Knorr. You also have to set
  the audio recording levels correctly with a standard mixer.
<h2 class="Ss" title="Ss" id="X11_grabbing"><a class="selflink" href="#X11_grabbing">X11
  grabbing</a></h2>
Grab the X11 display with ffmpeg via
<div class="Pp"></div>
<pre>
        ffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0 /tmp/out.mpg
</pre>
<div class="Pp"></div>
0.0 is display.screen number of your X11 server, same as the DISPLAY environment
  variable.
<div class="Pp"></div>
<pre>
        ffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0+10,20 /tmp/out.mpg
</pre>
<div class="Pp"></div>
0.0 is display.screen number of your X11 server, same as the DISPLAY environment
  variable. 10 is the x-offset and 20 the y-offset for the grabbing.
<h2 class="Ss" title="Ss" id="Video_and_Audio_file_format_conversion"><a class="selflink" href="#Video_and_Audio_file_format_conversion">Video
  and Audio file format conversion</a></h2>
Any supported file format and protocol can serve as input to ffmpeg:
<div class="Pp"></div>
Examples:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can use YUV files as input:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i /tmp/test%d.Y /tmp/out.mpg
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    It will use the files:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        /tmp/test0.Y, /tmp/test0.U, /tmp/test0.V,
        /tmp/test1.Y, /tmp/test1.U, /tmp/test1.V, etc...
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The Y files use twice the resolution of the U and V files. They are raw
      files, without header. They can be generated by all decent video decoders.
      You must specify the size of the image with the <b>-s</b> option if ffmpeg
      cannot guess it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can input from a raw YUV420P file:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i /tmp/test.yuv /tmp/out.avi
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    test.yuv is a file containing raw YUV planar data. Each frame is composed of
      the Y plane followed by the U and V planes at half vertical and horizontal
      resolution.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can output to a raw YUV420P file:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i mydivx.avi hugefile.yuv
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can set several input files and output files:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i /tmp/a.wav -s 640x480 -i /tmp/a.yuv /tmp/a.mpg
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Converts the audio file a.wav and the raw YUV video file a.yuv to MPEG file
      a.mpg.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can also do audio and video conversions at the same
      time:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i /tmp/a.wav -ar 22050 /tmp/a.mp2
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Converts a.wav to MPEG audio at 22050 Hz sample rate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can encode to several formats at the same time and
      define a mapping from input stream to output streams:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i /tmp/a.wav -map 0:a -b:a 64k /tmp/a.mp2 -map 0:a -b:a 128k /tmp/b.mp2
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Converts a.wav to a.mp2 at 64 kbits and to b.mp2 at 128 kbits. '-map
      file:index' specifies which input stream is used for each output stream,
      in the order of the definition of output streams.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can transcode decrypted VOBs:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i snatch_1.vob -f avi -c:v mpeg4 -b:v 800k -g 300 -bf 2 -c:a libmp3lame -b:a 128k snatch.avi
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This is a typical DVD ripping example; the input is a VOB file, the output
      an AVI file with MPEG-4 video and MP3 audio. Note that in this command we
      use B-frames so the MPEG-4 stream is DivX5 compatible, and GOP size is 300
      which means one intra frame every 10 seconds for 29.97fps input video.
      Furthermore, the audio stream is MP3-encoded so you need to enable LAME
      support by passing &quot;--enable-libmp3lame&quot; to configure. The
      mapping is particularly useful for DVD transcoding to get the desired
      audio language.
    <div style="height: 1.00em;">&#x00A0;</div>
    NOTE: To see the supported input formats, use &quot;ffmpeg
    -formats&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can extract images from a video, or create a video from
      many images:
    <div style="height: 1.00em;">&#x00A0;</div>
    For extracting images from a video:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i foo.avi -r 1 -s WxH -f image2 foo-%03d.jpeg
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This will extract one video frame per second from the video and will output
      them in files named <i>foo-001.jpeg</i>, <i>foo-002.jpeg</i>, etc. Images
      will be rescaled to fit the new WxH values.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you want to extract just a limited number of frames, you can use the
      above command in combination with the -vframes or -t option, or in
      combination with -ss to start extracting from a certain point in time.
    <div style="height: 1.00em;">&#x00A0;</div>
    For creating a video from many images:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -f image2 -framerate 12 -i foo-%03d.jpeg -s WxH foo.avi
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The syntax &quot;foo-%03d.jpeg&quot; specifies to use a decimal number
      composed of three digits padded with zeroes to express the sequence
      number. It is the same syntax supported by the C printf function, but only
      formats accepting a normal integer are suitable.
    <div style="height: 1.00em;">&#x00A0;</div>
    When importing an image sequence, -i also supports expanding shell-like
      wildcard patterns (globbing) internally, by selecting the image2-specific
      &quot;-pattern_type glob&quot; option.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, for creating a video from filenames matching the glob pattern
      &quot;foo-*.jpeg&quot;:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -f image2 -pattern_type glob -framerate 12 -i 'foo-*.jpeg' -s WxH foo.avi
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can put many streams of the same type in the output:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i test1.avi -i test2.avi -map 1:1 -map 1:0 -map 0:1 -map 0:0 -c copy -y test12.nut
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The resulting output file <i>test12.nut</i> will contain the first four
      streams from the input files in reverse order.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">To force CBR video output:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i myfile.avi -b 4000k -minrate 4000k -maxrate 4000k -bufsize 1835k out.m2v
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The four options lmin, lmax, mblmin and mblmax use 'lambda'
      units, but you may use the QP2LAMBDA constant to easily convert from 'q'
      units:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i src.ext -lmax 21*QP2LAMBDA dst.ext
    </pre>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>ffmpeg-all</i>(1), <i>ffplay</i>(1), <i>ffprobe</i>(1), <i>ffserver</i>(1),
  <i>ffmpeg-utils</i>(1), <i>ffmpeg-scaler</i>(1), <i>ffmpeg-resampler</i>(1),
  <i>ffmpeg-codecs</i>(1), <i>ffmpeg-bitstream-filters</i>(1),
  <i>ffmpeg-formats</i>(1), <i>ffmpeg-devices</i>(1),
  <i>ffmpeg-protocols</i>(1), <i>ffmpeg-filters</i>(1)
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
The FFmpeg developers.
<div class="Pp"></div>
For details about the authorship, see the Git history of the project
  (git://source.ffmpeg.org/ffmpeg), e.g. by typing the command <b>git log</b> in
  the FFmpeg source directory, or browsing the online repository at &lt;
  <b>http://source.ffmpeg.org</b>&gt;.
<div class="Pp"></div>
Maintainers for the specific components are listed in the file
  <i>MAINTAINERS</i> in the source code tree.</div>
<table class="foot">
  <tr>
    <td class="foot-date"> </td>
    <td class="foot-os"> </td>
  </tr>
</table>
</body>
</html>
