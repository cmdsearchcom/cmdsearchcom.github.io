<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>bwa(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">bwa(1)</td>
    <td class="head-vol">Bioinformatics tools</td>
    <td class="head-rtitle">bwa(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
bwa - Burrows-Wheeler Alignment Tool
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
bwa index ref.fa
<div class="Pp"></div>
bwa mem ref.fa reads.fq &gt; aln-se.sam
<div class="Pp"></div>
bwa mem ref.fa read1.fq read2.fq &gt; aln-pe.sam
<div class="Pp"></div>
bwa aln ref.fa short_read.fq &gt; aln_sa.sai
<div class="Pp"></div>
bwa samse ref.fa aln_sa.sai short_read.fq &gt; aln-se.sam
<div class="Pp"></div>
bwa sampe ref.fa aln_sa1.sai aln_sa2.sai read1.fq read2.fq &gt; aln-pe.sam
<div class="Pp"></div>
bwa bwasw ref.fa long_read.fq &gt; aln.sam
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
BWA is a software package for mapping low-divergent sequences against a large
  reference genome, such as the human genome. It consists of three algorithms:
  BWA-backtrack, BWA-SW and BWA-MEM. The first algorithm is designed for
  Illumina sequence reads up to 100bp, while the rest two for longer sequences
  ranged from 70bp to 1Mbp. BWA-MEM and BWA-SW share similar features such as
  long-read support and split alignment, but BWA-MEM, which is the latest, is
  generally recommended for high-quality queries as it is faster and more
  accurate. BWA-MEM also has better performance than BWA-backtrack for 70-100bp
  Illumina reads.
<div style="height: 1.00em;">&#x00A0;</div>
For all the algorithms, BWA first needs to construct the FM-index for the
  reference genome (the <b>index</b> command). Alignment algorithms are invoked
  with different sub-commands: <b>aln</b>/<b>samse</b>/<b>sampe</b> for
  BWA-backtrack, <b>bwasw</b> for BWA-SW and <b>mem</b> for the BWA-MEM
  algorithm.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="COMMANDS_AND_OPTIONS"><a class="selflink" href="#COMMANDS_AND_OPTIONS">COMMANDS
  AND OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>index</b></dt>
  <dd class="It-tag"><b>bwa index</b> [<b>-p</b> <i>prefix</i>] [<b>-a</b>
      <i>algoType</i>] <i>db.fa</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    Index database sequences in the FASTA format.
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>OPTIONS:</b></dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b><i>&#x00A0;STR</i></dt>
  <dd class="It-tag">Prefix of the output database [same as db filename]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b><i>&#x00A0;STR</i></dt>
  <dd class="It-tag">Algorithm for constructing BWT index. BWA implements three
      algorithms for BWT construction: <b>is</b>, <b>bwtsw</b> and <b>rb2</b>.
      The first algorithm is a little faster for small database but requires
      large RAM and does not work for databases with total length longer than
      2GB. The second algorithm is adapted from the BWT-SW source code. It in
      theory works with database with trillions of bases. When this option is
      not specified, the appropriate algorithm will be chosen
    automatically.</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mem</b></dt>
  <dd class="It-tag"><b>bwa mem</b> [<b>-aCHjMpP</b>] [<b>-t</b>
      <i>nThreads</i>] [<b>-k</b> <i>minSeedLen</i>] [<b>-w</b>
      <i>bandWidth</i>] [<b>-d</b> <i>zDropoff</i>] [<b>-r</b>
      <i>seedSplitRatio</i>] [<b>-c</b> <i>maxOcc</i>] [<b>-D</b>
      <i>chainShadow</i>] [<b>-m</b> <i>maxMateSW</i>] [<b>-W</b>
      <i>minSeedMatch</i>] [<b>-A</b> <i>matchScore</i>] [<b>-B</b>
      <i>mmPenalty</i>] [<b>-O</b> <i>gapOpenPen</i>] [<b>-E</b>
      <i>gapExtPen</i>] [<b>-L</b> <i>clipPen</i>] [<b>-U</b> <i>unpairPen</i>]
      [<b>-R</b> <i>RGline</i>] [<b>-H</b> <i>HDlines</i>] [<b>-v</b>
      <i>verboseLevel</i>] <i>db.prefix</i> <i>reads.fq</i> [<i>mates.fq</i>]
    <div style="height: 1.00em;">&#x00A0;</div>
    Align 70bp-1Mbp query sequences with the BWA-MEM algorithm. Briefly, the
      algorithm works by seeding alignments with maximal exact matches (MEMs)
      and then extending seeds with the affine-gap Smith-Waterman algorithm
      (SW).
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>mates.fq</i> file is absent and option <b>-p</b> is not set, this
      command regards input reads are single-end. If <i>mates.fq</i> is present,
      this command assumes the <i>i</i>-th read in <i>reads.fq</i> and the
      <i>i</i>-th read in <i>mates.fq</i> constitute a read pair. If <b>-p</b>
      is used, the command assumes the 2<i>i</i>-th and the (2<i>i</i>+1)-th
      read in <i>reads.fq</i> constitute a read pair (such input file is said to
      be interleaved). In this case, <i>mates.fq</i> is ignored. In the
      paired-end mode, the <b>mem</b> command will infer the read orientation
      and the insert size distribution from a batch of reads.
    <div style="height: 1.00em;">&#x00A0;</div>
    The BWA-MEM algorithm performs local alignment. It may produce multiple
      primary alignments for different part of a query sequence. This is a
      crucial feature for long sequences. However, some tools such as Picard's
      markDuplicates does not work with split alignments. One may consider to
      use option <b>-M</b> to flag shorter split hits as secondary.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>ALGORITHM OPTIONS:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Number of threads [1]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Minimum seed length. Matches shorter than <i>INT</i> will
      be missed. The alignment speed is usually insensitive to this value unless
      it significantly deviates from 20. [19]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Band width. Essentially, gaps longer than <i>INT</i> will
      not be found. Note that the maximum gap length is also affected by the
      scoring matrix and the hit length, not solely determined by this option.
      [100]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Off-diagonal X-dropoff (Z-dropoff). Stop extension when the
      difference between the best and the current extension score is above
      |<i>i</i>-<i>j</i>|*<i>A</i>+<i>INT</i>, where <i>i</i> and <i>j</i> are
      the current positions of the query and reference, respectively, and
      <i>A</i> is the matching score. Z-dropoff is similar to BLAST's X-dropoff
      except that it doesn't penalize gaps in one of the sequences in the
      alignment. Z-dropoff not only avoids unnecessary extension, but also
      reduces poor alignments inside a long good alignment. [100]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b><i>&#x00A0;FLOAT</i></dt>
  <dd class="It-tag">Trigger re-seeding for a MEM longer than
      <i>minSeedLen</i>*<i>FLOAT</i>. This is a key heuristic parameter for
      tuning the performance. Larger value yields fewer seeds, which leads to
      faster alignment speed but lower accuracy. [1.5]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Discard a MEM if it has more than <i>INT</i> occurence in
      the genome. This is an insensitive parameter. [500]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D</b><i>&#x00A0;FLOAT</i></dt>
  <dd class="It-tag">Drop chains shorter than <i>FLOAT</i> fraction of the
      longest overlapping chain [0.5]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Perform at most <i>INT</i> rounds of mate-SW [50]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-W</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Drop a chain if the number of bases in seeds is smaller
      than <i>INT</i>. This option is primarily used for longer contigs/reads.
      When positive, it also affects seed filtering. [0]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b></dt>
  <dd class="It-tag">In the paired-end mode, perform SW to rescue missing hits
      only but do not try to find hits that fit a proper pair.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SCORING OPTIONS:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-A</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Matching score. [1]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-B</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Mismatch penalty. The sequence error rate is approximately:
      {.75 * exp[-log(4) * B/A]}. [4]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-O</b><i>&#x00A0;INT[,INT]</i></dt>
  <dd class="It-tag">Gap open penalty. If two numbers are specified, the first
      is the penalty of openning a deletion and the second for openning an
      insertion. [6]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-E</b><i>&#x00A0;INT[,INT]</i></dt>
  <dd class="It-tag">Gap extension penalty. If two numbers are specified, the
      first is the penalty of extending a deletion and second for extending an
      insertion. A gap of length k costs O + k*E (i.e. <b>-O</b> is for opening
      a zero-length gap). [1]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L</b><i>&#x00A0;INT[,INT]</i></dt>
  <dd class="It-tag">Clipping penalty. When performing SW extension, BWA-MEM
      keeps track of the best score reaching the end of query. If this score is
      larger than the best SW score minus the clipping penalty, clipping will
      not be applied. Note that in this case, the SAM AS tag reports the best SW
      score; clipping penalty is not deduced. If two numbers are provided, the
      first is for 5'-end clipping and second for 3'-end clipping. [5]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-U</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Penalty for an unpaired read pair. BWA-MEM scores an
      unpaired read pair as scoreRead1+scoreRead2-<i>INT</i> and scores a paired
      as scoreRead1+scoreRead2-insertPenalty. It compares these two scores to
      determine whether we should force pairing. A larger value leads to more
      aggressive read pair. [17]
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>INPUT/OUTPUT OPTIONS:</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b></dt>
  <dd class="It-tag">Smart pairing. If two adjacent reads have the same name,
      they are considered to form a read pair. This way, paired-end and
      single-end reads can be mixed in a single FASTA/Q stream.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R</b><i>&#x00A0;STR</i></dt>
  <dd class="It-tag">Complete read group header line. '\t' can be used in
      <i>STR</i> and will be converted to a TAB in the output SAM. The read
      group ID will be attached to every read in the output. An example is
      '@RG\tID:foo\tSM:bar'. [null]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-H</b><i>&#x00A0;ARG</i></dt>
  <dd class="It-tag">If ARG starts with @, it is interpreted as a string and
      gets inserted into the output SAM header; otherwise, ARG is interpreted as
      a file with all lines starting with @ in the file inserted into the SAM
      header. [null]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-T</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Don't output alignment with score lower than <i>INT</i>.
      This option affects output and occasionally SAM flag 2. [30]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-j</b></dt>
  <dd class="It-tag">Treat ALT contigs as part of the primary assembly (i.e.
      ignore the <i>db.prefix.alt</i> file).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b><i>&#x00A0;INT[,INT2]</i></dt>
  <dd class="It-tag">If a query has not more than <i>INT</i> hits with score
      higher than 80% of the best hit, output them all in the XA tag. If
      <i>INT2</i> is specified, BWA-MEM outputs up to <i>INT2</i> hits if the
      list contains a hit to an ALT contig. [5,200]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b></dt>
  <dd class="It-tag">Output all found alignments for single-end or unpaired
      paired-end reads. These alignments will be flagged as secondary
      alignments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C</b></dt>
  <dd class="It-tag">Append append FASTA/Q comment to SAM output. This option
      can be used to transfer read meta information (e.g. barcode) to the SAM
      output. Note that the FASTA/Q comment (the string after a space in the
      header line) must conform the SAM spec (e.g. BC:Z:CGTAC). Malformated
      comments lead to incorrect SAM output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Y</b></dt>
  <dd class="It-tag">Use soft clipping CIGAR operation for supplementary
      alignments. By default, BWA-MEM uses soft clipping for the primary
      alignment and hard clipping for supplementary alignments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M</b></dt>
  <dd class="It-tag">Mark shorter split hits as secondary (for Picard
      compatibility).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Control the verbose level of the output. This option has
      not been fully supported throughout BWA. Ideally, a value 0 for disabling
      all the output to stderr; 1 for outputting errors only; 2 for warnings and
      errors; 3 for all normal messages; 4 or higher for debugging. When this
      option takes value 4, the output is not SAM. [3]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-I</b><i>&#x00A0;FLOAT[,FLOAT[,INT[,INT]]]</i></dt>
  <dd class="It-tag">Specify the mean, standard deviation (10% of the mean if
      absent), max (4 sigma from the mean if absent) and min (4 sigma if absent)
      of the insert size distribution. Only applicable to the FR orientation. By
      default, BWA-MEM infers these numbers and the pair orientations given
      enough reads. [inferred]
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>aln</b></dt>
  <dd class="It-tag">bwa aln [-n maxDiff] [-o maxGapO] [-e maxGapE] [-d
      nDelTail] [-i nIndelEnd] [-k maxSeedDiff] [-l seedLen] [-t nThrds] [-cRN]
      [-M misMsc] [-O gapOsc] [-E gapEsc] [-q trimQual] &lt;in.db.fasta&gt;
      &lt;in.query.fq&gt; &gt; &lt;out.sai&gt;
    <div style="height: 1.00em;">&#x00A0;</div>
    Find the SA coordinates of the input reads. Maximum <i>maxSeedDiff</i>
      differences are allowed in the first <i>seedLen</i> subsequence and
      maximum <i>maxDiff</i> differences are allowed in the whole sequence.
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>OPTIONS:</b></dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b><i>&#x00A0;NUM</i></dt>
  <dd class="It-tag">Maximum edit distance if the value is INT, or the fraction
      of missing alignments given 2% uniform base error rate if FLOAT. In the
      latter case, the maximum edit distance is automatically chosen for
      different read lengths. [0.04]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Maximum number of gap opens [1]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Maximum number of gap extensions, -1 for k-difference mode
      (disallowing long gaps) [-1]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Disallow a long deletion within INT bp towards the 3'-end
      [16]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Disallow an indel within INT bp towards the ends [5]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Take the first INT subsequence as seed. If INT is larger
      than the query sequence, seeding will be disabled. For long reads, this
      option is typically ranged from 25 to 35 for `-k 2'. [inf]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Maximum edit distance in the seed [2]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Number of threads (multi-threading mode) [1]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Mismatch penalty. BWA will not search for suboptimal hits
      with a score lower than (bestScore-misMsc). [3]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-O</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Gap open penalty [11]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-E</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Gap extension penalty [4]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Proceed with suboptimal alignments if there are no more
      than INT equally best hits. This option only affects paired-end mapping.
      Increasing this threshold helps to improve the pairing accuracy at the
      cost of speed, especially for short reads (~32bp).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b></dt>
  <dd class="It-tag">Reverse query but not complement it, which is required for
      alignment in the color space. (Disabled since 0.6.x)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-N</b></dt>
  <dd class="It-tag">Disable iterative search. All hits with no more than
      <i>maxDiff</i> differences will be found. This mode is much slower than
      the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Parameter for read trimming. BWA trims a read down to
      argmax_x{\sum_{i=x+1}^l(INT-q_i)} if q_l&lt;INT where l is the original
      read length. [0]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-I</b></dt>
  <dd class="It-tag">The input is in the Illumina 1.3+ read format (quality
      equals ASCII-64).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-B</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Length of barcode starting from the 5'-end. When <i>INT</i>
      is positive, the barcode of each read will be trimmed before mapping and
      will be written at the <b>BC</b> SAM tag. For paired-end reads, the
      barcode from both ends are concatenated. [0]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b</b></dt>
  <dd class="It-tag">Specify the input read sequence file is the BAM format. For
      paired-end data, two ends in a pair must be grouped together and options
      <b>-1</b> or <b>-2</b> are usually applied to specify which end should be
      mapped. Typical command lines for mapping pair-end data in the BAM format
      are:
    <div style="height: 1.00em;">&#x00A0;</div>
    <br/>
     bwa aln ref.fa -b1 reads.bam &gt; 1.sai
    <br/>
     bwa aln ref.fa -b2 reads.bam &gt; 2.sai
    <br/>
     bwa sampe ref.fa 1.sai 2.sai reads.bam reads.bam &gt; aln.sam</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-0</b></dt>
  <dd class="It-tag">When <b>-b</b> is specified, only use single-end reads in
      mapping.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-1</b></dt>
  <dd class="It-tag">When <b>-b</b> is specified, only use the first read in a
      read pair in mapping (skip single-end reads and the second reads).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-2</b></dt>
  <dd class="It-tag">When <b>-b</b> is specified, only use the second read in a
      read pair in mapping.</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>samse</b></dt>
  <dd class="It-tag">bwa samse [-n maxOcc] &lt;in.db.fasta&gt; &lt;in.sai&gt;
      &lt;in.fq&gt; &gt; &lt;out.sam&gt;
    <div style="height: 1.00em;">&#x00A0;</div>
    Generate alignments in the SAM format given single-end reads. Repetitive
      hits will be randomly chosen.
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>OPTIONS:</b></dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Maximum number of alignments to output in the XA tag for
      reads paired properly. If a read has more than INT hits, the XA tag will
      not be written. [3]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b><i>&#x00A0;STR</i></dt>
  <dd class="It-tag">Specify the read group in a format like
      `@RG\tID:foo\tSM:bar'. [null]</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sampe</b></dt>
  <dd class="It-tag">bwa sampe [-a maxInsSize] [-o maxOcc] [-n maxHitPaired] [-N
      maxHitDis] [-P] &lt;in.db.fasta&gt; &lt;in1.sai&gt; &lt;in2.sai&gt;
      &lt;in1.fq&gt; &lt;in2.fq&gt; &gt; &lt;out.sam&gt;
    <div style="height: 1.00em;">&#x00A0;</div>
    Generate alignments in the SAM format given paired-end reads. Repetitive
      read pairs will be placed randomly.
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>OPTIONS:</b></dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Maximum insert size for a read pair to be considered being
      mapped properly. Since 0.4.5, this option is only used when there are not
      enough good alignment to infer the distribution of insert sizes.
    [500]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Maximum occurrences of a read for pairing. A read with more
      occurrneces will be treated as a single-end read. Reducing this parameter
      helps faster pairing. [100000]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b></dt>
  <dd class="It-tag">Load the entire FM-index into memory to reduce disk
      operations (base-space reads only). With this option, at least 1.25N bytes
      of memory are required, where N is the length of the genome.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Maximum number of alignments to output in the XA tag for
      reads paired properly. If a read has more than INT hits, the XA tag will
      not be written. [3]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-N</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Maximum number of alignments to output in the XA tag for
      disconcordant read pairs (excluding singletons). If a read has more than
      INT hits, the XA tag will not be written. [10]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b><i>&#x00A0;STR</i></dt>
  <dd class="It-tag">Specify the read group in a format like
      `@RG\tID:foo\tSM:bar'. [null]</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bwasw</b></dt>
  <dd class="It-tag">bwa bwasw [-a matchScore] [-b mmPen] [-q gapOpenPen] [-r
      gapExtPen] [-t nThreads] [-w bandWidth] [-T thres] [-s hspIntv] [-z zBest]
      [-N nHspRev] [-c thresCoef] &lt;in.db.fasta&gt; &lt;in.fq&gt; [mate.fq]
    <div style="height: 1.00em;">&#x00A0;</div>
    Align query sequences in the <i>in.fq</i> file. When <i>mate.fq</i> is
      present, perform paired-end alignment. The paired-end mode only works for
      reads Illumina short-insert libraries. In the paired-end mode, BWA-SW may
      still output split alignments but they are all marked as not properly
      paired; the mate positions will not be written if the mate has multiple
      local hits.
    <div style="height: 1.00em;">&#x00A0;</div>
    <b>OPTIONS:</b></dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Score of a match [1]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Mismatch penalty [3]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Gap open penalty [5]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Gap extension penalty. The penalty for a contiguous gap of
      size k is q+k*r. [2]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Number of threads in the multi-threading mode [1]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Band width in the banded alignment [33]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-T</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Minimum score threshold divided by a [37]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b><i>&#x00A0;FLOAT</i></dt>
  <dd class="It-tag">Coefficient for threshold adjustment according to query
      length. Given an l-long query, the threshold for a hit to be retained is
      a*max{T,c*log(l)}. [5.5]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-z</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Z-best heuristics. Higher -z increases accuracy at the cost
      of speed. [1]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Maximum SA interval size for initiating a seed. Higher -s
      increases accuracy at the cost of speed. [3]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-N</b><i>&#x00A0;INT</i></dt>
  <dd class="It-tag">Minimum number of seeds supporting the resultant alignment
      to skip reverse alignment. [5]</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SAM_ALIGNMENT_FORMAT"><a class="selflink" href="#SAM_ALIGNMENT_FORMAT">SAM
  ALIGNMENT FORMAT</a></h1>
The output of the <b>`aln'</b> command is binary and designed for BWA use only.
  BWA outputs the final alignment in the SAM (Sequence Alignment/Map) format.
  Each line consists of:
<div style="height: 1.00em;">&#x00A0;</div>
<table class="tbl">
  <colgroup>
    <col style="width: 6.00ex;"/>
    <col style="width: 5.00ex;"/>
    <col style="width: 56.00ex;"/>
  </colgroup>
  <tr>
    <td>Col</td>
    <td>Field</td>
    <td>Description</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>1</td>
    <td>QNAME</td>
    <td>Query (pair) NAME</td>
  </tr>
  <tr>
    <td>2</td>
    <td>FLAG</td>
    <td>bitwise FLAG</td>
  </tr>
  <tr>
    <td>3</td>
    <td>RNAME</td>
    <td>Reference sequence NAME</td>
  </tr>
  <tr>
    <td>4</td>
    <td>POS</td>
    <td>1-based leftmost POSition/coordinate of clipped sequence</td>
  </tr>
  <tr>
    <td>5</td>
    <td>MAPQ</td>
    <td>MAPping Quality (Phred-scaled)</td>
  </tr>
  <tr>
    <td>6</td>
    <td>CIAGR</td>
    <td>extended CIGAR string</td>
  </tr>
  <tr>
    <td>7</td>
    <td>MRNM</td>
    <td>Mate Reference sequence NaMe (`=' if same as RNAME)</td>
  </tr>
  <tr>
    <td>8</td>
    <td>MPOS</td>
    <td>1-based Mate POSistion</td>
  </tr>
  <tr>
    <td>9</td>
    <td>ISIZE</td>
    <td>Inferred insert SIZE</td>
  </tr>
  <tr>
    <td>10</td>
    <td>SEQ</td>
    <td>query SEQuence on the same strand as the reference</td>
  </tr>
  <tr>
    <td>11</td>
    <td>QUAL</td>
    <td>query QUALity (ASCII-33 gives the Phred base quality)</td>
  </tr>
  <tr>
    <td>12</td>
    <td>OPT</td>
    <td>variable OPTional fields in the format TAG:VTYPE:VALUE</td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Each bit in the FLAG field is defined as:
<div style="height: 1.00em;">&#x00A0;</div>
<table class="tbl">
  <colgroup>
    <col style="width: 3.00ex;"/>
    <col style="width: 6.00ex;"/>
    <col style="width: 37.00ex;"/>
  </colgroup>
  <tr>
    <td>Chr</td>
    <td>Flag</td>
    <td>Description</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>p</td>
    <td>0x0001</td>
    <td>the read is paired in sequencing</td>
  </tr>
  <tr>
    <td>P</td>
    <td>0x0002</td>
    <td>the read is mapped in a proper pair</td>
  </tr>
  <tr>
    <td>u</td>
    <td>0x0004</td>
    <td>the query sequence itself is unmapped</td>
  </tr>
  <tr>
    <td>U</td>
    <td>0x0008</td>
    <td>the mate is unmapped</td>
  </tr>
  <tr>
    <td>r</td>
    <td>0x0010</td>
    <td>strand of the query (1 for reverse)</td>
  </tr>
  <tr>
    <td>R</td>
    <td>0x0020</td>
    <td>strand of the mate</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0x0040</td>
    <td>the read is the first read in a pair</td>
  </tr>
  <tr>
    <td>2</td>
    <td>0x0080</td>
    <td>the read is the second read in a pair</td>
  </tr>
  <tr>
    <td>s</td>
    <td>0x0100</td>
    <td>the alignment is not primary</td>
  </tr>
  <tr>
    <td>f</td>
    <td>0x0200</td>
    <td>QC failure</td>
  </tr>
  <tr>
    <td>d</td>
    <td>0x0400</td>
    <td>optical or PCR duplicate</td>
  </tr>
  <tr>
    <td>S</td>
    <td>0x0800</td>
    <td>supplementary alignment</td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The Please check &lt;http://samtools.sourceforge.net&gt; for the format
  specification and the tools for post-processing the alignment.
<div style="height: 1.00em;">&#x00A0;</div>
BWA generates the following optional fields. Tags starting with `X' are specific
  to BWA.
<div style="height: 1.00em;">&#x00A0;</div>
<table class="tbl">
  <colgroup>
    <col style="width: 3.00ex;"/>
    <col style="width: 48.00ex;"/>
  </colgroup>
  <tr>
    <td>Tag</td>
    <td>Meaning</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>NM</td>
    <td>Edit distance</td>
  </tr>
  <tr>
    <td>MD</td>
    <td>Mismatching positions/bases</td>
  </tr>
  <tr>
    <td>AS</td>
    <td>Alignment score</td>
  </tr>
  <tr>
    <td>BC</td>
    <td>Barcode sequence</td>
  </tr>
  <tr>
    <td>SA</td>
    <td>Supplementary alignments</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>X0</td>
    <td>Number of best hits</td>
  </tr>
  <tr>
    <td>X1</td>
    <td>Number of suboptimal hits found by BWA</td>
  </tr>
  <tr>
    <td>XN</td>
    <td>Number of ambiguous bases in the referenece</td>
  </tr>
  <tr>
    <td>XM</td>
    <td>Number of mismatches in the alignment</td>
  </tr>
  <tr>
    <td>XO</td>
    <td>Number of gap opens</td>
  </tr>
  <tr>
    <td>XG</td>
    <td>Number of gap extentions</td>
  </tr>
  <tr>
    <td>XT</td>
    <td>Type: Unique/Repeat/N/Mate-sw</td>
  </tr>
  <tr>
    <td>XA</td>
    <td>Alternative hits; format: /(chr,pos,CIGAR,NM;)*/</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>XS</td>
    <td>Suboptimal alignment score</td>
  </tr>
  <tr>
    <td>XF</td>
    <td>Support from forward/reverse alignment</td>
  </tr>
  <tr>
    <td>XE</td>
    <td>Number of supporting seeds</td>
  </tr>
</table>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Note that XO and XG are generated by BWT search while the CIGAR string by
  Smith-Waterman alignment. These two tags may be inconsistent with the CIGAR
  string. This is not a bug.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="NOTES_ON_SHORT-READ_ALIGNMENT"><a class="selflink" href="#NOTES_ON_SHORT-READ_ALIGNMENT">NOTES
  ON SHORT-READ ALIGNMENT</a></h1>
<h2 class="Ss" title="Ss" id="Alignment_Accuracy"><a class="selflink" href="#Alignment_Accuracy">Alignment
  Accuracy</a></h2>
When seeding is disabled, BWA guarantees to find an alignment containing maximum
  <i>maxDiff</i> differences including <i>maxGapO</i> gap opens which do not
  occur within <i>nIndelEnd</i> bp towards either end of the query. Longer gaps
  may be found if <i>maxGapE</i> is positive, but it is not guaranteed to find
  all hits. When seeding is enabled, BWA further requires that the first
  <i>seedLen</i> subsequence contains no more than <i>maxSeedDiff</i>
  differences.
<div class="Pp"></div>
When gapped alignment is disabled, BWA is expected to generate the same
  alignment as Eland version 1, the Illumina alignment program. However, as BWA
  change `N' in the database sequence to random nucleotides, hits to these
  random sequences will also be counted. As a consequence, BWA may mark a unique
  hit as a repeat, if the random sequences happen to be identical to the
  sequences which should be unqiue in the database.
<div class="Pp"></div>
By default, if the best hit is not highly repetitive (controlled by -R), BWA
  also finds all hits contains one more mismatch; otherwise, BWA finds all
  equally best hits only. Base quality is NOT considered in evaluating hits. In
  the paired-end mode, BWA pairs all hits it found. It further performs
  Smith-Waterman alignment for unmapped reads to rescue reads with a high erro
  rate, and for high-quality anomalous pairs to fix potential alignment errors.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="Estimating_Insert_Size_Distribution"><a class="selflink" href="#Estimating_Insert_Size_Distribution">Estimating
  Insert Size Distribution</a></h2>
BWA estimates the insert size distribution per 256*1024 read pairs. It first
  collects pairs of reads with both ends mapped with a single-end quality 20 or
  higher and then calculates median (Q2), lower and higher quartile (Q1 and Q3).
  It estimates the mean and the variance of the insert size distribution from
  pairs whose insert sizes are within interval [Q1-2(Q3-Q1), Q3+2(Q3-Q1)]. The
  maximum distance x for a pair considered to be properly paired (SAM flag 0x2)
  is calculated by solving equation Phi((x-mu)/sigma)=x/L*p0, where mu is the
  mean, sigma is the standard error of the insert size distribution, L is the
  length of the genome, p0 is prior of anomalous pair and Phi() is the standard
  cumulative distribution function. For mapping Illumina short-insert reads to
  the human genome, x is about 6-7 sigma away from the mean. Quartiles, mean,
  variance and x will be printed to the standard error output.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="Memory_Requirement"><a class="selflink" href="#Memory_Requirement">Memory
  Requirement</a></h2>
With bwtsw algorithm, 5GB memory is required for indexing the complete human
  genome sequences. For short reads, the <b>aln</b> command uses ~3.2GB memory
  and the <b>sampe</b> command uses ~5.4GB.
<div style="height: 1.00em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="Speed"><a class="selflink" href="#Speed">Speed</a></h2>
Indexing the human genome sequences takes 3 hours with bwtsw algorithm. Indexing
  smaller genomes with IS algorithms is faster, but requires more memory.
<div class="Pp"></div>
The speed of alignment is largely determined by the error rate of the query
  sequences (r). Firstly, BWA runs much faster for near perfect hits than for
  hits with many differences, and it stops searching for a hit with l+2
  differences if a l-difference hit is found. This means BWA will be very slow
  if r is high because in this case BWA has to visit hits with many differences
  and looking for these hits is expensive. Secondly, the alignment algorithm
  behind makes the speed sensitive to [k log(N)/m], where k is the maximum
  allowed differences, N the size of database and m the length of a query. In
  practice, we choose k w.r.t. r and therefore r is the leading factor. I would
  not recommend to use BWA on data with r&gt;0.02.
<div class="Pp"></div>
Pairing is slower for shorter reads. This is mainly because shorter reads have
  more spurious hits and converting SA coordinates to chromosomal coordinates
  are very costly.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="CHANGES_IN_BWA-0.6"><a class="selflink" href="#CHANGES_IN_BWA-0.6">CHANGES
  IN BWA-0.6</a></h1>
Since version 0.6, BWA has been able to work with a reference genome longer than
  4GB. This feature makes it possible to integrate the forward and reverse
  complemented genome in one FM-index, which speeds up both BWA-short and
  BWA-SW. As a tradeoff, BWA uses more memory because it has to keep all
  positions and ranks in 64-bit integers, twice larger than 32-bit integers used
  in the previous versions.
<div style="height: 1.00em;">&#x00A0;</div>
The latest BWA-SW also works for paired-end reads longer than 100bp. In
  comparison to BWA-short, BWA-SW tends to be more accurate for highly unique
  reads and more robust to relative long INDELs and structural variants.
  Nonetheless, BWA-short usually has higher power to distinguish the optimal hit
  from many suboptimal hits. The choice of the mapping algorithm may depend on
  the application.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
BWA website &lt;http://bio-bwa.sourceforge.net&gt;, Samtools website
  &lt;http://samtools.sourceforge.net&gt;
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Heng Li at the Sanger Institute wrote the key source codes and integrated the
  following codes for BWT construction: bwtsw
  &lt;http://i.cs.hku.hk/~ckwong3/bwtsw/&gt;, implemented by Chi-Kwong Wong at
  the University of Hong Kong and IS
  &lt;http://yuta.256.googlepages.com/sais&gt; originally proposed by Nong Ge
  &lt;http://www.cs.sysu.edu.cn/nong/&gt; at the Sun Yat-Sen University and
  implemented by Yuta Mori.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="LICENSE_AND_CITATION"><a class="selflink" href="#LICENSE_AND_CITATION">LICENSE
  AND CITATION</a></h1>
The full BWA package is distributed under GPLv3 as it uses source codes from
  BWT-SW which is covered by GPL. Sorting, hash table, BWT and IS libraries are
  distributed under the MIT license.
<div class="Pp"></div>
If you use the BWA-backtrack algorithm, please cite the following paper:
<div class="Pp"></div>
Li H. and Durbin R. (2009) Fast and accurate short read alignment with
  Burrows-Wheeler transform. Bioinformatics, 25, 1754-1760. [PMID: 19451168]
<div class="Pp"></div>
If you use the BWA-SW algorithm, please cite:
<div class="Pp"></div>
Li H. and Durbin R. (2010) Fast and accurate long-read alignment with
  Burrows-Wheeler transform. Bioinformatics, 26, 589-595. [PMID: 20080505]
<div class="Pp"></div>
If you use BWA-MEM or the fastmap component of BWA, please cite:
<div class="Pp"></div>
Li H. (2013) Aligning sequence reads, clone sequences and assembly contigs with
  BWA-MEM. arXiv:1303.3997v1 [q-bio.GN].
<div class="Pp"></div>
It is likely that the BWA-MEM manuscript will not appear in a peer-reviewed
  journal.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="HISTORY"><a class="selflink" href="#HISTORY">HISTORY</a></h1>
BWA is largely influenced by BWT-SW. It uses source codes from BWT-SW and mimics
  its binary file formats; BWA-SW resembles BWT-SW in several ways. The initial
  idea about BWT-based alignment also came from the group who developed BWT-SW.
  At the same time, BWA is different enough from BWT-SW. The short-read
  alignment algorithm bears no similarity to Smith-Waterman algorithm any more.
  While BWA-SW learns from BWT-SW, it introduces heuristics that can hardly be
  applied to the original algorithm. In all, BWA does not guarantee to find all
  local hits as what BWT-SW is designed to do, but it is much faster than BWT-SW
  on both short and long query sequences.
<div style="height: 1.00em;">&#x00A0;</div>
I started to write the first piece of codes on 24 May 2008 and got the initial
  stable version on 02 June 2008. During this period, I was acquainted that
  Professor Tak-Wah Lam, the first author of BWT-SW paper, was collaborating
  with Beijing Genomics Institute on SOAP2, the successor to SOAP (Short
  Oligonucleotide Analysis Package). SOAP2 has come out in November 2008.
  According to the SourceForge download page, the third BWT-based short read
  aligner, bowtie, was first released in August 2008. At the time of writing
  this manual, at least three more BWT-based short-read aligners are being
  implemented.
<div style="height: 1.00em;">&#x00A0;</div>
The BWA-SW algorithm is a new component of BWA. It was conceived in November
  2008 and implemented ten months later.
<div style="height: 1.00em;">&#x00A0;</div>
The BWA-MEM algorithm is based on an algorithm finding super-maximal exact
  matches (SMEMs), which was first published with the fermi assembler paper in
  2012. I first implemented the basic SMEM algorithm in the <b>fastmap</b>
  command for an experiment and then extended the basic algorithm and added the
  extension part in Feburary 2013 to make BWA-MEM a fully featured mapper.
<div style="height: 1.00em;">&#x00A0;</div>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">31 May 2016</td>
    <td class="foot-os">bwa-0.7.15-r1140</td>
  </tr>
</table>
</body>
</html>
