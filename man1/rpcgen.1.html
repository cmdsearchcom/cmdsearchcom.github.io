<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>rpcgen(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">rpcgen(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">rpcgen(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
rpcgen - an RPC protocol compiler
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
rpcgen  <i>infile</i>
</pre>
<div>&#x00A0;</div>
<pre>
rpcgen [-D <i>name</i>[=<i>value</i>]] [-T] [-K <i>secs</i>] <i>infile</i>
</pre>
<div>&#x00A0;</div>
<pre>
rpcgen -c|-h|-l|-m|-M|-t [-o  <i>outfile</i> ] <i>infile</i>
</pre>
<div>&#x00A0;</div>
<pre>
rpcgen [-I] -s  <i>nettype</i> [-o <i>outfile</i>] <i>infile</i>
</pre>
<div>&#x00A0;</div>
<pre>
rpcgen -n  <i>netid</i> [-o <i>outfile</i>] <i>infile</i>
</pre>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
rpcgen is a tool that generates C code to implement an RPC protocol. The input
  to rpcgen is a language similar to C known as RPC Language (Remote Procedure
  Call Language).
<div class="Pp"></div>
rpcgen is normally used as in the first synopsis where it takes an input file
  and generates up to four output files. If the <i>infile</i> is named proto.x,
  then rpcgen will generate a header file in proto.h, XDR routines in
  proto_xdr.c, server-side stubs in proto_svc.c, and client-side stubs in
  proto_clnt.c. With the -T option, it will also generate the RPC dispatch table
  in proto_tbl.i. With the -Sc option, it will also generate sample code which
  would illustrate how to use the remote procedures on the client side. This
  code would be created in proto_client.c. With the -Ss option, it will also
  generate a sample server code which would illustrate how to write the remote
  procedures. This code would be created in proto_server.c.
<div class="Pp"></div>
The server created can be started both by the port monitors (for example, inetd
  or listen) or by itself. When it is started by a port monitor, it creates
  servers only for the transport for which the file descriptor 0 was passed. The
  name of the transport must be specified by setting up the environmental
  variable PM_TRANSPORT. When the server generated by rpcgen is executed, it
  creates server handles for all the transports specified in NETPATH environment
  variable, or if it is unset, it creates server handles for all the visible
  transports from /etc/netconfig file. Note: the transports are chosen at run
  time and not at compile time.
<div class="Pp"></div>
When built for a port monitor (rpcgen -I), and that the server is self-started,
  it backgrounds itself by default. A special define symbol RPC_SVC_FG can be
  used to run the server process in foreground.
<div class="Pp"></div>
The second synopsis provides special features which allow for the creation of
  more sophisticated RPC servers. These features include support for user
  provided #defines and RPC dispatch tables. The entries in the RPC dispatch
  table contain:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">pointers to the service routine corresponding to that
      procedure,</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">a pointer to the input and output arguments</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">the size of these routines</dd>
</dl>
</div>
A server can use the dispatch table to check authorization and then to execute
  the service routine; a client library may use it to deal with the details of
  storage management and XDR data conversion.
<div class="Pp"></div>
The other three synopses shown above are used when one does not want to generate
  all the output files, but only a particular one. Some examples of their usage
  is described in the EXAMPLE section below. When rpcgen is executed with the -s
  option, it creates servers for that particular class of transports. When
  executed with the -n option, it creates a server for the transport specified
  by <i>netid</i>. If <i>infile</i> is not specified, rpcgen accepts the
  standard input.
<div class="Pp"></div>
The C preprocessor, cc -E [see cc(1)], is run on the input file before it is
  actually interpreted by rpcgen. For each type of output file, rpcgen defines a
  special preprocessor symbol for use by the rpcgen programmer:
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag">RPC_HDR</dt>
  <dd class="It-tag">defined when compiling into header files</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">RPC_XDR</dt>
  <dd class="It-tag">defined when compiling into XDR routines</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">RPC_SVC</dt>
  <dd class="It-tag">defined when compiling into server-side stubs</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">RPC_CLNT</dt>
  <dd class="It-tag">defined when compiling into client-side stubs</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">RPC_TBL</dt>
  <dd class="It-tag">defined when compiling into RPC dispatch tables</dd>
</dl>
<div class="Pp"></div>
Any line beginning with `%' is passed directly into the output file,
  uninterpreted by rpcgen.
<div class="Pp"></div>
For every data type referred to in <i>infile</i>, rpcgen assumes that there
  exists a routine with the string xdr_ prepended to the name of the data type.
  If this routine does not exist in the RPC/XDR library, it must be provided.
  Providing an undefined data type allows customization of XDR routines.
<div>&#x00A0;</div>
<div class="Pp"></div>
The following options are available:
<dl class="Bl-tag">
  <dt class="It-tag">-a</dt>
  <dd class="It-tag">Generate all the files including sample code for client and
      server side.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-b</dt>
  <dd class="It-tag">This generates code for the SunOS4.1 style of rpc. It is
      for backward compatibility. This is the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-5</dt>
  <dd class="It-tag">This generates code for the SysVr4 style of rpc. It is used
      by the Transport Independent RPC that is in Svr4 systems. By default
      rpcgen generates code for SunOS4.1 stype of rpc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-c</dt>
  <dd class="It-tag">Compile into XDR routines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-C</dt>
  <dd class="It-tag">Generate code in ANSI C. This option also generates code
      that could be compiled with the C++ compiler. This is the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-k</dt>
  <dd class="It-tag">Generate code in K&amp;R C. The default is ANSI C.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-D<i>name</i>[=<i>value</i>]</dt>
  <dd class="It-tag">Define a symbol <i>name</i>. Equivalent to the #define
      directive in the source. If no <i>value</i> is given, <i>value</i> is
      defined as 1. This option may be specified more than once.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-h</dt>
  <dd class="It-tag">Compile into C data-definitions (a header file). -T option
      can be used in conjunction to produce a header file which supports RPC
      dispatch tables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-I</dt>
  <dd class="It-tag">Generate a service that can be started from inetd. The
      default is to generate a static service that handles transports selected
      with -s. Using -I allows starting a service by either method.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-K<i> secs</i></dt>
  <dd class="It-tag">By default, services created using rpcgen wait 120 seconds
      after servicing a request before exiting. That interval can be changed
      using the -K flag. To create a server that exits immediately upon
      servicing a request, -K&#x00A0;0 can be used. To create a server that
      never exits, the appropriate argument is -K&#x00A0;-1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">When monitoring for a server, some portmonitors, like
      listen(1M), <i>always</i> spawn a new process in response to a service
      request. If it is known that a server will be used with such a monitor,
      the server should exit immediately on completion. For such servers, rpcgen
      should be used with -K&#x00A0;-1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-l</dt>
  <dd class="It-tag">Compile into client-side stubs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-m</dt>
  <dd class="It-tag">Compile into server-side stubs, but do not generate a
      &#x201C;main&#x201D; routine. This option is useful for doing
      callback-routines and for users who need to write their own
      &#x201C;main&#x201D; routine to do initialization.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-M</dt>
  <dd class="It-tag">Generate multithread-safe stubs for passing arguments and
      results between rpcgen-generated code and user written code. This option
      is useful for users who want to use threads in their code.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-n <i>netid</i></dt>
  <dd class="It-tag">Compile into server-side stubs for the transport specified
      by <i>netid</i>. There should be an entry for <i>netid</i> in the
      netconfig database. This option may be specified more than once, so as to
      compile a server that serves multiple transports.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-N</dt>
  <dd class="It-tag">Use the newstyle of rpcgen. This allows procedures to have
      multiple arguments. It also uses the style of parameter passing that
      closely resembles C. So, when passing an argument to a remote procedure
      you do not have to pass a pointer to the argument but the argument itself.
      This behaviour is different from the oldstyle of rpcgen generated code.
      The newstyle is not the default case because of backward
    compatibility.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-o <i>outfile</i></dt>
  <dd class="It-tag">Specify the name of the output file. If none is specified,
      standard output is used (-c, -h, -l, -m, -n, -s, -Sc, -Sm, -Ss, and -t
      modes only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s <i>nettype</i></dt>
  <dd class="It-tag">Compile into server-side stubs for all the transports
      belonging to the class <i>nettype</i>. The supported classes are netpath,
      visible, circuit_n, circuit_v, datagram_n, datagram_v, tcp, and udp [see
      rpc(3N) for the meanings associated with these classes]. This option may
      be specified more than once. Note: the transports are chosen at run time
      and not at compile time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-Sc</dt>
  <dd class="It-tag">Generate sample code to show the use of remote procedure
      and how to bind to the server before calling the client side stubs
      generated by rpcgen.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-Sm</dt>
  <dd class="It-tag">Generate a sample Makefile which can be used for compiling
      the application.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-Ss</dt>
  <dd class="It-tag">Generate skeleton code for the remote procedures on the
      server side. You would need to fill in the actual code for the remote
      procedures.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-t</dt>
  <dd class="It-tag">Compile into RPC dispatch table.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-T</dt>
  <dd class="It-tag">Generate the code to support RPC dispatch tables.</dd>
</dl>
<div class="Pp"></div>
The options -c, -h, -l, -m, -s and -t are used exclusively to generate a
  particular type of file, while the options -D and -T are global and can be
  used with the other options.
<div>&#x00A0;</div>
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
The RPC Language does not support nesting of structures. As a work-around,
  structures can be declared at the top-level, and their name used inside other
  structures in order to achieve the same effect.
<div class="Pp"></div>
Name clashes can occur when using program definitions, since the apparent
  scoping does not really apply. Most of these can be avoided by giving unique
  names for programs, versions, procedures and types.
<div class="Pp"></div>
The server code generated with -n option refers to the transport indicated by
  <i>netid</i> and hence is very site specific.
<h1 class="Sh" title="Sh" id="EXAMPLE"><a class="selflink" href="#EXAMPLE">EXAMPLE</a></h1>
The following example:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">$ rpcgen -T prot.x</dd>
</dl>
<div class="Pp"></div>
generates the five files: prot.h, prot_clnt.c, prot_svc.c, prot_xdr.c and
  prot_tbl.i.
<div class="Pp"></div>
The following example sends the C data-definitions (header file) to the standard
  output.
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">$ rpcgen -h prot.x</dd>
</dl>
<div class="Pp"></div>
To send the test version of the -DTEST, server side stubs for all the transport
  belonging to the class datagram_n to standard output, use:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">$ rpcgen -s datagram_n -DTEST prot.x</dd>
</dl>
<div class="Pp"></div>
To create the server side stubs for the transport indicated by <i>netid</i> tcp,
  use:
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">$ rpcgen -n tcp -o prot_svc.c prot.x</dd>
</dl>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
cc(1).</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
