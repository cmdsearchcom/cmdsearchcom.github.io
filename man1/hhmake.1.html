<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:16:47 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>HHMAKE(1) User Commands HHMAKE(1)</p>

<p style="margin-top: 1em">NAME <br>
hhmake - build an HMM from an input alignment or convert
between HMMER format and HHsearch format</p>

<p style="margin-top: 1em">SYNOPSIS <br>
hhmake -i file [options]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
HHmake 3.0.0 (15-03-2015) Build an HMM from an input
alignment in A2M, A3M, or FASTA format, or convert between
HMMER format (.hmm) and HHsearch format (.hhm). Remmert M,
<br>
Biegert A, Hauser A, and Soding J. HHblits: Lightning-fast
iterative protein sequence searching by HMM-HMM alignment.
Nat. Methods 9:173-175 (2011). (C) Johannes Soeding, <br>
Michael Remmert, Andreas Biegert, Andreas Hauser</p>

<p style="margin-top: 1em">-i &lt;file&gt; <br>
query alignment (A2M, A3M, or FASTA), or query HMM</p>

<p style="margin-top: 1em">Output options: <br>
-o &lt;file&gt; <br>
HMM file to be written to (default=&lt;infile.hhm&gt;)</p>

<p style="margin-top: 1em">-a &lt;file&gt; <br>
HMM file to be appended to</p>

<p style="margin-top: 1em">-v &lt;int&gt; <br>
verbose mode: 0:no screen output 1:only warings 2:
verbose</p>

<p style="margin-top: 1em">-seq &lt;int&gt; <br>
max. number of query/template sequences displayed (def=10)
Beware of overflows! All these sequences are stored in
memory.</p>

<p style="margin-top: 1em">-cons make consensus sequence
master sequence of query MSA</p>

<p style="margin-top: 1em">-name &lt;name&gt; <br>
use this name for HMM (default: use name of first
sequence)</p>

<p style="margin-top: 1em">Filter query multiple sequence
alignment</p>

<p style="margin-top: 1em">-id [0,100] maximum pairwise
sequence identity (%) (def=90)</p>

<p style="margin-top: 1em">-diff [0,inf[ <br>
filter MSA by selecting most diverse set of sequences,
keeping at least this many seqs in each MSA block of length
50 (def=100)</p>

<p style="margin-top: 1em">-cov [0,100] minimum coverage
with query (%) (def=0)</p>

<p style="margin-top: 1em">-qid [0,100] minimum sequence
identity with query (%) (def=0)</p>

<p style="margin-top: 1em">-qsc [0,100] minimum score per
column with query (def=-20.0)</p>

<p style="margin-top: 1em">-neff [1,inf] <br>
target diversity of alignment (default=off)</p>

<p style="margin-top: 1em">Input alignment format: <br>
-M a2m use A2M/A3M (default): upper case = Match; lower case
= Insert; &rsquo;-&rsquo; = Delete; &rsquo;.&rsquo; = gaps
aligned to inserts (may be omitted)</p>

<p style="margin-top: 1em">-M first <br>
use FASTA: columns with residue in 1st sequence are match
states</p>

<p style="margin-top: 1em">-M [0,100] <br>
use FASTA: columns with fewer than X% gaps are match
states</p>

<p style="margin-top: 1em">Pseudocount (pc) options: <br>
Context specific hhm pseudocounts:</p>

<p style="margin-top: 1em">-pc_hhm_contxt_mode {0,..,3}
<br>
position dependence of pc admixture &rsquo;tau&rsquo; (pc
mode, default=0)</p>

<p style="margin-top: 1em">0: no pseudo counts: <br>
tau = 0</p>

<p style="margin-top: 1em">1: constant <br>
tau = a</p>

<p style="margin-top: 1em">2: diversity-dependent: tau =
a/(1+((Neff[i]-1)/b)^c) 3: CSBlast admixture: tau =
a(1+b)/(Neff[i]+b) (Neff[i]: number of effective seqs in
local MSA around column i)</p>

<p style="margin-top: 1em">-pc_hhm_contxt_a <br>
[0,1] overall pseudocount admixture (def=0.9)</p>

<p style="margin-top: 1em">-pc_hhm_contxt_b <br>
[1,inf[ Neff threshold value for mode 2 (def=4.0)</p>

<p style="margin-top: 1em">-pc_hhm_contxt_c <br>
[0,3] extinction exponent c for mode 2 (def=1.0)</p>

<p style="margin-top: 1em">Context independent hhm
pseudocounts (used for templates; used for query if contxt
file is not available):</p>

<p style="margin-top: 1em">-pc_hhm_nocontxt_mode {0,..,3}
<br>
position dependence of pc admixture &rsquo;tau&rsquo; (pc
mode, default=2)</p>

<p style="margin-top: 1em">0: no pseudo counts: <br>
tau = 0</p>

<p style="margin-top: 1em">1: constant <br>
tau = a</p>

<p style="margin-top: 1em">2: diversity-dependent: tau =
a/(1+((Neff[i]-1)/b)^c) (Neff[i]: number of effective seqs
in local MSA around column i)</p>

<p style="margin-top: 1em">-pc_hhm_nocontxt_a <br>
[0,1] overall pseudocount admixture (def=1.0)</p>

<p style="margin-top: 1em">-pc_hhm_nocontxt_b <br>
[1,inf[ Neff threshold value for mode 2 (def=1.5)</p>

<p style="margin-top: 1em">-pc_hhm_nocontxt_c <br>
[0,3] extinction exponent c for mode 2 (def=1.0)</p>

<p style="margin-top: 1em">Context-specific
pseudo-counts:</p>

<p style="margin-top: 1em">-nocontxt <br>
use substitution-matrix instead of context-specific
pseudocounts</p>

<p style="margin-top: 1em">-contxt &lt;file&gt; context
file for computing context-specific pseudocounts
(default=./data/context_data.crf)</p>

<p style="margin-top: 1em">Other options: <br>
-maxres &lt;int&gt; <br>
max number of HMM columns (def=20001)</p>

<p style="margin-top: 1em">Example: hhmake -i test.a3m</p>

<p style="margin-top: 1em">hhmake 3.0~beta2 January 2017
HHMAKE(1)</p>
<hr>
</body>
</html>
