<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>sec(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">sec(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">sec(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
sec - simple event correlator
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sec</b></dt>
  <dd class="It-tag">[--conf=&lt;file pattern&gt; ...]
    <div>&#x00A0;</div>
    [--input=&lt;file pattern&gt;[=&lt;context&gt;] ...]
    <div>&#x00A0;</div>
    [--input-timeout=&lt;input timeout&gt;]
    <div>&#x00A0;</div>
    [--timeout-script=&lt;timeout script&gt;]
    <div>&#x00A0;</div>
    [--reopen-timeout=&lt;reopen timeout&gt;]
    <div>&#x00A0;</div>
    [--check-timeout=&lt;check timeout&gt;]
    <div>&#x00A0;</div>
    [--poll-timeout=&lt;poll timeout&gt;]
    <div>&#x00A0;</div>
    [--socket-timeout=&lt;socket timeout&gt;]
    <div>&#x00A0;</div>
    [--blocksize=&lt;io block size&gt;]
    <div>&#x00A0;</div>
    [--bufsize=&lt;input buffer size&gt;]
    <div>&#x00A0;</div>
    [--evstoresize=&lt;event store size&gt;]
    <div>&#x00A0;</div>
    [--cleantime=&lt;clean time&gt;]
    <div>&#x00A0;</div>
    [--log=&lt;logfile&gt;]
    <div>&#x00A0;</div>
    [--syslog=&lt;facility&gt;]
    <div>&#x00A0;</div>
    [--debug=&lt;debuglevel&gt;]
    <div>&#x00A0;</div>
    [--pid=&lt;pidfile&gt;]
    <div>&#x00A0;</div>
    [--dump=&lt;dumpfile&gt;]
    <div>&#x00A0;</div>
    [--user=&lt;username&gt;]
    <div>&#x00A0;</div>
    [--group=&lt;groupname&gt; ...]
    <div>&#x00A0;</div>
    [--umask=&lt;mode&gt;]
    <div>&#x00A0;</div>
    [--dumpfts | --nodumpfts]
    <div>&#x00A0;</div>
    [--quoting | --noquoting]
    <div>&#x00A0;</div>
    [--tail | --notail]
    <div>&#x00A0;</div>
    [--fromstart | --nofromstart]
    <div>&#x00A0;</div>
    [--detach | --nodetach]
    <div>&#x00A0;</div>
    [--jointbuf | --nojointbuf]
    <div>&#x00A0;</div>
    [--keepopen | --nokeepopen]
    <div>&#x00A0;</div>
    [--rwfifo | --norwfifo]
    <div>&#x00A0;</div>
    [--childterm | --nochildterm]
    <div>&#x00A0;</div>
    [--intevents | --nointevents]
    <div>&#x00A0;</div>
    [--intcontexts | --nointcontexts]
    <div>&#x00A0;</div>
    [--testonly | --notestonly]
    <div>&#x00A0;</div>
    [--help] [-?]
    <div>&#x00A0;</div>
    [--version]</dd>
</dl>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
SEC is an event correlation tool for advanced event processing which can be
  harnessed for event log monitoring, for network and security management, for
  fraud detection, and for any other task which involves event correlation.
  Event correlation is a procedure where a stream of events is processed, in
  order to detect (and act on) certain event groups that occur within predefined
  time windows. Unlike many other event correlation products which are
  heavyweight solutions, SEC is a lightweight and platform-independent event
  correlator which runs as a single process. The user can start it as a daemon,
  employ it in shell pipelines, execute it interactively in a terminal, run many
  SEC processes simultaneously for different tasks, and use it in a wide variety
  of other ways.
<div class="Pp"></div>
SEC reads lines from files, named pipes, or standard input, matches the lines
  with patterns (regular expressions, Perl subroutines, etc.) for recognizing
  input events, and correlates events according to the rules in its
  configuration file(s). Rules are matched against input in the order they are
  given in the configuration file. If there are two or more configuration files,
  rule sequence from every file is matched against input (unless explicitly
  specified otherwise). SEC can produce output by executing external programs
  (e.g., <b>snmptrap</b>(1) or <b>mail</b>(1)), by writing to files, by sending
  data to TCP and UDP based servers, by calling precompiled Perl subroutines,
  etc.
<div class="Pp"></div>
SEC can be run in various ways. For example, the following command line starts
  it as a daemon, in order to monitor events appended to the /var/log/messages
  syslog file with rules from /etc/sec/syslog.rules:
<div class="Pp"></div>
/usr/bin/sec --detach --conf=/etc/sec/syslog.rules \
<br/>
 --input=/var/log/messages
<div class="Pp"></div>
Each time /var/log/messages is rotated, a new instance of /var/log/messages is
  opened and processed from the beginning. The following command line runs SEC
  in a shell pipeline, configuring it to process lines from standard input, and
  to exit when the /usr/bin/nc tool closes its standard output and exits:
<div class="Pp"></div>
/usr/bin/nc -l 8080 | /usr/bin/sec --notail --input=- \
<br/>
 --conf=/etc/sec/my.conf
<div class="Pp"></div>
Some SEC rules start event correlation operations, while other rules react
  immediately to input events or system clock. For example, suppose that SEC has
  been started with the following command line
<div class="Pp"></div>
/usr/bin/sec --conf=/etc/sec/sshd.rules --input=/var/log/secure
<div class="Pp"></div>
in order to monitor the /var/log/secure syslog file for sshd events. Also,
  suppose that the /etc/sec/sshd.rules configuration file contains the following
  rule for correlating SSH failed login syslog events:
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (\S+) from [\d.]+ port \d+ ssh2
<div>&#x00A0;</div>
desc=Three SSH login failures within 1m for user $1
<div>&#x00A0;</div>
action=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost
<div>&#x00A0;</div>
window=60
<div>&#x00A0;</div>
thresh=3
<div class="Pp"></div>
The <i>pattern</i> field of the rule defines the pattern for recognizing input
  events, while the <i>ptype</i> field defines its type (regular expression).
  Suppose that user risto fails to log in over SSH and the following message is
  logged to /var/log/secure:
<div class="Pp"></div>
Dec 16 16:24:59 myserver sshd[13685]: Failed password for risto from 10.12.2.5
  port 41063 ssh2
<div class="Pp"></div>
This input message will match the regular expression pattern of the above rule,
  and the match variable $1 will be set to the string <i>risto</i> (see
  <b>perlre</b>(1) for details). After a match, SEC will evaluate the operation
  description string given with the <i>desc</i> field. This is done by
  substituting $1 with its current value which yields <i>Three SSH login
  failures within 1m for user risto</i>. SEC will then check if there already
  exists an event correlation operation identified with this string and
  triggered by the same rule. If the operation is not found, SEC will create a
  new operation for the user name risto, and the occurrence time of the input
  event will be recorded into the operation. Note that for event occurrence time
  SEC always uses the current time as returned by the <b>time</b>(2) system
  call, *not* the timestamp extracted from the event. Suppose that after 25
  seconds, a similar SSH login failure event for the same user name is observed.
  In this case, a running operation will be found for the operation description
  string <i>Three SSH login failures within 1m for user risto</i>, and the
  occurrence time of the second event is recorded into the operation. If after
  30 seconds a third event for the user name risto is observed, the operation
  has processed 3 events within 55 seconds. Since the threshold condition
  &quot;3 events within 60 seconds&quot; (as defined by the <i>thresh</i> and
  <i>window</i> fields) is now satisfied, SEC will execute the action defined
  with the <i>action</i> field -- it will fork a command
<div class="Pp"></div>
/bin/mail -s 'SSH login alert' root@localhost
<div class="Pp"></div>
with a pipe connected to its standard input. Then, SEC writes the operation
  description string <i>Three SSH login failures within 1m for user risto</i>
  (held by the %s special variable) to the standard input of the command through
  the pipe. In other words, an e-mail warning is sent to the local root-user.
  Finally, since there are 5 seconds left until the end of the event correlation
  window, the operation will consume the following SSH login failure events for
  user risto without any further action, and finish after 5 seconds.
<div class="Pp"></div>
The above example illustrates that the <i>desc</i> field of a rule defines the
  scope of event correlation and influences the number of operations created by
  the rule. For example, if we set the <i>desc</i> field to <i>Three SSH login
  failures within 1m</i>, the root-user would be also alerted on 3 SSH login
  failure events for *different* users within 1 minute. In order to avoid
  clashes between operations started by different rules, operation ID contains
  not only the value set by the <i>desc</i> field, but also the rule file name
  and the rule number inside the file. For example, if the rule file
  /etc/sec/sshd.rules contains one rule
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (\S+) from [\d.]+ port \d+ ssh2
<div>&#x00A0;</div>
desc=Three SSH login failures within 1m for user $1
<div>&#x00A0;</div>
action=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost
<div>&#x00A0;</div>
window=60
<div>&#x00A0;</div>
thresh=3
<div class="Pp"></div>
and the event
<div class="Pp"></div>
Dec 16 16:24:59 myserver sshd[13685]: Failed password for risto from 10.12.2.5
  port 41063 ssh2
<div class="Pp"></div>
is the first matching event for the above rule, this event will trigger a new
  event correlation operation with the ID
<div class="Pp"></div>
/etc/sec/sshd.rules | 0 | Three SSH login failures within 1m for user risto
<div class="Pp"></div>
(0 is the number assigned to the first rule in the file, see EVENT CORRELATION
  OPERATIONS section for more information).
<div class="Pp"></div>
The following simple example demonstrates that event correlation schemes can be
  defined by combining several rules. In this example, two rules harness
  contexts and synthetic events for achieving their goal:
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (\S+) from [\d.]+ port \d+ ssh2
<div>&#x00A0;</div>
desc=Three SSH login failures within 1m for user $1
<div>&#x00A0;</div>
action=event 3_SSH_LOGIN_FAILURES_FOR_$1
<div>&#x00A0;</div>
window=60
<div>&#x00A0;</div>
thresh=3
<div class="Pp"></div>
type=EventGroup
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=3_SSH_LOGIN_FAILURES_FOR_(\S+)
<div>&#x00A0;</div>
context=!USER_$1_COUNTED &amp;&amp; !COUNTING_OFF
<div>&#x00A0;</div>
count=create USER_$1_COUNTED 60
<div>&#x00A0;</div>
desc=Repeated SSH login failures for 30 distinct users within 1m
<div>&#x00A0;</div>
action=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost; \
<br/>
 create COUNTING_OFF 3600
<div>&#x00A0;</div>
window=60
<div>&#x00A0;</div>
thresh=30
<div class="Pp"></div>
The first rule looks almost identical to the rule from the previous example, but
  its <i>action</i> field is different -- after three SSH login failures have
  been observed for the same user name within one minute by an event correlation
  operation, the operation will emit the synthetic event
  3_SSH_LOGIN_FAILURES_FOR_&lt;username&gt;. Although synthetic events are
  created by SEC, they are treated like regular events received from input
  sources and are matched against rules. The regular expression pattern of the
  second rule will match the 3_SSH_LOGIN_FAILURES_FOR_&lt;username&gt; event and
  start a new event correlation operation if no such events have been previously
  seen. Also, each time a synthetic event for some user name has matched the
  rule, a context with the lifetime of 1 minute for that user name is created
  (see the <i>count</i> field). Note that this prevents further matches for the
  same user name, since a synthetic event for &lt;username&gt; can match the
  rule only if the context USER_&lt;username&gt;_COUNTED *does not* exist (as
  requested by the boolean expression in the <i>context</i> field; see CONTEXTS
  AND CONTEXT EXPRESSIONS section for more information). The operation started
  by the rule sends an e-mail warning to the local root-user if 30 synthetic
  events have been observed within 1 minute (see the <i>thresh</i> and
  <i>window</i> fields). Note that due to the use of the
  USER_&lt;username&gt;_COUNTED contexts, all synthetic events concern different
  user names. After sending an e-mail warning, the operation will also create
  the context COUNTING_OFF with the lifetime of 1 hour, and will continue to run
  until the 1 minute event correlation window expires. After the operation has
  finished, the presence of the COUNTING_OFF context will keep the second rule
  disabled (as requested by the boolean expression in the <i>context</i> field).
  Therefore, at most one e-mail warning per 1 hour is issued by above rules.
<div class="Pp"></div>
The above examples have presented the event correlation capabilities of SEC in a
  very brief fashion. The following sections will provide an in-depth discussion
  of SEC features.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--conf=&lt;file_pattern&gt;</b></dt>
  <dd class="It-tag">expand &lt;file_pattern&gt; to filenames (with the Perl
      <b>glob</b>() function) and read event correlation rules from every file.
      Multiple <b>--conf</b> options can be specified at command line. Each time
      SEC receives a signal that forces a configuration reload,
      &lt;file_pattern&gt; is re-evaluated. See also INPUT PROCESSING AND TIMING
      section for a discussion on rule processing order for multiple
      configuration files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--input=&lt;file_pattern&gt;[=&lt;context&gt;]</b></dt>
  <dd class="It-tag">expand &lt;file_pattern&gt; to filenames (with the Perl
      <b>glob</b>() function) and use the files as input sources. An input file
      can be a regular file, named pipe, or standard input if <b>-</b> was
      specified. Multiple <b>--input</b> options can be specified at command
      line. Each time SEC receives the <b>SIGHUP</b> or <b>SIGABRT</b> signal,
      &lt;file_pattern&gt; is re-evaluated. If SEC experiences a system error
      when reading from an input file, it will close the file (use the
      <b>--reopen-timeout</b> option for reopening the file). If &lt;context&gt;
      is given, SEC will set up the context &lt;context&gt; each time it reads a
      line from input files that correspond to &lt;file_pattern&gt;. This will
      help the user to write rules that match data from particular input
      source(s) only. When there is an <b>--input</b> option with
      &lt;context&gt; specified, it will automatically enable the
      <b>--intcontexts</b> option. See INTERNAL EVENTS AND CONTEXTS section for
      more information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--input-timeout=&lt;input_timeout&gt;</b>,
    <b>--timeout-script=&lt;timeout_script&gt;</b></dt>
  <dd class="It-tag">if SEC has not observed new data in an input file during
      &lt;input_timeout&gt; seconds (or the file was closed
      &lt;input_timeout&gt; seconds ago), &lt;timeout_script&gt; will be
      executed with command line parameters 1 and &lt;the name of the input
      file&gt;. If fresh data become available again, &lt;timeout_script&gt;
      will be executed with command line parameters 0 and &lt;the name of the
      input file&gt;. Setting &lt;input_timeout&gt; to 0 disables this behavior
      (this is also the default). Note that <b>--input_timeout</b> and
      <b>--timeout_script</b> options can be used as synonyms for
      <b>--input-timeout</b> and <b>--timeout-script</b>, respectively.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--reopen-timeout=&lt;reopen_timeout&gt;</b></dt>
  <dd class="It-tag">if an input file is in the closed state (e.g., SEC fails to
      open the file at startup, because it has not been created yet), SEC will
      attempt to reopen the file after every &lt;reopen_timeout&gt; seconds
      until open succeeds. Setting &lt;reopen_timeout&gt; to 0 disables this
      behavior (this is also the default). This option has no meaning when the
      <b>--notail</b> option is also specified. Note that
      <b>--reopen_timeout</b> is a synonym for <b>--reopen-timeout</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--check-timeout=&lt;check_timeout&gt;</b></dt>
  <dd class="It-tag">if SEC has not observed new data in an input file, the file
      will not be polled (both for status and data) during the next
      &lt;check_timeout&gt; seconds. Setting &lt;check_timeout&gt; to 0 disables
      this behavior (this is also the default). Note that <b>--check_timeout</b>
      is a synonym for <b>--check-timeout</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--poll-timeout=&lt;poll_timeout&gt;</b></dt>
  <dd class="It-tag">a real number that specifies how many seconds SEC will
      sleep when no new data were read from input files. Default is 0.1 seconds.
      Note that <b>--poll_timeout</b> is a synonym for
    <b>--poll-timeout</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--socket-timeout=&lt;socket_timeout&gt;</b></dt>
  <dd class="It-tag">if a network connection to a remote peer can't be
      established within &lt;socket_timeout&gt; seconds, give up. Default is 60
      seconds. Note that <b>--socket_timeout</b> is a synonym for
      <b>--socket-timeout</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--blocksize=&lt;io_block_size&gt;</b></dt>
  <dd class="It-tag">the number of bytes SEC will attempt to read at once from
      an input file. Default is 8192 bytes (i.e., read from input files by 8KB
      blocks).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bufsize=&lt;input_buffer_size&gt;</b></dt>
  <dd class="It-tag">set all input buffers to hold &lt;input_buffer_size&gt;
      lines. The content of input buffers will be compared with patterns that
      are part of rule definitions (i.e., no more than &lt;input_buffer_size&gt;
      lines can be matched by a pattern at a time). If &lt;input_buffer_size&gt;
      is set to 0, SEC will determine the proper value for
      &lt;input_buffer_size&gt; by checking event matching patterns of all SEC
      rules. Default is 0 (i.e., determine the size of input buffers
      automatically).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--evstoresize=&lt;event_store_size&gt;</b></dt>
  <dd class="It-tag">set an upper limit to the number of events in context event
      stores. Default is 0 which sets no limit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--cleantime=&lt;clean_time&gt;</b></dt>
  <dd class="It-tag">time interval in seconds that specifies how often internal
      event correlation and context lists are processed, in order to accomplish
      time-related tasks and to remove obsolete elements. See INPUT PROCESSING
      AND TIMING section for more information. Default is 1 second.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--log=&lt;logfile&gt;</b></dt>
  <dd class="It-tag">use &lt;logfile&gt; for logging SEC activities. Note that
      if the SEC standard error is connected to a terminal, messages will also
      be logged there, in order to facilitate debugging.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--syslog=&lt;facility&gt;</b></dt>
  <dd class="It-tag">use syslog for logging SEC activities. All messages will be
      logged with the facility &lt;facility&gt;, e.g., <i>local0</i> (see
      <b>syslog</b>(3) for possible facility values). Warning: be careful with
      using this option if SEC is employed for monitoring syslog log files,
      because message loops might occur.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--debug=&lt;debuglevel&gt;</b></dt>
  <dd class="It-tag">set logging verbosity for SEC. Setting debuglevel to
      &lt;debuglevel&gt; means that all messages of level &lt;debuglevel&gt; and
      lower are logged (e.g., if &lt;debuglevel&gt; is 3, messages from levels
      1-3 are logged). The following levels are recognized by SEC:
    <div>&#x00A0;</div>
    1 - critical messages (severe faults that cause SEC to terminate, e.g., a
      failed system call)
    <div>&#x00A0;</div>
    2 - error messages (faults that need attention, e.g., an incorrect rule
      definition in a configuration file)
    <div>&#x00A0;</div>
    3 - warning messages (possible faults, e.g., a command forked from SEC
      terminated with a non-zero exit code)
    <div>&#x00A0;</div>
    4 - notification messages (normal system level events and interrupts, e.g.,
      the reception of a signal)
    <div>&#x00A0;</div>
    5 - informative messages (information about external programs forked from
      SEC)
    <div>&#x00A0;</div>
    6 - debug messages (detailed information about all SEC activities)
    <div>&#x00A0;</div>
    Default &lt;debuglevel&gt; is 6 (i.e., log everything). See SIGNALS section
      for information on how to change &lt;debuglevel&gt; at runtime.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pid=&lt;pidfile&gt;</b></dt>
  <dd class="It-tag">SEC will store its process ID to &lt;pidfile&gt; at
      startup.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dump=&lt;dumpfile&gt;</b></dt>
  <dd class="It-tag">SEC will use &lt;dumpfile&gt; as its dump file for writing
      performance and debug data. With the <b>--dumpfts</b> option, a timestamp
      suffix is appended to the dump file name. See SIGNALS section for more
      information. Default is /tmp/sec.dump.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--user=&lt;username&gt;</b>,
    <b>--group=&lt;groupname&gt;</b></dt>
  <dd class="It-tag">if SEC is started with effective user ID 0, it will drop
      root privileges by switching to user &lt;username&gt; and group
      &lt;groupname&gt;. The <b>--group</b> option can't be used without the
      <b>--user</b> option. If the <b>--user</b> option is given without
      <b>--group</b>, primary group of the user &lt;username&gt; is assumed for
      &lt;groupname&gt;. If several groups are provided with multiple
      <b>--group</b> options, SEC switches to the first group with other groups
      as supplementary groups.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--umask=&lt;mode&gt;</b></dt>
  <dd class="It-tag">set file mode creation mask to &lt;mode&gt; at SEC startup,
      where &lt;mode&gt; is a value from the range 0..0777 (see also
      <b>umask</b>(2)). Octal, decimal, hexadecimal, and binary values can be
      specified for &lt;mode&gt; (e.g., octal mask 0027 can also be expressed as
      23, 0x17, and 0b000010111).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dumpfts</b>, <b>--nodumpfts</b></dt>
  <dd class="It-tag">if the <b>--dumpfts</b> option is specified, a timestamp
      suffix (seconds since Epoch) is appended to the dump file name that
      reflects the file creation time. Default is <b>--nodumpfts</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quoting</b>, <b>--noquoting</b></dt>
  <dd class="It-tag">if the <b>--quoting</b> option is specified, operation
      description strings that are supplied to command lines of <i>shellcmd</i>,
      <i>spawn</i>, and <i>cspawn</i> actions will be put inside single quotes.
      Each single quote (') that strings originally contain will be masked. This
      option prevents the shell from interpreting special symbols that operation
      description strings might contain. Default is <b>--noquoting</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--tail</b>, <b>--notail</b></dt>
  <dd class="It-tag">if the <b>--notail</b> option is specified, SEC will
      process all data that are currently available in input files and exit
      after reaching all EOFs. If all input is received from a pipe and the
      <b>--notail</b> option is given, SEC terminates when the last writer
      closes the pipe (EOF condition). Please note that with named pipes
      <b>--notail</b> should be used with <b>--norwfifo</b>. With the
      <b>--tail</b> option, SEC will jump to the end of input files and wait for
      new lines to arrive. Each input file is tracked both by its name and
      i-node, and input file rotations are handled seamlessly. If the input file
      is recreated or truncated, SEC will reopen it and process its content from
      the beginning. If the input file is removed (i.e., there is just an i-node
      left without a name), SEC will keep the i-node open and wait for the input
      file recreation. Default is <b>--tail</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--fromstart</b>, <b>--nofromstart</b></dt>
  <dd class="It-tag">these flags have no meaning when the <b>--notail</b> option
      is also specified. When used in combination with <b>--tail</b> (or alone,
      since <b>--tail</b> is enabled by default), <b>--fromstart</b> will force
      SEC to read and process input files from the beginning to the end, before
      the 'tail' mode is entered. Default is <b>--nofromstart</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--detach</b>, <b>--nodetach</b></dt>
  <dd class="It-tag">if the <b>--detach</b> option is specified, SEC will
      disassociate itself from the controlling terminal and become a daemon at
      startup (note that SEC will close its standard input, standard output, and
      standard error, and change its working directory to the root directory).
      Default is <b>--nodetach</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--jointbuf</b>, <b>--nojointbuf</b></dt>
  <dd class="It-tag">if the <b>--jointbuf</b> option is specified, SEC uses
      joint input buffer for all input sources (the size of the buffer is set
      with the <b>--bufsize</b> option). The <b>--nojointbuf</b> option creates
      a separate input buffer for each input file, and a separate buffer for all
      synthetic and internal events (the sizes of all buffers are set with the
      <b>--bufsize</b> option). The <b>--jointbuf</b> option allows multiline
      patterns to match lines from several input sources, while the
      <b>--nojointbuf</b> pattern restricts the matching to lines from one input
      source only. See INPUT PROCESSING AND TIMING section for more information.
      If the size of input buffer(s) is 1 (either explicitly set with
      <b>--bufsize=1</b> or automatically determined from SEC rules),
      <b>--jointbuf</b> option is enabled, otherwise the default is
      <b>--nojointbuf</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--keepopen</b>, <b>--nokeepopen</b></dt>
  <dd class="It-tag">if the <b>--keepopen</b> option is specified, SEC will keep
      input files open across soft restarts. When the <b>SIGABRT</b> signal is
      received, SEC will not reopen input files which have been opened
      previously, but will only open input files which are in the closed state.
      The <b>--nokeepopen</b> option forces SEC to close and (re)open all input
      files during soft restarts. Default is <b>--keepopen</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rwfifo</b>, <b>--norwfifo</b></dt>
  <dd class="It-tag">if the <b>--norwfifo</b> option is specified, named pipe
      input files are opened in read-only mode. In this mode, the named pipe has
      to be reopened when the last writer closes the pipe, in order to clear the
      EOF condition on the pipe. With the <b>--rwfifo</b> option, named pipe
      input files are opened in read-write mode, although SEC never writes to
      the pipes. In this mode, the pipe does not need to be reopened when an
      external writer closes it, since there is always at least one writer on
      the pipe and EOF will never appear. Therefore, if the <b>--notail</b>
      option has been given, <b>--norwfifo</b> should also be specified. Default
      is <b>--rwfifo</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--childterm</b>, <b>--nochildterm</b></dt>
  <dd class="It-tag">if the <b>--childterm</b> option is specified, SEC will
      send the SIGTERM signal to all its child processes when it terminates or
      goes through a full restart. Default is <b>--childterm</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--intevents</b>, <b>--nointevents</b></dt>
  <dd class="It-tag">SEC will generate internal events when it starts up, when
      it receives certain signals, and when it terminates gracefully. Specific
      rules can be written to match those internal events, in order to
      accomplish special tasks at SEC startup, restart, and shutdown. See
      INTERNAL EVENTS AND CONTEXTS section for more information. Default is
      <b>--nointevents</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--intcontexts</b>, <b>--nointcontexts</b></dt>
  <dd class="It-tag">SEC will create an internal context when it reads a line
      from an input file. This will help the user to write rules that match data
      from particular input source only. See INTERNAL EVENTS AND CONTEXTS
      section for more information. Default is <b>--nointcontexts</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--testonly</b>, <b>--notestonly</b></dt>
  <dd class="It-tag">if the <b>--testonly</b> option is specified, SEC will exit
      immediately after parsing the configuration file(s). If the configuration
      file(s) contained no faulty rules, SEC will exit with 0, otherwise with 1.
      Default is <b>--notestonly</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help</b>, <b>-?</b></dt>
  <dd class="It-tag">SEC will output usage information and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--version</b></dt>
  <dd class="It-tag">SEC will output version information and exit.</dd>
</dl>
<div class="Pp"></div>
Note that options can be introduced both with the single dash (-) and double
  dash (--), and both the equal sign (=) and whitespace can be used for
  separating the option name from the option value. For example,
  <b>-conf=&lt;file_pattern&gt;</b> and <b>--conf &lt;file_pattern&gt;</b>
  options are equivalent.
<h1 class="Sh" title="Sh" id="CONFIGURATION_FILES"><a class="selflink" href="#CONFIGURATION_FILES">CONFIGURATION
  FILES</a></h1>
Each SEC configuration file consists of rule definitions which are separated by
  empty lines, whitespace lines and/or comment lines. Each rule definition
  consists of keyword=value fields, one keyword and value per line. Values are
  case insensitive only where character case is not important (like the values
  specifying rule types, e.g., 'Single' and 'single' are treated identically).
  The backslash character (\) may be used at the end of a line to continue the
  current rule field in the next line. Lines which begin with the number sign
  (#) are treated as comments and ignored (whitespace characters may precede #).
  Any comment line, empty line, whitespace line, or end of file will terminate
  the preceding rule definition. For inserting comments into rule definitions,
  the <i>rem</i> keyword can be used. For example, the following lines define
  two rules:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
rem=this rule matches any line which contains \
<br/>
 three consecutive A characters and writes the string \
<br/>
 &quot;three A characters were observed&quot; to standard output
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=AAA
<div>&#x00A0;</div>
desc=Three A characters
<div>&#x00A0;</div>
action=write - three A characters were observed
<div>&#x00A0;</div>
# This comment line ends preceding rule definition.
<div>&#x00A0;</div>
# The following rule works like the previous rule,
<div>&#x00A0;</div>
# but looks for three consecutive B characters and
<div>&#x00A0;</div>
# writes the string &quot;three B characters were observed&quot;
<div>&#x00A0;</div>
# to standard output
<div>&#x00A0;</div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=BBB
<div>&#x00A0;</div>
desc=Three B characters
<div>&#x00A0;</div>
action=write - three B characters were observed
<div class="Pp"></div>
Apart from keywords that are part of rule definitions, <i>label</i> keywords may
  appear anywhere in the configuration file. The value of each <i>label</i>
  keyword will be treated as a label that can be referred to in rule definitions
  as a point-of-continue. This allows for continuing event processing at a rule
  that follows the label, after the current rule has matched and processed the
  event.
<div class="Pp"></div>
The points-of-continue are defined with <i>continue*</i> fields. Accepted values
  for these fields are:
<dl class="Bl-tag">
  <dt class="It-tag"><i>TakeNext</i></dt>
  <dd class="It-tag">after an event has matched the rule, search for matching
      rules in the configuration file will continue from the next rule.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>GoTo &lt;label&gt;</i></dt>
  <dd class="It-tag">after an event has matched the rule, search for matching
      rules will continue from the location of &lt;label&gt; in the
      configuration file (&lt;label&gt; must be defined with the <i>label</i>
      keyword anywhere in the configuration file *after* the current rule
      definition).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>DontCont</i> (default value)</dt>
  <dd class="It-tag">after an event has matched the rule, search for matching
      rules ends in the *current* configuration file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>EndMatch</i></dt>
  <dd class="It-tag">after an event has matched the rule, search for matching
      rules ends for *all* configuration files.</dd>
</dl>
<div class="Pp"></div>
SEC rules from the same configuration file are matched against input in the
  order they have been given in the file. For example, consider a configuration
  file which contains the following rule sequence:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=AAA
<div>&#x00A0;</div>
rem=after this rule has matched, continue from last rule
<div>&#x00A0;</div>
continue=GoTo lastRule
<div>&#x00A0;</div>
desc=Three A characters
<div>&#x00A0;</div>
action=write - three A characters were observed
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=BBB
<div>&#x00A0;</div>
rem=after this rule has matched, don't consider following rules, \
<br/>
 since 'continue' defaults to 'DontCont'
<div>&#x00A0;</div>
desc=Three B characters
<div>&#x00A0;</div>
action=write - three B characters were observed
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=CCC
<div>&#x00A0;</div>
rem=after this rule has matched, continue from next rule
<div>&#x00A0;</div>
continue=TakeNext
<div>&#x00A0;</div>
desc=Three C characters
<div>&#x00A0;</div>
action=write - three C characters were observed
<div class="Pp"></div>
label=lastRule
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=DDD
<div>&#x00A0;</div>
desc=Three D characters
<div>&#x00A0;</div>
action=write - three D characters were observed
<div class="Pp"></div>
For the input line &quot;AAABBBCCCDDD&quot;, this ruleset writes strings
  &quot;three A characters were observed&quot; and &quot;three D characters were
  observed&quot; to standard output. If the input line is &quot;BBBCCCDDD&quot;,
  the string &quot;three B characters were observed&quot; is written to standard
  output. For the input line &quot;CCCDDD&quot;, strings &quot;three C
  characters were observed&quot; and &quot;three D characters were
  observed&quot; are sent to standard output, while the input line
  &quot;DDD&quot; produces the output string &quot;three D characters were
  observed&quot;.
<div class="Pp"></div>
If there are two or more configuration files, rule sequence from every file is
  matched against input (unless explicitly specified otherwise). For example,
  suppose SEC is started with the command line
<div class="Pp"></div>
/usr/bin/sec --input=- \
<br/>
 --conf=/etc/sec/sec1.rules --conf=/etc/sec/sec2.rules
<div class="Pp"></div>
and the configuration file /etc/sec/sec1.rules has the following content:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=AAA
<div>&#x00A0;</div>
desc=Three A characters
<div>&#x00A0;</div>
action=write - three A characters were observed
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=BBB
<div>&#x00A0;</div>
continue=EndMatch
<div>&#x00A0;</div>
desc=Three B characters
<div>&#x00A0;</div>
action=write - three B characters were observed
<div class="Pp"></div>
Also, suppose the configuration file /etc/sec/sec2.rules has the following
  content:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=CCC
<div>&#x00A0;</div>
desc=Three C characters
<div>&#x00A0;</div>
action=write - three C characters were observed
<div class="Pp"></div>
If SEC receives the line &quot;AAABBBCCC&quot; from standard input, rules from
  both configuration files are tried, and as a result, the strings &quot;three A
  characters were observed&quot; and &quot;three C characters were
  observed&quot; are written to standard output. Note that rules from
  /etc/sec/sec1.rules are tried first against the input line, since the option
  <b>--conf=/etc/sec/sec1.rules</b> is given before
  <b>--conf=/etc/sec/sec2.rules</b> in the SEC command line (see also INPUT
  PROCESSING AND TIMING section for a more detailed discussion). If SEC receives
  the line &quot;BBBCCC&quot; from standard input, the second rule from
  /etc/sec/sec1.rules produces a match, and the string &quot;three B characters
  were observed&quot; is written to standard output. Since the rule contains
  <i>continue=EndMatch</i> statement, the search for matching rules will end for
  all configuration files, and rules from /etc/sec/sec2.rules will not be not
  tried. Without this statement, the search for matching rules would continue in
  /etc/sec/sec2.rules, and the first rule would write the string &quot;three C
  characters were observed&quot; to standard output.
<h1 class="Sh" title="Sh" id="PATTERNS,_PATTERN_TYPES_AND_MATCH_VARIABLES"><a class="selflink" href="#PATTERNS,_PATTERN_TYPES_AND_MATCH_VARIABLES">PATTERNS,
  PATTERN TYPES AND MATCH VARIABLES</a></h1>
Patterns and pattern types are defined with <i>pattern*</i> and <i>ptype*</i>
  rule fields. Many pattern types define the number of lines <i>N</i> which the
  pattern matches (if <i>N</i> is omitted, 1 is assumed). If <i>N</i> is greater
  than 1, the scope of matching is set with the <b>--jointbuf</b> and
  <b>--nojointbuf</b> options. With <b>--jointbuf</b>, the pattern is used for
  matching <i>N</i> last input lines taken from the joint input buffer (the
  lines can come from different input sources). With <b>--nojointbuf</b>, the
  source of the last input line is identified, and the pattern is matched with
  <i>N</i> last input lines from the input buffer of the identified source.
<dl class="Bl-tag">
  <dt class="It-tag"><i>SubStr[N]</i></dt>
  <dd class="It-tag">pattern is a string that is searched in the last N input
      lines L1, L2, ..., LN. If N is greater than 1, the input lines are joined
      into a string
      &quot;L1&lt;NEWLINE&gt;L2&lt;NEWLINE&gt;...&lt;NEWLINE&gt;LN&quot;, and
      the pattern string will be searched from it. If the pattern string is
      found in input line(s), the pattern matches. Backslash sequences \t, \n,
      \r, \s, and \0 can be used in the pattern for denoting tabulation,
      newline, carriage return, space character, and empty string, respectively,
      while \\ denotes backslash itself. For example, consider the following
      pattern definition:
    <div style="height: 1.00em;">&#x00A0;</div>
    ptype=substr
    <div>&#x00A0;</div>
    pattern=Backup done:\tsuccess
    <div style="height: 1.00em;">&#x00A0;</div>
    The pattern matches lines containing &quot;Backup
      done:&lt;TAB&gt;success&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that since the <i>SubStr[N]</i> pattern type has been designed for fast
      matching, it does not support match variables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>RegExp[N]</i></dt>
  <dd class="It-tag">pattern is a Perl regular expression (see <b>perlre</b>(1)
      for more information) for matching the last N input lines L1, L2, ..., LN.
      If N is greater than 1, the input lines are joined into a string
      &quot;L1&lt;NEWLINE&gt;L2&lt;NEWLINE&gt;...&lt;NEWLINE&gt;LN&quot;, and
      the regular expression is matched with this string. If the regular
      expression matches, match variables will be set, and these match variables
      can be used in other parts of the rule definition.
    <div style="height: 1.00em;">&#x00A0;</div>
    In addition to numbered match variables ($1, $2, etc.), SEC supports named
      match variables $+{name} and the $0 variable. The $0 variable holds the
      entire string of last N input lines that the regular expression has
      matched. Named match variables can be created in newer versions of Perl
      regular expression language, e.g., (?&lt;myvar&gt;AB|CD) sets $+{myvar} to
      AB or CD. The special named match variable $+{_inputsrc} is created by SEC
      and holds input file name(s) where matching line(s) came from.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, the following pattern matches the SSH &quot;Connection
      from&quot; event, and sets $0 to the entire event line, both $1 and $+{ip}
      to the IP address of the remote node, $2 to the port number at the remote
      node, and $+{_inputsrc} to the input file name:
    <div style="height: 1.00em;">&#x00A0;</div>
    ptype=RegExp
    <div>&#x00A0;</div>
    pattern=sshd\[\d+\]: Connection from (?&lt;ip&gt;[\d.]+) port (\d+)
    <div style="height: 1.00em;">&#x00A0;</div>
    Also, SEC allows for match caching and for the creation of additional named
      match variables through variable maps which are defined with the
      <i>varmap*</i> fields. Variable map is a list of <i>name=number</i>
      mappings separated by semicolons, where <i>name</i> is the name for the
      named variable and <i>number</i> identifies a numbered match variable that
      is set by the regular expression. Each name must begin with a letter and
      consist of letters, digits and underscores. After the regular expression
      has matched, named variables specified by the map are created from
      corresponding numbered variables. If the same named variable is set up
      both from the regular expression and variable map, the map takes
      precedence.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>name</i> is not followed by the equal sign and number in the
      <i>varmap*</i> field, it is regarded as a common name for all match
      variables and their values from a successful match. This name is used for
      caching a successful match by the pattern -- match variables and their
      values are stored in the memory-based pattern match cache under
      <i>name</i>. Cached match results can be reused by <i>Cached</i> and
      <i>NCached</i> patterns. Note that before processing each new input line,
      previous content of the pattern match cache is cleared. Also note that a
      successful pattern match is cached even if the subsequent context
      expression evaluation yields FALSE (see INPUT PROCESSING AND TIMING
      section for more information).
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, consider the following pattern definition:
    <div style="height: 1.00em;">&#x00A0;</div>
    ptype=regexp
    <div>&#x00A0;</div>
    pattern=(?i)(\S+\.mydomain).*printer: toner\/ink low
    <div>&#x00A0;</div>
    varmap=printer_toner_or_ink_low; message=0; hostname=1
    <div style="height: 1.00em;">&#x00A0;</div>
    The pattern matches &quot;printer: toner/ink low&quot; messages in a case
      insensitive manner from printers belonging to .mydomain. Note that the
      printer hostname is assigned to $1 and $+{hostname}, while the whole
      message line is assigned to $0 and $+{message}. The name of the file where
      message line came from is assigned to $+{_inputsrc}. Also, these variables
      and their values are stored to the pattern match cache under the name
      &quot;printer_toner_or_ink_low&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    The following pattern definition produces a match if the last two input
      lines are AAA and BBB:
    <div style="height: 1.00em;">&#x00A0;</div>
    ptype=regexp2
    <div>&#x00A0;</div>
    pattern=^AAA\nBBB$
    <div>&#x00A0;</div>
    varmap=aaa_bbb
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that with the <b>--nojointbuf</b> option the pattern only matches if
      the matching lines are coming from the *same* input file, while the
      <b>--jointbuf</b> option lifts that restriction.
    <div style="height: 1.00em;">&#x00A0;</div>
    In the case of a match, $0 is set to &quot;AAA&lt;NEWLINE&gt;BBB&quot; and
      $+{_inputsrc} to file name(s) for matching lines. Also, these
      variable-value pairs are cached under the name &quot;aaa_bbb&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>PerlFunc[N]</i></dt>
  <dd class="It-tag">pattern is a Perl function for matching the last N input
      lines L1, L2, ..., LN. The Perl function is compiled at SEC startup with
      the Perl <b>eval</b>() function, and <b>eval</b>() must return a code
      reference for the pattern to be valid (see also PERL INTEGRATION section).
      The function is called in Perl list context, and with the
      <b>--jointbuf</b> option, lines L1, L2, ..., LN and the names of
      corresponding input files F1, F2, ..., FN are passed to the function as
      parameters:
    <div style="height: 1.00em;">&#x00A0;</div>
    function(L1, L2, ..., LN, F1, F2, ..., FN)
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that with the <b>--nojointbuf</b> option, the function is called with a
      single file name parameter F, since lines L1, ..., LN are coming from the
      same input file:
    <div style="height: 1.00em;">&#x00A0;</div>
    function(L1, L2, ..., LN, F)
    <div style="height: 1.00em;">&#x00A0;</div>
    Also note that if the input line is a synthetic event, the input file name
      is Perl undefined value.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the function returns several values or a single value that is true in
      Perl boolean context, the pattern matches. If the function returns no
      values or a single value that is false in Perl boolean context (0, empty
      string or undefined value), the pattern does not match. If the pattern
      matches, return values will be assigned to numbered match variables ($1,
      $2, etc.). Like with RegExp patterns, the $0 variable is set to matching
      input line(s), the $+{_inputsrc} variable is set to input file name(s),
      and named match variables can be created from variable maps. For example,
      consider the following pattern definition:
    <div style="height: 1.00em;">&#x00A0;</div>
    ptype=perlfunc2
    <div>&#x00A0;</div>
    pattern=sub { return ($_[0] cmp $_[1]); }
    <div style="height: 1.00em;">&#x00A0;</div>
    The pattern compares last two input lines in a stringwise manner ($_[1]
      holds the last line and $_[0] the preceding one), and matches if the lines
      are different. Note that the result of the comparison is assigned to $1,
      while two matching lines are concatenated (with the newline character
      between them) and assigned to $0. The file name(s) for matching lines are
      assigned to $+{_inputsrc}.
    <div style="height: 1.00em;">&#x00A0;</div>
    The following pattern produces a match for any line, and sets $1, $2 and $3
      variables to strings &quot;abc&quot;, &quot;def&quot; and &quot;ghi&quot;,
      respectively (also, $0 is set to the whole input line and $+{_inputsrc} to
      the input file name):
    <div style="height: 1.00em;">&#x00A0;</div>
    ptype=perlfunc
    <div>&#x00A0;</div>
    pattern=sub { return (&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;); }
    <div style="height: 1.00em;">&#x00A0;</div>
    The following pattern definition produces a match if the input line is not a
      synthetic event and contains either the string &quot;abc&quot; or
      &quot;def&quot;. The $0 variable is set to the matching line, while $1,
      $+{file} and $+{_inputsrc} are set to the name of the input file:
    <div style="height: 1.00em;">&#x00A0;</div>
    ptype=perlfunc
    <div>&#x00A0;</div>
    pattern=sub { if (defined($_[1]) &amp;&amp; $_[0] =~ /abc|def/) \
    <div>&#x00A0;</div>
    { return $_[1]; } return 0; }
    <div>&#x00A0;</div>
    varmap= file=1
    <div style="height: 1.00em;">&#x00A0;</div>
    Finally, if a function pattern returns a single value which is a reference
      to a Perl hash, named match variables are created from key-value pairs in
      the hash. For example, the following pattern matches a line if it contains
      either the string &quot;three&quot; or &quot;four&quot;. Apart from
      setting $0 and $+{_inputsrc}, the pattern also creates match variables
      $+{three} and $+{four}, and sets them to 3 and 4, respectively:
    <div style="height: 1.00em;">&#x00A0;</div>
    ptype=perlfunc
    <div>&#x00A0;</div>
    pattern=sub { my(%hash); \
    <div>&#x00A0;</div>
    if ($_[0] !~ /three|four/) { return 0; } \
    <div>&#x00A0;</div>
    $hash{&quot;three&quot;} = 3; $hash{&quot;four&quot;} = 4; return \%hash;
    }</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>Cached</i></dt>
  <dd class="It-tag">pattern is a name that is searched in the pattern match
      cache (entries are stored into the cache with the <i>varmap*</i> fields).
      If an entry with the given name is found in the cache, the pattern
      matches, and match variables and values are retrieved from the cache. For
      example, if the input line matches the following pattern
    <div style="height: 1.00em;">&#x00A0;</div>
    ptype=perlfunc
    <div>&#x00A0;</div>
    pattern=sub { if (defined($_[1]) &amp;&amp; $_[0] =~ /abc|def/) \
    <div>&#x00A0;</div>
    { return $_[1]; } return 0; }
    <div>&#x00A0;</div>
    varmap=abc_or_def_found; file=1
    <div style="height: 1.00em;">&#x00A0;</div>
    then the entry &quot;abc_or_def_found&quot; is created in the pattern match
      cache. Therefore, the pattern
    <div style="height: 1.00em;">&#x00A0;</div>
    ptype=cached
    <div>&#x00A0;</div>
    pattern=abc_or_def_found
    <div style="height: 1.00em;">&#x00A0;</div>
    will also produce a match for this input line, and set the $0, $1, $+{file},
      and $+{_inputsrc} variables to values from the previous match.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>NSubStr[N]</i></dt>
  <dd class="It-tag">like <i>SubStr[N]</i>, except that the result of the match
      is negated. Note that this pattern type does not support match
    variables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>NRegExp[N]</i></dt>
  <dd class="It-tag">like <i>RegExp[N]</i>, except that the result of the match
      is negated and variable maps are not supported. Note that the only match
      variables supported by this pattern type are $0 and $+{_inputsrc}.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>NPerlFunc[N]</i></dt>
  <dd class="It-tag">like <i>PerlFunc[N]</i>, except that the result of the
      match is negated and variable maps are not supported. Note that the only
      match variables supported by this pattern type are $0 and
    $+{_inputsrc}.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>NCached</i></dt>
  <dd class="It-tag">like <i>Cached</i>, except that the result of the match is
      negated. Note that this pattern type does not support match
    variables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>TValue</i></dt>
  <dd class="It-tag">pattern is a truth value, with TRUE and FALSE being
      legitimate values. TRUE always matches an input line, while FALSE never
      matches anything. Note that this pattern type does not support match
      variables.</dd>
</dl>
<div class="Pp"></div>
When match variables are substituted, each &quot;$$&quot; sequence is
  interpreted as a literal dollar sign ($) which allows for masking match
  variables. For example, the string &quot;Received $$1&quot; becomes
  &quot;Received $1&quot; after substitution, while &quot;Received $$$1&quot;
  becomes &quot;Received $&lt;value_of_1st_var&gt;&quot;. In order to
  disambiguate numbered match variables from the following text, variable number
  must be enclosed in braces. For example, the string &quot;Received ${1}0&quot;
  becomes &quot;Received &lt;value_of_1st_var&gt;0&quot; after substitution,
  while the string &quot;Received $10&quot; would become &quot;Received
  &lt;value_of_10th_var&gt;&quot;.
<div class="Pp"></div>
If the match variable was not set by the pattern, it is substituted with an
  empty string (i.e., a zero-width string). Thus the string &quot;Received
  $10!&quot; becomes &quot;Received !&quot; after substitution if the pattern
  did not set $10. (Note that prior to SEC-2.6, unset variables were *not*
  substituted.)
<div class="Pp"></div>
In the current version of SEC, names of $+{name} match variables must comply
  with the following naming convention -- the first character can be a letter or
  underscore, while remaining characters can be letters, digits, underscores and
  exclamation marks (!). However, when setting named match variables from a
  pattern, it is recommended to begin the variable name with a letter, since
  names of special automatically created variables begin with an underscore
  (e.g., $+{_inputsrc}).
<div class="Pp"></div>
After the pattern has matched an event and match variables have been set, it is
  also possible to refer to previously cached match variables with the syntax
  <i>$:{entryname:varname}</i>, where <i>entryname</i> is the name of the
  pattern match cache entry, and <i>varname</i> is the name of the variable
  stored under the entry. For example, if the variable $+{ip} has been
  previously cached under the entry &quot;SSH&quot;, it can be referred as
  $:{SSH:ip}. For the reasons of efficiency, the $:{entryname:varname} syntax is
  not supported for fast pattern types which do not set match variables (i.e.,
  SubStr, NSubStr, NCached and TValue).
<div class="Pp"></div>
Note that since Pair and PairWithWindow rules have two patterns, match variables
  of the first pattern are shadowed for some rule fields when the second pattern
  matches and sets variables. In order to refer to shadowed variables, their
  names must begin with % instead of $ (e.g., %1 refers to match variable $1 set
  by the first pattern). However, the use of the %-prefix is only valid under
  the following circumstances -- *both* pattern types support match variables
  *and* in the given rule field match variables from *both* patterns can be
  used.
<div class="Pp"></div>
The %-prefixed match variables are masked with the &quot;%%&quot; sequence (like
  regular match variables with &quot;$$&quot;). Similarly, the braces can be
  used for disambiguating the %-prefixed variables from the following text.
<div class="Pp"></div>
Finally, note that the second pattern of Pair and PairWithWindow rules may
  contain match variables if the second pattern is of type SubStr, NSubStr,
  Regexp, or NRegExp. The variables are substituted at runtime with the values
  set by the first pattern. If the pattern is a regular expression, all special
  characters inside substituted values are masked with the Perl
  <b>quotemeta</b>() function and the final expression is checked for
  correctness.
<h1 class="Sh" title="Sh" id="CONTEXTS_AND_CONTEXT_EXPRESSIONS"><a class="selflink" href="#CONTEXTS_AND_CONTEXT_EXPRESSIONS">CONTEXTS
  AND CONTEXT EXPRESSIONS</a></h1>
A SEC context is a memory based entity which has one or more names, a lifetime,
  and an event store. Also, an action list can be set up for a context which is
  executed immediately before the context expires.
<div class="Pp"></div>
For example, the action <i>create MYCONTEXT 3600 (report MYCONTEXT /bin/mail
  root@localhost)</i> creates the context <b>MYCONTEXT</b> which has a lifetime
  of 3600 seconds and empty event store. Also, immediately before
  <b>MYCONTEXT</b> expires and is dropped from memory, the action <i>report
  MYCONTEXT /bin/mail root@localhost</i> is executed which mails the event store
  of <b>MYCONTEXT</b> to root@localhost.
<div class="Pp"></div>
Contexts can be used for event aggregation and reporting. Suppose the following
  actions are executed in this order:
<div class="Pp"></div>
create MYCONTEXT
<div>&#x00A0;</div>
add MYCONTEXT This is a test
<div>&#x00A0;</div>
alias MYCONTEXT MYALIAS
<div>&#x00A0;</div>
add MYALIAS This is another test
<div>&#x00A0;</div>
report MYCONTEXT /bin/mail root@localhost
<div>&#x00A0;</div>
delete MYALIAS
<div class="Pp"></div>
The first action creates the context <b>MYCONTEXT</b> with infinite lifetime and
  empty event store. The second action appends the string &quot;This is a
  test&quot; to the event store of <b>MYCONTEXT</b>. The third action sets up an
  alias name <b>MYALIAS</b> for the context (names <b>MYCONTEXT</b> and
  <b>MYALIAS</b> refer to the same context data structure). The fourth action
  appends the string &quot;This is another test&quot; to the event store of the
  context. The fifth action writes the lines
<div class="Pp"></div>
This is a test
<div>&#x00A0;</div>
This is another test
<div class="Pp"></div>
to the standard input of the <i>/bin/mail root@localhost</i> command. The sixth
  action deletes the context data structure from memory and drops its names
  <b>MYCONTEXT</b> and <b>MYALIAS</b>.
<div class="Pp"></div>
Since contexts are accessible from all rules and event correlation operations,
  they can be used for data sharing and joining several rules into one event
  correlation scheme. In order to check for the presence of contexts from rules,
  context expressions can be employed.
<div class="Pp"></div>
Context expressions are boolean expressions that are defined with the
  <i>context*</i> rule fields. Context expressions can be used for restricting
  the matches produced by patterns, since if the expression evaluates FALSE, the
  rule will not match an input event.
<div class="Pp"></div>
The context expression accepts context names, Perl miniprograms, Perl functions,
  and pattern match cache lookups as operands. These operands can be combined
  with the following operators:
<div>&#x00A0;</div>
! - logical NOT,
<div>&#x00A0;</div>
&amp;&amp; - short-circuit logical AND,
<div>&#x00A0;</div>
|| - short-circuit logical OR.
<div>&#x00A0;</div>
In addition, parentheses can be used for grouping purposes.
<div class="Pp"></div>
If the operand does not contain any special operators (such as -&gt; or :&gt;,
  see below), it is treated as a context name. Context name operands may contain
  match variables, but may not contain whitespace. If the context name refers to
  an existing context, the operand evaluates TRUE, otherwise it evaluates FALSE.
<div class="Pp"></div>
For example, consider the following rule sequence:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=Test: (\d+)
<div>&#x00A0;</div>
desc=test
<div>&#x00A0;</div>
action=create CONT_$1
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=Test2: (\d+) (\d+)
<div>&#x00A0;</div>
context=CONT_$1 &amp;&amp; CONT_$2
<div>&#x00A0;</div>
desc=test
<div>&#x00A0;</div>
action=write - Both $1 and $2 have been seen in the past
<div class="Pp"></div>
If the following input lines appear in this order
<div class="Pp"></div>
Test: 19
<div>&#x00A0;</div>
Test: 261
<div>&#x00A0;</div>
Test2: 19 787
<div>&#x00A0;</div>
Test: 787
<div>&#x00A0;</div>
Test2: 787 261
<div class="Pp"></div>
the first input line matches the first rule which creates the context
  <b>CONT_19</b>, and similarly, the second input line triggers the creation of
  the context <b>CONT_261</b>. The third input line &quot;Test2: 19 787&quot;
  matches the regular expression
<div class="Pp"></div>
Test2: (\d+) (\d+)
<div class="Pp"></div>
but does not match the second rule, since the boolean expression
<div class="Pp"></div>
CONT_19 &amp;&amp; CONT_787
<div class="Pp"></div>
evaluates FALSE (context <b>CONT_19</b> exists, but context <b>CONT_787</b>
  doesn't). The fourth input line matches the first rule which creates the
  context <b>CONT_787</b>. The fifth input line &quot;Test2: 787 261&quot;
  matches the second rule, since the boolean expression
<div class="Pp"></div>
CONT_787 &amp;&amp; CONT_261
<div class="Pp"></div>
evaluates TRUE (both context <b>CONT_787</b> and context <b>CONT_261</b> exist),
  and therefore the string &quot;Both 787 and 261 have been seen in the
  past&quot; is written to standard output.
<div class="Pp"></div>
If the context expression operand contains the arrow operator (-&gt;), the text
  following the arrow must be a valid Perl function definition that is compiled
  at SEC startup with the Perl <b>eval</b>() function. The <b>eval</b>() must
  return a code reference (see also PERL INTEGRATION section for more
  information). If any text precedes the arrow, it is treated as a list of
  parameters for the function. Parameters must be separated by whitespace and
  may contain match variables. In order to evaluate the context expression
  operand, the Perl function is called in the Perl scalar context. If the return
  value of the function is true in the Perl boolean context, the operand
  evaluates TRUE, otherwise it evaluates FALSE.
<div class="Pp"></div>
For example, the following rule matches an SSH login failure event if the login
  attempt comes from a privileged port of the client host:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (\S+) from [\d.]+ port (\d+) ssh2
<div>&#x00A0;</div>
context=$2 -&gt; ( sub { $_[0] &lt; 1024 } )
<div>&#x00A0;</div>
desc=SSH login failure for $1 priv port $2
<div>&#x00A0;</div>
action=write - SSH login failure for user $1 from a privileged port $2
<div class="Pp"></div>
When the following message from SSH daemon appears
<div class="Pp"></div>
Dec 16 16:24:59 myserver sshd[13685]: Failed password for risto from 10.12.2.5
  port 41063 ssh2
<div class="Pp"></div>
the regular expression of the rule matches this message, and the value of the $2
  match variable (41063) is passed to the Perl function
<div class="Pp"></div>
sub { $_[0] &lt; 1024 }
<div class="Pp"></div>
This function returns true if its input parameter is less than 1024 and false
  otherwise, and therefore the above message will not match the rule. However,
  the following message
<div class="Pp"></div>
Dec 16 16:25:17 myserver sshd[13689]: Failed password for risto from 10.12.2.5
  port 1023 ssh2
<div class="Pp"></div>
matches the rule, and the string &quot;SSH login failure for user risto from a
  privileged port 1023&quot; is written to standard output.
<div class="Pp"></div>
As another example, the following context expression evaluates TRUE if the
  /var/log/messages file does not exist or was last modified more than 1 hour
  ago (note that the Perl function takes no parameters):
<div class="Pp"></div>
context= -&gt; ( sub { my(@stat) = stat(&quot;/var/log/messages&quot;); \
<div>&#x00A0;</div>
return (!scalar(@stat) || time() - $stat[9] &gt; 3600); } )
<div class="Pp"></div>
If the context expression operand contains the :&gt; operator, the text that
  follows :&gt; must be a valid Perl function definition that is compiled at SEC
  startup with the Perl <b>eval</b>() function. The <b>eval</b>() must return a
  code reference (see also PERL INTEGRATION section for more information). If
  any text precedes the :&gt; operator, it is treated as a list of parameters
  for the function. Parameters must be separated by whitespace and may contain
  match variables. It is assumed that each parameter is a name of an entry in
  the pattern match cache. If an entry with the given name does not exist, Perl
  undefined value is passed to the function. If an entry with the given name
  exists, a reference to the entry is passed to the Perl function. Internally,
  each pattern match cache entry is implemented as a Perl hash which contains
  all match variables for the given entry. In the hash, each key-value pair
  represents some variable name and value, e.g., if cached match variable $+{ip}
  is holding 10.1.1.1, the hash contains the value <b>10.1.1.1</b> with the key
  <b>ip</b>. In order to evaluate the context expression operand, the Perl
  function is called in the Perl scalar context. If the return value of the
  function is true in the Perl boolean context, the operand evaluates TRUE,
  otherwise it evaluates FALSE.
<div class="Pp"></div>
For example, consider the following rule sequence:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: (?&lt;status&gt;Accepted|Failed) .+ \
<div>&#x00A0;</div>
for (?&lt;invuser&gt;invalid user )?(?&lt;user&gt;\S+) from (?&lt;ip&gt;[\d.]+)
  \
<div>&#x00A0;</div>
port (?&lt;port&gt;\d+) ssh2
<div>&#x00A0;</div>
varmap=SSH
<div>&#x00A0;</div>
continue=TakeNext
<div>&#x00A0;</div>
desc=parse SSH login events and pass them to following rules
<div>&#x00A0;</div>
action=none
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=Cached
<div>&#x00A0;</div>
pattern=SSH
<div>&#x00A0;</div>
context=SSH :&gt; ( sub { $_[0]-&gt;{&quot;status&quot;} eq &quot;Failed&quot;
  &amp;&amp; \
<br/>
 $_[0]-&gt;{&quot;port&quot;} &lt; 1024 &amp;&amp; \
<br/>
 defined($_[0]-&gt;{&quot;invuser&quot;}) } )
<div>&#x00A0;</div>
desc=Probe of invalid user $+{user} from privileged port of $+{ip}
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail -s 'SSH alert' root@localhost
<div class="Pp"></div>
The first rule matches and parses SSH login messages, and stores parsing results
  to the pattern match cache under the name <b>SSH</b>. The pattern of the
  second rule (defined with <i>ptype=Cached</i> and <i>pattern=SSH</i>) matches
  any input event for which the entry <b>SSH</b> has been previously created in
  the pattern match cache (in other words, the event has been recognized and
  parsed as an SSH login message). For each matching event, the second rule
  passes the reference to the <b>SSH</b> cache entry to the Perl function
<div class="Pp"></div>
sub { $_[0]-&gt;{&quot;status&quot;} eq &quot;Failed&quot; &amp;&amp; \
<br/>
 $_[0]-&gt;{&quot;port&quot;} &lt; 1024 &amp;&amp; \
<br/>
 defined($_[0]-&gt;{&quot;invuser&quot;}) }
<div class="Pp"></div>
The function checks the values of $+{status}, $+{port}, and $+{invuser} match
  variables under the <b>SSH</b> entry, and returns true if $+{status} equals to
  the string &quot;Failed&quot; (i.e., login attempt failed), the value of
  $+{port} is less than 1024, and $+{invuser} holds a defined value (i.e., user
  account does not exist). If the function (and thus context expression)
  evaluates TRUE, the rule sends a warning e-mail to root@localhost that a
  non-existing user account was probed from a privileged port of a client host.
<div class="Pp"></div>
If the context expression operand begins with the <i>varset</i> keyword, the
  following string is treated as a name of an entry in the pattern match cache.
  The operand evaluates TRUE if the given entry exists, and FALSE otherwise.
<div class="Pp"></div>
For example, the following context expression definition evaluates TRUE if the
  pattern match cache entry <b>SSH</b> exists and under this entry, the value of
  the match variable $+{user} equals to the string &quot;risto&quot;:
<div class="Pp"></div>
context=varset SSH &amp;&amp; SSH :&gt; ( sub { $_[0]-&gt;{&quot;user&quot;} eq
  &quot;risto&quot; } )
<div class="Pp"></div>
If the context expression operand begins with the equal sign (=), the following
  text must be a Perl miniprogram which is a valid parameter for the Perl
  <b>eval</b>() function. The miniprogram may contain match variables. In order
  to evaluate the Perl miniprogram operand, it will be compiled and executed by
  calling the Perl <b>eval</b>() function in the Perl scalar context (see also
  PERL INTEGRATION section). If the return value from <b>eval</b>() is true in
  the Perl boolean context, the operand evaluates TRUE, otherwise it evaluates
  FALSE. Please note that unlike Perl functions of -&gt; and :&gt; operators
  which are compiled once at SEC startup, Perl miniprograms are compiled before
  each execution, and their evaluation is thus considerably more expensive.
<div class="Pp"></div>
For example, the following context expression evaluates TRUE when neither the
  context <b>C1</b> nor the context <b>C2</b> exists and the value of the $1
  variable equals to the string &quot;myhost.mydomain&quot;:
<div class="Pp"></div>
context=!(C1 || C2) &amp;&amp; =(&quot;$1&quot; eq &quot;myhost.mydomain&quot;)
<div class="Pp"></div>
Since &amp;&amp; is a short-circuiting operator, the Perl code
<div class="Pp"></div>
&quot;$1&quot; eq &quot;myhost.mydomain&quot;
<div class="Pp"></div>
is *not* evaluated if either <b>C1</b> or <b>C2</b> exists.
<div class="Pp"></div>
Note that since Perl functions and miniprograms may contain strings that clash
  with context expression operators (e.g., '!'), it is recommended to enclose
  them in parentheses, e.g.,
<div class="Pp"></div>
context=$1 $2 -&gt; ( sub { $_[0] != $_[1] } )
<div class="Pp"></div>
context= =({my($temp) = 0; !$temp;})
<div class="Pp"></div>
Also, if function parameter lists contain such strings, they should be enclosed
  in parentheses in the similar way:
<div class="Pp"></div>
context=($1! $2) -&gt; ( sub { $_[0] eq $_[1] } )
<div class="Pp"></div>
If the whole context expression is enclosed in square brackets [], e.g.,
  [<b>MYCONTEXT1</b> &amp;&amp; !<b>MYCONTEXT2</b>], SEC evaluates the
  expression *before* pattern matching (normally, the pattern is matched with
  input line(s) first, so that match variables would be initialized and
  substituted before the expression is evaluated). However, if the expression
  does not contain match variables and many input events are known to match the
  pattern but not the expression, the []-operator could save substantial amount
  of CPU time.
<h1 class="Sh" title="Sh" id="ACTIONS,_ACTION_LISTS_AND_ACTION_LIST_VARIABLES"><a class="selflink" href="#ACTIONS,_ACTION_LISTS_AND_ACTION_LIST_VARIABLES">ACTIONS,
  ACTION LISTS AND ACTION LIST VARIABLES</a></h1>
Action lists are defined with the <i>action*</i> rule fields. An action list
  consists of action definitions that are separated by semicolons. Each action
  definition begins with a keyword specifying the action type. Depending on the
  action type, parameters may follow, and non-constant parameters may contain
  match variables. For instance, if the $1 and $2 match variables have the
  values &quot;test1&quot; and &quot;the second test&quot;, respectively, the
  action <i>create MYCONT_$1 60</i> creates the context <b>MYCONT_test1</b> with
  the lifetime of 60 seconds, while the action <i>write - The names of tests:
  $1, $2</i> writes the string &quot;The names of tests: test1, the second
  test&quot; to standard output. In order to use semicolons inside a
  non-constant parameter, the parameter must be enclosed in parentheses (the
  outermost set of parentheses will be removed by SEC during configuration file
  parsing).
<div class="Pp"></div>
For example, the following action list consists of <i>delete</i> and
  <i>shellcmd</i> actions:
<div class="Pp"></div>
action=delete MYCONTEXT; shellcmd (rm /tmp/sec1.tmp; rm /tmp/sec2.tmp)
<div class="Pp"></div>
The <i>delete</i> action deletes the context <b>MYCONTEXT</b>, while the
  <i>shellcmd</i> action executes the command line <i>rm /tmp/sec1.tmp; rm
  /tmp/sec2.tmp</i>. Since the command line contains a semicolon, it has been
  enclosed in parentheses, since otherwise the semicolon would be mistakenly
  considered a separator between two actions.
<div class="Pp"></div>
Apart from match variables, SEC supports <i>action list variables</i> in action
  lists which facilitate data sharing between actions and Perl integration. Each
  action list variable has a name which must begin with a letter and consist of
  letters, digits and underscores. Names of built-in variables usually start
  with a punctuation mark (.), so that they can be distinguished from user
  defined variables. In order to refer to an action list variable, its name must
  be prefixed by a percent sign (%). Unlike match variables, action list
  variables can only be used in action lists and they are substituted with their
  values immediately before the action list execution. Also, action list
  variables continue to exist after the current action list has been executed
  and can be employed in action lists of other rules.
<div class="Pp"></div>
The following action list variables are predefined by SEC:
<dl class="Bl-tag">
  <dt class="It-tag"><i>%s</i></dt>
  <dd class="It-tag">operation description string (the value of the <i>desc</i>
      field after match variables have been substituted with their values). Note
      that for the <i>action2</i> field of Pair and PairWithWindow rules, the %s
      variable is set by evaluating the <i>desc2</i> field of the rule.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%t</i></dt>
  <dd class="It-tag">the time in human-readable format, as returned by the Perl
      <b>localtime</b>() function in the Perl scalar context (e.g., Fri Feb 19
      17:54:18 2016).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%u</i></dt>
  <dd class="It-tag">the time in seconds since Epoch, as returned by the
      <b>time</b>(2) system call.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.sec</i></dt>
  <dd class="It-tag">number of seconds after the minute, in the range 00-59 (the
      value consists of two digits and is zero padded on the left).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.min</i></dt>
  <dd class="It-tag">number of minutes after the hour, in the range 00-59 (the
      value consists of two digits and is zero padded on the left).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.hour</i></dt>
  <dd class="It-tag">number of hours past midnight, in the range 00-23 (the
      value consists of two digits and is zero padded on the left).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.hmsstr</i></dt>
  <dd class="It-tag">the time in HH:MM:SS format (hours, minutes and seconds
      separated by colons, e.g., 09:32:04 or 18:06:02).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.mday</i></dt>
  <dd class="It-tag">day of the month, in the range 01-31 (the value consists of
      two digits and is zero padded on the left).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.mdaystr</i></dt>
  <dd class="It-tag">day of the month as a string (the value consists of two
      characters and is space padded on the left, e.g., &quot; 1&quot;, &quot;
      4&quot;, &quot; 9&quot;, or &quot;25&quot;).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.mon</i></dt>
  <dd class="It-tag">month, in the range 01-12 (the value consists of two digits
      and is zero padded on the left).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.monstr</i></dt>
  <dd class="It-tag">abbreviated name of the month according to the current
      locale, as returned by the %b specification of the <b>strftime</b>(3)
      library call (e.g., Jan, May, or Sep).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.year</i></dt>
  <dd class="It-tag">year (e.g., 1998 or 2016).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.wday</i></dt>
  <dd class="It-tag">day of the week, in the range 0-6 (0 denotes Sunday).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.wdaystr</i></dt>
  <dd class="It-tag">abbreviated name of the day of the week according to the
      current locale, as returned by the %a specification of the
      <b>strftime</b>(3) library call (e.g., Mon, Wed, or Sat).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.tzname</i></dt>
  <dd class="It-tag">name of the timezone according to the current locale, as
      returned by the %Z specification of the <b>strftime</b>(3) library call
      (e.g., UTC or EET).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.tzoff</i></dt>
  <dd class="It-tag">timezone offset from UTC, as returned by the %z
      specification of the <b>strftime</b>(3) library call (e.g., -0500 or
      +0200).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.tzoff2</i></dt>
  <dd class="It-tag">timezone offset from UTC in +hh:mm/-hh:mm format (e.g.,
      -05:00 or +02:00), provided that the %z specification of the
      <b>strftime</b>(3) library call returns the value in +hhmm/-hhmm format
      (if the value does not follow this format, %.tzoff2 is set to an empty
      string).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.nl</i></dt>
  <dd class="It-tag">newline character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.cr</i></dt>
  <dd class="It-tag">carriage return character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.tab</i></dt>
  <dd class="It-tag">tabulation character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>%.chr0, ..., %.chr31</i></dt>
  <dd class="It-tag">ASCII 0..31 control characters (e.g., %.chr7 is bell and
      %.chr12 is form feed character).</dd>
</dl>
<div class="Pp"></div>
For example, the following action list assigns the current time in human
  readable format and the content of the $0 match variable to the %text action
  list variable, and mails the value of %text to root@localhost:
<div class="Pp"></div>
action=assign %text %t: $0; pipe '%text' /bin/mail root@localhost
<div class="Pp"></div>
If the action list is executed at Nov 19 10:58:51 2015 and the $0 match variable
  has the value &quot;This is a test event&quot;, the <i>assign</i> action sets
  the %text action list variable to the string &quot;Thu Nov 19 10:58:51 2015:
  This is a test event&quot;, while the <i>pipe</i> action mails this string to
  root@localhost. Note that unlike match variables, action list variables have a
  global scope, and accessing the value of the %text variable in action lists of
  other rules will thus yield the string &quot;Thu Nov 19 10:58:51 2015: This is
  a test event&quot; (until another value is assigned to %text).
<div class="Pp"></div>
In order to disambiguate the variable from the following text, the variable name
  must be enclosed in braces. For example, the following action
<div class="Pp"></div>
action=write - %{.year}-%{.mon}-%{.mday}T%{.hmsstr}%{.tzoff2}
<div class="Pp"></div>
writes a timestamp in ISO 8601 format to standard output, e.g.,
  2016-02-24T07:34:01+02:00 (replacing %{.mday} with %.mday in the above action
  would mistakenly create a reference to %.mdayT variable).
<div class="Pp"></div>
When action list variables are substituted with their values, each sequence
  &quot;%%&quot; is interpreted as a literal percent sign (%) which allows for
  masking the variables. For example, the string &quot;s%%t&quot; becomes
  &quot;s%t&quot; after substitution, not &quot;s%&lt;timestamp&gt;&quot;.
<div class="Pp"></div>
However, note that if %-prefixed match variables are supported for the
  <i>action2</i> field of the Pair or PairWithWindow rule, the sequence
  &quot;%%%&quot; must be used in <i>action2</i> for masking a variable, since
  the string goes through *two* variable substitution rounds (first for
  %-prefixed match variables and then for action list variables, e.g., the
  string &quot;s%%%t&quot; first becomes &quot;s%%t&quot; and finally
  &quot;s%t&quot;).
<div class="Pp"></div>
Whenever a rule field goes through several substitution rounds, the $ or %
  characters are masked inside values substituted during earlier rounds, in
  order to avoid unwanted side effects during later rounds.
<div class="Pp"></div>
If the action list variable has not been set, it is substituted with an empty
  string (i.e., a zero-width string). Thus the string &quot;Value of A is:
  %a&quot; becomes &quot;Value of A is: &quot; after substitution if the
  variable %a is unset. (Note that prior to SEC-2.6, unset variables were *not*
  substituted.)
<div class="Pp"></div>
Finally, the values are substituted as strings, therefore values of other types
  (e.g., references) lose their original meaning, unless explicitly noted
  otherwise (e.g., if a Perl function reference is stored to an action list
  variable, the function can later be invoked through this variable with the
  <i>call</i> action).
<div class="Pp"></div>
SEC supports the following actions (optional parameters are enclosed in square
  brackets):
<dl class="Bl-tag">
  <dt class="It-tag"><i>none</i></dt>
  <dd class="It-tag">No action.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>logonly [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Message &lt;string&gt; is logged to destinations given with
      the <b>--log</b> and <b>--syslog</b> options. The level of the log message
      is set to 4 (see the <b>--debug</b> option for more information on log
      message levels). Default value for &lt;string&gt; is %s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>write &lt;filename&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">String &lt;string&gt; with a terminating newline is written
      to the file &lt;filename&gt; (&lt;filename&gt; may not contain
      whitespace). File may be a regular file, named pipe, or standard output
      (denoted by <b>-</b>). If the file is a regular file, &lt;string&gt; is
      appended to the end of the file. If the file does not exist, it is created
      as a regular file before writing. Note that the file will not be closed
      after the action completes, and the following <i>write</i> actions will
      access an already open file. However, several signals cause the file to be
      closed and reopened (see SIGNALS section for more information). Default
      value for &lt;string&gt; is %s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>writen &lt;filename&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Similar to the <i>write</i> action, except that the string
      &lt;string&gt; is written without a terminating newline. Note that
      <i>write</i> and <i>writen</i> actions share the same filehandle for
      accessing the file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>closef &lt;filename&gt;</i></dt>
  <dd class="It-tag">Close the file &lt;filename&gt; that has been previously
      opened by the <i>write</i> or <i>writen</i> action (&lt;filename&gt; may
      not contain whitespace).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>owritecl &lt;filename&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Similar to the <i>write</i> action, except that the file
      &lt;filename&gt; is opened and closed at each write. Also, the string
      &lt;string&gt; is written without a terminating newline. If the file has
      already been opened by a previous <i>write</i> action, <i>owritecl</i>
      does not use existing filehandle, but opens and closes the file
      separately.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>udgram &lt;filename&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">String &lt;string&gt; is written to the UNIX datagram
      socket &lt;filename&gt; (&lt;filename&gt; may not contain whitespace).
      Note that the socket will not be closed after the action completes, and
      the following <i>udgram</i> actions will access an already open socket.
      However, several signals cause the socket to be closed and reopened (see
      SIGNALS section for more information). Default value for &lt;string&gt; is
      %s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>closeudgr &lt;filename&gt;</i></dt>
  <dd class="It-tag">Close the UNIX datagram socket &lt;filename&gt; that has
      been previously opened by the <i>udgram</i> action (&lt;filename&gt; may
      not contain whitespace).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ustream &lt;filename&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">String &lt;string&gt; is written to the UNIX stream socket
      &lt;filename&gt; (&lt;filename&gt; may not contain whitespace). Note that
      the socket will not be closed after the action completes, and the
      following <i>ustream</i> actions will access an already open socket.
      However, several signals cause the socket to be closed and reopened (see
      SIGNALS section for more information). Default value for &lt;string&gt; is
      %s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>closeustr &lt;filename&gt;</i></dt>
  <dd class="It-tag">Close the UNIX stream socket &lt;filename&gt; that has been
      previously opened by the <i>ustream</i> action (&lt;filename&gt; may not
      contain whitespace).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>udpsock &lt;host&gt;:&lt;port&gt;
    [&lt;string&gt;]</i></dt>
  <dd class="It-tag">String &lt;string&gt; is sent to the UDP port &lt;port&gt;
      of the host &lt;host&gt;. Note that the UDP socket which is used for
      communication will not be closed after the action completes, and the
      following <i>udpsock</i> actions for the same remote peer will use an
      already existing socket. However, several signals cause the socket to be
      closed and recreated (see SIGNALS section for more information). Default
      value for &lt;string&gt; is %s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>closeudp &lt;host&gt;:&lt;port&gt;</i></dt>
  <dd class="It-tag">Close the UDP socket for peer &lt;host&gt;:&lt;port&gt;
      that has been previously opened by the <i>udpsock</i> action.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>tcpsock &lt;host&gt;:&lt;port&gt;
    [&lt;string&gt;]</i></dt>
  <dd class="It-tag">String &lt;string&gt; is sent to the TCP port &lt;port&gt;
      of the host &lt;host&gt;. The timeout value given with the
      <b>--socket-timeout</b> option determines for how many seconds SEC will
      attempt to establish a connection to the remote peer. If the connection
      establishment does not succeed immediately, the <i>tcpsock</i> action
      buffers &lt;string&gt; in memory for later sending to the remote peer.
      Note that the relevant TCP socket will not be closed after &lt;string&gt;
      has been transmitted, and the following <i>tcpsock</i> actions for the
      same peer will use an already existing socket. However, several signals
      cause the socket to be closed and recreated (see SIGNALS section for more
      information). Default value for &lt;string&gt; is %s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>closetcp &lt;host&gt;:&lt;port&gt;</i></dt>
  <dd class="It-tag">Close the TCP socket for peer &lt;host&gt;:&lt;port&gt;
      that has been previously opened by the <i>tcpsock</i> action.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>shellcmd &lt;cmdline&gt;</i></dt>
  <dd class="It-tag">Fork a process for executing command line &lt;cmdline&gt;.
      If the <b>--quoting</b> option was specified and &lt;cmdline&gt; contains
      %s variables, the value of %s is quoted with single quotes before
      substituting it into &lt;cmdline&gt;; if the value of %s contains single
      quotes, they are masked with backslashes (e.g., abc is converted to 'abc'
      and aa'bb is converted to 'aa'\''bb'). For additional information, see
      INTERPROCESS COMMUNICATION section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>spawn &lt;cmdline&gt;</i></dt>
  <dd class="It-tag">Similar to the <i>shellcmd</i> action, except that each
      line from the standard output of &lt;cmdline&gt; becomes a synthetic event
      and will be treated like a line from input file (see the <i>event</i>
      action for more information). If the <b>--intcontexts</b> command line
      option is given, internal context _INTERNAL_EVENT is set up before each
      synthetic event is processed (see INTERNAL EVENTS AND CONTEXTS section for
      more information).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>cspawn &lt;name&gt; &lt;cmdline&gt;</i></dt>
  <dd class="It-tag">Similar to the <i>spawn</i> action, except that if the
      <b>--intcontexts</b> command line option is given, internal context
      &lt;name&gt; is set up for each synthetic event.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pipe '[&lt;string&gt;]' [&lt;cmdline&gt;]</i></dt>
  <dd class="It-tag">Fork a process for executing command line &lt;cmdline&gt;.
      The string &lt;string&gt; with a terminating newline is written to the
      standard input of &lt;cmdline&gt; (single quotes are used for
      disambiguating &lt;string&gt; from &lt;cmdline&gt;). If &lt;string&gt;
      contains semicolons, &lt;string&gt; must be enclosed in parentheses (e.g.,
      <i>pipe '($1;$2)' /bin/cat</i>). Default value for &lt;string&gt; is %s.
      If &lt;cmdline&gt; is omitted, &lt;string&gt; is written to standard
      output. For additional information, see INTERPROCESS COMMUNICATION
      section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>create [&lt;name&gt; [&lt;time&gt; [&lt;action list&gt;]
    ] ]</i></dt>
  <dd class="It-tag">Create a context with the name &lt;name&gt;, lifetime of
      &lt;time&gt; seconds, and empty event store. The &lt;name&gt; parameter
      may not contain whitespace and defaults to %s. The &lt;time&gt; parameter
      must evaluate to an unsigned integer at runtime. Specifying 0 for
      &lt;time&gt; or omitting the value means infinite lifetime. If &lt;action
      list&gt; is given, it will be executed when the context expires. If
      &lt;action list&gt; contains several actions, the list must be enclosed in
      parentheses. In &lt;action list&gt;, the internal context name _THIS may
      be used for referring to the current context (see INTERNAL EVENTS AND
      CONTEXTS section for a detailed discussion). If an already existing
      context is recreated with <i>create</i>, its remaining lifetime is set to
      &lt;time&gt; seconds, its action list is reinitialized, and its event
      store is emptied.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>delete [&lt;name&gt;]</i></dt>
  <dd class="It-tag">Delete the context &lt;name&gt;. The &lt;name&gt; parameter
      may not contain whitespace and defaults to %s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>obsolete [&lt;name&gt;]</i></dt>
  <dd class="It-tag">Similar to the <i>delete</i> action, except that the action
      list of the context &lt;name&gt; (if present) is executed before
    deletion.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>set &lt;name&gt; &lt;time&gt; [&lt;action
    list&gt;]</i></dt>
  <dd class="It-tag">Change settings for the context &lt;name&gt;. The creation
      time of the context is set to the current time, and the lifetime of the
      context is set to &lt;time&gt; seconds. If the &lt;action list&gt;
      parameter is given, the context action list is set to &lt;action list&gt;.
      The &lt;name&gt; parameter may not contain whitespace and defaults to %s.
      The &lt;time&gt; parameter must evaluate to an unsigned integer or hyphen
      (-) at runtime. Specifying 0 for &lt;time&gt; means infinite lifetime. If
      &lt;time&gt; equals to -, the creation time and lifetime of the context
      are not changed. If &lt;action list&gt; contains several actions, the list
      must be enclosed in parentheses. In &lt;action list&gt;, the internal
      context name _THIS may be used for referring to the current context (see
      INTERNAL EVENTS AND CONTEXTS section for a detailed discussion).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>alias &lt;name&gt; [&lt;alias&gt;]</i></dt>
  <dd class="It-tag">Create an alias name &lt;alias&gt; for the context
      &lt;name&gt;. After creation, both &lt;alias&gt; and &lt;name&gt; will
      point to the same context data structure, and can thus be used
      interchangeably for referring to the context. The &lt;name&gt; and
      &lt;alias&gt; parameters may not contain whitespace, and &lt;alias&gt;
      defaults to %s. If the context &lt;name&gt; does not exist, the alias name
      is not created. If the <i>delete</i> action is called for one of the
      context names, the context data structure is destroyed, and all context
      names (which are now pointers to unallocated memory) cease to exist. Also
      note that when the context expires, its action list is executed only once,
      no matter how many names the context has.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>unalias [&lt;alias&gt;]</i></dt>
  <dd class="It-tag">Drop an existing context name &lt;alias&gt;, so that it can
      no longer be used for referring to the given context. The &lt;alias&gt;
      parameter may not contain whitespace and defaults to %s. If the name
      &lt;alias&gt; is the last reference to the context, the <i>unalias</i>
      action is identical to <i>delete</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>add &lt;name&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">String &lt;string&gt; is appended to the end of the event
      store of the context &lt;name&gt;. The &lt;name&gt; parameter may not
      contain whitespace, and the &lt;string&gt; parameter defaults to %s. If
      the context &lt;name&gt; does not exist, the context is created with an
      infinite lifetime, empty action list and empty event store (as with
      <i>create &lt;name&gt;</i>) before adding the string to event store. If
      &lt;string&gt; is a multi-line string (i.e., it contains newlines), it is
      split into lines, and each line is appended to the event store
    separately.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>prepend &lt;name&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Similar to the <i>add</i> action, except that the string
      &lt;string&gt; is prepended to the beginning of the event store of context
      &lt;name&gt;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>fill &lt;name&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Similar to the <i>add</i> action, except that the event
      store of the context &lt;name&gt; is emptied before &lt;string&gt; is
      added.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>report &lt;name&gt; [&lt;cmdline&gt;]</i></dt>
  <dd class="It-tag">Fork a process for executing command line &lt;cmdline&gt;,
      and write strings from the event store of the context &lt;name&gt; to the
      standard input of &lt;cmdline&gt;. Strings are written in the order they
      appear in the event store, with a terminating newline appended to each
      string. If the context &lt;name&gt; does not exist or its event store is
      empty, &lt;cmdline&gt; is not executed. The &lt;name&gt; parameter may not
      contain whitespace, and if &lt;cmdline&gt; is omitted, strings are written
      to standard output. For additional information, see INTERPROCESS
      COMMUNICATION section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>copy &lt;name&gt; %&lt;var&gt;</i></dt>
  <dd class="It-tag">Strings s1,...,sn from the event store of the context
      &lt;name&gt; are joined into a multi-line string
      &quot;s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn&quot;, and this string is
      assigned to the action list variable %&lt;var&gt;. If the context
      &lt;name&gt; does not exist, the value of %&lt;var&gt; does not
    change.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>empty &lt;name&gt; [%&lt;var&gt;]</i></dt>
  <dd class="It-tag">Similar to the <i>copy</i> action, except that the event
      store of the context &lt;name&gt; will be emptied after the assignment. If
      %&lt;var&gt; is omitted, the content of the event store is dropped without
      an assignment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pop &lt;name&gt; %&lt;var&gt;</i></dt>
  <dd class="It-tag">Remove the last string from the event store of context
      &lt;name&gt;, and assign it to the action list variable %&lt;var&gt;. If
      the event store is empty, %&lt;var&gt; is set to empty string. If the
      context &lt;name&gt; does not exist, the value of %&lt;var&gt; does not
      change.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>shift &lt;name&gt; %&lt;var&gt;</i></dt>
  <dd class="It-tag">Remove the first string from the event store of context
      &lt;name&gt;, and assign it to the action list variable %&lt;var&gt;. If
      the event store is empty, %&lt;var&gt; is set to empty string. If the
      context &lt;name&gt; does not exist, the value of %&lt;var&gt; does not
      change.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>exists %&lt;var&gt; &lt;name&gt;</i></dt>
  <dd class="It-tag">If the context &lt;name&gt; exists, set the action list
      variable %&lt;var&gt; to 1, otherwise set %&lt;var&gt; to 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>getsize %&lt;var&gt; &lt;name&gt;</i></dt>
  <dd class="It-tag">Find the number of strings in the event store of context
      &lt;name&gt;, and assign this number to the action list variable
      %&lt;var&gt;. If the context &lt;name&gt; does not exist, %&lt;var&gt; is
      set to Perl undefined value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>getaliases %&lt;var&gt; &lt;name&gt;</i></dt>
  <dd class="It-tag">Find all alias names for context &lt;name&gt;, join the
      names into a multi-line string
      &quot;alias1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;aliasn&quot;, and assign this
      string to the action list variable %&lt;var&gt;. If the context
      &lt;name&gt; does not exist, the value of %&lt;var&gt; does not
    change.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>getltime %&lt;var&gt; &lt;name&gt;</i></dt>
  <dd class="It-tag">Find the lifetime of context &lt;name&gt;, and assign this
      number to the action list variable %&lt;var&gt;. If the context
      &lt;name&gt; does not exist, the value of %&lt;var&gt; does not
    change.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>getctime %&lt;var&gt; &lt;name&gt;</i></dt>
  <dd class="It-tag">Find the creation time of context &lt;name&gt;, and assign
      this number to the action list variable %&lt;var&gt;. If the context
      &lt;name&gt; does not exist, the value of %&lt;var&gt; does not
    change.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>setctime &lt;time&gt; &lt;name&gt;</i></dt>
  <dd class="It-tag">Set the creation time of context &lt;name&gt; to
      &lt;time&gt;. The &lt;time&gt; parameter must evaluate to seconds since
      Epoch (as reported by the <b>time</b>(2) system call), and must reflect a
      time moment between the previous creation time and the current time (both
      endpoints included).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>event [&lt;time&gt;] [&lt;string&gt;]</i></dt>
  <dd class="It-tag">After &lt;time&gt; seconds, create a synthetic event
      &lt;string&gt;. If &lt;string&gt; is a multi-line string (i.e., it
      contains newlines), it is split into lines, and from each line a separate
      synthetic event is created. SEC will treat each synthetic event like a
      line from an input file -- the event will be matched against rules and it
      might trigger further actions. If the <b>--intcontexts</b> command line
      option is given, internal context _INTERNAL_EVENT is set up for synthetic
      event(s) (see INTERNAL EVENTS AND CONTEXTS section for more information).
      The &lt;time&gt; parameter is an integer constant. Specifying 0 for
      &lt;time&gt; or omitting the value means &quot;now&quot;. Default value
      for &lt;string&gt; is %s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>tevent &lt;time&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Similar to the <i>event</i> action, except that the
      &lt;time&gt; parameter may contain variables and must evaluate to an
      unsigned integer at runtime.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>cevent &lt;name&gt; &lt;time&gt;
    [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Similar to the <i>tevent</i> action, except that if the
      <b>--intcontexts</b> command line option is given, internal context
      &lt;name&gt; is set up for synthetic event(s).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>reset [&lt;offset&gt;] [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Terminate event correlation operation(s) with the operation
      description string &lt;string&gt;. Note that the <i>reset</i> action works
      only for operations started from the same configuration file. The
      &lt;offset&gt; parameter is used to refer to a specific rule in the
      configuration file. If &lt;offset&gt; is given, the operation started by
      the given rule is terminated (if it exists). If &lt;offset&gt; is an
      unsigned integer N, it refers to the N-th rule in the configuration file.
      If &lt;offset&gt; is 0, it refers to the current rule. If &lt;offset&gt;
      begins with the plus (+) or minus (-) sign, it specifies an offset from
      the current rule (e.g., -1 denotes the previous and +1 the next rule).
      Note that since Options rules are only processed when configuration files
      are loaded and they are not applied at runtime, Options rules are excluded
      when calculating &lt;offset&gt;. If &lt;offset&gt; is not given, SEC
      checks for each rule from the current configuration file if an operation
      with &lt;string&gt; has been started by this rule, and the operation is
      terminated if it exists. Default value for &lt;string&gt; is %s. For
      additional information, see EVENT CORRELATION OPERATIONS section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>getwpos %&lt;var&gt; &lt;offset&gt;
    [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Find the beginning of the event correlation window for an
      event correlation operation, and set the action list variable %&lt;var&gt;
      to this timestamp. The value assigned to %&lt;var&gt; is measured in
      seconds since Epoch (as reported by the <b>time</b>(2) system call). As
      with the <i>reset</i> action, the event correlation operation is
      identified by the operation description string &lt;string&gt; and the rule
      offset &lt;offset&gt;. If the operation does not exist, the value of
      %&lt;var&gt; does not change. Default value for &lt;string&gt; is %s. For
      additional information, see EVENT CORRELATION OPERATIONS section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>setwpos &lt;time&gt; &lt;offset&gt;
    [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Set the beginning of the event correlation window to
      &lt;time&gt; for an event correlation operation (if it exists). The
      &lt;time&gt; parameter must evaluate to seconds since Epoch (as reported
      by the <b>time</b>(2) system call), and must reflect a time moment between
      the previous window position and the current time (both endpoints
      included). As with the <i>reset</i> action, the event correlation
      operation is identified by the operation description string &lt;string&gt;
      and the rule offset &lt;offset&gt;. Default value for &lt;string&gt; is
      %s. For additional information, see EVENT CORRELATION OPERATIONS
    section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>assign %&lt;var&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Assign string &lt;string&gt; to the action list variable
      %&lt;var&gt;. Default value for &lt;string&gt; is %s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>assignsq %&lt;var&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Similar to the <i>assign</i> action, except that
      &lt;string&gt; is quoted with single quotes before assigning it to
      %&lt;var&gt;. If &lt;string&gt; contains single quotes, they are masked
      with backslashes (e.g., if the match variable $1 holds the value
      abc'123'xyz, the action <i>assignsq %myvar $1</i> assigns the value
      'abc'\''123'\''xyz' to the action list variable %myvar). This action is
      useful for disabling shell intepretation for the values of action list
      variables that appear in command lines executed by SEC. Default value for
      &lt;string&gt; is %s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>free %&lt;var&gt;</i></dt>
  <dd class="It-tag">Unset the action list variable %&lt;var&gt;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>eval %&lt;var&gt; &lt;code&gt;</i></dt>
  <dd class="It-tag">The parameter &lt;code&gt; is a Perl miniprogram that is
      compiled and executed by calling the Perl <b>eval</b>() function in the
      Perl list context. If the miniprogram returns a single value, it is
      assigned to the action list variable %&lt;var&gt;. If the miniprogram
      returns several values s1,...,sn, they are joined into a multi-line string
      &quot;s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn&quot;, and this string is
      assigned to %&lt;var&gt;. If no value is returned, %&lt;var&gt; is set to
      Perl undefined value. If <b>eval</b>() fails, the value of %&lt;var&gt;
      does not change. Since most Perl programs contain semicolons which are
      also employed by SEC as action separators, it is recommended to enclose
      the &lt;code&gt; parameter in parentheses, in order to mask the semicolons
      in &lt;code&gt;. For additional information, see PERL INTEGRATION
    section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>call %&lt;var&gt; %&lt;ref&gt;
    [&lt;paramlist&gt;]</i></dt>
  <dd class="It-tag">Call the precompiled Perl function referenced by the action
      list variable %&lt;ref&gt;, and assign the result to the action list
      variable %&lt;var&gt;. The %&lt;ref&gt; parameter must be a code reference
      that has been previously created with the <i>eval</i> action. The
      &lt;paramlist&gt; parameter (if given) is a string which specifies
      parameters for the function. The parameters must be separated by
      whitespace in the &lt;paramlist&gt; string. If the function returns a
      single value, it is assigned to %&lt;var&gt;. If the function returns
      several values s1,...,sn, they are joined into a multi-line string
      &quot;s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn&quot;, and this string is
      assigned to %&lt;var&gt;. If no value is returned, %&lt;var&gt; is set to
      Perl undefined value. If the function encounters a fatal runtime error or
      %&lt;ref&gt; is not a code reference, the value of %&lt;var&gt; does not
      change. For additional information, see PERL INTEGRATION section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>lcall %&lt;var&gt; [&lt;paramlist&gt;] -&gt;
    &lt;code&gt;</i></dt>
  <dd class="It-tag">Call the precompiled Perl function &lt;code&gt; and assign
      the result to the action list variable %&lt;var&gt;. The &lt;code&gt;
      parameter must be a valid Perl function definition that is compiled at SEC
      startup with the Perl <b>eval</b>() function, and <b>eval</b>() must
      return a code reference. The &lt;paramlist&gt; parameter (if given) is a
      string which specifies parameters for the function. The parameters must be
      separated by whitespace in the &lt;paramlist&gt; string. If the function
      returns a single value, it is assigned to %&lt;var&gt;. If the function
      returns several values s1,...,sn, they are joined into a multi-line string
      &quot;s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn&quot;, and this string is
      assigned to %&lt;var&gt;. If no value is returned, %&lt;var&gt; is set to
      Perl undefined value. If the function encounters a fatal runtime error,
      the value of %&lt;var&gt; does not change. Since most Perl functions
      contain semicolons which are also employed by SEC as action separators, it
      is recommended to enclose the &lt;code&gt; parameter in parentheses, in
      order to mask the semicolons in &lt;code&gt;. For additional information,
      see PERL INTEGRATION section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rewrite &lt;lnum&gt; [&lt;string&gt;]</i></dt>
  <dd class="It-tag">Replace last &lt;lnum&gt; lines in the input buffer with
      string &lt;string&gt;. If the <b>--nojointbuf</b> option was specified and
      the action is triggered by a matching event, the action modifies the
      buffer which holds this event. If the <b>--nojointbuf</b> option was
      specified and the action is triggered by the system clock (e.g., the
      action is executed from the Calendar rule), the action modifies the buffer
      which holds the last already processed event. With the <b>--jointbuf</b>
      option, the content of the joint input buffer is rewritten. The
      &lt;lnum&gt; parameter must evaluate to an unsigned integer at runtime. If
      &lt;lnum&gt; evaluates to 0, &lt;lnum&gt; is reset to the number of lines
      in &lt;string&gt;. If the value of &lt;lnum&gt; is greater than the buffer
      size N, &lt;lnum&gt; is reset to N. If &lt;string&gt; contains less than
      &lt;lnum&gt; lines, &lt;string&gt; will be padded with leading empty
      lines. If &lt;string&gt; contains more than &lt;lnum&gt; lines, only
      leading &lt;lnum&gt; lines from &lt;string&gt; are written into the
      buffer. Default value for &lt;string&gt; is %s. For additional
      information, see INPUT PROCESSING AND TIMING section.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>if %&lt;var&gt; ( &lt;action list&gt; ) [ else (
    &lt;action list2&gt; ) ]</i></dt>
  <dd class="It-tag">If the action list variable %&lt;var&gt; evaluates true in
      the Perl boolean context (i.e., it holds a defined value which is neither
      0 nor empty string), execute the action list &lt;action list&gt;. If the
      second action list &lt;action list2&gt; is given with the optional
      else-statement, it is executed if %&lt;var&gt; either does not exist or
      evaluates false (i.e., %&lt;var&gt; holds 0, empty string or Perl
      undefined value).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>while %&lt;var&gt; ( &lt;action list&gt; )</i></dt>
  <dd class="It-tag">Execute the action list &lt;action list&gt; repeatedly as
      long as the action list variable %&lt;var&gt; evaluates true in the Perl
      boolean context (i.e., it holds a defined value which is neither 0 nor
      empty string).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>break</i></dt>
  <dd class="It-tag">If used inside a while-loop, terminates its execution;
      otherwise terminates the execution of the entire action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue</i></dt>
  <dd class="It-tag">If used inside a while-loop, starts the next iteration of
      the loop; otherwise terminates the execution of the entire action
    list.</dd>
</dl>
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
Follow the /var/log/trapd.log file and feed to SEC input all lines that are
  appended to the file:
<div class="Pp"></div>
action=spawn /bin/tail -f /var/log/trapd.log
<div class="Pp"></div>
Mail the timestamp and the value of the $0 variable to the local root:
<div class="Pp"></div>
action=pipe '%t: $0' /bin/mail -s &quot;alert message&quot; root@localhost
<div class="Pp"></div>
Add the value of the $0 variable to the event store of the context
  <b>ftp_&lt;the value of $1&gt;</b>, and set the context to expire after 30
  minutes. When the context expires, its event store will be mailed to the local
  root:
<div class="Pp"></div>
action=add ftp_$1 $0; \
<br/>
 set ftp_$1 1800 (report ftp_$1 /bin/mail root@localhost)
<div class="Pp"></div>
Create a subroutine for weeding out comment lines from the input list, and use
  this subroutine for removing comment lines from the event store of the context
  <b>C1</b>:
<div class="Pp"></div>
action=eval %funcptr ( sub { my(@buf) = split(/\n/, $_[0]); \
<br/>
 my(@ret) = grep(!/^#/, @buf); return @ret; } ); \
<br/>
 copy C1 %in; call %out %funcptr %in; fill C1 %out
<div class="Pp"></div>
The following action list achieves the same goal as the previous action list
  with <i>while</i> and <i>if</i> actions:
<div class="Pp"></div>
action=getsize %size C1; while %size ( shift C1 %event; \
<br/>
 lcall %nocomment %event -&gt; ( sub { $_[0] !~ /^#/ } ); \
<br/>
 if %nocomment ( add C1 %event ); \
<br/>
 lcall %size %size -&gt; ( sub { $_[0]-1; } ) )
<h1 class="Sh" title="Sh" id="PARSING_ISSUES"><a class="selflink" href="#PARSING_ISSUES">PARSING
  ISSUES</a></h1>
As already noted, SEC context expressions and action lists may contain
  parentheses which are used for grouping and masking purposes. When SEC parses
  its configuration, it checks whether parentheses in context expressions and
  action lists are balanced (i.e., whether each parenthesis has a counterpart),
  since unbalanced parentheses introduce ambiguity. This can cause SEC to reject
  some legitimate constructs, e.g.,
<div class="Pp"></div>
action=eval %o (print &quot;)&quot;;)
<div class="Pp"></div>
is considered an invalid action list (however, note that
<div>&#x00A0;</div>
action=eval %o (print &quot;()&quot;;)
<div>&#x00A0;</div>
would be passed by SEC, since now parentheses are balanced). In order to avoid
  such parsing errors, each parenthesis without a counterpart must be masked
  with a backslash (the backslash will be removed by SEC during configuration
  file parsing). For example, the above action could be written as
<div class="Pp"></div>
action=eval %o (print &quot;\)&quot;;)
<h1 class="Sh" title="Sh" id="RULE_TYPES"><a class="selflink" href="#RULE_TYPES">RULE
  TYPES</a></h1>
This section provides a detailed discussion of SEC rule types.
<h2 class="Ss" title="Ss" id="SINGLE_RULE"><a class="selflink" href="#SINGLE_RULE">SINGLE
  RULE</a></h2>
The <b>Single</b> rule immediately executes an action list when an event has
  matched the rule. An event matches the rule if the pattern matches the event
  and the context expression (if given) evaluates TRUE.
<div class="Pp"></div>
The Single rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to Single (value is case insensitive, so single or
      sIngLe can be used instead).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype</i></dt>
  <dd class="It-tag">pattern type (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap</i> (optional)</dt>
  <dd class="It-tag">variable map.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i></dt>
  <dd class="It-tag">operation description string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that match variables may be used in <i>context</i>, <i>desc</i>, and
  <i>action</i> fields. Also note that this rule does not start an event
  correlation operation, and the <i>desc</i> field is merely used for setting
  the %s action list variable.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
type=single
<div>&#x00A0;</div>
continue=takenext
<div>&#x00A0;</div>
ptype=regexp
<div>&#x00A0;</div>
pattern=ftpd\[(\d+)\]: \S+ \(ristov2.*FTP session opened
<div>&#x00A0;</div>
desc=ftp session opened for ristov2 pid $1
<div>&#x00A0;</div>
action=create ftp_$1
<div class="Pp"></div>
type=single
<div>&#x00A0;</div>
continue=takenext
<div>&#x00A0;</div>
ptype=regexp
<div>&#x00A0;</div>
pattern=ftpd\[(\d+)\]:
<div>&#x00A0;</div>
context=ftp_$1
<div>&#x00A0;</div>
desc=ftp session event for ristov2 pid $1
<div>&#x00A0;</div>
action=add ftp_$1 $0; set ftp_$1 1800 \
<br/>
 (report ftp_$1 /bin/mail root@localhost)
<div class="Pp"></div>
type=single
<div>&#x00A0;</div>
ptype=regexp
<div>&#x00A0;</div>
pattern=ftpd\[(\d+)\]: \S+ \(ristov2.*FTP session closed
<div>&#x00A0;</div>
desc=ftp session closed for ristov2 pid $1
<div>&#x00A0;</div>
action=report ftp_$1 /bin/mail root@localhost; \
<br/>
 delete ftp_$1
<div class="Pp"></div>
This ruleset is created for monitoring the ftpd log file. The first rule creates
  the context <b>ftp_&lt;pid&gt;</b> when someone connects from host ristov2
  over FTP and establishes a new ftp session (the session is identified by the
  PID of the process which has been created for handling this session). The
  second rule adds all further log file lines for the session &lt;pid&gt; to the
  event store of the context <b>ftp_&lt;pid&gt;</b> (before adding a line, the
  rule checks if the context exists). After adding a line, the rule extends
  context's lifetime for 30 minutes and sets the action list that will be
  executed when the context expires. The third rule mails collected log file
  lines to root@localhost when the session &lt;pid&gt; is closed. Collected
  lines will also be mailed when the session &lt;pid&gt; has been inactive for
  30 minutes (no log file lines observed for that session).
<div class="Pp"></div>
Note that the log file line that has matched the first rule is also matched
  against the second rule (since the first rule has the <i>continue</i> field
  set to TakeNext). Since the second rule always matches this line, it will
  become the first line in the event store of <b>ftp_&lt;pid&gt;</b>. The second
  rule has also its <i>continue</i> field set to TakeNext, since otherwise no
  log file lines would reach the third rule.
<h2 class="Ss" title="Ss" id="SINGLEWITHSCRIPT_RULE"><a class="selflink" href="#SINGLEWITHSCRIPT_RULE">SINGLEWITHSCRIPT
  RULE</a></h2>
The <b>SingleWithScript</b> rule forks a process for executing an external
  program when an event has matched the rule. The names of all currently
  existing contexts are written to the standard input of the program. After the
  program has been forked, the rule matching continues immediately, and the
  program status will be checked periodically until the program exits. If the
  program returns 0 exit status, the action list defined by the <i>action</i>
  field is executed; otherwise the action list defined by the <i>action2</i>
  field is executed (if given).
<div class="Pp"></div>
The SingleWithScript rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to SingleWithScript (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype</i></dt>
  <dd class="It-tag">pattern type (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap</i> (optional)</dt>
  <dd class="It-tag">variable map.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>script</i></dt>
  <dd class="It-tag">an external program.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i></dt>
  <dd class="It-tag">operation description string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action2</i> (optional)</dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that match variables may be used in <i>context</i>, <i>script</i>,
  <i>desc</i>, <i>action</i>, and <i>action2</i> fields. Also note that this
  rule does not start an event correlation operation, and the <i>desc</i> field
  is merely used for setting the %s action list variable.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
type=SingleWithScript
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=interface ([\d.]+) down
<div>&#x00A0;</div>
script=/bin/ping -c 3 -q $1
<div>&#x00A0;</div>
desc=Check if $1 responds to ping
<div>&#x00A0;</div>
action=logonly Interface $1 reported down, but is pingable
<div>&#x00A0;</div>
action2=pipe '%t: Interface $1 is down' /bin/mail root@localhost
<div class="Pp"></div>
When &quot;interface &lt;ipaddress&gt; down&quot; line appears in input, the
  rule checks if &lt;ipaddress&gt; responds to ping. If &lt;ipaddress&gt; is
  pingable, the message &quot;Interface &lt;ipaddress&gt; reported down, but is
  pingable&quot; is logged; otherwise an e-mail warning containing a
  human-readable timestamp is sent to root@localhost.
<h2 class="Ss" title="Ss" id="SINGLEWITHSUPPRESS_RULE"><a class="selflink" href="#SINGLEWITHSUPPRESS_RULE">SINGLEWITHSUPPRESS
  RULE</a></h2>
The <b>SingleWithSuppress</b> rule runs event correlation operations for
  filtering repeated instances of the same event during T seconds. The value of
  T is defined by the <i>window</i> field.
<div class="Pp"></div>
When an event has matched the rule, SEC evaluates the operation description
  string given with the <i>desc</i> field. If the operation for the given string
  and rule does not exist, SEC will create it with the lifetime of T seconds,
  and the operation immediately executes an action list. If the operation
  exists, it consumes the matching event without any action.
<div class="Pp"></div>
The SingleWithSuppress rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to SingleWithSuppress (value is case
    insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype</i></dt>
  <dd class="It-tag">pattern type (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap</i> (optional)</dt>
  <dd class="It-tag">variable map.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i></dt>
  <dd class="It-tag">operation description string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>window</i></dt>
  <dd class="It-tag">event correlation window size (value is an integer
      constant).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that match variables may be used in <i>context</i>, <i>desc</i>, and
  <i>action</i> fields.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
type=SingleWithSuppress
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=(\S+): [fF]ile system full
<div>&#x00A0;</div>
desc=File system $1 full
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=900
<div class="Pp"></div>
This rule runs event correlation operations for processing &quot;file system
  full&quot; syslog messages, e.g.,
<div class="Pp"></div>
Dec 16 14:26:09 test ufs: [ID 845546 kern.notice] NOTICE: alloc: /var: file
  system full
<div class="Pp"></div>
When the first message for a file system is observed, an operation is created
  which sends an e-mail warning about this file system to root@localhost. The
  operation will then run for 900 seconds and silently consume further messages
  for the *same* file system. However, if a message for a different file system
  is observed, another operation will be started which sends a warning to
  root@localhost again (since the <i>desc</i> field contains the $1 match
  variable which evaluates to the file system name).
<h2 class="Ss" title="Ss" id="PAIR_RULE"><a class="selflink" href="#PAIR_RULE">PAIR
  RULE</a></h2>
The <b>Pair</b> rule runs event correlation operations for processing event
  pairs during T seconds. The value of T is defined by the <i>window</i> field.
  Default value is 0 which means infinity.
<div class="Pp"></div>
When an event has matched the conditions defined by the <i>pattern</i> and
  <i>context</i> field, SEC evaluates the operation description string given
  with the <i>desc</i> field. If the operation for the given string and rule
  exists, it consumes the matching event without any action. If the operation
  does not exist, SEC will create it with the lifetime of T seconds, and the
  operation immediately executes an action list defined by the <i>action</i>
  field. SEC will also copy the match conditions given with the <i>pattern2</i>
  and <i>context2</i> field into the operation, and substitute match variables
  with their values in copied conditions.
<div class="Pp"></div>
If the event does not match conditions defined by the <i>pattern</i> and
  <i>context</i> field, SEC will check the match conditions of all operations
  started by the given rule. Each matching operation executes the action list
  given with the <i>action2</i> field and finishes.
<div class="Pp"></div>
If match variables are set when the operation matches an event, they are made
  available as $-prefixed match variables in <i>context2</i>, <i>desc2</i>, and
  <i>action2</i> fields of the rule definition. For example, if <i>pattern2</i>
  field is a regular expression, then $1 in the <i>desc2</i> field is set by
  <i>pattern2</i>. In order to access match variables set by <i>pattern</i>,
  %-prefixed match variables have to be used in <i>context2</i>, <i>desc2</i>,
  and <i>action2</i> fields. For example, if <i>pattern</i> and <i>pattern2</i>
  are regular expressions, then %1 in the <i>desc2</i> field refers to the value
  set by the first capture group in <i>pattern</i> (i.e., it has the same value
  as $1 in the <i>desc</i> field).
<div class="Pp"></div>
The Pair rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to Pair (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive). Specifies the
      point-of-continue after a match by <i>pattern</i> and <i>context</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype</i></dt>
  <dd class="It-tag">pattern type for <i>pattern</i> (value is case
      insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap</i> (optional)</dt>
  <dd class="It-tag">variable map for <i>pattern</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression, evaluated together with
    <i>pattern</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i></dt>
  <dd class="It-tag">operation description string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue2</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive). Specifies the
      point-of-continue after a match by <i>pattern2</i> and
    <i>context2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype2</i></dt>
  <dd class="It-tag">pattern type for <i>pattern2</i> (value is case
      insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern2</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap2</i> (optional)</dt>
  <dd class="It-tag">variable map for <i>pattern2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context2</i> (optional)</dt>
  <dd class="It-tag">context expression, evaluated together with
      <i>pattern2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc2</i></dt>
  <dd class="It-tag">format string that sets the %s variable for
    <i>action2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action2</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>window</i> (optional)</dt>
  <dd class="It-tag">event correlation window size (value is an integer
      constant).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that match variables may be used in <i>context</i>, <i>desc</i>,
  <i>action</i>, <i>pattern2</i>, <i>context2</i>, <i>desc2</i>, and
  <i>action2</i> fields.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
type=Pair
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=kernel: nfs: server (\S+) not responding, still trying
<div>&#x00A0;</div>
desc=Server $1 is not responding
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
ptype2=SubStr
<div>&#x00A0;</div>
pattern2=kernel: nfs: server $1 OK
<div>&#x00A0;</div>
desc2=Server $1 is responding again
<div>&#x00A0;</div>
action2=logonly
<div>&#x00A0;</div>
window=3600
<div class="Pp"></div>
This rule runs event correlation operations for processing NFS &quot;server not
  responding&quot; and &quot;server OK&quot; syslog messages, e.g.,
<div class="Pp"></div>
Dec 18 22:39:48 test kernel: nfs: server box1 not responding, still trying
<div>&#x00A0;</div>
Dec 18 22:42:27 test kernel: nfs: server box1 OK
<div class="Pp"></div>
When the &quot;server not responding&quot; message for an NFS server is
  observed, an operation is created for this server which sends an e-mail
  warning about the server to root@localhost. The operation will then run for
  3600 seconds and silently consume further &quot;server not responding&quot;
  messages for the same server. If this operation observes &quot;server OK&quot;
  message for the *same* server, it will log the message &quot;Server
  &lt;servername&gt; is responding again&quot; and finish.
<div class="Pp"></div>
For example, if SEC observes the following event at 22:39:48
<div class="Pp"></div>
Dec 18 22:39:48 test kernel: nfs: server box1 not responding, still trying
<div class="Pp"></div>
an event correlation operation is created for server box1 which issues an e-mail
  warning about this server immediately. After that, the operation will run for
  3600 seconds (until 23:39:48), waiting for an event which would contain the
  substring &quot;kernel: nfs: server box1 OK&quot; (because the <i>pattern2</i>
  field contains the $1 match variable which evaluates to the server name).
<div class="Pp"></div>
If any further error messages appear for server box1 during the 3600 second
  lifetime of the operation, e.g.,
<div class="Pp"></div>
Dec 18 22:40:28 test kernel: nfs: server box1 not responding, still trying
<div>&#x00A0;</div>
Dec 18 22:41:09 test kernel: nfs: server box1 not responding, still trying
<div class="Pp"></div>
these messages will be silently consumed by the operation. If before its
  expiration the operation observes an event which contains the substring
  &quot;kernel: nfs: server box1 OK&quot;, e.g.,
<div class="Pp"></div>
Dec 18 22:42:27 test kernel: nfs: server box1 OK
<div class="Pp"></div>
the operation will log the message &quot;Server box1 is responding again&quot;
  and terminate immediately. If no such message appears during the 3600 second
  lifetime of the operation, the operation will expire without taking any
  action. Please note that if the <i>window</i> field would be either removed
  from the rule definition or set to 0, the operation would never silently
  expire, but would terminate only after observing an event which contains the
  substring &quot;kernel: nfs: server box1 OK&quot;.
<div class="Pp"></div>
If the above rule is modified in the following way
<div class="Pp"></div>
type=Pair
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=^([[:alnum:]: ]+) \S+ kernel: nfs: server (\S+) not responding, still
  trying
<div>&#x00A0;</div>
desc=Server $2 is not responding
<div>&#x00A0;</div>
action=logonly
<div>&#x00A0;</div>
ptype2=RegExp
<div>&#x00A0;</div>
pattern2=^([[:alnum:]: ]+) \S+ kernel: nfs: server $2 OK
<div>&#x00A0;</div>
desc2=Server %2 was not accessible from %1 to $1
<div>&#x00A0;</div>
action2=pipe '%s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=86400
<div class="Pp"></div>
this rule will run event correlation operations which report NFS server downtime
  to root@localhost via e-mail, provided that downtime does not exceed 24 hours
  (86400 seconds).
<div class="Pp"></div>
For example, if SEC observes the following event
<div class="Pp"></div>
Dec 18 23:01:17 test kernel: nfs: server box.test not responding, still trying
<div class="Pp"></div>
then the rule matches this event, sets $1 match variable to &quot;Dec 18
  23:01:17&quot; and $2 to &quot;box.test&quot;, and creates an event
  correlation operation for server box.test. This operation will start its work
  by logging the message &quot;Server box.test is not responding&quot;, and will
  then run for 86400 seconds, waiting for an event which would match the regular
  expression
<div class="Pp"></div>
^([[:alnum:]: ]+) \S+ kernel: nfs: server box\.test OK
<div class="Pp"></div>
Note that this expression was created from the regular expression template in
  the <i>pattern2</i> field by substituting the match variable $2 with its
  value. However, since the string &quot;box.test&quot; contains the dot (.)
  character which is a regular expression metacharacter, the dot is masked with
  the backslash in the regular expression.
<div class="Pp"></div>
Suppose SEC will then observe the event
<div class="Pp"></div>
Dec 18 23:09:54 test kernel: nfs: server box.test OK
<div class="Pp"></div>
This event matches the above regular expression which is used by the operation
  running for server box.test. Also, the regular expression match sets the $1
  variable to &quot;Dec 18 23:09:54&quot; and unsets the $2 variable. In order
  to refer to their original values when the operation was created, %1 and %2
  match variables have to be used in the <i>desc2</i> field (%1 equals to
  &quot;Dec 18 23:01:17&quot; and %2 equals to &quot;box.test&quot;). Therefore,
  the operation will send the e-mail message &quot;Server box.test was not
  accessible from Dec 18 23:01:17 to Dec 18 23:09:54&quot; to root@localhost,
  and will terminate immediately.
<h2 class="Ss" title="Ss" id="PAIRWITHWINDOW_RULE"><a class="selflink" href="#PAIRWITHWINDOW_RULE">PAIRWITHWINDOW
  RULE</a></h2>
The <b>PairWithWindow</b> rule runs event correlation operations for processing
  event pairs during T seconds. The value of T is defined by the <i>window</i>
  field.
<div class="Pp"></div>
When an event has matched the conditions defined by the <i>pattern</i> and
  <i>context</i> field, SEC evaluates the operation description string given
  with the <i>desc</i> field. If the operation for the given string and rule
  exists, it consumes the matching event without any action. If the operation
  does not exist, SEC will create it with the lifetime of T seconds. SEC will
  also copy the match conditions given with the <i>pattern2</i> and
  <i>context2</i> field into the operation, and substitute match variables with
  their values in copied conditions.
<div class="Pp"></div>
If the event does not match conditions defined by the <i>pattern</i> and
  <i>context</i> field, SEC will check the match conditions of all operations
  started by the given rule. Each matching operation executes the action list
  given with the <i>action2</i> field and finishes. If the operation has not
  observed a matching event by the end of its lifetime, it executes the action
  list given with the <i>action</i> field before finishing.
<div class="Pp"></div>
If match variables are set when the operation matches an event, they are made
  available as $-prefixed match variables in <i>context2</i>, <i>desc2</i>, and
  <i>action2</i> fields of the rule definition. For example, if <i>pattern2</i>
  field is a regular expression, then $1 in the <i>desc2</i> field is set by
  <i>pattern2</i>. In order to access match variables set by <i>pattern</i>,
  %-prefixed match variables have to be used in <i>context2</i>, <i>desc2</i>,
  and <i>action2</i> fields. For example, if <i>pattern</i> and <i>pattern2</i>
  are regular expressions, then %1 in the <i>desc2</i> field refers to the value
  set by the first capture group in <i>pattern</i> (i.e., it has the same value
  as $1 in the <i>desc</i> field).
<div class="Pp"></div>
The PairWithWindow rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to PairWithWindow (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive). Specifies the
      point-of-continue after a match by <i>pattern</i> and <i>context</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype</i></dt>
  <dd class="It-tag">pattern type for <i>pattern</i> (value is case
      insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap</i> (optional)</dt>
  <dd class="It-tag">variable map for <i>pattern</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression, evaluated together with
    <i>pattern</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i></dt>
  <dd class="It-tag">operation description string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue2</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive). Specifies the
      point-of-continue after a match by <i>pattern2</i> and
    <i>context2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype2</i></dt>
  <dd class="It-tag">pattern type for <i>pattern2</i> (value is case
      insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern2</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap2</i> (optional)</dt>
  <dd class="It-tag">variable map for <i>pattern2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context2</i> (optional)</dt>
  <dd class="It-tag">context expression, evaluated together with
      <i>pattern2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc2</i></dt>
  <dd class="It-tag">format string that sets the %s variable for
    <i>action2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action2</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>window</i></dt>
  <dd class="It-tag">event correlation window size (value is an integer
      constant).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that match variables may be used in <i>context</i>, <i>desc</i>,
  <i>action</i>, <i>pattern2</i>, <i>context2</i>, <i>desc2</i>, and
  <i>action2</i> fields.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
type=PairWithWindow
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (\S+) from ([\d.]+) port \d+ ssh2
<div>&#x00A0;</div>
desc=User $1 has been unable to log in from $2 over SSH during 1 minute
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
ptype2=RegExp
<div>&#x00A0;</div>
pattern2=sshd\[\d+\]: Accepted .+ for $1 from $2 port \d+ ssh2
<div>&#x00A0;</div>
desc2=SSH login successful for %1 from %2 after initial failure
<div>&#x00A0;</div>
action2=logonly
<div>&#x00A0;</div>
window=60
<div class="Pp"></div>
This rule runs event correlation operations for processing SSH login events,
  e.g.,
<div class="Pp"></div>
Dec 27 19:00:24 test sshd[10526]: Failed password for risto from 10.1.2.7 port
  52622 ssh2
<div>&#x00A0;</div>
Dec 27 19:00:27 test sshd[10526]: Accepted password for risto from 10.1.2.7 port
  52622 ssh2
<div class="Pp"></div>
When an SSH login failure is observed for a user name and a source IP address,
  an operation is created for this user name and IP address combination which
  will expect a successful login for the *same* user name and *same* IP address
  during 60 seconds. If the user will not log in from the same IP address during
  60 seconds, the operation will send an e-mail warning to root@localhost before
  finishing, otherwise it will log the message &quot;SSH login successful for
  &lt;username&gt; from &lt;ipaddress&gt; after initial failure&quot; and
  finish.
<div class="Pp"></div>
Suppose the following events are generated by an SSH daemon, and each event
  timestamp reflects the time SEC observes the event:
<div class="Pp"></div>
Dec 30 13:02:01 test sshd[30517]: Failed password for risto from 10.1.2.7 port
  42172 ssh2
<div>&#x00A0;</div>
Dec 30 13:02:30 test sshd[30810]: Failed password for root from 192.168.1.104
  port 46125 ssh2
<div>&#x00A0;</div>
Dec 30 13:02:37 test sshd[30517]: Failed password for risto from 10.1.2.7 port
  42172 ssh2
<div>&#x00A0;</div>
Dec 30 13:02:59 test sshd[30810]: Failed password for root from 192.168.1.104
  port 46125 ssh2
<div>&#x00A0;</div>
Dec 30 13:03:04 test sshd[30810]: Accepted password for root from 192.168.1.104
  port 46125 ssh2
<div class="Pp"></div>
When the first event is observed at 13:02:01, an operation is started for user
  risto and IP address 10.1.2.7 which will expect a successful login for risto
  from 10.1.2.7. The operation will run for 60 seconds, waiting for an event
  which would match the regular expression
<div class="Pp"></div>
sshd\[\d+\]: Accepted .+ for risto from 10\.1\.2\.7 port \d+ ssh2
<div class="Pp"></div>
Note that this expression was created from the regular expression template in
  the <i>pattern2</i> field by substituting match variables $1 and $2 with their
  values. However, since the value of $2 contains the dot (.) characters which
  are regular expression metacharacters, each dot is masked with the backslash
  in the regular expression.
<div class="Pp"></div>
When the second event is observed at 13:02:30, another operation is started for
  user root and IP address 192.168.1.104 which will expect root to log in
  successfully from 192.168.1.104. This operation will run for 60 seconds,
  waiting for an event matching the regular expression
<div class="Pp"></div>
sshd\[\d+\]: Accepted .+ for root from 192\.168\.1\.104 port \d+ ssh2
<div class="Pp"></div>
The third event at 13:02:37 represents a second login failure for user risto and
  IP address 10.1.2.7, and is silently consumed by the first operation.
  Likewise, the fourth event at 13:02:59 is silently consumed by the second
  operation. The first operation will run until 13:03:01 and then expire without
  seeing a successful login for risto from 10.1.2.7. Before terminating, the
  operation will send an e-mail warning to root@localhost that user risto has
  not managed to log in from 10.1.2.7 during one minute. At 13:03:04, the second
  operation will observe an event which matches its regular expression
<div class="Pp"></div>
sshd\[\d+\]: Accepted .+ for root from 192\.168\.1\.104 port \d+ ssh2
<div class="Pp"></div>
After seeing this event, the operation will log the message &quot;SSH login
  successful for root from 192.168.1.104 after initial failure&quot; and
  terminate immediately. Please note that the match by the regular expression
<div class="Pp"></div>
sshd\[\d+\]: Accepted .+ for root from 192\.168\.1\.104 port \d+ ssh2
<div class="Pp"></div>
sets the $1 match variable to 1 and unsets $2. Therefore, the %1 and %2 match
  variables have to be used in the <i>desc2</i> field, in order to refer to the
  original values of $1 (root) and $2 (192.168.1.104) when the operation was
  created.
<h2 class="Ss" title="Ss" id="SINGLEWITHTHRESHOLD_RULE"><a class="selflink" href="#SINGLEWITHTHRESHOLD_RULE">SINGLEWITHTHRESHOLD
  RULE</a></h2>
The <b>SingleWithThreshold</b> rule runs event correlation operations for
  counting repeated instances of the same event during T seconds, and taking an
  action if N events are observed. The values of T and N are defined by the
  <i>window</i> and <i>thresh</i> field, respectively.
<div class="Pp"></div>
When an event has matched the rule, SEC evaluates the operation description
  string given with the <i>desc</i> field. If the operation for the given string
  and rule does not exist, SEC will create it with the lifetime of T seconds.
  The operation will memorize the occurrence time of the event (current time as
  returned by the <b>time</b>(2) system call), and compare the number of
  memorized occurrence times with the threshold N. If the operation has observed
  N events, it executes the action list defined by the <i>action</i> field, and
  consumes all further matching events without any action. If the rule has an
  optional action list defined with the <i>action2</i> field, the operation will
  execute it before finishing, provided that the action list given with
  <i>action</i> has been previously executed by the operation. Note that a
  sliding window is employed for event counting -- if the operation has observed
  less than N events by the end of its lifetime, it drops occurrence times which
  are older than T seconds, and extends its lifetime for T seconds from the
  earliest remaining occurrence time. If there are no remaining occurrence
  times, the operation finishes without executing an action list.
<div class="Pp"></div>
The SingleWithThreshold rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to SingleWithThreshold (value is case
    insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype</i></dt>
  <dd class="It-tag">pattern type (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap</i> (optional)</dt>
  <dd class="It-tag">variable map.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i></dt>
  <dd class="It-tag">operation description string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action2</i> (optional)</dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>window</i></dt>
  <dd class="It-tag">event correlation window size (value is an integer
      constant).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>thresh</i></dt>
  <dd class="It-tag">counting threshold (value is an integer constant).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that match variables may be used in <i>context</i>, <i>desc</i>,
  <i>action</i>, and <i>action2</i> fields.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (\S+) from [\d.]+ port \d+ ssh2
<div>&#x00A0;</div>
desc=Three SSH login failures within 1m for user $1
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=60
<div>&#x00A0;</div>
thresh=3
<div class="Pp"></div>
This rule runs event correlation operations for counting the number of SSH login
  failure events. Each operation counts events for one user name, and if the
  operation has observed three login failures within 60 seconds, it sends an
  e-mail warning to root@localhost.
<div class="Pp"></div>
Suppose the following events are generated by an SSH daemon, and each event
  timestamp reflects the time SEC observes the event:
<div class="Pp"></div>
Dec 28 01:42:21 test sshd[28132]: Failed password for risto from 10.1.2.7 port
  42172 ssh2
<div>&#x00A0;</div>
Dec 28 01:43:10 test sshd[28132]: Failed password for risto from 10.1.2.7 port
  42172 ssh2
<div>&#x00A0;</div>
Dec 28 01:43:29 test sshd[28132]: Failed password for risto from 10.1.2.7 port
  42172 ssh2
<div>&#x00A0;</div>
Dec 28 01:44:00 test sshd[28149]: Failed password for risto2 from 10.1.2.7 port
  42176 ssh2
<div>&#x00A0;</div>
Dec 28 01:44:03 test sshd[28211]: Failed password for risto from 10.1.2.7 port
  42192 ssh2
<div>&#x00A0;</div>
Dec 28 01:44:07 test sshd[28211]: Failed password for risto from 10.1.2.7 port
  42192 ssh2
<div class="Pp"></div>
When the first event is observed at 01:42:21, a counting operation is started
  for user risto, with its event correlation window ending at 01:43:21. Since by
  01:43:21 two SSH login failures for user risto have occurred, the threshold
  condition remains unsatisfied for the operation. Therefore, the beginning of
  its event correlation window will be moved to 01:43:10 (the occurrence time of
  the second event), leaving the first event outside the window. At 01:44:00,
  another counting operation is started for user risto2. The threshold condition
  for the first operation will become satisfied at 01:44:03 (since the operation
  has seen three login failure events for user risto within 60 seconds), and
  thus an e-mail warning will be issued. Finally, the event occurring at
  01:44:07 will be consumed silently by the first operation (the operation will
  run until 01:44:10). Since there will be no further login failure events for
  user risto2, the second operation will exist until 01:45:00 without taking any
  action.
<h2 class="Ss" title="Ss" id="SINGLEWITH2THRESHOLDS_RULE"><a class="selflink" href="#SINGLEWITH2THRESHOLDS_RULE">SINGLEWITH2THRESHOLDS
  RULE</a></h2>
The <b>SingleWith2Thresholds</b> rule runs event correlation operations which
  take action if N1 events have been observed in the window of T1 seconds, and
  then at most N2 events will be observed in the window of T2 seconds. The
  values of T1, N1, T2, and N2 are defined by the <i>window</i>, <i>thresh</i>,
  <i>window2</i>, and <i>thresh2</i> field, respectively.
<div class="Pp"></div>
When an event has matched the rule, SEC evaluates the operation description
  string given with the <i>desc</i> field. If the operation for the given string
  and rule does not exist, SEC will create it with the lifetime of T1 seconds.
  The operation will memorize the occurrence time of the event (current time as
  returned by the <b>time</b>(2) system call), and compare the number of
  memorized occurrence times with the threshold N1. If the operation has
  observed N1 events, it executes the action list defined by the <i>action</i>
  field, and starts another counting round for T2 seconds. If no more than N2
  events have been observed by the end of the window, the operation executes the
  action list defined by the <i>action2</i> field and finishes. Note that both
  windows are sliding -- the first window slides like the window of the
  SingleWithThreshold operation, while the beginning of the second window is
  moved to the second earliest memorized event occurrence time when the
  threshold N2 is violated.
<div class="Pp"></div>
The SingleWith2Thresholds rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to SingleWith2Thresholds (value is case
    insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype</i></dt>
  <dd class="It-tag">pattern type (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap</i> (optional)</dt>
  <dd class="It-tag">variable map.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i></dt>
  <dd class="It-tag">operation description string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>window</i></dt>
  <dd class="It-tag">event correlation window size (value is an integer
      constant).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>thresh</i></dt>
  <dd class="It-tag">counting threshold.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc2</i></dt>
  <dd class="It-tag">format string that sets the %s variable for
    <i>action2</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action2</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>window2</i></dt>
  <dd class="It-tag">event correlation window size (value is an integer
      constant).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>thresh2</i></dt>
  <dd class="It-tag">counting threshold.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that match variables may be used in <i>context</i>, <i>desc</i>,
  <i>action</i>, <i>desc2</i>, and <i>action2</i> fields.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
type=SingleWith2Thresholds
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=(\S+): %SYS-3-CPUHOG
<div>&#x00A0;</div>
desc=Router $1 CPU overload
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=300
<div>&#x00A0;</div>
thresh=2
<div>&#x00A0;</div>
desc2=Router $1 CPU load has been normal for 1h
<div>&#x00A0;</div>
action2=logonly
<div>&#x00A0;</div>
window2=3600
<div>&#x00A0;</div>
thresh2=0
<div class="Pp"></div>
When a SYS-3-CPUHOG syslog message is received from a router, the rule starts a
  counting operation for this router which sends an e-mail warning to
  root@localhost if another such message is received from the same router within
  300 seconds. After sending the warning, the operation will continue to run
  until no SYS-3-CPUHOG syslog messages have been received from the router for
  3600 seconds. When this condition becomes satisfied, the operation will log
  the message &quot;Router &lt;routername&gt; CPU load has been normal for
  1h&quot; and finish.
<div class="Pp"></div>
Suppose the following events are generated by a router, and each event timestamp
  reflects the time SEC observes the event:
<div class="Pp"></div>
Dec 30 12:23:25 router1.mydomain Router1: %SYS-3-CPUHOG: cpu is hogged
<div>&#x00A0;</div>
Dec 30 12:25:38 router1.mydomain Router1: %SYS-3-CPUHOG: cpu is hogged
<div>&#x00A0;</div>
Dec 30 12:28:53 router1.mydomain Router1: %SYS-3-CPUHOG: cpu is hogged
<div class="Pp"></div>
When the first event is observed at 12:23:25, a counting operation is started
  for router Router1. The appearance of the second event at 12:25:38 fulfills
  the threshold condition given with the <i>thresh</i> and <i>window</i> fields
  (two events have been observed within 300 seconds). Therefore, the operation
  will send an e-mail warning about the CPU overload of Router1 to
  root@localhost.
<div class="Pp"></div>
After that, the operation will start another counting round, expecting to see no
  SYS-3-CPUHOG events (since <i>thresh2=0</i>) for Router1 during the following
  3600 seconds (the beginning of the operation's event correlation window will
  be moved to 12:25:38 for the second counting round). Since the appearance of
  the third event at 12:28:53 violates the threshold condition given with the
  <i>thresh2</i> and <i>window2</i> fields, the beginning of the event
  correlation window will be moved to 12:28:53. Since there will be no further
  SYS-3-CPUHOG messages for Router1, the operation will run until 13:28:53 and
  then expire, logging the message &quot;Router Router1 CPU load has been normal
  for 1h&quot; before finishing.
<h2 class="Ss" title="Ss" id="EVENTGROUP_RULE"><a class="selflink" href="#EVENTGROUP_RULE">EVENTGROUP
  RULE</a></h2>
The <b>EventGroup</b> rule runs event correlation operations for counting
  repeated instances of N different events e1,...,eN during T seconds, and
  taking an action if threshold conditions c1,...,cN for *all* events are
  satisfied (i.e., for each event eK there are at least cK event instances in
  the window). Note that the event correlation window of the EventGroup
  operation is sliding like the window of the SingleWithThreshold operation.
<div class="Pp"></div>
Event e1 is described with the <i>pattern</i> and <i>context</i> field, event e2
  is described with the <i>pattern2</i> and <i>context2</i> field, etc. The
  values for N and T are defined by the <i>type</i> and <i>window</i> field,
  respectively. The value for c1 is given with the <i>thresh</i> field, the
  value for c2 is given with the <i>thresh2</i> field, etc. Values for N and
  c1,...,cN default to 1.
<div class="Pp"></div>
In order to match an event with the rule, <i>pattern</i> and <i>context</i>
  fields are evaluated first. If they don't match the event, then
  <i>pattern2</i> and <i>context2</i> are evaluated, etc. If all N conditions
  are tried without a success, the event doesn't match the rule.
<div class="Pp"></div>
When an event has matched the rule, SEC evaluates the operation description
  string given with the <i>desc</i> field. If the operation for the given string
  and rule does not exist, SEC will create it with the lifetime of T seconds.
  The operation will memorize the occurrence time of the event (current time as
  returned by the <b>time</b>(2) system call), and compare the number of
  memorized occurrence times for each eK with the threshold cK (i.e., the number
  of observed instances of eK is compared with the threshold cK). If all
  threshold confitions are satisfied, the operation executes the action list
  defined by the <i>action</i> field, and consumes all further matching events
  without re-executing the action list if the <i>multact</i> field is set to No
  (this is the default). However, if <i>multact</i> is set to Yes, the operation
  will re-evaluate the threshold conditions on every further matching event,
  re-executing the action list given with the <i>action</i> field if all
  conditions are satisfied, and sliding the event correlation window forward
  when the window is about to expire (if no events remain in the window, the
  operation will finish).
<div class="Pp"></div>
If the rule definition has an optional action list defined with the
  <i>countK</i> field for event eK, the operation executes it every time an
  instance of eK is observed (even if <i>multact</i> is set to No and the
  operation has already executed the action list given with <i>action</i>).
<div class="Pp"></div>
If the rule definition has an optional action list defined with the <i>init</i>
  field, the operation executes it immediately after the operation has been
  created.
<div class="Pp"></div>
If the rule definition has an optional action list defined with the <i>end</i>
  field, the operation executes it immediately before the operation finishes.
  Note that this action list is *not* executed when the operation is terminated
  with the <i>reset</i> action.
<div class="Pp"></div>
If the rule definition has an optional action list defined with the <i>slide</i>
  field, the operation executes it immediately after the event correlation
  window has slidden forward. However, note that moving the window with the
  <i>setwpos</i> action will *not* trigger the execution.
<div class="Pp"></div>
The EventGroup rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag"><i></i>EventGroup[<i>N</i>] (value is case insensitive, N
      defaults to 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive). Specifies the
      point-of-continue after a match by <i>pattern</i> and <i>context</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype</i></dt>
  <dd class="It-tag">pattern type for <i>pattern</i> (value is case
      insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap</i> (optional)</dt>
  <dd class="It-tag">variable map for <i>pattern</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression, evaluated together with
    <i>pattern</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>count</i> (optional)</dt>
  <dd class="It-tag">action list for execution after a match by <i>pattern</i>
      and <i>context</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>thresh</i> (optional)</dt>
  <dd class="It-tag">counting threshold for events matched by <i>pattern</i> and
      <i>context</i> (value is an integer constant, default is 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>...</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continueN</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive). Specifies the
      point-of-continue after a match by <i>patternN</i> and
    <i>contextN</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptypeN</i></dt>
  <dd class="It-tag">pattern type for <i>patternN</i> (value is case
      insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>patternN</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmapN</i> (optional)</dt>
  <dd class="It-tag">variable map for <i>patternN</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>contextN</i> (optional)</dt>
  <dd class="It-tag">context expression, evaluated together with
      <i>patternN</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>countN</i> (optional)</dt>
  <dd class="It-tag">action list for execution after a match by <i>patternN</i>
      and <i>contextN</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>threshN</i> (optional)</dt>
  <dd class="It-tag">counting threshold for events matched by <i>patternN</i>
      and <i>contextN</i> (value is an integer constant, default is 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i></dt>
  <dd class="It-tag">operation description string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>init</i> (optional)</dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>end</i> (optional)</dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>slide</i> (optional)</dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>multact</i> (optional)</dt>
  <dd class="It-tag">Yes or No (values are case insensitive, default is
    No).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>window</i></dt>
  <dd class="It-tag">event correlation window size (value is an integer
      constant).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that match variables may be used in <i>context*</i>, <i>count*</i>,
  <i>desc</i>, <i>action</i>, <i>init</i>, <i>end</i>, and <i>slide</i> fields.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
The following example rule cross-correlates iptables events, Apache web server
  access log messages with 4xx response codes, and SSH login failure events:
<div class="Pp"></div>
type=EventGroup3
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (?:invalid user )?\S+ from ([\d.]+) port \d+
  ssh2
<div>&#x00A0;</div>
thresh=2
<div>&#x00A0;</div>
ptype2=RegExp
<div>&#x00A0;</div>
pattern2=^([\d.]+) \S+ \S+ \[.+?\] &quot;.+? HTTP\/[\d.]+&quot; 4\d+
<div>&#x00A0;</div>
thresh2=3
<div>&#x00A0;</div>
ptype3=RegExp
<div>&#x00A0;</div>
pattern3=kernel: iptables:.* SRC=([\d.]+)
<div>&#x00A0;</div>
thresh3=5
<div>&#x00A0;</div>
desc=Repeated probing from host $1
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=120
<div class="Pp"></div>
The rule starts an event correlation operation for an IP address if SSH login
  failure event, iptables event, or Apache 4xx event is observed for that IP
  address. The operation sends an e-mail warning to root@localhost if within 120
  seconds three threshold conditions are satisfied for the IP address it tracks
  -- (1) at least two SSH login failure events have occurred for this client IP,
  (2) at least three Apache 4xx events have occured for this client IP, (3) at
  least five iptables events have been observed for this source IP.
<div class="Pp"></div>
Suppose the following events occur, and each event timestamp reflects the time
  SEC observes the event:
<div class="Pp"></div>
192.168.1.104 - - [05/Jan/2014:01:11:22 +0200] &quot;GET /test.html
  HTTP/1.1&quot; 404 286 &quot;-&quot; &quot;Mozilla/5.0 (X11; Ubuntu; Linux
  i686; rv:26.0) Gecko/20100101 Firefox/26.0&quot;
<div>&#x00A0;</div>
Jan 5 01:12:52 localhost kernel: iptables: IN=eth0 OUT=
  MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104
  DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=48422 DF PROTO=TCP
  SPT=46351 DPT=21 WINDOW=29200 RES=0x00 SYN URGP=0
<div>&#x00A0;</div>
Jan 5 01:12:53 localhost kernel: iptables: IN=eth0 OUT=
  MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104
  DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=48423 DF PROTO=TCP
  SPT=46351 DPT=21 WINDOW=29200 RES=0x00 SYN URGP=0
<div>&#x00A0;</div>
Jan 5 01:13:01 localhost kernel: iptables: IN=eth0 OUT=
  MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104
  DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=20048 DF PROTO=TCP
  SPT=44963 DPT=23 WINDOW=29200 RES=0x00 SYN URGP=0
<div>&#x00A0;</div>
Jan 5 01:13:02 localhost kernel: iptables: IN=eth0 OUT=
  MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104
  DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=20049 DF PROTO=TCP
  SPT=44963 DPT=23 WINDOW=29200 RES=0x00 SYN URGP=0
<div>&#x00A0;</div>
Jan 5 01:13:08 localhost kernel: iptables: IN=eth0 OUT=
  MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104
  DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=36362 DF PROTO=TCP
  SPT=56918 DPT=25 WINDOW=29200 RES=0x00 SYN URGP=0
<div>&#x00A0;</div>
Jan 5 01:13:09 localhost kernel: iptables: IN=eth0 OUT=
  MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104
  DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=36363 DF PROTO=TCP
  SPT=56918 DPT=25 WINDOW=29200 RES=0x00 SYN URGP=0
<div>&#x00A0;</div>
192.168.1.104 - - [05/Jan/2014:01:13:51 +0200] &quot;GET /test.html
  HTTP/1.1&quot; 404 286 &quot;-&quot; &quot;Mozilla/5.0 (X11; Ubuntu; Linux
  i686; rv:26.0) Gecko/20100101 Firefox/26.0&quot;
<div>&#x00A0;</div>
192.168.1.104 - - [05/Jan/2014:01:13:54 +0200] &quot;GET /test.html
  HTTP/1.1&quot; 404 286 &quot;-&quot; &quot;Mozilla/5.0 (X11; Ubuntu; Linux
  i686; rv:26.0) Gecko/20100101 Firefox/26.0&quot;
<div>&#x00A0;</div>
192.168.1.104 - - [05/Jan/2014:01:14:00 +0200] &quot;GET /login.html
  HTTP/1.1&quot; 404 287 &quot;-&quot; &quot;Mozilla/5.0 (X11; Ubuntu; Linux
  i686; rv:26.0) Gecko/20100101 Firefox/26.0&quot;
<div>&#x00A0;</div>
192.168.1.104 - - [05/Jan/2014:01:14:03 +0200] &quot;GET /login.html
  HTTP/1.1&quot; 404 287 &quot;-&quot; &quot;Mozilla/5.0 (X11; Ubuntu; Linux
  i686; rv:26.0) Gecko/20100101 Firefox/26.0&quot;
<div>&#x00A0;</div>
192.168.1.104 - - [05/Jan/2014:01:14:03 +0200] &quot;GET /login.html
  HTTP/1.1&quot; 404 287 &quot;-&quot; &quot;Mozilla/5.0 (X11; Ubuntu; Linux
  i686; rv:26.0) Gecko/20100101 Firefox/26.0&quot;
<div>&#x00A0;</div>
Jan 5 01:14:11 localhost sshd[1810]: Failed password for root from 192.168.1.104
  port 46125 ssh2
<div>&#x00A0;</div>
Jan 5 01:14:12 localhost sshd[1810]: Failed password for root from 192.168.1.104
  port 46125 ssh2
<div>&#x00A0;</div>
Jan 5 01:14:18 localhost sshd[1822]: Failed password for root from 192.168.1.104
  port 46126 ssh2
<div>&#x00A0;</div>
Jan 5 01:14:19 localhost sshd[1822]: Failed password for root from 192.168.1.104
  port 46126 ssh2
<div>&#x00A0;</div>
192.168.1.104 - - [05/Jan/2014:01:14:34 +0200] &quot;GET /test.html
  HTTP/1.1&quot; 404 286 &quot;-&quot; &quot;Mozilla/5.0 (X11; Ubuntu; Linux
  i686; rv:26.0) Gecko/20100101 Firefox/26.0&quot;
<div class="Pp"></div>
The Apache 4xx event at 01:11:22 starts an event correlation operation for
  192.168.1.104 which has the event correlation window of 120 seconds, thus
  ending at 01:13:22. Between 01:12:52 and 01:13:09, six iptables events appear
  for 192.168.1.104, and the appearance of the fifth event at 01:13:08 fulfills
  the third threshold condition (within 120 seconds, at least five iptables
  events have been observed).
<div class="Pp"></div>
Since by 01:13:22 (the end of the event correlation window) no additional events
  have occurred, the first and second threshold condition remain unsatisfied.
  Therefore, the beginning of the event correlation window will be moved to
  01:12:52 (the occurrence time of the earliest event which is at most 120
  seconds old). As a result, the end of the window will move from 01:13:22 to
  01:14:52. The only event which is left outside the window is the Apache 4xx
  event at 01:11:22, and thus the threshold condition for iptables events
  remains satisfied.
<div class="Pp"></div>
Between 01:13:51 and 01:14:03, five Apache 4xx events occur, and the appearance
  of the third event at 01:14:00 fulfills the second threshold condition (within
  120 seconds, at least three Apache 4xx events have been observed). These
  events are followed by four SSH login failure events which occur between
  01:14:11 and 01:14:19. The appearance of the second event at 01:14:12 fulfills
  the first threshold condition (within 120 seconds, at least two SSH login
  failure events have been observed). Since at this particular moment (01:14:12)
  the other two conditions are also fulfilled, the operation sends an e-mail
  warning about 192.168.1.104 to root@localhost. After that, the operation
  silently consumes all further matching events for 192.168.1.104 until
  01:14:52, and then terminates.
<div class="Pp"></div>
Please note that if the above rule definition would contain <i>multact=yes</i>
  statement, the operation would continue sending e-mails at each matching event
  after 01:14:12, provided that all threshold conditions are satisfied.
  Therefore, the operation would send three additional e-mails at 01:14:18,
  01:14:19, and 01:14:34. Also, the operation would not terminate after its
  window ends at 01:14:52, but would rather slide the window forward and expect
  new events. At the occurence of any iptables, SSH login failure or Apache 4xx
  event for 192.168.1.104, the operation would produce a warning e-mail if all
  threshold conditions are fulfilled.
<div class="Pp"></div>
The following example rule cross-correlates iptables events and SSH login
  events:
<div class="Pp"></div>
type=EventGroup3
<div>&#x00A0;</div>
ptype=regexp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (\S+) from ([\d.]+) port \d+ ssh2
<div>&#x00A0;</div>
varmap= user=1; ip=2
<div>&#x00A0;</div>
count=alias OPER_$+{ip} LOGIN_FAILED_$+{user}_$+{ip}
<div>&#x00A0;</div>
ptype2=regexp
<div>&#x00A0;</div>
pattern2=sshd\[\d+\]: Accepted .+ for (\S+) from ([\d.]+) port \d+ ssh2
<div>&#x00A0;</div>
varmap2= user=1; ip=2
<div>&#x00A0;</div>
context2=LOGIN_FAILED_$+{user}_$+{ip}
<div>&#x00A0;</div>
ptype3=regexp
<div>&#x00A0;</div>
pattern3=kernel: iptables:.* SRC=([\d.]+)
<div>&#x00A0;</div>
varmap3= ip=1
<div>&#x00A0;</div>
desc=Client $+{ip} accessed a firewalled port and had difficulties with logging
  in
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
init=create OPER_$+{ip}
<div>&#x00A0;</div>
slide=delete OPER_$+{ip}; reset 0
<div>&#x00A0;</div>
end=delete OPER_$+{ip}
<div>&#x00A0;</div>
window=120
<div class="Pp"></div>
The rule starts an event correlation operation for an IP address if SSH login
  failure or iptables event was observed for that IP address. The operation
  exists for 120 seconds (since when the event correlation window slides
  forward, the operation terminates itself with the <i>reset</i> action as
  specified with the <i>slide</i> field). The operation sends an e-mail warning
  to root@localhost if within 120 seconds three threshold conditions are
  satisfied for the IP address it tracks -- (1) at least one iptables event has
  been observed for this source IP, (2) at least one SSH login failure has been
  observed for this client IP, (3) at least one successful SSH login has been
  observed for this client IP and for some user, provided that the operation has
  previously observed an SSH login failure for the same user and same client IP.
<div class="Pp"></div>
Suppose the following events occur, and each event timestamp reflects the time
  SEC observes the event:
<div class="Pp"></div>
Dec 27 19:00:06 test kernel: iptables: IN=eth0 OUT=
  MAC=00:13:72:8a:83:d2:00:1b:25:07:e2:1b:08:00 SRC=10.1.2.7 DST=10.2.5.5 LEN=60
  TOS=0x00 PREC=0x00 TTL=62 ID=1881 DF PROTO=TCP SPT=34342 DPT=23 WINDOW=5840
  RES=0x00 SYN URGP=0
<div>&#x00A0;</div>
Dec 27 19:00:14 test sshd[10520]: Accepted password for root from 10.1.2.7 port
  52609 ssh2
<div>&#x00A0;</div>
Dec 27 19:00:24 test sshd[10526]: Failed password for risto from 10.1.2.7 port
  52622 ssh2
<div>&#x00A0;</div>
Dec 27 19:00:27 test sshd[10526]: Accepted password for risto from 10.1.2.7 port
  52622 ssh2
<div class="Pp"></div>
The iptables event at 19:00:06 starts an event correlation operation for
  10.1.2.7 which has the event correlation window of 120 seconds. Immediately
  after the operation has been started, it creates the context OPER_10.1.2.7.
  The second event at 19:00:14 does not match the rule, since the context
  LOGIN_FAILED_root_10.1.2.7 does not exist. The third event at 19:00:24 matches
  the rule, and the operation which is running for 10.1.2.7 sets up the alias
  name LOGIN_FAILED_risto_10.1.2.7 for the context OPER_10.1.2.7. Finally, the
  fourth event at 19:00:27 matches the rule, since the context
  LOGIN_FAILED_risto_10.1.2.7 exists, and the event is therefore processed by
  the operation (the presence of the context indicates that the operation has
  previously observed a login failure for user risto from 10.1.2.7). At this
  particular moment (19:00:27), all three threshold conditions for the operation
  are fulfilled, and therefore it sends an e-mail warning about 10.1.2.7 to
  root@localhost. After that, the operation silently consumes all further
  matching events for 10.1.2.7 until 19:02:06, and then terminates. Immediately
  before termination, the operation deletes the context OPER_10.1.2.7 which also
  drops its alias name LOGIN_FAILED_risto_10.1.2.7.
<h2 class="Ss" title="Ss" id="SUPPRESS_RULE"><a class="selflink" href="#SUPPRESS_RULE">SUPPRESS
  RULE</a></h2>
The <b>Suppress</b> rule takes no action when an event has matched the rule, and
  keeps matching events from being processed by later rules in the configuration
  file.
<div class="Pp"></div>
The Suppress rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to Suppress (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype</i></dt>
  <dd class="It-tag">pattern type (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap</i> (optional)</dt>
  <dd class="It-tag">variable map.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i> (optional)</dt>
  <dd class="It-tag">string for describing the rule.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that match variables may be used in the <i>context</i> field. Also note
  that this rule does not start an event correlation operation, and the optional
  <i>desc</i> field is merely used for describing the rule.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
type=Suppress
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for \S+ from ([\d.]+) port \d+ ssh2
<div>&#x00A0;</div>
context=SUPPRESS_IP_$1
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (\S+) from ([\d.]+) port \d+ ssh2
<div>&#x00A0;</div>
desc=Three SSH login failures within 1m for user $1 from $2
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost; \
<br/>
 create SUPPRESS_IP_$2 3600
<div>&#x00A0;</div>
window=60
<div>&#x00A0;</div>
thresh=3
<div class="Pp"></div>
The first rule filters out SSH login failure events for an already reported
  source IP address, so that they will not be matched against the second rule
  during 3600 seconds after sending an e-mail warning.
<h2 class="Ss" title="Ss" id="CALENDAR_RULE"><a class="selflink" href="#CALENDAR_RULE">CALENDAR
  RULE</a></h2>
The <b>Calendar</b> rule was designed for executing actions at specific times.
  Unlike all other rules, this rule reacts only to the system clock, ignoring
  other input. The Calendar rule executes the action list given with the
  <i>action</i> field if the current time matches all conditions of the time
  specification given with the <i>time</i> field. The action list is executed
  only once for any matching minute.
<div class="Pp"></div>
The rule employs a time specification which closely resembles the
  <b>crontab</b>(1) style, but there are some subtle differences. The time
  specification consists of five or six conditions separated by whitespace. The
  first condition matches minutes (allowed values are 0-59), the second
  condition matches hours (allowed values are 0-23), the third condition days
  (allowed values are 0-31, with 0 denoting the last day of the month), the
  fourth condition months (allowed values are 1-12), and the fifth condition
  weekdays (allowed values are 0-7, with 0 and 7 denoting Sunday). The sixth
  condition is optional and matches years (allowed values are 0-99 which denote
  the last two digits of the year).
<div class="Pp"></div>
Asterisks (*), ranges of numbers (e.g., 8-11), and lists (e.g., 2,5,7-9) are
  allowed as conditions. Asterisks and ranges may be augmented with step values
  (e.g., 47-55/2 means 47,49,51,53,55).
<div class="Pp"></div>
Note that unlike <b>crontab</b>(1) time specification, the day and weekday
  conditions are *not* joined with logical OR, but rather with logical AND.
  Therefore, 0 1 25-31 10 7 means 1AM on last Sunday in October. On the other
  hand, with <b>crontab</b>(1) the same specification means 1AM in every last
  seven days or every Sunday in October.
<div class="Pp"></div>
Also, unlike some versions of <b>cron</b>(8), SEC is not restricted to take
  action only during the first second of the current minute. For example, if SEC
  is started at the 22th second of a minute, the wildcard condition produces a
  match for this minute. As another example, if the time specification matches
  the current minute but the context expression evaluates FALSE during the first
  half of the minute, the Calendar rule will execute the action list in the
  middle of this minute when the expression value becomes TRUE.
<div class="Pp"></div>
The Calendar rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to Calendar (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>time</i></dt>
  <dd class="It-tag">time specification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i></dt>
  <dd class="It-tag">operation description string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>action</i></dt>
  <dd class="It-tag">action list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that this rule does not start event correlation operation, and the
  <i>desc</i> field is merely used for setting the %s action list variable.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
type=Calendar
<div>&#x00A0;</div>
time=0 2 25-31 3,12 6
<div>&#x00A0;</div>
desc=Check if backup is done on last Saturday of Q1 and Q4
<div>&#x00A0;</div>
action=event WAITING_FOR_BACKUP
<div class="Pp"></div>
type=Calendar
<div>&#x00A0;</div>
time=0 2 24-30 6,9 6
<div>&#x00A0;</div>
desc=Check if backup is done on last Saturday of Q2 and Q3
<div>&#x00A0;</div>
action=event WAITING_FOR_BACKUP
<div class="Pp"></div>
type=PairWithWindow
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=WAITING_FOR_BACKUP
<div>&#x00A0;</div>
desc=Quarterly backup not completed on time!
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
ptype2=SubStr
<div>&#x00A0;</div>
pattern2=BACKUP READY
<div>&#x00A0;</div>
desc2=Quarterly backup successfully completed
<div>&#x00A0;</div>
action2=none
<div>&#x00A0;</div>
window=1800
<div class="Pp"></div>
The first two rules create a synthetic event WAITING_FOR_BACKUP at 2AM on last
  Saturday of March, June, September and December. The third rule matches this
  event and starts an event correlation operation which waits for the BACKUP
  READY event for 1800 seconds. If this event has not arrived by 2:30AM, the
  operation sends an e-mail warning to root@localhost.
<h2 class="Ss" title="Ss" id="JUMP_RULE"><a class="selflink" href="#JUMP_RULE">JUMP
  RULE</a></h2>
The <b>Jump</b> rule submits matching events to specific ruleset(s) for further
  processing. If the event matches the rule, SEC continues the search for
  matching rules in configuration file set(s) given with the <i>cfset</i> field.
  Rules from every file are tried in the order of their appearance in the file.
  Configuration file sets can be created from Options rules with the
  <i>joincfset</i> field, with each set containing at least one configuration
  file. If more that one set name is given with <i>cfset</i>, sets are processed
  from left to right; a matching rule in one set doesn't prevent SEC from
  processing the following sets. If the <i>constset</i> field is set to Yes, set
  names are assumed to be constants and will not be searched for match variables
  at runtime.
<div class="Pp"></div>
The Jump rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to Jump (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>continue</i> (optional)</dt>
  <dd class="It-tag">TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
      from &lt;label&gt;, values are case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ptype</i></dt>
  <dd class="It-tag">pattern type (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>pattern</i></dt>
  <dd class="It-tag">pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>varmap</i> (optional)</dt>
  <dd class="It-tag">variable map.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>context</i> (optional)</dt>
  <dd class="It-tag">context expression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>cfset</i> (optional)</dt>
  <dd class="It-tag">configuration file set names that are separated by
      whitespace.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>constset</i> (optional)</dt>
  <dd class="It-tag">Yes or No (values are case insensitive, default is
    Yes).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>desc</i> (optional)</dt>
  <dd class="It-tag">string for describing the rule.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
Note that match variables may be used in the <i>context</i> field. They may also
  be used in the <i>cfset</i> field, provided that the <i>constset</i> field is
  set to No. Also note that this rule does not start event correlation
  operations, and the optional <i>desc</i> field is merely used for describing
  the rule.
<div class="Pp"></div>
Finally, if the <i>cfset</i> field is not present and the <i>continue</i> field
  is set to GoTo, the Jump rule can be used for skipping rules inside the
  current configuration file; if both <i>cfset</i> and <i>continue</i> are not
  present, Jump is identical to Suppress.
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
type=Jump
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]:
<div>&#x00A0;</div>
cfset=sshd-rules auth-rules
<div class="Pp"></div>
When an sshd syslog message appears in input, rules from configuration files of
  the set <b>sshd-rules</b> are first used for matching the message, and then
  rules from the configuration file set <b>auth-rules</b> are tried.
<h2 class="Ss" title="Ss" id="OPTIONS_RULE"><a class="selflink" href="#OPTIONS_RULE">OPTIONS
  RULE</a></h2>
The <b>Options</b> rule sets processing options for the ruleset in the current
  configuration file. If more than one Options rule is present in the
  configuration file, the last instance overrides all previous ones. Note that
  the Options rule is only processed when SEC (re)starts and reads in the
  configuration file. Since this rule is not applied at runtime, it can never
  match events, react to the system clock, or start event correlation
  operations.
<div class="Pp"></div>
The <i>joincfset</i> field lists the names of one or more configuration file
  sets, and the current configuration file will be added to each set. If a set
  doesn't exist, it will be created and the current configuration file becomes
  its first member. If the <i>procallin</i> field is set to No, the rules from
  the configuration file will be used for matching input from Jump rules only.
<div class="Pp"></div>
The Options rule supports the following fields:
<dl class="Bl-tag">
  <dt class="It-tag"><i>type</i></dt>
  <dd class="It-tag">fixed to Options (value is case insensitive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>joincfset</i> (optional)</dt>
  <dd class="It-tag">configuration file set names that are separated by
      whitespace.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>procallin</i> (optional)</dt>
  <dd class="It-tag">Yes or No (values are case insensitive, default is
    Yes).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rem</i> (optional, may appear more than once)</dt>
  <dd class="It-tag">remarks and comments.</dd>
</dl>
<div class="Pp"></div>
<b>Examples:</b>
<div class="Pp"></div>
The following rule adds the current configuration file to the set
  <b>sshd-rules</b> which is used for matching input from Jump rules only:
<div class="Pp"></div>
type=Options
<div>&#x00A0;</div>
joincfset=sshd-rules
<div>&#x00A0;</div>
procallin=no
<div class="Pp"></div>
The following rule adds the current configuration file to sets <b>linux</b> and
  <b>solaris</b> which are used for matching all input:
<div class="Pp"></div>
type=Options
<div>&#x00A0;</div>
joincfset=linux solaris
<h1 class="Sh" title="Sh" id="EVENT_CORRELATION_OPERATIONS"><a class="selflink" href="#EVENT_CORRELATION_OPERATIONS">EVENT
  CORRELATION OPERATIONS</a></h1>
Event correlation operations are dynamic entities created by rules. After
  creating an operation, the rule also feeds the operation with events that need
  to be correlated. Since each rule can create and feed many operations which
  are running simultaneously, each operation needs a unique ID.
<div class="Pp"></div>
In order to identify event correlation operations, SEC assigns an ID to every
  operation that is composed from the configuration file name, the rule number,
  and the operation description string (defined by the <i>desc</i> field of the
  rule). If there are N rules in the configuration file (excluding Options
  rules), the rule numbers belong to the range 0..N-1, and the number of the
  k-th rule is k-1. Since each Options rule is only processed when SEC reads in
  the configuration file and is not applied at runtime, the Options rules will
  not receive rule numbers. Note that since the configuration file name and rule
  number are part of the operation ID, different rules can have identical
  <i>desc</i> fields without a danger of a clash between operations.
<div class="Pp"></div>
For example, if the configuration file /etc/sec/my.conf contains only one rule
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=user (\S+) login failure on (\S+)
<div>&#x00A0;</div>
desc=Repeated login failures for user $1 on $2
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=60
<div>&#x00A0;</div>
thresh=3
<div class="Pp"></div>
then the number of this rule is 0. When this rule matches an input event
  &quot;user admin login failure on tty1&quot;, the <i>desc</i> field yields an
  operation description string <i>Repeated login failures for user admin on
  tty1</i>, and the event will be directed for further processing to the
  operation with the following ID:
<div class="Pp"></div>
/etc/sec/my.conf | 0 | Repeated login failures for user admin on tty1
<div class="Pp"></div>
If the operation for this ID does not exist, the rule will create it. The newly
  created operation has its event counter initialized to 1, and it expects to
  receive two additional &quot;user admin login failure on tty1&quot; events
  from the rule within the following 60 seconds. If the operation receives such
  an event, its event counter is incremented, and if the counter reaches the
  value of 3, a warning e-mail is sent to root@localhost.
<div class="Pp"></div>
By tuning the <i>desc</i> field of the rule, the scope of individual event
  correlation operations can be changed. For instance, if the following events
  occur within 10 seconds
<div class="Pp"></div>
user admin login failure on tty1
<div>&#x00A0;</div>
user admin login failure on tty5
<div>&#x00A0;</div>
user admin login failure on tty2
<div class="Pp"></div>
the above rule starts three event correlation operations. However, if the
  <i>desc</i> field of the rule is changed to <i>Repeated login failures for
  user $1</i>, these events are processed by the *same* event correlation
  operation (the operation sends a warning e-mail to root@localhost when it
  receives the third event).
<div class="Pp"></div>
Since rules from the same configuration file are matched against input in the
  order they are given, the rule ordering influences the creation and feeding of
  event correlation operations. Suppose the configuration file /etc/sec/my.conf
  contains the following rules:
<div class="Pp"></div>
type=Suppress
<div>&#x00A0;</div>
ptype=TValue
<div>&#x00A0;</div>
pattern=TRUE
<div>&#x00A0;</div>
context=MYCONTEXT
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=user (\S+) login failure on (\S+)
<div>&#x00A0;</div>
desc=Repeated login failures for user $1 on $2
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=60
<div>&#x00A0;</div>
thresh=3
<div class="Pp"></div>
The second rule is able to create and feed event correlation operations as long
  as the context MYCONTEXT does not exist. However, after MYCONTEXT has been
  created, no input event will reach the second rule, and the rule is thus
  unable to create new operations and feed existing ones with events.
<div class="Pp"></div>
Note that Pair and PairWithWindow rules can feed the same event to several
  operations. Suppose the configuration file /etc/sec/my2.conf contains the
  following rules:
<div class="Pp"></div>
type=Suppress
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=test
<div class="Pp"></div>
type=Pair
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=database (\S+) down
<div>&#x00A0;</div>
desc=Database $1 is down
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
ptype2=RegExp
<div>&#x00A0;</div>
pattern2=database $1 up|all databases up
<div>&#x00A0;</div>
desc2=Database %1 is up
<div>&#x00A0;</div>
action2=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=86400
<div class="Pp"></div>
Since the following input events don't contain the substring &quot;test&quot;
<div class="Pp"></div>
database mydb1 down
<div>&#x00A0;</div>
database mydb2 down
<div>&#x00A0;</div>
database mydb3 down
<div class="Pp"></div>
they are matched by the second rule of type Pair which creates three event
  correlation operations. Each operation is running for one particular database
  name, and the operations have the following IDs:
<div class="Pp"></div>
/etc/sec/my2.conf | 1 | Database mydb1 is down
<div>&#x00A0;</div>
/etc/sec/my2.conf | 1 | Database mydb2 is down
<div>&#x00A0;</div>
/etc/sec/my2.conf | 1 | Database mydb3 is down
<div class="Pp"></div>
Each newly created operation sends an e-mail notification to root@localhost
  about the &quot;database down&quot; condition, and will then wait for 86400
  seconds (24 hours) for either of the following messages:
<div>&#x00A0;</div>
(a) &quot;database up&quot; message for the given database,
<div>&#x00A0;</div>
(b) &quot;all databases up&quot; message.
<div class="Pp"></div>
The operation with the ID
<div class="Pp"></div>
/etc/sec/my2.conf | 1 | Database mydb1 is down
<div class="Pp"></div>
uses the following regular expression for matching expected messages:
<div class="Pp"></div>
database mydb1 up|all databases up
<div class="Pp"></div>
The operation with the ID
<div class="Pp"></div>
/etc/sec/my2.conf | 1 | Database mydb2 is down
<div class="Pp"></div>
employs the following regular expression for matching expected messages:
<div class="Pp"></div>
database mydb2 up|all databases up
<div class="Pp"></div>
Finally, the operation with the ID
<div class="Pp"></div>
/etc/sec/my2.conf | 1 | Database mydb3 is down
<div class="Pp"></div>
uses the following regular expression:
<div class="Pp"></div>
database mydb3 up|all databases up
<div class="Pp"></div>
If the following input events appear after 10 minutes
<div class="Pp"></div>
database test up
<div>&#x00A0;</div>
admin logged in
<div>&#x00A0;</div>
database mydb3 up
<div>&#x00A0;</div>
all databases up
<div class="Pp"></div>
the first event &quot;database test up&quot; matches the first rule (Suppress)
  which does not pass the event further to the second rule (Pair). However, all
  following events reach the Pair rule. Since the messages don't match the
  <i>pattern</i> field of the rule, the rule feeds them to all currently
  existing operations it has created, so that the operations can match these
  events with their regular expressions. Because regular expressions of all
  three operations don't match the event &quot;admin logged in&quot;, the
  operations will continue to run. In the case of the &quot;database mydb3
  up&quot; event, the regular expression of the operation
<div class="Pp"></div>
/etc/sec/my2.conf | 1 | Database mydb3 is down
<div class="Pp"></div>
produces a match. Therefore, the operation will send the e-mail notification
  &quot;Database mydb3 is up&quot; to root@localhost and terminate. However, the
  following event &quot;all databases up&quot; matches the regular expressions
  of two remaining operations. As a result, the operations will send e-mail
  notifications &quot;Database mydb1 is up&quot; and &quot;Database mydb2 is
  up&quot; to root@localhost and terminate.
<div class="Pp"></div>
Each operation has an event correlation window which defines its scope in time.
  The size of the window is defined by the <i>window*</i> field, and the
  beginning of the window can be obtained with the <i>getwpos</i> action.
  SingleWithThreshold, SingleWith2Thresholds and EventGroup operations can slide
  its window forward during event processing, while for all operations the
  window can also be moved explicitly with the <i>setwpos</i> action. Also, with
  the <i>reset</i> action event correlation operations can be terminated. Note
  that <i>getwpos</i>, <i>setwpos</i>, and <i>reset</i> actions only work for
  operations started by the rules from the same configuration file.
<div class="Pp"></div>
For example, consider the configuration file /etc/sec/sshd.rules that contains
  the following rules:
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (\S+) from [\d.]+ port \d+ ssh2
<div>&#x00A0;</div>
desc=Three SSH login failures within 1m for user $1
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=60
<div>&#x00A0;</div>
thresh=3
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Accepted .+ for (\S+) from [\d.]+ port \d+ ssh2
<div>&#x00A0;</div>
desc=SSH login successful for user $1
<div>&#x00A0;</div>
action=reset -1 Three SSH login failures within 1m for user $1
<div class="Pp"></div>
Suppose the following events are generated by an SSH daemon, and each event
  timestamp reflects the time SEC observes the event:
<div class="Pp"></div>
Dec 29 15:00:03 test sshd[14129]: Failed password for risto from 10.1.2.7 port
  31312 ssh2
<div>&#x00A0;</div>
Dec 29 15:00:08 test sshd[14129]: Failed password for risto from 10.1.2.7 port
  31312 ssh2
<div>&#x00A0;</div>
Dec 29 15:00:17 test sshd[14129]: Accepted password for risto from 10.1.2.7 port
  31312 ssh2
<div>&#x00A0;</div>
Dec 29 15:00:52 test sshd[14142]: Failed password for risto from 10.1.1.2 port
  17721 ssh2
<div class="Pp"></div>
The first event at 15:00:03 starts an event correlation operation with the ID
<div class="Pp"></div>
/etc/sec/sshd.rules | 0 | Three SSH login failures within 1m for user risto
<div class="Pp"></div>
However, when the third event occurs at 15:00:17, the second rule matches it and
  terminates the operation with the action
<div class="Pp"></div>
reset -1 Three SSH login failures within 1m for user risto
<div class="Pp"></div>
The -1 parameter of <i>reset</i> restricts the action to operations started by
  the previous rule (i.e., the first rule that has a number 0), while the
  <i>Three SSH login failures within 1m for user risto</i> parameter refers to
  the operation description string. Together with the current configuration file
  name (/etc/sec/sshd.rules), the parameters yield the operation ID
<div class="Pp"></div>
/etc/sec/sshd.rules | 0 | Three SSH login failures within 1m for user risto
<div class="Pp"></div>
(If the operation with the given ID would not exist, <i>reset</i> would perform
  no operation.)
<div class="Pp"></div>
As a consequence, the fourth event at 15:00:52 starts another operation with the
  same ID as the terminated operation had. Without the second rule, the
  operation that was started at 15:00:03 would not be terminated, and the
  appearance of the fourth event would trigger a warning e-mail from that
  operation.
<h1 class="Sh" title="Sh" id="INPUT_PROCESSING_AND_TIMING"><a class="selflink" href="#INPUT_PROCESSING_AND_TIMING">INPUT
  PROCESSING AND TIMING</a></h1>
SEC processes input data iteratively by reading one line at each iteration,
  writing this line into a relevant input buffer, and matching the content of
  the updated buffer with rules from configuration files. If during the matching
  process an action list is executed which creates new input events (e.g.,
  through the <i>event</i> action), they are *not* written to buffer(s)
  immediately, but rather consumed at following iterations.
<div class="Pp"></div>
Note that when both synthetic events and regular input are available for
  processing, synthetic events are always consumed first. When all synthetic
  events have been consumed iteratively, SEC will start processing new data from
  input files.
<div class="Pp"></div>
With the <b>--jointbuf</b> option, SEC employs a joint input buffer for all
  input sources which holds N last input lines (the value of N can be set with
  the <b>--bufsize</b> option). Updating the input buffer means that the new
  line becomes the first element of the buffer, while the last element (the
  oldest line) is removed from the end of the buffer. With the
  <b>--nojointbuf</b> option, SEC maintains a buffer of N lines for each input
  file, and if the input line comes from file F, the buffer of F is updated as
  described previously. There is also a separate buffer for synthetic and
  internal events.
<div class="Pp"></div>
Suppose SEC is started with the following command line
<div class="Pp"></div>
/usr/bin/sec --conf=/etc/sec/test-multiline.conf --jointbuf \
<br/>
 --input=/var/log/prog1.log --input=/var/log/prog2.log
<div class="Pp"></div>
and the configuration file /etc/sec/test-multiline.conf has the following
  content:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
rem=this rule matches two consecutive lines where the first \
<br/>
 line contains &quot;test1&quot; and the second line &quot;test2&quot;, and \
<br/>
 writes the matching lines to standard output
<div>&#x00A0;</div>
ptype=RegExp2
<div>&#x00A0;</div>
pattern=test1.*\n.*test2
<div>&#x00A0;</div>
desc=two consecutive test lines
<div>&#x00A0;</div>
action=write - $0
<div class="Pp"></div>
When the following lines appear in input files /var/log/prog1.log and
  /var/log/prog2.log
<div class="Pp"></div>
Dec 31 12:33:12 test prog1: test1 (file /var/log/prog1.log)
<div>&#x00A0;</div>
Dec 31 12:34:09 test prog2: test1 (file /var/log/prog2.log)
<div>&#x00A0;</div>
Dec 31 12:39:35 test prog1: test2 (file /var/log/prog1.log)
<div>&#x00A0;</div>
Dec 31 12:41:53 test prog2: test2 (file /var/log/prog2.log)
<div class="Pp"></div>
they are stored in a common input buffer. Therefore, rule fires after the third
  event has appeared, and writes the following lines to standard output:
<div class="Pp"></div>
Dec 31 12:34:09 test prog2: test1 (file /var/log/prog2.log)
<div>&#x00A0;</div>
Dec 31 12:39:35 test prog1: test2 (file /var/log/prog1.log)
<div class="Pp"></div>
However, if SEC is started with the <b>--nojointbuf</b> option, separate input
  buffers are set up for /var/log/prog1.log and /var/log/prog2.log. Therefore,
  the rule fires after the third event has occurred, and writes the following
  lines to standard output:
<div class="Pp"></div>
Dec 31 12:33:12 test prog1: test1 (file /var/log/prog1.log)
<div>&#x00A0;</div>
Dec 31 12:39:35 test prog1: test2 (file /var/log/prog1.log)
<div class="Pp"></div>
The rule also fires after the fourth event has occurred, producing the following
  output:
<div class="Pp"></div>
Dec 31 12:34:09 test prog2: test1 (file /var/log/prog2.log)
<div>&#x00A0;</div>
Dec 31 12:41:53 test prog2: test2 (file /var/log/prog2.log)
<div class="Pp"></div>
The content of input buffers can be modified with the <i>rewrite</i> action, and
  modifications become visible immediately during ongoing event processing
  iteration. Suppose SEC is started with the following command line
<div class="Pp"></div>
/usr/bin/sec --conf=/etc/sec/test-rewrite.conf \
<br/>
 --input=- --nojointbuf
<div class="Pp"></div>
and the configuration file /etc/sec/test-rewrite.conf has the following content:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
rem=this rule matches two consecutive lines where the first \
<br/>
 line contains &quot;test1&quot; and the second line &quot;test2&quot;, and \
<br/>
 joins these lines in the input buffer
<div>&#x00A0;</div>
ptype=RegExp2
<div>&#x00A0;</div>
pattern=^(.*test1.*)\n(.*test2.*)$
<div>&#x00A0;</div>
continue=TakeNext
<div>&#x00A0;</div>
desc=join two test lines
<div>&#x00A0;</div>
action=rewrite 2 Joined $1 and $2
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
rem=this rule matches a line which begins with &quot;Joined&quot;, \
<br/>
 and writes this line to standard output
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=^Joined
<div>&#x00A0;</div>
desc=output joined lines
<div>&#x00A0;</div>
action=write - $0
<div class="Pp"></div>
When the following two lines appear in standard input
<div class="Pp"></div>
This is a test1
<div>&#x00A0;</div>
This is a test2
<div class="Pp"></div>
they are matched by the first rule which uses the <i>rewrite</i> action for
  replacing those two lines in the input buffer with a new content. The last
  line in the input buffer (&quot;This is a test2&quot;) is replaced with
  &quot;Joined This is a test1 and This is a test2&quot;, while the previous
  line in the input buffer (&quot;This is a test1&quot;) is replaced with an
  empty string. Since the rule contains <i>continue=TakeNext</i> statement, the
  matching process will continue from the following rule. This rule matches the
  last line in the input buffer if it begins with &quot;Joined&quot;, and writes
  the line to standard output, producing
<div class="Pp"></div>
Joined This is a test1 and This is a test2
<div class="Pp"></div>
After each event processing iteration, the pattern match cache is cleared. In
  other words, if a match is cached with the rule <i>varmap*</i> field, it is
  available during ongoing iteration only. Note that results from a successful
  pattern matching are also cached when the subsequent context expression
  evaluation yields FALSE. This allows for reusing results from partial rule
  matches. For example, the following rule creates the cache entry
  &quot;ssh_failed_login&quot; for any SSH failed login event, even if the
  context ALERTING_ON does not exist:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[\d+\]: Failed .+ for (\S+) from ([\d.]+) port \d+ ssh2
<div>&#x00A0;</div>
varmap=ssh_failed_login; user=1; ip=2
<div>&#x00A0;</div>
context=ALERTING_ON
<div>&#x00A0;</div>
desc=SSH login failure for user $1 from $2
<div>&#x00A0;</div>
action=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost
<div class="Pp"></div>
However, provided the context expression does not contain match variables,
  enclosing the expression in square brackets (e.g., [ALERTING_ON]) forces its
  evaluation before the pattern matching, and will thus prevent the matching and
  the creation of the cache entry if the evaluation yields FALSE.
<div class="Pp"></div>
Rules from the same configuration file are matched against the buffer content in
  the order they are given in that file. When multiple configuration files have
  been specified, rule sequences from all files are matched against the buffer
  content (unless specified otherwise with Options rules). The matching order is
  determined by the order of configuration files in SEC command line. For
  example, if the Perl <b>glob</b>() function returns filenames in ascending
  ASCII order, and configuration files /home/risto/A.conf, /home/risto/B.conf2,
  and /home/risto/C.conf are specified with <b>--conf=/home/risto/*.conf
  --conf=/home/risto/*.conf2</b> in SEC command line, then SEC first matches the
  input against the rule sequence from A.conf, then from C.conf, and finally
  from B.conf2. Also, note that even if A.conf contains a Suppress rule for a
  particular event, the event is still processed by rulesets in C.conf and
  B.conf2. However, note that <b>glob</b>() might return file names in different
  order if locale settings change. If you want to enforce a fixed order for
  configuration file application in a portable way, it is recommended to create
  a unique set for each file with the Options rule, and employ the Jump rule for
  defining the processing order for sets, e.g.:
<div class="Pp"></div>
# This rule appears in A.conf
<div>&#x00A0;</div>
type=Options
<div>&#x00A0;</div>
joincfset=FileA
<div>&#x00A0;</div>
procallin=no
<div class="Pp"></div>
# This rule appears in B.conf2
<div>&#x00A0;</div>
type=Options
<div>&#x00A0;</div>
joincfset=FileB
<div>&#x00A0;</div>
procallin=no
<div class="Pp"></div>
# This rule appears in C.conf
<div>&#x00A0;</div>
type=Options
<div>&#x00A0;</div>
joincfset=FileC
<div>&#x00A0;</div>
procallin=no
<div class="Pp"></div>
# This rule appears in main.conf
<div>&#x00A0;</div>
type=Jump
<div>&#x00A0;</div>
ptype=TValue
<div>&#x00A0;</div>
pattern=TRUE
<div>&#x00A0;</div>
cfset=FileA FileC FileB
<div class="Pp"></div>
After the relevant input buffer has been updated and its content has been
  matched by the rules, SEC handles caught signals and checks the status of
  child processes. When the timeout specified with the <b>--cleantime</b> option
  has expired, SEC also checks the status of contexts and event correlation
  operations. Therefore, relatively small values should be specified with the
  <b>--cleantime</b> option, in order to retain the accuracy of the event
  correlation process. If the <b>--cleantime</b> option is set to 0, SEC checks
  event correlation operations and contexts after processing every input line,
  but this consumes more CPU time. If the <b>--poll-timeout</b> option value
  exceeds the value given with <b>--cleantime</b>, the <b>--poll-timeout</b>
  option value takes precedence (i.e., sleeps after unsuccessful polls will not
  be shortened).
<div class="Pp"></div>
Finally, note that apart from the sleeps after unsuccessful polls, SEC measures
  all time intervals and occurrence times in seconds, and always uses the
  <b>time</b>(2) system call for obtaining the current time. Also, for input
  event occurrence time SEC always uses the time it observed the event, *not*
  the timestamp extracted from the event.
<h1 class="Sh" title="Sh" id="INTERNAL_EVENTS_AND_CONTEXTS"><a class="selflink" href="#INTERNAL_EVENTS_AND_CONTEXTS">INTERNAL
  EVENTS AND CONTEXTS</a></h1>
In the action list of a context, the context can also be referred with the
  internal context name _THIS. The name _THIS is created and deleted dynamically
  by SEC and it points to the context only during its action list execution.
  This feature is useful when the context has had several names during its
  lifetime (created with the <i>alias</i> action), and it is hard to determine
  which names exist when the context expires. For example, if the context is
  created with <i>create A 60 (report A /bin/mail root)</i> which is immediately
  followed by <i>alias A B</i> and <i>unalias A</i>, the <i>report</i> action
  will fail since the name A no longer refers to the context. However, replacing
  the first action with <i>create A 60 (report _THIS /bin/mail root)</i> will
  produce the correct result.
<div class="Pp"></div>
If the <b>--intevents</b> command line option is given, SEC will generate
  internal events when it is started up, when it receives certain signals, and
  when it terminates normally. Inside SEC, internal event is treated as if it
  was a line that was read from a SEC input file. Specific rules can be written
  to match internal events, in order to take some action (e.g., start an
  external event correlation module with <i>spawn</i> when SEC starts up). The
  following internal events are supported:
<div class="Pp"></div>
SEC_STARTUP - generated when SEC is started (this event will always be the first
  event that SEC sees)
<div class="Pp"></div>
SEC_PRE_RESTART - generated before processing of the <b>SIGHUP</b> signal (this
  event will be the last event that SEC sees before clearing all internal data
  structures and reloading its configuration)
<div class="Pp"></div>
SEC_RESTART - generated after processing of the <b>SIGHUP</b> signal (this event
  will be the first event that SEC sees after clearing all internal data
  structures and reloading its configuration)
<div class="Pp"></div>
SEC_PRE_SOFTRESTART - generated before processing of the <b>SIGABRT</b> signal
  (this event will be the last event that SEC sees before reloading its
  configuration)
<div class="Pp"></div>
SEC_SOFTRESTART - generated after processing of the <b>SIGABRT</b> signal (this
  event will be the first event that SEC sees after reloading its configuration)
<div class="Pp"></div>
SEC_PRE_LOGROTATE - generated before processing of the <b>SIGUSR2</b> signal
  (this event will be the last event that SEC sees before reopening its log file
  and closing its outputs)
<div class="Pp"></div>
SEC_LOGROTATE - generated after processing of the <b>SIGUSR2</b> signal (this
  event will be the first event that SEC sees after reopening its log file and
  closing its outputs)
<div class="Pp"></div>
SEC_SHUTDOWN - generated when SEC receives the <b>SIGTERM</b> signal, or when
  SEC reaches all EOFs of input files after being started with the
  <b>--notail</b> option. With the <b>--childterm</b> option, SEC sleeps for 3
  seconds after generating SEC_SHUTDOWN event, and then sends SIGTERM to its
  child processes (if a child process was triggered by SEC_SHUTDOWN, this delay
  leaves the process enough time for setting a signal handler for SIGTERM).
<div class="Pp"></div>
Before generating an internal event, SEC sets up a context named
  SEC_INTERNAL_EVENT, in order to disambiguate internal events from regular
  input. The SEC_INTERNAL_EVENT context is deleted immediately after the
  internal event has been matched against all rules.
<div class="Pp"></div>
If the <b>--intcontexts</b> command line option is given, or there is an
  <b>--input</b> option with a context specified, SEC creates an internal
  context each time it reads a line from an input file or a synthetic event. The
  internal context is deleted immediately after the line has been matched
  against all rules. For all input files that have the context name explicitly
  set with <b>--input=&lt;file_pattern&gt;=&lt;context&gt;</b>, the name of the
  internal context is &lt;context&gt;. If the line was read from the input file
  &lt;filename&gt; for which there is no context name set, the name of the
  internal context is _FILE_EVENT_&lt;filename&gt;. For synthetic events, the
  name of the internal context defaults to _INTERNAL_EVENT, but <i>cspawn</i>
  and <i>cevent</i> actions can be used for generating synthetic events with
  custom internal context names. This allows for writing rules that match data
  from one particular input source only. For example, the rule
<div class="Pp"></div>
type=Suppress
<div>&#x00A0;</div>
ptype=TValue
<div>&#x00A0;</div>
pattern=TRUE
<div>&#x00A0;</div>
context=[!_FILE_EVENT_/dev/logpipe]
<div class="Pp"></div>
passes only the lines that were read from /dev/logpipe, and also synthetic
  events that were generated with the _FILE_EVENT_/dev/logpipe internal context
  (e.g., with the action <i>cevent _FILE_EVENT_/dev/logpipe 0 This is a test
  event</i>). As another example, if SEC has been started with the command line
<div class="Pp"></div>
/usr/bin/sec --intevents --intcontexts --conf=/etc/sec/my.conf \
<br/>
 --input=/var/log/messages=MESSAGES \
<br/>
 --input=/var/log/secure=SECURE \
<br/>
 --input=/var/log/cron=CRON
<div class="Pp"></div>
and the rule file /etc/sec/my.conf contains the following rules
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=^(?:SEC_STARTUP|SEC_RESTART)$
<div>&#x00A0;</div>
context=[SEC_INTERNAL_EVENT]
<div>&#x00A0;</div>
desc=listen on 10514/tcp for incoming events
<div>&#x00A0;</div>
action=cspawn MESSAGES /usr/bin/nc -l -k 10514
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=.
<div>&#x00A0;</div>
context=[MESSAGES]
<div>&#x00A0;</div>
desc=echo everything from 10514/tcp and /var/log/messages
<div>&#x00A0;</div>
action=write - $0
<div class="Pp"></div>
then SEC will receive input lines from the log files /var/log/messages,
  /var/log/secure, and /var/log/cron, and will also run /usr/bin/nc for
  receiving input lines from the port 10514/tcp. All input lines from
  /var/log/messages and 10514/tcp are matched by the second rule and written to
  standard output.
<h1 class="Sh" title="Sh" id="INTERPROCESS_COMMUNICATION"><a class="selflink" href="#INTERPROCESS_COMMUNICATION">INTERPROCESS
  COMMUNICATION</a></h1>
The SingleWithScript rule and <i>shellcmd</i>, <i>spawn</i>, <i>cspawn</i>,
  <i>pipe</i>, and <i>report</i> actions fork a child process for executing an
  external program. If the program command line contains shell metacharacters,
  the command line is first parsed by the shell which then starts the program.
  SEC communicates with its child processes through pipes (created with the
  <b>pipe</b>(2) system call). When the child process is at the read end of the
  pipe, data have to be written to the pipe in blocking mode which ensures
  reliable data transmission. In order to avoid being blocked, SEC forks another
  child process for writing data to the pipe reliably.
<div class="Pp"></div>
After forking an external program, SEC continues immediately, and checks the
  program status periodically until the program exits. The running time of a
  child process is not limited in any way. With the <b>--childterm</b> option,
  SEC sends the <b>SIGTERM</b> signal to all child processes when it terminates.
  If some special exit procedures need to be accomplished in the child process
  (or the child wishes to ignore <b>SIGTERM</b>), then the child must install a
  handler for the <b>SIGTERM</b> signal. Note that if the program command line
  contains shell metacharacters, the parsing shell will run as a child process
  of SEC and the parent process of the program. Therefore, the <b>SIGTERM</b>
  signal will be sent to the shell, *not* the program. In order to avoid this,
  the shell's builtin <i>exec</i> command can be used (see <b>sh</b>(1) for more
  information) which replaces the shell with the program without forking a new
  process, e.g.,
<div class="Pp"></div>
action=spawn exec /usr/local/bin/myscript.pl 2&gt;/var/log/myscript.log
<div class="Pp"></div>
Note that if an action list includes two actions which fork external programs,
  the execution order these programs is not determined by the order of actions
  in the list, since both programs are running asynchronously. In order to
  address this issue, the execution order must be specified explicitly (e.g.,
  instead of writing <i>action=shellcmd cmd1; shellcmd cmd2</i>, use the shell
  &amp;&amp; operator and write <i>action=shellcmd cmd1 &amp;&amp; cmd2</i>).
<div class="Pp"></div>
Sometimes it is desireable to start an external program and provide it with data
  from several rules. In order to create such setup, named pipes can be
  harnessed. For example, if /var/log/pipe is a named pipe, then
<div class="Pp"></div>
action=shellcmd /usr/bin/logger -f /var/log/pipe -p user.notice
<div class="Pp"></div>
starts the /usr/bin/logger utility which sends all lines read from /var/log/pipe
  to the local syslog daemon with the &quot;user&quot; facility and
  &quot;notice&quot; level. In order to feed events to /usr/bin/logger, the
  <i>write</i> action can be used (e.g., <i>write /var/log/pipe This is my
  event</i>). Although SEC keeps the named pipe open across different
  <i>write</i> actions, the pipe will be closed on the reception of SIGHUP,
  SIGABRT and SIGUSR2 signals. Since many UNIX tools terminate on receiving EOF
  from standard input, they need restarting after such signals have arrived. For
  this purpose, the <b>--intevents</b> option and SEC internal events can be
  used. For example, the following rule starts the /usr/bin/logger utility at
  SEC startup, and also restarts it after the reception of relevant signals:
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=^(?:SEC_STARTUP|SEC_RESTART|SEC_SOFTRESTART|SEC_LOGROTATE)$
<div>&#x00A0;</div>
context=SEC_INTERNAL_EVENT
<div>&#x00A0;</div>
desc=start the logger tool
<div>&#x00A0;</div>
action=free %emptystring; owritecl /var/log/pipe %emptystring; \
<br/>
 shellcmd /usr/bin/logger -f /var/log/pipe -p user.notice
<div class="Pp"></div>
Note that if /var/log/pipe is never opened for writing by a <i>write</i> action,
  /usr/bin/logger will never see EOF and will thus not terminate. The
  <i>owritecl</i> action opens and closes /var/log/pipe without writing any
  bytes, in order to ensure the presence of EOF in such cases. This allows any
  previous /usr/bin/logger process to terminate before the new process is
  started.
<h1 class="Sh" title="Sh" id="PERL_INTEGRATION"><a class="selflink" href="#PERL_INTEGRATION">PERL
  INTEGRATION</a></h1>
SEC supports patterns, context expressions, and actions which involve calls to
  the Perl <b>eval</b>() function or the execution of precompiled Perl code. The
  use of Perl code in SEC patterns and context expressions allows for creating
  proper match conditions for scenarios which can't be handled by a simple
  regular expression match. For example, consider the following iptables syslog
  events:
<div class="Pp"></div>
May 27 10:00:15 box1 kernel: iptables: IN=eth0 OUT=
  MAC=08:00:27:be:9e:2f:00:10:db:ff:20:03:08:00 SRC=10.6.4.14 DST=10.1.8.2
  LEN=84 TOS=0x00 PREC=0x00 TTL=251 ID=61426 PROTO=ICMP TYPE=8 CODE=0 ID=11670
  SEQ=2
<div>&#x00A0;</div>
May 27 10:02:22 box1 kernel: iptables: IN=eth0 OUT=
  MAC=08:00:27:be:9e:2f:00:10:db:ff:20:03:08:00 SRC=10.6.4.14 DST=10.1.8.2
  LEN=52 TOS=0x00 PREC=0x00 TTL=60 ID=61441 DF PROTO=TCP SPT=53125 DPT=23
  WINDOW=49640 RES=0x00 SYN URGP=0
<div class="Pp"></div>
Depending on the protocol and the nature of the traffic, events can have a wide
  variety of fields, and parsing out all event data with one regular expression
  is infeasible. For addressing this issue, a PerlFunc pattern can be used which
  creates match variables from all fields of the matching event, stores them in
  one Perl hash, and returns a reference to this hash. Outside the PerlFunc
  pattern, match variables are initialized from the key-value pairs in the
  returned hash. Suppose the following Jump rule with a PerlFunc pattern is
  defined in the main.rules rule file:
<div class="Pp"></div>
type=Jump
<div>&#x00A0;</div>
ptype=PerlFunc
<div>&#x00A0;</div>
pattern=sub { my(%var); my($line) = $_[0]; \
<br/>
 if ($line !~ /kernel: iptables:/g) { return 0; } \
<br/>
 while ($line =~ /\G\s*([A-Z]+)(?:=(\S*))?/g) { \
<br/>
 $var{$1} = defined($2)?$2:1; \
<br/>
 } return \%var; }
<div>&#x00A0;</div>
varmap=IPTABLES
<div>&#x00A0;</div>
desc=parse iptables event
<div>&#x00A0;</div>
cfset=iptables
<div class="Pp"></div>
For example, if the iptables event contains the fields SRC=10.6.4.14,
  DST=10.1.8.2 and SYN, the above PerlFunc pattern sets up match variable
  $+{SRC} which holds 10.6.4.14, match variable $+{DST} which holds 10.1.8.2,
  and match variable $+{SYN} which holds 1. The Jump rule caches all created
  match variables under the name IPTABLES, and submits the matching event to
  <b>iptables</b> ruleset for further processing. Suppose the <b>iptables</b>
  ruleset is defined in the iptables.rules rule file:
<div class="Pp"></div>
type=Options
<div>&#x00A0;</div>
procallin=no
<div>&#x00A0;</div>
joincfset=iptables
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=Cached
<div>&#x00A0;</div>
pattern=IPTABLES
<div>&#x00A0;</div>
context=IPTABLES :&gt; ( sub { return $_[0]-&gt;{&quot;PROTO&quot;} eq
  &quot;ICMP&quot;; } )
<div>&#x00A0;</div>
desc=ICMP flood type $+{TYPE} code $+{CODE} from host $+{SRC}
<div>&#x00A0;</div>
action=logonly
<div>&#x00A0;</div>
window=10
<div>&#x00A0;</div>
thresh=100
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=Cached
<div>&#x00A0;</div>
pattern=IPTABLES
<div>&#x00A0;</div>
context=IPTABLES :&gt; ( sub { return exists($_[0]-&gt;{&quot;SYN&quot;})
  &amp;&amp; \
<br/>
 exists($_[0]-&gt;{&quot;FIN&quot;}) ; } )
<div>&#x00A0;</div>
desc=SYN+FIN flood from host $+{SRC}
<div>&#x00A0;</div>
action=logonly
<div>&#x00A0;</div>
window=10
<div>&#x00A0;</div>
thresh=100
<div class="Pp"></div>
The two SingleWithThreshold rules employ Cached patterns for matching iptables
  events by looking up the IPTABLES entry in the pattern match cache (created by
  the above Jump rule for each iptables event). In order to narrow down the
  match to specific iptables events, the rules employ precompiled Perl functions
  in context expressions. The :&gt; operator is used for speeding up the
  matching, providing the function with a single parameter which refers to the
  hash of variable name-value pairs for the IPTABLES cache entry.
<div class="Pp"></div>
The first SingleWithThreshold rule logs a warning message if within 10 seconds
  100 iptables events have been observed for ICMP packets with the same type,
  code, and source IP address. The second SingleWithThreshold rule logs a
  warning message if within 10 seconds 100 iptables events have been observed
  for TCP packets coming from the same host, and having both SYN and FIN flag
  set in each packet.
<div class="Pp"></div>
Apart from using action list variables for data sharing between rules, Perl
  variables created in Perl code can be employed for the same purpose. For
  example, when SEC has executed the following action
<div class="Pp"></div>
action=eval %a ($b = 1)
<div class="Pp"></div>
the variable $b and its value become visible in the following context expression
<div class="Pp"></div>
context= =(++$b &gt; 10)
<div class="Pp"></div>
(with that expression one can implement event counting implicitly). In order to
  avoid possible clashes with variables inside the SEC code itself, user-defined
  Perl code is executed in the main::SEC namespace (i.e., inside the special
  package main::SEC). By using the main:: prefix, SEC data structures can be
  accessed and modified. For example, the following rules restore and save
  contexts on SEC startup and shutdown (SEC keeps all contexts in
  %main::context_list hash):
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=SEC_STARTUP
<div>&#x00A0;</div>
context=SEC_INTERNAL_EVENT
<div>&#x00A0;</div>
continue=TakeNext
<div>&#x00A0;</div>
desc=Load the Storable module and terminate if it is not found
<div>&#x00A0;</div>
action=eval %ret (require Storable); \
<br/>
 if %ret ( logonly Storabe loaded ) else ( eval %o exit(1) )
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=SEC_STARTUP
<div>&#x00A0;</div>
context=SEC_INTERNAL_EVENT
<div>&#x00A0;</div>
desc=Restore all SEC contexts from /var/lib/sec/SEC_CONTEXTS on startup
<div>&#x00A0;</div>
action=lcall %ret -&gt; ( sub { \
<br/>
 my $ptr = $main::context_list{&quot;SEC_INTERNAL_EVENT&quot;}; \
<br/>
 %main::context_list = \
<br/>
 %{Storable::retrieve(&quot;/var/lib/sec/SEC_CONTEXTS&quot;)}; \
<br/>
 $main::context_list{&quot;SEC_INTERNAL_EVENT&quot;} = $ptr; } )
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=SEC_SHUTDOWN
<div>&#x00A0;</div>
context=SEC_INTERNAL_EVENT
<div>&#x00A0;</div>
desc=Save all SEC contexts into /var/lib/sec/SEC_CONTEXTS on shutdown
<div>&#x00A0;</div>
action=lcall %ret -&gt; ( sub { \
<br/>
 Storable::store(\%main::context_list, \
<br/>
 &quot;/var/lib/sec/SEC_CONTEXTS&quot;); } )
<div class="Pp"></div>
However, note that modifying data structures within SEC code is recommended only
  for advanced users who have carefully studied relevant parts of the code.
<div class="Pp"></div>
Finally, sometimes larger chunks of Perl code have to be used for event
  processing and correlation. However, writing many lines of code directly into
  a rule is cumbersome and may decrease its readability. In such cases it is
  recommended to separate the code into a custom Perl module which is loaded at
  SEC startup, and use the code through the module interface (see
  <b>perlmod</b>(1) for further details):
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=SubStr
<div>&#x00A0;</div>
pattern=SEC_STARTUP
<div>&#x00A0;</div>
context=SEC_INTERNAL_EVENT
<div>&#x00A0;</div>
desc=Load the SecStuff module
<div>&#x00A0;</div>
action=eval %ret (require '/usr/local/sec/SecStuff.pm'); \
<br/>
 if %ret ( none ) else ( eval %o exit(1) )
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=PerlFunc
<div>&#x00A0;</div>
pattern=sub { return SecStuff::my_match($_[0]); }
<div>&#x00A0;</div>
desc=event '$0' was matched by my_match()
<div>&#x00A0;</div>
action=write - %s
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<h2 class="Ss" title="Ss" id="Example_1_-_a_ruleset_for_Cisco_events"><a class="selflink" href="#Example_1_-_a_ruleset_for_Cisco_events">Example
  1 - a ruleset for Cisco events</a></h2>
This section presents an example rulebase for managing Cisco devices. It is
  assumed that the managed devices have syslog logging enabled, and that all
  syslog messages are sent to a central host and written to log file(s) that are
  monitored by SEC.
<div class="Pp"></div>
# Set up contexts NIGHT and WEEKEND for nights
<div>&#x00A0;</div>
# and weekends. The context NIGHT has a lifetime
<div>&#x00A0;</div>
# of 8 hours and the context WEEKEND 2 days
<div class="Pp"></div>
type=Calendar
<div>&#x00A0;</div>
time=0 23 * * *
<div>&#x00A0;</div>
desc=NIGHT
<div>&#x00A0;</div>
action=create %s 28800
<div class="Pp"></div>
type=Calendar
<div>&#x00A0;</div>
time=0 0 * * 6
<div>&#x00A0;</div>
desc=WEEKEND
<div>&#x00A0;</div>
action=create %s 172800
<div class="Pp"></div>
# If a router does not come up within 5 minutes
<div>&#x00A0;</div>
# after it was rebooted, generate event
<div>&#x00A0;</div>
# &quot;&lt;router&gt; REBOOT FAILURE&quot;. The next rule matches
<div>&#x00A0;</div>
# this event, checks the router with ping and sends
<div>&#x00A0;</div>
# a notification if there is no response.
<div class="Pp"></div>
type=PairWithWindow
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=\s([\w.-]+) \d+: %SYS-5-RELOAD
<div>&#x00A0;</div>
desc=$1 REBOOT FAILURE
<div>&#x00A0;</div>
action=event %s
<div>&#x00A0;</div>
ptype2=RegExp
<div>&#x00A0;</div>
pattern2=\s$1 \d+: %SYS-5-RESTART
<div>&#x00A0;</div>
desc2=%1 successful reboot
<div>&#x00A0;</div>
action2=logonly
<div>&#x00A0;</div>
window=300
<div class="Pp"></div>
type=SingleWithScript
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=^([\w.-]+) REBOOT FAILURE
<div>&#x00A0;</div>
script=/bin/ping -c 3 -q $1
<div>&#x00A0;</div>
desc=$1 did not come up after reboot
<div>&#x00A0;</div>
action=logonly $1 is pingable after reboot
<div>&#x00A0;</div>
action2=pipe '%t: %s' /bin/mail root@localhost
<div class="Pp"></div>
# Send a notification if CPU load of a router is too
<div>&#x00A0;</div>
# high (two CPUHOG messages are received within 5
<div>&#x00A0;</div>
# minutes); send another notification if the load is
<div>&#x00A0;</div>
# normal again (no CPUHOG messages within last 15
<div>&#x00A0;</div>
# minutes). Rule is not active at night or weekend.
<div class="Pp"></div>
type=SingleWith2Thresholds
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=\s([\w.-]+) \d+: %SYS-3-CPUHOG
<div>&#x00A0;</div>
context=!(NIGHT || WEEKEND)
<div>&#x00A0;</div>
desc=$1 CPU overload
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=300
<div>&#x00A0;</div>
thresh=2
<div>&#x00A0;</div>
desc2=$1 CPU load normal
<div>&#x00A0;</div>
action2=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window2=900
<div>&#x00A0;</div>
thresh2=0
<div class="Pp"></div>
# If a router interface is in down state for less
<div>&#x00A0;</div>
# than 15 seconds, generate event
<div>&#x00A0;</div>
# &quot;&lt;router&gt; INTERFACE &lt;interface&gt; SHORT OUTAGE&quot;;
<div>&#x00A0;</div>
# otherwise generate event
<div>&#x00A0;</div>
# &quot;&lt;router&gt; INTERFACE &lt;interface&gt; DOWN&quot;.
<div class="Pp"></div>
type=PairWithWindow
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=\s([\w.-]+) \d+: %LINK-3-UPDOWN: Interface ([\w.-]+), changed state to
  down
<div>&#x00A0;</div>
desc=$1 INTERFACE $2 DOWN
<div>&#x00A0;</div>
action=event %s
<div>&#x00A0;</div>
ptype2=RegExp
<div>&#x00A0;</div>
pattern2=\s$1 \d+: %LINK-3-UPDOWN: Interface $2, changed state to up
<div>&#x00A0;</div>
desc2=%1 INTERFACE %2 SHORT OUTAGE
<div>&#x00A0;</div>
action2=event %s
<div>&#x00A0;</div>
window=15
<div class="Pp"></div>
# If &quot;&lt;router&gt; INTERFACE &lt;interface&gt; DOWN&quot; event is
<div>&#x00A0;</div>
# received, send a notification and wait for
<div>&#x00A0;</div>
# &quot;interface up&quot; event from the same router interface
<div>&#x00A0;</div>
# for the next 24 hours
<div class="Pp"></div>
type=Pair
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=^([\w.-]+) INTERFACE ([\w.-]+) DOWN
<div>&#x00A0;</div>
desc=$1 interface $2 is down
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
ptype2=RegExp
<div>&#x00A0;</div>
pattern2=\s$1 \d+: %LINK-3-UPDOWN: Interface $2, changed state to up
<div>&#x00A0;</div>
desc2=%1 interface %2 is up
<div>&#x00A0;</div>
action2=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=86400
<div class="Pp"></div>
# If ten &quot;short outage&quot; events have been observed
<div>&#x00A0;</div>
# in the window of 6 hours, send a notification
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=^([\w.-]+) INTERFACE ([\w.-]+) SHORT OUTAGE
<div>&#x00A0;</div>
desc=Interface $2 at node $1 is unstable
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail root@localhost
<div>&#x00A0;</div>
window=21600
<div>&#x00A0;</div>
thresh=10
<h2 class="Ss" title="Ss" id="Example_2_-_hierarchically_organized_rulesets_for_iptables_and_sshd_events"><a class="selflink" href="#Example_2_-_hierarchically_organized_rulesets_for_iptables_and_sshd_events">Example
  2 - hierarchically organized rulesets for iptables and sshd events</a></h2>
This section presents an example of hierarchically organized rules for
  processing Linux iptables events from /var/log/messages and SSH login events
  from /var/log/secure. It is assumed that all rule files reside in the /etc/sec
  directory and that the rule hierarchy has two levels. The file
  /etc/sec/main.rules contains first-level Jump rules for matching and parsing
  events from input files and submitting them to proper rulesets for further
  processing. All other rule files in the /etc/sec directory contain
  second-level rules which receive their input from first-level Jump rules.
  Also, the example assumes that SEC is started with the following command line:
<div class="Pp"></div>
/usr/bin/sec --conf=/etc/sec/*.rules --intcontexts \
<br/>
 --input=/var/log/messages --input=/var/log/secure
<div class="Pp"></div>
#
<div>&#x00A0;</div>
# the content of /etc/sec/main.rules
<div>&#x00A0;</div>
#
<div class="Pp"></div>
type=Jump
<div>&#x00A0;</div>
context=[ _FILE_EVENT_/var/log/messages ]
<div>&#x00A0;</div>
ptype=PerlFunc
<div>&#x00A0;</div>
pattern=sub { my(%var); my($line) = $_[0]; \
<br/>
 if ($line !~ /kernel: iptables:/g) { return 0; } \
<br/>
 while ($line =~ /\G\s*([A-Z]+)(?:=(\S*))?/g) { \
<br/>
 $var{$1} = defined($2)?$2:1; \
<br/>
 } return \%var; }
<div>&#x00A0;</div>
varmap=IPTABLES
<div>&#x00A0;</div>
desc=parse iptables events and direct to relevant ruleset
<div>&#x00A0;</div>
cfset=iptables
<div class="Pp"></div>
type=Jump
<div>&#x00A0;</div>
context=[ _FILE_EVENT_/var/log/secure ]
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=sshd\[(?&lt;pid&gt;\d+)\]: (?&lt;status&gt;Accepted|Failed) \
<div>&#x00A0;</div>
(?&lt;authmethod&gt;[\w-]+) for (?&lt;invuser&gt;invalid user )?\
<div>&#x00A0;</div>
(?&lt;user&gt;[\w-]+) from (?&lt;srcip&gt;[\d.]+) port (?&lt;srcport&gt;\d+)
  ssh2$
<div>&#x00A0;</div>
varmap=SSH_LOGIN
<div>&#x00A0;</div>
desc=parse SSH login events and direct to relevant ruleset
<div>&#x00A0;</div>
cfset=ssh-login
<div class="Pp"></div>
type=Jump
<div>&#x00A0;</div>
context=[ SSH_EVENT ]
<div>&#x00A0;</div>
ptype=TValue
<div>&#x00A0;</div>
pattern=True
<div>&#x00A0;</div>
desc=direct SSH synthetic events to relevant ruleset
<div>&#x00A0;</div>
cfset=ssh-events
<div class="Pp"></div>
#
<div>&#x00A0;</div>
# the content of /etc/sec/iptables.rules
<div>&#x00A0;</div>
#
<div class="Pp"></div>
type=Options
<div>&#x00A0;</div>
procallin=no
<div>&#x00A0;</div>
joincfset=iptables
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=Cached
<div>&#x00A0;</div>
pattern=IPTABLES
<div>&#x00A0;</div>
context=IPTABLES :&gt; ( sub { return exists($_[0]-&gt;{&quot;SYN&quot;})
  &amp;&amp; \
<br/>
 exists($_[0]-&gt;{&quot;FIN&quot;}) ; } ) \
<br/>
 &amp;&amp; !SUPPRESS_IP_$+{SRC}
<div>&#x00A0;</div>
desc=SYN+FIN flood from host $+{SRC}
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail -s 'iptables alert' root@localhost; \
<br/>
 create SUPPRESS_IP_$+{SRC} 3600
<div>&#x00A0;</div>
window=10
<div>&#x00A0;</div>
thresh=100
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=Cached
<div>&#x00A0;</div>
pattern=IPTABLES
<div>&#x00A0;</div>
context=IPTABLES :&gt; ( sub { return exists($_[0]-&gt;{&quot;SYN&quot;})
  &amp;&amp; \
<br/>
 !exists($_[0]-&gt;{&quot;ACK&quot;}) ; } ) \
<br/>
 &amp;&amp; !SUPPRESS_IP_$+{SRC}
<div>&#x00A0;</div>
desc=SYN flood from host $+{SRC}
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail -s 'iptables alert' root@localhost; \
<br/>
 create SUPPRESS_IP_$+{SRC} 3600
<div>&#x00A0;</div>
window=10
<div>&#x00A0;</div>
thresh=100
<div class="Pp"></div>
#
<div>&#x00A0;</div>
# the content of /etc/sec/ssh-login.rules
<div>&#x00A0;</div>
#
<div class="Pp"></div>
type=Options
<div>&#x00A0;</div>
procallin=no
<div>&#x00A0;</div>
joincfset=ssh-login
<div class="Pp"></div>
type=Single
<div>&#x00A0;</div>
ptype=Cached
<div>&#x00A0;</div>
pattern=SSH_LOGIN
<div>&#x00A0;</div>
context=SSH_LOGIN :&gt; ( sub { return $_[0]-&gt;{&quot;status&quot;} eq
  &quot;Failed&quot; &amp;&amp; \
<br/>
 $_[0]-&gt;{&quot;srcport&quot;} &lt; 1024 &amp;&amp; \
<br/>
 defined($_[0]-&gt;{&quot;invuser&quot;}); } )
<div>&#x00A0;</div>
continue=TakeNext
<div>&#x00A0;</div>
desc=Probe of invalid user $+{user} from privileged port of $+{srcip}
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail -s 'SSH alert' root@localhost
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=Cached
<div>&#x00A0;</div>
pattern=SSH_LOGIN
<div>&#x00A0;</div>
context=SSH_LOGIN :&gt; ( sub { return $_[0]-&gt;{&quot;status&quot;} eq
  &quot;Failed&quot; &amp;&amp; \
<br/>
 defined($_[0]-&gt;{&quot;invuser&quot;}); } )
<div>&#x00A0;</div>
desc=Ten login probes for invalid users from $+{srcip} within 60s
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail -s 'SSH alert' root@localhost
<div>&#x00A0;</div>
thresh=10
<div>&#x00A0;</div>
window=60
<div class="Pp"></div>
type=PairWithWindow
<div>&#x00A0;</div>
ptype=Cached
<div>&#x00A0;</div>
pattern=SSH_LOGIN
<div>&#x00A0;</div>
context=SSH_LOGIN :&gt; ( sub { return $_[0]-&gt;{&quot;status&quot;} eq
  &quot;Failed&quot;; } )
<div>&#x00A0;</div>
desc=User $+{user} failed to log in from $+{srcip} within 60s
<div>&#x00A0;</div>
action=cevent SSH_EVENT 0 %s
<div>&#x00A0;</div>
ptype2=Cached
<div>&#x00A0;</div>
pattern2=SSH_LOGIN
<div>&#x00A0;</div>
context2=SSH_LOGIN :&gt; \
<br/>
 ( sub { return $_[0]-&gt;{&quot;status&quot;} eq &quot;Accepted&quot;; } )
  &amp;&amp; \
<br/>
 $+{user} %+{user} $+{srcip} %+{srcip} -&gt; \
<br/>
 ( sub { return $_[0] eq $_[1] &amp;&amp; $_[2] eq $_[3]; } )
<div>&#x00A0;</div>
desc2=User $+{user} logged in successfully from $+{srcip} within 60s
<div>&#x00A0;</div>
action2=logonly
<div>&#x00A0;</div>
window=60
<div class="Pp"></div>
#
<div>&#x00A0;</div>
# the content of /etc/sec/ssh-events.rules
<div>&#x00A0;</div>
#
<div class="Pp"></div>
type=Options
<div>&#x00A0;</div>
procallin=no
<div>&#x00A0;</div>
joincfset=ssh-events
<div class="Pp"></div>
type=SingleWithThreshold
<div>&#x00A0;</div>
ptype=RegExp
<div>&#x00A0;</div>
pattern=User ([\w-]+) failed to log in from [\d.]+ within 60s
<div>&#x00A0;</div>
desc=Ten login failures for user $1 within 1h
<div>&#x00A0;</div>
action=pipe '%t: %s' /bin/mail -s 'SSH alert' root@localhost
<div>&#x00A0;</div>
thresh=10
<div>&#x00A0;</div>
window=3600
<h1 class="Sh" title="Sh" id="ENVIRONMENT"><a class="selflink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
If the <b>SECRC</b> environment variable is set, SEC expects it to contain the
  name of its resource file. Resource file lines which are empty or which begin
  with the number sign (#) are ignored (whitespace may precede #). Each
  remaining line is appended to the <b>argv</b> array of SEC as a *single*
  element. Also, the lines are appended to <b>argv</b> in the order they appear
  in the resource file. Therefore, if the SEC command line option has a value,
  the option name and the value must either be separated by the equal sign (=)
  or a newline. Here is a simple resource file example:
<div class="Pp"></div>
# read events from standard input
<div>&#x00A0;</div>
--input=-
<div class="Pp"></div>
# rules are stored in /etc/sec/test.conf
<div>&#x00A0;</div>
--conf
<div>&#x00A0;</div>
/etc/sec/test.conf
<div class="Pp"></div>
Note that although SEC rereads its resource file at the reception of the
  <b>SIGHUP</b> or <b>SIGABRT</b> signal, adding an option that specifies a
  certain startup procedure (e.g., <b>--pid</b> or <b>--detach</b>) will not
  produce the desired effect at runtime. Also note that the resource file
  content is *not* parsed by shell, therefore shell metacharacters are passed to
  SEC as-is.
<h1 class="Sh" title="Sh" id="SIGNALS"><a class="selflink" href="#SIGNALS">SIGNALS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SIGHUP</b></dt>
  <dd class="It-tag">full restart -- SEC will reinterpret its command line and
      resource file options, reopen its log and input files, close its output
      files and sockets (these will be reopened on demand), reload its
      configuration, and drop *all* event correlation state (all event
      correlation operations will be terminated, all contexts will be deleted,
      all action list variables will be erased, etc.). With the
      <b>--childterm</b> option, SEC will also send the <b>SIGTERM</b> signal to
      its child processes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SIGABRT</b></dt>
  <dd class="It-tag">soft restart -- SEC will reinterpret its command line and
      resource file options, reopen its log file, and close its output files and
      sockets (these will be reopened on demand). If the <b>--keepopen</b>
      option is specified, previously opened input files will remain open across
      soft restart, otherwise all input files will be reopened. SEC will
      (re)load configuration from rule files which have been modified (file
      modification time returned by <b>stat</b>(2) has changed) or created after
      the previous configuration load. SEC will also terminate event correlation
      operations started from rule files that have been modified or removed
      after the previous configuration load. Other operations and previously
      loaded configuration from unmodified rule files will remain intact. Note
      that on some systems <b>SIGIOT</b> is used in place of
    <b>SIGABRT</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SIGUSR1</b></dt>
  <dd class="It-tag">detailed information about the current state of SEC
      (performance and rule matching statistics, running event correlation
      operations, created contexts, etc.) will be written to the SEC dump
    file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SIGUSR2</b></dt>
  <dd class="It-tag">SEC will reopen its log file (useful for log file
      rotation), and also close its output files and sockets which will be
      reopened on demand.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SIGINT</b></dt>
  <dd class="It-tag">SEC will increase its logging level by one; if the current
      level is 6, the level will be set back to 1. Please note this feature is
      available only if SEC is running non-interactively (e.g., in daemon
    mode).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SIGTERM</b></dt>
  <dd class="It-tag">SEC will terminate gracefully. With the <b>--childterm</b>
      option, all SEC child processes will receive <b>SIGTERM</b>.</dd>
</dl>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
With some locale settings, single quotes (') in this man page might be displayed
  incorrectly. As a workaround, set the LANG environment variable to C when
  reading this man page (e.g., env LANG=C man sec).
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Risto Vaarandi (ristov at users d0t s0urcef0rge d0t net)
<h1 class="Sh" title="Sh" id="ACKNOWLEDGMENTS"><a class="selflink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
This work is supported by SEB. The author thanks the following people for
  supplying software patches, documentation fixes, and suggesting new features:
  Al Sorrell, Brian Mielke, David Lang, James Brown, Jon Frazier, Mark D. Nagel,
  Peter Eckel, Rick Casey, and William Gertz. Last but not least, the author
  expresses his profound gratitute to John P. Rouillard for many great ideas and
  creative discussions that have helped to develop SEC.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>cron</b>(8), <b>crontab</b>(1), <b>fork</b>(2), <b>mail</b>(1),
  <b>perl</b>(1), <b>perlmod</b>(1), <b>perlre</b>(1), <b>pipe</b>(2),
  <b>sh</b>(1), <b>snmptrap</b>(1), <b>stat</b>(2), <b>strftime</b>(3),
  <b>syslog</b>(3), <b>time</b>(2), <b>umask</b>(2)</div>
<table class="foot">
  <tr>
    <td class="foot-date">February 2017</td>
    <td class="foot-os">SEC 2.7.11</td>
  </tr>
</table>
</body>
</html>
