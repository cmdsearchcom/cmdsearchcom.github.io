<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:37:13 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>sec(1) General Commands Manual sec(1)</p>

<p style="margin-top: 1em">NAME <br>
sec - simple event correlator</p>

<p style="margin-top: 1em">SYNOPSIS <br>
sec [--conf=&lt;file pattern&gt; ...] <br>
[--input=&lt;file pattern&gt;[=&lt;context&gt;] ...] <br>
[--input-timeout=&lt;input timeout&gt;] <br>
[--timeout-script=&lt;timeout script&gt;] <br>
[--reopen-timeout=&lt;reopen timeout&gt;] <br>
[--check-timeout=&lt;check timeout&gt;] <br>
[--poll-timeout=&lt;poll timeout&gt;] <br>
[--socket-timeout=&lt;socket timeout&gt;] <br>
[--blocksize=&lt;io block size&gt;] <br>
[--bufsize=&lt;input buffer size&gt;] <br>
[--evstoresize=&lt;event store size&gt;] <br>
[--cleantime=&lt;clean time&gt;] <br>
[--log=&lt;logfile&gt;] <br>
[--syslog=&lt;facility&gt;] <br>
[--debug=&lt;debuglevel&gt;] <br>
[--pid=&lt;pidfile&gt;] <br>
[--dump=&lt;dumpfile&gt;] <br>
[--user=&lt;username&gt;] <br>
[--group=&lt;groupname&gt; ...] <br>
[--umask=&lt;mode&gt;] <br>
[--dumpfts | --nodumpfts] <br>
[--quoting | --noquoting] <br>
[--tail | --notail] <br>
[--fromstart | --nofromstart] <br>
[--detach | --nodetach] <br>
[--jointbuf | --nojointbuf] <br>
[--keepopen | --nokeepopen] <br>
[--rwfifo | --norwfifo] <br>
[--childterm | --nochildterm] <br>
[--intevents | --nointevents] <br>
[--intcontexts | --nointcontexts] <br>
[--testonly | --notestonly] <br>
[--help] [-?] <br>
[--version]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
SEC is an event correlation tool for advanced event
processing which can be harnessed for event log monitoring,
for network and security management, for fraud detection,
and for <br>
any other task which involves event correlation. Event
correlation is a procedure where a stream of events is
processed, in order to detect (and act on) certain event
groups <br>
that occur within predefined time windows. Unlike many other
event correlation products which are heavyweight solutions,
SEC is a lightweight and platform-independent event
cor&acirc; <br>
relator which runs as a single process. The user can start
it as a daemon, employ it in shell pipelines, execute it
interactively in a terminal, run many SEC processes
simultane&acirc; <br>
ously for different tasks, and use it in a wide variety of
other ways.</p>

<p style="margin-top: 1em">SEC reads lines from files,
named pipes, or standard input, matches the lines with
patterns (regular expressions, Perl subroutines, etc.) for
recognizing input events, and cor&acirc; <br>
relates events according to the rules in its configuration
file(s). Rules are matched against input in the order they
are given in the configuration file. If there are two or
<br>
more configuration files, rule sequence from every file is
matched against input (unless explicitly specified
otherwise). SEC can produce output by executing external
programs <br>
(e.g., snmptrap(1) or mail(1)), by writing to files, by
sending data to TCP and UDP based servers, by calling
precompiled Perl subroutines, etc.</p>

<p style="margin-top: 1em">SEC can be run in various ways.
For example, the following command line starts it as a
daemon, in order to monitor events appended to the
/var/log/messages syslog file with rules <br>
from /etc/sec/syslog.rules:</p>

<p style="margin-top: 1em">/usr/bin/sec --detach
--conf=/etc/sec/syslog.rules --input=/var/log/messages</p>

<p style="margin-top: 1em">Each time /var/log/messages is
rotated, a new instance of /var/log/messages is opened and
processed from the beginning. The following command line
runs SEC in a shell pipeline, <br>
configuring it to process lines from standard input, and to
exit when the /usr/bin/nc tool closes its standard output
and exits:</p>

<p style="margin-top: 1em">/usr/bin/nc -l 8080 |
/usr/bin/sec --notail --input=- --conf=/etc/sec/my.conf</p>

<p style="margin-top: 1em">Some SEC rules start event
correlation operations, while other rules react immediately
to input events or system clock. For example, suppose that
SEC has been started with the <br>
following command line</p>

<p style="margin-top: 1em">/usr/bin/sec
--conf=/etc/sec/sshd.rules --input=/var/log/secure</p>

<p style="margin-top: 1em">in order to monitor the
/var/log/secure syslog file for sshd events. Also, suppose
that the /etc/sec/sshd.rules configuration file contains the
following rule for correlating <br>
SSH failed login syslog events:</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for () from [.]+ port + ssh2 <br>
desc=Three SSH login failures within 1m for user $1 <br>
action=pipe &rsquo;%s&rsquo; /bin/mail -s &rsquo;SSH login
alert&rsquo; root@localhost <br>
window=60 <br>
thresh=3</p>

<p style="margin-top: 1em">The pattern field of the rule
defines the pattern for recognizing input events, while the
ptype field defines its type (regular expression). Suppose
that user risto fails to log <br>
in over SSH and the following message is logged to
/var/log/secure:</p>

<p style="margin-top: 1em">Dec 16 16:24:59 myserver
sshd[13685]: Failed password for risto from 10.12.2.5 port
41063 ssh2</p>

<p style="margin-top: 1em">This input message will match
the regular expression pattern of the above rule, and the
match variable $1 will be set to the string risto (see
perlre(1) for details). After a <br>
match, SEC will evaluate the operation description string
given with the desc field. This is done by substituting $1
with its current value which yields Three SSH login failures
<br>
within 1m for user risto. SEC will then check if there
already exists an event correlation operation identified
with this string and triggered by the same rule. If the
opera&acirc; <br>
tion is not found, SEC will create a new operation for the
user name risto, and the occurrence time of the input event
will be recorded into the operation. Note that for event
<br>
occurrence time SEC always uses the current time as returned
by the time(2) system call, *not* the timestamp extracted
from the event. Suppose that after 25 seconds, a similar
<br>
SSH login failure event for the same user name is observed.
In this case, a running operation will be found for the
operation description string Three SSH login failures within
<br>
1m for user risto, and the occurrence time of the second
event is recorded into the operation. If after 30 seconds a
third event for the user name risto is observed, the
opera&acirc; <br>
tion has processed 3 events within 55 seconds. Since the
threshold condition &quot;3 events within 60 seconds&quot;
(as defined by the thresh and window fields) is now
satisfied, SEC will <br>
execute the action defined with the action field -- it will
fork a command</p>

<p style="margin-top: 1em">/bin/mail -s &rsquo;SSH login
alert&rsquo; root@localhost</p>

<p style="margin-top: 1em">with a pipe connected to its
standard input. Then, SEC writes the operation description
string Three SSH login failures within 1m for user risto
(held by the %s special variable) <br>
to the standard input of the command through the pipe. In
other words, an e-mail warning is sent to the local
root-user. Finally, since there are 5 seconds left until the
end <br>
of the event correlation window, the operation will consume
the following SSH login failure events for user risto
without any further action, and finish after 5 seconds.</p>

<p style="margin-top: 1em">The above example illustrates
that the desc field of a rule defines the scope of event
correlation and influences the number of operations created
by the rule. For example, if we <br>
set the desc field to Three SSH login failures within 1m,
the root-user would be also alerted on 3 SSH login failure
events for *different* users within 1 minute. In order to
<br>
avoid clashes between operations started by different rules,
operation ID contains not only the value set by the desc
field, but also the rule file name and the rule number <br>
inside the file. For example, if the rule file
/etc/sec/sshd.rules contains one rule</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for () from [.]+ port + ssh2 <br>
desc=Three SSH login failures within 1m for user $1 <br>
action=pipe &rsquo;%s&rsquo; /bin/mail -s &rsquo;SSH login
alert&rsquo; root@localhost <br>
window=60 <br>
thresh=3</p>

<p style="margin-top: 1em">and the event</p>

<p style="margin-top: 1em">Dec 16 16:24:59 myserver
sshd[13685]: Failed password for risto from 10.12.2.5 port
41063 ssh2</p>

<p style="margin-top: 1em">is the first matching event for
the above rule, this event will trigger a new event
correlation operation with the ID</p>

<p style="margin-top: 1em">/etc/sec/sshd.rules | 0 | Three
SSH login failures within 1m for user risto</p>

<p style="margin-top: 1em">(0 is the number assigned to the
first rule in the file, see EVENT CORRELATION OPERATIONS
section for more information).</p>

<p style="margin-top: 1em">The following simple example
demonstrates that event correlation schemes can be defined
by combining several rules. In this example, two rules
harness contexts and synthetic <br>
events for achieving their goal:</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for () from [.]+ port + ssh2 <br>
desc=Three SSH login failures within 1m for user $1 <br>
action=event 3_SSH_LOGIN_FAILURES_FOR_$1 <br>
window=60 <br>
thresh=3</p>

<p style="margin-top: 1em">type=EventGroup <br>
ptype=RegExp <br>
pattern=3_SSH_LOGIN_FAILURES_FOR_() <br>
context=!USER_$1_COUNTED &amp;&amp; !COUNTING_OFF <br>
count=create USER_$1_COUNTED 60 <br>
desc=Repeated SSH login failures for 30 distinct users
within 1m <br>
action=pipe &rsquo;%s&rsquo; /bin/mail -s &rsquo;SSH login
alert&rsquo; root@localhost; create COUNTING_OFF 3600 <br>
window=60 <br>
thresh=30</p>

<p style="margin-top: 1em">The first rule looks almost
identical to the rule from the previous example, but its
action field is different -- after three SSH login failures
have been observed for the same <br>
user name within one minute by an event correlation
operation, the operation will emit the synthetic event
3_SSH_LOGIN_FAILURES_FOR_&lt;username&gt;. Although
synthetic events are cre&acirc; <br>
ated by SEC, they are treated like regular events received
from input sources and are matched against rules. The
regular expression pattern of the second rule will match the
<br>
3_SSH_LOGIN_FAILURES_FOR_&lt;username&gt; event and start a
new event correlation operation if no such events have been
previously seen. Also, each time a synthetic event for some
<br>
user name has matched the rule, a context with the lifetime
of 1 minute for that user name is created (see the count
field). Note that this prevents further matches for the same
<br>
user name, since a synthetic event for &lt;username&gt; can
match the rule only if the context
USER_&lt;username&gt;_COUNTED *does not* exist (as requested
by the boolean expression in the <br>
context field; see CONTEXTS AND CONTEXT EXPRESSIONS section
for more information). The operation started by the rule
sends an e-mail warning to the local root-user if 30
syn&acirc; <br>
thetic events have been observed within 1 minute (see the
thresh and window fields). Note that due to the use of the
USER_&lt;username&gt;_COUNTED contexts, all synthetic events
con&acirc; <br>
cern different user names. After sending an e-mail warning,
the operation will also create the context COUNTING_OFF with
the lifetime of 1 hour, and will continue to run until <br>
the 1 minute event correlation window expires. After the
operation has finished, the presence of the COUNTING_OFF
context will keep the second rule disabled (as requested by
the <br>
boolean expression in the context field). Therefore, at most
one e-mail warning per 1 hour is issued by above rules.</p>

<p style="margin-top: 1em">The above examples have
presented the event correlation capabilities of SEC in a
very brief fashion. The following sections will provide an
in-depth discussion of SEC features.</p>

<p style="margin-top: 1em">OPTIONS <br>
--conf=&lt;file_pattern&gt; <br>
expand &lt;file_pattern&gt; to filenames (with the Perl
glob() function) and read event correlation rules from every
file. Multiple --conf options can be specified at command
<br>
line. Each time SEC receives a signal that forces a
configuration reload, &lt;file_pattern&gt; is re-evaluated.
See also INPUT PROCESSING AND TIMING section for a
discussion on <br>
rule processing order for multiple configuration files.</p>


<p style="margin-top: 1em">--input=&lt;file_pattern&gt;[=&lt;context&gt;]
<br>
expand &lt;file_pattern&gt; to filenames (with the Perl
glob() function) and use the files as input sources. An
input file can be a regular file, named pipe, or standard
input <br>
if - was specified. Multiple --input options can be
specified at command line. Each time SEC receives the SIGHUP
or SIGABRT signal, &lt;file_pattern&gt; is re-evaluated. If
SEC <br>
experiences a system error when reading from an input file,
it will close the file (use the --reopen-timeout option for
reopening the file). If &lt;context&gt; is given, SEC <br>
will set up the context &lt;context&gt; each time it reads a
line from input files that correspond to
&lt;file_pattern&gt;. This will help the user to write rules
that match data from <br>
particular input source(s) only. When there is an --input
option with &lt;context&gt; specified, it will automatically
enable the --intcontexts option. See INTERNAL EVENTS AND
<br>
CONTEXTS section for more information.</p>


<p style="margin-top: 1em">--input-timeout=&lt;input_timeout&gt;,
--timeout-script=&lt;timeout_script&gt; <br>
if SEC has not observed new data in an input file during
&lt;input_timeout&gt; seconds (or the file was closed
&lt;input_timeout&gt; seconds ago), &lt;timeout_script&gt;
will be executed <br>
with command line parameters 1 and &lt;the name of the input
file&gt;. If fresh data become available again,
&lt;timeout_script&gt; will be executed with command line
parameters 0 and <br>
&lt;the name of the input file&gt;. Setting
&lt;input_timeout&gt; to 0 disables this behavior (this is
also the default). Note that --input_timeout and
--timeout_script options can <br>
be used as synonyms for --input-timeout and
--timeout-script, respectively.</p>


<p style="margin-top: 1em">--reopen-timeout=&lt;reopen_timeout&gt;
<br>
if an input file is in the closed state (e.g., SEC fails to
open the file at startup, because it has not been created
yet), SEC will attempt to reopen the file after every <br>
&lt;reopen_timeout&gt; seconds until open succeeds. Setting
&lt;reopen_timeout&gt; to 0 disables this behavior (this is
also the default). This option has no meaning when the <br>
--notail option is also specified. Note that
--reopen_timeout is a synonym for --reopen-timeout.</p>


<p style="margin-top: 1em">--check-timeout=&lt;check_timeout&gt;
<br>
if SEC has not observed new data in an input file, the file
will not be polled (both for status and data) during the
next &lt;check_timeout&gt; seconds. Setting
&lt;check_timeout&gt; <br>
to 0 disables this behavior (this is also the default). Note
that --check_timeout is a synonym for --check-timeout.</p>


<p style="margin-top: 1em">--poll-timeout=&lt;poll_timeout&gt;
<br>
a real number that specifies how many seconds SEC will sleep
when no new data were read from input files. Default is 0.1
seconds. Note that --poll_timeout is a synonym <br>
for --poll-timeout.</p>


<p style="margin-top: 1em">--socket-timeout=&lt;socket_timeout&gt;
<br>
if a network connection to a remote peer can&rsquo;t be
established within &lt;socket_timeout&gt; seconds, give up.
Default is 60 seconds. Note that --socket_timeout is a
synonym for <br>
--socket-timeout.</p>


<p style="margin-top: 1em">--blocksize=&lt;io_block_size&gt;
<br>
the number of bytes SEC will attempt to read at once from an
input file. Default is 8192 bytes (i.e., read from input
files by 8KB blocks).</p>


<p style="margin-top: 1em">--bufsize=&lt;input_buffer_size&gt;
<br>
set all input buffers to hold &lt;input_buffer_size&gt;
lines. The content of input buffers will be compared with
patterns that are part of rule definitions (i.e., no more
than <br>
&lt;input_buffer_size&gt; lines can be matched by a pattern
at a time). If &lt;input_buffer_size&gt; is set to 0, SEC
will determine the proper value for
&lt;input_buffer_size&gt; by <br>
checking event matching patterns of all SEC rules. Default
is 0 (i.e., determine the size of input buffers
automatically).</p>


<p style="margin-top: 1em">--evstoresize=&lt;event_store_size&gt;
<br>
set an upper limit to the number of events in context event
stores. Default is 0 which sets no limit.</p>

<p style="margin-top: 1em">--cleantime=&lt;clean_time&gt;
<br>
time interval in seconds that specifies how often internal
event correlation and context lists are processed, in order
to accomplish time-related tasks and to remove obso&acirc;
<br>
lete elements. See INPUT PROCESSING AND TIMING section for
more information. Default is 1 second.</p>

<p style="margin-top: 1em">--log=&lt;logfile&gt; <br>
use &lt;logfile&gt; for logging SEC activities. Note that if
the SEC standard error is connected to a terminal, messages
will also be logged there, in order to facilitate
debug&acirc; <br>
ging.</p>

<p style="margin-top: 1em">--syslog=&lt;facility&gt; <br>
use syslog for logging SEC activities. All messages will be
logged with the facility &lt;facility&gt;, e.g., local0 (see
syslog(3) for possible facility values). Warning: be <br>
careful with using this option if SEC is employed for
monitoring syslog log files, because message loops might
occur.</p>

<p style="margin-top: 1em">--debug=&lt;debuglevel&gt; <br>
set logging verbosity for SEC. Setting debuglevel to
&lt;debuglevel&gt; means that all messages of level
&lt;debuglevel&gt; and lower are logged (e.g., if
&lt;debuglevel&gt; is 3, messages <br>
from levels 1-3 are logged). The following levels are
recognized by SEC: <br>
1 - critical messages (severe faults that cause SEC to
terminate, e.g., a failed system call) <br>
2 - error messages (faults that need attention, e.g., an
incorrect rule definition in a configuration file) <br>
3 - warning messages (possible faults, e.g., a command
forked from SEC terminated with a non-zero exit code) <br>
4 - notification messages (normal system level events and
interrupts, e.g., the reception of a signal) <br>
5 - informative messages (information about external
programs forked from SEC) <br>
6 - debug messages (detailed information about all SEC
activities) <br>
Default &lt;debuglevel&gt; is 6 (i.e., log everything). See
SIGNALS section for information on how to change
&lt;debuglevel&gt; at runtime.</p>

<p style="margin-top: 1em">--pid=&lt;pidfile&gt; <br>
SEC will store its process ID to &lt;pidfile&gt; at
startup.</p>

<p style="margin-top: 1em">--dump=&lt;dumpfile&gt; <br>
SEC will use &lt;dumpfile&gt; as its dump file for writing
performance and debug data. With the --dumpfts option, a
timestamp suffix is appended to the dump file name. See
SIG&acirc; <br>
NALS section for more information. Default is
/tmp/sec.dump.</p>

<p style="margin-top: 1em">--user=&lt;username&gt;,
--group=&lt;groupname&gt; <br>
if SEC is started with effective user ID 0, it will drop
root privileges by switching to user &lt;username&gt; and
group &lt;groupname&gt;. The --group option can&rsquo;t be
used without <br>
the --user option. If the --user option is given without
--group, primary group of the user &lt;username&gt; is
assumed for &lt;groupname&gt;. If several groups are
provided with <br>
multiple --group options, SEC switches to the first group
with other groups as supplementary groups.</p>

<p style="margin-top: 1em">--umask=&lt;mode&gt; <br>
set file mode creation mask to &lt;mode&gt; at SEC startup,
where &lt;mode&gt; is a value from the range 0..0777 (see
also umask(2)). Octal, decimal, hexadecimal, and binary
values <br>
can be specified for &lt;mode&gt; (e.g., octal mask 0027 can
also be expressed as 23, 0x17, and 0b000010111).</p>

<p style="margin-top: 1em">--dumpfts, --nodumpfts <br>
if the --dumpfts option is specified, a timestamp suffix
(seconds since Epoch) is appended to the dump file name that
reflects the file creation time. Default is <br>
--nodumpfts.</p>

<p style="margin-top: 1em">--quoting, --noquoting <br>
if the --quoting option is specified, operation description
strings that are supplied to command lines of shellcmd,
spawn, and cspawn actions will be put inside single <br>
quotes. Each single quote (&rsquo;) that strings originally
contain will be masked. This option prevents the shell from
interpreting special symbols that operation description <br>
strings might contain. Default is --noquoting.</p>

<p style="margin-top: 1em">--tail, --notail <br>
if the --notail option is specified, SEC will process all
data that are currently available in input files and exit
after reaching all EOFs. If all input is received from <br>
a pipe and the --notail option is given, SEC terminates when
the last writer closes the pipe (EOF condition). Please note
that with named pipes --notail should be used <br>
with --norwfifo. With the --tail option, SEC will jump to
the end of input files and wait for new lines to arrive.
Each input file is tracked both by its name and i- <br>
node, and input file rotations are handled seamlessly. If
the input file is recreated or truncated, SEC will reopen it
and process its content from the beginning. If the <br>
input file is removed (i.e., there is just an i-node left
without a name), SEC will keep the i-node open and wait for
the input file recreation. Default is --tail.</p>

<p style="margin-top: 1em">--fromstart, --nofromstart <br>
these flags have no meaning when the --notail option is also
specified. When used in combination with --tail (or alone,
since --tail is enabled by default), --fromstart <br>
will force SEC to read and process input files from the
beginning to the end, before the &rsquo;tail&rsquo; mode is
entered. Default is --nofromstart.</p>

<p style="margin-top: 1em">--detach, --nodetach <br>
if the --detach option is specified, SEC will disassociate
itself from the controlling terminal and become a daemon at
startup (note that SEC will close its standard <br>
input, standard output, and standard error, and change its
working directory to the root directory). Default is
--nodetach.</p>

<p style="margin-top: 1em">--jointbuf, --nojointbuf <br>
if the --jointbuf option is specified, SEC uses joint input
buffer for all input sources (the size of the buffer is set
with the --bufsize option). The --nojointbuf option <br>
creates a separate input buffer for each input file, and a
separate buffer for all synthetic and internal events (the
sizes of all buffers are set with the --bufsize <br>
option). The --jointbuf option allows multiline patterns to
match lines from several input sources, while the
--nojointbuf pattern restricts the matching to lines from
one <br>
input source only. See INPUT PROCESSING AND TIMING section
for more information. If the size of input buffer(s) is 1
(either explicitly set with --bufsize=1 or automati&acirc;
<br>
cally determined from SEC rules), --jointbuf option is
enabled, otherwise the default is --nojointbuf.</p>

<p style="margin-top: 1em">--keepopen, --nokeepopen <br>
if the --keepopen option is specified, SEC will keep input
files open across soft restarts. When the SIGABRT signal is
received, SEC will not reopen input files which <br>
have been opened previously, but will only open input files
which are in the closed state. The --nokeepopen option
forces SEC to close and (re)open all input files during <br>
soft restarts. Default is --keepopen.</p>

<p style="margin-top: 1em">--rwfifo, --norwfifo <br>
if the --norwfifo option is specified, named pipe input
files are opened in read-only mode. In this mode, the named
pipe has to be reopened when the last writer closes <br>
the pipe, in order to clear the EOF condition on the pipe.
With the --rwfifo option, named pipe input files are opened
in read-write mode, although SEC never writes to the <br>
pipes. In this mode, the pipe does not need to be reopened
when an external writer closes it, since there is always at
least one writer on the pipe and EOF will never <br>
appear. Therefore, if the --notail option has been given,
--norwfifo should also be specified. Default is
--rwfifo.</p>

<p style="margin-top: 1em">--childterm, --nochildterm <br>
if the --childterm option is specified, SEC will send the
SIGTERM signal to all its child processes when it terminates
or goes through a full restart. Default is <br>
--childterm.</p>

<p style="margin-top: 1em">--intevents, --nointevents <br>
SEC will generate internal events when it starts up, when it
receives certain signals, and when it terminates gracefully.
Specific rules can be written to match those <br>
internal events, in order to accomplish special tasks at SEC
startup, restart, and shutdown. See INTERNAL EVENTS AND
CONTEXTS section for more information. Default is <br>
--nointevents.</p>

<p style="margin-top: 1em">--intcontexts, --nointcontexts
<br>
SEC will create an internal context when it reads a line
from an input file. This will help the user to write rules
that match data from particular input source only. See <br>
INTERNAL EVENTS AND CONTEXTS section for more information.
Default is --nointcontexts.</p>

<p style="margin-top: 1em">--testonly, --notestonly <br>
if the --testonly option is specified, SEC will exit
immediately after parsing the configuration file(s). If the
configuration file(s) contained no faulty rules, SEC will
<br>
exit with 0, otherwise with 1. Default is --notestonly.</p>

<p style="margin-top: 1em">--help, -? <br>
SEC will output usage information and exit.</p>

<p style="margin-top: 1em">--version <br>
SEC will output version information and exit.</p>

<p style="margin-top: 1em">Note that options can be
introduced both with the single dash (-) and double dash
(--), and both the equal sign (=) and whitespace can be used
for separating the option name from <br>
the option value. For example, -conf=&lt;file_pattern&gt;
and --conf &lt;file_pattern&gt; options are equivalent.</p>

<p style="margin-top: 1em">CONFIGURATION FILES <br>
Each SEC configuration file consists of rule definitions
which are separated by empty lines, whitespace lines and/or
comment lines. Each rule definition consists of key&acirc;
<br>
word=value fields, one keyword and value per line. Values
are case insensitive only where character case is not
important (like the values specifying rule types, e.g.,
&rsquo;Single&rsquo; <br>
and &rsquo;single&rsquo; are treated identically). The
backslash character ( may be used at the end of a line to
continue the current rule field in the next line. Lines
which begin with <br>
the number sign (#) are treated as comments and ignored
(whitespace characters may precede #). Any comment line,
empty line, whitespace line, or end of file will terminate
the <br>
preceding rule definition. For inserting comments into rule
definitions, the rem keyword can be used. For example, the
following lines define two rules:</p>

<p style="margin-top: 1em">type=Single <br>
rem=this rule matches any line which contains three
consecutive A characters and writes the string &quot;three A
characters were observed&quot; to standard output <br>
ptype=SubStr <br>
pattern=AAA <br>
desc=Three A characters <br>
action=write - three A characters were observed <br>
# This comment line ends preceding rule definition. <br>
# The following rule works like the previous rule, <br>
# but looks for three consecutive B characters and <br>
# writes the string &quot;three B characters were
observed&quot; <br>
# to standard output <br>
type=Single <br>
ptype=SubStr <br>
pattern=BBB <br>
desc=Three B characters <br>
action=write - three B characters were observed</p>

<p style="margin-top: 1em">Apart from keywords that are
part of rule definitions, label keywords may appear anywhere
in the configuration file. The value of each label keyword
will be treated as a label <br>
that can be referred to in rule definitions as a
point-of-continue. This allows for continuing event
processing at a rule that follows the label, after the
current rule has <br>
matched and processed the event.</p>

<p style="margin-top: 1em">The points-of-continue are
defined with continue* fields. Accepted values for these
fields are:</p>

<p style="margin-top: 1em">TakeNext <br>
after an event has matched the rule, search for matching
rules in the configuration file will continue from the next
rule.</p>

<p style="margin-top: 1em">GoTo &lt;label&gt; <br>
after an event has matched the rule, search for matching
rules will continue from the location of &lt;label&gt; in
the configuration file (&lt;label&gt; must be defined with
the label <br>
keyword anywhere in the configuration file *after* the
current rule definition).</p>

<p style="margin-top: 1em">DontCont (default value) <br>
after an event has matched the rule, search for matching
rules ends in the *current* configuration file.</p>

<p style="margin-top: 1em">EndMatch <br>
after an event has matched the rule, search for matching
rules ends for *all* configuration files.</p>

<p style="margin-top: 1em">SEC rules from the same
configuration file are matched against input in the order
they have been given in the file. For example, consider a
configuration file which contains the <br>
following rule sequence:</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=AAA <br>
rem=after this rule has matched, continue from last rule
<br>
continue=GoTo lastRule <br>
desc=Three A characters <br>
action=write - three A characters were observed</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=BBB <br>
rem=after this rule has matched, don&rsquo;t consider
following rules, since &rsquo;continue&rsquo; defaults to
&rsquo;DontCont&rsquo; <br>
desc=Three B characters <br>
action=write - three B characters were observed</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=CCC <br>
rem=after this rule has matched, continue from next rule
<br>
continue=TakeNext <br>
desc=Three C characters <br>
action=write - three C characters were observed</p>

<p style="margin-top: 1em">label=lastRule</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=DDD <br>
desc=Three D characters <br>
action=write - three D characters were observed</p>

<p style="margin-top: 1em">For the input line
&quot;AAABBBCCCDDD&quot;, this ruleset writes strings
&quot;three A characters were observed&quot; and &quot;three
D characters were observed&quot; to standard output. If the
input line is <br>
&quot;BBBCCCDDD&quot;, the string &quot;three B characters
were observed&quot; is written to standard output. For the
input line &quot;CCCDDD&quot;, strings &quot;three C
characters were observed&quot; and &quot;three D <br>
characters were observed&quot; are sent to standard output,
while the input line &quot;DDD&quot; produces the output
string &quot;three D characters were observed&quot;.</p>

<p style="margin-top: 1em">If there are two or more
configuration files, rule sequence from every file is
matched against input (unless explicitly specified
otherwise). For example, suppose SEC is started <br>
with the command line</p>

<p style="margin-top: 1em">/usr/bin/sec --input=-
--conf=/etc/sec/sec1.rules --conf=/etc/sec/sec2.rules</p>

<p style="margin-top: 1em">and the configuration file
/etc/sec/sec1.rules has the following content:</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=AAA <br>
desc=Three A characters <br>
action=write - three A characters were observed</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=BBB <br>
continue=EndMatch <br>
desc=Three B characters <br>
action=write - three B characters were observed</p>

<p style="margin-top: 1em">Also, suppose the configuration
file /etc/sec/sec2.rules has the following content:</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=CCC <br>
desc=Three C characters <br>
action=write - three C characters were observed</p>

<p style="margin-top: 1em">If SEC receives the line
&quot;AAABBBCCC&quot; from standard input, rules from both
configuration files are tried, and as a result, the strings
&quot;three A characters were observed&quot; and <br>
&quot;three C characters were observed&quot; are written to
standard output. Note that rules from /etc/sec/sec1.rules
are tried first against the input line, since the option
<br>
--conf=/etc/sec/sec1.rules is given before
--conf=/etc/sec/sec2.rules in the SEC command line (see also
INPUT PROCESSING AND TIMING section for a more detailed
discussion). If <br>
SEC receives the line &quot;BBBCCC&quot; from standard
input, the second rule from /etc/sec/sec1.rules produces a
match, and the string &quot;three B characters were
observed&quot; is written to <br>
standard output. Since the rule contains continue=EndMatch
statement, the search for matching rules will end for all
configuration files, and rules from /etc/sec/sec2.rules will
<br>
not be not tried. Without this statement, the search for
matching rules would continue in /etc/sec/sec2.rules, and
the first rule would write the string &quot;three C
characters were <br>
observed&quot; to standard output.</p>

<p style="margin-top: 1em">PATTERNS, PATTERN TYPES AND
MATCH VARIABLES <br>
Patterns and pattern types are defined with pattern* and
ptype* rule fields. Many pattern types define the number of
lines N which the pattern matches (if N is omitted, 1 is
<br>
assumed). If N is greater than 1, the scope of matching is
set with the --jointbuf and --nojointbuf options. With
--jointbuf, the pattern is used for matching N last input
lines <br>
taken from the joint input buffer (the lines can come from
different input sources). With --nojointbuf, the source of
the last input line is identified, and the pattern is <br>
matched with N last input lines from the input buffer of the
identified source.</p>

<p style="margin-top: 1em">SubStr[N] <br>
pattern is a string that is searched in the last N input
lines L1, L2, ..., LN. If N is greater than 1, the input
lines are joined into a string
&quot;L1&lt;NEWLINE&gt;L2&lt;NEW&acirc; <br>
LINE&gt;...&lt;NEWLINE&gt;LN&quot;, and the pattern string
will be searched from it. If the pattern string is found in
input line(s), the pattern matches. Backslash sequences , 0
<br>
, nd can be used in the pattern for denoting tabulation,
newline, carriage return, space character, and empty string,
respectively, while \ denotes backslash <br>
itself. For example, consider the following pattern
definition:</p>

<p style="margin-top: 1em">ptype=substr <br>
pattern=Backup done:success</p>

<p style="margin-top: 1em">The pattern matches lines
containing &quot;Backup done:&lt;TAB&gt;success&quot;.</p>

<p style="margin-top: 1em">Note that since the SubStr[N]
pattern type has been designed for fast matching, it does
not support match variables.</p>

<p style="margin-top: 1em">RegExp[N] <br>
pattern is a Perl regular expression (see perlre(1) for more
information) for matching the last N input lines L1, L2,
..., LN. If N is greater than 1, the input lines are <br>
joined into a string
&quot;L1&lt;NEWLINE&gt;L2&lt;NEWLINE&gt;...&lt;NEWLINE&gt;LN&quot;,
and the regular expression is matched with this string. If
the regular expression matches, match variables <br>
will be set, and these match variables can be used in other
parts of the rule definition.</p>

<p style="margin-top: 1em">In addition to numbered match
variables ($1, $2, etc.), SEC supports named match variables
$+{name} and the $0 variable. The $0 variable holds the
entire string of last N <br>
input lines that the regular expression has matched. Named
match variables can be created in newer versions of Perl
regular expression language, e.g., (?&lt;myvar&gt;AB|CD)
<br>
sets $+{myvar} to AB or CD. The special named match variable
$+{_inputsrc} is created by SEC and holds input file name(s)
where matching line(s) came from.</p>

<p style="margin-top: 1em">For example, the following
pattern matches the SSH &quot;Connection from&quot; event,
and sets $0 to the entire event line, both $1 and $+{ip} to
the IP address of the remote node, <br>
$2 to the port number at the remote node, and $+{_inputsrc}
to the input file name:</p>

<p style="margin-top: 1em">ptype=RegExp <br>
pattern=sshd: Connection from (?&lt;ip&gt;[.]+) port (+)</p>

<p style="margin-top: 1em">Also, SEC allows for match
caching and for the creation of additional named match
variables through variable maps which are defined with the
varmap* fields. Variable map <br>
is a list of name=number mappings separated by semicolons,
where name is the name for the named variable and number
identifies a numbered match variable that is set by the <br>
regular expression. Each name must begin with a letter and
consist of letters, digits and underscores. After the
regular expression has matched, named variables specified
<br>
by the map are created from corresponding numbered
variables. If the same named variable is set up both from
the regular expression and variable map, the map takes
prece&acirc; <br>
dence.</p>

<p style="margin-top: 1em">If name is not followed by the
equal sign and number in the varmap* field, it is regarded
as a common name for all match variables and their values
from a successful <br>
match. This name is used for caching a successful match by
the pattern -- match variables and their values are stored
in the memory-based pattern match cache under name. <br>
Cached match results can be reused by Cached and NCached
patterns. Note that before processing each new input line,
previous content of the pattern match cache is cleared. <br>
Also note that a successful pattern match is cached even if
the subsequent context expression evaluation yields FALSE
(see INPUT PROCESSING AND TIMING section for more <br>
information).</p>

<p style="margin-top: 1em">For example, consider the
following pattern definition:</p>

<p style="margin-top: 1em">ptype=regexp <br>
pattern=(?i)(.mydomain).*printer: tonerink low <br>
varmap=printer_toner_or_ink_low; message=0; hostname=1</p>

<p style="margin-top: 1em">The pattern matches
&quot;printer: toner/ink low&quot; messages in a case
insensitive manner from printers belonging to .mydomain.
Note that the printer hostname is assigned to $1 <br>
and $+{hostname}, while the whole message line is assigned
to $0 and $+{message}. The name of the file where message
line came from is assigned to $+{_inputsrc}. Also, <br>
these variables and their values are stored to the pattern
match cache under the name
&quot;printer_toner_or_ink_low&quot;.</p>

<p style="margin-top: 1em">The following pattern definition
produces a match if the last two input lines are AAA and
BBB:</p>

<p style="margin-top: 1em">ptype=regexp2 <br>
pattern=^AAA0BB$ <br>
varmap=aaa_bbb</p>

<p style="margin-top: 1em">Note that with the --nojointbuf
option the pattern only matches if the matching lines are
coming from the *same* input file, while the --jointbuf
option lifts that <br>
restriction.</p>

<p style="margin-top: 1em">In the case of a match, $0 is
set to &quot;AAA&lt;NEWLINE&gt;BBB&quot; and $+{_inputsrc}
to file name(s) for matching lines. Also, these
variable-value pairs are cached under the name <br>
&quot;aaa_bbb&quot;.</p>

<p style="margin-top: 1em">PerlFunc[N] <br>
pattern is a Perl function for matching the last N input
lines L1, L2, ..., LN. The Perl function is compiled at SEC
startup with the Perl eval() function, and eval() must <br>
return a code reference for the pattern to be valid (see
also PERL INTEGRATION section). The function is called in
Perl list context, and with the --jointbuf option, <br>
lines L1, L2, ..., LN and the names of corresponding input
files F1, F2, ..., FN are passed to the function as
parameters:</p>

<p style="margin-top: 1em">function(L1, L2, ..., LN, F1,
F2, ..., FN)</p>

<p style="margin-top: 1em">Note that with the --nojointbuf
option, the function is called with a single file name
parameter F, since lines L1, ..., LN are coming from the
same input file:</p>

<p style="margin-top: 1em">function(L1, L2, ..., LN, F)</p>

<p style="margin-top: 1em">Also note that if the input line
is a synthetic event, the input file name is Perl undefined
value.</p>

<p style="margin-top: 1em">If the function returns several
values or a single value that is true in Perl boolean
context, the pattern matches. If the function returns no
values or a single value <br>
that is false in Perl boolean context (0, empty string or
undefined value), the pattern does not match. If the pattern
matches, return values will be assigned to numbered <br>
match variables ($1, $2, etc.). Like with RegExp patterns,
the $0 variable is set to matching input line(s), the
$+{_inputsrc} variable is set to input file name(s), and
<br>
named match variables can be created from variable maps. For
example, consider the following pattern definition:</p>

<p style="margin-top: 1em">ptype=perlfunc2 <br>
pattern=sub { return ($_[0] cmp $_[1]); }</p>

<p style="margin-top: 1em">The pattern compares last two
input lines in a stringwise manner ($_[1] holds the last
line and $_[0] the preceding one), and matches if the lines
are different. Note that <br>
the result of the comparison is assigned to $1, while two
matching lines are concatenated (with the newline character
between them) and assigned to $0. The file name(s) <br>
for matching lines are assigned to $+{_inputsrc}.</p>

<p style="margin-top: 1em">The following pattern produces a
match for any line, and sets $1, $2 and $3 variables to
strings &quot;abc&quot;, &quot;def&quot; and
&quot;ghi&quot;, respectively (also, $0 is set to the whole
input <br>
line and $+{_inputsrc} to the input file name):</p>

<p style="margin-top: 1em">ptype=perlfunc <br>
pattern=sub { return (&quot;abc&quot;, &quot;def&quot;,
&quot;ghi&quot;); }</p>

<p style="margin-top: 1em">The following pattern definition
produces a match if the input line is not a synthetic event
and contains either the string &quot;abc&quot; or
&quot;def&quot;. The $0 variable is set to the <br>
matching line, while $1, $+{file} and $+{_inputsrc} are set
to the name of the input file:</p>

<p style="margin-top: 1em">ptype=perlfunc <br>
pattern=sub { if (defined($_[1]) &amp;&amp; $_[0] =~
/abc|def/) { return $_[1]; } return 0; } <br>
varmap= file=1</p>

<p style="margin-top: 1em">Finally, if a function pattern
returns a single value which is a reference to a Perl hash,
named match variables are created from key-value pairs in
the hash. For example, <br>
the following pattern matches a line if it contains either
the string &quot;three&quot; or &quot;four&quot;. Apart from
setting $0 and $+{_inputsrc}, the pattern also creates match
variables <br>
$+{three} and $+{four}, and sets them to 3 and 4,
respectively:</p>

<p style="margin-top: 1em">ptype=perlfunc <br>
pattern=sub { my(%hash); if ($_[0] !~ /three|four/) { return
0; } $hash{&quot;three&quot;} = 3; $hash{&quot;four&quot;} =
4; return hash; }</p>

<p style="margin-top: 1em">Cached pattern is a name that is
searched in the pattern match cache (entries are stored into
the cache with the varmap* fields). If an entry with the
given name is found in the <br>
cache, the pattern matches, and match variables and values
are retrieved from the cache. For example, if the input line
matches the following pattern</p>

<p style="margin-top: 1em">ptype=perlfunc <br>
pattern=sub { if (defined($_[1]) &amp;&amp; $_[0] =~
/abc|def/) { return $_[1]; } return 0; } <br>
varmap=abc_or_def_found; file=1</p>

<p style="margin-top: 1em">then the entry
&quot;abc_or_def_found&quot; is created in the pattern match
cache. Therefore, the pattern</p>

<p style="margin-top: 1em">ptype=cached <br>
pattern=abc_or_def_found</p>

<p style="margin-top: 1em">will also produce a match for
this input line, and set the $0, $1, $+{file}, and
$+{_inputsrc} variables to values from the previous
match.</p>

<p style="margin-top: 1em">NSubStr[N] <br>
like SubStr[N], except that the result of the match is
negated. Note that this pattern type does not support match
variables.</p>

<p style="margin-top: 1em">NRegExp[N] <br>
like RegExp[N], except that the result of the match is
negated and variable maps are not supported. Note that the
only match variables supported by this pattern type are <br>
$0 and $+{_inputsrc}.</p>

<p style="margin-top: 1em">NPerlFunc[N] <br>
like PerlFunc[N], except that the result of the match is
negated and variable maps are not supported. Note that the
only match variables supported by this pattern type are <br>
$0 and $+{_inputsrc}.</p>

<p style="margin-top: 1em">NCached <br>
like Cached, except that the result of the match is negated.
Note that this pattern type does not support match
variables.</p>

<p style="margin-top: 1em">TValue pattern is a truth value,
with TRUE and FALSE being legitimate values. TRUE always
matches an input line, while FALSE never matches anything.
Note that this pattern type <br>
does not support match variables.</p>

<p style="margin-top: 1em">When match variables are
substituted, each &quot;$$&quot; sequence is interpreted as
a literal dollar sign ($) which allows for masking match
variables. For example, the string &quot;Received <br>
$$1&quot; becomes &quot;Received $1&quot; after
substitution, while &quot;Received $$$1&quot; becomes
&quot;Received $&lt;value_of_1st_var&gt;&quot;. In order to
disambiguate numbered match variables from the following
<br>
text, variable number must be enclosed in braces. For
example, the string &quot;Received ${1}0&quot; becomes
&quot;Received &lt;value_of_1st_var&gt;0&quot; after
substitution, while the string &quot;Received <br>
$10&quot; would become &quot;Received
&lt;value_of_10th_var&gt;&quot;.</p>

<p style="margin-top: 1em">If the match variable was not
set by the pattern, it is substituted with an empty string
(i.e., a zero-width string). Thus the string &quot;Received
$10!&quot; becomes &quot;Received !&quot; after <br>
substitution if the pattern did not set $10. (Note that
prior to SEC-2.6, unset variables were *not*
substituted.)</p>

<p style="margin-top: 1em">In the current version of SEC,
names of $+{name} match variables must comply with the
following naming convention -- the first character can be a
letter or underscore, while <br>
remaining characters can be letters, digits, underscores and
exclamation marks (!). However, when setting named match
variables from a pattern, it is recommended to begin the
<br>
variable name with a letter, since names of special
automatically created variables begin with an underscore
(e.g., $+{_inputsrc}).</p>

<p style="margin-top: 1em">After the pattern has matched an
event and match variables have been set, it is also possible
to refer to previously cached match variables with the
syntax $:{entryname:varname}, <br>
where entryname is the name of the pattern match cache
entry, and varname is the name of the variable stored under
the entry. For example, if the variable $+{ip} has been
previ&acirc; <br>
ously cached under the entry &quot;SSH&quot;, it can be
referred as $:{SSH:ip}. For the reasons of efficiency, the
$:{entryname:varname} syntax is not supported for fast
pattern types <br>
which do not set match variables (i.e., SubStr, NSubStr,
NCached and TValue).</p>

<p style="margin-top: 1em">Note that since Pair and
PairWithWindow rules have two patterns, match variables of
the first pattern are shadowed for some rule fields when the
second pattern matches and sets <br>
variables. In order to refer to shadowed variables, their
names must begin with % instead of $ (e.g., %1 refers to
match variable $1 set by the first pattern). However, the
use <br>
of the %-prefix is only valid under the following
circumstances -- *both* pattern types support match
variables *and* in the given rule field match variables from
*both* patterns <br>
can be used.</p>

<p style="margin-top: 1em">The %-prefixed match variables
are masked with the &quot;%%&quot; sequence (like regular
match variables with &quot;$$&quot;). Similarly, the braces
can be used for disambiguating the %-prefixed <br>
variables from the following text.</p>

<p style="margin-top: 1em">Finally, note that the second
pattern of Pair and PairWithWindow rules may contain match
variables if the second pattern is of type SubStr, NSubStr,
Regexp, or NRegExp. The vari&acirc; <br>
ables are substituted at runtime with the values set by the
first pattern. If the pattern is a regular expression, all
special characters inside substituted values are masked <br>
with the Perl quotemeta() function and the final expression
is checked for correctness.</p>

<p style="margin-top: 1em">CONTEXTS AND CONTEXT EXPRESSIONS
<br>
A SEC context is a memory based entity which has one or more
names, a lifetime, and an event store. Also, an action list
can be set up for a context which is executed immediately
<br>
before the context expires.</p>

<p style="margin-top: 1em">For example, the action create
MYCONTEXT 3600 (report MYCONTEXT /bin/mail root@localhost)
creates the context MYCONTEXT which has a lifetime of 3600
seconds and empty event <br>
store. Also, immediately before MYCONTEXT expires and is
dropped from memory, the action report MYCONTEXT /bin/mail
root@localhost is executed which mails the event store of
<br>
MYCONTEXT to root@localhost.</p>

<p style="margin-top: 1em">Contexts can be used for event
aggregation and reporting. Suppose the following actions are
executed in this order:</p>

<p style="margin-top: 1em">create MYCONTEXT <br>
add MYCONTEXT This is a test <br>
alias MYCONTEXT MYALIAS <br>
add MYALIAS This is another test <br>
report MYCONTEXT /bin/mail root@localhost <br>
delete MYALIAS</p>

<p style="margin-top: 1em">The first action creates the
context MYCONTEXT with infinite lifetime and empty event
store. The second action appends the string &quot;This is a
test&quot; to the event store of MYCON&acirc; <br>
TEXT. The third action sets up an alias name MYALIAS for the
context (names MYCONTEXT and MYALIAS refer to the same
context data structure). The fourth action appends the
string <br>
&quot;This is another test&quot; to the event store of the
context. The fifth action writes the lines</p>

<p style="margin-top: 1em">This is a test <br>
This is another test</p>

<p style="margin-top: 1em">to the standard input of the
/bin/mail root@localhost command. The sixth action deletes
the context data structure from memory and drops its names
MYCONTEXT and MYALIAS.</p>

<p style="margin-top: 1em">Since contexts are accessible
from all rules and event correlation operations, they can be
used for data sharing and joining several rules into one
event correlation scheme. In <br>
order to check for the presence of contexts from rules,
context expressions can be employed.</p>

<p style="margin-top: 1em">Context expressions are boolean
expressions that are defined with the context* rule fields.
Context expressions can be used for restricting the matches
produced by patterns, <br>
since if the expression evaluates FALSE, the rule will not
match an input event.</p>

<p style="margin-top: 1em">The context expression accepts
context names, Perl miniprograms, Perl functions, and
pattern match cache lookups as operands. These operands can
be combined with the following <br>
operators: <br>
! - logical NOT, <br>
&amp;&amp; - short-circuit logical AND, <br>
|| - short-circuit logical OR. <br>
In addition, parentheses can be used for grouping
purposes.</p>

<p style="margin-top: 1em">If the operand does not contain
any special operators (such as -&gt; or :&gt;, see below),
it is treated as a context name. Context name operands may
contain match variables, but may <br>
not contain whitespace. If the context name refers to an
existing context, the operand evaluates TRUE, otherwise it
evaluates FALSE.</p>

<p style="margin-top: 1em">For example, consider the
following rule sequence:</p>

<p style="margin-top: 1em">type=Single <br>
ptype=RegExp <br>
pattern=Test: (+) <br>
desc=test <br>
action=create CONT_$1</p>

<p style="margin-top: 1em">type=Single <br>
ptype=RegExp <br>
pattern=Test2: (+) (+) <br>
context=CONT_$1 &amp;&amp; CONT_$2 <br>
desc=test <br>
action=write - Both $1 and $2 have been seen in the past</p>

<p style="margin-top: 1em">If the following input lines
appear in this order</p>

<p style="margin-top: 1em">Test: 19 <br>
Test: 261 <br>
Test2: 19 787 <br>
Test: 787 <br>
Test2: 787 261</p>

<p style="margin-top: 1em">the first input line matches the
first rule which creates the context CONT_19, and similarly,
the second input line triggers the creation of the context
CONT_261. The third <br>
input line &quot;Test2: 19 787&quot; matches the regular
expression</p>

<p style="margin-top: 1em">Test2: (+) (+)</p>

<p style="margin-top: 1em">but does not match the second
rule, since the boolean expression</p>

<p style="margin-top: 1em">CONT_19 &amp;&amp; CONT_787</p>

<p style="margin-top: 1em">evaluates FALSE (context CONT_19
exists, but context CONT_787 doesn&rsquo;t). The fourth
input line matches the first rule which creates the context
CONT_787. The fifth input line <br>
&quot;Test2: 787 261&quot; matches the second rule, since
the boolean expression</p>

<p style="margin-top: 1em">CONT_787 &amp;&amp; CONT_261</p>

<p style="margin-top: 1em">evaluates TRUE (both context
CONT_787 and context CONT_261 exist), and therefore the
string &quot;Both 787 and 261 have been seen in the
past&quot; is written to standard output.</p>

<p style="margin-top: 1em">If the context expression
operand contains the arrow operator (-&gt;), the text
following the arrow must be a valid Perl function definition
that is compiled at SEC startup with the <br>
Perl eval() function. The eval() must return a code
reference (see also PERL INTEGRATION section for more
information). If any text precedes the arrow, it is treated
as a list of <br>
parameters for the function. Parameters must be separated by
whitespace and may contain match variables. In order to
evaluate the context expression operand, the Perl function
<br>
is called in the Perl scalar context. If the return value of
the function is true in the Perl boolean context, the
operand evaluates TRUE, otherwise it evaluates FALSE.</p>

<p style="margin-top: 1em">For example, the following rule
matches an SSH login failure event if the login attempt
comes from a privileged port of the client host:</p>

<p style="margin-top: 1em">type=Single <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for () from [.]+ port (+) ssh2 <br>
context=$2 -&gt; ( sub { $_[0] &lt; 1024 } ) <br>
desc=SSH login failure for $1 priv port $2 <br>
action=write - SSH login failure for user $1 from a
privileged port $2</p>

<p style="margin-top: 1em">When the following message from
SSH daemon appears</p>

<p style="margin-top: 1em">Dec 16 16:24:59 myserver
sshd[13685]: Failed password for risto from 10.12.2.5 port
41063 ssh2</p>

<p style="margin-top: 1em">the regular expression of the
rule matches this message, and the value of the $2 match
variable (41063) is passed to the Perl function</p>

<p style="margin-top: 1em">sub { $_[0] &lt; 1024 }</p>

<p style="margin-top: 1em">This function returns true if
its input parameter is less than 1024 and false otherwise,
and therefore the above message will not match the rule.
However, the following message</p>

<p style="margin-top: 1em">Dec 16 16:25:17 myserver
sshd[13689]: Failed password for risto from 10.12.2.5 port
1023 ssh2</p>

<p style="margin-top: 1em">matches the rule, and the string
&quot;SSH login failure for user risto from a privileged
port 1023&quot; is written to standard output.</p>

<p style="margin-top: 1em">As another example, the
following context expression evaluates TRUE if the
/var/log/messages file does not exist or was last modified
more than 1 hour ago (note that the Perl <br>
function takes no parameters):</p>

<p style="margin-top: 1em">context= -&gt; ( sub { my(@stat)
= stat(&quot;/var/log/messages&quot;); return
(!scalar(@stat) || time() - $stat[9] &gt; 3600); } )</p>

<p style="margin-top: 1em">If the context expression
operand contains the :&gt; operator, the text that follows
:&gt; must be a valid Perl function definition that is
compiled at SEC startup with the Perl eval() <br>
function. The eval() must return a code reference (see also
PERL INTEGRATION section for more information). If any text
precedes the :&gt; operator, it is treated as a list of <br>
parameters for the function. Parameters must be separated by
whitespace and may contain match variables. It is assumed
that each parameter is a name of an entry in the pattern
<br>
match cache. If an entry with the given name does not exist,
Perl undefined value is passed to the function. If an entry
with the given name exists, a reference to the entry is <br>
passed to the Perl function. Internally, each pattern match
cache entry is implemented as a Perl hash which contains all
match variables for the given entry. In the hash, each <br>
key-value pair represents some variable name and value,
e.g., if cached match variable $+{ip} is holding 10.1.1.1,
the hash contains the value 10.1.1.1 with the key ip. In
order <br>
to evaluate the context expression operand, the Perl
function is called in the Perl scalar context. If the return
value of the function is true in the Perl boolean context,
the <br>
operand evaluates TRUE, otherwise it evaluates FALSE.</p>

<p style="margin-top: 1em">For example, consider the
following rule sequence:</p>

<p style="margin-top: 1em">type=Single <br>
ptype=RegExp <br>
pattern=sshd: (?&lt;status&gt;Accepted|Failed) .+ for
(?&lt;invuser&gt;invalid user )?(?&lt;user&gt;) from
(?&lt;ip&gt;[.]+) port (?&lt;port&gt;+) ssh2 <br>
varmap=SSH <br>
continue=TakeNext <br>
desc=parse SSH login events and pass them to following rules
<br>
action=none</p>

<p style="margin-top: 1em">type=Single <br>
ptype=Cached <br>
pattern=SSH <br>
context=SSH :&gt; ( sub { $_[0]-&gt;{&quot;status&quot;} eq
&quot;Failed&quot; &amp;&amp; $_[0]-&gt;{&quot;port&quot;}
&lt; 1024 &amp;&amp;
defined($_[0]-&gt;{&quot;invuser&quot;}) } ) <br>
desc=Probe of invalid user $+{user} from privileged port of
$+{ip} <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail -s &rsquo;SSH
alert&rsquo; root@localhost</p>

<p style="margin-top: 1em">The first rule matches and
parses SSH login messages, and stores parsing results to the
pattern match cache under the name SSH. The pattern of the
second rule (defined with <br>
ptype=Cached and pattern=SSH) matches any input event for
which the entry SSH has been previously created in the
pattern match cache (in other words, the event has been
recog&acirc; <br>
nized and parsed as an SSH login message). For each matching
event, the second rule passes the reference to the SSH cache
entry to the Perl function</p>

<p style="margin-top: 1em">sub {
$_[0]-&gt;{&quot;status&quot;} eq &quot;Failed&quot;
&amp;&amp; $_[0]-&gt;{&quot;port&quot;} &lt; 1024 &amp;&amp;
defined($_[0]-&gt;{&quot;invuser&quot;}) }</p>

<p style="margin-top: 1em">The function checks the values
of $+{status}, $+{port}, and $+{invuser} match variables
under the SSH entry, and returns true if $+{status} equals
to the string &quot;Failed&quot; (i.e., <br>
login attempt failed), the value of $+{port} is less than
1024, and $+{invuser} holds a defined value (i.e., user
account does not exist). If the function (and thus context
<br>
expression) evaluates TRUE, the rule sends a warning e-mail
to root@localhost that a non-existing user account was
probed from a privileged port of a client host.</p>

<p style="margin-top: 1em">If the context expression
operand begins with the varset keyword, the following string
is treated as a name of an entry in the pattern match cache.
The operand evaluates TRUE if <br>
the given entry exists, and FALSE otherwise.</p>

<p style="margin-top: 1em">For example, the following
context expression definition evaluates TRUE if the pattern
match cache entry SSH exists and under this entry, the value
of the match variable $+{user} <br>
equals to the string &quot;risto&quot;:</p>

<p style="margin-top: 1em">context=varset SSH &amp;&amp;
SSH :&gt; ( sub { $_[0]-&gt;{&quot;user&quot;} eq
&quot;risto&quot; } )</p>

<p style="margin-top: 1em">If the context expression
operand begins with the equal sign (=), the following text
must be a Perl miniprogram which is a valid parameter for
the Perl eval() function. The <br>
miniprogram may contain match variables. In order to
evaluate the Perl miniprogram operand, it will be compiled
and executed by calling the Perl eval() function in the Perl
<br>
scalar context (see also PERL INTEGRATION section). If the
return value from eval() is true in the Perl boolean
context, the operand evaluates TRUE, otherwise it evaluates
<br>
FALSE. Please note that unlike Perl functions of -&gt; and
:&gt; operators which are compiled once at SEC startup, Perl
miniprograms are compiled before each execution, and their
eval&acirc; <br>
uation is thus considerably more expensive.</p>

<p style="margin-top: 1em">For example, the following
context expression evaluates TRUE when neither the context
C1 nor the context C2 exists and the value of the $1
variable equals to the string <br>
&quot;myhost.mydomain&quot;:</p>

<p style="margin-top: 1em">context=!(C1 || C2) &amp;&amp;
=(&quot;$1&quot; eq &quot;myhost.mydomain&quot;)</p>

<p style="margin-top: 1em">Since &amp;&amp; is a
short-circuiting operator, the Perl code</p>

<p style="margin-top: 1em">&quot;$1&quot; eq
&quot;myhost.mydomain&quot;</p>

<p style="margin-top: 1em">is *not* evaluated if either C1
or C2 exists.</p>

<p style="margin-top: 1em">Note that since Perl functions
and miniprograms may contain strings that clash with context
expression operators (e.g., &rsquo;!&rsquo;), it is
recommended to enclose them in parentheses, <br>
e.g.,</p>

<p style="margin-top: 1em">context=$1 $2 -&gt; ( sub {
$_[0] != $_[1] } )</p>

<p style="margin-top: 1em">context= =({my($temp) = 0;
!$temp;})</p>

<p style="margin-top: 1em">Also, if function parameter
lists contain such strings, they should be enclosed in
parentheses in the similar way:</p>

<p style="margin-top: 1em">context=($1! $2) -&gt; ( sub {
$_[0] eq $_[1] } )</p>

<p style="margin-top: 1em">If the whole context expression
is enclosed in square brackets [], e.g., [MYCONTEXT1
&amp;&amp; !MYCONTEXT2], SEC evaluates the expression
*before* pattern matching (normally, the pat&acirc; <br>
tern is matched with input line(s) first, so that match
variables would be initialized and substituted before the
expression is evaluated). However, if the expression does
not <br>
contain match variables and many input events are known to
match the pattern but not the expression, the []-operator
could save substantial amount of CPU time.</p>

<p style="margin-top: 1em">ACTIONS, ACTION LISTS AND ACTION
LIST VARIABLES <br>
Action lists are defined with the action* rule fields. An
action list consists of action definitions that are
separated by semicolons. Each action definition begins with
a key&acirc; <br>
word specifying the action type. Depending on the action
type, parameters may follow, and non-constant parameters may
contain match variables. For instance, if the $1 and $2 <br>
match variables have the values &quot;test1&quot; and
&quot;the second test&quot;, respectively, the action create
MYCONT_$1 60 creates the context MYCONT_test1 with the
lifetime of 60 seconds, <br>
while the action write - The names of tests: $1, $2 writes
the string &quot;The names of tests: test1, the second
test&quot; to standard output. In order to use semicolons
inside a non- <br>
constant parameter, the parameter must be enclosed in
parentheses (the outermost set of parentheses will be
removed by SEC during configuration file parsing).</p>

<p style="margin-top: 1em">For example, the following
action list consists of delete and shellcmd actions:</p>

<p style="margin-top: 1em">action=delete MYCONTEXT;
shellcmd (rm /tmp/sec1.tmp; rm /tmp/sec2.tmp)</p>

<p style="margin-top: 1em">The delete action deletes the
context MYCONTEXT, while the shellcmd action executes the
command line rm /tmp/sec1.tmp; rm /tmp/sec2.tmp. Since the
command line contains a semi&acirc; <br>
colon, it has been enclosed in parentheses, since otherwise
the semicolon would be mistakenly considered a separator
between two actions.</p>

<p style="margin-top: 1em">Apart from match variables, SEC
supports action list variables in action lists which
facilitate data sharing between actions and Perl
integration. Each action list variable has a <br>
name which must begin with a letter and consist of letters,
digits and underscores. Names of built-in variables usually
start with a punctuation mark (.), so that they can be <br>
distinguished from user defined variables. In order to refer
to an action list variable, its name must be prefixed by a
percent sign (%). Unlike match variables, action list <br>
variables can only be used in action lists and they are
substituted with their values immediately before the action
list execution. Also, action list variables continue to
exist <br>
after the current action list has been executed and can be
employed in action lists of other rules.</p>

<p style="margin-top: 1em">The following action list
variables are predefined by SEC:</p>

<p style="margin-top: 1em">%s operation description string
(the value of the desc field after match variables have been
substituted with their values). Note that for the action2
field of Pair and <br>
PairWithWindow rules, the %s variable is set by evaluating
the desc2 field of the rule.</p>

<p style="margin-top: 1em">%t the time in human-readable
format, as returned by the Perl localtime() function in the
Perl scalar context (e.g., Fri Feb 19 17:54:18 2016).</p>

<p style="margin-top: 1em">%u the time in seconds since
Epoch, as returned by the time(2) system call.</p>

<p style="margin-top: 1em">%.sec number of seconds after
the minute, in the range 00-59 (the value consists of two
digits and is zero padded on the left).</p>

<p style="margin-top: 1em">%.min number of minutes after
the hour, in the range 00-59 (the value consists of two
digits and is zero padded on the left).</p>

<p style="margin-top: 1em">%.hour number of hours past
midnight, in the range 00-23 (the value consists of two
digits and is zero padded on the left).</p>

<p style="margin-top: 1em">%.hmsstr <br>
the time in HH:MM:SS format (hours, minutes and seconds
separated by colons, e.g., 09:32:04 or 18:06:02).</p>

<p style="margin-top: 1em">%.mday day of the month, in the
range 01-31 (the value consists of two digits and is zero
padded on the left).</p>

<p style="margin-top: 1em">%.mdaystr <br>
day of the month as a string (the value consists of two
characters and is space padded on the left, e.g., &quot;
1&quot;, &quot; 4&quot;, &quot; 9&quot;, or
&quot;25&quot;).</p>

<p style="margin-top: 1em">%.mon month, in the range 01-12
(the value consists of two digits and is zero padded on the
left).</p>

<p style="margin-top: 1em">%.monstr <br>
abbreviated name of the month according to the current
locale, as returned by the %b specification of the
strftime(3) library call (e.g., Jan, May, or Sep).</p>

<p style="margin-top: 1em">%.year year (e.g., 1998 or
2016).</p>

<p style="margin-top: 1em">%.wday day of the week, in the
range 0-6 (0 denotes Sunday).</p>

<p style="margin-top: 1em">%.wdaystr <br>
abbreviated name of the day of the week according to the
current locale, as returned by the %a specification of the
strftime(3) library call (e.g., Mon, Wed, or Sat).</p>

<p style="margin-top: 1em">%.tzname <br>
name of the timezone according to the current locale, as
returned by the %Z specification of the strftime(3) library
call (e.g., UTC or EET).</p>

<p style="margin-top: 1em">%.tzoff <br>
timezone offset from UTC, as returned by the %z
specification of the strftime(3) library call (e.g., -0500
or +0200).</p>

<p style="margin-top: 1em">%.tzoff2 <br>
timezone offset from UTC in +hh:mm/-hh:mm format (e.g.,
-05:00 or +02:00), provided that the %z specification of the
strftime(3) library call returns the value in <br>
+hhmm/-hhmm format (if the value does not follow this
format, %.tzoff2 is set to an empty string).</p>

<p style="margin-top: 1em">%.nl newline character.</p>

<p style="margin-top: 1em">%.cr carriage return
character.</p>

<p style="margin-top: 1em">%.tab tabulation character.</p>

<p style="margin-top: 1em">%.chr0, ..., %.chr31 <br>
ASCII 0..31 control characters (e.g., %.chr7 is bell and
%.chr12 is form feed character).</p>

<p style="margin-top: 1em">For example, the following
action list assigns the current time in human readable
format and the content of the $0 match variable to the %text
action list variable, and mails the <br>
value of %text to root@localhost:</p>

<p style="margin-top: 1em">action=assign %text %t: $0; pipe
&rsquo;%text&rsquo; /bin/mail root@localhost</p>

<p style="margin-top: 1em">If the action list is executed
at Nov 19 10:58:51 2015 and the $0 match variable has the
value &quot;This is a test event&quot;, the assign action
sets the %text action list variable to <br>
the string &quot;Thu Nov 19 10:58:51 2015: This is a test
event&quot;, while the pipe action mails this string to
root@localhost. Note that unlike match variables, action
list variables <br>
have a global scope, and accessing the value of the %text
variable in action lists of other rules will thus yield the
string &quot;Thu Nov 19 10:58:51 2015: This is a test
event&quot; <br>
(until another value is assigned to %text).</p>

<p style="margin-top: 1em">In order to disambiguate the
variable from the following text, the variable name must be
enclosed in braces. For example, the following action</p>

<p style="margin-top: 1em">action=write -
%{.year}-%{.mon}-%{.mday}T%{.hmsstr}%{.tzoff2}</p>

<p style="margin-top: 1em">writes a timestamp in ISO 8601
format to standard output, e.g., 2016-02-24T07:34:01+02:00
(replacing %{.mday} with %.mday in the above action would
mistakenly create a reference <br>
to %.mdayT variable).</p>

<p style="margin-top: 1em">When action list variables are
substituted with their values, each sequence &quot;%%&quot;
is interpreted as a literal percent sign (%) which allows
for masking the variables. For example, <br>
the string &quot;s%%t&quot; becomes &quot;s%t&quot; after
substitution, not &quot;s%&lt;timestamp&gt;&quot;.</p>

<p style="margin-top: 1em">However, note that if %-prefixed
match variables are supported for the action2 field of the
Pair or PairWithWindow rule, the sequence &quot;%%%&quot;
must be used in action2 for masking a <br>
variable, since the string goes through *two* variable
substitution rounds (first for %-prefixed match variables
and then for action list variables, e.g., the string
&quot;s%%%t&quot; <br>
first becomes &quot;s%%t&quot; and finally
&quot;s%t&quot;).</p>

<p style="margin-top: 1em">Whenever a rule field goes
through several substitution rounds, the $ or % characters
are masked inside values substituted during earlier rounds,
in order to avoid unwanted side <br>
effects during later rounds.</p>

<p style="margin-top: 1em">If the action list variable has
not been set, it is substituted with an empty string (i.e.,
a zero-width string). Thus the string &quot;Value of A is:
%a&quot; becomes &quot;Value of A is: &quot; <br>
after substitution if the variable %a is unset. (Note that
prior to SEC-2.6, unset variables were *not*
substituted.)</p>

<p style="margin-top: 1em">Finally, the values are
substituted as strings, therefore values of other types
(e.g., references) lose their original meaning, unless
explicitly noted otherwise (e.g., if a Perl <br>
function reference is stored to an action list variable, the
function can later be invoked through this variable with the
call action).</p>

<p style="margin-top: 1em">SEC supports the following
actions (optional parameters are enclosed in square
brackets):</p>

<p style="margin-top: 1em">none No action.</p>

<p style="margin-top: 1em">logonly [&lt;string&gt;] <br>
Message &lt;string&gt; is logged to destinations given with
the --log and --syslog options. The level of the log message
is set to 4 (see the --debug option for more information
<br>
on log message levels). Default value for &lt;string&gt; is
%s.</p>

<p style="margin-top: 1em">write &lt;filename&gt;
[&lt;string&gt;] <br>
String &lt;string&gt; with a terminating newline is written
to the file &lt;filename&gt; (&lt;filename&gt; may not
contain whitespace). File may be a regular file, named pipe,
or standard <br>
output (denoted by -). If the file is a regular file,
&lt;string&gt; is appended to the end of the file. If the
file does not exist, it is created as a regular file before
<br>
writing. Note that the file will not be closed after the
action completes, and the following write actions will
access an already open file. However, several signals <br>
cause the file to be closed and reopened (see SIGNALS
section for more information). Default value for
&lt;string&gt; is %s.</p>

<p style="margin-top: 1em">writen &lt;filename&gt;
[&lt;string&gt;] <br>
Similar to the write action, except that the string
&lt;string&gt; is written without a terminating newline.
Note that write and writen actions share the same filehandle
for <br>
accessing the file.</p>

<p style="margin-top: 1em">closef &lt;filename&gt; <br>
Close the file &lt;filename&gt; that has been previously
opened by the write or writen action (&lt;filename&gt; may
not contain whitespace).</p>

<p style="margin-top: 1em">owritecl &lt;filename&gt;
[&lt;string&gt;] <br>
Similar to the write action, except that the file
&lt;filename&gt; is opened and closed at each write. Also,
the string &lt;string&gt; is written without a terminating
newline. If <br>
the file has already been opened by a previous write action,
owritecl does not use existing filehandle, but opens and
closes the file separately.</p>

<p style="margin-top: 1em">udgram &lt;filename&gt;
[&lt;string&gt;] <br>
String &lt;string&gt; is written to the UNIX datagram socket
&lt;filename&gt; (&lt;filename&gt; may not contain
whitespace). Note that the socket will not be closed after
the action com&acirc; <br>
pletes, and the following udgram actions will access an
already open socket. However, several signals cause the
socket to be closed and reopened (see SIGNALS section for
<br>
more information). Default value for &lt;string&gt; is
%s.</p>

<p style="margin-top: 1em">closeudgr &lt;filename&gt; <br>
Close the UNIX datagram socket &lt;filename&gt; that has
been previously opened by the udgram action
(&lt;filename&gt; may not contain whitespace).</p>

<p style="margin-top: 1em">ustream &lt;filename&gt;
[&lt;string&gt;] <br>
String &lt;string&gt; is written to the UNIX stream socket
&lt;filename&gt; (&lt;filename&gt; may not contain
whitespace). Note that the socket will not be closed after
the action com&acirc; <br>
pletes, and the following ustream actions will access an
already open socket. However, several signals cause the
socket to be closed and reopened (see SIGNALS section for
<br>
more information). Default value for &lt;string&gt; is
%s.</p>

<p style="margin-top: 1em">closeustr &lt;filename&gt; <br>
Close the UNIX stream socket &lt;filename&gt; that has been
previously opened by the ustream action (&lt;filename&gt;
may not contain whitespace).</p>

<p style="margin-top: 1em">udpsock
&lt;host&gt;:&lt;port&gt; [&lt;string&gt;] <br>
String &lt;string&gt; is sent to the UDP port &lt;port&gt;
of the host &lt;host&gt;. Note that the UDP socket which is
used for communication will not be closed after the action
completes, <br>
and the following udpsock actions for the same remote peer
will use an already existing socket. However, several
signals cause the socket to be closed and recreated (see
<br>
SIGNALS section for more information). Default value for
&lt;string&gt; is %s.</p>

<p style="margin-top: 1em">closeudp
&lt;host&gt;:&lt;port&gt; <br>
Close the UDP socket for peer &lt;host&gt;:&lt;port&gt; that
has been previously opened by the udpsock action.</p>

<p style="margin-top: 1em">tcpsock
&lt;host&gt;:&lt;port&gt; [&lt;string&gt;] <br>
String &lt;string&gt; is sent to the TCP port &lt;port&gt;
of the host &lt;host&gt;. The timeout value given with the
--socket-timeout option determines for how many seconds SEC
will <br>
attempt to establish a connection to the remote peer. If the
connection establishment does not succeed immediately, the
tcpsock action buffers &lt;string&gt; in memory for later
<br>
sending to the remote peer. Note that the relevant TCP
socket will not be closed after &lt;string&gt; has been
transmitted, and the following tcpsock actions for the same
peer <br>
will use an already existing socket. However, several
signals cause the socket to be closed and recreated (see
SIGNALS section for more information). Default value for
<br>
&lt;string&gt; is %s.</p>

<p style="margin-top: 1em">closetcp
&lt;host&gt;:&lt;port&gt; <br>
Close the TCP socket for peer &lt;host&gt;:&lt;port&gt; that
has been previously opened by the tcpsock action.</p>

<p style="margin-top: 1em">shellcmd &lt;cmdline&gt; <br>
Fork a process for executing command line &lt;cmdline&gt;.
If the --quoting option was specified and &lt;cmdline&gt;
contains %s variables, the value of %s is quoted with single
<br>
quotes before substituting it into &lt;cmdline&gt;; if the
value of %s contains single quotes, they are masked with
backslashes (e.g., abc is converted to &rsquo;abc&rsquo; and
aa&rsquo;bb is <br>
converted to &rsquo;aa&rsquo;&acute;&rsquo;bb&rsquo;). For
additional information, see INTERPROCESS COMMUNICATION
section.</p>

<p style="margin-top: 1em">spawn &lt;cmdline&gt; <br>
Similar to the shellcmd action, except that each line from
the standard output of &lt;cmdline&gt; becomes a synthetic
event and will be treated like a line from input file (see
<br>
the event action for more information). If the --intcontexts
command line option is given, internal context
_INTERNAL_EVENT is set up before each synthetic event is
pro&acirc; <br>
cessed (see INTERNAL EVENTS AND CONTEXTS section for more
information).</p>

<p style="margin-top: 1em">cspawn &lt;name&gt;
&lt;cmdline&gt; <br>
Similar to the spawn action, except that if the
--intcontexts command line option is given, internal context
&lt;name&gt; is set up for each synthetic event.</p>

<p style="margin-top: 1em">pipe
&rsquo;[&lt;string&gt;]&rsquo; [&lt;cmdline&gt;] <br>
Fork a process for executing command line &lt;cmdline&gt;.
The string &lt;string&gt; with a terminating newline is
written to the standard input of &lt;cmdline&gt; (single
quotes are used <br>
for disambiguating &lt;string&gt; from &lt;cmdline&gt;). If
&lt;string&gt; contains semicolons, &lt;string&gt; must be
enclosed in parentheses (e.g., pipe &rsquo;($1;$2)&rsquo;
/bin/cat). Default value for <br>
&lt;string&gt; is %s. If &lt;cmdline&gt; is omitted,
&lt;string&gt; is written to standard output. For additional
information, see INTERPROCESS COMMUNICATION section.</p>

<p style="margin-top: 1em">create [&lt;name&gt;
[&lt;time&gt; [&lt;action list&gt;] ] ] <br>
Create a context with the name &lt;name&gt;, lifetime of
&lt;time&gt; seconds, and empty event store. The
&lt;name&gt; parameter may not contain whitespace and
defaults to %s. The &lt;time&gt; <br>
parameter must evaluate to an unsigned integer at runtime.
Specifying 0 for &lt;time&gt; or omitting the value means
infinite lifetime. If &lt;action list&gt; is given, it will
be <br>
executed when the context expires. If &lt;action list&gt;
contains several actions, the list must be enclosed in
parentheses. In &lt;action list&gt;, the internal context
name _THIS <br>
may be used for referring to the current context (see
INTERNAL EVENTS AND CONTEXTS section for a detailed
discussion). If an already existing context is recreated
with <br>
create, its remaining lifetime is set to &lt;time&gt;
seconds, its action list is reinitialized, and its event
store is emptied.</p>

<p style="margin-top: 1em">delete [&lt;name&gt;] <br>
Delete the context &lt;name&gt;. The &lt;name&gt; parameter
may not contain whitespace and defaults to %s.</p>

<p style="margin-top: 1em">obsolete [&lt;name&gt;] <br>
Similar to the delete action, except that the action list of
the context &lt;name&gt; (if present) is executed before
deletion.</p>

<p style="margin-top: 1em">set &lt;name&gt; &lt;time&gt;
[&lt;action list&gt;] <br>
Change settings for the context &lt;name&gt;. The creation
time of the context is set to the current time, and the
lifetime of the context is set to &lt;time&gt; seconds. If
the <br>
&lt;action list&gt; parameter is given, the context action
list is set to &lt;action list&gt;. The &lt;name&gt;
parameter may not contain whitespace and defaults to %s. The
&lt;time&gt; parame&acirc; <br>
ter must evaluate to an unsigned integer or hyphen (-) at
runtime. Specifying 0 for &lt;time&gt; means infinite
lifetime. If &lt;time&gt; equals to -, the creation time and
lifetime <br>
of the context are not changed. If &lt;action list&gt;
contains several actions, the list must be enclosed in
parentheses. In &lt;action list&gt;, the internal context
name _THIS may <br>
be used for referring to the current context (see INTERNAL
EVENTS AND CONTEXTS section for a detailed discussion).</p>

<p style="margin-top: 1em">alias &lt;name&gt;
[&lt;alias&gt;] <br>
Create an alias name &lt;alias&gt; for the context
&lt;name&gt;. After creation, both &lt;alias&gt; and
&lt;name&gt; will point to the same context data structure,
and can thus be used inter&acirc; <br>
changeably for referring to the context. The &lt;name&gt;
and &lt;alias&gt; parameters may not contain whitespace, and
&lt;alias&gt; defaults to %s. If the context &lt;name&gt;
does not exist, <br>
the alias name is not created. If the delete action is
called for one of the context names, the context data
structure is destroyed, and all context names (which are now
<br>
pointers to unallocated memory) cease to exist. Also note
that when the context expires, its action list is executed
only once, no matter how many names the context has.</p>

<p style="margin-top: 1em">unalias [&lt;alias&gt;] <br>
Drop an existing context name &lt;alias&gt;, so that it can
no longer be used for referring to the given context. The
&lt;alias&gt; parameter may not contain whitespace and
defaults <br>
to %s. If the name &lt;alias&gt; is the last reference to
the context, the unalias action is identical to delete.</p>

<p style="margin-top: 1em">add &lt;name&gt;
[&lt;string&gt;] <br>
String &lt;string&gt; is appended to the end of the event
store of the context &lt;name&gt;. The &lt;name&gt;
parameter may not contain whitespace, and the &lt;string&gt;
parameter defaults to <br>
%s. If the context &lt;name&gt; does not exist, the context
is created with an infinite lifetime, empty action list and
empty event store (as with create &lt;name&gt;) before
adding <br>
the string to event store. If &lt;string&gt; is a multi-line
string (i.e., it contains newlines), it is split into lines,
and each line is appended to the event store sepa&acirc;
<br>
rately.</p>

<p style="margin-top: 1em">prepend &lt;name&gt;
[&lt;string&gt;] <br>
Similar to the add action, except that the string
&lt;string&gt; is prepended to the beginning of the event
store of context &lt;name&gt;.</p>

<p style="margin-top: 1em">fill &lt;name&gt;
[&lt;string&gt;] <br>
Similar to the add action, except that the event store of
the context &lt;name&gt; is emptied before &lt;string&gt; is
added.</p>

<p style="margin-top: 1em">report &lt;name&gt;
[&lt;cmdline&gt;] <br>
Fork a process for executing command line &lt;cmdline&gt;,
and write strings from the event store of the context
&lt;name&gt; to the standard input of &lt;cmdline&gt;.
Strings are written <br>
in the order they appear in the event store, with a
terminating newline appended to each string. If the context
&lt;name&gt; does not exist or its event store is empty,
&lt;cmd&acirc; <br>
line&gt; is not executed. The &lt;name&gt; parameter may not
contain whitespace, and if &lt;cmdline&gt; is omitted,
strings are written to standard output. For additional
information, <br>
see INTERPROCESS COMMUNICATION section.</p>

<p style="margin-top: 1em">copy &lt;name&gt; %&lt;var&gt;
<br>
Strings s1,...,sn from the event store of the context
&lt;name&gt; are joined into a multi-line string
&quot;s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn&quot;, and this
string is assigned to the action <br>
list variable %&lt;var&gt;. If the context &lt;name&gt; does
not exist, the value of %&lt;var&gt; does not change.</p>

<p style="margin-top: 1em">empty &lt;name&gt;
[%&lt;var&gt;] <br>
Similar to the copy action, except that the event store of
the context &lt;name&gt; will be emptied after the
assignment. If %&lt;var&gt; is omitted, the content of the
event store is <br>
dropped without an assignment.</p>

<p style="margin-top: 1em">pop &lt;name&gt; %&lt;var&gt;
<br>
Remove the last string from the event store of context
&lt;name&gt;, and assign it to the action list variable
%&lt;var&gt;. If the event store is empty, %&lt;var&gt; is
set to empty <br>
string. If the context &lt;name&gt; does not exist, the
value of %&lt;var&gt; does not change.</p>

<p style="margin-top: 1em">shift &lt;name&gt; %&lt;var&gt;
<br>
Remove the first string from the event store of context
&lt;name&gt;, and assign it to the action list variable
%&lt;var&gt;. If the event store is empty, %&lt;var&gt; is
set to empty <br>
string. If the context &lt;name&gt; does not exist, the
value of %&lt;var&gt; does not change.</p>

<p style="margin-top: 1em">exists %&lt;var&gt; &lt;name&gt;
<br>
If the context &lt;name&gt; exists, set the action list
variable %&lt;var&gt; to 1, otherwise set %&lt;var&gt; to
0.</p>

<p style="margin-top: 1em">getsize %&lt;var&gt;
&lt;name&gt; <br>
Find the number of strings in the event store of context
&lt;name&gt;, and assign this number to the action list
variable %&lt;var&gt;. If the context &lt;name&gt; does not
exist, %&lt;var&gt; <br>
is set to Perl undefined value.</p>

<p style="margin-top: 1em">getaliases %&lt;var&gt;
&lt;name&gt; <br>
Find all alias names for context &lt;name&gt;, join the
names into a multi-line string
&quot;alias1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;aliasn&quot;,
and assign this string to the action list variable <br>
%&lt;var&gt;. If the context &lt;name&gt; does not exist,
the value of %&lt;var&gt; does not change.</p>

<p style="margin-top: 1em">getltime %&lt;var&gt;
&lt;name&gt; <br>
Find the lifetime of context &lt;name&gt;, and assign this
number to the action list variable %&lt;var&gt;. If the
context &lt;name&gt; does not exist, the value of
%&lt;var&gt; does not change.</p>

<p style="margin-top: 1em">getctime %&lt;var&gt;
&lt;name&gt; <br>
Find the creation time of context &lt;name&gt;, and assign
this number to the action list variable %&lt;var&gt;. If the
context &lt;name&gt; does not exist, the value of
%&lt;var&gt; does not <br>
change.</p>

<p style="margin-top: 1em">setctime &lt;time&gt;
&lt;name&gt; <br>
Set the creation time of context &lt;name&gt; to
&lt;time&gt;. The &lt;time&gt; parameter must evaluate to
seconds since Epoch (as reported by the time(2) system
call), and must reflect a <br>
time moment between the previous creation time and the
current time (both endpoints included).</p>

<p style="margin-top: 1em">event [&lt;time&gt;]
[&lt;string&gt;] <br>
After &lt;time&gt; seconds, create a synthetic event
&lt;string&gt;. If &lt;string&gt; is a multi-line string
(i.e., it contains newlines), it is split into lines, and
from each line a <br>
separate synthetic event is created. SEC will treat each
synthetic event like a line from an input file -- the event
will be matched against rules and it might trigger <br>
further actions. If the --intcontexts command line option is
given, internal context _INTERNAL_EVENT is set up for
synthetic event(s) (see INTERNAL EVENTS AND CONTEXTS <br>
section for more information). The &lt;time&gt; parameter is
an integer constant. Specifying 0 for &lt;time&gt; or
omitting the value means &quot;now&quot;. Default value for
&lt;string&gt; is %s.</p>

<p style="margin-top: 1em">tevent &lt;time&gt;
[&lt;string&gt;] <br>
Similar to the event action, except that the &lt;time&gt;
parameter may contain variables and must evaluate to an
unsigned integer at runtime.</p>

<p style="margin-top: 1em">cevent &lt;name&gt; &lt;time&gt;
[&lt;string&gt;] <br>
Similar to the tevent action, except that if the
--intcontexts command line option is given, internal context
&lt;name&gt; is set up for synthetic event(s).</p>

<p style="margin-top: 1em">reset [&lt;offset&gt;]
[&lt;string&gt;] <br>
Terminate event correlation operation(s) with the operation
description string &lt;string&gt;. Note that the reset
action works only for operations started from the same
config&acirc; <br>
uration file. The &lt;offset&gt; parameter is used to refer
to a specific rule in the configuration file. If
&lt;offset&gt; is given, the operation started by the given
rule is ter&acirc; <br>
minated (if it exists). If &lt;offset&gt; is an unsigned
integer N, it refers to the N-th rule in the configuration
file. If &lt;offset&gt; is 0, it refers to the current rule.
If <br>
&lt;offset&gt; begins with the plus (+) or minus (-) sign,
it specifies an offset from the current rule (e.g., -1
denotes the previous and +1 the next rule). Note that since
<br>
Options rules are only processed when configuration files
are loaded and they are not applied at runtime, Options
rules are excluded when calculating &lt;offset&gt;. If
&lt;off&acirc; <br>
set&gt; is not given, SEC checks for each rule from the
current configuration file if an operation with
&lt;string&gt; has been started by this rule, and the
operation is termi&acirc; <br>
nated if it exists. Default value for &lt;string&gt; is %s.
For additional information, see EVENT CORRELATION OPERATIONS
section.</p>

<p style="margin-top: 1em">getwpos %&lt;var&gt;
&lt;offset&gt; [&lt;string&gt;] <br>
Find the beginning of the event correlation window for an
event correlation operation, and set the action list
variable %&lt;var&gt; to this timestamp. The value assigned
to <br>
%&lt;var&gt; is measured in seconds since Epoch (as reported
by the time(2) system call). As with the reset action, the
event correlation operation is identified by the
opera&acirc; <br>
tion description string &lt;string&gt; and the rule offset
&lt;offset&gt;. If the operation does not exist, the value
of %&lt;var&gt; does not change. Default value for
&lt;string&gt; is %s. <br>
For additional information, see EVENT CORRELATION OPERATIONS
section.</p>

<p style="margin-top: 1em">setwpos &lt;time&gt;
&lt;offset&gt; [&lt;string&gt;] <br>
Set the beginning of the event correlation window to
&lt;time&gt; for an event correlation operation (if it
exists). The &lt;time&gt; parameter must evaluate to seconds
since Epoch <br>
(as reported by the time(2) system call), and must reflect a
time moment between the previous window position and the
current time (both endpoints included). As with the <br>
reset action, the event correlation operation is identified
by the operation description string &lt;string&gt; and the
rule offset &lt;offset&gt;. Default value for &lt;string&gt;
is %s. <br>
For additional information, see EVENT CORRELATION OPERATIONS
section.</p>

<p style="margin-top: 1em">assign %&lt;var&gt;
[&lt;string&gt;] <br>
Assign string &lt;string&gt; to the action list variable
%&lt;var&gt;. Default value for &lt;string&gt; is %s.</p>

<p style="margin-top: 1em">assignsq %&lt;var&gt;
[&lt;string&gt;] <br>
Similar to the assign action, except that &lt;string&gt; is
quoted with single quotes before assigning it to
%&lt;var&gt;. If &lt;string&gt; contains single quotes, they
are masked with <br>
backslashes (e.g., if the match variable $1 holds the value
abc&rsquo;123&rsquo;xyz, the action assignsq %myvar $1
assigns the value
&rsquo;abc&rsquo;&acute;&rsquo;123&rsquo;&acute;&rsquo;xyz&rsquo;
to the action list variable <br>
%myvar). This action is useful for disabling shell
intepretation for the values of action list variables that
appear in command lines executed by SEC. Default value for
<br>
&lt;string&gt; is %s.</p>

<p style="margin-top: 1em">free %&lt;var&gt; <br>
Unset the action list variable %&lt;var&gt;.</p>

<p style="margin-top: 1em">eval %&lt;var&gt; &lt;code&gt;
<br>
The parameter &lt;code&gt; is a Perl miniprogram that is
compiled and executed by calling the Perl eval() function in
the Perl list context. If the miniprogram returns a single
<br>
value, it is assigned to the action list variable
%&lt;var&gt;. If the miniprogram returns several values
s1,...,sn, they are joined into a multi-line string
&quot;s1&lt;NEW&acirc; <br>
LINE&gt;...&lt;NEWLINE&gt;sn&quot;, and this string is
assigned to %&lt;var&gt;. If no value is returned,
%&lt;var&gt; is set to Perl undefined value. If eval()
fails, the value of %&lt;var&gt; does not <br>
change. Since most Perl programs contain semicolons which
are also employed by SEC as action separators, it is
recommended to enclose the &lt;code&gt; parameter in
parentheses, <br>
in order to mask the semicolons in &lt;code&gt;. For
additional information, see PERL INTEGRATION section.</p>

<p style="margin-top: 1em">call %&lt;var&gt; %&lt;ref&gt;
[&lt;paramlist&gt;] <br>
Call the precompiled Perl function referenced by the action
list variable %&lt;ref&gt;, and assign the result to the
action list variable %&lt;var&gt;. The %&lt;ref&gt;
parameter must be a <br>
code reference that has been previously created with the
eval action. The &lt;paramlist&gt; parameter (if given) is a
string which specifies parameters for the function. The <br>
parameters must be separated by whitespace in the
&lt;paramlist&gt; string. If the function returns a single
value, it is assigned to %&lt;var&gt;. If the function
returns several <br>
values s1,...,sn, they are joined into a multi-line string
&quot;s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn&quot;, and this
string is assigned to %&lt;var&gt;. If no value is returned,
%&lt;var&gt; is set to <br>
Perl undefined value. If the function encounters a fatal
runtime error or %&lt;ref&gt; is not a code reference, the
value of %&lt;var&gt; does not change. For additional
informa&acirc; <br>
tion, see PERL INTEGRATION section.</p>

<p style="margin-top: 1em">lcall %&lt;var&gt;
[&lt;paramlist&gt;] -&gt; &lt;code&gt; <br>
Call the precompiled Perl function &lt;code&gt; and assign
the result to the action list variable %&lt;var&gt;. The
&lt;code&gt; parameter must be a valid Perl function
definition that is <br>
compiled at SEC startup with the Perl eval() function, and
eval() must return a code reference. The &lt;paramlist&gt;
parameter (if given) is a string which specifies
parame&acirc; <br>
ters for the function. The parameters must be separated by
whitespace in the &lt;paramlist&gt; string. If the function
returns a single value, it is assigned to %&lt;var&gt;. If
the <br>
function returns several values s1,...,sn, they are joined
into a multi-line string
&quot;s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn&quot;, and this
string is assigned to %&lt;var&gt;. If no value is <br>
returned, %&lt;var&gt; is set to Perl undefined value. If
the function encounters a fatal runtime error, the value of
%&lt;var&gt; does not change. Since most Perl functions
contain <br>
semicolons which are also employed by SEC as action
separators, it is recommended to enclose the &lt;code&gt;
parameter in parentheses, in order to mask the semicolons in
<br>
&lt;code&gt;. For additional information, see PERL
INTEGRATION section.</p>

<p style="margin-top: 1em">rewrite &lt;lnum&gt;
[&lt;string&gt;] <br>
Replace last &lt;lnum&gt; lines in the input buffer with
string &lt;string&gt;. If the --nojointbuf option was
specified and the action is triggered by a matching event,
the action <br>
modifies the buffer which holds this event. If the
--nojointbuf option was specified and the action is
triggered by the system clock (e.g., the action is executed
from the <br>
Calendar rule), the action modifies the buffer which holds
the last already processed event. With the --jointbuf
option, the content of the joint input buffer is
rewrit&acirc; <br>
ten. The &lt;lnum&gt; parameter must evaluate to an unsigned
integer at runtime. If &lt;lnum&gt; evaluates to 0,
&lt;lnum&gt; is reset to the number of lines in
&lt;string&gt;. If the value of <br>
&lt;lnum&gt; is greater than the buffer size N, &lt;lnum&gt;
is reset to N. If &lt;string&gt; contains less than
&lt;lnum&gt; lines, &lt;string&gt; will be padded with
leading empty lines. If &lt;string&gt; <br>
contains more than &lt;lnum&gt; lines, only leading
&lt;lnum&gt; lines from &lt;string&gt; are written into the
buffer. Default value for &lt;string&gt; is %s. For
additional information, see <br>
INPUT PROCESSING AND TIMING section.</p>

<p style="margin-top: 1em">if %&lt;var&gt; ( &lt;action
list&gt; ) [ else ( &lt;action list2&gt; ) ] <br>
If the action list variable %&lt;var&gt; evaluates true in
the Perl boolean context (i.e., it holds a defined value
which is neither 0 nor empty string), execute the action
list <br>
&lt;action list&gt;. If the second action list &lt;action
list2&gt; is given with the optional else-statement, it is
executed if %&lt;var&gt; either does not exist or evaluates
false (i.e., <br>
%&lt;var&gt; holds 0, empty string or Perl undefined
value).</p>

<p style="margin-top: 1em">while %&lt;var&gt; ( &lt;action
list&gt; ) <br>
Execute the action list &lt;action list&gt; repeatedly as
long as the action list variable %&lt;var&gt; evaluates true
in the Perl boolean context (i.e., it holds a defined value
<br>
which is neither 0 nor empty string).</p>

<p style="margin-top: 1em">break If used inside a
while-loop, terminates its execution; otherwise terminates
the execution of the entire action list.</p>

<p style="margin-top: 1em">continue <br>
If used inside a while-loop, starts the next iteration of
the loop; otherwise terminates the execution of the entire
action list.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">Follow the /var/log/trapd.log
file and feed to SEC input all lines that are appended to
the file:</p>

<p style="margin-top: 1em">action=spawn /bin/tail -f
/var/log/trapd.log</p>

<p style="margin-top: 1em">Mail the timestamp and the value
of the $0 variable to the local root:</p>

<p style="margin-top: 1em">action=pipe &rsquo;%t: $0&rsquo;
/bin/mail -s &quot;alert message&quot; root@localhost</p>

<p style="margin-top: 1em">Add the value of the $0 variable
to the event store of the context ftp_&lt;the value of
$1&gt;, and set the context to expire after 30 minutes. When
the context expires, its event <br>
store will be mailed to the local root:</p>

<p style="margin-top: 1em">action=add ftp_$1 $0; set ftp_$1
1800 (report ftp_$1 /bin/mail root@localhost)</p>

<p style="margin-top: 1em">Create a subroutine for weeding
out comment lines from the input list, and use this
subroutine for removing comment lines from the event store
of the context C1:</p>

<p style="margin-top: 1em">action=eval %funcptr ( sub {
my(@buf) = split(/0, $_[0]); my(@ret) = grep(!/^#/, @buf);
return @ret; } ); copy C1 %in; call %out %funcptr %in; fill
C1 %out</p>

<p style="margin-top: 1em">The following action list
achieves the same goal as the previous action list with
while and if actions:</p>

<p style="margin-top: 1em">action=getsize %size C1; while
%size ( shift C1 %event; lcall %nocomment %event -&gt; ( sub
{ $_[0] !~ /^#/ } ); if %nocomment ( add C1 %event ); lcall
%size %size -&gt; ( sub { $_[0]-1; } ) )</p>

<p style="margin-top: 1em">PARSING ISSUES <br>
As already noted, SEC context expressions and action lists
may contain parentheses which are used for grouping and
masking purposes. When SEC parses its configuration, it
checks <br>
whether parentheses in context expressions and action lists
are balanced (i.e., whether each parenthesis has a
counterpart), since unbalanced parentheses introduce
ambiguity. <br>
This can cause SEC to reject some legitimate constructs,
e.g.,</p>

<p style="margin-top: 1em">action=eval %o (print
&quot;)&quot;;)</p>

<p style="margin-top: 1em">is considered an invalid action
list (however, note that <br>
action=eval %o (print &quot;()&quot;;) <br>
would be passed by SEC, since now parentheses are balanced).
In order to avoid such parsing errors, each parenthesis
without a counterpart must be masked with a backslash (the
<br>
backslash will be removed by SEC during configuration file
parsing). For example, the above action could be written
as</p>

<p style="margin-top: 1em">action=eval %o (print
&quot;&quot;;)</p>

<p style="margin-top: 1em">RULE TYPES <br>
This section provides a detailed discussion of SEC rule
types.</p>

<p style="margin-top: 1em">SINGLE RULE <br>
The Single rule immediately executes an action list when an
event has matched the rule. An event matches the rule if the
pattern matches the event and the context expression (if
<br>
given) evaluates TRUE.</p>

<p style="margin-top: 1em">The Single rule supports the
following fields:</p>

<p style="margin-top: 1em">type fixed to Single (value is
case insensitive, so single or sIngLe can be used
instead).</p>

<p style="margin-top: 1em">continue (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive).</p>

<p style="margin-top: 1em">ptype pattern type (value is
case insensitive).</p>

<p style="margin-top: 1em">pattern <br>
pattern.</p>

<p style="margin-top: 1em">varmap (optional) <br>
variable map.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression.</p>

<p style="margin-top: 1em">desc operation description
string.</p>

<p style="margin-top: 1em">action action list.</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that match variables may be
used in context, desc, and action fields. Also note that
this rule does not start an event correlation operation, and
the desc field is merely <br>
used for setting the %s action list variable.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">type=single <br>
continue=takenext <br>
ptype=regexp <br>
pattern=ftpd: stov2.*FTP session opened <br>
desc=ftp session opened for ristov2 pid $1 <br>
action=create ftp_$1</p>

<p style="margin-top: 1em">type=single <br>
continue=takenext <br>
ptype=regexp <br>
pattern=ftpd: <br>
context=ftp_$1 <br>
desc=ftp session event for ristov2 pid $1 <br>
action=add ftp_$1 $0; set ftp_$1 1800 (report ftp_$1
/bin/mail root@localhost)</p>

<p style="margin-top: 1em">type=single <br>
ptype=regexp <br>
pattern=ftpd: stov2.*FTP session closed <br>
desc=ftp session closed for ristov2 pid $1 <br>
action=report ftp_$1 /bin/mail root@localhost; delete
ftp_$1</p>

<p style="margin-top: 1em">This ruleset is created for
monitoring the ftpd log file. The first rule creates the
context ftp_&lt;pid&gt; when someone connects from host
ristov2 over FTP and establishes a new ftp <br>
session (the session is identified by the PID of the process
which has been created for handling this session). The
second rule adds all further log file lines for the session
<br>
&lt;pid&gt; to the event store of the context
ftp_&lt;pid&gt; (before adding a line, the rule checks if
the context exists). After adding a line, the rule extends
context&rsquo;s lifetime for 30 <br>
minutes and sets the action list that will be executed when
the context expires. The third rule mails collected log file
lines to root@localhost when the session &lt;pid&gt; is
closed. <br>
Collected lines will also be mailed when the session
&lt;pid&gt; has been inactive for 30 minutes (no log file
lines observed for that session).</p>

<p style="margin-top: 1em">Note that the log file line that
has matched the first rule is also matched against the
second rule (since the first rule has the continue field set
to TakeNext). Since the sec&acirc; <br>
ond rule always matches this line, it will become the first
line in the event store of ftp_&lt;pid&gt;. The second rule
has also its continue field set to TakeNext, since otherwise
no <br>
log file lines would reach the third rule.</p>

<p style="margin-top: 1em">SINGLEWITHSCRIPT RULE <br>
The SingleWithScript rule forks a process for executing an
external program when an event has matched the rule. The
names of all currently existing contexts are written to the
<br>
standard input of the program. After the program has been
forked, the rule matching continues immediately, and the
program status will be checked periodically until the
program <br>
exits. If the program returns 0 exit status, the action list
defined by the action field is executed; otherwise the
action list defined by the action2 field is executed (if
<br>
given).</p>

<p style="margin-top: 1em">The SingleWithScript rule
supports the following fields:</p>

<p style="margin-top: 1em">type fixed to SingleWithScript
(value is case insensitive).</p>

<p style="margin-top: 1em">continue (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive).</p>

<p style="margin-top: 1em">ptype pattern type (value is
case insensitive).</p>

<p style="margin-top: 1em">pattern <br>
pattern.</p>

<p style="margin-top: 1em">varmap (optional) <br>
variable map.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression.</p>

<p style="margin-top: 1em">script an external program.</p>

<p style="margin-top: 1em">desc operation description
string.</p>

<p style="margin-top: 1em">action action list.</p>

<p style="margin-top: 1em">action2 (optional) <br>
action list.</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that match variables may be
used in context, script, desc, action, and action2 fields.
Also note that this rule does not start an event correlation
operation, and the desc <br>
field is merely used for setting the %s action list
variable.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">type=SingleWithScript <br>
ptype=RegExp <br>
pattern=interface ([.]+) down <br>
script=/bin/ping -c 3 -q $1 <br>
desc=Check if $1 responds to ping <br>
action=logonly Interface $1 reported down, but is pingable
<br>
action2=pipe &rsquo;%t: Interface $1 is down&rsquo;
/bin/mail root@localhost</p>

<p style="margin-top: 1em">When &quot;interface
&lt;ipaddress&gt; down&quot; line appears in input, the rule
checks if &lt;ipaddress&gt; responds to ping. If
&lt;ipaddress&gt; is pingable, the message &quot;Interface
&lt;ipaddress&gt; reported <br>
down, but is pingable&quot; is logged; otherwise an e-mail
warning containing a human-readable timestamp is sent to
root@localhost.</p>

<p style="margin-top: 1em">SINGLEWITHSUPPRESS RULE <br>
The SingleWithSuppress rule runs event correlation
operations for filtering repeated instances of the same
event during T seconds. The value of T is defined by the
window field.</p>

<p style="margin-top: 1em">When an event has matched the
rule, SEC evaluates the operation description string given
with the desc field. If the operation for the given string
and rule does not exist, SEC <br>
will create it with the lifetime of T seconds, and the
operation immediately executes an action list. If the
operation exists, it consumes the matching event without any
action.</p>

<p style="margin-top: 1em">The SingleWithSuppress rule
supports the following fields:</p>

<p style="margin-top: 1em">type fixed to SingleWithSuppress
(value is case insensitive).</p>

<p style="margin-top: 1em">continue (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive).</p>

<p style="margin-top: 1em">ptype pattern type (value is
case insensitive).</p>

<p style="margin-top: 1em">pattern <br>
pattern.</p>

<p style="margin-top: 1em">varmap (optional) <br>
variable map.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression.</p>

<p style="margin-top: 1em">desc operation description
string.</p>

<p style="margin-top: 1em">action action list.</p>

<p style="margin-top: 1em">window event correlation window
size (value is an integer constant).</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that match variables may be
used in context, desc, and action fields.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">type=SingleWithSuppress <br>
ptype=RegExp <br>
pattern=(): [fF]ile system full <br>
desc=File system $1 full <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=900</p>

<p style="margin-top: 1em">This rule runs event correlation
operations for processing &quot;file system full&quot;
syslog messages, e.g.,</p>

<p style="margin-top: 1em">Dec 16 14:26:09 test ufs: [ID
845546 kern.notice] NOTICE: alloc: /var: file system
full</p>

<p style="margin-top: 1em">When the first message for a
file system is observed, an operation is created which sends
an e-mail warning about this file system to root@localhost.
The operation will then run <br>
for 900 seconds and silently consume further messages for
the *same* file system. However, if a message for a
different file system is observed, another operation will be
<br>
started which sends a warning to root@localhost again (since
the desc field contains the $1 match variable which
evaluates to the file system name).</p>

<p style="margin-top: 1em">PAIR RULE <br>
The Pair rule runs event correlation operations for
processing event pairs during T seconds. The value of T is
defined by the window field. Default value is 0 which means
infin&acirc; <br>
ity.</p>

<p style="margin-top: 1em">When an event has matched the
conditions defined by the pattern and context field, SEC
evaluates the operation description string given with the
desc field. If the operation for <br>
the given string and rule exists, it consumes the matching
event without any action. If the operation does not exist,
SEC will create it with the lifetime of T seconds, and the
<br>
operation immediately executes an action list defined by the
action field. SEC will also copy the match conditions given
with the pattern2 and context2 field into the operation,
<br>
and substitute match variables with their values in copied
conditions.</p>

<p style="margin-top: 1em">If the event does not match
conditions defined by the pattern and context field, SEC
will check the match conditions of all operations started by
the given rule. Each matching <br>
operation executes the action list given with the action2
field and finishes.</p>

<p style="margin-top: 1em">If match variables are set when
the operation matches an event, they are made available as
$-prefixed match variables in context2, desc2, and action2
fields of the rule defini&acirc; <br>
tion. For example, if pattern2 field is a regular
expression, then $1 in the desc2 field is set by pattern2.
In order to access match variables set by pattern,
%-prefixed match <br>
variables have to be used in context2, desc2, and action2
fields. For example, if pattern and pattern2 are regular
expressions, then %1 in the desc2 field refers to the value
set <br>
by the first capture group in pattern (i.e., it has the same
value as $1 in the desc field).</p>

<p style="margin-top: 1em">The Pair rule supports the
following fields:</p>

<p style="margin-top: 1em">type fixed to Pair (value is
case insensitive).</p>

<p style="margin-top: 1em">continue (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive). Specifies
the point-of-continue after a match by pattern and
context.</p>

<p style="margin-top: 1em">ptype pattern type for pattern
(value is case insensitive).</p>

<p style="margin-top: 1em">pattern <br>
pattern.</p>

<p style="margin-top: 1em">varmap (optional) <br>
variable map for pattern.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression, evaluated together with pattern.</p>

<p style="margin-top: 1em">desc operation description
string.</p>

<p style="margin-top: 1em">action action list.</p>

<p style="margin-top: 1em">continue2 (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive). Specifies
the point-of-continue after a match by pattern2 and
context2.</p>

<p style="margin-top: 1em">ptype2 pattern type for pattern2
(value is case insensitive).</p>

<p style="margin-top: 1em">pattern2 <br>
pattern.</p>

<p style="margin-top: 1em">varmap2 (optional) <br>
variable map for pattern2.</p>

<p style="margin-top: 1em">context2 (optional) <br>
context expression, evaluated together with pattern2.</p>

<p style="margin-top: 1em">desc2 format string that sets
the %s variable for action2.</p>

<p style="margin-top: 1em">action2 <br>
action list.</p>

<p style="margin-top: 1em">window (optional) <br>
event correlation window size (value is an integer
constant).</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that match variables may be
used in context, desc, action, pattern2, context2, desc2,
and action2 fields.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">type=Pair <br>
ptype=RegExp <br>
pattern=kernel: nfs: server () not responding, still trying
<br>
desc=Server $1 is not responding <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
ptype2=SubStr <br>
pattern2=kernel: nfs: server $1 OK <br>
desc2=Server $1 is responding again <br>
action2=logonly <br>
window=3600</p>

<p style="margin-top: 1em">This rule runs event correlation
operations for processing NFS &quot;server not
responding&quot; and &quot;server OK&quot; syslog messages,
e.g.,</p>

<p style="margin-top: 1em">Dec 18 22:39:48 test kernel:
nfs: server box1 not responding, still trying <br>
Dec 18 22:42:27 test kernel: nfs: server box1 OK</p>

<p style="margin-top: 1em">When the &quot;server not
responding&quot; message for an NFS server is observed, an
operation is created for this server which sends an e-mail
warning about the server to root@localhost. <br>
The operation will then run for 3600 seconds and silently
consume further &quot;server not responding&quot; messages
for the same server. If this operation observes &quot;server
OK&quot; message for <br>
the *same* server, it will log the message &quot;Server
&lt;servername&gt; is responding again&quot; and finish.</p>

<p style="margin-top: 1em">For example, if SEC observes the
following event at 22:39:48</p>

<p style="margin-top: 1em">Dec 18 22:39:48 test kernel:
nfs: server box1 not responding, still trying</p>

<p style="margin-top: 1em">an event correlation operation
is created for server box1 which issues an e-mail warning
about this server immediately. After that, the operation
will run for 3600 seconds (until <br>
23:39:48), waiting for an event which would contain the
substring &quot;kernel: nfs: server box1 OK&quot; (because
the pattern2 field contains the $1 match variable which
evaluates to the <br>
server name).</p>

<p style="margin-top: 1em">If any further error messages
appear for server box1 during the 3600 second lifetime of
the operation, e.g.,</p>

<p style="margin-top: 1em">Dec 18 22:40:28 test kernel:
nfs: server box1 not responding, still trying <br>
Dec 18 22:41:09 test kernel: nfs: server box1 not
responding, still trying</p>

<p style="margin-top: 1em">these messages will be silently
consumed by the operation. If before its expiration the
operation observes an event which contains the substring
&quot;kernel: nfs: server box1 OK&quot;, <br>
e.g.,</p>

<p style="margin-top: 1em">Dec 18 22:42:27 test kernel:
nfs: server box1 OK</p>

<p style="margin-top: 1em">the operation will log the
message &quot;Server box1 is responding again&quot; and
terminate immediately. If no such message appears during the
3600 second lifetime of the operation, the <br>
operation will expire without taking any action. Please note
that if the window field would be either removed from the
rule definition or set to 0, the operation would never <br>
silently expire, but would terminate only after observing an
event which contains the substring &quot;kernel: nfs: server
box1 OK&quot;.</p>

<p style="margin-top: 1em">If the above rule is modified in
the following way</p>

<p style="margin-top: 1em">type=Pair <br>
ptype=RegExp <br>
pattern=^([[:alnum:]: ]+) kernel: nfs: server () not
responding, still trying <br>
desc=Server $2 is not responding <br>
action=logonly <br>
ptype2=RegExp <br>
pattern2=^([[:alnum:]: ]+) kernel: nfs: server $2 OK <br>
desc2=Server %2 was not accessible from %1 to $1 <br>
action2=pipe &rsquo;%s&rsquo; /bin/mail root@localhost <br>
window=86400</p>

<p style="margin-top: 1em">this rule will run event
correlation operations which report NFS server downtime to
root@localhost via e-mail, provided that downtime does not
exceed 24 hours (86400 seconds).</p>

<p style="margin-top: 1em">For example, if SEC observes the
following event</p>

<p style="margin-top: 1em">Dec 18 23:01:17 test kernel:
nfs: server box.test not responding, still trying</p>

<p style="margin-top: 1em">then the rule matches this
event, sets $1 match variable to &quot;Dec 18 23:01:17&quot;
and $2 to &quot;box.test&quot;, and creates an event
correlation operation for server box.test. This opera&acirc;
<br>
tion will start its work by logging the message &quot;Server
box.test is not responding&quot;, and will then run for
86400 seconds, waiting for an event which would match the
regular <br>
expression</p>

<p style="margin-top: 1em">^([[:alnum:]: ]+) kernel: nfs:
server box.test OK</p>

<p style="margin-top: 1em">Note that this expression was
created from the regular expression template in the pattern2
field by substituting the match variable $2 with its value.
However, since the string <br>
&quot;box.test&quot; contains the dot (.) character which is
a regular expression metacharacter, the dot is masked with
the backslash in the regular expression.</p>

<p style="margin-top: 1em">Suppose SEC will then observe
the event</p>

<p style="margin-top: 1em">Dec 18 23:09:54 test kernel:
nfs: server box.test OK</p>

<p style="margin-top: 1em">This event matches the above
regular expression which is used by the operation running
for server box.test. Also, the regular expression match sets
the $1 variable to &quot;Dec 18 <br>
23:09:54&quot; and unsets the $2 variable. In order to refer
to their original values when the operation was created, %1
and %2 match variables have to be used in the desc2 field
(%1 <br>
equals to &quot;Dec 18 23:01:17&quot; and %2 equals to
&quot;box.test&quot;). Therefore, the operation will send
the e-mail message &quot;Server box.test was not accessible
from Dec 18 23:01:17 to Dec 18 <br>
23:09:54&quot; to root@localhost, and will terminate
immediately.</p>

<p style="margin-top: 1em">PAIRWITHWINDOW RULE <br>
The PairWithWindow rule runs event correlation operations
for processing event pairs during T seconds. The value of T
is defined by the window field.</p>

<p style="margin-top: 1em">When an event has matched the
conditions defined by the pattern and context field, SEC
evaluates the operation description string given with the
desc field. If the operation for <br>
the given string and rule exists, it consumes the matching
event without any action. If the operation does not exist,
SEC will create it with the lifetime of T seconds. SEC will
<br>
also copy the match conditions given with the pattern2 and
context2 field into the operation, and substitute match
variables with their values in copied conditions.</p>

<p style="margin-top: 1em">If the event does not match
conditions defined by the pattern and context field, SEC
will check the match conditions of all operations started by
the given rule. Each matching <br>
operation executes the action list given with the action2
field and finishes. If the operation has not observed a
matching event by the end of its lifetime, it executes the
<br>
action list given with the action field before
finishing.</p>

<p style="margin-top: 1em">If match variables are set when
the operation matches an event, they are made available as
$-prefixed match variables in context2, desc2, and action2
fields of the rule defini&acirc; <br>
tion. For example, if pattern2 field is a regular
expression, then $1 in the desc2 field is set by pattern2.
In order to access match variables set by pattern,
%-prefixed match <br>
variables have to be used in context2, desc2, and action2
fields. For example, if pattern and pattern2 are regular
expressions, then %1 in the desc2 field refers to the value
set <br>
by the first capture group in pattern (i.e., it has the same
value as $1 in the desc field).</p>

<p style="margin-top: 1em">The PairWithWindow rule supports
the following fields:</p>

<p style="margin-top: 1em">type fixed to PairWithWindow
(value is case insensitive).</p>

<p style="margin-top: 1em">continue (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive). Specifies
the point-of-continue after a match by pattern and
context.</p>

<p style="margin-top: 1em">ptype pattern type for pattern
(value is case insensitive).</p>

<p style="margin-top: 1em">pattern <br>
pattern.</p>

<p style="margin-top: 1em">varmap (optional) <br>
variable map for pattern.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression, evaluated together with pattern.</p>

<p style="margin-top: 1em">desc operation description
string.</p>

<p style="margin-top: 1em">action action list.</p>

<p style="margin-top: 1em">continue2 (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive). Specifies
the point-of-continue after a match by pattern2 and
context2.</p>

<p style="margin-top: 1em">ptype2 pattern type for pattern2
(value is case insensitive).</p>

<p style="margin-top: 1em">pattern2 <br>
pattern.</p>

<p style="margin-top: 1em">varmap2 (optional) <br>
variable map for pattern2.</p>

<p style="margin-top: 1em">context2 (optional) <br>
context expression, evaluated together with pattern2.</p>

<p style="margin-top: 1em">desc2 format string that sets
the %s variable for action2.</p>

<p style="margin-top: 1em">action2 <br>
action list.</p>

<p style="margin-top: 1em">window event correlation window
size (value is an integer constant).</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that match variables may be
used in context, desc, action, pattern2, context2, desc2,
and action2 fields.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">type=PairWithWindow <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for () from ([.]+) port + ssh2 <br>
desc=User $1 has been unable to log in from $2 over SSH
during 1 minute <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
ptype2=RegExp <br>
pattern2=sshd: Accepted .+ for $1 from $2 port + ssh2 <br>
desc2=SSH login successful for %1 from %2 after initial
failure <br>
action2=logonly <br>
window=60</p>

<p style="margin-top: 1em">This rule runs event correlation
operations for processing SSH login events, e.g.,</p>

<p style="margin-top: 1em">Dec 27 19:00:24 test
sshd[10526]: Failed password for risto from 10.1.2.7 port
52622 ssh2 <br>
Dec 27 19:00:27 test sshd[10526]: Accepted password for
risto from 10.1.2.7 port 52622 ssh2</p>

<p style="margin-top: 1em">When an SSH login failure is
observed for a user name and a source IP address, an
operation is created for this user name and IP address
combination which will expect a success&acirc; <br>
ful login for the *same* user name and *same* IP address
during 60 seconds. If the user will not log in from the same
IP address during 60 seconds, the operation will send an e-
<br>
mail warning to root@localhost before finishing, otherwise
it will log the message &quot;SSH login successful for
&lt;username&gt; from &lt;ipaddress&gt; after initial
failure&quot; and finish.</p>

<p style="margin-top: 1em">Suppose the following events are
generated by an SSH daemon, and each event timestamp
reflects the time SEC observes the event:</p>

<p style="margin-top: 1em">Dec 30 13:02:01 test
sshd[30517]: Failed password for risto from 10.1.2.7 port
42172 ssh2 <br>
Dec 30 13:02:30 test sshd[30810]: Failed password for root
from 192.168.1.104 port 46125 ssh2 <br>
Dec 30 13:02:37 test sshd[30517]: Failed password for risto
from 10.1.2.7 port 42172 ssh2 <br>
Dec 30 13:02:59 test sshd[30810]: Failed password for root
from 192.168.1.104 port 46125 ssh2 <br>
Dec 30 13:03:04 test sshd[30810]: Accepted password for root
from 192.168.1.104 port 46125 ssh2</p>

<p style="margin-top: 1em">When the first event is observed
at 13:02:01, an operation is started for user risto and IP
address 10.1.2.7 which will expect a successful login for
risto from 10.1.2.7. The <br>
operation will run for 60 seconds, waiting for an event
which would match the regular expression</p>

<p style="margin-top: 1em">sshd: Accepted .+ for risto from
10.1.2.7 port + ssh2</p>

<p style="margin-top: 1em">Note that this expression was
created from the regular expression template in the pattern2
field by substituting match variables $1 and $2 with their
values. However, since the <br>
value of $2 contains the dot (.) characters which are
regular expression metacharacters, each dot is masked with
the backslash in the regular expression.</p>

<p style="margin-top: 1em">When the second event is
observed at 13:02:30, another operation is started for user
root and IP address 192.168.1.104 which will expect root to
log in successfully from <br>
192.168.1.104. This operation will run for 60 seconds,
waiting for an event matching the regular expression</p>

<p style="margin-top: 1em">sshd: Accepted .+ for root from
192.168.1.104 port + ssh2</p>

<p style="margin-top: 1em">The third event at 13:02:37
represents a second login failure for user risto and IP
address 10.1.2.7, and is silently consumed by the first
operation. Likewise, the fourth event <br>
at 13:02:59 is silently consumed by the second operation.
The first operation will run until 13:03:01 and then expire
without seeing a successful login for risto from 10.1.2.7.
<br>
Before terminating, the operation will send an e-mail
warning to root@localhost that user risto has not managed to
log in from 10.1.2.7 during one minute. At 13:03:04, the
sec&acirc; <br>
ond operation will observe an event which matches its
regular expression</p>

<p style="margin-top: 1em">sshd: Accepted .+ for root from
192.168.1.104 port + ssh2</p>

<p style="margin-top: 1em">After seeing this event, the
operation will log the message &quot;SSH login successful
for root from 192.168.1.104 after initial failure&quot; and
terminate immediately. Please note that <br>
the match by the regular expression</p>

<p style="margin-top: 1em">sshd: Accepted .+ for root from
192.168.1.104 port + ssh2</p>

<p style="margin-top: 1em">sets the $1 match variable to 1
and unsets $2. Therefore, the %1 and %2 match variables have
to be used in the desc2 field, in order to refer to the
original values of $1 (root) <br>
and $2 (192.168.1.104) when the operation was created.</p>

<p style="margin-top: 1em">SINGLEWITHTHRESHOLD RULE <br>
The SingleWithThreshold rule runs event correlation
operations for counting repeated instances of the same event
during T seconds, and taking an action if N events are
observed. <br>
The values of T and N are defined by the window and thresh
field, respectively.</p>

<p style="margin-top: 1em">When an event has matched the
rule, SEC evaluates the operation description string given
with the desc field. If the operation for the given string
and rule does not exist, SEC <br>
will create it with the lifetime of T seconds. The operation
will memorize the occurrence time of the event (current time
as returned by the time(2) system call), and compare the
<br>
number of memorized occurrence times with the threshold N.
If the operation has observed N events, it executes the
action list defined by the action field, and consumes all
fur&acirc; <br>
ther matching events without any action. If the rule has an
optional action list defined with the action2 field, the
operation will execute it before finishing, provided that
the <br>
action list given with action has been previously executed
by the operation. Note that a sliding window is employed for
event counting -- if the operation has observed less than
<br>
N events by the end of its lifetime, it drops occurrence
times which are older than T seconds, and extends its
lifetime for T seconds from the earliest remaining
occurrence time. <br>
If there are no remaining occurrence times, the operation
finishes without executing an action list.</p>

<p style="margin-top: 1em">The SingleWithThreshold rule
supports the following fields:</p>

<p style="margin-top: 1em">type fixed to
SingleWithThreshold (value is case insensitive).</p>

<p style="margin-top: 1em">continue (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive).</p>

<p style="margin-top: 1em">ptype pattern type (value is
case insensitive).</p>

<p style="margin-top: 1em">pattern <br>
pattern.</p>

<p style="margin-top: 1em">varmap (optional) <br>
variable map.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression.</p>

<p style="margin-top: 1em">desc operation description
string.</p>

<p style="margin-top: 1em">action action list.</p>

<p style="margin-top: 1em">action2 (optional) <br>
action list.</p>

<p style="margin-top: 1em">window event correlation window
size (value is an integer constant).</p>

<p style="margin-top: 1em">thresh counting threshold (value
is an integer constant).</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that match variables may be
used in context, desc, action, and action2 fields.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for () from [.]+ port + ssh2 <br>
desc=Three SSH login failures within 1m for user $1 <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=60 <br>
thresh=3</p>

<p style="margin-top: 1em">This rule runs event correlation
operations for counting the number of SSH login failure
events. Each operation counts events for one user name, and
if the operation has observed <br>
three login failures within 60 seconds, it sends an e-mail
warning to root@localhost.</p>

<p style="margin-top: 1em">Suppose the following events are
generated by an SSH daemon, and each event timestamp
reflects the time SEC observes the event:</p>

<p style="margin-top: 1em">Dec 28 01:42:21 test
sshd[28132]: Failed password for risto from 10.1.2.7 port
42172 ssh2 <br>
Dec 28 01:43:10 test sshd[28132]: Failed password for risto
from 10.1.2.7 port 42172 ssh2 <br>
Dec 28 01:43:29 test sshd[28132]: Failed password for risto
from 10.1.2.7 port 42172 ssh2 <br>
Dec 28 01:44:00 test sshd[28149]: Failed password for risto2
from 10.1.2.7 port 42176 ssh2 <br>
Dec 28 01:44:03 test sshd[28211]: Failed password for risto
from 10.1.2.7 port 42192 ssh2 <br>
Dec 28 01:44:07 test sshd[28211]: Failed password for risto
from 10.1.2.7 port 42192 ssh2</p>

<p style="margin-top: 1em">When the first event is observed
at 01:42:21, a counting operation is started for user risto,
with its event correlation window ending at 01:43:21. Since
by 01:43:21 two SSH <br>
login failures for user risto have occurred, the threshold
condition remains unsatisfied for the operation. Therefore,
the beginning of its event correlation window will be <br>
moved to 01:43:10 (the occurrence time of the second event),
leaving the first event outside the window. At 01:44:00,
another counting operation is started for user risto2. The
<br>
threshold condition for the first operation will become
satisfied at 01:44:03 (since the operation has seen three
login failure events for user risto within 60 seconds), and
thus <br>
an e-mail warning will be issued. Finally, the event
occurring at 01:44:07 will be consumed silently by the first
operation (the operation will run until 01:44:10). Since
there <br>
will be no further login failure events for user risto2, the
second operation will exist until 01:45:00 without taking
any action.</p>

<p style="margin-top: 1em">SINGLEWITH2THRESHOLDS RULE <br>
The SingleWith2Thresholds rule runs event correlation
operations which take action if N1 events have been observed
in the window of T1 seconds, and then at most N2 events will
be <br>
observed in the window of T2 seconds. The values of T1, N1,
T2, and N2 are defined by the window, thresh, window2, and
thresh2 field, respectively.</p>

<p style="margin-top: 1em">When an event has matched the
rule, SEC evaluates the operation description string given
with the desc field. If the operation for the given string
and rule does not exist, SEC <br>
will create it with the lifetime of T1 seconds. The
operation will memorize the occurrence time of the event
(current time as returned by the time(2) system call), and
compare <br>
the number of memorized occurrence times with the threshold
N1. If the operation has observed N1 events, it executes the
action list defined by the action field, and starts <br>
another counting round for T2 seconds. If no more than N2
events have been observed by the end of the window, the
operation executes the action list defined by the action2
field <br>
and finishes. Note that both windows are sliding -- the
first window slides like the window of the
SingleWithThreshold operation, while the beginning of the
second window is <br>
moved to the second earliest memorized event occurrence time
when the threshold N2 is violated.</p>

<p style="margin-top: 1em">The SingleWith2Thresholds rule
supports the following fields:</p>

<p style="margin-top: 1em">type fixed to
SingleWith2Thresholds (value is case insensitive).</p>

<p style="margin-top: 1em">continue (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive).</p>

<p style="margin-top: 1em">ptype pattern type (value is
case insensitive).</p>

<p style="margin-top: 1em">pattern <br>
pattern.</p>

<p style="margin-top: 1em">varmap (optional) <br>
variable map.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression.</p>

<p style="margin-top: 1em">desc operation description
string.</p>

<p style="margin-top: 1em">action action list.</p>

<p style="margin-top: 1em">window event correlation window
size (value is an integer constant).</p>

<p style="margin-top: 1em">thresh counting threshold.</p>

<p style="margin-top: 1em">desc2 format string that sets
the %s variable for action2.</p>

<p style="margin-top: 1em">action2 <br>
action list.</p>

<p style="margin-top: 1em">window2 <br>
event correlation window size (value is an integer
constant).</p>

<p style="margin-top: 1em">thresh2 <br>
counting threshold.</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that match variables may be
used in context, desc, action, desc2, and action2
fields.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">type=SingleWith2Thresholds <br>
ptype=RegExp <br>
pattern=(): %SYS-3-CPUHOG <br>
desc=Router $1 CPU overload <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=300 <br>
thresh=2 <br>
desc2=Router $1 CPU load has been normal for 1h <br>
action2=logonly <br>
window2=3600 <br>
thresh2=0</p>

<p style="margin-top: 1em">When a SYS-3-CPUHOG syslog
message is received from a router, the rule starts a
counting operation for this router which sends an e-mail
warning to root@localhost if another such <br>
message is received from the same router within 300 seconds.
After sending the warning, the operation will continue to
run until no SYS-3-CPUHOG syslog messages have been <br>
received from the router for 3600 seconds. When this
condition becomes satisfied, the operation will log the
message &quot;Router &lt;routername&gt; CPU load has been
normal for 1h&quot; and <br>
finish.</p>

<p style="margin-top: 1em">Suppose the following events are
generated by a router, and each event timestamp reflects the
time SEC observes the event:</p>

<p style="margin-top: 1em">Dec 30 12:23:25 router1.mydomain
Router1: %SYS-3-CPUHOG: cpu is hogged <br>
Dec 30 12:25:38 router1.mydomain Router1: %SYS-3-CPUHOG: cpu
is hogged <br>
Dec 30 12:28:53 router1.mydomain Router1: %SYS-3-CPUHOG: cpu
is hogged</p>

<p style="margin-top: 1em">When the first event is observed
at 12:23:25, a counting operation is started for router
Router1. The appearance of the second event at 12:25:38
fulfills the threshold condition <br>
given with the thresh and window fields (two events have
been observed within 300 seconds). Therefore, the operation
will send an e-mail warning about the CPU overload of
Router1 <br>
to root@localhost.</p>

<p style="margin-top: 1em">After that, the operation will
start another counting round, expecting to see no
SYS-3-CPUHOG events (since thresh2=0) for Router1 during the
following 3600 seconds (the begin&acirc; <br>
ning of the operation&rsquo;s event correlation window will
be moved to 12:25:38 for the second counting round). Since
the appearance of the third event at 12:28:53 violates the
<br>
threshold condition given with the thresh2 and window2
fields, the beginning of the event correlation window will
be moved to 12:28:53. Since there will be no further <br>
SYS-3-CPUHOG messages for Router1, the operation will run
until 13:28:53 and then expire, logging the message
&quot;Router Router1 CPU load has been normal for 1h&quot;
before finishing.</p>

<p style="margin-top: 1em">EVENTGROUP RULE <br>
The EventGroup rule runs event correlation operations for
counting repeated instances of N different events e1,...,eN
during T seconds, and taking an action if threshold
condi&acirc; <br>
tions c1,...,cN for *all* events are satisfied (i.e., for
each event eK there are at least cK event instances in the
window). Note that the event correlation window of the <br>
EventGroup operation is sliding like the window of the
SingleWithThreshold operation.</p>

<p style="margin-top: 1em">Event e1 is described with the
pattern and context field, event e2 is described with the
pattern2 and context2 field, etc. The values for N and T are
defined by the type and <br>
window field, respectively. The value for c1 is given with
the thresh field, the value for c2 is given with the thresh2
field, etc. Values for N and c1,...,cN default to 1.</p>

<p style="margin-top: 1em">In order to match an event with
the rule, pattern and context fields are evaluated first. If
they don&rsquo;t match the event, then pattern2 and context2
are evaluated, etc. If all N <br>
conditions are tried without a success, the event
doesn&rsquo;t match the rule.</p>

<p style="margin-top: 1em">When an event has matched the
rule, SEC evaluates the operation description string given
with the desc field. If the operation for the given string
and rule does not exist, SEC <br>
will create it with the lifetime of T seconds. The operation
will memorize the occurrence time of the event (current time
as returned by the time(2) system call), and compare the
<br>
number of memorized occurrence times for each eK with the
threshold cK (i.e., the number of observed instances of eK
is compared with the threshold cK). If all threshold
confi&acirc; <br>
tions are satisfied, the operation executes the action list
defined by the action field, and consumes all further
matching events without re-executing the action list if the
mul&acirc; <br>
tact field is set to No (this is the default). However, if
multact is set to Yes, the operation will re-evaluate the
threshold conditions on every further matching event, re-
<br>
executing the action list given with the action field if all
conditions are satisfied, and sliding the event correlation
window forward when the window is about to expire (if no
<br>
events remain in the window, the operation will finish).</p>

<p style="margin-top: 1em">If the rule definition has an
optional action list defined with the countK field for event
eK, the operation executes it every time an instance of eK
is observed (even if multact <br>
is set to No and the operation has already executed the
action list given with action).</p>

<p style="margin-top: 1em">If the rule definition has an
optional action list defined with the init field, the
operation executes it immediately after the operation has
been created.</p>

<p style="margin-top: 1em">If the rule definition has an
optional action list defined with the end field, the
operation executes it immediately before the operation
finishes. Note that this action list is <br>
*not* executed when the operation is terminated with the
reset action.</p>

<p style="margin-top: 1em">If the rule definition has an
optional action list defined with the slide field, the
operation executes it immediately after the event
correlation window has slidden forward. <br>
However, note that moving the window with the setwpos action
will *not* trigger the execution.</p>

<p style="margin-top: 1em">The EventGroup rule supports the
following fields:</p>

<p style="margin-top: 1em">type EventGroup[N] (value is
case insensitive, N defaults to 1).</p>

<p style="margin-top: 1em">continue (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive). Specifies
the point-of-continue after a match by pattern and
context.</p>

<p style="margin-top: 1em">ptype pattern type for pattern
(value is case insensitive).</p>

<p style="margin-top: 1em">pattern <br>
pattern.</p>

<p style="margin-top: 1em">varmap (optional) <br>
variable map for pattern.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression, evaluated together with pattern.</p>

<p style="margin-top: 1em">count (optional) <br>
action list for execution after a match by pattern and
context.</p>

<p style="margin-top: 1em">thresh (optional) <br>
counting threshold for events matched by pattern and context
(value is an integer constant, default is 1).</p>

<p style="margin-top: 1em">...</p>

<p style="margin-top: 1em">continueN (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive). Specifies
the point-of-continue after a match by patternN and
contextN.</p>

<p style="margin-top: 1em">ptypeN pattern type for patternN
(value is case insensitive).</p>

<p style="margin-top: 1em">patternN <br>
pattern.</p>

<p style="margin-top: 1em">varmapN (optional) <br>
variable map for patternN.</p>

<p style="margin-top: 1em">contextN (optional) <br>
context expression, evaluated together with patternN.</p>

<p style="margin-top: 1em">countN (optional) <br>
action list for execution after a match by patternN and
contextN.</p>

<p style="margin-top: 1em">threshN (optional) <br>
counting threshold for events matched by patternN and
contextN (value is an integer constant, default is 1).</p>

<p style="margin-top: 1em">desc operation description
string.</p>

<p style="margin-top: 1em">action action list.</p>

<p style="margin-top: 1em">init (optional) <br>
action list.</p>

<p style="margin-top: 1em">end (optional) <br>
action list.</p>

<p style="margin-top: 1em">slide (optional) <br>
action list.</p>

<p style="margin-top: 1em">multact (optional) <br>
Yes or No (values are case insensitive, default is No).</p>

<p style="margin-top: 1em">window event correlation window
size (value is an integer constant).</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that match variables may be
used in context*, count*, desc, action, init, end, and slide
fields.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">The following example rule
cross-correlates iptables events, Apache web server access
log messages with 4xx response codes, and SSH login failure
events:</p>

<p style="margin-top: 1em">type=EventGroup3 <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for (?:invalid user )? from ([.]+)
port + ssh2 <br>
thresh=2 <br>
ptype2=RegExp <br>
pattern2=^([.]+) &quot;.+? HTTP[.]+&quot; 4+ <br>
thresh2=3 <br>
ptype3=RegExp <br>
pattern3=kernel: iptables:.* SRC=([.]+) <br>
thresh3=5 <br>
desc=Repeated probing from host $1 <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=120</p>

<p style="margin-top: 1em">The rule starts an event
correlation operation for an IP address if SSH login failure
event, iptables event, or Apache 4xx event is observed for
that IP address. The operation <br>
sends an e-mail warning to root@localhost if within 120
seconds three threshold conditions are satisfied for the IP
address it tracks -- (1) at least two SSH login failure
events <br>
have occurred for this client IP, (2) at least three Apache
4xx events have occured for this client IP, (3) at least
five iptables events have been observed for this source
IP.</p>

<p style="margin-top: 1em">Suppose the following events
occur, and each event timestamp reflects the time SEC
observes the event:</p>

<p style="margin-top: 1em">192.168.1.104 - -
[05/Jan/2014:01:11:22 +0200] &quot;GET /test.html
HTTP/1.1&quot; 404 286 &quot;-&quot; &quot;Mozilla/5.0 (X11;
Ubuntu; Linux i686; rv:26.0) Gecko/20100101
Firefox/26.0&quot; <br>
Jan 5 01:12:52 localhost kernel: iptables: IN=eth0 OUT=
MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00
SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10
PREC=0x00 TTL=64 <br>
ID=48422 DF PROTO=TCP SPT=46351 DPT=21 WINDOW=29200 RES=0x00
SYN URGP=0 <br>
Jan 5 01:12:53 localhost kernel: iptables: IN=eth0 OUT=
MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00
SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10
PREC=0x00 TTL=64 <br>
ID=48423 DF PROTO=TCP SPT=46351 DPT=21 WINDOW=29200 RES=0x00
SYN URGP=0 <br>
Jan 5 01:13:01 localhost kernel: iptables: IN=eth0 OUT=
MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00
SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10
PREC=0x00 TTL=64 <br>
ID=20048 DF PROTO=TCP SPT=44963 DPT=23 WINDOW=29200 RES=0x00
SYN URGP=0 <br>
Jan 5 01:13:02 localhost kernel: iptables: IN=eth0 OUT=
MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00
SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10
PREC=0x00 TTL=64 <br>
ID=20049 DF PROTO=TCP SPT=44963 DPT=23 WINDOW=29200 RES=0x00
SYN URGP=0 <br>
Jan 5 01:13:08 localhost kernel: iptables: IN=eth0 OUT=
MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00
SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10
PREC=0x00 TTL=64 <br>
ID=36362 DF PROTO=TCP SPT=56918 DPT=25 WINDOW=29200 RES=0x00
SYN URGP=0 <br>
Jan 5 01:13:09 localhost kernel: iptables: IN=eth0 OUT=
MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00
SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10
PREC=0x00 TTL=64 <br>
ID=36363 DF PROTO=TCP SPT=56918 DPT=25 WINDOW=29200 RES=0x00
SYN URGP=0 <br>
192.168.1.104 - - [05/Jan/2014:01:13:51 +0200] &quot;GET
/test.html HTTP/1.1&quot; 404 286 &quot;-&quot;
&quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0)
Gecko/20100101 Firefox/26.0&quot; <br>
192.168.1.104 - - [05/Jan/2014:01:13:54 +0200] &quot;GET
/test.html HTTP/1.1&quot; 404 286 &quot;-&quot;
&quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0)
Gecko/20100101 Firefox/26.0&quot; <br>
192.168.1.104 - - [05/Jan/2014:01:14:00 +0200] &quot;GET
/login.html HTTP/1.1&quot; 404 287 &quot;-&quot;
&quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0)
Gecko/20100101 Firefox/26.0&quot; <br>
192.168.1.104 - - [05/Jan/2014:01:14:03 +0200] &quot;GET
/login.html HTTP/1.1&quot; 404 287 &quot;-&quot;
&quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0)
Gecko/20100101 Firefox/26.0&quot; <br>
192.168.1.104 - - [05/Jan/2014:01:14:03 +0200] &quot;GET
/login.html HTTP/1.1&quot; 404 287 &quot;-&quot;
&quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0)
Gecko/20100101 Firefox/26.0&quot; <br>
Jan 5 01:14:11 localhost sshd[1810]: Failed password for
root from 192.168.1.104 port 46125 ssh2 <br>
Jan 5 01:14:12 localhost sshd[1810]: Failed password for
root from 192.168.1.104 port 46125 ssh2 <br>
Jan 5 01:14:18 localhost sshd[1822]: Failed password for
root from 192.168.1.104 port 46126 ssh2 <br>
Jan 5 01:14:19 localhost sshd[1822]: Failed password for
root from 192.168.1.104 port 46126 ssh2 <br>
192.168.1.104 - - [05/Jan/2014:01:14:34 +0200] &quot;GET
/test.html HTTP/1.1&quot; 404 286 &quot;-&quot;
&quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0)
Gecko/20100101 Firefox/26.0&quot;</p>

<p style="margin-top: 1em">The Apache 4xx event at 01:11:22
starts an event correlation operation for 192.168.1.104
which has the event correlation window of 120 seconds, thus
ending at 01:13:22. Between <br>
01:12:52 and 01:13:09, six iptables events appear for
192.168.1.104, and the appearance of the fifth event at
01:13:08 fulfills the third threshold condition (within 120
seconds, <br>
at least five iptables events have been observed).</p>

<p style="margin-top: 1em">Since by 01:13:22 (the end of
the event correlation window) no additional events have
occurred, the first and second threshold condition remain
unsatisfied. Therefore, the <br>
beginning of the event correlation window will be moved to
01:12:52 (the occurrence time of the earliest event which is
at most 120 seconds old). As a result, the end of the <br>
window will move from 01:13:22 to 01:14:52. The only event
which is left outside the window is the Apache 4xx event at
01:11:22, and thus the threshold condition for iptables <br>
events remains satisfied.</p>

<p style="margin-top: 1em">Between 01:13:51 and 01:14:03,
five Apache 4xx events occur, and the appearance of the
third event at 01:14:00 fulfills the second threshold
condition (within 120 seconds, at <br>
least three Apache 4xx events have been observed). These
events are followed by four SSH login failure events which
occur between 01:14:11 and 01:14:19. The appearance of the
<br>
second event at 01:14:12 fulfills the first threshold
condition (within 120 seconds, at least two SSH login
failure events have been observed). Since at this particular
moment <br>
(01:14:12) the other two conditions are also fulfilled, the
operation sends an e-mail warning about 192.168.1.104 to
root@localhost. After that, the operation silently consumes
<br>
all further matching events for 192.168.1.104 until
01:14:52, and then terminates.</p>

<p style="margin-top: 1em">Please note that if the above
rule definition would contain multact=yes statement, the
operation would continue sending e-mails at each matching
event after 01:14:12, provided <br>
that all threshold conditions are satisfied. Therefore, the
operation would send three additional e-mails at 01:14:18,
01:14:19, and 01:14:34. Also, the operation would not <br>
terminate after its window ends at 01:14:52, but would
rather slide the window forward and expect new events. At
the occurence of any iptables, SSH login failure or Apache
4xx <br>
event for 192.168.1.104, the operation would produce a
warning e-mail if all threshold conditions are
fulfilled.</p>

<p style="margin-top: 1em">The following example rule
cross-correlates iptables events and SSH login events:</p>

<p style="margin-top: 1em">type=EventGroup3 <br>
ptype=regexp <br>
pattern=sshd: Failed .+ for () from ([.]+) port + ssh2 <br>
varmap= user=1; ip=2 <br>
count=alias OPER_$+{ip} LOGIN_FAILED_$+{user}_$+{ip} <br>
ptype2=regexp <br>
pattern2=sshd: Accepted .+ for () from ([.]+) port + ssh2
<br>
varmap2= user=1; ip=2 <br>
context2=LOGIN_FAILED_$+{user}_$+{ip} <br>
ptype3=regexp <br>
pattern3=kernel: iptables:.* SRC=([.]+) <br>
varmap3= ip=1 <br>
desc=Client $+{ip} accessed a firewalled port and had
difficulties with logging in <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
init=create OPER_$+{ip} <br>
slide=delete OPER_$+{ip}; reset 0 <br>
end=delete OPER_$+{ip} <br>
window=120</p>

<p style="margin-top: 1em">The rule starts an event
correlation operation for an IP address if SSH login failure
or iptables event was observed for that IP address. The
operation exists for 120 seconds <br>
(since when the event correlation window slides forward, the
operation terminates itself with the reset action as
specified with the slide field). The operation sends an
e-mail <br>
warning to root@localhost if within 120 seconds three
threshold conditions are satisfied for the IP address it
tracks -- (1) at least one iptables event has been observed
for <br>
this source IP, (2) at least one SSH login failure has been
observed for this client IP, (3) at least one successful SSH
login has been observed for this client IP and for some <br>
user, provided that the operation has previously observed an
SSH login failure for the same user and same client IP.</p>

<p style="margin-top: 1em">Suppose the following events
occur, and each event timestamp reflects the time SEC
observes the event:</p>

<p style="margin-top: 1em">Dec 27 19:00:06 test kernel:
iptables: IN=eth0 OUT=
MAC=00:13:72:8a:83:d2:00:1b:25:07:e2:1b:08:00 SRC=10.1.2.7
DST=10.2.5.5 LEN=60 TOS=0x00 PREC=0x00 TTL=62 ID=1881 DF
PROTO=TCP <br>
SPT=34342 DPT=23 WINDOW=5840 RES=0x00 SYN URGP=0 <br>
Dec 27 19:00:14 test sshd[10520]: Accepted password for root
from 10.1.2.7 port 52609 ssh2 <br>
Dec 27 19:00:24 test sshd[10526]: Failed password for risto
from 10.1.2.7 port 52622 ssh2 <br>
Dec 27 19:00:27 test sshd[10526]: Accepted password for
risto from 10.1.2.7 port 52622 ssh2</p>

<p style="margin-top: 1em">The iptables event at 19:00:06
starts an event correlation operation for 10.1.2.7 which has
the event correlation window of 120 seconds. Immediately
after the operation has been <br>
started, it creates the context OPER_10.1.2.7. The second
event at 19:00:14 does not match the rule, since the context
LOGIN_FAILED_root_10.1.2.7 does not exist. The third <br>
event at 19:00:24 matches the rule, and the operation which
is running for 10.1.2.7 sets up the alias name
LOGIN_FAILED_risto_10.1.2.7 for the context OPER_10.1.2.7.
Finally, <br>
the fourth event at 19:00:27 matches the rule, since the
context LOGIN_FAILED_risto_10.1.2.7 exists, and the event is
therefore processed by the operation (the presence of the
<br>
context indicates that the operation has previously observed
a login failure for user risto from 10.1.2.7). At this
particular moment (19:00:27), all three threshold conditions
<br>
for the operation are fulfilled, and therefore it sends an
e-mail warning about 10.1.2.7 to root@localhost. After that,
the operation silently consumes all further matching <br>
events for 10.1.2.7 until 19:02:06, and then terminates.
Immediately before termination, the operation deletes the
context OPER_10.1.2.7 which also drops its alias name <br>
LOGIN_FAILED_risto_10.1.2.7.</p>

<p style="margin-top: 1em">SUPPRESS RULE <br>
The Suppress rule takes no action when an event has matched
the rule, and keeps matching events from being processed by
later rules in the configuration file.</p>

<p style="margin-top: 1em">The Suppress rule supports the
following fields:</p>

<p style="margin-top: 1em">type fixed to Suppress (value is
case insensitive).</p>

<p style="margin-top: 1em">ptype pattern type (value is
case insensitive).</p>

<p style="margin-top: 1em">pattern <br>
pattern.</p>

<p style="margin-top: 1em">varmap (optional) <br>
variable map.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression.</p>

<p style="margin-top: 1em">desc (optional) <br>
string for describing the rule.</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that match variables may be
used in the context field. Also note that this rule does not
start an event correlation operation, and the optional desc
field is merely used <br>
for describing the rule.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">type=Suppress <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for from ([.]+) port + ssh2 <br>
context=SUPPRESS_IP_$1</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for () from ([.]+) port + ssh2 <br>
desc=Three SSH login failures within 1m for user $1 from $2
<br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost;
create SUPPRESS_IP_$2 3600 <br>
window=60 <br>
thresh=3</p>

<p style="margin-top: 1em">The first rule filters out SSH
login failure events for an already reported source IP
address, so that they will not be matched against the second
rule during 3600 seconds after <br>
sending an e-mail warning.</p>

<p style="margin-top: 1em">CALENDAR RULE <br>
The Calendar rule was designed for executing actions at
specific times. Unlike all other rules, this rule reacts
only to the system clock, ignoring other input. The Calendar
<br>
rule executes the action list given with the action field if
the current time matches all conditions of the time
specification given with the time field. The action list is
exe&acirc; <br>
cuted only once for any matching minute.</p>

<p style="margin-top: 1em">The rule employs a time
specification which closely resembles the crontab(1) style,
but there are some subtle differences. The time
specification consists of five or six condi&acirc; <br>
tions separated by whitespace. The first condition matches
minutes (allowed values are 0-59), the second condition
matches hours (allowed values are 0-23), the third condition
<br>
days (allowed values are 0-31, with 0 denoting the last day
of the month), the fourth condition months (allowed values
are 1-12), and the fifth condition weekdays (allowed values
<br>
are 0-7, with 0 and 7 denoting Sunday). The sixth condition
is optional and matches years (allowed values are 0-99 which
denote the last two digits of the year).</p>

<p style="margin-top: 1em">Asterisks (*), ranges of numbers
(e.g., 8-11), and lists (e.g., 2,5,7-9) are allowed as
conditions. Asterisks and ranges may be augmented with step
values (e.g., 47-55/2 means <br>
47,49,51,53,55).</p>

<p style="margin-top: 1em">Note that unlike crontab(1) time
specification, the day and weekday conditions are *not*
joined with logical OR, but rather with logical AND.
Therefore, 0 1 25-31 10 7 means 1AM <br>
on last Sunday in October. On the other hand, with
crontab(1) the same specification means 1AM in every last
seven days or every Sunday in October.</p>

<p style="margin-top: 1em">Also, unlike some versions of
cron(8), SEC is not restricted to take action only during
the first second of the current minute. For example, if SEC
is started at the 22th second <br>
of a minute, the wildcard condition produces a match for
this minute. As another example, if the time specification
matches the current minute but the context expression
evalu&acirc; <br>
ates FALSE during the first half of the minute, the Calendar
rule will execute the action list in the middle of this
minute when the expression value becomes TRUE.</p>

<p style="margin-top: 1em">The Calendar rule supports the
following fields:</p>

<p style="margin-top: 1em">type fixed to Calendar (value is
case insensitive).</p>

<p style="margin-top: 1em">time time specification.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression.</p>

<p style="margin-top: 1em">desc operation description
string.</p>

<p style="margin-top: 1em">action action list.</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that this rule does not
start event correlation operation, and the desc field is
merely used for setting the %s action list variable.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">type=Calendar <br>
time=0 2 25-31 3,12 6 <br>
desc=Check if backup is done on last Saturday of Q1 and Q4
<br>
action=event WAITING_FOR_BACKUP</p>

<p style="margin-top: 1em">type=Calendar <br>
time=0 2 24-30 6,9 6 <br>
desc=Check if backup is done on last Saturday of Q2 and Q3
<br>
action=event WAITING_FOR_BACKUP</p>

<p style="margin-top: 1em">type=PairWithWindow <br>
ptype=SubStr <br>
pattern=WAITING_FOR_BACKUP <br>
desc=Quarterly backup not completed on time! <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
ptype2=SubStr <br>
pattern2=BACKUP READY <br>
desc2=Quarterly backup successfully completed <br>
action2=none <br>
window=1800</p>

<p style="margin-top: 1em">The first two rules create a
synthetic event WAITING_FOR_BACKUP at 2AM on last Saturday
of March, June, September and December. The third rule
matches this event and starts an <br>
event correlation operation which waits for the BACKUP READY
event for 1800 seconds. If this event has not arrived by
2:30AM, the operation sends an e-mail warning to
root@local&acirc; <br>
host.</p>

<p style="margin-top: 1em">JUMP RULE <br>
The Jump rule submits matching events to specific ruleset(s)
for further processing. If the event matches the rule, SEC
continues the search for matching rules in configuration
<br>
file set(s) given with the cfset field. Rules from every
file are tried in the order of their appearance in the file.
Configuration file sets can be created from Options rules
<br>
with the joincfset field, with each set containing at least
one configuration file. If more that one set name is given
with cfset, sets are processed from left to right; a <br>
matching rule in one set doesn&rsquo;t prevent SEC from
processing the following sets. If the constset field is set
to Yes, set names are assumed to be constants and will not
be <br>
searched for match variables at runtime.</p>

<p style="margin-top: 1em">The Jump rule supports the
following fields:</p>

<p style="margin-top: 1em">type fixed to Jump (value is
case insensitive).</p>

<p style="margin-top: 1em">continue (optional) <br>
TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart
from &lt;label&gt;, values are case insensitive).</p>

<p style="margin-top: 1em">ptype pattern type (value is
case insensitive).</p>

<p style="margin-top: 1em">pattern <br>
pattern.</p>

<p style="margin-top: 1em">varmap (optional) <br>
variable map.</p>

<p style="margin-top: 1em">context (optional) <br>
context expression.</p>

<p style="margin-top: 1em">cfset (optional) <br>
configuration file set names that are separated by
whitespace.</p>

<p style="margin-top: 1em">constset (optional) <br>
Yes or No (values are case insensitive, default is Yes).</p>

<p style="margin-top: 1em">desc (optional) <br>
string for describing the rule.</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Note that match variables may be
used in the context field. They may also be used in the
cfset field, provided that the constset field is set to No.
Also note that this rule <br>
does not start event correlation operations, and the
optional desc field is merely used for describing the
rule.</p>

<p style="margin-top: 1em">Finally, if the cfset field is
not present and the continue field is set to GoTo, the Jump
rule can be used for skipping rules inside the current
configuration file; if both <br>
cfset and continue are not present, Jump is identical to
Suppress.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">type=Jump <br>
ptype=RegExp <br>
pattern=sshd: <br>
cfset=sshd-rules auth-rules</p>

<p style="margin-top: 1em">When an sshd syslog message
appears in input, rules from configuration files of the set
sshd-rules are first used for matching the message, and then
rules from the configuration <br>
file set auth-rules are tried.</p>

<p style="margin-top: 1em">OPTIONS RULE <br>
The Options rule sets processing options for the ruleset in
the current configuration file. If more than one Options
rule is present in the configuration file, the last instance
<br>
overrides all previous ones. Note that the Options rule is
only processed when SEC (re)starts and reads in the
configuration file. Since this rule is not applied at
runtime, it <br>
can never match events, react to the system clock, or start
event correlation operations.</p>

<p style="margin-top: 1em">The joincfset field lists the
names of one or more configuration file sets, and the
current configuration file will be added to each set. If a
set doesn&rsquo;t exist, it will be cre&acirc; <br>
ated and the current configuration file becomes its first
member. If the procallin field is set to No, the rules from
the configuration file will be used for matching input from
<br>
Jump rules only.</p>

<p style="margin-top: 1em">The Options rule supports the
following fields:</p>

<p style="margin-top: 1em">type fixed to Options (value is
case insensitive).</p>

<p style="margin-top: 1em">joincfset (optional) <br>
configuration file set names that are separated by
whitespace.</p>

<p style="margin-top: 1em">procallin (optional) <br>
Yes or No (values are case insensitive, default is Yes).</p>

<p style="margin-top: 1em">rem (optional, may appear more
than once) <br>
remarks and comments.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">The following rule adds the
current configuration file to the set sshd-rules which is
used for matching input from Jump rules only:</p>

<p style="margin-top: 1em">type=Options <br>
joincfset=sshd-rules <br>
procallin=no</p>

<p style="margin-top: 1em">The following rule adds the
current configuration file to sets linux and solaris which
are used for matching all input:</p>

<p style="margin-top: 1em">type=Options <br>
joincfset=linux solaris</p>

<p style="margin-top: 1em">EVENT CORRELATION OPERATIONS
<br>
Event correlation operations are dynamic entities created by
rules. After creating an operation, the rule also feeds the
operation with events that need to be correlated. Since <br>
each rule can create and feed many operations which are
running simultaneously, each operation needs a unique
ID.</p>

<p style="margin-top: 1em">In order to identify event
correlation operations, SEC assigns an ID to every operation
that is composed from the configuration file name, the rule
number, and the operation <br>
description string (defined by the desc field of the rule).
If there are N rules in the configuration file (excluding
Options rules), the rule numbers belong to the range <br>
0..N-1, and the number of the k-th rule is k-1. Since each
Options rule is only processed when SEC reads in the
configuration file and is not applied at runtime, the
Options <br>
rules will not receive rule numbers. Note that since the
configuration file name and rule number are part of the
operation ID, different rules can have identical desc fields
<br>
without a danger of a clash between operations.</p>

<p style="margin-top: 1em">For example, if the
configuration file /etc/sec/my.conf contains only one
rule</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=RegExp <br>
pattern=user () login failure on () <br>
desc=Repeated login failures for user $1 on $2 <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=60 <br>
thresh=3</p>

<p style="margin-top: 1em">then the number of this rule is
0. When this rule matches an input event &quot;user admin
login failure on tty1&quot;, the desc field yields an
operation description string Repeated login <br>
failures for user admin on tty1, and the event will be
directed for further processing to the operation with the
following ID:</p>

<p style="margin-top: 1em">/etc/sec/my.conf | 0 | Repeated
login failures for user admin on tty1</p>

<p style="margin-top: 1em">If the operation for this ID
does not exist, the rule will create it. The newly created
operation has its event counter initialized to 1, and it
expects to receive two addi&acirc; <br>
tional &quot;user admin login failure on tty1&quot; events
from the rule within the following 60 seconds. If the
operation receives such an event, its event counter is
incremented, and if <br>
the counter reaches the value of 3, a warning e-mail is sent
to root@localhost.</p>

<p style="margin-top: 1em">By tuning the desc field of the
rule, the scope of individual event correlation operations
can be changed. For instance, if the following events occur
within 10 seconds</p>

<p style="margin-top: 1em">user admin login failure on tty1
<br>
user admin login failure on tty5 <br>
user admin login failure on tty2</p>

<p style="margin-top: 1em">the above rule starts three
event correlation operations. However, if the desc field of
the rule is changed to Repeated login failures for user $1,
these events are processed by <br>
the *same* event correlation operation (the operation sends
a warning e-mail to root@localhost when it receives the
third event).</p>

<p style="margin-top: 1em">Since rules from the same
configuration file are matched against input in the order
they are given, the rule ordering influences the creation
and feeding of event correlation <br>
operations. Suppose the configuration file /etc/sec/my.conf
contains the following rules:</p>

<p style="margin-top: 1em">type=Suppress <br>
ptype=TValue <br>
pattern=TRUE <br>
context=MYCONTEXT</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=RegExp <br>
pattern=user () login failure on () <br>
desc=Repeated login failures for user $1 on $2 <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=60 <br>
thresh=3</p>

<p style="margin-top: 1em">The second rule is able to
create and feed event correlation operations as long as the
context MYCONTEXT does not exist. However, after MYCONTEXT
has been created, no input event <br>
will reach the second rule, and the rule is thus unable to
create new operations and feed existing ones with
events.</p>

<p style="margin-top: 1em">Note that Pair and
PairWithWindow rules can feed the same event to several
operations. Suppose the configuration file /etc/sec/my2.conf
contains the following rules:</p>

<p style="margin-top: 1em">type=Suppress <br>
ptype=SubStr <br>
pattern=test</p>

<p style="margin-top: 1em">type=Pair <br>
ptype=RegExp <br>
pattern=database () down <br>
desc=Database $1 is down <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
ptype2=RegExp <br>
pattern2=database $1 up|all databases up <br>
desc2=Database %1 is up <br>
action2=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=86400</p>

<p style="margin-top: 1em">Since the following input events
don&rsquo;t contain the substring &quot;test&quot;</p>

<p style="margin-top: 1em">database mydb1 down <br>
database mydb2 down <br>
database mydb3 down</p>

<p style="margin-top: 1em">they are matched by the second
rule of type Pair which creates three event correlation
operations. Each operation is running for one particular
database name, and the operations <br>
have the following IDs:</p>

<p style="margin-top: 1em">/etc/sec/my2.conf | 1 | Database
mydb1 is down <br>
/etc/sec/my2.conf | 1 | Database mydb2 is down <br>
/etc/sec/my2.conf | 1 | Database mydb3 is down</p>

<p style="margin-top: 1em">Each newly created operation
sends an e-mail notification to root@localhost about the
&quot;database down&quot; condition, and will then wait for
86400 seconds (24 hours) for either of the <br>
following messages: <br>
(a) &quot;database up&quot; message for the given database,
<br>
(b) &quot;all databases up&quot; message.</p>

<p style="margin-top: 1em">The operation with the ID</p>

<p style="margin-top: 1em">/etc/sec/my2.conf | 1 | Database
mydb1 is down</p>

<p style="margin-top: 1em">uses the following regular
expression for matching expected messages:</p>

<p style="margin-top: 1em">database mydb1 up|all databases
up</p>

<p style="margin-top: 1em">The operation with the ID</p>

<p style="margin-top: 1em">/etc/sec/my2.conf | 1 | Database
mydb2 is down</p>

<p style="margin-top: 1em">employs the following regular
expression for matching expected messages:</p>

<p style="margin-top: 1em">database mydb2 up|all databases
up</p>

<p style="margin-top: 1em">Finally, the operation with the
ID</p>

<p style="margin-top: 1em">/etc/sec/my2.conf | 1 | Database
mydb3 is down</p>

<p style="margin-top: 1em">uses the following regular
expression:</p>

<p style="margin-top: 1em">database mydb3 up|all databases
up</p>

<p style="margin-top: 1em">If the following input events
appear after 10 minutes</p>

<p style="margin-top: 1em">database test up <br>
admin logged in <br>
database mydb3 up <br>
all databases up</p>

<p style="margin-top: 1em">the first event &quot;database
test up&quot; matches the first rule (Suppress) which does
not pass the event further to the second rule (Pair).
However, all following events reach the <br>
Pair rule. Since the messages don&rsquo;t match the pattern
field of the rule, the rule feeds them to all currently
existing operations it has created, so that the operations
can <br>
match these events with their regular expressions. Because
regular expressions of all three operations don&rsquo;t
match the event &quot;admin logged in&quot;, the operations
will continue to <br>
run. In the case of the &quot;database mydb3 up&quot; event,
the regular expression of the operation</p>

<p style="margin-top: 1em">/etc/sec/my2.conf | 1 | Database
mydb3 is down</p>

<p style="margin-top: 1em">produces a match. Therefore, the
operation will send the e-mail notification &quot;Database
mydb3 is up&quot; to root@localhost and terminate. However,
the following event &quot;all databases <br>
up&quot; matches the regular expressions of two remaining
operations. As a result, the operations will send e-mail
notifications &quot;Database mydb1 is up&quot; and
&quot;Database mydb2 is up&quot; to <br>
root@localhost and terminate.</p>

<p style="margin-top: 1em">Each operation has an event
correlation window which defines its scope in time. The size
of the window is defined by the window* field, and the
beginning of the window can be <br>
obtained with the getwpos action. SingleWithThreshold,
SingleWith2Thresholds and EventGroup operations can slide
its window forward during event processing, while for all
opera&acirc; <br>
tions the window can also be moved explicitly with the
setwpos action. Also, with the reset action event
correlation operations can be terminated. Note that getwpos,
setwpos, and <br>
reset actions only work for operations started by the rules
from the same configuration file.</p>

<p style="margin-top: 1em">For example, consider the
configuration file /etc/sec/sshd.rules that contains the
following rules:</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for () from [.]+ port + ssh2 <br>
desc=Three SSH login failures within 1m for user $1 <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=60 <br>
thresh=3</p>

<p style="margin-top: 1em">type=Single <br>
ptype=RegExp <br>
pattern=sshd: Accepted .+ for () from [.]+ port + ssh2 <br>
desc=SSH login successful for user $1 <br>
action=reset -1 Three SSH login failures within 1m for user
$1</p>

<p style="margin-top: 1em">Suppose the following events are
generated by an SSH daemon, and each event timestamp
reflects the time SEC observes the event:</p>

<p style="margin-top: 1em">Dec 29 15:00:03 test
sshd[14129]: Failed password for risto from 10.1.2.7 port
31312 ssh2 <br>
Dec 29 15:00:08 test sshd[14129]: Failed password for risto
from 10.1.2.7 port 31312 ssh2 <br>
Dec 29 15:00:17 test sshd[14129]: Accepted password for
risto from 10.1.2.7 port 31312 ssh2 <br>
Dec 29 15:00:52 test sshd[14142]: Failed password for risto
from 10.1.1.2 port 17721 ssh2</p>

<p style="margin-top: 1em">The first event at 15:00:03
starts an event correlation operation with the ID</p>

<p style="margin-top: 1em">/etc/sec/sshd.rules | 0 | Three
SSH login failures within 1m for user risto</p>

<p style="margin-top: 1em">However, when the third event
occurs at 15:00:17, the second rule matches it and
terminates the operation with the action</p>

<p style="margin-top: 1em">reset -1 Three SSH login
failures within 1m for user risto</p>

<p style="margin-top: 1em">The -1 parameter of reset
restricts the action to operations started by the previous
rule (i.e., the first rule that has a number 0), while the
Three SSH login failures within 1m <br>
for user risto parameter refers to the operation description
string. Together with the current configuration file name
(/etc/sec/sshd.rules), the parameters yield the operation
<br>
ID</p>

<p style="margin-top: 1em">/etc/sec/sshd.rules | 0 | Three
SSH login failures within 1m for user risto</p>

<p style="margin-top: 1em">(If the operation with the given
ID would not exist, reset would perform no operation.)</p>

<p style="margin-top: 1em">As a consequence, the fourth
event at 15:00:52 starts another operation with the same ID
as the terminated operation had. Without the second rule,
the operation that was started <br>
at 15:00:03 would not be terminated, and the appearance of
the fourth event would trigger a warning e-mail from that
operation.</p>

<p style="margin-top: 1em">INPUT PROCESSING AND TIMING <br>
SEC processes input data iteratively by reading one line at
each iteration, writing this line into a relevant input
buffer, and matching the content of the updated buffer with
<br>
rules from configuration files. If during the matching
process an action list is executed which creates new input
events (e.g., through the event action), they are *not*
written <br>
to buffer(s) immediately, but rather consumed at following
iterations.</p>

<p style="margin-top: 1em">Note that when both synthetic
events and regular input are available for processing,
synthetic events are always consumed first. When all
synthetic events have been consumed <br>
iteratively, SEC will start processing new data from input
files.</p>

<p style="margin-top: 1em">With the --jointbuf option, SEC
employs a joint input buffer for all input sources which
holds N last input lines (the value of N can be set with the
--bufsize option). Updating <br>
the input buffer means that the new line becomes the first
element of the buffer, while the last element (the oldest
line) is removed from the end of the buffer. With the <br>
--nojointbuf option, SEC maintains a buffer of N lines for
each input file, and if the input line comes from file F,
the buffer of F is updated as described previously. There is
<br>
also a separate buffer for synthetic and internal
events.</p>

<p style="margin-top: 1em">Suppose SEC is started with the
following command line</p>

<p style="margin-top: 1em">/usr/bin/sec
--conf=/etc/sec/test-multiline.conf --jointbuf
--input=/var/log/prog1.log --input=/var/log/prog2.log</p>

<p style="margin-top: 1em">and the configuration file
/etc/sec/test-multiline.conf has the following content:</p>

<p style="margin-top: 1em">type=Single <br>
rem=this rule matches two consecutive lines where the first
line contains &quot;test1&quot; and the second line
&quot;test2&quot;, and writes the matching lines to standard
output <br>
ptype=RegExp2 <br>
pattern=test1.*0*test2 <br>
desc=two consecutive test lines <br>
action=write - $0</p>

<p style="margin-top: 1em">When the following lines appear
in input files /var/log/prog1.log and /var/log/prog2.log</p>

<p style="margin-top: 1em">Dec 31 12:33:12 test prog1:
test1 (file /var/log/prog1.log) <br>
Dec 31 12:34:09 test prog2: test1 (file /var/log/prog2.log)
<br>
Dec 31 12:39:35 test prog1: test2 (file /var/log/prog1.log)
<br>
Dec 31 12:41:53 test prog2: test2 (file
/var/log/prog2.log)</p>

<p style="margin-top: 1em">they are stored in a common
input buffer. Therefore, rule fires after the third event
has appeared, and writes the following lines to standard
output:</p>

<p style="margin-top: 1em">Dec 31 12:34:09 test prog2:
test1 (file /var/log/prog2.log) <br>
Dec 31 12:39:35 test prog1: test2 (file
/var/log/prog1.log)</p>

<p style="margin-top: 1em">However, if SEC is started with
the --nojointbuf option, separate input buffers are set up
for /var/log/prog1.log and /var/log/prog2.log. Therefore,
the rule fires after the <br>
third event has occurred, and writes the following lines to
standard output:</p>

<p style="margin-top: 1em">Dec 31 12:33:12 test prog1:
test1 (file /var/log/prog1.log) <br>
Dec 31 12:39:35 test prog1: test2 (file
/var/log/prog1.log)</p>

<p style="margin-top: 1em">The rule also fires after the
fourth event has occurred, producing the following
output:</p>

<p style="margin-top: 1em">Dec 31 12:34:09 test prog2:
test1 (file /var/log/prog2.log) <br>
Dec 31 12:41:53 test prog2: test2 (file
/var/log/prog2.log)</p>

<p style="margin-top: 1em">The content of input buffers can
be modified with the rewrite action, and modifications
become visible immediately during ongoing event processing
iteration. Suppose SEC is <br>
started with the following command line</p>

<p style="margin-top: 1em">/usr/bin/sec
--conf=/etc/sec/test-rewrite.conf --input=- --nojointbuf</p>

<p style="margin-top: 1em">and the configuration file
/etc/sec/test-rewrite.conf has the following content:</p>

<p style="margin-top: 1em">type=Single <br>
rem=this rule matches two consecutive lines where the first
line contains &quot;test1&quot; and the second line
&quot;test2&quot;, and joins these lines in the input buffer
<br>
ptype=RegExp2 <br>
pattern=^(.*test1.*)0test2.*)$ <br>
continue=TakeNext <br>
desc=join two test lines <br>
action=rewrite 2 Joined $1 and $2</p>

<p style="margin-top: 1em">type=Single <br>
rem=this rule matches a line which begins with
&quot;Joined&quot;, and writes this line to standard output
<br>
ptype=RegExp <br>
pattern=^Joined <br>
desc=output joined lines <br>
action=write - $0</p>

<p style="margin-top: 1em">When the following two lines
appear in standard input</p>

<p style="margin-top: 1em">This is a test1 <br>
This is a test2</p>

<p style="margin-top: 1em">they are matched by the first
rule which uses the rewrite action for replacing those two
lines in the input buffer with a new content. The last line
in the input buffer (&quot;This <br>
is a test2&quot;) is replaced with &quot;Joined This is a
test1 and This is a test2&quot;, while the previous line in
the input buffer (&quot;This is a test1&quot;) is replaced
with an empty string. <br>
Since the rule contains continue=TakeNext statement, the
matching process will continue from the following rule. This
rule matches the last line in the input buffer if it begins
<br>
with &quot;Joined&quot;, and writes the line to standard
output, producing</p>

<p style="margin-top: 1em">Joined This is a test1 and This
is a test2</p>

<p style="margin-top: 1em">After each event processing
iteration, the pattern match cache is cleared. In other
words, if a match is cached with the rule varmap* field, it
is available during ongoing iter&acirc; <br>
ation only. Note that results from a successful pattern
matching are also cached when the subsequent context
expression evaluation yields FALSE. This allows for reusing
results <br>
from partial rule matches. For example, the following rule
creates the cache entry &quot;ssh_failed_login&quot; for any
SSH failed login event, even if the context ALERTING_ON does
not <br>
exist:</p>

<p style="margin-top: 1em">type=Single <br>
ptype=RegExp <br>
pattern=sshd: Failed .+ for () from ([.]+) port + ssh2 <br>
varmap=ssh_failed_login; user=1; ip=2 <br>
context=ALERTING_ON <br>
desc=SSH login failure for user $1 from $2 <br>
action=pipe &rsquo;%s&rsquo; /bin/mail -s &rsquo;SSH login
alert&rsquo; root@localhost</p>

<p style="margin-top: 1em">However, provided the context
expression does not contain match variables, enclosing the
expression in square brackets (e.g., [ALERTING_ON]) forces
its evaluation before the pat&acirc; <br>
tern matching, and will thus prevent the matching and the
creation of the cache entry if the evaluation yields
FALSE.</p>

<p style="margin-top: 1em">Rules from the same
configuration file are matched against the buffer content in
the order they are given in that file. When multiple
configuration files have been specified, <br>
rule sequences from all files are matched against the buffer
content (unless specified otherwise with Options rules). The
matching order is determined by the order of
configura&acirc; <br>
tion files in SEC command line. For example, if the Perl
glob() function returns filenames in ascending ASCII order,
and configuration files /home/risto/A.conf, <br>
/home/risto/B.conf2, and /home/risto/C.conf are specified
with --conf=/home/risto/*.conf --conf=/home/risto/*.conf2 in
SEC command line, then SEC first matches the input against
<br>
the rule sequence from A.conf, then from C.conf, and finally
from B.conf2. Also, note that even if A.conf contains a
Suppress rule for a particular event, the event is still
<br>
processed by rulesets in C.conf and B.conf2. However, note
that glob() might return file names in different order if
locale settings change. If you want to enforce a fixed order
<br>
for configuration file application in a portable way, it is
recommended to create a unique set for each file with the
Options rule, and employ the Jump rule for defining the
pro&acirc; <br>
cessing order for sets, e.g.:</p>

<p style="margin-top: 1em"># This rule appears in A.conf
<br>
type=Options <br>
joincfset=FileA <br>
procallin=no</p>

<p style="margin-top: 1em"># This rule appears in B.conf2
<br>
type=Options <br>
joincfset=FileB <br>
procallin=no</p>

<p style="margin-top: 1em"># This rule appears in C.conf
<br>
type=Options <br>
joincfset=FileC <br>
procallin=no</p>

<p style="margin-top: 1em"># This rule appears in main.conf
<br>
type=Jump <br>
ptype=TValue <br>
pattern=TRUE <br>
cfset=FileA FileC FileB</p>

<p style="margin-top: 1em">After the relevant input buffer
has been updated and its content has been matched by the
rules, SEC handles caught signals and checks the status of
child processes. When the <br>
timeout specified with the --cleantime option has expired,
SEC also checks the status of contexts and event correlation
operations. Therefore, relatively small values should be
<br>
specified with the --cleantime option, in order to retain
the accuracy of the event correlation process. If the
--cleantime option is set to 0, SEC checks event correlation
<br>
operations and contexts after processing every input line,
but this consumes more CPU time. If the --poll-timeout
option value exceeds the value given with --cleantime, the
<br>
--poll-timeout option value takes precedence (i.e., sleeps
after unsuccessful polls will not be shortened).</p>

<p style="margin-top: 1em">Finally, note that apart from
the sleeps after unsuccessful polls, SEC measures all time
intervals and occurrence times in seconds, and always uses
the time(2) system call for <br>
obtaining the current time. Also, for input event occurrence
time SEC always uses the time it observed the event, *not*
the timestamp extracted from the event.</p>

<p style="margin-top: 1em">INTERNAL EVENTS AND CONTEXTS
<br>
In the action list of a context, the context can also be
referred with the internal context name _THIS. The name
_THIS is created and deleted dynamically by SEC and it
points to <br>
the context only during its action list execution. This
feature is useful when the context has had several names
during its lifetime (created with the alias action), and it
is <br>
hard to determine which names exist when the context
expires. For example, if the context is created with create
A 60 (report A /bin/mail root) which is immediately followed
by <br>
alias A B and unalias A, the report action will fail since
the name A no longer refers to the context. However,
replacing the first action with create A 60 (report _THIS
<br>
/bin/mail root) will produce the correct result.</p>

<p style="margin-top: 1em">If the --intevents command line
option is given, SEC will generate internal events when it
is started up, when it receives certain signals, and when it
terminates normally. <br>
Inside SEC, internal event is treated as if it was a line
that was read from a SEC input file. Specific rules can be
written to match internal events, in order to take some <br>
action (e.g., start an external event correlation module
with spawn when SEC starts up). The following internal
events are supported:</p>

<p style="margin-top: 1em">SEC_STARTUP - generated when SEC
is started (this event will always be the first event that
SEC sees)</p>

<p style="margin-top: 1em">SEC_PRE_RESTART - generated
before processing of the SIGHUP signal (this event will be
the last event that SEC sees before clearing all internal
data structures and reloading its <br>
configuration)</p>

<p style="margin-top: 1em">SEC_RESTART - generated after
processing of the SIGHUP signal (this event will be the
first event that SEC sees after clearing all internal data
structures and reloading its con&acirc; <br>
figuration)</p>

<p style="margin-top: 1em">SEC_PRE_SOFTRESTART - generated
before processing of the SIGABRT signal (this event will be
the last event that SEC sees before reloading its
configuration)</p>

<p style="margin-top: 1em">SEC_SOFTRESTART - generated
after processing of the SIGABRT signal (this event will be
the first event that SEC sees after reloading its
configuration)</p>

<p style="margin-top: 1em">SEC_PRE_LOGROTATE - generated
before processing of the SIGUSR2 signal (this event will be
the last event that SEC sees before reopening its log file
and closing its outputs)</p>

<p style="margin-top: 1em">SEC_LOGROTATE - generated after
processing of the SIGUSR2 signal (this event will be the
first event that SEC sees after reopening its log file and
closing its outputs)</p>

<p style="margin-top: 1em">SEC_SHUTDOWN - generated when
SEC receives the SIGTERM signal, or when SEC reaches all
EOFs of input files after being started with the --notail
option. With the --childterm <br>
option, SEC sleeps for 3 seconds after generating
SEC_SHUTDOWN event, and then sends SIGTERM to its child
processes (if a child process was triggered by SEC_SHUTDOWN,
this delay <br>
leaves the process enough time for setting a signal handler
for SIGTERM).</p>

<p style="margin-top: 1em">Before generating an internal
event, SEC sets up a context named SEC_INTERNAL_EVENT, in
order to disambiguate internal events from regular input.
The SEC_INTERNAL_EVENT context <br>
is deleted immediately after the internal event has been
matched against all rules.</p>

<p style="margin-top: 1em">If the --intcontexts command
line option is given, or there is an --input option with a
context specified, SEC creates an internal context each time
it reads a line from an input <br>
file or a synthetic event. The internal context is deleted
immediately after the line has been matched against all
rules. For all input files that have the context name
explic&acirc; <br>
itly set with --input=&lt;file_pattern&gt;=&lt;context&gt;,
the name of the internal context is &lt;context&gt;. If the
line was read from the input file &lt;filename&gt; for which
there is no context <br>
name set, the name of the internal context is
_FILE_EVENT_&lt;filename&gt;. For synthetic events, the name
of the internal context defaults to _INTERNAL_EVENT, but
cspawn and cevent <br>
actions can be used for generating synthetic events with
custom internal context names. This allows for writing rules
that match data from one particular input source only. For
<br>
example, the rule</p>

<p style="margin-top: 1em">type=Suppress <br>
ptype=TValue <br>
pattern=TRUE <br>
context=[!_FILE_EVENT_/dev/logpipe]</p>

<p style="margin-top: 1em">passes only the lines that were
read from /dev/logpipe, and also synthetic events that were
generated with the _FILE_EVENT_/dev/logpipe internal context
(e.g., with the action <br>
cevent _FILE_EVENT_/dev/logpipe 0 This is a test event). As
another example, if SEC has been started with the command
line</p>

<p style="margin-top: 1em">/usr/bin/sec --intevents
--intcontexts --conf=/etc/sec/my.conf
--input=/var/log/messages=MESSAGES
--input=/var/log/secure=SECURE
--input=/var/log/cron=CRON</p>

<p style="margin-top: 1em">and the rule file
/etc/sec/my.conf contains the following rules</p>

<p style="margin-top: 1em">type=Single <br>
ptype=RegExp <br>
pattern=^(?:SEC_STARTUP|SEC_RESTART)$ <br>
context=[SEC_INTERNAL_EVENT] <br>
desc=listen on 10514/tcp for incoming events <br>
action=cspawn MESSAGES /usr/bin/nc -l -k 10514</p>

<p style="margin-top: 1em">type=Single <br>
ptype=RegExp <br>
pattern=. <br>
context=[MESSAGES] <br>
desc=echo everything from 10514/tcp and /var/log/messages
<br>
action=write - $0</p>

<p style="margin-top: 1em">then SEC will receive input
lines from the log files /var/log/messages, /var/log/secure,
and /var/log/cron, and will also run /usr/bin/nc for
receiving input lines from the port <br>
10514/tcp. All input lines from /var/log/messages and
10514/tcp are matched by the second rule and written to
standard output.</p>

<p style="margin-top: 1em">INTERPROCESS COMMUNICATION <br>
The SingleWithScript rule and shellcmd, spawn, cspawn, pipe,
and report actions fork a child process for executing an
external program. If the program command line contains <br>
shell metacharacters, the command line is first parsed by
the shell which then starts the program. SEC communicates
with its child processes through pipes (created with the
<br>
pipe(2) system call). When the child process is at the read
end of the pipe, data have to be written to the pipe in
blocking mode which ensures reliable data transmission. In
<br>
order to avoid being blocked, SEC forks another child
process for writing data to the pipe reliably.</p>

<p style="margin-top: 1em">After forking an external
program, SEC continues immediately, and checks the program
status periodically until the program exits. The running
time of a child process is not lim&acirc; <br>
ited in any way. With the --childterm option, SEC sends the
SIGTERM signal to all child processes when it terminates. If
some special exit procedures need to be accomplished in <br>
the child process (or the child wishes to ignore SIGTERM),
then the child must install a handler for the SIGTERM
signal. Note that if the program command line contains shell
<br>
metacharacters, the parsing shell will run as a child
process of SEC and the parent process of the program.
Therefore, the SIGTERM signal will be sent to the shell,
*not* the <br>
program. In order to avoid this, the shell&rsquo;s builtin
exec command can be used (see sh(1) for more information)
which replaces the shell with the program without forking a
new <br>
process, e.g.,</p>

<p style="margin-top: 1em">action=spawn exec
/usr/local/bin/myscript.pl 2&gt;/var/log/myscript.log</p>

<p style="margin-top: 1em">Note that if an action list
includes two actions which fork external programs, the
execution order these programs is not determined by the
order of actions in the list, since <br>
both programs are running asynchronously. In order to
address this issue, the execution order must be specified
explicitly (e.g., instead of writing action=shellcmd cmd1;
shell&acirc; <br>
cmd cmd2, use the shell &amp;&amp; operator and write
action=shellcmd cmd1 &amp;&amp; cmd2).</p>

<p style="margin-top: 1em">Sometimes it is desireable to
start an external program and provide it with data from
several rules. In order to create such setup, named pipes
can be harnessed. For example, if <br>
/var/log/pipe is a named pipe, then</p>

<p style="margin-top: 1em">action=shellcmd /usr/bin/logger
-f /var/log/pipe -p user.notice</p>

<p style="margin-top: 1em">starts the /usr/bin/logger
utility which sends all lines read from /var/log/pipe to the
local syslog daemon with the &quot;user&quot; facility and
&quot;notice&quot; level. In order to feed events <br>
to /usr/bin/logger, the write action can be used (e.g.,
write /var/log/pipe This is my event). Although SEC keeps
the named pipe open across different write actions, the pipe
<br>
will be closed on the reception of SIGHUP, SIGABRT and
SIGUSR2 signals. Since many UNIX tools terminate on
receiving EOF from standard input, they need restarting
after such <br>
signals have arrived. For this purpose, the --intevents
option and SEC internal events can be used. For example, the
following rule starts the /usr/bin/logger utility at SEC
<br>
startup, and also restarts it after the reception of
relevant signals:</p>

<p style="margin-top: 1em">type=Single <br>
ptype=RegExp <br>

pattern=^(?:SEC_STARTUP|SEC_RESTART|SEC_SOFTRESTART|SEC_LOGROTATE)$
<br>
context=SEC_INTERNAL_EVENT <br>
desc=start the logger tool <br>
action=free %emptystring; owritecl /var/log/pipe
%emptystring; shellcmd /usr/bin/logger -f /var/log/pipe -p
user.notice</p>

<p style="margin-top: 1em">Note that if /var/log/pipe is
never opened for writing by a write action, /usr/bin/logger
will never see EOF and will thus not terminate. The owritecl
action opens and closes <br>
/var/log/pipe without writing any bytes, in order to ensure
the presence of EOF in such cases. This allows any previous
/usr/bin/logger process to terminate before the new <br>
process is started.</p>

<p style="margin-top: 1em">PERL INTEGRATION <br>
SEC supports patterns, context expressions, and actions
which involve calls to the Perl eval() function or the
execution of precompiled Perl code. The use of Perl code in
SEC <br>
patterns and context expressions allows for creating proper
match conditions for scenarios which can&rsquo;t be handled
by a simple regular expression match. For example, consider
the <br>
following iptables syslog events:</p>

<p style="margin-top: 1em">May 27 10:00:15 box1 kernel:
iptables: IN=eth0 OUT=
MAC=08:00:27:be:9e:2f:00:10:db:ff:20:03:08:00 SRC=10.6.4.14
DST=10.1.8.2 LEN=84 TOS=0x00 PREC=0x00 TTL=251 ID=61426
PROTO=ICMP <br>
TYPE=8 CODE=0 ID=11670 SEQ=2 <br>
May 27 10:02:22 box1 kernel: iptables: IN=eth0 OUT=
MAC=08:00:27:be:9e:2f:00:10:db:ff:20:03:08:00 SRC=10.6.4.14
DST=10.1.8.2 LEN=52 TOS=0x00 PREC=0x00 TTL=60 ID=61441 DF
<br>
PROTO=TCP SPT=53125 DPT=23 WINDOW=49640 RES=0x00 SYN
URGP=0</p>

<p style="margin-top: 1em">Depending on the protocol and
the nature of the traffic, events can have a wide variety of
fields, and parsing out all event data with one regular
expression is infeasible. For <br>
addressing this issue, a PerlFunc pattern can be used which
creates match variables from all fields of the matching
event, stores them in one Perl hash, and returns a reference
<br>
to this hash. Outside the PerlFunc pattern, match variables
are initialized from the key-value pairs in the returned
hash. Suppose the following Jump rule with a PerlFunc
pat&acirc; <br>
tern is defined in the main.rules rule file:</p>

<p style="margin-top: 1em">type=Jump <br>
ptype=PerlFunc <br>
pattern=sub { my(%var); my($line) = $_[0]; if ($line !~
/kernel: iptables:/g) { return 0; } while ($line =~
/G([A-Z]+)(?:=())?/g) { $var{$1} = defined($2)?$2:1; }
return var; } <br>
varmap=IPTABLES <br>
desc=parse iptables event <br>
cfset=iptables</p>

<p style="margin-top: 1em">For example, if the iptables
event contains the fields SRC=10.6.4.14, DST=10.1.8.2 and
SYN, the above PerlFunc pattern sets up match variable
$+{SRC} which holds 10.6.4.14, match <br>
variable $+{DST} which holds 10.1.8.2, and match variable
$+{SYN} which holds 1. The Jump rule caches all created
match variables under the name IPTABLES, and submits the
match&acirc; <br>
ing event to iptables ruleset for further processing.
Suppose the iptables ruleset is defined in the
iptables.rules rule file:</p>

<p style="margin-top: 1em">type=Options <br>
procallin=no <br>
joincfset=iptables</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=Cached <br>
pattern=IPTABLES <br>
context=IPTABLES :&gt; ( sub { return
$_[0]-&gt;{&quot;PROTO&quot;} eq &quot;ICMP&quot;; } ) <br>
desc=ICMP flood type $+{TYPE} code $+{CODE} from host
$+{SRC} <br>
action=logonly <br>
window=10 <br>
thresh=100</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=Cached <br>
pattern=IPTABLES <br>
context=IPTABLES :&gt; ( sub { return
exists($_[0]-&gt;{&quot;SYN&quot;}) &amp;&amp;
exists($_[0]-&gt;{&quot;FIN&quot;}) ; } ) <br>
desc=SYN+FIN flood from host $+{SRC} <br>
action=logonly <br>
window=10 <br>
thresh=100</p>

<p style="margin-top: 1em">The two SingleWithThreshold
rules employ Cached patterns for matching iptables events by
looking up the IPTABLES entry in the pattern match cache
(created by the above Jump rule <br>
for each iptables event). In order to narrow down the match
to specific iptables events, the rules employ precompiled
Perl functions in context expressions. The :&gt; operator is
<br>
used for speeding up the matching, providing the function
with a single parameter which refers to the hash of variable
name-value pairs for the IPTABLES cache entry.</p>

<p style="margin-top: 1em">The first SingleWithThreshold
rule logs a warning message if within 10 seconds 100
iptables events have been observed for ICMP packets with the
same type, code, and source IP <br>
address. The second SingleWithThreshold rule logs a warning
message if within 10 seconds 100 iptables events have been
observed for TCP packets coming from the same host, and <br>
having both SYN and FIN flag set in each packet.</p>

<p style="margin-top: 1em">Apart from using action list
variables for data sharing between rules, Perl variables
created in Perl code can be employed for the same purpose.
For example, when SEC has exe&acirc; <br>
cuted the following action</p>

<p style="margin-top: 1em">action=eval %a ($b = 1)</p>

<p style="margin-top: 1em">the variable $b and its value
become visible in the following context expression</p>

<p style="margin-top: 1em">context= =(++$b &gt; 10)</p>

<p style="margin-top: 1em">(with that expression one can
implement event counting implicitly). In order to avoid
possible clashes with variables inside the SEC code itself,
user-defined Perl code is exe&acirc; <br>
cuted in the main::SEC namespace (i.e., inside the special
package main::SEC). By using the main:: prefix, SEC data
structures can be accessed and modified. For example, the
<br>
following rules restore and save contexts on SEC startup and
shutdown (SEC keeps all contexts in %main::context_list
hash):</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=SEC_STARTUP <br>
context=SEC_INTERNAL_EVENT <br>
continue=TakeNext <br>
desc=Load the Storable module and terminate if it is not
found <br>
action=eval %ret (require Storable); if %ret ( logonly
Storabe loaded ) else ( eval %o exit(1) )</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=SEC_STARTUP <br>
context=SEC_INTERNAL_EVENT <br>
desc=Restore all SEC contexts from /var/lib/sec/SEC_CONTEXTS
on startup <br>
action=lcall %ret -&gt; ( sub { my $ptr =
$main::context_list{&quot;SEC_INTERNAL_EVENT&quot;};
%main::context_list =
%{Storable::retrieve(&quot;/var/lib/sec/SEC_CONTEXTS&quot;)};
$main::context_list{&quot;SEC_INTERNAL_EVENT&quot;} = $ptr;
} )</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=SEC_SHUTDOWN <br>
context=SEC_INTERNAL_EVENT <br>
desc=Save all SEC contexts into /var/lib/sec/SEC_CONTEXTS on
shutdown <br>
action=lcall %ret -&gt; ( sub {
Storable::store(main::context_list,
&quot;/var/lib/sec/SEC_CONTEXTS&quot;); } )</p>

<p style="margin-top: 1em">However, note that modifying
data structures within SEC code is recommended only for
advanced users who have carefully studied relevant parts of
the code.</p>

<p style="margin-top: 1em">Finally, sometimes larger chunks
of Perl code have to be used for event processing and
correlation. However, writing many lines of code directly
into a rule is cumbersome and may <br>
decrease its readability. In such cases it is recommended to
separate the code into a custom Perl module which is loaded
at SEC startup, and use the code through the module <br>
interface (see perlmod(1) for further details):</p>

<p style="margin-top: 1em">type=Single <br>
ptype=SubStr <br>
pattern=SEC_STARTUP <br>
context=SEC_INTERNAL_EVENT <br>
desc=Load the SecStuff module <br>
action=eval %ret (require
&rsquo;/usr/local/sec/SecStuff.pm&rsquo;); if %ret ( none )
else ( eval %o exit(1) )</p>

<p style="margin-top: 1em">type=Single <br>
ptype=PerlFunc <br>
pattern=sub { return SecStuff::my_match($_[0]); } <br>
desc=event &rsquo;$0&rsquo; was matched by my_match() <br>
action=write - %s</p>

<p style="margin-top: 1em">EXAMPLES <br>
Example 1 - a ruleset for Cisco events <br>
This section presents an example rulebase for managing Cisco
devices. It is assumed that the managed devices have syslog
logging enabled, and that all syslog messages are sent <br>
to a central host and written to log file(s) that are
monitored by SEC.</p>

<p style="margin-top: 1em"># Set up contexts NIGHT and
WEEKEND for nights <br>
# and weekends. The context NIGHT has a lifetime <br>
# of 8 hours and the context WEEKEND 2 days</p>

<p style="margin-top: 1em">type=Calendar <br>
time=0 23 * * * <br>
desc=NIGHT <br>
action=create %s 28800</p>

<p style="margin-top: 1em">type=Calendar <br>
time=0 0 * * 6 <br>
desc=WEEKEND <br>
action=create %s 172800</p>

<p style="margin-top: 1em"># If a router does not come up
within 5 minutes <br>
# after it was rebooted, generate event <br>
# &quot;&lt;router&gt; REBOOT FAILURE&quot;. The next rule
matches <br>
# this event, checks the router with ping and sends <br>
# a notification if there is no response.</p>

<p style="margin-top: 1em">type=PairWithWindow <br>
ptype=RegExp <br>
pattern=504 <br>
desc=$1 REBOOT FAILURE <br>
action=event %s <br>
ptype2=RegExp <br>
pattern2=+: %SYS-5-RESTART <br>
desc2=%1 successful reboot <br>
action2=logonly <br>
window=300</p>

<p style="margin-top: 1em">type=SingleWithScript <br>
ptype=RegExp <br>
pattern=^([456 <br>
script=/bin/ping -c 3 -q $1 <br>
desc=$1 did not come up after reboot <br>
action=logonly $1 is pingable after reboot <br>
action2=pipe &rsquo;%t: %s&rsquo; /bin/mail
root@localhost</p>

<p style="margin-top: 1em"># Send a notification if CPU
load of a router is too <br>
# high (two CPUHOG messages are received within 5 <br>
# minutes); send another notification if the load is <br>
# normal again (no CPUHOG messages within last 15 <br>
# minutes). Rule is not active at night or weekend.</p>

<p style="margin-top: 1em">type=SingleWith2Thresholds <br>
ptype=RegExp <br>
pattern=504 <br>
context=!(NIGHT || WEEKEND) <br>
desc=$1 CPU overload <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=300 <br>
thresh=2 <br>
desc2=$1 CPU load normal <br>
action2=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window2=900 <br>
thresh2=0</p>

<p style="margin-top: 1em"># If a router interface is in
down state for less <br>
# than 15 seconds, generate event <br>
# &quot;&lt;router&gt; INTERFACE &lt;interface&gt; SHORT
OUTAGE&quot;; <br>
# otherwise generate event <br>
# &quot;&lt;router&gt; INTERFACE &lt;interface&gt;
DOWN&quot;.</p>

<p style="margin-top: 1em">type=PairWithWindow <br>
ptype=RegExp <br>
pattern=936 <br>
desc=$1 INTERFACE $2 DOWN <br>
action=event %s <br>
ptype2=RegExp <br>
pattern2=+: %LINK-3-UPDOWN: Interface $2, changed state to
up <br>
desc2=%1 INTERFACE %2 SHORT OUTAGE <br>
action2=event %s <br>
window=15</p>

<p style="margin-top: 1em"># If &quot;&lt;router&gt;
INTERFACE &lt;interface&gt; DOWN&quot; event is <br>
# received, send a notification and wait for <br>
# &quot;interface up&quot; event from the same router
interface <br>
# for the next 24 hours</p>

<p style="margin-top: 1em">type=Pair <br>
ptype=RegExp <br>
pattern=^([480 <br>
desc=$1 interface $2 is down <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
ptype2=RegExp <br>
pattern2=+: %LINK-3-UPDOWN: Interface $2, changed state to
up <br>
desc2=%1 interface %2 is up <br>
action2=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=86400</p>

<p style="margin-top: 1em"># If ten &quot;short
outage&quot; events have been observed <br>
# in the window of 6 hours, send a notification</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=RegExp <br>
pattern=^([480 <br>
desc=Interface $2 at node $1 is unstable <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail root@localhost
<br>
window=21600 <br>
thresh=10</p>

<p style="margin-top: 1em">Example 2 - hierarchically
organized rulesets for iptables and sshd events <br>
This section presents an example of hierarchically organized
rules for processing Linux iptables events from
/var/log/messages and SSH login events from /var/log/secure.
It is <br>
assumed that all rule files reside in the /etc/sec directory
and that the rule hierarchy has two levels. The file
/etc/sec/main.rules contains first-level Jump rules for
match&acirc; <br>
ing and parsing events from input files and submitting them
to proper rulesets for further processing. All other rule
files in the /etc/sec directory contain second-level rules
<br>
which receive their input from first-level Jump rules. Also,
the example assumes that SEC is started with the following
command line:</p>

<p style="margin-top: 1em">/usr/bin/sec
--conf=/etc/sec/*.rules --intcontexts
--input=/var/log/messages --input=/var/log/secure</p>

<p style="margin-top: 1em"># <br>
# the content of /etc/sec/main.rules <br>
#</p>

<p style="margin-top: 1em">type=Jump <br>
context=[ _FILE_EVENT_/var/log/messages ] <br>
ptype=PerlFunc <br>
pattern=sub { my(%var); my($line) = $_[0]; if ($line !~
/kernel: iptables:/g) { return 0; } while ($line =~
/G([A-Z]+)(?:=())?/g) { $var{$1} = defined($2)?$2:1; }
return var; } <br>
varmap=IPTABLES <br>
desc=parse iptables events and direct to relevant ruleset
<br>
cfset=iptables</p>

<p style="margin-top: 1em">type=Jump <br>
context=[ _FILE_EVENT_/var/log/secure ] <br>
ptype=RegExp <br>
pattern=sshd: (?&lt;status&gt;Accepted|Failed)
(?&lt;authmethod&gt;[1296 <br>
varmap=SSH_LOGIN <br>
desc=parse SSH login events and direct to relevant ruleset
<br>
cfset=ssh-login</p>

<p style="margin-top: 1em">type=Jump <br>
context=[ SSH_EVENT ] <br>
ptype=TValue <br>
pattern=True <br>
desc=direct SSH synthetic events to relevant ruleset <br>
cfset=ssh-events</p>

<p style="margin-top: 1em"># <br>
# the content of /etc/sec/iptables.rules <br>
#</p>

<p style="margin-top: 1em">type=Options <br>
procallin=no <br>
joincfset=iptables</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=Cached <br>
pattern=IPTABLES <br>
context=IPTABLES :&gt; ( sub { return
exists($_[0]-&gt;{&quot;SYN&quot;}) &amp;&amp;
exists($_[0]-&gt;{&quot;FIN&quot;}) ; } ) &amp;&amp;
!SUPPRESS_IP_$+{SRC} <br>
desc=SYN+FIN flood from host $+{SRC} <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail -s
&rsquo;iptables alert&rsquo; root@localhost; create
SUPPRESS_IP_$+{SRC} 3600 <br>
window=10 <br>
thresh=100</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=Cached <br>
pattern=IPTABLES <br>
context=IPTABLES :&gt; ( sub { return
exists($_[0]-&gt;{&quot;SYN&quot;}) &amp;&amp;
!exists($_[0]-&gt;{&quot;ACK&quot;}) ; } ) &amp;&amp;
!SUPPRESS_IP_$+{SRC} <br>
desc=SYN flood from host $+{SRC} <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail -s
&rsquo;iptables alert&rsquo; root@localhost; create
SUPPRESS_IP_$+{SRC} 3600 <br>
window=10 <br>
thresh=100</p>

<p style="margin-top: 1em"># <br>
# the content of /etc/sec/ssh-login.rules <br>
#</p>

<p style="margin-top: 1em">type=Options <br>
procallin=no <br>
joincfset=ssh-login</p>

<p style="margin-top: 1em">type=Single <br>
ptype=Cached <br>
pattern=SSH_LOGIN <br>
context=SSH_LOGIN :&gt; ( sub { return
$_[0]-&gt;{&quot;status&quot;} eq &quot;Failed&quot;
&amp;&amp; $_[0]-&gt;{&quot;srcport&quot;} &lt; 1024
&amp;&amp; defined($_[0]-&gt;{&quot;invuser&quot;}); } )
<br>
continue=TakeNext <br>
desc=Probe of invalid user $+{user} from privileged port of
$+{srcip} <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail -s &rsquo;SSH
alert&rsquo; root@localhost</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=Cached <br>
pattern=SSH_LOGIN <br>
context=SSH_LOGIN :&gt; ( sub { return
$_[0]-&gt;{&quot;status&quot;} eq &quot;Failed&quot;
&amp;&amp; defined($_[0]-&gt;{&quot;invuser&quot;}); } )
<br>
desc=Ten login probes for invalid users from $+{srcip}
within 60s <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail -s &rsquo;SSH
alert&rsquo; root@localhost <br>
thresh=10 <br>
window=60</p>

<p style="margin-top: 1em">type=PairWithWindow <br>
ptype=Cached <br>
pattern=SSH_LOGIN <br>
context=SSH_LOGIN :&gt; ( sub { return
$_[0]-&gt;{&quot;status&quot;} eq &quot;Failed&quot;; } )
<br>
desc=User $+{user} failed to log in from $+{srcip} within
60s <br>
action=cevent SSH_EVENT 0 %s <br>
ptype2=Cached <br>
pattern2=SSH_LOGIN <br>
context2=SSH_LOGIN :&gt; ( sub { return
$_[0]-&gt;{&quot;status&quot;} eq &quot;Accepted&quot;; } )
&amp;&amp; $+{user} %+{user} $+{srcip} %+{srcip} -&gt; ( sub
{ return $_[0] eq $_[1] &amp;&amp; $_[2] eq $_[3]; } ) <br>
desc2=User $+{user} logged in successfully from $+{srcip}
within 60s <br>
action2=logonly <br>
window=60</p>

<p style="margin-top: 1em"># <br>
# the content of /etc/sec/ssh-events.rules <br>
#</p>

<p style="margin-top: 1em">type=Options <br>
procallin=no <br>
joincfset=ssh-events</p>

<p style="margin-top: 1em">type=SingleWithThreshold <br>
ptype=RegExp <br>
pattern=User ([984 <br>
desc=Ten login failures for user $1 within 1h <br>
action=pipe &rsquo;%t: %s&rsquo; /bin/mail -s &rsquo;SSH
alert&rsquo; root@localhost <br>
thresh=10 <br>
window=3600</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
If the SECRC environment variable is set, SEC expects it to
contain the name of its resource file. Resource file lines
which are empty or which begin with the number sign (#) are
<br>
ignored (whitespace may precede #). Each remaining line is
appended to the argv array of SEC as a *single* element.
Also, the lines are appended to argv in the order they <br>
appear in the resource file. Therefore, if the SEC command
line option has a value, the option name and the value must
either be separated by the equal sign (=) or a newline. <br>
Here is a simple resource file example:</p>

<p style="margin-top: 1em"># read events from standard
input <br>
--input=-</p>

<p style="margin-top: 1em"># rules are stored in
/etc/sec/test.conf <br>
--conf <br>
/etc/sec/test.conf</p>

<p style="margin-top: 1em">Note that although SEC rereads
its resource file at the reception of the SIGHUP or SIGABRT
signal, adding an option that specifies a certain startup
procedure (e.g., --pid or <br>
--detach) will not produce the desired effect at runtime.
Also note that the resource file content is *not* parsed by
shell, therefore shell metacharacters are passed to SEC as-
<br>
is.</p>

<p style="margin-top: 1em">SIGNALS <br>
SIGHUP full restart -- SEC will reinterpret its command line
and resource file options, reopen its log and input files,
close its output files and sockets (these will be reopened
<br>
on demand), reload its configuration, and drop *all* event
correlation state (all event correlation operations will be
terminated, all contexts will be deleted, all action <br>
list variables will be erased, etc.). With the --childterm
option, SEC will also send the SIGTERM signal to its child
processes.</p>

<p style="margin-top: 1em">SIGABRT <br>
soft restart -- SEC will reinterpret its command line and
resource file options, reopen its log file, and close its
output files and sockets (these will be reopened on <br>
demand). If the --keepopen option is specified, previously
opened input files will remain open across soft restart,
otherwise all input files will be reopened. SEC will <br>
(re)load configuration from rule files which have been
modified (file modification time returned by stat(2) has
changed) or created after the previous configuration load.
<br>
SEC will also terminate event correlation operations started
from rule files that have been modified or removed after the
previous configuration load. Other operations <br>
and previously loaded configuration from unmodified rule
files will remain intact. Note that on some systems SIGIOT
is used in place of SIGABRT.</p>

<p style="margin-top: 1em">SIGUSR1 <br>
detailed information about the current state of SEC
(performance and rule matching statistics, running event
correlation operations, created contexts, etc.) will be
writ&acirc; <br>
ten to the SEC dump file.</p>

<p style="margin-top: 1em">SIGUSR2 <br>
SEC will reopen its log file (useful for log file rotation),
and also close its output files and sockets which will be
reopened on demand.</p>

<p style="margin-top: 1em">SIGINT SEC will increase its
logging level by one; if the current level is 6, the level
will be set back to 1. Please note this feature is available
only if SEC is running non- <br>
interactively (e.g., in daemon mode).</p>

<p style="margin-top: 1em">SIGTERM <br>
SEC will terminate gracefully. With the --childterm option,
all SEC child processes will receive SIGTERM.</p>

<p style="margin-top: 1em">BUGS <br>
With some locale settings, single quotes (&rsquo;) in this
man page might be displayed incorrectly. As a workaround,
set the LANG environment variable to C when reading this man
page <br>
(e.g., env LANG=C man sec).</p>

<p style="margin-top: 1em">AUTHOR <br>
Risto Vaarandi (ristov at users d0t s0urcef0rge d0t net)</p>

<p style="margin-top: 1em">ACKNOWLEDGMENTS <br>
This work is supported by SEB. The author thanks the
following people for supplying software patches,
documentation fixes, and suggesting new features: Al
Sorrell, Brian Mielke, <br>
David Lang, James Brown, Jon Frazier, Mark D. Nagel, Peter
Eckel, Rick Casey, and William Gertz. Last but not least,
the author expresses his profound gratitute to John P. <br>
Rouillard for many great ideas and creative discussions that
have helped to develop SEC.</p>

<p style="margin-top: 1em">SEE ALSO <br>
cron(8), crontab(1), fork(2), mail(1), perl(1), perlmod(1),
perlre(1), pipe(2), sh(1), snmptrap(1), stat(2),
strftime(3), syslog(3), time(2), umask(2)</p>

<p style="margin-top: 1em">SEC 2.7.11 February 2017
sec(1)</p>
<hr>
</body>
</html>
