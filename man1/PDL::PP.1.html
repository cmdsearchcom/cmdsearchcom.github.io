<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PP(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PP(1)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PP(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
PDL::PP - Generate PDL routines from concise descriptions
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
e.g.
<div class="Pp"></div>
<pre>
        pp_def(
                'sumover',
                Pars =&gt; 'a(n); [o]b();',
                Code =&gt; q{
                        double tmp=0;
                        loop(n) %{
                                tmp += $a();
                        %}
                        $b() = tmp;
                },
        );
        pp_done();
</pre>
<h1 class="Sh" title="Sh" id="FUNCTIONS"><a class="selflink" href="#FUNCTIONS">FUNCTIONS</a></h1>
Here is a quick reference list of the functions provided by PDL::PP.
<h2 class="Ss" title="Ss" id="pp_add_boot"><a class="selflink" href="#pp_add_boot">pp_add_boot</a></h2>
Add code to the BOOT section of generated XS file
<h2 class="Ss" title="Ss" id="pp_add_exported"><a class="selflink" href="#pp_add_exported">pp_add_exported</a></h2>
Add functions to the list of exported functions
<h2 class="Ss" title="Ss" id="pp_add_isa"><a class="selflink" href="#pp_add_isa">pp_add_isa</a></h2>
Add entries to the @ISA list
<h2 class="Ss" title="Ss" id="pp_addbegin"><a class="selflink" href="#pp_addbegin">pp_addbegin</a></h2>
Sets code to be added at the top of the generate .pm file
<h2 class="Ss" title="Ss" id="pp_addhdr"><a class="selflink" href="#pp_addhdr">pp_addhdr</a></h2>
Add code and includes to C section of the generated XS file
<h2 class="Ss" title="Ss" id="pp_addpm"><a class="selflink" href="#pp_addpm">pp_addpm</a></h2>
Add code to the generated .pm file
<h2 class="Ss" title="Ss" id="pp_addxs"><a class="selflink" href="#pp_addxs">pp_addxs</a></h2>
Add extra XS code to the generated XS file
<h2 class="Ss" title="Ss" id="pp_beginwrap"><a class="selflink" href="#pp_beginwrap">pp_beginwrap</a></h2>
Add BEGIN-block wrapping to code for the generated .pm file
<h2 class="Ss" title="Ss" id="pp_bless"><a class="selflink" href="#pp_bless">pp_bless</a></h2>
Sets the package to which the XS code is added (default is PDL)
<h2 class="Ss" title="Ss" id="pp_boundscheck"><a class="selflink" href="#pp_boundscheck">pp_boundscheck</a></h2>
Control state of PDL bounds checking activity
<h2 class="Ss" title="Ss" id="pp_core_importList"><a class="selflink" href="#pp_core_importList">pp_core_importList</a></h2>
Specify what is imported from PDL::Core
<h2 class="Ss" title="Ss" id="pp_def"><a class="selflink" href="#pp_def">pp_def</a></h2>
Define a new PDL function
<h2 class="Ss" title="Ss" id="pp_deprecate_module"><a class="selflink" href="#pp_deprecate_module">pp_deprecate_module</a></h2>
Add runtime and POD warnings about a module being deprecated
<h2 class="Ss" title="Ss" id="pp_done"><a class="selflink" href="#pp_done">pp_done</a></h2>
Mark the end of PDL::PP definitions in the file
<h2 class="Ss" title="Ss" id="pp_export_nothing"><a class="selflink" href="#pp_export_nothing">pp_export_nothing</a></h2>
Clear out the export list for your generated module
<h2 class="Ss" title="Ss" id="pp_line_numbers"><a class="selflink" href="#pp_line_numbers">pp_line_numbers</a></h2>
Add line number information to simplify debugging of PDL::PP code
<h2 class="Ss" title="Ss" id="pp_setversion"><a class="selflink" href="#pp_setversion">pp_setversion</a></h2>
Set the version for .pm and .xs files
<h1 class="Sh" title="Sh" id="OVERVIEW"><a class="selflink" href="#OVERVIEW">OVERVIEW</a></h1>
Why do we need PP? Several reasons: firstly, we want to be able to generate
  subroutine code for each of the PDL datatypes (PDL_Byte, PDL_Short, etc).
  AUTOMATICALLY. Secondly, when referring to slices of PDL arrays in Perl (e.g.
  &quot;$a-&gt;slice('0:10:2,:')&quot; or other things such as transposes) it is
  nice to be able to do this transparently and to be able to do this 'in-place'
  - i.e, not to have to make a memory copy of the section. PP handles all the
  necessary element and offset arithmetic for you. There are also the notions of
  threading (repeated calling of the same routine for multiple slices, see
  PDL::Indexing) and dataflow (see PDL::Dataflow) which use of PP allows.
<div class="Pp"></div>
In much of what follows we will assume familiarity of the reader with the
  concepts of implicit and explicit threading and index manipulations within
  PDL. If you have not yet heard of these concepts or are not very comfortable
  with them it is time to check PDL::Indexing.
<div class="Pp"></div>
As you may appreciate from its name PDL::PP is a Pre-Processor, i.e. it expands
  code via substitutions to make real C-code. Technically, the output is XS code
  (see <i>perlxs</i>) but that is very close to C.
<div class="Pp"></div>
So how do you use PP? Well for the most part you just write ordinary C code
  except for special PP constructs which take the form:
<div class="Pp"></div>
<pre>
   $something(something else)
</pre>
<div class="Pp"></div>
or:
<div class="Pp"></div>
<pre>
   PPfunction %{
     &lt;stuff&gt;
   %}
</pre>
<div class="Pp"></div>
The most important PP construct is the form &quot;$array()&quot;. Consider the
  very simple PP function to sum the elements of a 1D vector (in fact this is
  very similar to the actual code used by 'sumover'):
<div class="Pp"></div>
<pre>
   pp_def('sumit',
       Pars =&gt; 'a(n);  [o]b();',
       Code =&gt; q{
           double tmp;
           tmp = 0;
           loop(n) %{
               tmp += $a();
           %}
           $b() = tmp;
       }
   );
</pre>
<div class="Pp"></div>
What's going on? The &quot;Pars =&gt;&quot; line is very important for PP - it
  specifies all the arguments and their dimensionality. We call this the
  <i>signature</i> of the PP function (compare also the explanations in
  PDL::Indexing). In this case the routine takes a 1-D function as input and
  returns a 0-D scalar as output. The &quot;$a()&quot; PP construct is used to
  access elements of the array a(n) for you - PP fills in all the required C
  code.
<div class="Pp"></div>
You will notice that we are using the &quot;q{}&quot; single-quote operator.
  This is not an accident. You generally want to use single quotes to denote
  your PP Code sections. PDL::PP uses &quot;$var()&quot; for its parsing and if
  you don't use single quotes, Perl will try to interpolate &quot;$var()&quot;.
  Also, using the single quote &quot;q&quot; operator with curly braces makes it
  look like you are creating a code block, which is What You Mean. (Perl is
  smart enough to look for nested curly braces and not close the quote until it
  finds the matching curly brace, so it's safe to have nested blocks.) Under
  other circumstances, such as when you're stitching together a Code block using
  string concatenations, it's often easiest to use real single quotes as
<div class="Pp"></div>
<pre>
 Code =&gt; 'something'.$interpolatable.'somethingelse;'
</pre>
<div class="Pp"></div>
In the simple case here where all elements are accessed the PP construct
  &quot;loop(n) %{ ... %}&quot; is used to loop over all elements in dimension
  &quot;n&quot;. Note this feature of PP: ALL DIMENSIONS ARE SPECIFIED BY NAME.
<div class="Pp"></div>
This is made clearer if we avoid the PP <i>loop()</i> construct and write the
  loop explicitly using conventional C:
<div class="Pp"></div>
<pre>
   pp_def('sumit',
       Pars =&gt; 'a(n);  [o]b();',
       Code =&gt; q{
           PDL_Indx i,n_size;
           double tmp;
           n_size = $SIZE(n);
           tmp = 0;
           for(i=0; i&lt;n_size; i++) {
               tmp += $a(n=&gt;i);
           }
           $b() = tmp;
       },
   );
</pre>
<div class="Pp"></div>
which does the same as before, but is more long-winded. You can see to get
  element &quot;i&quot; of a() we say &quot;$a(n=&gt;i)&quot; - we are
  specifying the dimension by name &quot;n&quot;. In 2D we might say:
<div class="Pp"></div>
<pre>
   Pars=&gt;'a(m,n);',
      ...
      tmp += $a(m=&gt;i,n=&gt;j);
      ...
</pre>
<div class="Pp"></div>
The syntax &quot;m=&gt;i&quot; borrows from Perl hashes, which are in fact used
  in the implementation of PP. One could also say
  &quot;$a(n=&gt;j,m=&gt;i)&quot; as order is not important.
<div class="Pp"></div>
You can also see in the above example the use of another PP construct - $SIZE(n)
  to get the length of the dimension &quot;n&quot;.
<div class="Pp"></div>
It should, however, be noted that you shouldn't write an explicit C-loop when
  you could have used the PP &quot;loop&quot; construct since PDL::PP checks
  automatically the loop limits for you, usage of &quot;loop&quot; makes the
  code more concise, etc. But there are certainly situations where you need
  explicit control of the loop and now you know how to do it ;).
<div class="Pp"></div>
To revisit 'Why PP?' - the above code for <i>sumit()</i> will be generated for
  each data-type. It will operate on slices of arrays 'in-place'. It will thread
  automatically - e.g. if a 2D array is given it will be called repeatedly for
  each 1D row (again check PDL::Indexing for the details of threading). And then
  b() will be a 1D array of sums of each row. We could call it with
  $a-&gt;xchg(0,1) to sum the columns instead. And Dataflow tracing etc. will be
  available.
<div class="Pp"></div>
You can see PP saves the programmer from writing a lot of needlessly repetitive
  C-code -- in our opinion this is one of the best features of PDL making
  writing new C subroutines for PDL an amazingly concise exercise. A second
  reason is the ability to make PP expand your concise code definitions into
  different C code based on the needs of the computer architecture in question.
  Imagine for example you are lucky to have a supercomputer at your hands; in
  that case you want PDL::PP certainly to generate code that takes advantage of
  the vectorising/parallel computing features of your machine (this a project
  for the future). In any case, the bottom line is that your unchanged code
  should still expand to working XS code even if the internals of PDL changed.
<div class="Pp"></div>
Also, because you are generating the code in an actual Perl script, there are
  many fun things that you can do. Let's say that you need to write both sumit
  (as above) and multit. With a little bit of creativity, we can do
<div class="Pp"></div>
<pre>
   for({Name =&gt; 'sumit', Init =&gt; '0', Op =&gt; '+='},
       {Name =&gt; 'multit', Init =&gt; '1', Op =&gt; '*='}) {
           pp_def($_-&gt;{Name},
                   Pars =&gt; 'a(n);  [o]b();',
                   Code =&gt; '
                        double tmp;
                        tmp = '.$_-&gt;{Init}.';
                        loop(n) %{
                          tmp '.$_-&gt;{Op}.' $a();
                        %}
                        $b() = tmp;
           ');
   }
</pre>
<div class="Pp"></div>
which defines both the functions easily. Now, if you later need to change the
  signature or dimensionality or whatever, you only need to change one place in
  your code. Yeah, sure, your editor does have 'cut and paste' and 'search and
  replace' but it's still less bothersome and definitely more difficult to
  forget just one place and have strange bugs creep in. Also, adding 'orit'
  (bitwise or) later is a one-liner.
<div class="Pp"></div>
And remember, you really have Perl's full abilities with you - you can very
  easily read any input file and make routines from the information in that
  file. For simple cases like the above, the author (Tjl) currently favors the
  hash syntax like the above - it's not too much more characters than the
  corresponding array syntax but much easier to understand and change.
<div class="Pp"></div>
We should mention here also the ability to get the pointer to the beginning of
  the data in memory - a prerequisite for interfacing PDL to some libraries.
  This is handled with the &quot;$P(var)&quot; directive, see below.
<div class="Pp"></div>
When starting work on a new pp_def'ined function, if you make a mistake, you
  will usually find a pile of compiler errors indicating line numbers in the
  generated XS file. If you know how to read XS files (or if you want to learn
  the hard way), you could open the generated XS file and search for the line
  number with the error. However, a recent addition to PDL::PP helps report the
  correct line number of your errors: &quot;pp_line_numbers&quot;. Working with
  the original summit example, if you had a mis-spelling of tmp in your code,
  you could change the (erroneous) code to something like this and the compiler
  would give you much more useful information:
<div class="Pp"></div>
<pre>
   pp_def('sumit',
       Pars =&gt; 'a(n);  [o]b();',
       Code =&gt; pp_line_numbers(__LINE__, q{
           double tmp;
           tmp = 0;
           loop(n) %{
               tmp += $a();
           %}
           $b() = rmp;
       })
   );
</pre>
<div class="Pp"></div>
For the above situation, my compiler tells me:
<div class="Pp"></div>
<pre>
 ...
 test.pd:15: error: 'rmp' undeclared (first use in this function)
 ...
</pre>
<div class="Pp"></div>
In my example script (called test.pd), line 15 is exactly the line at which I
  made my typo: &quot;rmp&quot; instead of &quot;tmp&quot;.
<div class="Pp"></div>
So, after this quick overview of the general flavour of programming PDL routines
  using PDL::PP let's summarise in which circumstances you should actually use
  this preprocessor/precompiler. You should use PDL::PP if you want to
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">interface PDL to some external library</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">write some algorithm that would be slow if coded in Perl
      (this is not as often as you think; take a look at threading and dataflow
      first).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">be a PDL developer (and even then it's not obligatory)</dd>
</dl>
<h1 class="Sh" title="Sh" id="WARNING"><a class="selflink" href="#WARNING">WARNING</a></h1>
Because of its architecture, PDL::PP can be both flexible and easy to use on the
  one hand, yet exuberantly complicated at the same time. Currently, part of the
  problem is that error messages are not very informative and if something goes
  wrong, you'd better know what you are doing and be able to hack your way
  through the internals (or be able to figure out by trial and error what is
  wrong with your args to &quot;pp_def&quot;). Although work is being done to
  produce better warnings, do not be afraid to send your questions to the
  mailing list if you run into trouble.
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Now that you have some idea how to use &quot;pp_def&quot; to define new PDL
  functions it is time to explain the general syntax of &quot;pp_def&quot;.
  &quot;pp_def&quot; takes as arguments first the name of the function you are
  defining and then a hash list that can contain various keys.
<div class="Pp"></div>
Based on these keys PP generates XS code and a .pm file. The function
  &quot;pp_done&quot; (see example in the SYNOPSIS) is used to tell PDL::PP that
  there are no more definitions in this file and it is time to generate the .xs
  and
<br/>
 .pm file.
<div class="Pp"></div>
As a consequence, there may be several <i>pp_def()</i> calls inside a file (by
  convention files with PP code have the extension .pd or .pp) but generally
  only one <i>pp_done()</i>.
<div class="Pp"></div>
There are two main different types of usage of <i>pp_def()</i>, the 'data
  operation' and 'slice operation' prototypes.
<div class="Pp"></div>
The 'data operation' is used to take some data, mangle it and output some other
  data; this includes for example the '+' operation, matrix inverse, sumover etc
  and all the examples we have talked about in this document so far. Implicit
  and explicit threading and the creation of the result are taken care of
  automatically in those operations. You can even do dataflow with
  &quot;sumit&quot;, &quot;sumover&quot;, etc (don't be dismayed if you don't
  understand the concept of dataflow in PDL very well yet; it is still very much
  experimental).
<div class="Pp"></div>
The 'slice operation' is a different kind of operation: in a slice operation,
  you are not changing any data, you are defining correspondences between
  different elements of two piddles (examples include the index
  manipulation/slicing function definitions in the file <i>slices.pd</i> that is
  part of the PDL distribution; but beware, this is not introductory level
  stuff).
<div class="Pp"></div>
If PDL was compiled with support for bad values (i.e. &quot;WITH_BADVAL =&gt;
  1&quot;), then additional keys are required for &quot;pp_def&quot;, as
  explained below.
<div class="Pp"></div>
If you are just interested in communicating with some external library (for
  example some linear algebra/matrix library), you'll usually want the 'data
  operation' so we are going to discuss that first.
<h1 class="Sh" title="Sh" id="Data_operation"><a class="selflink" href="#Data_operation">Data
  operation</a></h1>
<h2 class="Ss" title="Ss" id="A_simple_example"><a class="selflink" href="#A_simple_example">A
  simple example</a></h2>
In the data operation, you must know what dimensions of data you need. First, an
  example with scalars:
<div class="Pp"></div>
<pre>
        pp_def('add',
                Pars =&gt; 'a(); b(); [o]c();',
                Code =&gt; '$c() = $a() + $b();'
        );
</pre>
<div class="Pp"></div>
That looks a little strange but let's dissect it. The first line is easy: we're
  defining a routine with the name 'add'. The second line simply declares our
  parameters and the parentheses mean that they are scalars. We call the string
  that defines our parameters and their dimensionality the <i>signature</i> of
  that function. For its relevance with regard to threading and index
  manipulations check the PDL::Indexing man page.
<div class="Pp"></div>
The third line is the actual operation. You need to use the dollar signs and
  parentheses to refer to your parameters (this will probably change at some
  point in the future, once a good syntax is found).
<div class="Pp"></div>
These lines are all that is necessary to actually define the function for PDL
  (well, actually it isn't; you additionally need to write a Makefile.PL (see
  below) and build the module (something like 'perl Makefile.PL; make'); but
  let's ignore that for the moment). So now you can do
<div class="Pp"></div>
<pre>
        use MyModule;
        $a = pdl 2,3,4;
        $b = pdl 5;
        $c = add($a,$b);
        # or
        add($a,$b,($c=null)); # Alternative form, useful if $c has been
                              # preset to something big, not useful here.
</pre>
<div class="Pp"></div>
and have threading work correctly (the result is $c == [7 8 9]).
<h2 class="Ss" title="Ss" id="The_Pars_section:_the_signature_of_a_PP_function"><a class="selflink" href="#The_Pars_section:_the_signature_of_a_PP_function">The
  Pars section: the signature of a PP function</a></h2>
Seeing the above example code you will most probably ask: what is this strange
  &quot;$c=null&quot; syntax in the second call to our new &quot;add&quot;
  function? If you take another look at the definition of &quot;add&quot; you
  will notice that the third argument &quot;c&quot; is flagged with the
  qualifier &quot;[o]&quot; which tells PDL::PP that this is an output argument.
  So the above call to add means 'create a new $c from scratch with correct
  dimensions' - &quot;null&quot; is a special token for 'empty piddle' (you
  might ask why we haven't used the value &quot;undef&quot; to flag this instead
  of the PDL specific &quot;null&quot;; we are currently thinking about it ;).
<div class="Pp"></div>
[This should be explained in some other section of the manual as well!!] The
  reason for having this syntax as an alternative is that if you have really
  huge piddles, you can do
<div class="Pp"></div>
<pre>
        $c = PDL-&gt;null;
        for(some long loop) {
                # munge a,b
                add($a,$b,$c);
                # munge c, put something back to a,b
        }
</pre>
<div class="Pp"></div>
and avoid allocating and deallocating $c each time. It is allocated once at the
  first <i>add()</i> and thereafter the memory stays until $c is destroyed.
<div class="Pp"></div>
If you just say
<div class="Pp"></div>
<pre>
  $c =  add($a,$b);
</pre>
<div class="Pp"></div>
the code generated by PP will automatically fill in &quot;$c=null&quot; and
  return the result. If you want to learn more about the reasons why PDL::PP
  supports this style where output arguments are given as last arguments check
  the PDL::Indexing man page.
<div class="Pp"></div>
&quot;[o]&quot; is not the only qualifier a pdl argument can have in the
  signature. Another important qualifier is the &quot;[t]&quot; option which
  flags a pdl as temporary. What does that mean? You tell PDL::PP that this pdl
  is only used for temporary results in the course of the calculation and you
  are not interested in its value after the computation has been completed. But
  why should PDL::PP want to know about this in the first place? The reason is
  closely related to the concepts of pdl auto creation (you heard about that
  above) and implicit threading. If you use implicit threading the
  dimensionality of automatically created pdls is actually larger than that
  specified in the signature. With &quot;[o]&quot; flagged pdls will be created
  so that they have the additional dimensions as required by the number of
  implicit thread dimensions. When creating a temporary pdl, however, it will
  always only be made big enough so that it can hold the result for one
  iteration in a thread loop, i.e. as large as required by the signature. So
  less memory is wasted when you flag a pdl as temporary. Secondly, you can use
  output auto creation with temporary pdls even when you are using explicit
  threading which is forbidden for normal output pdls flagged with
  &quot;[o]&quot; (see PDL::Indexing).
<div class="Pp"></div>
Here is an example where we use the [t] qualifier. We define the function
  &quot;callf&quot; that calls a C routine &quot;f&quot; which needs a temporary
  array of the same size and type as the array &quot;a&quot; (sorry about the
  forward reference for $P; it's a pointer access, see below) :
<div class="Pp"></div>
<pre>
  pp_def('callf',
        Pars =&gt; 'a(n); [t] tmp(n); [o] b()',
        Code =&gt; 'PDL_Indx ns = $SIZE(n);
                 f($P(a),$P(b),$P(tmp),ns);
                '
  );
</pre>
<h2 class="Ss" title="Ss" id="Argument_dimensions_and_the_signature"><a class="selflink" href="#Argument_dimensions_and_the_signature">Argument
  dimensions and the signature</a></h2>
Now we have just talked about dimensions of pdls and the signature. How are they
  related? Let's say that we want to add a scalar + the index number to a
  vector:
<div class="Pp"></div>
<pre>
        pp_def('add2',
                Pars =&gt; 'a(n); b(); [o]c(n);',
                Code =&gt; 'loop(n) %{
                                $c() = $a() + $b() + n;
                         %}'
        );
</pre>
<div class="Pp"></div>
There are several points to notice here: first, the &quot;Pars&quot; argument
  now contains the <i>n</i> arguments to show that we have a single dimensions
  in <i>a</i> and <i>c</i>. It is important to note that dimensions are actual
  entities that are accessed by name so this declares <i>a</i> and <i>c</i> to
  have the <b>same</b> first dimensions. In most PP definitions the size of
  named dimensions will be set from the respective dimensions of non-output pdls
  (those with no &quot;[o]&quot; flag) but sometimes you might want to set the
  size of a named dimension explicitly through an integer parameter. See below
  in the description of the &quot;OtherPars&quot; section how that works.
<h2 class="Ss" title="Ss" id="Constant_argument_dimensions_in_the_signature"><a class="selflink" href="#Constant_argument_dimensions_in_the_signature">Constant
  argument dimensions in the signature</a></h2>
Suppose you want an output piddle to be created automatically and you know that
  on every call its dimension will have the same size (say 9) regardless of the
  dimensions of the input piddles. In this case you use the following syntax in
  the Pars section to specify the size of the dimension:
<div class="Pp"></div>
<pre>
    ' [o] y(n=9); '
</pre>
<div class="Pp"></div>
As expected, extra dimensions required by threading will be created if
  necessary. If you need to assign a named dimension according to a more
  complicated formula (than a constant) you must use the
  &quot;RedoDimsCode&quot; key described below.
<h2 class="Ss" title="Ss" id="Type_conversions_and_the_signature"><a class="selflink" href="#Type_conversions_and_the_signature">Type
  conversions and the signature</a></h2>
The signature also determines the type conversions that will be performed when a
  PP function is invoked. So what happens when we invoke one of our previously
  defined functions with pdls of different type, e.g.
<div class="Pp"></div>
<pre>
  add2($a,$b,($ret=null));
</pre>
<div class="Pp"></div>
where $a is of type &quot;PDL_Float&quot; and $b of type &quot;PDL_Short&quot;?
  With the signature as shown in the definition of &quot;add2&quot; above the
  datatype of the operation (as determined at runtime) is that of the pdl with
  the 'highest' type (sequence is byte &lt; short &lt; ushort &lt; long &lt;
  float &lt; double). In the add2 example the datatype of the operation is float
  ($a has that datatype). All pdl arguments are then type converted to that
  datatype (they are not converted inplace but a copy with the right type is
  created if a pdl argument doesn't have the type of the operation). Null pdls
  don't contribute a type in the determination of the type of the operation.
  However, they will be created with the datatype of the operation; here, for
  example, $ret will be of type float. You should be aware of these rules when
  calling PP functions with pdls of different types to take the additional
  storage and runtime requirements into account.
<div class="Pp"></div>
These type conversions are correct for most functions you normally define with
  &quot;pp_def&quot;. However, there are certain cases where slightly modified
  type conversion behaviour is desired. For these cases additional qualifiers in
  the signature can be used to specify the desired properties with regard to
  type conversion. These qualifiers can be combined with those we have
  encountered already (the <i>creation qualifiers</i> &quot;[o]&quot; and
  &quot;[t]&quot;). Let's go through the list of qualifiers that change type
  conversion behaviour.
<div class="Pp"></div>
The most important is the &quot;indx&quot; qualifier which comes in handy when a
  pdl argument represents indices into another pdl. Let's take a look at an
  example from &quot;PDL::Ufunc&quot;:
<div class="Pp"></div>
<pre>
   pp_def('maximum_ind',
          Pars =&gt; 'a(n); indx [o] b()',
          Code =&gt; '$GENERIC() cur;
                   PDL_Indx curind;
                   loop(n) %{
                    if (!n || $a() &gt; cur) {cur = $a(); curind = n;}
                   %}
                   $b() = curind;',
   );
</pre>
<div class="Pp"></div>
The function &quot;maximum_ind&quot; finds the index of the largest element of a
  vector. If you look at the signature you notice that the output argument
  &quot;b&quot; has been declared with the additional &quot;indx&quot;
  qualifier. This has the following consequences for type conversions:
  regardless of the type of the input pdl &quot;a&quot; the output pdl
  &quot;b&quot; will be of type &quot;PDL_Indx&quot; which makes sense since
  &quot;b&quot; will represent an index into &quot;a&quot;.
<div class="Pp"></div>
Note that 'curind' is declared as type &quot;PDL_Indx&quot; and not
  &quot;indx&quot;. While most datatype declarations in the 'Pars' section use
  the same name as the underlying C type, &quot;indx&quot; is a type which is
  sufficient to handle PDL indexing operations. For 32-bit installs, it can be a
  32-bit integer type. For 64-bit installs, it will be a 64-bit integer type.
<div class="Pp"></div>
Furthermore, if you call the function with an existing output pdl &quot;b&quot;
  its type will not influence the datatype of the operation (see above). Hence,
  even if &quot;a&quot; is of a smaller type than &quot;b&quot; it will not be
  converted to match the type of &quot;b&quot; but stays untouched, which saves
  memory and CPU cycles and is the right thing to do when &quot;b&quot;
  represents indices. Also note that you can use the 'indx' qualifier together
  with other qualifiers (the &quot;[o]&quot; and &quot;[t]&quot; qualifiers).
  Order is significant -- type qualifiers precede creation qualifiers
  (&quot;[o]&quot; and &quot;[t]&quot;).
<div class="Pp"></div>
The above example also demonstrates typical usage of the &quot;$GENERIC()&quot;
  macro. It expands to the current type in a so called generic loop. What is a
  generic loop? As you already heard a PP function has a runtime datatype as
  determined by the type of the pdl arguments it has been invoked with. The PP
  generated XS code for this function therefore contains a switch like
  &quot;switch (type) {case PDL_Byte: ... case PDL_Double: ...}&quot; that
  selects a case based on the runtime datatype of the function (it's called a
  type ``loop'' because there is a loop in PP code that generates the cases). In
  any case your code is inserted once for each PDL type into this switch
  statement. The &quot;$GENERIC()&quot; macro just expands to the respective
  type in each copy of your parsed code in this &quot;switch&quot; statement,
  e.g., in the &quot;case PDL_Byte&quot; section &quot;cur&quot; will expand to
  &quot;PDL_Byte&quot; and so on for the other case statements. I guess you
  realise that this is a useful macro to hold values of pdls in some code.
<div class="Pp"></div>
There are a couple of other qualifiers with similar effects as &quot;indx&quot;.
  For your convenience there are the &quot;float&quot; and &quot;double&quot;
  qualifiers with analogous consequences on type conversions as
  &quot;indx&quot;. Let's assume you have a <i>very</i> large array for which
  you want to compute row and column sums with an equivalent of the
  &quot;sumover&quot; function. However, with the normal definition of
  &quot;sumover&quot; you might run into problems when your data is, e.g. of
  type short. A call like
<div class="Pp"></div>
<pre>
  sumover($large_pdl,($sums = null));
</pre>
<div class="Pp"></div>
will result in $sums be of type short and is therefore prone to overflow errors
  if $large_pdl is a very large array. On the other hand calling
<div class="Pp"></div>
<pre>
  @dims = $large_pdl-&gt;dims; shift @dims;
  sumover($large_pdl,($sums = zeroes(double,@dims)));
</pre>
<div class="Pp"></div>
is not a good alternative either. Now we don't have overflow problems with $sums
  but at the expense of a type conversion of $large_pdl to double, something bad
  if this is really a large pdl. That's where &quot;double&quot; comes in handy:
<div class="Pp"></div>
<pre>
  pp_def('sumoverd',
         Pars =&gt; 'a(n); double [o] b()',
         Code =&gt; 'double tmp=0;
                  loop(n) %{ tmp += a(); %}
                  $b() = tmp;',
  );
</pre>
<div class="Pp"></div>
This gets us around the type conversion and overflow problems. Again, analogous
  to the &quot;indx&quot; qualifier &quot;double&quot; results in &quot;b&quot;
  always being of type double regardless of the type of &quot;a&quot; without
  leading to a type conversion of &quot;a&quot; as a side effect.
<div class="Pp"></div>
Finally, there are the &quot;type+&quot; qualifiers where type is one of
  &quot;int&quot; or &quot;float&quot;. What shall that mean. Let's illustrate
  the &quot;int+&quot; qualifier with the actual definition of sumover:
<div class="Pp"></div>
<pre>
  pp_def('sumover',
         Pars =&gt; 'a(n); int+ [o] b()',
         Code =&gt; '$GENERIC(b) tmp=0;
                  loop(n) %{ tmp += a(); %}
                  $b() = tmp;',
  );
</pre>
<div class="Pp"></div>
As we had already seen for the &quot;int&quot;, &quot;float&quot; and
  &quot;double&quot; qualifiers, a pdl marked with a &quot;type+&quot; qualifier
  does not influence the datatype of the pdl operation. Its meaning is
  &quot;make this pdl at least of type &quot;type&quot; or higher, as required
  by the type of the operation&quot;. In the sumover example this means that
  when you call the function with an &quot;a&quot; of type PDL_Short the output
  pdl will be of type PDL_Long (just as would have been the case with the
  &quot;int&quot; qualifier). This again tries to avoid overflow problems when
  using small datatypes (e.g. byte images). However, when the datatype of the
  operation is higher than the type specified in the &quot;type+&quot; qualifier
  &quot;b&quot; will be created with the datatype of the operation, e.g. when
  &quot;a&quot; is of type double then &quot;b&quot; will be double as well. We
  hope you agree that this is sensible behaviour for &quot;sumover&quot;. It
  should be obvious how the &quot;float+&quot; qualifier works by analogy. It
  may become necessary to be able to specify a set of alternative types for the
  parameters. However, this will probably not be implemented until someone comes
  up with a reasonable use for it.
<div class="Pp"></div>
Note that we now had to specify the $GENERIC macro with the name of the pdl to
  derive the type from that argument. Why is that? If you carefully followed our
  explanations you will have realised that in some cases &quot;b&quot; will have
  a different type than the type of the operation. Calling the '$GENERIC' macro
  with &quot;b&quot; as argument makes sure that the type will always the same
  as that of &quot;b&quot; in that part of the generic loop.
<div class="Pp"></div>
This is about all there is to say about the &quot;Pars&quot; section in a
  &quot;pp_def&quot; call. You should remember that this section defines the
  <i>signature</i> of a PP defined function, you can use several options to
  qualify certain arguments as output and temporary args and all dimensions that
  you can later refer to in the &quot;Code&quot; section are defined by name.
<div class="Pp"></div>
It is important that you understand the meaning of the signature since in the
  latest PDL versions you can use it to define threaded functions from within
  Perl, i.e. what we call <i>Perl level threading</i>. Please check
  PDL::Indexing for details.
<h2 class="Ss" title="Ss" id="The_Code_section"><a class="selflink" href="#The_Code_section">The
  Code section</a></h2>
The &quot;Code&quot; section contains the actual XS code that will be in the
  innermost part of a thread loop (if you don't know what a thread loop is then
  you still haven't read PDL::Indexing; do it now ;) after any PP macros (like
  $GENERIC) and PP functions have been expanded (like the &quot;loop&quot;
  function we are going to explain next).
<div class="Pp"></div>
Let's quickly reiterate the &quot;sumover&quot; example:
<div class="Pp"></div>
<pre>
  pp_def('sumover',
         Pars =&gt; 'a(n); int+ [o] b()',
         Code =&gt; '$GENERIC(b) tmp=0;
                  loop(n) %{ tmp += a(); %}
                  $b() = tmp;',
  );
</pre>
<div class="Pp"></div>
The &quot;loop&quot; construct in the &quot;Code&quot; section also refers to
  the dimension name so you don't need to specify any limits: the loop is
  correctly sized and everything is done for you, again.
<div class="Pp"></div>
Next, there is the surprising fact that &quot;$a()&quot; and &quot;$b()&quot; do
  <b>not</b> contain the index. This is not necessary because we're looping over
  <i>n</i> and both variables know which dimensions they have so they
  automatically know they're being looped over.
<div class="Pp"></div>
This feature comes in very handy in many places and makes for much shorter code.
  Of course, there are times when you want to circumvent this; here is a
  function which make a matrix symmetric and serves as an example of how to code
  explicit looping:
<div class="Pp"></div>
<pre>
        pp_def('symm',
                Pars =&gt; 'a(n,n); [o]c(n,n);',
                Code =&gt; 'loop(n) %{
                                int n2;
                                for(n2=n; n2&lt;$SIZE(n); n2++) {
                                        $c(n0 =&gt; n, n1 =&gt; n2) =
                                        $c(n0 =&gt; n2, n1 =&gt; n) =
                                         $a(n0 =&gt; n, n1 =&gt; n2);
                                }
                        %}
                '
        );
</pre>
<div class="Pp"></div>
Let's dissect what is happening. Firstly, what is this function supposed to do?
  From its signature you see that it takes a 2D matrix with equal numbers of
  columns and rows and outputs a matrix of the same size. From a given input
  matrix $a it computes a symmetric output matrix $c (symmetric in the matrix
  sense that A^T = A where ^T means matrix transpose, or in PDL parlance $c ==
  $c-&gt;xchg(0,1)). It does this by using only the values on and below the
  diagonal of $a. In the output matrix $c all values on and below the diagonal
  are the same as those in $a while those above the diagonal are a mirror image
  of those below the diagonal (above and below are here interpreted in the way
  that PDL prints 2D pdls). If this explanation still sounds a bit strange just
  go ahead, make a little file into which you write this definition, build the
  new PDL extension (see section on Makefiles for PP code) and try it out with a
  couple of examples.
<div class="Pp"></div>
Having explained what the function is supposed to do there are a couple of
  points worth noting from the syntactical point of view. First, we get the size
  of the dimension named &quot;n&quot; again by using the $SIZE macro. Second,
  there are suddenly these funny &quot;n0&quot; and &quot;n1&quot; index names
  in the code though the signature defines only the dimension &quot;n&quot;. Why
  this? The reason becomes clear when you note that both the first and second
  dimension of $a and $b are named &quot;n&quot; in the signature of
  &quot;symm&quot;. This tells PDL::PP that the first and second dimension of
  these arguments should have the same size. Otherwise the generated function
  will raise a runtime error. However, now in an access to $a and $c PDL::PP
  cannot figure out which index &quot;n&quot; refers to any more just from the
  name of the index. Therefore, the indices with equal dimension names get
  numbered from left to right starting at 0, e.g. in the above example
  &quot;n0&quot; refers to the first dimension of $a and $c, &quot;n1&quot; to
  the second and so on.
<div class="Pp"></div>
In all examples so far, we have only used the &quot;Pars&quot; and
  &quot;Code&quot; members of the hash that was passed to &quot;pp_def&quot;.
  There are certainly other keys that are recognised by PDL::PP and we will hear
  about some of them in the course of this document. Find a (non-exhaustive)
  list of keys in Appendix A. A list of macros and PPfunctions (we have only
  encountered some of those in the examples above yet) that are expanded in
  values of the hash argument to &quot;pp_def&quot; is summarised in Appendix B.
<div class="Pp"></div>
At this point, it might be appropriate to mention that PDL::PP is not a
  completely static, well designed set of routines (as Tuomas puts it:
  &quot;stop thinking of PP as a set of routines carved in stone&quot;) but
  rather a collection of things that the PDL::PP author (Tuomas J. Lukka)
  considered he would have to write often into his PDL extension routines. PP
  tries to be expandable so that in the future, as new needs arise, new common
  code can be abstracted back into it. If you want to learn more on why you
  might want to change PDL::PP and how to do it check the section on PDL::PP
  internals.
<h2 class="Ss" title="Ss" id="Handling_bad_values"><a class="selflink" href="#Handling_bad_values">Handling
  bad values</a></h2>
If you do not have bad-value support compiled into PDL you can ignore this
  section and the related keys: &quot;BadCode&quot;, &quot;HandleBad&quot;, ...
  (try printing out the value of $PDL::Bad::Status - if it equals 0 then move
  straight on).
<div class="Pp"></div>
There are several keys and macros used when writing code to handle bad values.
  The first one is the &quot;HandleBad&quot; key:
<dl class="Bl-tag">
  <dt class="It-tag">HandleBad =&gt; 0</dt>
  <dd class="It-tag">This flags a pp-routine as <i>NOT</i> handling bad values.
      If this routine is sent piddles with their &quot;badflag&quot; set, then a
      warning message is printed to STDOUT and the piddles are processed as if
      the value used to represent bad values is a valid number. The
      &quot;badflag&quot; value is not propagated to the output piddles.
    <div style="height: 1.00em;">&#x00A0;</div>
    An example of when this is used is for FFT routines, which generally do not
      have a way of ignoring part of the data.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">HandleBad =&gt; 1</dt>
  <dd class="It-tag">This causes PDL::PP to write extra code that ensures the
      BadCode section is used, and that the &quot;$ISBAD()&quot; macro (and its
      brethren) work.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">HandleBad is not given</dt>
  <dd class="It-tag">If any of the input piddles have their &quot;badflag&quot;
      set, then the output piddles will have their &quot;badflag&quot; set, but
      any supplied BadCode is ignored.</dd>
</dl>
<div class="Pp"></div>
The value of &quot;HandleBad&quot; is used to define the contents of the
  &quot;BadDoc&quot; key, if it is not given.
<div class="Pp"></div>
To handle bad values, code must be written somewhat differently; for instance,
<div class="Pp"></div>
<pre>
 $c() = $a() + $b();
</pre>
<div class="Pp"></div>
becomes something like
<div class="Pp"></div>
<pre>
 if ( $a() != BADVAL &amp;&amp; $b() != BADVAL ) {
    $c() = $a() + $b();
 } else {
    $c() = BADVAL;
 }
</pre>
<div class="Pp"></div>
However, we only want the second version if bad values are present in the input
  piddles (and that bad-value support is wanted!) - otherwise we actually want
  the original code. This is where the &quot;BadCode&quot; key comes in; you use
  it to specify the code to execute if bad values may be present, and PP uses
  both it and the &quot;Code&quot; section to create something like:
<div class="Pp"></div>
<pre>
 if ( bad_values_are_present ) {
    fancy_threadloop_stuff {
       BadCode
    }
 } else {
    fancy_threadloop_stuff {
       Code
    }
 }
</pre>
<div class="Pp"></div>
This approach means that there is virtually no overhead when bad values are not
  present (i.e. the badflag routine returns 0).
<div class="Pp"></div>
The C preprocessor symbol &quot;PDL_BAD_CODE&quot; is defined when the bad code
  is compiled, so that you can reduce the amount of code you write. The BadCode
  section can use the same macros and looping constructs as the Code section.
  However, it wouldn't be much use without the following additional macros:
<dl class="Bl-tag">
  <dt class="It-tag">$ISBAD(var)</dt>
  <dd class="It-tag">To check whether a piddle's value is bad, use the $ISBAD
      macro:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 if ( $ISBAD(a()) ) { printf(&quot;a() is bad\n&quot;); }
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also access given elements of a piddle:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 if ( $ISBAD(a(n=&gt;l)) ) { printf(&quot;element %d of a() is bad\n&quot;, l); }
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$ISGOOD(var)</dt>
  <dd class="It-tag">This is the opposite of the $ISBAD macro.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$SETBAD(var)</dt>
  <dd class="It-tag">For when you want to set an element of a piddle bad.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$ISBADVAR(c_var,pdl)</dt>
  <dd class="It-tag">If you have cached the value of a piddle &quot;$a()&quot;
      into a c-variable (&quot;foo&quot; say), then to check whether it is bad,
      use &quot;$ISBADVAR(foo,a)&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$ISGOODVAR(c_var,pdl)</dt>
  <dd class="It-tag">As above, but this time checking that the cached value
      isn't bad.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$SETBADVAR(c_var,pdl)</dt>
  <dd class="It-tag">To copy the bad value for a piddle into a c variable, use
      &quot;$SETBADVAR(foo,a)&quot;.</dd>
</dl>
<div class="Pp"></div>
<i>TODO:</i> mention &quot;$PPISBAD()&quot; etc macros.
<div class="Pp"></div>
Using these macros, the above code could be specified as:
<div class="Pp"></div>
<pre>
 Code =&gt; '$c() = $a() + $b();',
 BadCode =&gt; '
    if ( $ISBAD(a()) || $ISBAD(b()) ) {
       $SETBAD(c());
    } else {
       $c() = $a() + $b();
    }',
</pre>
<div class="Pp"></div>
Since this is Perl, TMTOWTDI, so you could also write:
<div class="Pp"></div>
<pre>
 BadCode =&gt; '
    if ( $ISGOOD(a()) &amp;&amp; $ISGOOD(b()) ) {
       $c() = $a() + $b();
    } else {
       $SETBAD(c());
    }',
</pre>
<div class="Pp"></div>
You can reduce code repition using the C &quot;PDL_BAD_CODE&quot; macro, using
  the same code for both of the &quot;Code&quot; and &quot;BadCode&quot;
  sections:
<div class="Pp"></div>
<pre>
    #ifdef PDL_BAD_CODE
    if ( $ISGOOD(a()) &amp;&amp; $ISGOOD(b()) ) {
    #endif PDL_BAD_CODE
       $c() = $a() + $b();
    #ifdef PDL_BAD_CODE
    } else {
       $SETBAD(c());
    }
    #endif PDL_BAD_CODE
</pre>
<div class="Pp"></div>
If you want access to the value of the badflag for a given piddle, you can use
  the PDL STATE macros:
<dl class="Bl-tag">
  <dt class="It-tag">$ISPDLSTATEBAD(pdl)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$ISPDLSTATEGOOD(pdl)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$SETPDLSTATEBAD(pdl)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$SETPDLSTATEGOOD(pdl)</dt>
  <dd class="It-tag"></dd>
</dl>
<div class="Pp"></div>
<i>TODO:</i> mention the &quot;FindBadStatusCode&quot; and
  &quot;CopyBadStatusCode&quot; options to &quot;pp_def&quot;, as well as the
  &quot;BadDoc&quot; key.
<h2 class="Ss" title="Ss" id="Interfacing_your_own/library_functions_using_PP"><a class="selflink" href="#Interfacing_your_own/library_functions_using_PP">Interfacing
  your own/library functions using PP</a></h2>
Now, consider the following: you have your own C function (that may in fact be
  part of some library you want to interface to PDL) which takes as arguments
  two pointers to vectors of double:
<div class="Pp"></div>
<pre>
        void myfunc(int n,double *v1,double *v2);
</pre>
<div class="Pp"></div>
The correct way of defining the PDL function is
<div class="Pp"></div>
<pre>
        pp_def('myfunc',
                Pars =&gt; 'a(n); [o]b(n);',
                GenericTypes =&gt; ['D'],
                Code =&gt; 'myfunc($SIZE(n),$P(a),$P(b));'
        );
</pre>
<div class="Pp"></div>
The &quot;$P(&quot; <i>par</i>&quot;)&quot; syntax returns a pointer to the
  first element and the other elements are guaranteed to lie after that.
<div class="Pp"></div>
Notice that here it is possible to make many mistakes. First, $SIZE(n) must be
  used instead of &quot;n&quot;. Second, you shouldn't put any loops in this
  code. Third, here we encounter a new hash key recognised by PDL::PP : the
  &quot;GenericTypes&quot; declaration tells PDL::PP to ONLY GENERATE THE
  TYPELOOP FOP THE LIST OF TYPES SPECIFIED. In this case &quot;double&quot;.
  This has two advantages. Firstly the size of the compiled code is reduced
  vastly, secondly if non-double arguments are passed to &quot;myfunc()&quot;
  PDL will automatically convert them to double before passing to the external C
  routine and convert them back afterwards.
<div class="Pp"></div>
One can also use &quot;Pars&quot; to qualify the types of individual arguments.
  Thus one could also write this as:
<div class="Pp"></div>
<pre>
        pp_def('myfunc',
                Pars =&gt; 'double a(n); double [o]b(n);',
                Code =&gt; 'myfunc($SIZE(n),$P(a),$P(b));'
        );
</pre>
<div class="Pp"></div>
The type specification in &quot;Pars&quot; exempts the argument from variation
  in the typeloop - rather it is automatically converted too and from the type
  specified. This is obviously useful in a more general example, e.g.:
<div class="Pp"></div>
<pre>
        void myfunc(int n,float *v1,long *v2);
        pp_def('myfunc',
                Pars =&gt; 'float a(n); long [o]b(n);',
                GenericTypes =&gt; ['F'],
                Code =&gt; 'myfunc($SIZE(n),$P(a),$P(b));'
        );
</pre>
<div class="Pp"></div>
Note we still use &quot;GenericTypes&quot; to reduce the size of the type loop,
  obviously PP could in principle spot this and do it automatically though the
  code has yet to attain that level of sophistication!
<div class="Pp"></div>
Finally note when types are converted automatically one MUST use the
  &quot;[o]&quot; qualifier for output variables or you hard one changes will
  get optimised away by PP!
<div class="Pp"></div>
If you interface a large library you can automate the interfacing even further.
  Perl can help you again(!) in doing this. In many libraries you have certain
  calling conventions. This can be exploited. In short, you can write a little
  parser (which is really not difficult in Perl) that then generates the calls
  to &quot;pp_def&quot; from parsed descriptions of the functions in that
  library. For an example, please check the <i>Slatec</i> interface in the
  &quot;Lib&quot; tree of the PDL distribution. If you want to check (during
  debugging) which calls to PP functions your Perl code generated a little
  helper package comes in handy which replaces the PP functions by identically
  named ones that dump their arguments to stdout.
<div class="Pp"></div>
Just say
<div class="Pp"></div>
<pre>
   perl -MPDL::PP::Dump myfile.pd
</pre>
<div class="Pp"></div>
to see the calls to &quot;pp_def&quot; and friends. Try it with <i>ops.pd</i>
  and <i>slatec.pd</i>. If you're interested (or want to enhance it), the source
  is in Basic/Gen/PP/Dump.pm
<h2 class="Ss" title="Ss" id="Other_macros_and_functions_in_the_Code_section"><a class="selflink" href="#Other_macros_and_functions_in_the_Code_section">Other
  macros and functions in the Code section</a></h2>
Macros: So far we have encountered the $SIZE, $GENERIC and $P macros. Now we are
  going to quickly explain the other macros that are expanded in the
  &quot;Code&quot; section of PDL::PP along with examples of their usage.
<dl class="Bl-tag">
  <dt class="It-tag">$T</dt>
  <dd class="It-tag">The $T macro is used for type switches. This is very useful
      when you have to use different external (e.g. library) functions depending
      on the input type of arguments. The general syntax is
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        $Ttypeletters(type_alternatives)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    where &quot;typeletters&quot; is a permutation of a subset of the letters
      &quot;BSULFD&quot; which stand for Byte, Short, Ushort, etc. and
      &quot;type_alternatives&quot; are the expansions when the type of the PP
      operation is equal to that indicated by the respective letter. Let's
      illustrate this incomprehensible description by an example. Assuming you
      have two C functions with prototypes
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  void float_func(float *in, float *out);
  void double_func(double *in, double *out);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    which do basically the same thing but one accepts float and the other double
      pointers. You could interface them to PDL by defining a generic function
      &quot;foofunc&quot; (which will call the correct function depending on the
      type of the transformation):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  pp_def('foofunc',
        Pars =&gt; ' a(n); [o] b();',
        Code =&gt; ' $TFD(float_func,double_func) ($P(a),$P(b));'
        GenericTypes =&gt; [qw(F D)],
  );
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Please note that you can't say
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
       Code =&gt; ' $TFD(float,double)_func ($P(a),$P(b));'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    since the $T macro expands with trailing spaces, analogously to C
      preprocessor macros. The slightly longer form illustrated above is
      correct. If you really want brevity, you can of course do
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        '$TBSULFD('.(join ',',map {&quot;long_identifier_name_$_&quot;}
                qw/byt short unseigned lounge flotte dubble/).');'
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$PP</dt>
  <dd class="It-tag">The $PP macro is used for a so called <i>physical pointer
      access</i>. The <i>physical</i> refers to some internal optimisations of
      PDL (for those who are familiar with the PDL core we are talking about the
      vaffine optimisations). This macro is mainly for internal use and you
      shouldn't need to use it in any of your normal code.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$COMP (and the &quot;OtherPars&quot; section)</dt>
  <dd class="It-tag">The $COMP macro is used to access non-pdl values in the
      code section. Its name is derived from the implementation of
      transformations in PDL. The variables you can refer to using $COMP are
      members of the ``compiled'' structure that represents the PDL
      transformation in question but does not yet contain any information about
      dimensions (for further details check PDL::Internals). However, you can
      treat $COMP just as a black box without knowing anything about the
      implementation of transformations in PDL. So when would you use this
      macro? Its main usage is to access values of arguments that are declared
      in the &quot;OtherPars&quot; section of a &quot;pp_def&quot; definition.
      But then you haven't heard about the &quot;OtherPars&quot; key yet?! Let's
      have another example that illustrates typical usage of both new features:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  pp_def('pnmout',
        Pars =&gt; 'a(m)',
        OtherPars =&gt; &quot;char* fd&quot;,
        GenericTypes =&gt; [qw(B U S L)],
        Code =&gt; 'PerlIO *fp;
                 IO *io;
               io = GvIO(gv_fetchpv($COMP(fd),FALSE,SVt_PVIO));
                 if (!io || !(fp = IoIFP(io)))
                        croak(&quot;Can\'t figure out FP&quot;);
                 if (PerlIO_write(fp,$P(a),len) != len)
                                croak(&quot;Error writing pnm file&quot;);
  ');
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This function is used to write data from a pdl to a file. The file
      descriptor is passed as a string into this function. This parameter does
      not go into the &quot;Pars&quot; section since it cannot be usefully
      treated like a pdl but rather into the aptly named &quot;OtherPars&quot;
      section. Parameters in the &quot;OtherPars&quot; section follow those in
      the &quot;Pars&quot; section when invoking the function, i.e.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
   open FILE,&quot;&gt;out.dat&quot; or die &quot;couldn't open out.dat&quot;;
   pnmout($pdl,'FILE');
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    When you want to access this parameter inside the code section you have to
      tell PP by using the $COMP macro, i.e. you write &quot;$COMP(fd)&quot; as
      in the example. Otherwise PP wouldn't know that the &quot;fd&quot; you are
      referring to is the same as that specified in the &quot;OtherPars&quot;
      section.
    <div style="height: 1.00em;">&#x00A0;</div>
    Another use for the &quot;OtherPars&quot; section is to set a named
      dimension in the signature. Let's have an example how that is done:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  pp_def('setdim',
        Pars =&gt; '[o] a(n)',
        OtherPars =&gt; 'int ns =&gt; n',
        Code =&gt; 'loop(n) %{ $a() = n; %}',
  );
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This says that the named dimension &quot;n&quot; will be initialised from
      the value of the <i>other parameter</i> &quot;ns&quot; which is of integer
      type (I guess you have realised that we use the &quot;CType From =&gt;
      named_dim&quot; syntax). Now you can call this function in the usual way:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  setdim(($a=null),5);
  print $a;
    [ 0 1 2 3 4 ]
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Admittedly this function is not very useful but it demonstrates how it
      works. If you call the function with an existing pdl and you don't need to
      explicitly specify the size of &quot;n&quot; since PDL::PP can figure it
      out from the dimensions of the non-null pdl. In that case you just give
      the dimension parameter as &quot;-1&quot;:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  $a = hist($b);
  setdim($a,-1);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    That should do it.</dd>
</dl>
<div class="Pp"></div>
The only PP function that we have used in the examples so far is
  &quot;loop&quot;. Additionally, there are currently two other functions which
  are recognised in the &quot;Code&quot; section:
<dl class="Bl-tag">
  <dt class="It-tag">threadloop</dt>
  <dd class="It-tag">As we heard above the signature of a PP defined function
      defines the dimensions of all the pdl arguments involved in a
      <i>primitive</i> operation. However, you often call the functions that you
      defined with PP with pdls that have more dimensions than those specified
      in the signature. In this case the primitive operation is performed on all
      subslices of appropriate dimensionality in what is called a <i>thread
      loop</i> (see also overview above and PDL::Indexing). Assuming you have
      some notion of this concept you will probably appreciate that the
      operation specified in the code section should be optimised since this is
      the tightest loop inside a thread loop. However, if you revisit the
      example where we define the &quot;pnmout&quot; function, you will quickly
      realise that looking up the &quot;IO&quot; file descriptor in the inner
      thread loop is not very efficient when writing a pdl with many rows. A
      better approach would be to look up the &quot;IO&quot; descriptor once
      outside the thread loop and use its value then inside the tightest thread
      loop. This is exactly where the &quot;threadloop&quot; function comes in
      handy. Here is an improved definition of &quot;pnmout&quot; which uses
      this function:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  pp_def('pnmout',
        Pars =&gt; 'a(m)',
        OtherPars =&gt; &quot;char* fd&quot;,
        GenericTypes =&gt; [qw(B U S L)],
        Code =&gt; 'PerlIO *fp;
                 IO *io;
                 int len;
               io = GvIO(gv_fetchpv($COMP(fd),FALSE,SVt_PVIO));
                 if (!io || !(fp = IoIFP(io)))
                        croak(&quot;Can\'t figure out FP&quot;);
                 len = $SIZE(m) * sizeof($GENERIC());
                 threadloop %{
                    if (PerlIO_write(fp,$P(a),len) != len)
                                croak(&quot;Error writing pnm file&quot;);
                 %}
  ');
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This works as follows. Normally the C code you write inside the
      &quot;Code&quot; section is placed inside a thread loop (i.e. PP generates
      the appropriate wrapping XS code around it). However, when you explicitly
      use the &quot;threadloop&quot; function, PDL::PP recognises this and
      doesn't wrap your code with an additional thread loop. This has the effect
      that code you write outside the thread loop is only executed once per
      transformation and just the code with in the surrounding &quot;%{ ...
      %}&quot; pair is placed within the tightest thread loop. This also comes
      in handy when you want to perform a decision (or any other code,
      especially CPU intensive code) only once per thread, i.e.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  pp_addhdr('
    #define RAW 0
    #define ASCII 1
  ');
  pp_def('do_raworascii',
         Pars =&gt; 'a(); b(); [o]c()',
         OtherPars =&gt; 'int mode',
       Code =&gt; ' switch ($COMP(mode)) {
                    case RAW:
                        threadloop %{
                            /* do raw stuff */
                        %}
                        break;
                    case ASCII:
                        threadloop %{
                            /* do ASCII stuff */
                        %}
                        break;
                    default:
                        croak(&quot;unknown mode&quot;);
                   }'
   );
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">types</dt>
  <dd class="It-tag">The types function works similar to the $T macro. However,
      with the &quot;types&quot; function the code in the following block
      (delimited by &quot;%{&quot; and &quot;%}&quot; as usual) is executed for
      all those cases in which the datatype of the operation is <i>any of</i>
      the types represented by the letters in the argument to &quot;type&quot;,
      e.g.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
     Code =&gt; '...
             types(BSUL) %{
                 /* do integer type operation */
             %}
             types(FD) %{
                 /* do floating point operation */
             %}
             ...'
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="The_RedoDimsCode_Section"><a class="selflink" href="#The_RedoDimsCode_Section">The
  RedoDimsCode Section</a></h2>
The &quot;RedoDimsCode&quot; key is an optional key that is used to compute
  dimensions of piddles at runtime in case the standard rules for computing
  dimensions from the signature are not sufficient. The contents of the
  &quot;RedoDimsCode&quot; entry is interpreted in the same way that the Code
  section is interpreted-- <i>i.e.</i>, PP macros are expanded and the result is
  interpreted as C code. The purpose of the code is to set the size of some
  dimensions that appear in the signature. Storage allocation and threadloops
  and so forth will be set up as if the computed dimension had appeared in the
  signature. In your code, you first compute the desired size of a named
  dimension in the signature according to your needs and then assign that value
  to it via the $ <i>SIZE()</i> macro.
<div class="Pp"></div>
As an example, consider the following situation. You are interfacing an external
  library routine that requires an temporary array for workspace to be passed as
  an argument. Two input data arrays that are passed are p(m) and x(n). The
  output data array is y(n). The routine requires a workspace array with a
  length of n+m*m, and you'd like the storage created automatically just like it
  would be for any piddle flagged with [t] or [o]. What you'd like is to say
  something like
<div class="Pp"></div>
<pre>
 pp_def( &quot;myexternalfunc&quot;,
  Pars =&gt; &quot; p(m);  x(n);  [o] y; [t] work(n+m*m); &quot;, ...
</pre>
<div class="Pp"></div>
but that won't work, because PP can't interpret expressions with arithmetic in
  the signature. Instead you write
<div class="Pp"></div>
<pre>
  pp_def(
      &quot;myexternalfunc&quot;,
      Pars         =&gt; ' p(m);  x(n);  [o] y(); [t] work(wn); ',
      RedoDimsCode =&gt; '
        PDL_Indx im = $PDL(p)-&gt;dims[0];
        PDL_Indx in = $PDL(x)-&gt;dims[0];
        PDL_Indx min = in + im * im;
        PDL_Indx inw = $PDL(work)-&gt;dims[0];
        $SIZE(wn) = inw &gt;= min ? inw : min;
      ',
      Code =&gt; '
        externalfunc( $P(p), $P(x), $SIZE(m), $SIZE(n), $P(work) );
      '
  );
</pre>
<div class="Pp"></div>
This code works as follows: The macro $PDL(p) expands to a pointer to the pdl
  struct for the piddle p. You don't want a pointer to the data ( ie $P ) in
  this case, because you want to access the methods for the piddle on the C
  level. You get the first dimension of each of the piddles and store them in
  integers. Then you compute the minimum length the work array can be. If the
  user sent a piddle &quot;work&quot; with sufficient storage, then leave it
  alone. If the user sent, say a null pdl, or no pdl at all, then the size of wn
  will be zero and you reset it to the minimum value. Before the code in the
  Code section is executed PP will create the proper storage for
  &quot;work&quot; if it does not exist. Note that you only took the first
  dimension of &quot;p&quot; and &quot;x&quot; because the user may have sent
  piddles with extra threading dimensions. Of course, the temporary piddle
  &quot;work&quot; (note the [t] flag) should not be given any thread dimensions
  anyway.
<div class="Pp"></div>
You can also use &quot;RedoDimsCode&quot; to set the dimension of a piddle
  flagged with [o]. In this case you set the dimensions for the named dimension
  in the signature using $ <i>SIZE()</i> as in the preceding example. However,
  because the piddle is flagged with [o] instead of [t], threading dimensions
  will be added if required just as if the size of the dimension were computed
  from the signature according to the usual rules. Here is an example from
  PDL::Math
<div class="Pp"></div>
<pre>
 pp_def(&quot;polyroots&quot;,
      Pars =&gt; 'cr(n); ci(n); [o]rr(m); [o]ri(m);',
      RedoDimsCode =&gt; 'PDL_Indx sn = $PDL(cr)-&gt;dims[0]; $SIZE(m) = sn-1;',
</pre>
<div class="Pp"></div>
The input piddles are the real and imaginary parts of complex coefficients of a
  polynomial. The output piddles are real and imaginary parts of the roots.
  There are &quot;n&quot; roots to an &quot;n&quot;th order polynomial and such
  a polynomial has &quot;n+1&quot; coefficients (the zeoreth through the
  &quot;n&quot;th). In this example, threading will work correctly. That is, the
  first dimension of the output piddle with have its dimension adjusted, but
  other threading dimensions will be assigned just as if there were no
  &quot;RedoDimsCode&quot;.
<h2 class="Ss" title="Ss" id="Typemap_handling_in_the_&quot;OtherPars&quot;_section"><a class="selflink" href="#Typemap_handling_in_the_&quot;OtherPars&quot;_section">Typemap
  handling in the &quot;OtherPars&quot; section</a></h2>
The &quot;OtherPars&quot; section discussed above is very often absolutely
  crucial when you interface external libraries with PDL. However in many cases
  the external libraries either use derived types or pointers of various types.
<div class="Pp"></div>
The standard way to handle this in Perl is to use a &quot;typemap&quot; file.
  This is discussed in some detail in perlxs in the standard Perl documentation.
  In PP the functionality is very similar, so you can create a
  &quot;typemap&quot; file in the directory where your PP file resides and when
  it is built it is automatically read in to figure out the appropriate
  translation between the C type and Perl's built-in type.
<div class="Pp"></div>
That said, there are a couple of important differences from the general handling
  of types in XS. The first, and probably most important, is that at the moment
  pointers to types are not allowed in the &quot;OtherPars&quot; section. To get
  around this limitation you must use the &quot;IV&quot; type (thanks to Judd
  Taylor for pointing out that this is necessary for portability).
<div class="Pp"></div>
It is probably best to illustrate this with a couple of code-snippets:
<div class="Pp"></div>
For instance the &quot;gsl_spline_init&quot; function has the following C
  declaration:
<div class="Pp"></div>
<pre>
    int  gsl_spline_init(gsl_spline * spline,
          const double xa[], const double ya[], size_t size);
</pre>
<div class="Pp"></div>
Clearly the &quot;xa&quot; and &quot;ya&quot; arrays are candidates for being
  passed in as piddles and the &quot;size&quot; argument is just the length of
  these piddles so that can be handled by the &quot;$SIZE()&quot; macro in PP.
  The problem is the pointer to the &quot;gsl_spline&quot; type. The natural
  solution would be to write an &quot;OtherPars&quot; declaration of the form
<div class="Pp"></div>
<pre>
    OtherPars =&gt; 'gsl_spline *spl'
</pre>
<div class="Pp"></div>
and write a short &quot;typemap&quot; file which handled this type. This does
  not work at present however! So what you have to do is to go around the
  problem slightly (and in some ways this is easier too!):
<div class="Pp"></div>
The solution is to declare &quot;spline&quot; in the &quot;OtherPars&quot;
  section using an &quot;Integer Value&quot;, &quot;IV&quot;. This hides the
  nature of the variable from PP and you then need to (well to avoid compiler
  warnings at least!) perform a type cast when you use the variable in your
  code. Thus &quot;OtherPars&quot; should take the form:
<div class="Pp"></div>
<pre>
    OtherPars =&gt; 'IV spl'
</pre>
<div class="Pp"></div>
and when you use it in the code you will write
<div class="Pp"></div>
<pre>
    INT2PTR(gsl_spline *, $COMP(spl))
</pre>
<div class="Pp"></div>
where the Perl API macro &quot;INT2PTR&quot; has been used to handle the pointer
  cast to avoid compiler warnings and problems for machines with mixed 32bit and
  64bit Perl configurations. Putting this together as Andres Jordan has done
  (with the modification using &quot;IV&quot; by Judd Taylor) in the
  &quot;gsl_interp.pd&quot; in the distribution source you get:
<div class="Pp"></div>
<pre>
     pp_def('init_meat',
            Pars =&gt; 'double x(n); double y(n);',
            OtherPars =&gt; 'IV spl',
            Code =&gt;'
         gsl_spline_init,( INT2PTR(gsl_spline *, $COMP(spl)), $P(x),$P(y),$SIZE(n)));'
    );
</pre>
<div class="Pp"></div>
where I have removed a macro wrapper call, but that would obscure the
  discussion.
<div class="Pp"></div>
The other minor difference as compared to the standard typemap handling in Perl,
  is that the user cannot specify non-standard typemap locations or typemap
  filenames using the &quot;TYPEMAPS&quot; option in MakeMaker... Thus you can
  only use a file called &quot;typemap&quot; and/or the &quot;IV&quot; trick
  above.
<h2 class="Ss" title="Ss" id="Other_useful_PP_keys_in_data_operation_definitions"><a class="selflink" href="#Other_useful_PP_keys_in_data_operation_definitions">Other
  useful PP keys in data operation definitions</a></h2>
You have already heard about the &quot;OtherPars&quot; key. Currently, there are
  not many other keys for a data operation that will be useful in normal
  (whatever that is) PP programming. In fact, it would be interesting to hear
  about a case where you think you need more than what is provided at the
  moment. Please speak up on one of the PDL mailing lists. Most other keys
  recognised by &quot;pp_def&quot; are only really useful for what we call
  <i>slice operations</i> (see also above).
<div class="Pp"></div>
One thing that is strongly being planned is variable number of arguments, which
  will be a little tricky.
<div class="Pp"></div>
An incomplete list of the available keys:
<dl class="Bl-tag">
  <dt class="It-tag">Inplace</dt>
  <dd class="It-tag">Setting this key marks the routine as working inplace - ie
      the input and output piddles are the same. An example is
      &quot;$a-&gt;inplace-&gt;sqrt()&quot; (or
    &quot;sqrt(inplace($a))&quot;).</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">Inplace =&gt; 1</dt>
  <dd class="It-tag">Use when the routine is a unary function, such as
      &quot;sqrt&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Inplace =&gt; ['a']</dt>
  <dd class="It-tag">If there are more than one input piddles, specify the name
      of the one that can be changed inplace using an array reference.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Inplace =&gt; ['a','b']</dt>
  <dd class="It-tag">If there are more than one output piddle, specify the name
      of the input piddle and output piddle in a 2-element array reference. This
      probably isn't needed, but left in for completeness.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
If bad values are being used, care must be taken to ensure the propagation of
  the badflag when inplace is being used; consider this excerpt from
  <i>Basic/Bad/bad.pd</i>:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
  pp_def('replacebad',HandleBad =&gt; 1,
    Pars =&gt; 'a(); [o]b();',
    OtherPars =&gt; 'double newval',
    Inplace =&gt; 1,
    CopyBadStatusCode =&gt; 
    '/* propagate badflag if inplace AND it has changed */
     if ( a == b &amp;&amp; $ISPDLSTATEBAD(a) )
       PDL-&gt;propagate_badflag( b, 0 );
     /* always make sure the output is &quot;good&quot; */
     $SETPDLSTATEGOOD(b);
    ',
    ...
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Since this routine removes all bad values, then the output piddle had its bad
  flag cleared. If run inplace (so &quot;a == b&quot;), then we have to tell all
  the children of &quot;a&quot; that the bad flag has been cleared (to save time
  we make sure that we call &quot;PDL-&gt;propagate_badgflag&quot; only if the
  input piddle had its bad flag set).
<div style="height: 1.00em;">&#x00A0;</div>
NOTE: one idea is that the documentation for the routine could be automatically
  flagged to indicate that it can be executed inplace, ie something similar to
  how &quot;HandleBad&quot; sets &quot;BadDoc&quot; if it's not supplied (it's
  not an ideal solution).</div>
<h2 class="Ss" title="Ss" id="Other_PDL::PP_functions_to_support_concise_package_definition"><a class="selflink" href="#Other_PDL::PP_functions_to_support_concise_package_definition">Other
  PDL::PP functions to support concise package definition</a></h2>
So far, we have described the &quot;pp_def&quot; and &quot;pp_done&quot;
  functions. PDL::PP exports a few other functions to aid you in writing concise
  PDL extension package definitions.
<div class="Pp"></div>
<i>pp_addhdr</i>
<div class="Pp"></div>
Often when you interface library functions as in the above example you have to
  include additional C include files. Since the XS file is generated by PP we
  need some means to make PP insert the appropriate include directives in the
  right place into the generated XS file. To this end there is the
  &quot;pp_addhdr&quot; function. This is also the function to use when you want
  to define some C functions for internal use by some of the XS functions (which
  are mostly functions defined by &quot;pp_def&quot;). By including these
  functions here you make sure that PDL::PP inserts your code before the point
  where the actual XS module section begins and will therefore be left untouched
  by xsubpp (cf. <i>perlxs</i> and <i>perlxstut</i> man pages).
<div class="Pp"></div>
A typical call would be
<div class="Pp"></div>
<pre>
  pp_addhdr('
  #include &lt;unistd.h&gt;       /* we need defs of XXXX */
  #include &quot;libprotos.h&quot;    /* prototypes of library functions */
  #include &quot;mylocaldecs.h&quot;  /* Local decs */
  static void do_the real_work(PDL_Byte * in, PDL_Byte * out, int n)
  {
        /* do some calculations with the data */
  }
  ');
</pre>
<div class="Pp"></div>
This ensures that all the constants and prototypes you need will be properly
  included and that you can use the internal functions defined here in the
  &quot;pp_def&quot;s, e.g.:
<div class="Pp"></div>
<pre>
  pp_def('barfoo',
         Pars =&gt; ' a(n); [o] b(n)',
         GenericTypes =&gt; ['B'],
         Code =&gt; ' PDL_Indx ns = $SIZE(n);
                   do_the_real_work($P(a),$P(b),ns);
                 ',
  );
</pre>
<div class="Pp"></div>
<i>pp_addpm</i>
<div class="Pp"></div>
In many cases the actual PP code (meaning the arguments to &quot;pp_def&quot;
  calls) is only part of the package you are currently implementing. Often there
  is additional Perl code and XS code you would normally have written into the
  pm and XS files which are now automatically generated by PP. So how to get
  this stuff into those dynamically generated files? Fortunately, there are a
  couple of functions, generally called &quot;pp_addXXX&quot; that assist you in
  doing this.
<div class="Pp"></div>
Let's assume you have additional Perl code that should go into the generated
  <b>pm</b>-file. This is easily achieved with the &quot;pp_addpm&quot; command:
<div class="Pp"></div>
<pre>
   pp_addpm(&lt;&lt;'EOD');
   =head1 NAME
   PDL::Lib::Mylib -- a PDL interface to the Mylib library
   =head1 DESCRIPTION
   This package implements an interface to the Mylib package with full
   threading and indexing support (see L&lt;PDL::Indexing&gt;).
   =cut
   use PGPLOT;
   =head2 use_myfunc
        this function applies the myfunc operation to all the
        elements of the input pdl regardless of dimensions
        and returns the sum of the result
   =cut
   sub use_myfunc {
        my $pdl = shift;
        myfunc($pdl-&gt;clump(-1),($res=null));
        return $res-&gt;sum;
   }
   EOD
</pre>
<div class="Pp"></div>
<i>pp_add_exported</i>
<div class="Pp"></div>
You have probably got the idea. In some cases you also want to export your
  additional functions. To avoid getting into trouble with PP which also messes
  around with the @EXPORT array you just tell PP to add your functions to the
  list of exported functions:
<div class="Pp"></div>
<pre>
  pp_add_exported('use_myfunc gethynx');
</pre>
<div class="Pp"></div>
<i>pp_add_isa</i>
<div class="Pp"></div>
The &quot;pp_add_isa&quot; command works like the the
  &quot;pp_add_exported&quot; function. The arguments to &quot;pp_add_isa&quot;
  are added the @ISA list, e.g.
<div class="Pp"></div>
<pre>
  pp_add_isa(' Some::Other::Class ');
</pre>
<div class="Pp"></div>
<i>pp_bless</i>
<div class="Pp"></div>
If your pp_def routines are to be used as object methods use
  &quot;pp_bless&quot; to specify the package (i.e. class) to which your
  <i>pp_def</i>ed methods will be added. For example,
  &quot;pp_bless('PDL::MyClass')&quot;. The default is &quot;PDL&quot; if this
  is omitted.
<div class="Pp"></div>
<i>pp_addxs</i>
<div class="Pp"></div>
Sometimes you want to add extra XS code of your own (that is generally not
  involved with any threading/indexing issues but supplies some other
  functionality you want to access from the Perl side) to the generated XS file,
  for example
<div class="Pp"></div>
<pre>
  pp_addxs('','
  # Determine endianness of machine
  int
  isbigendian()
     CODE:
       unsigned short i;
       PDL_Byte *b;
       i = 42; b = (PDL_Byte*) (void*) &amp;i;
       if (*b == 42)
          RETVAL = 0;
       else if (*(b+1) == 42)
          RETVAL = 1;
       else
          croak(&quot;Impossible - machine is neither big nor little endian!!\n&quot;);
       OUTPUT:
         RETVAL
  ');
</pre>
<div class="Pp"></div>
Especially &quot;pp_add_exported&quot; and &quot;pp_addxs&quot; should be used
  with care. PP uses PDL::Exporter, hence letting PP export your function means
  that they get added to the standard list of function exported by default (the
  list defined by the export tag ``:Func''). If you use &quot;pp_addxs&quot; you
  shouldn't try to do anything that involves threading or indexing directly. PP
  is much better at generating the appropriate code from your definitions.
<div class="Pp"></div>
<i>pp_add_boot</i>
<div class="Pp"></div>
Finally, you may want to add some code to the BOOT section of the XS file (if
  you don't know what that is check <i>perlxs</i>). This is easily done with the
  &quot;pp_add_boot&quot; command:
<div class="Pp"></div>
<pre>
  pp_add_boot(&lt;&lt;EOB);
        descrip = mylib_initialize(KEEP_OPEN);
        if (descrip == NULL)
           croak(&quot;Can't initialize library&quot;);
        GlobalStruc-&gt;descrip = descrip;
        GlobalStruc-&gt;maxfiles = 200;
  EOB
</pre>
<div class="Pp"></div>
<i>pp_export_nothing</i>
<div class="Pp"></div>
By default, PP.pm puts all subs defined using the pp_def function into the
  output .pm file's EXPORT list. This can create problems if you are creating a
  subclassed object where you don't want any methods exported. (i.e. the methods
  will only be called using the $object-&gt;method syntax).
<div class="Pp"></div>
For these cases you can call <i>pp_export_nothing()</i> to clear out the export
  list. Example (At the end of the .pd file):
<div class="Pp"></div>
<pre>
  pp_export_nothing();
  pp_done();
</pre>
<div class="Pp"></div>
<i>pp_core_importList</i>
<div class="Pp"></div>
By default, PP.pm puts the 'use Core;' line into the output .pm file. This
  imports Core's exported names into the current namespace, which can create
  problems if you are over-riding one of Core's methods in the current file. You
  end up getting messages like &quot;Warning: sub sumover redefined in file
  subclass.pm&quot; when running the program.
<div class="Pp"></div>
For these cases the pp_core_importList can be used to change what is imported
  from Core.pm. For example:
<div class="Pp"></div>
<pre>
  pp_core_importList('()')
</pre>
<div class="Pp"></div>
This would result in
<div class="Pp"></div>
<pre>
  use Core();
</pre>
<div class="Pp"></div>
being generated in the output .pm file. This would result in no names being
  imported from Core.pm. Similarly, calling
<div class="Pp"></div>
<pre>
  pp_core_importList(' qw/ barf /')
</pre>
<div class="Pp"></div>
would result in
<div class="Pp"></div>
<pre>
  use Core qw/ barf/;
</pre>
<div class="Pp"></div>
being generated in the output .pm file. This would result in just 'barf' being
  imported from Core.pm.
<div class="Pp"></div>
<i>pp_setversion</i>
<div class="Pp"></div>
I am pretty sure that this allows you to simultaneously set the .pm and .xs
  files' versions, thus avoiding unnecessary version-skew between the two. To
  use this, simply have the following line at some point in your .pd file:
<div class="Pp"></div>
<pre>
 pp_setversion('0.0.3');
</pre>
<div class="Pp"></div>
However, don't use this if you use Module::Build::PDL. See that module's
  documentation for details.
<div class="Pp"></div>
<i>pp_deprecate_module</i>
<div class="Pp"></div>
If a particular module is deemed obsolete, this function can be used to mark it
  as deprecated. This has the effect of emitting a warning when a user tries to
  &quot;use&quot; the module. The generated POD for this module also carries a
  deprecation notice. The replacement module can be passed as an argument like
  this:
<div class="Pp"></div>
<pre>
 pp_deprecate_module( infavor =&gt; &quot;PDL::NewNonDeprecatedModule&quot; );
</pre>
<div class="Pp"></div>
Note that function affects <i>only</i> the runtime warning and the POD.
<h1 class="Sh" title="Sh" id="Making_your_PP_function_&quot;private&quot;"><a class="selflink" href="#Making_your_PP_function_&quot;private&quot;">Making
  your PP function &quot;private&quot;</a></h1>
Let's say that you have a function in your module called PDL::foo that uses the
  PP function &quot;bar_pp&quot; to do the heavy lifting. But you don't want to
  advertise that &quot;bar_pp&quot; exists. To do this, you must move your PP
  function to the top of your module file, then call
<div class="Pp"></div>
<pre>
 pp_export_nothing()
</pre>
<div class="Pp"></div>
to clear the &quot;EXPORT&quot; list. To ensure that no documentation (even the
  default PP docs) is generated, set
<div class="Pp"></div>
<pre>
 Doc =&gt; undef
</pre>
<div class="Pp"></div>
and to prevent the function from being added to the symbol table, set
<div class="Pp"></div>
<pre>
 PMFunc =&gt; ''
</pre>
<div class="Pp"></div>
in your pp_def declaration (see Image2D.pd for an example). This will
  effectively make your PP function &quot;private.&quot; However, it is
  <i>always</i> accessible via PDL::bar_pp due to Perl's module design. But
  making it private will cause the user to go very far out of his or her way to
  use it, so he or she shoulders the consequences!
<h1 class="Sh" title="Sh" id="Slice_operation"><a class="selflink" href="#Slice_operation">Slice
  operation</a></h1>
The slice operation section of this manual is provided using dataflow and lazy
  evaluation: when you need it, ask Tjl to write it. a delivery in a week from
  when I receive the email is 95% probable and two week delivery is 99%
  probable.
<div class="Pp"></div>
And anyway, the slice operations require a much more intimate knowledge of PDL
  internals than the data operations. Furthermore, the complexity of the issues
  involved is considerably higher than that in the average data operation. If
  you would like to convince yourself of this fact take a look at the
  <i>Basic/Slices/slices.pd</i> file in the PDL distribution :-). Nevertheless,
  functions generated using the slice operations are at the heart of the index
  manipulation and dataflow capabilities of PDL.
<div class="Pp"></div>
Also, there are a lot of dirty issues with virtual piddles and vaffines which we
  shall entirely skip here.
<h2 class="Ss" title="Ss" id="Slices_and_bad_values"><a class="selflink" href="#Slices_and_bad_values">Slices
  and bad values</a></h2>
Slice operations need to be able to handle bad values (if support is compiled
  into PDL). The easiest thing to do is look at <i>Basic/Slices/slices.pd</i> to
  see how this works.
<div class="Pp"></div>
Along with &quot;BadCode&quot;, there are also the &quot;BadBackCode&quot; and
  &quot;BadRedoDimsCode&quot; keys for &quot;pp_def&quot;. However, any
  &quot;EquivCPOffsCode&quot; should <i>not</i> need changing, since any changes
  are absorbed into the definition of the &quot;$EQUIVCPOFFS()&quot; macro (i.e.
  it is handled automatically by PDL::PP).
<h2 class="Ss" title="Ss" id="A_few_notes_on_writing_a_slicing_routine..."><a class="selflink" href="#A_few_notes_on_writing_a_slicing_routine...">A
  few notes on writing a slicing routine...</a></h2>
The following few paragraphs describe writing of a new slicing routine
  ('range'); any errors are CED's. (--CED 26-Aug-2002)
<h1 class="Sh" title="Sh" id="Handling_of_&quot;warn&quot;_and_&quot;barf&quot;_in_PP_Code"><a class="selflink" href="#Handling_of_&quot;warn&quot;_and_&quot;barf&quot;_in_PP_Code">Handling
  of &quot;warn&quot; and &quot;barf&quot; in PP Code</a></h1>
For printing warning messages or aborting/dieing, you can call &quot;warn&quot;
  or &quot;barf&quot; from PP code. However, you should be aware that these
  calls have been redefined using C preprocessor macros to
  &quot;PDL-&gt;barf&quot; and &quot;PDL-&gt;warn&quot;. These redefinitions are
  in place to keep you from inadvertently calling perl's &quot;warn&quot; or
  &quot;barf&quot; directly, which can cause segfaults during pthreading (i.e.
  processor multi-threading).
<div class="Pp"></div>
PDL's own versions of &quot;barf&quot; and &quot;warn&quot; will queue-up
  warning or barf messages until after pthreading is completed, and then call
  the perl versions of these routines.
<div class="Pp"></div>
See PDL::ParallelCPU for more information on pthreading.
<h1 class="Sh" title="Sh" id="USEFUL_ROUTINES"><a class="selflink" href="#USEFUL_ROUTINES">USEFUL
  ROUTINES</a></h1>
The PDL &quot;Core&quot; structure, defined in <i>Basic/Core/pdlcore.h.PL</i>,
  contains pointers to a number of routines that may be useful to you. The
  majority of these routines deal with manipulating piddles, but some are more
  general:
<dl class="Bl-tag">
  <dt class="It-tag">PDL-&gt;qsort_B( PDL_Byte *xx, PDL_Indx a, PDL_Indx b
    )</dt>
  <dd class="It-tag">Sort the array &quot;xx&quot; between the indices
      &quot;a&quot; and &quot;b&quot;. There are also versions for the other PDL
      datatypes, with postfix &quot;_S&quot;, &quot;_U&quot;, &quot;_L&quot;,
      &quot;_N&quot;, &quot;_Q&quot;, &quot;_F&quot;, and &quot;_D&quot;. Any
      module using this must ensure that &quot;PDL::Ufunc&quot; is loaded.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">PDL-&gt;qsort_ind_B( PDL_Byte *xx, PDL_Indx *ix, PDL_Indx
    a, PDL_Indx b )</dt>
  <dd class="It-tag">As for &quot;PDL-&gt;qsort_B&quot;, but this time sorting
      the indices rather than the data.</dd>
</dl>
<div class="Pp"></div>
The routine &quot;med2d&quot; in <i>Lib/Image2D/image2d.pd</i> shows how such
  routines are used.
<h1 class="Sh" title="Sh" id="MAKEFILES_FOR_PP_FILES"><a class="selflink" href="#MAKEFILES_FOR_PP_FILES">MAKEFILES
  FOR PP FILES</a></h1>
If you are going to generate a package from your PP file (typical file
  extensions are &quot;.pd&quot; or &quot;.pp&quot; for the files containing PP
  code) it is easiest and safest to leave generation of the appropriate commands
  to the Makefile. In the following we will outline the typical format of a Perl
  Makefile to automatically build and install your package from a description in
  a PP file. Most of the rules to build the xs, pm and other required files from
  the PP file are already predefined in the PDL::Core::Dev package. We just have
  to tell MakeMaker to use it.
<div class="Pp"></div>
In most cases you can define your Makefile like
<div class="Pp"></div>
<pre>
  # Makefile.PL for a package defined by PP code.
  use PDL::Core::Dev;            # Pick up development utilities
  use ExtUtils::MakeMaker;
  $package = [&quot;mylib.pd&quot;,Mylib,PDL::Lib::Mylib];
  %hash = pdlpp_stdargs($package);
  $hash{OBJECT} .= ' additional_Ccode$(OBJ_EXT) ';
  $hash{clean}-&gt;{FILES} .= ' todelete_Ccode$(OBJ_EXT) ';
  $hash{'VERSION_FROM'} = 'mylib.pd';
  WriteMakefile(%hash);
  sub MY::postamble { pdlpp_postamble($package); }
</pre>
<div class="Pp"></div>
Here, the list in $package is: first: PP source file name, then the prefix for
  the produced files and finally the whole package name. You can modify the hash
  in whatever way you like but it would be reasonable to stay within some limits
  so that your package will continue to work with later versions of PDL.
<div class="Pp"></div>
If you don't want to use prepackaged arguments, here is a generic
  <i>Makefile.PL</i> that you can adapt for your own needs:
<div class="Pp"></div>
<pre>
  # Makefile.PL for a package defined by PP code.
  use PDL::Core::Dev;            # Pick up development utilities
  use ExtUtils::MakeMaker;
  WriteMakefile(
   'NAME'       =&gt; 'PDL::Lib::Mylib',
   'VERSION_FROM'       =&gt; 'mylib.pd',
   'TYPEMAPS'     =&gt; [&amp;PDL_TYPEMAP()],
   'OBJECT'       =&gt; 'mylib$(OBJ_EXT) additional_Ccode$(OBJ_EXT)',
   'PM'         =&gt; { 'Mylib.pm'            =&gt; '$(INST_LIBDIR)/Mylib.pm'},
   'INC'          =&gt; &amp;PDL_INCLUDE(), # add include dirs as required by your lib
   'LIBS'         =&gt; [''],   # add link directives as necessary
   'clean'        =&gt; {'FILES'  =&gt;
                          'Mylib.pm Mylib.xs Mylib$(OBJ_EXT)
                          additional_Ccode$(OBJ_EXT)'},
  );
  # Add genpp rule; this will invoke PDL::PP on our PP file
  # the argument is an array reference where the array has three string elements:
  #   arg1: name of the source file that contains the PP code
  #   arg2: basename of the xs and pm files to be generated
  #   arg3: name of the package that is to be generated
  sub MY::postamble { pdlpp_postamble([&quot;mylib.pd&quot;,Mylib,PDL::Lib::Mylib]); }
</pre>
<div class="Pp"></div>
To make life even easier PDL::Core::Dev defines the function
  &quot;pdlpp_stdargs&quot; that returns a hash with default values that can be
  passed (either directly or after appropriate modification) to a call to
  WriteMakefile. Currently, &quot;pdlpp_stdargs&quot; returns a hash where the
  keys are filled in as follows:
<div class="Pp"></div>
<pre>
        (
         'NAME'         =&gt; $mod,
         'TYPEMAPS'     =&gt; [&amp;PDL_TYPEMAP()],
         'OBJECT'       =&gt; &quot;$pref\$(OBJ_EXT)&quot;,
         PM     =&gt; {&quot;$pref.pm&quot; =&gt; &quot;\$(INST_LIBDIR)/$pref.pm&quot;},
         MAN3PODS =&gt; {&quot;$src&quot; =&gt; &quot;\$(INST_MAN3DIR)/$mod.\$(MAN3EXT)&quot;},
         'INC'          =&gt; &amp;PDL_INCLUDE(),
         'LIBS'         =&gt; [''],
         'clean'        =&gt; {'FILES'  =&gt; &quot;$pref.xs $pref.pm $pref\$(OBJ_EXT)&quot;},
        )
</pre>
<div class="Pp"></div>
Here, $src is the name of the source file with PP code, $pref the prefix for the
  generated .pm and .xs files and $mod the name of the extension module to
  generate.
<h1 class="Sh" title="Sh" id="INTERNALS"><a class="selflink" href="#INTERNALS">INTERNALS</a></h1>
The internals of the current version consist of a large table which gives the
  rules according to which things are translated and the subs which implement
  these rules.
<div class="Pp"></div>
Later on, it would be good to make the table modifiable by the user so that
  different things may be tried.
<div class="Pp"></div>
[Meta comment: here will hopefully be more in the future; currently, your best
  bet will be to read the source code :-( or ask on the list (try the latter
  first) ]
<h1 class="Sh" title="Sh" id="Appendix_A:_Some_keys_recognised_by_PDL::PP"><a class="selflink" href="#Appendix_A:_Some_keys_recognised_by_PDL::PP">Appendix
  A: Some keys recognised by PDL::PP</a></h1>
Unless otherwise specified, the arguments are strings. Keys marked with (bad)
  are only used if bad-value support is compiled into PDL.
<dl class="Bl-tag">
  <dt class="It-tag">Pars</dt>
  <dd class="It-tag">define the signature of your function</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OtherPars</dt>
  <dd class="It-tag">arguments which are not pdls. Default: nothing. This is a
      semi-colon separated list of arguments, e.g., &quot;OtherPars=&gt;'int k;
      double value; char* fd'&quot;. See $COMP(x) and also the same entry in
      Appendix B.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Code</dt>
  <dd class="It-tag">the actual code that implements the functionality; several
      PP macros and PP functions are recognised in the string value</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">HandleBad (bad)</dt>
  <dd class="It-tag">If set to 1, the routine is assumed to support bad values
      and the code in the BadCode key is used if bad values are present; it also
      sets things up so that the &quot;$ISBAD()&quot; etc macros can be used. If
      set to 0, cause the routine to print a warning if any of the input piddles
      have their bad flag set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">BadCode (bad)</dt>
  <dd class="It-tag">Give the code to be used if bad values may be present in
      the input piddles. Only used if &quot;HandleBad =&gt; 1&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">GenericTypes</dt>
  <dd class="It-tag">An array reference. The array may contain any subset of the
      one-character strings `B', `S', `U', `L', `Q', `F' and `D', which specify
      which types your operation will accept. The meaning of each type is:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 B - signed byte (i.e. signed char)
 S - signed short (two-byte integer)
 U - unsigned short
 L - signed long (four-byte integer, int on 32 bit systems)
 N - signed integer for indexing piddle elements (platform &amp; Perl-dependent size)
 Q - signed long long (eight byte integer)
 F - float
 D - double
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This is very useful (and important!) when interfacing an external library.
      Default: [qw/B S U L N Q F D/]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Inplace</dt>
  <dd class="It-tag">Mark a function as being able to work inplace.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 Inplace =&gt; 1          if  Pars =&gt; 'a(); [o]b();'
 Inplace =&gt; ['a']      if  Pars =&gt; 'a(); b(); [o]c();'
 Inplace =&gt; ['a','b']  if  Pars =&gt; 'a(); b(); [o]c(); [o]d();'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If bad values are being used, care must be taken to ensure the propagation
      of the badflag when inplace is being used; for instance see the code for
      &quot;replacebad&quot; in <i>Basic/Bad/bad.pd</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Doc</dt>
  <dd class="It-tag">Used to specify a documentation string in Pod format. See
      PDL::Doc for information on PDL documentation conventions. Note: in the
      special case where the PP 'Doc' string is one line this is implicitly used
      for the quick reference AND the documentation!
    <div style="height: 1.00em;">&#x00A0;</div>
    If the Doc field is omitted PP will generate default documentation (after
      all it knows about the Signature).
    <div style="height: 1.00em;">&#x00A0;</div>
    If you really want the function NOT to be documented in any way at this
      point (e.g. for an internal routine, or because you are doing it elsewhere
      in the code) explicitly specify &quot;Doc=&gt;undef&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">BadDoc (bad)</dt>
  <dd class="It-tag">Contains the text returned by the &quot;badinfo&quot;
      command (in &quot;perldl&quot;) or the &quot;-b&quot; switch to the
      &quot;pdldoc&quot; shell script. In many cases, you will not need to
      specify this, since the information can be automatically created by
      PDL::PP. However, as befits computer-generated text, it's rather stilted;
      it may be much better to do it yourself!</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">NoPthread</dt>
  <dd class="It-tag">Optional flag to indicate the PDL function should
      <b>not</b> use processor threads (i.e. pthreads or POSIX threads) to split
      up work across multiple CPU cores. This option is typically set to 1 if
      the underlying PDL function is not threadsafe. If this option isn't
      present, then the function is assumed to be threadsafe. This option only
      applies if PDL has been compiled with POSIX threads enabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">PMCode</dt>
  <dd class="It-tag">PDL functions allow you to pass in a piddle into which you
      want the output saved. This is handy because you can allocate an output
      piddle once and reuse it many times; the alternative would be for PDL to
      create a new piddle each time, which may waste compute cycles or, more
      likely, RAM. This added flexibility comes at the cost of more complexity:
      PDL::PP has to write functions that are smart enough to count the
      arguments passed to it and create new piddles on the fly, but only if you
      want them.
    <div style="height: 1.00em;">&#x00A0;</div>
    PDL::PP is smart enough to do that, but there are restrictions on argument
      order and the like. If you want a more flexible function, you can write
      your own Perl-side wrapper and specify it in the PMCode key. The string
      that you supply must (should) define a Perl function with a name that
      matches what you gave to pp_def in the first place. When you wish to
      eventually invoke the PP-generated function, you will need to supply all
      piddles in the exact order specified in the signature: output piddles are
      not optional, and the PP-generated function will not return anything. The
      obfuscated name that you will call is _&lt;funcname&gt;_int.
    <div style="height: 1.00em;">&#x00A0;</div>
    I believe this documentation needs further clarification, but this will have
      to do. :-(</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">PMFunc</dt>
  <dd class="It-tag">When pp_def generates functions, it typically defines them
      in the PDL package. Then, in the .pm file that it generates for your
      module, it typically adds a line that essentially copies that function
      into your current package's symbol table with code that looks like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 *func_name = \&amp;PDL::func_name;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    It's a little bit smarter than that (it knows when to wrap that sort of
      thing in a BEGIN block, for example, and if you specified something
      different for pp_bless), but that's the gist of it. If you don't care to
      import the function into your current package's symbol table, you can
      specify
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 PMFunc =&gt; '',
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    PMFunc has no other side-effects, so you could use it to insert arbitrary
      Perl code into your module if you like. However, you should use pp_addpm
      if you want to add Perl code to your module.</dd>
</dl>
<h1 class="Sh" title="Sh" id="Appendix_B:_PP_macros_and_functions"><a class="selflink" href="#Appendix_B:_PP_macros_and_functions">Appendix
  B: PP macros and functions</a></h1>
<h2 class="Ss" title="Ss" id="Macros"><a class="selflink" href="#Macros">Macros</a></h2>
Macros labeled by (bad) are only used if bad-value support is compiled into PDL.
<dl class="Bl-tag">
  <dt class="It-tag">$<i>variablename_from_sig</i>()</dt>
  <dd class="It-tag">access a pdl (by its name) that was specified in the
      signature</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$COMP(x)</dt>
  <dd class="It-tag">access a value in the private data structure of this
      transformation (mainly used to use an argument that is specified in the
      &quot;OtherPars&quot; section)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$SIZE(n)</dt>
  <dd class="It-tag">replaced at runtime by the actual size of a <i>named</i>
      dimension (as specified in the <i>signature</i>)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$<i>GENERIC()</i></dt>
  <dd class="It-tag">replaced by the C type that is equal to the runtime type of
      the operation</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$P(a)</dt>
  <dd class="It-tag">a pointer access to the PDL named &quot;a&quot; in the
      signature. Useful for interfacing to C functions</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$PP(a)</dt>
  <dd class="It-tag">a physical pointer access to pdl &quot;a&quot;; mainly for
      internal use</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$TXXX(Alternative,Alternative)</dt>
  <dd class="It-tag">expansion alternatives according to runtime type of
      operation, where XXX is some string that is matched by
      &quot;/[BSULNQFD+]/&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$PDL(a)</dt>
  <dd class="It-tag">return a pointer to the pdl data structure (pdl *) of
      piddle &quot;a&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$ISBAD(a()) (bad)</dt>
  <dd class="It-tag">returns true if the value stored in &quot;a()&quot; equals
      the bad value for this piddle. Requires &quot;HandleBad&quot; being set to
      1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$ISGOOD(a()) (bad)</dt>
  <dd class="It-tag">returns true if the value stored in &quot;a()&quot; does
      not equal the bad value for this piddle. Requires &quot;HandleBad&quot;
      being set to 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$SETBAD(a()) (bad)</dt>
  <dd class="It-tag">Sets &quot;a()&quot; to equal the bad value for this
      piddle. Requires &quot;HandleBad&quot; being set to 1.</dd>
</dl>
<h2 class="Ss" title="Ss" id="functions"><a class="selflink" href="#functions">functions</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;loop(DIMS) %{ ... %}&quot;</dt>
  <dd class="It-tag">loop over named dimensions; limits are generated
      automatically by PP</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;threadloop %{ ... %}&quot;</dt>
  <dd class="It-tag">enclose following code in a thread loop</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;types(TYPES) %{ ... %}&quot;</dt>
  <dd class="It-tag">execute following code if type of operation is any of
      &quot;TYPES&quot;</dd>
</dl>
<h1 class="Sh" title="Sh" id="Appendix_C:_Functions_imported_by_PDL::PP"><a class="selflink" href="#Appendix_C:_Functions_imported_by_PDL::PP">Appendix
  C: Functions imported by PDL::PP</a></h1>
A number of functions are imported when you &quot;use PDL::PP&quot;. These
  include functions that control the generated C or XS code, functions that
  control the generated Perl code, and functions that manipulate the packages
  and symbol tables into which the code is created.
<h2 class="Ss" title="Ss" id="Generating_C_and_XS_Code"><a class="selflink" href="#Generating_C_and_XS_Code">Generating
  C and XS Code</a></h2>
PDL::PP's main purpose is to make it easy for you to wrap the threading engine
  around your own C code, but you can do some other things, too.
<dl class="Bl-tag">
  <dt class="It-tag">pp_def</dt>
  <dd class="It-tag">Used to wrap the threading engine around your C code.
      Virtually all of this document discusses the use of pp_def.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_done</dt>
  <dd class="It-tag">Indicates you are done with PDL::PP and that it should
      generate its .xs and .pm files based upon the other pp_* functions that
      you have called. This function takes no arguments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_addxs</dt>
  <dd class="It-tag">This lets you add XS code to your .xs file. This is useful
      if you want to create Perl-accessible functions that invoke C code but
      cannot or should not invoke the threading engine. XS is the standard means
      by which you wrap Perl-accessible C code. You can learn more at
    perlxs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_add_boot</dt>
  <dd class="It-tag">This function adds whatever string you pass to the XS BOOT
      section. The BOOT section is C code that gets called by Perl when your
      module is loaded and is useful for automatic initialization. You can learn
      more about XS and the BOOT section at perlxs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_addhdr</dt>
  <dd class="It-tag">Adds pure-C code to your XS file. XS files are structured
      such that pure C code must come before XS specifications. This allows you
      to specify such C code.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_boundscheck</dt>
  <dd class="It-tag">PDL normally checks the bounds of your accesses before
      making them. You can turn that on or off at runtime by setting
      MyPackage::set_boundscheck. This function allows you to remove that
      runtime flexibility and <b>never</b> do bounds checking. It also returns
      the current boundschecking status if called without any argumens.
    <div style="height: 1.00em;">&#x00A0;</div>
    NOTE: I have not found anything about bounds checking in other
      documentation. That needs to be addressed.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Generating_Perl_Code"><a class="selflink" href="#Generating_Perl_Code">Generating
  Perl Code</a></h2>
Many functions imported when you use PDL::PP allow you to modify the contents of
  the generated .pm file. In addition to pp_def and pp_done, the role of these
  functions is primarily to add code to various parts of your generated .pm
  file.
<dl class="Bl-tag">
  <dt class="It-tag">pp_addpm</dt>
  <dd class="It-tag">Adds Perl code to the generated .pm file. PDL::PP actually
      keeps track of three different sections of generated code: the Top, the
      Middle, and the Bottom. You can add Perl code to the Middle section using
      the one-argument form, where the argument is the Perl code you want to
      supply. In the two-argument form, the first argument is an anonymous hash
      with only one key that specifies where to put the second argument, which
      is the string that you want to add to the .pm file. The hash is one of
      these three:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 {At =&gt; 'Top'}
 {At =&gt; 'Middle'}
 {At =&gt; 'Bot'}
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    For example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 pp_addpm({At =&gt; 'Bot'}, &lt;&lt;POD);
 
 =head1 Some documentation
 
 I know I'm typing this in the middle of my file, but it'll go at
 the bottom.
 
 =cut
 
 POD
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Warning: If, in the middle of your .pd file, you put documentation meant for
      the bottom of your pod, you will thoroughly confuse CPAN. On the other
      hand, if in the middle of your .pd file, you add some Perl code destined
      for the bottom or top of your .pm file, you only have yourself to confuse.
      :-)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_beginwrap</dt>
  <dd class="It-tag">Adds BEGIN-block wrapping. Certain declarations can be
      wrapped in BEGIN blocks, though the default behavior is to have no such
      wrapping.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_addbegin</dt>
  <dd class="It-tag">Sets code to be added to the top of your .pm file, even
      above code that you specify with &quot;pp_addpm({At =&gt; 'Top'},
      ...)&quot;. Unlike pp_addpm, calling this overwrites whatever was there
      before. Generally, you probably shouldn't use it.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Tracking_Line_Numbers"><a class="selflink" href="#Tracking_Line_Numbers">Tracking
  Line Numbers</a></h2>
When you get compile errors, either from your C-like code or your Perl code, it
  can help to make those errors back to the line numbers in the source file at
  which the error occurred.
<dl class="Bl-tag">
  <dt class="It-tag">pp_line_numbers</dt>
  <dd class="It-tag">Takes a line number and a (usually long) string of code.
      The line number should indicate the line at which the quote begins. This
      is usually Perl's &quot;__LINE__&quot; literal, unless you are using
      heredocs, in which case it is &quot;__LINE__ + 1&quot;. The returned
      string has #line directives interspersed to help the compiler report
      errors on the proper line.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Modifying_the_Symbol_Table_and_Export_Behavior"><a class="selflink" href="#Modifying_the_Symbol_Table_and_Export_Behavior">Modifying
  the Symbol Table and Export Behavior</a></h2>
PDL::PP usually exports all functions generated using pp_def, and usually
  installs them into the PDL symbol table. However, you can modify this behavior
  with these functions.
<dl class="Bl-tag">
  <dt class="It-tag">pp_bless</dt>
  <dd class="It-tag">Sets the package (symbol table) to which the XS code is
      added. The default is PDL, which is generally what you want. If you use
      the default blessing and you create a function myfunc, then you can do the
      following:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 $piddle-&gt;myfunc(&lt;args&gt;);
 PDL::myfunc($piddle, &lt;args&gt;);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    On the other hand, if you bless your functions into another package, you
      cannot invoke them as PDL methods, and must invoke them as:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 MyPackage::myfunc($piddle, &lt;args&gt;);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Of course, you could always use the PMFunc key to add your function to the
      PDL symbol table, but why do that?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_add_isa</dt>
  <dd class="It-tag">Adds to the list of modules from which your <b>module</b>
      inherits. The default list is
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 qw(PDL::Exporter DynaLoader)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_core_importlist</dt>
  <dd class="It-tag">At the top of your generated .pm file is a line that looks
      like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 use PDL::Core;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can modify that by specifying a string to pp_core_importlist. For
      example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 pp_core_importlist('::Blarg');
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will result in
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 use PDL::Core::Blarg;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can use this, for example, to add a list of symbols to import from
      PDL::Core. For example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 pp_core_importlist(&quot; ':Internal'&quot;);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    will lead to the following use statement:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 use PDL::Core ':Internal';
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_setversion</dt>
  <dd class="It-tag">Sets your module's version. The version must be consistent
      between the .xs and the .pm file, and is used to ensure that your Perl's
      libraries do not suffer from version skew.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_add_exported</dt>
  <dd class="It-tag">Adds to the export list whatever names you give it.
      Functions created using pp_def are automatically added to the list. This
      function is useful if you define any Perl functions using pp_addpm or
      pp_addxs that you want exported as well.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pp_export_nothing</dt>
  <dd class="It-tag">This resets the list of exported symbols to nothing. This
      is probably better called &quot;pp_export_clear&quot;, since you can add
      exported symbols after calling &quot;pp_export_nothing&quot;. When called
      just before calling pp_done, this ensures that your module does not export
      anything, for example, if you only want programmers to use your functions
      as methods.</dd>
</dl>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>PDL</i>
<div class="Pp"></div>
For the concepts of threading and slicing check PDL::Indexing.
<div class="Pp"></div>
PDL::Internals
<div class="Pp"></div>
PDL::BadValues for information on bad values
<div class="Pp"></div>
<i>perlxs</i>, <i>perlxstut</i>
<h1 class="Sh" title="Sh" id="CURRENTLY_UNDOCUMENTED"><a class="selflink" href="#CURRENTLY_UNDOCUMENTED">CURRENTLY
  UNDOCUMENTED</a></h1>
Almost everything having to do with &quot;Slice operation&quot;. This includes
  much of the following (each entry is followed by a guess/description of where
  it is used or defined):
<dl class="Bl-tag">
  <dt class="It-tag">MACROS</dt>
  <dd class="It-tag">$<i>CDIM()</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>CHILD()</i>
    <br/>
     PDL::PP::Rule::Substitute::Usual
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>CHILD_P()</i>
    <br/>
     PDL::PP::Rule::Substitute::Usual
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>CHILD_PTR()</i>
    <br/>
     PDL::PP::Rule::Substitute::Usual
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>COPYDIMS()</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>COPYINDS()</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>CROAK()</i>
    <br/>
     <i>PDL::PP::Rule::Substitute::dosubst_private()</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>DOCOMPDIMS()</i>
    <br/>
     Used in slices.pd, defined where?
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>DOPRIVDIMS()</i>
    <br/>
     Used in slices.pd, defined where?
    <br/>
     Code comes from PDL::PP::CType::get_malloc, which is called by
      PDL::PP::CType::get_copy, which is called by PDL::PP::CopyOtherPars,
      PDL::PP::NT2Copies__, and PDL::PP::make_incsize_copy. But none of those
      three at first glance seem to have anything to do with $DOPRIVDIMS
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>EQUIVCPOFFS()</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>EQUIVCPTRUNC()</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>PARENT()</i>
    <br/>
     PDL::PP::Rule::Substitute::Usual
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>PARENT_P()</i>
    <br/>
     PDL::PP::Rule::Substitute::Usual
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>PARENT_PTR()</i>
    <br/>
     PDL::PP::Rule::Substitute::Usual
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>PDIM()</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>PRIV()</i>
    <br/>
     <i>PDL::PP::Rule::Substitute::dosubst_private()</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>RESIZE()</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>SETDELTATHREADIDS()</i>
    <br/>
     PDL::PP::Rule::MakeComp
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>SETDIMS()</i>
    <br/>
     PDL::PP::Rule::MakeComp
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>SETNDIMS()</i>
    <br/>
     PDL::PP::Rule::MakeComp
    <div style="height: 1.00em;">&#x00A0;</div>
    $ <i>SETREVERSIBLE()</i>
    <br/>
     <i>PDL::PP::Rule::Substitute::dosubst_private()</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Keys</dt>
  <dd class="It-tag">AffinePriv
    <div style="height: 1.00em;">&#x00A0;</div>
    BackCode
    <div style="height: 1.00em;">&#x00A0;</div>
    BadBackCode
    <div style="height: 1.00em;">&#x00A0;</div>
    CallCopy
    <div style="height: 1.00em;">&#x00A0;</div>
    Comp (related to $ <i>COMP()</i>?)
    <div style="height: 1.00em;">&#x00A0;</div>
    DefaultFlow
    <div style="height: 1.00em;">&#x00A0;</div>
    EquivCDimExpr
    <div style="height: 1.00em;">&#x00A0;</div>
    EquivCPOffsCode
    <div style="height: 1.00em;">&#x00A0;</div>
    EquivDimCheck
    <div style="height: 1.00em;">&#x00A0;</div>
    EquivPDimExpr
    <div style="height: 1.00em;">&#x00A0;</div>
    FTypes (see comment in this POD's source file between NoPthread and PMCode.)
    <div style="height: 1.00em;">&#x00A0;</div>
    GlobalNew
    <div style="height: 1.00em;">&#x00A0;</div>
    Identity
    <div style="height: 1.00em;">&#x00A0;</div>
    MakeComp
    <div style="height: 1.00em;">&#x00A0;</div>
    NoPdlThread
    <div style="height: 1.00em;">&#x00A0;</div>
    P2Child
    <div style="height: 1.00em;">&#x00A0;</div>
    ParentInds
    <div style="height: 1.00em;">&#x00A0;</div>
    Priv
    <div style="height: 1.00em;">&#x00A0;</div>
    ReadDataFuncName
    <div style="height: 1.00em;">&#x00A0;</div>
    RedoDims (related to RedoDimsCode ?)
    <div style="height: 1.00em;">&#x00A0;</div>
    Reversible
    <div style="height: 1.00em;">&#x00A0;</div>
    WriteBckDataFuncName
    <div style="height: 1.00em;">&#x00A0;</div>
    XCHGOnly</dd>
</dl>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
Although PDL::PP is quite flexible and thoroughly used, there are surely bugs.
  First amongst them: this documentation needs a thorough revision.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Copyright(C) 1997 Tuomas J. Lukka (lukka@fas.harvard.edu), Karl Glaazebrook
  (kgb@aaocbn1.aao.GOV.AU) and Christian Soeller (c.soeller@auckland.ac.nz). All
  rights reserved. Documentation updates Copyright(C) 2011 David Mertens
  (dcmertens.perl@gmail.com). This documentation is licensed under the same
  terms as Perl itself.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-05-18</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
