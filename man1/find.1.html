<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:09:58 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>FIND(1) General Commands Manual FIND(1)</p>

<p style="margin-top: 1em">NAME <br>
find - search for files in a directory hierarchy</p>

<p style="margin-top: 1em">SYNOPSIS <br>
find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...]
[expression]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This manual page documents the GNU version of find. GNU find
searches the directory tree rooted at each given file name
by evaluating the given expression from left to right, <br>
according to the rules of precedence (see section
OPERATORS), until the outcome is known (the left hand side
is false for and operations, true for or), at which point
find moves <br>
on to the next file name.</p>

<p style="margin-top: 1em">If you are using find in an
environment where security is important (for example if you
are using it to search directories that are writable by
other users), you should read the <br>
&quot;Security Considerations&quot; chapter of the findutils
documentation, which is called Finding Files and comes with
findutils. That document also includes a lot more detail and
dis&acirc; <br>
cussion than this manual page, so you may find it a more
useful source of information.</p>

<p style="margin-top: 1em">OPTIONS <br>
The -H, -L and -P options control the treatment of symbolic
links. Command-line arguments following these are taken to
be names of files or directories to be examined, up to the
<br>
first argument that begins with &lsquo;-&rsquo;, or the
argument &lsquo;(&rsquo; or &lsquo;!&rsquo;. That argument
and any following arguments are taken to be the expression
describing what is to be searched for. <br>
If no paths are given, the current directory is used. If no
expression is given, the expression -print is used (but you
should probably consider using -print0 instead, anyway).</p>

<p style="margin-top: 1em">This manual page talks about
&lsquo;options&rsquo; within the expression list. These
options control the behaviour of find but are specified
immediately after the last path name. The five <br>
&lsquo;real&rsquo; options -H, -L, -P, -D and -O must appear
before the first path name, if at all. A double dash -- can
also be used to signal that any remaining arguments are not
options <br>
(though ensuring that all start points begin with either
&lsquo;./&rsquo; or &lsquo;/&rsquo; is generally safer if
you use wildcards in the list of start points).</p>

<p style="margin-top: 1em">-P Never follow symbolic links.
This is the default behaviour. When find examines or prints
information a file, and the file is a symbolic link, the
information used shall <br>
be taken from the properties of the symbolic link
itself.</p>

<p style="margin-top: 1em">-L Follow symbolic links. When
find examines or prints information about files, the
information used shall be taken from the properties of the
file to which the link points, <br>
not from the link itself (unless it is a broken symbolic
link or find is unable to examine the file to which the link
points). Use of this option implies -noleaf. If you <br>
later use the -P option, -noleaf will still be in effect. If
-L is in effect and find discovers a symbolic link to a
subdirectory during its search, the subdirectory <br>
pointed to by the symbolic link will be searched.</p>

<p style="margin-top: 1em">When the -L option is in effect,
the -type predicate will always match against the type of
the file that a symbolic link points to rather than the link
itself (unless the <br>
symbolic link is broken). Using -L causes the -lname and
-ilname predicates always to return false.</p>

<p style="margin-top: 1em">-H Do not follow symbolic links,
except while processing the command line arguments. When
find examines or prints information about files, the
information used shall be <br>
taken from the properties of the symbolic link itself. The
only exception to this behaviour is when a file specified on
the command line is a symbolic link, and the link <br>
can be resolved. For that situation, the information used is
taken from whatever the link points to (that is, the link is
followed). The information about the link <br>
itself is used as a fallback if the file pointed to by the
symbolic link cannot be examined. If -H is in effect and one
of the paths specified on the command line is a <br>
symbolic link to a directory, the contents of that directory
will be examined (though of course -maxdepth 0 would prevent
this).</p>

<p style="margin-top: 1em">If more than one of -H, -L and
-P is specified, each overrides the others; the last one
appearing on the command line takes effect. Since it is the
default, the -P option should <br>
be considered to be in effect unless either -H or -L is
specified.</p>

<p style="margin-top: 1em">GNU find frequently stats files
during the processing of the command line itself, before any
searching has begun. These options also affect how those
arguments are processed. <br>
Specifically, there are a number of tests that compare files
listed on the command line against a file we are currently
considering. In each case, the file specified on the
com&acirc; <br>
mand line will have been examined and some of its properties
will have been saved. If the named file is in fact a
symbolic link, and the -P option is in effect (or if neither
-H <br>
nor -L were specified), the information used for the
comparison will be taken from the properties of the symbolic
link. Otherwise, it will be taken from the properties of the
<br>
file the link points to. If find cannot follow the link (for
example because it has insufficient privileges or the link
points to a nonexistent file) the properties of the link
<br>
itself will be used.</p>

<p style="margin-top: 1em">When the -H or -L options are in
effect, any symbolic links listed as the argument of -newer
will be dereferenced, and the timestamp will be taken from
the file to which the sym&acirc; <br>
bolic link points. The same consideration applies to
-newerXY, -anewer and -cnewer.</p>

<p style="margin-top: 1em">The -follow option has a similar
effect to -L, though it takes effect at the point where it
appears (that is, if -L is not used but -follow is, any
symbolic links appearing after <br>
-follow on the command line will be dereferenced, and those
before it will not).</p>

<p style="margin-top: 1em">-D debugoptions <br>
Print diagnostic information; this can be helpful to
diagnose problems with why find is not doing what you want.
The list of debug options should be comma separated. <br>
Compatibility of the debug options is not guaranteed between
releases of findutils. For a complete list of valid debug
options, see the output of find -D help. Valid <br>
debug options include</p>

<p style="margin-top: 1em">help Explain the debugging
options</p>

<p style="margin-top: 1em">tree Show the expression tree in
its original and optimised form.</p>

<p style="margin-top: 1em">stat Print messages as files are
examined with the stat and lstat system calls. The find
program tries to minimise such calls.</p>

<p style="margin-top: 1em">opt Prints diagnostic
information relating to the optimisation of the expression
tree; see the -O option.</p>

<p style="margin-top: 1em">rates Prints a summary
indicating how often each predicate succeeded or failed.</p>

<p style="margin-top: 1em">-Olevel <br>
Enables query optimisation. The find program reorders tests
to speed up execution while preserving the overall effect;
that is, predicates with side effects are not <br>
reordered relative to each other. The optimisations
performed at each optimisation level are as follows.</p>

<p style="margin-top: 1em">0 Equivalent to optimisation
level 1.</p>

<p style="margin-top: 1em">1 This is the default
optimisation level and corresponds to the traditional
behaviour. Expressions are reordered so that tests based
only on the names of files (for <br>
example -name and -regex) are performed first.</p>

<p style="margin-top: 1em">2 Any -type or -xtype tests are
performed after any tests based only on the names of files,
but before any tests that require information from the
inode. On many <br>
modern versions of Unix, file types are returned by
readdir() and so these predicates are faster to evaluate
than predicates which need to stat the file first. If <br>
you use the -fstype FOO predicate and specify a filsystem
type FOO which is not known (that is, present in
&lsquo;/etc/mtab&rsquo;) at the time find starts, that
predicate is <br>
equivalent to -false.</p>

<p style="margin-top: 1em">3 At this optimisation level,
the full cost-based query optimiser is enabled. The order of
tests is modified so that cheap (i.e. fast) tests are
performed first and <br>
more expensive ones are performed later, if necessary.
Within each cost band, predicates are evaluated earlier or
later according to whether they are likely to <br>
succeed or not. For -o, predicates which are likely to
succeed are evaluated earlier, and for -a, predicates which
are likely to fail are evaluated earlier.</p>

<p style="margin-top: 1em">The cost-based optimiser has a
fixed idea of how likely any given test is to succeed. In
some cases the probability takes account of the specific
nature of the test (for <br>
example, -type f is assumed to be more likely to succeed
than -type c). The cost-based optimiser is currently being
evaluated. If it does not actually improve the per&acirc;
<br>
formance of find, it will be removed again. Conversely,
optimisations that prove to be reliable, robust and
effective may be enabled at lower optimisation levels over
<br>
time. However, the default behaviour (i.e. optimisation
level 1) will not be changed in the 4.3.x release series.
The findutils test suite runs all the tests on find at <br>
each optimisation level and ensures that the result is the
same.</p>

<p style="margin-top: 1em">EXPRESSIONS <br>
The expression is made up of options (which affect overall
operation rather than the processing of a specific file, and
always return true), tests (which return a true or false
<br>
value), and actions (which have side effects and return a
true or false value), all separated by operators. -and is
assumed where the operator is omitted.</p>

<p style="margin-top: 1em">If the expression contains no
actions other than -prune, -print is performed on all files
for which the expression is true.</p>

<p style="margin-top: 1em">OPTIONS <br>
All options always return true. Except for -daystart,
-follow and -regextype, the options affect all tests,
including tests specified before the option. This is because
the <br>
options are processed when the command line is parsed, while
the tests don&rsquo;t do anything until files are examined.
The -daystart, -follow and -regextype options are different
in <br>
this respect, and have an effect only on tests which appear
later in the command line. Therefore, for clarity, it is
best to place them at the beginning of the expression. A
<br>
warning is issued if you don&rsquo;t do this.</p>

<p style="margin-top: 1em">-d A synonym for -depth, for
compatibility with FreeBSD, NetBSD, MacOS X and OpenBSD.</p>

<p style="margin-top: 1em">-daystart <br>
Measure times (for -amin, -atime, -cmin, -ctime, -mmin, and
-mtime) from the beginning of today rather than from 24
hours ago. This option only affects tests which appear <br>
later on the command line.</p>

<p style="margin-top: 1em">-depth Process each
directory&rsquo;s contents before the directory itself. The
-delete action also implies -depth.</p>

<p style="margin-top: 1em">-follow <br>
Deprecated; use the -L option instead. Dereference symbolic
links. Implies -noleaf. The -follow option affects only
those tests which appear after it on the command <br>
line. Unless the -H or -L option has been specified, the
position of the -follow option changes the behaviour of the
-newer predicate; any files listed as the argument of <br>
-newer will be dereferenced if they are symbolic links. The
same consideration applies to -newerXY, -anewer and -cnewer.
Similarly, the -type predicate will always match <br>
against the type of the file that a symbolic link points to
rather than the link itself. Using -follow causes the -lname
and -ilname predicates always to return false.</p>

<p style="margin-top: 1em">-help, --help <br>
Print a summary of the command-line usage of find and
exit.</p>

<p style="margin-top: 1em">-ignore_readdir_race <br>
Normally, find will emit an error message when it fails to
stat a file. If you give this option and a file is deleted
between the time find reads the name of the file <br>
from the directory and the time it tries to stat the file,
no error message will be issued. This also applies to files
or directories whose names are given on the com&acirc; <br>
mand line. This option takes effect at the time the command
line is read, which means that you cannot search one part of
the filesystem with this option on and part of it <br>
with this option off (if you need to do that, you will need
to issue two find commands instead, one with the option and
one without it).</p>

<p style="margin-top: 1em">-maxdepth levels <br>
Descend at most levels (a non-negative integer) levels of
directories below the command line arguments. -maxdepth 0
<br>
means only apply the tests and actions to the command line
arguments.</p>

<p style="margin-top: 1em">-mindepth levels <br>
Do not apply any tests or actions at levels less than levels
(a non-negative integer). -mindepth 1 means process all
files except the command line arguments.</p>

<p style="margin-top: 1em">-mount Don&rsquo;t descend
directories on other filesystems. An alternate name for
-xdev, for compatibility with some other versions of
find.</p>

<p style="margin-top: 1em">-noignore_readdir_race <br>
Turns off the effect of -ignore_readdir_race.</p>

<p style="margin-top: 1em">-noleaf <br>
Do not optimize by assuming that directories contain 2 fewer
subdirectories than their hard link count. This option is
needed when searching filesystems that do not fol&acirc;
<br>
low the Unix directory-link convention, such as CD-ROM or
MS-DOS filesystems or AFS volume mount points. Each
directory on a normal Unix filesystem has at least 2 hard
<br>
links: its name and its &lsquo;.&rsquo; entry. Additionally,
its subdirectories (if any) each have a &lsquo;..&rsquo;
entry linked to that directory. When find is examining a
directory, after <br>
it has statted 2 fewer subdirectories than the
directory&rsquo;s link count, it knows that the rest of the
entries in the directory are non-directories
(&lsquo;leaf&rsquo; files in the <br>
directory tree). If only the files&rsquo; names need to be
examined, there is no need to stat them; this gives a
significant increase in search speed.</p>

<p style="margin-top: 1em">-regextype type <br>
Changes the regular expression syntax understood by -regex
and -iregex tests which occur later on the command line.
Currently-implemented types are emacs (this is the <br>
default), posix-awk, posix-basic, posix-egrep and
posix-extended.</p>

<p style="margin-top: 1em">-version, --version <br>
Print the find version number and exit.</p>

<p style="margin-top: 1em">-warn, -nowarn <br>
Turn warning messages on or off. These warnings apply only
to the command line usage, not to any conditions that find
might encounter when it searches directories. The <br>
default behaviour corresponds to -warn if standard input is
a tty, and to -nowarn otherwise.</p>

<p style="margin-top: 1em">-xautofs <br>
Don&rsquo;t descend directories on autofs filesystems.</p>

<p style="margin-top: 1em">-xdev Don&rsquo;t descend
directories on other filesystems.</p>

<p style="margin-top: 1em">TESTS <br>
Some tests, for example -newerXY and -samefile, allow
comparison between the file currently being examined and
some reference file specified on the command line. When
these <br>
tests are used, the interpretation of the reference file is
determined by the options -H, -L and -P and any previous
-follow, but the reference file is only examined once, at
the <br>
time the command line is parsed. If the reference file
cannot be examined (for example, the stat(2) system call
fails for it), an error message is issued, and find exits
with a <br>
nonzero status.</p>

<p style="margin-top: 1em">Numeric arguments can be
specified as</p>

<p style="margin-top: 1em">+n for greater than n,</p>

<p style="margin-top: 1em">-n for less than n,</p>

<p style="margin-top: 1em">n for exactly n.</p>

<p style="margin-top: 1em">-amin n <br>
File was last accessed n minutes ago.</p>

<p style="margin-top: 1em">-anewer file <br>
File was last accessed more recently than file was modified.
If file is a symbolic link and the -H option or the -L
option is in effect, the access time of the file it <br>
points to is always used.</p>

<p style="margin-top: 1em">-atime n <br>
File was last accessed n*24 hours ago. When find figures out
how many 24-hour periods ago the file was last accessed, any
fractional part is ignored, so to match -atime <br>
+1, a file has to have been accessed at least two days
ago.</p>

<p style="margin-top: 1em">-cmin n <br>
File&rsquo;s status was last changed n minutes ago.</p>

<p style="margin-top: 1em">-cnewer file <br>
File&rsquo;s status was last changed more recently than file
was modified. If file is a symbolic link and the -H option
or the -L option is in effect, the status-change time of
<br>
the file it points to is always used.</p>

<p style="margin-top: 1em">-ctime n <br>
File&rsquo;s status was last changed n*24 hours ago. See the
comments for -atime to understand how rounding affects the
interpretation of file status change times.</p>

<p style="margin-top: 1em">-empty File is empty and is
either a regular file or a directory.</p>

<p style="margin-top: 1em">-executable <br>
Matches files which are executable and directories which are
searchable (in a file name resolution sense). This takes
into account access control lists and other permis&acirc;
<br>
sions artefacts which the -perm test ignores. This test
makes use of the access(2) system call, and so can be fooled
by NFS servers which do UID mapping (or root-squash&acirc;
<br>
ing), since many systems implement access(2) in the
client&rsquo;s kernel and so cannot make use of the UID
mapping information held on the server. Because this test is
based <br>
only on the result of the access(2) system call, there is no
guarantee that a file for which this test succeeds can
actually be executed.</p>

<p style="margin-top: 1em">-false Always false.</p>

<p style="margin-top: 1em">-fstype type <br>
File is on a filesystem of type type. The valid filesystem
types vary among different versions of Unix; an incomplete
list of filesystem types that are accepted on some <br>
version of Unix or another is: ufs, 4.2, 4.3, nfs, tmp, mfs,
S51K, S52K. You can use -printf with the %F directive to see
the types of your filesystems.</p>

<p style="margin-top: 1em">-gid n File&rsquo;s numeric
group ID is n.</p>

<p style="margin-top: 1em">-group gname <br>
File belongs to group gname (numeric group ID allowed).</p>

<p style="margin-top: 1em">-ilname pattern <br>
Like -lname, but the match is case insensitive. If the -L
option or the -follow option is in effect, this test returns
false unless the symbolic link is broken.</p>

<p style="margin-top: 1em">-iname pattern <br>
Like -name, but the match is case insensitive. For example,
the patterns &lsquo;fo*&rsquo; and &lsquo;F??&rsquo; match
the file names &lsquo;Foo&rsquo;, &lsquo;FOO&rsquo;,
&lsquo;foo&rsquo;, &lsquo;fOo&rsquo;, etc. The pattern
&lsquo;*foo*&lsquo; will <br>
also match a file called &rsquo;.foobar&rsquo;.</p>

<p style="margin-top: 1em">-inum n <br>
File has inode number n. It is normally easier to use the
-samefile test instead.</p>

<p style="margin-top: 1em">-ipath pattern <br>
Like -path. but the match is case insensitive.</p>

<p style="margin-top: 1em">-iregex pattern <br>
Like -regex, but the match is case insensitive.</p>

<p style="margin-top: 1em">-iwholename pattern <br>
See -ipath. This alternative is less portable than
-ipath.</p>

<p style="margin-top: 1em">-links n <br>
File has n links.</p>

<p style="margin-top: 1em">-lname pattern <br>
File is a symbolic link whose contents match shell pattern
pattern. The metacharacters do not treat &lsquo;/&rsquo; or
&lsquo;.&rsquo; specially. If the -L option or the -follow
option is in <br>
effect, this test returns false unless the symbolic link is
broken.</p>

<p style="margin-top: 1em">-mmin n <br>
File&rsquo;s data was last modified n minutes ago.</p>

<p style="margin-top: 1em">-mtime n <br>
File&rsquo;s data was last modified n*24 hours ago. See the
comments for -atime to understand how rounding affects the
interpretation of file modification times.</p>

<p style="margin-top: 1em">-name pattern <br>
Base of file name (the path with the leading directories
removed) matches shell pattern pattern. Because the leading
directories are removed, the file names considered <br>
for a match with -name will never include a slash, so
&lsquo;-name a/b&rsquo; will never match anything (you
probably need to use -path instead). The metacharacters
(&lsquo;*&rsquo;, &lsquo;?&rsquo;, and <br>
&lsquo;[]&rsquo;) match a &lsquo;.&rsquo; at the start of
the base name (this is a change in findutils-4.2.2; see
section STANDARDS CONFORMANCE below). To ignore a directory
and the files under <br>
it, use -prune; see an example in the description of -path.
Braces are not recognised as being special, despite the fact
that some shells including Bash imbue braces with <br>
a special meaning in shell patterns. The filename matching
is performed with the use of the fnmatch(3) library
function. Don&rsquo;t forget to enclose the pattern in
quotes <br>
in order to protect it from expansion by the shell.</p>

<p style="margin-top: 1em">-newer file <br>
File was modified more recently than file. If file is a
symbolic link and the -H option or the -L option is in
effect, the modification time of the file it points to is
<br>
always used.</p>

<p style="margin-top: 1em">-newerXY reference <br>
Compares the timestamp of the current file with reference.
The reference argument is normally the name of a file (and
one of its timestamps is used for the comparison) <br>
but it may also be a string describing an absolute time. X
and Y are placeholders for other letters, and these letters
select which time belonging to how reference is <br>
used for the comparison.</p>

<p style="margin-top: 1em">a The access time of the file
reference <br>
B The birth time of the file reference <br>
c The inode status change time of reference <br>
m The modification time of the file reference <br>
t reference is interpreted directly as a time</p>

<p style="margin-top: 1em">Some combinations are invalid;
for example, it is invalid for X to be t. Some combinations
are not implemented on all systems; for example B is not
supported on all sys&acirc; <br>
tems. If an invalid or unsupported combination of XY is
specified, a fatal error results. Time specifications are
interpreted as for the argument to the -d option of GNU <br>
date. If you try to use the birth time of a reference file,
and the birth time cannot be determined, a fatal error
message results. If you specify a test which refers to <br>
the birth time of files being examined, this test will fail
for any files where the birth time is unknown.</p>

<p style="margin-top: 1em">-nogroup <br>
No group corresponds to file&rsquo;s numeric group ID.</p>

<p style="margin-top: 1em">-nouser <br>
No user corresponds to file&rsquo;s numeric user ID.</p>

<p style="margin-top: 1em">-path pattern <br>
File name matches shell pattern pattern. The metacharacters
do not treat &lsquo;/&rsquo; or &lsquo;.&rsquo; specially;
so, for example, <br>
find . -path &quot;./sr*sc&quot; <br>
will print an entry for a directory called
&lsquo;./src/misc&rsquo; (if one exists). To ignore a whole
directory tree, use -prune rather than checking every file
in the tree. For <br>
example, to skip the directory &lsquo;src/emacs&rsquo; and
all files and directories under it, and print the names of
the other files found, do something like this: <br>
find . -path ./src/emacs -prune -o -print <br>
Note that the pattern match test applies to the whole file
name, starting from one of the start points named on the
command line. It would only make sense to use an abso&acirc;
<br>
lute path name here if the relevant start point is also an
absolute path. This means that this command will never match
anything: <br>
find bar -path /foo/bar/myfile -print <br>
Find compares the -path argument with the concatenation of a
directory name and the base name of the file it&rsquo;s
examining. Since the concatenation will never end with a
<br>
slash, -path arguments ending in a slash will match nothing
(except perhaps a start point specified on the command
line). The predicate -path is also supported by HP-UX <br>
find and will be in a forthcoming version of the POSIX
standard.</p>

<p style="margin-top: 1em">-perm mode <br>
File&rsquo;s permission bits are exactly mode (octal or
symbolic). Since an exact match is required, if you want to
use this form for symbolic modes, you may have to specify a
<br>
rather complex mode string. For example &lsquo;-perm
g=w&rsquo; will only match files which have mode 0020 (that
is, ones for which group write permission is the only
permission <br>
set). It is more likely that you will want to use the
&lsquo;/&rsquo; or &lsquo;-&rsquo; forms, for example
&lsquo;-perm -g=w&rsquo;, which matches any file with group
write permission. See the EXAMPLES <br>
section for some illustrative examples.</p>

<p style="margin-top: 1em">-perm -mode <br>
All of the permission bits mode are set for the file.
Symbolic modes are accepted in this form, and this is
usually the way in which would want to use them. You must
<br>
specify &lsquo;u&rsquo;, &lsquo;g&rsquo; or &lsquo;o&rsquo;
if you use a symbolic mode. See the EXAMPLES section for
some illustrative examples.</p>

<p style="margin-top: 1em">-perm /mode <br>
Any of the permission bits mode are set for the file.
Symbolic modes are accepted in this form. You must specify
&lsquo;u&rsquo;, &lsquo;g&rsquo; or &lsquo;o&rsquo; if you
use a symbolic mode. See the <br>
EXAMPLES section for some illustrative examples. If no
permission bits in mode are set, this test matches any file
(the idea here is to be consistent with the behaviour <br>
of -perm -000).</p>

<p style="margin-top: 1em">-perm +mode <br>
Deprecated, old way of searching for files with any of the
permission bits in mode set. You should use -perm /mode
instead. Trying to use the &lsquo;+&rsquo; syntax with
symbolic <br>
modes will yield surprising results. For example,
&lsquo;+u+x&rsquo; is a valid symbolic mode (equivalent to
+u,+x, i.e. 0111) and will therefore not be evaluated as
-perm +mode but <br>
instead as the exact mode specifier -perm mode and so it
matches files with exact permissions 0111 instead of files
with any execute bit set. If you found this paragraph <br>
confusing, you&rsquo;re not alone - just use -perm /mode.
This form of the -perm test is deprecated because the POSIX
specification requires the interpretation of a leading
&lsquo;+&rsquo; <br>
as being part of a symbolic mode, and so we switched to
using &lsquo;/&rsquo; instead.</p>

<p style="margin-top: 1em">-readable <br>
Matches files which are readable. This takes into account
access control lists and other permissions artefacts which
the -perm test ignores. This test makes use of the <br>
access(2) system call, and so can be fooled by NFS servers
which do UID mapping (or root-squashing), since many systems
implement access(2) in the client&rsquo;s kernel and so <br>
cannot make use of the UID mapping information held on the
server.</p>

<p style="margin-top: 1em">-regex pattern <br>
File name matches regular expression pattern. This is a
match on the whole path, not a search. For example, to match
a file named &lsquo;./fubar3&rsquo;, you can use the regular
<br>
expression &lsquo;.*bar.&rsquo; or &lsquo;.*b.*3&rsquo;, but
not &lsquo;f.*r3&rsquo;. The regular expressions understood
by find are by default Emacs Regular Expressions, but this
can be changed with the <br>
-regextype option.</p>

<p style="margin-top: 1em">-samefile name <br>
File refers to the same inode as name. When -L is in effect,
this can include symbolic links.</p>

<p style="margin-top: 1em">-size n[cwbkMG] <br>
File uses n units of space. The following suffixes can be
used:</p>

<p style="margin-top: 1em">&lsquo;b&rsquo; for 512-byte
blocks (this is the default if no suffix is used)</p>

<p style="margin-top: 1em">&lsquo;c&rsquo; for bytes</p>

<p style="margin-top: 1em">&lsquo;w&rsquo; for two-byte
words</p>

<p style="margin-top: 1em">&lsquo;k&rsquo; for Kilobytes
(units of 1024 bytes)</p>

<p style="margin-top: 1em">&lsquo;M&rsquo; for Megabytes
(units of 1048576 bytes)</p>

<p style="margin-top: 1em">&lsquo;G&rsquo; for Gigabytes
(units of 1073741824 bytes)</p>

<p style="margin-top: 1em">The size does not count indirect
blocks, but it does count blocks in sparse files that are
not actually allocated. Bear in mind that the
&lsquo;%k&rsquo; and &lsquo;%b&rsquo; format specifiers <br>
of -printf handle sparse files differently. The
&lsquo;b&rsquo; suffix always denotes 512-byte blocks and
never 1 Kilobyte blocks, which is different to the behaviour
of -ls.</p>

<p style="margin-top: 1em">-true Always true.</p>

<p style="margin-top: 1em">-type c <br>
File is of type c:</p>

<p style="margin-top: 1em">b block (buffered) special</p>

<p style="margin-top: 1em">c character (unbuffered)
special</p>

<p style="margin-top: 1em">d directory</p>

<p style="margin-top: 1em">p named pipe (FIFO)</p>

<p style="margin-top: 1em">f regular file</p>

<p style="margin-top: 1em">l symbolic link; this is never
true if the -L option or the -follow option is in effect,
unless the symbolic link is broken. If you want to search
for symbolic links <br>
when -L is in effect, use -xtype.</p>

<p style="margin-top: 1em">s socket</p>

<p style="margin-top: 1em">D door (Solaris)</p>

<p style="margin-top: 1em">-uid n File&rsquo;s numeric user
ID is n.</p>

<p style="margin-top: 1em">-used n <br>
File was last accessed n days after its status was last
changed.</p>

<p style="margin-top: 1em">-user uname <br>
File is owned by user uname (numeric user ID allowed).</p>

<p style="margin-top: 1em">-wholename pattern <br>
See -path. This alternative is less portable than -path.</p>

<p style="margin-top: 1em">-writable <br>
Matches files which are writable. This takes into account
access control lists and other permissions artefacts which
the -perm test ignores. This test makes use of the <br>
access(2) system call, and so can be fooled by NFS servers
which do UID mapping (or root-squashing), since many systems
implement access(2) in the client&rsquo;s kernel and so <br>
cannot make use of the UID mapping information held on the
server.</p>

<p style="margin-top: 1em">-xtype c <br>
The same as -type unless the file is a symbolic link. For
symbolic links: if the -H or -P option was specified, true
if the file is a link to a file of type c; if the -L <br>
option has been given, true if c is &lsquo;l&rsquo;. In
other words, for symbolic links, -xtype checks the type of
the file that -type does not check.</p>

<p style="margin-top: 1em">-context pattern <br>
(SELinux only) Security context of the file matches glob
pattern.</p>

<p style="margin-top: 1em">ACTIONS <br>
-delete <br>
Delete files; true if removal succeeded. If the removal
failed, an error message is issued. If -delete fails,
find&rsquo;s exit status will be nonzero (when it eventually
<br>
exits). Use of -delete automatically turns on the
&lsquo;-depth&rsquo; option.</p>

<p style="margin-top: 1em">Warnings: Don&rsquo;t forget
that the find command line is evaluated as an expression, so
putting -delete first will make find try to delete
everything below the starting points <br>
you specified. When testing a find command line that you
later intend to use with -delete, you should explicitly
specify -depth in order to avoid later surprises. <br>
Because -delete implies -depth, you cannot usefully use
-prune and -delete together.</p>

<p style="margin-top: 1em">-exec command ; <br>
Execute command; true if 0 status is returned. All following
arguments to find are taken to be arguments to the command
until an argument consisting of &lsquo;;&rsquo; is
encoun&acirc; <br>
tered. The string &lsquo;{}&rsquo; is replaced by the
current file name being processed everywhere it occurs in
the arguments to the command, not just in arguments where it
is alone, <br>
as in some versions of find. Both of these constructions
might need to be escaped (with a &lsquo;&acute;) or quoted
to protect them from expansion by the shell. See the
EXAMPLES <br>
section for examples of the use of the -exec option. The
specified command is run once for each matched file. The
command is executed in the starting directory. There <br>
are unavoidable security problems surrounding use of the
-exec action; you should use the -execdir option
instead.</p>

<p style="margin-top: 1em">-exec command {} + <br>
This variant of the -exec action runs the specified command
on the selected files, but the command line is built by
appending each selected file name at the end; the total <br>
number of invocations of the command will be much less than
the number of matched files. The command line is built in
much the same way that xargs builds its command <br>
lines. Only one instance of &lsquo;{}&rsquo; is allowed
within the command. The command is executed in the starting
directory.</p>

<p style="margin-top: 1em">-execdir command ;</p>

<p style="margin-top: 1em">-execdir command {} + <br>
Like -exec, but the specified command is run from the
subdirectory containing the matched file, which is not
normally the directory in which you started find. This a
much <br>
more secure method for invoking commands, as it avoids race
conditions during resolution of the paths to the matched
files. As with the -exec action, the &lsquo;+&rsquo; form of
<br>
-execdir will build a command line to process more than one
matched file, but any given invocation of command will only
list files that exist in the same subdirectory. If <br>
you use this option, you must ensure that your $PATH
environment variable does not reference &lsquo;.&rsquo;;
otherwise, an attacker can run any commands they like by
leaving an <br>
appropriately-named file in a directory in which you will
run -execdir. The same applies to having entries in $PATH
which are empty or which are not absolute directory <br>
names.</p>

<p style="margin-top: 1em">-fls file <br>
True; like -ls but write to file like -fprint. The output
file is always created, even if the predicate is never
matched. See the UNUSUAL FILENAMES section for
informa&acirc; <br>
tion about how unusual characters in filenames are
handled.</p>

<p style="margin-top: 1em">-fprint file <br>
True; print the full file name into file file. If file does
not exist when find is run, it is created; if it does exist,
it is truncated. The file names &lsquo;/dev/stdout&rsquo;
<br>
and &lsquo;/dev/stderr&rsquo; are handled specially; they
refer to the standard output and standard error output,
respectively. The output file is always created, even if the
predi&acirc; <br>
cate is never matched. See the UNUSUAL FILENAMES section for
information about how unusual characters in filenames are
handled.</p>

<p style="margin-top: 1em">-fprint0 file <br>
True; like -print0 but write to file like -fprint. The
output file is always created, even if the predicate is
never matched. See the UNUSUAL FILENAMES section for <br>
information about how unusual characters in filenames are
handled.</p>

<p style="margin-top: 1em">-fprintf file format <br>
True; like -printf but write to file like -fprint. The
output file is always created, even if the predicate is
never matched. See the UNUSUAL FILENAMES section for <br>
information about how unusual characters in filenames are
handled.</p>

<p style="margin-top: 1em">-ls True; list current file in
ls -dils format on standard output. The block counts are of
1K blocks, unless the environment variable POSIXLY_CORRECT
is set, in which case <br>
512-byte blocks are used. See the UNUSUAL FILENAMES section
for information about how unusual characters in filenames
are handled.</p>

<p style="margin-top: 1em">-ok command ; <br>
Like -exec but ask the user first. If the user agrees, run
the command. Otherwise just return false. If the command is
run, its standard input is redirected from <br>
/dev/null.</p>

<p style="margin-top: 1em">The response to the prompt is
matched against a pair of regular expressions to determine
if it is an affirmative or negative response. This regular
expression is obtained <br>
from the system if the &lsquo;POSIXLY_CORRECT&rsquo;
environment variable is set, or otherwise from find&rsquo;s
message translations. If the system has no suitable
definition, find&rsquo;s own <br>
definition will be used. In either case, the interpretation
of the regular expression itself will be affected by the
environment variables &rsquo;LC_CTYPE&rsquo; (character
classes) <br>
and &rsquo;LC_COLLATE&rsquo; (character ranges and
equivalence classes).</p>

<p style="margin-top: 1em">-okdir command ; <br>
Like -execdir but ask the user first in the same way as for
-ok. If the user does not agree, just return false. If the
command is run, its standard input is redirected <br>
from /dev/null.</p>

<p style="margin-top: 1em">-print True; print the full file
name on the standard output, followed by a newline. If you
are piping the output of find into another program and there
is the faintest possi&acirc; <br>
bility that the files which you are searching for might
contain a newline, then you should seriously consider using
the -print0 option instead of -print. See the UNUSUAL <br>
FILENAMES section for information about how unusual
characters in filenames are handled.</p>

<p style="margin-top: 1em">-print0 <br>
True; print the full file name on the standard output,
followed by a null character (instead of the newline
character that -print uses). This allows file names that
con&acirc; <br>
tain newlines or other types of white space to be correctly
interpreted by programs that process the find output. This
option corresponds to the -0 option of xargs.</p>

<p style="margin-top: 1em">-printf format <br>
True; print format on the standard output, interpreting
&lsquo;&acute; escapes and &lsquo;%&rsquo; directives. Field
widths and precisions can be specified as with the
&lsquo;printf&rsquo; C function. <br>
Please note that many of the fields are printed as %s rather
than %d, and this may mean that flags don&rsquo;t work as
you might expect. This also means that the &lsquo;-&rsquo;
flag does <br>
work (it forces fields to be left-aligned). Unlike -print,
-printf does not add a newline at the end of the string. The
escapes and directives are:</p>

<p style="margin-top: 1em">Alarm bell.</p>

<p style="margin-top: 1em">Backspace.</p>

<p style="margin-top: 1em">Form feed.</p>

<p style="margin-top: 1em">Newline.</p>

<p style="margin-top: 1em">Carriage return.</p>

<p style="margin-top: 1em">Horizontal tab.</p>

<p style="margin-top: 1em">Vertical tab.</p>

<p style="margin-top: 1em">ASCII NUL.</p>

<p style="margin-top: 1em">\ A literal backslash
(&lsquo;&acute;).</p>

<p style="margin-top: 1em">The character whose ASCII code
is NNN (octal).</p>

<p style="margin-top: 1em">A &lsquo;&acute; character
followed by any other character is treated as an ordinary
character, so they both are printed.</p>

<p style="margin-top: 1em">%% A literal percent sign.</p>

<p style="margin-top: 1em">%a File&rsquo;s last access time
in the format returned by the C &lsquo;ctime&rsquo;
function.</p>

<p style="margin-top: 1em">%Ak File&rsquo;s last access
time in the format specified by k, which is either
&lsquo;@&rsquo; or a directive for the C
&lsquo;strftime&rsquo; function. The possible values for k
are listed below; <br>
some of them might not be available on all systems, due to
differences in &lsquo;strftime&rsquo; between systems.</p>

<p style="margin-top: 1em">@ seconds since Jan. 1, 1970,
00:00 GMT, with fractional part.</p>

<p style="margin-top: 1em">Time fields:</p>

<p style="margin-top: 1em">H hour (00..23)</p>

<p style="margin-top: 1em">I hour (01..12)</p>

<p style="margin-top: 1em">k hour ( 0..23)</p>

<p style="margin-top: 1em">l hour ( 1..12)</p>

<p style="margin-top: 1em">M minute (00..59)</p>

<p style="margin-top: 1em">p locale&rsquo;s AM or PM</p>

<p style="margin-top: 1em">r time, 12-hour (hh:mm:ss
[AP]M)</p>

<p style="margin-top: 1em">S Second (00.00 .. 61.00). There
is a fractional part.</p>

<p style="margin-top: 1em">T time, 24-hour (hh:mm:ss)</p>

<p style="margin-top: 1em">+ Date and time, separated by
&lsquo;+&rsquo;, for example
&lsquo;2004-04-28+22:22:05.0&rsquo;. This is a GNU
extension. The time is given in the current timezone (which
may be <br>
affected by setting the TZ environment variable). The
seconds field includes a fractional part.</p>

<p style="margin-top: 1em">X locale&rsquo;s time
representation (H:M:S)</p>

<p style="margin-top: 1em">Z time zone (e.g., EDT), or
nothing if no time zone is determinable</p>

<p style="margin-top: 1em">Date fields:</p>

<p style="margin-top: 1em">a locale&rsquo;s abbreviated
weekday name (Sun..Sat)</p>

<p style="margin-top: 1em">A locale&rsquo;s full weekday
name, variable length (Sunday..Saturday)</p>

<p style="margin-top: 1em">b locale&rsquo;s abbreviated
month name (Jan..Dec)</p>

<p style="margin-top: 1em">B locale&rsquo;s full month
name, variable length (January..December)</p>

<p style="margin-top: 1em">c locale&rsquo;s date and time
(Sat Nov 04 12:02:33 EST 1989). The format is the same as
for ctime(3) and so to preserve compatibility with that
format, there is no <br>
fractional part in the seconds field.</p>

<p style="margin-top: 1em">d day of month (01..31)</p>

<p style="margin-top: 1em">D date (mm/dd/yy)</p>

<p style="margin-top: 1em">h same as b</p>

<p style="margin-top: 1em">j day of year (001..366)</p>

<p style="margin-top: 1em">m month (01..12)</p>

<p style="margin-top: 1em">U week number of year with
Sunday as first day of week (00..53)</p>

<p style="margin-top: 1em">w day of week (0..6)</p>

<p style="margin-top: 1em">W week number of year with
Monday as first day of week (00..53)</p>

<p style="margin-top: 1em">x locale&rsquo;s date
representation (mm/dd/yy)</p>

<p style="margin-top: 1em">y last two digits of year
(00..99)</p>

<p style="margin-top: 1em">Y year (1970...)</p>

<p style="margin-top: 1em">%b The amount of disk space used
for this file in 512-byte blocks. Since disk space is
allocated in multiples of the filesystem block size this is
usually greater than <br>
%s/512, but it can also be smaller if the file is a sparse
file.</p>

<p style="margin-top: 1em">%c File&rsquo;s last status
change time in the format returned by the C
&lsquo;ctime&rsquo; function.</p>

<p style="margin-top: 1em">%Ck File&rsquo;s last status
change time in the format specified by k, which is the same
as for %A.</p>

<p style="margin-top: 1em">%d File&rsquo;s depth in the
directory tree; 0 means the file is a command line
argument.</p>

<p style="margin-top: 1em">%D The device number on which
the file exists (the st_dev field of struct stat), in
decimal.</p>

<p style="margin-top: 1em">%f File&rsquo;s name with any
leading directories removed (only the last element).</p>

<p style="margin-top: 1em">%F Type of the filesystem the
file is on; this value can be used for -fstype.</p>

<p style="margin-top: 1em">%g File&rsquo;s group name, or
numeric group ID if the group has no name.</p>

<p style="margin-top: 1em">%G File&rsquo;s numeric group
ID.</p>

<p style="margin-top: 1em">%h Leading directories of
file&rsquo;s name (all but the last element). If the file
name contains no slashes (since it is in the current
directory) the %h specifier expands <br>
to &quot;.&quot;.</p>

<p style="margin-top: 1em">%H Command line argument under
which file was found.</p>

<p style="margin-top: 1em">%i File&rsquo;s inode number (in
decimal).</p>

<p style="margin-top: 1em">%k The amount of disk space used
for this file in 1K blocks. Since disk space is allocated in
multiples of the filesystem block size this is usually
greater than <br>
%s/1024, but it can also be smaller if the file is a sparse
file.</p>

<p style="margin-top: 1em">%l Object of symbolic link
(empty string if file is not a symbolic link).</p>

<p style="margin-top: 1em">%m File&rsquo;s permission bits
(in octal). This option uses the &lsquo;traditional&rsquo;
numbers which most Unix implementations use, but if your
particular implementation uses an <br>
unusual ordering of octal permissions bits, you will see a
difference between the actual value of the file&rsquo;s mode
and the output of %m. Normally you will want to <br>
have a leading zero on this number, and to do this, you
should use the # flag (as in, for example,
&lsquo;%#m&rsquo;).</p>

<p style="margin-top: 1em">%M File&rsquo;s permissions (in
symbolic form, as for ls). This directive is supported in
findutils 4.2.5 and later.</p>

<p style="margin-top: 1em">%n Number of hard links to
file.</p>

<p style="margin-top: 1em">%p File&rsquo;s name.</p>

<p style="margin-top: 1em">%P File&rsquo;s name with the
name of the command line argument under which it was found
removed.</p>

<p style="margin-top: 1em">%s File&rsquo;s size in
bytes.</p>

<p style="margin-top: 1em">%S File&rsquo;s sparseness. This
is calculated as (BLOCKSIZE*st_blocks / st_size). The exact
value you will get for an ordinary file of a certain length
is system-depen&acirc; <br>
dent. However, normally sparse files will have values less
than 1.0, and files which use indirect blocks may have a
value which is greater than 1.0. The value <br>
used for BLOCKSIZE is system-dependent, but is usually 512
bytes. If the file size is zero, the value printed is
undefined. On systems which lack support for <br>
st_blocks, a file&rsquo;s sparseness is assumed to be
1.0.</p>

<p style="margin-top: 1em">%t File&rsquo;s last
modification time in the format returned by the C
&lsquo;ctime&rsquo; function.</p>

<p style="margin-top: 1em">%Tk File&rsquo;s last
modification time in the format specified by k, which is the
same as for %A.</p>

<p style="margin-top: 1em">%u File&rsquo;s user name, or
numeric user ID if the user has no name.</p>

<p style="margin-top: 1em">%U File&rsquo;s numeric user
ID.</p>

<p style="margin-top: 1em">%y File&rsquo;s type (like in ls
-l), U=unknown type (shouldn&rsquo;t happen)</p>

<p style="margin-top: 1em">%Y File&rsquo;s type (like %y),
plus follow symlinks: L=loop, N=nonexistent</p>

<p style="margin-top: 1em">%Z (SELinux only) file&rsquo;s
security context.</p>

<p style="margin-top: 1em">%{ %[ %( <br>
Reserved for future use.</p>

<p style="margin-top: 1em">A &lsquo;%&rsquo; character
followed by any other character is discarded, but the other
character is printed (don&rsquo;t rely on this, as further
format characters may be introduced). A <br>
&lsquo;%&rsquo; at the end of the format argument causes
undefined behaviour since there is no following character.
In some locales, it may hide your door keys, while in others
it <br>
may remove the final page from the novel you are
reading.</p>

<p style="margin-top: 1em">The %m and %d directives support
the # , 0 and + flags, but the other directives do not, even
if they print numbers. Numeric directives that do not
support these flags <br>
include G, U, b, D, k and n. The &lsquo;-&rsquo; format flag
is supported and changes the alignment of a field from
right-justified (which is the default) to
left-justified.</p>

<p style="margin-top: 1em">See the UNUSUAL FILENAMES
section for information about how unusual characters in
filenames are handled.</p>

<p style="margin-top: 1em">-prune True; if the file is a
directory, do not descend into it. If -depth is given,
false; no effect. Because -delete implies -depth, you cannot
usefully use -prune and -delete <br>
together.</p>

<p style="margin-top: 1em">-quit Exit immediately. No child
processes will be left running, but no more paths specified
on the command line will be processed. For example, find
/tmp/foo /tmp/bar -print <br>
-quit will print only /tmp/foo. Any command lines which have
been built up with -execdir ... {} + will be invoked before
find exits. The exit status may or may not be <br>
zero, depending on whether an error has already
occurred.</p>

<p style="margin-top: 1em">UNUSUAL FILENAMES <br>
Many of the actions of find result in the printing of data
which is under the control of other users. This includes
file names, sizes, modification times and so forth. File
<br>
names are a potential problem since they can contain any
character except &lsquo; &rsquo; and &lsquo;/&rsquo;.
Unusual characters in file names can do unexpected and often
undesirable things to your <br>
terminal (for example, changing the settings of your
function keys on some terminals). Unusual characters are
handled differently by various actions, as described
below.</p>

<p style="margin-top: 1em">-print0, -fprint0 <br>
Always print the exact filename, unchanged, even if the
output is going to a terminal.</p>

<p style="margin-top: 1em">-ls, -fls <br>
Unusual characters are always escaped. White space,
backslash, and double quote characters are printed using
C-style escaping (for example &lsquo;, &lsquo; <br>
characters are printed using an octal escape. Other
printable characters (for -ls and -fls these are the
characters between octal 041 and 0176) are printed
as-is.</p>

<p style="margin-top: 1em">-printf, -fprintf <br>
If the output is not going to a terminal, it is printed
as-is. Otherwise, the result depends on which directive is
in use. The directives %D, %F, %g, %G, %H, %Y, and %y <br>
expand to values which are not under control of files&rsquo;
owners, and so are printed as-is. The directives %a, %b, %c,
%d, %i, %k, %m, %M, %n, %s, %t, %u and %U have values <br>
which are under the control of files&rsquo; owners but which
cannot be used to send arbitrary data to the terminal, and
so these are printed as-is. The directives %f, %h, %l, <br>
%p and %P are quoted. This quoting is performed in the same
way as for GNU ls. This is not the same quoting mechanism as
the one used for -ls and -fls. If you are able <br>
to decide what format to use for the output of find then it
is normally better to use &lsquo; &rsquo; as a terminator
than to use newline, as file names can contain white space
and <br>
newline characters. The setting of the
&lsquo;LC_CTYPE&rsquo; environment variable is used to
determine which characters need to be quoted.</p>

<p style="margin-top: 1em">-print, -fprint <br>
Quoting is handled in the same way as for -printf and
-fprintf. If you are using find in a script or in a
situation where the matched files might have arbitrary
names, <br>
you should consider using -print0 instead of -print.</p>

<p style="margin-top: 1em">The -ok and -okdir actions print
the current filename as-is. This may change in a future
release.</p>

<p style="margin-top: 1em">OPERATORS <br>
Listed in order of decreasing precedence:</p>

<p style="margin-top: 1em">( expr ) <br>
Force precedence. Since parentheses are special to the
shell, you will normally need to quote them. Many of the
examples in this manual page use backslashes for this <br>
purpose: &lsquo;.&rsquo; instead of &lsquo;(...)&rsquo;.</p>

<p style="margin-top: 1em">! expr True if expr is false.
This character will also usually need protection from
interpretation by the shell.</p>

<p style="margin-top: 1em">-not expr <br>
Same as ! expr, but not POSIX compliant.</p>

<p style="margin-top: 1em">expr1 expr2 <br>
Two expressions in a row are taken to be joined with an
implied &quot;and&quot;; expr2 is not evaluated if expr1 is
false.</p>

<p style="margin-top: 1em">expr1 -a expr2 <br>
Same as expr1 expr2.</p>

<p style="margin-top: 1em">expr1 -and expr2 <br>
Same as expr1 expr2, but not POSIX compliant.</p>

<p style="margin-top: 1em">expr1 -o expr2 <br>
Or; expr2 is not evaluated if expr1 is true.</p>

<p style="margin-top: 1em">expr1 -or expr2 <br>
Same as expr1 -o expr2, but not POSIX compliant.</p>

<p style="margin-top: 1em">expr1 , expr2 <br>
List; both expr1 and expr2 are always evaluated. The value
of expr1 is discarded; the value of the list is the value of
expr2. The comma operator can be useful for <br>
searching for several different types of thing, but
traversing the filesystem hierarchy only once. The -fprintf
action can be used to list the various matched items into
<br>
several different output files.</p>

<p style="margin-top: 1em">STANDARDS CONFORMANCE <br>
For closest compliance to the POSIX standard, you should set
the POSIXLY_CORRECT environment variable. The following
options are specified in the POSIX standard (IEEE Std <br>
1003.1, 2003 Edition):</p>

<p style="margin-top: 1em">-H This option is supported.</p>

<p style="margin-top: 1em">-L This option is supported.</p>

<p style="margin-top: 1em">-name This option is supported,
but POSIX conformance depends on the POSIX conformance of
the system&rsquo;s fnmatch(3) library function. As of
findutils-4.2.2, shell metacharacters <br>
(&lsquo;*&rsquo;, &lsquo;?&rsquo; or &lsquo;[]&rsquo; for
example) will match a leading &lsquo;.&rsquo;, because IEEE
PASC interpretation 126 requires this. This is a change from
previous versions of findutils.</p>

<p style="margin-top: 1em">-type Supported. POSIX specifies
&lsquo;b&rsquo;, &lsquo;c&rsquo;, &lsquo;d&rsquo;,
&lsquo;l&rsquo;, &lsquo;p&rsquo;, &lsquo;f&rsquo; and
&lsquo;s&rsquo;. GNU find also supports &lsquo;D&rsquo;,
representing a Door, where the OS provides these.</p>

<p style="margin-top: 1em">-ok Supported. Interpretation of
the response is according to the &quot;yes&quot; and
&quot;no&quot; patterns selected by setting the
&lsquo;LC_MESSAGES&rsquo; environment variable. When the
&lsquo;POSIXLY_COR&acirc; <br>
RECT&rsquo; environment variable is set, these patterns are
taken system&rsquo;s definition of a positive (yes) or
negative (no) response. See the system&rsquo;s documentation
for nl_lang&acirc; <br>
info(3), in particular YESEXPR and NOEXPR. When
&lsquo;POSIXLY_CORRECT&rsquo; is not set, the patterns are
instead taken from find&rsquo;s own message catalogue.</p>

<p style="margin-top: 1em">-newer Supported. If the file
specified is a symbolic link, it is always dereferenced.
This is a change from previous behaviour, which used to take
the relevant time from the <br>
symbolic link; see the HISTORY section below.</p>

<p style="margin-top: 1em">-perm Supported. If the
POSIXLY_CORRECT environment variable is not set, some mode
arguments (for example +a+x) which are not valid in POSIX
are supported for backward-compati&acirc; <br>
bility.</p>

<p style="margin-top: 1em">Other predicates <br>
The predicates -atime, -ctime, -depth, -group, -links,
-mtime, -nogroup, -nouser, -print, -prune, -size, -user and
-xdev &lsquo;-atime&rsquo;, &lsquo;-ctime&rsquo;,
&lsquo;-depth&rsquo;, &lsquo;-group&rsquo;,
&lsquo;-links&rsquo;, <br>
&lsquo;-mtime&rsquo;, &lsquo;-nogroup&rsquo;,
&lsquo;-nouser&rsquo;, &lsquo;-perm&rsquo;,
&lsquo;-print&rsquo;, &lsquo;-prune&rsquo;,
&lsquo;-size&rsquo;, &lsquo;-user&rsquo; and
&lsquo;-xdev&rsquo;, are all supported.</p>

<p style="margin-top: 1em">The POSIX standard specifies
parentheses &lsquo;(&rsquo;, &lsquo;)&rsquo;, negation
&lsquo;!&rsquo; and the &lsquo;and&rsquo; and
&lsquo;or&rsquo; operators ( -a, -o).</p>

<p style="margin-top: 1em">All other options, predicates,
expressions and so forth are extensions beyond the POSIX
standard. Many of these extensions are not unique to GNU
find, however.</p>

<p style="margin-top: 1em">The POSIX standard requires that
find detects loops:</p>

<p style="margin-top: 1em">The find utility shall detect
infinite loops; that is, entering a previously visited
directory that is an ancestor of the last file encountered.
When it detects an infi&acirc; <br>
nite loop, find shall write a diagnostic message to standard
error and shall either recover its position in the hierarchy
or terminate.</p>

<p style="margin-top: 1em">GNU find complies with these
requirements. The link count of directories which contain
entries which are hard links to an ancestor will often be
lower than they otherwise should <br>
be. This can mean that GNU find will sometimes optimise away
the visiting of a subdirectory which is actually a link to
an ancestor. Since find does not actually enter such a <br>
subdirectory, it is allowed to avoid emitting a diagnostic
message. Although this behaviour may be somewhat confusing,
it is unlikely that anybody actually depends on this
be&acirc; <br>
haviour. If the leaf optimisation has been turned off with
-noleaf, the directory entry will always be examined and the
diagnostic message will be issued where it is
appropri&acirc; <br>
ate. Symbolic links cannot be used to create filesystem
cycles as such, but if the -L option or the -follow option
is in use, a diagnostic message is issued when find
encounters <br>
a loop of symbolic links. As with loops containing hard
links, the leaf optimisation will often mean that find knows
that it doesn&rsquo;t need to call stat() or chdir() on the
sym&acirc; <br>
bolic link, so this diagnostic is frequently not
necessary.</p>

<p style="margin-top: 1em">The -d option is supported for
compatibility with various BSD systems, but you should use
the POSIX-compliant option -depth instead.</p>

<p style="margin-top: 1em">The POSIXLY_CORRECT environment
variable does not affect the behaviour of the -regex or
-iregex tests because those tests aren&rsquo;t specified in
the POSIX standard.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
LANG Provides a default value for the internationalization
variables that are unset or null.</p>

<p style="margin-top: 1em">LC_ALL If set to a non-empty
string value, override the values of all the other
internationalization variables.</p>

<p style="margin-top: 1em">LC_COLLATE <br>
The POSIX standard specifies that this variable affects the
pattern matching to be used for the -name option. GNU find
uses the fnmatch(3) library function, and so sup&acirc; <br>
port for &lsquo;LC_COLLATE&rsquo; depends on the system
library. This variable also affects the interpretation of
the response to -ok; while the &lsquo;LC_MESSAGES&rsquo;
variable selects the <br>
actual pattern used to interpret the response to -ok, the
interpretation of any bracket expressions in the pattern
will be affected by &lsquo;LC_COLLATE&rsquo;.</p>

<p style="margin-top: 1em">LC_CTYPE <br>
This variable affects the treatment of character classes
used in regular expressions and also with the -name test, if
the system&rsquo;s fnmatch(3) library function supports <br>
this. This variable also affects the interpretation of any
character classes in the regular expressions used to
interpret the response to the prompt issued by -ok. The <br>
&lsquo;LC_CTYPE&rsquo; environment variable will also affect
which characters are considered to be unprintable when
filenames are printed; see the section UNUSUAL
FILENAMES.</p>

<p style="margin-top: 1em">LC_MESSAGES <br>
Determines the locale to be used for internationalised
messages. If the &lsquo;POSIXLY_CORRECT&rsquo; environment
variable is set, this also determines the interpretation of
the <br>
response to the prompt made by the -ok action.</p>

<p style="margin-top: 1em">NLSPATH <br>
Determines the location of the internationalisation message
catalogues.</p>

<p style="margin-top: 1em">PATH Affects the directories
which are searched to find the executables invoked by -exec,
-execdir, -ok and -okdir.</p>

<p style="margin-top: 1em">POSIXLY_CORRECT <br>
Determines the block size used by -ls and -fls. If
POSIXLY_CORRECT is set, blocks are units of 512 bytes.
Otherwise they are units of 1024 bytes.</p>

<p style="margin-top: 1em">Setting this variable also turns
off warning messages (that is, implies -nowarn) by default,
because POSIX requires that apart from the output for -ok,
all messages <br>
printed on stderr are diagnostics and must result in a
non-zero exit status.</p>

<p style="margin-top: 1em">When POSIXLY_CORRECT is not set,
-perm +zzz is treated just like -perm /zzz if +zzz is not a
valid symbolic mode. When POSIXLY_CORRECT is set, such
constructs are treated <br>
as an error.</p>

<p style="margin-top: 1em">When POSIXLY_CORRECT is set, the
response to the prompt made by the -ok action is interpreted
according to the system&rsquo;s message catalogue, as
opposed to according to <br>
find&rsquo;s own message translations.</p>

<p style="margin-top: 1em">TZ Affects the time zone used
for some of the time-related format directives of -printf
and -fprintf.</p>

<p style="margin-top: 1em">BINARIES <br>
The findutils source distribution contains two different
implementations of find. The older implementation descends
the file system recursively, while the newer one uses
fts(3). <br>
Both are normally installed.</p>

<p style="margin-top: 1em">If the option --without-fts was
passed to configure, the recursive implementation is
installed as find and the fts-based implementation is
installed as ftsfind. Otherwise, the <br>
fts-based implementation is installed as find and the
recursive implementation is installed as oldfind.</p>

<p style="margin-top: 1em">EXAMPLES <br>
find /tmp -name core -type f -print | xargs /bin/rm -f</p>

<p style="margin-top: 1em">Find files named core in or
below the directory /tmp and delete them. Note that this
will work incorrectly if there are any filenames containing
newlines, single or double <br>
quotes, or spaces.</p>

<p style="margin-top: 1em">find /tmp -name core -type f
-print0 | xargs -0 /bin/rm -f</p>

<p style="margin-top: 1em">Find files named core in or
below the directory /tmp and delete them, processing
filenames in such a way that file or directory names
containing single or double quotes, spaces <br>
or newlines are correctly handled. The -name test comes
before the -type test in order to avoid having to call
stat(2) on every file.</p>

<p style="margin-top: 1em">find . -type f -exec file
&rsquo;{}&rsquo; ;</p>

<p style="margin-top: 1em">Runs &lsquo;file&rsquo; on every
file in or below the current directory. Notice that the
braces are enclosed in single quote marks to protect them
from interpretation as shell script punc&acirc; <br>
tuation. The semicolon is similarly protected by the use of
a backslash, though single quotes could have been used in
that case also.</p>

<p style="margin-top: 1em">find / -perm -4000 -fprintf
/root/suid.txt &rsquo;%#m %u %p0 , -size +100M -fprintf
/root/big.txt &rsquo;%-10s %p0</p>

<p style="margin-top: 1em">Traverse the filesystem just
once, listing setuid files and directories into
/root/suid.txt and large files into /root/big.txt.</p>

<p style="margin-top: 1em">find $HOME -mtime 0</p>

<p style="margin-top: 1em">Search for files in your home
directory which have been modified in the last twenty-four
hours. This command works this way because the time since
each file was last modified is <br>
divided by 24 hours and any remainder is discarded. That
means that to match -mtime 0, a file will have to have a
modification in the past which is less than 24 hours
ago.</p>

<p style="margin-top: 1em">find /sbin /usr/sbin -executable
-readable -print</p>

<p style="margin-top: 1em">Search for files which are
executable but not readable.</p>

<p style="margin-top: 1em">find . -perm 664</p>

<p style="margin-top: 1em">Search for files which have read
and write permission for their owner, and group, but which
other users can read but not write to. Files which meet
these criteria but have other <br>
permissions bits set (for example if someone can execute the
file) will not be matched.</p>

<p style="margin-top: 1em">find . -perm -664</p>

<p style="margin-top: 1em">Search for files which have read
and write permission for their owner and group, and which
other users can read, without regard to the presence of any
extra permission bits (for <br>
example the executable bit). This will match a file which
has mode 0777, for example.</p>

<p style="margin-top: 1em">find . -perm /222</p>

<p style="margin-top: 1em">Search for files which are
writable by somebody (their owner, or their group, or
anybody else).</p>

<p style="margin-top: 1em">find . -perm /220 <br>
find . -perm /u+w,g+w <br>
find . -perm /u=w,g=w</p>

<p style="margin-top: 1em">All three of these commands do
the same thing, but the first one uses the octal
representation of the file mode, and the other two use the
symbolic form. These commands all <br>
search for files which are writable by either their owner or
their group. The files don&rsquo;t have to be writable by
both the owner and group to be matched; either will do.</p>

<p style="margin-top: 1em">find . -perm -220 <br>
find . -perm -g+w,u+w</p>

<p style="margin-top: 1em">Both these commands do the same
thing; search for files which are writable by both their
owner and their group.</p>

<p style="margin-top: 1em">find . -perm -444 -perm /222 !
-perm /111 <br>
find . -perm -a+r -perm /a+w ! -perm /a+x</p>

<p style="margin-top: 1em">These two commands both search
for files that are readable for everybody ( -perm -444 or
-perm -a+r), have at least one write bit set ( -perm /222 or
-perm /a+w) but are not exe&acirc; <br>
cutable for anybody ( ! -perm /111 and ! -perm /a+x
respectively).</p>

<p style="margin-top: 1em">cd /source-dir <br>
find . -name .snapshot -prune -o -name *~ -print0 | <br>
cpio -pmd0 /dest-dir</p>

<p style="margin-top: 1em">This command copies the contents
of /source-dir to /dest-dir, but omits files and directories
named .snapshot (and anything in them). It also omits files
or directories whose <br>
name ends in ~, but not their contents. The construct -prune
-o ... -print0 is quite common. The idea here is that the
expression before -prune matches things which are <br>
to be pruned. However, the -prune action itself returns
true, so the following -o ensures that the right hand side
is evaluated only for those directories which didn&rsquo;t
get <br>
pruned (the contents of the pruned directories are not even
visited, so their contents are irrelevant). The expression
on the right hand side of the -o is in parentheses only <br>
for clarity. It emphasises that the -print0 action takes
place only for things that didn&rsquo;t have -prune applied
to them. Because the default &lsquo;and&rsquo; condition
between tests binds <br>
more tightly than -o, this is the default anyway, but the
parentheses help to show what is going on.</p>

<p style="margin-top: 1em">find repo/ -exec test -d {}/.svn
; -or -exec test -d {}/.git ; -or -exec test -d {}/CVS ;
-print -prune</p>

<p style="margin-top: 1em">Given the following directory of
projects and their associated SCM administrative
directories, perform an efficient search for the
projects&rsquo; roots:</p>

<p style="margin-top: 1em">repo/project1/CVS <br>
repo/gnu/project2/.svn <br>
repo/gnu/project3/.svn <br>
repo/gnu/project3/src/.svn <br>
repo/project4/.git</p>

<p style="margin-top: 1em">In this example, -prune prevents
unnecessary descent into directories that have already been
discovered (for example we do not search project3/src
because we already found <br>
project3/.svn), but ensures sibling directories (project2
and project3) are found.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
find exits with status 0 if all files are processed
successfully, greater than 0 if errors occur. This is
deliberately a very broad description, but if the return
value is non- <br>
zero, you should not rely on the correctness of the results
of find.</p>

<p style="margin-top: 1em">SEE ALSO <br>
locate(1), locatedb(5), updatedb(1), xargs(1), chmod(1),
fnmatch(3), regex(7), stat(2), lstat(2), ls(1), printf(3),
strftime(3), ctime(3), Finding Files (on-line in Info, or
<br>
printed).</p>

<p style="margin-top: 1em">HISTORY <br>
As of findutils-4.2.2, shell metacharacters
(&lsquo;*&rsquo;, &lsquo;?&rsquo; or &lsquo;[]&rsquo; for
example) used in filename patterns will match a leading
&lsquo;.&rsquo;, because IEEE POSIX interpretation 126
requires <br>
this.</p>

<p style="margin-top: 1em">As of findutils-4.3.3, -perm
/000 now matches all files instead of none.</p>

<p style="margin-top: 1em">Nanosecond-resolution timestamps
were implemented in findutils-4.3.3.</p>

<p style="margin-top: 1em">As of findutils-4.3.11, the
-delete action sets find&rsquo;s exit status to a nonzero
value when it fails. However, find will not exit
immediately. Previously, find&rsquo;s exit status was <br>
unaffected by the failure of -delete.</p>

<p style="margin-top: 1em">Feature Added in Also occurs in
<br>
-newerXY 4.3.3 BSD <br>
-D 4.3.1 <br>
-O 4.3.1 <br>
-readable 4.3.0 <br>
-writable 4.3.0 <br>
-executable 4.3.0 <br>
-regextype 4.2.24 <br>
-exec ... + 4.2.12 POSIX <br>
-execdir 4.2.12 BSD <br>
-okdir 4.2.12 <br>
-samefile 4.2.11 <br>
-H 4.2.5 POSIX <br>
-L 4.2.5 POSIX <br>
-P 4.2.5 BSD <br>
-delete 4.2.3 <br>
-quit 4.2.3 <br>
-d 4.2.3 BSD <br>
-wholename 4.2.0 <br>
-iwholename 4.2.0 <br>
-ignore_readdir_race 4.2.0 <br>
-fls 4.0 <br>
-ilname 3.8 <br>
-iname 3.8 <br>
-ipath 3.8 <br>
-iregex 3.8</p>

<p style="margin-top: 1em">The syntax -perm +MODE does not
work as expected in findutils-4.5.11 and it was removed in
findutils-4.5.12, in favour of -perm /MODE. The +MODE syntax
had been deprecated since <br>
findutils-4.2.21 which was released in 2005.</p>

<p style="margin-top: 1em">NON-BUGS <br>
$ find . -name *.c -print <br>
find: paths must precede expression <br>
Usage: find [-H] [-L] [-P] [-Olevel] [-D
help|tree|search|stat|rates|opt|exec] [path...]
[expression]</p>

<p style="margin-top: 1em">This happens because *.c has
been expanded by the shell resulting in find actually
receiving a command line like this:</p>

<p style="margin-top: 1em">find . -name bigram.c code.c
frcode.c locate.c -print</p>

<p style="margin-top: 1em">That command is of course not
going to work. Instead of doing things this way, you should
enclose the pattern in quotes or escape the wildcard: <br>
$ find . -name &rsquo;*.c&rsquo; -print <br>
$ find . -name c -print</p>

<p style="margin-top: 1em">BUGS <br>
There are security problems inherent in the behaviour that
the POSIX standard specifies for find, which therefore
cannot be fixed. For example, the -exec action is inherently
<br>
insecure, and -execdir should be used instead. Please see
Finding Files for more information.</p>

<p style="margin-top: 1em">The environment variable
LC_COLLATE has no effect on the -ok action.</p>

<p style="margin-top: 1em">The best way to report a bug is
to use the form at
http://savannah.gnu.org/bugs/?group=findutils. The reason
for this is that you will then be able to track progress in
fixing <br>
the problem. Other comments about find(1) and about the
findutils package in general can be sent to the
bug-findutils mailing list. To join the list, send email to
bug-findu&acirc; <br>
tils-request@gnu.org.</p>
 
<p style="margin-top: 1em">FIND(1)</p>
<hr>
</body>
</html>
