<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLDATA(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLDATA(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLDATA(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perldata - Perl data types
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<h2 class="Ss" title="Ss" id="Variable_names"><a class="selflink" href="#Variable_names">Variable
  names</a></h2>
Perl has three built-in data types: scalars, arrays of scalars, and associative
  arrays of scalars, known as &quot;hashes&quot;. A scalar is a single string
  (of any size, limited only by the available memory), number, or a reference to
  something (which will be discussed in perlref). Normal arrays are ordered
  lists of scalars indexed by number, starting with 0. Hashes are unordered
  collections of scalar values indexed by their associated string key.
<div class="Pp"></div>
Values are usually referred to by name, or through a named reference. The first
  character of the name tells you to what sort of data structure it refers. The
  rest of the name tells you the particular value to which it refers. Usually
  this name is a single <i>identifier</i>, that is, a string beginning with a
  letter or underscore, and containing letters, underscores, and digits. In some
  cases, it may be a chain of identifiers, separated by &quot;::&quot; (or by
  the slightly archaic &quot;'&quot;); all but the last are interpreted as names
  of packages, to locate the namespace in which to look up the final identifier
  (see &quot;Packages&quot; in perlmod for details). It's possible to substitute
  for a simple identifier, an expression that produces a reference to the value
  at runtime. This is described in more detail below and in perlref.
<div class="Pp"></div>
Perl also has its own built-in variables whose names don't follow these rules.
  They have strange names so they don't accidentally collide with one of your
  normal variables. Strings that match parenthesized parts of a regular
  expression are saved under names containing only digits after the
  &quot;$&quot; (see perlop and perlre). In addition, several special variables
  that provide windows into the inner working of Perl have names containing
  punctuation characters and control characters. These are documented in
  perlvar.
<div class="Pp"></div>
Scalar values are always named with '$', even when referring to a scalar that is
  part of an array or a hash. The '$' symbol works semantically like the English
  word &quot;the&quot; in that it indicates a single value is expected.
<div class="Pp"></div>
<pre>
    $days               # the simple scalar value &quot;days&quot;
    $days[28]           # the 29th element of array @days
    $days{'Feb'}        # the 'Feb' value from hash %days
    $#days              # the last index of array @days
</pre>
<div class="Pp"></div>
Entire arrays (and slices of arrays and hashes) are denoted by '@', which works
  much as the word &quot;these&quot; or &quot;those&quot; does in English, in
  that it indicates multiple values are expected.
<div class="Pp"></div>
<pre>
    @days               # ($days[0], $days[1],... $days[n])
    @days[3,4,5]        # same as ($days[3],$days[4],$days[5])
    @days{'a','c'}      # same as ($days{'a'},$days{'c'})
</pre>
<div class="Pp"></div>
Entire hashes are denoted by '%':
<div class="Pp"></div>
<pre>
    %days               # (key1, val1, key2, val2 ...)
</pre>
<div class="Pp"></div>
In addition, subroutines are named with an initial '&amp;', though this is
  optional when unambiguous, just as the word &quot;do&quot; is often redundant
  in English. Symbol table entries can be named with an initial '*', but you
  don't really care about that yet (if ever :-).
<div class="Pp"></div>
Every variable type has its own namespace, as do several non-variable
  identifiers. This means that you can, without fear of conflict, use the same
  name for a scalar variable, an array, or a hash--or, for that matter, for a
  filehandle, a directory handle, a subroutine name, a format name, or a label.
  This means that $foo and @foo are two different variables. It also means that
  $foo[1] is a part of @foo, not a part of $foo. This may seem a bit weird, but
  that's okay, because it is weird.
<div class="Pp"></div>
Because variable references always start with '$', '@', or '%', the
  &quot;reserved&quot; words aren't in fact reserved with respect to variable
  names. They <i>are</i> reserved with respect to labels and filehandles,
  however, which don't have an initial special character. You can't have a
  filehandle named &quot;log&quot;, for instance. Hint: you could say
  &quot;open(LOG,'logfile')&quot; rather than &quot;open(log,'logfile')&quot;.
  Using uppercase filehandles also improves readability and protects you from
  conflict with future reserved words. Case <i>is</i>
  significant--&quot;FOO&quot;, &quot;Foo&quot;, and &quot;foo&quot; are all
  different names. Names that start with a letter or underscore may also contain
  digits and underscores.
<div class="Pp"></div>
It is possible to replace such an alphanumeric name with an expression that
  returns a reference to the appropriate type. For a description of this, see
  perlref.
<div class="Pp"></div>
Names that start with a digit may contain only more digits. Names that do not
  start with a letter, underscore, digit or a caret (i.e. a control character)
  are limited to one character, e.g., $% or $$. (Most of these one character
  names have a predefined significance to Perl. For instance, $$ is the current
  process id.)
<h2 class="Ss" title="Ss" id="Context"><a class="selflink" href="#Context">Context</a></h2>
The interpretation of operations and values in Perl sometimes depends on the
  requirements of the context around the operation or value. There are two major
  contexts: list and scalar. Certain operations return list values in contexts
  wanting a list, and scalar values otherwise. If this is true of an operation
  it will be mentioned in the documentation for that operation. In other words,
  Perl overloads certain operations based on whether the expected return value
  is singular or plural. Some words in English work this way, like
  &quot;fish&quot; and &quot;sheep&quot;.
<div class="Pp"></div>
In a reciprocal fashion, an operation provides either a scalar or a list context
  to each of its arguments. For example, if you say
<div class="Pp"></div>
<pre>
    int( &lt;STDIN&gt; )
</pre>
<div class="Pp"></div>
the integer operation provides scalar context for the &lt;&gt; operator, which
  responds by reading one line from STDIN and passing it back to the integer
  operation, which will then find the integer value of that line and return
  that. If, on the other hand, you say
<div class="Pp"></div>
<pre>
    sort( &lt;STDIN&gt; )
</pre>
<div class="Pp"></div>
then the sort operation provides list context for &lt;&gt;, which will proceed
  to read every line available up to the end of file, and pass that list of
  lines back to the sort routine, which will then sort those lines and return
  them as a list to whatever the context of the sort was.
<div class="Pp"></div>
Assignment is a little bit special in that it uses its left argument to
  determine the context for the right argument. Assignment to a scalar evaluates
  the right-hand side in scalar context, while assignment to an array or hash
  evaluates the righthand side in list context. Assignment to a list (or slice,
  which is just a list anyway) also evaluates the right-hand side in list
  context.
<div class="Pp"></div>
When you use the &quot;use warnings&quot; pragma or Perl's <b>-w</b>
  command-line option, you may see warnings about useless uses of constants or
  functions in &quot;void context&quot;. Void context just means the value has
  been discarded, such as a statement containing only
  &quot;&quot;fred&quot;;&quot; or &quot;getpwuid(0);&quot;. It still counts as
  scalar context for functions that care whether or not they're being called in
  list context.
<div class="Pp"></div>
User-defined subroutines may choose to care whether they are being called in a
  void, scalar, or list context. Most subroutines do not need to bother, though.
  That's because both scalars and lists are automatically interpolated into
  lists. See &quot;wantarray&quot; in perlfunc for how you would dynamically
  discern your function's calling context.
<h2 class="Ss" title="Ss" id="Scalar_values"><a class="selflink" href="#Scalar_values">Scalar
  values</a></h2>
All data in Perl is a scalar, an array of scalars, or a hash of scalars. A
  scalar may contain one single value in any of three different flavors: a
  number, a string, or a reference. In general, conversion from one form to
  another is transparent. Although a scalar may not directly hold multiple
  values, it may contain a reference to an array or hash which in turn contains
  multiple values.
<div class="Pp"></div>
Scalars aren't necessarily one thing or another. There's no place to declare a
  scalar variable to be of type &quot;string&quot;, type &quot;number&quot;,
  type &quot;reference&quot;, or anything else. Because of the automatic
  conversion of scalars, operations that return scalars don't need to care (and
  in fact, cannot care) whether their caller is looking for a string, a number,
  or a reference. Perl is a contextually polymorphic language whose scalars can
  be strings, numbers, or references (which includes objects). Although strings
  and numbers are considered pretty much the same thing for nearly all purposes,
  references are strongly-typed, uncastable pointers with builtin
  reference-counting and destructor invocation.
<div class="Pp"></div>
A scalar value is interpreted as FALSE in the Boolean sense if it is undefined,
  the null string or the number 0 (or its string equivalent, &quot;0&quot;), and
  TRUE if it is anything else. The Boolean context is just a special kind of
  scalar context where no conversion to a string or a number is ever performed.
<div class="Pp"></div>
There are actually two varieties of null strings (sometimes referred to as
  &quot;empty&quot; strings), a defined one and an undefined one. The defined
  version is just a string of length zero, such as &quot;&quot;. The undefined
  version is the value that indicates that there is no real value for something,
  such as when there was an error, or at end of file, or when you refer to an
  uninitialized variable or element of an array or hash. Although in early
  versions of Perl, an undefined scalar could become defined when first used in
  a place expecting a defined value, this no longer happens except for rare
  cases of autovivification as explained in perlref. You can use the
  <i>defined()</i> operator to determine whether a scalar value is defined (this
  has no meaning on arrays or hashes), and the <i>undef()</i> operator to
  produce an undefined value.
<div class="Pp"></div>
To find out whether a given string is a valid non-zero number, it's sometimes
  enough to test it against both numeric 0 and also lexical &quot;0&quot;
  (although this will cause noises if warnings are on). That's because strings
  that aren't numbers count as 0, just as they do in <b>awk</b>:
<div class="Pp"></div>
<pre>
    if ($str == 0 &amp;&amp; $str ne &quot;0&quot;)  {
        warn &quot;That doesn't look like a number&quot;;
    }
</pre>
<div class="Pp"></div>
That method may be best because otherwise you won't treat IEEE notations like
  &quot;NaN&quot; or &quot;Infinity&quot; properly. At other times, you might
  prefer to determine whether string data can be used numerically by calling the
  <i>POSIX::strtod()</i> function or by inspecting your string with a regular
  expression (as documented in perlre).
<div class="Pp"></div>
<pre>
    warn &quot;has nondigits&quot;        if     /\D/;
    warn &quot;not a natural number&quot; unless /^\d+$/;             # rejects -3
    warn &quot;not an integer&quot;       unless /^-?\d+$/;           # rejects +3
    warn &quot;not an integer&quot;       unless /^[+-]?\d+$/;
    warn &quot;not a decimal number&quot; unless /^-?\d+\.?\d*$/;     # rejects .2
    warn &quot;not a decimal number&quot; unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;
    warn &quot;not a C float&quot;
        unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
</pre>
<div class="Pp"></div>
The length of an array is a scalar value. You may find the length of array @days
  by evaluating $#days, as in <b>csh</b>. However, this isn't the length of the
  array; it's the subscript of the last element, which is a different value
  since there is ordinarily a 0th element. Assigning to $#days actually changes
  the length of the array. Shortening an array this way destroys intervening
  values. Lengthening an array that was previously shortened does not recover
  values that were in those elements. (It used to do so in Perl 4, but we had to
  break this to make sure destructors were called when expected.)
<div class="Pp"></div>
You can also gain some minuscule measure of efficiency by pre-extending an array
  that is going to get big. You can also extend an array by assigning to an
  element that is off the end of the array. You can truncate an array down to
  nothing by assigning the null list () to it. The following are equivalent:
<div class="Pp"></div>
<pre>
    @whatever = ();
    $#whatever = -1;
</pre>
<div class="Pp"></div>
If you evaluate an array in scalar context, it returns the length of the array.
  (Note that this is not true of lists, which return the last value, like the C
  comma operator, nor of built-in functions, which return whatever they feel
  like returning.) The following is always true:
<div class="Pp"></div>
<pre>
    scalar(@whatever) == $#whatever + 1;
</pre>
<div class="Pp"></div>
Some programmers choose to use an explicit conversion so as to leave nothing to
  doubt:
<div class="Pp"></div>
<pre>
    $element_count = scalar(@whatever);
</pre>
<div class="Pp"></div>
If you evaluate a hash in scalar context, it returns false if the hash is empty.
  If there are any key/value pairs, it returns true; more precisely, the value
  returned is a string consisting of the number of used buckets and the number
  of allocated buckets, separated by a slash. This is pretty much useful only to
  find out whether Perl's internal hashing algorithm is performing poorly on
  your data set. For example, you stick 10,000 things in a hash, but evaluating
  %HASH in scalar context reveals &quot;1/16&quot;, which means only one out of
  sixteen buckets has been touched, and presumably contains all 10,000 of your
  items. This isn't supposed to happen. If a tied hash is evaluated in scalar
  context, the &quot;SCALAR&quot; method is called (with a fallback to
  &quot;FIRSTKEY&quot;).
<div class="Pp"></div>
You can preallocate space for a hash by assigning to the <i>keys()</i> function.
  This rounds up the allocated buckets to the next power of two:
<div class="Pp"></div>
<pre>
    keys(%users) = 1000;                # allocate 1024 buckets
</pre>
<h2 class="Ss" title="Ss" id="Scalar_value_constructors"><a class="selflink" href="#Scalar_value_constructors">Scalar
  value constructors</a></h2>
Numeric literals are specified in any of the following floating point or integer
  formats:
<div class="Pp"></div>
<pre>
    12345
    12345.67
    .23E-10             # a very small number
    3.14_15_92          # a very important number
    4_294_967_296       # underscore for legibility
    0xff                # hex
    0xdead_beef         # more hex   
    0377                # octal (only numbers, begins with 0)
    0b011011            # binary
</pre>
<div class="Pp"></div>
You are allowed to use underscores (underbars) in numeric literals between
  digits for legibility (but not multiple underscores in a row:
  &quot;23__500&quot; is not legal; &quot;23_500&quot; is). You could, for
  example, group binary digits by threes (as for a Unix-style mode argument such
  as 0b110_100_100) or by fours (to represent nibbles, as in 0b1010_0110) or in
  other groups.
<div class="Pp"></div>
String literals are usually delimited by either single or double quotes. They
  work much like quotes in the standard Unix shells: double-quoted string
  literals are subject to backslash and variable substitution; single-quoted
  strings are not (except for &quot;\'&quot; and &quot;\\&quot;). The usual
  C-style backslash rules apply for making characters such as newline, tab,
  etc., as well as some more exotic forms. See &quot;Quote and Quote-like
  Operators&quot; in perlop for a list.
<div class="Pp"></div>
Hexadecimal, octal, or binary, representations in string literals (e.g. '0xff')
  are not automatically converted to their integer representation. The
  <i>hex()</i> and <i>oct()</i> functions make these conversions for you. See
  &quot;hex&quot; in perlfunc and &quot;oct&quot; in perlfunc for more details.
<div class="Pp"></div>
You can also embed newlines directly in your strings, i.e., they can end on a
  different line than they begin. This is nice, but if you forget your trailing
  quote, the error will not be reported until Perl finds another line containing
  the quote character, which may be much further on in the script. Variable
  substitution inside strings is limited to scalar variables, arrays, and array
  or hash slices. (In other words, names beginning with $ or @, followed by an
  optional bracketed expression as a subscript.) The following code segment
  prints out &quot;The price is $100.&quot;
<div class="Pp"></div>
<pre>
    $Price = '$100';    # not interpolated
    print &quot;The price is $Price.\n&quot;;     # interpolated
</pre>
<div class="Pp"></div>
There is no double interpolation in Perl, so the $100 is left as is.
<div class="Pp"></div>
By default floating point numbers substituted inside strings use the dot
  (&quot;.&quot;) as the decimal separator. If &quot;use locale&quot; is in
  effect, and <i>POSIX::setlocale()</i> has been called, the character used for
  the decimal separator is affected by the LC_NUMERIC locale. See perllocale and
  POSIX.
<div class="Pp"></div>
As in some shells, you can enclose the variable name in braces to disambiguate
  it from following alphanumerics (and underscores). You must also do this when
  interpolating a variable into a string to separate the variable name from a
  following double-colon or an apostrophe, since these would be otherwise
  treated as a package separator:
<div class="Pp"></div>
<pre>
    $who = &quot;Larry&quot;;
    print PASSWD &quot;${who}::0:0:Superuser:/:/bin/perl\n&quot;;
    print &quot;We use ${who}speak when ${who}'s here.\n&quot;;
</pre>
<div class="Pp"></div>
Without the braces, Perl would have looked for a $whospeak, a $who::0, and a
  &quot;$who's&quot; variable. The last two would be the $0 and the $s variables
  in the (presumably) non-existent package &quot;who&quot;.
<div class="Pp"></div>
In fact, an identifier within such curlies is forced to be a string, as is any
  simple identifier within a hash subscript. Neither need quoting. Our earlier
  example, $days{'Feb'} can be written as $days{Feb} and the quotes will be
  assumed automatically. But anything more complicated in the subscript will be
  interpreted as an expression. This means for example that
  &quot;$version{2.0}++&quot; is equivalent to &quot;$version{2}++&quot;, not to
  &quot;$version{'2.0'}++&quot;.
<div class="Pp"></div>
<i>Version Strings</i>
<div class="Pp"></div>
A literal of the form &quot;v1.20.300.4000&quot; is parsed as a string composed
  of characters with the specified ordinals. This form, known as v-strings,
  provides an alternative, more readable way to construct strings, rather than
  use the somewhat less readable interpolation form
  &quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;. This is useful for representing Unicode
  strings, and for comparing version &quot;numbers&quot; using the string
  comparison operators, &quot;cmp&quot;, &quot;gt&quot;, &quot;lt&quot; etc. If
  there are two or more dots in the literal, the leading &quot;v&quot; may be
  omitted.
<div class="Pp"></div>
<pre>
    print v9786;              # prints SMILEY, &quot;\x{263a}&quot;
    print v102.111.111;       # prints &quot;foo&quot;
    print 102.111.111;        # same
</pre>
<div class="Pp"></div>
Such literals are accepted by both &quot;require&quot; and &quot;use&quot; for
  doing a version check. Note that using the v-strings for IPv4 addresses is not
  portable unless you also use the <i>inet_aton()</i>/<i>inet_ntoa()</i>
  routines of the Socket package.
<div class="Pp"></div>
Note that since Perl 5.8.1 the single-number v-strings (like &quot;v65&quot;)
  are not v-strings before the &quot;=&gt;&quot; operator (which is usually used
  to separate a hash key from a hash value); instead they are interpreted as
  literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0,
  but that caused more confusion and breakage than good. Multi-number v-strings
  like &quot;v65.66&quot; and 65.66.67 continue to be v-strings always.
<div class="Pp"></div>
<i>Special Literals</i>
<div class="Pp"></div>
The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current
  filename, line number, and package name at that point in your program. __SUB__
  gives a reference to the current subroutine. They may be used only as separate
  tokens; they will not be interpolated into strings. If there is no current
  package (due to an empty &quot;package;&quot; directive), __PACKAGE__ is the
  undefined value. (But the empty &quot;package;&quot; is no longer supported,
  as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value.
  __SUB__ is only available in 5.16 or higher, and only with a &quot;use
  v5.16&quot; or &quot;use feature &quot;current_sub&quot;&quot; declaration.
<div class="Pp"></div>
The two control characters ^D and ^Z, and the tokens __END__ and __DATA__ may be
  used to indicate the logical end of the script before the actual end of file.
  Any following text is ignored.
<div class="Pp"></div>
Text after __DATA__ may be read via the filehandle &quot;PACKNAME::DATA&quot;,
  where &quot;PACKNAME&quot; is the package that was current when the __DATA__
  token was encountered. The filehandle is left open pointing to the line after
  __DATA__. The program should &quot;close DATA&quot; when it is done reading
  from it. (Leaving it open leaks filehandles if the module is reloaded for any
  reason, so it's a safer practice to close it.) For compatibility with older
  scripts written before __DATA__ was introduced, __END__ behaves like __DATA__
  in the top level script (but not in files loaded with &quot;require&quot; or
  &quot;do&quot;) and leaves the remaining contents of the file accessible via
  &quot;main::DATA&quot;.
<div class="Pp"></div>
See SelfLoader for more description of __DATA__, and an example of its use. Note
  that you cannot read from the DATA filehandle in a BEGIN block: the BEGIN
  block is executed as soon as it is seen (during compilation), at which point
  the corresponding __DATA__ (or __END__) token has not yet been seen.
<div class="Pp"></div>
<i>Barewords</i>
<div class="Pp"></div>
A word that has no other interpretation in the grammar will be treated as if it
  were a quoted string. These are known as &quot;barewords&quot;. As with
  filehandles and labels, a bareword that consists entirely of lowercase letters
  risks conflict with future reserved words, and if you use the &quot;use
  warnings&quot; pragma or the <b>-w</b> switch, Perl will warn you about any
  such words. Perl limits barewords (like identifiers) to about 250 characters.
  Future versions of Perl are likely to eliminate these arbitrary limitations.
<div class="Pp"></div>
Some people may wish to outlaw barewords entirely. If you say
<div class="Pp"></div>
<pre>
    use strict 'subs';
</pre>
<div class="Pp"></div>
then any bareword that would NOT be interpreted as a subroutine call produces a
  compile-time error instead. The restriction lasts to the end of the enclosing
  block. An inner block may countermand this by saying &quot;no strict
  'subs'&quot;.
<div class="Pp"></div>
<i>Array Interpolation</i>
<div class="Pp"></div>
Arrays and slices are interpolated into double-quoted strings by joining the
  elements with the delimiter specified in the $&quot; variable ($LIST_SEPARATOR
  if &quot;use English;&quot; is specified), space by default. The following are
  equivalent:
<div class="Pp"></div>
<pre>
    $temp = join($&quot;, @ARGV);
    system &quot;echo $temp&quot;;
    system &quot;echo @ARGV&quot;;
</pre>
<div class="Pp"></div>
Within search patterns (which also undergo double-quotish substitution) there is
  an unfortunate ambiguity: Is &quot;/$foo[bar]/&quot; to be interpreted as
  &quot;/${foo}[bar]/&quot; (where &quot;[bar]&quot; is a character class for
  the regular expression) or as &quot;/${foo[bar]}/&quot; (where
  &quot;[bar]&quot; is the subscript to array @foo)? If @foo doesn't otherwise
  exist, then it's obviously a character class. If @foo exists, Perl takes a
  good guess about &quot;[bar]&quot;, and is almost always right. If it does
  guess wrong, or if you're just plain paranoid, you can force the correct
  interpretation with curly braces as above.
<div class="Pp"></div>
If you're looking for the information on how to use here-documents, which used
  to be here, that's been moved to &quot;Quote and Quote-like Operators&quot; in
  perlop.
<h2 class="Ss" title="Ss" id="List_value_constructors"><a class="selflink" href="#List_value_constructors">List
  value constructors</a></h2>
List values are denoted by separating individual values by commas (and enclosing
  the list in parentheses where precedence requires it):
<div class="Pp"></div>
<pre>
    (LIST)
</pre>
<div class="Pp"></div>
In a context not requiring a list value, the value of what appears to be a list
  literal is simply the value of the final element, as with the C comma
  operator. For example,
<div class="Pp"></div>
<pre>
    @foo = ('cc', '-E', $bar);
</pre>
<div class="Pp"></div>
assigns the entire list value to array @foo, but
<div class="Pp"></div>
<pre>
    $foo = ('cc', '-E', $bar);
</pre>
<div class="Pp"></div>
assigns the value of variable $bar to the scalar variable $foo. Note that the
  value of an actual array in scalar context is the length of the array; the
  following assigns the value 3 to $foo:
<div class="Pp"></div>
<pre>
    @foo = ('cc', '-E', $bar);
    $foo = @foo;                # $foo gets 3
</pre>
<div class="Pp"></div>
You may have an optional comma before the closing parenthesis of a list literal,
  so that you can say:
<div class="Pp"></div>
<pre>
    @foo = (
        1,
        2,
        3,
    );
</pre>
<div class="Pp"></div>
To use a here-document to assign an array, one line per element, you might use
  an approach like this:
<div class="Pp"></div>
<pre>
    @sauces = &lt;&lt;End_Lines =~ m/(\S.*\S)/g;
        normal tomato
        spicy tomato
        green chile
        pesto
        white wine
    End_Lines
</pre>
<div class="Pp"></div>
LISTs do automatic interpolation of sublists. That is, when a LIST is evaluated,
  each element of the list is evaluated in list context, and the resulting list
  value is interpolated into LIST just as if each individual element were a
  member of LIST. Thus arrays and hashes lose their identity in a LIST--the list
<div class="Pp"></div>
<pre>
    (@foo,@bar,&amp;SomeSub,%glarch)
</pre>
<div class="Pp"></div>
contains all the elements of @foo followed by all the elements of @bar, followed
  by all the elements returned by the subroutine named SomeSub called in list
  context, followed by the key/value pairs of %glarch. To make a list reference
  that does <i>NOT</i> interpolate, see perlref.
<div class="Pp"></div>
The null list is represented by (). Interpolating it in a list has no effect.
  Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no
  elements is the same as if no array had been interpolated at that point.
<div class="Pp"></div>
This interpolation combines with the facts that the opening and closing
  parentheses are optional (except when necessary for precedence) and lists may
  end with an optional comma to mean that multiple commas within lists are legal
  syntax. The list &quot;1,,3&quot; is a concatenation of two lists,
  &quot;1,&quot; and 3, the first of which ends with that optional comma.
  &quot;1,,3&quot; is &quot;(1,),(3)&quot; is &quot;1,3&quot; (And similarly for
  &quot;1,,,3&quot; is &quot;(1,),(,),3&quot; is &quot;1,3&quot; and so on.) Not
  that we'd advise you to use this obfuscation.
<div class="Pp"></div>
A list value may also be subscripted like a normal array. You must put the list
  in parentheses to avoid ambiguity. For example:
<div class="Pp"></div>
<pre>
    # Stat returns list value.
    $time = (stat($file))[8];
    # SYNTAX ERROR HERE.
    $time = stat($file)[8];  # OOPS, FORGOT PARENTHESES
    # Find a hex digit.
    $hexdigit = ('a','b','c','d','e','f')[$digit-10];
    # A &quot;reverse comma operator&quot;.
    return (pop(@foo),pop(@foo))[0];
</pre>
<div class="Pp"></div>
Lists may be assigned to only when each element of the list is itself legal to
  assign to:
<div class="Pp"></div>
<pre>
    ($a, $b, $c) = (1, 2, 3);
    ($map{'red'}, $map{'blue'}, $map{'green'}) = (0x00f, 0x0f0, 0xf00);
</pre>
<div class="Pp"></div>
An exception to this is that you may assign to &quot;undef&quot; in a list. This
  is useful for throwing away some of the return values of a function:
<div class="Pp"></div>
<pre>
    ($dev, $ino, undef, undef, $uid, $gid) = stat($file);
</pre>
<div class="Pp"></div>
List assignment in scalar context returns the number of elements produced by the
  expression on the right side of the assignment:
<div class="Pp"></div>
<pre>
    $x = (($foo,$bar) = (3,2,1));       # set $x to 3, not 2
    $x = (($foo,$bar) = f());           # set $x to f()'s return count
</pre>
<div class="Pp"></div>
This is handy when you want to do a list assignment in a Boolean context,
  because most list functions return a null list when finished, which when
  assigned produces a 0, which is interpreted as FALSE.
<div class="Pp"></div>
It's also the source of a useful idiom for executing a function or performing an
  operation in list context and then counting the number of return values, by
  assigning to an empty list and then using that assignment in scalar context.
  For example, this code:
<div class="Pp"></div>
<pre>
    $count = () = $string =~ /\d+/g;
</pre>
<div class="Pp"></div>
will place into $count the number of digit groups found in $string. This happens
  because the pattern match is in list context (since it is being assigned to
  the empty list), and will therefore return a list of all matching parts of the
  string. The list assignment in scalar context will translate that into the
  number of elements (here, the number of times the pattern matched) and assign
  that to $count. Note that simply using
<div class="Pp"></div>
<pre>
    $count = $string =~ /\d+/g;
</pre>
<div class="Pp"></div>
would not have worked, since a pattern match in scalar context will only return
  true or false, rather than a count of matches.
<div class="Pp"></div>
The final element of a list assignment may be an array or a hash:
<div class="Pp"></div>
<pre>
    ($a, $b, @rest) = split;
    my($a, $b, %rest) = @_;
</pre>
<div class="Pp"></div>
You can actually put an array or hash anywhere in the list, but the first one in
  the list will soak up all the values, and anything after it will become
  undefined. This may be useful in a <i>my()</i> or <i>local()</i>.
<div class="Pp"></div>
A hash can be initialized using a literal list holding pairs of items to be
  interpreted as a key and a value:
<div class="Pp"></div>
<pre>
    # same as map assignment above
    %map = ('red',0x00f,'blue',0x0f0,'green',0xf00);
</pre>
<div class="Pp"></div>
While literal lists and named arrays are often interchangeable, that's not the
  case for hashes. Just because you can subscript a list value like a normal
  array does not mean that you can subscript a list value as a hash. Likewise,
  hashes included as parts of other lists (including parameters lists and return
  lists from functions) always flatten out into key/value pairs. That's why it's
  good to use references sometimes.
<div class="Pp"></div>
It is often more readable to use the &quot;=&gt;&quot; operator between
  key/value pairs. The &quot;=&gt;&quot; operator is mostly just a more visually
  distinctive synonym for a comma, but it also arranges for its left-hand
  operand to be interpreted as a string if it's a bareword that would be a legal
  simple identifier. &quot;=&gt;&quot; doesn't quote compound identifiers, that
  contain double colons. This makes it nice for initializing hashes:
<div class="Pp"></div>
<pre>
    %map = (
                 red   =&gt; 0x00f,
                 blue  =&gt; 0x0f0,
                 green =&gt; 0xf00,
   );
</pre>
<div class="Pp"></div>
or for initializing hash references to be used as records:
<div class="Pp"></div>
<pre>
    $rec = {
                witch =&gt; 'Mable the Merciless',
                cat   =&gt; 'Fluffy the Ferocious',
                date  =&gt; '10/31/1776',
    };
</pre>
<div class="Pp"></div>
or for using call-by-named-parameter to complicated functions:
<div class="Pp"></div>
<pre>
   $field = $query-&gt;radio_group(
               name      =&gt; 'group_name',
               values    =&gt; ['eenie','meenie','minie'],
               default   =&gt; 'meenie',
               linebreak =&gt; 'true',
               labels    =&gt; \%labels
   );
</pre>
<div class="Pp"></div>
Note that just because a hash is initialized in that order doesn't mean that it
  comes out in that order. See &quot;sort&quot; in perlfunc for examples of how
  to arrange for an output ordering.
<h2 class="Ss" title="Ss" id="Subscripts"><a class="selflink" href="#Subscripts">Subscripts</a></h2>
An array can be accessed one scalar at a time by specifying a dollar sign
  (&quot;$&quot;), then the name of the array (without the leading
  &quot;@&quot;), then the subscript inside square brackets. For example:
<div class="Pp"></div>
<pre>
    @myarray = (5, 50, 500, 5000);
    print &quot;The Third Element is&quot;, $myarray[2], &quot;\n&quot;;
</pre>
<div class="Pp"></div>
The array indices start with 0. A negative subscript retrieves its value from
  the end. In our example, $myarray[-1] would have been 5000, and $myarray[-2]
  would have been 500.
<div class="Pp"></div>
Hash subscripts are similar, only instead of square brackets curly brackets are
  used. For example:
<div class="Pp"></div>
<pre>
    %scientists = 
    (
        &quot;Newton&quot; =&gt; &quot;Isaac&quot;,
        &quot;Einstein&quot; =&gt; &quot;Albert&quot;,
        &quot;Darwin&quot; =&gt; &quot;Charles&quot;,
        &quot;Feynman&quot; =&gt; &quot;Richard&quot;,
    );
    print &quot;Darwin's First Name is &quot;, $scientists{&quot;Darwin&quot;}, &quot;\n&quot;;
</pre>
<div class="Pp"></div>
You can also subscript a list to get a single element from it:
<div class="Pp"></div>
<pre>
    $dir = (getpwnam(&quot;daemon&quot;))[7];
</pre>
<h2 class="Ss" title="Ss" id="Multi-dimensional_array_emulation"><a class="selflink" href="#Multi-dimensional_array_emulation">Multi-dimensional
  array emulation</a></h2>
Multidimensional arrays may be emulated by subscripting a hash with a list. The
  elements of the list are joined with the subscript separator (see
  &quot;$;&quot; in perlvar).
<div class="Pp"></div>
<pre>
    $foo{$a,$b,$c}
</pre>
<div class="Pp"></div>
is equivalent to
<div class="Pp"></div>
<pre>
    $foo{join($;, $a, $b, $c)}
</pre>
<div class="Pp"></div>
The default subscript separator is &quot;\034&quot;, the same as SUBSEP in
  <b>awk</b>.
<h2 class="Ss" title="Ss" id="Slices"><a class="selflink" href="#Slices">Slices</a></h2>
A slice accesses several elements of a list, an array, or a hash simultaneously
  using a list of subscripts. It's more convenient than writing out the
  individual elements as a list of separate scalar values.
<div class="Pp"></div>
<pre>
    ($him, $her)   = @folks[0,-1];              # array slice
    @them          = @folks[0 .. 3];            # array slice
    ($who, $home)  = @ENV{&quot;USER&quot;, &quot;HOME&quot;};      # hash slice
    ($uid, $dir)   = (getpwnam(&quot;daemon&quot;))[2,7]; # list slice
</pre>
<div class="Pp"></div>
Since you can assign to a list of variables, you can also assign to an array or
  hash slice.
<div class="Pp"></div>
<pre>
    @days[3..5]    = qw/Wed Thu Fri/;
    @colors{'red','blue','green'} 
                   = (0xff0000, 0x0000ff, 0x00ff00);
    @folks[0, -1]  = @folks[-1, 0];
</pre>
<div class="Pp"></div>
The previous assignments are exactly equivalent to
<div class="Pp"></div>
<pre>
    ($days[3], $days[4], $days[5]) = qw/Wed Thu Fri/;
    ($colors{'red'}, $colors{'blue'}, $colors{'green'})
                   = (0xff0000, 0x0000ff, 0x00ff00);
    ($folks[0], $folks[-1]) = ($folks[-1], $folks[0]);
</pre>
<div class="Pp"></div>
Since changing a slice changes the original array or hash that it's slicing, a
  &quot;foreach&quot; construct will alter some--or even all--of the values of
  the array or hash.
<div class="Pp"></div>
<pre>
    foreach (@array[ 4 .. 10 ]) { s/peter/paul/ } 
    foreach (@hash{qw[key1 key2]}) {
        s/^\s+//;           # trim leading whitespace
        s/\s+$//;           # trim trailing whitespace
        s/(\w+)/\u\L$1/g;   # &quot;titlecase&quot; words
    }
</pre>
<div class="Pp"></div>
A slice of an empty list is still an empty list. Thus:
<div class="Pp"></div>
<pre>
    @a = ()[1,0];           # @a has no elements
    @b = (@a)[0,1];         # @b has no elements
    @c = (0,1)[2,3];        # @c has no elements
</pre>
<div class="Pp"></div>
But:
<div class="Pp"></div>
<pre>
    @a = (1)[1,0];          # @a has two elements
    @b = (1,undef)[1,0,2];  # @b has three elements
</pre>
<div class="Pp"></div>
This makes it easy to write loops that terminate when a null list is returned:
<div class="Pp"></div>
<pre>
    while ( ($home, $user) = (getpwent)[7,0]) {
        printf &quot;%-8s %s\n&quot;, $user, $home;
    }
</pre>
<div class="Pp"></div>
As noted earlier in this document, the scalar sense of list assignment is the
  number of elements on the right-hand side of the assignment. The null list
  contains no elements, so when the password file is exhausted, the result is 0,
  not 2.
<div class="Pp"></div>
Slices in scalar context return the last item of the slice.
<div class="Pp"></div>
<pre>
    @a = qw/first second third/;
    %h = (first =&gt; 'A', second =&gt; 'B');
    $t = @a[0, 1];                  # $t is now 'second'
    $u = @h{'first', 'second'};     # $u is now 'B'
</pre>
<div class="Pp"></div>
If you're confused about why you use an '@' there on a hash slice instead of a
  '%', think of it like this. The type of bracket (square or curly) governs
  whether it's an array or a hash being looked at. On the other hand, the
  leading symbol ('$' or '@') on the array or hash indicates whether you are
  getting back a singular value (a scalar) or a plural one (a list).
<h2 class="Ss" title="Ss" id="Typeglobs_and_Filehandles"><a class="selflink" href="#Typeglobs_and_Filehandles">Typeglobs
  and Filehandles</a></h2>
Perl uses an internal type called a <i>typeglob</i> to hold an entire symbol
  table entry. The type prefix of a typeglob is a &quot;*&quot;, because it
  represents all types. This used to be the preferred way to pass arrays and
  hashes by reference into a function, but now that we have real references,
  this is seldom needed.
<div class="Pp"></div>
The main use of typeglobs in modern Perl is create symbol table aliases. This
  assignment:
<div class="Pp"></div>
<pre>
    *this = *that;
</pre>
<div class="Pp"></div>
makes $this an alias for $that, @this an alias for @that, %this an alias for
  %that, &amp;this an alias for &amp;that, etc. Much safer is to use a
  reference. This:
<div class="Pp"></div>
<pre>
    local *Here::blue = \$There::green;
</pre>
<div class="Pp"></div>
temporarily makes $Here::blue an alias for $There::green, but doesn't make
  @Here::blue an alias for @There::green, or %Here::blue an alias for
  %There::green, etc. See &quot;Symbol Tables&quot; in perlmod for more examples
  of this. Strange though this may seem, this is the basis for the whole module
  import/export system.
<div class="Pp"></div>
Another use for typeglobs is to pass filehandles into a function or to create
  new filehandles. If you need to use a typeglob to save away a filehandle, do
  it this way:
<div class="Pp"></div>
<pre>
    $fh = *STDOUT;
</pre>
<div class="Pp"></div>
or perhaps as a real reference, like this:
<div class="Pp"></div>
<pre>
    $fh = \*STDOUT;
</pre>
<div class="Pp"></div>
See perlsub for examples of using these as indirect filehandles in functions.
<div class="Pp"></div>
Typeglobs are also a way to create a local filehandle using the <i>local()</i>
  operator. These last until their block is exited, but may be passed back. For
  example:
<div class="Pp"></div>
<pre>
    sub newopen {
        my $path = shift;
        local  *FH;  # not my!
        open   (FH, $path)          or  return undef;
        return *FH;
    }
    $fh = newopen('/etc/passwd');
</pre>
<div class="Pp"></div>
Now that we have the *foo{THING} notation, typeglobs aren't used as much for
  filehandle manipulations, although they're still needed to pass brand new file
  and directory handles into or out of functions. That's because *HANDLE{IO}
  only works if HANDLE has already been used as a handle. In other words, *FH
  must be used to create new symbol table entries; *foo{THING} cannot. When in
  doubt, use *FH.
<div class="Pp"></div>
All functions that are capable of creating filehandles ( <i>open()</i>,
  <i>opendir()</i>, <i>pipe()</i>, <i>socketpair()</i>, <i>sysopen()</i>,
  <i>socket()</i>, and <i>accept()</i>) automatically create an anonymous
  filehandle if the handle passed to them is an uninitialized scalar variable.
  This allows the constructs such as &quot;open(my $fh, ...)&quot; and
  &quot;open(local $fh,...)&quot; to be used to create filehandles that will
  conveniently be closed automatically when the scope ends, provided there are
  no other references to them. This largely eliminates the need for typeglobs
  when opening filehandles that must be passed around, as in the following
  example:
<div class="Pp"></div>
<pre>
    sub myopen {
        open my $fh, &quot;@_&quot;
             or die &quot;Can't open '@_': $!&quot;;
        return $fh;
    }
    {
        my $f = myopen(&quot;&lt;/etc/motd&quot;);
        print &lt;$f&gt;;
        # $f implicitly closed here
    }
</pre>
<div class="Pp"></div>
Note that if an initialized scalar variable is used instead the result is
  different: &quot;my $fh='zzz'; open($fh, ...)&quot; is equivalent to
  &quot;open( *{'zzz'}, ...)&quot;. &quot;use strict 'refs'&quot; forbids such
  practice.
<div class="Pp"></div>
Another way to create anonymous filehandles is with the Symbol module or with
  the IO::Handle module and its ilk. These modules have the advantage of not
  hiding different types of the same name during the <i>local()</i>. See the
  bottom of &quot;open&quot; in perlfunc for an example.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
See perlvar for a description of Perl's built-in variables and a discussion of
  legal variable names. See perlref, perlsub, and &quot;Symbol Tables&quot; in
  perlmod for more discussion on typeglobs and the *foo{THING} syntax.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
