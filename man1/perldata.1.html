<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:46 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLDATA(1) Perl Programmers Reference Guide
PERLDATA(1)</p>

<p style="margin-top: 1em">NAME <br>
perldata - Perl data types</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Variable names <br>
Perl has three built-in data types: scalars, arrays of
scalars, and associative arrays of scalars, known as
&quot;hashes&quot;. A scalar is a single string (of any
size, limited only by <br>
the available memory), number, or a reference to something
(which will be discussed in perlref). Normal arrays are
ordered lists of scalars indexed by number, starting with 0.
<br>
Hashes are unordered collections of scalar values indexed by
their associated string key.</p>

<p style="margin-top: 1em">Values are usually referred to
by name, or through a named reference. The first character
of the name tells you to what sort of data structure it
refers. The rest of the name <br>
tells you the particular value to which it refers. Usually
this name is a single identifier, that is, a string
beginning with a letter or underscore, and containing
letters, <br>
underscores, and digits. In some cases, it may be a chain of
identifiers, separated by &quot;::&quot; (or by the slightly
archaic &quot;&rsquo;&quot;); all but the last are
interpreted as names of <br>
packages, to locate the namespace in which to look up the
final identifier (see &quot;Packages&quot; in perlmod for
details). It&rsquo;s possible to substitute for a simple
identifier, an <br>
expression that produces a reference to the value at
runtime. This is described in more detail below and in
perlref.</p>

<p style="margin-top: 1em">Perl also has its own built-in
variables whose names don&rsquo;t follow these rules. They
have strange names so they don&rsquo;t accidentally collide
with one of your normal variables. <br>
Strings that match parenthesized parts of a regular
expression are saved under names containing only digits
after the &quot;$&quot; (see perlop and perlre). In
addition, several special <br>
variables that provide windows into the inner working of
Perl have names containing punctuation characters and
control characters. These are documented in perlvar.</p>

<p style="margin-top: 1em">Scalar values are always named
with &rsquo;$&rsquo;, even when referring to a scalar that
is part of an array or a hash. The &rsquo;$&rsquo; symbol
works semantically like the English word &quot;the&quot; in
<br>
that it indicates a single value is expected.</p>

<p style="margin-top: 1em">$days # the simple scalar value
&quot;days&quot; <br>
$days[28] # the 29th element of array @days <br>
$days{&rsquo;Feb&rsquo;} # the &rsquo;Feb&rsquo; value from
hash %days <br>
$#days # the last index of array @days</p>

<p style="margin-top: 1em">Entire arrays (and slices of
arrays and hashes) are denoted by &rsquo;@&rsquo;, which
works much as the word &quot;these&quot; or
&quot;those&quot; does in English, in that it indicates
multiple values are <br>
expected.</p>

<p style="margin-top: 1em">@days # ($days[0], $days[1],...
$days[n]) <br>
@days[3,4,5] # same as ($days[3],$days[4],$days[5]) <br>
@days{&rsquo;a&rsquo;,&rsquo;c&rsquo;} # same as
($days{&rsquo;a&rsquo;},$days{&rsquo;c&rsquo;})</p>

<p style="margin-top: 1em">Entire hashes are denoted by
&rsquo;%&rsquo;:</p>

<p style="margin-top: 1em">%days # (key1, val1, key2, val2
...)</p>

<p style="margin-top: 1em">In addition, subroutines are
named with an initial &rsquo;&amp;&rsquo;, though this is
optional when unambiguous, just as the word &quot;do&quot;
is often redundant in English. Symbol table entries can <br>
be named with an initial &rsquo;*&rsquo;, but you
don&rsquo;t really care about that yet (if ever :-).</p>

<p style="margin-top: 1em">Every variable type has its own
namespace, as do several non-variable identifiers. This
means that you can, without fear of conflict, use the same
name for a scalar variable, an <br>
array, or a hash--or, for that matter, for a filehandle, a
directory handle, a subroutine name, a format name, or a
label. This means that $foo and @foo are two different <br>
variables. It also means that $foo[1] is a part of @foo, not
a part of $foo. This may seem a bit weird, but that&rsquo;s
okay, because it is weird.</p>

<p style="margin-top: 1em">Because variable references
always start with &rsquo;$&rsquo;, &rsquo;@&rsquo;, or
&rsquo;%&rsquo;, the &quot;reserved&quot; words aren&rsquo;t
in fact reserved with respect to variable names. They are
reserved with respect to <br>
labels and filehandles, however, which don&rsquo;t have an
initial special character. You can&rsquo;t have a filehandle
named &quot;log&quot;, for instance. Hint: you could say
&quot;open(LOG,&rsquo;logfile&rsquo;)&quot; <br>
rather than &quot;open(log,&rsquo;logfile&rsquo;)&quot;.
Using uppercase filehandles also improves readability and
protects you from conflict with future reserved words. Case
is significant--&quot;FOO&quot;, <br>
&quot;Foo&quot;, and &quot;foo&quot; are all different
names. Names that start with a letter or underscore may also
contain digits and underscores.</p>

<p style="margin-top: 1em">It is possible to replace such
an alphanumeric name with an expression that returns a
reference to the appropriate type. For a description of
this, see perlref.</p>

<p style="margin-top: 1em">Names that start with a digit
may contain only more digits. Names that do not start with a
letter, underscore, digit or a caret (i.e. a control
character) are limited to one <br>
character, e.g., $% or $$. (Most of these one character
names have a predefined significance to Perl. For instance,
$$ is the current process id.)</p>

<p style="margin-top: 1em">Context <br>
The interpretation of operations and values in Perl
sometimes depends on the requirements of the context around
the operation or value. There are two major contexts: list
and <br>
scalar. Certain operations return list values in contexts
wanting a list, and scalar values otherwise. If this is true
of an operation it will be mentioned in the documentation
<br>
for that operation. In other words, Perl overloads certain
operations based on whether the expected return value is
singular or plural. Some words in English work this way,
<br>
like &quot;fish&quot; and &quot;sheep&quot;.</p>

<p style="margin-top: 1em">In a reciprocal fashion, an
operation provides either a scalar or a list context to each
of its arguments. For example, if you say</p>

<p style="margin-top: 1em">int( &lt;STDIN&gt; )</p>

<p style="margin-top: 1em">the integer operation provides
scalar context for the &lt;&gt; operator, which responds by
reading one line from STDIN and passing it back to the
integer operation, which will then <br>
find the integer value of that line and return that. If, on
the other hand, you say</p>

<p style="margin-top: 1em">sort( &lt;STDIN&gt; )</p>

<p style="margin-top: 1em">then the sort operation provides
list context for &lt;&gt;, which will proceed to read every
line available up to the end of file, and pass that list of
lines back to the sort routine, <br>
which will then sort those lines and return them as a list
to whatever the context of the sort was.</p>

<p style="margin-top: 1em">Assignment is a little bit
special in that it uses its left argument to determine the
context for the right argument. Assignment to a scalar
evaluates the right-hand side in <br>
scalar context, while assignment to an array or hash
evaluates the righthand side in list context. Assignment to
a list (or slice, which is just a list anyway) also
evaluates <br>
the right-hand side in list context.</p>

<p style="margin-top: 1em">When you use the &quot;use
warnings&quot; pragma or Perl&rsquo;s -w command-line
option, you may see warnings about useless uses of constants
or functions in &quot;void context&quot;. Void context just
<br>
means the value has been discarded, such as a statement
containing only &quot;&quot;fred&quot;;&quot; or
&quot;getpwuid(0);&quot;. It still counts as scalar context
for functions that care whether or not <br>
they&rsquo;re being called in list context.</p>

<p style="margin-top: 1em">User-defined subroutines may
choose to care whether they are being called in a void,
scalar, or list context. Most subroutines do not need to
bother, though. That&rsquo;s because <br>
both scalars and lists are automatically interpolated into
lists. See &quot;wantarray&quot; in perlfunc for how you
would dynamically discern your function&rsquo;s calling
context.</p>

<p style="margin-top: 1em">Scalar values <br>
All data in Perl is a scalar, an array of scalars, or a hash
of scalars. A scalar may contain one single value in any of
three different flavors: a number, a string, or a <br>
reference. In general, conversion from one form to another
is transparent. Although a scalar may not directly hold
multiple values, it may contain a reference to an array or
<br>
hash which in turn contains multiple values.</p>

<p style="margin-top: 1em">Scalars aren&rsquo;t necessarily
one thing or another. There&rsquo;s no place to declare a
scalar variable to be of type &quot;string&quot;, type
&quot;number&quot;, type &quot;reference&quot;, or anything
else. <br>
Because of the automatic conversion of scalars, operations
that return scalars don&rsquo;t need to care (and in fact,
cannot care) whether their caller is looking for a string, a
<br>
number, or a reference. Perl is a contextually polymorphic
language whose scalars can be strings, numbers, or
references (which includes objects). Although strings and
numbers <br>
are considered pretty much the same thing for nearly all
purposes, references are strongly-typed, uncastable pointers
with builtin reference-counting and destructor
invocation.</p>

<p style="margin-top: 1em">A scalar value is interpreted as
FALSE in the Boolean sense if it is undefined, the null
string or the number 0 (or its string equivalent,
&quot;0&quot;), and TRUE if it is anything else. <br>
The Boolean context is just a special kind of scalar context
where no conversion to a string or a number is ever
performed.</p>

<p style="margin-top: 1em">There are actually two varieties
of null strings (sometimes referred to as &quot;empty&quot;
strings), a defined one and an undefined one. The defined
version is just a string of length <br>
zero, such as &quot;&quot;. The undefined version is the
value that indicates that there is no real value for
something, such as when there was an error, or at end of
file, or when you <br>
refer to an uninitialized variable or element of an array or
hash. Although in early versions of Perl, an undefined
scalar could become defined when first used in a place <br>
expecting a defined value, this no longer happens except for
rare cases of autovivification as explained in perlref. You
can use the defined() operator to determine whether a <br>
scalar value is defined (this has no meaning on arrays or
hashes), and the undef() operator to produce an undefined
value.</p>

<p style="margin-top: 1em">To find out whether a given
string is a valid non-zero number, it&rsquo;s sometimes
enough to test it against both numeric 0 and also lexical
&quot;0&quot; (although this will cause noises if <br>
warnings are on). That&rsquo;s because strings that
aren&rsquo;t numbers count as 0, just as they do in awk:</p>

<p style="margin-top: 1em">if ($str == 0 &amp;&amp; $str ne
&quot;0&quot;) { <br>
warn &quot;That doesn&rsquo;t look like a number&quot;; <br>
}</p>

<p style="margin-top: 1em">That method may be best because
otherwise you won&rsquo;t treat IEEE notations like
&quot;NaN&quot; or &quot;Infinity&quot; properly. At other
times, you might prefer to determine whether string data can
<br>
be used numerically by calling the POSIX::strtod() function
or by inspecting your string with a regular expression (as
documented in perlre).</p>

<p style="margin-top: 1em">warn &quot;has nondigits&quot;
if / warn &quot;not a natural number&quot; unless /^+$/; #
rejects -3 <br>
warn &quot;not an integer&quot; unless /^-?+$/; # rejects +3
<br>
warn &quot;not an integer&quot; unless /^[+-]?+$/; <br>
warn &quot;not a decimal number&quot; unless /^-?+.?*$/; #
rejects .2 <br>
warn &quot;not a decimal number&quot; unless
/^-?(?:+(?:.*)?|.+)$/; <br>
warn &quot;not a C float&quot; <br>
unless /^([+-]?)(?=|.)*(.*)?([Ee]([+-]?+))?$/;</p>

<p style="margin-top: 1em">The length of an array is a
scalar value. You may find the length of array @days by
evaluating $#days, as in csh. However, this isn&rsquo;t the
length of the array; it&rsquo;s the <br>
subscript of the last element, which is a different value
since there is ordinarily a 0th element. Assigning to $#days
actually changes the length of the array. Shortening an <br>
array this way destroys intervening values. Lengthening an
array that was previously shortened does not recover values
that were in those elements. (It used to do so in Perl 4,
<br>
but we had to break this to make sure destructors were
called when expected.)</p>

<p style="margin-top: 1em">You can also gain some minuscule
measure of efficiency by pre-extending an array that is
going to get big. You can also extend an array by assigning
to an element that is off <br>
the end of the array. You can truncate an array down to
nothing by assigning the null list () to it. The following
are equivalent:</p>

<p style="margin-top: 1em">@whatever = (); <br>
$#whatever = -1;</p>

<p style="margin-top: 1em">If you evaluate an array in
scalar context, it returns the length of the array. (Note
that this is not true of lists, which return the last value,
like the C comma operator, nor <br>
of built-in functions, which return whatever they feel like
returning.) The following is always true:</p>

<p style="margin-top: 1em">scalar(@whatever) == $#whatever
+ 1;</p>

<p style="margin-top: 1em">Some programmers choose to use
an explicit conversion so as to leave nothing to doubt:</p>

<p style="margin-top: 1em">$element_count =
scalar(@whatever);</p>

<p style="margin-top: 1em">If you evaluate a hash in scalar
context, it returns false if the hash is empty. If there are
any key/value pairs, it returns true; more precisely, the
value returned is a <br>
string consisting of the number of used buckets and the
number of allocated buckets, separated by a slash. This is
pretty much useful only to find out whether Perl&rsquo;s
internal <br>
hashing algorithm is performing poorly on your data set. For
example, you stick 10,000 things in a hash, but evaluating
%HASH in scalar context reveals &quot;1/16&quot;, which
means only <br>
one out of sixteen buckets has been touched, and presumably
contains all 10,000 of your items. This isn&rsquo;t supposed
to happen. If a tied hash is evaluated in scalar context,
the <br>
&quot;SCALAR&quot; method is called (with a fallback to
&quot;FIRSTKEY&quot;).</p>

<p style="margin-top: 1em">You can preallocate space for a
hash by assigning to the keys() function. This rounds up the
allocated buckets to the next power of two:</p>

<p style="margin-top: 1em">keys(%users) = 1000; # allocate
1024 buckets</p>

<p style="margin-top: 1em">Scalar value constructors <br>
Numeric literals are specified in any of the following
floating point or integer formats:</p>

<p style="margin-top: 1em">12345 <br>
12345.67 <br>
.23E-10 # a very small number <br>
3.14_15_92 # a very important number <br>
4_294_967_296 # underscore for legibility <br>
0xff # hex <br>
0xdead_beef # more hex <br>
0377 # octal (only numbers, begins with 0) <br>
0b011011 # binary</p>

<p style="margin-top: 1em">You are allowed to use
underscores (underbars) in numeric literals between digits
for legibility (but not multiple underscores in a row:
&quot;23__500&quot; is not legal; &quot;23_500&quot; is).
<br>
You could, for example, group binary digits by threes (as
for a Unix-style mode argument such as 0b110_100_100) or by
fours (to represent nibbles, as in 0b1010_0110) or in other
<br>
groups.</p>

<p style="margin-top: 1em">String literals are usually
delimited by either single or double quotes. They work much
like quotes in the standard Unix shells: double-quoted
string literals are subject to <br>
backslash and variable substitution; single-quoted strings
are not (except for &quot;&acute;&quot; and &quot;\&quot;).
The usual C-style backslash rules apply for making
characters such as newline, <br>
tab, etc., as well as some more exotic forms. See
&quot;Quote and Quote-like Operators&quot; in perlop for a
list.</p>

<p style="margin-top: 1em">Hexadecimal, octal, or binary,
representations in string literals (e.g. &rsquo;0xff&rsquo;)
are not automatically converted to their integer
representation. The hex() and oct() functions <br>
make these conversions for you. See &quot;hex&quot; in
perlfunc and &quot;oct&quot; in perlfunc for more
details.</p>

<p style="margin-top: 1em">You can also embed newlines
directly in your strings, i.e., they can end on a different
line than they begin. This is nice, but if you forget your
trailing quote, the error will <br>
not be reported until Perl finds another line containing the
quote character, which may be much further on in the script.
Variable substitution inside strings is limited to <br>
scalar variables, arrays, and array or hash slices. (In
other words, names beginning with $ or @, followed by an
optional bracketed expression as a subscript.) The following
<br>
code segment prints out &quot;The price is $100.&quot;</p>

<p style="margin-top: 1em">$Price = &rsquo;$100&rsquo;; #
not interpolated <br>
print &quot;The price is $Price.0; # interpolated</p>

<p style="margin-top: 1em">There is no double interpolation
in Perl, so the $100 is left as is.</p>

<p style="margin-top: 1em">By default floating point
numbers substituted inside strings use the dot
(&quot;.&quot;) as the decimal separator. If &quot;use
locale&quot; is in effect, and POSIX::setlocale() has been
called, <br>
the character used for the decimal separator is affected by
the LC_NUMERIC locale. See perllocale and POSIX.</p>

<p style="margin-top: 1em">As in some shells, you can
enclose the variable name in braces to disambiguate it from
following alphanumerics (and underscores). You must also do
this when interpolating a <br>
variable into a string to separate the variable name from a
following double-colon or an apostrophe, since these would
be otherwise treated as a package separator:</p>

<p style="margin-top: 1em">$who = &quot;Larry&quot;; <br>
print PASSWD &quot;${who}::0:0:Superuser:/:/bin/perl0; <br>
print &quot;We use ${who}speak when ${who}&rsquo;s
here.0;</p>

<p style="margin-top: 1em">Without the braces, Perl would
have looked for a $whospeak, a $who::0, and a
&quot;$who&rsquo;s&quot; variable. The last two would be the
$0 and the $s variables in the (presumably) non- <br>
existent package &quot;who&quot;.</p>

<p style="margin-top: 1em">In fact, an identifier within
such curlies is forced to be a string, as is any simple
identifier within a hash subscript. Neither need quoting.
Our earlier example, <br>
$days{&rsquo;Feb&rsquo;} can be written as $days{Feb} and
the quotes will be assumed automatically. But anything more
complicated in the subscript will be interpreted as an
expression. <br>
This means for example that &quot;$version{2.0}++&quot; is
equivalent to &quot;$version{2}++&quot;, not to
&quot;$version{&rsquo;2.0&rsquo;}++&quot;.</p>

<p style="margin-top: 1em">Version Strings</p>

<p style="margin-top: 1em">A literal of the form
&quot;v1.20.300.4000&quot; is parsed as a string composed of
characters with the specified ordinals. This form, known as
v-strings, provides an alternative, more <br>
readable way to construct strings, rather than use the
somewhat less readable interpolation form &quot;a0}&quot;.
This is useful for representing Unicode strings, <br>
and for comparing version &quot;numbers&quot; using the
string comparison operators, &quot;cmp&quot;,
&quot;gt&quot;, &quot;lt&quot; etc. If there are two or more
dots in the literal, the leading &quot;v&quot; may be
omitted.</p>

<p style="margin-top: 1em">print v9786; # prints SMILEY,
&quot;}&quot; <br>
print v102.111.111; # prints &quot;foo&quot; <br>
print 102.111.111; # same</p>

<p style="margin-top: 1em">Such literals are accepted by
both &quot;require&quot; and &quot;use&quot; for doing a
version check. Note that using the v-strings for IPv4
addresses is not portable unless you also use the <br>
inet_aton()/inet_ntoa() routines of the Socket package.</p>

<p style="margin-top: 1em">Note that since Perl 5.8.1 the
single-number v-strings (like &quot;v65&quot;) are not
v-strings before the &quot;=&gt;&quot; operator (which is
usually used to separate a hash key from a hash value); <br>
instead they are interpreted as literal strings
(&rsquo;v65&rsquo;). They were v-strings from Perl 5.6.0 to
Perl 5.8.0, but that caused more confusion and breakage than
good. Multi-number <br>
v-strings like &quot;v65.66&quot; and 65.66.67 continue to
be v-strings always.</p>

<p style="margin-top: 1em">Special Literals</p>

<p style="margin-top: 1em">The special literals __FILE__,
__LINE__, and __PACKAGE__ represent the current filename,
line number, and package name at that point in your program.
__SUB__ gives a reference <br>
to the current subroutine. They may be used only as separate
tokens; they will not be interpolated into strings. If there
is no current package (due to an empty &quot;package;&quot;
<br>
directive), __PACKAGE__ is the undefined value. (But the
empty &quot;package;&quot; is no longer supported, as of
version 5.10.) Outside of a subroutine, __SUB__ is the
undefined value. <br>
__SUB__ is only available in 5.16 or higher, and only with a
&quot;use v5.16&quot; or &quot;use feature
&quot;current_sub&quot;&quot; declaration.</p>

<p style="margin-top: 1em">The two control characters ^D
and ^Z, and the tokens __END__ and __DATA__ may be used to
indicate the logical end of the script before the actual end
of file. Any following text <br>
is ignored.</p>

<p style="margin-top: 1em">Text after __DATA__ may be read
via the filehandle &quot;PACKNAME::DATA&quot;, where
&quot;PACKNAME&quot; is the package that was current when
the __DATA__ token was encountered. The filehandle is <br>
left open pointing to the line after __DATA__. The program
should &quot;close DATA&quot; when it is done reading from
it. (Leaving it open leaks filehandles if the module is
reloaded for <br>
any reason, so it&rsquo;s a safer practice to close it.) For
compatibility with older scripts written before __DATA__ was
introduced, __END__ behaves like __DATA__ in the top level
<br>
script (but not in files loaded with &quot;require&quot; or
&quot;do&quot;) and leaves the remaining contents of the
file accessible via &quot;main::DATA&quot;.</p>

<p style="margin-top: 1em">See SelfLoader for more
description of __DATA__, and an example of its use. Note
that you cannot read from the DATA filehandle in a BEGIN
block: the BEGIN block is executed as <br>
soon as it is seen (during compilation), at which point the
corresponding __DATA__ (or __END__) token has not yet been
seen.</p>

<p style="margin-top: 1em">Barewords</p>

<p style="margin-top: 1em">A word that has no other
interpretation in the grammar will be treated as if it were
a quoted string. These are known as &quot;barewords&quot;.
As with filehandles and labels, a bareword <br>
that consists entirely of lowercase letters risks conflict
with future reserved words, and if you use the &quot;use
warnings&quot; pragma or the -w switch, Perl will warn you
about any <br>
such words. Perl limits barewords (like identifiers) to
about 250 characters. Future versions of Perl are likely to
eliminate these arbitrary limitations.</p>

<p style="margin-top: 1em">Some people may wish to outlaw
barewords entirely. If you say</p>

<p style="margin-top: 1em">use strict
&rsquo;subs&rsquo;;</p>

<p style="margin-top: 1em">then any bareword that would NOT
be interpreted as a subroutine call produces a compile-time
error instead. The restriction lasts to the end of the
enclosing block. An inner <br>
block may countermand this by saying &quot;no strict
&rsquo;subs&rsquo;&quot;.</p>

<p style="margin-top: 1em">Array Interpolation</p>

<p style="margin-top: 1em">Arrays and slices are
interpolated into double-quoted strings by joining the
elements with the delimiter specified in the $&quot;
variable ($LIST_SEPARATOR if &quot;use English;&quot; is
<br>
specified), space by default. The following are
equivalent:</p>

<p style="margin-top: 1em">$temp = join($&quot;, @ARGV);
<br>
system &quot;echo $temp&quot;;</p>

<p style="margin-top: 1em">system &quot;echo
@ARGV&quot;;</p>

<p style="margin-top: 1em">Within search patterns (which
also undergo double-quotish substitution) there is an
unfortunate ambiguity: Is &quot;/$foo[bar]/&quot; to be
interpreted as &quot;/${foo}[bar]/&quot; (where
&quot;[bar]&quot; <br>
is a character class for the regular expression) or as
&quot;/${foo[bar]}/&quot; (where &quot;[bar]&quot; is the
subscript to array @foo)? If @foo doesn&rsquo;t otherwise
exist, then it&rsquo;s obviously a <br>
character class. If @foo exists, Perl takes a good guess
about &quot;[bar]&quot;, and is almost always right. If it
does guess wrong, or if you&rsquo;re just plain paranoid,
you can force the <br>
correct interpretation with curly braces as above.</p>

<p style="margin-top: 1em">If you&rsquo;re looking for the
information on how to use here-documents, which used to be
here, that&rsquo;s been moved to &quot;Quote and Quote-like
Operators&quot; in perlop.</p>

<p style="margin-top: 1em">List value constructors <br>
List values are denoted by separating individual values by
commas (and enclosing the list in parentheses where
precedence requires it):</p>

<p style="margin-top: 1em">(LIST)</p>

<p style="margin-top: 1em">In a context not requiring a
list value, the value of what appears to be a list literal
is simply the value of the final element, as with the C
comma operator. For example,</p>

<p style="margin-top: 1em">@foo = (&rsquo;cc&rsquo;,
&rsquo;-E&rsquo;, $bar);</p>

<p style="margin-top: 1em">assigns the entire list value to
array @foo, but</p>

<p style="margin-top: 1em">$foo = (&rsquo;cc&rsquo;,
&rsquo;-E&rsquo;, $bar);</p>

<p style="margin-top: 1em">assigns the value of variable
$bar to the scalar variable $foo. Note that the value of an
actual array in scalar context is the length of the array;
the following assigns the <br>
value 3 to $foo:</p>

<p style="margin-top: 1em">@foo = (&rsquo;cc&rsquo;,
&rsquo;-E&rsquo;, $bar); <br>
$foo = @foo; # $foo gets 3</p>

<p style="margin-top: 1em">You may have an optional comma
before the closing parenthesis of a list literal, so that
you can say:</p>

<p style="margin-top: 1em">@foo = ( <br>
1, <br>
2, <br>
3, <br>
);</p>

<p style="margin-top: 1em">To use a here-document to assign
an array, one line per element, you might use an approach
like this:</p>

<p style="margin-top: 1em">@sauces = &lt;&lt;End_Lines =~
m/(*/g; <br>
normal tomato <br>
spicy tomato <br>
green chile <br>
pesto <br>
white wine <br>
End_Lines</p>

<p style="margin-top: 1em">LISTs do automatic interpolation
of sublists. That is, when a LIST is evaluated, each element
of the list is evaluated in list context, and the resulting
list value is <br>
interpolated into LIST just as if each individual element
were a member of LIST. Thus arrays and hashes lose their
identity in a LIST--the list</p>


<p style="margin-top: 1em">(@foo,@bar,&amp;SomeSub,%glarch)</p>

<p style="margin-top: 1em">contains all the elements of
@foo followed by all the elements of @bar, followed by all
the elements returned by the subroutine named SomeSub called
in list context, followed by <br>
the key/value pairs of %glarch. To make a list reference
that does NOT interpolate, see perlref.</p>

<p style="margin-top: 1em">The null list is represented by
(). Interpolating it in a list has no effect. Thus
((),(),()) is equivalent to (). Similarly, interpolating an
array with no elements is the <br>
same as if no array had been interpolated at that point.</p>

<p style="margin-top: 1em">This interpolation combines with
the facts that the opening and closing parentheses are
optional (except when necessary for precedence) and lists
may end with an optional comma <br>
to mean that multiple commas within lists are legal syntax.
The list &quot;1,,3&quot; is a concatenation of two lists,
&quot;1,&quot; and 3, the first of which ends with that
optional comma. &quot;1,,3&quot; <br>
is &quot;(1,),(3)&quot; is &quot;1,3&quot; (And similarly
for &quot;1,,,3&quot; is &quot;(1,),(,),3&quot; is
&quot;1,3&quot; and so on.) Not that we&rsquo;d advise you
to use this obfuscation.</p>

<p style="margin-top: 1em">A list value may also be
subscripted like a normal array. You must put the list in
parentheses to avoid ambiguity. For example:</p>

<p style="margin-top: 1em"># Stat returns list value. <br>
$time = (stat($file))[8];</p>

<p style="margin-top: 1em"># SYNTAX ERROR HERE. <br>
$time = stat($file)[8]; # OOPS, FORGOT PARENTHESES</p>

<p style="margin-top: 1em"># Find a hex digit. <br>
$hexdigit =
(&rsquo;a&rsquo;,&rsquo;b&rsquo;,&rsquo;c&rsquo;,&rsquo;d&rsquo;,&rsquo;e&rsquo;,&rsquo;f&rsquo;)[$digit-10];</p>

<p style="margin-top: 1em"># A &quot;reverse comma
operator&quot;. <br>
return (pop(@foo),pop(@foo))[0];</p>

<p style="margin-top: 1em">Lists may be assigned to only
when each element of the list is itself legal to assign
to:</p>

<p style="margin-top: 1em">($a, $b, $c) = (1, 2, 3);</p>

<p style="margin-top: 1em">($map{&rsquo;red&rsquo;},
$map{&rsquo;blue&rsquo;}, $map{&rsquo;green&rsquo;}) =
(0x00f, 0x0f0, 0xf00);</p>

<p style="margin-top: 1em">An exception to this is that you
may assign to &quot;undef&quot; in a list. This is useful
for throwing away some of the return values of a
function:</p>

<p style="margin-top: 1em">($dev, $ino, undef, undef, $uid,
$gid) = stat($file);</p>

<p style="margin-top: 1em">List assignment in scalar
context returns the number of elements produced by the
expression on the right side of the assignment:</p>

<p style="margin-top: 1em">$x = (($foo,$bar) = (3,2,1)); #
set $x to 3, not 2 <br>
$x = (($foo,$bar) = f()); # set $x to f()&rsquo;s return
count</p>

<p style="margin-top: 1em">This is handy when you want to
do a list assignment in a Boolean context, because most list
functions return a null list when finished, which when
assigned produces a 0, which is <br>
interpreted as FALSE.</p>

<p style="margin-top: 1em">It&rsquo;s also the source of a
useful idiom for executing a function or performing an
operation in list context and then counting the number of
return values, by assigning to an empty <br>
list and then using that assignment in scalar context. For
example, this code:</p>

<p style="margin-top: 1em">$count = () = $string =~
/+/g;</p>

<p style="margin-top: 1em">will place into $count the
number of digit groups found in $string. This happens
because the pattern match is in list context (since it is
being assigned to the empty list), and <br>
will therefore return a list of all matching parts of the
string. The list assignment in scalar context will translate
that into the number of elements (here, the number of times
<br>
the pattern matched) and assign that to $count. Note that
simply using</p>

<p style="margin-top: 1em">$count = $string =~ /+/g;</p>

<p style="margin-top: 1em">would not have worked, since a
pattern match in scalar context will only return true or
false, rather than a count of matches.</p>

<p style="margin-top: 1em">The final element of a list
assignment may be an array or a hash:</p>

<p style="margin-top: 1em">($a, $b, @rest) = split; <br>
my($a, $b, %rest) = @_;</p>

<p style="margin-top: 1em">You can actually put an array or
hash anywhere in the list, but the first one in the list
will soak up all the values, and anything after it will
become undefined. This may be <br>
useful in a my() or local().</p>

<p style="margin-top: 1em">A hash can be initialized using
a literal list holding pairs of items to be interpreted as a
key and a value:</p>

<p style="margin-top: 1em"># same as map assignment above
<br>
%map =
(&rsquo;red&rsquo;,0x00f,&rsquo;blue&rsquo;,0x0f0,&rsquo;green&rsquo;,0xf00);</p>

<p style="margin-top: 1em">While literal lists and named
arrays are often interchangeable, that&rsquo;s not the case
for hashes. Just because you can subscript a list value like
a normal array does not mean <br>
that you can subscript a list value as a hash. Likewise,
hashes included as parts of other lists (including
parameters lists and return lists from functions) always
flatten out <br>
into key/value pairs. That&rsquo;s why it&rsquo;s good to
use references sometimes.</p>

<p style="margin-top: 1em">It is often more readable to use
the &quot;=&gt;&quot; operator between key/value pairs. The
&quot;=&gt;&quot; operator is mostly just a more visually
distinctive synonym for a comma, but it also <br>
arranges for its left-hand operand to be interpreted as a
string if it&rsquo;s a bareword that would be a legal simple
identifier. &quot;=&gt;&quot; doesn&rsquo;t quote compound
identifiers, that contain <br>
double colons. This makes it nice for initializing
hashes:</p>

<p style="margin-top: 1em">%map = ( <br>
red =&gt; 0x00f, <br>
blue =&gt; 0x0f0, <br>
green =&gt; 0xf00, <br>
);</p>

<p style="margin-top: 1em">or for initializing hash
references to be used as records:</p>

<p style="margin-top: 1em">$rec = { <br>
witch =&gt; &rsquo;Mable the Merciless&rsquo;, <br>
cat =&gt; &rsquo;Fluffy the Ferocious&rsquo;, <br>
date =&gt; &rsquo;10/31/1776&rsquo;, <br>
};</p>

<p style="margin-top: 1em">or for using
call-by-named-parameter to complicated functions:</p>

<p style="margin-top: 1em">$field = $query-&gt;radio_group(
<br>
name =&gt; &rsquo;group_name&rsquo;, <br>
values =&gt;
[&rsquo;eenie&rsquo;,&rsquo;meenie&rsquo;,&rsquo;minie&rsquo;],
<br>
default =&gt; &rsquo;meenie&rsquo;, <br>
linebreak =&gt; &rsquo;true&rsquo;, <br>
labels =&gt; labels <br>
);</p>

<p style="margin-top: 1em">Note that just because a hash is
initialized in that order doesn&rsquo;t mean that it comes
out in that order. See &quot;sort&quot; in perlfunc for
examples of how to arrange for an output <br>
ordering.</p>

<p style="margin-top: 1em">Subscripts <br>
An array can be accessed one scalar at a time by specifying
a dollar sign (&quot;$&quot;), then the name of the array
(without the leading &quot;@&quot;), then the subscript
inside square brackets. <br>
For example:</p>

<p style="margin-top: 1em">@myarray = (5, 50, 500, 5000);
<br>
print &quot;The Third Element is&quot;, $myarray[2],
&quot;0;</p>

<p style="margin-top: 1em">The array indices start with 0.
A negative subscript retrieves its value from the end. In
our example, $myarray[-1] would have been 5000, and
$myarray[-2] would have been 500.</p>

<p style="margin-top: 1em">Hash subscripts are similar,
only instead of square brackets curly brackets are used. For
example:</p>

<p style="margin-top: 1em">%scientists = <br>
( <br>
&quot;Newton&quot; =&gt; &quot;Isaac&quot;, <br>
&quot;Einstein&quot; =&gt; &quot;Albert&quot;, <br>
&quot;Darwin&quot; =&gt; &quot;Charles&quot;, <br>
&quot;Feynman&quot; =&gt; &quot;Richard&quot;, <br>
);</p>

<p style="margin-top: 1em">print &quot;Darwin&rsquo;s First
Name is &quot;, $scientists{&quot;Darwin&quot;},
&quot;0;</p>

<p style="margin-top: 1em">You can also subscript a list to
get a single element from it:</p>

<p style="margin-top: 1em">$dir =
(getpwnam(&quot;daemon&quot;))[7];</p>

<p style="margin-top: 1em">Multi-dimensional array
emulation <br>
Multidimensional arrays may be emulated by subscripting a
hash with a list. The elements of the list are joined with
the subscript separator (see &quot;$;&quot; in perlvar).</p>

<p style="margin-top: 1em">$foo{$a,$b,$c}</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">$foo{join($;, $a, $b, $c)}</p>

<p style="margin-top: 1em">The default subscript separator
is &quot; 34&quot;, the same as SUBSEP in awk.</p>

<p style="margin-top: 1em">Slices <br>
A slice accesses several elements of a list, an array, or a
hash simultaneously using a list of subscripts. It&rsquo;s
more convenient than writing out the individual elements as
a <br>
list of separate scalar values.</p>

<p style="margin-top: 1em">($him, $her) = @folks[0,-1]; #
array slice <br>
@them = @folks[0 .. 3]; # array slice <br>
($who, $home) = @ENV{&quot;USER&quot;, &quot;HOME&quot;}; #
hash slice <br>
($uid, $dir) = (getpwnam(&quot;daemon&quot;))[2,7]; # list
slice</p>

<p style="margin-top: 1em">Since you can assign to a list
of variables, you can also assign to an array or hash
slice.</p>

<p style="margin-top: 1em">@days[3..5] = qw/Wed Thu Fri/;
<br>

@colors{&rsquo;red&rsquo;,&rsquo;blue&rsquo;,&rsquo;green&rsquo;}
<br>
= (0xff0000, 0x0000ff, 0x00ff00); <br>
@folks[0, -1] = @folks[-1, 0];</p>

<p style="margin-top: 1em">The previous assignments are
exactly equivalent to</p>

<p style="margin-top: 1em">($days[3], $days[4], $days[5]) =
qw/Wed Thu Fri/; <br>
($colors{&rsquo;red&rsquo;}, $colors{&rsquo;blue&rsquo;},
$colors{&rsquo;green&rsquo;}) <br>
= (0xff0000, 0x0000ff, 0x00ff00); <br>
($folks[0], $folks[-1]) = ($folks[-1], $folks[0]);</p>

<p style="margin-top: 1em">Since changing a slice changes
the original array or hash that it&rsquo;s slicing, a
&quot;foreach&quot; construct will alter some--or even
all--of the values of the array or hash.</p>

<p style="margin-top: 1em">foreach (@array[ 4 .. 10 ]) {
s/peter/paul/ }</p>

<p style="margin-top: 1em">foreach (@hash{qw[key1 key2]}) {
<br>
s/^/; # trim leading whitespace <br>
s/; # trim trailing whitespace <br>
s/(600 <br>
}</p>

<p style="margin-top: 1em">A slice of an empty list is
still an empty list. Thus:</p>

<p style="margin-top: 1em">@a = ()[1,0]; # @a has no
elements <br>
@b = (@a)[0,1]; # @b has no elements <br>
@c = (0,1)[2,3]; # @c has no elements</p>

<p style="margin-top: 1em">But:</p>

<p style="margin-top: 1em">@a = (1)[1,0]; # @a has two
elements <br>
@b = (1,undef)[1,0,2]; # @b has three elements</p>

<p style="margin-top: 1em">This makes it easy to write
loops that terminate when a null list is returned:</p>

<p style="margin-top: 1em">while ( ($home, $user) =
(getpwent)[7,0]) { <br>
printf &quot;%-8s %s0, $user, $home; <br>
}</p>

<p style="margin-top: 1em">As noted earlier in this
document, the scalar sense of list assignment is the number
of elements on the right-hand side of the assignment. The
null list contains no elements, so <br>
when the password file is exhausted, the result is 0, not
2.</p>

<p style="margin-top: 1em">Slices in scalar context return
the last item of the slice.</p>

<p style="margin-top: 1em">@a = qw/first second third/;
<br>
%h = (first =&gt; &rsquo;A&rsquo;, second =&gt;
&rsquo;B&rsquo;); <br>
$t = @a[0, 1]; # $t is now &rsquo;second&rsquo; <br>
$u = @h{&rsquo;first&rsquo;, &rsquo;second&rsquo;}; # $u is
now &rsquo;B&rsquo;</p>

<p style="margin-top: 1em">If you&rsquo;re confused about
why you use an &rsquo;@&rsquo; there on a hash slice instead
of a &rsquo;%&rsquo;, think of it like this. The type of
bracket (square or curly) governs whether it&rsquo;s an
array or <br>
a hash being looked at. On the other hand, the leading
symbol (&rsquo;$&rsquo; or &rsquo;@&rsquo;) on the array or
hash indicates whether you are getting back a singular value
(a scalar) or a plural <br>
one (a list).</p>

<p style="margin-top: 1em">Typeglobs and Filehandles <br>
Perl uses an internal type called a typeglob to hold an
entire symbol table entry. The type prefix of a typeglob is
a &quot;*&quot;, because it represents all types. This used
to be the <br>
preferred way to pass arrays and hashes by reference into a
function, but now that we have real references, this is
seldom needed.</p>

<p style="margin-top: 1em">The main use of typeglobs in
modern Perl is create symbol table aliases. This
assignment:</p>

<p style="margin-top: 1em">*this = *that;</p>

<p style="margin-top: 1em">makes $this an alias for $that,
@this an alias for @that, %this an alias for %that,
&amp;this an alias for &amp;that, etc. Much safer is to use
a reference. This:</p>

<p style="margin-top: 1em">local *Here::blue =
here::green;</p>

<p style="margin-top: 1em">temporarily makes $Here::blue an
alias for $There::green, but doesn&rsquo;t make @Here::blue
an alias for @There::green, or %Here::blue an alias for
%There::green, etc. See &quot;Symbol <br>
Tables&quot; in perlmod for more examples of this. Strange
though this may seem, this is the basis for the whole module
import/export system.</p>

<p style="margin-top: 1em">Another use for typeglobs is to
pass filehandles into a function or to create new
filehandles. If you need to use a typeglob to save away a
filehandle, do it this way:</p>

<p style="margin-top: 1em">$fh = *STDOUT;</p>

<p style="margin-top: 1em">or perhaps as a real reference,
like this:</p>

<p style="margin-top: 1em">$fh = TDOUT;</p>

<p style="margin-top: 1em">See perlsub for examples of
using these as indirect filehandles in functions.</p>

<p style="margin-top: 1em">Typeglobs are also a way to
create a local filehandle using the local() operator. These
last until their block is exited, but may be passed back.
For example:</p>

<p style="margin-top: 1em">sub newopen { <br>
my $path = shift; <br>
local *FH; # not my! <br>
open (FH, $path) or return undef; <br>
return *FH; <br>
} <br>
$fh = newopen(&rsquo;/etc/passwd&rsquo;);</p>

<p style="margin-top: 1em">Now that we have the *foo{THING}
notation, typeglobs aren&rsquo;t used as much for filehandle
manipulations, although they&rsquo;re still needed to pass
brand new file and directory handles <br>
into or out of functions. That&rsquo;s because *HANDLE{IO}
only works if HANDLE has already been used as a handle. In
other words, *FH must be used to create new symbol table
entries; <br>
*foo{THING} cannot. When in doubt, use *FH.</p>

<p style="margin-top: 1em">All functions that are capable
of creating filehandles (open(), opendir(), pipe(),
socketpair(), sysopen(), socket(), and accept())
automatically create an anonymous filehandle <br>
if the handle passed to them is an uninitialized scalar
variable. This allows the constructs such as &quot;open(my
$fh, ...)&quot; and &quot;open(local $fh,...)&quot; to be
used to create <br>
filehandles that will conveniently be closed automatically
when the scope ends, provided there are no other references
to them. This largely eliminates the need for typeglobs <br>
when opening filehandles that must be passed around, as in
the following example:</p>

<p style="margin-top: 1em">sub myopen { <br>
open my $fh, &quot;@_&quot; <br>
or die &quot;Can&rsquo;t open &rsquo;@_&rsquo;: $!&quot;;
<br>
return $fh; <br>
}</p>

<p style="margin-top: 1em">{ <br>
my $f = myopen(&quot;&lt;/etc/motd&quot;); <br>
print &lt;$f&gt;; <br>
# $f implicitly closed here <br>
}</p>

<p style="margin-top: 1em">Note that if an initialized
scalar variable is used instead the result is different:
&quot;my $fh=&rsquo;zzz&rsquo;; open($fh, ...)&quot; is
equivalent to &quot;open( *{&rsquo;zzz&rsquo;}, ...)&quot;.
&quot;use strict &rsquo;refs&rsquo;&quot; <br>
forbids such practice.</p>

<p style="margin-top: 1em">Another way to create anonymous
filehandles is with the Symbol module or with the IO::Handle
module and its ilk. These modules have the advantage of not
hiding different types <br>
of the same name during the local(). See the bottom of
&quot;open&quot; in perlfunc for an example.</p>

<p style="margin-top: 1em">SEE ALSO <br>
See perlvar for a description of Perl&rsquo;s built-in
variables and a discussion of legal variable names. See
perlref, perlsub, and &quot;Symbol Tables&quot; in perlmod
for more discussion on <br>
typeglobs and the *foo{THING} syntax.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLDATA(1)</p>
<hr>
</body>
</html>
