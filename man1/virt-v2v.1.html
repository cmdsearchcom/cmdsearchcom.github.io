<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>virt-v2v(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">virt-v2v(1)</td>
    <td class="head-vol">Virtualization Support</td>
    <td class="head-rtitle">virt-v2v(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
virt-v2v - Convert a guest to use KVM
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest
 virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest \
   -o rhev -os rhev.nfs:/export_domain --network rhevm
 virt-v2v -i libvirtxml guest-domain.xml -o local -os /var/tmp
 virt-v2v -i disk disk.img -o local -os /var/tmp
 virt-v2v -i disk disk.img -o glance
</pre>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Virt-v2v converts guests from a foreign hypervisor to run on KVM. It can read
  Linux and Windows guests running on VMware, Xen, Hyper-V and some other
  hypervisors, and convert them to KVM managed by libvirt, OpenStack, oVirt, Red
  Hat Enterprise Virtualisation (RHEV) or several other targets.
<div class="Pp"></div>
There is also a companion front-end called <i>virt-p2v</i>(1) which comes as an
  ISO, CD or PXE image that can be booted on physical machines to virtualize
  those machines (physical to virtual, or p2v).
<div class="Pp"></div>
This manual page documents the rewritten virt-v2v included in libguestfs
  &#x2265; 1.28.
<h1 class="Sh" title="Sh" id="INPUT_AND_OUTPUT_MODES"><a class="selflink" href="#INPUT_AND_OUTPUT_MODES">INPUT
  AND OUTPUT MODES</a></h1>
<pre>
                          &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o null
 -i disk &#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;    &#x2502;            &#x2502; &#x2500;&#x2518;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o local
 -i ova  &#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510; &#x2514;&#x2500;&#x2500;&#x25B6; &#x2502; virt-v2v   &#x2502; &#x2500;&#x2500;&#x2518;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o qemu
                   &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; &#x2502; conversion &#x2502; &#x2500;&#x2500;&#x2500;&#x2518;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
 VMware&#x2500;&#x25B6;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;   &#x2502; server     &#x2502; &#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o libvirt &#x2502;&#x2500;&#x25B6; KVM
 Xen &#x2500;&#x2500;&#x2500;&#x25B6;&#x2502; -i libvirt &#x2500;&#x2500;&#x25B6; &#x2502;            &#x2502;     &#x2502;  (default) &#x2502;
 ... &#x2500;&#x2500;&#x2500;&#x25B6;&#x2502;  (default) &#x2502;   &#x2502;            &#x2502; &#x2500;&#x2500;&#x2510; &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
         &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;   &#x2502;            &#x2502; &#x2500;&#x2510;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o glance
 -i libvirtxml &#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; &#x2502;            &#x2502; &#x2510;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o rhev
                          &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o vdsm
</pre>
<div class="Pp"></div>
Virt-v2v has a number of possible input and output modes, selected using the
  <i>-i</i> and <i>-o</i> options. Only one input and output mode can be
  selected for each run of virt-v2v.
<div class="Pp"></div>
<i>-i disk</i> is used for reading from local disk images (mainly for testing).
<div class="Pp"></div>
<i>-i libvirt</i> is used for reading from any libvirt source. Since libvirt can
  connect to many different hypervisors, it is used for reading guests from
  VMware, RHEL 5 Xen and more. The <i>-ic</i> option selects the precise libvirt
  source.
<div class="Pp"></div>
<i>-i libvirtxml</i> is used to read from libvirt XML files. This is the method
  used by <i>virt-p2v</i>(1) behind the scenes.
<div class="Pp"></div>
<i>-i ova</i> is used for reading from a VMware ova source file.
<div class="Pp"></div>
<i>-o glance</i> is used for writing to OpenStack Glance.
<div class="Pp"></div>
<i>-o libvirt</i> is used for writing to any libvirt target. Libvirt can connect
  to local or remote KVM hypervisors. The <i>-oc</i> option selects the precise
  libvirt target.
<div class="Pp"></div>
<i>-o local</i> is used to write to a local disk image with a local libvirt
  configuration file (mainly for testing).
<div class="Pp"></div>
<i>-o qemu</i> writes to a local disk image with a shell script for booting the
  guest directly in qemu (mainly for testing).
<div class="Pp"></div>
<i>-o rhev</i> is used to write to a RHEV-M / oVirt target. <i>-o vdsm</i> is
  only used when virt-v2v runs under VDSM control.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<h2 class="Ss" title="Ss" id="Convert_from_VMware_vCenter_server_to_local_libvirt"><a class="selflink" href="#Convert_from_VMware_vCenter_server_to_local_libvirt">Convert
  from VMware vCenter server to local libvirt</a></h2>
You have a VMware vCenter server called &quot;vcenter.example.com&quot;, a
  datacenter called &quot;Datacenter&quot;, and an ESXi hypervisor called
  &quot;esxi&quot;. You want to convert a guest called &quot;vmware_guest&quot;
  to run locally under libvirt.
<div class="Pp"></div>
<pre>
 virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest
</pre>
<div class="Pp"></div>
In this case you will most likely have to run virt-v2v as &quot;root&quot;,
  since it needs to talk to the system libvirt daemon and copy the guest disks
  to <i>/var/lib/libvirt/images</i>.
<div class="Pp"></div>
For more information see &quot;INPUT FROM VMWARE VCENTER SERVER&quot; below.
<h2 class="Ss" title="Ss" id="Convert_from_VMware_to_RHEV-M/oVirt"><a class="selflink" href="#Convert_from_VMware_to_RHEV-M/oVirt">Convert
  from VMware to RHEV-M/oVirt</a></h2>
This is the same as the previous example, except you want to send the guest to a
  RHEV-M Export Storage Domain which is located remotely (over NFS) at
  &quot;rhev.nfs:/export_domain&quot;. If you are unclear about the location of
  the Export Storage Domain you should check the settings on your RHEV-M
  management console. Guest network interface(s) are connected to the target
  network called &quot;rhevm&quot;.
<div class="Pp"></div>
<pre>
 virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest \
   -o rhev -os rhev.nfs:/export_domain --network rhevm
</pre>
<div class="Pp"></div>
In this case the host running virt-v2v acts as a <b>conversion server</b>.
<div class="Pp"></div>
Note that after conversion, the guest will appear in the RHEV-M Export Storage
  Domain, from where you will need to import it using the RHEV-M user interface.
  (See &quot;OUTPUT TO RHEV&quot;).
<h2 class="Ss" title="Ss" id="Convert_disk_image_to_OpenStack_glance"><a class="selflink" href="#Convert_disk_image_to_OpenStack_glance">Convert
  disk image to OpenStack glance</a></h2>
Given a disk image from another hypervisor that you want to convert to run on
  OpenStack (only KVM-based OpenStack is supported), you can do:
<div class="Pp"></div>
<pre>
 virt-v2v -i disk disk.img -o glance
</pre>
<div class="Pp"></div>
See &quot;OUTPUT TO GLANCE&quot; below.
<h2 class="Ss" title="Ss" id="Convert_disk_image_to_disk_image"><a class="selflink" href="#Convert_disk_image_to_disk_image">Convert
  disk image to disk image</a></h2>
Given a disk image from another hypervisor that you want to convert to run on
  KVM, you have two options. The simplest way is to try:
<div class="Pp"></div>
<pre>
 virt-v2v -i disk disk.img -o local -os /var/tmp
</pre>
<div class="Pp"></div>
where virt-v2v guesses everything about the input <i>disk.img</i> and (in this
  case) writes the converted result to <i>/var/tmp</i>.
<div class="Pp"></div>
A more complex method is to write some libvirt XML describing the input guest
  (if you can get the source hypervisor to provide you with libvirt XML, then so
  much the better). You can then do:
<div class="Pp"></div>
<pre>
 virt-v2v -i libvirtxml guest-domain.xml -o local -os /var/tmp
</pre>
<div class="Pp"></div>
Since <i>guest-domain.xml</i> contains the path(s) to the guest disk image(s)
  you do not need to specify the name of the disk image on the command line.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help</b></dt>
  <dd class="It-tag">Display help.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b</b> ...</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bridge</b> ...</dt>
  <dd class="It-tag">See <i>--network</i> below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--colors</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--colours</b></dt>
  <dd class="It-tag">Use ANSI colour sequences to colourize messages. This is
      the default when the output is a tty. If the output of the program is
      redirected to a file, ANSI colour sequences are disabled unless you use
      this option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--compressed</b></dt>
  <dd class="It-tag">Write a compressed output file. This is only allowed if the
      output format is qcow2 (see <i>-of</i> below), and is equivalent to the
      <i>-c</i> option of <i>qemu-img</i>(1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--debug-gc</b></dt>
  <dd class="It-tag">Debug garbage collection and memory allocation. This is
      only useful when debugging memory problems in virt-v2v or the OCaml
      libguestfs bindings.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--debug-overlays</b></dt>
  <dd class="It-tag">Save the overlay file(s) created during conversion. This
      option is only used for debugging virt-v2v and may be removed in a future
      version.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i disk</b></dt>
  <dd class="It-tag">Set the input method to <i>disk</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    In this mode you can read a virtual machine disk image with no metadata.
      virt-v2v tries to guess the best default metadata. This is usually
      adequate but you can get finer control (eg. of memory and vCPUs) by using
      <i>-i libvirtxml</i> instead. Only guests that use a single disk can be
      imported this way.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i libvirt</b></dt>
  <dd class="It-tag">Set the input method to <i>libvirt</i>. This is the
      default.
    <div style="height: 1.00em;">&#x00A0;</div>
    In this mode you have to specify a libvirt guest name or UUID on the command
      line. You may also specify a libvirt connection URI (see <i>-ic</i>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i libvirtxml</b></dt>
  <dd class="It-tag">Set the input method to <i>libvirtxml</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    In this mode you have to pass a libvirt XML file on the command line. This
      file is read in order to get metadata about the source guest (such as its
      name, amount of memory), and also to locate the input disks. See
      &quot;MINIMAL XML FOR -i libvirtxml OPTION&quot; below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i local</b></dt>
  <dd class="It-tag">This is the same as <i>-i disk</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i ova</b></dt>
  <dd class="It-tag">Set the input method to <i>ova</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    In this mode you can read a VMware ova file. Virt-v2v will read the ova
      manifest file and check the vmdk volumes for validity (checksums) as well
      as analyzing the ovf file, and then convert the guest. See &quot;INPUT
      FROM VMWARE OVA&quot; below</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ic</b> libvirtURI</dt>
  <dd class="It-tag">Specify a libvirt connection URI to use when reading the
      guest. This is only used when <i>-i&#x00A0;libvirt</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Only local libvirt connections, VMware vCenter connections, or RHEL 5 Xen
      remote connections can be used. Other remote libvirt connections will not
      work in general.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also &quot;INPUT FROM VMWARE VCENTER SERVER&quot;, &quot;INPUT FROM RHEL
      5 XEN&quot; below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-if</b> format</dt>
  <dd class="It-tag">For <i>-i disk</i> only, this specifies the format of the
      input disk image. For other input methods you should specify the input
      format in the metadata.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--machine-readable</b></dt>
  <dd class="It-tag">This option is used to make the output more machine
      friendly when being parsed by other programs. See &quot;MACHINE READABLE
      OUTPUT&quot; below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b> in:out</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b> out</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--network</b> in:out</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--network</b> out</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b</b> in:out</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b</b> out</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bridge</b> in:out</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--bridge</b> out</dt>
  <dd class="It-tag">Map network (or bridge) called &quot;in&quot; to network
      (or bridge) called &quot;out&quot;. If no &quot;in:&quot; prefix is given,
      all other networks (or bridges) are mapped to &quot;out&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    See &quot;NETWORKS AND BRIDGES&quot; below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-copy</b></dt>
  <dd class="It-tag">Don't copy the disks. Instead, conversion is performed (and
      thrown away), and metadata is written, but no disks are created. See also
      discussion of <i>-o&#x00A0;null</i> below.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is useful in two cases: Either you want to test if conversion is likely
      to succeed, without the long copying process. Or you are only interested
      in looking at the metadata.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is not compatible with <i>-o libvirt</i> since it would create a
      faulty guest (one with no disks).
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is not compatible with <i>-o glance</i> for technical
    reasons.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-trim all</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-trim</b> mp[,mp...]</dt>
  <dd class="It-tag">By default virt-v2v runs <i>fstrim</i>(8) to reduce the
      amount of data that needs to be copied. This is known to break some buggy
      bootloaders causing boot failures after conversion (see for example
      https://bugzilla.redhat.com/show_bug.cgi?id=1141145#c27).
    <div style="height: 1.00em;">&#x00A0;</div>
    You can use <i>--no-trim all</i> to disable all trimming. Note this will
      greatly increase the amount of data that has to be copied and can make
      virt-v2v run much more slowly.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also disable trimming on selected filesystems only (specified by a
      comma-separated list of their mount point(s) in the guest). Typically you
      would use <i>--no-trim /boot</i> to work around the grub bug mentioned
      above.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also disable trimming on partitions using the libguestfs naming
      scheme for devices, eg: <i>--no-trim /dev/sdb2</i> means do not trim the
      second partition on the second block device. Use
      <i>virt-filesystems</i>(1) to list filesystem names in a guest.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o disk</b></dt>
  <dd class="It-tag">This is the same as <i>-o local</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o glance</b></dt>
  <dd class="It-tag">Set the output method to OpenStack Glance. In this mode the
      converted guest is uploaded to Glance. See &quot;OUTPUT TO GLANCE&quot;
      below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o libvirt</b></dt>
  <dd class="It-tag">Set the output method to <i>libvirt</i>. This is the
      default.
    <div style="height: 1.00em;">&#x00A0;</div>
    In this mode, the converted guest is created as a libvirt guest. You may
      also specify a libvirt connection URI (see <i>-oc</i>).
    <div style="height: 1.00em;">&#x00A0;</div>
    See &quot;OUTPUT TO LIBVIRT&quot; below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o local</b></dt>
  <dd class="It-tag">Set the output method to <i>local</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    In this mode, the converted guest is written to a local directory specified
      by <i>-os /dir</i> (the directory must exist). The converted guest's disks
      are written as:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 /dir/name-sda
 /dir/name-sdb
 [etc]
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and a libvirt XML file is created containing guest metadata:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 /dir/name.xml
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    where &quot;name&quot; is the guest name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o null</b></dt>
  <dd class="It-tag">Set the output method to <i>null</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The guest is converted and copied (unless you also specify
      <i>--no-copy</i>), but the results are thrown away and no metadata is
      written.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o ovirt</b></dt>
  <dd class="It-tag">This is the same as <i>-o rhev</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o qemu</b></dt>
  <dd class="It-tag">Set the output method to <i>qemu</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is similar to <i>-o local</i>, except that a shell script is written
      which you can use to boot the guest in qemu. The converted disks and shell
      script are written to the directory specified by <i>-os</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o rhev</b></dt>
  <dd class="It-tag">Set the output method to <i>rhev</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The converted guest is written to a RHEV Export Storage Domain. The
      <i>-os</i> parameter must also be used to specify the location of the
      Export Storage Domain. Note this does not actually import the guest into
      RHEV. You have to do that manually later using the UI.
    <div style="height: 1.00em;">&#x00A0;</div>
    See &quot;OUTPUT TO RHEV&quot; below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o vdsm</b></dt>
  <dd class="It-tag">Set the output method to <i>vdsm</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    This mode is similar to <i>-o rhev</i>, but the full path to the data domain
      must be given:
      <i>/rhev/data-center/&lt;data-center-uuid&gt;/&lt;data-domain-uuid&gt;</i>.
      This mode is only used when virt-v2v runs under VDSM control.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-oa sparse</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-oa preallocated</b></dt>
  <dd class="It-tag">Set the output file allocation mode. The default is
      &quot;sparse&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-oc</b> libvirtURI</dt>
  <dd class="It-tag">Specify a libvirt connection to use when writing the
      converted guest. This is only used when <i>-o&#x00A0;libvirt</i>. See
      &quot;OUTPUT TO LIBVIRT&quot; below.
    <div style="height: 1.00em;">&#x00A0;</div>
    Only local libvirt connections can be used. Remote libvirt connections will
      not work.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-of</b> format</dt>
  <dd class="It-tag">When converting the guest, convert the disks to the given
      format.
    <div style="height: 1.00em;">&#x00A0;</div>
    If not specified, then the input format is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-on</b> name</dt>
  <dd class="It-tag">Rename the guest when converting it. If this option is not
      used then the output name is the same as the input name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-os</b> storage</dt>
  <dd class="It-tag">The location of the storage for the converted guest.
    <div style="height: 1.00em;">&#x00A0;</div>
    For <i>-o libvirt</i>, this is a libvirt directory pool (see
      &quot;virsh&#x00A0;pool-list&quot;) or pool UUID.
    <div style="height: 1.00em;">&#x00A0;</div>
    For <i>-o local</i> and <i>-o qemu</i>, this is a directory name. The
      directory must exist.
    <div style="height: 1.00em;">&#x00A0;</div>
    For <i>-o rhev</i>, this can be an NFS path of the Export Storage Domain of
      the form &quot;&lt;host&gt;:&lt;path&gt;&quot;, eg:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 rhev-storage.example.com:/rhev/export
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The NFS export must be mountable and writable by the user and host running
      virt-v2v, since the virt-v2v program has to actually mount it when it
      runs. So you probably have to run virt-v2v as &quot;root&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Or:</b> You can mount the Export Storage Domain yourself, and point
      <i>-os</i> to the mountpoint. Note that virt-v2v will still need to write
      to this remote directory, so virt-v2v will still need to run as
      &quot;root&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    You will get an error if virt-v2v is unable to mount/write to the Export
      Storage Domain.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--password-file</b> file</dt>
  <dd class="It-tag">Instead of asking for password(s) interactively, pass the
      password through a file. Note the file should contain the whole password,
      <b>without any trailing newline</b>, and for security the file should have
      mode 0600 so that others cannot read it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--print-source</b></dt>
  <dd class="It-tag">Print information about the source guest and stop. This
      option is useful when you are setting up network and bridge maps. See
      &quot;NETWORKS AND BRIDGES&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quiet</b></dt>
  <dd class="It-tag">This disables progress bars and other unnecessary
    output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root ask</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root single</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root first</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root</b> /dev/sdX</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--root</b> /dev/VG/LV</dt>
  <dd class="It-tag">Choose the root filesystem to be converted.
    <div style="height: 1.00em;">&#x00A0;</div>
    In the case where the virtual machine is dual-boot or multi-boot, or where
      the VM has other filesystems that look like operating systems, this option
      can be used to select the root filesystem (a.k.a. &quot;C:&quot; drive or
      <i>/</i>) of the operating system that is to be converted. The Windows
      Recovery Console, certain attached DVD drives, and bugs in libguestfs
      inspection heuristics, can make a guest look like a multi-boot operating
      system.
    <div style="height: 1.00em;">&#x00A0;</div>
    The default in virt-v2v &#x2264; 0.7.1 was <i>--root&#x00A0;single</i>,
      which causes virt-v2v to die if a multi-boot operating system is found.
    <div style="height: 1.00em;">&#x00A0;</div>
    Since virt-v2v &#x2265; 0.7.2 the default is now <i>--root&#x00A0;ask</i>:
      If the VM is found to be multi-boot, then virt-v2v will stop and list the
      possible root filesystems and ask the user which to use. This requires
      that virt-v2v is run interactively.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>--root&#x00A0;first</i> means to choose the first root device in the
      case of a multi-boot operating system. Since this is a heuristic, it may
      sometimes choose the wrong one.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also name a specific root device, eg. <i>--root&#x00A0;/dev/sda2</i>
      would mean to use the second partition on the first hard drive. If the
      named root device does not exist or was not detected as a root device,
      then virt-v2v will fail.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that there is a bug in grub which prevents it from successfully booting
      a multiboot system if VirtIO is enabled. Grub is only able to boot an
      operating system from the first VirtIO disk. Specifically, <i>/boot</i>
      must be on the first VirtIO disk, and it cannot chainload an OS which is
      not in the first VirtIO disk.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vdsm-compat=0.10</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vdsm-compat=1.1</b></dt>
  <dd class="It-tag">If <i>-o vdsm</i> and the output format is qcow2, then we
      add the qcow2 <i>compat=0.10</i> option to the output file for
      compatibility with RHEL 6 (see https://bugzilla.redhat.com/1145582).
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>--vdsm-compat=1.1</i> is used then modern qcow2 (<i>compat=1.1</i>)
      files are generated instead.
    <div style="height: 1.00em;">&#x00A0;</div>
    Currently <i>--vdsm-compat=0.10</i> is the default, but this will change to
      <i>--vdsm-compat=1.1</i> in a future version of virt-v2v (when we can
      assume that everyone is using a modern version of qemu).
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Note this option only affects </b><b><i>-o vdsm</i></b><b> output</b>.
      All other output modes (including <i>-o rhev</i>) generate modern qcow2
      <i>compat=1.1</i> files, always.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vdsm-image-uuid</b> UUID</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vdsm-vol-uuid</b> UUID</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vdsm-vm-uuid</b> UUID</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vdsm-ovf-output</b></dt>
  <dd class="It-tag">Normally the RHEV output mode chooses random UUIDs for the
      target guest. However VDSM needs to control the UUIDs and passes these
      parameters when virt-v2v runs under VDSM control. The parameters
    control:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">the image directory of each guest disk
      (<i>--vdsm-image-uuid</i>) (this option is passed once for each guest
      disk)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">UUIDs for each guest disk (<i>--vdsm-vol-uuid</i>) (this
      option is passed once for each guest disk)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">the OVF file name (<i>--vdsm-vm-uuid</i>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">the OVF output directory (default current directory)
      (<i>--vdsm-ovf-output</i>).</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
The format of UUIDs is: &quot;12345678-1234-1234-1234-123456789abc&quot; (each
  hex digit can be &quot;0-9&quot; or &quot;a-f&quot;), conforming to
  OSF&#x00A0;DCE&#x00A0;1.1.
<div style="height: 1.00em;">&#x00A0;</div>
These options can only be used with <i>-o vdsm</i>.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--verbose</b></dt>
  <dd class="It-tag">Enable verbose messages for debugging.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--version</b></dt>
  <dd class="It-tag">Display version number and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vmtype desktop</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--vmtype server</b></dt>
  <dd class="It-tag">For the <i>-o rhev</i> or <i>-o vdsm</i> targets only,
      specify the type of guest. You can set this to &quot;desktop&quot; or
      &quot;server&quot;. If the option is not given, then a suitable default is
      chosen based on the detected guest operating system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x</b></dt>
  <dd class="It-tag">Enable tracing of libguestfs API calls.</dd>
</dl>
<h1 class="Sh" title="Sh" id="XEN_PARAVIRTUALIZED_GUESTS"><a class="selflink" href="#XEN_PARAVIRTUALIZED_GUESTS">XEN
  PARAVIRTUALIZED GUESTS</a></h1>
Older versions of virt-v2v could turn a Xen paravirtualized (PV) guest into a
  KVM guest by installing a new kernel. This version of virt-v2v does <i>not</i>
  attempt to install any new kernels. Instead it will give you an error if there
  are <i>only</i> Xen PV kernels available.
<div class="Pp"></div>
Therefore before conversion you should check that a regular kernel is installed.
  For some older Linux distributions, this means installing a kernel from the
  table below:
<div class="Pp"></div>
<pre>
 RHEL 3         (Does not apply, as there was no Xen PV kernel)
 
 RHEL 4         i686 with &gt; 10GB of RAM: install 'kernel-hugemem'
                i686 SMP: install 'kernel-smp'
                other i686: install 'kernel'
                x86-64 SMP with &gt; 8 CPUs: install 'kernel-largesmp'
                x86-64 SMP: install 'kernel-smp'
                other x86-64: install 'kernel'
 
 RHEL 5         i686: install 'kernel-PAE'
                x86-64: install 'kernel'
 
 SLES 10        i586 with &gt; 10GB of RAM: install 'kernel-bigsmp'
                i586 SMP: install 'kernel-smp'
                other i586: install 'kernel-default'
                x86-64 SMP: install 'kernel-smp'
                other x86-64: install 'kernel-default'
 
 SLES 11+       i586: install 'kernel-pae'
                x86-64: install 'kernel-default'
 Windows        (Does not apply, as there is no Xen PV Windows kernel)
</pre>
<h1 class="Sh" title="Sh" id="ENABLING_VIRTIO"><a class="selflink" href="#ENABLING_VIRTIO">ENABLING
  VIRTIO</a></h1>
&quot;Virtio&quot; is the name for a set of drivers which make disk (block
  device), network and other guest operations work much faster on KVM.
<div class="Pp"></div>
Older versions of virt-v2v could install these drivers for certain Linux guests.
  This version of virt-v2v does <i>not</i> attempt to install new Linux kernels
  or drivers, but will warn you if they are not installed already.
<div class="Pp"></div>
In order to enable virtio, and hence improve performance of the guest after
  conversion, you should ensure that the <b>minimum</b> versions of packages are
  installed <i>before</i> conversion, by consulting the table below.
<div class="Pp"></div>
<pre>
 RHEL 3         No virtio drivers are available
 
 RHEL 4         kernel &gt;= 2.5.9-89.EL
                lvm2 &gt;= 2.02.42-5.el4
                device-mapper &gt;= 1.02.28-2.el4
                selinux-policy-targeted &gt;= 1.17.30-2.152.el4
                policycoreutils &gt;= 1.18.1-4.13
 
 RHEL 5         kernel &gt;= 2.6.18-128.el5
                lvm2 &gt;= 2.02.40-6.el5
                selinux-policy-targeted &gt;= 2.4.6-203.el5
 
 RHEL 6+        All versions support virtio
 
 Fedora         All versions support virtio
 
 SLES 11+       All versions support virtio
 
 SLES 10        kernel &gt;= 2.6.16.60-0.85.1
 
 OpenSUSE 11+   All versions support virtio
 
 OpenSUSE 10    kernel &gt;= 2.6.25.5-1.1
 Windows        Drivers are installed from the directory pointed to by
                &quot;VIRTIO_WIN&quot; environment variable
                (/usr/share/virtio-win by default) if present
</pre>
<h1 class="Sh" title="Sh" id="RHEL_4"><a class="selflink" href="#RHEL_4">RHEL
  4</a></h1>
<h2 class="Ss" title="Ss" id="SELinux_relabel_appears_to_hang_forever"><a class="selflink" href="#SELinux_relabel_appears_to_hang_forever">SELinux
  relabel appears to hang forever</a></h2>
In RHEL &#x2264; 4.7 there was a bug which causes SELinux relabelling to appear
  to hang forever at:
<div class="Pp"></div>
<pre>
 *** Warning -- SELinux relabel is required. ***
 *** Disabling security enforcement.         ***
 *** Relabeling could take a very long time, ***
 *** depending on file system size.          ***
</pre>
<div class="Pp"></div>
In reality it is waiting for you to press a key (but there is no visual
  indication of this). You can either hit the &quot;[Return]&quot; key, at which
  point the guest will finish relabelling and reboot, or you can install
  policycoreutils &#x2265; 1.18.1-4.13 before starting the v2v conversion. See
  also https://bugzilla.redhat.com/show_bug.cgi?id=244636
<h1 class="Sh" title="Sh" id="WINDOWS"><a class="selflink" href="#WINDOWS">WINDOWS</a></h1>
<h2 class="Ss" title="Ss" id="Windows_&#x2265;_8_Fast_Startup_is_incompatible_with_virt-v2v"><a class="selflink" href="#Windows_&#x2265;_8_Fast_Startup_is_incompatible_with_virt-v2v">Windows
  &#x2265; 8 Fast Startup is incompatible with virt-v2v</a></h2>
Guests which use the Windows &#x2265; 8 &quot;Fast Startup&quot; feature (or
  guests which are hibernated) cannot be converted with virt-v2v. You will see
  an error:
<div class="Pp"></div>
<pre>
 virt-v2v: error: unable to mount the disk image for writing. This has
 probably happened because Windows Hibernation or Fast Restart is being
 used in this guest. You have to disable this (in the guest) in order
 to use virt-v2v.
</pre>
<div class="Pp"></div>
As the message says, you need to boot the guest and disable the &quot;Fast
  Startup&quot; feature (Control Panel &#x2192; Power Options &#x2192; Choose
  what the power buttons do &#x2192; Change settings that are currently
  unavailable &#x2192; Turn on fast startup), and shut down the guest, and then
  you will be able to convert it.
<div class="Pp"></div>
For more information, see: &quot;WINDOWS HIBERNATION AND WINDOWS 8 FAST
  STARTUP&quot; in <i>guestfs</i>(3).
<h2 class="Ss" title="Ss" id="Boot_failure:_0x0000007B"><a class="selflink" href="#Boot_failure:_0x0000007B">Boot
  failure: 0x0000007B</a></h2>
This boot failure is caused by Windows being unable to find or load the right
  disk driver (eg. <i>viostor.sys</i>). If you experience this error, here are
  some things to check:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">First ensure that the guest boots on the source hypervisor
      before conversion.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Check you have the Windows virtio drivers available in
      <i>/usr/share/virtio-win</i>, and that virt-v2v did not print any warning
      about not being able to install virtio drivers.
    <div style="height: 1.00em;">&#x00A0;</div>
    On Red&#x00A0;Hat&#x00A0;Enterprise&#x00A0;Linux&#x00A0;7, you will need to
      install the signed drivers available in the &quot;virtio-win&quot;
      package. If you do not have access to the signed drivers, then you will
      probably need to disable driver signing in the boot menus.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Check that you are presenting a virtio-blk interface
      (<b>not</b> virtio-scsi and <b>not</b> ide) to the guest. On the qemu/KVM
      command line you should see something similar to this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 ... -drive file=windows-sda,if=virtio ...
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    In libvirt XML, you should see:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 &lt;target dev='vda' bus='virtio'/&gt;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Check that Windows Group Policy does not prevent the driver
      from being installed or used. Try deleting Windows Group Policy before
      conversion.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Check there is no anti-virus or other software which
      implements Group Policy-like prohibitions on installing or using new
      drivers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Enable boot debugging and check the <i>viostor.sys</i>
      driver is being loaded.</dd>
</dl>
<h2 class="Ss" title="Ss" id="OpenStack_and_Windows_reactivation"><a class="selflink" href="#OpenStack_and_Windows_reactivation">OpenStack
  and Windows reactivation</a></h2>
OpenStack does not offer stable device / PCI addresses to guests. Every time it
  creates or starts a guest, it regenerates the libvirt XML for that guest from
  scratch. The libvirt XML will have no &lt;address&gt; fields. Libvirt will
  then assign addresses to devices, in a predictable manner. Addresses may
  change if any of the following are true:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A new disk or network device has been added or removed from
      the guest.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The version of OpenStack or (possibly) libvirt has
    changed.</dd>
</dl>
<div class="Pp"></div>
Because Windows does not like &quot;hardware&quot; changes of this kind, it may
  trigger Windows reactivation.
<div class="Pp"></div>
This can also prevent booting with a 7B error [see previous section] if the
  guest has group policy containing &quot;Device Installation
  Restrictions&quot;.
<h1 class="Sh" title="Sh" id="UEFI"><a class="selflink" href="#UEFI">UEFI</a></h1>
VMware allows you to present UEFI firmware to guests (instead of the ordinary PC
  BIOS). Virt-v2v can convert these guests, but requires that UEFI is supported
  by the target hypervisor.
<div class="Pp"></div>
Currently KVM supports OVMF, an open source UEFI firmware, and can run these
  guests.
<div class="Pp"></div>
Since OVMF support was only recently added to KVM (in 2014/2015), not all target
  environments support UEFI guests yet:
<dl class="Bl-tag">
  <dt class="It-tag">UEFI on libvirt, qemu</dt>
  <dd class="It-tag">Supported. Virt-v2v will generate the correct libvirt XML
      (metadata) automatically, but note that the same version of OVMF must be
      installed on the conversion host as is installed on the target hypervisor,
      else you will have to adjust paths in the metadata.
    <div style="height: 1.00em;">&#x00A0;</div>
    On RHEL &#x2265; 7.3, only qemu-kvm-rhev (not qemu-kvm) is supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">UEFI on OpenStack</dt>
  <dd class="It-tag">Not supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">UEFI on RHEV</dt>
  <dd class="It-tag">Not supported.</dd>
</dl>
<h1 class="Sh" title="Sh" id="NETWORKS_AND_BRIDGES"><a class="selflink" href="#NETWORKS_AND_BRIDGES">NETWORKS
  AND BRIDGES</a></h1>
Guests are usually connected to one or more networks, and when converted to the
  target hypervisor you usually want to reconnect those networks at the
  destination. The options <i>--network</i> and <i>--bridge</i> allow you to do
  that.
<div class="Pp"></div>
If you are unsure of what networks and bridges are in use on the source
  hypervisor, then you can examine the source metadata (libvirt XML, vCenter
  information, etc.). Or you can run virt-v2v with the <i>--print-source</i>
  option which causes virt-v2v to print out the information it has about the
  guest on the source and then exit.
<div class="Pp"></div>
In the <i>--print-source</i> output you will see a section showing the guest's
  Network Interface Cards (NICs):
<div class="Pp"></div>
<pre>
 $ virt-v2v [-i ...] --print-source name
 [...]
 NICs:
     Network &quot;default&quot; mac: 52:54:00:d0:cf:0e
</pre>
<div class="Pp"></div>
This is typical of a libvirt guest: It has a single network interface connected
  to a network called &quot;default&quot;.
<div class="Pp"></div>
To map a specific network to a target network, for example &quot;default&quot;
  on the source to &quot;rhevm&quot; on the target, use:
<div class="Pp"></div>
<pre>
 virt-v2v [...] --network default:rhevm
</pre>
<div class="Pp"></div>
To map every network to a target network, use:
<div class="Pp"></div>
<pre>
 virt-v2v [...] --network rhevm
</pre>
<div class="Pp"></div>
Bridges are handled in the same way, but you have to use the <i>--bridge</i>
  option instead. For example:
<div class="Pp"></div>
<pre>
 $ virt-v2v [-i ...] --print-source name
 [...]
 NICs:
     Bridge &quot;br0&quot;
 
 $ virt-v2v [...] --bridge br0:targetbr
</pre>
<h1 class="Sh" title="Sh" id="INPUT_FROM_VMWARE_VCENTER_SERVER"><a class="selflink" href="#INPUT_FROM_VMWARE_VCENTER_SERVER">INPUT
  FROM VMWARE VCENTER SERVER</a></h1>
Virt-v2v is able to import guests from VMware vCenter Server.
<div class="Pp"></div>
vCenter &#x2265; 5.0 is required. If you don't have vCenter, using OVA is
  recommended instead (see &quot;INPUT FROM VMWARE OVA&quot; below), or if that
  is not possible then see &quot;INPUT FROM VMWARE ESXi HYPERVISOR&quot;.
<div class="Pp"></div>
Virt-v2v uses libvirt for access to vCenter, and therefore the input mode should
  be <i>-i libvirt</i>. As this is the default, you don't need to specify it on
  the command line.
<h2 class="Ss" title="Ss" id="VCENTER:_REMOVE_VMWARE_TOOLS_FROM_WINDOWS_GUESTS"><a class="selflink" href="#VCENTER:_REMOVE_VMWARE_TOOLS_FROM_WINDOWS_GUESTS">VCENTER:
  REMOVE VMWARE TOOLS FROM WINDOWS GUESTS</a></h2>
For Windows guests, you should remove VMware tools before conversion. Although
  this is not strictly necessary, and the guest will still be able to run, if
  you don't do this then the converted guest will complain on every boot. The
  tools cannot be removed after conversion because the uninstaller checks if it
  is running on VMware and refuses to start (which is also the reason that
  virt-v2v cannot remove them).
<div class="Pp"></div>
This is not necessary for Linux guests, as virt-v2v is able to remove VMware
  tools.
<h2 class="Ss" title="Ss" id="VCENTER:_URI"><a class="selflink" href="#VCENTER:_URI">VCENTER:
  URI</a></h2>
The libvirt URI of a vCenter server looks something like this:
<div class="Pp"></div>
<pre>
 vpx://user@server/Datacenter/esxi
</pre>
<div class="Pp"></div>
where:
<dl class="Bl-tag">
  <dt class="It-tag">&quot;user@&quot;</dt>
  <dd class="It-tag">is the (optional, but recommended) user to connect as.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the username contains a backslash (eg. &quot;DOMAIN\USER&quot;) then you
      will need to URI-escape that character using %5c:
      &quot;DOMAIN%5cUSER&quot; (5c is the hexadecimal ASCII code for
      backslash.) Other punctuation may also have to be escaped.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;server&quot;</dt>
  <dd class="It-tag">is the vCenter Server (<i>not</i> hypervisor).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;Datacenter&quot;</dt>
  <dd class="It-tag">is the name of the datacenter.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the name contains a space, replace it with the URI-escape code %20.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;esxi&quot;</dt>
  <dd class="It-tag">is the name of the ESXi hypervisor running the guest.</dd>
</dl>
<div class="Pp"></div>
If the VMware deployment is using folders, then these may need to be added to
  the URI, eg:
<div class="Pp"></div>
<pre>
 vpx://user@server/Folder/Datacenter/esxi
</pre>
<div class="Pp"></div>
For full details of libvirt URIs, see: http://libvirt.org/drvesx.html
<div class="Pp"></div>
Typical errors from libvirt / virsh when the URI is wrong include:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Could not find datacenter specified in [...]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Could not find compute resource specified in [...]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Path [...] does not specify a compute resource</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Path [...] does not specify a host system</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Could not find host system specified in [...]</dd>
</dl>
<h2 class="Ss" title="Ss" id="VCENTER:_TEST_LIBVIRT_CONNECTION_TO_VCENTER"><a class="selflink" href="#VCENTER:_TEST_LIBVIRT_CONNECTION_TO_VCENTER">VCENTER:
  TEST LIBVIRT CONNECTION TO VCENTER</a></h2>
Use the <i>virsh</i>(1) command to list the guests on the vCenter Server like
  this:
<div class="Pp"></div>
<pre>
 $ virsh -c 'vpx://root@vcenter.example.com/Datacenter/esxi' list --all
 Enter root's password for vcenter.example.com: ***
 
  Id    Name                           State
 ----------------------------------------------------
  -     Fedora 20                      shut off
  -     Windows 2003                   shut off
</pre>
<div class="Pp"></div>
If you get an error &quot;Peer certificate cannot be authenticated with given CA
  certificates&quot; or similar, then you can either import the vCenter host's
  certificate, or bypass signature verification by adding the
  &quot;?no_verify=1&quot; flag:
<div class="Pp"></div>
<pre>
 $ virsh -c 'vpx://root@vcenter.example.com/Datacenter/esxi?no_verify=1' list --all
</pre>
<div class="Pp"></div>
You should also try dumping the metadata from any guest on your server, like
  this:
<div class="Pp"></div>
<pre>
 $ virsh -c 'vpx://root@vcenter.example.com/Datacenter/esxi' dumpxml &quot;Windows 2003&quot;
 &lt;domain type='vmware'&gt;
   &lt;name&gt;Windows 2003&lt;/name&gt;
   [...]
 &lt;/domain&gt;
</pre>
<div class="Pp"></div>
<b>If the above commands do not work, then virt-v2v is not going to</b> <b>work
  either</b>. Fix your libvirt configuration and/or your VMware vCenter Server
  before continuing.
<h2 class="Ss" title="Ss" id="VCENTER:_IMPORTING_A_GUEST"><a class="selflink" href="#VCENTER:_IMPORTING_A_GUEST">VCENTER:
  IMPORTING A GUEST</a></h2>
To import a particular guest from vCenter Server, do:
<div class="Pp"></div>
<pre>
 $ virt-v2v -ic 'vpx://root@vcenter.example.com/Datacenter/esxi?no_verify=1' \
   &quot;Windows 2003&quot; \
   -o local -os /var/tmp
</pre>
<div class="Pp"></div>
where &quot;Windows 2003&quot; is the name of the guest (which must be shut
  down).
<div class="Pp"></div>
Note that you may be asked for the vCenter password <i>twice</i>. This happens
  once because libvirt needs it, and a second time because virt-v2v itself
  connects directly to the server. Use <i>--password-file</i> to supply a
  password via a file.
<div class="Pp"></div>
In this case the output flags are set to write the converted guest to a
  temporary directory as this is just an example, but you can also write to
  libvirt or any other supported target.
<h2 class="Ss" title="Ss" id="VCENTER:_NON-ADMINISTRATOR_ROLE"><a class="selflink" href="#VCENTER:_NON-ADMINISTRATOR_ROLE">VCENTER:
  NON-ADMINISTRATOR ROLE</a></h2>
Instead of using the vCenter Administrator role, you can create a custom
  non-administrator role to perform the conversion. You will however need to
  give it a minimum set of permissions as follows:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Create a custom role in vCenter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">Enable (check) the following objects:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 Datastore:
  - Browse datastore
  - Low level file operations
 
 Sessions:
  - Validate session
 
 Virtual Machine:
   Provisioning:
     - Allow disk access
     - Allow read-only disk access
     - Guest Operating system management by VIX API
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="VCENTER:_FIREWALL_AND_PROXY_SETTINGS"><a class="selflink" href="#VCENTER:_FIREWALL_AND_PROXY_SETTINGS">VCENTER:
  FIREWALL AND PROXY SETTINGS</a></h2>
<i>vCenter: Ports</i>
<div class="Pp"></div>
If there is a firewall between the virt-v2v conversion server and the vCenter
  server, then you will need to open port 443 (https) and port 5480.
<div class="Pp"></div>
Port 443 is used to copy the guest disk image(s). Port 5480 is used to query
  vCenter for guest metadata.
<div class="Pp"></div>
These port numbers are only the defaults. It is possible to reconfigure vCenter
  to use other port numbers. In that case you would need to specify those ports
  in the &quot;vpx://&quot; URI. See &quot;VCENTER: URI&quot; above.
<div class="Pp"></div>
These ports only apply to virt-v2v conversions. You may have to open other ports
  for other vCenter functionality, for example the web user interface. VMware
  documents the required ports for vCenter in their online documentation.
<div class="Pp"></div>
<pre>
 &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;   port 443 &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;        &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
 &#x2502; virt-v2v   &#x2502;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; vCenter    &#x2502;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; ESXi       &#x2502;
 &#x2502; conversion &#x2502;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; server     &#x2502;        &#x2502; hypervisor &#x2502;
 &#x2502; server     &#x2502;  port 5480 &#x2502;            &#x2502;        &#x2502;   &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x2502;
 &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;            &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;        &#x2502;   &#x2502;guest&#x2502;  &#x2502;
                                                 &#x2514;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;
</pre>
<div class="Pp"></div>
(In the diagram above the arrows show the direction in which the TCP connection
  is initiated, <i>not</i> necessarily the direction of data transfer.)
<div class="Pp"></div>
Virt-v2v itself does not connect directly to the ESXi hypervisor containing the
  guest. However vCenter connects to the hypervisor and forwards the
  information, so if you have a firewall between vCenter and its hypervisors you
  may need to open additional ports (consult VMware documentation).
<div class="Pp"></div>
<i>vCenter: Proxy settings</i>
<div class="Pp"></div>
To copy the disks, virt-v2v uses <i>libcurl</i>(3). The Curl library obeys the
  proxy environment variables, in particular &quot;https_proxy&quot;,
  &quot;all_proxy&quot; and &quot;no_proxy&quot; (&quot;HTTPS_PROXY&quot;,
  &quot;ALL_PROXY&quot; and &quot;NO_PROXY&quot; can also be used, but the
  lowercase named environment variables take precedence).
<div class="Pp"></div>
If these environment variables are set then copying may happen via the proxy,
  and so a different set of ports may need to be opened in the firewall.
<div class="Pp"></div>
The port 5480 connection never uses a proxy.
<h1 class="Sh" title="Sh" id="INPUT_FROM_VMWARE_OVA"><a class="selflink" href="#INPUT_FROM_VMWARE_OVA">INPUT
  FROM VMWARE OVA</a></h1>
Virt-v2v is able to import guests from VMware's OVA (Open Virtualization
  Appliance) files. Only OVAs exported from VMware vSphere will work.
<h2 class="Ss" title="Ss" id="OVA:_REMOVE_VMWARE_TOOLS_FROM_WINDOWS_GUESTS"><a class="selflink" href="#OVA:_REMOVE_VMWARE_TOOLS_FROM_WINDOWS_GUESTS">OVA:
  REMOVE VMWARE TOOLS FROM WINDOWS GUESTS</a></h2>
For Windows guests, you should remove VMware tools before conversion. Although
  this is not strictly necessary, and the guest will still be able to run, if
  you don't do this then the converted guest will complain on every boot. The
  tools cannot be removed after conversion because the uninstaller checks if it
  is running on VMware and refuses to start (which is also the reason that
  virt-v2v cannot remove them).
<div class="Pp"></div>
This is not necessary for Linux guests, as virt-v2v is able to remove VMware
  tools.
<h2 class="Ss" title="Ss" id="OVA:_CREATE_OVA"><a class="selflink" href="#OVA:_CREATE_OVA">OVA:
  CREATE OVA</a></h2>
To create an OVA in vSphere, use the &quot;Export OVF Template&quot; option
  (from the VM context menu, or from the File menu). Either &quot;Folder of
  files&quot; (OVF) or &quot;Single file&quot; (OVA) will work, but OVA is
  probably easier to deal with. OVA files are really just uncompressed tar
  files, so you can use commands like &quot;tar tf VM.ova&quot; to view their
  contents.
<div class="Pp"></div>
<i>Create OVA with ovftool</i>
<div class="Pp"></div>
You can also use VMware's proprietary &quot;ovftool&quot;:
<div class="Pp"></div>
<pre>
 ovftool --noSSLVerify \
   vi://USER:PASSWORD@esxi.example.com/VM \
   VM.ova
</pre>
<div class="Pp"></div>
To connect to vCenter:
<div class="Pp"></div>
<pre>
 ovftool  --noSSLVerify \
   vi://USER:PASSWORD@vcenter.example.com/DATACENTER-NAME/vm/VM \
   VM.ova
</pre>
<div class="Pp"></div>
For Active Directory-aware authentication, you have to express the &quot;@&quot;
  character in the form of its ascii hex-code (%5c):
<div class="Pp"></div>
<pre>
 vi://DOMAIN%5cUSER:PASSWORD@...
</pre>
<h2 class="Ss" title="Ss" id="OVA:_IMPORTING_A_GUEST"><a class="selflink" href="#OVA:_IMPORTING_A_GUEST">OVA:
  IMPORTING A GUEST</a></h2>
To import an OVA file called <i>VM.ova</i>, do;
<div class="Pp"></div>
<pre>
 $ virt-v2v -i ova VM.ova -o local -os /var/tmp
</pre>
<div class="Pp"></div>
If you exported the guest as a &quot;Folder of files&quot;, <i>or</i> if you
  unpacked the OVA tarball yourself, then you can point virt-v2v at the
  directory containing the files:
<div class="Pp"></div>
<pre>
 $ virt-v2v -i ova /path/to/files -o local -os /var/tmp
</pre>
<h1 class="Sh" title="Sh" id="INPUT_FROM_VMWARE_ESXi_HYPERVISOR"><a class="selflink" href="#INPUT_FROM_VMWARE_ESXi_HYPERVISOR">INPUT
  FROM VMWARE ESXi HYPERVISOR</a></h1>
Virt-v2v cannot access an ESXi hypervisor directly. You should use the OVA
  method above (see &quot;INPUT FROM VMWARE OVA&quot;) if possible, as it is
  much faster and requires much less disk space than the method described in
  this section.
<div class="Pp"></div>
You can use the <i>virt-v2v-copy-to-local</i>(1) tool to copy the guest off the
  hypervisor into a local file, and then convert it.
<h2 class="Ss" title="Ss" id="ESXi:_REMOVE_VMWARE_TOOLS_FROM_WINDOWS_GUESTS"><a class="selflink" href="#ESXi:_REMOVE_VMWARE_TOOLS_FROM_WINDOWS_GUESTS">ESXi:
  REMOVE VMWARE TOOLS FROM WINDOWS GUESTS</a></h2>
For Windows guests, you should remove VMware tools before conversion. Although
  this is not strictly necessary, and the guest will still be able to run, if
  you don't do this then the converted guest will complain on every boot. The
  tools cannot be removed after conversion because the uninstaller checks if it
  is running on VMware and refuses to start (which is also the reason that
  virt-v2v cannot remove them).
<div class="Pp"></div>
This is not necessary for Linux guests, as virt-v2v is able to remove VMware
  tools.
<h2 class="Ss" title="Ss" id="ESXi:_URI"><a class="selflink" href="#ESXi:_URI">ESXi:
  URI</a></h2>
The libvirt URI for VMware ESXi hypervisors will look something like this:
<div class="Pp"></div>
<pre>
 esx://root@esxi.example.com?no_verify=1
</pre>
<div class="Pp"></div>
The &quot;?no_verify=1&quot; parameter disables TLS certificate checking.
<h2 class="Ss" title="Ss" id="ESXi:_TEST_LIBVIRT_CONNECTION_TO_ESXi_HYPERVISOR"><a class="selflink" href="#ESXi:_TEST_LIBVIRT_CONNECTION_TO_ESXi_HYPERVISOR">ESXi:
  TEST LIBVIRT CONNECTION TO ESXi HYPERVISOR</a></h2>
Use the <i>virsh</i>(1) command to test the URI and list the remote guests
  available:
<div class="Pp"></div>
<pre>
 $ virsh -c esx://root@esxi.example.com?no_verify=1 list --all
 Enter root's password for esxi.example.com: ***
  Id    Name                           State
 ----------------------------------------------------
  -     guest                          shut off
</pre>
<h2 class="Ss" title="Ss" id="ESXi:_COPY_THE_GUEST_TO_THE_LOCAL_MACHINE"><a class="selflink" href="#ESXi:_COPY_THE_GUEST_TO_THE_LOCAL_MACHINE">ESXi:
  COPY THE GUEST TO THE LOCAL MACHINE</a></h2>
Using the libvirt URI as the <i>-ic</i> option, copy one of the guests to the
  local machine:
<div class="Pp"></div>
<pre>
 $ virt-v2v-copy-to-local -ic esx://root@esxi.example.com?no_verify=1 guest
</pre>
<div class="Pp"></div>
This creates <i>guest.xml</i>, <i>guest-disk1</i>, ...
<h2 class="Ss" title="Ss" id="ESXi:_DO_THE_VIRT-V2V_CONVERSION"><a class="selflink" href="#ESXi:_DO_THE_VIRT-V2V_CONVERSION">ESXi:
  DO THE VIRT-V2V CONVERSION</a></h2>
Perform the conversion of the guest using virt-v2v:
<div class="Pp"></div>
<pre>
 $ virt-v2v -i libvirtxml guest.xml -o local -os /var/tmp
</pre>
<h2 class="Ss" title="Ss" id="ESXi:_CLEAN_UP"><a class="selflink" href="#ESXi:_CLEAN_UP">ESXi:
  CLEAN UP</a></h2>
Remove the <i>guest.xml</i> and <i>guest-disk*</i> files.
<h1 class="Sh" title="Sh" id="INPUT_FROM_RHEL_5_XEN"><a class="selflink" href="#INPUT_FROM_RHEL_5_XEN">INPUT
  FROM RHEL 5 XEN</a></h1>
Virt-v2v is able to import Xen guests from RHEL 5 Xen hosts.
<div class="Pp"></div>
Virt-v2v uses libvirt for access to the remote Xen host, and therefore the input
  mode should be <i>-i libvirt</i>. As this is the default, you don't need to
  specify it on the command line.
<h2 class="Ss" title="Ss" id="XEN:_SET_UP_SSH-AGENT_ACCESS_TO_XEN_HOST"><a class="selflink" href="#XEN:_SET_UP_SSH-AGENT_ACCESS_TO_XEN_HOST">XEN:
  SET UP SSH-AGENT ACCESS TO XEN HOST</a></h2>
Currently you must enable passwordless SSH access to the remote Xen host from
  the virt-v2v conversion server.
<div class="Pp"></div>
You must also use ssh-agent, and add your ssh public key to
  <i>/root/.ssh/authorized_keys</i> (on the Xen host).
<div class="Pp"></div>
After doing this, you should check that passwordless access works from the
  virt-v2v server to the Xen host. For example:
<div class="Pp"></div>
<pre>
 $ ssh root@xen.example.com
 [ logs straight into the shell, no password is requested ]
</pre>
<div class="Pp"></div>
Note that password-interactive and Kerberos access are <b>not</b> supported. You
  <b>have</b> to set up ssh access using ssh-agent and authorized_keys.
<h2 class="Ss" title="Ss" id="XEN:_TEST_LIBVIRT_CONNECTION_TO_REMOTE_XEN_HOST"><a class="selflink" href="#XEN:_TEST_LIBVIRT_CONNECTION_TO_REMOTE_XEN_HOST">XEN:
  TEST LIBVIRT CONNECTION TO REMOTE XEN HOST</a></h2>
Use the <i>virsh</i>(1) command to list the guests on the remote Xen host:
<div class="Pp"></div>
<pre>
 $ virsh -c xen+ssh://root@xen.example.com list --all
  Id    Name                           State
 ----------------------------------------------------
  0     Domain-0                       running
  -     rhel49-x86_64-pv               shut off
</pre>
<div class="Pp"></div>
You should also try dumping the metadata from any guest on your server, like
  this:
<div class="Pp"></div>
<pre>
 $ virsh -c xen+ssh://root@xen.example.com dumpxml rhel49-x86_64-pv
 &lt;domain type='xen'&gt;
   &lt;name&gt;rhel49-x86_64-pv&lt;/name&gt;
   [...]
 &lt;/domain&gt;
</pre>
<div class="Pp"></div>
<b>If the above commands do not work, then virt-v2v is not going to</b> <b>work
  either</b>. Fix your libvirt configuration or the remote server before
  continuing.
<div class="Pp"></div>
<b>If the guest disks are located on a host block device</b>, then the
  conversion will fail. See &quot;XEN OR SSH CONVERSIONS FROM BLOCK
  DEVICES&quot; below for a workaround.
<h2 class="Ss" title="Ss" id="XEN:_IMPORTING_A_GUEST"><a class="selflink" href="#XEN:_IMPORTING_A_GUEST">XEN:
  IMPORTING A GUEST</a></h2>
To import a particular guest from a Xen server, do:
<div class="Pp"></div>
<pre>
 $ virt-v2v -ic 'xen+ssh://root@xen.example.com' \
   rhel49-x86_64-pv \
   -o local -os /var/tmp
</pre>
<div class="Pp"></div>
where &quot;rhel49-x86_64-pv&quot; is the name of the guest (which must be shut
  down).
<div class="Pp"></div>
In this case the output flags are set to write the converted guest to a
  temporary directory as this is just an example, but you can also write to
  libvirt or any other supported target.
<h2 class="Ss" title="Ss" id="XEN_OR_SSH_CONVERSIONS_FROM_BLOCK_DEVICES"><a class="selflink" href="#XEN_OR_SSH_CONVERSIONS_FROM_BLOCK_DEVICES">XEN
  OR SSH CONVERSIONS FROM BLOCK DEVICES</a></h2>
Currently virt-v2v cannot directly access a Xen guest (or any guest located
  remotely over ssh) if that guest's disks are located on host block devices.
<div class="Pp"></div>
To tell if a Xen guest uses host block devices, look at the guest XML. You will
  see:
<div class="Pp"></div>
<pre>
  &lt;disk type='block' device='disk'&gt;
    ...
    &lt;source dev='/dev/VG/guest'/&gt;
</pre>
<div class="Pp"></div>
where &quot;type='block'&quot;, &quot;source dev=&quot; and &quot;/dev/...&quot;
  are all indications that the disk is located on a host block device.
<div class="Pp"></div>
This happens because the qemu ssh block driver that we use to access remote
  disks uses the ssh sftp protocol, and this protocol cannot correctly detect
  the size of host block devices.
<div class="Pp"></div>
The workaround is to copy the guest over to the conversion server, using the
  separate <i>virt-v2v-copy-to-local</i>(1) tool, followed by running virt-v2v.
  You will need sufficient space on the conversion server to store a full copy
  of the guest.
<div class="Pp"></div>
<pre>
 virt-v2v-copy-to-local -ic xen+ssh://root@xen.example.com guest
 virt-v2v -i libvirtxml guest.xml -o local -os /var/tmp
 rm guest.xml guest-disk*
</pre>
<h1 class="Sh" title="Sh" id="OUTPUT_TO_LIBVIRT"><a class="selflink" href="#OUTPUT_TO_LIBVIRT">OUTPUT
  TO LIBVIRT</a></h1>
The <i>-o libvirt</i> option lets you upload the converted guest to a
  libvirt-managed host. There are several limitations:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can only use a local libvirt connection [see below for
      how to workaround this].</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The <i>-os pool</i> option must specify a directory pool,
      not anything more exotic such as iSCSI [but see below].</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can only upload to a KVM hypervisor.</dd>
</dl>
<div class="Pp"></div>
<b>To output to a remote libvirt instance and/or a non-directory storage
  pool</b> you have to use the following workaround:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Use virt-v2v in <i>-o local</i> mode to convert the guest
      disks and metadata into a local temporary directory:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 virt-v2v [...] -o local -os /var/tmp
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This creates two (or more) files in <i>/var/tmp</i> called:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 /var/tmp/NAME.xml     # the libvirt XML (metadata)
 /var/tmp/NAME-sda     # the guest's first disk
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    (for &quot;NAME&quot; substitute the guest's name).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">Upload the converted disk(s) into the storage pool called
      &quot;POOL&quot;:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 size=$(stat -c%s /var/tmp/NAME-sda)
 virsh vol-create-as POOL NAME-sda $size --format raw
 virsh vol-upload --pool POOL NAME-sda /var/tmp/NAME-sda
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Edit <i>/var/tmp/NAME.xml</i> to change
      <i>/var/tmp/NAME-sda</i> to the pool name. In other words, locate the
      following bit of XML:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 &lt;disk type='file' device='disk'&gt;
   &lt;driver name='qemu' type='raw' cache='none' /&gt;
   &lt;source file='/var/tmp/NAME-sda' /&gt;
   &lt;target dev='hda' bus='ide' /&gt;
 &lt;/disk&gt;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and change two things: The &quot;type='file'&quot; attribute must be changed
      to &quot;type='volume'&quot;, and the &quot;&lt;source&gt;&quot; element
      must be changed to include &quot;pool&quot; and &quot;volume&quot;
      attributes:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 &lt;disk type='volume' device='disk'&gt;
   ...
   &lt;source pool='POOL' volume='NAME-sda' /&gt;
   ...
 &lt;/disk&gt;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">Define the final guest in libvirt:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 virsh define /var/tmp/NAME.xml
    </pre>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="OUTPUT_TO_RHEV"><a class="selflink" href="#OUTPUT_TO_RHEV">OUTPUT
  TO RHEV</a></h1>
This section only applies to the <i>-o rhev</i> output mode. If you use virt-v2v
  from the RHEV-M user interface, then behind the scenes the import is managed
  by VDSM using the <i>-o vdsm</i> output mode (which end users should not try
  to use directly).
<div class="Pp"></div>
You have to specify <i>-o rhev</i> and an <i>-os</i> option that points to the
  RHEV-M Export Storage Domain. You can either specify the NFS server and
  mountpoint, eg. &quot;-os&#x00A0;rhev-storage:/rhev/export&quot;, or you can
  mount that first and point to the directory where it is mounted, eg.
  &quot;-os&#x00A0;/tmp/mnt&quot;. Be careful not to point to the Data Storage
  Domain by accident as that will not work.
<div class="Pp"></div>
On successful completion virt-v2v will have written the new guest to the Export
  Storage Domain, but it will not yet be ready to run. It must be imported into
  RHEV using the UI before it can be used.
<div class="Pp"></div>
In RHEV &#x2265; 2.2 this is done from the Storage tab. Select the export domain
  the guest was written to. A pane will appear underneath the storage domain
  list displaying several tabs, one of which is &quot;VM Import&quot;. The
  converted guest will be listed here. Select the appropriate guest an click
  &quot;Import&quot;. See the RHEV documentation for additional details.
<div class="Pp"></div>
If you export several guests, then you can import them all at the same time
  through the UI.
<h1 class="Sh" title="Sh" id="OUTPUT_TO_GLANCE"><a class="selflink" href="#OUTPUT_TO_GLANCE">OUTPUT
  TO GLANCE</a></h1>
To output to OpenStack Glance, use the <i>-o glance</i> option.
<div class="Pp"></div>
This runs the <i>glance</i>(1) CLI program which must be installed on the
  virt-v2v conversion host. For authentication to work, you will need to set
  &quot;OS_*&quot; environment variables. In most cases you can do this by
  sourcing a file called something like <i>keystonerc_admin</i>.
<div class="Pp"></div>
Virt-v2v adds metadata for the guest to Glance, describing such things as the
  guest operating system and what drivers it requires. The command &quot;glance
  image-show&quot; will display the metadata as &quot;Property&quot; fields such
  as &quot;os_type&quot; and &quot;hw_disk_bus&quot;.
<h2 class="Ss" title="Ss" id="Glance_and_sparseness"><a class="selflink" href="#Glance_and_sparseness">Glance
  and sparseness</a></h2>
Glance image upload doesn't appear to correctly handle sparseness. For this
  reason, using qcow2 will be faster and use less space on the Glance server.
  Use the virt-v2v <i>-of&#x00A0;qcow2</i> option.
<h2 class="Ss" title="Ss" id="Glance_and_multiple_disks"><a class="selflink" href="#Glance_and_multiple_disks">Glance
  and multiple disks</a></h2>
If the guest has a single disk, then the name of the disk in Glance will be the
  name of the guest. You can control this using the <i>-on</i> option.
<div class="Pp"></div>
Glance doesn't have a concept of associating multiple disks with a single guest,
  and Nova doesn't allow you to boot a guest from multiple Glance disks either.
  If the guest has multiple disks, then the first (assumed to be the system
  disk) will have the name of the guest, and the second and subsequent data
  disks will be called &quot; <i>guestname</i>-disk2&quot;,
  &quot;<i>guestname</i>-disk3&quot; etc. It may be best to leave the system
  disk in Glance, and import the data disks to Cinder (see next section).
<h2 class="Ss" title="Ss" id="Importing_disks_into_Cinder"><a class="selflink" href="#Importing_disks_into_Cinder">Importing
  disks into Cinder</a></h2>
Since most virt-v2v guests are &quot;pets&quot;, Glance is perhaps not the best
  place to store them. There is no way for virt-v2v to upload directly to Cinder
  (https://bugzilla.redhat.com/1155229). There are two ways to upload to Cinder:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Import the image to Glance first (ie. <i>-o glance</i>) and
      then copy it to Cinder:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 cinder create --image-id &lt;GLANCE-IMAGE-UUID&gt; &lt;SIZE&gt;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">Create (through some other means) a new volume / LUN in
      your Cinder backing store. Migrate the guest to this volume (using <i>-o
      local</i>). Then ask Cinder to take over management of the volume using:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 cinder manage &lt;VOLUMEREF&gt;
    </pre>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="RESOURCE_REQUIREMENTS"><a class="selflink" href="#RESOURCE_REQUIREMENTS">RESOURCE
  REQUIREMENTS</a></h1>
<h2 class="Ss" title="Ss" id="Network"><a class="selflink" href="#Network">Network</a></h2>
The most important resource for virt-v2v appears to be network bandwidth.
  Virt-v2v should be able to copy guest data at gigabit ethernet speeds or
  greater.
<div class="Pp"></div>
Ensure that the network connections between servers (conversion server, NFS
  server, vCenter, Xen) are as fast and as low latency as possible.
<h2 class="Ss" title="Ss" id="Disk_space"><a class="selflink" href="#Disk_space">Disk
  space</a></h2>
Virt-v2v places potentially large temporary files in $TMPDIR (which is
  <i>/var/tmp</i> if you don't set it). Using tmpfs is a bad idea.
<div class="Pp"></div>
For each guest disk, an overlay is stored temporarily. This stores the changes
  made during conversion, and is used as a cache. The overlays are not
  particularly large - tens or low hundreds of megabytes per disk is typical. In
  addition to the overlay(s), input and output methods may use disk space, as
  outlined in the table below.
<dl class="Bl-tag">
  <dt class="It-tag"><i>-i ova</i></dt>
  <dd class="It-tag">This temporarily places a full copy of the uncompressed
      source disks in $TMPDIR.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>-o glance</i></dt>
  <dd class="It-tag">This temporarily places a full copy of the output disks in
      $TMPDIR.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>-o local</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>-o qemu</i></dt>
  <dd class="It-tag">You must ensure there is sufficient space in the output
      directory for the converted guest.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>-o null</i></dt>
  <dd class="It-tag">This temporarily places a full copy of the output disks in
      $TMPDIR.</dd>
</dl>
<div class="Pp"></div>
See also &quot;Minimum free space check in the host&quot; below.
<h2 class="Ss" title="Ss" id="VMware_vCenter_resources"><a class="selflink" href="#VMware_vCenter_resources">VMware
  vCenter resources</a></h2>
Copying from VMware vCenter is currently quite slow, but we believe this to be
  an issue with VMware. Ensuring the VMware ESXi hypervisor and vCenter are
  running on fast hardware with plenty of memory should alleviate this.
<h2 class="Ss" title="Ss" id="Compute_power_and_RAM"><a class="selflink" href="#Compute_power_and_RAM">Compute
  power and RAM</a></h2>
Virt-v2v is not especially compute or RAM intensive. If you are running many
  parallel conversions, then you may consider allocating one CPU core and
  between 512 MB and 1 GB of RAM per running instance.
<div class="Pp"></div>
Virt-v2v can be run in a virtual machine.
<h2 class="Ss" title="Ss" id="Trimming"><a class="selflink" href="#Trimming">Trimming</a></h2>
Virt-v2v attempts to optimize the speed of conversion by ignoring guest
  filesystem data which is not used. This would include unused filesystem
  blocks, blocks containing zeroes, and deleted files.
<div class="Pp"></div>
To do this, virt-v2v issues a non-destructive <i>fstrim</i>(8) operation. As
  this happens to an overlay placed over the guest data, it does <b>not</b>
  affect the source in any way.
<div class="Pp"></div>
If this fstrim operation fails, you will see a warning, but virt-v2v will
  continue anyway. It may run more slowly (in some cases much more slowly),
  because it is copying the unused parts of the disk.
<div class="Pp"></div>
Unfortunately support for fstrim is not universal, and it also depends on
  specific details of the filesystem, partition alignment, and backing storage.
  As an example, NTFS filesystems cannot be fstrimmed if they occupy a partition
  which is not aligned to the underlying storage. That was the default on
  Windows before Vista. As another example, VFAT filesystems (used by UEFI
  guests) cannot be trimmed at all.
<div class="Pp"></div>
fstrim support in the Linux kernel is improving gradually, so over time some of
  these restrictions will be lifted and virt-v2v will work faster.
<h1 class="Sh" title="Sh" id="POST-CONVERSION_TASKS"><a class="selflink" href="#POST-CONVERSION_TASKS">POST-CONVERSION
  TASKS</a></h1>
<h2 class="Ss" title="Ss" id="Guest_network_configuration"><a class="selflink" href="#Guest_network_configuration">Guest
  network configuration</a></h2>
Virt-v2v cannot currently reconfigure a guest's network configuration. If the
  converted guest is not connected to the same subnet as the source, its network
  configuration may have to be updated. See also <i>virt-customize</i>(1).
<h2 class="Ss" title="Ss" id="Converting_a_Windows_guest"><a class="selflink" href="#Converting_a_Windows_guest">Converting
  a Windows guest</a></h2>
When converting a Windows guests, the conversion process is split into two
  stages:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Offline conversion.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">First boot.</dd>
</dl>
<div class="Pp"></div>
The guest will be bootable after the offline conversion stage, but will not yet
  have all necessary drivers installed to work correctly. These will be
  installed automatically the first time the guest boots.
<div class="Pp"></div>
<b>N.B.</b> Take care not to interrupt the automatic driver installation process
  when logging in to the guest for the first time, as this may prevent the guest
  from subsequently booting correctly.
<h1 class="Sh" title="Sh" id="FREE_SPACE_FOR_CONVERSION"><a class="selflink" href="#FREE_SPACE_FOR_CONVERSION">FREE
  SPACE FOR CONVERSION</a></h1>
<h2 class="Ss" title="Ss" id="Free_space_in_the_guest"><a class="selflink" href="#Free_space_in_the_guest">Free
  space in the guest</a></h2>
Virt-v2v checks there is sufficient free space in the guest filesystem to
  perform the conversion. Currently it checks:
<dl class="Bl-tag">
  <dt class="It-tag">Linux root filesystem or Windows &quot;C:&quot; drive</dt>
  <dd class="It-tag">Minimum free space: 20 MB</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Linux <i>/boot</i></dt>
  <dd class="It-tag">Minimum free space: 50 MB
    <div style="height: 1.00em;">&#x00A0;</div>
    This is because we need to build a new initramfs for some Enterprise Linux
      conversions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Any other mountable filesystem</dt>
  <dd class="It-tag">Minimum free space: 10 MB</dd>
</dl>
<h2 class="Ss" title="Ss" id="Minimum_free_space_check_in_the_host"><a class="selflink" href="#Minimum_free_space_check_in_the_host">Minimum
  free space check in the host</a></h2>
You must have sufficient free space in the host directory used to store
  temporary overlays (except in <i>--in-place</i> mode). To find out which
  directory this is, use:
<div class="Pp"></div>
<pre>
 $ df -h &quot;`guestfish get-cachedir`&quot;
 Filesystem        Size  Used Avail Use% Mounted on
 /dev/mapper/root   50G   40G  6.8G  86% /
</pre>
<div class="Pp"></div>
and look under the &quot;Avail&quot; column. Virt-v2v will refuse to do the
  conversion at all unless at least 1GB is available there.
<div class="Pp"></div>
See also &quot;RESOURCE REQUIREMENTS&quot; above.
<h1 class="Sh" title="Sh" id="RUNNING_VIRT-V2V_AS_ROOT_OR_NON-ROOT"><a class="selflink" href="#RUNNING_VIRT-V2V_AS_ROOT_OR_NON-ROOT">RUNNING
  VIRT-V2V AS ROOT OR NON-ROOT</a></h1>
Nothing in virt-v2v inherently needs root access, and it will run just fine as a
  non-root user. However, certain external features may require either root or a
  special user:
<dl class="Bl-tag">
  <dt class="It-tag">Mounting the Export Storage Domain</dt>
  <dd class="It-tag">When using <i>-o rhev -os server:/esd</i> virt-v2v has to
      have sufficient privileges to NFS mount the Export Storage Domain from
      &quot;server&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can avoid needing root here by mounting it yourself before running
      virt-v2v, and passing <i>-os /mountpoint</i> instead, but first of all
      read the next section&#x00A0;...</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Writing to the Export Storage Domain as 36:36</dt>
  <dd class="It-tag">RHEV-M cannot read files and directories from the Export
      Storage Domain unless they have UID:GID 36:36. You will see VM import
      problems if the UID:GID is not correct.
    <div style="height: 1.00em;">&#x00A0;</div>
    When you run virt-v2v <i>-o rhev</i> as root, virt-v2v attempts to create
      files and directories with the correct ownership. If you run virt-v2v as
      non-root, it will probably still work, but you will need to manually
      change ownership after virt-v2v has finished.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Writing to libvirt</dt>
  <dd class="It-tag">When using <i>-o libvirt</i>, you may need to run virt-v2v
      as root so that it can write to the libvirt system instance (ie.
      &quot;qemu:///system&quot;) and to the default location for disk images
      (usually <i>/var/lib/libvirt/images</i>).
    <div style="height: 1.00em;">&#x00A0;</div>
    You can avoid this by setting up libvirt connection authentication, see
      http://libvirt.org/auth.html. Alternatively, use <i>-oc
      qemu:///session</i>, which will write to your per-user libvirt
    instance.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Writing to Glance</dt>
  <dd class="It-tag">This does <i>not</i> need root (in fact it probably won't
      work), but may require either a special user and/or for you to source a
      script that sets authentication environment variables. Consult the Glance
      documentation.</dd>
</dl>
<h1 class="Sh" title="Sh" id="DEBUGGING_RHEV-M_IMPORT_FAILURES"><a class="selflink" href="#DEBUGGING_RHEV-M_IMPORT_FAILURES">DEBUGGING
  RHEV-M IMPORT FAILURES</a></h1>
When you export to the RHEV-M Export Storage Domain, and then import that guest
  through the RHEV-M UI, you may encounter an import failure. Diagnosing these
  failures is infuriatingly difficult as the UI generally hides the true reason
  for the failure.
<div class="Pp"></div>
There are two log files of interest. The first is stored on the RHEV-M server
  itself, and is called <i>/var/log/ovirt-engine/engine.log</i>
<div class="Pp"></div>
The second file, which is the most useful, is found on the SPM host (SPM stands
  for &quot;Storage Pool Manager&quot;). This is a RHEV node that is elected to
  do all metadata modifications in the data center, such as image or snapshot
  creation. You can find out which host is the current SPM from the
  &quot;Hosts&quot; tab &quot;Spm Status&quot; column. Once you have located the
  SPM, log into it and grab the file <i>/var/log/vdsm/vdsm.log</i> which will
  contain detailed error messages from low-level commands.
<h1 class="Sh" title="Sh" id="MINIMAL_XML_FOR_-i_libvirtxml_OPTION"><a class="selflink" href="#MINIMAL_XML_FOR_-i_libvirtxml_OPTION">MINIMAL
  XML FOR -i libvirtxml OPTION</a></h1>
When using the <i>-i libvirtxml</i> option, you have to supply some libvirt XML.
  Writing this from scratch is hard, so the template below is helpful.
<div class="Pp"></div>
<b>Note this should only be used for testing and/or where you know what</b>
  <b>you're doing!</b> If you have libvirt metadata for the guest, always use
  that instead.
<div class="Pp"></div>
<pre>
 &lt;domain type='kvm'&gt;
   &lt;name&gt;NAME&lt;/name&gt;
   &lt;memory&gt;1048576&lt;/memory&gt;
   &lt;vcpu&gt;2&lt;/vcpu&gt;
   &lt;os&gt;
     &lt;type&gt;hvm&lt;/type&gt;
     &lt;boot dev='hd'/&gt;
   &lt;/os&gt;
   &lt;features&gt;
     &lt;acpi/&gt;
     &lt;apic/&gt;
     &lt;pae/&gt;
   &lt;/features&gt;
   &lt;devices&gt;
     &lt;disk type='file' device='disk'&gt;
       &lt;driver name='qemu' type='raw'/&gt;
       &lt;source file='/path/to/disk/image'/&gt;
       &lt;target dev='hda' bus='ide'/&gt;
     &lt;/disk&gt;
     &lt;interface type='network'&gt;
       &lt;mac address='52:54:00:01:02:03'/&gt;
       &lt;source network='default'/&gt;
       &lt;model type='rtl8139'/&gt;
     &lt;/interface&gt;
   &lt;/devices&gt;
 &lt;/domain&gt;
</pre>
<h1 class="Sh" title="Sh" id="MACHINE_READABLE_OUTPUT"><a class="selflink" href="#MACHINE_READABLE_OUTPUT">MACHINE
  READABLE OUTPUT</a></h1>
The <i>--machine-readable</i> option can be used to make the output more machine
  friendly, which is useful when calling virt-v2v from other programs, GUIs etc.
<div class="Pp"></div>
There are two ways to use this option.
<div class="Pp"></div>
Firstly use the option on its own to query the capabilities of the virt-v2v
  binary. Typical output looks like this:
<div class="Pp"></div>
<pre>
 $ virt-v2v --machine-readable
 virt-v2v
 libguestfs-rewrite
 input:disk
 [...]
 output:local
 [...]
 convert:enterprise-linux
 convert:windows
</pre>
<div class="Pp"></div>
A list of features is printed, one per line, and the program exits with status
  0.
<div class="Pp"></div>
The &quot;input:&quot; and &quot;output:&quot; features refer to <i>-i</i> and
  <i>-o</i> (input and output mode) options supported by this binary. The
  &quot;convert:&quot; features refer to guest types that this binary knows how
  to convert.
<div class="Pp"></div>
Secondly use the option in conjunction with other options to make the regular
  program output more machine friendly.
<div class="Pp"></div>
At the moment this means:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Progress bar messages can be parsed from stdout by looking
      for this regular expression:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 ^[0-9]+/[0-9]+$
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">The calling program should treat messages sent to stdout
      (except for progress bar messages) as status messages. They can be logged
      and/or displayed to the user.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">The calling program should treat messages sent to stderr as
      error messages. In addition, virt-v2v exits with a non-zero status code if
      there was a fatal error.</dd>
</dl>
<div class="Pp"></div>
Virt-v2v &#x2264; 0.9.1 did not support the <i>--machine-readable</i> option at
  all. The option was added when virt-v2v was rewritten in 2014.
<h1 class="Sh" title="Sh" id="FILES"><a class="selflink" href="#FILES">FILES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><i>/usr/share/virtio-win</i></dt>
  <dd class="It-tag">(Optional)
    <div style="height: 1.00em;">&#x00A0;</div>
    If this directory is present, then virtio drivers for Windows guests will be
      found from this directory and installed in the guest during
    conversion.</dd>
</dl>
<h1 class="Sh" title="Sh" id="ENVIRONMENT_VARIABLES"><a class="selflink" href="#ENVIRONMENT_VARIABLES">ENVIRONMENT
  VARIABLES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;TMPDIR&quot;</dt>
  <dd class="It-tag">Location of the temporary directory used for the
      potentially large temporary overlay file.
    <div style="height: 1.00em;">&#x00A0;</div>
    See the &quot;Disk space&quot; section above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;VIRT_TOOLS_DATA_DIR&quot;</dt>
  <dd class="It-tag">This can point to the directory containing data files used
      for Windows conversion.
    <div style="height: 1.00em;">&#x00A0;</div>
    Normally you do not need to set this. If not set, a compiled-in default will
      be used (something like <i>/usr/share/virt-tools</i>).
    <div style="height: 1.00em;">&#x00A0;</div>
    This directory may contain the following files:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>rhsrvany.exe</i></dt>
  <dd class="It-tag">(Required when doing conversions of Windows guests)
    <div style="height: 1.00em;">&#x00A0;</div>
    This is the RHSrvAny Windows binary, used to install a &quot;firstboot&quot;
      script in the guest during conversion of Windows guests.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also: &quot;https://github.com/rwmjones/rhsrvany&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>rhev-apt.exe</i></dt>
  <dd class="It-tag">(Optional)
    <div style="height: 1.00em;">&#x00A0;</div>
    The RHEV Application Provisioning Tool (RHEV APT). If this file is present,
      then RHEV APT will be installed in the Windows guest during conversion.
      This tool is a guest agent which ensures that the virtio drivers remain up
      to date when the guest is running on Red Hat Enterprise Virtualization
      (RHEV).
    <div style="height: 1.00em;">&#x00A0;</div>
    This file comes from Red Hat Enterprise Virtualization (RHEV), and is not
      distributed with virt-v2v.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;VIRTIO_WIN&quot;</dt>
  <dd class="It-tag">This is where VirtIO drivers for Windows are searched for (
      <i>/usr/share/virtio-win</i> if unset). It can be a directory <i>or</i>
      point to <i>virtio-win.iso</i> (CD ROM image containing drivers).
    <div style="height: 1.00em;">&#x00A0;</div>
    See &quot;ENABLING VIRTIO&quot;.</dd>
</dl>
<div class="Pp"></div>
For other environment variables, see &quot;ENVIRONMENT VARIABLES&quot; in
  <i>guestfs</i>(3).
<h1 class="Sh" title="Sh" id="OTHER_TOOLS"><a class="selflink" href="#OTHER_TOOLS">OTHER
  TOOLS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><i>virt-v2v-copy-to-local</i>(1)</dt>
  <dd class="It-tag">There are some special cases where virt-v2v cannot directly
      access the remote hypervisor. In that case you have to use
      <i>virt-v2v-copy-to-local</i>(1) to make a local copy of the guest first,
      followed by running &quot;virt-v2v -i libvirtxml&quot; to perform the
      conversion.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>engine-image-uploader</i>(8)</dt>
  <dd class="It-tag">Variously called &quot;engine-image-uploader&quot;,
      &quot;ovirt-image-uploader&quot; or &quot;rhevm-image-uploader&quot;, this
      tool allows you to copy a guest from one oVirt or RHEV Export Storage
      Domain to another. It only permits importing a guest that was previously
      exported from another oVirt/RHEV instance.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">import-to-ovirt.pl</dt>
  <dd class="It-tag">This script can be used to import guests that already run
      on KVM to oVirt or RHEV. For more information, see this blog posting by
      the author of virt-v2v:
    <div style="height: 1.00em;">&#x00A0;</div>
    https://rwmj.wordpress.com/2015/09/18/importing-kvm-guests-to-ovirt-or-rhev/#content</dd>
</dl>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>virt-p2v</i>(1), <i>virt-customize</i>(1), <i>virt-df</i>(1),
  <i>virt-filesystems</i>(1), <i>virt-sparsify</i>(1), <i>virt-sysprep</i>(1),
  <i>guestfs</i>(3), <i>guestfish</i>(1), <i>qemu-img</i>(1), <i>fstrim</i>(8),
  <i>virt-v2v-copy-to-local</i>(1), <i>virt-v2v-test-harness</i>(1),
  <i>engine-image-uploader</i>(8), import-to-ovirt.pl, http://libguestfs.org/.
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Richard W.M. Jones http://people.redhat.com/~rjones/
<div class="Pp"></div>
Matthew Booth
<div class="Pp"></div>
Mike Latimer
<div class="Pp"></div>
Pino Toscano
<div class="Pp"></div>
Shahar Havivi
<div class="Pp"></div>
Tingting Zheng
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (C) 2009-2016 Red Hat Inc.
<h1 class="Sh" title="Sh" id="LICENSE"><a class="selflink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any later
  version.
<div class="Pp"></div>
This program is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE. See the GNU General Public License for more details.
<div class="Pp"></div>
You should have received a copy of the GNU General Public License along with
  this program; if not, write to the Free Software Foundation, Inc., 51 Franklin
  Street, Fifth Floor, Boston, MA 02110-1301 USA.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
To get a list of bugs against libguestfs, use this link:
  https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools
<div class="Pp"></div>
To report a new bug against libguestfs, use this link:
  https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools
<div class="Pp"></div>
When reporting a bug, please supply:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The version of libguestfs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Where you got libguestfs (eg. which Linux distro, compiled
      from source, etc)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Describe the bug accurately and give a way to reproduce
    it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Run <i>libguestfs-test-tool</i>(1) and paste the
      <b>complete, unedited</b> output into the bug report.</dd>
</dl>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-08-08</td>
    <td class="foot-os">libguestfs-1.32.7</td>
  </tr>
</table>
</body>
</html>
