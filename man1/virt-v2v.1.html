<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:42:22 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>virt-v2v(1) Virtualization Support virt-v2v(1)</p>

<p style="margin-top: 1em">NAME <br>
virt-v2v - Convert a guest to use KVM</p>

<p style="margin-top: 1em">SYNOPSIS <br>
virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi
vmware_guest</p>

<p style="margin-top: 1em">virt-v2v -ic
vpx://vcenter.example.com/Datacenter/esxi vmware_guest -o
rhev -os rhev.nfs:/export_domain --network rhevm</p>

<p style="margin-top: 1em">virt-v2v -i libvirtxml
guest-domain.xml -o local -os /var/tmp</p>

<p style="margin-top: 1em">virt-v2v -i disk disk.img -o
local -os /var/tmp</p>

<p style="margin-top: 1em">virt-v2v -i disk disk.img -o
glance</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Virt-v2v converts guests from a foreign hypervisor to run on
KVM. It can read Linux and Windows guests running on VMware,
Xen, Hyper-V and some other hypervisors, and convert <br>
them to KVM managed by libvirt, OpenStack, oVirt, Red Hat
Enterprise Virtualisation (RHEV) or several other
targets.</p>

<p style="margin-top: 1em">There is also a companion
front-end called virt-p2v(1) which comes as an ISO, CD or
PXE image that can be booted on physical machines to
virtualize those machines (physical to <br>
virtual, or p2v).</p>

<p style="margin-top: 1em">This manual page documents the
rewritten virt-v2v included in libguestfs &acirc;&yen;
1.28.</p>

<p style="margin-top: 1em">INPUT AND OUTPUT MODES <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para;
-o null <br>
-i disk
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc; &acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para;
-o local <br>
-i ova
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc;&acirc;&acirc;&acirc;&para; &acirc; virt-v2v &acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para;
-o qemu <br>
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para; &acirc;
conversion &acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>

VMware&acirc;&acirc;&para;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc; server &acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&para; -o libvirt
&acirc;&acirc;&acirc;&para; KVM <br>
Xen &acirc;&acirc;&acirc;&acirc;&para;&acirc; -i libvirt
&acirc;&acirc;&acirc;&para; &acirc; &acirc; &acirc;
(default) &acirc; <br>
... &acirc;&acirc;&acirc;&acirc;&para;&acirc; (default)
&acirc; &acirc; &acirc; &acirc;&acirc;&acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc; &acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para;
-o glance <br>
-i libvirtxml
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para;
&acirc; &acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para;
-o rhev <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para;
-o vdsm</p>

<p style="margin-top: 1em">Virt-v2v has a number of
possible input and output modes, selected using the -i and
-o options. Only one input and output mode can be selected
for each run of virt-v2v.</p>

<p style="margin-top: 1em">-i disk is used for reading from
local disk images (mainly for testing).</p>

<p style="margin-top: 1em">-i libvirt is used for reading
from any libvirt source. Since libvirt can connect to many
different hypervisors, it is used for reading guests from
VMware, RHEL 5 Xen and more. <br>
The -ic option selects the precise libvirt source.</p>

<p style="margin-top: 1em">-i libvirtxml is used to read
from libvirt XML files. This is the method used by
virt-p2v(1) behind the scenes.</p>

<p style="margin-top: 1em">-i ova is used for reading from
a VMware ova source file.</p>

<p style="margin-top: 1em">-o glance is used for writing to
OpenStack Glance.</p>

<p style="margin-top: 1em">-o libvirt is used for writing
to any libvirt target. Libvirt can connect to local or
remote KVM hypervisors. The -oc option selects the precise
libvirt target.</p>

<p style="margin-top: 1em">-o local is used to write to a
local disk image with a local libvirt configuration file
(mainly for testing).</p>

<p style="margin-top: 1em">-o qemu writes to a local disk
image with a shell script for booting the guest directly in
qemu (mainly for testing).</p>

<p style="margin-top: 1em">-o rhev is used to write to a
RHEV-M / oVirt target. -o vdsm is only used when virt-v2v
runs under VDSM control.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Convert from VMware vCenter server to local libvirt <br>
You have a VMware vCenter server called
&quot;vcenter.example.com&quot;, a datacenter called
&quot;Datacenter&quot;, and an ESXi hypervisor called
&quot;esxi&quot;. You want to convert a guest called <br>
&quot;vmware_guest&quot; to run locally under libvirt.</p>

<p style="margin-top: 1em">virt-v2v -ic
vpx://vcenter.example.com/Datacenter/esxi vmware_guest</p>

<p style="margin-top: 1em">In this case you will most
likely have to run virt-v2v as &quot;root&quot;, since it
needs to talk to the system libvirt daemon and copy the
guest disks to /var/lib/libvirt/images.</p>

<p style="margin-top: 1em">For more information see
&quot;INPUT FROM VMWARE VCENTER SERVER&quot; below.</p>

<p style="margin-top: 1em">Convert from VMware to
RHEV-M/oVirt <br>
This is the same as the previous example, except you want to
send the guest to a RHEV-M Export Storage Domain which is
located remotely (over NFS) at
&quot;rhev.nfs:/export_domain&quot;. <br>
If you are unclear about the location of the Export Storage
Domain you should check the settings on your RHEV-M
management console. Guest network interface(s) are connected
to <br>
the target network called &quot;rhevm&quot;.</p>

<p style="margin-top: 1em">virt-v2v -ic
vpx://vcenter.example.com/Datacenter/esxi vmware_guest -o
rhev -os rhev.nfs:/export_domain --network rhevm</p>

<p style="margin-top: 1em">In this case the host running
virt-v2v acts as a conversion server.</p>

<p style="margin-top: 1em">Note that after conversion, the
guest will appear in the RHEV-M Export Storage Domain, from
where you will need to import it using the RHEV-M user
interface. (See &quot;OUTPUT TO <br>
RHEV&quot;).</p>

<p style="margin-top: 1em">Convert disk image to OpenStack
glance <br>
Given a disk image from another hypervisor that you want to
convert to run on OpenStack (only KVM-based OpenStack is
supported), you can do:</p>

<p style="margin-top: 1em">virt-v2v -i disk disk.img -o
glance</p>

<p style="margin-top: 1em">See &quot;OUTPUT TO GLANCE&quot;
below.</p>

<p style="margin-top: 1em">Convert disk image to disk image
<br>
Given a disk image from another hypervisor that you want to
convert to run on KVM, you have two options. The simplest
way is to try:</p>

<p style="margin-top: 1em">virt-v2v -i disk disk.img -o
local -os /var/tmp</p>

<p style="margin-top: 1em">where virt-v2v guesses
everything about the input disk.img and (in this case)
writes the converted result to /var/tmp.</p>

<p style="margin-top: 1em">A more complex method is to
write some libvirt XML describing the input guest (if you
can get the source hypervisor to provide you with libvirt
XML, then so much the better). <br>
You can then do:</p>

<p style="margin-top: 1em">virt-v2v -i libvirtxml
guest-domain.xml -o local -os /var/tmp</p>

<p style="margin-top: 1em">Since guest-domain.xml contains
the path(s) to the guest disk image(s) you do not need to
specify the name of the disk image on the command line.</p>

<p style="margin-top: 1em">OPTIONS <br>
--help <br>
Display help.</p>

<p style="margin-top: 1em">-b ... <br>
--bridge ... <br>
See --network below.</p>

<p style="margin-top: 1em">--colors <br>
--colours <br>
Use ANSI colour sequences to colourize messages. This is the
default when the output is a tty. If the output of the
program is redirected to a file, ANSI colour sequences <br>
are disabled unless you use this option.</p>

<p style="margin-top: 1em">--compressed <br>
Write a compressed output file. This is only allowed if the
output format is qcow2 (see -of below), and is equivalent to
the -c option of qemu-img(1).</p>

<p style="margin-top: 1em">--debug-gc <br>
Debug garbage collection and memory allocation. This is only
useful when debugging memory problems in virt-v2v or the
OCaml libguestfs bindings.</p>

<p style="margin-top: 1em">--debug-overlays <br>
Save the overlay file(s) created during conversion. This
option is only used for debugging virt-v2v and may be
removed in a future version.</p>

<p style="margin-top: 1em">-i disk <br>
Set the input method to disk.</p>

<p style="margin-top: 1em">In this mode you can read a
virtual machine disk image with no metadata. virt-v2v tries
to guess the best default metadata. This is usually adequate
but you can get finer <br>
control (eg. of memory and vCPUs) by using -i libvirtxml
instead. Only guests that use a single disk can be imported
this way.</p>

<p style="margin-top: 1em">-i libvirt <br>
Set the input method to libvirt. This is the default.</p>

<p style="margin-top: 1em">In this mode you have to specify
a libvirt guest name or UUID on the command line. You may
also specify a libvirt connection URI (see -ic).</p>

<p style="margin-top: 1em">-i libvirtxml <br>
Set the input method to libvirtxml.</p>

<p style="margin-top: 1em">In this mode you have to pass a
libvirt XML file on the command line. This file is read in
order to get metadata about the source guest (such as its
name, amount of memory), <br>
and also to locate the input disks. See &quot;MINIMAL XML
FOR -i libvirtxml OPTION&quot; below.</p>

<p style="margin-top: 1em">-i local <br>
This is the same as -i disk.</p>

<p style="margin-top: 1em">-i ova <br>
Set the input method to ova.</p>

<p style="margin-top: 1em">In this mode you can read a
VMware ova file. Virt-v2v will read the ova manifest file
and check the vmdk volumes for validity (checksums) as well
as analyzing the ovf file, <br>
and then convert the guest. See &quot;INPUT FROM VMWARE
OVA&quot; below</p>

<p style="margin-top: 1em">-ic libvirtURI <br>
Specify a libvirt connection URI to use when reading the
guest. This is only used when -i&Acirc;&nbsp;libvirt.</p>

<p style="margin-top: 1em">Only local libvirt connections,
VMware vCenter connections, or RHEL 5 Xen remote connections
can be used. Other remote libvirt connections will not work
in general.</p>

<p style="margin-top: 1em">See also &quot;INPUT FROM VMWARE
VCENTER SERVER&quot;, &quot;INPUT FROM RHEL 5 XEN&quot;
below.</p>

<p style="margin-top: 1em">-if format <br>
For -i disk only, this specifies the format of the input
disk image. For other input methods you should specify the
input format in the metadata.</p>

<p style="margin-top: 1em">--machine-readable <br>
This option is used to make the output more machine friendly
when being parsed by other programs. See &quot;MACHINE
READABLE OUTPUT&quot; below.</p>

<p style="margin-top: 1em">-n in:out <br>
-n out <br>
--network in:out <br>
--network out <br>
-b in:out <br>
-b out <br>
--bridge in:out <br>
--bridge out <br>
Map network (or bridge) called &quot;in&quot; to network (or
bridge) called &quot;out&quot;. If no &quot;in:&quot; prefix
is given, all other networks (or bridges) are mapped to
&quot;out&quot;.</p>

<p style="margin-top: 1em">See &quot;NETWORKS AND
BRIDGES&quot; below.</p>

<p style="margin-top: 1em">--no-copy <br>
Don&rsquo;t copy the disks. Instead, conversion is performed
(and thrown away), and metadata is written, but no disks are
created. See also discussion of -o&Acirc;&nbsp;null
below.</p>

<p style="margin-top: 1em">This is useful in two cases:
Either you want to test if conversion is likely to succeed,
without the long copying process. Or you are only interested
in looking at the <br>
metadata.</p>

<p style="margin-top: 1em">This option is not compatible
with -o libvirt since it would create a faulty guest (one
with no disks).</p>

<p style="margin-top: 1em">This option is not compatible
with -o glance for technical reasons.</p>

<p style="margin-top: 1em">--no-trim all <br>
--no-trim mp[,mp...] <br>
By default virt-v2v runs fstrim(8) to reduce the amount of
data that needs to be copied. This is known to break some
buggy bootloaders causing boot failures after conversion
<br>
(see for example
https://bugzilla.redhat.com/show_bug.cgi?id=1141145#c27).</p>

<p style="margin-top: 1em">You can use --no-trim all to
disable all trimming. Note this will greatly increase the
amount of data that has to be copied and can make virt-v2v
run much more slowly.</p>

<p style="margin-top: 1em">You can also disable trimming on
selected filesystems only (specified by a comma-separated
list of their mount point(s) in the guest). Typically you
would use --no-trim <br>
/boot to work around the grub bug mentioned above.</p>

<p style="margin-top: 1em">You can also disable trimming on
partitions using the libguestfs naming scheme for devices,
eg: --no-trim /dev/sdb2 means do not trim the second
partition on the second block <br>
device. Use virt-filesystems(1) to list filesystem names in
a guest.</p>

<p style="margin-top: 1em">-o disk <br>
This is the same as -o local.</p>

<p style="margin-top: 1em">-o glance <br>
Set the output method to OpenStack Glance. In this mode the
converted guest is uploaded to Glance. See &quot;OUTPUT TO
GLANCE&quot; below.</p>

<p style="margin-top: 1em">-o libvirt <br>
Set the output method to libvirt. This is the default.</p>

<p style="margin-top: 1em">In this mode, the converted
guest is created as a libvirt guest. You may also specify a
libvirt connection URI (see -oc).</p>

<p style="margin-top: 1em">See &quot;OUTPUT TO
LIBVIRT&quot; below.</p>

<p style="margin-top: 1em">-o local <br>
Set the output method to local.</p>

<p style="margin-top: 1em">In this mode, the converted
guest is written to a local directory specified by -os /dir
(the directory must exist). The converted guest&rsquo;s
disks are written as:</p>

<p style="margin-top: 1em">/dir/name-sda <br>
/dir/name-sdb <br>
[etc]</p>

<p style="margin-top: 1em">and a libvirt XML file is
created containing guest metadata:</p>

<p style="margin-top: 1em">/dir/name.xml</p>

<p style="margin-top: 1em">where &quot;name&quot; is the
guest name.</p>

<p style="margin-top: 1em">-o null <br>
Set the output method to null.</p>

<p style="margin-top: 1em">The guest is converted and
copied (unless you also specify --no-copy), but the results
are thrown away and no metadata is written.</p>

<p style="margin-top: 1em">-o ovirt <br>
This is the same as -o rhev.</p>

<p style="margin-top: 1em">-o qemu <br>
Set the output method to qemu.</p>

<p style="margin-top: 1em">This is similar to -o local,
except that a shell script is written which you can use to
boot the guest in qemu. The converted disks and shell script
are written to the <br>
directory specified by -os.</p>

<p style="margin-top: 1em">-o rhev <br>
Set the output method to rhev.</p>

<p style="margin-top: 1em">The converted guest is written
to a RHEV Export Storage Domain. The -os parameter must also
be used to specify the location of the Export Storage
Domain. Note this does not <br>
actually import the guest into RHEV. You have to do that
manually later using the UI.</p>

<p style="margin-top: 1em">See &quot;OUTPUT TO RHEV&quot;
below.</p>

<p style="margin-top: 1em">-o vdsm <br>
Set the output method to vdsm.</p>

<p style="margin-top: 1em">This mode is similar to -o rhev,
but the full path to the data domain must be given:
/rhev/data-center/&lt;data-center-uuid&gt;/&lt;data-domain-uuid&gt;.
This mode is only used when <br>
virt-v2v runs under VDSM control.</p>

<p style="margin-top: 1em">-oa sparse <br>
-oa preallocated <br>
Set the output file allocation mode. The default is
&quot;sparse&quot;.</p>

<p style="margin-top: 1em">-oc libvirtURI <br>
Specify a libvirt connection to use when writing the
converted guest. This is only used when
-o&Acirc;&nbsp;libvirt. See &quot;OUTPUT TO LIBVIRT&quot;
below.</p>

<p style="margin-top: 1em">Only local libvirt connections
can be used. Remote libvirt connections will not work.</p>

<p style="margin-top: 1em">-of format <br>
When converting the guest, convert the disks to the given
format.</p>

<p style="margin-top: 1em">If not specified, then the input
format is used.</p>

<p style="margin-top: 1em">-on name <br>
Rename the guest when converting it. If this option is not
used then the output name is the same as the input name.</p>

<p style="margin-top: 1em">-os storage <br>
The location of the storage for the converted guest.</p>

<p style="margin-top: 1em">For -o libvirt, this is a
libvirt directory pool (see
&quot;virsh&Acirc;&nbsp;pool-list&quot;) or pool UUID.</p>

<p style="margin-top: 1em">For -o local and -o qemu, this
is a directory name. The directory must exist.</p>

<p style="margin-top: 1em">For -o rhev, this can be an NFS
path of the Export Storage Domain of the form
&quot;&lt;host&gt;:&lt;path&gt;&quot;, eg:</p>


<p style="margin-top: 1em">rhev-storage.example.com:/rhev/export</p>

<p style="margin-top: 1em">The NFS export must be mountable
and writable by the user and host running virt-v2v, since
the virt-v2v program has to actually mount it when it runs.
So you probably have <br>
to run virt-v2v as &quot;root&quot;.</p>

<p style="margin-top: 1em">Or: You can mount the Export
Storage Domain yourself, and point -os to the mountpoint.
Note that virt-v2v will still need to write to this remote
directory, so virt-v2v will <br>
still need to run as &quot;root&quot;.</p>

<p style="margin-top: 1em">You will get an error if
virt-v2v is unable to mount/write to the Export Storage
Domain.</p>

<p style="margin-top: 1em">--password-file file <br>
Instead of asking for password(s) interactively, pass the
password through a file. Note the file should contain the
whole password, without any trailing newline, and for <br>
security the file should have mode 0600 so that others
cannot read it.</p>

<p style="margin-top: 1em">--print-source <br>
Print information about the source guest and stop. This
option is useful when you are setting up network and bridge
maps. See &quot;NETWORKS AND BRIDGES&quot;.</p>

<p style="margin-top: 1em">-q <br>
--quiet <br>
This disables progress bars and other unnecessary
output.</p>

<p style="margin-top: 1em">--root ask <br>
--root single <br>
--root first <br>
--root /dev/sdX <br>
--root /dev/VG/LV <br>
Choose the root filesystem to be converted.</p>

<p style="margin-top: 1em">In the case where the virtual
machine is dual-boot or multi-boot, or where the VM has
other filesystems that look like operating systems, this
option can be used to select <br>
the root filesystem (a.k.a. &quot;C:&quot; drive or /) of
the operating system that is to be converted. The Windows
Recovery Console, certain attached DVD drives, and bugs in
<br>
libguestfs inspection heuristics, can make a guest look like
a multi-boot operating system.</p>

<p style="margin-top: 1em">The default in virt-v2v
&acirc;&curren; 0.7.1 was --root&Acirc;&nbsp;single, which
causes virt-v2v to die if a multi-boot operating system is
found.</p>

<p style="margin-top: 1em">Since virt-v2v &acirc;&yen;
0.7.2 the default is now --root&Acirc;&nbsp;ask: If the VM
is found to be multi-boot, then virt-v2v will stop and list
the possible root filesystems and ask the user <br>
which to use. This requires that virt-v2v is run
interactively.</p>

<p style="margin-top: 1em">--root&Acirc;&nbsp;first means
to choose the first root device in the case of a multi-boot
operating system. Since this is a heuristic, it may
sometimes choose the wrong one.</p>

<p style="margin-top: 1em">You can also name a specific
root device, eg. --root&Acirc;&nbsp;/dev/sda2 would mean to
use the second partition on the first hard drive. If the
named root device does not exist or was <br>
not detected as a root device, then virt-v2v will fail.</p>

<p style="margin-top: 1em">Note that there is a bug in grub
which prevents it from successfully booting a multiboot
system if VirtIO is enabled. Grub is only able to boot an
operating system from the <br>
first VirtIO disk. Specifically, /boot must be on the first
VirtIO disk, and it cannot chainload an OS which is not in
the first VirtIO disk.</p>

<p style="margin-top: 1em">--vdsm-compat=0.10 <br>
--vdsm-compat=1.1 <br>
If -o vdsm and the output format is qcow2, then we add the
qcow2 compat=0.10 option to the output file for
compatibility with RHEL 6 (see <br>
https://bugzilla.redhat.com/1145582).</p>

<p style="margin-top: 1em">If --vdsm-compat=1.1 is used
then modern qcow2 (compat=1.1) files are generated
instead.</p>

<p style="margin-top: 1em">Currently --vdsm-compat=0.10 is
the default, but this will change to --vdsm-compat=1.1 in a
future version of virt-v2v (when we can assume that everyone
is using a modern <br>
version of qemu).</p>

<p style="margin-top: 1em">Note this option only affects -o
vdsm output. All other output modes (including -o rhev)
generate modern qcow2 compat=1.1 files, always.</p>

<p style="margin-top: 1em">--vdsm-image-uuid UUID <br>
--vdsm-vol-uuid UUID <br>
--vdsm-vm-uuid UUID <br>
--vdsm-ovf-output <br>
Normally the RHEV output mode chooses random UUIDs for the
target guest. However VDSM needs to control the UUIDs and
passes these parameters when virt-v2v runs under VDSM <br>
control. The parameters control:</p>

<p style="margin-top: 1em">&Acirc;&middot; the image
directory of each guest disk (--vdsm-image-uuid) (this
option is passed once for each guest disk)</p>

<p style="margin-top: 1em">&Acirc;&middot; UUIDs for each
guest disk (--vdsm-vol-uuid) (this option is passed once for
each guest disk)</p>

<p style="margin-top: 1em">&Acirc;&middot; the OVF file
name (--vdsm-vm-uuid).</p>

<p style="margin-top: 1em">&Acirc;&middot; the OVF output
directory (default current directory)
(--vdsm-ovf-output).</p>

<p style="margin-top: 1em">The format of UUIDs is:
&quot;12345678-1234-1234-1234-123456789abc&quot; (each hex
digit can be &quot;0-9&quot; or &quot;a-f&quot;), conforming
to OSF&Acirc;&nbsp;DCE&Acirc;&nbsp;1.1.</p>

<p style="margin-top: 1em">These options can only be used
with -o vdsm.</p>

<p style="margin-top: 1em">-v <br>
--verbose <br>
Enable verbose messages for debugging.</p>

<p style="margin-top: 1em">-V <br>
--version <br>
Display version number and exit.</p>

<p style="margin-top: 1em">--vmtype desktop <br>
--vmtype server <br>
For the -o rhev or -o vdsm targets only, specify the type of
guest. You can set this to &quot;desktop&quot; or
&quot;server&quot;. If the option is not given, then a
suitable default is chosen <br>
based on the detected guest operating system.</p>

<p style="margin-top: 1em">-x Enable tracing of libguestfs
API calls.</p>

<p style="margin-top: 1em">XEN PARAVIRTUALIZED GUESTS <br>
Older versions of virt-v2v could turn a Xen paravirtualized
(PV) guest into a KVM guest by installing a new kernel. This
version of virt-v2v does not attempt to install any new <br>
kernels. Instead it will give you an error if there are only
Xen PV kernels available.</p>

<p style="margin-top: 1em">Therefore before conversion you
should check that a regular kernel is installed. For some
older Linux distributions, this means installing a kernel
from the table below:</p>

<p style="margin-top: 1em">RHEL 3 (Does not apply, as there
was no Xen PV kernel)</p>

<p style="margin-top: 1em">RHEL 4 i686 with &gt; 10GB of
RAM: install &rsquo;kernel-hugemem&rsquo; <br>
i686 SMP: install &rsquo;kernel-smp&rsquo; <br>
other i686: install &rsquo;kernel&rsquo; <br>
x86-64 SMP with &gt; 8 CPUs: install
&rsquo;kernel-largesmp&rsquo; <br>
x86-64 SMP: install &rsquo;kernel-smp&rsquo; <br>
other x86-64: install &rsquo;kernel&rsquo;</p>

<p style="margin-top: 1em">RHEL 5 i686: install
&rsquo;kernel-PAE&rsquo; <br>
x86-64: install &rsquo;kernel&rsquo;</p>

<p style="margin-top: 1em">SLES 10 i586 with &gt; 10GB of
RAM: install &rsquo;kernel-bigsmp&rsquo; <br>
i586 SMP: install &rsquo;kernel-smp&rsquo; <br>
other i586: install &rsquo;kernel-default&rsquo; <br>
x86-64 SMP: install &rsquo;kernel-smp&rsquo; <br>
other x86-64: install &rsquo;kernel-default&rsquo;</p>

<p style="margin-top: 1em">SLES 11+ i586: install
&rsquo;kernel-pae&rsquo; <br>
x86-64: install &rsquo;kernel-default&rsquo;</p>

<p style="margin-top: 1em">Windows (Does not apply, as
there is no Xen PV Windows kernel)</p>

<p style="margin-top: 1em">ENABLING VIRTIO <br>
&quot;Virtio&quot; is the name for a set of drivers which
make disk (block device), network and other guest operations
work much faster on KVM.</p>

<p style="margin-top: 1em">Older versions of virt-v2v could
install these drivers for certain Linux guests. This version
of virt-v2v does not attempt to install new Linux kernels or
drivers, but will warn <br>
you if they are not installed already.</p>

<p style="margin-top: 1em">In order to enable virtio, and
hence improve performance of the guest after conversion, you
should ensure that the minimum versions of packages are
installed before conversion, <br>
by consulting the table below.</p>

<p style="margin-top: 1em">RHEL 3 No virtio drivers are
available</p>

<p style="margin-top: 1em">RHEL 4 kernel &gt;= 2.5.9-89.EL
<br>
lvm2 &gt;= 2.02.42-5.el4 <br>
device-mapper &gt;= 1.02.28-2.el4 <br>
selinux-policy-targeted &gt;= 1.17.30-2.152.el4 <br>
policycoreutils &gt;= 1.18.1-4.13</p>

<p style="margin-top: 1em">RHEL 5 kernel &gt;=
2.6.18-128.el5 <br>
lvm2 &gt;= 2.02.40-6.el5 <br>
selinux-policy-targeted &gt;= 2.4.6-203.el5</p>

<p style="margin-top: 1em">RHEL 6+ All versions support
virtio</p>

<p style="margin-top: 1em">Fedora All versions support
virtio</p>

<p style="margin-top: 1em">SLES 11+ All versions support
virtio</p>

<p style="margin-top: 1em">SLES 10 kernel &gt;=
2.6.16.60-0.85.1</p>

<p style="margin-top: 1em">OpenSUSE 11+ All versions
support virtio</p>

<p style="margin-top: 1em">OpenSUSE 10 kernel &gt;=
2.6.25.5-1.1</p>

<p style="margin-top: 1em">Windows Drivers are installed
from the directory pointed to by <br>
&quot;VIRTIO_WIN&quot; environment variable <br>
(/usr/share/virtio-win by default) if present</p>

<p style="margin-top: 1em">RHEL 4 <br>
SELinux relabel appears to hang forever <br>
In RHEL &acirc;&curren; 4.7 there was a bug which causes
SELinux relabelling to appear to hang forever at:</p>

<p style="margin-top: 1em">*** Warning -- SELinux relabel
is required. *** <br>
*** Disabling security enforcement. *** <br>
*** Relabeling could take a very long time, *** <br>
*** depending on file system size. ***</p>

<p style="margin-top: 1em">In reality it is waiting for you
to press a key (but there is no visual indication of this).
You can either hit the &quot;[Return]&quot; key, at which
point the guest will finish <br>
relabelling and reboot, or you can install policycoreutils
&acirc;&yen; 1.18.1-4.13 before starting the v2v conversion.
See also
https://bugzilla.redhat.com/show_bug.cgi?id=244636</p>

<p style="margin-top: 1em">WINDOWS <br>
Windows &acirc;&yen; 8 Fast Startup is incompatible with
virt-v2v <br>
Guests which use the Windows &acirc;&yen; 8 &quot;Fast
Startup&quot; feature (or guests which are hibernated)
cannot be converted with virt-v2v. You will see an
error:</p>

<p style="margin-top: 1em">virt-v2v: error: unable to mount
the disk image for writing. This has <br>
probably happened because Windows Hibernation or Fast
Restart is being <br>
used in this guest. You have to disable this (in the guest)
in order <br>
to use virt-v2v.</p>

<p style="margin-top: 1em">As the message says, you need to
boot the guest and disable the &quot;Fast Startup&quot;
feature (Control Panel &acirc; Power Options &acirc; Choose
what the power buttons do &acirc; Change settings that <br>
are currently unavailable &acirc; Turn on fast startup), and
shut down the guest, and then you will be able to convert
it.</p>

<p style="margin-top: 1em">For more information, see:
&quot;WINDOWS HIBERNATION AND WINDOWS 8 FAST STARTUP&quot;
in guestfs(3).</p>

<p style="margin-top: 1em">Boot failure: 0x0000007B <br>
This boot failure is caused by Windows being unable to find
or load the right disk driver (eg. viostor.sys). If you
experience this error, here are some things to check:</p>

<p style="margin-top: 1em">&Acirc;&middot; First ensure
that the guest boots on the source hypervisor before
conversion.</p>

<p style="margin-top: 1em">&Acirc;&middot; Check you have
the Windows virtio drivers available in
/usr/share/virtio-win, and that virt-v2v did not print any
warning about not being able to install virtio drivers.</p>

<p style="margin-top: 1em">On
Red&Acirc;&nbsp;Hat&Acirc;&nbsp;Enterprise&Acirc;&nbsp;Linux&Acirc;&nbsp;7,
you will need to install the signed drivers available in the
&quot;virtio-win&quot; package. If you do not have access to
the signed drivers, then you <br>
will probably need to disable driver signing in the boot
menus.</p>

<p style="margin-top: 1em">&Acirc;&middot; Check that you
are presenting a virtio-blk interface (not virtio-scsi and
not ide) to the guest. On the qemu/KVM command line you
should see something similar to this:</p>

<p style="margin-top: 1em">... -drive
file=windows-sda,if=virtio ...</p>

<p style="margin-top: 1em">In libvirt XML, you should
see:</p>

<p style="margin-top: 1em">&lt;target dev=&rsquo;vda&rsquo;
bus=&rsquo;virtio&rsquo;/&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Check that
Windows Group Policy does not prevent the driver from being
installed or used. Try deleting Windows Group Policy before
conversion.</p>

<p style="margin-top: 1em">&Acirc;&middot; Check there is
no anti-virus or other software which implements Group
Policy-like prohibitions on installing or using new
drivers.</p>

<p style="margin-top: 1em">&Acirc;&middot; Enable boot
debugging and check the viostor.sys driver is being
loaded.</p>

<p style="margin-top: 1em">OpenStack and Windows
reactivation <br>
OpenStack does not offer stable device / PCI addresses to
guests. Every time it creates or starts a guest, it
regenerates the libvirt XML for that guest from scratch. The
<br>
libvirt XML will have no &lt;address&gt; fields. Libvirt
will then assign addresses to devices, in a predictable
manner. Addresses may change if any of the following are
true:</p>

<p style="margin-top: 1em">&Acirc;&middot; A new disk or
network device has been added or removed from the guest.</p>

<p style="margin-top: 1em">&Acirc;&middot; The version of
OpenStack or (possibly) libvirt has changed.</p>

<p style="margin-top: 1em">Because Windows does not like
&quot;hardware&quot; changes of this kind, it may trigger
Windows reactivation.</p>

<p style="margin-top: 1em">This can also prevent booting
with a 7B error [see previous section] if the guest has
group policy containing &quot;Device Installation
Restrictions&quot;.</p>

<p style="margin-top: 1em">UEFI <br>
VMware allows you to present UEFI firmware to guests
(instead of the ordinary PC BIOS). Virt-v2v can convert
these guests, but requires that UEFI is supported by the
target <br>
hypervisor.</p>

<p style="margin-top: 1em">Currently KVM supports OVMF, an
open source UEFI firmware, and can run these guests.</p>

<p style="margin-top: 1em">Since OVMF support was only
recently added to KVM (in 2014/2015), not all target
environments support UEFI guests yet:</p>

<p style="margin-top: 1em">UEFI on libvirt, qemu <br>
Supported. Virt-v2v will generate the correct libvirt XML
(metadata) automatically, but note that the same version of
OVMF must be installed on the conversion host as is <br>
installed on the target hypervisor, else you will have to
adjust paths in the metadata.</p>

<p style="margin-top: 1em">On RHEL &acirc;&yen; 7.3, only
qemu-kvm-rhev (not qemu-kvm) is supported.</p>

<p style="margin-top: 1em">UEFI on OpenStack <br>
Not supported.</p>

<p style="margin-top: 1em">UEFI on RHEV <br>
Not supported.</p>

<p style="margin-top: 1em">NETWORKS AND BRIDGES <br>
Guests are usually connected to one or more networks, and
when converted to the target hypervisor you usually want to
reconnect those networks at the destination. The options
<br>
--network and --bridge allow you to do that.</p>

<p style="margin-top: 1em">If you are unsure of what
networks and bridges are in use on the source hypervisor,
then you can examine the source metadata (libvirt XML,
vCenter information, etc.). Or you can <br>
run virt-v2v with the --print-source option which causes
virt-v2v to print out the information it has about the guest
on the source and then exit.</p>

<p style="margin-top: 1em">In the --print-source output you
will see a section showing the guest&rsquo;s Network
Interface Cards (NICs):</p>

<p style="margin-top: 1em">$ virt-v2v [-i ...]
--print-source name <br>
[...] <br>
NICs: <br>
Network &quot;default&quot; mac: 52:54:00:d0:cf:0e</p>

<p style="margin-top: 1em">This is typical of a libvirt
guest: It has a single network interface connected to a
network called &quot;default&quot;.</p>

<p style="margin-top: 1em">To map a specific network to a
target network, for example &quot;default&quot; on the
source to &quot;rhevm&quot; on the target, use:</p>

<p style="margin-top: 1em">virt-v2v [...] --network
default:rhevm</p>

<p style="margin-top: 1em">To map every network to a target
network, use:</p>

<p style="margin-top: 1em">virt-v2v [...] --network
rhevm</p>

<p style="margin-top: 1em">Bridges are handled in the same
way, but you have to use the --bridge option instead. For
example:</p>

<p style="margin-top: 1em">$ virt-v2v [-i ...]
--print-source name <br>
[...] <br>
NICs: <br>
Bridge &quot;br0&quot;</p>

<p style="margin-top: 1em">$ virt-v2v [...] --bridge
br0:targetbr</p>

<p style="margin-top: 1em">INPUT FROM VMWARE VCENTER SERVER
<br>
Virt-v2v is able to import guests from VMware vCenter
Server.</p>

<p style="margin-top: 1em">vCenter &acirc;&yen; 5.0 is
required. If you don&rsquo;t have vCenter, using OVA is
recommended instead (see &quot;INPUT FROM VMWARE OVA&quot;
below), or if that is not possible then see &quot;INPUT FROM
<br>
VMWARE ESXi HYPERVISOR&quot;.</p>

<p style="margin-top: 1em">Virt-v2v uses libvirt for access
to vCenter, and therefore the input mode should be -i
libvirt. As this is the default, you don&rsquo;t need to
specify it on the command line.</p>

<p style="margin-top: 1em">VCENTER: REMOVE VMWARE TOOLS
FROM WINDOWS GUESTS <br>
For Windows guests, you should remove VMware tools before
conversion. Although this is not strictly necessary, and the
guest will still be able to run, if you don&rsquo;t do this
then <br>
the converted guest will complain on every boot. The tools
cannot be removed after conversion because the uninstaller
checks if it is running on VMware and refuses to start <br>
(which is also the reason that virt-v2v cannot remove
them).</p>

<p style="margin-top: 1em">This is not necessary for Linux
guests, as virt-v2v is able to remove VMware tools.</p>

<p style="margin-top: 1em">VCENTER: URI <br>
The libvirt URI of a vCenter server looks something like
this:</p>


<p style="margin-top: 1em">vpx://user@server/Datacenter/esxi</p>

<p style="margin-top: 1em">where:</p>

<p style="margin-top: 1em">&quot;user@&quot; <br>
is the (optional, but recommended) user to connect as.</p>

<p style="margin-top: 1em">If the username contains a
backslash (eg. &quot;DOMAINUSER&quot;) then you will need to
URI-escape that character using %5c:
&quot;DOMAIN%5cUSER&quot; (5c is the hexadecimal ASCII code
for <br>
backslash.) Other punctuation may also have to be
escaped.</p>

<p style="margin-top: 1em">&quot;server&quot; <br>
is the vCenter Server (not hypervisor).</p>

<p style="margin-top: 1em">&quot;Datacenter&quot; <br>
is the name of the datacenter.</p>

<p style="margin-top: 1em">If the name contains a space,
replace it with the URI-escape code %20.</p>

<p style="margin-top: 1em">&quot;esxi&quot; <br>
is the name of the ESXi hypervisor running the guest.</p>

<p style="margin-top: 1em">If the VMware deployment is
using folders, then these may need to be added to the URI,
eg:</p>


<p style="margin-top: 1em">vpx://user@server/Folder/Datacenter/esxi</p>

<p style="margin-top: 1em">For full details of libvirt
URIs, see: http://libvirt.org/drvesx.html</p>

<p style="margin-top: 1em">Typical errors from libvirt /
virsh when the URI is wrong include:</p>

<p style="margin-top: 1em">&Acirc;&middot; Could not find
datacenter specified in [...]</p>

<p style="margin-top: 1em">&Acirc;&middot; Could not find
compute resource specified in [...]</p>

<p style="margin-top: 1em">&Acirc;&middot; Path [...] does
not specify a compute resource</p>

<p style="margin-top: 1em">&Acirc;&middot; Path [...] does
not specify a host system</p>

<p style="margin-top: 1em">&Acirc;&middot; Could not find
host system specified in [...]</p>

<p style="margin-top: 1em">VCENTER: TEST LIBVIRT CONNECTION
TO VCENTER <br>
Use the virsh(1) command to list the guests on the vCenter
Server like this:</p>

<p style="margin-top: 1em">$ virsh -c
&rsquo;vpx://root@vcenter.example.com/Datacenter/esxi&rsquo;
list --all <br>
Enter root&rsquo;s password for vcenter.example.com: ***</p>

<p style="margin-top: 1em">Id Name State <br>
---------------------------------------------------- <br>
- Fedora 20 shut off <br>
- Windows 2003 shut off</p>

<p style="margin-top: 1em">If you get an error &quot;Peer
certificate cannot be authenticated with given CA
certificates&quot; or similar, then you can either import
the vCenter host&rsquo;s certificate, or bypass <br>
signature verification by adding the
&quot;?no_verify=1&quot; flag:</p>

<p style="margin-top: 1em">$ virsh -c
&rsquo;vpx://root@vcenter.example.com/Datacenter/esxi?no_verify=1&rsquo;
list --all</p>

<p style="margin-top: 1em">You should also try dumping the
metadata from any guest on your server, like this:</p>

<p style="margin-top: 1em">$ virsh -c
&rsquo;vpx://root@vcenter.example.com/Datacenter/esxi&rsquo;
dumpxml &quot;Windows 2003&quot; <br>
&lt;domain type=&rsquo;vmware&rsquo;&gt; <br>
&lt;name&gt;Windows 2003&lt;/name&gt; <br>
[...] <br>
&lt;/domain&gt;</p>

<p style="margin-top: 1em">If the above commands do not
work, then virt-v2v is not going to work either. Fix your
libvirt configuration and/or your VMware vCenter Server
before continuing.</p>

<p style="margin-top: 1em">VCENTER: IMPORTING A GUEST <br>
To import a particular guest from vCenter Server, do:</p>

<p style="margin-top: 1em">$ virt-v2v -ic
&rsquo;vpx://root@vcenter.example.com/Datacenter/esxi?no_verify=1&rsquo;
&quot;Windows 2003&quot; -o local -os /var/tmp</p>

<p style="margin-top: 1em">where &quot;Windows 2003&quot;
is the name of the guest (which must be shut down).</p>

<p style="margin-top: 1em">Note that you may be asked for
the vCenter password twice. This happens once because
libvirt needs it, and a second time because virt-v2v itself
connects directly to the server. <br>
Use --password-file to supply a password via a file.</p>

<p style="margin-top: 1em">In this case the output flags
are set to write the converted guest to a temporary
directory as this is just an example, but you can also write
to libvirt or any other supported <br>
target.</p>

<p style="margin-top: 1em">VCENTER: NON-ADMINISTRATOR ROLE
<br>
Instead of using the vCenter Administrator role, you can
create a custom non-administrator role to perform the
conversion. You will however need to give it a minimum set
of <br>
permissions as follows:</p>

<p style="margin-top: 1em">1. Create a custom role in
vCenter.</p>

<p style="margin-top: 1em">2. Enable (check) the following
objects:</p>

<p style="margin-top: 1em">Datastore: <br>
- Browse datastore <br>
- Low level file operations</p>

<p style="margin-top: 1em">Sessions: <br>
- Validate session</p>

<p style="margin-top: 1em">Virtual Machine: <br>
Provisioning: <br>
- Allow disk access <br>
- Allow read-only disk access <br>
- Guest Operating system management by VIX API</p>

<p style="margin-top: 1em">VCENTER: FIREWALL AND PROXY
SETTINGS <br>
vCenter: Ports</p>

<p style="margin-top: 1em">If there is a firewall between
the virt-v2v conversion server and the vCenter server, then
you will need to open port 443 (https) and port 5480.</p>

<p style="margin-top: 1em">Port 443 is used to copy the
guest disk image(s). Port 5480 is used to query vCenter for
guest metadata.</p>

<p style="margin-top: 1em">These port numbers are only the
defaults. It is possible to reconfigure vCenter to use other
port numbers. In that case you would need to specify those
ports in the &quot;vpx://&quot; <br>
URI. See &quot;VCENTER: URI&quot; above.</p>

<p style="margin-top: 1em">These ports only apply to
virt-v2v conversions. You may have to open other ports for
other vCenter functionality, for example the web user
interface. VMware documents the <br>
required ports for vCenter in their online
documentation.</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
port 443
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; virt-v2v
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para;
vCenter
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para;
ESXi &acirc; <br>
&acirc; conversion
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&para;
server &acirc; &acirc; hypervisor &acirc; <br>
&acirc; server &acirc; port 5480 &acirc; &acirc; &acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc; &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
&acirc; &acirc;guest&acirc; &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">(In the diagram above the arrows
show the direction in which the TCP connection is initiated,
not necessarily the direction of data transfer.)</p>

<p style="margin-top: 1em">Virt-v2v itself does not connect
directly to the ESXi hypervisor containing the guest.
However vCenter connects to the hypervisor and forwards the
information, so if you have a <br>
firewall between vCenter and its hypervisors you may need to
open additional ports (consult VMware documentation).</p>

<p style="margin-top: 1em">vCenter: Proxy settings</p>

<p style="margin-top: 1em">To copy the disks, virt-v2v uses
libcurl(3). The Curl library obeys the proxy environment
variables, in particular &quot;https_proxy&quot;,
&quot;all_proxy&quot; and &quot;no_proxy&quot;
(&quot;HTTPS_PROXY&quot;, <br>
&quot;ALL_PROXY&quot; and &quot;NO_PROXY&quot; can also be
used, but the lowercase named environment variables take
precedence).</p>

<p style="margin-top: 1em">If these environment variables
are set then copying may happen via the proxy, and so a
different set of ports may need to be opened in the
firewall.</p>

<p style="margin-top: 1em">The port 5480 connection never
uses a proxy.</p>

<p style="margin-top: 1em">INPUT FROM VMWARE OVA <br>
Virt-v2v is able to import guests from VMware&rsquo;s OVA
(Open Virtualization Appliance) files. Only OVAs exported
from VMware vSphere will work.</p>

<p style="margin-top: 1em">OVA: REMOVE VMWARE TOOLS FROM
WINDOWS GUESTS <br>
For Windows guests, you should remove VMware tools before
conversion. Although this is not strictly necessary, and the
guest will still be able to run, if you don&rsquo;t do this
then <br>
the converted guest will complain on every boot. The tools
cannot be removed after conversion because the uninstaller
checks if it is running on VMware and refuses to start <br>
(which is also the reason that virt-v2v cannot remove
them).</p>

<p style="margin-top: 1em">This is not necessary for Linux
guests, as virt-v2v is able to remove VMware tools.</p>

<p style="margin-top: 1em">OVA: CREATE OVA <br>
To create an OVA in vSphere, use the &quot;Export OVF
Template&quot; option (from the VM context menu, or from the
File menu). Either &quot;Folder of files&quot; (OVF) or
&quot;Single file&quot; (OVA) will <br>
work, but OVA is probably easier to deal with. OVA files are
really just uncompressed tar files, so you can use commands
like &quot;tar tf VM.ova&quot; to view their contents.</p>

<p style="margin-top: 1em">Create OVA with ovftool</p>

<p style="margin-top: 1em">You can also use VMware&rsquo;s
proprietary &quot;ovftool&quot;:</p>

<p style="margin-top: 1em">ovftool --noSSLVerify
vi://USER:PASSWORD@esxi.example.com/VM VM.ova</p>

<p style="margin-top: 1em">To connect to vCenter:</p>

<p style="margin-top: 1em">ovftool --noSSLVerify
vi://USER:PASSWORD@vcenter.example.com/DATACENTER-NAME/vm/VM
VM.ova</p>

<p style="margin-top: 1em">For Active Directory-aware
authentication, you have to express the &quot;@&quot;
character in the form of its ascii hex-code (%5c):</p>


<p style="margin-top: 1em">vi://DOMAIN%5cUSER:PASSWORD@...</p>

<p style="margin-top: 1em">OVA: IMPORTING A GUEST <br>
To import an OVA file called VM.ova, do;</p>

<p style="margin-top: 1em">$ virt-v2v -i ova VM.ova -o
local -os /var/tmp</p>

<p style="margin-top: 1em">If you exported the guest as a
&quot;Folder of files&quot;, or if you unpacked the OVA
tarball yourself, then you can point virt-v2v at the
directory containing the files:</p>

<p style="margin-top: 1em">$ virt-v2v -i ova /path/to/files
-o local -os /var/tmp</p>

<p style="margin-top: 1em">INPUT FROM VMWARE ESXi
HYPERVISOR <br>
Virt-v2v cannot access an ESXi hypervisor directly. You
should use the OVA method above (see &quot;INPUT FROM VMWARE
OVA&quot;) if possible, as it is much faster and requires
much less <br>
disk space than the method described in this section.</p>

<p style="margin-top: 1em">You can use the
virt-v2v-copy-to-local(1) tool to copy the guest off the
hypervisor into a local file, and then convert it.</p>

<p style="margin-top: 1em">ESXi: REMOVE VMWARE TOOLS FROM
WINDOWS GUESTS <br>
For Windows guests, you should remove VMware tools before
conversion. Although this is not strictly necessary, and the
guest will still be able to run, if you don&rsquo;t do this
then <br>
the converted guest will complain on every boot. The tools
cannot be removed after conversion because the uninstaller
checks if it is running on VMware and refuses to start <br>
(which is also the reason that virt-v2v cannot remove
them).</p>

<p style="margin-top: 1em">This is not necessary for Linux
guests, as virt-v2v is able to remove VMware tools.</p>

<p style="margin-top: 1em">ESXi: URI <br>
The libvirt URI for VMware ESXi hypervisors will look
something like this:</p>


<p style="margin-top: 1em">esx://root@esxi.example.com?no_verify=1</p>

<p style="margin-top: 1em">The &quot;?no_verify=1&quot;
parameter disables TLS certificate checking.</p>

<p style="margin-top: 1em">ESXi: TEST LIBVIRT CONNECTION TO
ESXi HYPERVISOR <br>
Use the virsh(1) command to test the URI and list the remote
guests available:</p>

<p style="margin-top: 1em">$ virsh -c
esx://root@esxi.example.com?no_verify=1 list --all <br>
Enter root&rsquo;s password for esxi.example.com: *** <br>
Id Name State <br>
---------------------------------------------------- <br>
- guest shut off</p>

<p style="margin-top: 1em">ESXi: COPY THE GUEST TO THE
LOCAL MACHINE <br>
Using the libvirt URI as the -ic option, copy one of the
guests to the local machine:</p>

<p style="margin-top: 1em">$ virt-v2v-copy-to-local -ic
esx://root@esxi.example.com?no_verify=1 guest</p>

<p style="margin-top: 1em">This creates guest.xml,
guest-disk1, ...</p>

<p style="margin-top: 1em">ESXi: DO THE VIRT-V2V CONVERSION
<br>
Perform the conversion of the guest using virt-v2v:</p>

<p style="margin-top: 1em">$ virt-v2v -i libvirtxml
guest.xml -o local -os /var/tmp</p>

<p style="margin-top: 1em">ESXi: CLEAN UP <br>
Remove the guest.xml and guest-disk* files.</p>

<p style="margin-top: 1em">INPUT FROM RHEL 5 XEN <br>
Virt-v2v is able to import Xen guests from RHEL 5 Xen
hosts.</p>

<p style="margin-top: 1em">Virt-v2v uses libvirt for access
to the remote Xen host, and therefore the input mode should
be -i libvirt. As this is the default, you don&rsquo;t need
to specify it on the command <br>
line.</p>

<p style="margin-top: 1em">XEN: SET UP SSH-AGENT ACCESS TO
XEN HOST <br>
Currently you must enable passwordless SSH access to the
remote Xen host from the virt-v2v conversion server.</p>

<p style="margin-top: 1em">You must also use ssh-agent, and
add your ssh public key to /root/.ssh/authorized_keys (on
the Xen host).</p>

<p style="margin-top: 1em">After doing this, you should
check that passwordless access works from the virt-v2v
server to the Xen host. For example:</p>

<p style="margin-top: 1em">$ ssh root@xen.example.com <br>
[ logs straight into the shell, no password is requested
]</p>

<p style="margin-top: 1em">Note that password-interactive
and Kerberos access are not supported. You have to set up
ssh access using ssh-agent and authorized_keys.</p>

<p style="margin-top: 1em">XEN: TEST LIBVIRT CONNECTION TO
REMOTE XEN HOST <br>
Use the virsh(1) command to list the guests on the remote
Xen host:</p>

<p style="margin-top: 1em">$ virsh -c
xen+ssh://root@xen.example.com list --all <br>
Id Name State <br>
---------------------------------------------------- <br>
0 Domain-0 running <br>
- rhel49-x86_64-pv shut off</p>

<p style="margin-top: 1em">You should also try dumping the
metadata from any guest on your server, like this:</p>

<p style="margin-top: 1em">$ virsh -c
xen+ssh://root@xen.example.com dumpxml rhel49-x86_64-pv <br>
&lt;domain type=&rsquo;xen&rsquo;&gt; <br>
&lt;name&gt;rhel49-x86_64-pv&lt;/name&gt; <br>
[...] <br>
&lt;/domain&gt;</p>

<p style="margin-top: 1em">If the above commands do not
work, then virt-v2v is not going to work either. Fix your
libvirt configuration or the remote server before
continuing.</p>

<p style="margin-top: 1em">If the guest disks are located
on a host block device, then the conversion will fail. See
&quot;XEN OR SSH CONVERSIONS FROM BLOCK DEVICES&quot; below
for a workaround.</p>

<p style="margin-top: 1em">XEN: IMPORTING A GUEST <br>
To import a particular guest from a Xen server, do:</p>

<p style="margin-top: 1em">$ virt-v2v -ic
&rsquo;xen+ssh://root@xen.example.com&rsquo;
rhel49-x86_64-pv -o local -os /var/tmp</p>

<p style="margin-top: 1em">where
&quot;rhel49-x86_64-pv&quot; is the name of the guest (which
must be shut down).</p>

<p style="margin-top: 1em">In this case the output flags
are set to write the converted guest to a temporary
directory as this is just an example, but you can also write
to libvirt or any other supported <br>
target.</p>

<p style="margin-top: 1em">XEN OR SSH CONVERSIONS FROM
BLOCK DEVICES <br>
Currently virt-v2v cannot directly access a Xen guest (or
any guest located remotely over ssh) if that guest&rsquo;s
disks are located on host block devices.</p>

<p style="margin-top: 1em">To tell if a Xen guest uses host
block devices, look at the guest XML. You will see:</p>

<p style="margin-top: 1em">&lt;disk
type=&rsquo;block&rsquo; device=&rsquo;disk&rsquo;&gt; <br>
... <br>
&lt;source dev=&rsquo;/dev/VG/guest&rsquo;/&gt;</p>

<p style="margin-top: 1em">where
&quot;type=&rsquo;block&rsquo;&quot;, &quot;source
dev=&quot; and &quot;/dev/...&quot; are all indications that
the disk is located on a host block device.</p>

<p style="margin-top: 1em">This happens because the qemu
ssh block driver that we use to access remote disks uses the
ssh sftp protocol, and this protocol cannot correctly detect
the size of host block <br>
devices.</p>

<p style="margin-top: 1em">The workaround is to copy the
guest over to the conversion server, using the separate
virt-v2v-copy-to-local(1) tool, followed by running
virt-v2v. You will need sufficient <br>
space on the conversion server to store a full copy of the
guest.</p>

<p style="margin-top: 1em">virt-v2v-copy-to-local -ic
xen+ssh://root@xen.example.com guest <br>
virt-v2v -i libvirtxml guest.xml -o local -os /var/tmp <br>
rm guest.xml guest-disk*</p>

<p style="margin-top: 1em">OUTPUT TO LIBVIRT <br>
The -o libvirt option lets you upload the converted guest to
a libvirt-managed host. There are several limitations:</p>

<p style="margin-top: 1em">&Acirc;&middot; You can only use
a local libvirt connection [see below for how to workaround
this].</p>

<p style="margin-top: 1em">&Acirc;&middot; The -os pool
option must specify a directory pool, not anything more
exotic such as iSCSI [but see below].</p>

<p style="margin-top: 1em">&Acirc;&middot; You can only
upload to a KVM hypervisor.</p>

<p style="margin-top: 1em">To output to a remote libvirt
instance and/or a non-directory storage pool you have to use
the following workaround:</p>

<p style="margin-top: 1em">1. Use virt-v2v in -o local mode
to convert the guest disks and metadata into a local
temporary directory:</p>

<p style="margin-top: 1em">virt-v2v [...] -o local -os
/var/tmp</p>

<p style="margin-top: 1em">This creates two (or more) files
in /var/tmp called:</p>

<p style="margin-top: 1em">/var/tmp/NAME.xml # the libvirt
XML (metadata) <br>
/var/tmp/NAME-sda # the guest&rsquo;s first disk</p>

<p style="margin-top: 1em">(for &quot;NAME&quot; substitute
the guest&rsquo;s name).</p>

<p style="margin-top: 1em">2. Upload the converted disk(s)
into the storage pool called &quot;POOL&quot;:</p>

<p style="margin-top: 1em">size=$(stat -c%s
/var/tmp/NAME-sda) <br>
virsh vol-create-as POOL NAME-sda $size --format raw <br>
virsh vol-upload --pool POOL NAME-sda /var/tmp/NAME-sda</p>

<p style="margin-top: 1em">3. Edit /var/tmp/NAME.xml to
change /var/tmp/NAME-sda to the pool name. In other words,
locate the following bit of XML:</p>

<p style="margin-top: 1em">&lt;disk type=&rsquo;file&rsquo;
device=&rsquo;disk&rsquo;&gt; <br>
&lt;driver name=&rsquo;qemu&rsquo; type=&rsquo;raw&rsquo;
cache=&rsquo;none&rsquo; /&gt; <br>
&lt;source file=&rsquo;/var/tmp/NAME-sda&rsquo; /&gt; <br>
&lt;target dev=&rsquo;hda&rsquo; bus=&rsquo;ide&rsquo; /&gt;
<br>
&lt;/disk&gt;</p>

<p style="margin-top: 1em">and change two things: The
&quot;type=&rsquo;file&rsquo;&quot; attribute must be
changed to &quot;type=&rsquo;volume&rsquo;&quot;, and the
&quot;&lt;source&gt;&quot; element must be changed to
include &quot;pool&quot; and &quot;volume&quot;
attributes:</p>

<p style="margin-top: 1em">&lt;disk
type=&rsquo;volume&rsquo; device=&rsquo;disk&rsquo;&gt; <br>
... <br>
&lt;source pool=&rsquo;POOL&rsquo;
volume=&rsquo;NAME-sda&rsquo; /&gt; <br>
... <br>
&lt;/disk&gt;</p>

<p style="margin-top: 1em">4. Define the final guest in
libvirt:</p>

<p style="margin-top: 1em">virsh define
/var/tmp/NAME.xml</p>

<p style="margin-top: 1em">OUTPUT TO RHEV <br>
This section only applies to the -o rhev output mode. If you
use virt-v2v from the RHEV-M user interface, then behind the
scenes the import is managed by VDSM using the -o vdsm <br>
output mode (which end users should not try to use
directly).</p>

<p style="margin-top: 1em">You have to specify -o rhev and
an -os option that points to the RHEV-M Export Storage
Domain. You can either specify the NFS server and
mountpoint, eg. <br>
&quot;-os&Acirc;&nbsp;rhev-storage:/rhev/export&quot;, or
you can mount that first and point to the directory where it
is mounted, eg. &quot;-os&Acirc;&nbsp;/tmp/mnt&quot;. Be
careful not to point to the Data Storage <br>
Domain by accident as that will not work.</p>

<p style="margin-top: 1em">On successful completion
virt-v2v will have written the new guest to the Export
Storage Domain, but it will not yet be ready to run. It must
be imported into RHEV using the UI <br>
before it can be used.</p>

<p style="margin-top: 1em">In RHEV &acirc;&yen; 2.2 this is
done from the Storage tab. Select the export domain the
guest was written to. A pane will appear underneath the
storage domain list displaying several <br>
tabs, one of which is &quot;VM Import&quot;. The converted
guest will be listed here. Select the appropriate guest an
click &quot;Import&quot;. See the RHEV documentation for
additional details.</p>

<p style="margin-top: 1em">If you export several guests,
then you can import them all at the same time through the
UI.</p>

<p style="margin-top: 1em">OUTPUT TO GLANCE <br>
To output to OpenStack Glance, use the -o glance option.</p>

<p style="margin-top: 1em">This runs the glance(1) CLI
program which must be installed on the virt-v2v conversion
host. For authentication to work, you will need to set
&quot;OS_*&quot; environment variables. In <br>
most cases you can do this by sourcing a file called
something like keystonerc_admin.</p>

<p style="margin-top: 1em">Virt-v2v adds metadata for the
guest to Glance, describing such things as the guest
operating system and what drivers it requires. The command
&quot;glance image-show&quot; will display <br>
the metadata as &quot;Property&quot; fields such as
&quot;os_type&quot; and &quot;hw_disk_bus&quot;.</p>

<p style="margin-top: 1em">Glance and sparseness <br>
Glance image upload doesn&rsquo;t appear to correctly handle
sparseness. For this reason, using qcow2 will be faster and
use less space on the Glance server. Use the virt-v2v <br>
-of&Acirc;&nbsp;qcow2 option.</p>

<p style="margin-top: 1em">Glance and multiple disks <br>
If the guest has a single disk, then the name of the disk in
Glance will be the name of the guest. You can control this
using the -on option.</p>

<p style="margin-top: 1em">Glance doesn&rsquo;t have a
concept of associating multiple disks with a single guest,
and Nova doesn&rsquo;t allow you to boot a guest from
multiple Glance disks either. If the guest has <br>
multiple disks, then the first (assumed to be the system
disk) will have the name of the guest, and the second and
subsequent data disks will be called
&quot;guestname-disk2&quot;, <br>
&quot;guestname-disk3&quot; etc. It may be best to leave the
system disk in Glance, and import the data disks to Cinder
(see next section).</p>

<p style="margin-top: 1em">Importing disks into Cinder <br>
Since most virt-v2v guests are &quot;pets&quot;, Glance is
perhaps not the best place to store them. There is no way
for virt-v2v to upload directly to Cinder <br>
(https://bugzilla.redhat.com/1155229). There are two ways to
upload to Cinder:</p>

<p style="margin-top: 1em">1. Import the image to Glance
first (ie. -o glance) and then copy it to Cinder:</p>

<p style="margin-top: 1em">cinder create --image-id
&lt;GLANCE-IMAGE-UUID&gt; &lt;SIZE&gt;</p>

<p style="margin-top: 1em">2. Create (through some other
means) a new volume / LUN in your Cinder backing store.
Migrate the guest to this volume (using -o local). Then ask
Cinder to take over <br>
management of the volume using:</p>

<p style="margin-top: 1em">cinder manage
&lt;VOLUMEREF&gt;</p>

<p style="margin-top: 1em">RESOURCE REQUIREMENTS <br>
Network <br>
The most important resource for virt-v2v appears to be
network bandwidth. Virt-v2v should be able to copy guest
data at gigabit ethernet speeds or greater.</p>

<p style="margin-top: 1em">Ensure that the network
connections between servers (conversion server, NFS server,
vCenter, Xen) are as fast and as low latency as
possible.</p>

<p style="margin-top: 1em">Disk space <br>
Virt-v2v places potentially large temporary files in $TMPDIR
(which is /var/tmp if you don&rsquo;t set it). Using tmpfs
is a bad idea.</p>

<p style="margin-top: 1em">For each guest disk, an overlay
is stored temporarily. This stores the changes made during
conversion, and is used as a cache. The overlays are not
particularly large - tens or <br>
low hundreds of megabytes per disk is typical. In addition
to the overlay(s), input and output methods may use disk
space, as outlined in the table below.</p>

<p style="margin-top: 1em">-i ova <br>
This temporarily places a full copy of the uncompressed
source disks in $TMPDIR.</p>

<p style="margin-top: 1em">-o glance <br>
This temporarily places a full copy of the output disks in
$TMPDIR.</p>

<p style="margin-top: 1em">-o local <br>
-o qemu <br>
You must ensure there is sufficient space in the output
directory for the converted guest.</p>

<p style="margin-top: 1em">-o null <br>
This temporarily places a full copy of the output disks in
$TMPDIR.</p>

<p style="margin-top: 1em">See also &quot;Minimum free
space check in the host&quot; below.</p>

<p style="margin-top: 1em">VMware vCenter resources <br>
Copying from VMware vCenter is currently quite slow, but we
believe this to be an issue with VMware. Ensuring the VMware
ESXi hypervisor and vCenter are running on fast hardware
<br>
with plenty of memory should alleviate this.</p>

<p style="margin-top: 1em">Compute power and RAM <br>
Virt-v2v is not especially compute or RAM intensive. If you
are running many parallel conversions, then you may consider
allocating one CPU core and between 512 MB and 1 GB of <br>
RAM per running instance.</p>

<p style="margin-top: 1em">Virt-v2v can be run in a virtual
machine.</p>

<p style="margin-top: 1em">Trimming <br>
Virt-v2v attempts to optimize the speed of conversion by
ignoring guest filesystem data which is not used. This would
include unused filesystem blocks, blocks containing zeroes,
<br>
and deleted files.</p>

<p style="margin-top: 1em">To do this, virt-v2v issues a
non-destructive fstrim(8) operation. As this happens to an
overlay placed over the guest data, it does not affect the
source in any way.</p>

<p style="margin-top: 1em">If this fstrim operation fails,
you will see a warning, but virt-v2v will continue anyway.
It may run more slowly (in some cases much more slowly),
because it is copying the <br>
unused parts of the disk.</p>

<p style="margin-top: 1em">Unfortunately support for fstrim
is not universal, and it also depends on specific details of
the filesystem, partition alignment, and backing storage. As
an example, NTFS <br>
filesystems cannot be fstrimmed if they occupy a partition
which is not aligned to the underlying storage. That was the
default on Windows before Vista. As another example, <br>
VFAT filesystems (used by UEFI guests) cannot be trimmed at
all.</p>

<p style="margin-top: 1em">fstrim support in the Linux
kernel is improving gradually, so over time some of these
restrictions will be lifted and virt-v2v will work
faster.</p>

<p style="margin-top: 1em">POST-CONVERSION TASKS <br>
Guest network configuration <br>
Virt-v2v cannot currently reconfigure a guest&rsquo;s
network configuration. If the converted guest is not
connected to the same subnet as the source, its network
configuration may <br>
have to be updated. See also virt-customize(1).</p>

<p style="margin-top: 1em">Converting a Windows guest <br>
When converting a Windows guests, the conversion process is
split into two stages:</p>

<p style="margin-top: 1em">1. Offline conversion.</p>

<p style="margin-top: 1em">2. First boot.</p>

<p style="margin-top: 1em">The guest will be bootable after
the offline conversion stage, but will not yet have all
necessary drivers installed to work correctly. These will be
installed automatically the <br>
first time the guest boots.</p>

<p style="margin-top: 1em">N.B. Take care not to interrupt
the automatic driver installation process when logging in to
the guest for the first time, as this may prevent the guest
from subsequently booting <br>
correctly.</p>

<p style="margin-top: 1em">FREE SPACE FOR CONVERSION <br>
Free space in the guest <br>
Virt-v2v checks there is sufficient free space in the guest
filesystem to perform the conversion. Currently it
checks:</p>

<p style="margin-top: 1em">Linux root filesystem or Windows
&quot;C:&quot; drive <br>
Minimum free space: 20 MB</p>

<p style="margin-top: 1em">Linux /boot <br>
Minimum free space: 50 MB</p>

<p style="margin-top: 1em">This is because we need to build
a new initramfs for some Enterprise Linux conversions.</p>

<p style="margin-top: 1em">Any other mountable filesystem
<br>
Minimum free space: 10 MB</p>

<p style="margin-top: 1em">Minimum free space check in the
host <br>
You must have sufficient free space in the host directory
used to store temporary overlays (except in --in-place
mode). To find out which directory this is, use:</p>

<p style="margin-top: 1em">$ df -h &quot;&lsquo;guestfish
get-cachedir&lsquo;&quot; <br>
Filesystem Size Used Avail Use% Mounted on <br>
/dev/mapper/root 50G 40G 6.8G 86% /</p>

<p style="margin-top: 1em">and look under the
&quot;Avail&quot; column. Virt-v2v will refuse to do the
conversion at all unless at least 1GB is available
there.</p>

<p style="margin-top: 1em">See also &quot;RESOURCE
REQUIREMENTS&quot; above.</p>

<p style="margin-top: 1em">RUNNING VIRT-V2V AS ROOT OR
NON-ROOT <br>
Nothing in virt-v2v inherently needs root access, and it
will run just fine as a non-root user. However, certain
external features may require either root or a special
user:</p>

<p style="margin-top: 1em">Mounting the Export Storage
Domain <br>
When using -o rhev -os server:/esd virt-v2v has to have
sufficient privileges to NFS mount the Export Storage Domain
from &quot;server&quot;.</p>

<p style="margin-top: 1em">You can avoid needing root here
by mounting it yourself before running virt-v2v, and passing
-os /mountpoint instead, but first of all read the next
section&Acirc;&nbsp;...</p>

<p style="margin-top: 1em">Writing to the Export Storage
Domain as 36:36 <br>
RHEV-M cannot read files and directories from the Export
Storage Domain unless they have UID:GID 36:36. You will see
VM import problems if the UID:GID is not correct.</p>

<p style="margin-top: 1em">When you run virt-v2v -o rhev as
root, virt-v2v attempts to create files and directories with
the correct ownership. If you run virt-v2v as non-root, it
will probably still <br>
work, but you will need to manually change ownership after
virt-v2v has finished.</p>

<p style="margin-top: 1em">Writing to libvirt <br>
When using -o libvirt, you may need to run virt-v2v as root
so that it can write to the libvirt system instance (ie.
&quot;qemu:///system&quot;) and to the default location for
disk <br>
images (usually /var/lib/libvirt/images).</p>

<p style="margin-top: 1em">You can avoid this by setting up
libvirt connection authentication, see
http://libvirt.org/auth.html. Alternatively, use -oc
qemu:///session, which will write to your per- <br>
user libvirt instance.</p>

<p style="margin-top: 1em">Writing to Glance <br>
This does not need root (in fact it probably won&rsquo;t
work), but may require either a special user and/or for you
to source a script that sets authentication environment <br>
variables. Consult the Glance documentation.</p>

<p style="margin-top: 1em">DEBUGGING RHEV-M IMPORT FAILURES
<br>
When you export to the RHEV-M Export Storage Domain, and
then import that guest through the RHEV-M UI, you may
encounter an import failure. Diagnosing these failures is
<br>
infuriatingly difficult as the UI generally hides the true
reason for the failure.</p>

<p style="margin-top: 1em">There are two log files of
interest. The first is stored on the RHEV-M server itself,
and is called /var/log/ovirt-engine/engine.log</p>

<p style="margin-top: 1em">The second file, which is the
most useful, is found on the SPM host (SPM stands for
&quot;Storage Pool Manager&quot;). This is a RHEV node that
is elected to do all metadata modifications <br>
in the data center, such as image or snapshot creation. You
can find out which host is the current SPM from the
&quot;Hosts&quot; tab &quot;Spm Status&quot; column. Once
you have located the SPM, <br>
log into it and grab the file /var/log/vdsm/vdsm.log which
will contain detailed error messages from low-level
commands.</p>

<p style="margin-top: 1em">MINIMAL XML FOR -i libvirtxml
OPTION <br>
When using the -i libvirtxml option, you have to supply some
libvirt XML. Writing this from scratch is hard, so the
template below is helpful.</p>

<p style="margin-top: 1em">Note this should only be used
for testing and/or where you know what you&rsquo;re doing!
If you have libvirt metadata for the guest, always use that
instead.</p>

<p style="margin-top: 1em">&lt;domain
type=&rsquo;kvm&rsquo;&gt; <br>
&lt;name&gt;NAME&lt;/name&gt; <br>
&lt;memory&gt;1048576&lt;/memory&gt; <br>
&lt;vcpu&gt;2&lt;/vcpu&gt; <br>
&lt;os&gt; <br>
&lt;type&gt;hvm&lt;/type&gt; <br>
&lt;boot dev=&rsquo;hd&rsquo;/&gt; <br>
&lt;/os&gt; <br>
&lt;features&gt; <br>
&lt;acpi/&gt; <br>
&lt;apic/&gt; <br>
&lt;pae/&gt; <br>
&lt;/features&gt; <br>
&lt;devices&gt; <br>
&lt;disk type=&rsquo;file&rsquo;
device=&rsquo;disk&rsquo;&gt; <br>
&lt;driver name=&rsquo;qemu&rsquo;
type=&rsquo;raw&rsquo;/&gt; <br>
&lt;source file=&rsquo;/path/to/disk/image&rsquo;/&gt; <br>
&lt;target dev=&rsquo;hda&rsquo; bus=&rsquo;ide&rsquo;/&gt;
<br>
&lt;/disk&gt; <br>
&lt;interface type=&rsquo;network&rsquo;&gt; <br>
&lt;mac address=&rsquo;52:54:00:01:02:03&rsquo;/&gt; <br>
&lt;source network=&rsquo;default&rsquo;/&gt; <br>
&lt;model type=&rsquo;rtl8139&rsquo;/&gt; <br>
&lt;/interface&gt; <br>
&lt;/devices&gt; <br>
&lt;/domain&gt;</p>

<p style="margin-top: 1em">MACHINE READABLE OUTPUT <br>
The --machine-readable option can be used to make the output
more machine friendly, which is useful when calling virt-v2v
from other programs, GUIs etc.</p>

<p style="margin-top: 1em">There are two ways to use this
option.</p>

<p style="margin-top: 1em">Firstly use the option on its
own to query the capabilities of the virt-v2v binary.
Typical output looks like this:</p>

<p style="margin-top: 1em">$ virt-v2v --machine-readable
<br>
virt-v2v <br>
libguestfs-rewrite <br>
input:disk <br>
[...] <br>
output:local <br>
[...] <br>
convert:enterprise-linux <br>
convert:windows</p>

<p style="margin-top: 1em">A list of features is printed,
one per line, and the program exits with status 0.</p>

<p style="margin-top: 1em">The &quot;input:&quot; and
&quot;output:&quot; features refer to -i and -o (input and
output mode) options supported by this binary. The
&quot;convert:&quot; features refer to guest types that this
binary <br>
knows how to convert.</p>

<p style="margin-top: 1em">Secondly use the option in
conjunction with other options to make the regular program
output more machine friendly.</p>

<p style="margin-top: 1em">At the moment this means:</p>

<p style="margin-top: 1em">1. Progress bar messages can be
parsed from stdout by looking for this regular
expression:</p>

<p style="margin-top: 1em">^[0-9]+/[0-9]+$</p>

<p style="margin-top: 1em">2. The calling program should
treat messages sent to stdout (except for progress bar
messages) as status messages. They can be logged and/or
displayed to the user.</p>

<p style="margin-top: 1em">3. The calling program should
treat messages sent to stderr as error messages. In
addition, virt-v2v exits with a non-zero status code if
there was a fatal error.</p>

<p style="margin-top: 1em">Virt-v2v &acirc;&curren; 0.9.1
did not support the --machine-readable option at all. The
option was added when virt-v2v was rewritten in 2014.</p>

<p style="margin-top: 1em">FILES <br>
/usr/share/virtio-win <br>
(Optional)</p>

<p style="margin-top: 1em">If this directory is present,
then virtio drivers for Windows guests will be found from
this directory and installed in the guest during
conversion.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
&quot;TMPDIR&quot; <br>
Location of the temporary directory used for the potentially
large temporary overlay file.</p>

<p style="margin-top: 1em">See the &quot;Disk space&quot;
section above.</p>

<p style="margin-top: 1em">&quot;VIRT_TOOLS_DATA_DIR&quot;
<br>
This can point to the directory containing data files used
for Windows conversion.</p>

<p style="margin-top: 1em">Normally you do not need to set
this. If not set, a compiled-in default will be used
(something like /usr/share/virt-tools).</p>

<p style="margin-top: 1em">This directory may contain the
following files:</p>

<p style="margin-top: 1em">rhsrvany.exe <br>
(Required when doing conversions of Windows guests)</p>

<p style="margin-top: 1em">This is the RHSrvAny Windows
binary, used to install a &quot;firstboot&quot; script in
the guest during conversion of Windows guests.</p>

<p style="margin-top: 1em">See also:
&quot;https://github.com/rwmjones/rhsrvany&quot;</p>

<p style="margin-top: 1em">rhev-apt.exe <br>
(Optional)</p>

<p style="margin-top: 1em">The RHEV Application
Provisioning Tool (RHEV APT). If this file is present, then
RHEV APT will be installed in the Windows guest during
conversion. This tool is a guest <br>
agent which ensures that the virtio drivers remain up to
date when the guest is running on Red Hat Enterprise
Virtualization (RHEV).</p>

<p style="margin-top: 1em">This file comes from Red Hat
Enterprise Virtualization (RHEV), and is not distributed
with virt-v2v.</p>

<p style="margin-top: 1em">&quot;VIRTIO_WIN&quot; <br>
This is where VirtIO drivers for Windows are searched for
(/usr/share/virtio-win if unset). It can be a directory or
point to virtio-win.iso (CD ROM image containing <br>
drivers).</p>

<p style="margin-top: 1em">See &quot;ENABLING
VIRTIO&quot;.</p>

<p style="margin-top: 1em">For other environment variables,
see &quot;ENVIRONMENT VARIABLES&quot; in guestfs(3).</p>

<p style="margin-top: 1em">OTHER TOOLS <br>
virt-v2v-copy-to-local(1) <br>
There are some special cases where virt-v2v cannot directly
access the remote hypervisor. In that case you have to use
virt-v2v-copy-to-local(1) to make a local copy of the <br>
guest first, followed by running &quot;virt-v2v -i
libvirtxml&quot; to perform the conversion.</p>

<p style="margin-top: 1em">engine-image-uploader(8) <br>
Variously called &quot;engine-image-uploader&quot;,
&quot;ovirt-image-uploader&quot; or
&quot;rhevm-image-uploader&quot;, this tool allows you to
copy a guest from one oVirt or RHEV Export Storage Domain
<br>
to another. It only permits importing a guest that was
previously exported from another oVirt/RHEV instance.</p>

<p style="margin-top: 1em">import-to-ovirt.pl <br>
This script can be used to import guests that already run on
KVM to oVirt or RHEV. For more information, see this blog
posting by the author of virt-v2v:</p>


<p style="margin-top: 1em">https://rwmj.wordpress.com/2015/09/18/importing-kvm-guests-to-ovirt-or-rhev/#content</p>

<p style="margin-top: 1em">SEE ALSO <br>
virt-p2v(1), virt-customize(1), virt-df(1),
virt-filesystems(1), virt-sparsify(1), virt-sysprep(1),
guestfs(3), guestfish(1), qemu-img(1), fstrim(8),
virt-v2v-copy-to-local(1), <br>
virt-v2v-test-harness(1), engine-image-uploader(8),
import-to-ovirt.pl, http://libguestfs.org/.</p>

<p style="margin-top: 1em">AUTHORS <br>
Richard W.M. Jones http://people.redhat.com/~rjones/</p>

<p style="margin-top: 1em">Matthew Booth</p>

<p style="margin-top: 1em">Mike Latimer</p>

<p style="margin-top: 1em">Pino Toscano</p>

<p style="margin-top: 1em">Shahar Havivi</p>

<p style="margin-top: 1em">Tingting Zheng</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (C) 2009-2016 Red Hat Inc.</p>

<p style="margin-top: 1em">LICENSE <br>
This program is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
<br>
version 2 of the License, or (at your option) any later
version.</p>

<p style="margin-top: 1em">This program is distributed in
the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR <br>
PURPOSE. See the GNU General Public License for more
details.</p>

<p style="margin-top: 1em">You should have received a copy
of the GNU General Public License along with this program;
if not, write to the Free Software Foundation, Inc., 51
Franklin Street, Fifth Floor, <br>
Boston, MA 02110-1301 USA.</p>

<p style="margin-top: 1em">BUGS <br>
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-top: 1em">To report a new bug against
libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-top: 1em">When reporting a bug, please
supply:</p>

<p style="margin-top: 1em">&Acirc;&middot; The version of
libguestfs.</p>

<p style="margin-top: 1em">&Acirc;&middot; Where you got
libguestfs (eg. which Linux distro, compiled from source,
etc)</p>

<p style="margin-top: 1em">&Acirc;&middot; Describe the bug
accurately and give a way to reproduce it.</p>

<p style="margin-top: 1em">&Acirc;&middot; Run
libguestfs-test-tool(1) and paste the complete, unedited
output into the bug report.</p>

<p style="margin-top: 1em">libguestfs-1.32.7 2016-08-08
virt-v2v(1)</p>
<hr>
</body>
</html>
