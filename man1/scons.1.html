<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:37:03 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>SCONS(1) SCons 2.5.1 SCONS(1)</p>

<p style="margin-top: 1em">NAME <br>
scons - a software construction tool</p>

<p style="margin-top: 1em">SYNOPSIS <br>
scons [options...] [name=val...] [targets...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The scons utility builds software (or other files) by
determining which component pieces must be rebuilt and
executing the necessary commands to rebuild them.</p>

<p style="margin-top: 1em">By default, scons searches for a
file named SConstruct, Sconstruct, or sconstruct (in that
order) in the current directory and reads its configuration
from the first file found. <br>
An alternate file name may be specified via the -f
option.</p>

<p style="margin-top: 1em">The SConstruct file can specify
subsidiary configuration files using the SConscript()
function. By convention, these subsidiary files are named
SConscript, although any name may <br>
be used. (Because of this naming convention, the term
&quot;SConscript files&quot; is sometimes used to refer
generically to all scons configuration files, regardless of
actual file name.)</p>

<p style="margin-top: 1em">The configuration files specify
the target files to be built, and (optionally) the rules to
build those targets. Reasonable default rules exist for
building common software <br>
components (executable programs, object files, libraries),
so that for most software projects, only the target and
input files need be specified.</p>

<p style="margin-top: 1em">Before reading the SConstruct
file, scons looks for a directory named site_scons in
various system directories (see below) and the directory
containing the SConstruct file; for <br>
each of those dirs which exists, site_scons is prepended to
sys.path, the file site_scons/site_init.py, is evaluated if
it exists, and the directory site_scons/site_tools is <br>
prepended to the default toolpath if it exists. See the
--no-site-dir and --site-dir options for more details.</p>

<p style="margin-top: 1em">scons reads and executes the
SConscript files as Python scripts, so you may use normal
Python scripting capabilities (such as flow control, data
manipulation, and imported Python <br>
libraries) to handle complicated build situations. scons,
however, reads and executes all of the SConscript files
before it begins building any targets. To make this obvious,
<br>
scons prints the following messages about what it is
doing:</p>

<p style="margin-top: 1em">$ scons foo.out <br>
scons: Reading SConscript files ... <br>
scons: done reading SConscript files. <br>
scons: Building targets ... <br>
cp foo.in foo.out <br>
scons: done building targets. <br>
$</p>

<p style="margin-top: 1em">The status messages (everything
except the line that reads &quot;cp foo.in foo.out&quot;)
may be suppressed using the -Q option.</p>

<p style="margin-top: 1em">scons does not automatically
propagate the external environment used to execute scons to
the commands used to build target files. This is so that
builds will be guaranteed <br>
repeatable regardless of the environment variables set at
the time scons is invoked. This also means that if the
compiler or other commands that you want to use to build
your <br>
target files are not in standard system locations, scons
will not find them unless you explicitly set the PATH to
include those locations. Whenever you create an scons <br>
construction environment, you can propagate the value of
PATH from your external environment as follows:</p>

<p style="margin-top: 1em">import os <br>
env = Environment(ENV = {&rsquo;PATH&rsquo; :
os.environ[&rsquo;PATH&rsquo;]})</p>

<p style="margin-top: 1em">Similarly, if the commands use
external environment variables like $PATH, $HOME,
$JAVA_HOME, $LANG, $SHELL, $TERM, etc., these variables can
also be explicitly propagated:</p>

<p style="margin-top: 1em">import os <br>
env = Environment(ENV = {&rsquo;PATH&rsquo; :
os.environ[&rsquo;PATH&rsquo;], <br>
&rsquo;HOME&rsquo; : os.environ[&rsquo;HOME&rsquo;]})</p>

<p style="margin-top: 1em">Or you may explicitly propagate
the invoking user&rsquo;s complete external environment:</p>

<p style="margin-top: 1em">import os <br>
env = Environment(ENV = os.environ)</p>

<p style="margin-top: 1em">This comes at the expense of
making your build dependent on the user&rsquo;s environment
being set correctly, but it may be more convenient for many
configurations.</p>

<p style="margin-top: 1em">scons can scan known input files
automatically for dependency information (for example,
#include statements in C or C++ files) and will rebuild
dependent files appropriately <br>
whenever any &quot;included&quot; input file changes. scons
supports the ability to define new scanners for unknown
input file types.</p>

<p style="margin-top: 1em">scons knows how to fetch files
automatically from SCCS or RCS subdirectories using SCCS,
RCS or BitKeeper.</p>

<p style="margin-top: 1em">scons is normally executed in a
top-level directory containing a SConstruct file, optionally
specifying as command-line arguments the target file or
files to be built.</p>

<p style="margin-top: 1em">By default, the command</p>

<p style="margin-top: 1em">scons</p>

<p style="margin-top: 1em">will build all target files in
or below the current directory. Explicit default targets (to
be built when no targets are specified on the command line)
may be defined the <br>
SConscript file(s) using the Default() function, described
below.</p>

<p style="margin-top: 1em">Even when Default() targets are
specified in the SConscript file(s), all target files in or
below the current directory may be built by explicitly
specifying the current <br>
directory (.) as a command-line target:</p>

<p style="margin-top: 1em">scons .</p>

<p style="margin-top: 1em">Building all target files,
including any files outside of the current directory, may be
specified by supplying a command-line target of the root
directory (on POSIX systems):</p>

<p style="margin-top: 1em">scons /</p>

<p style="margin-top: 1em">or the path name(s) of the
volume(s) in which all the targets should be built (on
Windows systems):</p>

<p style="margin-top: 1em">scons C:&nbsp;D: <br>
To build only specific targets, supply them as command-line
arguments:</p>

<p style="margin-top: 1em">scons foo bar</p>

<p style="margin-top: 1em">in which case only the specified
targets will be built (along with any derived files on which
they depend).</p>

<p style="margin-top: 1em">Specifying &quot;cleanup&quot;
targets in SConscript files is not usually necessary. The -c
flag removes all files necessary to build the specified
target:</p>

<p style="margin-top: 1em">scons -c .</p>

<p style="margin-top: 1em">to remove all target files,
or:</p>

<p style="margin-top: 1em">scons -c build export</p>

<p style="margin-top: 1em">to remove target files under
build and export. Additional files or directories to remove
can be specified using the Clean() function. Conversely,
targets that would normally be <br>
removed by the -c invocation can be prevented from being
removed by using the NoClean() function.</p>

<p style="margin-top: 1em">A subset of a hierarchical tree
may be built by remaining at the top-level directory (where
the SConstruct file lives) and specifying the subdirectory
as the target to be built:</p>

<p style="margin-top: 1em">scons src/subdir</p>

<p style="margin-top: 1em">or by changing directory and
invoking scons with the -u option, which traverses up the
directory hierarchy until it finds the SConstruct file, and
then builds targets relatively <br>
to the current subdirectory:</p>

<p style="margin-top: 1em">cd src/subdir <br>
scons -u .</p>

<p style="margin-top: 1em">scons supports building multiple
targets in parallel via a -j option that takes, as its
argument, the number of simultaneous tasks that may be
spawned:</p>

<p style="margin-top: 1em">scons -j 4</p>

<p style="margin-top: 1em">builds four targets in parallel,
for example.</p>

<p style="margin-top: 1em">scons can maintain a cache of
target (derived) files that can be shared between multiple
builds. When caching is enabled in a SConscript file, any
target files built by scons <br>
will be copied to the cache. If an up-to-date target file is
found in the cache, it will be retrieved from the cache
instead of being rebuilt locally. Caching behavior may be
<br>
disabled and controlled in other ways by the --cache-force,
--cache-disable, --cache-readonly, and --cache-show
command-line options. The --random option is useful to
prevent <br>
multiple builds from trying to update the cache
simultaneously.</p>

<p style="margin-top: 1em">Values of variables to be passed
to the SConscript file(s) may be specified on the command
line:</p>

<p style="margin-top: 1em">scons debug=1 .</p>

<p style="margin-top: 1em">These variables are available in
SConscript files through the ARGUMENTS dictionary, and can
be used in the SConscript file(s) to modify the build in any
way:</p>

<p style="margin-top: 1em">if
ARGUMENTS.get(&rsquo;debug&rsquo;, 0): <br>
env = Environment(CCFLAGS = &rsquo;-g&rsquo;) <br>
else: <br>
env = Environment()</p>

<p style="margin-top: 1em">The command-line variable
arguments are also available in the ARGLIST list, indexed by
their order on the command line. This allows you to process
them in order rather than by <br>
name, if necessary. ARGLIST[0] returns a tuple containing
(argname, argvalue). A Python exception is thrown if you try
to access a list member that does not exist.</p>

<p style="margin-top: 1em">scons requires Python version
2.7 or later. There should be no other dependencies or
requirements to run scons.</p>

<p style="margin-top: 1em">By default, scons knows how to
search for available programming tools on various systems.
On Windows systems, scons searches in order for the
Microsoft Visual C++ tools, the <br>
MinGW tool chain, the Intel compiler tools, and the PharLap
ETS compiler. On OS/2 systems, scons searches in order for
the OS/2 compiler, the GCC tool chain, and the Microsoft
<br>
Visual C++ tools, On SGI IRIX, IBM AIX, Hewlett Packard
HP-UX, and Sun Solaris systems, scons searches for the
native compiler tools (MIPSpro, Visual Age, aCC, and Forte
tools <br>
respectively) and the GCC tool chain. On all other
platforms, including POSIX (Linux and UNIX) platforms, scons
searches in order for the GCC tool chain, the Microsoft
Visual C++ <br>
tools, and the Intel compiler tools. You may, of course,
override these default values by appropriate configuration
of Environment construction variables.</p>

<p style="margin-top: 1em">OPTIONS <br>
In general, scons supports the same command-line options as
GNU make, and many of those supported by cons.</p>

<p style="margin-top: 1em">-b <br>
Ignored for compatibility with non-GNU versions of make.</p>

<p style="margin-top: 1em">-c, --clean, --remove <br>
Clean up by removing all target files for which a
construction command is specified. Also remove any files or
directories associated to the construction command using the
<br>
Clean() function. Will not remove any targets specified by
the NoClean() function.</p>

<p style="margin-top: 1em">--cache-debug=file <br>
Print debug information about the CacheDir() derived-file
caching to the specified file. If file is - (a hyphen), the
debug information are printed to the standard output. <br>
The printed messages describe what signature file names are
being looked for in, retrieved from, or written to the
CacheDir() directory tree.</p>

<p style="margin-top: 1em">--cache-disable, --no-cache <br>
Disable the derived-file caching specified by CacheDir().
scons will neither retrieve files from the cache nor copy
files to the cache.</p>

<p style="margin-top: 1em">--cache-force, --cache-populate
<br>
When using CacheDir(), populate a cache by copying any
already-existing, up-to-date derived files to the cache, in
addition to files built by this invocation. This is useful
<br>
to populate a new cache with all the current derived files,
or to add to the cache any derived files recently built with
caching disabled via the --cache-disable option.</p>

<p style="margin-top: 1em">--cache-readonly <br>
Use the cache (if enabled) for reading, but do not not
update the cache with changed files.</p>

<p style="margin-top: 1em">--cache-show <br>
When using CacheDir() and retrieving a derived file from the
cache, show the command that would have been executed to
build the file, instead of the usual report, &quot;Retrieved
<br>
&lsquo;file&rsquo; from cache.&quot; This will produce
consistent output for build logs, regardless of whether a
target file was rebuilt or retrieved from the cache.</p>

<p style="margin-top: 1em">--config=mode <br>
This specifies how the Configure call should use or generate
the results of configuration tests. The option should be
specified from among the following choices:</p>

<p style="margin-top: 1em">--config=auto <br>
scons will use its normal dependency mechanisms to decide if
a test must be rebuilt or not. This saves time by not
running the same configuration tests every time you invoke
<br>
scons, but will overlook changes in system header files or
external commands (such as compilers) if you don&rsquo;t
specify those dependecies explicitly. This is the default
<br>
behavior.</p>

<p style="margin-top: 1em">--config=force <br>
If this option is specified, all configuration tests will be
re-run regardless of whether the cached results are out of
date. This can be used to explicitly force the <br>
configuration tests to be updated in response to an
otherwise unconfigured change in a system header file or
compiler.</p>

<p style="margin-top: 1em">--config=cache <br>
If this option is specified, no configuration tests will be
rerun and all results will be taken from cache. Note that
scons will still consider it an error if --config=cache <br>
is specified and a necessary test does not yet have any
results in the cache.</p>

<p style="margin-top: 1em">-C directory,
--directory=directory <br>
Change to the specified directory before searching for the
SConstruct, Sconstruct, or sconstruct file, or doing
anything else. Multiple -C options are interpreted relative
to <br>
the previous one, and the right-most -C option wins. (This
option is nearly equivalent to -f directory/SConstruct,
except that it will search for SConstruct, Sconstruct, or
<br>
sconstruct in the specified directory.)</p>

<p style="margin-top: 1em">-D <br>
Works exactly the same way as the -u option except for the
way default targets are handled. When this option is used
and no targets are specified on the command line, all <br>
default targets are built, whether or not they are below the
current directory.</p>

<p style="margin-top: 1em">--debug=type <br>
Debug the build process. type[,type...] specifies what type
of debugging. Multiple types may be specified, separated by
commas. The following types are valid:</p>

<p style="margin-top: 1em">--debug=count <br>
Print how many objects are created of the various classes
used internally by SCons before and after reading the
SConscript files and before and after building targets. This
<br>
is not supported when SCons is executed with the Python -O
(optimized) option or when the SCons modules have been
compiled with optimization (that is, when executing from
<br>
*.pyo files).</p>

<p style="margin-top: 1em">--debug=duplicate <br>
Print a line for each unlink/relink (or copy) of a variant
file from its source file. Includes debugging info for
unlinking stale variant files, as well as unlinking old <br>
targets before building them.</p>

<p style="margin-top: 1em">--debug=dtree <br>
A synonym for the newer --tree=derived option. This will be
deprecated in some future release and ultimately
removed.</p>

<p style="margin-top: 1em">--debug=explain <br>
Print an explanation of precisely why scons is deciding to
(re-)build any targets. (Note: this does not print anything
for targets that are not rebuilt.)</p>

<p style="margin-top: 1em">--debug=findlibs <br>
Instruct the scanner that searches for libraries to print a
message about each potential library name it is searching
for, and about the actual libraries it finds.</p>

<p style="margin-top: 1em">--debug=includes <br>
Print the include tree after each top-level target is built.
This is generally used to find out what files are included
by the sources of a given derived file:</p>

<p style="margin-top: 1em">$ scons --debug=includes
foo.o</p>

<p style="margin-top: 1em">--debug=memoizer <br>
Prints a summary of hits and misses using the Memoizer, an
internal subsystem that counts how often SCons uses cached
values in memory instead of recomputing them each time <br>
they&rsquo;re needed.</p>

<p style="margin-top: 1em">--debug=memory <br>
Prints how much memory SCons uses before and after reading
the SConscript files and before and after building
targets.</p>

<p style="margin-top: 1em">--debug=nomemoizer <br>
A deprecated option preserved for backwards
compatibility.</p>

<p style="margin-top: 1em">--debug=objects <br>
Prints a list of the various objects of the various classes
used internally by SCons.</p>

<p style="margin-top: 1em">--debug=pdb <br>
Re-run SCons under the control of the pdb Python
debugger.</p>

<p style="margin-top: 1em">--debug=prepare <br>
Print a line each time any target (internal or external) is
prepared for building. scons prints this for each target it
considers, even if that target is up to date (see <br>
also --debug=explain). This can help debug problems with
targets that aren&rsquo;t being built; it shows whether
scons is at least considering them or not.</p>

<p style="margin-top: 1em">--debug=presub <br>
Print the raw command line used to build each target before
the construction environment variables are substituted. Also
shows which targets are being built by this command. <br>
Output looks something like this:</p>

<p style="margin-top: 1em">$ scons --debug=presub <br>
Building myprog.o with action(s): <br>
$SHCC $SHCFLAGS $SHCCFLAGS $CPPFLAGS $_CPPINCFLAGS -c -o
$TARGET $SOURCES <br>
...</p>

<p style="margin-top: 1em">--debug=stacktrace <br>
Prints an internal Python stack trace when encountering an
otherwise unexplained error.</p>

<p style="margin-top: 1em">--debug=stree <br>
A synonym for the newer --tree=all,status option. This will
be deprecated in some future release and ultimately
removed.</p>

<p style="margin-top: 1em">--debug=time <br>
Prints various time profiling information: the time spent
executing each individual build command; the total build
time (time SCons ran from beginning to end); the total time
<br>
spent reading and executing SConscript files; the total time
spent SCons itself spend running (that is, not counting
reading and executing SConscript files); and both the <br>
total time spent executing all build commands and the
elapsed wall-clock time spent executing those build
commands. (When scons is executed without the -j option, the
elapsed <br>
wall-clock time will typically be slightly longer than the
total time spent executing all the build commands, due to
the SCons processing that takes place in between <br>
executing each command. When scons is executed with the -j
option, and your build configuration allows good
parallelization, the elapsed wall-clock time should be <br>
significantly smaller than the total time spent executing
all the build commands, since multiple build commands and
intervening SCons processing should take place in <br>
parallel.)</p>

<p style="margin-top: 1em">--debug=tree <br>
A synonym for the newer --tree=all option. This will be
deprecated in some future release and ultimately
removed.</p>

<p style="margin-top: 1em">--diskcheck=types <br>
Enable specific checks for whether or not there is a file on
disk where the SCons configuration expects a directory (or
vice versa), and whether or not RCS or SCCS sources <br>
exist when searching for source and include files. The types
argument can be set to: all, to enable all checks explicitly
(the default behavior); none, to disable all such <br>
checks; match, to check that files and directories on disk
match SCons&rsquo; expected configuration; rcs, to check for
the existence of an RCS source for any missing source or
<br>
include files; sccs, to check for the existence of an SCCS
source for any missing source or include files. Multiple
checks can be specified separated by commas; for example,
<br>
--diskcheck=sccs,rcs would still check for SCCS and RCS
sources, but disable the check for on-disk matches of files
and directories. Disabling some or all of these checks can
<br>
provide a performance boost for large configurations, or
when the configuration will check for files and/or
directories across networked or shared file systems, at the
slight <br>
increased risk of an incorrect build or of not handling
errors gracefully (if include files really should be found
in SCCS or RCS, for example, or if a file really does exist
<br>
where the SCons configuration expects a directory).</p>

<p style="margin-top: 1em">--duplicate=ORDER <br>
There are three ways to duplicate files in a build tree:
hard links, soft (symbolic) links and copies. The default
behaviour of SCons is to prefer hard links to soft links to
<br>
copies. You can specify different behaviours with this
option. ORDER must be one of hard-soft-copy (the default),
soft-hard-copy, hard-copy, soft-copy or copy. SCons will
<br>
attempt to duplicate files using the mechanisms in the
specified order.</p>

<p style="margin-top: 1em">-f file, --file=file,
--makefile=file, --sconstruct=file <br>
Use file as the initial SConscript file. Multiple -f options
may be specified, in which case scons will read all of the
specified files.</p>

<p style="margin-top: 1em">-h, --help <br>
Print a local help message for this build, if one is defined
in the SConscript file(s), plus a line that describes the -H
option for command-line option help. If no local <br>
help message is defined, prints the standard help message
about command-line options. Exits after displaying the
appropriate message.</p>

<p style="margin-top: 1em">-H, --help-options <br>
Print the standard help message about command-line options
and exit.</p>

<p style="margin-top: 1em">-i, --ignore-errors <br>
Ignore all errors from commands executed to rebuild
files.</p>

<p style="margin-top: 1em">-I directory,
--include-dir=directory <br>
Specifies a directory to search for imported Python modules.
If several -I options are used, the directories are searched
in the order specified.</p>

<p style="margin-top: 1em">--implicit-cache <br>
Cache implicit dependencies. This causes scons to use the
implicit (scanned) dependencies from the last time it was
run instead of scanning the files for implicit <br>
dependencies. This can significantly speed up SCons, but
with the following limitations:</p>

<p style="margin-top: 1em">scons will not detect changes to
implicit dependency search paths (e.g. CPPPATH, LIBPATH)
that would ordinarily cause different versions of same-named
files to be used.</p>

<p style="margin-top: 1em">scons will miss changes in the
implicit dependencies in cases where a new implicit
dependency is added earlier in the implicit dependency
search path (e.g. CPPPATH, LIBPATH) <br>
than a current implicit dependency with the same name.</p>

<p style="margin-top: 1em">--implicit-deps-changed <br>
Forces SCons to ignore the cached implicit dependencies.
This causes the implicit dependencies to be rescanned and
recached. This implies --implicit-cache.</p>

<p style="margin-top: 1em">--implicit-deps-unchanged <br>
Force SCons to ignore changes in the implicit dependencies.
This causes cached implicit dependencies to always be used.
This implies --implicit-cache.</p>

<p style="margin-top: 1em">--interactive <br>
Starts SCons in interactive mode. The SConscript files are
read once and a scons&gt;&gt;&gt; prompt is printed. Targets
may now be rebuilt by typing commands at interactive prompt
<br>
without having to re-read the SConscript files and
re-initialize the dependency graph from scratch.</p>

<p style="margin-top: 1em">SCons interactive mode supports
the following commands:</p>

<p style="margin-top: 1em">build[OPTIONS] [TARGETS] ...
<br>
Builds the specified TARGETS (and their dependencies) with
the specified SCons command-line OPTIONS. b and scons are
synonyms.</p>

<p style="margin-top: 1em">The following SCons command-line
options affect the build command:</p>

<p style="margin-top: 1em">--cache-debug=FILE <br>
--cache-disable, --no-cache <br>
--cache-force, --cache-populate <br>
--cache-readonly <br>
--cache-show <br>
--debug=TYPE <br>
-i, --ignore-errors <br>
-j N, --jobs=N <br>
-k, --keep-going <br>
-n, --no-exec, --just-print, --dry-run, --recon <br>
-Q <br>
-s, --silent, --quiet <br>
--taskmastertrace=FILE <br>
--tree=OPTIONS</p>

<p style="margin-top: 1em">Any other SCons command-line
options that are specified do not cause errors but have no
effect on the build command (mainly because they affect how
the SConscript files are <br>
read, which only happens once at the beginning of
interactive mode).</p>

<p style="margin-top: 1em">clean[OPTIONS] [TARGETS] ...
<br>
Cleans the specified TARGETS (and their dependencies) with
the specified options. c is a synonym. This command is
itself a synonym for build --clean</p>

<p style="margin-top: 1em">exit <br>
Exits SCons interactive mode. You can also exit by
terminating input (CTRL+D on UNIX or Linux systems, CTRL+Z
on Windows systems).</p>

<p style="margin-top: 1em">help[COMMAND] <br>
Provides a help message about the commands available in
SCons interactive mode. If COMMAND is specified, h and ? are
synonyms.</p>

<p style="margin-top: 1em">shell[COMMANDLINE] <br>
Executes the specified COMMANDLINE in a subshell. If no
COMMANDLINE is specified, executes the interactive command
interpreter specified in the SHELL environment variable <br>
(on UNIX and Linux systems) or the COMSPEC environment
variable (on Windows systems). sh and ! are synonyms.</p>

<p style="margin-top: 1em">version <br>
Prints SCons version information.</p>

<p style="margin-top: 1em">An empty line repeats the last
typed command. Command-line editing can be used if the
readline module is available.</p>

<p style="margin-top: 1em">$ scons --interactive <br>
scons: Reading SConscript files ... <br>
scons: done reading SConscript files. <br>
scons&gt;&gt;&gt; build -n prog <br>
scons&gt;&gt;&gt; exit</p>

<p style="margin-top: 1em">-j N, --jobs=N <br>
Specifies the number of jobs (commands) to run
simultaneously. If there is more than one -j option, the
last one is effective.</p>

<p style="margin-top: 1em">-k, --keep-going <br>
Continue as much as possible after an error. The target that
failed and those that depend on it will not be remade, but
other targets specified on the command line will still <br>
be processed.</p>

<p style="margin-top: 1em">-m <br>
Ignored for compatibility with non-GNU versions of make.</p>

<p style="margin-top: 1em">--max-drift=SECONDS <br>
Set the maximum expected drift in the modification time of
files to SECONDS. This value determines how long a file must
be unmodified before its cached content signature will <br>
be used instead of calculating a new content signature (MD5
checksum) of the file&rsquo;s contents. The default value is
2 days, which means a file must have a modification time of
<br>
at least two days ago in order to have its cached content
signature used. A negative value means to never cache the
content signature and to ignore the cached value if there
<br>
already is one. A value of 0 means to always use the cached
signature, no matter how old the file is.</p>

<p style="margin-top: 1em">--md5-chunksize=KILOBYTES <br>
Set the block size used to compute MD5 signatures to
KILOBYTES. This value determines the size of the chunks
which are read in at once when computing MD5 signatures.
Files <br>
below that size are fully stored in memory before performing
the signature computation while bigger files are read in
block-by-block. A huge block-size leads to high memory <br>
consumption while a very small block-size slows down the
build considerably.</p>

<p style="margin-top: 1em">The default value is to use a
chunk size of 64 kilobytes, which should be appropriate for
most uses.</p>

<p style="margin-top: 1em">-n, --just-print, --dry-run,
--recon <br>
No execute. Print the commands that would be executed to
build any out-of-date target files, but do not execute the
commands.</p>

<p style="margin-top: 1em">--no-site-dir <br>
Prevents the automatic addition of the standard site_scons
dirs to sys.path. Also prevents loading the
site_scons/site_init.py modules if they exist, and prevents
adding <br>
their site_scons/site_tools dirs to the toolpath.</p>

<p style="margin-top: 1em">--profile=file <br>
Run SCons under the Python profiler and save the results in
the specified file. The results may be analyzed using the
Python pstats module.</p>

<p style="margin-top: 1em">-q, --question <br>
Do not run any commands, or print anything. Just return an
exit status that is zero if the specified targets are
already up to date, non-zero otherwise.</p>

<p style="margin-top: 1em">-Q <br>
Quiets SCons status messages about reading SConscript files,
building targets and entering directories. Commands that are
executed to rebuild target files are still printed.</p>

<p style="margin-top: 1em">--random <br>
Build dependencies in a random order. This is useful when
building multiple trees simultaneously with caching enabled,
to prevent multiple builds from simultaneously trying <br>
to build or retrieve the same target files.</p>

<p style="margin-top: 1em">-s, --silent, --quiet <br>
Silent. Do not print commands that are executed to rebuild
target files. Also suppresses SCons status messages.</p>

<p style="margin-top: 1em">-S, --no-keep-going, --stop <br>
Ignored for compatibility with GNU make.</p>

<p style="margin-top: 1em">--site-dir=dir <br>
Uses the named dir as the site dir rather than the default
site_scons dirs. This dir will get prepended to sys.path,
the module dir/site_init.py will get loaded if it exists,
<br>
and dir/site_tools will get added to the default
toolpath.</p>

<p style="margin-top: 1em">The default set of site_scons
dirs used when --site-dir is not specified depends on the
system platform, as follows. Note that the directories are
examined in the order <br>
given, from most generic to most specific, so the
last-executed site_init.py file is the most specific one
(which gives it the chance to override everything else), and
the <br>
dirs are prepended to the paths, again so the last dir
examined comes first in the resulting path.</p>

<p style="margin-top: 1em">Windows:</p>

<p style="margin-top: 1em">%ALLUSERSPROFILE/Application
Data/scons/site_scons <br>
%USERPROFILE%/Local Settings/Application
Data/scons/site_scons <br>
%APPDATA%/scons/site_scons <br>
%HOME%/.scons/site_scons <br>
./site_scons</p>

<p style="margin-top: 1em">Mac OS X:</p>

<p style="margin-top: 1em">/Library/Application
Support/SCons/site_scons <br>
/opt/local/share/scons/site_scons (for MacPorts) <br>
/sw/share/scons/site_scons (for Fink) <br>
$HOME/Library/Application Support/SCons/site_scons <br>
$HOME/.scons/site_scons <br>
./site_scons</p>

<p style="margin-top: 1em">Solaris:</p>

<p style="margin-top: 1em">/opt/sfw/scons/site_scons <br>
/usr/share/scons/site_scons <br>
$HOME/.scons/site_scons <br>
./site_scons</p>

<p style="margin-top: 1em">Linux, HPUX, and other
Posix-like systems:</p>

<p style="margin-top: 1em">/usr/share/scons/site_scons <br>
$HOME/.scons/site_scons <br>
./site_scons</p>

<p style="margin-top: 1em">--stack-size=KILOBYTES <br>
Set the size stack used to run threads to KILOBYTES. This
value determines the stack size of the threads used to run
jobs. These are the threads that execute the actions of <br>
the builders for the nodes that are out-of-date. Note that
this option has no effect unless the num_jobs option, which
corresponds to -j and --jobs, is larger than one. Using <br>
a stack size that is too small may cause stack overflow
errors. This usually shows up as segmentation faults that
cause scons to abort before building anything. Using a stack
<br>
size that is too large will cause scons to use more memory
than required and may slow down the entire build
process.</p>

<p style="margin-top: 1em">The default value is to use a
stack size of 256 kilobytes, which should be appropriate for
most uses. You should not need to increase this value unless
you encounter stack <br>
overflow errors.</p>

<p style="margin-top: 1em">-t, --touch <br>
Ignored for compatibility with GNU make. (Touching a file to
make it appear up-to-date is unnecessary when using
scons.)</p>

<p style="margin-top: 1em">--taskmastertrace=file <br>
Prints trace information to the specified file about how the
internal Taskmaster object evaluates and controls the order
in which Nodes are built. A file name of - may be <br>
used to specify the standard output.</p>

<p style="margin-top: 1em">-tree=options <br>
Prints a tree of the dependencies after each top-level
target is built. This prints out some or all of the tree, in
various formats, depending on the options specified:</p>

<p style="margin-top: 1em">--tree=all <br>
Print the entire dependency tree after each top-level target
is built. This prints out the complete dependency tree,
including implicit dependencies and ignored
dependencies.</p>

<p style="margin-top: 1em">--tree=derived <br>
Restricts the tree output to only derived (target) files,
not source files.</p>

<p style="margin-top: 1em">--tree=status <br>
Prints status information for each displayed node.</p>

<p style="margin-top: 1em">--tree=prune <br>
Prunes the tree to avoid repeating dependency information
for nodes that have already been displayed. Any node that
has already been displayed will have its name printed in
<br>
[square brackets], as an indication that the dependencies
for that node can be found by searching for the relevant
output higher up in the tree.</p>

<p style="margin-top: 1em">Multiple options may be
specified, separated by commas:</p>

<p style="margin-top: 1em"># Prints only derived files,
with status information: <br>
scons --tree=derived,status</p>

<p style="margin-top: 1em"># Prints all dependencies of
target, with status information <br>
# and pruning dependencies of already-visited Nodes: <br>
scons --tree=all,prune,status target</p>

<p style="margin-top: 1em">-u, --up, --search-up <br>
Walks up the directory structure until an SConstruct ,
Sconstruct or sconstruct file is found, and uses that as the
top of the directory tree. If no targets are specified on
<br>
the command line, only targets at or below the current
directory will be built.</p>

<p style="margin-top: 1em">-U <br>
Works exactly the same way as the -u option except for the
way default targets are handled. When this option is used
and no targets are specified on the command line, all <br>
default targets that are defined in the SConscript(s) in the
current directory are built, regardless of what directory
the resultant targets end up in.</p>

<p style="margin-top: 1em">-v, --version <br>
Print the scons version, copyright information, list of
authors, and any other relevant information. Then exit.</p>

<p style="margin-top: 1em">-w, --print-directory <br>
Print a message containing the working directory before and
after other processing.</p>

<p style="margin-top: 1em">--no-print-directory <br>
Turn off -w, even if it was turned on implicitly.</p>

<p style="margin-top: 1em">--warn=type, --warn=no-type <br>
Enable or disable warnings. type specifies the type of
warnings to be enabled or disabled:</p>

<p style="margin-top: 1em">--warn=all, --warn=no-all <br>
Enables or disables all warnings.</p>

<p style="margin-top: 1em">--warn=cache-version,
--warn=no-cache-version <br>
Enables or disables warnings about the cache directory not
using the latest configuration information CacheDir(). These
warnings are enabled by default.</p>

<p style="margin-top: 1em">--warn=cache-write-error,
--warn=no-cache-write-error <br>
Enables or disables warnings about errors trying to write a
copy of a built file to a specified CacheDir(). These
warnings are disabled by default.</p>

<p style="margin-top: 1em">--warn=corrupt-sconsign,
--warn=no-corrupt-sconsign <br>
Enables or disables warnings about unfamiliar signature data
in .sconsign files. These warnings are enabled by
default.</p>

<p style="margin-top: 1em">--warn=dependency,
--warn=no-dependency <br>
Enables or disables warnings about dependencies. These
warnings are disabled by default.</p>

<p style="margin-top: 1em">--warn=deprecated,
--warn=no-deprecated <br>
Enables or disables all warnings about use of currently
deprecated features. These warnings are enabled by default.
Note that the --warn=no-deprecated option does not disable
<br>
warnings about absolutely all deprecated features. Warnings
for some deprecated features that have already been through
several releases with deprecation warnings may be <br>
mandatory for a release or two before they are officially no
longer supported by SCons. Warnings for some specific
deprecated features may be enabled or disabled <br>
individually; see below.</p>

<p style="margin-top: 1em">--warn=deprecated-copy,
--warn=no-deprecated-copy <br>
Enables or disables warnings about use of the deprecated
env.Copy() method.</p>


<p style="margin-top: 1em">--warn=deprecated-source-signatures,
--warn=no-deprecated-source-signatures <br>
Enables or disables warnings about use of the deprecated
SourceSignatures() function or env.SourceSignatures()
method.</p>


<p style="margin-top: 1em">--warn=deprecated-target-signatures,
--warn=no-deprecated-target-signatures <br>
Enables or disables warnings about use of the deprecated
TargetSignatures() function or env.TargetSignatures()
method.</p>

<p style="margin-top: 1em">--warn=duplicate-environment,
--warn=no-duplicate-environment <br>
Enables or disables warnings about attempts to specify a
build of a target with two different construction
environments that use the same action. These warnings are
enabled <br>
by default.</p>

<p style="margin-top: 1em">--warn=fortran-cxx-mix,
--warn=no-fortran-cxx-mix <br>
Enables or disables the specific warning about linking
Fortran and C++ object files in a single executable, which
can yield unpredictable behavior with some compilers.</p>

<p style="margin-top: 1em">--warn=future-deprecated,
--warn=no-future-deprecated <br>
Enables or disables warnings about features that will be
deprecated in the future. These warnings are disabled by
default. Enabling this warning is especially recommended for
<br>
projects that redistribute SCons configurations for other
users to build, so that the project can be warned as soon as
possible about to-be-deprecated features that may <br>
require changes to the configuration.</p>

<p style="margin-top: 1em">--warn=link, --warn=no-link <br>
Enables or disables warnings about link steps.</p>

<p style="margin-top: 1em">--warn=misleading-keywords,
--warn=no-misleading-keywords <br>
Enables or disables warnings about use of the misspelled
keywords targets and sources when calling Builders. (Note
the last s characters, the correct spellings are target and
<br>
source.) These warnings are enabled by default.</p>

<p style="margin-top: 1em">--warn=missing-sconscript,
--warn=no-missing-sconscript <br>
Enables or disables warnings about missing SConscript files.
These warnings are enabled by default.</p>

<p style="margin-top: 1em">--warn=no-md5-module,
--warn=no-no-md5-module <br>
Enables or disables warnings about the version of Python not
having an MD5 checksum module available. These warnings are
enabled by default.</p>

<p style="margin-top: 1em">--warn=no-metaclass-support,
--warn=no-no-metaclass-support <br>
Enables or disables warnings about the version of Python not
supporting metaclasses when the --debug=memoizer option is
used. These warnings are enabled by default.</p>

<p style="margin-top: 1em">--warn=no-object-count,
--warn=no-no-object-count <br>
Enables or disables warnings about the --debug=object
feature not working when scons is run with the python -O
option or from optimized Python (.pyo) modules.</p>

<p style="margin-top: 1em">--warn=no-parallel-support,
--warn=no-no-parallel-support <br>
Enables or disables warnings about the version of Python not
being able to support parallel builds when the -j option is
used. These warnings are enabled by default.</p>

<p style="margin-top: 1em">--warn=python-version,
--warn=no-python-version <br>
Enables or disables the warning about running SCons with a
deprecated version of Python. These warnings are enabled by
default.</p>

<p style="margin-top: 1em">--warn=reserved-variable,
--warn=no-reserved-variable <br>
Enables or disables warnings about attempts to set the
reserved construction variable names CHANGED_SOURCES,
CHANGED_TARGETS, TARGET, TARGETS, SOURCE, SOURCES, <br>
UNCHANGED_SOURCES or UNCHANGED_TARGETS. These warnings are
disabled by default.</p>

<p style="margin-top: 1em">--warn=stack-size,
--warn=no-stack-size <br>
Enables or disables warnings about requests to set the stack
size that could not be honored. These warnings are enabled
by default.</p>

<p style="margin-top: 1em">--warn=target_not_build,
--warn=no-target_not_built <br>
Enables or disables warnings about a build rule not building
the expected targets. These warnings are not currently
enabled by default.</p>

<p style="margin-top: 1em">-Y repository,
--repository=repository, --srcdir=repository <br>
Search the specified repository for any input and target
files not found in the local directory hierarchy. Multiple
-Y options may be specified, in which case the <br>
repositories are searched in the order specified.</p>

<p style="margin-top: 1em">CONFIGURATION FILE REFERENCE
<br>
Construction Environments <br>
A construction environment is the basic means by which the
SConscript files communicate build information to scons. A
new construction environment is created using the <br>
Environment function:</p>

<p style="margin-top: 1em">env = Environment()</p>

<p style="margin-top: 1em">Variables, called construction
variables, may be set in a construction environment either
by specifying them as keywords when the object is created or
by assigning them a value <br>
after the object is created:</p>

<p style="margin-top: 1em">env = Environment(FOO =
&rsquo;foo&rsquo;) <br>
env[&rsquo;BAR&rsquo;] = &rsquo;bar&rsquo;</p>

<p style="margin-top: 1em">As a convenience, construction
variables may also be set or modified by the parse_flags
keyword argument, which applies the ParseFlags method
(described below) to the argument <br>
value after all other processing is completed. This is
useful either if the exact content of the flags is unknown
(for example, read from a control file) or if the flags are
<br>
distributed to a number of construction variables.</p>

<p style="margin-top: 1em">env = Environment(parse_flags =
&rsquo;-Iinclude -DEBUG -lm&rsquo;)</p>

<p style="margin-top: 1em">This example adds
&rsquo;include&rsquo; to CPPPATH, &rsquo;EBUG&rsquo; to
CPPDEFINES, and &rsquo;m&rsquo; to LIBS.</p>

<p style="margin-top: 1em">By default, a new construction
environment is initialized with a set of builder methods and
construction variables that are appropriate for the current
platform. An optional <br>
platform keyword argument may be used to specify that an
environment should be initialized for a different
platform:</p>

<p style="margin-top: 1em">env = Environment(platform =
&rsquo;cygwin&rsquo;) <br>
env = Environment(platform = &rsquo;os2&rsquo;) <br>
env = Environment(platform = &rsquo;posix&rsquo;) <br>
env = Environment(platform = &rsquo;win32&rsquo;)</p>

<p style="margin-top: 1em">Specifying a platform
initializes the appropriate construction variables in the
environment to use and generate file names with prefixes and
suffixes appropriate for the <br>
platform.</p>

<p style="margin-top: 1em">Note that the win32 platform
adds the SystemDrive and SystemRoot variables from the
user&rsquo;s external environment to the construction
environment&rsquo;s ENV dictionary. This is so that <br>
any executed commands that use sockets to connect with other
systems (such as fetching source files from external CVS
repository specifications like <br>
:pserver:anonymous@cvs.sourceforge.net:/cvsroot/scons) will
work on Windows systems.</p>

<p style="margin-top: 1em">The platform argument may be
function or callable object, in which case the Environment()
method will call the specified argument to update the new
construction environment:</p>

<p style="margin-top: 1em">def my_platform(env): <br>
env[&rsquo;VAR&rsquo;] = &rsquo;xyzzy&rsquo;</p>

<p style="margin-top: 1em">env = Environment(platform =
my_platform)</p>

<p style="margin-top: 1em">Additionally, a specific set of
tools with which to initialize the environment may be
specified as an optional keyword argument:</p>

<p style="margin-top: 1em">env = Environment(tools =
[&rsquo;msvc&rsquo;, &rsquo;lex&rsquo;])</p>

<p style="margin-top: 1em">Non-built-in tools may be
specified using the toolpath argument:</p>

<p style="margin-top: 1em">env = Environment(tools =
[&rsquo;default&rsquo;, &rsquo;foo&rsquo;], toolpath =
[&rsquo;tools&rsquo;])</p>

<p style="margin-top: 1em">This looks for a tool
specification in tools/foo.py (as well as using the ordinary
default tools for the platform). foo.py should have two
functions: generate(env, **kw) and <br>
exists(env). The generate() function modifies the passed-in
environment to set up variables so that the tool can be
executed; it may use any keyword arguments that the user
<br>
supplies (see below) to vary its initialization. The
exists() function should return a true value if the tool is
available. Tools in the toolpath are used before any of the
<br>
built-in ones. For example, adding gcc.py to the toolpath
would override the built-in gcc tool. Also note that the
toolpath is stored in the environment for use by later calls
to <br>
Clone() and Tool() methods:</p>

<p style="margin-top: 1em">base =
Environment(toolpath=[&rsquo;custom_path&rsquo;]) <br>
derived = base.Clone(tools=[&rsquo;custom_tool&rsquo;]) <br>
derived.CustomBuilder()</p>

<p style="margin-top: 1em">The elements of the tools list
may also be functions or callable objects, in which case the
Environment() method will call the specified elements to
update the new construction <br>
environment:</p>

<p style="margin-top: 1em">def my_tool(env): <br>
env[&rsquo;XYZZY&rsquo;] = &rsquo;xyzzy&rsquo;</p>

<p style="margin-top: 1em">env = Environment(tools =
[my_tool])</p>

<p style="margin-top: 1em">The individual elements of the
tools list may also themselves be two-element lists of the
form (toolname, kw_dict). SCons searches for the toolname
specification file as <br>
described above, and passes kw_dict, which must be a
dictionary, as keyword arguments to the tool&rsquo;s
generate function. The generate function can use the
arguments to modify the <br>
tool&rsquo;s behavior by setting up the environment in
different ways or otherwise changing its initialization.</p>

<p style="margin-top: 1em"># in tools/my_tool.py: <br>
def generate(env, **kw): <br>
# Sets MY_TOOL to the value of keyword argument
&rsquo;arg1&rsquo; or 1. <br>
env[&rsquo;MY_TOOL&rsquo;] = kw.get(&rsquo;arg1&rsquo;,
&rsquo;1&rsquo;) <br>
def exists(env): <br>
return 1</p>

<p style="margin-top: 1em"># in SConstruct: <br>
env = Environment(tools = [&rsquo;default&rsquo;,
(&rsquo;my_tool&rsquo;, {&rsquo;arg1&rsquo;:
&rsquo;abc&rsquo;})], <br>
toolpath=[&rsquo;tools&rsquo;])</p>

<p style="margin-top: 1em">The tool definition (i.e.
my_tool()) can use the PLATFORM variable from the
environment it receives to customize the tool for different
platforms.</p>

<p style="margin-top: 1em">If no tool list is specified,
then SCons will auto-detect the installed tools using the
PATH variable in the ENV construction variable and the
platform name when the Environment <br>
is constructed. Changing the PATH variable after the
Environment is constructed will not cause the tools to be
redetected.</p>

<p style="margin-top: 1em">SCons supports the following
tool specifications out of the box:</p>

<p style="margin-top: 1em">386asm <br>
Sets construction variables for the 386ASM assembler for the
Phar Lap ETS embedded operating system.</p>

<p style="margin-top: 1em">Sets: $AS, $ASCOM, $ASFLAGS,
$ASPPCOM, $ASPPFLAGS.</p>

<p style="margin-top: 1em">Uses: $CC, $CPPFLAGS,
$_CPPDEFFLAGS, $_CPPINCFLAGS.</p>

<p style="margin-top: 1em">aixc++ <br>
Sets construction variables for the IMB xlc / Visual Age C++
compiler.</p>

<p style="margin-top: 1em">Sets: $CXX, $CXXVERSION, $SHCXX,
$SHOBJSUFFIX.</p>

<p style="margin-top: 1em">aixcc <br>
Sets construction variables for the IBM xlc / Visual Age C
compiler.</p>

<p style="margin-top: 1em">Sets: $CC, $CCVERSION,
$SHCC.</p>

<p style="margin-top: 1em">aixf77 <br>
Sets construction variables for the IBM Visual Age f77
Fortran compiler.</p>

<p style="margin-top: 1em">Sets: $F77, $SHF77.</p>

<p style="margin-top: 1em">aixlink <br>
Sets construction variables for the IBM Visual Age
linker.</p>

<p style="margin-top: 1em">Sets: $LINKFLAGS, $SHLIBSUFFIX,
$SHLINKFLAGS.</p>

<p style="margin-top: 1em">applelink <br>
Sets construction variables for the Apple linker (similar to
the GNU linker).</p>

<p style="margin-top: 1em">Sets: $FRAMEWORKPATHPREFIX,
$LDMODULECOM, $LDMODULEFLAGS, $LDMODULEPREFIX,
$LDMODULESUFFIX, $LINKCOM, $SHLINKCOM, $SHLINKFLAGS,
$_FRAMEWORKPATH, $_FRAMEWORKS.</p>

<p style="margin-top: 1em">Uses: $FRAMEWORKSFLAGS.</p>

<p style="margin-top: 1em">ar <br>
Sets construction variables for the ar library archiver.</p>

<p style="margin-top: 1em">Sets: $AR, $ARCOM, $ARFLAGS,
$LIBPREFIX, $LIBSUFFIX, $RANLIB, $RANLIBCOM,
$RANLIBFLAGS.</p>

<p style="margin-top: 1em">as <br>
Sets construction variables for the as assembler.</p>

<p style="margin-top: 1em">Sets: $AS, $ASCOM, $ASFLAGS,
$ASPPCOM, $ASPPFLAGS.</p>

<p style="margin-top: 1em">Uses: $CC, $CPPFLAGS,
$_CPPDEFFLAGS, $_CPPINCFLAGS.</p>

<p style="margin-top: 1em">bcc32 <br>
Sets construction variables for the bcc32 compiler.</p>

<p style="margin-top: 1em">Sets: $CC, $CCCOM, $CCFLAGS,
$CFILESUFFIX, $CFLAGS, $CPPDEFPREFIX, $CPPDEFSUFFIX,
$INCPREFIX, $INCSUFFIX, $SHCC, $SHCCCOM, $SHCCFLAGS,
$SHCFLAGS, $SHOBJSUFFIX.</p>

<p style="margin-top: 1em">Uses: $_CPPDEFFLAGS,
$_CPPINCFLAGS.</p>

<p style="margin-top: 1em">BitKeeper <br>
Sets construction variables for the BitKeeper source code
control system.</p>

<p style="margin-top: 1em">Sets: $BITKEEPER, $BITKEEPERCOM,
$BITKEEPERGET, $BITKEEPERGETFLAGS.</p>

<p style="margin-top: 1em">Uses: $BITKEEPERCOMSTR.</p>

<p style="margin-top: 1em">cc <br>
Sets construction variables for generic POSIX C
copmilers.</p>

<p style="margin-top: 1em">Sets: $CC, $CCCOM, $CCFLAGS,
$CFILESUFFIX, $CFLAGS, $CPPDEFPREFIX, $CPPDEFSUFFIX,
$FRAMEWORKPATH, $FRAMEWORKS, $INCPREFIX, $INCSUFFIX, $SHCC,
$SHCCCOM, $SHCCFLAGS, $SHCFLAGS, <br>
$SHOBJSUFFIX.</p>

<p style="margin-top: 1em">Uses: $PLATFORM.</p>

<p style="margin-top: 1em">cvf <br>
Sets construction variables for the Compaq Visual Fortran
compiler.</p>

<p style="margin-top: 1em">Sets: $FORTRAN, $FORTRANCOM,
$FORTRANMODDIR, $FORTRANMODDIRPREFIX, $FORTRANMODDIRSUFFIX,
$FORTRANPPCOM, $OBJSUFFIX, $SHFORTRANCOM,
$SHFORTRANPPCOM.</p>

<p style="margin-top: 1em">Uses: $CPPFLAGS, $FORTRANFLAGS,
$SHFORTRANFLAGS, $_CPPDEFFLAGS, $_FORTRANINCFLAGS,
$_FORTRANMODFLAG.</p>

<p style="margin-top: 1em">CVS <br>
Sets construction variables for the CVS source code
management system.</p>

<p style="margin-top: 1em">Sets: $CVS, $CVSCOFLAGS,
$CVSCOM, $CVSFLAGS.</p>

<p style="margin-top: 1em">Uses: $CVSCOMSTR.</p>

<p style="margin-top: 1em">cXX <br>
Sets construction variables for generic POSIX C++
compilers.</p>

<p style="margin-top: 1em">Sets: $CPPDEFPREFIX,
$CPPDEFSUFFIX, $CXX, $CXXCOM, $CXXFILESUFFIX, $CXXFLAGS,
$INCPREFIX, $INCSUFFIX, $OBJSUFFIX, $SHCXX, $SHCXXCOM,
$SHCXXFLAGS, $SHOBJSUFFIX.</p>

<p style="margin-top: 1em">Uses: $CXXCOMSTR.</p>

<p style="margin-top: 1em">cyglink <br>
Set construction variables for cygwin linker/loader.</p>

<p style="margin-top: 1em">Sets: $IMPLIBPREFIX,
$IMPLIBSUFFIX, $LDMODULEVERSIONFLAGS, $LINKFLAGS,
$RPATHPREFIX, $RPATHSUFFIX, $SHLIBPREFIX, $SHLIBSUFFIX,
$SHLIBVERSIONFLAGS, $SHLINKCOM, $SHLINKFLAGS, <br>
$_LDMODULEVERSIONFLAGS, $_SHLIBVERSIONFLAGS.</p>

<p style="margin-top: 1em">default <br>
Sets variables by calling a default list of Tool modules for
the platform on which SCons is running.</p>

<p style="margin-top: 1em">dmd <br>
Sets construction variables for D language compiler DMD.</p>

<p style="margin-top: 1em">Sets: $DC, $DCOM, $DDEBUG,
$DDEBUGPREFIX, $DDEBUGSUFFIX, $DFILESUFFIX, $DFLAGPREFIX,
$DFLAGS, $DFLAGSUFFIX, $DINCPREFIX, $DINCSUFFIX, $DLIB,
$DLIBCOM, $DLIBDIRPREFIX, <br>
$DLIBDIRSUFFIX, $DLIBFLAGPREFIX, $DLIBFLAGSUFFIX,
$DLIBLINKPREFIX, $DLIBLINKSUFFIX, $DLINK, $DLINKCOM,
$DLINKFLAGS, $DPATH, $DVERPREFIX, $DVERSIONS, $DVERSUFFIX,
<br>
$RPATHPREFIX, $RPATHSUFFIX, $SHDC, $SHDCOM, $SHDLINK,
$SHDLINKCOM, $SHDLINKFLAGS, $_DDEBUGFLAGS, $_DFLAGS,
$_DINCFLAGS, $_DLIBDIRFLAGS, $_DLIBFLAGS, $_DLIBFLAGS,
$_DVERFLAGS, <br>
$_RPATH.</p>

<p style="margin-top: 1em">docbook <br>
This tool tries to make working with Docbook in SCons a
little easier. It provides several toolchains for creating
different output formats, like HTML or PDF. Contained in
<br>
the package is a distribution of the Docbook XSL stylesheets
as of version 1.76.1. As long as you don&rsquo;t specify
your own stylesheets for customization, these official <br>
versions are picked as default...which should reduce the
inevitable setup hassles for you.</p>

<p style="margin-top: 1em">Implicit dependencies to images
and XIncludes are detected automatically if you meet the
HTML requirements. The additional stylesheet
utils/xmldepend.xsl by Paul DuBois is <br>
used for this purpose.</p>

<p style="margin-top: 1em">Note, that there is no support
for XML catalog resolving offered! This tool calls the XSLT
processors and PDF renderers with the stylesheets you
specified, that&rsquo;s it. The <br>
rest lies in your hands and you still have to know what
you&rsquo;re doing when resolving names via a catalog.</p>

<p style="margin-top: 1em">For activating the tool
&quot;docbook&quot;, you have to add its name to the
Environment constructor, like this</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;])</p>

<p style="margin-top: 1em">On its startup, the Docbook tool
tries to find a required xsltproc processor, and a PDF
renderer, e.g. fop. So make sure that these are added to
your system&rsquo;s environment <br>
PATH and can be called directly, without specifying their
full path.</p>

<p style="margin-top: 1em">For the most basic processing of
Docbook to HTML, you need to have installed</p>

<p style="margin-top: 1em">&Acirc;&middot; the Python lxml
binding to libxml2, or</p>

<p style="margin-top: 1em">&Acirc;&middot; the direct
Python bindings for libxml2/libxslt, or</p>

<p style="margin-top: 1em">&Acirc;&middot; a standalone
XSLT processor, currently detected are xsltproc, saxon,
saxon-xslt and xalan.</p>

<p style="margin-top: 1em">Rendering to PDF requires you to
have one of the applications fop or xep installed.</p>

<p style="margin-top: 1em">Creating a HTML or PDF document
is very simple and straightforward. Say</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtml(&rsquo;manual.html&rsquo;,
&rsquo;manual.xml&rsquo;) <br>
env.DocbookPdf(&rsquo;manual.pdf&rsquo;,
&rsquo;manual.xml&rsquo;)</p>

<p style="margin-top: 1em">to get both outputs from your
XML source manual.xml. As a shortcut, you can give the stem
of the filenames alone, like this:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtml(&rsquo;manual&rsquo;) <br>
env.DocbookPdf(&rsquo;manual&rsquo;)</p>

<p style="margin-top: 1em">and get the same result. Target
and source lists are also supported:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>

env.DocbookHtml([&rsquo;manual.html&rsquo;,&rsquo;reference.html&rsquo;],
[&rsquo;manual.xml&rsquo;,&rsquo;reference.xml&rsquo;])</p>

<p style="margin-top: 1em">or even</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>

env.DocbookHtml([&rsquo;manual&rsquo;,&rsquo;reference&rsquo;])</p>

<p style="margin-top: 1em">Important <br>
Whenever you leave out the list of sources, you may not
specify a file extension! The Tool uses the given names as
file stems, and adds the suffixes for target and source <br>
files accordingly. <br>
The rules given above are valid for the Builders
DocbookHtml, DocbookPdf, DocbookEpub, DocbookSlidesPdf and
DocbookXInclude. For the DocbookMan transformation you can
specify <br>
a target name, but the actual output names are automatically
set from the refname entries in your XML source.</p>

<p style="margin-top: 1em">The Builders DocbookHtmlChunked,
DocbookHtmlhelp and DocbookSlidesHtml are special, in
that:</p>

<p style="margin-top: 1em">1. they create a large set of
files, where the exact names and their number depend on the
content of the source file, and</p>

<p style="margin-top: 1em">2. the main target is always
named index.html, i.e. the output name for the XSL
transformation is not picked up by the stylesheets.</p>

<p style="margin-top: 1em">As a result, there is simply no
use in specifying a target HTML name. So the basic syntax
for these builders is always:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtmlhelp(&rsquo;manual&rsquo;)</p>

<p style="margin-top: 1em">If you want to use a specific
XSL file, you can set the additional xsl parameter to your
Builder call as follows:</p>


<p style="margin-top: 1em">env.DocbookHtml(&rsquo;other.html&rsquo;,
&rsquo;manual.xml&rsquo;, xsl=&rsquo;html.xsl&rsquo;)</p>

<p style="margin-top: 1em">Since this may get tedious if
you always use the same local naming for your customized XSL
files, e.g. html.xsl for HTML and pdf.xsl for PDF output, a
set of variables for <br>
setting the default XSL name is provided. These are:</p>

<p style="margin-top: 1em">DOCBOOK_DEFAULT_XSL_HTML <br>
DOCBOOK_DEFAULT_XSL_HTMLCHUNKED <br>
DOCBOOK_DEFAULT_XSL_HTMLHELP <br>
DOCBOOK_DEFAULT_XSL_PDF <br>
DOCBOOK_DEFAULT_XSL_EPUB <br>
DOCBOOK_DEFAULT_XSL_MAN <br>
DOCBOOK_DEFAULT_XSL_SLIDESPDF <br>
DOCBOOK_DEFAULT_XSL_SLIDESHTML</p>

<p style="margin-top: 1em">and you can set them when
constructing your environment:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;], <br>
DOCBOOK_DEFAULT_XSL_HTML=&rsquo;html.xsl&rsquo;, <br>
DOCBOOK_DEFAULT_XSL_PDF=&rsquo;pdf.xsl&rsquo;) <br>
env.DocbookHtml(&rsquo;manual&rsquo;) # now uses
html.xsl</p>

<p style="margin-top: 1em">Sets: $DOCBOOK_DEFAULT_XSL_EPUB,
$DOCBOOK_DEFAULT_XSL_HTML, $DOCBOOK_DEFAULT_XSL_HTMLCHUNKED,
$DOCBOOK_DEFAULT_XSL_HTMLHELP, $DOCBOOK_DEFAULT_XSL_MAN,
<br>
$DOCBOOK_DEFAULT_XSL_PDF, $DOCBOOK_DEFAULT_XSL_SLIDESHTML,
$DOCBOOK_DEFAULT_XSL_SLIDESPDF, $DOCBOOK_FOP,
$DOCBOOK_FOPCOM, $DOCBOOK_FOPFLAGS, $DOCBOOK_XMLLINT, <br>
$DOCBOOK_XMLLINTCOM, $DOCBOOK_XMLLINTFLAGS,
$DOCBOOK_XSLTPROC, $DOCBOOK_XSLTPROCCOM,
$DOCBOOK_XSLTPROCFLAGS, $DOCBOOK_XSLTPROCPARAMS.</p>

<p style="margin-top: 1em">Uses: $DOCBOOK_FOPCOMSTR,
$DOCBOOK_XMLLINTCOMSTR, $DOCBOOK_XSLTPROCCOMSTR.</p>

<p style="margin-top: 1em">dvi <br>
Attaches the DVI builder to the construction
environment.</p>

<p style="margin-top: 1em">dvipdf <br>
Sets construction variables for the dvipdf utility.</p>

<p style="margin-top: 1em">Sets: $DVIPDF, $DVIPDFCOM,
$DVIPDFFLAGS.</p>

<p style="margin-top: 1em">Uses: $DVIPDFCOMSTR.</p>

<p style="margin-top: 1em">dvips <br>
Sets construction variables for the dvips utility.</p>

<p style="margin-top: 1em">Sets: $DVIPS, $DVIPSFLAGS,
$PSCOM, $PSPREFIX, $PSSUFFIX.</p>

<p style="margin-top: 1em">Uses: $PSCOMSTR.</p>

<p style="margin-top: 1em">f03 <br>
Set construction variables for generic POSIX Fortran 03
compilers.</p>

<p style="margin-top: 1em">Sets: $F03, $F03COM, $F03FLAGS,
$F03PPCOM, $SHF03, $SHF03COM, $SHF03FLAGS, $SHF03PPCOM,
$_F03INCFLAGS.</p>

<p style="margin-top: 1em">Uses: $F03COMSTR, $F03PPCOMSTR,
$SHF03COMSTR, $SHF03PPCOMSTR.</p>

<p style="margin-top: 1em">f08 <br>
Set construction variables for generic POSIX Fortran 08
compilers.</p>

<p style="margin-top: 1em">Sets: $F08, $F08COM, $F08FLAGS,
$F08PPCOM, $SHF08, $SHF08COM, $SHF08FLAGS, $SHF08PPCOM,
$_F08INCFLAGS.</p>

<p style="margin-top: 1em">Uses: $F08COMSTR, $F08PPCOMSTR,
$SHF08COMSTR, $SHF08PPCOMSTR.</p>

<p style="margin-top: 1em">f77 <br>
Set construction variables for generic POSIX Fortran 77
compilers.</p>

<p style="margin-top: 1em">Sets: $F77, $F77COM,
$F77FILESUFFIXES, $F77FLAGS, $F77PPCOM, $F77PPFILESUFFIXES,
$FORTRAN, $FORTRANCOM, $FORTRANFLAGS, $SHF77, $SHF77COM,
$SHF77FLAGS, $SHF77PPCOM, <br>
$SHFORTRAN, $SHFORTRANCOM, $SHFORTRANFLAGS, $SHFORTRANPPCOM,
$_F77INCFLAGS.</p>

<p style="margin-top: 1em">Uses: $F77COMSTR, $F77PPCOMSTR,
$FORTRANCOMSTR, $FORTRANPPCOMSTR, $SHF77COMSTR,
$SHF77PPCOMSTR, $SHFORTRANCOMSTR, $SHFORTRANPPCOMSTR.</p>

<p style="margin-top: 1em">f90 <br>
Set construction variables for generic POSIX Fortran 90
compilers.</p>

<p style="margin-top: 1em">Sets: $F90, $F90COM, $F90FLAGS,
$F90PPCOM, $SHF90, $SHF90COM, $SHF90FLAGS, $SHF90PPCOM,
$_F90INCFLAGS.</p>

<p style="margin-top: 1em">Uses: $F90COMSTR, $F90PPCOMSTR,
$SHF90COMSTR, $SHF90PPCOMSTR.</p>

<p style="margin-top: 1em">f95 <br>
Set construction variables for generic POSIX Fortran 95
compilers.</p>

<p style="margin-top: 1em">Sets: $F95, $F95COM, $F95FLAGS,
$F95PPCOM, $SHF95, $SHF95COM, $SHF95FLAGS, $SHF95PPCOM,
$_F95INCFLAGS.</p>

<p style="margin-top: 1em">Uses: $F95COMSTR, $F95PPCOMSTR,
$SHF95COMSTR, $SHF95PPCOMSTR.</p>

<p style="margin-top: 1em">fortran <br>
Set construction variables for generic POSIX Fortran
compilers.</p>

<p style="margin-top: 1em">Sets: $FORTRAN, $FORTRANCOM,
$FORTRANFLAGS, $SHFORTRAN, $SHFORTRANCOM, $SHFORTRANFLAGS,
$SHFORTRANPPCOM.</p>

<p style="margin-top: 1em">Uses: $FORTRANCOMSTR,
$FORTRANPPCOMSTR, $SHFORTRANCOMSTR, $SHFORTRANPPCOMSTR.</p>

<p style="margin-top: 1em">g++ <br>
Set construction variables for the gXX C++ compiler.</p>

<p style="margin-top: 1em">Sets: $CXX, $CXXVERSION,
$SHCXXFLAGS, $SHOBJSUFFIX.</p>

<p style="margin-top: 1em">g77 <br>
Set construction variables for the g77 Fortran compiler.
Calls the f77 Tool module to set variables.</p>

<p style="margin-top: 1em">gas <br>
Sets construction variables for the gas assembler. Calls the
as module.</p>

<p style="margin-top: 1em">Sets: $AS.</p>

<p style="margin-top: 1em">gcc <br>
Set construction variables for the gcc C compiler.</p>

<p style="margin-top: 1em">Sets: $CC, $CCVERSION,
$SHCCFLAGS.</p>

<p style="margin-top: 1em">gdc <br>
Sets construction variables for the D language compiler
GDC.</p>

<p style="margin-top: 1em">Sets: $DC, $DCOM, $DDEBUG,
$DDEBUGPREFIX, $DDEBUGSUFFIX, $DFILESUFFIX, $DFLAGPREFIX,
$DFLAGS, $DFLAGSUFFIX, $DINCPREFIX, $DINCSUFFIX, $DLIB,
$DLIBCOM, $DLIBFLAGPREFIX, <br>
$DLIBFLAGSUFFIX, $DLINK, $DLINKCOM, $DLINKFLAGPREFIX,
$DLINKFLAGS, $DLINKFLAGSUFFIX, $DPATH, $DVERPREFIX,
$DVERSIONS, $DVERSUFFIX, $RPATHPREFIX, $RPATHSUFFIX, $SHDC,
$SHDCOM, <br>
$SHDLINK, $SHDLINKCOM, $SHDLINKFLAGS, $_DDEBUGFLAGS,
$_DFLAGS, $_DINCFLAGS, $_DLIBFLAGS, $_DVERFLAGS,
$_RPATH.</p>

<p style="margin-top: 1em">gettext <br>
This is actually a toolset, which supports
internationalization and localization of software being
constructed with SCons. The toolset loads following
tools:</p>

<p style="margin-top: 1em">&Acirc;&middot; xgettext - to
extract internationalized messages from source code to POT
file(s),</p>

<p style="margin-top: 1em">&Acirc;&middot; msginit - may be
optionally used to initialize PO files,</p>

<p style="margin-top: 1em">&Acirc;&middot; msgmerge - to
update PO files, that already contain translated
messages,</p>

<p style="margin-top: 1em">&Acirc;&middot; msgfmt - to
compile textual PO file to binary installable MO file.</p>

<p style="margin-top: 1em">When you enable gettext, it
internally loads all abovementioned tools, so you&rsquo;re
encouraged to see their individual documentation.</p>

<p style="margin-top: 1em">Each of the above tools provides
its own builder(s) which may be used to perform particular
activities related to software internationalization. You may
be however interested <br>
in top-level builder Translate described few paragraphs
later.</p>

<p style="margin-top: 1em">To use gettext tools add
&rsquo;gettext&rsquo; tool to your environment:</p>

<p style="margin-top: 1em">env = Environment( tools =
[&rsquo;default&rsquo;, &rsquo;gettext&rsquo;] )</p>

<p style="margin-top: 1em">gfortran <br>
Sets construction variables for the GNU F95/F2003 GNU
compiler.</p>

<p style="margin-top: 1em">Sets: $F77, $F90, $F95,
$FORTRAN, $SHF77, $SHF77FLAGS, $SHF90, $SHF90FLAGS, $SHF95,
$SHF95FLAGS, $SHFORTRAN, $SHFORTRANFLAGS.</p>

<p style="margin-top: 1em">gnulink <br>
Set construction variables for GNU linker/loader.</p>

<p style="margin-top: 1em">Sets: $LDMODULEVERSIONFLAGS,
$RPATHPREFIX, $RPATHSUFFIX, $SHLIBVERSIONFLAGS,
$SHLINKFLAGS, $_LDMODULESONAME, $_SHLIBSONAME.</p>

<p style="margin-top: 1em">gs <br>
This Tool sets the required construction variables for
working with the Ghostscript command. It also registers an
appropriate Action with the PDF Builder (PDF), such that the
<br>
conversion from PS/EPS to PDF happens automatically for the
TeX/LaTeX toolchain. Finally, it adds an explicit
Ghostscript Builder (Gs) to the environment.</p>

<p style="margin-top: 1em">Sets: $GS, $GSCOM, $GSFLAGS.</p>

<p style="margin-top: 1em">Uses: $GSCOMSTR.</p>

<p style="margin-top: 1em">hpc++ <br>
Set construction variables for the compilers aCC on HP/UX
systems.</p>

<p style="margin-top: 1em">hpcc <br>
Set construction variables for the aCC on HP/UX systems.
Calls the cXX tool for additional variables.</p>

<p style="margin-top: 1em">Sets: $CXX, $CXXVERSION,
$SHCXXFLAGS.</p>

<p style="margin-top: 1em">hplink <br>
Sets construction variables for the linker on HP/UX
systems.</p>

<p style="margin-top: 1em">Sets: $LINKFLAGS, $SHLIBSUFFIX,
$SHLINKFLAGS.</p>

<p style="margin-top: 1em">icc <br>
Sets construction variables for the icc compiler on OS/2
systems.</p>

<p style="margin-top: 1em">Sets: $CC, $CCCOM, $CFILESUFFIX,
$CPPDEFPREFIX, $CPPDEFSUFFIX, $CXXCOM, $CXXFILESUFFIX,
$INCPREFIX, $INCSUFFIX.</p>

<p style="margin-top: 1em">Uses: $CCFLAGS, $CFLAGS,
$CPPFLAGS, $_CPPDEFFLAGS, $_CPPINCFLAGS.</p>

<p style="margin-top: 1em">icl <br>
Sets construction variables for the Intel C/C++ compiler.
Calls the intelc Tool module to set its variables.</p>

<p style="margin-top: 1em">ifl <br>
Sets construction variables for the Intel Fortran
compiler.</p>

<p style="margin-top: 1em">Sets: $FORTRAN, $FORTRANCOM,
$FORTRANPPCOM, $SHFORTRANCOM, $SHFORTRANPPCOM.</p>

<p style="margin-top: 1em">Uses: $CPPFLAGS, $FORTRANFLAGS,
$_CPPDEFFLAGS, $_FORTRANINCFLAGS.</p>

<p style="margin-top: 1em">ifort <br>
Sets construction variables for newer versions of the Intel
Fortran compiler for Linux.</p>

<p style="margin-top: 1em">Sets: $F77, $F90, $F95,
$FORTRAN, $SHF77, $SHF77FLAGS, $SHF90, $SHF90FLAGS, $SHF95,
$SHF95FLAGS, $SHFORTRAN, $SHFORTRANFLAGS.</p>

<p style="margin-top: 1em">ilink <br>
Sets construction variables for the ilink linker on OS/2
systems.</p>

<p style="margin-top: 1em">Sets: $LIBDIRPREFIX,
$LIBDIRSUFFIX, $LIBLINKPREFIX, $LIBLINKSUFFIX, $LINK,
$LINKCOM, $LINKFLAGS.</p>

<p style="margin-top: 1em">ilink32 <br>
Sets construction variables for the Borland ilink32
linker.</p>

<p style="margin-top: 1em">Sets: $LIBDIRPREFIX,
$LIBDIRSUFFIX, $LIBLINKPREFIX, $LIBLINKSUFFIX, $LINK,
$LINKCOM, $LINKFLAGS.</p>

<p style="margin-top: 1em">install <br>
Sets construction variables for file and directory
installation.</p>

<p style="margin-top: 1em">Sets: $INSTALL, $INSTALLSTR.</p>

<p style="margin-top: 1em">intelc <br>
Sets construction variables for the Intel C/C++ compiler
(Linux and Windows, version 7 and later). Calls the gcc or
msvc (on Linux and Windows, respectively) to set <br>
underlying variables.</p>

<p style="margin-top: 1em">Sets: $AR, $CC, $CXX,
$INTEL_C_COMPILER_VERSION, $LINK.</p>

<p style="margin-top: 1em">jar <br>
Sets construction variables for the jar utility.</p>

<p style="margin-top: 1em">Sets: $JAR, $JARCOM, $JARFLAGS,
$JARSUFFIX.</p>

<p style="margin-top: 1em">Uses: $JARCOMSTR.</p>

<p style="margin-top: 1em">javac <br>
Sets construction variables for the javac compiler.</p>

<p style="margin-top: 1em">Sets: $JAVABOOTCLASSPATH,
$JAVAC, $JAVACCOM, $JAVACFLAGS, $JAVACLASSPATH,
$JAVACLASSSUFFIX, $JAVASOURCEPATH, $JAVASUFFIX.</p>

<p style="margin-top: 1em">Uses: $JAVACCOMSTR.</p>

<p style="margin-top: 1em">javah <br>
Sets construction variables for the javah tool.</p>

<p style="margin-top: 1em">Sets: $JAVACLASSSUFFIX, $JAVAH,
$JAVAHCOM, $JAVAHFLAGS.</p>

<p style="margin-top: 1em">Uses: $JAVACLASSPATH,
$JAVAHCOMSTR.</p>

<p style="margin-top: 1em">latex <br>
Sets construction variables for the latex utility.</p>

<p style="margin-top: 1em">Sets: $LATEX, $LATEXCOM,
$LATEXFLAGS.</p>

<p style="margin-top: 1em">Uses: $LATEXCOMSTR.</p>

<p style="margin-top: 1em">ldc <br>
Sets construction variables for the D language compiler
LDC2.</p>

<p style="margin-top: 1em">Sets: $DC, $DCOM, $DDEBUG,
$DDEBUGPREFIX, $DDEBUGSUFFIX, $DFILESUFFIX, $DFLAGPREFIX,
$DFLAGS, $DFLAGSUFFIX, $DINCPREFIX, $DINCSUFFIX, $DLIB,
$DLIBCOM, $DLIBDIRPREFIX, <br>
$DLIBDIRSUFFIX, $DLIBFLAGPREFIX, $DLIBFLAGSUFFIX,
$DLIBLINKPREFIX, $DLIBLINKSUFFIX, $DLINK, $DLINKCOM,
$DLINKFLAGPREFIX, $DLINKFLAGS, $DLINKFLAGSUFFIX, $DPATH,
$DVERPREFIX, <br>
$DVERSIONS, $DVERSUFFIX, $RPATHPREFIX, $RPATHSUFFIX, $SHDC,
$SHDCOM, $SHDLINK, $SHDLINKCOM, $SHDLINKFLAGS,
$_DDEBUGFLAGS, $_DFLAGS, $_DINCFLAGS, $_DLIBDIRFLAGS,
$_DLIBFLAGS, <br>
$_DLIBFLAGS, $_DVERFLAGS, $_RPATH.</p>

<p style="margin-top: 1em">lex <br>
Sets construction variables for the lex lexical
analyser.</p>

<p style="margin-top: 1em">Sets: $LEX, $LEXCOM,
$LEXFLAGS.</p>

<p style="margin-top: 1em">Uses: $LEXCOMSTR.</p>

<p style="margin-top: 1em">link <br>
Sets construction variables for generic POSIX linkers.</p>

<p style="margin-top: 1em">Sets: $LDMODULE, $LDMODULECOM,
$LDMODULEFLAGS, $LDMODULENOVERSIONSYMLINKS, $LDMODULEPREFIX,
$LDMODULESUFFIX, $LDMODULEVERSION, $LDMODULEVERSIONFLAGS,
$LIBDIRPREFIX, <br>
$LIBDIRSUFFIX, $LIBLINKPREFIX, $LIBLINKSUFFIX, $LINK,
$LINKCOM, $LINKFLAGS, $SHLIBSUFFIX, $SHLINK, $SHLINKCOM,
$SHLINKFLAGS, $__LDMODULEVERSIONFLAGS,
$__SHLIBVERSIONFLAGS.</p>

<p style="margin-top: 1em">Uses: $LDMODULECOMSTR,
$LINKCOMSTR, $SHLINKCOMSTR.</p>

<p style="margin-top: 1em">linkloc <br>
Sets construction variables for the LinkLoc linker for the
Phar Lap ETS embedded operating system.</p>

<p style="margin-top: 1em">Sets: $LIBDIRPREFIX,
$LIBDIRSUFFIX, $LIBLINKPREFIX, $LIBLINKSUFFIX, $LINK,
$LINKCOM, $LINKFLAGS, $SHLINK, $SHLINKCOM, $SHLINKFLAGS.</p>

<p style="margin-top: 1em">Uses: $LINKCOMSTR,
$SHLINKCOMSTR.</p>

<p style="margin-top: 1em">m4 <br>
Sets construction variables for the m4 macro processor.</p>

<p style="margin-top: 1em">Sets: $M4, $M4COM, $M4FLAGS.</p>

<p style="margin-top: 1em">Uses: $M4COMSTR.</p>

<p style="margin-top: 1em">masm <br>
Sets construction variables for the Microsoft assembler.</p>

<p style="margin-top: 1em">Sets: $AS, $ASCOM, $ASFLAGS,
$ASPPCOM, $ASPPFLAGS.</p>

<p style="margin-top: 1em">Uses: $ASCOMSTR, $ASPPCOMSTR,
$CPPFLAGS, $_CPPDEFFLAGS, $_CPPINCFLAGS.</p>

<p style="margin-top: 1em">midl <br>
Sets construction variables for the Microsoft IDL
compiler.</p>

<p style="margin-top: 1em">Sets: $MIDL, $MIDLCOM,
$MIDLFLAGS.</p>

<p style="margin-top: 1em">Uses: $MIDLCOMSTR.</p>

<p style="margin-top: 1em">mingw <br>
Sets construction variables for MinGW (Minimal Gnu on
Windows).</p>

<p style="margin-top: 1em">Sets: $AS, $CC, $CXX,
$LDMODULECOM, $LIBPREFIX, $LIBSUFFIX, $OBJSUFFIX, $RC,
$RCCOM, $RCFLAGS, $RCINCFLAGS, $RCINCPREFIX, $RCINCSUFFIX,
$SHCCFLAGS, $SHCXXFLAGS, $SHLINKCOM, <br>
$SHLINKFLAGS, $SHOBJSUFFIX, $WINDOWSDEFPREFIX,
$WINDOWSDEFSUFFIX.</p>

<p style="margin-top: 1em">Uses: $RCCOMSTR,
$SHLINKCOMSTR.</p>

<p style="margin-top: 1em">msgfmt <br>
This scons tool is a part of scons gettext toolset. It
provides scons interface to msgfmt(1) command, which
generates binary message catalog (MO) from a textual
translation <br>
description (PO).</p>

<p style="margin-top: 1em">Sets: $MOSUFFIX, $MSGFMT,
$MSGFMTCOM, $MSGFMTCOMSTR, $MSGFMTFLAGS, $POSUFFIX.</p>

<p style="margin-top: 1em">Uses: $LINGUAS_FILE.</p>

<p style="margin-top: 1em">msginit <br>
This scons tool is a part of scons gettext toolset. It
provides scons interface to msginit(1) program, which
creates new PO file, initializing the meta information with
<br>
values from user&rsquo;s environment (or options).</p>

<p style="margin-top: 1em">Sets: $MSGINIT, $MSGINITCOM,
$MSGINITCOMSTR, $MSGINITFLAGS, $POAUTOINIT, $POCREATE_ALIAS,
$POSUFFIX, $POTSUFFIX, $_MSGINITLOCALE.</p>

<p style="margin-top: 1em">Uses: $LINGUAS_FILE,
$POAUTOINIT, $POTDOMAIN.</p>

<p style="margin-top: 1em">msgmerge <br>
This scons tool is a part of scons gettext toolset. It
provides scons interface to msgmerge(1) command, which
merges two Uniform style .po files together.</p>

<p style="margin-top: 1em">Sets: $MSGMERGE, $MSGMERGECOM,
$MSGMERGECOMSTR, $MSGMERGEFLAGS, $POSUFFIX, $POTSUFFIX,
$POUPDATE_ALIAS.</p>

<p style="margin-top: 1em">Uses: $LINGUAS_FILE,
$POAUTOINIT, $POTDOMAIN.</p>

<p style="margin-top: 1em">mslib <br>
Sets construction variables for the Microsoft mslib library
archiver.</p>

<p style="margin-top: 1em">Sets: $AR, $ARCOM, $ARFLAGS,
$LIBPREFIX, $LIBSUFFIX.</p>

<p style="margin-top: 1em">Uses: $ARCOMSTR.</p>

<p style="margin-top: 1em">mslink <br>
Sets construction variables for the Microsoft linker.</p>

<p style="margin-top: 1em">Sets: $LDMODULE, $LDMODULECOM,
$LDMODULEFLAGS, $LDMODULEPREFIX, $LDMODULESUFFIX,
$LIBDIRPREFIX, $LIBDIRSUFFIX, $LIBLINKPREFIX,
$LIBLINKSUFFIX, $LINK, $LINKCOM, $LINKFLAGS, <br>
$REGSVR, $REGSVRCOM, $REGSVRFLAGS, $SHLINK, $SHLINKCOM,
$SHLINKFLAGS, $WIN32DEFPREFIX, $WIN32DEFSUFFIX,
$WIN32EXPPREFIX, $WIN32EXPSUFFIX, $WINDOWSDEFPREFIX, <br>
$WINDOWSDEFSUFFIX, $WINDOWSEXPPREFIX, $WINDOWSEXPSUFFIX,
$WINDOWSPROGMANIFESTPREFIX, $WINDOWSPROGMANIFESTSUFFIX,
$WINDOWSSHLIBMANIFESTPREFIX, $WINDOWSSHLIBMANIFESTSUFFIX,
<br>
$WINDOWS_INSERT_DEF.</p>

<p style="margin-top: 1em">Uses: $LDMODULECOMSTR,
$LINKCOMSTR, $REGSVRCOMSTR, $SHLINKCOMSTR.</p>

<p style="margin-top: 1em">mssdk <br>
Sets variables for Microsoft Platform SDK and/or Windows
SDK. Note that unlike most other Tool modules, mssdk does
not set construction variables, but sets the environment
<br>
variables in the environment SCons uses to execute the
Microsoft toolchain: %INCLUDE%, %LIB%, %LIBPATH% and
%PATH%.</p>

<p style="margin-top: 1em">Uses: $MSSDK_DIR,
$MSSDK_VERSION, $MSVS_VERSION.</p>

<p style="margin-top: 1em">msvc <br>
Sets construction variables for the Microsoft Visual C/C++
compiler.</p>

<p style="margin-top: 1em">Sets: $BUILDERS, $CC, $CCCOM,
$CCFLAGS, $CCPCHFLAGS, $CCPDBFLAGS, $CFILESUFFIX, $CFLAGS,
$CPPDEFPREFIX, $CPPDEFSUFFIX, $CXX, $CXXCOM, $CXXFILESUFFIX,
$CXXFLAGS, $INCPREFIX, <br>
$INCSUFFIX, $OBJPREFIX, $OBJSUFFIX, $PCHCOM, $PCHPDBFLAGS,
$RC, $RCCOM, $RCFLAGS, $SHCC, $SHCCCOM, $SHCCFLAGS,
$SHCFLAGS, $SHCXX, $SHCXXCOM, $SHCXXFLAGS, $SHOBJPREFIX,
<br>
$SHOBJSUFFIX.</p>

<p style="margin-top: 1em">Uses: $CCCOMSTR, $CXXCOMSTR,
$PCH, $PCHSTOP, $PDB, $SHCCCOMSTR, $SHCXXCOMSTR.</p>

<p style="margin-top: 1em">msvs <br>
Sets construction variables for Microsoft Visual Studio.</p>

<p style="margin-top: 1em">Sets: $MSVSBUILDCOM,
$MSVSCLEANCOM, $MSVSENCODING, $MSVSPROJECTCOM,
$MSVSREBUILDCOM, $MSVSSCONS, $MSVSSCONSCOM, $MSVSSCONSCRIPT,
$MSVSSCONSFLAGS, $MSVSSOLUTIONCOM.</p>

<p style="margin-top: 1em">mwcc <br>
Sets construction variables for the Metrowerks CodeWarrior
compiler.</p>

<p style="margin-top: 1em">Sets: $CC, $CCCOM, $CFILESUFFIX,
$CPPDEFPREFIX, $CPPDEFSUFFIX, $CXX, $CXXCOM, $CXXFILESUFFIX,
$INCPREFIX, $INCSUFFIX, $MWCW_VERSION, $MWCW_VERSIONS,
$SHCC, $SHCCCOM, <br>
$SHCCFLAGS, $SHCFLAGS, $SHCXX, $SHCXXCOM, $SHCXXFLAGS.</p>

<p style="margin-top: 1em">Uses: $CCCOMSTR, $CXXCOMSTR,
$SHCCCOMSTR, $SHCXXCOMSTR.</p>

<p style="margin-top: 1em">mwld <br>
Sets construction variables for the Metrowerks CodeWarrior
linker.</p>

<p style="margin-top: 1em">Sets: $AR, $ARCOM,
$LIBDIRPREFIX, $LIBDIRSUFFIX, $LIBLINKPREFIX,
$LIBLINKSUFFIX, $LINK, $LINKCOM, $SHLINK, $SHLINKCOM,
$SHLINKFLAGS.</p>

<p style="margin-top: 1em">nasm <br>
Sets construction variables for the nasm Netwide
Assembler.</p>

<p style="margin-top: 1em">Sets: $AS, $ASCOM, $ASFLAGS,
$ASPPCOM, $ASPPFLAGS.</p>

<p style="margin-top: 1em">Uses: $ASCOMSTR,
$ASPPCOMSTR.</p>

<p style="margin-top: 1em">packaging <br>
A framework for building binary and source packages.</p>

<p style="margin-top: 1em">Packaging <br>
Sets construction variables for the Package Builder.</p>

<p style="margin-top: 1em">pdf <br>
Sets construction variables for the Portable Document Format
builder.</p>

<p style="margin-top: 1em">Sets: $PDFPREFIX,
$PDFSUFFIX.</p>

<p style="margin-top: 1em">pdflatex <br>
Sets construction variables for the pdflatex utility.</p>

<p style="margin-top: 1em">Sets: $LATEXRETRIES, $PDFLATEX,
$PDFLATEXCOM, $PDFLATEXFLAGS.</p>

<p style="margin-top: 1em">Uses: $PDFLATEXCOMSTR.</p>

<p style="margin-top: 1em">pdftex <br>
Sets construction variables for the pdftex utility.</p>

<p style="margin-top: 1em">Sets: $LATEXRETRIES, $PDFLATEX,
$PDFLATEXCOM, $PDFLATEXFLAGS, $PDFTEX, $PDFTEXCOM,
$PDFTEXFLAGS.</p>

<p style="margin-top: 1em">Uses: $PDFLATEXCOMSTR,
$PDFTEXCOMSTR.</p>

<p style="margin-top: 1em">Perforce <br>
Sets construction variables for interacting with the
Perforce source code management system.</p>

<p style="margin-top: 1em">Sets: $P4, $P4COM, $P4FLAGS.</p>

<p style="margin-top: 1em">Uses: $P4COMSTR.</p>

<p style="margin-top: 1em">qt <br>
Sets construction variables for building Qt
applications.</p>

<p style="margin-top: 1em">Sets: $QTDIR, $QT_AUTOSCAN,
$QT_BINPATH, $QT_CPPPATH, $QT_LIB, $QT_LIBPATH, $QT_MOC,
$QT_MOCCXXPREFIX, $QT_MOCCXXSUFFIX, $QT_MOCFROMCXXCOM,
$QT_MOCFROMCXXFLAGS, <br>
$QT_MOCFROMHCOM, $QT_MOCFROMHFLAGS, $QT_MOCHPREFIX,
$QT_MOCHSUFFIX, $QT_UIC, $QT_UICCOM, $QT_UICDECLFLAGS,
$QT_UICDECLPREFIX, $QT_UICDECLSUFFIX, $QT_UICIMPLFLAGS, <br>
$QT_UICIMPLPREFIX, $QT_UICIMPLSUFFIX, $QT_UISUFFIX.</p>

<p style="margin-top: 1em">RCS <br>
Sets construction variables for the interaction with the
Revision Control System.</p>

<p style="margin-top: 1em">Sets: $RCS, $RCS_CO, $RCS_COCOM,
$RCS_COFLAGS.</p>

<p style="margin-top: 1em">Uses: $RCS_COCOMSTR.</p>

<p style="margin-top: 1em">rmic <br>
Sets construction variables for the rmic utility.</p>

<p style="margin-top: 1em">Sets: $JAVACLASSSUFFIX, $RMIC,
$RMICCOM, $RMICFLAGS.</p>

<p style="margin-top: 1em">Uses: $RMICCOMSTR.</p>

<p style="margin-top: 1em">rpcgen <br>
Sets construction variables for building with RPCGEN.</p>

<p style="margin-top: 1em">Sets: $RPCGEN,
$RPCGENCLIENTFLAGS, $RPCGENFLAGS, $RPCGENHEADERFLAGS,
$RPCGENSERVICEFLAGS, $RPCGENXDRFLAGS.</p>

<p style="margin-top: 1em">SCCS <br>
Sets construction variables for interacting with the Source
Code Control System.</p>

<p style="margin-top: 1em">Sets: $SCCS, $SCCSCOM,
$SCCSFLAGS, $SCCSGETFLAGS.</p>

<p style="margin-top: 1em">Uses: $SCCSCOMSTR.</p>

<p style="margin-top: 1em">sgiar <br>
Sets construction variables for the SGI library
archiver.</p>

<p style="margin-top: 1em">Sets: $AR, $ARCOMSTR, $ARFLAGS,
$LIBPREFIX, $LIBSUFFIX, $SHLINK, $SHLINKFLAGS.</p>

<p style="margin-top: 1em">Uses: $ARCOMSTR,
$SHLINKCOMSTR.</p>

<p style="margin-top: 1em">sgic++ <br>
Sets construction variables for the SGI C++ compiler.</p>

<p style="margin-top: 1em">Sets: $CXX, $CXXFLAGS, $SHCXX,
$SHOBJSUFFIX.</p>

<p style="margin-top: 1em">sgicc <br>
Sets construction variables for the SGI C compiler.</p>

<p style="margin-top: 1em">Sets: $CXX, $SHOBJSUFFIX.</p>

<p style="margin-top: 1em">sgilink <br>
Sets construction variables for the SGI linker.</p>

<p style="margin-top: 1em">Sets: $LINK, $RPATHPREFIX,
$RPATHSUFFIX, $SHLINKFLAGS.</p>

<p style="margin-top: 1em">sunar <br>
Sets construction variables for the Sun library
archiver.</p>

<p style="margin-top: 1em">Sets: $AR, $ARCOM, $ARFLAGS,
$LIBPREFIX, $LIBSUFFIX.</p>

<p style="margin-top: 1em">Uses: $ARCOMSTR.</p>

<p style="margin-top: 1em">sunc++ <br>
Sets construction variables for the Sun C++ compiler.</p>

<p style="margin-top: 1em">Sets: $CXX, $CXXVERSION, $SHCXX,
$SHCXXFLAGS, $SHOBJPREFIX, $SHOBJSUFFIX.</p>

<p style="margin-top: 1em">suncc <br>
Sets construction variables for the Sun C compiler.</p>

<p style="margin-top: 1em">Sets: $CXX, $SHCCFLAGS,
$SHOBJPREFIX, $SHOBJSUFFIX.</p>

<p style="margin-top: 1em">sunf77 <br>
Set construction variables for the Sun f77 Fortran
compiler.</p>

<p style="margin-top: 1em">Sets: $F77, $FORTRAN, $SHF77,
$SHF77FLAGS, $SHFORTRAN, $SHFORTRANFLAGS.</p>

<p style="margin-top: 1em">sunf90 <br>
Set construction variables for the Sun f90 Fortran
compiler.</p>

<p style="margin-top: 1em">Sets: $F90, $FORTRAN, $SHF90,
$SHF90FLAGS, $SHFORTRAN, $SHFORTRANFLAGS.</p>

<p style="margin-top: 1em">sunf95 <br>
Set construction variables for the Sun f95 Fortran
compiler.</p>

<p style="margin-top: 1em">Sets: $F95, $FORTRAN, $SHF95,
$SHF95FLAGS, $SHFORTRAN, $SHFORTRANFLAGS.</p>

<p style="margin-top: 1em">sunlink <br>
Sets construction variables for the Sun linker.</p>

<p style="margin-top: 1em">Sets: $RPATHPREFIX,
$RPATHSUFFIX, $SHLINKFLAGS.</p>

<p style="margin-top: 1em">swig <br>
Sets construction variables for the SWIG interface
generator.</p>

<p style="margin-top: 1em">Sets: $SWIG, $SWIGCFILESUFFIX,
$SWIGCOM, $SWIGCXXFILESUFFIX, $SWIGDIRECTORSUFFIX,
$SWIGFLAGS, $SWIGINCPREFIX, $SWIGINCSUFFIX, $SWIGPATH,
$SWIGVERSION, $_SWIGINCFLAGS.</p>

<p style="margin-top: 1em">Uses: $SWIGCOMSTR.</p>

<p style="margin-top: 1em">tar <br>
Sets construction variables for the tar archiver.</p>

<p style="margin-top: 1em">Sets: $TAR, $TARCOM, $TARFLAGS,
$TARSUFFIX.</p>

<p style="margin-top: 1em">Uses: $TARCOMSTR.</p>

<p style="margin-top: 1em">tex <br>
Sets construction variables for the TeX formatter and
typesetter.</p>

<p style="margin-top: 1em">Sets: $BIBTEX, $BIBTEXCOM,
$BIBTEXFLAGS, $LATEX, $LATEXCOM, $LATEXFLAGS, $MAKEINDEX,
$MAKEINDEXCOM, $MAKEINDEXFLAGS, $TEX, $TEXCOM,
$TEXFLAGS.</p>

<p style="margin-top: 1em">Uses: $BIBTEXCOMSTR,
$LATEXCOMSTR, $MAKEINDEXCOMSTR, $TEXCOMSTR.</p>

<p style="margin-top: 1em">textfile <br>
Set construction variables for the Textfile and Substfile
builders.</p>

<p style="margin-top: 1em">Sets: $LINESEPARATOR,
$SUBSTFILEPREFIX, $SUBSTFILESUFFIX, $TEXTFILEPREFIX,
$TEXTFILESUFFIX.</p>

<p style="margin-top: 1em">Uses: $SUBST_DICT.</p>

<p style="margin-top: 1em">tlib <br>
Sets construction variables for the Borlan tib library
archiver.</p>

<p style="margin-top: 1em">Sets: $AR, $ARCOM, $ARFLAGS,
$LIBPREFIX, $LIBSUFFIX.</p>

<p style="margin-top: 1em">Uses: $ARCOMSTR.</p>

<p style="margin-top: 1em">xgettext <br>
This scons tool is a part of scons gettext toolset. It
provides scons interface to xgettext(1) program, which
extracts internationalized messages from source code. The
tool <br>
provides POTUpdate builder to make PO Template files.</p>

<p style="margin-top: 1em">Sets: $POTSUFFIX,
$POTUPDATE_ALIAS, $XGETTEXTCOM, $XGETTEXTCOMSTR,
$XGETTEXTFLAGS, $XGETTEXTFROM, $XGETTEXTFROMPREFIX,
$XGETTEXTFROMSUFFIX, $XGETTEXTPATH, <br>
$XGETTEXTPATHPREFIX, $XGETTEXTPATHSUFFIX, $_XGETTEXTDOMAIN,
$_XGETTEXTFROMFLAGS, $_XGETTEXTPATHFLAGS.</p>

<p style="margin-top: 1em">Uses: $POTDOMAIN.</p>

<p style="margin-top: 1em">yacc <br>
Sets construction variables for the yacc parse
generator.</p>

<p style="margin-top: 1em">Sets: $YACC, $YACCCOM,
$YACCFLAGS, $YACCHFILESUFFIX, $YACCHXXFILESUFFIX,
$YACCVCGFILESUFFIX.</p>

<p style="margin-top: 1em">Uses: $YACCCOMSTR.</p>

<p style="margin-top: 1em">zip <br>
Sets construction variables for the zip archiver.</p>

<p style="margin-top: 1em">Sets: $ZIP, $ZIPCOM,
$ZIPCOMPRESSION, $ZIPFLAGS, $ZIPSUFFIX.</p>

<p style="margin-top: 1em">Uses: $ZIPCOMSTR.</p>

<p style="margin-top: 1em">Additionally, there is a
&quot;tool&quot; named default which configures the
environment with a default set of tools for the current
platform.</p>

<p style="margin-top: 1em">On posix and cygwin platforms
the GNU tools (e.g. gcc) are preferred by SCons, on Windows
the Microsoft tools (e.g. msvc) followed by MinGW are
preferred by SCons, and in OS/2 <br>
the IBM tools (e.g. icc) are preferred by SCons.</p>

<p style="margin-top: 1em">Builder Methods <br>
Build rules are specified by calling a construction
environment&rsquo;s builder methods. The arguments to the
builder methods are target (a list of targets to be built,
usually file <br>
names) and source (a list of sources to be built, usually
file names).</p>

<p style="margin-top: 1em">Because long lists of file names
can lead to a lot of quoting, scons supplies a Split()
global function and a same-named environment method that
split a single string into a <br>
list, separated on strings of white-space characters. (These
are similar to the split() member function of Python strings
but work even if the input isn&rsquo;t a string.)</p>

<p style="margin-top: 1em">Like all Python arguments, the
target and source arguments to a builder method can be
specified either with or without the &quot;target&quot; and
&quot;source&quot; keywords. When the keywords are <br>
omitted, the target is first, followed by the source. The
following are equivalent examples of calling the Program
builder method:</p>

<p style="margin-top: 1em">env.Program(&rsquo;bar&rsquo;,
[&rsquo;bar.c&rsquo;, &rsquo;foo.c&rsquo;]) <br>
env.Program(&rsquo;bar&rsquo;, Split(&rsquo;bar.c
foo.c&rsquo;)) <br>
env.Program(&rsquo;bar&rsquo;, env.Split(&rsquo;bar.c
foo.c&rsquo;)) <br>
env.Program(source = [&rsquo;bar.c&rsquo;,
&rsquo;foo.c&rsquo;], target = &rsquo;bar&rsquo;) <br>
env.Program(target = &rsquo;bar&rsquo;, Split(&rsquo;bar.c
foo.c&rsquo;)) <br>
env.Program(target = &rsquo;bar&rsquo;,
env.Split(&rsquo;bar.c foo.c&rsquo;)) <br>
env.Program(&rsquo;bar&rsquo;, source = &rsquo;bar.c
foo.c&rsquo;.split())</p>

<p style="margin-top: 1em">Target and source file names
that are not absolute path names (that is, do not begin with
/ on POSIX systems or on Windows systems, with or without an
optional drive letter) <br>
are interpreted relative to the directory containing the
SConscript file being read. An initial # (hash mark) on a
path name means that the rest of the file name is
interpreted <br>
relative to the directory containing the top-level
SConstruct file, even if the # is followed by a directory
separator character (slash or backslash).</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># The comments describing the
targets that will be built <br>
# assume these calls are in a SConscript file in the <br>
# a subdirectory named &quot;subdir&quot;.</p>

<p style="margin-top: 1em"># Builds the program
&quot;subdir/foo&quot; from &quot;subdir/foo.c&quot;: <br>
env.Program(&rsquo;foo&rsquo;, &rsquo;foo.c&rsquo;)</p>

<p style="margin-top: 1em"># Builds the program
&quot;/tmp/bar&quot; from &quot;subdir/bar.c&quot;: <br>
env.Program(&rsquo;/tmp/bar&rsquo;, &rsquo;bar.c&rsquo;)</p>

<p style="margin-top: 1em"># An initial &rsquo;#&rsquo; or
&rsquo;#/&rsquo; are equivalent; the following <br>
# calls build the programs &quot;foo&quot; and
&quot;bar&quot; (in the <br>
# top-level SConstruct directory) from
&quot;subdir/foo.c&quot; and <br>
# &quot;subdir/bar.c&quot;, respectively: <br>
env.Program(&rsquo;#foo&rsquo;, &rsquo;foo.c&rsquo;) <br>
env.Program(&rsquo;#/bar&rsquo;, &rsquo;bar.c&rsquo;)</p>

<p style="margin-top: 1em"># Builds the program
&quot;other/foo&quot; (relative to the top-level <br>
# SConstruct directory) from &quot;subdir/foo.c&quot;: <br>
env.Program(&rsquo;#other/foo&rsquo;,
&rsquo;foo.c&rsquo;)</p>

<p style="margin-top: 1em">When the target shares the same
base name as the source and only the suffix varies, and if
the builder method has a suffix defined for the target file
type, then the target <br>
argument may be omitted completely, and scons will deduce
the target file name from the source file name. The
following examples all build the executable program bar (on
POSIX <br>
systems) or bar.exe (on Windows systems) from the bar.c
source file:</p>

<p style="margin-top: 1em">env.Program(target =
&rsquo;bar&rsquo;, source = &rsquo;bar.c&rsquo;) <br>
env.Program(&rsquo;bar&rsquo;, source = &rsquo;bar.c&rsquo;)
<br>
env.Program(source = &rsquo;bar.c&rsquo;) <br>
env.Program(&rsquo;bar.c&rsquo;)</p>

<p style="margin-top: 1em">As a convenience, a srcdir
keyword argument may be specified when calling a Builder.
When specified, all source file strings that are not
absolute paths will be interpreted <br>
relative to the specified srcdir. The following example will
build the build/prog (or build/prog.exe on Windows) program
from the files src/f1.c and src/f2.c:</p>


<p style="margin-top: 1em">env.Program(&rsquo;build/prog&rsquo;,
[&rsquo;f1.c&rsquo;, &rsquo;f2.c&rsquo;],
srcdir=&rsquo;src&rsquo;)</p>

<p style="margin-top: 1em">It is possible to override or
add construction variables when calling a builder method by
passing additional keyword arguments. These overridden or
added variables will only be <br>
in effect when building the target, so they will not affect
other parts of the build. For example, if you want to add
additional libraries for just one program:</p>


<p style="margin-top: 1em">env.Program(&rsquo;hello&rsquo;,
&rsquo;hello.c&rsquo;, LIBS=[&rsquo;gl&rsquo;,
&rsquo;glut&rsquo;])</p>

<p style="margin-top: 1em">or generate a shared library
with a non-standard suffix:</p>


<p style="margin-top: 1em">env.SharedLibrary(&rsquo;word&rsquo;,
&rsquo;word.cpp&rsquo;, <br>
SHLIBSUFFIX=&rsquo;.ocx&rsquo;, <br>
LIBSUFFIXES=[&rsquo;.ocx&rsquo;])</p>

<p style="margin-top: 1em">(Note that both the $SHLIBSUFFIX
and $LIBSUFFIXES variables must be set if you want SCons to
search automatically for dependencies on the non-standard
library names; see the <br>
descriptions of these variables, below, for more
information.)</p>

<p style="margin-top: 1em">It is also possible to use the
parse_flags keyword argument in an override:</p>

<p style="margin-top: 1em">env =
Program(&rsquo;hello&rsquo;, &rsquo;hello.c&rsquo;,
parse_flags = &rsquo;-Iinclude -DEBUG -lm&rsquo;)</p>

<p style="margin-top: 1em">This example adds
&rsquo;include&rsquo; to CPPPATH, &rsquo;EBUG&rsquo; to
CPPDEFINES, and &rsquo;m&rsquo; to LIBS.</p>

<p style="margin-top: 1em">Although the builder methods
defined by scons are, in fact, methods of a construction
environment object, they may also be called without an
explicit environment:</p>

<p style="margin-top: 1em">Program(&rsquo;hello&rsquo;,
&rsquo;hello.c&rsquo;) <br>
SharedLibrary(&rsquo;word&rsquo;,
&rsquo;word.cpp&rsquo;)</p>

<p style="margin-top: 1em">In this case, the methods are
called internally using a default construction environment
that consists of the tools and values that scons has
determined are appropriate for the <br>
local system.</p>

<p style="margin-top: 1em">Builder methods that can be
called without an explicit environment may be called from
custom Python modules that you import into an SConscript
file by adding the following to the <br>
Python module:</p>

<p style="margin-top: 1em">from SCons.Script import *</p>

<p style="margin-top: 1em">All builder methods return a
list-like object containing Nodes that represent the target
or targets that will be built. A Node is an internal SCons
object which represents build <br>
targets or sources.</p>

<p style="margin-top: 1em">The returned Node-list object
can be passed to other builder methods as source(s) or
passed to any SCons function or method where a filename
would normally be accepted. For <br>
example, if it were necessary to add a specific -D flag when
compiling one specific object file:</p>

<p style="margin-top: 1em">bar_obj_list =
env.StaticObject(&rsquo;bar.c&rsquo;,
CPPDEFINES=&rsquo;-DBAR&rsquo;) <br>
env.Program(source = [&rsquo;foo.c&rsquo;, bar_obj_list,
&rsquo;main.c&rsquo;])</p>

<p style="margin-top: 1em">Using a Node in this way makes
for a more portable build by avoiding having to specify a
platform-specific object suffix when calling the Program()
builder method.</p>

<p style="margin-top: 1em">Note that Builder calls will
automatically &quot;flatten&quot; the source and target file
lists, so it&rsquo;s all right to have the bar_obj list
return by the StaticObject() call in the middle <br>
of the source file list. If you need to manipulate a list of
lists returned by Builders directly using Python, you can
either build the list by hand:</p>

<p style="margin-top: 1em">foo =
Object(&rsquo;foo.c&rsquo;) <br>
bar = Object(&rsquo;bar.c&rsquo;) <br>
objects = [&rsquo;begin.o&rsquo;] + foo +
[&rsquo;middle.o&rsquo;] + bar + [&rsquo;end.o&rsquo;] <br>
for object in objects: <br>
print str(object)</p>

<p style="margin-top: 1em">Or you can use the Flatten()
function supplied by scons to create a list containing just
the Nodes, which may be more convenient:</p>

<p style="margin-top: 1em">foo =
Object(&rsquo;foo.c&rsquo;) <br>
bar = Object(&rsquo;bar.c&rsquo;) <br>
objects = Flatten([&rsquo;begin.o&rsquo;, foo,
&rsquo;middle.o&rsquo;, bar, &rsquo;end.o&rsquo;]) <br>
for object in objects: <br>
print str(object)</p>

<p style="margin-top: 1em">Note also that because Builder
calls return a list-like object, not an actual Python list,
you should not use the Python += operator to append Builder
results to a Python list. <br>
Because the list and the object are different types, Python
will not update the original list in place, but will instead
create a new Node-list object containing the <br>
concatenation of the list elements and the Builder results.
This will cause problems for any other Python variables in
your SCons configuration that still hold on to a reference
<br>
to the original list. Instead, use the Python .extend()
method to make sure the list is updated in-place.
Example:</p>

<p style="margin-top: 1em">object_files = []</p>

<p style="margin-top: 1em"># Do NOT use += as follows: <br>
# <br>
# object_files += Object(&rsquo;bar.c&rsquo;) <br>
# <br>
# It will not update the object_files list in place. <br>
# <br>
# Instead, use the .extend() method: <br>
object_files.extend(Object(&rsquo;bar.c&rsquo;))</p>

<p style="margin-top: 1em">The path name for a Node&rsquo;s
file may be used by passing the Node to the Python-builtin
str() function:</p>

<p style="margin-top: 1em">bar_obj_list =
env.StaticObject(&rsquo;bar.c&rsquo;,
CPPDEFINES=&rsquo;-DBAR&rsquo;) <br>
print &quot;The path to bar_obj is:&quot;,
str(bar_obj_list[0])</p>

<p style="margin-top: 1em">Note again that because the
Builder call returns a list, we have to access the first
element in the list (bar_obj_list[0]) to get at the Node
that actually represents the object <br>
file.</p>

<p style="margin-top: 1em">Builder calls support a chdir
keyword argument that specifies that the Builder&rsquo;s
action(s) should be executed after changing directory. If
the chdir argument is a string or a <br>
directory Node, scons will change to the specified
directory. If the chdir is not a string or Node and is
non-zero, then scons will change to the target file&rsquo;s
directory.</p>

<p style="margin-top: 1em"># scons will change to the
&quot;sub&quot; subdirectory <br>
# before executing the &quot;cp&quot; command. <br>
env.Command(&rsquo;sub/dir/foo.out&rsquo;,
&rsquo;sub/dir/foo.in&rsquo;, <br>
&quot;cp dir/foo.in dir/foo.out&quot;, <br>
chdir=&rsquo;sub&rsquo;)</p>

<p style="margin-top: 1em"># Because chdir is not a string,
scons will change to the <br>
# target&rsquo;s directory (&quot;sub/dir&quot;) before
executing the <br>
# &quot;cp&quot; command. <br>
env.Command(&rsquo;sub/dir/foo.out&rsquo;,
&rsquo;sub/dir/foo.in&rsquo;, <br>
&quot;cp foo.in foo.out&quot;, <br>
chdir=1)</p>

<p style="margin-top: 1em">Note that scons will not
automatically modify its expansion of construction variables
like $TARGET and $SOURCE when using the chdir keyword
argument--that is, the expanded file <br>
names will still be relative to the top-level SConstruct
directory, and consequently incorrect relative to the chdir
directory. If you use the chdir keyword argument, you will
<br>
typically need to supply a different command line using
expansions like ${TARGET.file} and ${SOURCE.file} to use
just the filename portion of the targets and source.</p>

<p style="margin-top: 1em">scons provides the following
builder methods:</p>

<p style="margin-top: 1em">CFile(), env.CFile() <br>
Builds a C source file given a lex (.l) or yacc (.y) input
file. The suffix specified by the $CFILESUFFIX construction
variable (.c by default) is automatically added to the <br>
target if it is not already present. Example:</p>

<p style="margin-top: 1em"># builds foo.c <br>
env.CFile(target = &rsquo;foo.c&rsquo;, source =
&rsquo;foo.l&rsquo;) <br>
# builds bar.c <br>
env.CFile(target = &rsquo;bar&rsquo;, source =
&rsquo;bar.y&rsquo;)</p>

<p style="margin-top: 1em">Command(), env.Command() <br>
The Command &quot;Builder&quot; is actually implemented as a
function that looks like a Builder, but actually takes an
additional argument of the action from which the Builder
should <br>
be made. See the Command function description for the
calling syntax and details.</p>

<p style="margin-top: 1em">CXXFile(), env.CXXFile() <br>
Builds a C++ source file given a lex (.ll) or yacc (.yy)
input file. The suffix specified by the $CXXFILESUFFIX
construction variable (.cc by default) is automatically
added <br>
to the target if it is not already present. Example:</p>

<p style="margin-top: 1em"># builds foo.cc <br>
env.CXXFile(target = &rsquo;foo.cc&rsquo;, source =
&rsquo;foo.ll&rsquo;) <br>
# builds bar.cc <br>
env.CXXFile(target = &rsquo;bar&rsquo;, source =
&rsquo;bar.yy&rsquo;)</p>

<p style="margin-top: 1em">DocbookEpub(), env.DocbookEpub()
<br>
A pseudo-Builder, providing a Docbook toolchain for EPUB
output.</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookEpub(&rsquo;manual.epub&rsquo;,
&rsquo;manual.xml&rsquo;)</p>

<p style="margin-top: 1em">or simply</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookEpub(&rsquo;manual&rsquo;)</p>

<p style="margin-top: 1em">DocbookHtml(), env.DocbookHtml()
<br>
A pseudo-Builder, providing a Docbook toolchain for HTML
output.</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtml(&rsquo;manual.html&rsquo;,
&rsquo;manual.xml&rsquo;)</p>

<p style="margin-top: 1em">or simply</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtml(&rsquo;manual&rsquo;)</p>

<p style="margin-top: 1em">DocbookHtmlChunked(),
env.DocbookHtmlChunked() <br>
A pseudo-Builder, providing a Docbook toolchain for chunked
HTML output. It supports the base.dir parameter. The
chunkfast.xsl file (requires &quot;EXSLT&quot;) is used as
the default <br>
stylesheet. Basic syntax:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtmlChunked(&rsquo;manual&rsquo;)</p>

<p style="margin-top: 1em">where manual.xml is the input
file.</p>

<p style="margin-top: 1em">If you use the root.filename
parameter in your own stylesheets you have to specify the
new target name. This ensures that the dependencies get
correct, especially for the <br>
cleanup via &acirc;scons -c&acirc;:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtmlChunked(&rsquo;mymanual.html&rsquo;,
&rsquo;manual&rsquo;, xsl=&rsquo;htmlchunk.xsl&rsquo;)</p>

<p style="margin-top: 1em">Some basic support for the
base.dir is provided. You can add the base_dir keyword to
your Builder call, and the given prefix gets prepended to
all the created filenames:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtmlChunked(&rsquo;manual&rsquo;,
xsl=&rsquo;htmlchunk.xsl&rsquo;,
base_dir=&rsquo;output/&rsquo;)</p>

<p style="margin-top: 1em">Make sure that you don&rsquo;t
forget the trailing slash for the base folder, else your
files get renamed only!</p>

<p style="margin-top: 1em">DocbookHtmlhelp(),
env.DocbookHtmlhelp() <br>
A pseudo-Builder, providing a Docbook toolchain for HTMLHELP
output. Its basic syntax is:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtmlhelp(&rsquo;manual&rsquo;)</p>

<p style="margin-top: 1em">where manual.xml is the input
file.</p>

<p style="margin-top: 1em">If you use the root.filename
parameter in your own stylesheets you have to specify the
new target name. This ensures that the dependencies get
correct, especially for the <br>
cleanup via &acirc;scons -c&acirc;:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtmlhelp(&rsquo;mymanual.html&rsquo;,
&rsquo;manual&rsquo;, xsl=&rsquo;htmlhelp.xsl&rsquo;)</p>

<p style="margin-top: 1em">Some basic support for the
base.dir parameter is provided. You can add the base_dir
keyword to your Builder call, and the given prefix gets
prepended to all the created <br>
filenames:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookHtmlhelp(&rsquo;manual&rsquo;,
xsl=&rsquo;htmlhelp.xsl&rsquo;,
base_dir=&rsquo;output/&rsquo;)</p>

<p style="margin-top: 1em">Make sure that you don&rsquo;t
forget the trailing slash for the base folder, else your
files get renamed only!</p>

<p style="margin-top: 1em">DocbookMan(), env.DocbookMan()
<br>
A pseudo-Builder, providing a Docbook toolchain for Man page
output. Its basic syntax is:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookMan(&rsquo;manual&rsquo;)</p>

<p style="margin-top: 1em">where manual.xml is the input
file. Note, that you can specify a target name, but the
actual output names are automatically set from the refname
entries in your XML source.</p>

<p style="margin-top: 1em">DocbookPdf(), env.DocbookPdf()
<br>
A pseudo-Builder, providing a Docbook toolchain for PDF
output.</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookPdf(&rsquo;manual.pdf&rsquo;,
&rsquo;manual.xml&rsquo;)</p>

<p style="margin-top: 1em">or simply</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookPdf(&rsquo;manual&rsquo;)</p>

<p style="margin-top: 1em">DocbookSlidesHtml(),
env.DocbookSlidesHtml() <br>
A pseudo-Builder, providing a Docbook toolchain for HTML
slides output.</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookSlidesHtml(&rsquo;manual&rsquo;)</p>

<p style="margin-top: 1em">If you use the titlefoil.html
parameter in your own stylesheets you have to give the new
target name. This ensures that the dependencies get correct,
especially for the <br>
cleanup via &acirc;scons -c&acirc;:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>

env.DocbookSlidesHtml(&rsquo;mymanual.html&rsquo;,&rsquo;manual&rsquo;,
xsl=&rsquo;slideshtml.xsl&rsquo;)</p>

<p style="margin-top: 1em">Some basic support for the
base.dir parameter is provided. You can add the base_dir
keyword to your Builder call, and the given prefix gets
prepended to all the created <br>
filenames:</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookSlidesHtml(&rsquo;manual&rsquo;,
xsl=&rsquo;slideshtml.xsl&rsquo;,
base_dir=&rsquo;output/&rsquo;)</p>

<p style="margin-top: 1em">Make sure that you don&rsquo;t
forget the trailing slash for the base folder, else your
files get renamed only!</p>

<p style="margin-top: 1em">DocbookSlidesPdf(),
env.DocbookSlidesPdf() <br>
A pseudo-Builder, providing a Docbook toolchain for PDF
slides output.</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookSlidesPdf(&rsquo;manual.pdf&rsquo;,
&rsquo;manual.xml&rsquo;)</p>

<p style="margin-top: 1em">or simply</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookSlidesPdf(&rsquo;manual&rsquo;)</p>

<p style="margin-top: 1em">DocbookXInclude(),
env.DocbookXInclude() <br>
A pseudo-Builder, for resolving XIncludes in a separate
processing step.</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookXInclude(&rsquo;manual_xincluded.xml&rsquo;,
&rsquo;manual.xml&rsquo;)</p>

<p style="margin-top: 1em">DocbookXslt(), env.DocbookXslt()
<br>
A pseudo-Builder, applying a given XSL transformation to the
input file.</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;docbook&rsquo;]) <br>
env.DocbookXslt(&rsquo;manual_transformed.xml&rsquo;,
&rsquo;manual.xml&rsquo;,
xsl=&rsquo;transform.xslt&rsquo;)</p>

<p style="margin-top: 1em">Note, that this builder requires
the xsl parameter to be set.</p>

<p style="margin-top: 1em">DVI(), env.DVI() <br>
Builds a .dvi file from a .tex, .ltx or .latex input file.
If the source file suffix is .tex, scons will examine the
contents of the file; if the string ocumentclass or <br>
ocumentstyle is found, the file is assumed to be a LaTeX
file and the target is built by invoking the $LATEXCOM
command line; otherwise, the $TEXCOM command line is used.
<br>
If the file is a LaTeX file, the DVI builder method will
also examine the contents of the .aux file and invoke the
$BIBTEX command line if the string bibdata is found, start
<br>
$MAKEINDEX to generate an index if a .ind file is found and
will examine the contents .log file and re-run the $LATEXCOM
command if the log file says it is necessary.</p>

<p style="margin-top: 1em">The suffix .dvi (hard-coded
within TeX itself) is automatically added to the target if
it is not already present. Examples:</p>

<p style="margin-top: 1em"># builds from aaa.tex <br>
env.DVI(target = &rsquo;aaa.dvi&rsquo;, source =
&rsquo;aaa.tex&rsquo;) <br>
# builds bbb.dvi <br>
env.DVI(target = &rsquo;bbb&rsquo;, source =
&rsquo;bbb.ltx&rsquo;) <br>
# builds from ccc.latex <br>
env.DVI(target = &rsquo;ccc.dvi&rsquo;, source =
&rsquo;ccc.latex&rsquo;)</p>

<p style="margin-top: 1em">Gs(), env.Gs() <br>
A Builder for explicitly calling the gs executable.
Depending on the underlying OS, the different names gs,
gsos2 and gswin32c are tried.</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;gs&rsquo;]) <br>

env.Gs(&rsquo;cover.jpg&rsquo;,&rsquo;scons-scons.pdf&rsquo;,
<br>
GSFLAGS=&rsquo;-dNOPAUSE -dBATCH -sDEVICE=jpeg -dFirstPage=1
-dLastPage=1 -q&rsquo;) <br>
)</p>

<p style="margin-top: 1em">Install(), env.Install() <br>
Installs one or more source files or directories in the
specified target, which must be a directory. The names of
the specified source files or directories remain the same
<br>
within the destination directory. The sources may be given
as a string or as a node returned by a builder.</p>


<p style="margin-top: 1em">env.Install(&rsquo;/usr/local/bin&rsquo;,
source = [&rsquo;foo&rsquo;, &rsquo;bar&rsquo;])</p>

<p style="margin-top: 1em">InstallAs(), env.InstallAs()
<br>
Installs one or more source files or directories to specific
names, allowing changing a file or directory name as part of
the installation. It is an error if the target and <br>
source arguments list different numbers of files or
directories.</p>

<p style="margin-top: 1em">env.InstallAs(target =
&rsquo;/usr/local/bin/foo&rsquo;, <br>
source = &rsquo;foo_debug&rsquo;) <br>
env.InstallAs(target = [&rsquo;../lib/libfoo.a&rsquo;,
&rsquo;../lib/libbar.a&rsquo;], <br>
source = [&rsquo;libFOO.a&rsquo;,
&rsquo;libBAR.a&rsquo;])</p>

<p style="margin-top: 1em">InstallVersionedLib(),
env.InstallVersionedLib() <br>
Installs a versioned shared library. The symlinks
appropriate to the architecture will be generated based on
symlinks of the source library.</p>

<p style="margin-top: 1em">env.InstallVersionedLib(target =
&rsquo;/usr/local/bin/foo&rsquo;, <br>
source = &rsquo;libxyz.1.5.2.so&rsquo;)</p>

<p style="margin-top: 1em">Jar(), env.Jar() <br>
Builds a Java archive (.jar) file from the specified list of
sources. Any directories in the source list will be searched
for .class files). Any .java files in the source <br>
list will be compiled to .class files by calling the Java
Builder.</p>

<p style="margin-top: 1em">If the $JARCHDIR value is set,
the jar command will change to the specified directory using
the -C option. If $JARCHDIR is not set explicitly, SCons
will use the top of any <br>
subdirectory tree in which Java .class were built by the
Java Builder.</p>

<p style="margin-top: 1em">If the contents any of the
source files begin with the string Manifest-Version, the
file is assumed to be a manifest and is passed to the jar
command with the m option set.</p>

<p style="margin-top: 1em">env.Jar(target =
&rsquo;foo.jar&rsquo;, source = &rsquo;classes&rsquo;)</p>

<p style="margin-top: 1em">env.Jar(target =
&rsquo;bar.jar&rsquo;, <br>
source = [&rsquo;bar1.java&rsquo;,
&rsquo;bar2.java&rsquo;])</p>

<p style="margin-top: 1em">Java(), env.Java() <br>
Builds one or more Java class files. The sources may be any
combination of explicit .java files, or directory trees
which will be scanned for .java files.</p>

<p style="margin-top: 1em">SCons will parse each source
.java file to find the classes (including inner classes)
defined within that file, and from that figure out the
target .class files that will be <br>
created. The class files will be placed underneath the
specified target directory.</p>

<p style="margin-top: 1em">SCons will also search each Java
file for the Java package name, which it assumes can be
found on a line beginning with the string package in the
first column; the resulting <br>
.class files will be placed in a directory reflecting the
specified package name. For example, the file Foo.java
defining a single public Foo class and containing a package
<br>
name of sub.dir will generate a corresponding
sub/dir/Foo.class class file.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">env.Java(target =
&rsquo;classes&rsquo;, source = &rsquo;src&rsquo;) <br>
env.Java(target = &rsquo;classes&rsquo;, source =
[&rsquo;src1&rsquo;, &rsquo;src2&rsquo;]) <br>
env.Java(target = &rsquo;classes&rsquo;, source =
[&rsquo;File1.java&rsquo;, &rsquo;File2.java&rsquo;])</p>

<p style="margin-top: 1em">Java source files can use the
native encoding for the underlying OS. Since SCons compiles
in simple ASCII mode by default, the compiler will generate
warnings about <br>
unmappable characters, which may lead to errors as the file
is processed further. In this case, the user must specify
the LANG environment variable to tell the compiler what <br>
encoding is used. For portibility, it&rsquo;s best if the
encoding is hard-coded so that the compile will work if it
is done on a system with a different encoding.</p>

<p style="margin-top: 1em">env = Environment() <br>
env[&rsquo;ENV&rsquo;][&rsquo;LANG&rsquo;] =
&rsquo;en_GB.UTF-8&rsquo;</p>

<p style="margin-top: 1em">JavaH(), env.JavaH() <br>
Builds C header and source files for implementing Java
native methods. The target can be either a directory in
which the header files will be written, or a header file
name <br>
which will contain all of the definitions. The source can be
the names of .class files, the names of .java files to be
compiled into .class files by calling the Java builder <br>
method, or the objects returned from the Java builder
method.</p>

<p style="margin-top: 1em">If the construction variable
$JAVACLASSDIR is set, either in the environment or in the
call to the JavaH builder method itself, then the value of
the variable will be <br>
stripped from the beginning of any .class file names.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># builds java_native.h <br>
classes = env.Java(target = &rsquo;classdir&rsquo;, source =
&rsquo;src&rsquo;) <br>
env.JavaH(target = &rsquo;java_native.h&rsquo;, source =
classes)</p>

<p style="margin-top: 1em"># builds include/package_foo.h
and include/package_bar.h <br>
env.JavaH(target = &rsquo;include&rsquo;, <br>
source = [&rsquo;package/foo.class&rsquo;,
&rsquo;package/bar.class&rsquo;])</p>

<p style="margin-top: 1em"># builds export/foo.h and
export/bar.h <br>
env.JavaH(target = &rsquo;export&rsquo;, <br>
source = [&rsquo;classes/foo.class&rsquo;,
&rsquo;classes/bar.class&rsquo;], <br>
JAVACLASSDIR = &rsquo;classes&rsquo;)</p>

<p style="margin-top: 1em">Library(), env.Library() <br>
A synonym for the StaticLibrary builder method.</p>

<p style="margin-top: 1em">LoadableModule(),
env.LoadableModule() <br>
On most systems, this is the same as SharedLibrary. On Mac
OS X (Darwin) platforms, this creates a loadable module
bundle.</p>

<p style="margin-top: 1em">M4(), env.M4() <br>
Builds an output file from an M4 input file. This uses a
default $M4FLAGS value of -E, which considers all warnings
to be fatal and stops on the first warning when using the
<br>
GNU version of m4. Example:</p>

<p style="margin-top: 1em">env.M4(target =
&rsquo;foo.c&rsquo;, source = &rsquo;foo.c.m4&rsquo;)</p>

<p style="margin-top: 1em">Moc(), env.Moc() <br>
Builds an output file from a moc input file. Moc input files
are either header files or cxx files. This builder is only
available after using the tool &rsquo;qt&rsquo;. See the
$QTDIR <br>
variable for more information. Example:</p>

<p style="margin-top: 1em">env.Moc(&rsquo;foo.h&rsquo;) #
generates moc_foo.cc <br>
env.Moc(&rsquo;foo.cpp&rsquo;) # generates foo.moc</p>

<p style="margin-top: 1em">MOFiles(), env.MOFiles() <br>
This builder belongs to msgfmt tool. The builder compiles PO
files to MO files.</p>

<p style="margin-top: 1em">Example 1. Create pl.mo and
en.mo by compiling pl.po and en.po:</p>

<p style="margin-top: 1em"># ... <br>
env.MOFiles([&rsquo;pl&rsquo;, &rsquo;en&rsquo;])</p>

<p style="margin-top: 1em">Example 2. Compile files for
languages defined in LINGUAS file:</p>

<p style="margin-top: 1em"># ... <br>
env.MOFiles(LINGUAS_FILE = 1)</p>

<p style="margin-top: 1em">Example 3. Create pl.mo and
en.mo by compiling pl.po and en.po plus files for languages
defined in LINGUAS file:</p>

<p style="margin-top: 1em"># ... <br>
env.MOFiles([&rsquo;pl&rsquo;, &rsquo;en&rsquo;],
LINGUAS_FILE = 1)</p>

<p style="margin-top: 1em">Example 4. Compile files for
languages defined in LINGUAS file (another version):</p>

<p style="margin-top: 1em"># ... <br>
env[&rsquo;LINGUAS_FILE&rsquo;] = 1 <br>
env.MOFiles()</p>

<p style="margin-top: 1em">MSVSProject(), env.MSVSProject()
<br>
Builds a Microsoft Visual Studio project file, and by
default builds a solution file as well.</p>

<p style="margin-top: 1em">This builds a Visual Studio
project file, based on the version of Visual Studio that is
configured (either the latest installed version, or the
version specified by <br>
$MSVS_VERSION in the Environment constructor). For Visual
Studio 6, it will generate a .dsp file. For Visual Studio 7
(.NET) and later versions, it will generate a .vcproj <br>
file.</p>

<p style="margin-top: 1em">By default, this also generates
a solution file for the specified project, a .dsw file for
Visual Studio 6 or a .sln file for Visual Studio 7 (.NET).
This behavior may be <br>
disabled by specifying auto_build_solution=0 when you call
MSVSProject, in which case you presumably want to build the
solution file(s) by calling the MSVSSolution Builder <br>
(see below).</p>

<p style="margin-top: 1em">The MSVSProject builder takes
several lists of filenames to be placed into the project
file. These are currently limited to srcs, incs, localincs,
resources, and misc. These <br>
are pretty self-explanatory, but it should be noted that
these lists are added to the $SOURCES construction variable
as strings, NOT as SCons File Nodes. This is because they
<br>
represent file names to be added to the project file, not
the source files used to build the project file.</p>

<p style="margin-top: 1em">The above filename lists are all
optional, although at least one must be specified for the
resulting project file to be non-empty.</p>

<p style="margin-top: 1em">In addition to the above lists
of values, the following values may be specified:</p>

<p style="margin-top: 1em">target <br>
The name of the target .dsp or .vcproj file. The correct
suffix for the version of Visual Studio must be used, but
the $MSVSPROJECTSUFFIX construction variable will be <br>
defined to the correct value (see example below).</p>

<p style="margin-top: 1em">variant <br>
The name of this particular variant. For Visual Studio 7
projects, this can also be a list of variant names. These
are typically things like &quot;Debug&quot; or
&quot;Release&quot;, but <br>
really can be anything you want. For Visual Studio 7
projects, they may also specify a target platform separated
from the variant name by a | (vertical pipe) character: <br>
Debug|Xbox. The default target platform is Win32. Multiple
calls to MSVSProject with different variants are allowed;
all variants will be added to the project file with <br>
their appropriate build targets and sources.</p>

<p style="margin-top: 1em">cmdargs <br>
Additional command line arguments for the different
variants. The number of cmdargs entries must match the
number of variant entries, or be empty (not specified). If
you <br>
give only one, it will automatically be propagated to all
variants.</p>

<p style="margin-top: 1em">buildtarget <br>
An optional string, node, or list of strings or nodes (one
per build variant), to tell the Visual Studio debugger what
output target to use in what build variant. The <br>
number of buildtarget entries must match the number of
variant entries.</p>

<p style="margin-top: 1em">runfile <br>
The name of the file that Visual Studio 7 and later will run
and debug. This appears as the value of the Output field in
the resulting Visual Studio project file. If this <br>
is not specified, the default is the same as the specified
buildtarget value.</p>

<p style="margin-top: 1em">Note that because SCons always
executes its build commands from the directory in which the
SConstruct file is located, if you generate a project file
in a different directory <br>
than the SConstruct directory, users will not be able to
double-click on the file name in compilation error messages
displayed in the Visual Studio console output window. <br>
This can be remedied by adding the Visual C/C++ /FC compiler
option to the $CCFLAGS variable so that the compiler will
print the full path name of any files that cause <br>
compilation errors.</p>

<p style="margin-top: 1em">Example usage:</p>

<p style="margin-top: 1em">barsrcs =
[&rsquo;bar.cpp&rsquo;], <br>
barincs = [&rsquo;bar.h&rsquo;], <br>
barlocalincs = [&rsquo;StdAfx.h&rsquo;] <br>
barresources =
[&rsquo;bar.rc&rsquo;,&rsquo;resource.h&rsquo;] <br>
barmisc = [&rsquo;bar_readme.txt&rsquo;]</p>

<p style="margin-top: 1em">dll = env.SharedLibrary(target =
&rsquo;bar.dll&rsquo;, <br>
source = barsrcs)</p>

<p style="margin-top: 1em">env.MSVSProject(target =
&rsquo;Bar&rsquo; + env[&rsquo;MSVSPROJECTSUFFIX&rsquo;],
<br>
srcs = barsrcs, <br>
incs = barincs, <br>
localincs = barlocalincs, <br>
resources = barresources, <br>
misc = barmisc, <br>
buildtarget = dll, <br>
variant = &rsquo;Release&rsquo;)</p>

<p style="margin-top: 1em">Starting with version 2.4 of
SCons it&rsquo;s also possible to specify the optional
argument DebugSettings, which creates files for debugging
under Visual Studio:</p>

<p style="margin-top: 1em">DebugSettings <br>
A dictionary of debug settings that get written to the
.vcproj.user or the .vcxproj.user file, depending on the
version installed. As it is done for cmdargs (see above),
<br>
you can specify a DebugSettings dictionary per variant. If
you give only one, it will be propagated to all
variants.</p>

<p style="margin-top: 1em">Currently, only Visual Studio
v9.0 and Visual Studio version v11 are implemented, for
other versions no file is generated. To generate the user
file, you just need to add a <br>
DebugSettings dictionary to the environment with the right
parameters for your MSVS version. If the dictionary is
empty, or does not contain any good value, no file will be
<br>
generated.</p>

<p style="margin-top: 1em">Following is a more contrived
example, involving the setup of a project for variants and
DebugSettings:</p>

<p style="margin-top: 1em"># Assuming you store your
defaults in a file <br>
vars = Variables(&rsquo;variables.py&rsquo;) <br>
msvcver = vars.args.get(&rsquo;vc&rsquo;,
&rsquo;9&rsquo;)</p>

<p style="margin-top: 1em"># Check command args to force
one Microsoft Visual Studio version <br>
if msvcver == &rsquo;9&rsquo; or msvcver ==
&rsquo;11&rsquo;: <br>
env = Environment(MSVC_VERSION=msvcver+&rsquo;.0&rsquo;,
MSVC_BATCH=False) <br>
else: <br>
env = Environment()</p>


<p style="margin-top: 1em">AddOption(&rsquo;--userfile&rsquo;,
action=&rsquo;store_true&rsquo;,
dest=&rsquo;userfile&rsquo;, default=False, <br>
help=&quot;Create Visual Studio Project user file&quot;)</p>

<p style="margin-top: 1em"># <br>
# 1. Configure your Debug Setting dictionary with options
you want in the list <br>
# of allowed options, for instance if you want to create a
user file to launch <br>
# a specific application for testing your dll with Microsoft
Visual Studio 2008 (v9): <br>
# <br>
V9DebugSettings = { <br>

&rsquo;Command&rsquo;:&rsquo;c:\myapp\using\thisdll.exe&rsquo;,
<br>
&rsquo;WorkingDirectory&rsquo;:
&rsquo;c:\myapp\using\&rsquo;, <br>
&rsquo;CommandArguments&rsquo;: &rsquo;-p password&rsquo;,
<br>
# &rsquo;Attach&rsquo;:&rsquo;false&rsquo;, <br>
# &rsquo;DebuggerType&rsquo;:&rsquo;3&rsquo;, <br>
# &rsquo;Remote&rsquo;:&rsquo;1&rsquo;, <br>
# &rsquo;RemoteMachine&rsquo;: None, <br>
# &rsquo;RemoteCommand&rsquo;: None, <br>
# &rsquo;HttpUrl&rsquo;: None, <br>
# &rsquo;PDBPath&rsquo;: None, <br>
# &rsquo;SQLDebugging&rsquo;: None, <br>
# &rsquo;Environment&rsquo;: &rsquo;&rsquo;, <br>
# &rsquo;EnvironmentMerge&rsquo;:&rsquo;true&rsquo;, <br>
# &rsquo;DebuggerFlavor&rsquo;: None, <br>
# &rsquo;MPIRunCommand&rsquo;: None, <br>
# &rsquo;MPIRunArguments&rsquo;: None, <br>
# &rsquo;MPIRunWorkingDirectory&rsquo;: None, <br>
# &rsquo;ApplicationCommand&rsquo;: None, <br>
# &rsquo;ApplicationArguments&rsquo;: None, <br>
# &rsquo;ShimCommand&rsquo;: None, <br>
# &rsquo;MPIAcceptMode&rsquo;: None, <br>
# &rsquo;MPIAcceptFilter&rsquo;: None, <br>
}</p>

<p style="margin-top: 1em"># <br>
# 2. Because there are a lot of different options depending
on the Microsoft <br>
# Visual Studio version, if you use more than one version
you have to <br>
# define a dictionary per version, for instance if you want
to create a user <br>
# file to launch a specific application for testing your dll
with Microsoft <br>
# Visual Studio 2012 (v11): <br>
# <br>
V10DebugSettings = { <br>
&rsquo;LocalDebuggerCommand&rsquo;:
&rsquo;c:\myapp\using\thisdll.exe&rsquo;, <br>
&rsquo;LocalDebuggerWorkingDirectory&rsquo;:
&rsquo;c:\myapp\using\&rsquo;, <br>
&rsquo;LocalDebuggerCommandArguments&rsquo;: &rsquo;-p
password&rsquo;, <br>
# &rsquo;LocalDebuggerEnvironment&rsquo;: None, <br>
# &rsquo;DebuggerFlavor&rsquo;:
&rsquo;WindowsLocalDebugger&rsquo;, <br>
# &rsquo;LocalDebuggerAttach&rsquo;: None, <br>
# &rsquo;LocalDebuggerDebuggerType&rsquo;: None, <br>
# &rsquo;LocalDebuggerMergeEnvironment&rsquo;: None, <br>
# &rsquo;LocalDebuggerSQLDebugging&rsquo;: None, <br>
# &rsquo;RemoteDebuggerCommand&rsquo;: None, <br>
# &rsquo;RemoteDebuggerCommandArguments&rsquo;: None, <br>
# &rsquo;RemoteDebuggerWorkingDirectory&rsquo;: None, <br>
# &rsquo;RemoteDebuggerServerName&rsquo;: None, <br>
# &rsquo;RemoteDebuggerConnection&rsquo;: None, <br>
# &rsquo;RemoteDebuggerDebuggerType&rsquo;: None, <br>
# &rsquo;RemoteDebuggerAttach&rsquo;: None, <br>
# &rsquo;RemoteDebuggerSQLDebugging&rsquo;: None, <br>
# &rsquo;DeploymentDirectory&rsquo;: None, <br>
# &rsquo;AdditionalFiles&rsquo;: None, <br>
# &rsquo;RemoteDebuggerDeployDebugCppRuntime&rsquo;: None,
<br>
# &rsquo;WebBrowserDebuggerHttpUrl&rsquo;: None, <br>
# &rsquo;WebBrowserDebuggerDebuggerType&rsquo;: None, <br>
# &rsquo;WebServiceDebuggerHttpUrl&rsquo;: None, <br>
# &rsquo;WebServiceDebuggerDebuggerType&rsquo;: None, <br>
# &rsquo;WebServiceDebuggerSQLDebugging&rsquo;: None, <br>
}</p>

<p style="margin-top: 1em"># <br>
# 3. Select the dictionary you want depending on the version
of visual Studio <br>
# Files you want to generate. <br>
# <br>
if not env.GetOption(&rsquo;userfile&rsquo;): <br>
dbgSettings = None <br>
elif env.get(&rsquo;MSVC_VERSION&rsquo;, None) ==
&rsquo;9.0&rsquo;: <br>
dbgSettings = V9DebugSettings <br>
elif env.get(&rsquo;MSVC_VERSION&rsquo;, None) ==
&rsquo;11.0&rsquo;: <br>
dbgSettings = V10DebugSettings <br>
else: <br>
dbgSettings = None</p>

<p style="margin-top: 1em"># <br>
# 4. Add the dictionary to the DebugSettings keyword. <br>
# <br>
barsrcs = [&rsquo;bar.cpp&rsquo;, &rsquo;dllmain.cpp&rsquo;,
&rsquo;stdafx.cpp&rsquo;] <br>
barincs = [&rsquo;targetver.h&rsquo;] <br>
barlocalincs = [&rsquo;StdAfx.h&rsquo;] <br>
barresources =
[&rsquo;bar.rc&rsquo;,&rsquo;resource.h&rsquo;] <br>
barmisc = [&rsquo;ReadMe.txt&rsquo;]</p>

<p style="margin-top: 1em">dll = env.SharedLibrary(target =
&rsquo;bar.dll&rsquo;, <br>
source = barsrcs)</p>

<p style="margin-top: 1em">env.MSVSProject(target =
&rsquo;Bar&rsquo; + env[&rsquo;MSVSPROJECTSUFFIX&rsquo;],
<br>
srcs = barsrcs, <br>
incs = barincs, <br>
localincs = barlocalincs, <br>
resources = barresources, <br>
misc = barmisc, <br>
buildtarget = [dll[0]] * 2, <br>
variant = (&rsquo;Debug|Win32&rsquo;,
&rsquo;Release|Win32&rsquo;), <br>
cmdargs = &rsquo;vc=%s&rsquo; % msvcver, <br>
DebugSettings = (dbgSettings, {}))</p>

<p style="margin-top: 1em">MSVSSolution(),
env.MSVSSolution() <br>
Builds a Microsoft Visual Studio solution file.</p>

<p style="margin-top: 1em">This builds a Visual Studio
solution file, based on the version of Visual Studio that is
configured (either the latest installed version, or the
version specified by <br>
$MSVS_VERSION in the construction environment). For Visual
Studio 6, it will generate a .dsw file. For Visual Studio 7
(.NET), it will generate a .sln file.</p>

<p style="margin-top: 1em">The following values must be
specified:</p>

<p style="margin-top: 1em">target <br>
The name of the target .dsw or .sln file. The correct suffix
for the version of Visual Studio must be used, but the value
$MSVSSOLUTIONSUFFIX will be defined to the <br>
correct value (see example below).</p>

<p style="margin-top: 1em">variant <br>
The name of this particular variant, or a list of variant
names (the latter is only supported for MSVS 7 solutions).
These are typically things like &quot;Debug&quot; or
&quot;Release&quot;, <br>
but really can be anything you want. For MSVS 7 they may
also specify target platform, like this
&quot;Debug|Xbox&quot;. Default platform is Win32.</p>

<p style="margin-top: 1em">projects <br>
A list of project file names, or Project nodes returned by
calls to the MSVSProject Builder, to be placed into the
solution file. It should be noted that these file names <br>
are NOT added to the $SOURCES environment variable in form
of files, but rather as strings. This is because they
represent file names to be added to the solution file, <br>
not the source files used to build the solution file.</p>

<p style="margin-top: 1em">Example Usage:</p>

<p style="margin-top: 1em">env.MSVSSolution(target =
&rsquo;Bar&rsquo; + env[&rsquo;MSVSSOLUTIONSUFFIX&rsquo;],
projects = [&rsquo;bar&rsquo; <br>
+ env[&rsquo;MSVSPROJECTSUFFIX&rsquo;]], variant =
&rsquo;Release&rsquo;)</p>

<p style="margin-top: 1em">Object(), env.Object() <br>
A synonym for the StaticObject builder method.</p>

<p style="margin-top: 1em">Package(), env.Package() <br>
Builds a Binary Package of the given source files.</p>

<p style="margin-top: 1em">env.Package(source =
FindInstalledFiles())</p>

<p style="margin-top: 1em">Builds software distribution
packages. Packages consist of files to install and packaging
information. The former may be specified with the source
parameter and may be left <br>
out, in which case the FindInstalledFiles function will
collect all files that have an Install or InstallAs Builder
attached. If the target is not specified it will be <br>
deduced from additional information given to this
Builder.</p>

<p style="margin-top: 1em">The packaging information is
specified with the help of construction variables documented
below. This information is called a tag to stress that some
of them can also be <br>
attached to files with the Tag function. The mandatory ones
will complain if they were not specified. They vary
depending on chosen target packager.</p>

<p style="margin-top: 1em">The target packager may be
selected with the &quot;PACKAGETYPE&quot; command line
option or with the $PACKAGETYPE construction variable.
Currently the following packagers available:</p>

<p style="margin-top: 1em">* msi - Microsoft Installer *
rpm - Redhat Package Manger * ipkg - Itsy Package Management
System * tarbz2 - compressed tar * targz - compressed tar *
zip - zip file * <br>
src_tarbz2 - compressed tar source * src_targz - compressed
tar source * src_zip - zip file source</p>

<p style="margin-top: 1em">An updated list is always
available under the &quot;package_type&quot; option when
running &quot;scons --help&quot; on a project that has
packaging activated.</p>

<p style="margin-top: 1em">env =
Environment(tools=[&rsquo;default&rsquo;,
&rsquo;packaging&rsquo;]) <br>
env.Install(&rsquo;/bin/&rsquo;, &rsquo;my_program&rsquo;)
<br>
env.Package( NAME = &rsquo;foo&rsquo;, <br>
VERSION = &rsquo;1.2.3&rsquo;, <br>
PACKAGEVERSION = 0, <br>
PACKAGETYPE = &rsquo;rpm&rsquo;, <br>
LICENSE = &rsquo;gpl&rsquo;, <br>
SUMMARY = &rsquo;balalalalal&rsquo;, <br>
DESCRIPTION = &rsquo;this should be really really
long&rsquo;, <br>
X_RPM_GROUP = &rsquo;Application/fu&rsquo;, <br>
SOURCE_URL = &rsquo;http://foo.org/foo-1.2.3.tar.gz&rsquo;
<br>
)</p>

<p style="margin-top: 1em">PCH(), env.PCH() <br>
Builds a Microsoft Visual C++ precompiled header. Calling
this builder method returns a list of two targets: the PCH
as the first element, and the object file as the second <br>
element. Normally the object file is ignored. This builder
method is only provided when Microsoft Visual C++ is being
used as the compiler. The PCH builder method is <br>
generally used in conjunction with the PCH construction
variable to force object files to use the precompiled
header:</p>

<p style="margin-top: 1em">env[&rsquo;PCH&rsquo;] =
env.PCH(&rsquo;StdAfx.cpp&rsquo;)[0]</p>

<p style="margin-top: 1em">PDF(), env.PDF() <br>
Builds a .pdf file from a .dvi input file (or, by extension,
a .tex, .ltx, or .latex input file). The suffix specified by
the $PDFSUFFIX construction variable (.pdf by <br>
default) is added automatically to the target if it is not
already present. Example:</p>

<p style="margin-top: 1em"># builds from aaa.tex <br>
env.PDF(target = &rsquo;aaa.pdf&rsquo;, source =
&rsquo;aaa.tex&rsquo;) <br>
# builds bbb.pdf from bbb.dvi <br>
env.PDF(target = &rsquo;bbb&rsquo;, source =
&rsquo;bbb.dvi&rsquo;)</p>

<p style="margin-top: 1em">POInit(), env.POInit() <br>
This builder belongs to msginit tool. The builder
initializes missing PO file(s) if $POAUTOINIT is set. If
$POAUTOINIT is not set (default), POInit prints instruction
for <br>
user (that is supposed to be a translator), telling how the
PO file should be initialized. In normal projects you should
not use POInit and use POUpdate instead. POUpdate <br>
chooses intelligently between msgmerge(1) and msginit(1).
POInit always uses msginit(1) and should be regarded as
builder for special purposes or for temporary use (e.g. for
<br>
quick, one time initialization of a bunch of PO files) or
for tests.</p>

<p style="margin-top: 1em">Target nodes defined through
POInit are not built by default (they&rsquo;re Ignored from
&rsquo;.&rsquo; node) but are added to special Alias
(&rsquo;po-create&rsquo; by default). The alias name may be
<br>
changed through the $POCREATE_ALIAS construction variable.
All PO files defined through POInit may be easily
initialized by scons po-create.</p>

<p style="margin-top: 1em">Example 1. Initialize en.po and
pl.po from messages.pot:</p>

<p style="margin-top: 1em"># ... <br>
env.POInit([&rsquo;en&rsquo;, &rsquo;pl&rsquo;]) #
messages.pot --&gt; [en.po, pl.po]</p>

<p style="margin-top: 1em">Example 2. Initialize en.po and
pl.po from foo.pot:</p>

<p style="margin-top: 1em"># ... <br>
env.POInit([&rsquo;en&rsquo;, &rsquo;pl&rsquo;],
[&rsquo;foo&rsquo;]) # foo.pot --&gt; [en.po, pl.po]</p>

<p style="margin-top: 1em">Example 3. Initialize en.po and
pl.po from foo.pot but using $POTDOMAIN construction
variable:</p>

<p style="margin-top: 1em"># ... <br>
env.POInit([&rsquo;en&rsquo;, &rsquo;pl&rsquo;],
POTDOMAIN=&rsquo;foo&rsquo;) # foo.pot --&gt; [en.po,
pl.po]</p>

<p style="margin-top: 1em">Example 4. Initialize PO files
for languages defined in LINGUAS file. The files will be
initialized from template messages.pot:</p>

<p style="margin-top: 1em"># ... <br>
env.POInit(LINGUAS_FILE = 1) # needs &rsquo;LINGUAS&rsquo;
file</p>

<p style="margin-top: 1em">Example 5. Initialize en.po and
pl.pl PO files plus files for languages defined in LINGUAS
file. The files will be initialized from template
messages.pot:</p>

<p style="margin-top: 1em"># ... <br>
env.POInit([&rsquo;en&rsquo;, &rsquo;pl&rsquo;],
LINGUAS_FILE = 1)</p>

<p style="margin-top: 1em">Example 6. You may preconfigure
your environment first, and then initialize PO files:</p>

<p style="margin-top: 1em"># ... <br>
env[&rsquo;POAUTOINIT&rsquo;] = 1 <br>
env[&rsquo;LINGUAS_FILE&rsquo;] = 1 <br>
env[&rsquo;POTDOMAIN&rsquo;] = &rsquo;foo&rsquo; <br>
env.POInit()</p>

<p style="margin-top: 1em">which has same efect as:</p>

<p style="margin-top: 1em"># ... <br>
env.POInit(POAUTOINIT = 1, LINGUAS_FILE = 1, POTDOMAIN =
&rsquo;foo&rsquo;)</p>

<p style="margin-top: 1em">PostScript(), env.PostScript()
<br>
Builds a .ps file from a .dvi input file (or, by extension,
a .tex, .ltx, or .latex input file). The suffix specified by
the $PSSUFFIX construction variable (.ps by default) <br>
is added automatically to the target if it is not already
present. Example:</p>

<p style="margin-top: 1em"># builds from aaa.tex <br>
env.PostScript(target = &rsquo;aaa.ps&rsquo;, source =
&rsquo;aaa.tex&rsquo;) <br>
# builds bbb.ps from bbb.dvi <br>
env.PostScript(target = &rsquo;bbb&rsquo;, source =
&rsquo;bbb.dvi&rsquo;)</p>

<p style="margin-top: 1em">POTUpdate(), env.POTUpdate()
<br>
The builder belongs to xgettext tool. The builder updates
target POT file if exists or creates one if it
doesn&rsquo;t. The node is not built by default (i.e. it is
Ignored from <br>
&rsquo;.&rsquo;), but only on demand (i.e. when given POT
file is required or when special alias is invoked). This
builder adds its targe node (messages.pot, say) to a special
alias <br>
(pot-update by default, see $POTUPDATE_ALIAS) so you can
update/create them easily with scons pot-update. The file is
not written until there is no real change in <br>
internationalized messages (or in comments that enter POT
file).</p>

<p style="margin-top: 1em">Note <br>
You may see xgettext(1) being invoked by the xgettext tool
even if there is no real change in internationalized
messages (so the POT file is not being updated). This <br>
happens every time a source file has changed. In such case
we invoke xgettext(1) and compare its output with the
content of POT file to decide whether the file should be
<br>
updated or not.</p>

<p style="margin-top: 1em">Example 1. Let&rsquo;s create
po/ directory and place following SConstruct script
there:</p>

<p style="margin-top: 1em"># SConstruct in
&rsquo;po/&rsquo; subdir <br>
env = Environment( tools = [&rsquo;default&rsquo;,
&rsquo;xgettext&rsquo;] ) <br>
env.POTUpdate([&rsquo;foo&rsquo;], [&rsquo;../a.cpp&rsquo;,
&rsquo;../b.cpp&rsquo;]) <br>
env.POTUpdate([&rsquo;bar&rsquo;], [&rsquo;../c.cpp&rsquo;,
&rsquo;../d.cpp&rsquo;])</p>

<p style="margin-top: 1em">Then invoke scons few times:</p>

<p style="margin-top: 1em">user@host:$ scons # Does not
create foo.pot nor bar.pot <br>
user@host:$ scons foo.pot # Updates or creates foo.pot <br>
user@host:$ scons pot-update # Updates or creates foo.pot
and bar.pot <br>
user@host:$ scons -c # Does not clean foo.pot nor
bar.pot.</p>

<p style="margin-top: 1em">the results shall be as the
comments above say.</p>

<p style="margin-top: 1em">Example 2. The POTUpdate builder
may be used with no target specified, in which case default
target messages.pot will be used. The default target may
also be overridden by <br>
setting $POTDOMAIN construction variable or providing it as
an override to POTUpdate builder:</p>

<p style="margin-top: 1em"># SConstruct script <br>
env = Environment( tools = [&rsquo;default&rsquo;,
&rsquo;xgettext&rsquo;] ) <br>
env[&rsquo;POTDOMAIN&rsquo;] = &quot;foo&quot; <br>
env.POTUpdate(source = [&quot;a.cpp&quot;,
&quot;b.cpp&quot;]) # Creates foo.pot ... <br>
env.POTUpdate(POTDOMAIN = &quot;bar&quot;, source =
[&quot;c.cpp&quot;, &quot;d.cpp&quot;]) # and bar.pot</p>

<p style="margin-top: 1em">Example 3. The sources may be
specified within separate file, for example POTFILES.in:</p>

<p style="margin-top: 1em"># POTFILES.in in
&rsquo;po/&rsquo; subdirectory <br>
../a.cpp <br>
../b.cpp <br>
# end of file</p>

<p style="margin-top: 1em">The name of the file
(POTFILES.in) containing the list of sources is provided via
$XGETTEXTFROM:</p>

<p style="margin-top: 1em"># SConstruct file in
&rsquo;po/&rsquo; subdirectory <br>
env = Environment( tools = [&rsquo;default&rsquo;,
&rsquo;xgettext&rsquo;] ) <br>
env.POTUpdate(XGETTEXTFROM = &rsquo;POTFILES.in&rsquo;)</p>

<p style="margin-top: 1em">Example 4. You may use
$XGETTEXTPATH to define source search path. Assume, for
example, that you have files a.cpp, b.cpp, po/SConstruct,
po/POTFILES.in. Then your <br>
POT-related files could look as below:</p>

<p style="margin-top: 1em"># POTFILES.in in
&rsquo;po/&rsquo; subdirectory <br>
a.cpp <br>
b.cpp <br>
# end of file</p>

<p style="margin-top: 1em"># SConstruct file in
&rsquo;po/&rsquo; subdirectory <br>
env = Environment( tools = [&rsquo;default&rsquo;,
&rsquo;xgettext&rsquo;] ) <br>
env.POTUpdate(XGETTEXTFROM = &rsquo;POTFILES.in&rsquo;,
XGETTEXTPATH=&rsquo;../&rsquo;)</p>

<p style="margin-top: 1em">Example 5. Multiple search
directories may be defined within a list, i.e. XGETTEXTPATH
= [&rsquo;dir1&rsquo;, &rsquo;dir2&rsquo;, ...]. The order
in the list determines the search order of source <br>
files. The path to the first file found is used.</p>

<p style="margin-top: 1em">Let&rsquo;s create
0/1/po/SConstruct script:</p>

<p style="margin-top: 1em"># SConstruct file in
&rsquo;0/1/po/&rsquo; subdirectory <br>
env = Environment( tools = [&rsquo;default&rsquo;,
&rsquo;xgettext&rsquo;] ) <br>
env.POTUpdate(XGETTEXTFROM = &rsquo;POTFILES.in&rsquo;,
XGETTEXTPATH=[&rsquo;../&rsquo;, &rsquo;../../&rsquo;])</p>

<p style="margin-top: 1em">and 0/1/po/POTFILES.in:</p>

<p style="margin-top: 1em"># POTFILES.in in
&rsquo;0/1/po/&rsquo; subdirectory <br>
a.cpp <br>
# end of file</p>

<p style="margin-top: 1em">Write two *.cpp files, the first
one is 0/a.cpp:</p>

<p style="margin-top: 1em">/* 0/a.cpp */ <br>
gettext(&quot;Hello from ../../a.cpp&quot;)</p>

<p style="margin-top: 1em">and the second is 0/1/a.cpp:</p>

<p style="margin-top: 1em">/* 0/1/a.cpp */ <br>
gettext(&quot;Hello from ../a.cpp&quot;)</p>

<p style="margin-top: 1em">then run scons. You&rsquo;ll
obtain 0/1/po/messages.pot with the message &quot;Hello from
../a.cpp&quot;. When you reverse order in $XGETTEXTFOM, i.e.
when you write SConscript as</p>

<p style="margin-top: 1em"># SConstruct file in
&rsquo;0/1/po/&rsquo; subdirectory <br>
env = Environment( tools = [&rsquo;default&rsquo;,
&rsquo;xgettext&rsquo;] ) <br>
env.POTUpdate(XGETTEXTFROM = &rsquo;POTFILES.in&rsquo;,
XGETTEXTPATH=[&rsquo;../../&rsquo;, &rsquo;../&rsquo;])</p>

<p style="margin-top: 1em">then the messages.pot will
contain msgid &quot;Hello from ../../a.cpp&quot; line and
not msgid &quot;Hello from ../a.cpp&quot;.</p>

<p style="margin-top: 1em">POUpdate(), env.POUpdate() <br>
The builder belongs to msgmerge tool. The builder updates PO
files with msgmerge(1), or initializes missing PO files as
described in documentation of msginit tool and POInit <br>
builder (see also $POAUTOINIT). Note, that POUpdate does not
add its targets to po-create alias as POInit does.</p>

<p style="margin-top: 1em">Target nodes defined through
POUpdate are not built by default (they&rsquo;re Ignored
from &rsquo;.&rsquo; node). Instead, they are added
automatically to special Alias (&rsquo;po-update&rsquo; by
<br>
default). The alias name may be changed through the
$POUPDATE_ALIAS construction variable. You can easily update
PO files in your project by scons po-update.</p>

<p style="margin-top: 1em">Example 1. Update en.po and
pl.po from messages.pot template (see also $POTDOMAIN),
assuming that the later one exists or there is rule to build
it (see POTUpdate):</p>

<p style="margin-top: 1em"># ... <br>
env.POUpdate([&rsquo;en&rsquo;,&rsquo;pl&rsquo;]) #
messages.pot --&gt; [en.po, pl.po]</p>

<p style="margin-top: 1em">Example 2. Update en.po and
pl.po from foo.pot template:</p>

<p style="margin-top: 1em"># ... <br>
env.POUpdate([&rsquo;en&rsquo;, &rsquo;pl&rsquo;],
[&rsquo;foo&rsquo;]) # foo.pot --&gt; [en.po, pl.pl]</p>

<p style="margin-top: 1em">Example 3. Update en.po and
pl.po from foo.pot (another version):</p>

<p style="margin-top: 1em"># ... <br>
env.POUpdate([&rsquo;en&rsquo;, &rsquo;pl&rsquo;],
POTDOMAIN=&rsquo;foo&rsquo;) # foo.pot -- &gt; [en.po,
pl.pl]</p>

<p style="margin-top: 1em">Example 4. Update files for
languages defined in LINGUAS file. The files are updated
from messages.pot template:</p>

<p style="margin-top: 1em"># ... <br>
env.POUpdate(LINGUAS_FILE = 1) # needs &rsquo;LINGUAS&rsquo;
file</p>

<p style="margin-top: 1em">Example 5. Same as above, but
update from foo.pot template:</p>

<p style="margin-top: 1em"># ... <br>
env.POUpdate(LINGUAS_FILE = 1, source =
[&rsquo;foo&rsquo;])</p>

<p style="margin-top: 1em">Example 6. Update en.po and
pl.po plus files for languages defined in LINGUAS file. The
files are updated from messages.pot template:</p>

<p style="margin-top: 1em"># produce &rsquo;en.po&rsquo;,
&rsquo;pl.po&rsquo; + files defined in
&rsquo;LINGUAS&rsquo;: <br>
env.POUpdate([&rsquo;en&rsquo;, &rsquo;pl&rsquo; ],
LINGUAS_FILE = 1)</p>

<p style="margin-top: 1em">Example 7. Use $POAUTOINIT to
automatically initialize PO file if it doesn&rsquo;t
exist:</p>

<p style="margin-top: 1em"># ... <br>
env.POUpdate(LINGUAS_FILE = 1, POAUTOINIT = 1)</p>

<p style="margin-top: 1em">Example 8. Update PO files for
languages defined in LINGUAS file. The files are updated
from foo.pot template. All necessary settings are
pre-configured via environment.</p>

<p style="margin-top: 1em"># ... <br>
env[&rsquo;POAUTOINIT&rsquo;] = 1 <br>
env[&rsquo;LINGUAS_FILE&rsquo;] = 1 <br>
env[&rsquo;POTDOMAIN&rsquo;] = &rsquo;foo&rsquo; <br>
env.POUpdate()</p>

<p style="margin-top: 1em">Program(), env.Program() <br>
Builds an executable given one or more object files or C,
C++, D, or Fortran source files. If any C, C++, D or Fortran
source files are specified, then they will be <br>
automatically compiled to object files using the Object
builder method; see that builder method&rsquo;s description
for a list of legal source file suffixes and how they are
<br>
interpreted. The target executable file prefix (specified by
the $PROGPREFIX construction variable; nothing by default)
and suffix (specified by the $PROGSUFFIX construction <br>
variable; by default, .exe on Windows systems, nothing on
POSIX systems) are automatically added to the target if not
already present. Example:</p>

<p style="margin-top: 1em">env.Program(target =
&rsquo;foo&rsquo;, source = [&rsquo;foo.o&rsquo;,
&rsquo;bar.c&rsquo;, &rsquo;baz.f&rsquo;])</p>

<p style="margin-top: 1em">RES(), env.RES() <br>
Builds a Microsoft Visual C++ resource file. This builder
method is only provided when Microsoft Visual C++ or MinGW
is being used as the compiler. The .res (or .o for MinGW)
<br>
suffix is added to the target name if no other suffix is
given. The source file is scanned for implicit dependencies
as though it were a C file. Example:</p>


<p style="margin-top: 1em">env.RES(&rsquo;resource.rc&rsquo;)</p>

<p style="margin-top: 1em">RMIC(), env.RMIC() <br>
Builds stub and skeleton class files for remote objects from
Java .class files. The target is a directory relative to
which the stub and skeleton class files will be written.
<br>
The source can be the names of .class files, or the objects
return from the Java builder method.</p>

<p style="margin-top: 1em">If the construction variable
$JAVACLASSDIR is set, either in the environment or in the
call to the RMIC builder method itself, then the value of
the variable will be stripped <br>
from the beginning of any .class file names.</p>

<p style="margin-top: 1em">classes = env.Java(target =
&rsquo;classdir&rsquo;, source = &rsquo;src&rsquo;) <br>
env.RMIC(target = &rsquo;outdir1&rsquo;, source =
classes)</p>

<p style="margin-top: 1em">env.RMIC(target =
&rsquo;outdir2&rsquo;, <br>
source = [&rsquo;package/foo.class&rsquo;,
&rsquo;package/bar.class&rsquo;])</p>

<p style="margin-top: 1em">env.RMIC(target =
&rsquo;outdir3&rsquo;, <br>
source = [&rsquo;classes/foo.class&rsquo;,
&rsquo;classes/bar.class&rsquo;], <br>
JAVACLASSDIR = &rsquo;classes&rsquo;)</p>

<p style="margin-top: 1em">RPCGenClient(),
env.RPCGenClient() <br>
Generates an RPC client stub (_clnt.c) file from a specified
RPC (.x) source file. Because rpcgen only builds output
files in the local directory, the command will be <br>
executed in the source file&rsquo;s directory by
default.</p>

<p style="margin-top: 1em"># Builds src/rpcif_clnt.c <br>
env.RPCGenClient(&rsquo;src/rpcif.x&rsquo;)</p>

<p style="margin-top: 1em">RPCGenHeader(),
env.RPCGenHeader() <br>
Generates an RPC header (.h) file from a specified RPC (.x)
source file. Because rpcgen only builds output files in the
local directory, the command will be executed in the <br>
source file&rsquo;s directory by default.</p>

<p style="margin-top: 1em"># Builds src/rpcif.h <br>
env.RPCGenHeader(&rsquo;src/rpcif.x&rsquo;)</p>

<p style="margin-top: 1em">RPCGenService(),
env.RPCGenService() <br>
Generates an RPC server-skeleton (_svc.c) file from a
specified RPC (.x) source file. Because rpcgen only builds
output files in the local directory, the command will be
<br>
executed in the source file&rsquo;s directory by
default.</p>

<p style="margin-top: 1em"># Builds src/rpcif_svc.c <br>
env.RPCGenClient(&rsquo;src/rpcif.x&rsquo;)</p>

<p style="margin-top: 1em">RPCGenXDR(), env.RPCGenXDR()
<br>
Generates an RPC XDR routine (_xdr.c) file from a specified
RPC (.x) source file. Because rpcgen only builds output
files in the local directory, the command will be executed
<br>
in the source file&rsquo;s directory by default.</p>

<p style="margin-top: 1em"># Builds src/rpcif_xdr.c <br>
env.RPCGenClient(&rsquo;src/rpcif.x&rsquo;)</p>

<p style="margin-top: 1em">SharedLibrary(),
env.SharedLibrary() <br>
Builds a shared library (.so on a POSIX system, .dll on
Windows) given one or more object files or C, C++, D or
Fortran source files. If any source files are given, then
they <br>
will be automatically compiled to object files. The static
library prefix and suffix (if any) are automatically added
to the target. The target library file prefix (specified
<br>
by the $SHLIBPREFIX construction variable; by default, lib
on POSIX systems, nothing on Windows systems) and suffix
(specified by the $SHLIBSUFFIX construction variable; by
<br>
default, .dll on Windows systems, .so on POSIX systems) are
automatically added to the target if not already present.
Example:</p>

<p style="margin-top: 1em">env.SharedLibrary(target =
&rsquo;bar&rsquo;, source = [&rsquo;bar.c&rsquo;,
&rsquo;foo.o&rsquo;])</p>

<p style="margin-top: 1em">On Windows systems, the
SharedLibrary builder method will always build an import
(.lib) library in addition to the shared (.dll) library,
adding a .lib library with the same <br>
basename if there is not already a .lib file explicitly
listed in the targets.</p>

<p style="margin-top: 1em">On Cygwin systems, the
SharedLibrary builder method will always build an import
(.dll.a) library in addition to the shared (.dll) library,
adding a .dll.a library with the <br>
same basename if there is not already a .dll.a file
explicitly listed in the targets.</p>

<p style="margin-top: 1em">Any object files listed in the
source must have been built for a shared library (that is,
using the SharedObject builder method). scons will raise an
error if there is any <br>
mismatch.</p>

<p style="margin-top: 1em">On some platforms, there is a
distinction between a shared library (loaded automatically
by the system to resolve external references) and a loadable
module (explicitly <br>
loaded by user action). For maximum portability, use the
LoadableModule builder for the latter.</p>

<p style="margin-top: 1em">When the $SHLIBVERSION
construction variable is defined a versioned shared library
is created. This modifies the $SHLINKFLAGS as required, adds
the version number to the <br>
library name, and creates the symlinks that are needed.</p>

<p style="margin-top: 1em">env.SharedLibrary(target =
&rsquo;bar&rsquo;, source = [&rsquo;bar.c&rsquo;,
&rsquo;foo.o&rsquo;], SHLIBVERSION=&rsquo;1.5.2&rsquo;)</p>

<p style="margin-top: 1em">On a POSIX system, versions with
a single token create exactly one symlink: libbar.so.6 would
have symlinks libbar.so only. On a POSIX system, versions
with two or more <br>
tokens create exactly two symlinks: libbar.so.2.3.1 would
have symlinks libbar.so and libbar.so.2; on a Darwin (OSX)
system the library would be libbar.2.3.1.dylib and the <br>
link would be libbar.dylib.</p>

<p style="margin-top: 1em">On Windows systems, specifying
register=1 will cause the .dll to be registered after it is
built using REGSVR32. The command that is run
(&quot;regsvr32&quot; by default) is determined <br>
by $REGSVR construction variable, and the flags passed are
determined by $REGSVRFLAGS. By default, $REGSVRFLAGS
includes the /s option, to prevent dialogs from popping up
and <br>
requiring user attention when it is run. If you change
$REGSVRFLAGS, be sure to include the /s option. For
example,</p>

<p style="margin-top: 1em">env.SharedLibrary(target =
&rsquo;bar&rsquo;, <br>
source = [&rsquo;bar.cxx&rsquo;, &rsquo;foo.obj&rsquo;],
<br>
register=1)</p>

<p style="margin-top: 1em">will register bar.dll as a COM
object when it is done linking it.</p>

<p style="margin-top: 1em">SharedObject(),
env.SharedObject() <br>
Builds an object file for inclusion in a shared library.
Source files must have one of the same set of extensions
specified above for the StaticObject builder method. On some
<br>
platforms building a shared object requires additional
compiler option (e.g. -fPIC for gcc) in addition to those
needed to build a normal (static) object, but on some <br>
platforms there is no difference between a shared object and
a normal (static) one. When there is a difference, SCons
will only allow shared objects to be linked into a <br>
shared library, and will use a different suffix for shared
objects. On platforms where there is no difference, SCons
will allow both normal (static) and shared objects to be
<br>
linked into a shared library, and will use the same suffix
for shared and normal (static) objects. The target object
file prefix (specified by the $SHOBJPREFIX construction <br>
variable; by default, the same as $OBJPREFIX) and suffix
(specified by the $SHOBJSUFFIX construction variable) are
automatically added to the target if not already present.
<br>
Examples:</p>

<p style="margin-top: 1em">env.SharedObject(target =
&rsquo;ddd&rsquo;, source = &rsquo;ddd.c&rsquo;) <br>
env.SharedObject(target = &rsquo;eee.o&rsquo;, source =
&rsquo;eee.cpp&rsquo;) <br>
env.SharedObject(target = &rsquo;fff.obj&rsquo;, source =
&rsquo;fff.for&rsquo;)</p>

<p style="margin-top: 1em">Note that the source files will
be scanned according to the suffix mappings in the
SourceFileScanner object. See the section &quot;Scanner
Objects,&quot; below, for more information.</p>

<p style="margin-top: 1em">StaticLibrary(),
env.StaticLibrary() <br>
Builds a static library given one or more object files or C,
C++, D or Fortran source files. If any source files are
given, then they will be automatically compiled to object
<br>
files. The static library prefix and suffix (if any) are
automatically added to the target. The target library file
prefix (specified by the $LIBPREFIX construction variable;
<br>
by default, lib on POSIX systems, nothing on Windows
systems) and suffix (specified by the $LIBSUFFIX
construction variable; by default, .lib on Windows systems,
.a on POSIX <br>
systems) are automatically added to the target if not
already present. Example:</p>

<p style="margin-top: 1em">env.StaticLibrary(target =
&rsquo;bar&rsquo;, source = [&rsquo;bar.c&rsquo;,
&rsquo;foo.o&rsquo;])</p>

<p style="margin-top: 1em">Any object files listed in the
source must have been built for a static library (that is,
using the StaticObject builder method). scons will raise an
error if there is any <br>
mismatch.</p>

<p style="margin-top: 1em">StaticObject(),
env.StaticObject() <br>
Builds a static object file from one or more C, C++, D, or
Fortran source files. Source files must have one of the
following extensions:</p>

<p style="margin-top: 1em">.asm assembly language file <br>
.ASM assembly language file <br>
.c C file <br>
.C Windows: C file <br>
POSIX: C++ file <br>
.cc C++ file <br>
.cpp C++ file <br>
.cxx C++ file <br>
.cxx C++ file <br>
.c++ C++ file <br>
.C++ C++ file <br>
.d D file <br>
.f Fortran file <br>
.F Windows: Fortran file <br>
POSIX: Fortran file + C pre-processor <br>
.for Fortran file <br>
.FOR Fortran file <br>
.fpp Fortran file + C pre-processor <br>
.FPP Fortran file + C pre-processor <br>
.m Object C file <br>
.mm Object C++ file <br>
.s assembly language file <br>
.S Windows: assembly language file <br>
ARM: CodeSourcery Sourcery Lite <br>
.sx assembly language file + C pre-processor <br>
POSIX: assembly language file + C pre-processor <br>
.spp assembly language file + C pre-processor <br>
.SPP assembly language file + C pre-processor</p>

<p style="margin-top: 1em">The target object file prefix
(specified by the $OBJPREFIX construction variable; nothing
by default) and suffix (specified by the $OBJSUFFIX
construction variable; .obj on <br>
Windows systems, .o on POSIX systems) are automatically
added to the target if not already present. Examples:</p>

<p style="margin-top: 1em">env.StaticObject(target =
&rsquo;aaa&rsquo;, source = &rsquo;aaa.c&rsquo;) <br>
env.StaticObject(target = &rsquo;bbb.o&rsquo;, source =
&rsquo;bbb.c++&rsquo;) <br>
env.StaticObject(target = &rsquo;ccc.obj&rsquo;, source =
&rsquo;ccc.f&rsquo;)</p>

<p style="margin-top: 1em">Note that the source files will
be scanned according to the suffix mappings in
SourceFileScanner object. See the section &quot;Scanner
Objects,&quot; below, for more information.</p>

<p style="margin-top: 1em">Substfile(), env.Substfile()
<br>
The Substfile builder creates a single text file from
another file or set of files by concatenating them with
$LINESEPARATOR and replacing text using the $SUBST_DICT <br>
construction variable. Nested lists of source files are
flattened. See also Textfile.</p>

<p style="margin-top: 1em">If a single source file is
present with an .in suffix, the suffix is stripped and the
remainder is used as the default target name.</p>

<p style="margin-top: 1em">The prefix and suffix specified
by the $SUBSTFILEPREFIX and $SUBSTFILESUFFIX construction
variables (the null string by default in both cases) are
automatically added to the <br>
target if they are not already present.</p>

<p style="margin-top: 1em">If a construction variable named
$SUBST_DICT is present, it may be either a Python dictionary
or a sequence of (key,value) tuples. If it is a dictionary
it is converted into <br>
a list of tuples in an arbitrary order, so if one key is a
prefix of another key or if one substitution could be
further expanded by another subsitition, it is unpredictable
<br>
whether the expansion will occur.</p>

<p style="margin-top: 1em">Any occurrences of a key in the
source are replaced by the corresponding value, which may be
a Python callable function or a string. If the value is a
callable, it is called <br>
with no arguments to get a string. Strings are
subst-expanded and the result replaces the key.</p>

<p style="margin-top: 1em">env = Environment(tools =
[&rsquo;default&rsquo;, &rsquo;textfile&rsquo;])</p>

<p style="margin-top: 1em">env[&rsquo;prefix&rsquo;] =
&rsquo;/usr/bin&rsquo; <br>
script_dict = {&rsquo;@prefix@&rsquo;: &rsquo;/bin&rsquo;,
@exec_prefix@: &rsquo;$prefix&rsquo;} <br>
env.Substfile(&rsquo;script.in&rsquo;, SUBST_DICT =
script_dict)</p>

<p style="margin-top: 1em">conf_dict =
{&rsquo;%VERSION%&rsquo;: &rsquo;1.2.3&rsquo;,
&rsquo;%BASE%&rsquo;: &rsquo;MyProg&rsquo;} <br>
env.Substfile(&rsquo;config.h.in&rsquo;, conf_dict,
SUBST_DICT = conf_dict)</p>

<p style="margin-top: 1em"># UNPREDICTABLE - one key is a
prefix of another <br>
bad_foo = {&rsquo;$foo&rsquo;: &rsquo;$foo&rsquo;,
&rsquo;$foobar&rsquo;: &rsquo;$foobar&rsquo;} <br>
env.Substfile(&rsquo;foo.in&rsquo;, SUBST_DICT =
bad_foo)</p>

<p style="margin-top: 1em"># PREDICTABLE - keys are applied
longest first <br>
good_foo = [(&rsquo;$foobar&rsquo;, &rsquo;$foobar&rsquo;),
(&rsquo;$foo&rsquo;, &rsquo;$foo&rsquo;)] <br>
env.Substfile(&rsquo;foo.in&rsquo;, SUBST_DICT =
good_foo)</p>

<p style="margin-top: 1em"># UNPREDICTABLE - one
substitution could be futher expanded <br>
bad_bar = {&rsquo;@bar@&rsquo;: &rsquo;@soap@&rsquo;,
&rsquo;@soap@&rsquo;: &rsquo;lye&rsquo;} <br>
env.Substfile(&rsquo;bar.in&rsquo;, SUBST_DICT =
bad_bar)</p>

<p style="margin-top: 1em"># PREDICTABLE - substitutions
are expanded in order <br>
good_bar = ((&rsquo;@bar@&rsquo;, &rsquo;@soap@&rsquo;),
(&rsquo;@soap@&rsquo;, &rsquo;lye&rsquo;)) <br>
env.Substfile(&rsquo;bar.in&rsquo;, SUBST_DICT =
good_bar)</p>

<p style="margin-top: 1em"># the SUBST_DICT may be in
common (and not an override) <br>
substutions = {} <br>
subst = Environment(tools = [&rsquo;textfile&rsquo;],
SUBST_DICT = substitutions) <br>
substitutions[&rsquo;@foo@&rsquo;] = &rsquo;foo&rsquo; <br>
subst[&rsquo;SUBST_DICT&rsquo;][&rsquo;@bar@&rsquo;] =
&rsquo;bar&rsquo; <br>
subst.Substfile(&rsquo;pgm1.c&rsquo;, [Value(&rsquo;#include
&quot;@foo@.h&quot;&rsquo;), <br>
Value(&rsquo;#include &quot;@bar@.h&quot;&rsquo;), <br>
&quot;common.in&quot;, <br>
&quot;pgm1.in&quot; <br>
]) <br>
subst.Substfile(&rsquo;pgm2.c&rsquo;, [Value(&rsquo;#include
&quot;@foo@.h&quot;&rsquo;), <br>
Value(&rsquo;#include &quot;@bar@.h&quot;&rsquo;), <br>
&quot;common.in&quot;, <br>
&quot;pgm2.in&quot; <br>
])</p>

<p style="margin-top: 1em">Tar(), env.Tar() <br>
Builds a tar archive of the specified files and/or
directories. Unlike most builder methods, the Tar builder
method may be called multiple times for a given target; each
<br>
additional call adds to the list of entries that will be
built into the archive. Any source directories will be
scanned for changes to any on-disk files, regardless of <br>
whether or not scons knows about them from other Builder or
function calls.</p>

<p style="margin-top: 1em">env.Tar(&rsquo;src.tar&rsquo;,
&rsquo;src&rsquo;)</p>

<p style="margin-top: 1em"># Create the stuff.tar file.
<br>
env.Tar(&rsquo;stuff&rsquo;, [&rsquo;subdir1&rsquo;,
&rsquo;subdir2&rsquo;]) <br>
# Also add &quot;another&quot; to the stuff.tar file. <br>
env.Tar(&rsquo;stuff&rsquo;, &rsquo;another&rsquo;)</p>

<p style="margin-top: 1em"># Set TARFLAGS to create a
gzip-filtered archive. <br>
env = Environment(TARFLAGS = &rsquo;-c -z&rsquo;) <br>
env.Tar(&rsquo;foo.tar.gz&rsquo;, &rsquo;foo&rsquo;)</p>

<p style="margin-top: 1em"># Also set the suffix to .tgz.
<br>
env = Environment(TARFLAGS = &rsquo;-c -z&rsquo;, <br>
TARSUFFIX = &rsquo;.tgz&rsquo;) <br>
env.Tar(&rsquo;foo&rsquo;)</p>

<p style="margin-top: 1em">Textfile(), env.Textfile() <br>
The Textfile builder generates a single text file. The
source strings constitute the lines; nested lists of sources
are flattened. $LINESEPARATOR is used to separate the <br>
strings.</p>

<p style="margin-top: 1em">If present, the $SUBST_DICT
construction variable is used to modify the strings before
they are written; see the Substfile description for
details.</p>

<p style="margin-top: 1em">The prefix and suffix specified
by the $TEXTFILEPREFIX and $TEXTFILESUFFIX construction
variables (the null string and .txt by default,
respectively) are automatically added <br>
to the target if they are not already present. Examples:</p>

<p style="margin-top: 1em"># builds/writes foo.txt <br>
env.Textfile(target = &rsquo;foo.txt&rsquo;, source =
[&rsquo;Goethe&rsquo;, 42, &rsquo;Schiller&rsquo;])</p>

<p style="margin-top: 1em"># builds/writes bar.txt <br>
env.Textfile(target = &rsquo;bar&rsquo;, <br>
source = [&rsquo;lalala&rsquo;, &rsquo;tanteratei&rsquo;],
<br>
LINESEPARATOR=&rsquo;|*&rsquo;)</p>

<p style="margin-top: 1em"># nested lists are flattened
automatically <br>
env.Textfile(target = &rsquo;blob&rsquo;, <br>
source = [&rsquo;lalala&rsquo;, [&rsquo;Goethe&rsquo;, 42
&rsquo;Schiller&rsquo;], &rsquo;tanteratei&rsquo;])</p>

<p style="margin-top: 1em"># files may be used as input by
wraping them in File() <br>
env.Textfile(target = &rsquo;concat&rsquo;, # concatenate
files with a marker between <br>
source = [File(&rsquo;concat1&rsquo;),
File(&rsquo;concat2&rsquo;)], <br>
LINESEPARATOR = &rsquo;====================0)</p>

<p style="margin-top: 1em">Results are: <br>
foo.txt <br>
....8&lt;---- <br>
Goethe <br>
42 <br>
Schiller <br>
....8&lt;---- (no linefeed at the end)</p>

<p style="margin-top: 1em">bar.txt: <br>
....8&lt;---- <br>
lalala|*tanteratei <br>
....8&lt;---- (no linefeed at the end)</p>

<p style="margin-top: 1em">blob.txt <br>
....8&lt;---- <br>
lalala <br>
Goethe <br>
42 <br>
Schiller <br>
tanteratei <br>
....8&lt;---- (no linefeed at the end)</p>

<p style="margin-top: 1em">Translate(), env.Translate()
<br>
This pseudo-builder belongs to gettext toolset. The builder
extracts internationalized messages from source files,
updates POT template (if necessary) and then updates PO <br>
translations (if necessary). If $POAUTOINIT is set, missing
PO files will be automatically created (i.e. without
translator person intervention). The variables $LINGUAS_FILE
<br>
and $POTDOMAIN are taken into acount too. All other
construction variables used by POTUpdate, and POUpdate work
here too.</p>

<p style="margin-top: 1em">Example 1. The simplest way is
to specify input files and output languages inline in a
SCons script when invoking Translate</p>

<p style="margin-top: 1em"># SConscript in
&rsquo;po/&rsquo; directory <br>
env = Environment( tools = [&quot;default&quot;,
&quot;gettext&quot;] ) <br>
env[&rsquo;POAUTOINIT&rsquo;] = 1 <br>
env.Translate([&rsquo;en&rsquo;,&rsquo;pl&rsquo;],
[&rsquo;../a.cpp&rsquo;,&rsquo;../b.cpp&rsquo;])</p>

<p style="margin-top: 1em">Example 2. If you wish, you may
also stick to conventional style known from autotools, i.e.
using POTFILES.in and LINGUAS files</p>

<p style="margin-top: 1em"># LINGUAS <br>
en pl <br>
#end</p>

<p style="margin-top: 1em"># POTFILES.in <br>
a.cpp <br>
b.cpp <br>
# end</p>

<p style="margin-top: 1em"># SConscript <br>
env = Environment( tools = [&quot;default&quot;,
&quot;gettext&quot;] ) <br>
env[&rsquo;POAUTOINIT&rsquo;] = 1 <br>
env[&rsquo;XGETTEXTPATH&rsquo;] = [&rsquo;../&rsquo;] <br>
env.Translate(LINGUAS_FILE = 1, XGETTEXTFROM =
&rsquo;POTFILES.in&rsquo;)</p>

<p style="margin-top: 1em">The last approach is perhaps the
recommended one. It allows easily split
internationalization/localization onto separate SCons
scripts, where a script in source tree is <br>
responsible for translations (from sources to PO files) and
script(s) under variant directories are responsible for
compilation of PO to MO files to and for installation of
<br>
MO files. The &quot;gluing factor&quot; synchronizing these
two scripts is then the content of LINGUAS file. Note, that
the updated POT and PO files are usually going to be
committed <br>
back to the repository, so they must be updated within the
source directory (and not in variant directories).
Additionaly, the file listing of po/ directory contains
LINGUAS <br>
file, so the source tree looks familiar to translators, and
they may work with the project in their usual way.</p>

<p style="margin-top: 1em">Example 3. Let&rsquo;s prepare a
development tree as below</p>

<p style="margin-top: 1em">project/ <br>
+ SConstruct <br>
+ build/ <br>
+ src/ <br>
+ po/ <br>
+ SConscript <br>
+ SConscript.i18n <br>
+ POTFILES.in <br>
+ LINGUAS</p>

<p style="margin-top: 1em">with build being variant
directory. Write the top-level SConstruct script as
follows</p>

<p style="margin-top: 1em"># SConstruct <br>
env = Environment( tools = [&quot;default&quot;,
&quot;gettext&quot;] ) <br>
VariantDir(&rsquo;build&rsquo;, &rsquo;src&rsquo;, duplicate
= 0) <br>
env[&rsquo;POAUTOINIT&rsquo;] = 1 <br>
SConscript(&rsquo;src/po/SConscript.i18n&rsquo;, exports =
&rsquo;env&rsquo;) <br>
SConscript(&rsquo;build/po/SConscript&rsquo;, exports =
&rsquo;env&rsquo;)</p>

<p style="margin-top: 1em">the src/po/SConscript.i18n
as</p>

<p style="margin-top: 1em"># src/po/SConscript.i18n <br>
Import(&rsquo;env&rsquo;) <br>
env.Translate(LINGUAS_FILE=1,
XGETTEXTFROM=&rsquo;POTFILES.in&rsquo;,
XGETTEXTPATH=[&rsquo;../&rsquo;])</p>

<p style="margin-top: 1em">and the src/po/SConscript</p>

<p style="margin-top: 1em"># src/po/SConscript <br>
Import(&rsquo;env&rsquo;) <br>
env.MOFiles(LINGUAS_FILE = 1)</p>

<p style="margin-top: 1em">Such setup produces POT and PO
files under source tree in src/po/ and binary MO files under
variant tree in build/po/. This way the POT and PO files are
separated from other <br>
output files, which must not be committed back to source
repositories (e.g. MO files).</p>

<p style="margin-top: 1em">Note <br>
In above example, the PO files are not updated, nor created
automatically when you issue scons &rsquo;.&rsquo; command.
The files must be updated (created) by hand via scons <br>
po-update and then MO files can be compiled by running scons
&rsquo;.&rsquo;.</p>

<p style="margin-top: 1em">TypeLibrary(), env.TypeLibrary()
<br>
Builds a Windows type library (.tlb) file from an input IDL
file (.idl). In addition, it will build the associated
interface stub and proxy source files, naming them <br>
according to the base name of the .idl file. For
example,</p>


<p style="margin-top: 1em">env.TypeLibrary(source=&quot;foo.idl&quot;)</p>

<p style="margin-top: 1em">Will create foo.tlb, foo.h,
foo_i.c, foo_p.c and foo_data.c files.</p>

<p style="margin-top: 1em">Uic(), env.Uic() <br>
Builds a header file, an implementation file and a moc file
from an ui file. and returns the corresponding nodes in the
above order. This builder is only available after <br>
using the tool &rsquo;qt&rsquo;. Note: you can specify .ui
files directly as source files to the Program, Library and
SharedLibrary builders without using this builder. Using
this <br>
builder lets you override the standard naming conventions
(be careful: prefixes are always prepended to names of built
files; if you don&rsquo;t want prefixes, you may set them to
<br>
&lsquo;&lsquo;). See the $QTDIR variable for more
information. Example:</p>

<p style="margin-top: 1em">env.Uic(&rsquo;foo.ui&rsquo;) #
-&gt; [&rsquo;foo.h&rsquo;, &rsquo;uic_foo.cc&rsquo;,
&rsquo;moc_foo.cc&rsquo;] <br>
env.Uic(target = Split(&rsquo;include/foo.h gen/uicfoo.cc
gen/mocfoo.cc&rsquo;), <br>
source = &rsquo;foo.ui&rsquo;) # -&gt;
[&rsquo;include/foo.h&rsquo;, &rsquo;gen/uicfoo.cc&rsquo;,
&rsquo;gen/mocfoo.cc&rsquo;]</p>

<p style="margin-top: 1em">Zip(), env.Zip() <br>
Builds a zip archive of the specified files and/or
directories. Unlike most builder methods, the Zip builder
method may be called multiple times for a given target; each
<br>
additional call adds to the list of entries that will be
built into the archive. Any source directories will be
scanned for changes to any on-disk files, regardless of <br>
whether or not scons knows about them from other Builder or
function calls.</p>

<p style="margin-top: 1em">env.Zip(&rsquo;src.zip&rsquo;,
&rsquo;src&rsquo;)</p>

<p style="margin-top: 1em"># Create the stuff.zip file.
<br>
env.Zip(&rsquo;stuff&rsquo;, [&rsquo;subdir1&rsquo;,
&rsquo;subdir2&rsquo;]) <br>
# Also add &quot;another&quot; to the stuff.tar file. <br>
env.Zip(&rsquo;stuff&rsquo;, &rsquo;another&rsquo;)</p>

<p style="margin-top: 1em">All targets of builder methods
automatically depend on their sources. An explicit
dependency can be specified using the Depends method of a
construction environment (see below).</p>

<p style="margin-top: 1em">In addition, scons automatically
scans source files for various programming languages, so the
dependencies do not need to be specified explicitly. By
default, SCons can C source <br>
files, C++ source files, Fortran source files with .F (POSIX
systems only), .fpp, or .FPP file extensions, and assembly
language files with .S (POSIX systems only), .spp, or .SPP
<br>
files extensions for C preprocessor dependencies. SCons also
has default support for scanning D source files, You can
also write your own Scanners to add support for additional
<br>
source file types. These can be added to the default Scanner
object used by the Object(), StaticObject(), and
SharedObject() Builders by adding them to the
SourceFileScanner <br>
object. See the section &quot;Scanner Objects&quot; below,
for more information about defining your own Scanner objects
and using the SourceFileScanner object.</p>

<p style="margin-top: 1em">Methods and Functions to Do
Things <br>
In addition to Builder methods, scons provides a number of
other construction environment methods and global functions
to manipulate the build configuration.</p>

<p style="margin-top: 1em">Usually, a construction
environment method and global function with the same name
both exist so that you don&rsquo;t have to remember whether
to a specific bit of functionality must be <br>
called with or without a construction environment. In the
following list, if you call something as a global function
it looks like:</p>

<p style="margin-top: 1em">Function(arguments)</p>

<p style="margin-top: 1em">and if you call something
through a construction environment it looks like:</p>

<p style="margin-top: 1em">env.Function(arguments)</p>

<p style="margin-top: 1em">If you can call the
functionality in both ways, then both forms are listed.</p>

<p style="margin-top: 1em">Global functions may be called
from custom Python modules that you import into an
SConscript file by adding the following to the Python
module:</p>

<p style="margin-top: 1em">from SCons.Script import *</p>

<p style="margin-top: 1em">Except where otherwise noted,
the same-named construction environment method and global
function provide the exact same functionality. The only
difference is that, where <br>
appropriate, calling the functionality through a
construction environment will substitute construction
variables into any supplied strings. For example:</p>

<p style="margin-top: 1em">env = Environment(FOO =
&rsquo;foo&rsquo;) <br>
Default(&rsquo;$FOO&rsquo;) <br>
env.Default(&rsquo;$FOO&rsquo;)</p>

<p style="margin-top: 1em">In the above example, the first
call to the global Default() function will actually add a
target named $FOO to the list of default targets, while the
second call to the <br>
env.Default() construction environment method will expand
the value and add a target named foo to the list of default
targets. For more on construction variable expansion, see
<br>
the next section on construction variables.</p>

<p style="margin-top: 1em">Construction environment methods
and global functions supported by scons include:</p>

<p style="margin-top: 1em">Action(action, [cmd/str/fun,
[var, ...]] [option=value, ...]), env.Action(action,
[cmd/str/fun, [var, ...]] [option=value, ...]) <br>
Creates an Action object for the specified action. See the
section &quot;Action Objects,&quot; below, for a complete
explanation of the arguments and behavior.</p>

<p style="margin-top: 1em">Note that the env.Action() form
of the invocation will expand construction variables in any
argument strings, including the action argument, at the time
it is called using <br>
the construction variables in the env construction
environment through which env.Action() was called. The
Action() form delays all variable expansion until the Action
object <br>
is actually used.</p>

<p style="margin-top: 1em">AddMethod(object, function,
[name]), env.AddMethod(function, [name]) <br>
When called with the AddMethod() form, adds the specified
function to the specified object as the specified method
name. When called with the env.AddMethod() form, adds the
<br>
specified function to the construction environment env as
the specified method name. In both cases, if name is omitted
or None, the name of the specified function itself is <br>
used for the method name.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># Note that the first argument
to the function to <br>
# be attached as a method must be the object through <br>
# which the method will be called; the Python <br>
# convention is to call it &rsquo;self&rsquo;. <br>
def my_method(self, arg): <br>
print &quot;my_method() got&quot;, arg</p>

<p style="margin-top: 1em"># Use the global AddMethod()
function to add a method <br>
# to the Environment class. This <br>
AddMethod(Environment, my_method) <br>
env = Environment() <br>
env.my_method(&rsquo;arg&rsquo;)</p>

<p style="margin-top: 1em"># Add the function as a method,
using the function <br>
# name for the method call. <br>
env = Environment() <br>
env.AddMethod(my_method, &rsquo;other_method_name&rsquo;)
<br>
env.other_method_name(&rsquo;another arg&rsquo;)</p>

<p style="margin-top: 1em">AddOption(arguments) <br>
This function adds a new command-line option to be
recognized. The specified arguments are the same as
supported by the standard Python optparse.add_option()
method (with a <br>
few additional capabilities noted below); see the
documentation for optparse for a thorough discussion of its
option-processing capabities.</p>

<p style="margin-top: 1em">In addition to the arguments and
values supported by the optparse.add_option() method, the
SCons AddOption function allows you to set the nargs keyword
value to &rsquo;?&rsquo; (a string <br>
with just the question mark) to indicate that the specified
long option(s) take(s) an optional argument. When nargs =
&rsquo;?&rsquo; is passed to the AddOption function, the
const <br>
keyword argument may be used to supply the
&quot;default&quot; value that should be used when the
option is specified on the command line without an explicit
argument.</p>

<p style="margin-top: 1em">If no default= keyword argument
is supplied when calling AddOption, the option will have a
default value of None.</p>

<p style="margin-top: 1em">Once a new command-line option
has been added with AddOption, the option value may be
accessed using GetOption or env.GetOption(). The value may
also be set, using SetOption <br>
or env.SetOption(), if conditions in a SConscript require
overriding any default value. Note, however, that a value
specified on the command line will always override a value
<br>
set by any SConscript file.</p>

<p style="margin-top: 1em">Any specified help= strings for
the new option(s) will be displayed by the -H or -h options
(the latter only if no other help text is specified in the
SConscript files). The <br>
help text for the local options specified by AddOption will
appear below the SCons options themselves, under a separate
Local Options heading. The options will appear in the <br>
help text in the order in which the AddOption calls
occur.</p>

<p style="margin-top: 1em">Example:</p>


<p style="margin-top: 1em">AddOption(&rsquo;--prefix&rsquo;,
<br>
dest=&rsquo;prefix&rsquo;, <br>
nargs=1, type=&rsquo;string&rsquo;, <br>
action=&rsquo;store&rsquo;, <br>
metavar=&rsquo;DIR&rsquo;, <br>
help=&rsquo;installation prefix&rsquo;) <br>
env = Environment(PREFIX =
GetOption(&rsquo;prefix&rsquo;))</p>

<p style="margin-top: 1em">AddPostAction(target, action),
env.AddPostAction(target, action) <br>
Arranges for the specified action to be performed after the
specified target has been built. The specified action(s) may
be an Action object, or anything that can be <br>
converted into an Action object (see below).</p>

<p style="margin-top: 1em">When multiple targets are
supplied, the action may be called multiple times, once
after each action that generates one or more targets in the
list.</p>

<p style="margin-top: 1em">AddPreAction(target, action),
env.AddPreAction(target, action) <br>
Arranges for the specified action to be performed before the
specified target is built. The specified action(s) may be an
Action object, or anything that can be converted <br>
into an Action object (see below).</p>

<p style="margin-top: 1em">When multiple targets are
specified, the action(s) may be called multiple times, once
before each action that generates one or more targets in the
list.</p>

<p style="margin-top: 1em">Note that if any of the targets
are built in multiple steps, the action will be invoked just
before the &quot;final&quot; action that specifically
generates the specified target(s). <br>
For example, when building an executable program from a
specified source .c file via an intermediate object
file:</p>

<p style="margin-top: 1em">foo =
Program(&rsquo;foo.c&rsquo;) <br>
AddPreAction(foo, &rsquo;pre_action&rsquo;)</p>

<p style="margin-top: 1em">The specified pre_action would
be executed before scons calls the link command that
actually generates the executable program binary foo, not
before compiling the foo.c file <br>
into an object file.</p>

<p style="margin-top: 1em">Alias(alias, [targets,
[action]]), env.Alias(alias, [targets, [action]]) <br>
Creates one or more phony targets that expand to one or more
other targets. An optional action (command) or list of
actions can be specified that will be executed whenever <br>
the any of the alias targets are out-of-date. Returns the
Node object representing the alias, which exists outside of
any file system. This Node object, or the alias name, <br>
may be used as a dependency of any other target, including
another alias. Alias can be called multiple times for the
same alias to add additional targets to the alias, or <br>
additional actions to the list for this alias.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">Alias(&rsquo;install&rsquo;)
<br>
Alias(&rsquo;install&rsquo;, &rsquo;/usr/bin&rsquo;) <br>
Alias([&rsquo;install&rsquo;, &rsquo;install-lib&rsquo;],
&rsquo;/usr/local/lib&rsquo;)</p>


<p style="margin-top: 1em">env.Alias(&rsquo;install&rsquo;,
[&rsquo;/usr/local/bin&rsquo;,
&rsquo;/usr/local/lib&rsquo;]) <br>
env.Alias(&rsquo;install&rsquo;,
[&rsquo;/usr/local/man&rsquo;])</p>

<p style="margin-top: 1em">env.Alias(&rsquo;update&rsquo;,
[&rsquo;file1&rsquo;, &rsquo;file2&rsquo;],
&quot;update_database $SOURCES&quot;)</p>


<p style="margin-top: 1em">AllowSubstExceptions([exception,
...]) <br>
Specifies the exceptions that will be allowed when expanding
construction variables. By default, any construction
variable expansions that generate a NameError or IndexError
<br>
exception will expand to a &rsquo;&rsquo; (a null string)
and not cause scons to fail. All exceptions not in the
specified list will generate an error message and terminate
processing.</p>

<p style="margin-top: 1em">If AllowSubstExceptions is
called multiple times, each call completely overwrites the
previous list of allowed exceptions.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em"># Requires that all construction
variable names exist. <br>
# (You may wish to do this if you want to enforce strictly
<br>
# that all construction variables must be defined before
use.) <br>
AllowSubstExceptions()</p>

<p style="margin-top: 1em"># Also allow a string containing
a zero-division expansion <br>
# like &rsquo;${1 / 0}&rsquo; to evalute to &rsquo;&rsquo;.
<br>
AllowSubstExceptions(IndexError, NameError,
ZeroDivisionError)</p>

<p style="margin-top: 1em">AlwaysBuild(target, ...),
env.AlwaysBuild(target, ...) <br>
Marks each given target so that it is always assumed to be
out of date, and will always be rebuilt if needed. Note,
however, that AlwaysBuild does not add its target(s) to <br>
the default target list, so the targets will only be built
if they are specified on the command line, or are a
dependent of a target specified on the command line--but
they <br>
will always be built if so specified. Multiple targets can
be passed in to a single call to AlwaysBuild.</p>

<p style="margin-top: 1em">env.Append(key=val, [...]) <br>
Appends the specified keyword arguments to the end of
construction variables in the environment. If the
Environment does not have the specified construction
variable, it is <br>
simply added to the environment. If the values of the
construction variable and the keyword argument are the same
type, then the two values will be simply added together.
<br>
Otherwise, the construction variable and the value of the
keyword argument are both coerced to lists, and the lists
are added together. (See also the Prepend method,
below.)</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env.Append(CCFLAGS = &rsquo;
-g&rsquo;, FOO = [&rsquo;foo.yyy&rsquo;])</p>

<p style="margin-top: 1em">env.AppendENVPath(name, newpath,
[envname, sep, delete_existing]) <br>
This appends new path elements to the given path in the
specified external environment (ENV by default). This will
only add any particular path once (leaving the last one it
<br>
encounters and ignoring the rest, to preserve path order),
and to help assure this, will normalize all paths (using
os.path.normpath and os.path.normcase). This can also <br>
handle the case where the given old path variable is a list
instead of a string, in which case a list will be returned
instead of a string.</p>

<p style="margin-top: 1em">If delete_existing is 0, then
adding a path that already exists will not move it to the
end; it will stay where it is in the list.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">print
&rsquo;before:&rsquo;,env[&rsquo;ENV&rsquo;][&rsquo;INCLUDE&rsquo;]
<br>
include_path = &rsquo;/foo/bar:/foo&rsquo; <br>
env.AppendENVPath(&rsquo;INCLUDE&rsquo;, include_path) <br>
print
&rsquo;after:&rsquo;,env[&rsquo;ENV&rsquo;][&rsquo;INCLUDE&rsquo;]</p>

<p style="margin-top: 1em">yields: <br>
before: /foo:/biz <br>
after: /biz:/foo/bar:/foo</p>

<p style="margin-top: 1em">env.AppendUnique(key=val, [...],
delete_existing=0) <br>
Appends the specified keyword arguments to the end of
construction variables in the environment. If the
Environment does not have the specified construction
variable, it is <br>
simply added to the environment. If the construction
variable being appended to is a list, then any value(s) that
already exist in the construction variable will not be added
<br>
again to the list. However, if delete_existing is 1,
existing matching values are removed first, so existing
values in the arg list move to the end of the list.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env.AppendUnique(CCFLAGS =
&rsquo;-g&rsquo;, FOO = [&rsquo;foo.yyy&rsquo;])</p>

<p style="margin-top: 1em">env.BitKeeper() <br>
A factory function that returns a Builder object to be used
to fetch source files using BitKeeper. The returned Builder
is intended to be passed to the SourceCode function.</p>

<p style="margin-top: 1em">This function is deprecated. For
details, see the entry for the SourceCode function.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env.SourceCode(&rsquo;.&rsquo;,
env.BitKeeper())</p>

<p style="margin-top: 1em">BuildDir(build_dir, src_dir,
[duplicate]), env.BuildDir(build_dir, src_dir, [duplicate])
<br>
Deprecated synonyms for VariantDir and env.VariantDir(). The
build_dir argument becomes the variant_dir argument of
VariantDir or env.VariantDir().</p>

<p style="margin-top: 1em">Builder(action, [arguments]),
env.Builder(action, [arguments]) <br>
Creates a Builder object for the specified action. See the
section &quot;Builder Objects,&quot; below, for a complete
explanation of the arguments and behavior.</p>

<p style="margin-top: 1em">Note that the env.Builder() form
of the invocation will expand construction variables in any
arguments strings, including the action argument, at the
time it is called using <br>
the construction variables in the env construction
environment through which env.Builder() was called. The
Builder form delays all variable expansion until after the
Builder <br>
object is actually called.</p>

<p style="margin-top: 1em">CacheDir(cache_dir),
env.CacheDir(cache_dir) <br>
Specifies that scons will maintain a cache of derived files
in cache_dir. The derived files in the cache will be shared
among all the builds using the same CacheDir call. <br>
Specifying a cache_dir of None disables derived file
caching.</p>

<p style="margin-top: 1em">Calling env.CacheDir() will only
affect targets built through the specified construction
environment. Calling CacheDir sets a global default that
will be used by all targets <br>
built through construction environments that do not have an
env.CacheDir() specified.</p>

<p style="margin-top: 1em">When a CacheDir() is being used
and scons finds a derived file that needs to be rebuilt, it
will first look in the cache to see if a derived file has
already been built from <br>
identical input files and an identical build action (as
incorporated into the MD5 build signature). If so, scons
will retrieve the file from the cache. If the derived file
is <br>
not present in the cache, scons will rebuild it and then
place a copy of the built file in the cache (identified by
its MD5 build signature), so that it may be retrieved by
<br>
other builds that need to build the same derived file from
identical inputs.</p>

<p style="margin-top: 1em">Use of a specified CacheDir may
be disabled for any invocation by using the --cache-disable
option.</p>

<p style="margin-top: 1em">If the --cache-force option is
used, scons will place a copy of all derived files in the
cache, even if they already existed and were not built by
this invocation. This is <br>
useful to populate a cache the first time CacheDir is added
to a build, or after using the --cache-disable option.</p>

<p style="margin-top: 1em">When using CacheDir, scons will
report, &quot;Retrieved &lsquo;file&rsquo; from cache,&quot;
unless the --cache-show option is being used. When the
--cache-show option is used, scons will print <br>
the action that would have been used to build the file,
without any indication that the file was actually retrieved
from the cache. This is useful to generate build logs that
<br>
are equivalent regardless of whether a given derived file
has been built in-place or retrieved from the cache.</p>

<p style="margin-top: 1em">The NoCache method can be used
to disable caching of specific files. This can be useful if
inputs and/or outputs of some tool are impossible to predict
or prohibitively <br>
large.</p>

<p style="margin-top: 1em">Clean(targets, files_or_dirs),
env.Clean(targets, files_or_dirs) <br>
This specifies a list of files or directories which should
be removed whenever the targets are specified with the -c
command line option. The specified targets may be a list
<br>
or an individual target. Multiple calls to Clean are legal,
and create new targets or add files and directories to the
clean list for the specified targets.</p>

<p style="margin-top: 1em">Multiple files or directories
should be specified either as separate arguments to the
Clean method, or as a list. Clean will also accept the
return value of any of the <br>
construction environment Builder methods. Examples:</p>

<p style="margin-top: 1em">The related NoClean function
overrides calling Clean for the same target, and any targets
passed to both functions will not be removed by the -c
option.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">Clean(&rsquo;foo&rsquo;,
[&rsquo;bar&rsquo;, &rsquo;baz&rsquo;]) <br>
Clean(&rsquo;dist&rsquo;, env.Program(&rsquo;hello&rsquo;,
&rsquo;hello.c&rsquo;)) <br>
Clean([&rsquo;foo&rsquo;, &rsquo;bar&rsquo;],
&rsquo;something_else_to_clean&rsquo;)</p>

<p style="margin-top: 1em">In this example, installing the
project creates a subdirectory for the documentation. This
statement causes the subdirectory to be removed if the
project is deinstalled.</p>

<p style="margin-top: 1em">Clean(docdir,
os.path.join(docdir, projectname))</p>

<p style="margin-top: 1em">env.Clone([key=val, ...]) <br>
Returns a separate copy of a construction environment. If
there are any keyword arguments specified, they are added to
the returned copy, overwriting any existing values for <br>
the keywords.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env2 = env.Clone() <br>
env3 = env.Clone(CCFLAGS = &rsquo;-g&rsquo;)</p>

<p style="margin-top: 1em">Additionally, a list of tools
and a toolpath may be specified, as in the Environment
constructor:</p>

<p style="margin-top: 1em">def MyTool(env):
env[&rsquo;FOO&rsquo;] = &rsquo;bar&rsquo; <br>
env4 = env.Clone(tools = [&rsquo;msvc&rsquo;, MyTool])</p>

<p style="margin-top: 1em">The parse_flags keyword argument
is also recognized:</p>

<p style="margin-top: 1em"># create an environment for
compiling programs that use wxWidgets <br>
wx_env = env.Clone(parse_flags = &rsquo;!wx-config --cflags
--cxxflags&rsquo;)</p>

<p style="margin-top: 1em">Command(target, source, action,
[key=val, ...]), env.Command(target, source, action,
[key=val, ...]) <br>
Executes a specific action (or list of actions) to build a
target file or files. This is more convenient than defining
a separate Builder object for a single special-case <br>
build.</p>

<p style="margin-top: 1em">As a special case, the
source_scanner keyword argument can be used to specify a
Scanner object that will be used to scan the sources. (The
global DirScanner object can be <br>
used if any of the sources will be directories that must be
scanned on-disk for changes to files that aren&rsquo;t
already specified in other Builder of function calls.)</p>

<p style="margin-top: 1em">Any other keyword arguments
specified override any same-named existing construction
variables.</p>

<p style="margin-top: 1em">An action can be an external
command, specified as a string, or a callable Python object;
see &quot;Action Objects,&quot; below, for more complete
information. Also note that a string <br>
specifying an external command may be preceded by an @
(at-sign) to suppress printing the command in question, or
by a - (hyphen) to ignore the exit status of the external
<br>
command.</p>

<p style="margin-top: 1em">Examples:</p>


<p style="margin-top: 1em">env.Command(&rsquo;foo.out&rsquo;,
&rsquo;foo.in&rsquo;, <br>
&quot;$FOO_BUILD &lt; $SOURCES &gt; $TARGET&quot;)</p>


<p style="margin-top: 1em">env.Command(&rsquo;bar.out&rsquo;,
&rsquo;bar.in&rsquo;, <br>
[&quot;rm -f $TARGET&quot;, <br>
&quot;$BAR_BUILD &lt; $SOURCES &gt; $TARGET&quot;], <br>
ENV = {&rsquo;PATH&rsquo; :
&rsquo;/usr/local/bin/&rsquo;})</p>

<p style="margin-top: 1em">def rename(env, target, source):
<br>
import os <br>
os.rename(&rsquo;.tmp&rsquo;, str(target[0]))</p>


<p style="margin-top: 1em">env.Command(&rsquo;baz.out&rsquo;,
&rsquo;baz.in&rsquo;, <br>
[&quot;$BAZ_BUILD &lt; $SOURCES &gt; .tmp&quot;, <br>
rename ])</p>

<p style="margin-top: 1em">Note that the Command function
will usually assume, by default, that the specified targets
and/or sources are Files, if no other part of the
configuration identifies what <br>
type of entry it is. If necessary, you can explicitly
specify that targets or source nodes should be treated as
directoriese by using the Dir or env.Dir() functions.</p>

<p style="margin-top: 1em">Examples:</p>


<p style="margin-top: 1em">env.Command(&rsquo;ddd.list&rsquo;,
Dir(&rsquo;ddd&rsquo;), &rsquo;ls -l $SOURCE &gt;
$TARGET&rsquo;)</p>

<p style="margin-top: 1em">env[&rsquo;DISTDIR&rsquo;] =
&rsquo;destination/directory&rsquo; <br>
env.Command(env.Dir(&rsquo;$DISTDIR&rsquo;)), None,
make_distdir)</p>

<p style="margin-top: 1em">(Also note that SCons will
usually automatically create any directory necessary to hold
a target file, so you normally don&rsquo;t need to create
directories by hand.)</p>

<p style="margin-top: 1em">Configure(env, [custom_tests,
conf_dir, log_file, config_h]), env.Configure([custom_tests,
conf_dir, log_file, config_h]) <br>
Creates a Configure object for integrated functionality
similar to GNU autoconf. See the section &quot;Configure
Contexts,&quot; below, for a complete explanation of the
arguments and <br>
behavior.</p>

<p style="margin-top: 1em">env.Copy([key=val, ...]) <br>
A now-deprecated synonym for env.Clone().</p>

<p style="margin-top: 1em">env.CVS(repository, module) <br>
A factory function that returns a Builder object to be used
to fetch source files from the specified CVS repository. The
returned Builder is intended to be passed to the <br>
SourceCode function.</p>

<p style="margin-top: 1em">This function is deprecated. For
details, see the entry for the SourceCode function.</p>

<p style="margin-top: 1em">The optional specified module
will be added to the beginning of all repository path names;
this can be used, in essence, to strip initial directory
names from the repository <br>
path names, so that you only have to replicate part of the
repository directory hierarchy in your local build
directory.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># Will fetch foo/bar/src.c <br>
# from /usr/local/CVSROOT/foo/bar/src.c. <br>
env.SourceCode(&rsquo;.&rsquo;,
env.CVS(&rsquo;/usr/local/CVSROOT&rsquo;))</p>

<p style="margin-top: 1em"># Will fetch bar/src.c <br>
# from /usr/local/CVSROOT/foo/bar/src.c. <br>
env.SourceCode(&rsquo;.&rsquo;,
env.CVS(&rsquo;/usr/local/CVSROOT&rsquo;,
&rsquo;foo&rsquo;))</p>

<p style="margin-top: 1em"># Will fetch src.c <br>
# from /usr/local/CVSROOT/foo/bar/src.c. <br>
env.SourceCode(&rsquo;.&rsquo;,
env.CVS(&rsquo;/usr/local/CVSROOT&rsquo;,
&rsquo;foo/bar&rsquo;))</p>

<p style="margin-top: 1em">Decider(function),
env.Decider(function) <br>
Specifies that all up-to-date decisions for targets built
through this construction environment will be handled by the
specified function. The function can be one of the <br>
following strings that specify the type of decision function
to be performed:</p>

<p style="margin-top: 1em">timestamp-newer <br>
Specifies that a target shall be considered out of date and
rebuilt if the dependency&rsquo;s timestamp is newer than
the target file&rsquo;s timestamp. This is the behavior of
the <br>
classic Make utility, and make can be used a synonym for
timestamp-newer.</p>

<p style="margin-top: 1em">timestamp-match <br>
Specifies that a target shall be considered out of date and
rebuilt if the dependency&rsquo;s timestamp is different
than the timestamp recorded the last time the target was
<br>
built. This provides behavior very similar to the classic
Make utility (in particular, files are not opened up so that
their contents can be checksummed) except that the <br>
target will also be rebuilt if a dependency file has been
restored to a version with an earlier timestamp, such as can
happen when restoring files from backup archives.</p>

<p style="margin-top: 1em">MD5 <br>
Specifies that a target shall be considered out of date and
rebuilt if the dependency&rsquo;s content has changed sine
the last time the target was built, as determined be <br>
performing an MD5 checksum on the dependency&rsquo;s
contents and comparing it to the checksum recorded the last
time the target was built. content can be used as a synonym
<br>
for MD5.</p>

<p style="margin-top: 1em">MD5-timestamp <br>
Specifies that a target shall be considered out of date and
rebuilt if the dependency&rsquo;s content has changed sine
the last time the target was built, except that <br>
dependencies with a timestamp that matches the last time the
target was rebuilt will be assumed to be up-to-date and not
rebuilt. This provides behavior very similar to <br>
the MD5 behavior of always checksumming file contents, with
an optimization of not checking the contents of files whose
timestamps haven&rsquo;t changed. The drawback is that <br>
SCons will not detect if a file&rsquo;s content has changed
but its timestamp is the same, as might happen in an
automated script that runs a build, updates a file, and runs
<br>
the build again, all within a single second.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># Use exact timestamp matches by
default. <br>
Decider(&rsquo;timestamp-match&rsquo;)</p>

<p style="margin-top: 1em"># Use MD5 content signatures for
any targets built <br>
# with the attached construction environment. <br>
env.Decider(&rsquo;content&rsquo;)</p>

<p style="margin-top: 1em">In addition to the above
already-available functions, the function argument may be an
actual Python function that takes the following three
arguments:</p>

<p style="margin-top: 1em">dependency <br>
The Node (file) which should cause the target to be rebuilt
if it has &quot;changed&quot; since the last tme target was
built.</p>

<p style="margin-top: 1em">target <br>
The Node (file) being built. In the normal case, this is
what should get rebuilt if the dependency has
&quot;changed.&quot;</p>

<p style="margin-top: 1em">prev_ni <br>
Stored information about the state of the dependency the
last time the target was built. This can be consulted to
match various file characteristics such as the <br>
timestamp, size, or content signature.</p>

<p style="margin-top: 1em">The function should return a
True (non-zero) value if the dependency has
&quot;changed&quot; since the last time the target was built
(indicating that the target should be rebuilt), <br>
and False (zero) otherwise (indicating that the target
should not be rebuilt). Note that the decision can be made
using whatever criteria are appopriate. Ignoring some or all
<br>
of the function arguments is perfectly normal.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">def my_decider(dependency,
target, prev_ni): <br>
return not os.path.exists(str(target))</p>

<p style="margin-top: 1em">env.Decider(my_decider)</p>

<p style="margin-top: 1em">Default(targets),
env.Default(targets) <br>
This specifies a list of default targets, which will be
built by scons if no explicit targets are given on the
command line. Multiple calls to Default are legal, and add
to <br>
the list of default targets.</p>

<p style="margin-top: 1em">Multiple targets should be
specified as separate arguments to the Default method, or as
a list. Default will also accept the Node returned by any of
a construction <br>
environment&rsquo;s builder methods.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">Default(&rsquo;foo&rsquo;,
&rsquo;bar&rsquo;, &rsquo;baz&rsquo;) <br>
env.Default([&rsquo;a&rsquo;, &rsquo;b&rsquo;,
&rsquo;c&rsquo;]) <br>
hello = env.Program(&rsquo;hello&rsquo;,
&rsquo;hello.c&rsquo;) <br>
env.Default(hello)</p>

<p style="margin-top: 1em">An argument to Default of None
will clear all default targets. Later calls to Default will
add to the (now empty) default-target list like normal.</p>

<p style="margin-top: 1em">The current list of targets
added using the Default function or method is available in
the DEFAULT_TARGETS list; see below.</p>

<p style="margin-top: 1em">DefaultEnvironment([args]) <br>
Creates and returns a default construction environment
object. This construction environment is used internally by
SCons in order to execute many of the global functions in
<br>
this list, and to fetch source files transparently from
source code management systems.</p>

<p style="margin-top: 1em">Depends(target, dependency),
env.Depends(target, dependency) <br>
Specifies an explicit dependency; the target will be rebuilt
whenever the dependency has changed. Both the specified
target and dependency can be a string (usually the path <br>
name of a file or directory) or Node objects, or a list of
strings or Node objects (such as returned by a Builder
call). This should only be necessary for cases where the
<br>
dependency is not caught by a Scanner for the file.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env.Depends(&rsquo;foo&rsquo;,
&rsquo;other-input-file-for-foo&rsquo;)</p>

<p style="margin-top: 1em">mylib =
env.Library(&rsquo;mylib.c&rsquo;) <br>
installed_lib = env.Install(&rsquo;lib&rsquo;, mylib) <br>
bar = env.Program(&rsquo;bar.c&rsquo;)</p>

<p style="margin-top: 1em"># Arrange for the library to be
copied into the installation <br>
# directory before trying to build the &quot;bar&quot;
program. <br>
# (Note that this is for example only. A &quot;real&quot;
library <br>
# dependency would normally be configured through the $LIBS
<br>
# and $LIBPATH variables, not using an env.Depends()
call.)</p>

<p style="margin-top: 1em">env.Depends(bar,
installed_lib)</p>

<p style="margin-top: 1em">env.Dictionary([vars]) <br>
Returns a dictionary object containing copies of all of the
construction variables in the environment. If there are any
variable names specified, only the specified <br>
construction variables are returned in the dictionary.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">dict = env.Dictionary() <br>
cc_dict = env.Dictionary(&rsquo;CC&rsquo;,
&rsquo;CCFLAGS&rsquo;, &rsquo;CCCOM&rsquo;)</p>

<p style="margin-top: 1em">Dir(name, [directory]),
env.Dir(name, [directory]) <br>
This returns a Directory Node, an object that represents the
specified directory name. name can be a relative or absolute
path. directory is an optional directory that will <br>
be used as the parent directory. If no directory is
specified, the current script&rsquo;s directory is used as
the parent.</p>

<p style="margin-top: 1em">If name is a list, SCons returns
a list of Dir nodes. Construction variables are expanded in
name.</p>

<p style="margin-top: 1em">Directory Nodes can be used
anywhere you would supply a string as a directory name to a
Builder method or function. Directory Nodes have attributes
and methods that are <br>
useful in many situations; see &quot;File and Directory
Nodes,&quot; below.</p>

<p style="margin-top: 1em">env.Dump([key]) <br>
Returns a pretty printable representation of the
environment. key, if not None, should be a string containing
the name of the variable of interest.</p>

<p style="margin-top: 1em">This SConstruct:</p>

<p style="margin-top: 1em">env=Environment() <br>
print env.Dump(&rsquo;CCCOM&rsquo;)</p>

<p style="margin-top: 1em">will print:</p>

<p style="margin-top: 1em">&rsquo;$CC -c -o $TARGET
$CCFLAGS $CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS
$SOURCES&rsquo;</p>

<p style="margin-top: 1em">While this SConstruct:</p>

<p style="margin-top: 1em">env=Environment() <br>
print env.Dump()</p>

<p style="margin-top: 1em">will print:</p>

<p style="margin-top: 1em">{ &rsquo;AR&rsquo;:
&rsquo;ar&rsquo;, <br>
&rsquo;ARCOM&rsquo;: &rsquo;$AR $ARFLAGS $TARGET
$SOURCES0RANLIB $RANLIBFLAGS $TARGET&rsquo;, <br>
&rsquo;ARFLAGS&rsquo;: [&rsquo;r&rsquo;], <br>
&rsquo;AS&rsquo;: &rsquo;as&rsquo;, <br>
&rsquo;ASCOM&rsquo;: &rsquo;$AS $ASFLAGS -o $TARGET
$SOURCES&rsquo;, <br>
&rsquo;ASFLAGS&rsquo;: [], <br>
...</p>

<p style="margin-top: 1em">EnsurePythonVersion(major,
minor), env.EnsurePythonVersion(major, minor) <br>
Ensure that the Python version is at least major.minor. This
function will print out an error message and exit SCons with
a non-zero exit code if the actual Python version is <br>
not late enough.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">EnsurePythonVersion(2,2)</p>

<p style="margin-top: 1em">EnsureSConsVersion(major, minor,
[revision]), env.EnsureSConsVersion(major, minor,
[revision]) <br>
Ensure that the SCons version is at least major.minor, or
major.minor.revision. if revision is specified. This
function will print out an error message and exit SCons with
a <br>
non-zero exit code if the actual SCons version is not late
enough.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">EnsureSConsVersion(0,14)</p>

<p style="margin-top: 1em">EnsureSConsVersion(0,96,90)</p>

<p style="margin-top: 1em">Environment([key=value, ...]),
env.Environment([key=value, ...]) <br>
Return a new construction environment initialized with the
specified key=value pairs.</p>

<p style="margin-top: 1em">Execute(action, [strfunction,
varlist]), env.Execute(action, [strfunction, varlist]) <br>
Executes an Action object. The specified action may be an
Action object (see the section &quot;Action Objects,&quot;
below, for a complete explanation of the arguments and
behavior), <br>
or it may be a command-line string, list of commands, or
executable Python function, each of which will be converted
into an Action object and then executed. The exit value <br>
of the command or return value of the Python function will
be returned.</p>

<p style="margin-top: 1em">Note that scons will print an
error message if the executed action fails--that is, exits
with or returns a non-zero value. scons will not, however,
automatically terminate <br>
the build if the specified action fails. If you want the
build to stop in response to a failed Execute call, you must
explicitly check for a non-zero return value:</p>


<p style="margin-top: 1em">Execute(Copy(&rsquo;file.out&rsquo;,
&rsquo;file.in&rsquo;))</p>

<p style="margin-top: 1em">if Execute(&quot;mkdir
sub/dir/ectory&quot;): <br>
# The mkdir failed, don&rsquo;t try to build. <br>
Exit(1)</p>

<p style="margin-top: 1em">Exit([value]), env.Exit([value])
<br>
This tells scons to exit immediately with the specified
value. A default exit value of 0 (zero) is used if no value
is specified.</p>

<p style="margin-top: 1em">Export(vars), env.Export(vars)
<br>
This tells scons to export a list of variables from the
current SConscript file to all other SConscript files. The
exported variables are kept in a global collection, so <br>
subsequent calls to Export will over-write previous exports
that have the same name. Multiple variable names can be
passed to Export as separate arguments or as a list. <br>
Keyword arguments can be used to provide names and their
values. A dictionary can be used to map variables to a
different name when exported. Both local variables and
global <br>
variables can be exported.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">env = Environment() <br>
# Make env available for all SConscript files to Import().
<br>
Export(&quot;env&quot;)</p>

<p style="margin-top: 1em">package = &rsquo;my_name&rsquo;
<br>
# Make env and package available for all SConscript files:.
<br>
Export(&quot;env&quot;, &quot;package&quot;)</p>

<p style="margin-top: 1em"># Make env and package available
for all SConscript files: <br>
Export([&quot;env&quot;, &quot;package&quot;])</p>

<p style="margin-top: 1em"># Make env available using the
name debug: <br>
Export(debug = env)</p>

<p style="margin-top: 1em"># Make env available using the
name debug: <br>
Export({&quot;debug&quot;:env})</p>

<p style="margin-top: 1em">Note that the SConscript
function supports an exports argument that makes it easier
to to export a variable or set of variables to a single
SConscript file. See the <br>
description of the SConscript function, below.</p>

<p style="margin-top: 1em">File(name, [directory]),
env.File(name, [directory]) <br>
This returns a File Node, an object that represents the
specified file name. name can be a relative or absolute
path. directory is an optional directory that will be used
<br>
as the parent directory.</p>

<p style="margin-top: 1em">If name is a list, SCons returns
a list of File nodes. Construction variables are expanded in
name.</p>

<p style="margin-top: 1em">File Nodes can be used anywhere
you would supply a string as a file name to a Builder method
or function. File Nodes have attributes and methods that are
useful in many <br>
situations; see &quot;File and Directory Nodes,&quot;
below.</p>

<p style="margin-top: 1em">FindFile(file, dirs),
env.FindFile(file, dirs) <br>
Search for file in the path specified by dirs. dirs may be a
list of directory names or a single directory name. In
addition to searching for files that exist in the <br>
filesystem, this function also searches for derived files
that have not yet been built.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">foo =
env.FindFile(&rsquo;foo&rsquo;, [&rsquo;dir1&rsquo;,
&rsquo;dir2&rsquo;])</p>

<p style="margin-top: 1em">FindInstalledFiles(),
env.FindInstalledFiles() <br>
Returns the list of targets set up by the Install or
InstallAs builders.</p>

<p style="margin-top: 1em">This function serves as a
convenient method to select the contents of a binary
package.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">Install( &rsquo;/bin&rsquo;, [
&rsquo;executable_a&rsquo;, &rsquo;executable_b&rsquo; ]
)</p>

<p style="margin-top: 1em"># will return the file node list
<br>
# [ &rsquo;/bin/executable_a&rsquo;,
&rsquo;/bin/executable_b&rsquo; ] <br>
FindInstalledFiles()</p>

<p style="margin-top: 1em">Install( &rsquo;/lib&rsquo;, [
&rsquo;some_library&rsquo; ] )</p>

<p style="margin-top: 1em"># will return the file node list
<br>
# [ &rsquo;/bin/executable_a&rsquo;,
&rsquo;/bin/executable_b&rsquo;,
&rsquo;/lib/some_library&rsquo; ] <br>
FindInstalledFiles()</p>

<p style="margin-top: 1em">FindPathDirs(variable) <br>
Returns a function (actually a callable Python object)
intended to be used as the path_function of a Scanner
object. The returned object will look up the specified
variable <br>
in a construction environment and treat the construction
variable&rsquo;s value as a list of directory paths that
should be searched (like $CPPPATH, $LIBPATH, etc.).</p>

<p style="margin-top: 1em">Note that use of FindPathDirs is
generally preferable to writing your own path_function for
the following reasons: 1) The returned list will contain all
appropriate <br>
directories found in source trees (when VariantDir is used)
or in code repositories (when Repository or the -Y option
are used). 2) scons will identify expansions of variable
<br>
that evaluate to the same list of directories as, in fact,
the same list, and avoid re-scanning the directories for
files, when possible.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">def my_scan(node, env, path,
arg): <br>
# Code to scan file contents goes here... <br>
return include_files</p>

<p style="margin-top: 1em">scanner = Scanner(name =
&rsquo;myscanner&rsquo;, <br>
function = my_scan, <br>
path_function = FindPathDirs(&rsquo;MYPATH&rsquo;))</p>


<p style="margin-top: 1em">FindSourceFiles(node=&rsquo;&quot;.&quot;&rsquo;),
env.FindSourceFiles(node=&rsquo;&quot;.&quot;&rsquo;) <br>
Returns the list of nodes which serve as the source of the
built files. It does so by inspecting the dependency tree
starting at the optional argument node which defaults to
<br>
the &rsquo;&quot;.&quot;&rsquo;-node. It will then return
all leaves of node. These are all children which have no
further children.</p>

<p style="margin-top: 1em">This function is a convenient
method to select the contents of a Source Package.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">Program(
&rsquo;src/main_a.c&rsquo; ) <br>
Program( &rsquo;src/main_b.c&rsquo; ) <br>
Program( &rsquo;main_c.c&rsquo; )</p>

<p style="margin-top: 1em"># returns
[&rsquo;main_c.c&rsquo;, &rsquo;src/main_a.c&rsquo;,
&rsquo;SConstruct&rsquo;, &rsquo;src/main_b.c&rsquo;] <br>
FindSourceFiles()</p>

<p style="margin-top: 1em"># returns
[&rsquo;src/main_b.c&rsquo;, &rsquo;src/main_a.c&rsquo; ]
<br>
FindSourceFiles( &rsquo;src&rsquo; )</p>

<p style="margin-top: 1em">As you can see build support
files (SConstruct in the above example) will also be
returned by this function.</p>

<p style="margin-top: 1em">Flatten(sequence),
env.Flatten(sequence) <br>
Takes a sequence (that is, a Python list or tuple) that may
contain nested sequences and returns a flattened list
containing all of the individual elements in any sequence.
<br>
This can be helpful for collecting the lists returned by
calls to Builders; other Builders will automatically flatten
lists specified as input, but direct Python manipulation
<br>
of these lists does not.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">foo =
Object(&rsquo;foo.c&rsquo;) <br>
bar = Object(&rsquo;bar.c&rsquo;)</p>

<p style="margin-top: 1em"># Because &lsquo;foo&rsquo; and
&lsquo;bar&rsquo; are lists returned by the Object()
Builder, <br>
# &lsquo;objects&rsquo; will be a list containing nested
lists: <br>
objects = [&rsquo;f1.o&rsquo;, foo, &rsquo;f2.o&rsquo;, bar,
&rsquo;f3.o&rsquo;]</p>

<p style="margin-top: 1em"># Passing such a list to another
Builder is all right because <br>
# the Builder will flatten the list automatically: <br>
Program(source = objects)</p>

<p style="margin-top: 1em"># If you need to manipulate the
list directly using Python, you need to <br>
# call Flatten() yourself, or otherwise handle nested lists:
<br>
for object in Flatten(objects): <br>
print str(object)</p>

<p style="margin-top: 1em">GetBuildFailures() <br>
Returns a list of exceptions for the actions that failed
while attempting to build targets. Each element in the
returned list is a BuildError object with the following <br>
attributes that record various aspects of the build
failure:</p>

<p style="margin-top: 1em">.node The node that was being
built when the build failure occurred.</p>

<p style="margin-top: 1em">.status The numeric exit status
returned by the command or Python function that failed when
trying to build the specified Node.</p>

<p style="margin-top: 1em">.errstr The SCons error string
describing the build failure. (This is often a generic
message like &quot;Error 2&quot; to indicate that an
executed command exited with a status of 2.)</p>

<p style="margin-top: 1em">.filename The name of the file
or directory that actually caused the failure. This may be
different from the .node attribute. For example, if an
attempt to build a target <br>
named sub/dir/target fails because the sub/dir directory
could not be created, then the .node attribute will be
sub/dir/target but the .filename attribute will be
sub/dir.</p>

<p style="margin-top: 1em">.executor The SCons Executor
object for the target Node being built. This can be used to
retrieve the construction environment used for the failed
action.</p>

<p style="margin-top: 1em">.action The actual SCons Action
object that failed. This will be one specific action out of
the possible list of actions that would have been executed
to build the target.</p>

<p style="margin-top: 1em">.command The actual expanded
command that was executed and failed, after expansion of
$TARGET, $SOURCE, and other construction variables.</p>

<p style="margin-top: 1em">Note that the GetBuildFailures
function will always return an empty list until any build
failure has occurred, which means that GetBuildFailures will
always return an empty <br>
list while the SConscript files are being read. Its primary
intended use is for functions that will be executed before
SCons exits by passing them to the standard Python <br>
atexit.register() function. Example:</p>

<p style="margin-top: 1em">import atexit</p>

<p style="margin-top: 1em">def print_build_failures(): <br>
from SCons.Script import GetBuildFailures <br>
for bf in GetBuildFailures(): <br>
print &quot;%s failed: %s&quot; % (bf.node, bf.errstr)</p>


<p style="margin-top: 1em">atexit.register(print_build_failures)</p>

<p style="margin-top: 1em">GetBuildPath(file, [...]),
env.GetBuildPath(file, [...]) <br>
Returns the scons path name (or names) for the specified
file (or files). The specified file or files may be scons
Nodes or strings representing path names.</p>

<p style="margin-top: 1em">GetLaunchDir(),
env.GetLaunchDir() <br>
Returns the absolute path name of the directory from which
scons was initially invoked. This can be useful when using
the -u, -U or -D options, which internally change to the
<br>
directory in which the SConstruct file is found.</p>

<p style="margin-top: 1em">GetOption(name),
env.GetOption(name) <br>
This function provides a way to query the value of SCons
options set on scons command line (or set using the
SetOption function). The options supported are:</p>

<p style="margin-top: 1em">cache_debug <br>
which corresponds to --cache-debug;</p>

<p style="margin-top: 1em">cache_disable <br>
which corresponds to --cache-disable;</p>

<p style="margin-top: 1em">cache_force <br>
which corresponds to --cache-force;</p>

<p style="margin-top: 1em">cache_show <br>
which corresponds to --cache-show;</p>

<p style="margin-top: 1em">clean <br>
which corresponds to -c, --clean and --remove;</p>

<p style="margin-top: 1em">config <br>
which corresponds to --config;</p>

<p style="margin-top: 1em">directory <br>
which corresponds to -C and --directory;</p>

<p style="margin-top: 1em">diskcheck <br>
which corresponds to --diskcheck</p>

<p style="margin-top: 1em">duplicate <br>
which corresponds to --duplicate;</p>

<p style="margin-top: 1em">file <br>
which corresponds to -f, --file, --makefile and
--sconstruct;</p>

<p style="margin-top: 1em">help <br>
which corresponds to -h and --help;</p>

<p style="margin-top: 1em">ignore_errors <br>
which corresponds to --ignore-errors;</p>

<p style="margin-top: 1em">implicit_cache <br>
which corresponds to --implicit-cache;</p>

<p style="margin-top: 1em">implicit_deps_changed <br>
which corresponds to --implicit-deps-changed;</p>

<p style="margin-top: 1em">implicit_deps_unchanged <br>
which corresponds to --implicit-deps-unchanged;</p>

<p style="margin-top: 1em">interactive <br>
which corresponds to --interact and --interactive;</p>

<p style="margin-top: 1em">keep_going <br>
which corresponds to -k and --keep-going;</p>

<p style="margin-top: 1em">max_drift <br>
which corresponds to --max-drift;</p>

<p style="margin-top: 1em">no_exec <br>
which corresponds to -n, --no-exec, --just-print, --dry-run
and --recon;</p>

<p style="margin-top: 1em">no_site_dir <br>
which corresponds to --no-site-dir;</p>

<p style="margin-top: 1em">num_jobs <br>
which corresponds to -j and --jobs;</p>

<p style="margin-top: 1em">profile_file <br>
which corresponds to --profile;</p>

<p style="margin-top: 1em">question <br>
which corresponds to -q and --question;</p>

<p style="margin-top: 1em">random <br>
which corresponds to --random;</p>

<p style="margin-top: 1em">repository <br>
which corresponds to -Y, --repository and --srcdir;</p>

<p style="margin-top: 1em">silent <br>
which corresponds to -s, --silent and --quiet;</p>

<p style="margin-top: 1em">site_dir <br>
which corresponds to --site-dir;</p>

<p style="margin-top: 1em">stack_size <br>
which corresponds to --stack-size;</p>

<p style="margin-top: 1em">taskmastertrace_file <br>
which corresponds to --taskmastertrace; and</p>

<p style="margin-top: 1em">warn <br>
which corresponds to --warn and --warning.</p>

<p style="margin-top: 1em">See the documentation for the
corresponding command line object for information about each
specific option.</p>

<p style="margin-top: 1em">Glob(pattern, [ondisk, source,
strings, exclude]), env.Glob(pattern, [ondisk, source,
strings, exclude]) <br>
Returns Nodes (or strings) that match the specified pattern,
relative to the directory of the current SConscript file.
The env.Glob() form performs string substition on <br>
pattern and returns whatever matches the resulting expanded
pattern.</p>

<p style="margin-top: 1em">The specified pattern uses Unix
shell style metacharacters for matching:</p>

<p style="margin-top: 1em">* matches everything <br>
? matches any single character <br>
[seq] matches any character in seq <br>
[!seq] matches any char not in seq</p>

<p style="margin-top: 1em">If the first character of a
filename is a dot, it must be matched explicitly. Character
matches do not span directory separators.</p>

<p style="margin-top: 1em">The Glob knows about
repositories (see the Repository function) and source
directories (see the VariantDir function) and returns a Node
(or string, if so configured) in the <br>
local (SConscript) directory if matching Node is found
anywhere in a corresponding repository or source
directory.</p>

<p style="margin-top: 1em">The ondisk argument may be set
to False (or any other non-true value) to disable the search
for matches on disk, thereby only returning matches among
already-configured File <br>
or Dir Nodes. The default behavior is to return
corresponding Nodes for any on-disk matches found.</p>

<p style="margin-top: 1em">The source argument may be set
to True (or any equivalent value) to specify that, when the
local directory is a VariantDir, the returned Nodes should
be from the <br>
corresponding source directory, not the local directory.</p>

<p style="margin-top: 1em">The strings argument may be set
to True (or any equivalent value) to have the Glob function
return strings, not Nodes, that represent the matched files
or directories. The <br>
returned strings will be relative to the local (SConscript)
directory. (Note that This may make it easier to perform
arbitrary manipulation of file names, but if the returned
<br>
strings are passed to a different SConscript file, any Node
translation will be relative to the other SConscript
directory, not the original SConscript directory.)</p>

<p style="margin-top: 1em">The exclude argument may be set
to a pattern or a list of patterns (following the same Unix
shell semantics) which must be filtered out of returned
elements. Elements <br>
matching a least one pattern of this list will be
excluded.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">Program(&rsquo;foo&rsquo;,
Glob(&rsquo;*.c&rsquo;)) <br>
Zip(&rsquo;/tmp/everything&rsquo;, Glob(&rsquo;.??*&rsquo;)
+ Glob(&rsquo;*&rsquo;)) <br>
sources = Glob(&rsquo;*.cpp&rsquo;,
exclude=[&rsquo;os_*_specific_*.cpp&rsquo;]) +
Glob(&rsquo;os_%s_specific_*.cpp&rsquo;%currentOS)</p>

<p style="margin-top: 1em">Help(text, append=False),
env.Help(text, append=False) <br>
This specifies help text to be printed if the -h argument is
given to scons. If Help is called multiple times, the text
is appended together in the order that Help is called. <br>
With append set to False, any Help text generated with
AddOption is clobbered. If append is True, the AddOption
help is prepended to the help string, thus preserving the -h
<br>
message.</p>

<p style="margin-top: 1em">Ignore(target, dependency),
env.Ignore(target, dependency) <br>
The specified dependency file(s) will be ignored when
deciding if the target file(s) need to be rebuilt.</p>

<p style="margin-top: 1em">You can also use Ignore to
remove a target from the default build. In order to do this
you must specify the directory the target will be built in
as the target, and the file <br>
you want to skip building as the dependency.</p>

<p style="margin-top: 1em">Note that this will only remove
the dependencies listed from the files built by default. It
will still be built if that dependency is needed by another
object being built. <br>
See the third and forth examples below.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">env.Ignore(&rsquo;foo&rsquo;,
&rsquo;foo.c&rsquo;) <br>
env.Ignore(&rsquo;bar&rsquo;, [&rsquo;bar1.h&rsquo;,
&rsquo;bar2.h&rsquo;]) <br>
env.Ignore(&rsquo;.&rsquo;,&rsquo;foobar.obj&rsquo;) <br>

env.Ignore(&rsquo;bar&rsquo;,&rsquo;bar/foobar.obj&rsquo;)</p>

<p style="margin-top: 1em">Import(vars), env.Import(vars)
<br>
This tells scons to import a list of variables into the
current SConscript file. This will import variables that
were exported with Export or in the exports argument to <br>
SConscript. Variables exported by SConscript have
precedence. Multiple variable names can be passed to Import
as separate arguments or as a list. The variable
&quot;*&quot; can be used <br>
to import all variables.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">Import(&quot;env&quot;) <br>
Import(&quot;env&quot;, &quot;variable&quot;) <br>
Import([&quot;env&quot;, &quot;variable&quot;]) <br>
Import(&quot;*&quot;)</p>

<p style="margin-top: 1em">Literal(string),
env.Literal(string) <br>
The specified string will be preserved as-is and not have
construction variables expanded.</p>

<p style="margin-top: 1em">Local(targets),
env.Local(targets) <br>
The specified targets will have copies made in the local
tree, even if an already up-to-date copy exists in a
repository. Returns a list of the target Node or Nodes.</p>

<p style="margin-top: 1em">env.MergeFlags(arg, [unique])
<br>
Merges the specified arg values to the construction
environment&rsquo;s construction variables. If the arg
argument is not a dictionary, it is converted to one by
calling <br>
env.ParseFlags on the argument before the values are merged.
Note that arg must be a single value, so multiple strings
must be passed in as a list, not as separate arguments <br>
to env.MergeFlags.</p>

<p style="margin-top: 1em">By default, duplicate values are
eliminated; you can, however, specify unique=0 to allow
duplicate values to be added. When eliminating duplicate
values, any construction <br>
variables that end with the string PATH keep the left-most
unique value. All other construction variables keep the
right-most unique value.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># Add an optimization flag to
$CCFLAGS. <br>
env.MergeFlags(&rsquo;-O3&rsquo;)</p>

<p style="margin-top: 1em"># Combine the flags returned
from running pkg-config with an optimization <br>
# flag and merge the result into the construction variables.
<br>
env.MergeFlags([&rsquo;!pkg-config gtk+-2.0 --cflags&rsquo;,
&rsquo;-O3&rsquo;])</p>

<p style="margin-top: 1em"># Combine an optimization flag
with the flags returned from running pkg-config <br>
# twice and merge the result into the construction
variables. <br>
env.MergeFlags([&rsquo;-O3&rsquo;, <br>
&rsquo;!pkg-config gtk+-2.0 --cflags --libs&rsquo;, <br>
&rsquo;!pkg-config libpng12 --cflags --libs&rsquo;])</p>

<p style="margin-top: 1em">NoCache(target, ...),
env.NoCache(target, ...) <br>
Specifies a list of files which should not be cached
whenever the CacheDir method has been activated. The
specified targets may be a list or an individual target.</p>

<p style="margin-top: 1em">Multiple files should be
specified either as separate arguments to the NoCache
method, or as a list. NoCache will also accept the return
value of any of the construction <br>
environment Builder methods.</p>

<p style="margin-top: 1em">Calling NoCache on directories
and other non-File Node types has no effect because only
File Nodes are cached.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">NoCache(&rsquo;foo.elf&rsquo;)
<br>
NoCache(env.Program(&rsquo;hello&rsquo;,
&rsquo;hello.c&rsquo;))</p>

<p style="margin-top: 1em">NoClean(target, ...),
env.NoClean(target, ...) <br>
Specifies a list of files or directories which should not be
removed whenever the targets (or their dependencies) are
specified with the -c command line option. The specified
<br>
targets may be a list or an individual target. Multiple
calls to NoClean are legal, and prevent each specified
target from being removed by calls to the -c option.</p>

<p style="margin-top: 1em">Multiple files or directories
should be specified either as separate arguments to the
NoClean method, or as a list. NoClean will also accept the
return value of any of the <br>
construction environment Builder methods.</p>

<p style="margin-top: 1em">Calling NoClean for a target
overrides calling Clean for the same target, and any targets
passed to both functions will not be removed by the -c
option.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">NoClean(&rsquo;foo.elf&rsquo;)
<br>
NoClean(env.Program(&rsquo;hello&rsquo;,
&rsquo;hello.c&rsquo;))</p>

<p style="margin-top: 1em">env.ParseConfig(command,
[function, unique]) <br>
Calls the specified function to modify the environment as
specified by the output of command. The default function is
env.MergeFlags, which expects the output of a typical <br>
*-config command (for example, gtk-config) and adds the
options to the appropriate construction variables. By
default, duplicate values are not added to any construction
<br>
variables; you can specify unique=0 to allow duplicate
values to be added.</p>

<p style="margin-top: 1em">Interpreted options and the
construction variables they affect are as specified for the
env.ParseFlags method (which this method calls). See that
method&rsquo;s description, below, <br>
for a table of options and construction variables.</p>

<p style="margin-top: 1em">ParseDepends(filename,
[must_exist, only_one]), env.ParseDepends(filename,
[must_exist, only_one]) <br>
Parses the contents of the specified filename as a list of
dependencies in the style of Make or mkdep, and explicitly
establishes all of the listed dependencies.</p>

<p style="margin-top: 1em">By default, it is not an error
if the specified filename does not exist. The optional
must_exist argument may be set to a non-zero value to have
scons throw an exception and <br>
generate an error if the file does not exist, or is
otherwise inaccessible.</p>

<p style="margin-top: 1em">The optional only_one argument
may be set to a non-zero value to have scons thrown an
exception and generate an error if the file contains
dependency information for more <br>
than one target. This can provide a small sanity check for
files intended to be generated by, for example, the gcc -M
flag, which should typically only write dependency <br>
information for one output file into a corresponding .d
file.</p>

<p style="margin-top: 1em">The filename and all of the
files listed therein will be interpreted relative to the
directory of the SConscript file which calls the
ParseDepends function.</p>

<p style="margin-top: 1em">env.ParseFlags(flags, ...) <br>
Parses one or more strings containing typical command-line
flags for GCC tool chains and returns a dictionary with the
flag values separated into the appropriate SCons <br>
construction variables. This is intended as a companion to
the env.MergeFlags method, but allows for the values in the
returned dictionary to be modified, if necessary, <br>
before merging them into the construction environment. (Note
that env.MergeFlags will call this method if its argument is
not a dictionary, so it is usually not necessary to <br>
call env.ParseFlags directly unless you want to manipulate
the values.)</p>

<p style="margin-top: 1em">If the first character in any
string is an exclamation mark (!), the rest of the string is
executed as a command, and the output from the command is
parsed as GCC tool chain <br>
command-line flags and added to the resulting
dictionary.</p>

<p style="margin-top: 1em">Flag values are translated
accordig to the prefix found, and added to the following
construction variables:</p>

<p style="margin-top: 1em">-arch CCFLAGS, LINKFLAGS <br>
-D CPPDEFINES <br>
-framework FRAMEWORKS <br>
-frameworkdir= FRAMEWORKPATH <br>
-include CCFLAGS <br>
-isysroot CCFLAGS, LINKFLAGS <br>
-I CPPPATH <br>
-l LIBS <br>
-L LIBPATH <br>
-mno-cygwin CCFLAGS, LINKFLAGS <br>
-mwindows LINKFLAGS <br>
-pthread CCFLAGS, LINKFLAGS <br>
-std= CFLAGS <br>
-Wa, ASFLAGS, CCFLAGS <br>
-Wl,-rpath= RPATH <br>
-Wl,-R, RPATH <br>
-Wl,-R RPATH <br>
-Wl, LINKFLAGS <br>
-Wp, CPPFLAGS <br>
- CCFLAGS <br>
+ CCFLAGS, LINKFLAGS</p>

<p style="margin-top: 1em">Any other strings not associated
with options are assumed to be the names of libraries and
added to the $LIBS construction variable.</p>

<p style="margin-top: 1em">Examples (all of which produce
the same result):</p>

<p style="margin-top: 1em">dict = env.ParseFlags(&rsquo;-O2
-Dfoo -Dbar=1&rsquo;) <br>
dict = env.ParseFlags(&rsquo;-O2&rsquo;,
&rsquo;-Dfoo&rsquo;, &rsquo;-Dbar=1&rsquo;) <br>
dict = env.ParseFlags([&rsquo;-O2&rsquo;, &rsquo;-Dfoo
-Dbar=1&rsquo;]) <br>
dict = env.ParseFlags(&rsquo;-O2&rsquo;, &rsquo;!echo -Dfoo
-Dbar=1&rsquo;)</p>

<p style="margin-top: 1em">env.Perforce() <br>
A factory function that returns a Builder object to be used
to fetch source files from the Perforce source code
management system. The returned Builder is intended to be
<br>
passed to the SourceCode function.</p>

<p style="margin-top: 1em">This function is deprecated. For
details, see the entry for the SourceCode function.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env.SourceCode(&rsquo;.&rsquo;,
env.Perforce())</p>

<p style="margin-top: 1em">Perforce uses a number of
external environment variables for its operation.
Consequently, this function adds the following variables
from the user&rsquo;s external environment to <br>
the construction environment&rsquo;s ENV dictionary:
P4CHARSET, P4CLIENT, P4LANGUAGE, P4PASSWD, P4PORT, P4USER,
SystemRoot, USER, and USERNAME.</p>

<p style="margin-top: 1em">Platform(string) <br>
The Platform form returns a callable object that can be used
to initialize a construction environment using the platform
keyword of the Environment function.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env = Environment(platform =
Platform(&rsquo;win32&rsquo;))</p>

<p style="margin-top: 1em">The env.Platform form applies
the callable object for the specified platform string to the
environment through which the method was called.</p>


<p style="margin-top: 1em">env.Platform(&rsquo;posix&rsquo;)</p>

<p style="margin-top: 1em">Note that the win32 platform
adds the SystemDrive and SystemRoot variables from the
user&rsquo;s external environment to the construction
environment&rsquo;s $ENV dictionary. This is so <br>
that any executed commands that use sockets to connect with
other systems (such as fetching source files from external
CVS repository specifications like <br>
:pserver:anonymous@cvs.sourceforge.net:/cvsroot/scons) will
work on Windows systems.</p>

<p style="margin-top: 1em">Precious(target, ...),
env.Precious(target, ...) <br>
Marks each given target as precious so it is not deleted
before it is rebuilt. Normally scons deletes a target before
building it. Multiple targets can be passed in to a <br>
single call to Precious.</p>

<p style="margin-top: 1em">env.Prepend(key=val, [...]) <br>
Appends the specified keyword arguments to the beginning of
construction variables in the environment. If the
Environment does not have the specified construction
variable, <br>
it is simply added to the environment. If the values of the
construction variable and the keyword argument are the same
type, then the two values will be simply added <br>
together. Otherwise, the construction variable and the value
of the keyword argument are both coerced to lists, and the
lists are added together. (See also the Append method, <br>
above.)</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env.Prepend(CCFLAGS = &rsquo;-g
&rsquo;, FOO = [&rsquo;foo.yyy&rsquo;])</p>

<p style="margin-top: 1em">env.PrependENVPath(name,
newpath, [envname, sep, delete_existing]) <br>
This appends new path elements to the given path in the
specified external environment ($ENV by default). This will
only add any particular path once (leaving the first one
<br>
it encounters and ignoring the rest, to preserve path
order), and to help assure this, will normalize all paths
(using os.path.normpath and os.path.normcase). This can also
<br>
handle the case where the given old path variable is a list
instead of a string, in which case a list will be returned
instead of a string.</p>

<p style="margin-top: 1em">If delete_existing is 0, then
adding a path that already exists will not move it to the
beginning; it will stay where it is in the list.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">print
&rsquo;before:&rsquo;,env[&rsquo;ENV&rsquo;][&rsquo;INCLUDE&rsquo;]
<br>
include_path = &rsquo;/foo/bar:/foo&rsquo; <br>
env.PrependENVPath(&rsquo;INCLUDE&rsquo;, include_path) <br>
print
&rsquo;after:&rsquo;,env[&rsquo;ENV&rsquo;][&rsquo;INCLUDE&rsquo;]</p>

<p style="margin-top: 1em">The above example will
print:</p>

<p style="margin-top: 1em">before: /biz:/foo <br>
after: /foo/bar:/foo:/biz</p>

<p style="margin-top: 1em">env.PrependUnique(key=val,
delete_existing=0, [...]) <br>
Appends the specified keyword arguments to the beginning of
construction variables in the environment. If the
Environment does not have the specified construction
variable, <br>
it is simply added to the environment. If the construction
variable being appended to is a list, then any value(s) that
already exist in the construction variable will not be <br>
added again to the list. However, if delete_existing is 1,
existing matching values are removed first, so existing
values in the arg list move to the front of the list.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env.PrependUnique(CCFLAGS =
&rsquo;-g&rsquo;, FOO = [&rsquo;foo.yyy&rsquo;])</p>

<p style="margin-top: 1em">Progress(callable, [interval]),
Progress(string, [interval, file, overwrite]),
Progress(list_of_strings, [interval, file, overwrite]) <br>
Allows SCons to show progress made during the build by
displaying a string or calling a function while evaluating
Nodes (e.g. files).</p>

<p style="margin-top: 1em">If the first specified argument
is a Python callable (a function or an object that has a
__call__() method), the function will be called once every
interval times a Node is <br>
evaluated. The callable will be passed the evaluated Node as
its only argument. (For future compatibility, it&rsquo;s a
good idea to also add *args and **kw as arguments to your
<br>
function or method. This will prevent the code from breaking
if SCons ever changes the interface to call the function
with additional arguments in the future.)</p>

<p style="margin-top: 1em">An example of a simple custom
progress function that prints a string containing the Node
name every 10 Nodes:</p>

<p style="margin-top: 1em">def my_progress_function(node,
*args, **kw): <br>
print &rsquo;Evaluating node %s!&rsquo; % node <br>
Progress(my_progress_function, interval=10)</p>

<p style="margin-top: 1em">A more complicated example of a
custom progress display object that prints a string
containing a count every 100(a carriage return) at evaluated
Nodes. Note the use of <br>
the end so that the string will overwrite itself on a
display:</p>

<p style="margin-top: 1em">import sys <br>
class ProgressCounter(object): <br>
count = 0 <br>
def __call__(self, node, *args, **kw): <br>
self.count += 100 &rsquo; % <br>
sys.stderr.write(&rsquo;Evaluated %s nodes self.count) <br>
Progress(ProgressCounter(), interval=100)</p>

<p style="margin-top: 1em">If the first argument Progress
is a string, the string will be displayed every interval
evaluated Nodes. The default is to print the string on
standard output; an alternate <br>
output stream may be specified with the file= argument. The
following will print a series of dots on the error output,
one dot for every 100 evaluated Nodes:</p>

<p style="margin-top: 1em">import sys <br>
Progress(&rsquo;.&rsquo;, interval=100, file=sys.stderr)</p>

<p style="margin-top: 1em">If the string contains the
verbatim substring $TARGET, it will be replaced with the
Node. Note that, for performance reasons, this is not a
regular SCons variable substition, <br>
so you can not use other variables or use curly braces. The
following example will print the name of every(carriage
return) to cause each line to evaluated Node, using a <br>
overwritten by the next line, and the overwrite= keyword
argument to make sure the previously-printed file name is
overwritten with blank spaces:</p>

<p style="margin-top: 1em">import sys &rsquo;,
overwrite=True) <br>
Progress(&rsquo;$TARGET</p>

<p style="margin-top: 1em">If the first argument to
Progress is a list of strings, then each string in the list
will be displayed in rotating fashion every interval
evaluated Nodes. This can be used to <br>
implement a &quot;spinner&quot; on the user&rsquo;s screen
as follows: &rsquo;], interval=5) &rsquo;, &rsquo;/ &rsquo;,
&rsquo;| &rsquo;, &rsquo;\</p>

<p style="margin-top: 1em">Progress([&rsquo;-</p>

<p style="margin-top: 1em">Pseudo(target, ...),
env.Pseudo(target, ...) <br>
This indicates that each given target should not be created
by the build rule, and if the target is created, an error
will be generated. This is similar to the gnu make <br>
.PHONY target. However, in the vast majority of cases, an
Alias is more appropriate. Multiple targets can be passed in
to a single call to Pseudo.</p>

<p style="margin-top: 1em">env.RCS() <br>
A factory function that returns a Builder object to be used
to fetch source files from RCS. The returned Builder is
intended to be passed to the SourceCode function:</p>

<p style="margin-top: 1em">This function is deprecated. For
details, see the entry for the SourceCode function.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">env.SourceCode(&rsquo;.&rsquo;,
env.RCS())</p>

<p style="margin-top: 1em">Note that scons will fetch
source files from RCS subdirectories automatically, so
configuring RCS as demonstrated in the above example should
only be necessary if you are <br>
fetching from RCS,v files in the same directory as the
source files, or if you need to explicitly specify RCS for a
specific subdirectory.</p>

<p style="margin-top: 1em">env.Replace(key=val, [...]) <br>
Replaces construction variables in the Environment with the
specified keyword arguments.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env.Replace(CCFLAGS =
&rsquo;-g&rsquo;, FOO = &rsquo;foo.xxx&rsquo;)</p>

<p style="margin-top: 1em">Repository(directory),
env.Repository(directory) <br>
Specifies that directory is a repository to be searched for
files. Multiple calls to Repository are legal, and each one
adds to the list of repositories that will be <br>
searched.</p>

<p style="margin-top: 1em">To scons, a repository is a copy
of the source tree, from the top-level directory on down,
which may contain both source files and derived files that
can be used to build <br>
targets in the local source tree. The canonical example
would be an official source tree maintained by an
integrator. If the repository contains derived files, then
the <br>
derived files should have been built using scons, so that
the repository contains the necessary signature information
to allow scons to figure out when it is appropriate to <br>
use the repository copy of a derived file, instead of
building one locally.</p>

<p style="margin-top: 1em">Note that if an up-to-date
derived file already exists in a repository, scons will not
make a copy in the local directory tree. In order to
guarantee that a local copy will <br>
be made, use the Local method.</p>

<p style="margin-top: 1em">Requires(target, prerequisite),
env.Requires(target, prerequisite) <br>
Specifies an order-only relationship between the specified
target file(s) and the specified prerequisite file(s). The
prerequisite file(s) will be (re)built, if necessary, <br>
before the target file(s), but the target file(s) do not
actually depend on the prerequisites and will not be rebuilt
simply because the prerequisite file(s) change.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env.Requires(&rsquo;foo&rsquo;,
&rsquo;file-that-must-be-built-before-foo&rsquo;)</p>

<p style="margin-top: 1em">Return([vars..., stop=]) <br>
By default, this stops processing the current SConscript
file and returns to the calling SConscript file the values
of the variables named in the vars string arguments. <br>
Multiple strings contaning variable names may be passed to
Return. Any strings that contain white space</p>

<p style="margin-top: 1em">The optional stop= keyword
argument may be set to a false value to continue processing
the rest of the SConscript file after the Return call. This
was the default behavior <br>
prior to SCons 0.98. However, the values returned are still
the values of the variables in the named vars at the point
Return is called.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># Returns without returning a
value. <br>
Return()</p>

<p style="margin-top: 1em"># Returns the value of the
&rsquo;foo&rsquo; Python variable. <br>
Return(&quot;foo&quot;)</p>

<p style="margin-top: 1em"># Returns the values of the
Python variables &rsquo;foo&rsquo; and &rsquo;bar&rsquo;.
<br>
Return(&quot;foo&quot;, &quot;bar&quot;)</p>

<p style="margin-top: 1em"># Returns the values of Python
variables &rsquo;val1&rsquo; and &rsquo;val2&rsquo;. <br>
Return(&rsquo;val1 val2&rsquo;)</p>

<p style="margin-top: 1em">Scanner(function, [argument,
keys, path_function, node_class, node_factory, scan_check,
recursive]), env.Scanner(function, [argument, keys,
path_function, node_class, <br>
node_factory, scan_check, recursive]) <br>
Creates a Scanner object for the specified function. See the
section &quot;Scanner Objects,&quot; below, for a complete
explanation of the arguments and behavior.</p>

<p style="margin-top: 1em">env.SCCS() <br>
A factory function that returns a Builder object to be used
to fetch source files from SCCS. The returned Builder is
intended to be passed to the SourceCode function.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env.SourceCode(&rsquo;.&rsquo;,
env.SCCS())</p>

<p style="margin-top: 1em">Note that scons will fetch
source files from SCCS subdirectories automatically, so
configuring SCCS as demonstrated in the above example should
only be necessary if you are <br>
fetching from s.SCCS files in the same directory as the
source files, or if you need to explicitly specify SCCS for
a specific subdirectory.</p>

<p style="margin-top: 1em">SConscript(scripts, [exports,
variant_dir, duplicate]), env.SConscript(scripts, [exports,
variant_dir, duplicate]), SConscript(dirs=subdirs,
[name=script, exports, variant_dir, <br>
duplicate]), env.SConscript(dirs=subdirs, [name=script,
exports, variant_dir, duplicate]) <br>
This tells scons to execute one or more subsidiary
SConscript (configuration) files. Any variables returned by
a called script using Return will be returned by the call to
<br>
SConscript. There are two ways to call the SConscript
function.</p>

<p style="margin-top: 1em">The first way you can call
SConscript is to explicitly specify one or more scripts as
the first argument. A single script may be specified as a
string; multiple scripts must <br>
be specified as a list (either explicitly or as created by a
function like Split). Examples:</p>


<p style="margin-top: 1em">SConscript(&rsquo;SConscript&rsquo;)
# run SConscript in the current directory <br>
SConscript(&rsquo;src/SConscript&rsquo;) # run SConscript in
the src directory <br>
SConscript([&rsquo;src/SConscript&rsquo;,
&rsquo;doc/SConscript&rsquo;]) <br>
config = SConscript(&rsquo;MyConfig.py&rsquo;)</p>

<p style="margin-top: 1em">The second way you can call
SConscript is to specify a list of (sub)directory names as a
dirs=subdirs keyword argument. In this case, scons will, by
default, execute a <br>
subsidiary configuration file named SConscript in each of
the specified directories. You may specify a name other than
SConscript by supplying an optional name=script keyword <br>
argument. The first three examples below have the same
effect as the first three examples above:</p>


<p style="margin-top: 1em">SConscript(dirs=&rsquo;.&rsquo;)
# run SConscript in the current directory <br>
SConscript(dirs=&rsquo;src&rsquo;) # run SConscript in the
src directory <br>
SConscript(dirs=[&rsquo;src&rsquo;, &rsquo;doc&rsquo;]) <br>
SConscript(dirs=[&rsquo;sub1&rsquo;, &rsquo;sub2&rsquo;],
name=&rsquo;MySConscript&rsquo;)</p>

<p style="margin-top: 1em">The optional exports argument
provides a list of variable names or a dictionary of named
values to export to the script(s). These variables are
locally exported only to the <br>
specified script(s), and do not affect the global pool of
variables used by the Export function. The subsidiary
script(s) must use the Import function to import the <br>
variables. Examples:</p>

<p style="margin-top: 1em">foo =
SConscript(&rsquo;sub/SConscript&rsquo;,
exports=&rsquo;env&rsquo;) <br>
SConscript(&rsquo;dir/SConscript&rsquo;,
exports=[&rsquo;env&rsquo;, &rsquo;variable&rsquo;]) <br>
SConscript(dirs=&rsquo;subdir&rsquo;, exports=&rsquo;env
variable&rsquo;) <br>
SConscript(dirs=[&rsquo;one&rsquo;, &rsquo;two&rsquo;,
&rsquo;three&rsquo;], exports=&rsquo;shared_info&rsquo;)</p>

<p style="margin-top: 1em">If the optional variant_dir
argument is present, it causes an effect equivalent to the
VariantDir method described below. (If variant_dir is not
present, the</p>

<p style="margin-top: 1em">duplicate argument is ignored.)
The variant_dir argument is interpreted relative to the
directory of the calling SConscript file. See the
description of the VariantDir <br>
function below for additional details and restrictions.</p>

<p style="margin-top: 1em">If variant_dir is present, the
source directory is the directory in which the SConscript
file resides and the SConscript file is evaluated as if it
were in the variant_dir <br>
directory:</p>


<p style="margin-top: 1em">SConscript(&rsquo;src/SConscript&rsquo;,
variant_dir = &rsquo;build&rsquo;)</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">VariantDir(&rsquo;build&rsquo;,
&rsquo;src&rsquo;) <br>
SConscript(&rsquo;build/SConscript&rsquo;)</p>

<p style="margin-top: 1em">This later paradigm is often
used when the sources are in the same directory as the
SConstruct:</p>


<p style="margin-top: 1em">SConscript(&rsquo;SConscript&rsquo;,
variant_dir = &rsquo;build&rsquo;)</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">VariantDir(&rsquo;build&rsquo;,
&rsquo;.&rsquo;) <br>
SConscript(&rsquo;build/SConscript&rsquo;)</p>

<p style="margin-top: 1em">Here are some composite
examples:</p>

<p style="margin-top: 1em"># collect the configuration
information and use it to build src and doc <br>
shared_info = SConscript(&rsquo;MyConfig.py&rsquo;) <br>
SConscript(&rsquo;src/SConscript&rsquo;,
exports=&rsquo;shared_info&rsquo;) <br>
SConscript(&rsquo;doc/SConscript&rsquo;,
exports=&rsquo;shared_info&rsquo;)</p>

<p style="margin-top: 1em"># build debugging and production
versions. SConscript <br>
# can use Dir(&rsquo;.&rsquo;).path to determine variant.
<br>
SConscript(&rsquo;SConscript&rsquo;,
variant_dir=&rsquo;debug&rsquo;, duplicate=0) <br>
SConscript(&rsquo;SConscript&rsquo;,
variant_dir=&rsquo;prod&rsquo;, duplicate=0)</p>

<p style="margin-top: 1em"># build debugging and production
versions. SConscript <br>
# is passed flags to use. <br>
opts = { &rsquo;CPPDEFINES&rsquo; : [&rsquo;DEBUG&rsquo;],
&rsquo;CCFLAGS&rsquo; : &rsquo;-pgdb&rsquo; } <br>
SConscript(&rsquo;SConscript&rsquo;,
variant_dir=&rsquo;debug&rsquo;, duplicate=0, exports=opts)
<br>
opts = { &rsquo;CPPDEFINES&rsquo; : [&rsquo;NODEBUG&rsquo;],
&rsquo;CCFLAGS&rsquo; : &rsquo;-O&rsquo; } <br>
SConscript(&rsquo;SConscript&rsquo;,
variant_dir=&rsquo;prod&rsquo;, duplicate=0,
exports=opts)</p>

<p style="margin-top: 1em"># build common documentation and
compile for different architectures <br>
SConscript(&rsquo;doc/SConscript&rsquo;,
variant_dir=&rsquo;build/doc&rsquo;, duplicate=0) <br>
SConscript(&rsquo;src/SConscript&rsquo;,
variant_dir=&rsquo;build/x86&rsquo;, duplicate=0) <br>
SConscript(&rsquo;src/SConscript&rsquo;,
variant_dir=&rsquo;build/ppc&rsquo;, duplicate=0)</p>

<p style="margin-top: 1em">SConscriptChdir(value),
env.SConscriptChdir(value) <br>
By default, scons changes its working directory to the
directory in which each subsidiary SConscript file lives.
This behavior may be disabled by specifying either:</p>

<p style="margin-top: 1em">SConscriptChdir(0) <br>
env.SConscriptChdir(0)</p>

<p style="margin-top: 1em">in which case scons will stay in
the top-level directory while reading all SConscript files.
(This may be necessary when building from repositories, when
all the directories <br>
in which SConscript files may be found don&rsquo;t
necessarily exist locally.) You may enable and disable this
ability by calling SConscriptChdir() multiple times.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">env = Environment() <br>
SConscriptChdir(0) <br>
SConscript(&rsquo;foo/SConscript&rsquo;) # will not chdir to
foo <br>
env.SConscriptChdir(1) <br>
SConscript(&rsquo;bar/SConscript&rsquo;) # will chdir to
bar</p>

<p style="margin-top: 1em">SConsignFile([file,
dbm_module]), env.SConsignFile([file, dbm_module]) <br>
This tells scons to store all file signatures in the
specified database file. If the file name is omitted,
.sconsign is used by default. (The actual file name(s)
stored on <br>
disk may have an appropriated suffix appended by the <br>
dbm_module.) If file is not an absolute path name, the file
is placed in the same directory as the top-level SConstruct
file.</p>

<p style="margin-top: 1em">If file is None, then scons will
store file signatures in a separate .sconsign file in each
directory, not in one global database file. (This was the
default behavior prior <br>
to SCons 0.96.91 and 0.97.)</p>

<p style="margin-top: 1em">The optional dbm_module argument
can be used to specify which Python database module The
default is to use a custom SCons.dblite module that uses
pickled Python data <br>
structures, and which works on all Python versions.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># Explicitly stores signatures
in &quot;.sconsign.dblite&quot; <br>
# in the top-level SConstruct directory (the <br>
# default behavior). <br>
SConsignFile()</p>

<p style="margin-top: 1em"># Stores signatures in the file
&quot;etc/scons-signatures&quot; <br>
# relative to the top-level SConstruct directory. <br>
SConsignFile(&quot;etc/scons-signatures&quot;)</p>

<p style="margin-top: 1em"># Stores signatures in the
specified absolute file name. <br>
SConsignFile(&quot;/home/me/SCons/signatures&quot;)</p>

<p style="margin-top: 1em"># Stores signatures in a
separate .sconsign file <br>
# in each directory. <br>
SConsignFile(None)</p>

<p style="margin-top: 1em">env.SetDefault(key=val, [...])
<br>
Sets construction variables to default values specified with
the keyword arguments if (and only if) the variables are not
already set. The following statements are <br>
equivalent:</p>

<p style="margin-top: 1em">env.SetDefault(FOO =
&rsquo;foo&rsquo;)</p>

<p style="margin-top: 1em">if &rsquo;FOO&rsquo; not in env:
env[&rsquo;FOO&rsquo;] = &rsquo;foo&rsquo;</p>

<p style="margin-top: 1em">SetOption(name, value),
env.SetOption(name, value) <br>
This function provides a way to set a select subset of the
scons command line options from a SConscript file. The
options supported are:</p>

<p style="margin-top: 1em">clean <br>
which corresponds to -c, --clean and --remove;</p>

<p style="margin-top: 1em">duplicate <br>
which corresponds to --duplicate;</p>

<p style="margin-top: 1em">help <br>
which corresponds to -h and --help;</p>

<p style="margin-top: 1em">implicit_cache <br>
which corresponds to --implicit-cache;</p>

<p style="margin-top: 1em">max_drift <br>
which corresponds to --max-drift;</p>

<p style="margin-top: 1em">no_exec <br>
which corresponds to -n, --no-exec, --just-print, --dry-run
and --recon;</p>

<p style="margin-top: 1em">num_jobs <br>
which corresponds to -j and --jobs;</p>

<p style="margin-top: 1em">random <br>
which corresponds to --random; and</p>

<p style="margin-top: 1em">stack_size <br>
which corresponds to --stack-size.</p>

<p style="margin-top: 1em">See the documentation for the
corresponding command line object for information about each
specific option.</p>

<p style="margin-top: 1em">Example:</p>


<p style="margin-top: 1em">SetOption(&rsquo;max_drift&rsquo;,
1)</p>

<p style="margin-top: 1em">SideEffect(side_effect, target),
env.SideEffect(side_effect, target) <br>
Declares side_effect as a side effect of building target.
Both side_effect and target can be a list, a file name, or a
node. A side effect is a target file that is created or <br>
updated as a side effect of building other targets. For
example, a Windows PDB file is created as a side effect of
building the .obj files for a static library, and various
<br>
log files are created updated as side effects of various TeX
commands. If a target is a side effect of multiple build
commands, scons will ensure that only one set of <br>
commands is executed at a time. Consequently, you only need
to use this method for side-effect targets that are built as
a result of multiple build commands.</p>

<p style="margin-top: 1em">Because multiple build commands
may update the same side effect file, by default the
side_effect target is not automatically removed when the
target is removed by the -c <br>
option. (Note, however, that the side_effect might be
removed as part of cleaning the directory in which it
lives.) If you want to make sure the side_effect is cleaned
<br>
whenever a specific target is cleaned, you must specify this
explicitly with the Clean or env.Clean function.</p>

<p style="margin-top: 1em">SourceCode(entries, builder),
env.SourceCode(entries, builder) <br>
This function and its associate factory functions are
deprecated. There is no replacement. The intended use was to
keep a local tree in sync with an archive, but in actuality
<br>
the function only causes the archive to be fetched on the
first run. Synchronizing with the archive is best done
external to SCons.</p>

<p style="margin-top: 1em">Arrange for non-existent source
files to be fetched from a source code management system
using the specified builder. The specified entries may be a
Node, string or list of <br>
both, and may represent either individual source files or
directories in which source files can be found.</p>

<p style="margin-top: 1em">For any non-existent source
files, scons will search up the directory tree and use the
first SourceCode builder it finds. The specified builder may
be None, in which case <br>
scons will not use a builder to fetch source files for the
specified entries, even if a SourceCode builder has been
specified for a directory higher up the tree.</p>

<p style="margin-top: 1em">scons will, by default, fetch
files from SCCS or RCS subdirectories without explicit
configuration. This takes some extra processing time to
search for the necessary source <br>
code management files on disk. You can avoid these extra
searches and speed up your build a little by disabling these
searches as follows:</p>

<p style="margin-top: 1em">env.SourceCode(&rsquo;.&rsquo;,
None)</p>

<p style="margin-top: 1em">Note that if the specified
builder is one you create by hand, it must have an
associated construction environment to use when fetching a
source file.</p>

<p style="margin-top: 1em">scons provides a set of canned
factory functions that return appropriate Builders for
various popular source code management systems. Canonical
examples of invocation <br>
include:</p>

<p style="margin-top: 1em">env.SourceCode(&rsquo;.&rsquo;,
env.BitKeeper(&rsquo;/usr/local/BKsources&rsquo;)) <br>
env.SourceCode(&rsquo;src&rsquo;,
env.CVS(&rsquo;/usr/local/CVSROOT&rsquo;)) <br>
env.SourceCode(&rsquo;/&rsquo;, env.RCS()) <br>
env.SourceCode([&rsquo;f1.c&rsquo;, &rsquo;f2.c&rsquo;],
env.SCCS()) <br>
env.SourceCode(&rsquo;no_source.c&rsquo;, None)</p>

<p style="margin-top: 1em">SourceSignatures(type),
env.SourceSignatures(type) <br>
Note: Although it is not yet officially deprecated, use of
this function is discouraged. See the Decider function for a
more flexible and straightforward way to configure <br>
SCons&rsquo; decision-making.</p>

<p style="margin-top: 1em">The SourceSignatures function
tells scons how to decide if a source file (a file that is
not built from any other files) has changed since the last
time it was used to build <br>
a particular target file. Legal values are MD5 or
timestamp.</p>

<p style="margin-top: 1em">If the environment method is
used, the specified type of source signature is only used
when deciding whether targets built with that environment
are up-to-date or must be <br>
rebuilt. If the global function is used, the specified type
of source signature becomes the default used for all
decisions about whether targets are up-to-date.</p>

<p style="margin-top: 1em">MD5 means scons decides that a
source file has changed if the MD5 checksum of its contents
has changed since the last time it was used to rebuild a
particular target file.</p>

<p style="margin-top: 1em">timestamp means scons decides
that a source file has changed if its timestamp
(modification time) has changed since the last time it was
used to rebuild a particular target <br>
file. (Note that although this is similar to the behavior of
Make, by default it will also rebuild if the dependency is
older than the last time it was used to rebuild the <br>
target file.)</p>

<p style="margin-top: 1em">There is no different between
the two behaviors for Python Value node objects.</p>

<p style="margin-top: 1em">MD5 signatures take longer to
compute, but are more accurate than timestamp signatures.
The default value is MD5.</p>

<p style="margin-top: 1em">Note that the default
TargetSignatures setting (see below) is to use this
SourceSignatures setting for any target files that are used
to build other target files. <br>
Consequently, changing the value of SourceSignatures will,
by default, affect the up-to-date decision for all files in
the build (or all files built with a specific <br>
construction environment when env.SourceSignatures is
used).</p>

<p style="margin-top: 1em">Split(arg), env.Split(arg) <br>
Returns a list of file names or other objects. If arg is a
string, it will be split on strings of white-space
characters within the string, making it easier to write long
<br>
lists of file names. If arg is already a list, the list will
be returned untouched. If arg is any other type of object,
it will be returned as a list containing just the <br>
object.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">files = Split(&quot;f1.c f2.c
f3.c&quot;) <br>
files = env.Split(&quot;f4.c f5.c f6.c&quot;) <br>
files = Split(&quot;&quot;&quot; <br>
f7.c <br>
f8.c <br>
f9.c <br>
&quot;&quot;&quot;)</p>

<p style="margin-top: 1em">env.subst(input, [raw, target,
source, conv]) <br>
Performs construction variable interpolation on the
specified string or sequence argument input.</p>

<p style="margin-top: 1em">By default, leading or trailing
white space will be removed from the result. and all
sequences of white space will be compressed to a single
space character. Additionally, <br>
any $( and $) character sequences will be stripped from the
returned string, The optional raw argument may be set to 1
if you want to preserve white space and $(-$) <br>
sequences. The raw argument may be set to 2 if you want to
strip all characters between any $( and $) pairs (as is done
for signature calculation).</p>

<p style="margin-top: 1em">If the input is a sequence (list
or tuple), the individual elements of the sequence will be
expanded, and the results will be returned as a list.</p>

<p style="margin-top: 1em">The optional target and source
keyword arguments must be set to lists of target and source
nodes, respectively, if you want the $TARGET, $TARGETS,
$SOURCE and $SOURCES to be <br>
available for expansion. This is usually necessary if you
are calling env.subst from within a Python function used as
an SCons action.</p>

<p style="margin-top: 1em">Returned string values or
sequence elements are converted to their string
representation by default. The optional conv argument may
specify a conversion function that will be <br>
used in place of the default. For example, if you want
Python objects (including SCons Nodes) to be returned as
Python objects, you can use the Python &Icirc; idiom to pass
in an <br>
unnamed function that simply returns its unconverted
argument.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">print env.subst(&quot;The C
compiler is: $CC&quot;)</p>

<p style="margin-top: 1em">def compile(target, source,
env): <br>
sourceDir = env.subst(&quot;${SOURCE.srcdir}&quot;, <br>
target=target, <br>
source=source)</p>

<p style="margin-top: 1em">source_nodes =
env.subst(&rsquo;$EXPAND_TO_NODELIST&rsquo;, <br>
conv=lambda x: x)</p>

<p style="margin-top: 1em">Tag(node, tags) <br>
Annotates file or directory Nodes with information about how
the Package Builder should package those files or
directories. All tags are optional.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># makes sure the built library
will be installed with 0644 file <br>
# access mode <br>
Tag( Library( &rsquo;lib.c&rsquo; ),
UNIX_ATTR=&quot;0644&quot; )</p>

<p style="margin-top: 1em"># marks file2.txt to be a
documentation file <br>
Tag( &rsquo;file2.txt&rsquo;, DOC )</p>

<p style="margin-top: 1em">TargetSignatures(type),
env.TargetSignatures(type) <br>
Note: Although it is not yet officially deprecated, use of
this function is discouraged. See the Decider function for a
more flexible and straightforward way to configure <br>
SCons&rsquo; decision-making.</p>

<p style="margin-top: 1em">The TargetSignatures function
tells scons how to decide if a target file (a file that is
built from any other files) has changed since the last time
it was used to build some <br>
other target file. Legal values are &quot;build&quot;;
&quot;content&quot; (or its synonym &quot;MD5&quot;);
&quot;timestamp&quot;; or &quot;source&quot;.</p>

<p style="margin-top: 1em">If the environment method is
used, the specified type of target signature is only used
for targets built with that environment. If the global
function is used, the specified <br>
type of signature becomes the default used for all target
files that don&rsquo;t have an explicit target signature
type specified for their environments.</p>

<p style="margin-top: 1em">&quot;content&quot; (or its
synonym &quot;MD5&quot;) means scons decides that a target
file has changed if the MD5 checksum of its contents has
changed since the last time it was used to rebuild <br>
some other target file. This means scons will open up MD5
sum the contents of target files after they&rsquo;re built,
and may decide that it does not need to rebuild
&quot;downstream&quot; <br>
target files if a file was rebuilt with exactly the same
contents as the last time.</p>

<p style="margin-top: 1em">&quot;timestamp&quot; means
scons decides that a target file has changed if its
timestamp (modification time) has changed since the last
time it was used to rebuild some other target <br>
file. (Note that although this is similar to the behavior of
Make, by default it will also rebuild if the dependency is
older than the last time it was used to rebuild the <br>
target file.)</p>

<p style="margin-top: 1em">&quot;source&quot; means scons
decides that a target file has changed as specified by the
corresponding SourceSignatures setting (&quot;MD5&quot; or
&quot;timestamp&quot;). This means that scons will <br>
treat all input files to a target the same way, regardless
of whether they are source files or have been built from
other files.</p>

<p style="margin-top: 1em">&quot;build&quot; means scons
decides that a target file has changed if it has been
rebuilt in this invocation or if its content or timestamp
have changed as specified by the <br>
corresponding SourceSignatures setting. This
&quot;propagates&quot; the status of a rebuilt file so that
other &quot;downstream&quot; target files will always be
rebuilt, even if the contents or <br>
the timestamp have not changed.</p>

<p style="margin-top: 1em">&quot;build&quot; signatures are
fastest because &quot;content&quot; (or &quot;MD5&quot;)
signatures take longer to compute, but are more accurate
than &quot;timestamp&quot; signatures, and can prevent
unnecessary <br>
&quot;downstream&quot; rebuilds when a target file is
rebuilt to the exact same contents as the previous build.
The &quot;source&quot; setting provides the most consistent
behavior when other <br>
target files may be rebuilt from both source and target
input files. The default value is &quot;source&quot;.</p>

<p style="margin-top: 1em">Because the default setting is
&quot;source&quot;, using SourceSignatures is generally
preferable to TargetSignatures, so that the up-to-date
decision will be consistent for all files <br>
(or all files built with a specific construction
environment). Use of TargetSignatures provides specific
control for how built target files affect their
&quot;downstream&quot; <br>
dependencies.</p>

<p style="margin-top: 1em">Tool(string, [toolpath, **kw]),
env.Tool(string, [toolpath, **kw]) <br>
The Tool form of the function returns a callable object that
can be used to initialize a construction environment using
the tools keyword of the Environment() method. The <br>
object may be called with a construction environment as an
argument, in which case the object will add the necessary
variables to the construction environment and the name of
<br>
the tool will be added to the $TOOLS construction
variable.</p>

<p style="margin-top: 1em">Additional keyword arguments are
passed to the tool&rsquo;s generate() method.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">env = Environment(tools = [
Tool(&rsquo;msvc&rsquo;) ])</p>

<p style="margin-top: 1em">env = Environment() <br>
t = Tool(&rsquo;msvc&rsquo;) <br>
t(env) # adds &rsquo;msvc&rsquo; to the TOOLS variable <br>
u = Tool(&rsquo;opengl&rsquo;, toolpath =
[&rsquo;tools&rsquo;]) <br>
u(env) # adds &rsquo;opengl&rsquo; to the TOOLS variable</p>

<p style="margin-top: 1em">The env.Tool form of the
function applies the callable object for the specified tool
string to the environment through which the method was
called.</p>

<p style="margin-top: 1em">Additional keyword arguments are
passed to the tool&rsquo;s generate() method.</p>

<p style="margin-top: 1em">env.Tool(&rsquo;gcc&rsquo;) <br>
env.Tool(&rsquo;opengl&rsquo;, toolpath =
[&rsquo;build/tools&rsquo;])</p>

<p style="margin-top: 1em">Value(value, [built_value]),
env.Value(value, [built_value]) <br>
Returns a Node object representing the specified Python
value. Value Nodes can be used as dependencies of targets.
If the result of calling str(value) changes between SCons
<br>
runs, any targets depending on Value(value) will be rebuilt.
(This is true even when using timestamps to decide if files
are up-to-date.) When using timestamp source <br>
signatures, Value Nodes&rsquo; timestamps are equal to the
system time when the Node is created.</p>

<p style="margin-top: 1em">The returned Value Node object
has a write() method that can be used to &quot;build&quot; a
Value Node by setting a new value. The optional built_value
argument can be specified when <br>
the Value Node is created to indicate the Node should
already be considered &quot;built.&quot; There is a
corresponding read() method that will return the built value
of the Node.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">env = Environment()</p>

<p style="margin-top: 1em">def create(target, source, env):
<br>
# A function that will write a &rsquo;prefix=$SOURCE&rsquo;
<br>
# string into the file name specified as the <br>
# $TARGET. <br>
f = open(str(target[0]), &rsquo;wb&rsquo;) <br>
f.write(&rsquo;prefix=&rsquo; +
source[0].get_contents())</p>

<p style="margin-top: 1em"># Fetch the prefix= argument, if
any, from the command <br>
# line, and use /usr/local as the default. <br>
prefix = ARGUMENTS.get(&rsquo;prefix&rsquo;,
&rsquo;/usr/local&rsquo;)</p>

<p style="margin-top: 1em"># Attach a .Config() builder for
the above function action <br>
# to the construction environment. <br>
env[&rsquo;BUILDERS&rsquo;][&rsquo;Config&rsquo;] =
Builder(action = create) <br>
env.Config(target = &rsquo;package-config&rsquo;, source =
Value(prefix))</p>

<p style="margin-top: 1em">def build_value(target, source,
env): <br>
# A function that &quot;builds&quot; a Python Value by
updating <br>
# the the Python value with the contents of the file <br>
# specified as the source of the Builder call ($SOURCE).
<br>
target[0].write(source[0].get_contents())</p>

<p style="margin-top: 1em">output =
env.Value(&rsquo;before&rsquo;) <br>
input = env.Value(&rsquo;after&rsquo;)</p>

<p style="margin-top: 1em"># Attach a .UpdateValue()
builder for the above function <br>
# action to the construction environment. <br>
env[&rsquo;BUILDERS&rsquo;][&rsquo;UpdateValue&rsquo;] =
Builder(action = build_value) <br>
env.UpdateValue(target = Value(output), source =
Value(input))</p>

<p style="margin-top: 1em">VariantDir(variant_dir, src_dir,
[duplicate]), env.VariantDir(variant_dir, src_dir,
[duplicate]) <br>
Use the VariantDir function to create a copy of your sources
in another location: if a name under variant_dir is not
found but exists under src_dir, the file or directory is
<br>
copied to variant_dir. Target files can be built in a
different directory than the original sources by simply
refering to the sources (and targets) within the variant
tree.</p>

<p style="margin-top: 1em">VariantDir can be called
multiple times with the same src_dir to set up multiple
builds with different options (variants). The src_dir
location must be in or underneath the <br>
SConstruct file&rsquo;s directory, and variant_dir may not
be underneath src_dir.</p>

<p style="margin-top: 1em">The default behavior is for
scons to physically duplicate the source files in the
variant tree. Thus, a build performed in the variant tree is
guaranteed to be identical to a <br>
build performed in the source tree even if intermediate
source files are generated during the build, or
preprocessors or other scanners search for included files
relative to <br>
the source file, or individual compilers or other invoked
tools are hard-coded to put derived files in the same
directory as source files.</p>

<p style="margin-top: 1em">If possible on the platform, the
duplication is performed by linking rather than copying; see
also the --duplicate command-line option. Moreover, only the
files needed for <br>
the build are duplicated; files and directories that are not
used are not present in variant_dir.</p>

<p style="margin-top: 1em">Duplicating the source tree may
be disabled by setting the duplicate argument to 0 (zero).
This will cause scons to invoke Builders using the path
names of source files in <br>
src_dir and the path names of derived files within
variant_dir. This is always more efficient than duplicate=1,
and is usually safe for most builds (but see above for cases
<br>
that may cause problems).</p>

<p style="margin-top: 1em">Note that VariantDir works most
naturally with a subsidiary SConscript file. However, you
would then call the subsidiary SConscript file not in the
source directory, but in <br>
the variant_dir, regardless of the value of duplicate. This
is how you tell scons which variant of a source tree to
build:</p>

<p style="margin-top: 1em"># run src/SConscript in two
variant directories <br>
VariantDir(&rsquo;build/variant1&rsquo;, &rsquo;src&rsquo;)
<br>
SConscript(&rsquo;build/variant1/SConscript&rsquo;) <br>
VariantDir(&rsquo;build/variant2&rsquo;, &rsquo;src&rsquo;)
<br>
SConscript(&rsquo;build/variant2/SConscript&rsquo;)</p>

<p style="margin-top: 1em">See also the SConscript
function, described above, for another way to specify a
variant directory in conjunction with calling a subsidiary
SConscript file.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># use names in the build
directory, not the source directory <br>
VariantDir(&rsquo;build&rsquo;, &rsquo;src&rsquo;,
duplicate=0) <br>
Program(&rsquo;build/prog&rsquo;,
&rsquo;build/source.c&rsquo;)</p>

<p style="margin-top: 1em"># this builds both the source
and docs in a separate subtree <br>
VariantDir(&rsquo;build&rsquo;, &rsquo;.&rsquo;,
duplicate=0) <br>

SConscript(dirs=[&rsquo;build/src&rsquo;,&rsquo;build/doc&rsquo;])</p>

<p style="margin-top: 1em"># same as previous example, but
only uses SConscript <br>
SConscript(dirs=&rsquo;src&rsquo;,
variant_dir=&rsquo;build/src&rsquo;, duplicate=0) <br>
SConscript(dirs=&rsquo;doc&rsquo;,
variant_dir=&rsquo;build/doc&rsquo;, duplicate=0)</p>

<p style="margin-top: 1em">WhereIs(program, [path, pathext,
reject]), env.WhereIs(program, [path, pathext, reject]) <br>
Searches for the specified executable program, returning the
full path name to the program if it is found, and returning
None if not. Searches the specified path, the value <br>
of the calling environment&rsquo;s PATH
(env[&rsquo;ENV&rsquo;][&rsquo;PATH&rsquo;]), or the
user&rsquo;s current external PATH
(os.environ[&rsquo;PATH&rsquo;]) by default. On Windows
systems, searches for executable <br>
programs with any of the file extensions listed in the
specified pathext, the calling environment&rsquo;s PATHEXT
(env[&rsquo;ENV&rsquo;][&rsquo;PATHEXT&rsquo;]) or the
user&rsquo;s current PATHEXT <br>
(os.environ[&rsquo;PATHEXT&rsquo;]) by default. Will not
select any path name or names in the specified reject list,
if any.</p>

<p style="margin-top: 1em">SConscript Variables <br>
In addition to the global functions and methods, scons
supports a number of Python variables that can be used in
SConscript files to affect how you want the build to be <br>
performed. These variables may be accessed from custom
Python modules that you import into an SConscript file by
adding the following to the Python module:</p>

<p style="margin-top: 1em">from SCons.Script import *</p>

<p style="margin-top: 1em">ARGLIST <br>
A list keyword=value arguments specified on the command
line. Each element in the list is a tuple containing the
(keyword,value) of the argument. The separate keyword and
<br>
value elements of the tuple can be accessed by subscripting
for element [0] and [1] of the tuple, respectively.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">print &quot;first keyword, value
=&quot;, ARGLIST[0][0], ARGLIST[0][1] <br>
print &quot;second keyword, value =&quot;, ARGLIST[1][0],
ARGLIST[1][1] <br>
third_tuple = ARGLIST[2] <br>
print &quot;third keyword, value =&quot;, third_tuple[0],
third_tuple[1] <br>
for key, value in ARGLIST: <br>
# process key and value</p>

<p style="margin-top: 1em">ARGUMENTS <br>
A dictionary of all the keyword=value arguments specified on
the command line. The dictionary is not in order, and if a
given keyword has more than one value assigned to it <br>
on the command line, the last (right-most) value is the one
in the ARGUMENTS dictionary.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">if
ARGUMENTS.get(&rsquo;debug&rsquo;, 0): <br>
env = Environment(CCFLAGS = &rsquo;-g&rsquo;) <br>
else: <br>
env = Environment()</p>

<p style="margin-top: 1em">BUILD_TARGETS <br>
A list of the targets which scons will actually try to
build, regardless of whether they were specified on the
command line or via the Default() function or method. The
<br>
elements of this list may be strings or nodes, so you should
run the list through the Python str function to make sure
any Node path names are converted to strings.</p>

<p style="margin-top: 1em">Because this list may be taken
from the list of targets specified using the Default()
function or method, the contents of the list may change on
each successive call to <br>
Default(). See the DEFAULT_TARGETS list, below, for
additional information.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">if &rsquo;foo&rsquo; in
BUILD_TARGETS: <br>
print &quot;Don&rsquo;t forget to test the &lsquo;foo&rsquo;
program!&quot; <br>
if &rsquo;special/program&rsquo; in BUILD_TARGETS: <br>
SConscript(&rsquo;special&rsquo;)</p>

<p style="margin-top: 1em">Note that the BUILD_TARGETS list
only contains targets expected listed on the command line or
via calls to the Default() function or method. It does not
contain all dependent <br>
targets that will be built as a result of making the sure
the explicitly-specified targets are up to date.</p>

<p style="margin-top: 1em">COMMAND_LINE_TARGETS <br>
A list of the targets explicitly specified on the command
line. If there are no targets specified on the command line,
the list is empty. This can be used, for example, to <br>
take specific actions only when a certain target or targets
is explicitly being built.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">if &rsquo;foo&rsquo; in
COMMAND_LINE_TARGETS: <br>
print &quot;Don&rsquo;t forget to test the &lsquo;foo&rsquo;
program!&quot; <br>
if &rsquo;special/program&rsquo; in COMMAND_LINE_TARGETS:
<br>
SConscript(&rsquo;special&rsquo;)</p>

<p style="margin-top: 1em">DEFAULT_TARGETS <br>
A list of the target nodes that have been specified using
the Default() function or method. The elements of the list
are nodes, so you need to run them through the Python str
<br>
function to get at the path name for each Node.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">print str(DEFAULT_TARGETS[0])
<br>
if &rsquo;foo&rsquo; in map(str, DEFAULT_TARGETS): <br>
print &quot;Don&rsquo;t forget to test the &lsquo;foo&rsquo;
program!&quot;</p>

<p style="margin-top: 1em">The contents of the
DEFAULT_TARGETS list change on on each successive call to
the Default() function:</p>

<p style="margin-top: 1em">print map(str, DEFAULT_TARGETS)
# originally [] <br>
Default(&rsquo;foo&rsquo;) <br>
print map(str, DEFAULT_TARGETS) # now a node
[&rsquo;foo&rsquo;] <br>
Default(&rsquo;bar&rsquo;) <br>
print map(str, DEFAULT_TARGETS) # now a node
[&rsquo;foo&rsquo;, &rsquo;bar&rsquo;] <br>
Default(None) <br>
print map(str, DEFAULT_TARGETS) # back to []</p>

<p style="margin-top: 1em">Consequently, be sure to use
DEFAULT_TARGETS only after you&rsquo;ve made all of your
Default() calls, or else simply be careful of the order of
these statements in your SConscript <br>
files so that you don&rsquo;t look for a specific default
target before it&rsquo;s actually been added to the
list.</p>

<p style="margin-top: 1em">Construction Variables <br>
A construction environment has an associated dictionary of
construction variables that are used by built-in or
user-supplied build rules. Construction variables must
follow the <br>
same rules for Python identifiers: the initial character
must be an underscore or letter, followed by any number of
underscores, letters, or digits.</p>

<p style="margin-top: 1em">A number of useful construction
variables are automatically defined by scons for each
supported platform, and additional construction variables
can be defined by the user. The <br>
following is a list of the automatically defined
construction variables:</p>

<p style="margin-top: 1em">__LDMODULEVERSIONFLAGS <br>
This construction variable automatically introduces
$_LDMODULEVERSIONFLAGS if $LDMODULEVERSION is set. Othervise
it evaluates to an empty string.</p>

<p style="margin-top: 1em">__SHLIBVERSIONFLAGS <br>
This construction variable automatically introduces
$_SHLIBVERSIONFLAGS if $SHLIBVERSION is set. Othervise it
evaluates to an empty string.</p>

<p style="margin-top: 1em">AR <br>
The static library archiver.</p>

<p style="margin-top: 1em">ARCHITECTURE <br>
Specifies the system architecture for which the package is
being built. The default is the system architecture of the
machine on which SCons is running. This is used to fill <br>
in the Architecture: field in an Ipkg control file, and as
part of the name of a generated RPM file.</p>

<p style="margin-top: 1em">ARCOM <br>
The command line used to generate a static library from
object files.</p>

<p style="margin-top: 1em">ARCOMSTR <br>
The string displayed when an object file is generated from
an assembly-language source file. If this is not set, then
$ARCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(ARCOMSTR =
&quot;Archiving $TARGET&quot;)</p>

<p style="margin-top: 1em">ARFLAGS <br>
General options passed to the static library archiver.</p>

<p style="margin-top: 1em">AS <br>
The assembler.</p>

<p style="margin-top: 1em">ASCOM <br>
The command line used to generate an object file from an
assembly-language source file.</p>

<p style="margin-top: 1em">ASCOMSTR <br>
The string displayed when an object file is generated from
an assembly-language source file. If this is not set, then
$ASCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(ASCOMSTR =
&quot;Assembling $TARGET&quot;)</p>

<p style="margin-top: 1em">ASFLAGS <br>
General options passed to the assembler.</p>

<p style="margin-top: 1em">ASPPCOM <br>
The command line used to assemble an assembly-language
source file into an object file after first running the file
through the C preprocessor. Any options specified in the
<br>
$ASFLAGS and $CPPFLAGS construction variables are included
on this command line.</p>

<p style="margin-top: 1em">ASPPCOMSTR <br>
The string displayed when an object file is generated from
an assembly-language source file after first running the
file through the C preprocessor. If this is not set, then
<br>
$ASPPCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(ASPPCOMSTR =
&quot;Assembling $TARGET&quot;)</p>

<p style="margin-top: 1em">ASPPFLAGS <br>
General options when an assembling an assembly-language
source file into an object file after first running the file
through the C preprocessor. The default is to use the <br>
value of $ASFLAGS.</p>

<p style="margin-top: 1em">BIBTEX <br>
The bibliography generator for the TeX formatter and
typesetter and the LaTeX structured formatter and
typesetter.</p>

<p style="margin-top: 1em">BIBTEXCOM <br>
The command line used to call the bibliography generator for
the TeX formatter and typesetter and the LaTeX structured
formatter and typesetter.</p>

<p style="margin-top: 1em">BIBTEXCOMSTR <br>
The string displayed when generating a bibliography for TeX
or LaTeX. If this is not set, then $BIBTEXCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(BIBTEXCOMSTR =
&quot;Generating bibliography $TARGET&quot;)</p>

<p style="margin-top: 1em">BIBTEXFLAGS <br>
General options passed to the bibliography generator for the
TeX formatter and typesetter and the LaTeX structured
formatter and typesetter.</p>

<p style="margin-top: 1em">BITKEEPER <br>
The BitKeeper executable.</p>

<p style="margin-top: 1em">BITKEEPERCOM <br>
The command line for fetching source files using
BitKeeper.</p>

<p style="margin-top: 1em">BITKEEPERCOMSTR <br>
The string displayed when fetching a source file using
BitKeeper. If this is not set, then $BITKEEPERCOM (the
command line) is displayed.</p>

<p style="margin-top: 1em">BITKEEPERGET <br>
The command ($BITKEEPER) and subcommand for fetching source
files using BitKeeper.</p>

<p style="margin-top: 1em">BITKEEPERGETFLAGS <br>
Options that are passed to the BitKeeper get subcommand.</p>

<p style="margin-top: 1em">BUILDERS <br>
A dictionary mapping the names of the builders available
through this environment to underlying Builder objects.
Builders named Alias, CFile, CXXFile, DVI, Library, Object,
<br>
PDF, PostScript, and Program are available by default. If
you initialize this variable when an Environment is
created:</p>

<p style="margin-top: 1em">env = Environment(BUILDERS =
{&rsquo;NewBuilder&rsquo; : foo})</p>

<p style="margin-top: 1em">the default Builders will no
longer be available. To use a new Builder object in addition
to the default Builders, add your new Builder object like
this:</p>

<p style="margin-top: 1em">env = Environment() <br>
env.Append(BUILDERS = {&rsquo;NewBuilder&rsquo; : foo})</p>

<p style="margin-top: 1em">or this:</p>

<p style="margin-top: 1em">env = Environment() <br>
env[&rsquo;BUILDERS][&rsquo;NewBuilder&rsquo;] = foo</p>

<p style="margin-top: 1em">CC <br>
The C compiler.</p>

<p style="margin-top: 1em">CCCOM <br>
The command line used to compile a C source file to a
(static) object file. Any options specified in the $CFLAGS,
$CCFLAGS and $CPPFLAGS construction variables are included
<br>
on this command line.</p>

<p style="margin-top: 1em">CCCOMSTR <br>
The string displayed when a C source file is compiled to a
(static) object file. If this is not set, then $CCCOM (the
command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(CCCOMSTR =
&quot;Compiling static object $TARGET&quot;)</p>

<p style="margin-top: 1em">CCFLAGS <br>
General options that are passed to the C and C++
compilers.</p>

<p style="margin-top: 1em">CCPCHFLAGS <br>
Options added to the compiler command line to support
building with precompiled headers. The default value expands
expands to the appropriate Microsoft Visual C++ <br>
command-line options when the $PCH construction variable is
set.</p>

<p style="margin-top: 1em">CCPDBFLAGS <br>
Options added to the compiler command line to support
storing debugging information in a Microsoft Visual C++ PDB
file. The default value expands expands to appropriate <br>
Microsoft Visual C++ command-line options when the $PDB
construction variable is set.</p>

<p style="margin-top: 1em">The Visual C++ compiler option
that SCons uses by default to generate PDB information is
/Z7. This works correctly with parallel (-j) builds because
it embeds the debug <br>
information in the intermediate object files, as opposed to
sharing a single PDB file between multiple object files.
This is also the only way to get debug information <br>
embedded into a static library. Using the /Zi instead may
yield improved link-time performance, although parallel
builds will no longer work.</p>

<p style="margin-top: 1em">You can generate PDB files with
the /Zi switch by overriding the default $CCPDBFLAGS
variable as follows:</p>

<p style="margin-top: 1em">env[&rsquo;CCPDBFLAGS&rsquo;] =
[&rsquo;${(PDB and &quot;/Zi /Fd%s&quot; % File(PDB)) or
&quot;&quot;}&rsquo;]</p>

<p style="margin-top: 1em">An alternative would be to use
the /Zi to put the debugging information in a separate .pdb
file for each object file by overriding the $CCPDBFLAGS
variable as follows:</p>

<p style="margin-top: 1em">env[&rsquo;CCPDBFLAGS&rsquo;] =
&rsquo;/Zi /Fd${TARGET}.pdb&rsquo;</p>

<p style="margin-top: 1em">CCVERSION <br>
The version number of the C compiler. This may or may not be
set, depending on the specific C compiler being used.</p>

<p style="margin-top: 1em">CFILESUFFIX <br>
The suffix for C source files. This is used by the internal
CFile builder when generating C files from Lex (.l) or YACC
(.y) input files. The default suffix, of course, is .c <br>
(lower case). On case-insensitive systems (like Windows),
SCons also treats .C (upper case) files as C files.</p>

<p style="margin-top: 1em">CFLAGS <br>
General options that are passed to the C compiler (C only;
not C++).</p>

<p style="margin-top: 1em">CHANGE_SPECFILE <br>
A hook for modifying the file that controls the packaging
build (the .spec for RPM, the control for Ipkg, the .wxs for
MSI). If set, the function will be called after the <br>
SCons template for the file has been written. XXX</p>

<p style="margin-top: 1em">CHANGED_SOURCES <br>
A reserved variable name that may not be set or used in a
construction environment. (See &quot;Variable
Substitution,&quot; below.)</p>

<p style="margin-top: 1em">CHANGED_TARGETS <br>
A reserved variable name that may not be set or used in a
construction environment. (See &quot;Variable
Substitution,&quot; below.)</p>

<p style="margin-top: 1em">CHANGELOG <br>
The name of a file containing the change log text to be
included in the package. This is included as the %changelog
section of the RPM .spec file.</p>

<p style="margin-top: 1em">_concat <br>
A function used to produce variables like $_CPPINCFLAGS. It
takes four or five arguments: a prefix to concatenate onto
each element, a list of elements, a suffix to <br>
concatenate onto each element, an environment for variable
interpolation, and an optional function that will be called
to transform the list before concatenation.</p>

<p style="margin-top: 1em">env[&rsquo;_CPPINCFLAGS&rsquo;]
= &rsquo;$( ${_concat(INCPREFIX, CPPPATH, INCSUFFIX,
__env__, RDirs)} $)&rsquo;,</p>

<p style="margin-top: 1em">CONFIGUREDIR <br>
The name of the directory in which Configure context test
files are written. The default is .sconf_temp in the
top-level directory containing the SConstruct file.</p>

<p style="margin-top: 1em">CONFIGURELOG <br>
The name of the Configure context log file. The default is
config.log in the top-level directory containing the
SConstruct file.</p>

<p style="margin-top: 1em">_CPPDEFFLAGS <br>
An automatically-generated construction variable containing
the C preprocessor command-line options to define values.
The value of $_CPPDEFFLAGS is created by appending <br>
$CPPDEFPREFIX and $CPPDEFSUFFIX to the beginning and end of
each definition in $CPPDEFINES.</p>

<p style="margin-top: 1em">CPPDEFINES <br>
A platform independent specification of C preprocessor
definitions. The definitions will be added to command lines
through the automatically-generated $_CPPDEFFLAGS <br>
construction variable (see above), which is constructed
according to the type of value of $CPPDEFINES:</p>

<p style="margin-top: 1em">If $CPPDEFINES is a string, the
values of the $CPPDEFPREFIX and $CPPDEFSUFFIX construction
variables will be added to the beginning and end.</p>

<p style="margin-top: 1em"># Will add -Dxyz to POSIX
compiler command lines, <br>
# and /Dxyz to Microsoft Visual C++ command lines. <br>
env = Environment(CPPDEFINES=&rsquo;xyz&rsquo;)</p>

<p style="margin-top: 1em">If $CPPDEFINES is a list, the
values of the $CPPDEFPREFIX and $CPPDEFSUFFIX construction
variables will be appended to the beginning and end of each
element in the list. If <br>
any element is a list or tuple, then the first item is the
name being defined and the second item is its value:</p>

<p style="margin-top: 1em"># Will add -DB=2 -DA to POSIX
compiler command lines, <br>
# and /DB=2 /DA to Microsoft Visual C++ command lines. <br>
env = Environment(CPPDEFINES=[(&rsquo;B&rsquo;, 2),
&rsquo;A&rsquo;])</p>

<p style="margin-top: 1em">If $CPPDEFINES is a dictionary,
the values of the $CPPDEFPREFIX and $CPPDEFSUFFIX
construction variables will be appended to the beginning and
end of each item from the <br>
dictionary. The key of each dictionary item is a name being
defined to the dictionary item&rsquo;s corresponding value;
if the value is None, then the name is defined without an
<br>
explicit value. Note that the resulting flags are sorted by
keyword to ensure that the order of the options on the
command line is consistent each time scons is run.</p>

<p style="margin-top: 1em"># Will add -DA -DB=2 to POSIX
compiler command lines, <br>
# and /DA /DB=2 to Microsoft Visual C++ command lines. <br>
env = Environment(CPPDEFINES={&rsquo;B&rsquo;:2,
&rsquo;A&rsquo;:None})</p>

<p style="margin-top: 1em">CPPDEFPREFIX <br>
The prefix used to specify preprocessor definitions on the C
compiler command line. This will be appended to the
beginning of each definition in the $CPPDEFINES construction
<br>
variable when the $_CPPDEFFLAGS variable is automatically
generated.</p>

<p style="margin-top: 1em">CPPDEFSUFFIX <br>
The suffix used to specify preprocessor definitions on the C
compiler command line. This will be appended to the end of
each definition in the $CPPDEFINES construction <br>
variable when the $_CPPDEFFLAGS variable is automatically
generated.</p>

<p style="margin-top: 1em">CPPFLAGS <br>
User-specified C preprocessor options. These will be
included in any command that uses the C preprocessor,
including not just compilation of C and C++ source files via
the <br>
$CCCOM, $SHCCCOM, $CXXCOM and $SHCXXCOM command lines, but
also the $FORTRANPPCOM, $SHFORTRANPPCOM, $F77PPCOM and
$SHF77PPCOM command lines used to compile a Fortran source
<br>
file, and the $ASPPCOM command line used to assemble an
assembly language source file, after first running each file
through the C preprocessor. Note that this variable does
<br>
not contain -I (or similar) include search path options that
scons generates automatically from $CPPPATH. See
$_CPPINCFLAGS, below, for the variable that expands to those
<br>
options.</p>

<p style="margin-top: 1em">_CPPINCFLAGS <br>
An automatically-generated construction variable containing
the C preprocessor command-line options for specifying
directories to be searched for include files. The value of
<br>
$_CPPINCFLAGS is created by appending $INCPREFIX and
$INCSUFFIX to the beginning and end of each directory in
$CPPPATH.</p>

<p style="margin-top: 1em">CPPPATH <br>
The list of directories that the C preprocessor will search
for include directories. The C/C++ implicit dependency
scanner will search these directories for include files.
<br>
Don&rsquo;t explicitly put include directory arguments in
CCFLAGS or CXXFLAGS because the result will be non-portable
and the directories will not be searched by the dependency
<br>
scanner. Note: directory names in CPPPATH will be looked-up
relative to the SConscript directory when they are used in a
command. To force scons to look-up a directory <br>
relative to the root of the source tree use #:</p>

<p style="margin-top: 1em">env =
Environment(CPPPATH=&rsquo;#/include&rsquo;)</p>

<p style="margin-top: 1em">The directory look-up can also
be forced using the Dir() function:</p>

<p style="margin-top: 1em">include =
Dir(&rsquo;include&rsquo;) <br>
env = Environment(CPPPATH=include)</p>

<p style="margin-top: 1em">The directory list will be added
to command lines through the automatically-generated
$_CPPINCFLAGS construction variable, which is constructed by
appending the values of the <br>
$INCPREFIX and $INCSUFFIX construction variables to the
beginning and end of each directory in $CPPPATH. Any command
lines you define that need the CPPPATH directory list <br>
should include $_CPPINCFLAGS:</p>

<p style="margin-top: 1em">env =
Environment(CCCOM=&quot;my_compiler $_CPPINCFLAGS -c -o
$TARGET $SOURCE&quot;)</p>

<p style="margin-top: 1em">CPPSUFFIXES <br>
The list of suffixes of files that will be scanned for C
preprocessor implicit dependencies (#include lines). The
default list is:</p>

<p style="margin-top: 1em">[&quot;.c&quot;, &quot;.C&quot;,
&quot;.cxx&quot;, &quot;.cpp&quot;, &quot;.c++&quot;,
&quot;.cc&quot;, <br>
&quot;.h&quot;, &quot;.H&quot;, &quot;.hxx&quot;,
&quot;.hpp&quot;, &quot;.hh&quot;, <br>
&quot;.F&quot;, &quot;.fpp&quot;, &quot;.FPP&quot;, <br>
&quot;.m&quot;, &quot;.mm&quot;, <br>
&quot;.S&quot;, &quot;.spp&quot;, &quot;.SPP&quot;]</p>

<p style="margin-top: 1em">CVS <br>
The CVS executable.</p>

<p style="margin-top: 1em">CVSCOFLAGS <br>
Options that are passed to the CVS checkout subcommand.</p>

<p style="margin-top: 1em">CVSCOM <br>
The command line used to fetch source files from a CVS
repository.</p>

<p style="margin-top: 1em">CVSCOMSTR <br>
The string displayed when fetching a source file from a CVS
repository. If this is not set, then $CVSCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">CVSFLAGS <br>
General options that are passed to CVS. By default, this is
set to -d $CVSREPOSITORY to specify from where the files
must be fetched.</p>

<p style="margin-top: 1em">CVSREPOSITORY <br>
The path to the CVS repository. This is referenced in the
default $CVSFLAGS value.</p>

<p style="margin-top: 1em">CXX <br>
The C++ compiler.</p>

<p style="margin-top: 1em">CXXCOM <br>
The command line used to compile a C++ source file to an
object file. Any options specified in the $CXXFLAGS and
$CPPFLAGS construction variables are included on this
command <br>
line.</p>

<p style="margin-top: 1em">CXXCOMSTR <br>
The string displayed when a C++ source file is compiled to a
(static) object file. If this is not set, then $CXXCOM (the
command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(CXXCOMSTR =
&quot;Compiling static object $TARGET&quot;)</p>

<p style="margin-top: 1em">CXXFILESUFFIX <br>
The suffix for C++ source files. This is used by the
internal CXXFile builder when generating C++ files from Lex
(.ll) or YACC (.yy) input files. The default suffix is .cc.
<br>
SCons also treats files with the suffixes .cpp, .cxx, .c++,
and .C++ as C++ files, and files with .mm suffixes as
Objective C++ files. On case-sensitive systems (Linux, UNIX,
<br>
and other POSIX-alikes), SCons also treats .C (upper case)
files as C++ files.</p>

<p style="margin-top: 1em">CXXFLAGS <br>
General options that are passed to the C++ compiler. By
default, this includes the value of $CCFLAGS, so that
setting $CCFLAGS affects both C and C++ compilation. If you
want <br>
to add C++-specific flags, you must set or override the
value of $CXXFLAGS.</p>

<p style="margin-top: 1em">CXXVERSION <br>
The version number of the C++ compiler. This may or may not
be set, depending on the specific C++ compiler being
used.</p>

<p style="margin-top: 1em">DC <br>
DC.</p>

<p style="margin-top: 1em">DCOM <br>
DCOM.</p>

<p style="margin-top: 1em">DDEBUG <br>
DDEBUG.</p>

<p style="margin-top: 1em">_DDEBUGFLAGS <br>
_DDEBUGFLAGS.</p>

<p style="margin-top: 1em">DDEBUGPREFIX <br>
DDEBUGPREFIX.</p>

<p style="margin-top: 1em">DDEBUGSUFFIX <br>
DDEBUGSUFFIX.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
A long description of the project being packaged. This is
included in the relevant section of the file that controls
the packaging build.</p>

<p style="margin-top: 1em">DESCRIPTION_lang <br>
A language-specific long description for the specified lang.
This is used to populate a %description -l section of an RPM
.spec file.</p>

<p style="margin-top: 1em">DFILESUFFIX <br>
DFILESUFFIX.</p>

<p style="margin-top: 1em">DFLAGPREFIX <br>
DFLAGPREFIX.</p>

<p style="margin-top: 1em">DFLAGS <br>
DFLAGS.</p>

<p style="margin-top: 1em">_DFLAGS <br>
_DFLAGS.</p>

<p style="margin-top: 1em">DFLAGSUFFIX <br>
DFLAGSUFFIX.</p>

<p style="margin-top: 1em">_DINCFLAGS <br>
_DINCFLAGS.</p>

<p style="margin-top: 1em">DINCPREFIX <br>
DINCPREFIX.</p>

<p style="margin-top: 1em">DINCSUFFIX <br>
DINCSUFFIX.</p>

<p style="margin-top: 1em">Dir <br>
A function that converts a string into a Dir instance
relative to the target being built.</p>

<p style="margin-top: 1em">A function that converts a
string into a Dir instance relative to the target being
built.</p>

<p style="margin-top: 1em">Dirs <br>
A function that converts a list of strings into a list of
Dir instances relative to the target being built.</p>

<p style="margin-top: 1em">DLIB <br>
DLIB.</p>

<p style="margin-top: 1em">DLIBCOM <br>
DLIBCOM.</p>

<p style="margin-top: 1em">_DLIBDIRFLAGS <br>
_DLIBDIRFLAGS.</p>

<p style="margin-top: 1em">DLIBDIRPREFIX <br>
DLIBDIRPREFIX.</p>

<p style="margin-top: 1em">DLIBDIRSUFFIX <br>
DLIBDIRSUFFIX.</p>

<p style="margin-top: 1em">DLIBFLAGPREFIX <br>
DLIBFLAGPREFIX.</p>

<p style="margin-top: 1em">_DLIBFLAGS <br>
_DLIBFLAGS.</p>

<p style="margin-top: 1em">DLIBFLAGSUFFIX <br>
DLIBFLAGSUFFIX.</p>

<p style="margin-top: 1em">DLIBLINKPREFIX <br>
DLIBLINKPREFIX.</p>

<p style="margin-top: 1em">DLIBLINKSUFFIX <br>
DLIBLINKSUFFIX.</p>

<p style="margin-top: 1em">DLINK <br>
DLINK.</p>

<p style="margin-top: 1em">DLINKCOM <br>
DLINKCOM.</p>

<p style="margin-top: 1em">DLINKFLAGPREFIX <br>
DLINKFLAGPREFIX.</p>

<p style="margin-top: 1em">DLINKFLAGS <br>
DLINKFLAGS.</p>

<p style="margin-top: 1em">DLINKFLAGSUFFIX <br>
DLINKFLAGSUFFIX.</p>

<p style="margin-top: 1em">DOCBOOK_DEFAULT_XSL_EPUB <br>
The default XSLT file for the DocbookEpub builder within the
current environment, if no other XSLT gets specified via
keyword.</p>

<p style="margin-top: 1em">DOCBOOK_DEFAULT_XSL_HTML <br>
The default XSLT file for the DocbookHtml builder within the
current environment, if no other XSLT gets specified via
keyword.</p>

<p style="margin-top: 1em">DOCBOOK_DEFAULT_XSL_HTMLCHUNKED
<br>
The default XSLT file for the DocbookHtmlChunked builder
within the current environment, if no other XSLT gets
specified via keyword.</p>

<p style="margin-top: 1em">DOCBOOK_DEFAULT_XSL_HTMLHELP
<br>
The default XSLT file for the DocbookHtmlhelp builder within
the current environment, if no other XSLT gets specified via
keyword.</p>

<p style="margin-top: 1em">DOCBOOK_DEFAULT_XSL_MAN <br>
The default XSLT file for the DocbookMan builder within the
current environment, if no other XSLT gets specified via
keyword.</p>

<p style="margin-top: 1em">DOCBOOK_DEFAULT_XSL_PDF <br>
The default XSLT file for the DocbookPdf builder within the
current environment, if no other XSLT gets specified via
keyword.</p>

<p style="margin-top: 1em">DOCBOOK_DEFAULT_XSL_SLIDESHTML
<br>
The default XSLT file for the DocbookSlidesHtml builder
within the current environment, if no other XSLT gets
specified via keyword.</p>

<p style="margin-top: 1em">DOCBOOK_DEFAULT_XSL_SLIDESPDF
<br>
The default XSLT file for the DocbookSlidesPdf builder
within the current environment, if no other XSLT gets
specified via keyword.</p>

<p style="margin-top: 1em">DOCBOOK_FOP <br>
The path to the PDF renderer fop or xep, if one of them is
installed (fop gets checked first).</p>

<p style="margin-top: 1em">DOCBOOK_FOPCOM <br>
The full command-line for the PDF renderer fop or xep.</p>

<p style="margin-top: 1em">DOCBOOK_FOPCOMSTR <br>
The string displayed when a renderer like fop or xep is used
to create PDF output from an XML file.</p>

<p style="margin-top: 1em">DOCBOOK_FOPFLAGS <br>
Additonal command-line flags for the PDF renderer fop or
xep.</p>

<p style="margin-top: 1em">DOCBOOK_XMLLINT <br>
The path to the external executable xmllint, if it&rsquo;s
installed. Note, that this is only used as last fallback for
resolving XIncludes, if no libxml2 or lxml Python binding
<br>
can be imported in the current system.</p>

<p style="margin-top: 1em">DOCBOOK_XMLLINTCOM <br>
The full command-line for the external executable
xmllint.</p>

<p style="margin-top: 1em">DOCBOOK_XMLLINTCOMSTR <br>
The string displayed when xmllint is used to resolve
XIncludes for a given XML file.</p>

<p style="margin-top: 1em">DOCBOOK_XMLLINTFLAGS <br>
Additonal command-line flags for the external executable
xmllint.</p>

<p style="margin-top: 1em">DOCBOOK_XSLTPROC <br>
The path to the external executable xsltproc (or saxon,
xalan), if one of them is installed. Note, that this is only
used as last fallback for XSL transformations, if no <br>
libxml2 or lxml Python binding can be imported in the
current system.</p>

<p style="margin-top: 1em">DOCBOOK_XSLTPROCCOM <br>
The full command-line for the external executable xsltproc
(or saxon, xalan).</p>

<p style="margin-top: 1em">DOCBOOK_XSLTPROCCOMSTR <br>
The string displayed when xsltproc is used to transform an
XML file via a given XSLT stylesheet.</p>

<p style="margin-top: 1em">DOCBOOK_XSLTPROCFLAGS <br>
Additonal command-line flags for the external executable
xsltproc (or saxon, xalan).</p>

<p style="margin-top: 1em">DOCBOOK_XSLTPROCPARAMS <br>
Additonal parameters that are not intended for the XSLT
processor executable, but the XSL processing itself. By
default, they get appended at the end of the command line
for <br>
saxon and saxon-xslt, respectively.</p>

<p style="margin-top: 1em">DPATH <br>
DPATH.</p>

<p style="margin-top: 1em">DSUFFIXES <br>
The list of suffixes of files that will be scanned for
imported D package files. The default list is:</p>

<p style="margin-top: 1em">[&rsquo;.d&rsquo;]</p>

<p style="margin-top: 1em">_DVERFLAGS <br>
_DVERFLAGS.</p>

<p style="margin-top: 1em">DVERPREFIX <br>
DVERPREFIX.</p>

<p style="margin-top: 1em">DVERSIONS <br>
DVERSIONS.</p>

<p style="margin-top: 1em">DVERSUFFIX <br>
DVERSUFFIX.</p>

<p style="margin-top: 1em">DVIPDF <br>
The TeX DVI file to PDF file converter.</p>

<p style="margin-top: 1em">DVIPDFCOM <br>
The command line used to convert TeX DVI files into a PDF
file.</p>

<p style="margin-top: 1em">DVIPDFCOMSTR <br>
The string displayed when a TeX DVI file is converted into a
PDF file. If this is not set, then $DVIPDFCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">DVIPDFFLAGS <br>
General options passed to the TeX DVI file to PDF file
converter.</p>

<p style="margin-top: 1em">DVIPS <br>
The TeX DVI file to PostScript converter.</p>

<p style="margin-top: 1em">DVIPSFLAGS <br>
General options passed to the TeX DVI file to PostScript
converter.</p>

<p style="margin-top: 1em">ENV <br>
A dictionary of environment variables to use when invoking
commands. When $ENV is used in a command all list values
will be joined using the path separator and any other <br>
non-string values will simply be coerced to a string. Note
that, by default, scons does not propagate the environment
in force when you execute scons to the commands used to <br>
build target files. This is so that builds will be
guaranteed repeatable regardless of the environment
variables set at the time scons is invoked.</p>

<p style="margin-top: 1em">If you want to propagate your
environment variables to the commands executed to build
target files, you must do so explicitly:</p>

<p style="margin-top: 1em">import os <br>
env = Environment(ENV = os.environ)</p>

<p style="margin-top: 1em">Note that you can choose only to
propagate certain environment variables. A common example is
the system PATH environment variable, so that scons uses the
same utilities as <br>
the invoking shell (or other process):</p>

<p style="margin-top: 1em">import os <br>
env = Environment(ENV = {&rsquo;PATH&rsquo; :
os.environ[&rsquo;PATH&rsquo;]})</p>

<p style="margin-top: 1em">ESCAPE <br>
A function that will be called to escape shell special
characters in command lines. The function should take one
argument: the command line string to escape; and should <br>
return the escaped command line.</p>

<p style="margin-top: 1em">F03 <br>
The Fortran 03 compiler. You should normally set the
$FORTRAN variable, which specifies the default Fortran
compiler for all Fortran versions. You only need to set $F03
if <br>
you need to use a specific compiler or compiler version for
Fortran 03 files.</p>

<p style="margin-top: 1em">F03COM <br>
The command line used to compile a Fortran 03 source file to
an object file. You only need to set $F03COM if you need to
use a specific command line for Fortran 03 files. You <br>
should normally set the $FORTRANCOM variable, which
specifies the default command line for all Fortran
versions.</p>

<p style="margin-top: 1em">F03COMSTR <br>
The string displayed when a Fortran 03 source file is
compiled to an object file. If this is not set, then $F03COM
or $FORTRANCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">F03FILESUFFIXES <br>
The list of file extensions for which the F03 dialect will
be used. By default, this is [&rsquo;.f03&rsquo;]</p>

<p style="margin-top: 1em">F03FLAGS <br>
General user-specified options that are passed to the
Fortran 03 compiler. Note that this variable does not
contain -I (or similar) include search path options that
scons <br>
generates automatically from $F03PATH. See $_F03INCFLAGS
below, for the variable that expands to those options. You
only need to set $F03FLAGS if you need to define specific
<br>
user options for Fortran 03 files. You should normally set
the $FORTRANFLAGS variable, which specifies the
user-specified options passed to the default Fortran
compiler for <br>
all Fortran versions.</p>

<p style="margin-top: 1em">_F03INCFLAGS <br>
An automatically-generated construction variable containing
the Fortran 03 compiler command-line options for specifying
directories to be searched for include files. The <br>
value of $_F03INCFLAGS is created by appending $INCPREFIX
and $INCSUFFIX to the beginning and end of each directory in
$F03PATH.</p>

<p style="margin-top: 1em">F03PATH <br>
The list of directories that the Fortran 03 compiler will
search for include directories. The implicit dependency
scanner will search these directories for include files.
<br>
Don&rsquo;t explicitly put include directory arguments in
$F03FLAGS because the result will be non-portable and the
directories will not be searched by the dependency scanner.
<br>
Note: directory names in $F03PATH will be looked-up relative
to the SConscript directory when they are used in a command.
To force scons to look-up a directory relative to <br>
the root of the source tree use #: You only need to set
$F03PATH if you need to define a specific include path for
Fortran 03 files. You should normally set the $FORTRANPATH
<br>
variable, which specifies the include path for the default
Fortran compiler for all Fortran versions.</p>

<p style="margin-top: 1em">env =
Environment(F03PATH=&rsquo;#/include&rsquo;)</p>

<p style="margin-top: 1em">The directory look-up can also
be forced using the Dir() function:</p>

<p style="margin-top: 1em">include =
Dir(&rsquo;include&rsquo;) <br>
env = Environment(F03PATH=include)</p>

<p style="margin-top: 1em">The directory list will be added
to command lines through the automatically-generated
$_F03INCFLAGS construction variable, which is constructed by
appending the values of the <br>
$INCPREFIX and $INCSUFFIX construction variables to the
beginning and end of each directory in $F03PATH. Any command
lines you define that need the F03PATH directory list <br>
should include $_F03INCFLAGS:</p>

<p style="margin-top: 1em">env =
Environment(F03COM=&quot;my_compiler $_F03INCFLAGS -c -o
$TARGET $SOURCE&quot;)</p>

<p style="margin-top: 1em">F03PPCOM <br>
The command line used to compile a Fortran 03 source file to
an object file after first running the file through the C
preprocessor. Any options specified in the $F03FLAGS <br>
and $CPPFLAGS construction variables are included on this
command line. You only need to set $F03PPCOM if you need to
use a specific C-preprocessor command line for Fortran <br>
03 files. You should normally set the $FORTRANPPCOM
variable, which specifies the default C-preprocessor command
line for all Fortran versions.</p>

<p style="margin-top: 1em">F03PPCOMSTR <br>
The string displayed when a Fortran 03 source file is
compiled to an object file after first running the file
through the C preprocessor. If this is not set, then
$F03PPCOM <br>
or $FORTRANPPCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">F03PPFILESUFFIXES <br>
The list of file extensions for which the compilation +
preprocessor pass for F03 dialect will be used. By default,
this is empty</p>

<p style="margin-top: 1em">F08 <br>
The Fortran 08 compiler. You should normally set the
$FORTRAN variable, which specifies the default Fortran
compiler for all Fortran versions. You only need to set $F08
if <br>
you need to use a specific compiler or compiler version for
Fortran 08 files.</p>

<p style="margin-top: 1em">F08COM <br>
The command line used to compile a Fortran 08 source file to
an object file. You only need to set $F08COM if you need to
use a specific command line for Fortran 08 files. You <br>
should normally set the $FORTRANCOM variable, which
specifies the default command line for all Fortran
versions.</p>

<p style="margin-top: 1em">F08COMSTR <br>
The string displayed when a Fortran 08 source file is
compiled to an object file. If this is not set, then $F08COM
or $FORTRANCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">F08FILESUFFIXES <br>
The list of file extensions for which the F08 dialect will
be used. By default, this is [&rsquo;.f08&rsquo;]</p>

<p style="margin-top: 1em">F08FLAGS <br>
General user-specified options that are passed to the
Fortran 08 compiler. Note that this variable does not
contain -I (or similar) include search path options that
scons <br>
generates automatically from $F08PATH. See $_F08INCFLAGS
below, for the variable that expands to those options. You
only need to set $F08FLAGS if you need to define specific
<br>
user options for Fortran 08 files. You should normally set
the $FORTRANFLAGS variable, which specifies the
user-specified options passed to the default Fortran
compiler for <br>
all Fortran versions.</p>

<p style="margin-top: 1em">_F08INCFLAGS <br>
An automatically-generated construction variable containing
the Fortran 08 compiler command-line options for specifying
directories to be searched for include files. The <br>
value of $_F08INCFLAGS is created by appending $INCPREFIX
and $INCSUFFIX to the beginning and end of each directory in
$F08PATH.</p>

<p style="margin-top: 1em">F08PATH <br>
The list of directories that the Fortran 08 compiler will
search for include directories. The implicit dependency
scanner will search these directories for include files.
<br>
Don&rsquo;t explicitly put include directory arguments in
$F08FLAGS because the result will be non-portable and the
directories will not be searched by the dependency scanner.
<br>
Note: directory names in $F08PATH will be looked-up relative
to the SConscript directory when they are used in a command.
To force scons to look-up a directory relative to <br>
the root of the source tree use #: You only need to set
$F08PATH if you need to define a specific include path for
Fortran 08 files. You should normally set the $FORTRANPATH
<br>
variable, which specifies the include path for the default
Fortran compiler for all Fortran versions.</p>

<p style="margin-top: 1em">env =
Environment(F08PATH=&rsquo;#/include&rsquo;)</p>

<p style="margin-top: 1em">The directory look-up can also
be forced using the Dir() function:</p>

<p style="margin-top: 1em">include =
Dir(&rsquo;include&rsquo;) <br>
env = Environment(F08PATH=include)</p>

<p style="margin-top: 1em">The directory list will be added
to command lines through the automatically-generated
$_F08INCFLAGS construction variable, which is constructed by
appending the values of the <br>
$INCPREFIX and $INCSUFFIX construction variables to the
beginning and end of each directory in $F08PATH. Any command
lines you define that need the F08PATH directory list <br>
should include $_F08INCFLAGS:</p>

<p style="margin-top: 1em">env =
Environment(F08COM=&quot;my_compiler $_F08INCFLAGS -c -o
$TARGET $SOURCE&quot;)</p>

<p style="margin-top: 1em">F08PPCOM <br>
The command line used to compile a Fortran 08 source file to
an object file after first running the file through the C
preprocessor. Any options specified in the $F08FLAGS <br>
and $CPPFLAGS construction variables are included on this
command line. You only need to set $F08PPCOM if you need to
use a specific C-preprocessor command line for Fortran <br>
08 files. You should normally set the $FORTRANPPCOM
variable, which specifies the default C-preprocessor command
line for all Fortran versions.</p>

<p style="margin-top: 1em">F08PPCOMSTR <br>
The string displayed when a Fortran 08 source file is
compiled to an object file after first running the file
through the C preprocessor. If this is not set, then
$F08PPCOM <br>
or $FORTRANPPCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">F08PPFILESUFFIXES <br>
The list of file extensions for which the compilation +
preprocessor pass for F08 dialect will be used. By default,
this is empty</p>

<p style="margin-top: 1em">F77 <br>
The Fortran 77 compiler. You should normally set the
$FORTRAN variable, which specifies the default Fortran
compiler for all Fortran versions. You only need to set $F77
if <br>
you need to use a specific compiler or compiler version for
Fortran 77 files.</p>

<p style="margin-top: 1em">F77COM <br>
The command line used to compile a Fortran 77 source file to
an object file. You only need to set $F77COM if you need to
use a specific command line for Fortran 77 files. You <br>
should normally set the $FORTRANCOM variable, which
specifies the default command line for all Fortran
versions.</p>

<p style="margin-top: 1em">F77COMSTR <br>
The string displayed when a Fortran 77 source file is
compiled to an object file. If this is not set, then $F77COM
or $FORTRANCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">F77FILESUFFIXES <br>
The list of file extensions for which the F77 dialect will
be used. By default, this is [&rsquo;.f77&rsquo;]</p>

<p style="margin-top: 1em">F77FLAGS <br>
General user-specified options that are passed to the
Fortran 77 compiler. Note that this variable does not
contain -I (or similar) include search path options that
scons <br>
generates automatically from $F77PATH. See $_F77INCFLAGS
below, for the variable that expands to those options. You
only need to set $F77FLAGS if you need to define specific
<br>
user options for Fortran 77 files. You should normally set
the $FORTRANFLAGS variable, which specifies the
user-specified options passed to the default Fortran
compiler for <br>
all Fortran versions.</p>

<p style="margin-top: 1em">_F77INCFLAGS <br>
An automatically-generated construction variable containing
the Fortran 77 compiler command-line options for specifying
directories to be searched for include files. The <br>
value of $_F77INCFLAGS is created by appending $INCPREFIX
and $INCSUFFIX to the beginning and end of each directory in
$F77PATH.</p>

<p style="margin-top: 1em">F77PATH <br>
The list of directories that the Fortran 77 compiler will
search for include directories. The implicit dependency
scanner will search these directories for include files.
<br>
Don&rsquo;t explicitly put include directory arguments in
$F77FLAGS because the result will be non-portable and the
directories will not be searched by the dependency scanner.
<br>
Note: directory names in $F77PATH will be looked-up relative
to the SConscript directory when they are used in a command.
To force scons to look-up a directory relative to <br>
the root of the source tree use #: You only need to set
$F77PATH if you need to define a specific include path for
Fortran 77 files. You should normally set the $FORTRANPATH
<br>
variable, which specifies the include path for the default
Fortran compiler for all Fortran versions.</p>

<p style="margin-top: 1em">env =
Environment(F77PATH=&rsquo;#/include&rsquo;)</p>

<p style="margin-top: 1em">The directory look-up can also
be forced using the Dir() function:</p>

<p style="margin-top: 1em">include =
Dir(&rsquo;include&rsquo;) <br>
env = Environment(F77PATH=include)</p>

<p style="margin-top: 1em">The directory list will be added
to command lines through the automatically-generated
$_F77INCFLAGS construction variable, which is constructed by
appending the values of the <br>
$INCPREFIX and $INCSUFFIX construction variables to the
beginning and end of each directory in $F77PATH. Any command
lines you define that need the F77PATH directory list <br>
should include $_F77INCFLAGS:</p>

<p style="margin-top: 1em">env =
Environment(F77COM=&quot;my_compiler $_F77INCFLAGS -c -o
$TARGET $SOURCE&quot;)</p>

<p style="margin-top: 1em">F77PPCOM <br>
The command line used to compile a Fortran 77 source file to
an object file after first running the file through the C
preprocessor. Any options specified in the $F77FLAGS <br>
and $CPPFLAGS construction variables are included on this
command line. You only need to set $F77PPCOM if you need to
use a specific C-preprocessor command line for Fortran <br>
77 files. You should normally set the $FORTRANPPCOM
variable, which specifies the default C-preprocessor command
line for all Fortran versions.</p>

<p style="margin-top: 1em">F77PPCOMSTR <br>
The string displayed when a Fortran 77 source file is
compiled to an object file after first running the file
through the C preprocessor. If this is not set, then
$F77PPCOM <br>
or $FORTRANPPCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">F77PPFILESUFFIXES <br>
The list of file extensions for which the compilation +
preprocessor pass for F77 dialect will be used. By default,
this is empty</p>

<p style="margin-top: 1em">F90 <br>
The Fortran 90 compiler. You should normally set the
$FORTRAN variable, which specifies the default Fortran
compiler for all Fortran versions. You only need to set $F90
if <br>
you need to use a specific compiler or compiler version for
Fortran 90 files.</p>

<p style="margin-top: 1em">F90COM <br>
The command line used to compile a Fortran 90 source file to
an object file. You only need to set $F90COM if you need to
use a specific command line for Fortran 90 files. You <br>
should normally set the $FORTRANCOM variable, which
specifies the default command line for all Fortran
versions.</p>

<p style="margin-top: 1em">F90COMSTR <br>
The string displayed when a Fortran 90 source file is
compiled to an object file. If this is not set, then $F90COM
or $FORTRANCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">F90FILESUFFIXES <br>
The list of file extensions for which the F90 dialect will
be used. By default, this is [&rsquo;.f90&rsquo;]</p>

<p style="margin-top: 1em">F90FLAGS <br>
General user-specified options that are passed to the
Fortran 90 compiler. Note that this variable does not
contain -I (or similar) include search path options that
scons <br>
generates automatically from $F90PATH. See $_F90INCFLAGS
below, for the variable that expands to those options. You
only need to set $F90FLAGS if you need to define specific
<br>
user options for Fortran 90 files. You should normally set
the $FORTRANFLAGS variable, which specifies the
user-specified options passed to the default Fortran
compiler for <br>
all Fortran versions.</p>

<p style="margin-top: 1em">_F90INCFLAGS <br>
An automatically-generated construction variable containing
the Fortran 90 compiler command-line options for specifying
directories to be searched for include files. The <br>
value of $_F90INCFLAGS is created by appending $INCPREFIX
and $INCSUFFIX to the beginning and end of each directory in
$F90PATH.</p>

<p style="margin-top: 1em">F90PATH <br>
The list of directories that the Fortran 90 compiler will
search for include directories. The implicit dependency
scanner will search these directories for include files.
<br>
Don&rsquo;t explicitly put include directory arguments in
$F90FLAGS because the result will be non-portable and the
directories will not be searched by the dependency scanner.
<br>
Note: directory names in $F90PATH will be looked-up relative
to the SConscript directory when they are used in a command.
To force scons to look-up a directory relative to <br>
the root of the source tree use #: You only need to set
$F90PATH if you need to define a specific include path for
Fortran 90 files. You should normally set the $FORTRANPATH
<br>
variable, which specifies the include path for the default
Fortran compiler for all Fortran versions.</p>

<p style="margin-top: 1em">env =
Environment(F90PATH=&rsquo;#/include&rsquo;)</p>

<p style="margin-top: 1em">The directory look-up can also
be forced using the Dir() function:</p>

<p style="margin-top: 1em">include =
Dir(&rsquo;include&rsquo;) <br>
env = Environment(F90PATH=include)</p>

<p style="margin-top: 1em">The directory list will be added
to command lines through the automatically-generated
$_F90INCFLAGS construction variable, which is constructed by
appending the values of the <br>
$INCPREFIX and $INCSUFFIX construction variables to the
beginning and end of each directory in $F90PATH. Any command
lines you define that need the F90PATH directory list <br>
should include $_F90INCFLAGS:</p>

<p style="margin-top: 1em">env =
Environment(F90COM=&quot;my_compiler $_F90INCFLAGS -c -o
$TARGET $SOURCE&quot;)</p>

<p style="margin-top: 1em">F90PPCOM <br>
The command line used to compile a Fortran 90 source file to
an object file after first running the file through the C
preprocessor. Any options specified in the $F90FLAGS <br>
and $CPPFLAGS construction variables are included on this
command line. You only need to set $F90PPCOM if you need to
use a specific C-preprocessor command line for Fortran <br>
90 files. You should normally set the $FORTRANPPCOM
variable, which specifies the default C-preprocessor command
line for all Fortran versions.</p>

<p style="margin-top: 1em">F90PPCOMSTR <br>
The string displayed when a Fortran 90 source file is
compiled after first running the file through the C
preprocessor. If this is not set, then $F90PPCOM or
$FORTRANPPCOM <br>
(the command line) is displayed.</p>

<p style="margin-top: 1em">F90PPFILESUFFIXES <br>
The list of file extensions for which the compilation +
preprocessor pass for F90 dialect will be used. By default,
this is empty</p>

<p style="margin-top: 1em">F95 <br>
The Fortran 95 compiler. You should normally set the
$FORTRAN variable, which specifies the default Fortran
compiler for all Fortran versions. You only need to set $F95
if <br>
you need to use a specific compiler or compiler version for
Fortran 95 files.</p>

<p style="margin-top: 1em">F95COM <br>
The command line used to compile a Fortran 95 source file to
an object file. You only need to set $F95COM if you need to
use a specific command line for Fortran 95 files. You <br>
should normally set the $FORTRANCOM variable, which
specifies the default command line for all Fortran
versions.</p>

<p style="margin-top: 1em">F95COMSTR <br>
The string displayed when a Fortran 95 source file is
compiled to an object file. If this is not set, then $F95COM
or $FORTRANCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">F95FILESUFFIXES <br>
The list of file extensions for which the F95 dialect will
be used. By default, this is [&rsquo;.f95&rsquo;]</p>

<p style="margin-top: 1em">F95FLAGS <br>
General user-specified options that are passed to the
Fortran 95 compiler. Note that this variable does not
contain -I (or similar) include search path options that
scons <br>
generates automatically from $F95PATH. See $_F95INCFLAGS
below, for the variable that expands to those options. You
only need to set $F95FLAGS if you need to define specific
<br>
user options for Fortran 95 files. You should normally set
the $FORTRANFLAGS variable, which specifies the
user-specified options passed to the default Fortran
compiler for <br>
all Fortran versions.</p>

<p style="margin-top: 1em">_F95INCFLAGS <br>
An automatically-generated construction variable containing
the Fortran 95 compiler command-line options for specifying
directories to be searched for include files. The <br>
value of $_F95INCFLAGS is created by appending $INCPREFIX
and $INCSUFFIX to the beginning and end of each directory in
$F95PATH.</p>

<p style="margin-top: 1em">F95PATH <br>
The list of directories that the Fortran 95 compiler will
search for include directories. The implicit dependency
scanner will search these directories for include files.
<br>
Don&rsquo;t explicitly put include directory arguments in
$F95FLAGS because the result will be non-portable and the
directories will not be searched by the dependency scanner.
<br>
Note: directory names in $F95PATH will be looked-up relative
to the SConscript directory when they are used in a command.
To force scons to look-up a directory relative to <br>
the root of the source tree use #: You only need to set
$F95PATH if you need to define a specific include path for
Fortran 95 files. You should normally set the $FORTRANPATH
<br>
variable, which specifies the include path for the default
Fortran compiler for all Fortran versions.</p>

<p style="margin-top: 1em">env =
Environment(F95PATH=&rsquo;#/include&rsquo;)</p>

<p style="margin-top: 1em">The directory look-up can also
be forced using the Dir() function:</p>

<p style="margin-top: 1em">include =
Dir(&rsquo;include&rsquo;) <br>
env = Environment(F95PATH=include)</p>

<p style="margin-top: 1em">The directory list will be added
to command lines through the automatically-generated
$_F95INCFLAGS construction variable, which is constructed by
appending the values of the <br>
$INCPREFIX and $INCSUFFIX construction variables to the
beginning and end of each directory in $F95PATH. Any command
lines you define that need the F95PATH directory list <br>
should include $_F95INCFLAGS:</p>

<p style="margin-top: 1em">env =
Environment(F95COM=&quot;my_compiler $_F95INCFLAGS -c -o
$TARGET $SOURCE&quot;)</p>

<p style="margin-top: 1em">F95PPCOM <br>
The command line used to compile a Fortran 95 source file to
an object file after first running the file through the C
preprocessor. Any options specified in the $F95FLAGS <br>
and $CPPFLAGS construction variables are included on this
command line. You only need to set $F95PPCOM if you need to
use a specific C-preprocessor command line for Fortran <br>
95 files. You should normally set the $FORTRANPPCOM
variable, which specifies the default C-preprocessor command
line for all Fortran versions.</p>

<p style="margin-top: 1em">F95PPCOMSTR <br>
The string displayed when a Fortran 95 source file is
compiled to an object file after first running the file
through the C preprocessor. If this is not set, then
$F95PPCOM <br>
or $FORTRANPPCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">F95PPFILESUFFIXES <br>
The list of file extensions for which the compilation +
preprocessor pass for F95 dialect will be used. By default,
this is empty</p>

<p style="margin-top: 1em">File <br>
A function that converts a string into a File instance
relative to the target being built.</p>

<p style="margin-top: 1em">A function that converts a
string into a File instance relative to the target being
built.</p>

<p style="margin-top: 1em">FORTRAN <br>
The default Fortran compiler for all versions of
Fortran.</p>

<p style="margin-top: 1em">FORTRANCOM <br>
The command line used to compile a Fortran source file to an
object file. By default, any options specified in the
$FORTRANFLAGS, $CPPFLAGS, $_CPPDEFFLAGS, $_FORTRANMODFLAG,
<br>
and $_FORTRANINCFLAGS construction variables are included on
this command line.</p>

<p style="margin-top: 1em">FORTRANCOMSTR <br>
The string displayed when a Fortran source file is compiled
to an object file. If this is not set, then $FORTRANCOM (the
command line) is displayed.</p>

<p style="margin-top: 1em">FORTRANFILESUFFIXES <br>
The list of file extensions for which the FORTRAN dialect
will be used. By default, this is [&rsquo;.f&rsquo;,
&rsquo;.for&rsquo;, &rsquo;.ftn&rsquo;]</p>

<p style="margin-top: 1em">FORTRANFLAGS <br>
General user-specified options that are passed to the
Fortran compiler. Note that this variable does not contain
-I (or similar) include or module search path options that
<br>
scons generates automatically from $FORTRANPATH. See
$_FORTRANINCFLAGS and $_FORTRANMODFLAG, below, for the
variables that expand those options.</p>

<p style="margin-top: 1em">_FORTRANINCFLAGS <br>
An automatically-generated construction variable containing
the Fortran compiler command-line options for specifying
directories to be searched for include files and module <br>
files. The value of $_FORTRANINCFLAGS is created by
prepending/appending $INCPREFIX and $INCSUFFIX to the
beginning and end of each directory in $FORTRANPATH.</p>

<p style="margin-top: 1em">FORTRANMODDIR <br>
Directory location where the Fortran compiler should place
any module files it generates. This variable is empty, by
default. Some Fortran compilers will internally append <br>
this directory in the search path for module files, as
well.</p>

<p style="margin-top: 1em">FORTRANMODDIRPREFIX <br>
The prefix used to specify a module directory on the Fortran
compiler command line. This will be appended to the
beginning of the directory in the $FORTRANMODDIR
construction <br>
variables when the $_FORTRANMODFLAG variables is
automatically generated.</p>

<p style="margin-top: 1em">FORTRANMODDIRSUFFIX <br>
The suffix used to specify a module directory on the Fortran
compiler command line. This will be appended to the
beginning of the directory in the $FORTRANMODDIR
construction <br>
variables when the $_FORTRANMODFLAG variables is
automatically generated.</p>

<p style="margin-top: 1em">_FORTRANMODFLAG <br>
An automatically-generated construction variable containing
the Fortran compiler command-line option for specifying the
directory location where the Fortran compiler should <br>
place any module files that happen to get generated during
compilation. The value of $_FORTRANMODFLAG is created by
prepending/appending $FORTRANMODDIRPREFIX and <br>
$FORTRANMODDIRSUFFIX to the beginning and end of the
directory in $FORTRANMODDIR.</p>

<p style="margin-top: 1em">FORTRANMODPREFIX <br>
The module file prefix used by the Fortran compiler. SCons
assumes that the Fortran compiler follows the quasi-standard
naming convention for module files of module_name.mod. <br>
As a result, this variable is left empty, by default. For
situations in which the compiler does not necessarily follow
the normal convention, the user may use this variable. <br>
Its value will be appended to every module file name as
scons attempts to resolve dependencies.</p>

<p style="margin-top: 1em">FORTRANMODSUFFIX <br>
The module file suffix used by the Fortran compiler. SCons
assumes that the Fortran compiler follows the quasi-standard
naming convention for module files of module_name.mod. <br>
As a result, this variable is set to &quot;.mod&quot;, by
default. For situations in which the compiler does not
necessarily follow the normal convention, the user may use
this <br>
variable. Its value will be appended to every module file
name as scons attempts to resolve dependencies.</p>

<p style="margin-top: 1em">FORTRANPATH <br>
The list of directories that the Fortran compiler will
search for include files and (for some compilers) module
files. The Fortran implicit dependency scanner will search
<br>
these directories for include files (but not module files
since they are autogenerated and, as such, may not actually
exist at the time the scan takes place). Don&rsquo;t <br>
explicitly put include directory arguments in FORTRANFLAGS
because the result will be non-portable and the directories
will not be searched by the dependency scanner. Note: <br>
directory names in FORTRANPATH will be looked-up relative to
the SConscript directory when they are used in a command. To
force scons to look-up a directory relative to the <br>
root of the source tree use #:</p>

<p style="margin-top: 1em">env =
Environment(FORTRANPATH=&rsquo;#/include&rsquo;)</p>

<p style="margin-top: 1em">The directory look-up can also
be forced using the Dir() function:</p>

<p style="margin-top: 1em">include =
Dir(&rsquo;include&rsquo;) <br>
env = Environment(FORTRANPATH=include)</p>

<p style="margin-top: 1em">The directory list will be added
to command lines through the automatically-generated
$_FORTRANINCFLAGS construction variable, which is
constructed by appending the values of <br>
the $INCPREFIX and $INCSUFFIX construction variables to the
beginning and end of each directory in $FORTRANPATH. Any
command lines you define that need the FORTRANPATH <br>
directory list should include $_FORTRANINCFLAGS:</p>

<p style="margin-top: 1em">env =
Environment(FORTRANCOM=&quot;my_compiler $_FORTRANINCFLAGS
-c -o $TARGET $SOURCE&quot;)</p>

<p style="margin-top: 1em">FORTRANPPCOM <br>
The command line used to compile a Fortran source file to an
object file after first running the file through the C
preprocessor. By default, any options specified in the <br>
$FORTRANFLAGS, $CPPFLAGS, $_CPPDEFFLAGS, $_FORTRANMODFLAG,
and $_FORTRANINCFLAGS construction variables are included on
this command line.</p>

<p style="margin-top: 1em">FORTRANPPCOMSTR <br>
The string displayed when a Fortran source file is compiled
to an object file after first running the file through the C
preprocessor. If this is not set, then $FORTRANPPCOM <br>
(the command line) is displayed.</p>

<p style="margin-top: 1em">FORTRANPPFILESUFFIXES <br>
The list of file extensions for which the compilation +
preprocessor pass for FORTRAN dialect will be used. By
default, this is [&rsquo;.fpp&rsquo;,
&rsquo;.FPP&rsquo;]</p>

<p style="margin-top: 1em">FORTRANSUFFIXES <br>
The list of suffixes of files that will be scanned for
Fortran implicit dependencies (INCLUDE lines and USE
statements). The default list is:</p>

<p style="margin-top: 1em">[&quot;.f&quot;, &quot;.F&quot;,
&quot;.for&quot;, &quot;.FOR&quot;, &quot;.ftn&quot;,
&quot;.FTN&quot;, &quot;.fpp&quot;, &quot;.FPP&quot;, <br>
&quot;.f77&quot;, &quot;.F77&quot;, &quot;.f90&quot;,
&quot;.F90&quot;, &quot;.f95&quot;, &quot;.F95&quot;]</p>

<p style="margin-top: 1em">FRAMEWORKPATH <br>
On Mac OS X with gcc, a list containing the paths to search
for frameworks. Used by the compiler to find framework-style
includes like #include &lt;Fmwk/Header.h&gt;. Used by the
<br>
linker to find user-specified frameworks when linking (see
$FRAMEWORKS). For example:</p>


<p style="margin-top: 1em">env.AppendUnique(FRAMEWORKPATH=&rsquo;#myframeworkdir&rsquo;)</p>

<p style="margin-top: 1em">will add</p>

<p style="margin-top: 1em">... -Fmyframeworkdir</p>

<p style="margin-top: 1em">to the compiler and linker
command lines.</p>

<p style="margin-top: 1em">_FRAMEWORKPATH <br>
On Mac OS X with gcc, an automatically-generated
construction variable containing the linker command-line
options corresponding to $FRAMEWORKPATH.</p>

<p style="margin-top: 1em">FRAMEWORKPATHPREFIX <br>
On Mac OS X with gcc, the prefix to be used for the
FRAMEWORKPATH entries. (see $FRAMEWORKPATH). The default
value is -F.</p>

<p style="margin-top: 1em">FRAMEWORKPREFIX <br>
On Mac OS X with gcc, the prefix to be used for linking in
frameworks (see $FRAMEWORKS). The default value is
-framework.</p>

<p style="margin-top: 1em">_FRAMEWORKS <br>
On Mac OS X with gcc, an automatically-generated
construction variable containing the linker command-line
options for linking with FRAMEWORKS.</p>

<p style="margin-top: 1em">FRAMEWORKS <br>
On Mac OS X with gcc, a list of the framework names to be
linked into a program or shared library or bundle. The
default value is the empty list. For example:</p>


<p style="margin-top: 1em">env.AppendUnique(FRAMEWORKS=Split(&rsquo;System
Cocoa SystemConfiguration&rsquo;))</p>

<p style="margin-top: 1em">FRAMEWORKSFLAGS <br>
On Mac OS X with gcc, general user-supplied frameworks
options to be added at the end of a command line building a
loadable module. (This has been largely superseded by the
<br>
$FRAMEWORKPATH, $FRAMEWORKPATHPREFIX, $FRAMEWORKPREFIX and
$FRAMEWORKS variables described above.)</p>

<p style="margin-top: 1em">GS <br>
The Ghostscript program used, e.g. to convert PostScript to
PDF files.</p>

<p style="margin-top: 1em">GSCOM <br>
The full Ghostscript command line used for the conversion
process. Its default value is &acirc;$GS $GSFLAGS
-sOutputFile=$TARGET $SOURCES&acirc;.</p>

<p style="margin-top: 1em">GSCOMSTR <br>
The string displayed when Ghostscript is called for the
conversion process. If this is not set (the default), then
$GSCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">GSFLAGS <br>
General options passed to the Ghostscript program, when
converting PostScript to PDF files for example. Its default
value is &acirc;-dNOPAUSE -dBATCH
-sDEVICE=pdfwrite&acirc;</p>

<p style="margin-top: 1em">HOST_ARCH <br>
Sets the host architecture for Visual Studio compiler. If
not set, default to the detected host architecture: note
that this may depend on the python you are using. This <br>
variable must be passed as an argument to the Environment()
constructor; setting it later has no effect.</p>

<p style="margin-top: 1em">Valid values are the same as for
$TARGET_ARCH.</p>

<p style="margin-top: 1em">This is currently only used on
Windows, but in the future it will be used on other OSes as
well.</p>

<p style="margin-top: 1em">The name of the host hardware
architecture used to create the Environment. If a platform
is specified when creating the Environment, then that
Platform&rsquo;s logic will handle <br>
setting this value. This value is immutable, and should not
be changed by the user after the Environment is initialized.
Currently only set for Win32.</p>

<p style="margin-top: 1em">HOST_OS <br>
The name of the host operating system used to create the
Environment. If a platform is specified when creating the
Environment, then that Platform&rsquo;s logic will handle
setting <br>
this value. This value is immutable, and should not be
changed by the user after the Environment is initialized.
Currently only set for Win32.</p>

<p style="margin-top: 1em">IDLSUFFIXES <br>
The list of suffixes of files that will be scanned for IDL
implicit dependencies (#include or import lines). The
default list is:</p>

<p style="margin-top: 1em">[&quot;.idl&quot;,
&quot;.IDL&quot;]</p>

<p style="margin-top: 1em">IMPLIBNOVERSIONSYMLINKS <br>
Used to override
$SHLIBNOVERSIONSYMLINKS/$LDMODULENOVERSIONSYMLINKS when
creating versioned import library for a shared
library/loadable module. If not defined, then <br>
$SHLIBNOVERSIONSYMLINKS/$LDMODULENOVERSIONSYMLINKS is used
to determine whether to disable symlink generation or
not.</p>

<p style="margin-top: 1em">IMPLIBPREFIX <br>
The prefix used for import library names. For example,
cygwin uses import libraries (libfoo.dll.a) in pair with
dynamic libraries (cygfoo.dll). The cyglink linker sets <br>
$IMPLIBPREFIX to &rsquo;lib&rsquo; and $SHLIBPREFIX to
&rsquo;cyg&rsquo;.</p>

<p style="margin-top: 1em">IMPLIBSUFFIX <br>
The suffix used for import library names. For example,
cygwin uses import libraries (libfoo.dll.a) in pair with
dynamic libraries (cygfoo.dll). The cyglink linker sets <br>
$IMPLIBSUFFIX to &rsquo;.dll.a&rsquo; and $SHLIBSUFFIX to
&rsquo;.dll&rsquo;.</p>

<p style="margin-top: 1em">IMPLIBVERSION <br>
Used to override $SHLIBVERSION/$LDMODULEVERSION when
generating versioned import library for a shared
library/loadable module. If undefined, the <br>
$SHLIBVERSION/$LDMODULEVERSION is used to determine the
version of versioned import library.</p>

<p style="margin-top: 1em">IMPLICIT_COMMAND_DEPENDENCIES
<br>
Controls whether or not SCons will add implicit dependencies
for the commands executed to build targets.</p>

<p style="margin-top: 1em">By default, SCons will add to
each target an implicit dependency on the command
represented by the first argument on any command line it
executes. The specific file for the <br>
dependency is found by searching the PATH variable in the
ENV environment used to execute the command.</p>

<p style="margin-top: 1em">If the construction variable
$IMPLICIT_COMMAND_DEPENDENCIES is set to a false value
(None, False, 0, etc.), then the implicit dependency will
not be added to the targets <br>
built with that construction environment.</p>

<p style="margin-top: 1em">env =
Environment(IMPLICIT_COMMAND_DEPENDENCIES = 0)</p>

<p style="margin-top: 1em">INCPREFIX <br>
The prefix used to specify an include directory on the C
compiler command line. This will be appended to the
beginning of each directory in the $CPPPATH and $FORTRANPATH
<br>
construction variables when the $_CPPINCFLAGS and
$_FORTRANINCFLAGS variables are automatically generated.</p>

<p style="margin-top: 1em">INCSUFFIX <br>
The suffix used to specify an include directory on the C
compiler command line. This will be appended to the end of
each directory in the $CPPPATH and $FORTRANPATH <br>
construction variables when the $_CPPINCFLAGS and
$_FORTRANINCFLAGS variables are automatically generated.</p>

<p style="margin-top: 1em">INSTALL <br>
A function to be called to install a file into a destination
file name. The default function copies the file into the
destination (and sets the destination file&rsquo;s mode and
<br>
permission bits to match the source file&rsquo;s). The
function takes the following arguments:</p>

<p style="margin-top: 1em">def install(dest, source,
env):</p>

<p style="margin-top: 1em">dest is the path name of the
destination file. source is the path name of the source
file. env is the construction environment (a dictionary of
construction values) in <br>
force for this file installation.</p>

<p style="margin-top: 1em">INSTALLSTR <br>
The string displayed when a file is installed into a
destination file name. The default is:</p>

<p style="margin-top: 1em">Install file:
&quot;$SOURCE&quot; as &quot;$TARGET&quot;</p>

<p style="margin-top: 1em">INTEL_C_COMPILER_VERSION <br>
Set by the &quot;intelc&quot; Tool to the major version
number of the Intel C compiler selected for use.</p>

<p style="margin-top: 1em">JAR <br>
The Java archive tool.</p>

<p style="margin-top: 1em">The Java archive tool.</p>

<p style="margin-top: 1em">JARCHDIR <br>
The directory to which the Java archive tool should change
(using the -C option).</p>

<p style="margin-top: 1em">The directory to which the Java
archive tool should change (using the -C option).</p>

<p style="margin-top: 1em">JARCOM <br>
The command line used to call the Java archive tool.</p>

<p style="margin-top: 1em">The command line used to call
the Java archive tool.</p>

<p style="margin-top: 1em">JARCOMSTR <br>
The string displayed when the Java archive tool is called If
this is not set, then $JARCOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">env = Environment(JARCOMSTR =
&quot;JARchiving $SOURCES into $TARGET&quot;)</p>

<p style="margin-top: 1em">The string displayed when the
Java archive tool is called If this is not set, then $JARCOM
(the command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(JARCOMSTR =
&quot;JARchiving $SOURCES into $TARGET&quot;)</p>

<p style="margin-top: 1em">JARFLAGS <br>
General options passed to the Java archive tool. By default
this is set to cf to create the necessary jar file.</p>

<p style="margin-top: 1em">General options passed to the
Java archive tool. By default this is set to cf to create
the necessary jar file.</p>

<p style="margin-top: 1em">JARSUFFIX <br>
The suffix for Java archives: .jar by default.</p>

<p style="margin-top: 1em">The suffix for Java archives:
.jar by default.</p>

<p style="margin-top: 1em">JAVABOOTCLASSPATH <br>
Specifies the list of directories that will be added to the
javac command line via the -bootclasspath option. The
individual directory names will be separated by the <br>
operating system&rsquo;s path separate character (: on
UNIX/Linux/POSIX, ; on Windows).</p>

<p style="margin-top: 1em">JAVAC <br>
The Java compiler.</p>

<p style="margin-top: 1em">JAVACCOM <br>
The command line used to compile a directory tree containing
Java source files to corresponding Java class files. Any
options specified in the $JAVACFLAGS construction <br>
variable are included on this command line.</p>

<p style="margin-top: 1em">JAVACCOMSTR <br>
The string displayed when compiling a directory tree of Java
source files to corresponding Java class files. If this is
not set, then $JAVACCOM (the command line) is <br>
displayed.</p>

<p style="margin-top: 1em">env = Environment(JAVACCOMSTR =
&quot;Compiling class files $TARGETS from
$SOURCES&quot;)</p>

<p style="margin-top: 1em">JAVACFLAGS <br>
General options that are passed to the Java compiler.</p>

<p style="margin-top: 1em">JAVACLASSDIR <br>
The directory in which Java class files may be found. This
is stripped from the beginning of any Java .class file names
supplied to the JavaH builder.</p>

<p style="margin-top: 1em">JAVACLASSPATH <br>
Specifies the list of directories that will be searched for
Java .class file. The directories in this list will be added
to the javac and javah command lines via the <br>
-classpath option. The individual directory names will be
separated by the operating system&rsquo;s path separate
character (: on UNIX/Linux/POSIX, ; on Windows).</p>

<p style="margin-top: 1em">Note that this currently just
adds the specified directory via the -classpath option.
SCons does not currently search the $JAVACLASSPATH
directories for dependency .class <br>
files.</p>

<p style="margin-top: 1em">JAVACLASSSUFFIX <br>
The suffix for Java class files; .class by default.</p>

<p style="margin-top: 1em">JAVAH <br>
The Java generator for C header and stub files.</p>

<p style="margin-top: 1em">JAVAHCOM <br>
The command line used to generate C header and stub files
from Java classes. Any options specified in the $JAVAHFLAGS
construction variable are included on this command line.</p>

<p style="margin-top: 1em">JAVAHCOMSTR <br>
The string displayed when C header and stub files are
generated from Java classes. If this is not set, then
$JAVAHCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(JAVAHCOMSTR =
&quot;Generating header/stub file(s) $TARGETS from
$SOURCES&quot;)</p>

<p style="margin-top: 1em">JAVAHFLAGS <br>
General options passed to the C header and stub file
generator for Java classes.</p>

<p style="margin-top: 1em">JAVASOURCEPATH <br>
Specifies the list of directories that will be searched for
input .java file. The directories in this list will be added
to the javac command line via the -sourcepath option. <br>
The individual directory names will be separated by the
operating system&rsquo;s path separate character (: on
UNIX/Linux/POSIX, ; on Windows).</p>

<p style="margin-top: 1em">Note that this currently just
adds the specified directory via the -sourcepath option.
SCons does not currently search the $JAVASOURCEPATH
directories for dependency .java <br>
files.</p>

<p style="margin-top: 1em">JAVASUFFIX <br>
The suffix for Java files; .java by default.</p>

<p style="margin-top: 1em">JAVAVERSION <br>
Specifies the Java version being used by the Java builder.
This is not currently used to select one version of the Java
compiler vs. another. Instead, you should set this to <br>
specify the version of Java supported by your javac
compiler. The default is 1.4.</p>

<p style="margin-top: 1em">This is sometimes necessary
because Java 1.5 changed the file names that are created for
nested anonymous inner classes, which can cause a mismatch
with the files that SCons <br>
expects will be generated by the javac compiler. Setting
$JAVAVERSION to 1.5 (or 1.6, as appropriate) can make SCons
realize that a Java 1.5 or 1.6 build is actually up to <br>
date.</p>

<p style="margin-top: 1em">LATEX <br>
The LaTeX structured formatter and typesetter.</p>

<p style="margin-top: 1em">LATEXCOM <br>
The command line used to call the LaTeX structured formatter
and typesetter.</p>

<p style="margin-top: 1em">LATEXCOMSTR <br>
The string displayed when calling the LaTeX structured
formatter and typesetter. If this is not set, then $LATEXCOM
(the command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(LATEXCOMSTR =
&quot;Building $TARGET from LaTeX input $SOURCES&quot;)</p>

<p style="margin-top: 1em">LATEXFLAGS <br>
General options passed to the LaTeX structured formatter and
typesetter.</p>

<p style="margin-top: 1em">LATEXRETRIES <br>
The maximum number of times that LaTeX will be re-run if the
.log generated by the $LATEXCOM command indicates that there
are undefined references. The default is to try to <br>
resolve undefined references by re-running LaTeX up to three
times.</p>

<p style="margin-top: 1em">LATEXSUFFIXES <br>
The list of suffixes of files that will be scanned for LaTeX
implicit dependencies (include or import files). The default
list is:</p>

<p style="margin-top: 1em">[&quot;.tex&quot;,
&quot;.ltx&quot;, &quot;.latex&quot;]</p>

<p style="margin-top: 1em">LDMODULE <br>
The linker for building loadable modules. By default, this
is the same as $SHLINK.</p>

<p style="margin-top: 1em">LDMODULECOM <br>
The command line for building loadable modules. On Mac OS X,
this uses the $LDMODULE, $LDMODULEFLAGS and $FRAMEWORKSFLAGS
variables. On other systems, this is the same as <br>
$SHLINK.</p>

<p style="margin-top: 1em">LDMODULECOMSTR <br>
The string displayed when building loadable modules. If this
is not set, then $LDMODULECOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">LDMODULEFLAGS <br>
General user options passed to the linker for building
loadable modules.</p>

<p style="margin-top: 1em">LDMODULENOVERSIONSYMLINKS <br>
Instructs the LoadableModule builder to not automatically
create symlinks for versioned modules. Defaults to
$SHLIBNOVERSIONSYMLINKS</p>

<p style="margin-top: 1em">LDMODULEPREFIX <br>
The prefix used for loadable module file names. On Mac OS X,
this is null; on other systems, this is the same as
$SHLIBPREFIX.</p>

<p style="margin-top: 1em">_LDMODULESONAME <br>
A macro that automatically generates loadable module&rsquo;s
SONAME based on $TARGET, $LDMODULEVERSION and
$LDMODULESUFFIX. Used by LoadableModule builder when the
linker tool <br>
supports SONAME (e.g. gnulink).</p>

<p style="margin-top: 1em">LDMODULESUFFIX <br>
The suffix used for loadable module file names. On Mac OS X,
this is null; on other systems, this is the same as
$SHLIBSUFFIX.</p>

<p style="margin-top: 1em">LDMODULEVERSION <br>
When this construction variable is defined, a versioned
loadable module is created by LoadableModule builder. This
activates the $_LDMODULEVERSIONFLAGS and thus modifies the
<br>
$LDMODULECOM as required, adds the version number to the
library name, and creates the symlinks that are needed.
$LDMODULEVERSION versions should exist in the same format as
<br>
$SHLIBVERSION.</p>

<p style="margin-top: 1em">LDMODULEVERSIONFLAGS <br>
Extra flags added to $LDMODULECOM when building versioned
LoadableModule. These flags are only used when
$LDMODULEVERSION is set.</p>

<p style="margin-top: 1em">_LDMODULEVERSIONFLAGS <br>
This macro automatically introduces extra flags to
$LDMODULECOM when building versioned LoadableModule (that is
when $LDMODULEVERSION is set). _LDMODULEVERSIONFLAGS usually
<br>
adds $SHLIBVERSIONFLAGS and some extra dynamically generated
options (such as -Wl,-soname=$_LDMODULESONAME). It is unused
by plain (unversioned) loadable modules.</p>

<p style="margin-top: 1em">LEX <br>
The lexical analyzer generator.</p>

<p style="margin-top: 1em">LEXCOM <br>
The command line used to call the lexical analyzer generator
to generate a source file.</p>

<p style="margin-top: 1em">LEXCOMSTR <br>
The string displayed when generating a source file using the
lexical analyzer generator. If this is not set, then $LEXCOM
(the command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(LEXCOMSTR =
&quot;Lex&rsquo;ing $TARGET from $SOURCES&quot;)</p>

<p style="margin-top: 1em">LEXFLAGS <br>
General options passed to the lexical analyzer
generator.</p>

<p style="margin-top: 1em">_LIBDIRFLAGS <br>
An automatically-generated construction variable containing
the linker command-line options for specifying directories
to be searched for library. The value of $_LIBDIRFLAGS <br>
is created by appending $LIBDIRPREFIX and $LIBDIRSUFFIX to
the beginning and end of each directory in $LIBPATH.</p>

<p style="margin-top: 1em">LIBDIRPREFIX <br>
The prefix used to specify a library directory on the linker
command line. This will be appended to the beginning of each
directory in the $LIBPATH construction variable when <br>
the $_LIBDIRFLAGS variable is automatically generated.</p>

<p style="margin-top: 1em">LIBDIRSUFFIX <br>
The suffix used to specify a library directory on the linker
command line. This will be appended to the end of each
directory in the $LIBPATH construction variable when the
<br>
$_LIBDIRFLAGS variable is automatically generated.</p>

<p style="margin-top: 1em">LIBEMITTER <br>
TODO</p>

<p style="margin-top: 1em">_LIBFLAGS <br>
An automatically-generated construction variable containing
the linker command-line options for specifying libraries to
be linked with the resulting target. The value of <br>
$_LIBFLAGS is created by appending $LIBLINKPREFIX and
$LIBLINKSUFFIX to the beginning and end of each filename in
$LIBS.</p>

<p style="margin-top: 1em">LIBLINKPREFIX <br>
The prefix used to specify a library to link on the linker
command line. This will be appended to the beginning of each
library in the $LIBS construction variable when the <br>
$_LIBFLAGS variable is automatically generated.</p>

<p style="margin-top: 1em">LIBLINKSUFFIX <br>
The suffix used to specify a library to link on the linker
command line. This will be appended to the end of each
library in the $LIBS construction variable when the <br>
$_LIBFLAGS variable is automatically generated.</p>

<p style="margin-top: 1em">LIBPATH <br>
The list of directories that will be searched for libraries.
The implicit dependency scanner will search these
directories for include files. Don&rsquo;t explicitly put
include <br>
directory arguments in $LINKFLAGS or $SHLINKFLAGS because
the result will be non-portable and the directories will not
be searched by the dependency scanner. Note: directory <br>
names in LIBPATH will be looked-up relative to the
SConscript directory when they are used in a command. To
force scons to look-up a directory relative to the root of
the <br>
source tree use #:</p>

<p style="margin-top: 1em">env =
Environment(LIBPATH=&rsquo;#/libs&rsquo;)</p>

<p style="margin-top: 1em">The directory look-up can also
be forced using the Dir() function:</p>

<p style="margin-top: 1em">libs = Dir(&rsquo;libs&rsquo;)
<br>
env = Environment(LIBPATH=libs)</p>

<p style="margin-top: 1em">The directory list will be added
to command lines through the automatically-generated
$_LIBDIRFLAGS construction variable, which is constructed by
appending the values of the <br>
$LIBDIRPREFIX and $LIBDIRSUFFIX construction variables to
the beginning and end of each directory in $LIBPATH. Any
command lines you define that need the LIBPATH directory
<br>
list should include $_LIBDIRFLAGS:</p>

<p style="margin-top: 1em">env =
Environment(LINKCOM=&quot;my_linker $_LIBDIRFLAGS $_LIBFLAGS
-o $TARGET $SOURCE&quot;)</p>

<p style="margin-top: 1em">LIBPREFIX <br>
The prefix used for (static) library file names. A default
value is set for each platform (posix, win32, os2, etc.),
but the value is overridden by individual tools (ar, <br>
mslib, sgiar, sunar, tlib, etc.) to reflect the names of the
libraries they create.</p>

<p style="margin-top: 1em">LIBPREFIXES <br>
A list of all legal prefixes for library file names. When
searching for library dependencies, SCons will look for
files with these prefixes, the base library name, and <br>
suffixes in the $LIBSUFFIXES list.</p>

<p style="margin-top: 1em">LIBS <br>
A list of one or more libraries that will be linked with any
executable programs created by this environment.</p>

<p style="margin-top: 1em">The library list will be added
to command lines through the automatically-generated
$_LIBFLAGS construction variable, which is constructed by
appending the values of the <br>
$LIBLINKPREFIX and $LIBLINKSUFFIX construction variables to
the beginning and end of each filename in $LIBS. Any command
lines you define that need the LIBS library list <br>
should include $_LIBFLAGS:</p>

<p style="margin-top: 1em">env =
Environment(LINKCOM=&quot;my_linker $_LIBDIRFLAGS $_LIBFLAGS
-o $TARGET $SOURCE&quot;)</p>

<p style="margin-top: 1em">If you add a File object to the
$LIBS list, the name of that file will be added to
$_LIBFLAGS, and thus the link line, as is, without
$LIBLINKPREFIX or $LIBLINKSUFFIX. For <br>
example:</p>


<p style="margin-top: 1em">env.Append(LIBS=File(&rsquo;/tmp/mylib.so&rsquo;))</p>

<p style="margin-top: 1em">In all cases, scons will add
dependencies from the executable program to all the
libraries in this list.</p>

<p style="margin-top: 1em">LIBSUFFIX <br>
The suffix used for (static) library file names. A default
value is set for each platform (posix, win32, os2, etc.),
but the value is overridden by individual tools (ar, <br>
mslib, sgiar, sunar, tlib, etc.) to reflect the names of the
libraries they create.</p>

<p style="margin-top: 1em">LIBSUFFIXES <br>
A list of all legal suffixes for library file names. When
searching for library dependencies, SCons will look for
files with prefixes, in the $LIBPREFIXES list, the base <br>
library name, and these suffixes.</p>

<p style="margin-top: 1em">LICENSE <br>
The abbreviated name of the license under which this project
is released (gpl, lpgl, bsd etc.). See
http://www.opensource.org/licenses/alphabetical for a list
of license <br>
names.</p>

<p style="margin-top: 1em">LINESEPARATOR <br>
The separator used by the Substfile and Textfile builders.
This value is used between sources when constructing the
target. It defaults to the current system line
separator.</p>

<p style="margin-top: 1em">LINGUAS_FILE <br>
The $LINGUAS_FILE defines file(s) containing list of
additional linguas to be processed by POInit, POUpdate or
MOFiles builders. It also affects Translate builder. If the
<br>
variable contains a string, it defines name of the list
file. The $LINGUAS_FILE may be a list of file names as well.
If $LINGUAS_FILE is set to True (or non-zero numeric <br>
value), the list will be read from default file named
LINGUAS.</p>

<p style="margin-top: 1em">LINK <br>
The linker.</p>

<p style="margin-top: 1em">LINKCOM <br>
The command line used to link object files into an
executable.</p>

<p style="margin-top: 1em">LINKCOMSTR <br>
The string displayed when object files are linked into an
executable. If this is not set, then $LINKCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(LINKCOMSTR =
&quot;Linking $TARGET&quot;)</p>

<p style="margin-top: 1em">LINKFLAGS <br>
General user options passed to the linker. Note that this
variable should not contain -l (or similar) options for
linking with the libraries listed in $LIBS, nor -L (or <br>
similar) library search path options that scons generates
automatically from $LIBPATH. See $_LIBFLAGS above, for the
variable that expands to library-link options, and <br>
$_LIBDIRFLAGS above, for the variable that expands to
library search path options.</p>

<p style="margin-top: 1em">M4 <br>
The M4 macro preprocessor.</p>

<p style="margin-top: 1em">M4COM <br>
The command line used to pass files through the M4 macro
preprocessor.</p>

<p style="margin-top: 1em">M4COMSTR <br>
The string displayed when a file is passed through the M4
macro preprocessor. If this is not set, then $M4COM (the
command line) is displayed.</p>

<p style="margin-top: 1em">M4FLAGS <br>
General options passed to the M4 macro preprocessor.</p>

<p style="margin-top: 1em">MAKEINDEX <br>
The makeindex generator for the TeX formatter and typesetter
and the LaTeX structured formatter and typesetter.</p>

<p style="margin-top: 1em">MAKEINDEXCOM <br>
The command line used to call the makeindex generator for
the TeX formatter and typesetter and the LaTeX structured
formatter and typesetter.</p>

<p style="margin-top: 1em">MAKEINDEXCOMSTR <br>
The string displayed when calling the makeindex generator
for the TeX formatter and typesetter and the LaTeX
structured formatter and typesetter. If this is not set,
then <br>
$MAKEINDEXCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">MAKEINDEXFLAGS <br>
General options passed to the makeindex generator for the
TeX formatter and typesetter and the LaTeX structured
formatter and typesetter.</p>

<p style="margin-top: 1em">MAXLINELENGTH <br>
The maximum number of characters allowed on an external
command line. On Win32 systems, link lines longer than this
many characters are linked via a temporary file name.</p>

<p style="margin-top: 1em">MIDL <br>
The Microsoft IDL compiler.</p>

<p style="margin-top: 1em">MIDLCOM <br>
The command line used to pass files to the Microsoft IDL
compiler.</p>

<p style="margin-top: 1em">MIDLCOMSTR <br>
The string displayed when the Microsoft IDL copmiler is
called. If this is not set, then $MIDLCOM (the command line)
is displayed.</p>

<p style="margin-top: 1em">MIDLFLAGS <br>
General options passed to the Microsoft IDL compiler.</p>

<p style="margin-top: 1em">MOSUFFIX <br>
Suffix used for MO files (default: &rsquo;.mo&rsquo;). See
msgfmt tool and MOFiles builder.</p>

<p style="margin-top: 1em">MSGFMT <br>
Absolute path to msgfmt(1) binary, found by Detect(). See
msgfmt tool and MOFiles builder.</p>

<p style="margin-top: 1em">MSGFMTCOM <br>
Complete command line to run msgfmt(1) program. See msgfmt
tool and MOFiles builder.</p>

<p style="margin-top: 1em">MSGFMTCOMSTR <br>
String to display when msgfmt(1) is invoked (default:
&rsquo;&rsquo;, which means &lsquo;&lsquo;print
$MSGFMTCOM&rsquo;&rsquo;). See msgfmt tool and MOFiles
builder.</p>

<p style="margin-top: 1em">MSGFMTFLAGS <br>
Additional flags to msgfmt(1). See msgfmt tool and MOFiles
builder.</p>

<p style="margin-top: 1em">MSGINIT <br>
Path to msginit(1) program (found via Detect()). See msginit
tool and POInit builder.</p>

<p style="margin-top: 1em">MSGINITCOM <br>
Complete command line to run msginit(1) program. See msginit
tool and POInit builder.</p>

<p style="margin-top: 1em">MSGINITCOMSTR <br>
String to display when msginit(1) is invoked (default:
&rsquo;&rsquo;, which means &lsquo;&lsquo;print
$MSGINITCOM&rsquo;&rsquo;). See msginit tool and POInit
builder.</p>

<p style="margin-top: 1em">MSGINITFLAGS <br>
List of additional flags to msginit(1) (default: []). See
msginit tool and POInit builder.</p>

<p style="margin-top: 1em">_MSGINITLOCALE <br>
Internal &lsquo;&lsquo;macro&rsquo;&rsquo;. Computes locale
(language) name based on target filename (default:
&rsquo;${TARGET.filebase}&rsquo;).</p>

<p style="margin-top: 1em">See msginit tool and POInit
builder.</p>

<p style="margin-top: 1em">MSGMERGE <br>
Absolute path to msgmerge(1) binary as found by Detect().
See msgmerge tool and POUpdate builder.</p>

<p style="margin-top: 1em">MSGMERGECOM <br>
Complete command line to run msgmerge(1) command. See
msgmerge tool and POUpdate builder.</p>

<p style="margin-top: 1em">MSGMERGECOMSTR <br>
String to be displayed when msgmerge(1) is invoked (default:
&rsquo;&rsquo;, which means &lsquo;&lsquo;print
$MSGMERGECOM&rsquo;&rsquo;). See msgmerge tool and POUpdate
builder.</p>

<p style="margin-top: 1em">MSGMERGEFLAGS <br>
Additional flags to msgmerge(1) command. See msgmerge tool
and POUpdate builder.</p>

<p style="margin-top: 1em">MSSDK_DIR <br>
The directory containing the Microsoft SDK (either Platform
SDK or Windows SDK) to be used for compilation.</p>

<p style="margin-top: 1em">MSSDK_VERSION <br>
The version string of the Microsoft SDK (either Platform SDK
or Windows SDK) to be used for compilation. Supported
versions include 6.1, 6.0A, 6.0, 2003R2 and 2003R1.</p>

<p style="margin-top: 1em">MSVC_BATCH <br>
When set to any true value, specifies that SCons should
batch compilation of object files when calling the Microsoft
Visual C/C++ compiler. All compilations of source files <br>
from the same source directory that generate target files in
a same output directory and were configured in SCons using
the same construction environment will be built in a <br>
single call to the compiler. Only source files that have
changed since their object files were built will be passed
to each compiler invocation (via the $CHANGED_SOURCES <br>
construction variable). Any compilations where the object
(target) file base name (minus the .obj) does not match the
source file base name will be compiled separately.</p>

<p style="margin-top: 1em">MSVC_USE_SCRIPT <br>
Use a batch script to set up Microsoft Visual Studio
compiler</p>

<p style="margin-top: 1em">$MSVC_USE_SCRIPT overrides
$MSVC_VERSION and $TARGET_ARCH. If set to the name of a
Visual Studio .bat file (e.g. vcvars.bat), SCons will run
that bat file and extract the <br>
relevant variables from the result (typically %INCLUDE%,
%LIB%, and %PATH%). Setting MSVC_USE_SCRIPT to None bypasses
the Visual Studio autodetection entirely; use this if <br>
you are running SCons in a Visual Studio cmd window and
importing the shell&rsquo;s environment variables.</p>

<p style="margin-top: 1em">MSVC_VERSION <br>
Sets the preferred version of Microsoft Visual C/C++ to
use.</p>

<p style="margin-top: 1em">If $MSVC_VERSION is not set,
SCons will (by default) select the latest version of Visual
C/C++ installed on your system. If the specified version
isn&rsquo;t installed, tool <br>
initialization will fail. This variable must be passed as an
argument to the Environment() constructor; setting it later
has no effect.</p>

<p style="margin-top: 1em">Valid values for Windows are
12.0, 12.0Exp, 11.0, 11.0Exp, 10.0, 10.0Exp, 9.0, 9.0Exp,
8.0, 8.0Exp, 7.1, 7.0, and 6.0. Versions ending in Exp refer
to &quot;Express&quot; or &quot;Express <br>
for Desktop&quot; editions.</p>

<p style="margin-top: 1em">MSVS <br>
When the Microsoft Visual Studio tools are initialized, they
set up this dictionary with the following keys:</p>

<p style="margin-top: 1em">VERSION <br>
the version of MSVS being used (can be set via
$MSVS_VERSION)</p>

<p style="margin-top: 1em">VERSIONS <br>
the available versions of MSVS installed</p>

<p style="margin-top: 1em">VCINSTALLDIR <br>
installed directory of Visual C++</p>

<p style="margin-top: 1em">VSINSTALLDIR <br>
installed directory of Visual Studio</p>

<p style="margin-top: 1em">FRAMEWORKDIR <br>
installed directory of the .NET framework</p>

<p style="margin-top: 1em">FRAMEWORKVERSIONS <br>
list of installed versions of the .NET framework, sorted
latest to oldest.</p>

<p style="margin-top: 1em">FRAMEWORKVERSION <br>
latest installed version of the .NET framework</p>

<p style="margin-top: 1em">FRAMEWORKSDKDIR <br>
installed location of the .NET SDK.</p>

<p style="margin-top: 1em">PLATFORMSDKDIR <br>
installed location of the Platform SDK.</p>

<p style="margin-top: 1em">PLATFORMSDK_MODULES <br>
dictionary of installed Platform SDK modules, where the
dictionary keys are keywords for the various modules, and
the values are 2-tuples where the first is the release <br>
date, and the second is the version number.</p>

<p style="margin-top: 1em">If a value isn&rsquo;t set, it
wasn&rsquo;t available in the registry.</p>

<p style="margin-top: 1em">MSVS_ARCH <br>
Sets the architecture for which the generated project(s)
should build.</p>

<p style="margin-top: 1em">The default value is x86. amd64
is also supported by SCons for some Visual Studio versions.
Trying to set $MSVS_ARCH to an architecture that&rsquo;s not
supported for a given <br>
Visual Studio version will generate an error.</p>

<p style="margin-top: 1em">MSVS_PROJECT_GUID <br>
The string placed in a generated Microsoft Visual Studio
project file as the value of the ProjectGUID attribute.
There is no default value. If not defined, a new GUID is
<br>
generated.</p>

<p style="margin-top: 1em">MSVS_SCC_AUX_PATH <br>
The path name placed in a generated Microsoft Visual Studio
project file as the value of the SccAuxPath attribute if the
MSVS_SCC_PROVIDER construction variable is also set. <br>
There is no default value.</p>

<p style="margin-top: 1em">MSVS_SCC_CONNECTION_ROOT <br>
The root path of projects in your SCC workspace, i.e the
path under which all project and solution files will be
generated. It is used as a reference path from which the
<br>
relative paths of the generated Microsoft Visual Studio
project and solution files are computed. The relative
project file path is placed as the value of the SccLocalPath
<br>
attribute of the project file and as the values of the
SccProjectFilePathRelativizedFromConnection[i] (where [i]
ranges from 0 to the number of projects in the solution)
<br>
attributes of the GlobalSection(SourceCodeControl) section
of the Microsoft Visual Studio solution file. Similarly the
relative solution file path is placed as the values of <br>
the SccLocalPath[i] (where [i] ranges from 0 to the number
of projects in the solution) attributes of the
GlobalSection(SourceCodeControl) section of the Microsoft
Visual <br>
Studio solution file. This is used only if the
MSVS_SCC_PROVIDER construction variable is also set. The
default value is the current working directory.</p>

<p style="margin-top: 1em">MSVS_SCC_PROJECT_NAME <br>
The project name placed in a generated Microsoft Visual
Studio project file as the value of the SccProjectName
attribute if the MSVS_SCC_PROVIDER construction variable is
<br>
also set. In this case the string is also placed in the
SccProjectName0 attribute of the
GlobalSection(SourceCodeControl) section of the Microsoft
Visual Studio solution <br>
file. There is no default value.</p>

<p style="margin-top: 1em">MSVS_SCC_PROVIDER <br>
The string placed in a generated Microsoft Visual Studio
project file as the value of the SccProvider attribute. The
string is also placed in the SccProvider0 attribute of <br>
the GlobalSection(SourceCodeControl) section of the
Microsoft Visual Studio solution file. There is no default
value.</p>

<p style="margin-top: 1em">MSVS_VERSION <br>
Sets the preferred version of Microsoft Visual Studio to
use.</p>

<p style="margin-top: 1em">If $MSVS_VERSION is not set,
SCons will (by default) select the latest version of Visual
Studio installed on your system. So, if you have version 6
and version 7 (MSVS .NET) <br>
installed, it will prefer version 7. You can override this
by specifying the MSVS_VERSION variable in the Environment
initialization, setting it to the appropriate version <br>
(&rsquo;6.0&rsquo; or &rsquo;7.0&rsquo;, for example). If
the specified version isn&rsquo;t installed, tool
initialization will fail.</p>

<p style="margin-top: 1em">This is obsolete: use
$MSVC_VERSION instead. If $MSVS_VERSION is set and
$MSVC_VERSION is not, $MSVC_VERSION will be set
automatically to $MSVS_VERSION. If both are set to <br>
different values, scons will raise an error.</p>

<p style="margin-top: 1em">MSVSBUILDCOM <br>
The build command line placed in a generated Microsoft
Visual Studio project file. The default is to have Visual
Studio invoke SCons with any specified build targets.</p>

<p style="margin-top: 1em">MSVSCLEANCOM <br>
The clean command line placed in a generated Microsoft
Visual Studio project file. The default is to have Visual
Studio invoke SCons with the -c option to remove any <br>
specified targets.</p>

<p style="margin-top: 1em">MSVSENCODING <br>
The encoding string placed in a generated Microsoft Visual
Studio project file. The default is encoding
Windows-1252.</p>

<p style="margin-top: 1em">MSVSPROJECTCOM <br>
The action used to generate Microsoft Visual Studio project
files.</p>

<p style="margin-top: 1em">MSVSPROJECTSUFFIX <br>
The suffix used for Microsoft Visual Studio project (DSP)
files. The default value is .vcproj when using Visual Studio
version 7.x (.NET) or later version, and .dsp when <br>
using earlier versions of Visual Studio.</p>

<p style="margin-top: 1em">MSVSREBUILDCOM <br>
The rebuild command line placed in a generated Microsoft
Visual Studio project file. The default is to have Visual
Studio invoke SCons with any specified rebuild targets.</p>

<p style="margin-top: 1em">MSVSSCONS <br>
The SCons used in generated Microsoft Visual Studio project
files. The default is the version of SCons being used to
generate the project file.</p>

<p style="margin-top: 1em">MSVSSCONSCOM <br>
The default SCons command used in generated Microsoft Visual
Studio project files.</p>

<p style="margin-top: 1em">MSVSSCONSCRIPT <br>
The sconscript file (that is, SConstruct or SConscript file)
that will be invoked by Visual Studio project files (through
the $MSVSSCONSCOM variable). The default is the same <br>
sconscript file that contains the call to MSVSProject to
build the project file.</p>

<p style="margin-top: 1em">MSVSSCONSFLAGS <br>
The SCons flags used in generated Microsoft Visual Studio
project files.</p>

<p style="margin-top: 1em">MSVSSOLUTIONCOM <br>
The action used to generate Microsoft Visual Studio solution
files.</p>

<p style="margin-top: 1em">MSVSSOLUTIONSUFFIX <br>
The suffix used for Microsoft Visual Studio solution (DSW)
files. The default value is .sln when using Visual Studio
version 7.x (.NET), and .dsw when using earlier versions
<br>
of Visual Studio.</p>

<p style="margin-top: 1em">MT <br>
The program used on Windows systems to embed manifests into
DLLs and EXEs. See also $WINDOWS_EMBED_MANIFEST.</p>

<p style="margin-top: 1em">MTEXECOM <br>
The Windows command line used to embed manifests into
executables. See also $MTSHLIBCOM.</p>

<p style="margin-top: 1em">MTFLAGS <br>
Flags passed to the $MT manifest embedding program (Windows
only).</p>

<p style="margin-top: 1em">MTSHLIBCOM <br>
The Windows command line used to embed manifests into shared
libraries (DLLs). See also $MTEXECOM.</p>

<p style="margin-top: 1em">MWCW_VERSION <br>
The version number of the MetroWerks CodeWarrior C compiler
to be used.</p>

<p style="margin-top: 1em">MWCW_VERSIONS <br>
A list of installed versions of the MetroWerks CodeWarrior C
compiler on this system.</p>

<p style="margin-top: 1em">NAME <br>
Specfies the name of the project to package.</p>

<p style="margin-top: 1em">no_import_lib <br>
When set to non-zero, suppresses creation of a corresponding
Windows static import lib by the SharedLibrary builder when
used with MinGW, Microsoft Visual Studio or <br>
Metrowerks. This also suppresses creation of an export
(.exp) file when using Microsoft Visual Studio.</p>

<p style="margin-top: 1em">OBJPREFIX <br>
The prefix used for (static) object file names.</p>

<p style="margin-top: 1em">OBJSUFFIX <br>
The suffix used for (static) object file names.</p>

<p style="margin-top: 1em">P4 <br>
The Perforce executable.</p>

<p style="margin-top: 1em">P4COM <br>
The command line used to fetch source files from
Perforce.</p>

<p style="margin-top: 1em">P4COMSTR <br>
The string displayed when fetching a source file from
Perforce. If this is not set, then $P4COM (the command line)
is displayed.</p>

<p style="margin-top: 1em">P4FLAGS <br>
General options that are passed to Perforce.</p>

<p style="margin-top: 1em">PACKAGEROOT <br>
Specifies the directory where all files in resulting archive
will be placed if applicable. The default value is
&quot;$NAME-$VERSION&quot;.</p>

<p style="margin-top: 1em">PACKAGETYPE <br>
Selects the package type to build. Currently these are
available:</p>

<p style="margin-top: 1em">* msi - Microsoft Installer *
rpm - Redhat Package Manger * ipkg - Itsy Package Management
System * tarbz2 - compressed tar * targz - compressed tar *
zip - zip file * <br>
src_tarbz2 - compressed tar source * src_targz - compressed
tar source * src_zip - zip file source</p>

<p style="margin-top: 1em">This may be overridden with the
&quot;package_type&quot; command line option.</p>

<p style="margin-top: 1em">PACKAGEVERSION <br>
The version of the package (not the underlying project).
This is currently only used by the rpm packager and should
reflect changes in the packaging, not the underlying <br>
project code itself.</p>

<p style="margin-top: 1em">PCH <br>
The Microsoft Visual C++ precompiled header that will be
used when compiling object files. This variable is ignored
by tools other than Microsoft Visual C++. When this <br>
variable is defined SCons will add options to the compiler
command line to cause it to use the precompiled header, and
will also set up the dependencies for the PCH file. <br>
Example:</p>

<p style="margin-top: 1em">env[&rsquo;PCH&rsquo;] =
&rsquo;StdAfx.pch&rsquo;</p>

<p style="margin-top: 1em">PCHCOM <br>
The command line used by the PCH builder to generated a
precompiled header.</p>

<p style="margin-top: 1em">PCHCOMSTR <br>
The string displayed when generating a precompiled header.
If this is not set, then $PCHCOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">PCHPDBFLAGS <br>
A construction variable that, when expanded, adds the /yD
flag to the command line only if the $PDB construction
variable is set.</p>

<p style="margin-top: 1em">PCHSTOP <br>
This variable specifies how much of a source file is
precompiled. This variable is ignored by tools other than
Microsoft Visual C++, or when the PCH variable is not being
<br>
used. When this variable is define it must be a string that
is the name of the header that is included at the end of the
precompiled portion of the source files, or the empty <br>
string if the &quot;#pragma hrdstop&quot; construct is being
used:</p>

<p style="margin-top: 1em">env[&rsquo;PCHSTOP&rsquo;] =
&rsquo;StdAfx.h&rsquo;</p>

<p style="margin-top: 1em">PDB <br>
The Microsoft Visual C++ PDB file that will store debugging
information for object files, shared libraries, and
programs. This variable is ignored by tools other than <br>
Microsoft Visual C++. When this variable is defined SCons
will add options to the compiler and linker command line to
cause them to generate external debugging information, <br>
and will also set up the dependencies for the PDB file.
Example:</p>

<p style="margin-top: 1em">env[&rsquo;PDB&rsquo;] =
&rsquo;hello.pdb&rsquo;</p>

<p style="margin-top: 1em">The Visual C++ compiler switch
that SCons uses by default to generate PDB information is
/Z7. This works correctly with parallel (-j) builds because
it embeds the debug <br>
information in the intermediate object files, as opposed to
sharing a single PDB file between multiple object files.
This is also the only way to get debug information <br>
embedded into a static library. Using the /Zi instead may
yield improved link-time performance, although parallel
builds will no longer work. You can generate PDB files with
<br>
the /Zi switch by overriding the default $CCPDBFLAGS
variable; see the entry for that variable for specific
examples.</p>

<p style="margin-top: 1em">PDFCOM <br>
A deprecated synonym for $DVIPDFCOM.</p>

<p style="margin-top: 1em">PDFLATEX <br>
The pdflatex utility.</p>

<p style="margin-top: 1em">PDFLATEXCOM <br>
The command line used to call the pdflatex utility.</p>

<p style="margin-top: 1em">PDFLATEXCOMSTR <br>
The string displayed when calling the pdflatex utility. If
this is not set, then $PDFLATEXCOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">env =
Environment(PDFLATEX;COMSTR = &quot;Building $TARGET from
LaTeX input $SOURCES&quot;)</p>

<p style="margin-top: 1em">PDFLATEXFLAGS <br>
General options passed to the pdflatex utility.</p>

<p style="margin-top: 1em">PDFPREFIX <br>
The prefix used for PDF file names.</p>

<p style="margin-top: 1em">PDFSUFFIX <br>
The suffix used for PDF file names.</p>

<p style="margin-top: 1em">PDFTEX <br>
The pdftex utility.</p>

<p style="margin-top: 1em">PDFTEXCOM <br>
The command line used to call the pdftex utility.</p>

<p style="margin-top: 1em">PDFTEXCOMSTR <br>
The string displayed when calling the pdftex utility. If
this is not set, then $PDFTEXCOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">env = Environment(PDFTEXCOMSTR =
&quot;Building $TARGET from TeX input $SOURCES&quot;)</p>

<p style="margin-top: 1em">PDFTEXFLAGS <br>
General options passed to the pdftex utility.</p>

<p style="margin-top: 1em">PKGCHK <br>
On Solaris systems, the package-checking program that will
be used (along with $PKGINFO) to look for installed versions
of the Sun PRO C++ compiler. The default is <br>
/usr/sbin/pgkchk.</p>

<p style="margin-top: 1em">PKGINFO <br>
On Solaris systems, the package information program that
will be used (along with $PKGCHK) to look for installed
versions of the Sun PRO C++ compiler. The default is
pkginfo.</p>

<p style="margin-top: 1em">PLATFORM <br>
The name of the platform used to create the Environment. If
no platform is specified when the Environment is created,
scons autodetects the platform.</p>

<p style="margin-top: 1em">env = Environment(tools = [])
<br>
if env[&rsquo;PLATFORM&rsquo;] == &rsquo;cygwin&rsquo;: <br>
Tool(&rsquo;mingw&rsquo;)(env) <br>
else: <br>
Tool(&rsquo;msvc&rsquo;)(env)</p>

<p style="margin-top: 1em">POAUTOINIT <br>
The $POAUTOINIT variable, if set to True (on non-zero
numeric value), let the msginit tool to automatically
initialize missing PO files with msginit(1). This applies to
both, <br>
POInit and POUpdate builders (and others that use any of
them).</p>

<p style="margin-top: 1em">POCREATE_ALIAS <br>
Common alias for all PO files created with POInit builder
(default: &rsquo;po-create&rsquo;). See msginit tool and
POInit builder.</p>

<p style="margin-top: 1em">POSUFFIX <br>
Suffix used for PO files (default: &rsquo;.po&rsquo;) See
msginit tool and POInit builder.</p>

<p style="margin-top: 1em">POTDOMAIN <br>
The $POTDOMAIN defines default domain, used to generate POT
filename as $POTDOMAIN.pot when no POT file name is provided
by the user. This applies to POTUpdate, POInit and <br>
POUpdate builders (and builders, that use them, e.g.
Translate). Normally (if $POTDOMAIN is not defined), the
builders use messages.pot as default POT file name.</p>

<p style="margin-top: 1em">POTSUFFIX <br>
Suffix used for PO Template files (default:
&rsquo;.pot&rsquo;). See xgettext tool and POTUpdate
builder.</p>

<p style="margin-top: 1em">POTUPDATE_ALIAS <br>
Name of the common phony target for all PO Templates created
with POUpdate (default: &rsquo;pot-update&rsquo;). See
xgettext tool and POTUpdate builder.</p>

<p style="margin-top: 1em">POUPDATE_ALIAS <br>
Common alias for all PO files being defined with POUpdate
builder (default: &rsquo;po-update&rsquo;). See msgmerge
tool and POUpdate builder.</p>

<p style="margin-top: 1em">PRINT_CMD_LINE_FUNC <br>
A Python function used to print the command lines as they
are executed (assuming command printing is not disabled by
the -q or -s options or their equivalents). The function
<br>
should take four arguments: s, the command being executed (a
string), target, the target being built (file node, list, or
string name(s)), source, the source(s) used (file <br>
node, list, or string name(s)), and env, the environment
being used.</p>

<p style="margin-top: 1em">The function must do the
printing itself. The default implementation, used if this
variable is not set or is None, is:</p>

<p style="margin-top: 1em">def print_cmd_line(s, target,
source, env): <br>
sys.stdout.write(s + &quot;0)</p>

<p style="margin-top: 1em">Here&rsquo;s an example of a
more interesting function:</p>

<p style="margin-top: 1em">def print_cmd_line(s, target,
source, env): <br>
sys.stdout.write(&quot;Building %s -&gt; %s...0 % <br>
(&rsquo; and &rsquo;.join([str(x) for x in source]), <br>
&rsquo; and &rsquo;.join([str(x) for x in target]))) <br>
env=Environment(PRINT_CMD_LINE_FUNC=print_cmd_line) <br>
env.Program(&rsquo;foo&rsquo;, &rsquo;foo.c&rsquo;)</p>

<p style="margin-top: 1em">This just prints &quot;Building
targetname from sourcename...&quot; instead of the actual
commands. Such a function could also log the actual commands
to a log file, for example.</p>

<p style="margin-top: 1em">PROGEMITTER <br>
TODO</p>

<p style="margin-top: 1em">PROGPREFIX <br>
The prefix used for executable file names.</p>

<p style="margin-top: 1em">PROGSUFFIX <br>
The suffix used for executable file names.</p>

<p style="margin-top: 1em">PSCOM <br>
The command line used to convert TeX DVI files into a
PostScript file.</p>

<p style="margin-top: 1em">PSCOMSTR <br>
The string displayed when a TeX DVI file is converted into a
PostScript file. If this is not set, then $PSCOM (the
command line) is displayed.</p>

<p style="margin-top: 1em">PSPREFIX <br>
The prefix used for PostScript file names.</p>

<p style="margin-top: 1em">PSSUFFIX <br>
The prefix used for PostScript file names.</p>

<p style="margin-top: 1em">QT_AUTOSCAN <br>
Turn off scanning for mocable files. Use the Moc Builder to
explicitly specify files to run moc on.</p>

<p style="margin-top: 1em">QT_BINPATH <br>
The path where the qt binaries are installed. The default
value is &rsquo;$QTDIR/bin&rsquo;.</p>

<p style="margin-top: 1em">QT_CPPPATH <br>
The path where the qt header files are installed. The
default value is &rsquo;$QTDIR/include&rsquo;. Note: If you
set this variable to None, the tool won&rsquo;t change the
$CPPPATH <br>
construction variable.</p>

<p style="margin-top: 1em">QT_DEBUG <br>
Prints lots of debugging information while scanning for moc
files.</p>

<p style="margin-top: 1em">QT_LIB <br>
Default value is &rsquo;qt&rsquo;. You may want to set this
to &rsquo;qt-mt&rsquo;. Note: If you set this variable to
None, the tool won&rsquo;t change the $LIBS variable.</p>

<p style="margin-top: 1em">QT_LIBPATH <br>
The path where the qt libraries are installed. The default
value is &rsquo;$QTDIR/lib&rsquo;. Note: If you set this
variable to None, the tool won&rsquo;t change the $LIBPATH
construction <br>
variable.</p>

<p style="margin-top: 1em">QT_MOC <br>
Default value is &rsquo;$QT_BINPATH/moc&rsquo;.</p>

<p style="margin-top: 1em">QT_MOCCXXPREFIX <br>
Default value is &rsquo;&rsquo;. Prefix for moc output
files, when source is a cxx file.</p>

<p style="margin-top: 1em">QT_MOCCXXSUFFIX <br>
Default value is &rsquo;.moc&rsquo;. Suffix for moc output
files, when source is a cxx file.</p>

<p style="margin-top: 1em">QT_MOCFROMCXXCOM <br>
Command to generate a moc file from a cpp file.</p>

<p style="margin-top: 1em">QT_MOCFROMCXXCOMSTR <br>
The string displayed when generating a moc file from a cpp
file. If this is not set, then $QT_MOCFROMCXXCOM (the
command line) is displayed.</p>

<p style="margin-top: 1em">QT_MOCFROMCXXFLAGS <br>
Default value is &rsquo;-i&rsquo;. These flags are passed to
moc, when moccing a C++ file.</p>

<p style="margin-top: 1em">QT_MOCFROMHCOM <br>
Command to generate a moc file from a header.</p>

<p style="margin-top: 1em">QT_MOCFROMHCOMSTR <br>
The string displayed when generating a moc file from a cpp
file. If this is not set, then $QT_MOCFROMHCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">QT_MOCFROMHFLAGS <br>
Default value is &rsquo;&rsquo;. These flags are passed to
moc, when moccing a header file.</p>

<p style="margin-top: 1em">QT_MOCHPREFIX <br>
Default value is &rsquo;moc_&rsquo;. Prefix for moc output
files, when source is a header.</p>

<p style="margin-top: 1em">QT_MOCHSUFFIX <br>
Default value is &rsquo;$CXXFILESUFFIX&rsquo;. Suffix for
moc output files, when source is a header.</p>

<p style="margin-top: 1em">QT_UIC <br>
Default value is &rsquo;$QT_BINPATH/uic&rsquo;.</p>

<p style="margin-top: 1em">QT_UICCOM <br>
Command to generate header files from .ui files.</p>

<p style="margin-top: 1em">QT_UICCOMSTR <br>
The string displayed when generating header files from .ui
files. If this is not set, then $QT_UICCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">QT_UICDECLFLAGS <br>
Default value is &rsquo;&rsquo;. These flags are passed to
uic, when creating a a h file from a .ui file.</p>

<p style="margin-top: 1em">QT_UICDECLPREFIX <br>
Default value is &rsquo;&rsquo;. Prefix for uic generated
header files.</p>

<p style="margin-top: 1em">QT_UICDECLSUFFIX <br>
Default value is &rsquo;.h&rsquo;. Suffix for uic generated
header files.</p>

<p style="margin-top: 1em">QT_UICIMPLFLAGS <br>
Default value is &rsquo;&rsquo;. These flags are passed to
uic, when creating a cxx file from a .ui file.</p>

<p style="margin-top: 1em">QT_UICIMPLPREFIX <br>
Default value is &rsquo;uic_&rsquo;. Prefix for uic
generated implementation files.</p>

<p style="margin-top: 1em">QT_UICIMPLSUFFIX <br>
Default value is &rsquo;$CXXFILESUFFIX&rsquo;. Suffix for
uic generated implementation files.</p>

<p style="margin-top: 1em">QT_UISUFFIX <br>
Default value is &rsquo;.ui&rsquo;. Suffix of designer input
files.</p>

<p style="margin-top: 1em">QTDIR <br>
The qt tool tries to take this from os.environ. It also
initializes all QT_* construction variables listed below.
(Note that all paths are constructed with python&rsquo;s
<br>
os.path.join() method, but are listed here with the
&rsquo;/&rsquo; separator for easier reading.) In addition,
the construction environment variables $CPPPATH, $LIBPATH
and $LIBS may be <br>
modified and the variables $PROGEMITTER, $SHLIBEMITTER and
$LIBEMITTER are modified. Because the build-performance is
affected when using this tool, you have to explicitly <br>
specify it at Environment creation:</p>


<p style="margin-top: 1em">Environment(tools=[&rsquo;default&rsquo;,&rsquo;qt&rsquo;])</p>

<p style="margin-top: 1em">The qt tool supports the
following operations:</p>

<p style="margin-top: 1em">Automatic moc file generation
from header files. You do not have to specify moc files
explicitly, the tool does it for you. However, there are a
few preconditions to do so: <br>
Your header file must have the same filebase as your
implementation file and must stay in the same directory. It
must have one of the suffixes .h, .hpp, .H, .hxx, .hh. You
<br>
can turn off automatic moc file generation by setting
QT_AUTOSCAN to 0. See also the corresponding Moc() builder
method.</p>

<p style="margin-top: 1em">Automatic moc file generation
from cxx files. As stated in the qt documentation, include
the moc file at the end of the cxx file. Note that you have
to include the file, <br>
which is generated by the transformation
${QT_MOCCXXPREFIX}&lt;basename&gt;${QT_MOCCXXSUFFIX}, by
default &lt;basename&gt;.moc. A warning is generated after
building the moc file, if you <br>
do not include the correct file. If you are using
VariantDir, you may need to specify duplicate=1. You can
turn off automatic moc file generation by setting
QT_AUTOSCAN to 0. <br>
See also the corresponding Moc builder method.</p>

<p style="margin-top: 1em">Automatic handling of .ui files.
The implementation files generated from .ui files are
handled much the same as yacc or lex files. Each .ui file
given as a source of <br>
Program, Library or SharedLibrary will generate three files,
the declaration file, the implementation file and a moc
file. Because there are also generated headers, you may <br>
need to specify duplicate=1 in calls to VariantDir. See also
the corresponding Uic builder method.</p>

<p style="margin-top: 1em">RANLIB <br>
The archive indexer.</p>

<p style="margin-top: 1em">RANLIBCOM <br>
The command line used to index a static library archive.</p>

<p style="margin-top: 1em">RANLIBCOMSTR <br>
The string displayed when a static library archive is
indexed. If this is not set, then $RANLIBCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(RANLIBCOMSTR =
&quot;Indexing $TARGET&quot;)</p>

<p style="margin-top: 1em">RANLIBFLAGS <br>
General options passed to the archive indexer.</p>

<p style="margin-top: 1em">RC <br>
The resource compiler used to build a Microsoft Visual C++
resource file.</p>

<p style="margin-top: 1em">RCCOM <br>
The command line used to build a Microsoft Visual C++
resource file.</p>

<p style="margin-top: 1em">RCCOMSTR <br>
The string displayed when invoking the resource compiler to
build a Microsoft Visual C++ resource file. If this is not
set, then $RCCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">RCFLAGS <br>
The flags passed to the resource compiler by the RES
builder.</p>

<p style="margin-top: 1em">RCINCFLAGS <br>
An automatically-generated construction variable containing
the command-line options for specifying directories to be
searched by the resource compiler. The value of <br>
$RCINCFLAGS is created by appending $RCINCPREFIX and
$RCINCSUFFIX to the beginning and end of each directory in
$CPPPATH.</p>

<p style="margin-top: 1em">RCINCPREFIX <br>
The prefix (flag) used to specify an include directory on
the resource compiler command line. This will be appended to
the beginning of each directory in the $CPPPATH <br>
construction variable when the $RCINCFLAGS variable is
expanded.</p>

<p style="margin-top: 1em">RCINCSUFFIX <br>
The suffix used to specify an include directory on the
resource compiler command line. This will be appended to the
end of each directory in the $CPPPATH construction <br>
variable when the $RCINCFLAGS variable is expanded.</p>

<p style="margin-top: 1em">RCS <br>
The RCS executable. Note that this variable is not actually
used for the command to fetch source files from RCS; see the
$RCS_CO construction variable, below.</p>

<p style="margin-top: 1em">RCS_CO <br>
The RCS &quot;checkout&quot; executable, used to fetch
source files from RCS.</p>

<p style="margin-top: 1em">RCS_COCOM <br>
The command line used to fetch (checkout) source files from
RCS.</p>

<p style="margin-top: 1em">RCS_COCOMSTR <br>
The string displayed when fetching a source file from RCS.
If this is not set, then $RCS_COCOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">RCS_COFLAGS <br>
Options that are passed to the $RCS_CO command.</p>

<p style="margin-top: 1em">RDirs <br>
A function that converts a string into a list of Dir
instances by searching the repositories.</p>

<p style="margin-top: 1em">REGSVR <br>
The program used on Windows systems to register a
newly-built DLL library whenever the SharedLibrary builder
is passed a keyword argument of register=1.</p>

<p style="margin-top: 1em">REGSVRCOM <br>
The command line used on Windows systems to register a
newly-built DLL library whenever the SharedLibrary builder
is passed a keyword argument of register=1.</p>

<p style="margin-top: 1em">REGSVRCOMSTR <br>
The string displayed when registering a newly-built DLL
file. If this is not set, then $REGSVRCOM (the command line)
is displayed.</p>

<p style="margin-top: 1em">REGSVRFLAGS <br>
Flags passed to the DLL registration program on Windows
systems when a newly-built DLL library is registered. By
default, this includes the /s that prevents dialog boxes
from <br>
popping up and requiring user attention.</p>

<p style="margin-top: 1em">RMIC <br>
The Java RMI stub compiler.</p>

<p style="margin-top: 1em">RMICCOM <br>
The command line used to compile stub and skeleton class
files from Java classes that contain RMI implementations.
Any options specified in the $RMICFLAGS construction <br>
variable are included on this command line.</p>

<p style="margin-top: 1em">RMICCOMSTR <br>
The string displayed when compiling stub and skeleton class
files from Java classes that contain RMI implementations. If
this is not set, then $RMICCOM (the command line) is <br>
displayed.</p>

<p style="margin-top: 1em">env = Environment(RMICCOMSTR =
&quot;Generating stub/skeleton class files $TARGETS from
$SOURCES&quot;)</p>

<p style="margin-top: 1em">RMICFLAGS <br>
General options passed to the Java RMI stub compiler.</p>

<p style="margin-top: 1em">_RPATH <br>
An automatically-generated construction variable containing
the rpath flags to be used when linking a program with
shared libraries. The value of $_RPATH is created by <br>
appending $RPATHPREFIX and $RPATHSUFFIX to the beginning and
end of each directory in $RPATH.</p>

<p style="margin-top: 1em">RPATH <br>
A list of paths to search for shared libraries when running
programs. Currently only used in the GNU (gnulink), IRIX
(sgilink) and Sun (sunlink) linkers. Ignored on platforms
<br>
and toolchains that don&rsquo;t support it. Note that the
paths added to RPATH are not transformed by scons in any
way: if you want an absolute path, you must make it absolute
<br>
yourself.</p>

<p style="margin-top: 1em">RPATHPREFIX <br>
The prefix used to specify a directory to be searched for
shared libraries when running programs. This will be
appended to the beginning of each directory in the $RPATH
<br>
construction variable when the $_RPATH variable is
automatically generated.</p>

<p style="margin-top: 1em">RPATHSUFFIX <br>
The suffix used to specify a directory to be searched for
shared libraries when running programs. This will be
appended to the end of each directory in the $RPATH <br>
construction variable when the $_RPATH variable is
automatically generated.</p>

<p style="margin-top: 1em">RPCGEN <br>
The RPC protocol compiler.</p>

<p style="margin-top: 1em">RPCGENCLIENTFLAGS <br>
Options passed to the RPC protocol compiler when generating
client side stubs. These are in addition to any flags
specified in the $RPCGENFLAGS construction variable.</p>

<p style="margin-top: 1em">RPCGENFLAGS <br>
General options passed to the RPC protocol compiler.</p>

<p style="margin-top: 1em">RPCGENHEADERFLAGS <br>
Options passed to the RPC protocol compiler when generating
a header file. These are in addition to any flags specified
in the $RPCGENFLAGS construction variable.</p>

<p style="margin-top: 1em">RPCGENSERVICEFLAGS <br>
Options passed to the RPC protocol compiler when generating
server side stubs. These are in addition to any flags
specified in the $RPCGENFLAGS construction variable.</p>

<p style="margin-top: 1em">RPCGENXDRFLAGS <br>
Options passed to the RPC protocol compiler when generating
XDR routines. These are in addition to any flags specified
in the $RPCGENFLAGS construction variable.</p>

<p style="margin-top: 1em">SCANNERS <br>
A list of the available implicit dependency scanners. New
file scanners may be added by appending to this list,
although the more flexible approach is to associate scanners
<br>
with a specific Builder. See the sections &quot;Builder
Objects&quot; and &quot;Scanner Objects,&quot; below, for
more information.</p>

<p style="margin-top: 1em">SCCS <br>
The SCCS executable.</p>

<p style="margin-top: 1em">SCCSCOM <br>
The command line used to fetch source files from SCCS.</p>

<p style="margin-top: 1em">SCCSCOMSTR <br>
The string displayed when fetching a source file from a CVS
repository. If this is not set, then $SCCSCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">SCCSFLAGS <br>
General options that are passed to SCCS.</p>

<p style="margin-top: 1em">SCCSGETFLAGS <br>
Options that are passed specifically to the SCCS
&quot;get&quot; subcommand. This can be set, for example, to
-e to check out editable files from SCCS.</p>

<p style="margin-top: 1em">SCONS_HOME <br>
The (optional) path to the SCons library directory,
initialized from the external environment. If set, this is
used to construct a shorter and more efficient search path
in <br>
the $MSVSSCONS command line executed from Microsoft Visual
Studio project files.</p>

<p style="margin-top: 1em">SHCC <br>
The C compiler used for generating shared-library
objects.</p>

<p style="margin-top: 1em">SHCCCOM <br>
The command line used to compile a C source file to a
shared-library object file. Any options specified in the
$SHCFLAGS, $SHCCFLAGS and $CPPFLAGS construction variables
are <br>
included on this command line.</p>

<p style="margin-top: 1em">SHCCCOMSTR <br>
The string displayed when a C source file is compiled to a
shared object file. If this is not set, then $SHCCCOM (the
command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(SHCCCOMSTR =
&quot;Compiling shared object $TARGET&quot;)</p>

<p style="margin-top: 1em">SHCCFLAGS <br>
Options that are passed to the C and C++ compilers to
generate shared-library objects.</p>

<p style="margin-top: 1em">SHCFLAGS <br>
Options that are passed to the C compiler (only; not C++) to
generate shared-library objects.</p>

<p style="margin-top: 1em">SHCXX <br>
The C++ compiler used for generating shared-library
objects.</p>

<p style="margin-top: 1em">SHCXXCOM <br>
The command line used to compile a C++ source file to a
shared-library object file. Any options specified in the
$SHCXXFLAGS and $CPPFLAGS construction variables are
included <br>
on this command line.</p>

<p style="margin-top: 1em">SHCXXCOMSTR <br>
The string displayed when a C++ source file is compiled to a
shared object file. If this is not set, then $SHCXXCOM (the
command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(SHCXXCOMSTR =
&quot;Compiling shared object $TARGET&quot;)</p>

<p style="margin-top: 1em">SHCXXFLAGS <br>
Options that are passed to the C++ compiler to generate
shared-library objects.</p>

<p style="margin-top: 1em">SHDC <br>
SHDC.</p>

<p style="margin-top: 1em">SHDCOM <br>
SHDCOM.</p>

<p style="margin-top: 1em">SHDLINK <br>
SHDLINK.</p>

<p style="margin-top: 1em">SHDLINKCOM <br>
SHDLINKCOM.</p>

<p style="margin-top: 1em">SHDLINKFLAGS <br>
SHDLINKFLAGS.</p>

<p style="margin-top: 1em">SHELL <br>
A string naming the shell program that will be passed to the
$SPAWN function. See the $SPAWN construction variable for
more information.</p>

<p style="margin-top: 1em">SHF03 <br>
The Fortran 03 compiler used for generating shared-library
objects. You should normally set the $SHFORTRAN variable,
which specifies the default Fortran compiler for all <br>
Fortran versions. You only need to set $SHF03 if you need to
use a specific compiler or compiler version for Fortran 03
files.</p>

<p style="margin-top: 1em">SHF03COM <br>
The command line used to compile a Fortran 03 source file to
a shared-library object file. You only need to set $SHF03COM
if you need to use a specific command line for <br>
Fortran 03 files. You should normally set the $SHFORTRANCOM
variable, which specifies the default command line for all
Fortran versions.</p>

<p style="margin-top: 1em">SHF03COMSTR <br>
The string displayed when a Fortran 03 source file is
compiled to a shared-library object file. If this is not
set, then $SHF03COM or $SHFORTRANCOM (the command line) is
<br>
displayed.</p>

<p style="margin-top: 1em">SHF03FLAGS <br>
Options that are passed to the Fortran 03 compiler to
generated shared-library objects. You only need to set
$SHF03FLAGS if you need to define specific user options for
<br>
Fortran 03 files. You should normally set the
$SHFORTRANFLAGS variable, which specifies the user-specified
options passed to the default Fortran compiler for all
Fortran <br>
versions.</p>

<p style="margin-top: 1em">SHF03PPCOM <br>
The command line used to compile a Fortran 03 source file to
a shared-library object file after first running the file
through the C preprocessor. Any options specified in <br>
the $SHF03FLAGS and $CPPFLAGS construction variables are
included on this command line. You only need to set
$SHF03PPCOM if you need to use a specific C-preprocessor
command <br>
line for Fortran 03 files. You should normally set the
$SHFORTRANPPCOM variable, which specifies the default
C-preprocessor command line for all Fortran versions.</p>

<p style="margin-top: 1em">SHF03PPCOMSTR <br>
The string displayed when a Fortran 03 source file is
compiled to a shared-library object file after first running
the file through the C preprocessor. If this is not set,
<br>
then $SHF03PPCOM or $SHFORTRANPPCOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">SHF08 <br>
The Fortran 08 compiler used for generating shared-library
objects. You should normally set the $SHFORTRAN variable,
which specifies the default Fortran compiler for all <br>
Fortran versions. You only need to set $SHF08 if you need to
use a specific compiler or compiler version for Fortran 08
files.</p>

<p style="margin-top: 1em">SHF08COM <br>
The command line used to compile a Fortran 08 source file to
a shared-library object file. You only need to set $SHF08COM
if you need to use a specific command line for <br>
Fortran 08 files. You should normally set the $SHFORTRANCOM
variable, which specifies the default command line for all
Fortran versions.</p>

<p style="margin-top: 1em">SHF08COMSTR <br>
The string displayed when a Fortran 08 source file is
compiled to a shared-library object file. If this is not
set, then $SHF08COM or $SHFORTRANCOM (the command line) is
<br>
displayed.</p>

<p style="margin-top: 1em">SHF08FLAGS <br>
Options that are passed to the Fortran 08 compiler to
generated shared-library objects. You only need to set
$SHF08FLAGS if you need to define specific user options for
<br>
Fortran 08 files. You should normally set the
$SHFORTRANFLAGS variable, which specifies the user-specified
options passed to the default Fortran compiler for all
Fortran <br>
versions.</p>

<p style="margin-top: 1em">SHF08PPCOM <br>
The command line used to compile a Fortran 08 source file to
a shared-library object file after first running the file
through the C preprocessor. Any options specified in <br>
the $SHF08FLAGS and $CPPFLAGS construction variables are
included on this command line. You only need to set
$SHF08PPCOM if you need to use a specific C-preprocessor
command <br>
line for Fortran 08 files. You should normally set the
$SHFORTRANPPCOM variable, which specifies the default
C-preprocessor command line for all Fortran versions.</p>

<p style="margin-top: 1em">SHF08PPCOMSTR <br>
The string displayed when a Fortran 08 source file is
compiled to a shared-library object file after first running
the file through the C preprocessor. If this is not set,
<br>
then $SHF08PPCOM or $SHFORTRANPPCOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">SHF77 <br>
The Fortran 77 compiler used for generating shared-library
objects. You should normally set the $SHFORTRAN variable,
which specifies the default Fortran compiler for all <br>
Fortran versions. You only need to set $SHF77 if you need to
use a specific compiler or compiler version for Fortran 77
files.</p>

<p style="margin-top: 1em">SHF77COM <br>
The command line used to compile a Fortran 77 source file to
a shared-library object file. You only need to set $SHF77COM
if you need to use a specific command line for <br>
Fortran 77 files. You should normally set the $SHFORTRANCOM
variable, which specifies the default command line for all
Fortran versions.</p>

<p style="margin-top: 1em">SHF77COMSTR <br>
The string displayed when a Fortran 77 source file is
compiled to a shared-library object file. If this is not
set, then $SHF77COM or $SHFORTRANCOM (the command line) is
<br>
displayed.</p>

<p style="margin-top: 1em">SHF77FLAGS <br>
Options that are passed to the Fortran 77 compiler to
generated shared-library objects. You only need to set
$SHF77FLAGS if you need to define specific user options for
<br>
Fortran 77 files. You should normally set the
$SHFORTRANFLAGS variable, which specifies the user-specified
options passed to the default Fortran compiler for all
Fortran <br>
versions.</p>

<p style="margin-top: 1em">SHF77PPCOM <br>
The command line used to compile a Fortran 77 source file to
a shared-library object file after first running the file
through the C preprocessor. Any options specified in <br>
the $SHF77FLAGS and $CPPFLAGS construction variables are
included on this command line. You only need to set
$SHF77PPCOM if you need to use a specific C-preprocessor
command <br>
line for Fortran 77 files. You should normally set the
$SHFORTRANPPCOM variable, which specifies the default
C-preprocessor command line for all Fortran versions.</p>

<p style="margin-top: 1em">SHF77PPCOMSTR <br>
The string displayed when a Fortran 77 source file is
compiled to a shared-library object file after first running
the file through the C preprocessor. If this is not set,
<br>
then $SHF77PPCOM or $SHFORTRANPPCOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">SHF90 <br>
The Fortran 90 compiler used for generating shared-library
objects. You should normally set the $SHFORTRAN variable,
which specifies the default Fortran compiler for all <br>
Fortran versions. You only need to set $SHF90 if you need to
use a specific compiler or compiler version for Fortran 90
files.</p>

<p style="margin-top: 1em">SHF90COM <br>
The command line used to compile a Fortran 90 source file to
a shared-library object file. You only need to set $SHF90COM
if you need to use a specific command line for <br>
Fortran 90 files. You should normally set the $SHFORTRANCOM
variable, which specifies the default command line for all
Fortran versions.</p>

<p style="margin-top: 1em">SHF90COMSTR <br>
The string displayed when a Fortran 90 source file is
compiled to a shared-library object file. If this is not
set, then $SHF90COM or $SHFORTRANCOM (the command line) is
<br>
displayed.</p>

<p style="margin-top: 1em">SHF90FLAGS <br>
Options that are passed to the Fortran 90 compiler to
generated shared-library objects. You only need to set
$SHF90FLAGS if you need to define specific user options for
<br>
Fortran 90 files. You should normally set the
$SHFORTRANFLAGS variable, which specifies the user-specified
options passed to the default Fortran compiler for all
Fortran <br>
versions.</p>

<p style="margin-top: 1em">SHF90PPCOM <br>
The command line used to compile a Fortran 90 source file to
a shared-library object file after first running the file
through the C preprocessor. Any options specified in <br>
the $SHF90FLAGS and $CPPFLAGS construction variables are
included on this command line. You only need to set
$SHF90PPCOM if you need to use a specific C-preprocessor
command <br>
line for Fortran 90 files. You should normally set the
$SHFORTRANPPCOM variable, which specifies the default
C-preprocessor command line for all Fortran versions.</p>

<p style="margin-top: 1em">SHF90PPCOMSTR <br>
The string displayed when a Fortran 90 source file is
compiled to a shared-library object file after first running
the file through the C preprocessor. If this is not set,
<br>
then $SHF90PPCOM or $SHFORTRANPPCOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">SHF95 <br>
The Fortran 95 compiler used for generating shared-library
objects. You should normally set the $SHFORTRAN variable,
which specifies the default Fortran compiler for all <br>
Fortran versions. You only need to set $SHF95 if you need to
use a specific compiler or compiler version for Fortran 95
files.</p>

<p style="margin-top: 1em">SHF95COM <br>
The command line used to compile a Fortran 95 source file to
a shared-library object file. You only need to set $SHF95COM
if you need to use a specific command line for <br>
Fortran 95 files. You should normally set the $SHFORTRANCOM
variable, which specifies the default command line for all
Fortran versions.</p>

<p style="margin-top: 1em">SHF95COMSTR <br>
The string displayed when a Fortran 95 source file is
compiled to a shared-library object file. If this is not
set, then $SHF95COM or $SHFORTRANCOM (the command line) is
<br>
displayed.</p>

<p style="margin-top: 1em">SHF95FLAGS <br>
Options that are passed to the Fortran 95 compiler to
generated shared-library objects. You only need to set
$SHF95FLAGS if you need to define specific user options for
<br>
Fortran 95 files. You should normally set the
$SHFORTRANFLAGS variable, which specifies the user-specified
options passed to the default Fortran compiler for all
Fortran <br>
versions.</p>

<p style="margin-top: 1em">SHF95PPCOM <br>
The command line used to compile a Fortran 95 source file to
a shared-library object file after first running the file
through the C preprocessor. Any options specified in <br>
the $SHF95FLAGS and $CPPFLAGS construction variables are
included on this command line. You only need to set
$SHF95PPCOM if you need to use a specific C-preprocessor
command <br>
line for Fortran 95 files. You should normally set the
$SHFORTRANPPCOM variable, which specifies the default
C-preprocessor command line for all Fortran versions.</p>

<p style="margin-top: 1em">SHF95PPCOMSTR <br>
The string displayed when a Fortran 95 source file is
compiled to a shared-library object file after first running
the file through the C preprocessor. If this is not set,
<br>
then $SHF95PPCOM or $SHFORTRANPPCOM (the command line) is
displayed.</p>

<p style="margin-top: 1em">SHFORTRAN <br>
The default Fortran compiler used for generating
shared-library objects.</p>

<p style="margin-top: 1em">SHFORTRANCOM <br>
The command line used to compile a Fortran source file to a
shared-library object file.</p>

<p style="margin-top: 1em">SHFORTRANCOMSTR <br>
The string displayed when a Fortran source file is compiled
to a shared-library object file. If this is not set, then
$SHFORTRANCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">SHFORTRANFLAGS <br>
Options that are passed to the Fortran compiler to generate
shared-library objects.</p>

<p style="margin-top: 1em">SHFORTRANPPCOM <br>
The command line used to compile a Fortran source file to a
shared-library object file after first running the file
through the C preprocessor. Any options specified in the
<br>
$SHFORTRANFLAGS and $CPPFLAGS construction variables are
included on this command line.</p>

<p style="margin-top: 1em">SHFORTRANPPCOMSTR <br>
The string displayed when a Fortran source file is compiled
to a shared-library object file after first running the file
through the C preprocessor. If this is not set, then <br>
$SHFORTRANPPCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">SHLIBEMITTER <br>
TODO</p>

<p style="margin-top: 1em">SHLIBNOVERSIONSYMLINKS <br>
Instructs the SharedLibrary builder to not create symlinks
for versioned shared libraries.</p>

<p style="margin-top: 1em">SHLIBPREFIX <br>
The prefix used for shared library file names.</p>

<p style="margin-top: 1em">_SHLIBSONAME <br>
A macro that automatically generates shared library&rsquo;s
SONAME based on $TARGET, $SHLIBVERSION and $SHLIBSUFFIX.
Used by SharedLibrary builder when the linker tool supports
<br>
SONAME (e.g. gnulink).</p>

<p style="margin-top: 1em">SHLIBSUFFIX <br>
The suffix used for shared library file names.</p>

<p style="margin-top: 1em">SHLIBVERSION <br>
When this construction variable is defined, a versioned
shared library is created by SharedLibrary builder. This
activates the $_SHLIBVERSIONFLAGS and thus modifies the <br>
$SHLINKCOM as required, adds the version number to the
library name, and creates the symlinks that are needed.
$SHLIBVERSION versions should exist as alpha-numeric, <br>
decimal-delimited values as defined by the regular
expression &quot;144</p>

<p style="margin-top: 1em">_SHLIBVERSIONFLAGS <br>
This macro automatically introduces extra flags to
$SHLINKCOM when building versioned SharedLibrary (that is
when $SHLIBVERSION is set). _SHLIBVERSIONFLAGS usually adds
<br>
$SHLIBVERSIONFLAGS and some extra dynamically generated
options (such as -Wl,-soname=$_SHLIBSONAME. It is unused by
&quot;plain&quot; (unversioned) shared libraries.</p>

<p style="margin-top: 1em">SHLIBVERSIONFLAGS <br>
Extra flags added to $SHLINKCOM when building versioned
SharedLibrary. These flags are only used when $SHLIBVERSION
is set.</p>

<p style="margin-top: 1em">SHLINK <br>
The linker for programs that use shared libraries.</p>

<p style="margin-top: 1em">SHLINKCOM <br>
The command line used to link programs using shared
libraries.</p>

<p style="margin-top: 1em">SHLINKCOMSTR <br>
The string displayed when programs using shared libraries
are linked. If this is not set, then $SHLINKCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(SHLINKCOMSTR =
&quot;Linking shared $TARGET&quot;)</p>

<p style="margin-top: 1em">SHLINKFLAGS <br>
General user options passed to the linker for programs using
shared libraries. Note that this variable should not contain
-l (or similar) options for linking with the <br>
libraries listed in $LIBS, nor -L (or similar) include
search path options that scons generates automatically from
$LIBPATH. See $_LIBFLAGS above, for the variable that <br>
expands to library-link options, and $_LIBDIRFLAGS above,
for the variable that expands to library search path
options.</p>

<p style="margin-top: 1em">SHOBJPREFIX <br>
The prefix used for shared object file names.</p>

<p style="margin-top: 1em">SHOBJSUFFIX <br>
The suffix used for shared object file names.</p>

<p style="margin-top: 1em">SONAME <br>
Variable used to hard-code SONAME for versioned shared
library/loadable module.</p>


<p style="margin-top: 1em">env.SharedLibrary(&rsquo;test&rsquo;,
&rsquo;test.c&rsquo;, SHLIBVERSION=&rsquo;0.1.2&rsquo;,
SONAME=&rsquo;libtest.so.2&rsquo;)</p>

<p style="margin-top: 1em">The variable is used, for
example, by gnulink linker tool.</p>

<p style="margin-top: 1em">SOURCE <br>
A reserved variable name that may not be set or used in a
construction environment. (See &quot;Variable
Substitution,&quot; below.)</p>

<p style="margin-top: 1em">SOURCE_URL <br>
The URL (web address) of the location from which the project
was retrieved. This is used to fill in the Source: field in
the controlling information for Ipkg and RPM <br>
packages.</p>

<p style="margin-top: 1em">SOURCES <br>
A reserved variable name that may not be set or used in a
construction environment. (See &quot;Variable
Substitution,&quot; below.)</p>

<p style="margin-top: 1em">SPAWN <br>
A command interpreter function that will be called to
execute command line strings. The function must expect the
following arguments:</p>

<p style="margin-top: 1em">def spawn(shell, escape, cmd,
args, env):</p>

<p style="margin-top: 1em">sh is a string naming the shell
program to use. escape is a function that can be called to
escape shell special characters in the command line. cmd is
the path to the <br>
command to be executed. args is the arguments to the
command. env is a dictionary of the environment variables in
which the command should be executed.</p>


<p style="margin-top: 1em">STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME
<br>
When this variable is true, static objects and shared
objects are assumed to be the same; that is, SCons does not
check for linking static objects into a shared library.</p>

<p style="margin-top: 1em">SUBST_DICT <br>
The dictionary used by the Substfile or Textfile builders
for substitution values. It can be anything acceptable to
the dict() constructor, so in addition to a dictionary, <br>
lists of tuples are also acceptable.</p>

<p style="margin-top: 1em">SUBSTFILEPREFIX <br>
The prefix used for Substfile file names, the null string by
default.</p>

<p style="margin-top: 1em">SUBSTFILESUFFIX <br>
The suffix used for Substfile file names, the null string by
default.</p>

<p style="margin-top: 1em">SUMMARY <br>
A short summary of what the project is about. This is used
to fill in the Summary: field in the controlling information
for Ipkg and RPM packages, and as the Description: <br>
field in MSI packages.</p>

<p style="margin-top: 1em">SWIG <br>
The scripting language wrapper and interface generator.</p>

<p style="margin-top: 1em">SWIGCFILESUFFIX <br>
The suffix that will be used for intermediate C source files
generated by the scripting language wrapper and interface
generator. The default value is _wrap$CFILESUFFIX. By <br>
default, this value is used whenever the -c++ option is not
specified as part of the $SWIGFLAGS construction
variable.</p>

<p style="margin-top: 1em">SWIGCOM <br>
The command line used to call the scripting language wrapper
and interface generator.</p>

<p style="margin-top: 1em">SWIGCOMSTR <br>
The string displayed when calling the scripting language
wrapper and interface generator. If this is not set, then
$SWIGCOM (the command line) is displayed.</p>

<p style="margin-top: 1em">SWIGCXXFILESUFFIX <br>
The suffix that will be used for intermediate C++ source
files generated by the scripting language wrapper and
interface generator. The default value is _wrap$CFILESUFFIX.
By <br>
default, this value is used whenever the -c++ option is
specified as part of the $SWIGFLAGS construction
variable.</p>

<p style="margin-top: 1em">SWIGDIRECTORSUFFIX <br>
The suffix that will be used for intermediate C++ header
files generated by the scripting language wrapper and
interface generator. These are only generated for C++ code
when <br>
the SWIG &rsquo;directors&rsquo; feature is turned on. The
default value is _wrap.h.</p>

<p style="margin-top: 1em">SWIGFLAGS <br>
General options passed to the scripting language wrapper and
interface generator. This is where you should set -python,
-perl5, -tcl, or whatever other options you want to <br>
specify to SWIG. If you set the -c++ option in this
variable, scons will, by default, generate a C++
intermediate source file with the extension that is
specified as the <br>
$CXXFILESUFFIX variable.</p>

<p style="margin-top: 1em">_SWIGINCFLAGS <br>
An automatically-generated construction variable containing
the SWIG command-line options for specifying directories to
be searched for included files. The value of <br>
$_SWIGINCFLAGS is created by appending $SWIGINCPREFIX and
$SWIGINCSUFFIX to the beginning and end of each directory in
$SWIGPATH.</p>

<p style="margin-top: 1em">SWIGINCPREFIX <br>
The prefix used to specify an include directory on the SWIG
command line. This will be appended to the beginning of each
directory in the $SWIGPATH construction variable when <br>
the $_SWIGINCFLAGS variable is automatically generated.</p>

<p style="margin-top: 1em">SWIGINCSUFFIX <br>
The suffix used to specify an include directory on the SWIG
command line. This will be appended to the end of each
directory in the $SWIGPATH construction variable when the
<br>
$_SWIGINCFLAGS variable is automatically generated.</p>

<p style="margin-top: 1em">SWIGOUTDIR <br>
Specifies the output directory in which the scripting
language wrapper and interface generator should place
generated language-specific files. This will be used by
SCons to <br>
identify the files that will be generated by the swig call,
and translated into the swig -outdir option on the command
line.</p>

<p style="margin-top: 1em">SWIGPATH <br>
The list of directories that the scripting language wrapper
and interface generate will search for included files. The
SWIG implicit dependency scanner will search these <br>
directories for include files. The default value is an empty
list.</p>

<p style="margin-top: 1em">Don&rsquo;t explicitly put
include directory arguments in SWIGFLAGS; the result will be
non-portable and the directories will not be searched by the
dependency scanner. Note: <br>
directory names in SWIGPATH will be looked-up relative to
the SConscript directory when they are used in a command. To
force scons to look-up a directory relative to the root <br>
of the source tree use #:</p>

<p style="margin-top: 1em">env =
Environment(SWIGPATH=&rsquo;#/include&rsquo;)</p>

<p style="margin-top: 1em">The directory look-up can also
be forced using the Dir() function:</p>

<p style="margin-top: 1em">include =
Dir(&rsquo;include&rsquo;) <br>
env = Environment(SWIGPATH=include)</p>

<p style="margin-top: 1em">The directory list will be added
to command lines through the automatically-generated
$_SWIGINCFLAGS construction variable, which is constructed
by appending the values of <br>
the $SWIGINCPREFIX and $SWIGINCSUFFIX construction variables
to the beginning and end of each directory in $SWIGPATH. Any
command lines you define that need the SWIGPATH <br>
directory list should include $_SWIGINCFLAGS:</p>

<p style="margin-top: 1em">env =
Environment(SWIGCOM=&quot;my_swig -o $TARGET $_SWIGINCFLAGS
$SOURCES&quot;)</p>

<p style="margin-top: 1em">SWIGVERSION <br>
The version number of the SWIG tool.</p>

<p style="margin-top: 1em">TAR <br>
The tar archiver.</p>

<p style="margin-top: 1em">TARCOM <br>
The command line used to call the tar archiver.</p>

<p style="margin-top: 1em">TARCOMSTR <br>
The string displayed when archiving files using the tar
archiver. If this is not set, then $TARCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(TARCOMSTR =
&quot;Archiving $TARGET&quot;)</p>

<p style="margin-top: 1em">TARFLAGS <br>
General options passed to the tar archiver.</p>

<p style="margin-top: 1em">TARGET <br>
A reserved variable name that may not be set or used in a
construction environment. (See &quot;Variable
Substitution,&quot; below.)</p>

<p style="margin-top: 1em">TARGET_ARCH <br>
Sets the target architecture for Visual Studio compiler
(i.e. the arch of the binaries generated by the compiler).
If not set, default to $HOST_ARCH, or, if that is unset, to
<br>
the architecture of the running machine&rsquo;s OS (note
that the python build or architecture has no effect). This
variable must be passed as an argument to the Environment()
<br>
constructor; setting it later has no effect. This is
currently only used on Windows, but in the future it will be
used on other OSes as well.</p>

<p style="margin-top: 1em">Valid values for Windows are
x86, i386 (for 32 bits); amd64, emt64, x86_64 (for 64 bits);
and ia64 (Itanium). For example, if you want to compile
64-bit binaries, you would <br>
set TARGET_ARCH=&rsquo;x86_64&rsquo; in your SCons
environment.</p>

<p style="margin-top: 1em">The name of the target hardware
architecture for the compiled objects created by this
Environment. This defaults to the value of HOST_ARCH, and
the user can override it. <br>
Currently only set for Win32.</p>

<p style="margin-top: 1em">TARGET_OS <br>
The name of the target operating system for the compiled
objects created by this Environment. This defaults to the
value of HOST_OS, and the user can override it. Currently
<br>
only set for Win32.</p>

<p style="margin-top: 1em">TARGETS <br>
A reserved variable name that may not be set or used in a
construction environment. (See &quot;Variable
Substitution,&quot; below.)</p>

<p style="margin-top: 1em">TARSUFFIX <br>
The suffix used for tar file names.</p>

<p style="margin-top: 1em">TEMPFILEPREFIX <br>
The prefix for a temporary file used to execute lines longer
than $MAXLINELENGTH. The default is &rsquo;@&rsquo;. This
may be set for toolchains that use other values, such as
&rsquo;-@&rsquo; for <br>
the diab compiler or &rsquo;-via&rsquo; for ARM
toolchain.</p>

<p style="margin-top: 1em">TEX <br>
The TeX formatter and typesetter.</p>

<p style="margin-top: 1em">TEXCOM <br>
The command line used to call the TeX formatter and
typesetter.</p>

<p style="margin-top: 1em">TEXCOMSTR <br>
The string displayed when calling the TeX formatter and
typesetter. If this is not set, then $TEXCOM (the command
line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(TEXCOMSTR =
&quot;Building $TARGET from TeX input $SOURCES&quot;)</p>

<p style="margin-top: 1em">TEXFLAGS <br>
General options passed to the TeX formatter and
typesetter.</p>

<p style="margin-top: 1em">TEXINPUTS <br>
List of directories that the LaTeX program will search for
include directories. The LaTeX implicit dependency scanner
will search these directories for include and import <br>
files.</p>

<p style="margin-top: 1em">TEXTFILEPREFIX <br>
The prefix used for Textfile file names, the null string by
default.</p>

<p style="margin-top: 1em">TEXTFILESUFFIX <br>
The suffix used for Textfile file names; .txt by
default.</p>

<p style="margin-top: 1em">TOOLS <br>
A list of the names of the Tool specifications that are part
of this construction environment.</p>

<p style="margin-top: 1em">UNCHANGED_SOURCES <br>
A reserved variable name that may not be set or used in a
construction environment. (See &quot;Variable
Substitution,&quot; below.)</p>

<p style="margin-top: 1em">UNCHANGED_TARGETS <br>
A reserved variable name that may not be set or used in a
construction environment. (See &quot;Variable
Substitution,&quot; below.)</p>

<p style="margin-top: 1em">VENDOR <br>
The person or organization who supply the packaged software.
This is used to fill in the Vendor: field in the controlling
information for RPM packages, and the Manufacturer: <br>
field in the controlling information for MSI packages.</p>

<p style="margin-top: 1em">VERSION <br>
The version of the project, specified as a string.</p>

<p style="margin-top: 1em">WIN32_INSERT_DEF <br>
A deprecated synonym for $WINDOWS_INSERT_DEF.</p>

<p style="margin-top: 1em">WIN32DEFPREFIX <br>
A deprecated synonym for $WINDOWSDEFPREFIX.</p>

<p style="margin-top: 1em">WIN32DEFSUFFIX <br>
A deprecated synonym for $WINDOWSDEFSUFFIX.</p>

<p style="margin-top: 1em">WIN32EXPPREFIX <br>
A deprecated synonym for $WINDOWSEXPSUFFIX.</p>

<p style="margin-top: 1em">WIN32EXPSUFFIX <br>
A deprecated synonym for $WINDOWSEXPSUFFIX.</p>

<p style="margin-top: 1em">WINDOWS_EMBED_MANIFEST <br>
Set this variable to True or 1 to embed the
compiler-generated manifest (normally ${TARGET}.manifest)
into all Windows exes and DLLs built with this environment,
as a <br>
resource during their link step. This is done using $MT and
$MTEXECOM and $MTSHLIBCOM.</p>

<p style="margin-top: 1em">WINDOWS_INSERT_DEF <br>
When this is set to true, a library build of a Windows
shared library (.dll file) will also build a corresponding
.def file at the same time, if a .def file is not already
<br>
listed as a build target. The default is 0 (do not build a
.def file).</p>

<p style="margin-top: 1em">WINDOWS_INSERT_MANIFEST <br>
When this is set to true, scons will be aware of the
.manifest files generated by Microsoft Visua C/C++ 8.</p>

<p style="margin-top: 1em">WINDOWSDEFPREFIX <br>
The prefix used for Windows .def file names.</p>

<p style="margin-top: 1em">WINDOWSDEFSUFFIX <br>
The suffix used for Windows .def file names.</p>

<p style="margin-top: 1em">WINDOWSEXPPREFIX <br>
The prefix used for Windows .exp file names.</p>

<p style="margin-top: 1em">WINDOWSEXPSUFFIX <br>
The suffix used for Windows .exp file names.</p>

<p style="margin-top: 1em">WINDOWSPROGMANIFESTPREFIX <br>
The prefix used for executable program .manifest files
generated by Microsoft Visual C/C++.</p>

<p style="margin-top: 1em">WINDOWSPROGMANIFESTSUFFIX <br>
The suffix used for executable program .manifest files
generated by Microsoft Visual C/C++.</p>

<p style="margin-top: 1em">WINDOWSSHLIBMANIFESTPREFIX <br>
The prefix used for shared library .manifest files generated
by Microsoft Visual C/C++.</p>

<p style="margin-top: 1em">WINDOWSSHLIBMANIFESTSUFFIX <br>
The suffix used for shared library .manifest files generated
by Microsoft Visual C/C++.</p>

<p style="margin-top: 1em">X_IPK_DEPENDS <br>
This is used to fill in the Depends: field in the
controlling information for Ipkg packages.</p>

<p style="margin-top: 1em">X_IPK_DESCRIPTION <br>
This is used to fill in the Description: field in the
controlling information for Ipkg packages. The default value
is $SUMMARY0DESCRIPTION</p>

<p style="margin-top: 1em">X_IPK_MAINTAINER <br>
This is used to fill in the Maintainer: field in the
controlling information for Ipkg packages.</p>

<p style="margin-top: 1em">X_IPK_PRIORITY <br>
This is used to fill in the Priority: field in the
controlling information for Ipkg packages.</p>

<p style="margin-top: 1em">X_IPK_SECTION <br>
This is used to fill in the Section: field in the
controlling information for Ipkg packages.</p>

<p style="margin-top: 1em">X_MSI_LANGUAGE <br>
This is used to fill in the Language: attribute in the
controlling information for MSI packages.</p>

<p style="margin-top: 1em">X_MSI_LICENSE_TEXT <br>
The text of the software license in RTF format. Carriage
return characters will be replaced with the RTF equivalent
\par.</p>

<p style="margin-top: 1em">X_MSI_UPGRADE_CODE <br>
TODO</p>

<p style="margin-top: 1em">X_RPM_AUTOREQPROV <br>
This is used to fill in the AutoReqProv: field in the RPM
.spec file.</p>

<p style="margin-top: 1em">X_RPM_BUILD <br>
internal, but overridable</p>

<p style="margin-top: 1em">X_RPM_BUILDREQUIRES <br>
This is used to fill in the BuildRequires: field in the RPM
.spec file.</p>

<p style="margin-top: 1em">X_RPM_BUILDROOT <br>
internal, but overridable</p>

<p style="margin-top: 1em">X_RPM_CLEAN <br>
internal, but overridable</p>

<p style="margin-top: 1em">X_RPM_CONFLICTS <br>
This is used to fill in the Conflicts: field in the RPM
.spec file.</p>

<p style="margin-top: 1em">X_RPM_DEFATTR <br>
This value is used as the default attributes for the files
in the RPM package. The default value is (-,root,root).</p>

<p style="margin-top: 1em">X_RPM_DISTRIBUTION <br>
This is used to fill in the Distribution: field in the RPM
.spec file.</p>

<p style="margin-top: 1em">X_RPM_EPOCH <br>
This is used to fill in the Epoch: field in the controlling
information for RPM packages.</p>

<p style="margin-top: 1em">X_RPM_EXCLUDEARCH <br>
This is used to fill in the ExcludeArch: field in the RPM
.spec file.</p>

<p style="margin-top: 1em">X_RPM_EXLUSIVEARCH <br>
This is used to fill in the ExclusiveArch: field in the RPM
.spec file.</p>

<p style="margin-top: 1em">X_RPM_GROUP <br>
This is used to fill in the Group: field in the RPM .spec
file.</p>

<p style="margin-top: 1em">X_RPM_GROUP_lang <br>
This is used to fill in the Group(lang): field in the RPM
.spec file. Note that lang is not literal and should be
replaced by the appropriate language code.</p>

<p style="margin-top: 1em">X_RPM_ICON <br>
This is used to fill in the Icon: field in the RPM .spec
file.</p>

<p style="margin-top: 1em">X_RPM_INSTALL <br>
internal, but overridable</p>

<p style="margin-top: 1em">X_RPM_PACKAGER <br>
This is used to fill in the Packager: field in the RPM .spec
file.</p>

<p style="margin-top: 1em">X_RPM_POSTINSTALL <br>
This is used to fill in the %post: section in the RPM .spec
file.</p>

<p style="margin-top: 1em">X_RPM_POSTUNINSTALL <br>
This is used to fill in the %postun: section in the RPM
.spec file.</p>

<p style="margin-top: 1em">X_RPM_PREFIX <br>
This is used to fill in the Prefix: field in the RPM .spec
file.</p>

<p style="margin-top: 1em">X_RPM_PREINSTALL <br>
This is used to fill in the %pre: section in the RPM .spec
file.</p>

<p style="margin-top: 1em">X_RPM_PREP <br>
internal, but overridable</p>

<p style="margin-top: 1em">X_RPM_PREUNINSTALL <br>
This is used to fill in the %preun: section in the RPM .spec
file.</p>

<p style="margin-top: 1em">X_RPM_PROVIDES <br>
This is used to fill in the Provides: field in the RPM .spec
file.</p>

<p style="margin-top: 1em">X_RPM_REQUIRES <br>
This is used to fill in the Requires: field in the RPM .spec
file.</p>

<p style="margin-top: 1em">X_RPM_SERIAL <br>
This is used to fill in the Serial: field in the RPM .spec
file.</p>

<p style="margin-top: 1em">X_RPM_URL <br>
This is used to fill in the Url: field in the RPM .spec
file.</p>

<p style="margin-top: 1em">XGETTEXT <br>
Path to xgettext(1) program (found via Detect()). See
xgettext tool and POTUpdate builder.</p>

<p style="margin-top: 1em">XGETTEXTCOM <br>
Complete xgettext command line. See xgettext tool and
POTUpdate builder.</p>

<p style="margin-top: 1em">XGETTEXTCOMSTR <br>
A string that is shown when xgettext(1) command is invoked
(default: &rsquo;&rsquo;, which means &quot;print
$XGETTEXTCOM&quot;). See xgettext tool and POTUpdate
builder.</p>

<p style="margin-top: 1em">_XGETTEXTDOMAIN <br>
Internal &quot;macro&quot;. Generates xgettext domain name
form source and target (default:
&rsquo;${TARGET.filebase}&rsquo;).</p>

<p style="margin-top: 1em">XGETTEXTFLAGS <br>
Additional flags to xgettext(1). See xgettext tool and
POTUpdate builder.</p>

<p style="margin-top: 1em">XGETTEXTFROM <br>
Name of file containing list of xgettext(1)&rsquo;s source
files. Autotools&rsquo; users know this as POTFILES.in so
they will in most cases set
XGETTEXTFROM=&quot;POTFILES.in&quot; here. The <br>
$XGETTEXTFROM files have same syntax and semantics as the
well known GNU POTFILES.in. See xgettext tool and POTUpdate
builder.</p>

<p style="margin-top: 1em">_XGETTEXTFROMFLAGS <br>
Internal &quot;macro&quot;. Genrates list of -D&lt;dir&gt;
flags from the $XGETTEXTPATH list.</p>

<p style="margin-top: 1em">XGETTEXTFROMPREFIX <br>
This flag is used to add single $XGETTEXTFROM file to
xgettext(1)&rsquo;s commandline (default:
&rsquo;-f&rsquo;).</p>

<p style="margin-top: 1em">XGETTEXTFROMSUFFIX <br>
(default: &rsquo;&rsquo;)</p>

<p style="margin-top: 1em">XGETTEXTPATH <br>
List of directories, there xgettext(1) will look for source
files (default: []).</p>

<p style="margin-top: 1em">Note <br>
This variable works only together with $XGETTEXTFROM <br>
See also xgettext tool and POTUpdate builder.</p>

<p style="margin-top: 1em">_XGETTEXTPATHFLAGS <br>
Internal &quot;macro&quot;. Generates list of -f&lt;file&gt;
flags from $XGETTEXTFROM.</p>

<p style="margin-top: 1em">XGETTEXTPATHPREFIX <br>
This flag is used to add single search path to
xgettext(1)&rsquo;s commandline (default:
&rsquo;-D&rsquo;).</p>

<p style="margin-top: 1em">XGETTEXTPATHSUFFIX <br>
(default: &rsquo;&rsquo;)</p>

<p style="margin-top: 1em">YACC <br>
The parser generator.</p>

<p style="margin-top: 1em">YACCCOM <br>
The command line used to call the parser generator to
generate a source file.</p>

<p style="margin-top: 1em">YACCCOMSTR <br>
The string displayed when generating a source file using the
parser generator. If this is not set, then $YACCCOM (the
command line) is displayed.</p>

<p style="margin-top: 1em">env = Environment(YACCCOMSTR =
&quot;Yacc&rsquo;ing $TARGET from $SOURCES&quot;)</p>

<p style="margin-top: 1em">YACCFLAGS <br>
General options passed to the parser generator. If
$YACCFLAGS contains a -d option, SCons assumes that the call
will also create a .h file (if the yacc source file ends in
a <br>
.y suffix) or a .hpp file (if the yacc source file ends in a
.yy suffix)</p>

<p style="margin-top: 1em">YACCHFILESUFFIX <br>
The suffix of the C header file generated by the parser
generator when the -d option is used. Note that setting this
variable does not cause the parser generator to generate
<br>
a header file with the specified suffix, it exists to allow
you to specify what suffix the parser generator will use of
its own accord. The default value is .h.</p>

<p style="margin-top: 1em">YACCHXXFILESUFFIX <br>
The suffix of the C++ header file generated by the parser
generator when the -d option is used. Note that setting this
variable does not cause the parser generator to <br>
generate a header file with the specified suffix, it exists
to allow you to specify what suffix the parser generator
will use of its own accord. The default value is .hpp, <br>
except on Mac OS X, where the default is ${TARGET.suffix}.h.
because the default bison parser generator just appends .h
to the name of the generated C++ file.</p>

<p style="margin-top: 1em">YACCVCGFILESUFFIX <br>
The suffix of the file containing the VCG grammar automaton
definition when the --graph= option is used. Note that
setting this variable does not cause the parser generator
<br>
to generate a VCG file with the specified suffix, it exists
to allow you to specify what suffix the parser generator
will use of its own accord. The default value is .vcg.</p>

<p style="margin-top: 1em">ZIP <br>
The zip compression and file packaging utility.</p>

<p style="margin-top: 1em">ZIPCOM <br>
The command line used to call the zip utility, or the
internal Python function used to create a zip archive.</p>

<p style="margin-top: 1em">ZIPCOMPRESSION <br>
The compression flag from the Python zipfile module used by
the internal Python function to control whether the zip
archive is compressed or not. The default value is <br>
zipfile.ZIP_DEFLATED, which creates a compressed zip
archive. This value has no effect if the zipfile module is
unavailable.</p>

<p style="margin-top: 1em">ZIPCOMSTR <br>
The string displayed when archiving files using the zip
utility. If this is not set, then $ZIPCOM (the command line
or internal Python function) is displayed.</p>

<p style="margin-top: 1em">env = Environment(ZIPCOMSTR =
&quot;Zipping $TARGET&quot;)</p>

<p style="margin-top: 1em">ZIPFLAGS <br>
General options passed to the zip utility.</p>

<p style="margin-top: 1em">ZIPROOT <br>
An optional zip root directory (default empty). The
filenames stored in the zip file will be relative to this
directory, if given. Otherwise the filenames are relative to
the <br>
current directory of the command. For instance:</p>

<p style="margin-top: 1em">env = Environment() <br>
env.Zip(&rsquo;foo.zip&rsquo;,
&rsquo;subdir1/subdir2/file1&rsquo;,
ZIPROOT=&rsquo;subdir1&rsquo;)</p>

<p style="margin-top: 1em">will produce a zip file foo.zip
containing a file with the name subdir2/file1 rather than
subdir1/subdir2/file1.</p>

<p style="margin-top: 1em">ZIPSUFFIX <br>
The suffix used for zip file names.</p>

<p style="margin-top: 1em">Construction variables can be
retrieved and set using the Dictionary method of the
construction environment:</p>

<p style="margin-top: 1em">dict = env.Dictionary() <br>
dict[&quot;CC&quot;] = &quot;cc&quot;</p>

<p style="margin-top: 1em">or using the [] operator:</p>

<p style="margin-top: 1em">env[&quot;CC&quot;] =
&quot;cc&quot;</p>

<p style="margin-top: 1em">Construction variables can also
be passed to the construction environment constructor:</p>

<p style="margin-top: 1em">env =
Environment(CC=&quot;cc&quot;)</p>

<p style="margin-top: 1em">or when copying a construction
environment using the Clone method:</p>

<p style="margin-top: 1em">env2 =
env.Clone(CC=&quot;cl.exe&quot;)</p>

<p style="margin-top: 1em">Configure Contexts <br>
scons supports configure contexts, an integrated mechanism
similar to the various AC_CHECK macros in GNU autoconf for
testing for the existence of C header files, libraries, etc.
<br>
In contrast to autoconf, scons does not maintain an explicit
cache of the tested values, but uses its normal dependency
tracking to keep the checked values up to date. However,
<br>
users may override this behaviour with the --config command
line option.</p>

<p style="margin-top: 1em">The following methods can be
used to perform checks:</p>

<p style="margin-top: 1em">Configure(env, [custom_tests,
conf_dir, log_file, config_h, clean, help]),
env.Configure([custom_tests, conf_dir, log_file, config_h,
clean, help]) <br>
This creates a configure context, which can be used to
perform checks. env specifies the environment for building
the tests. This environment may be modified when performing
<br>
checks. custom_tests is a dictionary containing custom
tests. See also the section about custom tests below. By
default, no custom tests are added to the configure context.
<br>
conf_dir specifies a directory where the test cases are
built. Note that this directory is not used for building
normal targets. The default value is the directory <br>
#/.sconf_temp. log_file specifies a file which collects the
output from commands that are executed to check for the
existence of header files, libraries, etc. The default is
<br>
the file #/config.log. If you are using the VariantDir()
method, you may want to specify a subdirectory under your
variant directory. config_h specifies a C header file <br>
where the results of tests will be written, e.g. #define
HAVE_STDIO_H, #define HAVE_LIBM, etc. The default is to not
write a config.h file. You can specify the same config.h
<br>
file in multiple calls to Configure, in which case scons
will concatenate all results in the specified file. Note
that SCons uses its normal dependency checking to decide if
<br>
it&rsquo;s necessary to rebuild the specified config_h file.
This means that the file is not necessarily re-built each
time scons is run, but is only rebuilt if its contents will
<br>
have changed and some target that depends on the config_h
file is being built.</p>

<p style="margin-top: 1em">The optional clean and help
arguments can be used to suppress execution of the
configuration tests when the -c/--clean or -H/-h/--help
options are used, respectively. The <br>
default behavior is always to execute configure context
tests, since the results of the tests may affect the list of
targets to be cleaned or the help text. If the configure
<br>
tests do not affect these, then you may add the clean=False
or help=False arguments (or both) to avoid unnecessary test
execution.</p>

<p style="margin-top: 1em">A created Configure instance has
the following associated methods:</p>

<p style="margin-top: 1em">SConf.Finish(context),
sconf.Finish() <br>
This method should be called after configuration is done. It
returns the environment as modified by the configuration
checks performed. After this method is called, no <br>
further checks can be performed with this configuration
context. However, you can create a new Configure context to
perform additional checks. Only one context should be <br>
active at a time.</p>

<p style="margin-top: 1em">The following Checks are
predefined. (This list will likely grow larger as time goes
by and developers contribute new useful tests.)</p>

<p style="margin-top: 1em">SConf.CheckHeader(context,
header, [include_quotes, language]),
sconf.CheckHeader(header, [include_quotes, language]) <br>
Checks if header is usable in the specified language. header
may be a list, in which case the last item in the list is
the header file to be checked, and the previous list <br>
items are header files whose #include lines should precede
the header line being checked for. The optional argument
include_quotes must be a two character string, where the
<br>
first character denotes the opening quote and the second
character denotes the closing quote. By default, both
characters are &quot; (double quote). The optional argument
language <br>
should be either C or C++ and selects the compiler to be
used for the check. Returns 1 on success and 0 on
failure.</p>

<p style="margin-top: 1em">SConf.CheckCHeader(context,
header, [include_quotes]), sconf.CheckCHeader(header,
[include_quotes]) <br>
This is a wrapper around SConf.CheckHeader which checks if
header is usable in the C language. header may be a list, in
which case the last item in the list is the header <br>
file to be checked, and the previous list items are header
files whose #include lines should precede the header line
being checked for. The optional argument include_quotes <br>
must be a two character string, where the first character
denotes the opening quote and the second character denotes
the closing quote (both default to &quot;). Returns 1 on
<br>
success and 0 on failure.</p>

<p style="margin-top: 1em">SConf.CheckCXXHeader(context,
header, [include_quotes]), sconf.CheckCXXHeader(header,
[include_quotes]) <br>
This is a wrapper around SConf.CheckHeader which checks if
header is usable in the C++ language. header may be a list,
in which case the last item in the list is the header <br>
file to be checked, and the previous list items are header
files whose #include lines should precede the header line
being checked for. The optional argument include_quotes <br>
must be a two character string, where the first character
denotes the opening quote and the second character denotes
the closing quote (both default to &quot;). Returns 1 on
<br>
success and 0 on failure.</p>

<p style="margin-top: 1em">SConf.CheckFunc(context,,
function_name, [header, language]),
sconf.CheckFunc(function_name, [header, language]) <br>
Checks if the specified C or C++ function is available.
function_name is the name of the function to check for. The
optional header argument is a string that will be placed
<br>
at the top of the test file that will be compiled to check
if the function exists; the default is:</p>

<p style="margin-top: 1em">#ifdef __cplusplus <br>
extern &quot;C&quot; <br>
#endif <br>
char function_name();</p>

<p style="margin-top: 1em">The optional language argument
should be C or C++ and selects the compiler to be used for
the check; the default is &quot;C&quot;.</p>

<p style="margin-top: 1em">SConf.CheckLib(context,
[library, symbol, header, language, autoadd=1]),
sconf.CheckLib([library, symbol, header, language,
autoadd=1]) <br>
Checks if library provides symbol. If the value of autoadd
is 1 and the library provides the specified symbol, appends
the library to the LIBS construction environment <br>
variable. library may also be None (the default), in which
case symbol is checked with the current LIBS variable, or a
list of library names, in which case each library in <br>
the list will be checked for symbol. If symbol is not set or
is None, then SConf.CheckLib() just checks if you can link
against the specified library. The optional language <br>
argument should be C or C++ and selects the compiler to be
used for the check; the default is &quot;C&quot;. The
default value for autoadd is 1. This method returns 1 on
success and 0 <br>
on error.</p>


<p style="margin-top: 1em">SConf.CheckLibWithHeader(context,
library, header, language, [call, autoadd]),
sconf.CheckLibWithHeader(library, header, language, [call,
autoadd]) <br>
In contrast to the SConf.CheckLib call, this call provides a
more sophisticated way to check against libraries. Again,
library specifies the library or a list of libraries to <br>
check. header specifies a header to check for. header may be
a list, in which case the last item in the list is the
header file to be checked, and the previous list items <br>
are header files whose #include lines should precede the
header line being checked for. language may be one of
&rsquo;C&rsquo;,&rsquo;c&rsquo;,&rsquo;CXX&rsquo;,&rsquo;cxx&rsquo;,&rsquo;C++&rsquo;
and &rsquo;c++&rsquo;. call can be any valid <br>
expression (with a trailing &rsquo;;&rsquo;). If call is not
set, the default simply checks that you can link against the
specified library. autoadd specifies whether to add the
library <br>
to the environment (only if the check succeeds). This method
returns 1 on success and 0 on error.</p>

<p style="margin-top: 1em">SConf.CheckType(context,
type_name, [includes, language]), sconf.CheckType(type_name,
[includes, language]) <br>
Checks for the existence of a type defined by typedef.
type_name specifies the typedef name to check for. includes
is a string containing one or more #include lines that <br>
will be inserted into the program that will be run to test
for the existence of the type. The optional language
argument should be C or C++ and selects the compiler to be
<br>
used for the check; the default is &quot;C&quot;.
Example:</p>


<p style="margin-top: 1em">sconf.CheckType(&rsquo;foo_type&rsquo;,
&rsquo;#include &quot;my_types.h&quot;&rsquo;,
&rsquo;C++&rsquo;)</p>

<p style="margin-top: 1em">Configure.CheckCC(self) <br>
Checks whether the C compiler (as defined by the CC
construction variable) works by trying to compile a small
source file.</p>

<p style="margin-top: 1em">By default, SCons only detects
if there is a program with the correct name, not if it is a
functioning compiler.</p>

<p style="margin-top: 1em">This uses the exact same command
than the one used by the object builder for C source file,
so it can be used to detect if a particular compiler flag
works or not.</p>

<p style="margin-top: 1em">Configure.CheckCXX(self) <br>
Checks whether the C++ compiler (as defined by the CXX
construction variable) works by trying to compile a small
source file. By default, SCons only detects if there is a
<br>
program with the correct name, not if it is a functioning
compiler.</p>

<p style="margin-top: 1em">This uses the exact same command
than the one used by the object builder for CXX source
files, so it can be used to detect if a particular compiler
flag works or not.</p>

<p style="margin-top: 1em">Configure.CheckSHCC(self) <br>
Checks whether the C compiler (as defined by the SHCC
construction variable) works by trying to compile a small
source file. By default, SCons only detects if there is a
<br>
program with the correct name, not if it is a functioning
compiler.</p>

<p style="margin-top: 1em">This uses the exact same command
than the one used by the object builder for C source file,
so it can be used to detect if a particular compiler flag
works or not. This does <br>
not check whether the object code can be used to build a
shared library, only that the compilation (not link)
succeeds.</p>

<p style="margin-top: 1em">Configure.CheckSHCXX(self) <br>
Checks whether the C++ compiler (as defined by the SHCXX
construction variable) works by trying to compile a small
source file. By default, SCons only detects if there is a
<br>
program with the correct name, not if it is a functioning
compiler.</p>

<p style="margin-top: 1em">This uses the exact same command
than the one used by the object builder for CXX source
files, so it can be used to detect if a particular compiler
flag works or not. This <br>
does not check whether the object code can be used to build
a shared library, only that the compilation (not link)
succeeds.</p>

<p style="margin-top: 1em">Example of a typical Configure
usage:</p>

<p style="margin-top: 1em">env = Environment() <br>
conf = Configure( env ) <br>
if not conf.CheckCHeader( &rsquo;math.h&rsquo; ): <br>
print &rsquo;We really need math.h!&rsquo; <br>
Exit(1) <br>
if conf.CheckLibWithHeader( &rsquo;qt&rsquo;,
&rsquo;qapp.h&rsquo;, &rsquo;c++&rsquo;, <br>
&rsquo;QApplication qapp(0,0);&rsquo; ): <br>
# do stuff for qt - usage, e.g. <br>
conf.env.Append( CPPFLAGS = &rsquo;-DWITH_QT&rsquo; ) <br>
env = conf.Finish()</p>

<p style="margin-top: 1em">SConf.CheckTypeSize(context,
type_name, [header, language, expect]),
sconf.CheckTypeSize(type_name, [header, language, expect])
<br>
Checks for the size of a type defined by typedef. type_name
specifies the typedef name to check for. The optional header
argument is a string that will be placed at the top <br>
of the test file that will be compiled to check if the
function exists; the default is empty. The optional language
argument should be C or C++ and selects the compiler to be
<br>
used for the check; the default is &quot;C&quot;. The
optional expect argument should be an integer. If this
argument is used, the function will only check whether the
type given in <br>
type_name has the expected size (in bytes). For example,
CheckTypeSize(&rsquo;short&rsquo;, expect = 2) will return
success only if short is two bytes.</p>

<p style="margin-top: 1em">SConf.CheckDeclaration(context,
symbol, [includes, language]),
sconf.CheckDeclaration(symbol, [includes, language]) <br>
Checks if the specified symbol is declared. includes is a
string containing one or more #include lines that will be
inserted into the program that will be run to test for <br>
the existence of the type. The optional language argument
should be C or C++ and selects the compiler to be used for
the check; the default is &quot;C&quot;.</p>

<p style="margin-top: 1em">SConf.Define(context, symbol,
[value, comment]), sconf.Define(symbol, [value, comment])
<br>
This function does not check for anything, but defines a
preprocessor symbol that will be added to the configuration
header file. It is the equivalent of AC_DEFINE, and <br>
defines the symbol name with the optional value and the
optional comment comment.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">env = Environment() <br>
conf = Configure( env )</p>

<p style="margin-top: 1em"># Puts the following line in the
config header file: <br>
# #define A_SYMBOL <br>
conf.Define(&rsquo;A_SYMBOL&rsquo;)</p>

<p style="margin-top: 1em"># Puts the following line in the
config header file: <br>
# #define A_SYMBOL 1 <br>
conf.Define(&rsquo;A_SYMBOL&rsquo;, 1)</p>

<p style="margin-top: 1em">Be careful about quoting string
values, though:</p>

<p style="margin-top: 1em">env = Environment() <br>
conf = Configure( env )</p>

<p style="margin-top: 1em"># Puts the following line in the
config header file: <br>
# #define A_SYMBOL YA <br>
conf.Define(&rsquo;A_SYMBOL&rsquo;, &quot;YA&quot;)</p>

<p style="margin-top: 1em"># Puts the following line in the
config header file: <br>
# #define A_SYMBOL &quot;YA&quot; <br>
conf.Define(&rsquo;A_SYMBOL&rsquo;,
&rsquo;&quot;YA&quot;&rsquo;)</p>

<p style="margin-top: 1em">For comment:</p>

<p style="margin-top: 1em">env = Environment() <br>
conf = Configure( env )</p>

<p style="margin-top: 1em"># Puts the following lines in
the config header file: <br>
# /* Set to 1 if you have a symbol */ <br>
# #define A_SYMBOL 1 <br>
conf.Define(&rsquo;A_SYMBOL&rsquo;, 1, &rsquo;Set to 1 if
you have a symbol&rsquo;)</p>

<p style="margin-top: 1em">You can define your own custom
checks. in addition to the predefined checks. These are
passed in a dictionary to the Configure function. This
dictionary maps the names of the <br>
checks to user defined Python callables (either Python
functions or class instances implementing the __call__
method). The first argument of the call is always a
CheckContext <br>
instance followed by the arguments, which must be supplied
by the user of the check. These CheckContext instances
define the following methods:</p>

<p style="margin-top: 1em">CheckContext.Message(self, text)
<br>
Usually called before the check is started. text will be
displayed to the user, e.g. &rsquo;Checking for library
X...&rsquo;</p>

<p style="margin-top: 1em">CheckContext.Result(self,, res)
<br>
Usually called after the check is done. res can be either an
integer or a string. In the former case, &rsquo;yes&rsquo;
(res != 0) or &rsquo;no&rsquo; (res == 0) is displayed to
the user, in the <br>
latter case the given string is displayed.</p>

<p style="margin-top: 1em">CheckContext.TryCompile(self,
text, extension) <br>
Checks if a file with the specified extension (e.g.
&rsquo;.c&rsquo;) containing text can be compiled using the
environment&rsquo;s Object builder. Returns 1 on success and
0 on failure.</p>

<p style="margin-top: 1em">CheckContext.TryLink(self, text,
extension) <br>
Checks, if a file with the specified extension (e.g.
&rsquo;.c&rsquo;) containing text can be compiled using the
environment&rsquo;s Program builder. Returns 1 on success
and 0 on failure.</p>

<p style="margin-top: 1em">CheckContext.TryRun(self, text,
extension) <br>
Checks, if a file with the specified extension (e.g.
&rsquo;.c&rsquo;) containing text can be compiled using the
environment&rsquo;s Program builder. On success, the program
is run. If the <br>
program executes successfully (that is, its return status is
0), a tuple (1, outputStr) is returned, where outputStr is
the standard output of the program. If the program <br>
fails execution (its return status is non-zero), then (0,
&rsquo;&rsquo;) is returned.</p>

<p style="margin-top: 1em">CheckContext.TryAction(self,
action, [text, extension]) <br>
Checks if the specified action with an optional source file
(contents text , extension extension = &rsquo;&rsquo; ) can
be executed. action may be anything which can be converted
to a <br>
scons Action. On success, (1, outputStr) is returned, where
outputStr is the content of the target file. On failure (0,
&rsquo;&rsquo;) is returned.</p>

<p style="margin-top: 1em">CheckContext.TryBuild(self,
builder, [text, extension]) <br>
Low level implementation for testing specific builds; the
methods above are based on this method. Given the Builder
instance builder and the optional text of a source file <br>
with optional extension, this method returns 1 on success
and 0 on failure. In addition, self.lastTarget is set to the
build target node, if the build was successful.</p>

<p style="margin-top: 1em">Example for implementing and
using custom tests:</p>

<p style="margin-top: 1em">def CheckQt(context, qtdir):
<br>
context.Message( &rsquo;Checking for qt ...&rsquo; ) <br>
lastLIBS = context.env[&rsquo;LIBS&rsquo;] <br>
lastLIBPATH = context.env[&rsquo;LIBPATH&rsquo;] <br>
lastCPPPATH= context.env[&rsquo;CPPPATH&rsquo;] <br>
context.env.Append(LIBS = &rsquo;qt&rsquo;, LIBPATH = qtdir
+ &rsquo;/lib&rsquo;, CPPPATH = qtdir +
&rsquo;/include&rsquo; ) <br>
ret = context.TryLink(&quot;&quot;&quot; <br>
#include &lt;qapp.h&gt; <br>
int main(int argc, char **argv) { <br>
QApplication qapp(argc, argv); <br>
return 0; <br>
} <br>
&quot;&quot;&quot;) <br>
if not ret: <br>
context.env.Replace(LIBS = lastLIBS, LIBPATH=lastLIBPATH,
CPPPATH=lastCPPPATH) <br>
context.Result( ret ) <br>
return ret</p>

<p style="margin-top: 1em">env = Environment() <br>
conf = Configure( env, custom_tests = {
&rsquo;CheckQt&rsquo; : CheckQt } ) <br>
if not conf.CheckQt(&rsquo;/usr/lib/qt&rsquo;): <br>
print &rsquo;We really need qt!&rsquo; <br>
Exit(1) <br>
env = conf.Finish()</p>

<p style="margin-top: 1em">Command-Line Construction
Variables <br>
Often when building software, some variables must be
specified at build time. For example, libraries needed for
the build may be in non-standard locations, or site-specific
<br>
compiler options may need to be passed to the compiler.
scons provides a Variables object to support overriding
construction variables on the command line:</p>

<p style="margin-top: 1em">$ scons VARIABLE=foo</p>

<p style="margin-top: 1em">The variable values can also be
specified in a text-based SConscript file. To create a
Variables object, call the Variables() function:</p>

<p style="margin-top: 1em">Variables([files], [args]) <br>
This creates a Variables object that will read construction
variables from the file or list of filenames specified in
files. If no files are specified, or the files argument <br>
is None, then no files will be read. The optional argument
args is a dictionary of values that will override anything
read from the specified files; it is primarily intended <br>
to be passed the ARGUMENTS dictionary that holds variables
specified on the command line. Example:</p>

<p style="margin-top: 1em">vars =
Variables(&rsquo;custom.py&rsquo;) <br>
vars = Variables(&rsquo;overrides.py&rsquo;, ARGUMENTS) <br>
vars = Variables(None, {FOO:&rsquo;expansion&rsquo;,
BAR:7})</p>

<p style="margin-top: 1em">Variables objects have the
following methods:</p>

<p style="margin-top: 1em">Add(key, [help, default,
validator, converter]) <br>
This adds a customizable construction variable to the
Variables object. key is the name of the variable. help is
the help text for the variable. default is the default <br>
value of the variable; if the default value is None and
there is no explicit value specified, the construction
variable will not be added to the construction environment.
<br>
validator is called to validate the value of the variable,
and should take three arguments: key, value, and
environment. The recommended way to handle an invalid value
is to <br>
raise an exception (see example below). converter is called
to convert the value before putting it in the environment,
and should take either a value, or the value and <br>
environment, as parameters. The converter must return a
value, which will be converted into a string before being
validated by the validator (if any) and then added to the
<br>
environment.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">vars.Add(&rsquo;CC&rsquo;,
&rsquo;The C compiler&rsquo;)</p>

<p style="margin-top: 1em">def validate_color(key, val,
env): <br>
if not val in [&rsquo;red&rsquo;, &rsquo;blue&rsquo;,
&rsquo;yellow&rsquo;]: <br>
raise Exception(&quot;Invalid color value
&rsquo;%s&rsquo;&quot; % val) <br>
vars.Add(&rsquo;COLOR&rsquo;, validator=valid_color)</p>

<p style="margin-top: 1em">AddVariables(list) <br>
A wrapper script that adds multiple customizable
construction variables to a Variables object. list is a list
of tuple or list objects that contain the arguments for an
<br>
individual call to the Add method.</p>

<p style="margin-top: 1em">opt.AddVariables( <br>
(&rsquo;debug&rsquo;, &rsquo;&rsquo;, 0), <br>
(&rsquo;CC&rsquo;, &rsquo;The C compiler&rsquo;), <br>
(&rsquo;VALIDATE&rsquo;, &rsquo;An option for testing
validation&rsquo;, <br>
&rsquo;notset&rsquo;, validator, None), <br>
)</p>

<p style="margin-top: 1em">Update(env, [args]) <br>
This updates a construction environment env with the
customized construction variables. Any specified variables
that are not configured for the Variables object will be
saved <br>
and may be retrieved with the UnknownVariables() method,
below.</p>

<p style="margin-top: 1em">Normally this method is not
called directly, but is called indirectly by passing the
Variables object to the Environment() function:</p>

<p style="margin-top: 1em">env =
Environment(variables=vars)</p>

<p style="margin-top: 1em">The text file(s) that were
specified when the Variables object was created are executed
as Python scripts, and the values of (global) Python
variables set in the file are added <br>
to the construction environment.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">CC = &rsquo;my_cc&rsquo;</p>

<p style="margin-top: 1em">UnknownVariables() <br>
Returns a dictionary containing any variables that were
specified either in the files or the dictionary with which
the Variables object was initialized, but for which the <br>
Variables object was not configured.</p>

<p style="margin-top: 1em">env =
Environment(variables=vars) <br>
for key, value in vars.UnknownVariables(): <br>
print &quot;unknown variable: %s=%s&quot; % (key, value)</p>

<p style="margin-top: 1em">Save(filename, env) <br>
This saves the currently set variables into a script file
named filename that can be used on the next invocation to
automatically load the current settings. This method <br>
combined with the Variables method can be used to support
caching of variables between runs.</p>

<p style="margin-top: 1em">env = Environment() <br>
vars = Variables([&rsquo;variables.cache&rsquo;,
&rsquo;custom.py&rsquo;]) <br>
vars.Add(...) <br>
vars.Update(env) <br>
vars.Save(&rsquo;variables.cache&rsquo;, env)</p>

<p style="margin-top: 1em">GenerateHelpText(env, [sort])
<br>
This generates help text documenting the customizable
construction variables suitable to passing in to the Help()
function. env is the construction environment that will be
<br>
used to get the actual values of customizable variables.
Calling with an optional sort function will cause the output
to be sorted by the specified argument. The specific <br>
sort function should take two arguments and return -1, 0 or
1 (like the standard Python cmp function).</p>


<p style="margin-top: 1em">Help(vars.GenerateHelpText(env))
<br>
Help(vars.GenerateHelpText(env, sort=cmp))</p>

<p style="margin-top: 1em">FormatVariableHelpText(env, opt,
help, default, actual) <br>
This method returns a formatted string containing the
printable help text for one option. It is normally not
called directly, but is called by the GenerateHelpText()
method <br>
to create the returned help text. It may be overridden with
your own function that takes the arguments specified above
and returns a string of help text formatted to your <br>
liking. Note that the GenerateHelpText() will not put any
blank lines or extra characters in between the entries, so
you must add those characters to the returned string if <br>
you want the entries separated.</p>

<p style="margin-top: 1em">def my_format(env, opt, help,
default, actual): <br>
fmt = &quot;1s: default=%s actual=%s (%s)0 <br>
return fmt % (opt, default. actual, help) <br>
vars.FormatVariableHelpText = my_format</p>

<p style="margin-top: 1em">To make it more convenient to
work with customizable Variables, scons provides a number of
functions that make it easy to set up various types of
Variables:</p>

<p style="margin-top: 1em">BoolVariable(key, help, default)
<br>
Return a tuple of arguments to set up a Boolean option. The
option will use the specified name key, have a default value
of default, and display the specified help text. The <br>
option will interpret the values y, yes, t, true, 1, on and
all as true, and the values n, no, f, false, 0, off and none
as false.</p>

<p style="margin-top: 1em">EnumVariable(key, help, default,
allowed_values, [map, ignorecase]) <br>
Return a tuple of arguments to set up an option whose value
may be one of a specified list of legal enumerated values.
The option will use the specified name key, have a <br>
default value of default, and display the specified help
text. The option will only support those values in the
allowed_values list. The optional map argument is a
dictionary <br>
that can be used to convert input values into specific legal
values in the allowed_values list. If the value of
ignore_case is 0 (the default), then the values are <br>
case-sensitive. If the value of ignore_case is 1, then
values will be matched case-insensitive. If the value of
ignore_case is 2, then values will be matched <br>
case-insensitive, and all input values will be converted to
lower case.</p>

<p style="margin-top: 1em">ListVariable(key, help, default,
names, [,map]) <br>
Return a tuple of arguments to set up an option whose value
may be one or more of a specified list of legal enumerated
values. The option will use the specified name key, <br>
have a default value of default, and display the specified
help text. The option will only support the values all,
none, or the values in the names list. More than one value
<br>
may be specified, with all values separated by commas. The
default may be a string of comma-separated default values,
or a list of the default values. The optional map <br>
argument is a dictionary that can be used to convert input
values into specific legal values in the names list.</p>

<p style="margin-top: 1em">PackageVariable(key, help,
default) <br>
Return a tuple of arguments to set up an option whose value
is a path name of a package that may be enabled, disabled or
given an explicit path name. The option will use the <br>
specified name key, have a default value of default, and
display the specified help text. The option will support the
values yes, true, on, enable or search, in which case <br>
the specified default will be used, or the option may be set
to an arbitrary string (typically the path name to a package
that is being enabled). The option will also support <br>
the values no, false, off or disable to disable use of the
specified option.</p>

<p style="margin-top: 1em">PathVariable(key, help, default,
[validator]) <br>
Return a tuple of arguments to set up an option whose value
is expected to be a path name. The option will use the
specified name key, have a default value of default, and
<br>
display the specified help text. An additional validator may
be specified that will be called to verify that the
specified path is acceptable. SCons supplies the following
<br>
ready-made validators: PathVariable.PathExists (the
default), which verifies that the specified path exists;
PathVariable.PathIsFile, which verifies that the specified
path <br>
is an existing file; PathVariable.PathIsDir, which verifies
that the specified path is an existing directory;
PathVariable.PathIsDirCreate, which verifies that the
specified <br>
path is a directory and will create the specified directory
if the path does not exist; and PathVariable.PathAccept,
which simply accepts the specific path name argument <br>
without validation, and which is suitable if you want your
users to be able to specify a directory path that will be
created as part of the build process, for example. You <br>
may supply your own validator function, which must take
three arguments (key, the name of the variable to be set;
val, the specified value being checked; and env, the <br>
construction environment) and should raise an exception if
the specified value is not acceptable.</p>

<p style="margin-top: 1em">These functions make it
convenient to create a number of variables with consistent
behavior in a single call to the AddVariables method:</p>

<p style="margin-top: 1em">vars.AddVariables( <br>
BoolVariable(&rsquo;warnings&rsquo;, &rsquo;compilation with
-Wall and similiar&rsquo;, 1), <br>
EnumVariable(&rsquo;debug&rsquo;, &rsquo;debug output and
symbols&rsquo;, &rsquo;no&rsquo; <br>
allowed_values=(&rsquo;yes&rsquo;, &rsquo;no&rsquo;,
&rsquo;full&rsquo;), <br>
map={}, ignorecase=0), # case sensitive <br>
ListVariable(&rsquo;shared&rsquo;, <br>
&rsquo;libraries to build as shared libraries&rsquo;, <br>
&rsquo;all&rsquo;, <br>
names = list_of_libs), <br>
PackageVariable(&rsquo;x11&rsquo;, <br>
&rsquo;use X11 installed here (yes = search some
places)&rsquo;, <br>
&rsquo;yes&rsquo;), <br>
PathVariable(&rsquo;qtdir&rsquo;, &rsquo;where the root of
Qt is installed&rsquo;, qtdir), <br>
PathVariable(&rsquo;foopath&rsquo;, &rsquo;where the foo
library is installed&rsquo;, foopath, <br>
PathVariable.PathIsDir),</p>

<p style="margin-top: 1em">)</p>

<p style="margin-top: 1em">File and Directory Nodes <br>
The File() and Dir() functions return File and Dir Nodes,
respectively. python objects, respectively. Those objects
have several user-visible attributes and methods that are
<br>
often useful:</p>

<p style="margin-top: 1em">path <br>
The build path of the given file or directory. This path is
relative to the top-level directory (where the SConstruct
file is found). The build path is the same as the source
<br>
path if variant_dir is not being used.</p>

<p style="margin-top: 1em">abspath <br>
The absolute build path of the given file or directory.</p>

<p style="margin-top: 1em">srcnode() <br>
The srcnode() method returns another File or Dir object
representing the source path of the given File or Dir.
The</p>

<p style="margin-top: 1em"># Get the current build
dir&rsquo;s path, relative to top. <br>
Dir(&rsquo;.&rsquo;).path <br>
# Current dir&rsquo;s absolute path <br>
Dir(&rsquo;.&rsquo;).abspath <br>
# Next line is always &rsquo;.&rsquo;, because it is the top
dir&rsquo;s path relative to itself. <br>
Dir(&rsquo;#.&rsquo;).path <br>
File(&rsquo;foo.c&rsquo;).srcnode().path # source path of
the given source file.</p>

<p style="margin-top: 1em"># Builders also return File
objects: <br>
foo = env.Program(&rsquo;foo.c&rsquo;) <br>
print &quot;foo will be built in %s&quot;%foo.path</p>

<p style="margin-top: 1em">A Dir Node or File Node can also
be used to create file and subdirectory Nodes relative to
the generating Node. A Dir Node will place the new Nodes
within the directory it <br>
represents. A File node will place the new Nodes within its
parent directory (that is, &quot;beside&quot; the file in
question). If d is a Dir (directory) Node and f is a File
(file) <br>
Node, then these methods are available:</p>

<p style="margin-top: 1em">d.Dir(name) <br>
Returns a directory Node for a subdirectory of d named
name.</p>

<p style="margin-top: 1em">d.File(name) <br>
Returns a file Node for a file within d named name.</p>

<p style="margin-top: 1em">d.Entry(name) <br>
Returns an unresolved Node within d named name.</p>

<p style="margin-top: 1em">f.Dir(name) <br>
Returns a directory named name within the parent directory
of f.</p>

<p style="margin-top: 1em">f.File(name) <br>
Returns a file named name within the parent directory of
f.</p>

<p style="margin-top: 1em">f.Entry(name) <br>
Returns an unresolved Node named name within the parent
directory of f.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em"># Get a Node for a file within a
directory <br>
incl = Dir(&rsquo;include&rsquo;) <br>
f = incl.File(&rsquo;header.h&rsquo;)</p>

<p style="margin-top: 1em"># Get a Node for a subdirectory
within a directory <br>
dist = Dir(&rsquo;project-3.2.1) <br>
src = dist.Dir(&rsquo;src&rsquo;)</p>

<p style="margin-top: 1em"># Get a Node for a file in the
same directory <br>
cfile = File(&rsquo;sample.c&rsquo;) <br>
hfile = cfile.File(&rsquo;sample.h&rsquo;)</p>

<p style="margin-top: 1em"># Combined example <br>
docs = Dir(&rsquo;docs&rsquo;) <br>
html = docs.Dir(&rsquo;html&rsquo;) <br>
index = html.File(&rsquo;index.html&rsquo;) <br>
css = index.File(&rsquo;app.css&rsquo;)</p>

<p style="margin-top: 1em">EXTENDING SCONS <br>
Builder Objects <br>
scons can be extended to build different types of targets by
adding new Builder objects to a construction environment. In
general, you should only need to add a new Builder <br>
object when you want to build a new type of file or other
external target. If you just want to invoke a different
compiler or other tool to build a Program, Object, Library,
or <br>
any other type of output file for which scons already has an
existing Builder, it is generally much easier to use those
existing Builders in a construction environment that sets
<br>
the appropriate construction variables (CC, LINK, etc.).</p>

<p style="margin-top: 1em">Builder objects are created
using the Builder function. The Builder function accepts the
following arguments:</p>

<p style="margin-top: 1em">action <br>
The command line string used to build the target from the
source. action can also be: a list of strings representing
the command to be executed and its arguments (suitable <br>
for enclosing white space in an argument), a dictionary
mapping source file name suffixes to any combination of
command line strings (if the builder should accept multiple
<br>
source file extensions), a Python function; an Action object
(see the next section); or a list of any of the above.</p>

<p style="margin-top: 1em">An action function takes three
arguments: source - a list of source nodes, target - a list
of target nodes, env - the construction environment.</p>

<p style="margin-top: 1em">prefix <br>
The prefix that will be prepended to the target file name.
This may be specified as a: * string,</p>

<p style="margin-top: 1em">* callable object - a function
or other callable that takes two arguments (a construction
environment and a list of sources) and returns a prefix,</p>

<p style="margin-top: 1em">* dictionary - specifies a
mapping from a specific source suffix (of the first source
specified) to a corresponding target prefix. Both the source
suffix and target prefix <br>
specifications may use environment variable substitution,
and the target prefix (the &rsquo;value&rsquo; entries in
the dictionary) may also be a callable object. The default
target <br>
prefix may be indicated by a dictionary entry with a key
value of None.</p>

<p style="margin-top: 1em">b = Builder(&quot;build_it &lt;
$SOURCE &gt; $TARGET&quot;, <br>
prefix = &quot;file-&quot;)</p>

<p style="margin-top: 1em">def gen_prefix(env, sources):
<br>
return &quot;file-&quot; + env[&rsquo;PLATFORM&rsquo;] +
&rsquo;-&rsquo; <br>
b = Builder(&quot;build_it &lt; $SOURCE &gt; $TARGET&quot;,
<br>
prefix = gen_prefix)</p>

<p style="margin-top: 1em">b = Builder(&quot;build_it &lt;
$SOURCE &gt; $TARGET&quot;, <br>
suffix = { None: &quot;file-&quot;, <br>
&quot;$SRC_SFX_A&quot;: gen_prefix })</p>

<p style="margin-top: 1em">suffix <br>
The suffix that will be appended to the target file name.
This may be specified in the same manner as the prefix
above. If the suffix is a string, then scons will append a
<br>
&rsquo;.&rsquo; to the beginning of the suffix if it&rsquo;s
not already there. The string returned by callable object
(or obtained from the dictionary) is untouched and must
append its own <br>
&rsquo;.&rsquo; to the beginning if one is desired.</p>

<p style="margin-top: 1em">b = Builder(&quot;build_it &lt;
$SOURCE &gt; $TARGET&quot; <br>
suffix = &quot;-file&quot;)</p>

<p style="margin-top: 1em">def gen_suffix(env, sources):
<br>
return &quot;.&quot; + env[&rsquo;PLATFORM&rsquo;] +
&quot;-file&quot; <br>
b = Builder(&quot;build_it &lt; $SOURCE &gt; $TARGET&quot;,
<br>
suffix = gen_suffix)</p>

<p style="margin-top: 1em">b = Builder(&quot;build_it &lt;
$SOURCE &gt; $TARGET&quot;, <br>
suffix = { None: &quot;.sfx1&quot;, <br>
&quot;$SRC_SFX_A&quot;: gen_suffix })</p>

<p style="margin-top: 1em">ensure_suffix <br>
When set to any true value, causes scons to add the target
suffix specified by the suffix keyword to any target strings
that have a different suffix. (The default behavior is <br>
to leave untouched any target file name that looks like it
already has any suffix.)</p>

<p style="margin-top: 1em">b1 = Builder(&quot;build_it &lt;
$SOURCE &gt; $TARGET&quot; <br>
suffix = &quot;.out&quot;) <br>
b2 = Builder(&quot;build_it &lt; $SOURCE &gt; $TARGET&quot;
<br>
suffix = &quot;.out&quot;, <br>
ensure_suffix) <br>
env = Environment() <br>
env[&rsquo;BUILDERS&rsquo;][&rsquo;B1&rsquo;] = b1 <br>
env[&rsquo;BUILDERS&rsquo;][&rsquo;B2&rsquo;] = b2</p>

<p style="margin-top: 1em"># Builds &quot;foo.txt&quot;
because ensure_suffix is not set. <br>
env.B1(&rsquo;foo.txt&rsquo;, &rsquo;foo.in&rsquo;)</p>

<p style="margin-top: 1em"># Builds &quot;bar.txt.out&quot;
because ensure_suffix is set. <br>
env.B2(&rsquo;bar.txt&rsquo;, &rsquo;bar.in&rsquo;)</p>

<p style="margin-top: 1em">src_suffix <br>
The expected source file name suffix. This may be a string
or a list of strings.</p>

<p style="margin-top: 1em">target_scanner <br>
A Scanner object that will be invoked to find implicit
dependencies for this target file. This keyword argument
should be used for Scanner objects that find implicit <br>
dependencies based only on the target file and the
construction environment, not for implicit dependencies
based on source files. (See the section &quot;Scanner
Objects&quot; below, <br>
for information about creating Scanner objects.)</p>

<p style="margin-top: 1em">source_scanner <br>
A Scanner object that will be invoked to find implicit
dependencies in any source files used to build this target
file. This is where you would specify a scanner to find <br>
things like #include lines in source files. The pre-built
DirScanner Scanner object may be used to indicate that this
Builder should scan directory trees for on-disk changes <br>
to files that scons does not know about from other Builder
or function calls. (See the section &quot;Scanner
Objects&quot; below, for information about creating your own
Scanner <br>
objects.)</p>

<p style="margin-top: 1em">target_factory <br>
A factory function that the Builder will use to turn any
targets specified as strings into SCons Nodes. By default,
SCons assumes that all targets are files. Other useful <br>
target_factory values include Dir, for when a Builder
creates a directory target, and Entry, for when a Builder
can create either a file or directory target.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">MakeDirectoryBuilder =
Builder(action=my_mkdir, target_factory=Dir) <br>
env = Environment() <br>
env.Append(BUILDERS =
{&rsquo;MakeDirectory&rsquo;:MakeDirectoryBuilder}) <br>
env.MakeDirectory(&rsquo;new_directory&rsquo;, [])</p>

<p style="margin-top: 1em">Note that the call to the
MakeDirectory Builder needs to specify an empty source list
to make the string represent the builder&rsquo;s target;
without that, it would assume the <br>
argument is the source, and would try to deduce the target
name from it, which in the absence of an automatically-added
prefix or suffix would lead to a matching target and <br>
source name and a circular dependency.</p>

<p style="margin-top: 1em">source_factory <br>
A factory function that the Builder will use to turn any
sources specified as strings into SCons Nodes. By default,
SCons assumes that all source are files. Other useful <br>
source_factory values include Dir, for when a Builder uses a
directory as a source, and Entry, for when a Builder can use
files or directories (or both) as sources.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">CollectBuilder =
Builder(action=my_mkdir, source_factory=Entry) <br>
env = Environment() <br>
env.Append(BUILDERS =
{&rsquo;Collect&rsquo;:CollectBuilder}) <br>
env.Collect(&rsquo;archive&rsquo;,
[&rsquo;directory_name&rsquo;, &rsquo;file_name&rsquo;])</p>

<p style="margin-top: 1em">emitter <br>
A function or list of functions to manipulate the target and
source lists before dependencies are established and the
target(s) are actually built. emitter can also be a <br>
string containing a construction variable to expand to an
emitter function or list of functions, or a dictionary
mapping source file suffixes to emitter functions. (Only the
<br>
suffix of the first source file is used to select the actual
emitter function from an emitter dictionary.)</p>

<p style="margin-top: 1em">An emitter function takes three
arguments: source - a list of source nodes, target - a list
of target nodes, env - the construction environment. An
emitter must return a <br>
tuple containing two lists, the list of targets to be built
by this builder, and the list of sources for this
builder.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">def e(target, source, env): <br>
return (target + [&rsquo;foo.foo&rsquo;], source +
[&rsquo;foo.src&rsquo;])</p>

<p style="margin-top: 1em"># Simple association of an
emitter function with a Builder. <br>
b = Builder(&quot;my_build &lt; $TARGET &gt; $SOURCE&quot;,
<br>
emitter = e)</p>

<p style="margin-top: 1em">def e2(target, source, env):
<br>
return (target + [&rsquo;bar.foo&rsquo;], source +
[&rsquo;bar.src&rsquo;])</p>

<p style="margin-top: 1em"># Simple association of a list
of emitter functions with a Builder. <br>
b = Builder(&quot;my_build &lt; $TARGET &gt; $SOURCE&quot;,
<br>
emitter = [e, e2])</p>

<p style="margin-top: 1em"># Calling an emitter function
through a construction variable. <br>
env = Environment(MY_EMITTER = e) <br>
b = Builder(&quot;my_build &lt; $TARGET &gt; $SOURCE&quot;,
<br>
emitter = &rsquo;$MY_EMITTER&rsquo;)</p>

<p style="margin-top: 1em"># Calling a list of emitter
functions through a construction variable. <br>
env = Environment(EMITTER_LIST = [e, e2]) <br>
b = Builder(&quot;my_build &lt; $TARGET &gt; $SOURCE&quot;,
<br>
emitter = &rsquo;$EMITTER_LIST&rsquo;)</p>

<p style="margin-top: 1em"># Associating multiple emitters
with different file <br>
# suffixes using a dictionary. <br>
def e_suf1(target, source, env): <br>
return (target + [&rsquo;another_target_file&rsquo;],
source) <br>
def e_suf2(target, source, env): <br>
return (target, source +
[&rsquo;another_source_file&rsquo;]) <br>
b = Builder(&quot;my_build &lt; $TARGET &gt; $SOURCE&quot;,
<br>
emitter = {&rsquo;.suf1&rsquo; : e_suf1, <br>
&rsquo;.suf2&rsquo; : e_suf2})</p>

<p style="margin-top: 1em">multi <br>
Specifies whether this builder is allowed to be called
multiple times for the same target file(s). The default is
0, which means the builder can not be called multiple times
<br>
for the same target file(s). Calling a builder multiple
times for the same target simply adds additional source
files to the target; it is not allowed to change the <br>
environment associated with the target, specify addition
environment overrides, or associate a different builder with
the target.</p>

<p style="margin-top: 1em">env <br>
A construction environment that can be used to fetch source
code using this Builder. (Note that this environment is not
used for normal builds of normal target files, which <br>
use the environment that was used to call the Builder for
the target file.)</p>

<p style="margin-top: 1em">generator <br>
A function that returns a list of actions that will be
executed to build the target(s) from the source(s). The
returned action(s) may be an Action object, or anything that
<br>
can be converted into an Action object (see the next
section).</p>

<p style="margin-top: 1em">The generator function takes
four arguments: source - a list of source nodes, target - a
list of target nodes, env - the construction environment,
for_signature - a Boolean <br>
value that specifies whether the generator is being called
for generating a build signature (as opposed to actually
executing the command). Example:</p>

<p style="margin-top: 1em">def g(source, target, env,
for_signature): <br>
return [[&quot;gcc&quot;, &quot;-c&quot;, &quot;-o&quot;] +
target + source]</p>

<p style="margin-top: 1em">b = Builder(generator=g)</p>

<p style="margin-top: 1em">The generator and action
arguments must not both be used for the same Builder.</p>

<p style="margin-top: 1em">src_builder <br>
Specifies a builder to use when a source file name suffix
does not match any of the suffixes of the builder. Using
this argument produces a multi-stage builder.</p>

<p style="margin-top: 1em">single_source <br>
Specifies that this builder expects exactly one source file
per call. Giving more than one source file without target
files results in implicitly calling the builder multiple
<br>
times (once for each source given). Giving multiple source
files together with target files results in a UserError
exception.</p>

<p style="margin-top: 1em">The generator and action
arguments must not both be used for the same Builder.</p>

<p style="margin-top: 1em">source_ext_match <br>
When the specified action argument is a dictionary, the
default behavior when a builder is passed multiple source
files is to make sure that the extensions of all the source
<br>
files match. If it is legal for this builder to be called
with a list of source files with different extensions, this
check can be suppressed by setting source_ext_match to <br>
None or some other non-true value. When source_ext_match is
disable, scons will use the suffix of the first specified
source file to select the appropriate action from the <br>
action dictionary.</p>

<p style="margin-top: 1em">In the following example, the
setting of source_ext_match prevents scons from exiting with
an error due to the mismatched suffixes of foo.in and
foo.extra.</p>

<p style="margin-top: 1em">b =
Builder(action={&rsquo;.in&rsquo; : &rsquo;build $SOURCES
&gt; $TARGET&rsquo;}, <br>
source_ext_match = None)</p>

<p style="margin-top: 1em">env = Environment(BUILDERS =
{&rsquo;MyBuild&rsquo;:b}) <br>
env.MyBuild(&rsquo;foo.out&rsquo;, [&rsquo;foo.in&rsquo;,
&rsquo;foo.extra&rsquo;])</p>

<p style="margin-top: 1em">env <br>
A construction environment that can be used to fetch source
code using this Builder. (Note that this environment is not
used for normal builds of normal target files, which <br>
use the environment that was used to call the Builder for
the target file.)</p>

<p style="margin-top: 1em">b = Builder(action=&quot;build
&lt; $SOURCE &gt; $TARGET&quot;) <br>
env = Environment(BUILDERS = {&rsquo;MyBuild&rsquo; : b})
<br>
env.MyBuild(&rsquo;foo.out&rsquo;, &rsquo;foo.in&rsquo;,
my_arg = &rsquo;xyzzy&rsquo;)</p>

<p style="margin-top: 1em">chdir <br>
A directory from which scons will execute the action(s)
specified for this Builder. If the chdir argument is a
string or a directory Node, scons will change to the
specified <br>
directory. If the chdir is not a string or Node and is
non-zero, then scons will change to the target file&rsquo;s
directory.</p>

<p style="margin-top: 1em">Note that scons will not
automatically modify its expansion of construction variables
like $TARGET and $SOURCE when using the chdir keyword
argument--that is, the expanded <br>
file names will still be relative to the top-level
SConstruct directory, and consequently incorrect relative to
the chdir directory. Builders created using chdir keyword
<br>
argument, will need to use construction variable expansions
like ${TARGET.file} and ${SOURCE.file} to use just the
filename portion of the targets and source.</p>

<p style="margin-top: 1em">b = Builder(action=&quot;build
&lt; ${SOURCE.file} &gt; ${TARGET.file}&quot;, <br>
chdir=1) <br>
env = Environment(BUILDERS = {&rsquo;MyBuild&rsquo; : b})
<br>
env.MyBuild(&rsquo;sub/dir/foo.out&rsquo;,
&rsquo;sub/dir/foo.in&rsquo;)</p>

<p style="margin-top: 1em">WARNING: Python only keeps one
current directory location for all of the threads. This
means that use of the chdir argument will not work with the
SCons -j option, because <br>
individual worker threads spawned by SCons interfere with
each other when they start changing directory.</p>

<p style="margin-top: 1em">Any additional keyword arguments
supplied when a Builder object is created (that is, when the
Builder() function is called) will be set in the executing
construction environment <br>
when the Builder object is called. The canonical example
here would be to set a construction variable to the
repository of a source code system.</p>

<p style="margin-top: 1em">Any additional keyword arguments
supplied when a Builder object is called will only be
associated with the target created by that particular
Builder call (and any other files <br>
built as a result of the call).</p>

<p style="margin-top: 1em">These extra keyword arguments
are passed to the following functions: command generator
functions, function Actions, and emitter functions.</p>

<p style="margin-top: 1em">Action Objects <br>
The Builder() function will turn its action keyword argument
into an appropriate internal Action object. You can also
explicitly create Action objects using the Action() global
<br>
function, which can then be passed to the Builder()
function. This can be used to configure an Action object
more flexibly, or it may simply be more efficient than
letting each <br>
separate Builder object create a separate Action when
multiple Builder objects need to do the same thing.</p>

<p style="margin-top: 1em">The Action() global function
returns an appropriate object for the action represented by
the type of the first argument:</p>

<p style="margin-top: 1em">Action <br>
If the first argument is already an Action object, the
object is simply returned.</p>

<p style="margin-top: 1em">String <br>
If the first argument is a string, a command-line Action is
returned. Note that the command-line string may be preceded
by an @ (at-sign) to suppress printing of the <br>
specified command line, or by a - (hyphen) to ignore the
exit status from the specified command:</p>

<p style="margin-top: 1em">Action(&rsquo;$CC -c -o $TARGET
$SOURCES&rsquo;)</p>

<p style="margin-top: 1em"># Doesn&rsquo;t print the line
being executed. <br>
Action(&rsquo;@build $TARGET $SOURCES&rsquo;)</p>

<p style="margin-top: 1em"># Ignores return value <br>
Action(&rsquo;-build $TARGET $SOURCES&rsquo;)</p>

<p style="margin-top: 1em">List <br>
If the first argument is a list, then a list of Action
objects is returned. An Action object is created as
necessary for each element in the list. If an element within
the <br>
list is itself a list, the internal list is the command and
arguments to be executed via the command line. This allows
white space to be enclosed in an argument by defining a <br>
command in a list within a list:</p>

<p style="margin-top: 1em">Action([[&rsquo;cc&rsquo;,
&rsquo;-c&rsquo;, &rsquo;-DWHITE SPACE&rsquo;,
&rsquo;-o&rsquo;, &rsquo;$TARGET&rsquo;,
&rsquo;$SOURCES&rsquo;]])</p>

<p style="margin-top: 1em">Function <br>
If the first argument is a Python function, a function
Action is returned. The Python function must take three
keyword arguments, target (a Node object representing the
<br>
target file), source (a Node object representing the source
file) and env (the construction environment used for
building the target file). The target and source arguments
<br>
may be lists of Node objects if there is more than one
target file or source file. The actual target and source
file name(s) may be retrieved from their Node objects via
the <br>
built-in Python str() function:</p>

<p style="margin-top: 1em">target_file_name = str(target)
<br>
source_file_names = map(lambda x: str(x), source)</p>

<p style="margin-top: 1em">The function should return 0 or
None to indicate a successful build of the target file(s).
The function may raise an exception or return a non-zero
exit status to indicate an <br>
unsuccessful build.</p>

<p style="margin-top: 1em">def build_it(target = None,
source = None, env = None): <br>
# build the target from the source <br>
return 0</p>

<p style="margin-top: 1em">a = Action(build_it)</p>

<p style="margin-top: 1em">If the action argument is not
one of the above, None is returned.</p>

<p style="margin-top: 1em">The second argument is optional
and is used to define the output which is printed when the
Action is actually performed. In the absence of this
parameter, or if it&rsquo;s an empty <br>
string, a default output depending on the type of the action
is used. For example, a command-line action will print the
executed command. The argument must be either a Python <br>
function or a string.</p>

<p style="margin-top: 1em">In the first case, it&rsquo;s a
function that returns a string to be printed to describe the
action being executed. The function may also be specified by
the strfunction= keyword <br>
argument. Like a function to build a file, this function
must take three keyword arguments: target (a Node object
representing the target file), source (a Node object <br>
representing the source file) and env (a construction
environment). The target and source arguments may be lists
of Node objects if there is more than one target file or
source <br>
file.</p>

<p style="margin-top: 1em">In the second case, you provide
the string itself. The string may also be specified by the
cmdstr= keyword argument. The string typically contains
variables, notably $TARGET(S) <br>
and $SOURCE(S), or consists of just a single variable, which
is optionally defined somewhere else. SCons itself heavily
uses the latter variant.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">def build_it(target, source,
env): <br>
# build the target from the source <br>
return 0</p>

<p style="margin-top: 1em">def string_it(target, source,
env): <br>
return &quot;building &rsquo;%s&rsquo; from
&rsquo;%s&rsquo;&quot; % (target[0], source[0])</p>

<p style="margin-top: 1em"># Use a positional argument.
<br>
f = Action(build_it, string_it) <br>
s = Action(build_it, &quot;building &rsquo;$TARGET&rsquo;
from &rsquo;$SOURCE&rsquo;&quot;)</p>

<p style="margin-top: 1em"># Alternatively, use a keyword
argument. <br>
f = Action(build_it, strfunction=string_it) <br>
s = Action(build_it, cmdstr=&quot;building
&rsquo;$TARGET&rsquo; from &rsquo;$SOURCE&rsquo;&quot;)</p>

<p style="margin-top: 1em"># You can provide a configurable
variable. <br>
l = Action(build_it, &rsquo;$STRINGIT&rsquo;)</p>

<p style="margin-top: 1em">The third and succeeding
arguments, if present, may either be a construction variable
or a list of construction variables whose values will be
included in the signature of the <br>
Action when deciding whether a target should be rebuilt
because the action changed. The variables may also be
specified by a varlist= keyword parameter; if both are
present, they <br>
are combined. This is necessary whenever you want a target
to be rebuilt when a specific construction variable changes.
This is not often needed for a string action, as the <br>
expanded variables will normally be part of the command
line, but may be needed if a Python function action uses the
value of a construction variable when generating the command
<br>
line.</p>

<p style="margin-top: 1em">def build_it(target, source,
env): <br>
# build the target from the &rsquo;XXX&rsquo; construction
variable <br>
open(target[0],
&rsquo;w&rsquo;).write(env[&rsquo;XXX&rsquo;]) <br>
return 0</p>

<p style="margin-top: 1em"># Use positional arguments. <br>
a = Action(build_it, &rsquo;$STRINGIT&rsquo;,
[&rsquo;XXX&rsquo;])</p>

<p style="margin-top: 1em"># Alternatively, use a keyword
argument. <br>
a = Action(build_it, varlist=[&rsquo;XXX&rsquo;])</p>

<p style="margin-top: 1em">The Action() global function can
be passed the following optional keyword arguments to modify
the Action object&rsquo;s behavior:</p>

<p style="margin-top: 1em">chdir The chdir keyword argument
specifies that scons will execute the action after changing
to the specified directory. If the chdir argument is a
string or a directory Node, <br>
scons will change to the specified directory. If the chdir
argument is not a string or Node and is non-zero, then scons
will change to the target file&rsquo;s directory.</p>

<p style="margin-top: 1em">Note that scons will not
automatically modify its expansion of construction variables
like $TARGET and $SOURCE when using the chdir keyword
argument--that is, the expanded file <br>
names will still be relative to the top-level SConstruct
directory, and consequently incorrect relative to the chdir
directory. Builders created using chdir keyword argument,
<br>
will need to use construction variable expansions like
${TARGET.file} and ${SOURCE.file} to use just the filename
portion of the targets and source.</p>

<p style="margin-top: 1em">a = Action(&quot;build &lt;
${SOURCE.file} &gt; ${TARGET.file}&quot;, <br>
chdir=1)</p>

<p style="margin-top: 1em">exitstatfunc The Action() global
function also takes an exitstatfunc keyword argument which
specifies a function that is passed the exit status (or
return value) from the <br>
specified action and can return an arbitrary or modified
value. This can be used, for example, to specify that an
Action object&rsquo;s return value should be ignored under
special <br>
conditions and SCons should, therefore, consider that the
action always suceeds:</p>

<p style="margin-top: 1em">def always_succeed(s): <br>
# Always return 0, which indicates success. <br>
return 0 <br>
a = Action(&quot;build &lt; ${SOURCE.file} &gt;
${TARGET.file}&quot;, <br>
exitstatfunc=always_succeed)</p>

<p style="margin-top: 1em">batch_key The batch_key keyword
argument can be used to specify that the Action can create
multiple target files by processing multiple independent
source files simultaneously. <br>
(The canonical example is &quot;batch compilation&quot; of
multiple object files by passing multiple source files to a
single invocation of a compiler such as Microsoft&rsquo;s
Visual C / C++ <br>
compiler.) If the batch_key argument is any non-False,
non-callable Python value, the configured Action object will
cause scons to collect all targets built with the Action
<br>
object and configured with the same construction environment
into single invocations of the Action object&rsquo;s command
line or function. Command lines will typically want to use
the <br>
CHANGED_SOURCES construction variable (and possibly
CHANGED_TARGETS as well) to only pass to the command line
those sources that have actually changed since their targets
were <br>
built.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">a = Action(&rsquo;build
$CHANGED_SOURCES&rsquo;, batch_key=True)</p>

<p style="margin-top: 1em">The batch_key argument may also
be a callable function that returns a key that will be used
to identify different &quot;batches&quot; of target files to
be collected for batch building. A <br>
batch_key function must take the following arguments:</p>

<p style="margin-top: 1em">action <br>
The action object.</p>

<p style="margin-top: 1em">env <br>
The construction environment configured for the target.</p>

<p style="margin-top: 1em">target <br>
The list of targets for a particular configured action.</p>

<p style="margin-top: 1em">source <br>
The list of source for a particular configured action.</p>

<p style="margin-top: 1em">The returned key should
typically be a tuple of values derived from the arguments,
using any appropriate logic to decide how multiple
invocations should be batched. For <br>
example, a batch_key function may decide to return the value
of a specific construction variable from the env argument
which will cause scons to batch-build targets with <br>
matching values of that variable, or perhaps return the id()
of the entire construction environment, in which case scons
will batch-build all targets configured with the same <br>
construction environment. Returning None indicates that the
particular target should not be part of any batched build,
but instead will be built by a separate invocation of <br>
action&rsquo;s command or function. Example:</p>

<p style="margin-top: 1em">def batch_key(action, env,
target, source): <br>
tdir = target[0].dir <br>
if tdir.name == &rsquo;special&rsquo;: <br>
# Don&rsquo;t batch-build any target <br>
# in the special/ subdirectory. <br>
return None <br>
return (id(action), id(env), tdir) <br>
a = Action(&rsquo;build $CHANGED_SOURCES&rsquo;,
batch_key=batch_key)</p>

<p style="margin-top: 1em">Miscellaneous Action Functions
<br>
scons supplies a number of functions that arrange for
various common file and directory manipulations to be
performed. These are similar in concept to &quot;tasks&quot;
in the Ant build <br>
tool, although the implementation is slightly different.
These functions do not actually perform the specified action
at the time the function is called, but instead return an
<br>
Action object that can be executed at the appropriate time.
(In Object-Oriented terminology, these are actually Action
Factory functions that return Action objects.)</p>

<p style="margin-top: 1em">In practice, there are two
natural ways that these Action Functions are intended to be
used.</p>

<p style="margin-top: 1em">First, if you need to perform
the action at the time the SConscript file is being read,
you can use the Execute global function to do so:</p>


<p style="margin-top: 1em">Execute(Touch(&rsquo;file&rsquo;))</p>

<p style="margin-top: 1em">Second, you can use these
functions to supply Actions in a list for use by the Command
method. This can allow you to perform more complicated
sequences of file manipulation <br>
without relying on platform-specific external commands:
that</p>

<p style="margin-top: 1em">env = Environment(TMPBUILD =
&rsquo;/tmp/builddir&rsquo;) <br>
env.Command(&rsquo;foo.out&rsquo;, &rsquo;foo.in&rsquo;,
<br>
[Mkdir(&rsquo;$TMPBUILD&rsquo;), <br>
Copy(&rsquo;$TMPBUILD&rsquo;, &rsquo;${SOURCE.dir}&rsquo;),
<br>
&quot;cd $TMPBUILD &amp;&amp; make&quot;, <br>
Delete(&rsquo;$TMPBUILD&rsquo;)])</p>

<p style="margin-top: 1em">Chmod(dest, mode) <br>
Returns an Action object that changes the permissions on the
specified dest file or directory to the specified mode which
can be octal or string, similar to the bash command. <br>
Examples:</p>


<p style="margin-top: 1em">Execute(Chmod(&rsquo;file&rsquo;,
0755))</p>


<p style="margin-top: 1em">env.Command(&rsquo;foo.out&rsquo;,
&rsquo;foo.in&rsquo;, <br>
[Copy(&rsquo;$TARGET&rsquo;, &rsquo;$SOURCE&rsquo;), <br>
Chmod(&rsquo;$TARGET&rsquo;, 0755)])</p>


<p style="margin-top: 1em">Execute(Chmod(&rsquo;file&rsquo;,
&quot;ugo+w&quot;))</p>


<p style="margin-top: 1em">env.Command(&rsquo;foo.out&rsquo;,
&rsquo;foo.in&rsquo;, <br>
[Copy(&rsquo;$TARGET&rsquo;, &rsquo;$SOURCE&rsquo;), <br>
Chmod(&rsquo;$TARGET&rsquo;, &quot;ugo+w&quot;)])</p>

<p style="margin-top: 1em">Copy(dest, src) <br>
Returns an Action object that will copy the src source file
or directory to the dest destination file or directory.
Examples:</p>


<p style="margin-top: 1em">Execute(Copy(&rsquo;foo.output&rsquo;,
&rsquo;foo.input&rsquo;))</p>


<p style="margin-top: 1em">env.Command(&rsquo;bar.out&rsquo;,
&rsquo;bar.in&rsquo;, <br>
Copy(&rsquo;$TARGET&rsquo;, &rsquo;$SOURCE&rsquo;))</p>

<p style="margin-top: 1em">Delete(entry, [must_exist]) <br>
Returns an Action that deletes the specified entry, which
may be a file or a directory tree. If a directory is
specified, the entire directory tree will be removed. If the
<br>
must_exist flag is set, then a Python error will be thrown
if the specified entry does not exist; the default is
must_exist=0, that is, the Action will silently do nothing
if <br>
the entry does not exist. Examples:</p>


<p style="margin-top: 1em">Execute(Delete(&rsquo;/tmp/buildroot&rsquo;))</p>


<p style="margin-top: 1em">env.Command(&rsquo;foo.out&rsquo;,
&rsquo;foo.in&rsquo;, <br>
[Delete(&rsquo;${TARGET.dir}&rsquo;), <br>
MyBuildAction])</p>


<p style="margin-top: 1em">Execute(Delete(&rsquo;file_that_must_exist&rsquo;,
must_exist=1))</p>

<p style="margin-top: 1em">Mkdir(dir) <br>
Returns an Action that creates the specified directory dir .
Examples:</p>


<p style="margin-top: 1em">Execute(Mkdir(&rsquo;/tmp/outputdir&rsquo;))</p>


<p style="margin-top: 1em">env.Command(&rsquo;foo.out&rsquo;,
&rsquo;foo.in&rsquo;, <br>
[Mkdir(&rsquo;/tmp/builddir&rsquo;), <br>
Copy(&rsquo;/tmp/builddir/foo.in&rsquo;,
&rsquo;$SOURCE&rsquo;), <br>
&quot;cd /tmp/builddir &amp;&amp; make&quot;, <br>
Copy(&rsquo;$TARGET&rsquo;,
&rsquo;/tmp/builddir/foo.out&rsquo;)])</p>

<p style="margin-top: 1em">Move(dest, src) <br>
Returns an Action that moves the specified src file or
directory to the specified dest file or directory.
Examples:</p>


<p style="margin-top: 1em">Execute(Move(&rsquo;file.destination&rsquo;,
&rsquo;file.source&rsquo;))</p>


<p style="margin-top: 1em">env.Command(&rsquo;output_file&rsquo;,
&rsquo;input_file&rsquo;, <br>
[MyBuildAction, <br>
Move(&rsquo;$TARGET&rsquo;,
&rsquo;file_created_by_MyBuildAction&rsquo;)])</p>

<p style="margin-top: 1em">Touch(file) <br>
Returns an Action that updates the modification time on the
specified file. Examples:</p>


<p style="margin-top: 1em">Execute(Touch(&rsquo;file_to_be_touched&rsquo;))</p>


<p style="margin-top: 1em">env.Command(&rsquo;marker&rsquo;,
&rsquo;input_file&rsquo;, <br>
[MyBuildAction, <br>
Touch(&rsquo;$TARGET&rsquo;)])</p>

<p style="margin-top: 1em">Variable Substitution <br>
Before executing a command, scons performs construction
variable interpolation on the strings that make up the
command line of builders. Variables are introduced by a $
prefix. <br>
Besides construction variables, scons provides the following
variables for each command execution:</p>

<p style="margin-top: 1em">CHANGED_SOURCES <br>
The file names of all sources of the build command that have
changed since the target was last built.</p>

<p style="margin-top: 1em">CHANGED_TARGETS <br>
The file names of all targets that would be built from
sources that have changed since the target was last
built.</p>

<p style="margin-top: 1em">SOURCE <br>
The file name of the source of the build command, or the
file name of the first source if multiple sources are being
built.</p>

<p style="margin-top: 1em">SOURCES <br>
The file names of the sources of the build command.</p>

<p style="margin-top: 1em">TARGET <br>
The file name of the target being built, or the file name of
the first target if multiple targets are being built.</p>

<p style="margin-top: 1em">TARGETS <br>
The file names of all targets being built.</p>

<p style="margin-top: 1em">UNCHANGED_SOURCES <br>
The file names of all sources of the build command that have
not changed since the target was last built.</p>

<p style="margin-top: 1em">UNCHANGED_TARGETS <br>
The file names of all targets that would be built from
sources that have not changed since the target was last
built.</p>

<p style="margin-top: 1em">(Note that the above variables
are reserved and may not be set in a construction
environment.)</p>

<p style="margin-top: 1em">For example, given the
construction variable CC=&rsquo;cc&rsquo;,
targets=[&rsquo;foo&rsquo;], and
sources=[&rsquo;foo.c&rsquo;, &rsquo;bar.c&rsquo;]:</p>

<p style="margin-top: 1em">action=&rsquo;$CC -c -o $TARGET
$SOURCES&rsquo;</p>

<p style="margin-top: 1em">would produce the command
line:</p>

<p style="margin-top: 1em">cc -c -o foo foo.c bar.c</p>

<p style="margin-top: 1em">Variable names may be surrounded
by curly braces ({}) to separate the name from the trailing
characters. Within the curly braces, a variable name may
have a Python slice <br>
subscript appended to select one or more items from a list.
In the previous example, the string:</p>

<p style="margin-top: 1em">${SOURCES[1]}</p>

<p style="margin-top: 1em">would produce:</p>

<p style="margin-top: 1em">bar.c</p>

<p style="margin-top: 1em">Additionally, a variable name
may have the following special modifiers appended within the
enclosing curly braces to modify the interpolated
string:</p>

<p style="margin-top: 1em">base <br>
The base path of the file name, including the directory path
but excluding any suffix.</p>

<p style="margin-top: 1em">dir <br>
The name of the directory in which the file exists.</p>

<p style="margin-top: 1em">file <br>
The file name, minus any directory portion.</p>

<p style="margin-top: 1em">filebase <br>
Just the basename of the file, minus any suffix and minus
the directory.</p>

<p style="margin-top: 1em">suffix <br>
Just the file suffix.</p>

<p style="margin-top: 1em">abspath <br>
The absolute path name of the file.</p>

<p style="margin-top: 1em">posix <br>
The POSIX form of the path, with directories separated by /
(forward slashes) not backslashes. This is sometimes
necessary on Windows systems when a path references a file
on <br>
other (POSIX) systems.</p>

<p style="margin-top: 1em">srcpath <br>
The directory and file name to the source file linked to
this file through VariantDir(). If this file isn&rsquo;t
linked, it just returns the directory and filename
unchanged.</p>

<p style="margin-top: 1em">srcdir <br>
The directory containing the source file linked to this file
through VariantDir(). If this file isn&rsquo;t linked, it
just returns the directory part of the filename.</p>

<p style="margin-top: 1em">rsrcpath <br>
The directory and file name to the source file linked to
this file through VariantDir(). If the file does not exist
locally but exists in a Repository, the path in the <br>
Repository is returned. If this file isn&rsquo;t linked, it
just returns the directory and filename unchanged.</p>

<p style="margin-top: 1em">rsrcdir <br>
The Repository directory containing the source file linked
to this file through VariantDir(). If this file isn&rsquo;t
linked, it just returns the directory part of the
filename.</p>

<p style="margin-top: 1em">For example, the specified
target will expand as follows for the corresponding
modifiers:</p>

<p style="margin-top: 1em">$TARGET =&gt; sub/dir/file.x
<br>
${TARGET.base} =&gt; sub/dir/file <br>
${TARGET.dir} =&gt; sub/dir <br>
${TARGET.file} =&gt; file.x <br>
${TARGET.filebase} =&gt; file <br>
${TARGET.suffix} =&gt; .x <br>
${TARGET.abspath} =&gt; /top/dir/sub/dir/file.x</p>


<p style="margin-top: 1em">SConscript(&rsquo;src/SConscript&rsquo;,
variant_dir=&rsquo;sub/dir&rsquo;) <br>
$SOURCE =&gt; sub/dir/file.x <br>
${SOURCE.srcpath} =&gt; src/file.x <br>
${SOURCE.srcdir} =&gt; src</p>


<p style="margin-top: 1em">Repository(&rsquo;/usr/repository&rsquo;)
<br>
$SOURCE =&gt; sub/dir/file.x <br>
${SOURCE.rsrcpath} =&gt; /usr/repository/src/file.x <br>
${SOURCE.rsrcdir} =&gt; /usr/repository/src</p>

<p style="margin-top: 1em">Note that curly braces braces
may also be used to enclose arbitrary Python code to be
evaluated. (In fact, this is how the above modifiers are
substituted, they are simply <br>
attributes of the Python objects that represent TARGET,
SOURCES, etc.) See the section &quot;Python Code
Substitution&quot; below, for more thorough examples of how
this can be used.</p>

<p style="margin-top: 1em">Lastly, a variable name may be a
callable Python function associated with a construction
variable in the environment. The function should take four
arguments: target - a list of <br>
target nodes, source - a list of source nodes, env - the
construction environment, for_signature - a Boolean value
that specifies whether the function is being called for <br>
generating a build signature. SCons will insert whatever the
called function returns into the expanded string:</p>

<p style="margin-top: 1em">def foo(target, source, env,
for_signature): <br>
return &quot;bar&quot;</p>

<p style="margin-top: 1em"># Will expand $BAR to &quot;bar
baz&quot; <br>
env=Environment(FOO=foo, BAR=&quot;$FOO baz&quot;)</p>

<p style="margin-top: 1em">You can use this feature to pass
arguments to a Python function by creating a callable class
that stores one or more arguments in an object, and then
uses them when the <br>
__call__() method is called. Note that in this case, the
entire variable expansion must be enclosed by curly braces
so that the arguments will be associated with the <br>
instantiation of the class:</p>

<p style="margin-top: 1em">class foo(object): <br>
def __init__(self, arg): <br>
self.arg = arg</p>

<p style="margin-top: 1em">def __call__(self, target,
source, env, for_signature): <br>
return self.arg + &quot; bar&quot;</p>

<p style="margin-top: 1em"># Will expand $BAR to &quot;my
argument bar baz&quot; <br>
env=Environment(FOO=foo, BAR=&quot;${FOO(&rsquo;my
argument&rsquo;)} baz&quot;)</p>

<p style="margin-top: 1em">The special pseudo-variables $(
and $) may be used to surround parts of a command line that
may change without causing a rebuild--that is, which are not
included in the signature <br>
of target files built with this command. All text between $(
and $) will be removed from the command line before it is
added to file signatures, and the $( and $) will be removed
<br>
before the command is executed. For example, the command
line:</p>

<p style="margin-top: 1em">echo Last build occurred $(
$TODAY $). &gt; $TARGET</p>

<p style="margin-top: 1em">would execute the command:</p>

<p style="margin-top: 1em">echo Last build occurred $TODAY.
&gt; $TARGET</p>

<p style="margin-top: 1em">but the command signature added
to any target files would be:</p>

<p style="margin-top: 1em">echo Last build occurred . &gt;
$TARGET</p>

<p style="margin-top: 1em">Python Code Substitution <br>
Any python code within ${-} pairs gets evaluated by python
&rsquo;eval&rsquo;, with the python globals set to the
current environment&rsquo;s set of construction variables.
So in the following <br>
case:</p>

<p style="margin-top: 1em">env[&rsquo;COND&rsquo;] = 0 <br>
env.Command(&rsquo;foo.out&rsquo;, &rsquo;foo.in&rsquo;,
<br>
&rsquo;&rsquo;&rsquo;echo ${COND==1 and &rsquo;FOO&rsquo; or
&rsquo;BAR&rsquo;} &gt; $TARGET&rsquo;&rsquo;&rsquo;)</p>

<p style="margin-top: 1em">the command executed will be
either</p>

<p style="margin-top: 1em">echo FOO &gt; foo.out</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">echo BAR &gt; foo.out</p>

<p style="margin-top: 1em">according to the current value
of env[&rsquo;COND&rsquo;] when the command is executed. The
evaluation occurs when the target is being built, not when
the SConscript is being read. So if <br>
env[&rsquo;COND&rsquo;] is changed later in the SConscript,
the final value will be used.</p>

<p style="margin-top: 1em">Here&rsquo;s a more interesting
example. Note that all of COND, FOO, and BAR are environment
variables, and their values are substituted into the final
command. FOO is a list, so its <br>
elements are interpolated separated by spaces.</p>

<p style="margin-top: 1em">env=Environment() <br>
env[&rsquo;COND&rsquo;] = 0 <br>
env[&rsquo;FOO&rsquo;] = [&rsquo;foo1&rsquo;,
&rsquo;foo2&rsquo;] <br>
env[&rsquo;BAR&rsquo;] = &rsquo;barbar&rsquo; <br>
env.Command(&rsquo;foo.out&rsquo;, &rsquo;foo.in&rsquo;,
<br>
&rsquo;echo ${COND==1 and FOO or BAR} &gt;
$TARGET&rsquo;)</p>

<p style="margin-top: 1em"># Will execute this: <br>
# echo foo1 foo2 &gt; foo.out</p>

<p style="margin-top: 1em">SCons uses the following rules
when converting construction variables into command
lines:</p>

<p style="margin-top: 1em">String <br>
When the value is a string it is interpreted as a space
delimited list of command line arguments.</p>

<p style="margin-top: 1em">List <br>
When the value is a list it is interpreted as a list of
command line arguments. Each element of the list is
converted to a string.</p>

<p style="margin-top: 1em">Other <br>
Anything that is not a list or string is converted to a
string and interpreted as a single command line
argument.</p>

<p style="margin-top: 1em">Newline <br>
Newline characters (0 delimit lines. The newline parsing is
done after all other parsing, so it is not possible for
arguments (e.g. file names) to contain embedded newline <br>
characters. This limitation will likely go away in a future
version of SCons.</p>

<p style="margin-top: 1em">Scanner Objects <br>
You can use the Scanner function to define objects to scan
new file types for implicit dependencies. The Scanner
function accepts the following arguments:</p>

<p style="margin-top: 1em">function <br>
This can be either: 1) a Python function that will process
the Node (file) and return a list of File Nodes representing
the implicit dependencies (file names) found in the <br>
contents; or: 2) a dictionary that maps keys (typically the
file suffix, but see below for more discussion) to other
Scanners that should be called.</p>

<p style="margin-top: 1em">If the argument is actually a
Python function, the function must take three or four
arguments:</p>

<p style="margin-top: 1em">def scanner_function(node, env,
path):</p>

<p style="margin-top: 1em">def scanner_function(node, env,
path, arg=None):</p>

<p style="margin-top: 1em">The node argument is the
internal SCons node representing the file. Use str(node) to
fetch the name of the file, and node.get_contents() to fetch
contents of the file. Note <br>
that the file is not guaranteed to exist before the scanner
is called, so the scanner function should check that if
there&rsquo;s any chance that the scanned file might not
exist <br>
(for example, if it&rsquo;s built from other files).</p>

<p style="margin-top: 1em">The env argument is the
construction environment for the scan. Fetch values from it
using the env.Dictionary() method.</p>

<p style="margin-top: 1em">The path argument is a tuple (or
list) of directories that can be searched for files. This
will usually be the tuple returned by the path_function
argument (see below).</p>

<p style="margin-top: 1em">The arg argument is the argument
supplied when the scanner was created, if any.</p>

<p style="margin-top: 1em">name <br>
The name of the Scanner. This is mainly used to identify the
Scanner internally.</p>

<p style="margin-top: 1em">argument <br>
An optional argument that, if specified, will be passed to
the scanner function (described above) and the path function
(specified below).</p>

<p style="margin-top: 1em">skeys <br>
An optional list that can be used to determine which scanner
should be used for a given Node. In the usual case of
scanning for file names, this argument will be a list of
<br>
suffixes for the different file types that this Scanner
knows how to scan. If the argument is a string, then it will
be expanded into a list by the current environment.</p>

<p style="margin-top: 1em">path_function <br>
A Python function that takes four or five arguments: a
construction environment, a Node for the directory
containing the SConscript file in which the first target was
<br>
defined, a list of target nodes, a list of source nodes, and
an optional argument supplied when the scanner was created.
The path_function returns a tuple of directories that <br>
can be searched for files to be returned by this Scanner
object. (Note that the FindPathDirs() function can be used
to return a ready-made path_function for a given <br>
construction variable name, instead of having to write your
own function from scratch.)</p>

<p style="margin-top: 1em">node_class <br>
The class of Node that should be returned by this Scanner
object. Any strings or other objects returned by the scanner
function that are not of this class will be run through <br>
the node_factory function.</p>

<p style="margin-top: 1em">node_factory <br>
A Python function that will take a string or other object
and turn it into the appropriate class of Node to be
returned by this Scanner object.</p>

<p style="margin-top: 1em">scan_check <br>
An optional Python function that takes two arguments, a Node
(file) and a construction environment, and returns whether
the Node should, in fact, be scanned for dependencies. <br>
This check can be used to eliminate unnecessary calls to the
scanner function when, for example, the underlying file
represented by a Node does not yet exist.</p>

<p style="margin-top: 1em">recursive <br>
An optional flag that specifies whether this scanner should
be re-invoked on the dependency files returned by the
scanner. When this flag is not set, the Node subsystem will
<br>
only invoke the scanner on the file being scanned, and not
(for example) also on the files specified by the #include
lines in the file being scanned. recursive may be a <br>
callable function, in which case it will be called with a
list of Nodes found and should return a list of Nodes that
should be scanned recursively; this can be used to select
<br>
a specific subset of Nodes for additional scanning.</p>

<p style="margin-top: 1em">Note that scons has a global
SourceFileScanner object that is used by the Object(),
SharedObject(), and StaticObject() builders to decide which
scanner should be used for <br>
different file extensions. You can using the
SourceFileScanner.add_scanner() method to add your own
Scanner object to the scons infrastructure that builds
target programs or <br>
libraries from a list of source files of different
types:</p>

<p style="margin-top: 1em">def xyz_scan(node, env, path):
<br>
contents = node.get_text_contents() <br>
# Scan the contents and return the included files.</p>

<p style="margin-top: 1em">XYZScanner =
Scanner(xyz_scan)</p>


<p style="margin-top: 1em">SourceFileScanner.add_scanner(&rsquo;.xyz&rsquo;,
XYZScanner)</p>


<p style="margin-top: 1em">env.Program(&rsquo;my_prog&rsquo;,
[&rsquo;file1.c&rsquo;, &rsquo;file2.f&rsquo;,
&rsquo;file3.xyz&rsquo;])</p>

<p style="margin-top: 1em">SYSTEM-SPECIFIC BEHAVIOR <br>
SCons and its configuration files are very portable, due
largely to its implementation in Python. There are, however,
a few portability issues waiting to trap the unwary.</p>

<p style="margin-top: 1em">.C file suffix <br>
SCons handles the upper-case .C file suffix differently,
depending on the capabilities of the underlying system. On a
case-sensitive system such as Linux or UNIX, SCons treats a
<br>
file with a .C suffix as a C++ source file. On a
case-insensitive system such as Windows, SCons treats a file
with a .C suffix as a C source file.</p>

<p style="margin-top: 1em">.F file suffix <br>
SCons handles the upper-case .F file suffix differently,
depending on the capabilities of the underlying system. On a
case-sensitive system such as Linux or UNIX, SCons treats a
<br>
file with a .F suffix as a Fortran source file that is to be
first run through the standard C preprocessor. On a
case-insensitive system such as Windows, SCons treats a file
with <br>
a .F suffix as a Fortran source file that should not be run
through the C preprocessor.</p>

<p style="margin-top: 1em">Windows: Cygwin Tools and Cygwin
Python vs. Windows Pythons <br>
Cygwin supplies a set of tools and utilities that let users
work on a Windows system using a more POSIX-like
environment. The Cygwin tools, including Cygwin Python, do
this, in <br>
part, by sharing an ability to interpret UNIX-like path
names. For example, the Cygwin tools will internally
translate a Cygwin path name like /cygdrive/c/mydir to an
equivalent <br>
Windows pathname of C:/mydir (equivalent to C:dir).</p>

<p style="margin-top: 1em">Versions of Python that are
built for native Windows execution, such as the python.org
and ActiveState versions, do not have the Cygwin path name
semantics. This means that using <br>
a native Windows version of Python to build compiled
programs using Cygwin tools (such as gcc, bison, and flex)
may yield unpredictable results. &quot;Mixing and
matching&quot; in this way <br>
can be made to work, but it requires careful attention to
the use of path names in your SConscript files.</p>

<p style="margin-top: 1em">In practice, users can sidestep
the issue by adopting the following rules: When using gcc,
use the Cygwin-supplied Python interpreter to run SCons;
when using Microsoft Visual <br>
C/C++ (or some other Windows compiler) use the python.org or
ActiveState version of Python to run SCons.</p>

<p style="margin-top: 1em">Windows: scons.bat file <br>
On Windows systems, SCons is executed via a wrapper
scons.bat file. This has (at least) two ramifications:</p>

<p style="margin-top: 1em">First, Windows command-line
users that want to use variable assignment on the command
line may have to put double quotes around the
assignments:</p>

<p style="margin-top: 1em">scons &quot;FOO=BAR&quot;
&quot;BAZ=BLEH&quot;</p>

<p style="margin-top: 1em">Second, the Cygwin shell does
not recognize this file as being the same as an scons
command issued at the command-line prompt. You can work
around this either by executing <br>
scons.bat from the Cygwin command line, or by creating a
wrapper shell script named scons .</p>

<p style="margin-top: 1em">MinGW <br>
The MinGW bin directory must be in your PATH environment
variable or the PATH variable under the ENV construction
variable for SCons to detect and use the MinGW tools. When
<br>
running under the native Windows Python interpreter, SCons
will prefer the MinGW tools over the Cygwin tools, if they
are both installed, regardless of the order of the bin <br>
directories in the PATH variable. If you have both MSVC and
MinGW installed and you want to use MinGW instead of MSVC,
then you must explicitly tell SCons to use MinGW by
passing</p>

<p style="margin-top: 1em">tools=[&rsquo;mingw&rsquo;]</p>

<p style="margin-top: 1em">to the Environment() function,
because SCons will prefer the MSVC tools over the MinGW
tools.</p>

<p style="margin-top: 1em">EXAMPLES <br>
To help you get started using SCons, this section contains a
brief overview of some common tasks.</p>

<p style="margin-top: 1em">Basic Compilation From a Single
Source File <br>
env = Environment() <br>
env.Program(target = &rsquo;foo&rsquo;, source =
&rsquo;foo.c&rsquo;)</p>

<p style="margin-top: 1em">Note: Build the file by
specifying the target as an argument (&quot;scons foo&quot;
or &quot;scons foo.exe&quot;). or by specifying a dot
(&quot;scons .&quot;).</p>

<p style="margin-top: 1em">Basic Compilation From Multiple
Source Files <br>
env = Environment() <br>
env.Program(target = &rsquo;foo&rsquo;, source =
Split(&rsquo;f1.c f2.c f3.c&rsquo;))</p>

<p style="margin-top: 1em">Setting a Compilation Flag <br>
env = Environment(CCFLAGS = &rsquo;-g&rsquo;) <br>
env.Program(target = &rsquo;foo&rsquo;, source =
&rsquo;foo.c&rsquo;)</p>

<p style="margin-top: 1em">Search The Local Directory For
.h Files <br>
Note: You do not need to set CCFLAGS to specify -I options
by hand. SCons will construct the right -I options from
CPPPATH.</p>

<p style="margin-top: 1em">env = Environment(CPPPATH =
[&rsquo;.&rsquo;]) <br>
env.Program(target = &rsquo;foo&rsquo;, source =
&rsquo;foo.c&rsquo;)</p>

<p style="margin-top: 1em">Search Multiple Directories For
.h Files <br>
env = Environment(CPPPATH = [&rsquo;include1&rsquo;,
&rsquo;include2&rsquo;]) <br>
env.Program(target = &rsquo;foo&rsquo;, source =
&rsquo;foo.c&rsquo;)</p>

<p style="margin-top: 1em">Building a Static Library <br>
env = Environment() <br>
env.StaticLibrary(target = &rsquo;foo&rsquo;, source =
Split(&rsquo;l1.c l2.c&rsquo;)) <br>
env.StaticLibrary(target = &rsquo;bar&rsquo;, source =
[&rsquo;l3.c&rsquo;, &rsquo;l4.c&rsquo;])</p>

<p style="margin-top: 1em">Building a Shared Library <br>
env = Environment() <br>
env.SharedLibrary(target = &rsquo;foo&rsquo;, source =
[&rsquo;l5.c&rsquo;, &rsquo;l6.c&rsquo;]) <br>
env.SharedLibrary(target = &rsquo;bar&rsquo;, source =
Split(&rsquo;l7.c l8.c&rsquo;))</p>

<p style="margin-top: 1em">Linking a Local Library Into a
Program <br>
env = Environment(LIBS = &rsquo;mylib&rsquo;, LIBPATH =
[&rsquo;.&rsquo;]) <br>
env.Library(target = &rsquo;mylib&rsquo;, source =
Split(&rsquo;l1.c l2.c&rsquo;)) <br>
env.Program(target = &rsquo;prog&rsquo;, source =
[&rsquo;p1.c&rsquo;, &rsquo;p2.c&rsquo;])</p>

<p style="margin-top: 1em">Defining Your Own Builder Object
<br>
Notice that when you invoke the Builder, you can leave off
the target file suffix, and SCons will add it
automatically.</p>

<p style="margin-top: 1em">bld = Builder(action =
&rsquo;pdftex &lt; $SOURCES &gt; $TARGET&rsquo; <br>
suffix = &rsquo;.pdf&rsquo;, <br>
src_suffix = &rsquo;.tex&rsquo;) <br>
env = Environment(BUILDERS = {&rsquo;PDFBuilder&rsquo; :
bld}) <br>
env.PDFBuilder(target = &rsquo;foo.pdf&rsquo;, source =
&rsquo;foo.tex&rsquo;)</p>

<p style="margin-top: 1em"># The following creates
&quot;bar.pdf&quot; from &quot;bar.tex&quot; <br>
env.PDFBuilder(target = &rsquo;bar&rsquo;, source =
&rsquo;bar&rsquo;)</p>

<p style="margin-top: 1em">Note also that the above
initialization overwrites the default Builder objects, so
the Environment created above can not be used call Builders
like env.Program(), env.Object(), <br>
env.StaticLibrary(), etc.</p>

<p style="margin-top: 1em">Adding Your Own Builder Object
to an Environment <br>
bld = Builder(action = &rsquo;pdftex &lt; $SOURCES &gt;
$TARGET&rsquo; <br>
suffix = &rsquo;.pdf&rsquo;, <br>
src_suffix = &rsquo;.tex&rsquo;) <br>
env = Environment() <br>
env.Append(BUILDERS = {&rsquo;PDFBuilder&rsquo; : bld}) <br>
env.PDFBuilder(target = &rsquo;foo.pdf&rsquo;, source =
&rsquo;foo.tex&rsquo;) <br>
env.Program(target = &rsquo;bar&rsquo;, source =
&rsquo;bar.c&rsquo;)</p>

<p style="margin-top: 1em">You also can use other Pythonic
techniques to add to the BUILDERS construction variable,
such as:</p>

<p style="margin-top: 1em">env = Environment() <br>
env[&rsquo;BUILDERS][&rsquo;PDFBuilder&rsquo;] = bld</p>

<p style="margin-top: 1em">Defining Your Own Scanner Object
<br>
The following example shows an extremely simple scanner (the
kfile_scan() function) that doesn&rsquo;t use a search path
at all and simply returns the file names present on any
include <br>
lines in the scanned file. This would implicitly assume that
all included files live in the top-level directory:</p>

<p style="margin-top: 1em">import re</p>

<p style="margin-top: 1em">include_re =
re.compile(r&rsquo;^include$&rsquo;, re.M)</p>

<p style="margin-top: 1em">def kfile_scan(node, env, path,
arg): <br>
contents = node.get_text_contents() <br>
includes = include_re.findall(contents) <br>
return env.File(includes)</p>

<p style="margin-top: 1em">kscan = Scanner(name =
&rsquo;kfile&rsquo;, <br>
function = kfile_scan, <br>
argument = None, <br>
skeys = [&rsquo;.k&rsquo;]) <br>
scanners = Environment().Dictionary(&rsquo;SCANNERS&rsquo;)
<br>
env = Environment(SCANNERS = scanners + [kscan])</p>

<p style="margin-top: 1em">env.Command(&rsquo;foo&rsquo;,
&rsquo;foo.k&rsquo;, &rsquo;kprocess &lt; $SOURCES &gt;
$TARGET&rsquo;)</p>

<p style="margin-top: 1em">bar_in =
File(&rsquo;bar.in&rsquo;) <br>
env.Command(&rsquo;bar&rsquo;, bar_in, &rsquo;kprocess
$SOURCES &gt; $TARGET&rsquo;) <br>
bar_in.target_scanner = kscan</p>

<p style="margin-top: 1em">It is important to note that you
have to return a list of File nodes from the scan function,
simple strings for the file names won&rsquo;t do. As in the
examples we are showing here, <br>
you can use the File() function of your current Environment
in order to create nodes on the fly from a sequence of file
names with relative paths.</p>

<p style="margin-top: 1em">Here is a similar but more
complete example that searches a path of directories
(specified as the MYPATH construction variable) for files
that actually exist:</p>

<p style="margin-top: 1em">import re <br>
import os <br>
include_re = re.compile(r&rsquo;^include$&rsquo;, re.M)</p>

<p style="margin-top: 1em">def my_scan(node, env, path,
arg): <br>
contents = node.get_text_contents() <br>
includes = include_re.findall(contents) <br>
if includes == []: <br>
return [] <br>
results = [] <br>
for inc in includes: <br>
for dir in path: <br>
file = str(dir) + os.sep + inc <br>
if os.path.exists(file): <br>
results.append(file) <br>
break <br>
return env.File(results)</p>

<p style="margin-top: 1em">scanner = Scanner(name =
&rsquo;myscanner&rsquo;, <br>
function = my_scan, <br>
argument = None, <br>
skeys = [&rsquo;.x&rsquo;], <br>
path_function = FindPathDirs(&rsquo;MYPATH&rsquo;) <br>
) <br>
scanners = Environment().Dictionary(&rsquo;SCANNERS&rsquo;)
<br>
env = Environment(SCANNERS = scanners + [scanner], <br>
MYPATH = [&rsquo;incs&rsquo;])</p>

<p style="margin-top: 1em">env.Command(&rsquo;foo&rsquo;,
&rsquo;foo.x&rsquo;, &rsquo;xprocess &lt; $SOURCES &gt;
$TARGET&rsquo;)</p>

<p style="margin-top: 1em">The FindPathDirs() function used
in the previous example returns a function (actually a
callable Python object) that will return a list of
directories specified in the $MYPATH <br>
construction variable. It lets SCons detect the file
incs/foo.inc , even if foo.x contains the line include
foo.inc only. If you need to customize how the search path
is derived, <br>
you would provide your own path_function argument when
creating the Scanner object, as follows:</p>

<p style="margin-top: 1em"># MYPATH is a list of
directories to search for files in <br>
def pf(env, dir, target, source, arg): <br>
top_dir = Dir(&rsquo;#&rsquo;).abspath <br>
results = [] <br>
if &rsquo;MYPATH&rsquo; in env: <br>
for p in env[&rsquo;MYPATH&rsquo;]: <br>
results.append(top_dir + os.sep + p) <br>
return results</p>

<p style="margin-top: 1em">scanner = Scanner(name =
&rsquo;myscanner&rsquo;, <br>
function = my_scan, <br>
argument = None, <br>
skeys = [&rsquo;.x&rsquo;], <br>
path_function = pf <br>
)</p>

<p style="margin-top: 1em">Creating a Hierarchical Build
<br>
Notice that the file names specified in a
subdirectory&rsquo;s SConscript file are relative to that
subdirectory.</p>

<p style="margin-top: 1em">SConstruct:</p>

<p style="margin-top: 1em">env = Environment() <br>
env.Program(target = &rsquo;foo&rsquo;, source =
&rsquo;foo.c&rsquo;)</p>


<p style="margin-top: 1em">SConscript(&rsquo;sub/SConscript&rsquo;)</p>

<p style="margin-top: 1em">sub/SConscript:</p>

<p style="margin-top: 1em">env = Environment() <br>
# Builds sub/foo from sub/foo.c <br>
env.Program(target = &rsquo;foo&rsquo;, source =
&rsquo;foo.c&rsquo;)</p>


<p style="margin-top: 1em">SConscript(&rsquo;dir/SConscript&rsquo;)</p>

<p style="margin-top: 1em">sub/dir/SConscript:</p>

<p style="margin-top: 1em">env = Environment() <br>
# Builds sub/dir/foo from sub/dir/foo.c <br>
env.Program(target = &rsquo;foo&rsquo;, source =
&rsquo;foo.c&rsquo;)</p>

<p style="margin-top: 1em">Sharing Variables Between
SConscript Files <br>
You must explicitly Export() and Import() variables that you
want to share between SConscript files.</p>

<p style="margin-top: 1em">SConstruct:</p>

<p style="margin-top: 1em">env = Environment() <br>
env.Program(target = &rsquo;foo&rsquo;, source =
&rsquo;foo.c&rsquo;)</p>

<p style="margin-top: 1em">Export(&quot;env&quot;) <br>
SConscript(&rsquo;subdirectory/SConscript&rsquo;)</p>

<p style="margin-top: 1em">subdirectory/SConscript:</p>

<p style="margin-top: 1em">Import(&quot;env&quot;) <br>
env.Program(target = &rsquo;foo&rsquo;, source =
&rsquo;foo.c&rsquo;)</p>

<p style="margin-top: 1em">Building Multiple Variants From
the Same Source <br>
Use the variant_dir keyword argument to the SConscript
function to establish one or more separate variant build
directory trees for a given source directory:</p>

<p style="margin-top: 1em">SConstruct:</p>

<p style="margin-top: 1em">cppdefines = [&rsquo;FOO&rsquo;]
<br>
Export(&quot;cppdefines&quot;) <br>
SConscript(&rsquo;src/SConscript&rsquo;,
variant_dir=&rsquo;foo&rsquo;)</p>

<p style="margin-top: 1em">cppdefines = [&rsquo;BAR&rsquo;]
<br>
Export(&quot;cppdefines&quot;) <br>
SConscript(&rsquo;src/SConscript&rsquo;,
variant_dir=&rsquo;bar&rsquo;)</p>

<p style="margin-top: 1em">src/SConscript:</p>

<p style="margin-top: 1em">Import(&quot;cppdefines&quot;)
<br>
env = Environment(CPPDEFINES = cppdefines) <br>
env.Program(target = &rsquo;src&rsquo;, source =
&rsquo;src.c&rsquo;)</p>

<p style="margin-top: 1em">Note the use of the Export()
method to set the &quot;cppdefines&quot; variable to a
different value each time we call the SConscript
function.</p>

<p style="margin-top: 1em">Hierarchical Build of Two
Libraries Linked With a Program <br>
SConstruct:</p>

<p style="margin-top: 1em">env = Environment(LIBPATH =
[&rsquo;#libA&rsquo;, &rsquo;#libB&rsquo;]) <br>
Export(&rsquo;env&rsquo;) <br>
SConscript(&rsquo;libA/SConscript&rsquo;) <br>
SConscript(&rsquo;libB/SConscript&rsquo;) <br>
SConscript(&rsquo;Main/SConscript&rsquo;)</p>

<p style="margin-top: 1em">libA/SConscript:</p>

<p style="margin-top: 1em">Import(&rsquo;env&rsquo;) <br>
env.Library(&rsquo;a&rsquo;, Split(&rsquo;a1.c a2.c
a3.c&rsquo;))</p>

<p style="margin-top: 1em">libB/SConscript:</p>

<p style="margin-top: 1em">Import(&rsquo;env&rsquo;) <br>
env.Library(&rsquo;b&rsquo;, Split(&rsquo;b1.c b2.c
b3.c&rsquo;))</p>

<p style="margin-top: 1em">Main/SConscript:</p>

<p style="margin-top: 1em">Import(&rsquo;env&rsquo;) <br>
e = env.Copy(LIBS = [&rsquo;a&rsquo;, &rsquo;b&rsquo;]) <br>
e.Program(&rsquo;foo&rsquo;, Split(&rsquo;m1.c m2.c
m3.c&rsquo;))</p>

<p style="margin-top: 1em">The &rsquo;#&rsquo; in the
LIBPATH directories specify that they&rsquo;re relative to
the top-level directory, so they don&rsquo;t turn into
&quot;Main/libA&quot; when they&rsquo;re used in
Main/SConscript.</p>

<p style="margin-top: 1em">Specifying only &rsquo;a&rsquo;
and &rsquo;b&rsquo; for the library names allows SCons to
append the appropriate library prefix and suffix for the
current platform (for example, &rsquo;liba.a&rsquo; on POSIX
<br>
systems, &rsquo;a.lib&rsquo; on Windows).</p>

<p style="margin-top: 1em">Customizing construction
variables from the command line. <br>
The following would allow the C compiler to be specified on
the command line or in the file custom.py.</p>

<p style="margin-top: 1em">vars =
Variables(&rsquo;custom.py&rsquo;) <br>
vars.Add(&rsquo;CC&rsquo;, &rsquo;The C compiler.&rsquo;)
<br>
env = Environment(variables=vars) <br>
Help(vars.GenerateHelpText(env))</p>

<p style="margin-top: 1em">The user could specify the C
compiler on the command line:</p>

<p style="margin-top: 1em">scons &quot;CC=my_cc&quot;</p>

<p style="margin-top: 1em">or in the custom.py file:</p>

<p style="margin-top: 1em">CC = &rsquo;my_cc&rsquo;</p>

<p style="margin-top: 1em">or get documentation on the
options:</p>

<p style="margin-top: 1em">$ scons -h</p>

<p style="margin-top: 1em">CC: The C compiler. <br>
default: None <br>
actual: cc</p>

<p style="margin-top: 1em">Using Microsoft Visual C++
precompiled headers <br>
Since windows.h includes everything and the kitchen sink, it
can take quite some time to compile it over and over again
for a bunch of object files, so Microsoft provides a <br>
mechanism to compile a set of headers once and then include
the previously compiled headers in any object file. This
technology is called precompiled headers. The general recipe
<br>
is to create a file named &quot;StdAfx.cpp&quot; that
includes a single header named &quot;StdAfx.h&quot;, and
then include every header you want to precompile in
&quot;StdAfx.h&quot;, and finally include <br>
&quot;StdAfx.h&quot; as the first header in all the source
files you are compiling to object files. For example:</p>

<p style="margin-top: 1em">StdAfx.h:</p>

<p style="margin-top: 1em">#include &lt;windows.h&gt; <br>
#include &lt;my_big_header.h&gt;</p>

<p style="margin-top: 1em">StdAfx.cpp:</p>

<p style="margin-top: 1em">#include &lt;StdAfx.h&gt;</p>

<p style="margin-top: 1em">Foo.cpp:</p>

<p style="margin-top: 1em">#include &lt;StdAfx.h&gt;</p>

<p style="margin-top: 1em">/* do some stuff */</p>

<p style="margin-top: 1em">Bar.cpp:</p>

<p style="margin-top: 1em">#include &lt;StdAfx.h&gt;</p>

<p style="margin-top: 1em">/* do some other stuff */</p>

<p style="margin-top: 1em">SConstruct:</p>

<p style="margin-top: 1em">env=Environment() <br>
env[&rsquo;PCHSTOP&rsquo;] = &rsquo;StdAfx.h&rsquo; <br>
env[&rsquo;PCH&rsquo;] =
env.PCH(&rsquo;StdAfx.cpp&rsquo;)[0] <br>
env.Program(&rsquo;MyApp&rsquo;, [&rsquo;Foo.cpp&rsquo;,
&rsquo;Bar.cpp&rsquo;])</p>

<p style="margin-top: 1em">For more information see the
document for the PCH builder, and the PCH and PCHSTOP
construction variables. To learn about the details of
precompiled headers consult the MSDN <br>
documentation for /Yc, /Yu, and /Yp.</p>

<p style="margin-top: 1em">Using Microsoft Visual C++
external debugging information <br>
Since including debugging information in programs and shared
libraries can cause their size to increase significantly,
Microsoft provides a mechanism for including the debugging
<br>
information in an external file called a PDB file. SCons
supports PDB files through the PDB construction
variable.</p>

<p style="margin-top: 1em">SConstruct:</p>

<p style="margin-top: 1em">env=Environment() <br>
env[&rsquo;PDB&rsquo;] = &rsquo;MyApp.pdb&rsquo; <br>
env.Program(&rsquo;MyApp&rsquo;, [&rsquo;Foo.cpp&rsquo;,
&rsquo;Bar.cpp&rsquo;])</p>

<p style="margin-top: 1em">For more information see the
document for the PDB construction variable.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
SCONS_LIB_DIR <br>
Specifies the directory that contains the SCons Python
module directory (e.g.
/home/aroach/scons-src-0.01/src/engine).</p>

<p style="margin-top: 1em">SCONSFLAGS <br>
A string of options that will be used by scons in addition
to those passed on the command line.</p>

<p style="margin-top: 1em">SEE ALSO <br>
scons User Manual, scons Design Document, scons source
code.</p>

<p style="margin-top: 1em">AUTHORS <br>
Originally: Steven Knight &lt;knight@baldmt.com&gt; and
Anthony Roach &lt;aroach@electriceyeball.com&gt; Since 2010:
The SCons Development Team &lt;scons-dev@scons.org&gt;</p>

<p style="margin-top: 1em">AUTHORS <br>
Steven Knight <br>
Author.</p>

<p style="margin-top: 1em">Steven Knight and the SCons
Development Team</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright &Acirc;&copy; 2004 - 2016 The SCons Foundation</p>

<p style="margin-top: 1em">SCons 2.5.1 version 2.5.1
&lt;pubdate&gt;2004 - 2016&lt;/pubdate&gt; SCONS(1)</p>
<hr>
</body>
</html>
