<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>srec_examples(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">srec_examples(1)</td>
    <td class="head-vol">i</td>
    <td class="head-rtitle">srec_examples(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
srec_examples - examples of how to use SRecord
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <i>srec_cat</i> command is very powerful, due to the ability to combine the
  the input filters in almost unlimited ways. This manual page describes a few
  of them.
<div class="Pp"></div>
This manual page describes how to use the various input files, input filters and
  input generators. But these are only examples, for more complete details, see
  the <i>srec_input</i>(1) manual page.
<h2 class="Ss" title="Ss" id="The_Commands_Lines_Are_Too_Long"><a class="selflink" href="#The_Commands_Lines_Are_Too_Long">The
  Commands Lines Are Too Long</a></h2>
If you are marooned on an operating system with absurdly short command line
  length limits, some of the commands which follow may be too long. You can get
  around this handicap by placing your command line in a file, say
  <i>fred.txt</i>, and then tell <i>srec_cat</i>(1) to read this file for the
  rest of its command line, like this
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat @fred.txt</div>
<div class="Pp"></div>
This also has the advantage of allowing comments, allowing you to write your
  command line options over several lines, and even indenting to make the
  command more clear. Comments start at a &#x201C; <b>#</b>&#x201D; and extend
  to the end of the line. Blank lines are ignored.
<div class="Pp"></div>
Of course, you could always upgrade to Linux, which has been sucking less for
  over -92 years now.
<h2 class="Ss" title="Ss" id="Your_Examples_Wanted"><a class="selflink" href="#Your_Examples_Wanted">Your
  Examples Wanted</a></h2>
If you have a clever way of using SRecord, or have solved a difficult problem
  with SRecord, you could contribute to this manual page, making it more useful
  for everyone. Send your example in an email to the email address at the end of
  this manual page.
<h1 class="Sh" title="Sh" id="CONVERTING_FILE_FORMATS"><a class="selflink" href="#CONVERTING_FILE_FORMATS">CONVERTING
  FILE FORMATS</a></h1>
The simplest of the things <i>srec_cat</i>(1) can do is convert from one EPROM
  file format to another. Please keep in mind, as you read this section, that
  you can do many of these things simultaneously in one command. They are only
  broken out separately to make them easier to understand.
<h2 class="Ss" title="Ss" id="Intel_to_Motorola"><a class="selflink" href="#Intel_to_Motorola">Intel
  to Motorola</a></h2>
One of the simplest examples is converting files from Intel hex format to
  Motorola S&#x2010;Record format:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat <i>intel&#x2010;file</i> -intel -o
  <i>srec&#x2010;file</i></div>
<div class="Pp"></div>
Note that the format specifier immediately follows the name of the file it is
  describing. Pick any two formats that SRecord understands, and it can convert
  between all of them. (Except the assembler, BASIC, C and FPGA outputs which
  are write only.)
<h2 class="Ss" title="Ss" id="Motorola_to_Intel"><a class="selflink" href="#Motorola_to_Intel">Motorola
  to Intel</a></h2>
Converting the other way is just as simple:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat <i>srec&#x2010;file</i> -o
  <i>intel&#x2010;file</i> -intel</div>
<div class="Pp"></div>
The default format is Motorola S&#x2010;Record format, so it does not need to be
  specified after the file name.
<h2 class="Ss" title="Ss" id="Different_Shapes_of_the_Same_Format"><a class="selflink" href="#Different_Shapes_of_the_Same_Format">Different
  Shapes of the Same Format</a></h2>
It is regrettably common that some addle&#x2010;pated EPROM programmers only
  implement a portion of the specification used to represent their hex files.
  For example, some compilers produce &#x201C;s19&#x201D; Motorola data (that
  is, S1 data records with S9 start records, 16 bit address fields) which would
  be OK except that some blockhead EPROM programmers insist on
  &#x201C;s37&#x201D; Motorola data (that is, S3 data records with S7 start
  records, 32 bit address fields).
<div class="Pp"></div>
It is possible to convert from one Motorola shape to another using the
  <b>-Address&#x2010;Length</b> option:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat short.srec -o long.srec
  -address&#x2010;length=4</div>
<div class="Pp"></div>
This command says to use four byte (32&#x2010;bit) addresses on output.
<div class="Pp"></div>
This section also applies to Intel hex files, as they, too, have the ability to
  select from a variety of address widths. To convert from one Intel shape to
  another using the same <b>-Address&#x2010;Length</b> option:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat i32.hex -o i16.hex
  -address&#x2010;length=3</div>
<div class="Pp"></div>
This command says to use &#x201C;i16hex&#x201D; 20&#x2010;bit segmented
  addresses on output. An address length of 4 is the default
  (&#x201C;i32hex&#x201D; 32&#x2010;bit linear addressing), and an address
  length of 2 would request &#x201C;i8hex&#x201D; 16&#x2010;bit addressing.
<h2 class="Ss" title="Ss" id="Line_Lengths"><a class="selflink" href="#Line_Lengths">Line
  Lengths</a></h2>
From time to time you will come across a feeble&#x2010;minded EPROM programmer
  that can't cope with long text lines, they assume that there will only ever be
  46 characters per line and barf when they see the default line lengths that
  <i>srec_cat</i>(1) writes (or worse, get a stack scribble and crash).
<div class="Pp"></div>
The Motorola S&#x2010;record format definition permits up to 255 bytes of
  payload, or lines of <i>514</i> characters, plus the line termination. All
  EPROM programmers <i>should</i> have sufficiently large line buffers to cope
  with records this big. Few do.
<div class="Pp"></div>
The -line&#x2010;length option may be used to specify the maximum line length
  (not including the newline) to be used on output. For example, 16 byte
  payloads for Motorola hex
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat long.srec -o short.s19
  -line&#x2010;length=46</div>
<div class="Pp"></div>
The line length option interacts with the address length option, so some
  tinkering to optimize for your particular situation many be necessary.
<h2 class="Ss" title="Ss" id="Output_Block_Size"><a class="selflink" href="#Output_Block_Size">Output
  Block Size</a></h2>
Every once in a while you will come across an ancient daft EPROM programmer that
  can't cope with long data records, they assume that there will only ever be at
  most 16 bytes of data per record, and barf when they see the default 32 byte
  payloads that <i>srec_cat</i>(1) writes (or worse, the buffer over&#x2010;run
  causes a tall grass walk that scribbles on your EPROM).
<div class="Pp"></div>
The Intel hex format definition permits up to 255 bytes of payload data per
  record. All EPROM programmers <i>should</i> have sufficiently large data
  buffers to cope with records this big. Good luck with that.
<div class="Pp"></div>
The -Output&#x2010;Block&#x2010;Size option may be used to specify the record
  data size to be used on output. For example, Intel hex with 16 byte payloads:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat long.srec -o short.hex -intel
  -obs=16</div>
<div class="Pp"></div>
Be careful not to put the <b>-obs</b> option between the output file name and
  the format specifier.
<h2 class="Ss" title="Ss" id="Just_the_Data,_Please"><a class="selflink" href="#Just_the_Data,_Please">Just
  the Data, Please</a></h2>
There are some bonehead EPROM programmers which can only cope with data records,
  and are unable to cope with header records or execution start address records.
  If you have this problem, the <b>-data&#x2010;only</b> option can be used to
  suppress just about everything except the data. The actual effect depends on
  the format, of course, because some don't have these features anyway.
<div class="Pp"></div>
The <b>-data&#x2010;only</b> option is short hand. There are four properties
  which may be <b>-disabled</b> or <b>-enabled</b> separately. See the
  <i>srec_cat</i>(1) man page for a description of the <b>-disabled</b> and
  <b>-enabled</b> options.
<div class="Pp"></div>
For example, your neanderthal EPROM programmer requires Motorola hex with header
  records (S0), but without data count (S5) records. Not using the
  <b>-data&#x2010;only</b> option has it barf on the data count record, but
  using the <b>-data&#x2010;only</b> option has it barf on the missing header
  record. Using the <b>-disable=data&#x2010;count</b> option would leave the
  header record intact while suppressing the data count record.
<h2 class="Ss" title="Ss" id="Data_Headers"><a class="selflink" href="#Data_Headers">Data
  Headers</a></h2>
The <i>srec_cat</i>(1) command always tries to pass through header records
  unchanged, whenever they are present. It even tries preserve them across file
  format changes, to the limit the file formats are capable of.
<div class="Pp"></div>
If there is no file header record and you would like to add one, or you wish to
  override an existing file header record, use the <b>-header</b>=<i>string</i>
  option. You will need to quote the string (to insulate it from the shell) if
  it contains spaces or shell meta&#x2010;characters.
<h2 class="Ss" title="Ss" id="Execution_Start_Addresses"><a class="selflink" href="#Execution_Start_Addresses">Execution
  Start Addresses</a></h2>
The <i>srec_cat</i>(1) command always tries to pass through execution start
  addresses (typically occurring at the end of the file), whenever they are
  present. They are adjusted along with the data records by the <b>-offset</b>
  filter. It even tries preserve them across file format changes, to the limit
  the file formats are capable of.
<div class="Pp"></div>
If there is no execution start address record and you would like to add one, or
  you wish to override an existing execution start address record, use the
  <b>-execution&#x2010;start&#x2010;address</b>= <i>number</i> option.
<div class="Pp"></div>
Please note: the execution start address is a different concept than the first
  address in memory of your data. Think of it as a &#x201C;goto&#x201D; address
  to be jumped to by the monitor when the hex load is complete. If you want to
  change where your data starts in memory, use the <b>-offset</b> filter.
<h2 class="Ss" title="Ss" id="Fixing_Checksums"><a class="selflink" href="#Fixing_Checksums">Fixing
  Checksums</a></h2>
Some embedded firmware developers are saddled with featherbrained tools which
  produce incorrect checksums, which the more vigilant models of EPROM
  programmer will not accept.
<div class="Pp"></div>
To fix the checksums on a file, use the <b>-ignore&#x2010;checksums</b> option.
  For example:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat broken.srec -ignore&#x2010;checksums
  -o fixed.srec</div>
<div class="Pp"></div>
The checksums in <i>broken.srec</i> are parsed (it is still and error if they
  are absent) but are not checked. The resulting <i>fixed.srec</i> file has
  correct checksums. The <b>-ignore&#x2010;checksums</b> option only applies to
  input.
<div class="Pp"></div>
This option may be used on any file format which has checksums, including Intel
  hex.
<h2 class="Ss" title="Ss" id="Discovering_Mystery_Formats"><a class="selflink" href="#Discovering_Mystery_Formats">Discovering
  Mystery Formats</a></h2>
See the <b>What Format Is This?</b> section, below, for how to discover and
  convert mystery EPROM load file formats.
<h1 class="Sh" title="Sh" id="BINARY_FILES"><a class="selflink" href="#BINARY_FILES">BINARY
  FILES</a></h1>
It is possible to convert to and from binary files. You can even mix binary
  files and other formats together in the same <i>srec_cat</i>(1) command.
<h2 class="Ss" title="Ss" id="Writing_Binary_Files"><a class="selflink" href="#Writing_Binary_Files">Writing
  Binary Files</a></h2>
The simplest way of reading a hex file and converting it to a binary file looks
  like this:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat fred.hex -o fred.bin -binary</div>
<div class="Pp"></div>
This reads the Motorola hex file <i>fred.srec</i> and writes it out to the
  <i>fred.bin</i> as raw binary.
<div class="Pp"></div>
Note that the data is placed into the binary file at the byte offset specified
  by the addresses in the hex file. If there are holes in the data they are
  filled with zero. This is, of course, common with linker output where the code
  is placed starting at a particular place in memory. For example, when you have
  an image that starts at 0x100000, the first 1MB of the output binary file will
  be zero.
<div class="Pp"></div>
You can automatically cancel this offset using a command like
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat fred.hex -offset &#x2212;
  -minimum&#x2010;addr fred.hex -o fred.bin</div>
<div class="Pp"></div>
The above command works by offsetting the <i>fred.hex</i> file lower in memory
  by the least address in the <i>fred.hex</i> file's data.
<div class="Pp"></div>
See also the <i>srec_binary</i>(5) man page for additional detail.
<h2 class="Ss" title="Ss" id="Reading_Binary_Files"><a class="selflink" href="#Reading_Binary_Files">Reading
  Binary Files</a></h2>
The simplest way of reading a binary file and converting it looks like this
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat fred.bin -binary -o fred.srec</div>
<div class="Pp"></div>
This reads the binary file <i>fred.bin</i> and writes all of its data back out
  again as a Motorola S&#x2010;Record file.
<div class="Pp"></div>
Often, this binary isn't exactly where you want it in the address space, because
  it is assumed to reside at address zero. If you need to move it around use the
  <b>-offset</b> filter.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat fred.bin -binary -offset 0x10000 -o
  fred.srec</div>
<div class="Pp"></div>
You also need to avoid file &#x201C;holes&#x201D; which are filled with zero.
  You can use the <b>-crop</b> filter, of you could use the <b>-unfill</b>
  filter if you don't know exactly where the data is.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat fred.bin -binary -unfill 0x00 512 -o
  fred.srec</div>
<div class="Pp"></div>
The above command removes runs of zero bytes that are 512 bytes long or longer.
  If your file contains 1GB of leading zero bytes, this is going to be slow, it
  may be better to use the <i>dd</i>(1) command to slice and dice first.
<h1 class="Sh" title="Sh" id="JOINING_FILES_TOGETHER"><a class="selflink" href="#JOINING_FILES_TOGETHER">JOINING
  FILES TOGETHER</a></h1>
The <i>srec_cat</i> command takes its name from the UNIX <i>cat</i>(1) command,
  which is short for &#x201C;catenate&#x201D; or &#x201C;to join&#x201D;. The
  <i>srec_cat</i> command joins EPROM load files together.
<h2 class="Ss" title="Ss" id="All_In_One"><a class="selflink" href="#All_In_One">All
  In One</a></h2>
Joining EPROM load files together into a single file is simple, just name as
  many files on the command line as you need:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat <i>infile1</i> <i>infile2</i> -o
  <i>outfile</i></div>
<div class="Pp"></div>
This example is all Motorola S&#x2010;Record files, because that's the default
  format. You can have multiple formats in the one command, and
  <i>srec_cat</i>(1) will still work. You don't even have to output the same
  format:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile1</i> -spectrum <i>infile2</i> -needham \
    -o  <i>outfile</i> -signetics
</pre>
</div>
<div class="Pp"></div>
These are all ancient formats, however it isn't uncommon to have to mix and
  match Intel and Motorola formats in the one project.
<h2 class="Ss" title="Ss" id="Overlaying_two_data_files"><a class="selflink" href="#Overlaying_two_data_files">Overlaying
  two data files</a></h2>
It is common to want to &#x201C;join&#x201D; two hex files together, without any
  changes of address. on the assumption neither file intersects with the other.
  This is a simple &#x201C;layers&#x201D;, it is quite common for linkers to
  output the main code, and then a whole bunch of relocation and jump
  destination, by writing a two layered files.
<div style="margin-left: 5.00ex;">
<pre>
srec_cat one.he two.hex -o three.hex
</pre>
</div>
Almost always you see an error
<div style="height: 0.25em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
srec_cat: two.srec: 49282: contradictory 0x00000000 value (previous = 0x00, this
  one = 0x80)</div>
<div style="height: 0.25em;">&#x00A0;</div>
<div class="Pp"></div>
This means that the files actually intersect, they try to set the same location.
  You can turn the error into a warning, using the
  <b>-contradictory&#x2010;bytes=warning</b> command line option. But this will
  probably generate a bazillion warnings.
<div class="Pp"></div>
The necessary step is to crop the first file, to avoid the regions the second
  file is going o be overwriting.
<div style="height: 0.25em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat                               \
    one.srec -exclude -within two.srec \
    two.srec -exclude -within one.srec \
    -o three.hex
</pre>
</div>
<div class="Pp"></div>
Depending on your linker this will have no errors (but if it wants another
  layer, more jiggery&#x2010;pokery is required).
<h2 class="Ss" title="Ss" id="Filtering_After_Joining"><a class="selflink" href="#Filtering_After_Joining">Filtering
  After Joining</a></h2>
There are times when you want to join two sets of data together, and then apply
  a filter to the joined result. To do this you use parentheses.
<div style="height: 0.25em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat                                                  \
    '('                                                   \
         <i>infile</i> -exclude 0xFFF0 0x10000                      \
        -generate 0xFFF0 0xFFF8 -repeat&#x2010;string 'Bananas ' \
    ')'                                                   \
    -length&#x2010;b&#x2010;e 0xFFF8 4                                  \
    -checksum&#x2010;neg&#x2010;b&#x2010;e 0xFFFC 4 4                          \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The above example command catenate an input file (with the generated data area
  excluded) with a constant string. This catenated input is then filtered to add
  a 4&#x2010;byte length, and a 4&#x2010;byte checksum.
<h2 class="Ss" title="Ss" id="Joining_End&#x2010;to&#x2010;End"><a class="selflink" href="#Joining_End&#x2010;to&#x2010;End">Joining
  End&#x2010;to&#x2010;End</a></h2>
All too often the address ranges in the EPROM load files will overlap. You will
  get an error if they do. If both files start from address zero, because each
  goes into a separate EPROM, you may need to use the offset filter:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile1</i> \
     <i>infile2</i> -offset 0x80000 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
Sometimes you want the two files to follow each other exactly, but you don't
  know the offset in advance:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile1</i> \
     <i>infile2</i> -offset -maximum&#x2010;addr <i>infile1</i> \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
Notice that where the was a number (0x80000) before, there is now a calculation
  (-maximum&#x2010;addr <i>infile1</i>). This is possible most places a number
  may be used (also -minimum&#x2010;addr and -range).
<h1 class="Sh" title="Sh" id="CROPPING_THE_DATA"><a class="selflink" href="#CROPPING_THE_DATA">CROPPING
  THE DATA</a></h1>
It is possible to copy an EPROM load file, selecting addresses to keep and
  addresses to discard.
<h2 class="Ss" title="Ss" id="What_To_Keep"><a class="selflink" href="#What_To_Keep">What
  To Keep</a></h2>
A common activity is to crop your data to match your EPROM location. Your linker
  may add other junk that you are not interested in, <i>e.g.</i> at the RAM
  location. In this example, there is a 1MB EPROM at the 2MB boundary:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -crop 0x200000 0x300000 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The lower bound for all address ranges is inclusive, the upper bound is
  exclusive. If you subtract them, you get the number of bytes.
<h2 class="Ss" title="Ss" id="Address_Offset"><a class="selflink" href="#Address_Offset">Address
  Offset</a></h2>
Just possibly, you have a moronic EPROM programmer, and it barfs if the EPROM
  image doesn't start at zero. To find out just where is <i>does</i> start in
  memory, use the <i>srec_info</i>(1) command:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
$  <b>srec_info example.srec</b>
Format: Motorola S&#x2010;Record
Header: extra&#x2010;whizz tool chain linker
Execution Start Address: 0x00200000
Data:   0x200000 - 0x32AAEF
$
</pre>
</div>
<div class="Pp"></div>
Rather than butcher the linker command file, just offset the addresses:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -crop 0x200000 0x300000 -offset &#x2212;0x200000 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
Note that the offset given is <i>negative</i>, it has the effect of subtracting
  that value from all addresses in the input records, to form the output record
  addresses. In this case, shifting the image back to zero.
<div class="Pp"></div>
This example also demonstrates how the input filters may be chained together:
  first the crop and then the offset, all in one command, without the need for
  temporary files.
<div class="Pp"></div>
If all you want to do is offset the data to start from address zero, this can be
  automated, so you don't have to know the minimum address in advance, by using
  <i>srec_cat</i>'s ability to calculate some things on the command line:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -offset &#x2212; -minimum&#x2010;addr <i>infile</i> \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
Note the spaces either side of the minus sign, they are mandatory.
<h2 class="Ss" title="Ss" id="What_To_Throw_Away"><a class="selflink" href="#What_To_Throw_Away">What
  To Throw Away</a></h2>
There are times when you need to exclude an small address range from an EPROM
  load file, rather than wanting to keep a small address range. The
  <b>-exclude</b> filter may be used for this purpose.
<div class="Pp"></div>
For example, if you wish to exclude the address range where the serial number of
  an embedded device is kept, say 0x20 bytes at 0x100, you would use a command
  like this:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat input.srec -exclude 0x100 0x120 -o
  output.srec</div>
<div class="Pp"></div>
The <i>output.srec</i> file will have a hole in the data at the necessary
  locations.
<div class="Pp"></div>
Note that you can have both <b>-crop</b> and <b>-exclude</b> on the same command
  line, whichever works more naturally for your situation.
<h2 class="Ss" title="Ss" id="Discontinuous_Address_Ranges"><a class="selflink" href="#Discontinuous_Address_Ranges">Discontinuous
  Address Ranges</a></h2>
Address ranges don't have to be a single range, you can build up an address
  range using more than a single pair.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -crop 0x100 0x200 0x1000 0x1200 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
This filter results in data from 0x100..0x1FF and data from 0x1000..0x1200 to
  pass through, the rest is dropped. This is is more efficient than chaining a
  <b>-crop</b> and an <b>-exclude</b> filter together.
<h1 class="Sh" title="Sh" id="MOVING_THINGS_AROUND"><a class="selflink" href="#MOVING_THINGS_AROUND">MOVING
  THINGS AROUND</a></h1>
It is also possible to change the address of data records, both forwards and
  backwards. It is also possible rearrange where data records are placed in
  memory.
<h2 class="Ss" title="Ss" id="Offset_Filter"><a class="selflink" href="#Offset_Filter">Offset
  Filter</a></h2>
The <b>-offset=</b><i>number</i> filter operates on the addresses of records. If
  the number is positive the addresses move that many bytes higher in memory,
  negative values move lower.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -crop 0x200000 0x300000 -offset &#x2212;0x200000 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The above example moves the 1MB block of data at 0x200000 down to zero (the
  offset is <i>negative</i>) and discards the rest of the data.
<h2 class="Ss" title="Ss" id="Byte_Swapping"><a class="selflink" href="#Byte_Swapping">Byte
  Swapping</a></h2>
There are times when the bytes in the data need to be swapped, converting
  between big&#x2010;endian and little&#x2010;endian data usually.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -byte&#x2010;swap 4 -o <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
This reverses bytes in 32 bit values (4 bytes). The default, if you don't supply
  a width, is to reverse bytes in 16 bit values (2 bytes). You can actually use
  any weird value you like, it doesn't even have to be a power of 2. Perhaps 64
  bits (8 bytes) may be useful one day.
<h2 class="Ss" title="Ss" id="Binary_Output"><a class="selflink" href="#Binary_Output">Binary
  Output</a></h2>
You need to watch out for binary files on output, because the holes are filled
  with zeros. Your 100kB program at the top of 32&#x2010;bit addressed memory
  will make a 4GB file. See <i>srec_binary</i>(5) for how understand and avoid
  this problem, usually with the <b>-offset</b> filter.
<h2 class="Ss" title="Ss" id="Splitting_an_Image"><a class="selflink" href="#Splitting_an_Image">Splitting
  an Image</a></h2>
If you have a 16&#x2010;bit data bus, but you are using two 8&#x2010;bit EPROMs
  to hold your firmware, you can generate the even and odd images by using the
  <b>-SPlit</b> filter. Assuming your firmware is in the <i>firmware.hex</i>
  file, use the following:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat firmware.hex -split 2 0 -o firmware.even.hex
srec_cat firmware.hex -split 2 1 -o firmware.odd.hex
</pre>
</div>
<div class="Pp"></div>
This will result in the two necessary EPROM images. Note that the output
  addresses are divided by the split multiple, so if your EPROM images are at a
  particular offset (say 0x10000, in the following example), you need to remove
  the offset, and then replace it...
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat firmware.hex \
    -offset &#x2212;0x10000 -split 2 0 \
    -offset 0x10000 -o firmware.even.hex
srec_cat firmware.hex \
    -offset &#x2212;0x10000 -split 2 1 \
    -offset 0x10000 -o firmware.odd.hex
</pre>
</div>
<div class="Pp"></div>
Note how the ability to apply multiple filters simplifies what would otherwise
  be a much longer script.
<h2 class="Ss" title="Ss" id="Striping"><a class="selflink" href="#Striping">Striping</a></h2>
A second use for the <b>-SPlit</b> filter is memory striping.
<div class="Pp"></div>
You don't have to split into byte&#x2010;wide parts, you can choose other sizes.
  It is common to want to convert 32&#x2010;bit wide data into two set of
  16&#x2010;bit wide data.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat firmware.hex -split 4 0 2 -o firmware.01.hex
srec_cat firmware.hex -split 4 2 2 -o firmware.23.hex
</pre>
</div>
<div class="Pp"></div>
This is relatively simple to understand, but you can use even wider stripes.
<div class="Pp"></div>
In this next example, the hardware requires that 512&#x2010;byte blocks
  alternate between 4 EPROMs. Generating the 4 images would be done as follows:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat firmware.hex -split 0x800 0x000 0x200 -o firmware.0.hex
srec_cat firmware.hex -split 0x800 0x200 0x200 -o firmware.1.hex
srec_cat firmware.hex -split 0x800 0x400 0x200 -o firmware.2.hex
srec_cat firmware.hex -split 0x800 0x600 0x200 -o firmware.3.hex
</pre>
</div>
<h2 class="Ss" title="Ss" id="Asymmetric_Striping"><a class="selflink" href="#Asymmetric_Striping">Asymmetric
  Striping</a></h2>
A more peculiar example of striping is the Microchip dsPIC33F microcontroller,
  that has a weird memory storage pattern and they are able to store 3 bytes in
  an address that should only contain 2 bytes. The result is a hex file that has
  zero&#x2010;filled the top byte (little&#x2010;endian), and all addresses are
  doubled from what they are in the chip. Here is an example:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
S1130000000102000405060008090A000C0D0E0098
S1130010101112001415160018191A001C1D1E00C8
S1130020202122002425260028292A002C2D2E00F8
S1130030303132003435360038393A003C3D3E0028
</pre>
</div>
<div class="Pp"></div>
To get rid of the 00 padding bytes, leaving only the 3/4 significant bytes, you
  also use the split filter, with its additional <i>width</i> argument, like
  this:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat example.srec -split 4 0 3 -o no_dross.srec
</pre>
</div>
<div class="Pp"></div>
This results in a file with the 00 padding bytes removed. It looks like this:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
S113000000010204050608090A0C0D0E1011121451
S1130010151618191A1C1D1E2021222425262829EC
S11300202A2C2D2E30313234353638393A3C3D3E87
</pre>
</div>
<div class="Pp"></div>
Notice how the addresses are 3/4 the size, as well. You can reverse this using
  the <b>-unsplit</b> and <b>-fill=0</b> filters.
<h2 class="Ss" title="Ss" id="Unsplit_ING_Images"><a class="selflink" href="#Unsplit_ING_Images">Unsplit
  ING Images</a></h2>
The unsplit filter may be used to reverse the effects of the split filter. Note
  that the address range is expanded leaving holes between the stripes. By using
  all the stripes, the complete input is reassembled, without any holes.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat -o firmware.hex \
    firmware.even.hex -unsplit 2 0 \
    firmware.odd.hex  -unsplit 2 1
</pre>
</div>
<div class="Pp"></div>
The above example reverses the previous 16&#x2010;bit data bus example. In
  general, you unsplit with the same parameters that you split with.
<h1 class="Sh" title="Sh" id="FILLING_THE_BLANKS"><a class="selflink" href="#FILLING_THE_BLANKS">FILLING
  THE BLANKS</a></h1>
Often EPROM load files will have &#x201C;holes&#x201D; in them, places where the
  compiler and linker did not put anything. For some purposes this is OK, and
  for other purposes something has to be done about the holes.
<h2 class="Ss" title="Ss" id="The_Fill_Filter"><a class="selflink" href="#The_Fill_Filter">The
  Fill Filter</a></h2>
It is possible to fill the blanks where your data does not lie. The simplest
  example of this fills the entire EPROM:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat <i>infile</i> -fill 0x00 0x200000
  0x300000 -o <i>outfile</i></div>
<div class="Pp"></div>
This example fills the holes, if any, with zeros. You must specify a range -
  with a 32&#x2010;bit address space, filling everything generates <i>huge</i>
  load files.
<div class="Pp"></div>
If you only want to fill the gaps in your data, and don't want to fill the
  entire EPROM, try:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat <i>infile</i> -fill 0x00 -over
  <i>infile</i> -o <i>outfile</i></div>
<div class="Pp"></div>
This example demonstrates the fact that wherever an address range may be
  specified, the <b>-over</b> and <b>-within</b> options may be used.
<h2 class="Ss" title="Ss" id="Unfilling_the_Blanks"><a class="selflink" href="#Unfilling_the_Blanks">Unfilling
  the Blanks</a></h2>
It is common to need to &#x201C;unfill&#x201D; an EPROM image after you read it
  out of a chip. Usually, it will have had all the holes filled with 0xFF (areas
  of the EPROM you don't program show as 0xFF when you read them back).
<div class="Pp"></div>
To get rid of all the 0xFF bytes in the data, use this filter:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat <i>infile</i> -unfill 0xFF -o
  <i>outfile</i></div>
<div class="Pp"></div>
This will get rid of <i>all</i> the 0xFF bytes, including the ones you actually
  wanted in there. There are two ways to deal with this. First, you can specify
  a minimum run length to the un&#x2010;fill:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">srec_cat <i>infile</i> -unfill 0xFF 5 -o
  <i>outfile</i></div>
<div class="Pp"></div>
This says that runs of 1 to 4 bytes of 0xFF are OK, and that a hole should only
  be created for runs of 5 or more 0xFF bytes in a row. The second method is to
  re&#x2010;fill over the intermediate gaps:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>outfile</i> -fill 0xFF -over <i>outfile</i> \
    -o  <i>outfile2</i>
</pre>
</div>
<div class="Pp"></div>
Which method you choose depends on your needs, and the shape of the data in your
  EPROM. You may need to combine both techniques.
<h2 class="Ss" title="Ss" id="Address_Range_Padding"><a class="selflink" href="#Address_Range_Padding">Address
  Range Padding</a></h2>
Some data formats are 16 bits wide, and automatically fill with 0xFF bytes if it
  is necessary to fill out the other half of a word which is not in the data. If
  you need to fill with a different value, you can use a command like this:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -fill 0x0A \
    -within  <i>infile</i> -range&#x2010;padding 2 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
This gives the fill filter an address range calculated from details of the input
  file. The address range is all the address ranges covered by data in the
  <i>infile</i>, extended downwards (if necessary) at the start of each
  sub&#x2010;range to a 2 byte multiple and extended upwards (if necessary) at
  the end of each sub&#x2010;range to a 2 byte multiple. This also works for
  larger multiples, like 1kB page boundaries of flash chips. This address range
  padding works anywhere an address range is required.
<h2 class="Ss" title="Ss" id="Fill_with_Copyright"><a class="selflink" href="#Fill_with_Copyright">Fill
  with Copyright</a></h2>
It is possible to fill unused portions of your EPROM with a repeating copyright
  message. Anyone trying to reverse engineer your EPROMs is going to see the
  copyright notice in their hex editor.
<div class="Pp"></div>
This is accomplished with two input sources, one from a data file, and one which
  is generated on&#x2010;the&#x2010;fly.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> \
    -generate '(' 0 0x100000 -minus -within  <i>infile</i> ')' \
        -repeat&#x2010;string 'Copyright (C) 1812 Tchaikovsky.  ' \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
Notice the address range for the data generation: it takes the address range of
  your EPROM, in this case 1MB starting from 0, and subtracts from it the
  address ranges used by the input file.
<div class="Pp"></div>
If you want to script this with the current year (because 1812 is a bit out of
  date) use the shell's output substitution (back ticks) ability:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> \
    -generate '(' 0 0x100000 -minus -within  <i>infile</i> ')' \
        -repeat&#x2010;string &quot;Copyright (C) `date +%Y` Tchaikovsky.  &quot; \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The string specified is repeated over and over again, until it has filled all
  the holes.
<h2 class="Ss" title="Ss" id="Obfuscating_with_Noise"><a class="selflink" href="#Obfuscating_with_Noise">Obfuscating
  with Noise</a></h2>
Sometimes you want to fill your EPROM images with noise, to conceal where the
  real data stops and starts. You can do this with the
  <b>-random&#x2010;fill</b> filter.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -random&#x2010;fill 0x200000 0x300000 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
It works just like the <b>-fill</b> filter, but uses random numbers instead of a
  constant byte value.
<h2 class="Ss" title="Ss" id="Fill_With_16&#x2010;bit_Words"><a class="selflink" href="#Fill_With_16&#x2010;bit_Words">Fill
  With 16&#x2010;bit Words</a></h2>
When filling the image with a constant byte value doesn't work, and you need a
  constant 16&#x2010;bit word value instead, use the <b>-repeat&#x2010;data</b>
  generator, which takes an arbitrarily long sequence of bytes to use as the
  fill pattern:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> \
    -generator '(' 0x200000 0x300000 -minus -within  <i>infile</i> ')' \
        -repeat&#x2010;data 0x1B 0x08 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
Notice how the generator's address range once again avoids the address ranges
  occupied by the <i>infile</i>'s data. You have to get the endian&#x2010;ness
  right yourself.
<h1 class="Sh" title="Sh" id="INSERTING_CONSTANT_DATA"><a class="selflink" href="#INSERTING_CONSTANT_DATA">INSERTING
  CONSTANT DATA</a></h1>
From time to time you will want to insert constant data, or data not produced by
  your compiler or assembler, into your EPROM load images.
<h2 class="Ss" title="Ss" id="Binary_Means_Literal"><a class="selflink" href="#Binary_Means_Literal">Binary
  Means Literal</a></h2>
One simple way is to have the desired information in a file. To insert the
  file's contents literally, with no format interpretation, use the
  <i>binary</i> input format:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -binary -o <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
It will probably be necessary to use an <i>offset</i> filter to move the data to
  where you actually want it within the image:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -binary -offset 0x1234 -o <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
It is also possible to use the standard input as a data source, which lends
  itself to being scripted. For example, to insert the current date and time
  into an EPROM load file, you could use a pipe:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
date | srec_cat - -bin -offset 0xFFE3 -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The special file name &#x201C;-&#x201D; means to read from the standard input.
  The output of the <i>date</i> command is always 29 characters long, and the
  offset shown will place it at the top of a 64KB EPROM image.
<h2 class="Ss" title="Ss" id="Repeating_Once"><a class="selflink" href="#Repeating_Once">Repeating
  Once</a></h2>
The <b>Fill with Copyright</b> section, above, shows how to repeat a string over
  and over. We can use a single repeat to insert a string just once.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat -generate 0xFFE3 0x10000 -repeat&#x2010;string &quot;`date`&quot; \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
Notice how the address range for the data generation exactly matches the length
  of the <i>date</i>(1) output size. You can, of course, add your input file to
  the above <i>srec_cat</i>(1) command to catenate your EPROM image together
  with the date and time.
<h2 class="Ss" title="Ss" id="Inserting_A_Long"><a class="selflink" href="#Inserting_A_Long">Inserting
  A Long</a></h2>
Another possibility is to add the Subversion commit number to your EPROM image.
  In this example, we are inserting it a a 4&#x2010;byte little&#x2010;endian
  value at address 0x0008. The Subversion commit number is in the
  <i>$version</i> shell variable in this example:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat -generate 0x0008 0x000C -constant&#x2010;l&#x2010;e $version 4 \
     <i>infile</i> -exclude 0x0008 0x000C \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
Note that we use a filter to ensure there is a hole in the input where the
  version number goes, just in case the linker put something there.
<h1 class="Sh" title="Sh" id="DATA_ABOUT_THE_DATA"><a class="selflink" href="#DATA_ABOUT_THE_DATA">DATA
  ABOUT THE DATA</a></h1>
It is possible to add a variety of data about the data to the output.
<h2 class="Ss" title="Ss" id="Checksums"><a class="selflink" href="#Checksums">Checksums</a></h2>
The <b>-checksum&#x2010;negative&#x2010;big&#x2010;endian</b> filter may be used
  to sum the data, and then insert the negative of the sum into the data. This
  has the effect of summing to zero when the checksum itself is summed across,
  provided the sum width matches the inserted value width.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> \
        -crop 0 0xFFFFFC \
        -random&#x2010;fill 0 0xFFFFFC \
        -checksum&#x2010;neg&#x2010;b&#x2010;e 0xFFFFFC 4 4 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
In this example, we have an EPROM in the lowest megabyte of memory. The -crop
  filter ensures we are only summing the data within the EPROM, and not anywhere
  else. The -random&#x2010;fill filter fills any holes left in the data with
  random values. Finally, the -checksum&#x2010;neg&#x2010;b&#x2010;e filter
  inserts a 32 bit (4 byte) checksum in big&#x2010;endian format in the last 4
  bytes of the EPROM image. Naturally, there is a little&#x2010;endian version
  of this filter as well.
<div class="Pp"></div>
Your embedded code can check the EPROM using C code similar to the following:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
unsigned long *begin = (unsigned long *)0;
unsigned long *end = (unsigned long *)0x100000;
unsigned long sum = 0;
while (begin &lt; end)
    sum += *begin++;
if (sum != 0)
{
     <i>Oops</i>
}
</pre>
</div>
<div class="Pp"></div>
The <b>-checksum&#x2010;bitnot&#x2010;big&#x2010;endian</b> filter is similar,
  except that summing over the checksum should yield a value of
  all&#x2010;one&#x2010;bits (&#x2212;1). For example, using shorts rather than
  longs:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> \
        -crop 0 0xFFFFFE \
        -fill 0xCC 0x00000 0xFFFFFE \
        -checksum&#x2010;neg&#x2010;b&#x2010;e 0xFFFFFE 2 2 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
Assuming you chose the correct endian&#x2010;ness filter, your embedded code can
  check the EPROM using C code similar to the following:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
unsigned short *begin = (unsigned short *)0;
unsigned short *end = (unsigned short *)0x100000;
unsigned short sum = 0;
while (begin &lt; end)
    sum += *begin++;
if (sum != 0xFFFF)
{
     <i>Oops</i>
}
</pre>
</div>
<div class="Pp"></div>
There is also a <b>-checksum&#x2010;positive&#x2010;b&#x2010;e</b> filter, and a
  matching little&#x2010;endian filter, which inserts the simple sum, and which
  would be checked in C using an equality test.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> \
        -crop 0 0xFFFFFF \
        -fill 0x00 0x00000 0xFFFFFF \
        -checksum&#x2010;neg&#x2010;b&#x2010;e 0xFFFFFF 1 1 \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
Assuming you chose the correct endian&#x2010;ness filter, your embedded code can
  check the EPROM using C code similar to the following:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
unsigned char *begin = (unsigned char *)0;
unsigned char *end = (unsigned char *)0xFFFFF;
unsigned char sum = 0;
while (begin &lt; end)
    sum += *begin++;
if (sum != *end)
{
     <i>Oops</i>
}
</pre>
</div>
<div class="Pp"></div>
In the 8&#x2010;bit case, it doesn't matter whether you use the
  big&#x2010;endian or little&#x2010;endian filter.
<h2 class="Ss" title="Ss" id="Quick_Hex&#x2010;Dump"><a class="selflink" href="#Quick_Hex&#x2010;Dump">Quick
  Hex&#x2010;Dump</a></h2>
You can look at the checksum of your data, by using the
  &#x201C;hex&#x2010;dump&#x201D; output format. This is useful for looking at
  calculated values, or for debugging an <i>srec_cat</i>(1) command before
  immortalizing it in a script.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i>                        \
        -crop 0 0x10000             \
        -fill 0xFF 0x0000 0x10000   \
        -checksum&#x2010;neg&#x2010;b&#x2010;e 0x10000 4 \
        -crop 0x10000 0x10004       \
    -o - -hex&#x2010;dump
</pre>
</div>
<div class="Pp"></div>
This command reads in the file, checksums the data and places the checksum at
  0x10000, crops the result to contain only the checksum, and then prints the
  checksum on the standard output in a classical hexadecimal dump format. The
  special file name &#x201C;-&#x201D; means &#x201C;the standard output&#x201D;
  in this context.
<h2 class="Ss" title="Ss" id="Cyclic_Redundancy_Checks"><a class="selflink" href="#Cyclic_Redundancy_Checks">Cyclic
  Redundancy Checks</a></h2>
The simple additive checksums have a number of theoretical limitations, to do
  with errors they can and can't detect. The CRC methods have fewer problems.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i>                        \
        -crop 0 0xFFFFFC            \
        -fill 0x00 0x00000 0xFFFFFC \
        -crc32&#x2010;b&#x2010;e 0xFFFFFC         \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
In the above example, we have an EPROM in the lowest megabyte of memory. The
  <b>-crop</b> filter ensures we are only summing the data within the EPROM, and
  not anywhere else. The <b>-fill</b> filter fills any holes left in the data.
  Finally, the <b>-checksum&#x2010;neg&#x2010;b&#x2010;e</b> filter inserts a 32
  bit (4 byte) checksum in big&#x2010;endian format in the last 4 bytes of the
  EPROM image. Naturally, there is a little&#x2010;endian version of this filter
  as well.
<div class="Pp"></div>
The checksum is calculated using the industry standard 32&#x2010;bit CRC.
  Because SRecord is open source, you can always read the source code to see how
  it works. There are many non&#x2010;GPL versions of this code available on the
  Internet, and suitable for embedding in proprietary firmware.
<div class="Pp"></div>
There is also a 16&#x2010;bit CRC available.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i>                        \
        -crop 0 0xFFFFFE            \
        -fill 0x00 0x00000 0xFFFFFE \
        -crc16&#x2010;b&#x2010;e 0xFFFFFE         \
    -o  <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The checksum is calculated using the CCITT formula. Because SRecord is open
  source, you can always read the source code to see how it works. There are
  many non&#x2010;GPL version of this code available on the Internet, and
  suitable for embedding in proprietary firmware.
<div class="Pp"></div>
You can look at the CRC of your data, by using the
  &#x201C;hex&#x2010;dump&#x201D; output format.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i>                      \
        -crop 0 0x10000           \
        -fill 0xFF 0x0000 0x10000 \
        -crc16&#x2010;b&#x2010;e 0x10000        \
        -crop 0x10000 0x10002     \
    -o - -hex&#x2010;dump
</pre>
</div>
<div class="Pp"></div>
This command reads in the file, calculates the CRC of the data and places the
  CRC at 0x10000, crops the result to contain only the CRC, and then prints the
  checksum on the standard output in a classical hexadecimal dump format.
<h2 class="Ss" title="Ss" id="Where_Is_My_Data?"><a class="selflink" href="#Where_Is_My_Data?">Where
  Is My Data?</a></h2>
There are several properties of your EPROM image that you may wish to insert
  into the data.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -minimum&#x2010;b&#x2010;e 0xFFFE 2 -o <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The above example inserts the minimum address of the data ( <i>low</i>
  <i>water</i>) into the data, as two bytes in big&#x2010;endian order at
  address 0xFFFE. This includes the minimum itself. If the data already contains
  bytes at the given address, you need to use an exclude filter. The number of
  bytes defaults to 4.
<div class="Pp"></div>
There is also a <b>-minimum&#x2010;l&#x2010;e</b> filter for inserting
  little&#x2010;endian values, and two more filters called
  <b>-exclusive&#x2010;minimum&#x2010;b&#x2010;e</b> and
  <b>-exclusive&#x2010;minimum&#x2010;l&#x2010;e</b> that do not include the
  minimum itself in the calculation of the minimum data address.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -maximum&#x2010;b&#x2010;e 0xFFFFFC 4 -o <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The above example inserts the maximum address of the data ( <i>high water +
  1</i>, just like address ranges) into the data, as four bytes in
  big&#x2010;endian order at address 0xFFFFFC. This includes the maximum itself.
  If the data already contains bytes at the given address, you need to use an
  <b>-exclude</b> filter. The number of bytes defaults to 4.
<div class="Pp"></div>
There is also a <b>-maximum&#x2010;l&#x2010;e</b> filter for inserting
  little&#x2010;endian values, and two more filters called
  <b>-exclusive&#x2010;maximum&#x2010;b&#x2010;e</b> and
  <b>-exclusive&#x2010;maximum&#x2010;l&#x2010;e</b> that do not include the
  maximum itself in the calculation of the maximum data address.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -length&#x2010;b&#x2010;e 0xFFFFFC 4 -o <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The above example inserts the length of the data ( <i>high water</i> + 1
  &#x2212; <i>low water</i>) into the data, as four bytes in big&#x2010;endian
  order at address 0xFFFFFC. This includes the length itself. If the data
  already contains bytes at the length location, you need to use an
  <b>-exclude</b> filter. The number of bytes defaults to 4.
<div class="Pp"></div>
There is also a <b>-length&#x2010;l&#x2010;e</b> filter for inserting a
  little&#x2010;endian length, and the
  <b>-exclusive&#x2010;length&#x2010;b&#x2010;e</b> and
  <b>-exclusive&#x2010;length&#x2010;l&#x2010;e</b> filters that do not include
  the length itself in the calculation.
<h2 class="Ss" title="Ss" id="What_Format_Is_This?"><a class="selflink" href="#What_Format_Is_This?">What
  Format Is This?</a></h2>
You can obtain a variety of information about an EPROM load file by using the
  <i>srec_info</i>(1) command. For example:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
$  <b>srec_info example.srec</b>
Format: Motorola S&#x2010;Record
Header: &quot;http://srecord.sourceforge.net/&quot;
Execution Start Address: 00000000
Data:   0000 - 0122
        0456 - 0FFF
$
</pre>
</div>
<div class="Pp"></div>
This example shows that the file is a Motorola S&#x2010;Record. The text in the
  file header is printed, along with the execution start address. The final
  section shows the address ranges containing data (the upper bound of each
  subrange is <i>in</i>clusive, rather than the <i>ex</i>clusive form used on
  the command line.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
$  <b>srec_info some&#x2010;weird&#x2010;file.hex -guess</b>
Format: Signetics
Data:   0000 - 0122
        0456 - 0FFF
$
</pre>
</div>
<div class="Pp"></div>
The above example guesses the EPROM load file format. It isn't infallible but it
  usually gets it right. You can use <b>-guess</b> anywhere you would give an
  explicit format, but it tends to be slower and for that reason is not
  recommended. Also, for automated build systems, you want hard errors as early
  as possible; if a file isn't in the expected format, you want it to barf.
<h1 class="Sh" title="Sh" id="MANGLING_THE_DATA"><a class="selflink" href="#MANGLING_THE_DATA">MANGLING
  THE DATA</a></h1>
It is possible to change the values of the data bytes in several ways.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -and 0xF0 -o <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The above example performs a bit&#x2010;wise AND of the data bytes with the 0xF0
  mask. The addresses of records are unchanged. I can't actually think of a use
  for this filter.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -or 0x0F -o <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The above example performs a bit&#x2010;wise OR of the data bytes with the 0x0F
  bits. The addresses of records are unchanged. I can't actually think of a use
  for this filter.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -xor 0xA5 -o <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The above example performs a bit&#x2010;wise exclusive OR of the data bytes with
  the 0xA5 bits. The addresses of records are unchanged. You could use this to
  obfuscate the contents of your EPROM.
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
srec_cat  <i>infile</i> -not -o <i>outfile</i>
</pre>
</div>
<div class="Pp"></div>
The above example performs a bit&#x2010;wise NOT of the data bytes. The
  addresses of records are unchanged. Security by obscurity?
<div>&#x00A0;</div>
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<i>srec_cat</i> version 1.64
<div>&#x00A0;</div>
Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
  2009, 2010, 2011, 2012, 2013, 2014 Peter Miller
<div>&#x00A0;</div>
<div class="Pp"></div>
The <i>srec_cat</i> program comes with ABSOLUTELY NO WARRANTY; for details use
  the ' <i>srec_cat -VERSion License</i>' command. This is free software and you
  are welcome to redistribute it under certain conditions; for details use the '
  <i>srec_cat -VERSion License</i>' command.
<div>&#x00A0;</div>
<h1 class="Sh" title="Sh" id="MAINTAINER"><a class="selflink" href="#MAINTAINER">MAINTAINER</a></h1>
<table class="tbl">
  <colgroup>
    <col style="width: 14.00ex;"/>
    <col style="width: 11.00ex;"/>
    <col style="width: 26.00ex;"/>
  </colgroup>
  <tr>
    <td>Scott Finneran</td>
    <td>E&#x2010;Mail:</td>
    <td>scottfinneran@yahoo.com.au</td>
  </tr>
  <tr>
    <td>Peter Miller</td>
    <td>E&#x2010;Mail:</td>
    <td>pmiller@opensource.org.au</td>
  </tr>
</table>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">SRecord</td>
    <td class="foot-os">Reference Manual</td>
  </tr>
</table>
</body>
</html>
