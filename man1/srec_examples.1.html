<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:38:57 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>srec_examples(1) i srec_examples(1)</p>

<p style="margin-top: 1em">NAME <br>
srec_examples - examples of how to use SRecord</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The srec_cat command is very powerful, due to the ability to
combine the the input filters in almost unlimited ways. This
manual page describes a few of them.</p>

<p style="margin-top: 1em">This manual page describes how
to use the various input files, input filters and input
generators. But these are only examples, for more complete
details, see the srec_input(1) <br>
manual page.</p>

<p style="margin-top: 1em">The Commands Lines Are Too Long
<br>
If you are marooned on an operating system with absurdly
short command line length limits, some of the commands which
follow may be too long. You can get around this handicap by
<br>
placing your command line in a file, say fred.txt, and then
tell srec_cat(1) to read this file for the rest of its
command line, like this</p>

<p style="margin-top: 1em">srec_cat @fred.txt</p>

<p style="margin-top: 1em">This also has the advantage of
allowing comments, allowing you to write your command line
options over several lines, and even indenting to make the
command more clear. Comments <br>
start at a &acirc;#&acirc; and extend to the end of the
line. Blank lines are ignored.</p>

<p style="margin-top: 1em">Of course, you could always
upgrade to Linux, which has been sucking less for over 25
years now.</p>

<p style="margin-top: 1em">Your Examples Wanted <br>
If you have a clever way of using SRecord, or have solved a
difficult problem with SRecord, you could contribute to this
manual page, making it more useful for everyone. Send <br>
your example in an email to the email address at the end of
this manual page.</p>

<p style="margin-top: 1em">CONVERTING FILE FORMATS <br>
The simplest of the things srec_cat(1) can do is convert
from one EPROM file format to another. Please keep in mind,
as you read this section, that you can do many of these <br>
things simultaneously in one command. They are only broken
out separately to make them easier to understand.</p>

<p style="margin-top: 1em">Intel to Motorola <br>
One of the simplest examples is converting files from Intel
hex format to Motorola S&acirc;Record format:</p>

<p style="margin-top: 1em">srec_cat intel&acirc;file -intel
-o srec&acirc;file</p>

<p style="margin-top: 1em">Note that the format specifier
immediately follows the name of the file it is describing.
Pick any two formats that SRecord understands, and it can
convert between all of them. <br>
(Except the assembler, BASIC, C and FPGA outputs which are
write only.)</p>

<p style="margin-top: 1em">Motorola to Intel <br>
Converting the other way is just as simple:</p>

<p style="margin-top: 1em">srec_cat srec&acirc;file -o
intel&acirc;file -intel</p>

<p style="margin-top: 1em">The default format is Motorola
S&acirc;Record format, so it does not need to be specified
after the file name.</p>

<p style="margin-top: 1em">Different Shapes of the Same
Format <br>
It is regrettably common that some addle&acirc;pated EPROM
programmers only implement a portion of the specification
used to represent their hex files. For example, some
compilers <br>
produce &acirc;s19&acirc; Motorola data (that is, S1 data
records with S9 start records, 16 bit address fields) which
would be OK except that some blockhead EPROM programmers
insist on &acirc;s37&acirc; <br>
Motorola data (that is, S3 data records with S7 start
records, 32 bit address fields).</p>

<p style="margin-top: 1em">It is possible to convert from
one Motorola shape to another using the
-Address&acirc;Length option:</p>

<p style="margin-top: 1em">srec_cat short.srec -o long.srec
-address&acirc;length=4</p>

<p style="margin-top: 1em">This command says to use four
byte (32&acirc;bit) addresses on output.</p>

<p style="margin-top: 1em">This section also applies to
Intel hex files, as they, too, have the ability to select
from a variety of address widths. To convert from one Intel
shape to another using the <br>
same -Address&acirc;Length option:</p>

<p style="margin-top: 1em">srec_cat i32.hex -o i16.hex
-address&acirc;length=3</p>

<p style="margin-top: 1em">This command says to use
&acirc;i16hex&acirc; 20&acirc;bit segmented addresses on
output. An address length of 4 is the default
(&acirc;i32hex&acirc; 32&acirc;bit linear addressing), and
an address length of 2 <br>
would request &acirc;i8hex&acirc; 16&acirc;bit
addressing.</p>

<p style="margin-top: 1em">Line Lengths <br>
From time to time you will come across a feeble&acirc;minded
EPROM programmer that can&rsquo;t cope with long text lines,
they assume that there will only ever be 46 characters per
line and <br>
barf when they see the default line lengths that srec_cat(1)
writes (or worse, get a stack scribble and crash).</p>

<p style="margin-top: 1em">The Motorola S&acirc;record
format definition permits up to 255 bytes of payload, or
lines of 514 characters, plus the line termination. All
EPROM programmers should have sufficiently <br>
large line buffers to cope with records this big. Few
do.</p>

<p style="margin-top: 1em">The -line&acirc;length option
may be used to specify the maximum line length (not
including the newline) to be used on output. For example, 16
byte payloads for Motorola hex</p>

<p style="margin-top: 1em">srec_cat long.srec -o short.s19
-line&acirc;length=46</p>

<p style="margin-top: 1em">The line length option interacts
with the address length option, so some tinkering to
optimize for your particular situation many be
necessary.</p>

<p style="margin-top: 1em">Output Block Size <br>
Every once in a while you will come across an ancient daft
EPROM programmer that can&rsquo;t cope with long data
records, they assume that there will only ever be at most 16
bytes of <br>
data per record, and barf when they see the default 32 byte
payloads that srec_cat(1) writes (or worse, the buffer
over&acirc;run causes a tall grass walk that scribbles on
your <br>
EPROM).</p>

<p style="margin-top: 1em">The Intel hex format definition
permits up to 255 bytes of payload data per record. All
EPROM programmers should have sufficiently large data
buffers to cope with records this <br>
big. Good luck with that.</p>

<p style="margin-top: 1em">The
-Output&acirc;Block&acirc;Size option may be used to specify
the record data size to be used on output. For example,
Intel hex with 16 byte payloads:</p>

<p style="margin-top: 1em">srec_cat long.srec -o short.hex
-intel -obs=16</p>

<p style="margin-top: 1em">Be careful not to put the -obs
option between the output file name and the format
specifier.</p>

<p style="margin-top: 1em">Just the Data, Please <br>
There are some bonehead EPROM programmers which can only
cope with data records, and are unable to cope with header
records or execution start address records. If you have this
<br>
problem, the -data&acirc;only option can be used to suppress
just about everything except the data. The actual effect
depends on the format, of course, because some don&rsquo;t
have these <br>
features anyway.</p>

<p style="margin-top: 1em">The -data&acirc;only option is
short hand. There are four properties which may be -disabled
or -enabled separately. See the srec_cat(1) man page for a
description of the -disabled <br>
and -enabled options.</p>

<p style="margin-top: 1em">For example, your neanderthal
EPROM programmer requires Motorola hex with header records
(S0), but without data count (S5) records. Not using the
-data&acirc;only option has it barf <br>
on the data count record, but using the -data&acirc;only
option has it barf on the missing header record. Using the
-disable=data&acirc;count option would leave the header
record intact <br>
while suppressing the data count record.</p>

<p style="margin-top: 1em">Data Headers <br>
The srec_cat(1) command always tries to pass through header
records unchanged, whenever they are present. It even tries
preserve them across file format changes, to the limit <br>
the file formats are capable of.</p>

<p style="margin-top: 1em">If there is no file header
record and you would like to add one, or you wish to
override an existing file header record, use the
-header=string option. You will need to quote <br>
the string (to insulate it from the shell) if it contains
spaces or shell meta&acirc;characters.</p>

<p style="margin-top: 1em">Execution Start Addresses <br>
The srec_cat(1) command always tries to pass through
execution start addresses (typically occurring at the end of
the file), whenever they are present. They are adjusted
along <br>
with the data records by the -offset filter. It even tries
preserve them across file format changes, to the limit the
file formats are capable of.</p>

<p style="margin-top: 1em">If there is no execution start
address record and you would like to add one, or you wish to
override an existing execution start address record, use the
-execution&acirc;start&acirc; <br>
address=number option.</p>

<p style="margin-top: 1em">Please note: the execution start
address is a different concept than the first address in
memory of your data. Think of it as a &acirc;goto&acirc;
address to be jumped to by the monitor <br>
when the hex load is complete. If you want to change where
your data starts in memory, use the -offset filter.</p>

<p style="margin-top: 1em">Fixing Checksums <br>
Some embedded firmware developers are saddled with
featherbrained tools which produce incorrect checksums,
which the more vigilant models of EPROM programmer will not
accept.</p>

<p style="margin-top: 1em">To fix the checksums on a file,
use the -ignore&acirc;checksums option. For example:</p>

<p style="margin-top: 1em">srec_cat broken.srec
-ignore&acirc;checksums -o fixed.srec</p>

<p style="margin-top: 1em">The checksums in broken.srec are
parsed (it is still and error if they are absent) but are
not checked. The resulting fixed.srec file has correct
checksums. The -ignore&acirc;check&acirc; <br>
sums option only applies to input.</p>

<p style="margin-top: 1em">This option may be used on any
file format which has checksums, including Intel hex.</p>

<p style="margin-top: 1em">Discovering Mystery Formats <br>
See the What Format Is This? section, below, for how to
discover and convert mystery EPROM load file formats.</p>

<p style="margin-top: 1em">BINARY FILES <br>
It is possible to convert to and from binary files. You can
even mix binary files and other formats together in the same
srec_cat(1) command.</p>

<p style="margin-top: 1em">Writing Binary Files <br>
The simplest way of reading a hex file and converting it to
a binary file looks like this:</p>

<p style="margin-top: 1em">srec_cat fred.hex -o fred.bin
-binary</p>

<p style="margin-top: 1em">This reads the Motorola hex file
fred.srec and writes it out to the fred.bin as raw
binary.</p>

<p style="margin-top: 1em">Note that the data is placed
into the binary file at the byte offset specified by the
addresses in the hex file. If there are holes in the data
they are filled with zero. This <br>
is, of course, common with linker output where the code is
placed starting at a particular place in memory. For
example, when you have an image that starts at 0x100000, the
<br>
first 1MB of the output binary file will be zero.</p>

<p style="margin-top: 1em">You can automatically cancel
this offset using a command like</p>

<p style="margin-top: 1em">srec_cat fred.hex -offset
&acirc; -minimum&acirc;addr fred.hex -o fred.bin</p>

<p style="margin-top: 1em">The above command works by
offsetting the fred.hex file lower in memory by the least
address in the fred.hex file&rsquo;s data.</p>

<p style="margin-top: 1em">See also the srec_binary(5) man
page for additional detail.</p>

<p style="margin-top: 1em">Reading Binary Files <br>
The simplest way of reading a binary file and converting it
looks like this</p>

<p style="margin-top: 1em">srec_cat fred.bin -binary -o
fred.srec</p>

<p style="margin-top: 1em">This reads the binary file
fred.bin and writes all of its data back out again as a
Motorola S&acirc;Record file.</p>

<p style="margin-top: 1em">Often, this binary isn&rsquo;t
exactly where you want it in the address space, because it
is assumed to reside at address zero. If you need to move it
around use the -offset filter.</p>

<p style="margin-top: 1em">srec_cat fred.bin -binary
-offset 0x10000 -o fred.srec</p>

<p style="margin-top: 1em">You also need to avoid file
&acirc;holes&acirc; which are filled with zero. You can use
the -crop filter, of you could use the -unfill filter if you
don&rsquo;t know exactly where the data is.</p>

<p style="margin-top: 1em">srec_cat fred.bin -binary
-unfill 0x00 512 -o fred.srec</p>

<p style="margin-top: 1em">The above command removes runs
of zero bytes that are 512 bytes long or longer. If your
file contains 1GB of leading zero bytes, this is going to be
slow, it may be better to <br>
use the dd(1) command to slice and dice first.</p>

<p style="margin-top: 1em">JOINING FILES TOGETHER <br>
The srec_cat command takes its name from the UNIX cat(1)
command, which is short for &acirc;catenate&acirc; or
&acirc;to join&acirc;. The srec_cat command joins EPROM load
files together.</p>

<p style="margin-top: 1em">All In One <br>
Joining EPROM load files together into a single file is
simple, just name as many files on the command line as you
need:</p>

<p style="margin-top: 1em">srec_cat infile1 infile2 -o
outfile</p>

<p style="margin-top: 1em">This example is all Motorola
S&acirc;Record files, because that&rsquo;s the default
format. You can have multiple formats in the one command,
and srec_cat(1) will still work. You don&rsquo;t <br>
even have to output the same format:</p>

<p style="margin-top: 1em">srec_cat infile1 -spectrum
infile2 -needham -o outfile -signetics</p>

<p style="margin-top: 1em">These are all ancient formats,
however it isn&rsquo;t uncommon to have to mix and match
Intel and Motorola formats in the one project.</p>

<p style="margin-top: 1em">Overlaying two data files <br>
It is common to want to &acirc;join&acirc; two hex files
together, without any changes of address. on the assumption
neither file intersects with the other. This is a simple
&acirc;layers&acirc;, it is <br>
quite common for linkers to output the main code, and then a
whole bunch of relocation and jump destination, by writing a
two layered files. <br>
srec_cat one.he two.hex -o three.hex <br>
Almost always you see an error <br>
srec_cat: two.srec: 49282: contradictory 0x00000000 value
(previous = 0x00, this one = 0x80)</p>

<p style="margin-top: 1em">This means that the files
actually intersect, they try to set the same location. You
can turn the error into a warning, using the
-contradictory&acirc;bytes=warning command line <br>
option. But this will probably generate a bazillion
warnings.</p>

<p style="margin-top: 1em">The necessary step is to crop
the first file, to avoid the regions the second file is
going o be overwriting. <br>
srec_cat one.srec -exclude -within two.srec two.srec
-exclude -within one.srec -o three.hex</p>

<p style="margin-top: 1em">Depending on your linker this
will have no errors (but if it wants another layer, more
jiggery&acirc;pokery is required).</p>

<p style="margin-top: 1em">Filtering After Joining <br>
There are times when you want to join two sets of data
together, and then apply a filter to the joined result. To
do this you use parentheses. <br>
srec_cat &rsquo;(&rsquo; infile -exclude 0xFFF0 0x10000
-generate 0xFFF0 0xFFF8 -repeat&acirc;string &rsquo;Bananas
&rsquo; &rsquo;)&rsquo; -length&acirc;b&acirc;e 0xFFF8 4
-checksum&acirc;neg&acirc;b&acirc;e 0xFFFC 4 4 -o
outfile</p>

<p style="margin-top: 1em">The above example command
catenate an input file (with the generated data area
excluded) with a constant string. This catenated input is
then filtered to add a 4&acirc;byte length, <br>
and a 4&acirc;byte checksum.</p>

<p style="margin-top: 1em">Joining End&acirc;to&acirc;End
<br>
All too often the address ranges in the EPROM load files
will overlap. You will get an error if they do. If both
files start from address zero, because each goes into a
sepa&acirc; <br>
rate EPROM, you may need to use the offset filter:</p>

<p style="margin-top: 1em">srec_cat infile1 infile2 -offset
0x80000 -o outfile</p>

<p style="margin-top: 1em">Sometimes you want the two files
to follow each other exactly, but you don&rsquo;t know the
offset in advance:</p>

<p style="margin-top: 1em">srec_cat infile1 infile2 -offset
-maximum&acirc;addr infile1 -o outfile</p>

<p style="margin-top: 1em">Notice that where the was a
number (0x80000) before, there is now a calculation
(-maximum&acirc;addr infile1). This is possible most places
a number may be used (also -minimum&acirc;addr <br>
and -range).</p>

<p style="margin-top: 1em">CROPPING THE DATA <br>
It is possible to copy an EPROM load file, selecting
addresses to keep and addresses to discard.</p>

<p style="margin-top: 1em">What To Keep <br>
A common activity is to crop your data to match your EPROM
location. Your linker may add other junk that you are not
interested in, e.g. at the RAM location. In this example,
<br>
there is a 1MB EPROM at the 2MB boundary:</p>

<p style="margin-top: 1em">srec_cat infile -crop 0x200000
0x300000 -o outfile</p>

<p style="margin-top: 1em">The lower bound for all address
ranges is inclusive, the upper bound is exclusive. If you
subtract them, you get the number of bytes.</p>

<p style="margin-top: 1em">Address Offset <br>
Just possibly, you have a moronic EPROM programmer, and it
barfs if the EPROM image doesn&rsquo;t start at zero. To
find out just where is does start in memory, use the
srec_info(1) <br>
command:</p>

<p style="margin-top: 1em">$ srec_info example.srec <br>
Format: Motorola S&acirc;Record <br>
Header: extra&acirc;whizz tool chain linker <br>
Execution Start Address: 0x00200000 <br>
Data: 0x200000 - 0x32AAEF <br>
$</p>

<p style="margin-top: 1em">Rather than butcher the linker
command file, just offset the addresses:</p>

<p style="margin-top: 1em">srec_cat infile -crop 0x200000
0x300000 -offset &acirc;0x200000 -o outfile</p>

<p style="margin-top: 1em">Note that the offset given is
negative, it has the effect of subtracting that value from
all addresses in the input records, to form the output
record addresses. In this case, <br>
shifting the image back to zero.</p>

<p style="margin-top: 1em">This example also demonstrates
how the input filters may be chained together: first the
crop and then the offset, all in one command, without the
need for temporary files.</p>

<p style="margin-top: 1em">If all you want to do is offset
the data to start from address zero, this can be automated,
so you don&rsquo;t have to know the minimum address in
advance, by using srec_cat&rsquo;s ability <br>
to calculate some things on the command line:</p>

<p style="margin-top: 1em">srec_cat infile -offset &acirc;
-minimum&acirc;addr infile -o outfile</p>

<p style="margin-top: 1em">Note the spaces either side of
the minus sign, they are mandatory.</p>

<p style="margin-top: 1em">What To Throw Away <br>
There are times when you need to exclude an small address
range from an EPROM load file, rather than wanting to keep a
small address range. The -exclude filter may be used for
<br>
this purpose.</p>

<p style="margin-top: 1em">For example, if you wish to
exclude the address range where the serial number of an
embedded device is kept, say 0x20 bytes at 0x100, you would
use a command like this:</p>

<p style="margin-top: 1em">srec_cat input.srec -exclude
0x100 0x120 -o output.srec</p>

<p style="margin-top: 1em">The output.srec file will have a
hole in the data at the necessary locations.</p>

<p style="margin-top: 1em">Note that you can have both
-crop and -exclude on the same command line, whichever works
more naturally for your situation.</p>

<p style="margin-top: 1em">Discontinuous Address Ranges
<br>
Address ranges don&rsquo;t have to be a single range, you
can build up an address range using more than a single
pair.</p>

<p style="margin-top: 1em">srec_cat infile -crop 0x100
0x200 0x1000 0x1200 -o outfile</p>

<p style="margin-top: 1em">This filter results in data from
0x100..0x1FF and data from 0x1000..0x1200 to pass through,
the rest is dropped. This is is more efficient than chaining
a -crop and an -exclude <br>
filter together.</p>

<p style="margin-top: 1em">MOVING THINGS AROUND <br>
It is also possible to change the address of data records,
both forwards and backwards. It is also possible rearrange
where data records are placed in memory.</p>

<p style="margin-top: 1em">Offset Filter <br>
The -offset=number filter operates on the addresses of
records. If the number is positive the addresses move that
many bytes higher in memory, negative values move lower.</p>

<p style="margin-top: 1em">srec_cat infile -crop 0x200000
0x300000 -offset &acirc;0x200000 -o outfile</p>

<p style="margin-top: 1em">The above example moves the 1MB
block of data at 0x200000 down to zero (the offset is
negative) and discards the rest of the data.</p>

<p style="margin-top: 1em">Byte Swapping <br>
There are times when the bytes in the data need to be
swapped, converting between big&acirc;endian and
little&acirc;endian data usually.</p>

<p style="margin-top: 1em">srec_cat infile -byte&acirc;swap
4 -o outfile</p>

<p style="margin-top: 1em">This reverses bytes in 32 bit
values (4 bytes). The default, if you don&rsquo;t supply a
width, is to reverse bytes in 16 bit values (2 bytes). You
can actually use any weird value <br>
you like, it doesn&rsquo;t even have to be a power of 2.
Perhaps 64 bits (8 bytes) may be useful one day.</p>

<p style="margin-top: 1em">Binary Output <br>
You need to watch out for binary files on output, because
the holes are filled with zeros. Your 100kB program at the
top of 32&acirc;bit addressed memory will make a 4GB file.
See <br>
srec_binary(5) for how understand and avoid this problem,
usually with the -offset filter.</p>

<p style="margin-top: 1em">Splitting an Image <br>
If you have a 16&acirc;bit data bus, but you are using two
8&acirc;bit EPROMs to hold your firmware, you can generate
the even and odd images by using the -SPlit filter. Assuming
your <br>
firmware is in the firmware.hex file, use the following:</p>

<p style="margin-top: 1em">srec_cat firmware.hex -split 2 0
-o firmware.even.hex <br>
srec_cat firmware.hex -split 2 1 -o firmware.odd.hex</p>

<p style="margin-top: 1em">This will result in the two
necessary EPROM images. Note that the output addresses are
divided by the split multiple, so if your EPROM images are
at a particular offset (say <br>
0x10000, in the following example), you need to remove the
offset, and then replace it...</p>

<p style="margin-top: 1em">srec_cat firmware.hex -offset
&acirc;0x10000 -split 2 0 -offset 0x10000 -o
firmware.even.hex <br>
srec_cat firmware.hex -offset &acirc;0x10000 -split 2 1
-offset 0x10000 -o firmware.odd.hex</p>

<p style="margin-top: 1em">Note how the ability to apply
multiple filters simplifies what would otherwise be a much
longer script.</p>

<p style="margin-top: 1em">Striping <br>
A second use for the -SPlit filter is memory striping.</p>

<p style="margin-top: 1em">You don&rsquo;t have to split
into byte&acirc;wide parts, you can choose other sizes. It
is common to want to convert 32&acirc;bit wide data into two
set of 16&acirc;bit wide data.</p>

<p style="margin-top: 1em">srec_cat firmware.hex -split 4 0
2 -o firmware.01.hex <br>
srec_cat firmware.hex -split 4 2 2 -o firmware.23.hex</p>

<p style="margin-top: 1em">This is relatively simple to
understand, but you can use even wider stripes.</p>

<p style="margin-top: 1em">In this next example, the
hardware requires that 512&acirc;byte blocks alternate
between 4 EPROMs. Generating the 4 images would be done as
follows:</p>

<p style="margin-top: 1em">srec_cat firmware.hex -split
0x800 0x000 0x200 -o firmware.0.hex <br>
srec_cat firmware.hex -split 0x800 0x200 0x200 -o
firmware.1.hex <br>
srec_cat firmware.hex -split 0x800 0x400 0x200 -o
firmware.2.hex <br>
srec_cat firmware.hex -split 0x800 0x600 0x200 -o
firmware.3.hex</p>

<p style="margin-top: 1em">Asymmetric Striping <br>
A more peculiar example of striping is the Microchip
dsPIC33F microcontroller, that has a weird memory storage
pattern and they are able to store 3 bytes in an address
that <br>
should only contain 2 bytes. The result is a hex file that
has zero&acirc;filled the top byte (little&acirc;endian),
and all addresses are doubled from what they are in the
chip. Here is <br>
an example:</p>


<p style="margin-top: 1em">S1130000000102000405060008090A000C0D0E0098
<br>
S1130010101112001415160018191A001C1D1E00C8 <br>
S1130020202122002425260028292A002C2D2E00F8 <br>
S1130030303132003435360038393A003C3D3E0028</p>

<p style="margin-top: 1em">To get rid of the 00 padding
bytes, leaving only the 3/4 significant bytes, you also use
the split filter, with its additional width argument, like
this:</p>

<p style="margin-top: 1em">srec_cat example.srec -split 4 0
3 -o no_dross.srec</p>

<p style="margin-top: 1em">This results in a file with the
00 padding bytes removed. It looks like this:</p>


<p style="margin-top: 1em">S113000000010204050608090A0C0D0E1011121451
<br>
S1130010151618191A1C1D1E2021222425262829EC <br>
S11300202A2C2D2E30313234353638393A3C3D3E87</p>

<p style="margin-top: 1em">Notice how the addresses are 3/4
the size, as well. You can reverse this using the -unsplit
and -fill=0 filters.</p>

<p style="margin-top: 1em">Unsplit ING Images <br>
The unsplit filter may be used to reverse the effects of the
split filter. Note that the address range is expanded
leaving holes between the stripes. By using all the stripes,
<br>
the complete input is reassembled, without any holes.</p>

<p style="margin-top: 1em">srec_cat -o firmware.hex
firmware.even.hex -unsplit 2 0 firmware.odd.hex -unsplit 2
1</p>

<p style="margin-top: 1em">The above example reverses the
previous 16&acirc;bit data bus example. In general, you
unsplit with the same parameters that you split with.</p>

<p style="margin-top: 1em">FILLING THE BLANKS <br>
Often EPROM load files will have &acirc;holes&acirc; in
them, places where the compiler and linker did not put
anything. For some purposes this is OK, and for other
purposes something has <br>
to be done about the holes.</p>

<p style="margin-top: 1em">The Fill Filter <br>
It is possible to fill the blanks where your data does not
lie. The simplest example of this fills the entire
EPROM:</p>

<p style="margin-top: 1em">srec_cat infile -fill 0x00
0x200000 0x300000 -o outfile</p>

<p style="margin-top: 1em">This example fills the holes, if
any, with zeros. You must specify a range - with a
32&acirc;bit address space, filling everything generates
huge load files.</p>

<p style="margin-top: 1em">If you only want to fill the
gaps in your data, and don&rsquo;t want to fill the entire
EPROM, try:</p>

<p style="margin-top: 1em">srec_cat infile -fill 0x00 -over
infile -o outfile</p>

<p style="margin-top: 1em">This example demonstrates the
fact that wherever an address range may be specified, the
-over and -within options may be used.</p>

<p style="margin-top: 1em">Unfilling the Blanks <br>
It is common to need to &acirc;unfill&acirc; an EPROM image
after you read it out of a chip. Usually, it will have had
all the holes filled with 0xFF (areas of the EPROM you
don&rsquo;t program <br>
show as 0xFF when you read them back).</p>

<p style="margin-top: 1em">To get rid of all the 0xFF bytes
in the data, use this filter:</p>

<p style="margin-top: 1em">srec_cat infile -unfill 0xFF -o
outfile</p>

<p style="margin-top: 1em">This will get rid of all the
0xFF bytes, including the ones you actually wanted in there.
There are two ways to deal with this. First, you can specify
a minimum run length to <br>
the un&acirc;fill:</p>

<p style="margin-top: 1em">srec_cat infile -unfill 0xFF 5
-o outfile</p>

<p style="margin-top: 1em">This says that runs of 1 to 4
bytes of 0xFF are OK, and that a hole should only be created
for runs of 5 or more 0xFF bytes in a row. The second method
is to re&acirc;fill over the <br>
intermediate gaps:</p>

<p style="margin-top: 1em">srec_cat outfile -fill 0xFF
-over outfile -o outfile2</p>

<p style="margin-top: 1em">Which method you choose depends
on your needs, and the shape of the data in your EPROM. You
may need to combine both techniques.</p>

<p style="margin-top: 1em">Address Range Padding <br>
Some data formats are 16 bits wide, and automatically fill
with 0xFF bytes if it is necessary to fill out the other
half of a word which is not in the data. If you need to fill
<br>
with a different value, you can use a command like this:</p>

<p style="margin-top: 1em">srec_cat infile -fill 0x0A
-within infile -range&acirc;padding 2 -o outfile</p>

<p style="margin-top: 1em">This gives the fill filter an
address range calculated from details of the input file. The
address range is all the address ranges covered by data in
the infile, extended down&acirc; <br>
wards (if necessary) at the start of each sub&acirc;range to
a 2 byte multiple and extended upwards (if necessary) at the
end of each sub&acirc;range to a 2 byte multiple. This also
works <br>
for larger multiples, like 1kB page boundaries of flash
chips. This address range padding works anywhere an address
range is required.</p>

<p style="margin-top: 1em">Fill with Copyright <br>
It is possible to fill unused portions of your EPROM with a
repeating copyright message. Anyone trying to reverse
engineer your EPROMs is going to see the copyright notice in
<br>
their hex editor.</p>

<p style="margin-top: 1em">This is accomplished with two
input sources, one from a data file, and one which is
generated on&acirc;the&acirc;fly.</p>

<p style="margin-top: 1em">srec_cat infile -generate
&rsquo;(&rsquo; 0 0x100000 -minus -within infile
&rsquo;)&rsquo; -repeat&acirc;string &rsquo;Copyright (C)
1812 Tchaikovsky. &rsquo; -o outfile</p>

<p style="margin-top: 1em">Notice the address range for the
data generation: it takes the address range of your EPROM,
in this case 1MB starting from 0, and subtracts from it the
address ranges used by the <br>
input file.</p>

<p style="margin-top: 1em">If you want to script this with
the current year (because 1812 is a bit out of date) use the
shell&rsquo;s output substitution (back ticks) ability:</p>

<p style="margin-top: 1em">srec_cat infile -generate
&rsquo;(&rsquo; 0 0x100000 -minus -within infile
&rsquo;)&rsquo; -repeat&acirc;string &quot;Copyright (C)
&lsquo;date +%Y&lsquo; Tchaikovsky. &quot; -o outfile</p>

<p style="margin-top: 1em">The string specified is repeated
over and over again, until it has filled all the holes.</p>

<p style="margin-top: 1em">Obfuscating with Noise <br>
Sometimes you want to fill your EPROM images with noise, to
conceal where the real data stops and starts. You can do
this with the -random&acirc;fill filter.</p>

<p style="margin-top: 1em">srec_cat infile
-random&acirc;fill 0x200000 0x300000 -o outfile</p>

<p style="margin-top: 1em">It works just like the -fill
filter, but uses random numbers instead of a constant byte
value.</p>

<p style="margin-top: 1em">Fill With 16&acirc;bit Words
<br>
When filling the image with a constant byte value
doesn&rsquo;t work, and you need a constant 16&acirc;bit
word value instead, use the -repeat&acirc;data generator,
which takes an arbitrarily long <br>
sequence of bytes to use as the fill pattern:</p>

<p style="margin-top: 1em">srec_cat infile -generator
&rsquo;(&rsquo; 0x200000 0x300000 -minus -within infile
&rsquo;)&rsquo; -repeat&acirc;data 0x1B 0x08 -o outfile</p>

<p style="margin-top: 1em">Notice how the generator&rsquo;s
address range once again avoids the address ranges occupied
by the infile&rsquo;s data. You have to get the
endian&acirc;ness right yourself.</p>

<p style="margin-top: 1em">INSERTING CONSTANT DATA <br>
From time to time you will want to insert constant data, or
data not produced by your compiler or assembler, into your
EPROM load images.</p>

<p style="margin-top: 1em">Binary Means Literal <br>
One simple way is to have the desired information in a file.
To insert the file&rsquo;s contents literally, with no
format interpretation, use the binary input format:</p>

<p style="margin-top: 1em">srec_cat infile -binary -o
outfile</p>

<p style="margin-top: 1em">It will probably be necessary to
use an offset filter to move the data to where you actually
want it within the image:</p>

<p style="margin-top: 1em">srec_cat infile -binary -offset
0x1234 -o outfile</p>

<p style="margin-top: 1em">It is also possible to use the
standard input as a data source, which lends itself to being
scripted. For example, to insert the current date and time
into an EPROM load file, <br>
you could use a pipe:</p>

<p style="margin-top: 1em">date | srec_cat - -bin -offset
0xFFE3 -o outfile</p>

<p style="margin-top: 1em">The special file name
&acirc;-&acirc; means to read from the standard input. The
output of the date command is always 29 characters long, and
the offset shown will place it at the top of a <br>
64KB EPROM image.</p>

<p style="margin-top: 1em">Repeating Once <br>
The Fill with Copyright section, above, shows how to repeat
a string over and over. We can use a single repeat to insert
a string just once.</p>

<p style="margin-top: 1em">srec_cat -generate 0xFFE3
0x10000 -repeat&acirc;string &quot;&lsquo;date&lsquo;&quot;
-o outfile</p>

<p style="margin-top: 1em">Notice how the address range for
the data generation exactly matches the length of the
date(1) output size. You can, of course, add your input file
to the above srec_cat(1) com&acirc; <br>
mand to catenate your EPROM image together with the date and
time.</p>

<p style="margin-top: 1em">Inserting A Long <br>
Another possibility is to add the Subversion commit number
to your EPROM image. In this example, we are inserting it a
a 4&acirc;byte little&acirc;endian value at address 0x0008.
The Sub&acirc; <br>
version commit number is in the $version shell variable in
this example:</p>

<p style="margin-top: 1em">srec_cat -generate 0x0008 0x000C
-constant&acirc;l&acirc;e $version 4 infile -exclude 0x0008
0x000C -o outfile</p>

<p style="margin-top: 1em">Note that we use a filter to
ensure there is a hole in the input where the version number
goes, just in case the linker put something there.</p>

<p style="margin-top: 1em">DATA ABOUT THE DATA <br>
It is possible to add a variety of data about the data to
the output.</p>

<p style="margin-top: 1em">Checksums <br>
The -checksum&acirc;negative&acirc;big&acirc;endian filter
may be used to sum the data, and then insert the negative of
the sum into the data. This has the effect of summing to
zero when the <br>
checksum itself is summed across, provided the sum width
matches the inserted value width.</p>

<p style="margin-top: 1em">srec_cat infile -crop 0 0xFFFFFC
-random&acirc;fill 0 0xFFFFFC
-checksum&acirc;neg&acirc;b&acirc;e 0xFFFFFC 4 4 -o
outfile</p>

<p style="margin-top: 1em">In this example, we have an
EPROM in the lowest megabyte of memory. The -crop filter
ensures we are only summing the data within the EPROM, and
not anywhere else. The -random&acirc; <br>
fill filter fills any holes left in the data with random
values. Finally, the -checksum&acirc;neg&acirc;b&acirc;e
filter inserts a 32 bit (4 byte) checksum in
big&acirc;endian format in the last 4 <br>
bytes of the EPROM image. Naturally, there is a
little&acirc;endian version of this filter as well.</p>

<p style="margin-top: 1em">Your embedded code can check the
EPROM using C code similar to the following:</p>

<p style="margin-top: 1em">unsigned long *begin = (unsigned
long *)0; <br>
unsigned long *end = (unsigned long *)0x100000; <br>
unsigned long sum = 0; <br>
while (begin &lt; end) <br>
sum += *begin++; <br>
if (sum != 0) <br>
{ <br>
Oops <br>
}</p>

<p style="margin-top: 1em">The
-checksum&acirc;bitnot&acirc;big&acirc;endian filter is
similar, except that summing over the checksum should yield
a value of all&acirc;one&acirc;bits (&acirc;1). For example,
using shorts rather than longs:</p>

<p style="margin-top: 1em">srec_cat infile -crop 0 0xFFFFFE
-fill 0xCC 0x00000 0xFFFFFE
-checksum&acirc;neg&acirc;b&acirc;e 0xFFFFFE 2 2 -o
outfile</p>

<p style="margin-top: 1em">Assuming you chose the correct
endian&acirc;ness filter, your embedded code can check the
EPROM using C code similar to the following:</p>

<p style="margin-top: 1em">unsigned short *begin =
(unsigned short *)0; <br>
unsigned short *end = (unsigned short *)0x100000; <br>
unsigned short sum = 0; <br>
while (begin &lt; end) <br>
sum += *begin++; <br>
if (sum != 0xFFFF) <br>
{ <br>
Oops <br>
}</p>

<p style="margin-top: 1em">There is also a
-checksum&acirc;positive&acirc;b&acirc;e filter, and a
matching little&acirc;endian filter, which inserts the
simple sum, and which would be checked in C using an
equality test.</p>

<p style="margin-top: 1em">srec_cat infile -crop 0 0xFFFFFF
-fill 0x00 0x00000 0xFFFFFF
-checksum&acirc;neg&acirc;b&acirc;e 0xFFFFFF 1 1 -o
outfile</p>

<p style="margin-top: 1em">Assuming you chose the correct
endian&acirc;ness filter, your embedded code can check the
EPROM using C code similar to the following:</p>

<p style="margin-top: 1em">unsigned char *begin = (unsigned
char *)0; <br>
unsigned char *end = (unsigned char *)0xFFFFF; <br>
unsigned char sum = 0; <br>
while (begin &lt; end) <br>
sum += *begin++; <br>
if (sum != *end) <br>
{ <br>
Oops <br>
}</p>

<p style="margin-top: 1em">In the 8&acirc;bit case, it
doesn&rsquo;t matter whether you use the big&acirc;endian or
little&acirc;endian filter.</p>

<p style="margin-top: 1em">Quick Hex&acirc;Dump <br>
You can look at the checksum of your data, by using the
&acirc;hex&acirc;dump&acirc; output format. This is useful
for looking at calculated values, or for debugging an
srec_cat(1) command before <br>
immortalizing it in a script.</p>

<p style="margin-top: 1em">srec_cat infile -crop 0 0x10000
-fill 0xFF 0x0000 0x10000
-checksum&acirc;neg&acirc;b&acirc;e 0x10000 4 -crop 0x10000
0x10004 -o - -hex&acirc;dump</p>

<p style="margin-top: 1em">This command reads in the file,
checksums the data and places the checksum at 0x10000, crops
the result to contain only the checksum, and then prints the
checksum on the standard <br>
output in a classical hexadecimal dump format. The special
file name &acirc;-&acirc; means &acirc;the standard
output&acirc; in this context.</p>

<p style="margin-top: 1em">Cyclic Redundancy Checks <br>
The simple additive checksums have a number of theoretical
limitations, to do with errors they can and can&rsquo;t
detect. The CRC methods have fewer problems.</p>

<p style="margin-top: 1em">srec_cat infile -crop 0 0xFFFFFC
-fill 0x00 0x00000 0xFFFFFC -crc32&acirc;b&acirc;e 0xFFFFFC
-o outfile</p>

<p style="margin-top: 1em">In the above example, we have an
EPROM in the lowest megabyte of memory. The -crop filter
ensures we are only summing the data within the EPROM, and
not anywhere else. The <br>
-fill filter fills any holes left in the data. Finally, the
-checksum&acirc;neg&acirc;b&acirc;e filter inserts a 32 bit
(4 byte) checksum in big&acirc;endian format in the last 4
bytes of the EPROM <br>
image. Naturally, there is a little&acirc;endian version of
this filter as well.</p>

<p style="margin-top: 1em">The checksum is calculated using
the industry standard 32&acirc;bit CRC. Because SRecord is
open source, you can always read the source code to see how
it works. There are many non&acirc; <br>
GPL versions of this code available on the Internet, and
suitable for embedding in proprietary firmware.</p>

<p style="margin-top: 1em">There is also a 16&acirc;bit CRC
available.</p>

<p style="margin-top: 1em">srec_cat infile -crop 0 0xFFFFFE
-fill 0x00 0x00000 0xFFFFFE -crc16&acirc;b&acirc;e 0xFFFFFE
-o outfile</p>

<p style="margin-top: 1em">The checksum is calculated using
the CCITT formula. Because SRecord is open source, you can
always read the source code to see how it works. There are
many non&acirc;GPL version of <br>
this code available on the Internet, and suitable for
embedding in proprietary firmware.</p>

<p style="margin-top: 1em">You can look at the CRC of your
data, by using the &acirc;hex&acirc;dump&acirc; output
format.</p>

<p style="margin-top: 1em">srec_cat infile -crop 0 0x10000
-fill 0xFF 0x0000 0x10000 -crc16&acirc;b&acirc;e 0x10000
-crop 0x10000 0x10002 -o - -hex&acirc;dump</p>

<p style="margin-top: 1em">This command reads in the file,
calculates the CRC of the data and places the CRC at
0x10000, crops the result to contain only the CRC, and then
prints the checksum on the stan&acirc; <br>
dard output in a classical hexadecimal dump format.</p>

<p style="margin-top: 1em">Where Is My Data? <br>
There are several properties of your EPROM image that you
may wish to insert into the data.</p>

<p style="margin-top: 1em">srec_cat infile
-minimum&acirc;b&acirc;e 0xFFFE 2 -o outfile</p>

<p style="margin-top: 1em">The above example inserts the
minimum address of the data (low water) into the data, as
two bytes in big&acirc;endian order at address 0xFFFE. This
includes the minimum itself. If <br>
the data already contains bytes at the given address, you
need to use an exclude filter. The number of bytes defaults
to 4.</p>

<p style="margin-top: 1em">There is also a
-minimum&acirc;l&acirc;e filter for inserting
little&acirc;endian values, and two more filters called
-exclusive&acirc;minimum&acirc;b&acirc;e and
-exclusive&acirc;minimum&acirc;l&acirc;e that do not include
the min&acirc; <br>
imum itself in the calculation of the minimum data
address.</p>

<p style="margin-top: 1em">srec_cat infile
-maximum&acirc;b&acirc;e 0xFFFFFC 4 -o outfile</p>

<p style="margin-top: 1em">The above example inserts the
maximum address of the data (high water + 1, just like
address ranges) into the data, as four bytes in
big&acirc;endian order at address 0xFFFFFC. This <br>
includes the maximum itself. If the data already contains
bytes at the given address, you need to use an -exclude
filter. The number of bytes defaults to 4.</p>

<p style="margin-top: 1em">There is also a
-maximum&acirc;l&acirc;e filter for inserting
little&acirc;endian values, and two more filters called
-exclusive&acirc;maximum&acirc;b&acirc;e and
-exclusive&acirc;maximum&acirc;l&acirc;e that do not include
the max&acirc; <br>
imum itself in the calculation of the maximum data
address.</p>

<p style="margin-top: 1em">srec_cat infile
-length&acirc;b&acirc;e 0xFFFFFC 4 -o outfile</p>

<p style="margin-top: 1em">The above example inserts the
length of the data (high water + 1 &acirc; low water) into
the data, as four bytes in big&acirc;endian order at address
0xFFFFFC. This includes the length <br>
itself. If the data already contains bytes at the length
location, you need to use an -exclude filter. The number of
bytes defaults to 4.</p>

<p style="margin-top: 1em">There is also a
-length&acirc;l&acirc;e filter for inserting a
little&acirc;endian length, and the
-exclusive&acirc;length&acirc;b&acirc;e and
-exclusive&acirc;length&acirc;l&acirc;e filters that do not
include the length itself in <br>
the calculation.</p>

<p style="margin-top: 1em">What Format Is This? <br>
You can obtain a variety of information about an EPROM load
file by using the srec_info(1) command. For example:</p>

<p style="margin-top: 1em">$ srec_info example.srec <br>
Format: Motorola S&acirc;Record <br>
Header: &quot;http://srecord.sourceforge.net/&quot; <br>
Execution Start Address: 00000000 <br>
Data: 0000 - 0122 <br>
0456 - 0FFF <br>
$</p>

<p style="margin-top: 1em">This example shows that the file
is a Motorola S&acirc;Record. The text in the file header is
printed, along with the execution start address. The final
section shows the address <br>
ranges containing data (the upper bound of each subrange is
inclusive, rather than the exclusive form used on the
command line.</p>

<p style="margin-top: 1em">$ srec_info
some&acirc;weird&acirc;file.hex -guess <br>
Format: Signetics <br>
Data: 0000 - 0122 <br>
0456 - 0FFF <br>
$</p>

<p style="margin-top: 1em">The above example guesses the
EPROM load file format. It isn&rsquo;t infallible but it
usually gets it right. You can use -guess anywhere you would
give an explicit format, but it <br>
tends to be slower and for that reason is not recommended.
Also, for automated build systems, you want hard errors as
early as possible; if a file isn&rsquo;t in the expected
format, <br>
you want it to barf.</p>

<p style="margin-top: 1em">MANGLING THE DATA <br>
It is possible to change the values of the data bytes in
several ways.</p>

<p style="margin-top: 1em">srec_cat infile -and 0xF0 -o
outfile</p>

<p style="margin-top: 1em">The above example performs a
bit&acirc;wise AND of the data bytes with the 0xF0 mask. The
addresses of records are unchanged. I can&rsquo;t actually
think of a use for this filter.</p>

<p style="margin-top: 1em">srec_cat infile -or 0x0F -o
outfile</p>

<p style="margin-top: 1em">The above example performs a
bit&acirc;wise OR of the data bytes with the 0x0F bits. The
addresses of records are unchanged. I can&rsquo;t actually
think of a use for this filter.</p>

<p style="margin-top: 1em">srec_cat infile -xor 0xA5 -o
outfile</p>

<p style="margin-top: 1em">The above example performs a
bit&acirc;wise exclusive OR of the data bytes with the 0xA5
bits. The addresses of records are unchanged. You could use
this to obfuscate the contents of <br>
your EPROM.</p>

<p style="margin-top: 1em">srec_cat infile -not -o
outfile</p>

<p style="margin-top: 1em">The above example performs a
bit&acirc;wise NOT of the data bytes. The addresses of
records are unchanged. Security by obscurity?</p>

<p style="margin-top: 1em">COPYRIGHT <br>
srec_cat version 1.64 <br>
Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004,
2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014
Peter Miller</p>

<p style="margin-top: 1em">The srec_cat program comes with
ABSOLUTELY NO WARRANTY; for details use the &rsquo;srec_cat
-VERSion License&rsquo; command. This is free software and
you are welcome to redistribute it <br>
under certain conditions; for details use the
&rsquo;srec_cat -VERSion License&rsquo; command.</p>

<p style="margin-top: 1em">MAINTAINER <br>
Scott Finneran E&acirc;Mail: scottfinneran@yahoo.com.au <br>
Peter Miller E&acirc;Mail: pmiller@opensource.org.au</p>

<p style="margin-top: 1em">Reference Manual SRecord
srec_examples(1)</p>
<hr>
</body>
</html>
