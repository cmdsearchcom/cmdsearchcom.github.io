<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:23:45 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MAKEPP_FAQ(1) Makepp MAKEPP_FAQ(1)</p>

<p style="margin-top: 1em">NAME <br>
makepp_faq -- Frequently asked questions about makepp</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Here you may find installation instructions and some points
which are not obvious from the rest of the documentation.
This shows stumbling blocks, whereas howto type questions
<br>
will be found in the cookbook.</p>

<p style="margin-top: 1em">Getting Started <br>
Where to download?</p>

<p style="margin-top: 1em">Makepp is hosted on SourceForge
and can be downloaded as a source code tarball or as
installation package for Debian .deb based Linuxes or .rpm
based Linuxes from <br>
http://sourceforge.net/projects/makepp/files/</p>

<p style="margin-top: 1em">Like tons of Perl software,
makepp can also be downloaded from CPAN by clicking the
Download link on http://search.cpan.org/dist/makepp/</p>

<p style="margin-top: 1em">Makepp is part of Debian
GNU/Linux unstable and testing. This means you can install
it directly via &quot;apt-get install makepp&quot; or by
choosing it from your preferred package tool <br>
like synaptic.</p>

<p style="margin-top: 1em">Makepp is part of archlinux and
of Gentoo Linux. Note that distro-specific suffixes like
2.0-1 or 2.0-r1 is not the release candidate 1, but the
final released version 2.0.</p>

<p style="margin-top: 1em">Can I try it without
installing?</p>

<p style="margin-top: 1em">Yes, if you want to try makepp
on your own makefiles, either put the directory where you
unpacked it into your path, or else run it explicitly like
this, with an absolute or <br>
relative path to makepp:</p>

<p style="margin-top: 1em">perl
/where/you/unpacked/it/makepp</p>

<p style="margin-top: 1em">How to choose perl version?</p>

<p style="margin-top: 1em">You must have Perl 5.8 or newer
somewhere on your system. By default all uninstalled scripts
will use the &quot;perl&quot; in your path. But you can run
them with an explicit instance of <br>
perl. The test runner and installation will run everything
with this same instance.</p>

<p style="margin-top: 1em">/path/to/perl
/where/you/unpacked/it/makepp</p>

<p style="margin-top: 1em">In case some script
doesn&rsquo;t properly recognize which &quot;perl&quot; it
is being run with, you can help it by telling it the path to
the same instance of perl via the &quot;PERL&quot;
variable:</p>

<p style="margin-top: 1em">PERL=/path/to/perl /path/to/perl
/where/you/unpacked/it/makepp</p>

<p style="margin-top: 1em">This can also be an instance to
be searched in your path, if it doesn&rsquo;t contain a
directory separator:</p>

<p style="margin-top: 1em">PERL=perl5.16.2 perl5.16.2
/where/you/unpacked/it/makepp</p>

<p style="margin-top: 1em">How to install?</p>

<p style="margin-top: 1em">There are two ways to install,
which lead to the same result:</p>

<p style="margin-top: 1em">configure (alias config.pl) <br>
This allows for traditional style installation:</p>

<p style="margin-top: 1em">./configure &amp;&amp; make test
&amp;&amp; make install</p>

<p style="margin-top: 1em">The only difference between
these two is that &quot;configure&quot; is not a Perl
script, so you can&rsquo;t say &quot;perl configure&quot;,
whereas you can use all the above variants like &quot;perl
<br>
config.pl&quot;. Valid options are:</p>

<p style="margin-top: 1em">-b,
--bindir=/path/to/installation/bin <br>
Where the binaries go (default: prefix/bin). Makepp&rsquo;s
binaries are just Perl scripts so they are architecture
independent. If you give this option, but no
&quot;--prefix&quot;, <br>
it will strip /bin to deduce a prefix for the other default
values.</p>

<p style="margin-top: 1em">-d,
--datadir=/path/to/installation/share/makepp <br>
Where to install makepp&rsquo;s library files (default:
prefix/share/makepp).</p>

<p style="margin-top: 1em">-f,
--findbin=relative/path/to/datadir/from/bindir <br>
Where to find libraries relative to executables, or
&rsquo;none&rsquo; (the default) to find them in
datadir.</p>

<p style="margin-top: 1em">-h,
--htmldir=/path/to/installation/share/html <br>
Where the HTML documentation goes (default:
prefix/doc/makepp if prefix/doc exists, else datadir/html),
or &rsquo;none&rsquo; if you do not want it installed.</p>

<p style="margin-top: 1em">-m, --mandir=/path/to/man <br>
Where the manual pages should reside (default:
prefix/share/man if it exists, else prefix/man), or
&rsquo;none&rsquo; if you do not want them installed.</p>

<p style="margin-top: 1em">--makefile=/path/to/Makefile
<br>
Specify location where you can write the Makefile (default:
.). Unlike the other options, which are remembered for the
following install step, this file is created <br>
immediately.</p>

<p style="margin-top: 1em">-p,
--prefix=/path/to/installation <br>
Specify location where you want to install everything
(default: /usr/local). All other paths are by default
relative to this one.</p>

<p style="margin-top: 1em">-V <br>
--version <br>
Print out the version number.</p>

<p style="margin-top: 1em">If you want to do a mockup
installation to some destdir for packaging your own
distribution, you can give an extra parameter to the last
command:</p>

<p style="margin-top: 1em">make DESTDIR=/temporary/destdir
install</p>

<p style="margin-top: 1em">install.pl <br>
This is the backend that performs the actual installation.
You can call it directly:</p>

<p style="margin-top: 1em">./install.pl bindir datadir
mandir htmldir findbin destdir</p>

<p style="margin-top: 1em">The parameters are optional and
correspond to the options from the previous section. You are
prompted for those you don&rsquo;t supply, except for the
last one, which is not <br>
normally needed.</p>

<p style="margin-top: 1em">Makefile.PL <br>
The customary file Makefile.PL is currently only present for
technical reasons. It will not help you to install.
Therefore, alas, you can&rsquo;t use tools like
&quot;cpanm&quot; to <br>
install in one go.</p>

<p style="margin-top: 1em">On some systems whichever
&quot;perl&quot; you end up calling may be a symbolic link
to some precise version &quot;perl5.m.n&quot;. In this case
perl sees only that one, and will thus use it to <br>
install against. If you don&rsquo;t want that, use the
&quot;PERL&quot; variable as described above. If you install
with the second variant, i.e. just the name of the
executable without <br>
slashes, the installed scripts will always search for that
one via &quot;/usr/bin/env&quot;. This makes them a tiny bit
slower to start, for a greater flexibility.</p>

<p style="margin-top: 1em">Why does installation say
permission denied?</p>

<p style="margin-top: 1em">If you want to install to a
system directory like /usr, /usr/local or /opt, you can only
do that if you run the installation as user root. On many
Unices you can run a command <br>
as root, by prepending &quot;sudo&quot; to it, and depending
on the system entering the either the root password, or
yours, as prompted for.</p>

<p style="margin-top: 1em">This is not necessary for the
preparatory &quot;configure&quot; or &quot;config.pl&quot;
step which only writes a Makefile in the current
directory.</p>

<p style="margin-top: 1em">Build Questions <br>
What are unimportant targets?</p>

<p style="margin-top: 1em">Makepp remembers the
dependencies of every file. If any of them need to be
rebuilt, that will be done before rescanning. But if the
build failed, yet the scan succeeds, because <br>
the file isn&rsquo;t even needed anymore, then at the end
the failure will be reported as unimportant. (The build
should not be attempted, instead letting the rescan do those
builds <br>
it finds to be necessary, but that happens in a different
place, so this would be difficult.)</p>

<p style="margin-top: 1em">Why does it run this rule 3
times?</p>

<p style="margin-top: 1em">GNU make has no makepp style
multi target rules. Instead it interprets this as a shortcut
for three separate rules:</p>

<p style="margin-top: 1em">a b c: <br>
echo $@ <br>
touch a b c</p>

<p style="margin-top: 1em">However, it doesn&rsquo;t check
why a file is there. If a file exists (and is newer than any
dependencies) it is happy. Whichever of the three files gets
built first, provides the <br>
other two, so this behaves somewhat like a multitarget rule
-- but can cause race conditions in parallel builds.</p>

<p style="margin-top: 1em">A similar rule might have
been:</p>

<p style="margin-top: 1em">a b c: <br>
touch $@</p>

<p style="margin-top: 1em">Gmake indeed runs this one once
per required file. Without knowing what the command does (it
might be a script which internally creates some files), the
two cases can&rsquo;t easily <br>
be told apart by makepp.</p>

<p style="margin-top: 1em">So as a special compatibility
fallback, if a multi target rule action mentions only old
style $@ and neither new style &quot;$(output)&quot; nor
&quot;$(target)&quot; nor their plural forms, it is <br>
treated as separate rules. This however means running it
repeatedly, as makepp ignores randomly appearing files for
which it has no metadata.</p>

<p style="margin-top: 1em">Why does it complain that a
created file is phony?</p>

<p style="margin-top: 1em">If you have a command that
continues working asynchronously, after it came back with a
success return code, makepp will notice the promised file as
missing and complain. This <br>
can also typically happen on some network file systems,
which may physically write only several seconds later.</p>

<p style="margin-top: 1em">If you cannot evite such an
unsatisfactory situation, you can ask makepp to be sloppy
about this check with the &quot;--gullible&quot; option. But
then the next command which depends on <br>
the produced file might still fail.</p>

<p style="margin-top: 1em">Why does it recreate files
unnecessarily?</p>

<p style="margin-top: 1em">I have observed this on NFS,
where due to file attribute caching the timestamp of the
produced file was not yet the one the it finally had. On the
next run makepp noticed the <br>
difference and considered the file unduly modified. This got
resolved with a mount option of &quot;acregmin=0&quot;,
making attributes visible immediately.</p>

<p style="margin-top: 1em">This can also happen with
repositories, e.g. if someone else has built in the
repository with &quot;umask 066&quot; or using a compiler
that bars others from reading the produced file. <br>
This will also happen if either the repository or your build
tree shares a common path prefix with some dependencies
(e.g. /opt/repository and /opt/sometool, in which case
makepp <br>
will remember the path once as relative, and once as
absolute, looking like changed dependencies.</p>

<p style="margin-top: 1em">Does the C source file or the
object file depend on headers?</p>

<p style="margin-top: 1em">It depends on your viewpoint. If
a prototype in a header changes, the programmer may have to
adapt the source code. So from that viewpoint there is a
dependency.</p>

<p style="margin-top: 1em">But for the build this is
completely irrelevant. Here the outputs depend on the
inputs. If a header file changes this may affect the object
file (e.g. addition of parameters <br>
with default values, which the programmer may ignore, but
not the compiler). So from makepp&rsquo;s viewpoint only the
produced object file depends on the headers, i.e. must be
<br>
rebuilt when these change.</p>

<p style="margin-top: 1em">Miscellaneous <br>
Why does makepp selectively detect dependencies?</p>

<p style="margin-top: 1em">In this rule why does makepp
make output depend on input1, but not on input2?</p>

<p style="margin-top: 1em">output: <br>
zcat &lt;input1 &gt;output <br>
zcat input2 &gt;&gt;output</p>

<p style="margin-top: 1em">There are three levels to
scanning. The first is the lexer, which tries to understand
the Shell part of the execution. I.e. which commands get
called and what I/O redirections <br>
take place. This notices input1 and output (even if it had
not been declared a target of this rule).</p>

<p style="margin-top: 1em">The next step are the command
parsers. Makepp has a few for typical compilation commands.
These check the command line options to understand what the
command will do. In the <br>
process they pick up dependencies like libraries (&quot;cc
-llib&quot;), include paths (&quot;cc -Idir&quot;) and input
files. The task of a &quot;zcat&quot; parser would be to
know that &quot;-S&quot; takes an <br>
argument, but all other non option words are filenames
(optionally suffixed by .gz), and that &quot;--&quot; ends
options. Alas there is no such parser, no more than for
hundreds of other <br>
commands.</p>

<p style="margin-top: 1em">The third step for some
languages is the scanning of input files, to detect includes
as further dependencies. This does not apply to this
example.</p>

<p style="margin-top: 1em">How can I debug makepp?</p>

<p style="margin-top: 1em">You can put &quot;$(print
)&quot; around a suspicious expression. This returns the
unchanged expression, while printing it as a side
effect.</p>

<p style="margin-top: 1em">You can dump the current
directory&rsquo;s (multiply after &quot;-C&quot; if you
want) makefile with the &quot;--dump-makefile=file&quot;
option, to see how makepp sees it.</p>

<p style="margin-top: 1em">Makepp writes a log of
everything it does and why. You can look at that with
makepplog, mppl or makeppgraph, mppg. You can make it more
verbose by setting the environment <br>
variable &quot;MAKEPP_DEBUG&quot;.</p>

<p style="margin-top: 1em">Makepp records all it knows
about a file, for reuse on the next run. Though it takes
some understanding of makepp&rsquo;s internals, dumping it
with makeppinfo, mppi for one or more <br>
files, usually gives a clue what is wrong.
&quot;MAKEPP_DEBUG&quot; additionally provides the
&quot;RULE_SOURCE&quot;.</p>

<p style="margin-top: 1em">If you are feeling adventurous,
use makepp from cvs. This includes extra modules that hook
into &quot;perl -d&quot; to better display makepp&rsquo;s
internals.</p>

<p style="margin-top: 1em">Is it safe to use?</p>

<p style="margin-top: 1em">Yes, it will do exactly what
your makefiles say (which many programmers find hard to
understand, since rule based inference is very different
from most programming paradigms).</p>

<p style="margin-top: 1em">And no, if you don&rsquo;t trust
the makefiles you got, definitely not! A makefile is a funny
kind of script, the purpose of which is to run commands that
are expected to modify your <br>
file system. Makepp has no means of checking what harm they
will do.</p>

<p style="margin-top: 1em">Worse, there are execute always
syntaxes, which are performed even with
&quot;--dry-run&quot; (which does not run the rules, but
evaluates everything else). That might be something like
<br>
this:</p>

<p style="margin-top: 1em">bad_boy := $(shell rm *)</p>

<p style="margin-top: 1em">External tools <br>
Can I use cc -M or gcc -MM?</p>

<p style="margin-top: 1em">The short answer is yes. The
long answer is that they have the advantage of knowing the
effect of even the last weird compiler option, and
sub-includes hidden in some compiler <br>
internal directory, where makepp only comes pretty close.
The disadvantage is that they have no idea of the build
rules, so they can not reliably depend on yet to-be-built
<br>
files, which includes files to be fetched from a repository.
And they are not extensible to other languages, as
makepp&rsquo;s scanner is. Usually you are at least as well
off, not <br>
resorting to these tools.</p>

<p style="margin-top: 1em">Nonetheless, some compilers can
produce this as a by-product. If you&rsquo;d rather use this
see :include.</p>

<p style="margin-top: 1em">Can I use CCache, Compilercache
or cachecc1?</p>

<p style="margin-top: 1em">The short answer is yes. The
long answer is that these programs need to repeat the work
makepp does, to get a reliable fingerprint of files. With
traditional makes this even <br>
comes too late, because those miss many situations calling
for a recompilation. With makepp it is just easier to use
the built in build cache, which has the added advantage that
<br>
it can handle all kinds of files.</p>

<p style="margin-top: 1em">Note that ccache direct mode has
a bug https://bugzilla.samba.org/show_bug.cgi?id=8728 that
will ignore change in include pathes. This makes
t/makeppreplay.test fail with &quot;wrong <br>
file: out&quot;. Export &quot;CCACHE_NODIRECT=1&quot; to
avoid that.</p>

<p style="margin-top: 1em">AUTHOR <br>
Daniel Pfeiffer (occitan@esperanto.org)</p>

<p style="margin-top: 1em">perl v5.24.1 2016-11-28
MAKEPP_FAQ(1)</p>
<hr>
</body>
</html>
