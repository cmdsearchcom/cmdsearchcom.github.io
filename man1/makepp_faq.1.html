<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>MAKEPP_FAQ(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MAKEPP_FAQ(1)</td>
    <td class="head-vol">Makepp</td>
    <td class="head-rtitle">MAKEPP_FAQ(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
makepp_faq -- Frequently asked questions about makepp
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Here you may find installation instructions and some points which are not
  obvious from the rest of the documentation. This shows stumbling blocks,
  whereas howto type questions will be found in the cookbook.
<h2 class="Ss" title="Ss" id="Getting_Started"><a class="selflink" href="#Getting_Started">Getting
  Started</a></h2>
<i>Where to download?</i>
<div class="Pp"></div>
Makepp is hosted on SourceForge and can be downloaded as a source code tarball
  or as installation package for Debian <i>.deb</i> based Linuxes or <i>.rpm</i>
  based Linuxes from http://sourceforge.net/projects/makepp/files/
<div class="Pp"></div>
Like tons of Perl software, makepp can also be downloaded from CPAN by clicking
  the Download link on http://search.cpan.org/dist/makepp/
<div class="Pp"></div>
Makepp is part of Debian GNU/Linux unstable and testing. This means you can
  install it directly via &quot;apt-get install makepp&quot; or by choosing it
  from your preferred package tool like synaptic.
<div class="Pp"></div>
Makepp is part of archlinux and of Gentoo Linux. Note that distro-specific
  suffixes like 2.0-1 or 2.0-r1 is not the release candidate 1, but the final
  released version 2.0.
<div class="Pp"></div>
<i>Can I try it without installing?</i>
<div class="Pp"></div>
Yes, if you want to try makepp on your own makefiles, either put the directory
  where you unpacked it into your path, or else run it explicitly like this,
  with an absolute or relative path to makepp:
<div class="Pp"></div>
<pre>
    perl /where/you/unpacked/it/makepp
</pre>
<div class="Pp"></div>
<i>How to choose perl version?</i>
<div class="Pp"></div>
You must have Perl 5.8 or newer somewhere on your system. By default all
  uninstalled scripts will use the &quot;perl&quot; in your path. But you can
  run them with an explicit instance of perl. The test runner and installation
  will run everything with this same instance.
<div class="Pp"></div>
<pre>
    /path/to/perl /where/you/unpacked/it/makepp
</pre>
<div class="Pp"></div>
In case some script doesn't properly recognize which &quot;perl&quot; it is
  being run with, you can help it by telling it the path to the same instance of
  perl via the &quot;PERL&quot; variable:
<div class="Pp"></div>
<pre>
    PERL=/path/to/perl /path/to/perl /where/you/unpacked/it/makepp
</pre>
<div class="Pp"></div>
This can also be an instance to be searched in your path, if it doesn't contain
  a directory separator:
<div class="Pp"></div>
<pre>
    PERL=perl5.16.2 perl5.16.2 /where/you/unpacked/it/makepp
</pre>
<div class="Pp"></div>
<i>How to install?</i>
<div class="Pp"></div>
There are two ways to install, which lead to the same result:
<dl class="Bl-tag">
  <dt class="It-tag">configure (alias config.pl)</dt>
  <dd class="It-tag">This allows for traditional style installation:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    ./configure &amp;&amp; make test &amp;&amp; make install
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The only difference between these two is that &quot;configure&quot; is not a
      Perl script, so you can't say &quot;perl configure&quot;, whereas you can
      use all the above variants like &quot;perl config.pl&quot;. Valid options
      are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-b, --bindir=<i>/path/to/installation/bin</i></dt>
  <dd class="It-tag">Where the binaries go (default: <i>prefix</i>/bin).
      Makepp's binaries are just Perl scripts so they are architecture
      independent. If you give this option, but no &quot;--prefix&quot;, it will
      strip <i>/bin</i> to deduce a <i>prefix</i> for the other default
    values.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-d,
    --datadir=<i>/path/to/installation/share/makepp</i></dt>
  <dd class="It-tag">Where to install makepp's library files (default:
      <i>prefix</i>/share/makepp).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-f,
    --findbin=<i>relative/path/to/datadir/from/bindir</i></dt>
  <dd class="It-tag">Where to find libraries relative to executables, or 'none'
      (the default) to find them in <i>datadir</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-h, --htmldir=<i>/path/to/installation/share/html</i></dt>
  <dd class="It-tag">Where the HTML documentation goes (default:
      <i>prefix</i>/doc/makepp if <i>prefix</i>/doc exists, else
      <i>datadir</i>/html), or 'none' if you do not want it installed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-m, --mandir=/<i>path/to/man</i></dt>
  <dd class="It-tag">Where the manual pages should reside (default:
      <i>prefix</i>/share/man if it exists, else <i>prefix</i>/man), or 'none'
      if you do not want them installed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--makefile=<i>/path/to/Makefile</i></dt>
  <dd class="It-tag">Specify location where you can write the Makefile (default:
      .). Unlike the other options, which are remembered for the following
      install step, this file is created immediately.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-p, --prefix=<i>/path/to/installation</i></dt>
  <dd class="It-tag">Specify location where you want to install everything
      (default: /usr/local). All other paths are by default relative to this
      one.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-V</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--version</dt>
  <dd class="It-tag">Print out the version number.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
If you want to do a mockup installation to some destdir for packaging your own
  distribution, you can give an extra parameter to the last command:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    make DESTDIR=/temporary/destdir install
</pre>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">install.pl</dt>
  <dd class="It-tag">This is the backend that performs the actual installation.
      You can call it directly:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    ./install.pl bindir datadir mandir htmldir findbin destdir
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The parameters are optional and correspond to the options from the previous
      section. You are prompted for those you don't supply, except for the last
      one, which is not normally needed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>Makefile.PL</i></dt>
  <dd class="It-tag">The customary file <i>Makefile.PL</i> is currently only
      present for technical reasons. It will <b>not</b> help you to install.
      Therefore, alas, you can't use tools like &quot;cpanm&quot; to install in
      one go.</dd>
</dl>
<div class="Pp"></div>
On some systems whichever &quot;perl&quot; you end up calling may be a symbolic
  link to some precise version &quot;perl5.m.n&quot;. In this case perl sees
  only that one, and will thus use it to install against. If you don't want
  that, use the &quot;PERL&quot; variable as described above. If you install
  with the second variant, i.e. just the name of the executable without slashes,
  the installed scripts will always search for that one via
  &quot;/usr/bin/env&quot;. This makes them a tiny bit slower to start, for a
  greater flexibility.
<div class="Pp"></div>
<i>Why does installation say permission denied?</i>
<div class="Pp"></div>
If you want to install to a system directory like <i>/usr</i>, <i>/usr/local</i>
  or <i>/opt</i>, you can only do that if you run the installation as user root.
  On many Unices you can run a command as root, by prepending &quot;sudo&quot;
  to it, and depending on the system entering the either the root password, or
  yours, as prompted for.
<div class="Pp"></div>
This is not necessary for the preparatory &quot;configure&quot; or
  &quot;config.pl&quot; step which only writes a <i>Makefile</i> in the current
  directory.
<h2 class="Ss" title="Ss" id="Build_Questions"><a class="selflink" href="#Build_Questions">Build
  Questions</a></h2>
<i>What are unimportant targets?</i>
<div class="Pp"></div>
Makepp remembers the dependencies of every file. If any of them need to be
  rebuilt, that will be done before rescanning. But if the build failed, yet the
  scan succeeds, because the file isn't even needed anymore, then at the end the
  failure will be reported as unimportant. (The build should not be attempted,
  instead letting the rescan do those builds it finds to be necessary, but that
  happens in a different place, so this would be difficult.)
<div class="Pp"></div>
<i>Why does it run this rule 3 times?</i>
<div class="Pp"></div>
GNU make has no makepp style multi target rules. Instead it interprets this as a
  shortcut for three separate rules:
<div class="Pp"></div>
<pre>
    a b c:
        echo $@
        touch a b c
</pre>
<div class="Pp"></div>
However, it doesn't check why a file is there. If a file exists (and is newer
  than any dependencies) it is happy. Whichever of the three files gets built
  first, provides the other two, so this behaves somewhat like a multitarget
  rule -- but can cause race conditions in parallel builds.
<div class="Pp"></div>
A similar rule might have been:
<div class="Pp"></div>
<pre>
    a b c:
        touch $@
</pre>
<div class="Pp"></div>
Gmake indeed runs this one once per required file. Without knowing what the
  command does (it might be a script which internally creates some files), the
  two cases can't easily be told apart by makepp.
<div class="Pp"></div>
So as a special compatibility fallback, if a multi target rule action mentions
  only old style $@ and neither new style &quot;$(output)&quot; nor
  &quot;$(target)&quot; nor their plural forms, it is treated as separate rules.
  This however means running it repeatedly, as makepp ignores randomly appearing
  files for which it has no metadata.
<div class="Pp"></div>
<i>Why does it complain that a created file is phony?</i>
<div class="Pp"></div>
If you have a command that continues working asynchronously, after it came back
  with a success return code, makepp will notice the promised file as missing
  and complain. This can also typically happen on some network file systems,
  which may physically write only several seconds later.
<div class="Pp"></div>
If you cannot evite such an unsatisfactory situation, you can ask makepp to be
  sloppy about this check with the &quot;--gullible&quot; option. But then the
  next command which depends on the produced file might still fail.
<div class="Pp"></div>
<i>Why does it recreate files unnecessarily?</i>
<div class="Pp"></div>
I have observed this on NFS, where due to file attribute caching the timestamp
  of the produced file was not yet the one the it finally had. On the next run
  makepp noticed the difference and considered the file unduly modified. This
  got resolved with a mount option of &quot;acregmin=0&quot;, making attributes
  visible immediately.
<div class="Pp"></div>
This can also happen with repositories, e.g. if someone else has built in the
  repository with &quot;umask 066&quot; or using a compiler that bars others
  from reading the produced file. This will also happen if either the repository
  or your build tree shares a common path prefix with some dependencies (e.g.
  <i>/opt/repository</i> and <i>/opt/sometool</i>, in which case makepp will
  remember the path once as relative, and once as absolute, looking like changed
  dependencies.
<div class="Pp"></div>
<i>Does the C source file or the object file depend on headers?</i>
<div class="Pp"></div>
It depends on your viewpoint. If a prototype in a header changes, the programmer
  may have to adapt the source code. So from that viewpoint there is a
  dependency.
<div class="Pp"></div>
But for the build this is completely irrelevant. Here the outputs depend on the
  inputs. If a header file changes this may affect the object file (e.g.
  addition of parameters with default values, which the programmer may ignore,
  but not the compiler). So from makepp's viewpoint only the produced object
  file depends on the headers, i.e. must be rebuilt when these change.
<h2 class="Ss" title="Ss" id="Miscellaneous"><a class="selflink" href="#Miscellaneous">Miscellaneous</a></h2>
<i>Why does makepp selectively detect dependencies?</i>
<div class="Pp"></div>
In this rule why does makepp make <i>output</i> depend on <i>input1</i>, but not
  on <i>input2</i>?
<div class="Pp"></div>
<pre>
    output:
        zcat &lt;input1 &gt;output
        zcat input2 &gt;&gt;output
</pre>
<div class="Pp"></div>
There are three levels to scanning. The first is the lexer, which tries to
  understand the Shell part of the execution. I.e. which commands get called and
  what I/O redirections take place. This notices <i>input1</i> and <i>output</i>
  (even if it had not been declared a target of this rule).
<div class="Pp"></div>
The next step are the command parsers. Makepp has a few for typical compilation
  commands. These check the command line options to understand what the command
  will do. In the process they pick up dependencies like libraries (&quot;cc
  -llib&quot;), include paths (&quot;cc -Idir&quot;) and input files. The task
  of a &quot;zcat&quot; parser would be to know that &quot;-S&quot; takes an
  argument, but all other non option words are filenames (optionally suffixed by
  <i>.gz</i>), and that &quot;--&quot; ends options. Alas there is no such
  parser, no more than for hundreds of other commands.
<div class="Pp"></div>
The third step for some languages is the scanning of input files, to detect
  includes as further dependencies. This does not apply to this example.
<div class="Pp"></div>
<i>How can I debug makepp?</i>
<div class="Pp"></div>
You can put &quot;$(print )&quot; around a suspicious expression. This returns
  the unchanged expression, while printing it as a side effect.
<div class="Pp"></div>
You can dump the current directory's (multiply after &quot;-C&quot; if you want)
  makefile with the &quot;--dump-makefile=file&quot; option, to see how makepp
  sees it.
<div class="Pp"></div>
Makepp writes a log of everything it does and why. You can look at that with
  makepplog, mppl or makeppgraph, mppg. You can make it more verbose by setting
  the environment variable &quot;MAKEPP_DEBUG&quot;.
<div class="Pp"></div>
Makepp records all it knows about a file, for reuse on the next run. Though it
  takes some understanding of makepp's internals, dumping it with makeppinfo,
  mppi for one or more files, usually gives a clue what is wrong.
  &quot;MAKEPP_DEBUG&quot; additionally provides the &quot;RULE_SOURCE&quot;.
<div class="Pp"></div>
If you are feeling adventurous, use makepp from cvs. This includes extra modules
  that hook into &quot;perl -d&quot; to better display makepp's internals.
<div class="Pp"></div>
<i>Is it safe to use?</i>
<div class="Pp"></div>
<b>Yes</b>, it will do exactly what your makefiles say (which many programmers
  find hard to understand, since rule based inference is very different from
  most programming paradigms).
<div class="Pp"></div>
<b>And no</b>, if you don't trust the makefiles you got, definitely not! A
  makefile is a funny kind of script, the purpose of which is to run commands
  that are expected to modify your file system. Makepp has no means of checking
  what harm they will do.
<div class="Pp"></div>
Worse, there are execute always syntaxes, which are performed even with
  &quot;--dry-run&quot; (which does not run the rules, but evaluates everything
  else). That might be something like this:
<div class="Pp"></div>
<pre>
    bad_boy := $(shell rm *)
</pre>
<h2 class="Ss" title="Ss" id="External_tools"><a class="selflink" href="#External_tools">External
  tools</a></h2>
<i>Can I use cc -M or gcc -MM?</i>
<div class="Pp"></div>
The short answer is yes. The long answer is that they have the advantage of
  knowing the effect of even the last weird compiler option, and sub-includes
  hidden in some compiler internal directory, where makepp only comes pretty
  close. The disadvantage is that they have no idea of the build rules, so they
  can not reliably depend on yet to-be-built files, which includes files to be
  fetched from a repository. And they are not extensible to other languages, as
  makepp's scanner is. Usually you are at least as well off, not resorting to
  these tools.
<div class="Pp"></div>
Nonetheless, some compilers can produce this as a by-product. If you'd rather
  use this see :include.
<div class="Pp"></div>
<i>Can I use CCache, Compilercache or cachecc1?</i>
<div class="Pp"></div>
The short answer is yes. The long answer is that these programs need to repeat
  the work makepp does, to get a reliable fingerprint of files. With traditional
  makes this even comes too late, because those miss many situations calling for
  a recompilation. With makepp it is just easier to use the built in build
  cache, which has the added advantage that it can handle all kinds of files.
<div class="Pp"></div>
Note that ccache direct mode has a bug
  https://bugzilla.samba.org/show_bug.cgi?id=8728 that will ignore change in
  include pathes. This makes <i>t/makeppreplay.test</i> fail with &quot;wrong
  file: out&quot;. Export &quot;CCACHE_NODIRECT=1&quot; to avoid that.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Daniel Pfeiffer (occitan@esperanto.org)</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-28</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
