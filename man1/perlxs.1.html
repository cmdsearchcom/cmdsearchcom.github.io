<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:16 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLXS(1) Perl Programmers Reference Guide PERLXS(1)</p>

<p style="margin-top: 1em">NAME <br>
perlxs - XS language reference manual</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Introduction <br>
XS is an interface description file format used to create an
extension interface between Perl and C code (or a C library)
which one wishes to use with Perl. The XS interface is <br>
combined with the library to create a new library which can
then be either dynamically loaded or statically linked into
perl. The XS interface description is written in the XS <br>
language and is the core component of the Perl extension
interface.</p>

<p style="margin-top: 1em">An XSUB forms the basic unit of
the XS interface. After compilation by the xsubpp compiler,
each XSUB amounts to a C function definition which will
provide the glue between Perl <br>
calling conventions and C calling conventions.</p>

<p style="margin-top: 1em">The glue code pulls the
arguments from the Perl stack, converts these Perl values to
the formats expected by a C function, call this C function,
transfers the return values of <br>
the C function back to Perl. Return values here may be a
conventional C return value or any C function arguments that
may serve as output parameters. These return values may be
<br>
passed back to Perl either by putting them on the Perl
stack, or by modifying the arguments supplied from the Perl
side.</p>

<p style="margin-top: 1em">The above is a somewhat
simplified view of what really happens. Since Perl allows
more flexible calling conventions than C, XSUBs may do much
more in practice, such as checking <br>
input parameters for validity, throwing exceptions (or
returning undef/empty list) if the return value from the C
function indicates failure, calling different C functions
based <br>
on numbers and types of the arguments, providing an
object-oriented interface, etc.</p>

<p style="margin-top: 1em">Of course, one could write such
glue code directly in C. However, this would be a tedious
task, especially if one needs to write glue for multiple C
functions, and/or one is not <br>
familiar enough with the Perl stack discipline and other
such arcana. XS comes to the rescue here: instead of writing
this glue C code in long-hand, one can write a more concise
<br>
short-hand description of what should be done by the glue,
and let the XS compiler xsubpp handle the rest.</p>

<p style="margin-top: 1em">The XS language allows one to
describe the mapping between how the C routine is used, and
how the corresponding Perl routine is used. It also allows
creation of Perl routines <br>
which are directly translated to C code and which are not
related to a pre-existing C function. In cases when the C
interface coincides with the Perl interface, the XSUB <br>
declaration is almost identical to a declaration of a C
function (in K&amp;R style). In such circumstances, there is
another tool called &quot;h2xs&quot; that is able to
translate an entire C <br>
header file into a corresponding XS file that will provide
glue to the functions/macros described in the header
file.</p>

<p style="margin-top: 1em">The XS compiler is called
xsubpp. This compiler creates the constructs necessary to
let an XSUB manipulate Perl values, and creates the glue
necessary to let Perl call the XSUB. <br>
The compiler uses typemaps to determine how to map C
function parameters and output values to Perl values and
back. The default typemap (which comes with Perl) handles
many <br>
common C types. A supplementary typemap may also be needed
to handle any special structures and types for the library
being linked. For more information on typemaps, see <br>
perlxstypemap.</p>

<p style="margin-top: 1em">A file in XS format starts with
a C language section which goes until the first &quot;MODULE
=&quot; directive. Other XS directives and XSUB definitions
may follow this line. The <br>
&quot;language&quot; used in this part of the file is
usually referred to as the XS language. xsubpp recognizes
and skips POD (see perlpod) in both the C and XS language
sections, which <br>
allows the XS file to contain embedded documentation.</p>

<p style="margin-top: 1em">See perlxstut for a tutorial on
the whole extension creation process.</p>

<p style="margin-top: 1em">Note: For some extensions, Dave
Beazley&rsquo;s SWIG system may provide a significantly more
convenient mechanism for creating the extension glue code.
See &lt;http://www.swig.org/&gt; for <br>
more information.</p>

<p style="margin-top: 1em">On The Road <br>
Many of the examples which follow will concentrate on
creating an interface between Perl and the ONC+ RPC bind
library functions. The rpcb_gettime() function is used to
<br>
demonstrate many features of the XS language. This function
has two parameters; the first is an input parameter and the
second is an output parameter. The function also returns
<br>
a status value.</p>

<p style="margin-top: 1em">bool_t rpcb_gettime(const char
*host, time_t *timep);</p>

<p style="margin-top: 1em">From C this function will be
called with the following statements.</p>

<p style="margin-top: 1em">#include &lt;rpc/rpc.h&gt; <br>
bool_t status; <br>
time_t timep; <br>
status = rpcb_gettime( &quot;localhost&quot;, &amp;timep
);</p>

<p style="margin-top: 1em">If an XSUB is created to offer a
direct translation between this function and Perl, then this
XSUB will be used from Perl with the following code. The
$status and $timep <br>
variables will contain the output of the function.</p>

<p style="margin-top: 1em">use RPC; <br>
$status = rpcb_gettime( &quot;localhost&quot;, $timep );</p>

<p style="margin-top: 1em">The following XS file shows an
XS subroutine, or XSUB, which demonstrates one possible
interface to the rpcb_gettime() function. This XSUB
represents a direct translation <br>
between C and Perl and so preserves the interface even from
Perl. This XSUB will be invoked from Perl with the usage
shown above. Note that the first three #include statements,
<br>
for &quot;EXTERN.h&quot;, &quot;perl.h&quot;, and
&quot;XSUB.h&quot;, will always be present at the beginning
of an XS file. This approach and others will be expanded
later in this document.</p>

<p style="margin-top: 1em">#include &quot;EXTERN.h&quot;
<br>
#include &quot;perl.h&quot; <br>
#include &quot;XSUB.h&quot; <br>
#include &lt;rpc/rpc.h&gt;</p>

<p style="margin-top: 1em">MODULE = RPC PACKAGE = RPC</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
time_t &amp;timep <br>
OUTPUT: <br>
timep</p>

<p style="margin-top: 1em">Any extension to Perl, including
those containing XSUBs, should have a Perl module to serve
as the bootstrap which pulls the extension into Perl. This
module will export the <br>
extension&rsquo;s functions and variables to the Perl
program and will cause the extension&rsquo;s XSUBs to be
linked into Perl. The following module will be used for most
of the examples <br>
in this document and should be used from Perl with the
&quot;use&quot; command as shown earlier. Perl modules are
explained in more detail later in this document.</p>

<p style="margin-top: 1em">package RPC;</p>

<p style="margin-top: 1em">require Exporter; <br>
require DynaLoader; <br>
@ISA = qw(Exporter DynaLoader); <br>
@EXPORT = qw( rpcb_gettime );</p>

<p style="margin-top: 1em">bootstrap RPC; <br>
1;</p>

<p style="margin-top: 1em">Throughout this document a
variety of interfaces to the rpcb_gettime() XSUB will be
explored. The XSUBs will take their parameters in different
orders or will take different <br>
numbers of parameters. In each case the XSUB is an
abstraction between Perl and the real C rpcb_gettime()
function, and the XSUB must always ensure that the real
rpcb_gettime() <br>
function is called with the correct parameters. This
abstraction will allow the programmer to create a more
Perl-like interface to the C function.</p>

<p style="margin-top: 1em">The Anatomy of an XSUB <br>
The simplest XSUBs consist of 3 parts: a description of the
return value, the name of the XSUB routine and the names of
its arguments, and a description of types or formats of <br>
the arguments.</p>

<p style="margin-top: 1em">The following XSUB allows a Perl
program to access a C library function called sin(). The
XSUB will imitate the C function which takes a single
argument and returns a single <br>
value.</p>

<p style="margin-top: 1em">double <br>
sin(x) <br>
double x</p>

<p style="margin-top: 1em">Optionally, one can merge the
description of types and the list of argument names,
rewriting this as</p>

<p style="margin-top: 1em">double <br>
sin(double x)</p>

<p style="margin-top: 1em">This makes this XSUB look
similar to an ANSI C declaration. An optional semicolon is
allowed after the argument list, as in</p>

<p style="margin-top: 1em">double <br>
sin(double x);</p>

<p style="margin-top: 1em">Parameters with C pointer types
can have different semantic: C functions with similar
declarations</p>

<p style="margin-top: 1em">bool
string_looks_as_a_number(char *s); <br>
bool make_char_uppercase(char *c);</p>

<p style="margin-top: 1em">are used in absolutely
incompatible manner. Parameters to these functions could be
described xsubpp like this:</p>

<p style="margin-top: 1em">char * s <br>
char &amp;c</p>

<p style="margin-top: 1em">Both these XS declarations
correspond to the &quot;char*&quot; C type, but they have
different semantics, see &quot;The &amp; Unary
Operator&quot;.</p>

<p style="margin-top: 1em">It is convenient to think that
the indirection operator &quot;*&quot; should be considered
as a part of the type and the address operator
&quot;&amp;&quot; should be considered part of the variable.
<br>
See perlxstypemap for more info about handling qualifiers
and unary operators in C types.</p>

<p style="margin-top: 1em">The function name and the return
type must be placed on separate lines and should be flush
left-adjusted.</p>

<p style="margin-top: 1em">INCORRECT CORRECT</p>

<p style="margin-top: 1em">double sin(x) double <br>
double x sin(x) <br>
double x</p>

<p style="margin-top: 1em">The rest of the function
description may be indented or left-adjusted. The following
example shows a function with its body left-adjusted. Most
examples in this document will <br>
indent the body for better readability.</p>

<p style="margin-top: 1em">CORRECT</p>

<p style="margin-top: 1em">double <br>
sin(x) <br>
double x</p>

<p style="margin-top: 1em">More complicated XSUBs may
contain many other sections. Each section of an XSUB starts
with the corresponding keyword, such as INIT: or CLEANUP:.
However, the first two lines <br>
of an XSUB always contain the same data: descriptions of the
return type and the names of the function and its
parameters. Whatever immediately follows these is considered
to be <br>
an INPUT: section unless explicitly marked with another
keyword. (See &quot;The INPUT: Keyword&quot;.)</p>

<p style="margin-top: 1em">An XSUB section continues until
another section-start keyword is found.</p>

<p style="margin-top: 1em">The Argument Stack <br>
The Perl argument stack is used to store the values which
are sent as parameters to the XSUB and to store the
XSUB&rsquo;s return value(s). In reality all Perl functions
(including <br>
non-XSUB ones) keep their values on this stack all the same
time, each limited to its own range of positions on the
stack. In this document the first position on that stack
<br>
which belongs to the active function will be referred to as
position 0 for that function.</p>

<p style="margin-top: 1em">XSUBs refer to their stack
arguments with the macro ST(x), where x refers to a position
in this XSUB&rsquo;s part of the stack. Position 0 for that
function would be known to the XSUB <br>
as ST(0). The XSUB&rsquo;s incoming parameters and outgoing
return values always begin at ST(0). For many simple cases
the xsubpp compiler will generate the code necessary to
handle <br>
the argument stack by embedding code fragments found in the
typemaps. In more complex cases the programmer must supply
the code.</p>

<p style="margin-top: 1em">The RETVAL Variable <br>
The RETVAL variable is a special C variable that is declared
automatically for you. The C type of RETVAL matches the
return type of the C library function. The xsubpp compiler
<br>
will declare this variable in each XSUB with
non-&quot;void&quot; return type. By default the generated C
function will use RETVAL to hold the return value of the C
library function being <br>
called. In simple cases the value of RETVAL will be placed
in ST(0) of the argument stack where it can be received by
Perl as the return value of the XSUB.</p>

<p style="margin-top: 1em">If the XSUB has a return type of
&quot;void&quot; then the compiler will not declare a RETVAL
variable for that function. When using a PPCODE: section no
manipulation of the RETVAL <br>
variable is required, the section may use direct stack
manipulation to place output values on the stack.</p>

<p style="margin-top: 1em">If PPCODE: directive is not
used, &quot;void&quot; return value should be used only for
subroutines which do not return a value, even if CODE:
directive is used which sets ST(0) <br>
explicitly.</p>

<p style="margin-top: 1em">Older versions of this document
recommended to use &quot;void&quot; return value in such
cases. It was discovered that this could lead to segfaults
in cases when XSUB was truly &quot;void&quot;. <br>
This practice is now deprecated, and may be not supported at
some future version. Use the return value &quot;SV *&quot;
in such cases. (Currently &quot;xsubpp&quot; contains some
heuristic code <br>
which tries to disambiguate between &quot;truly-void&quot;
and &quot;old-practice-declared-as-void&quot; functions.
Hence your code is at mercy of this heuristics unless you
use &quot;SV *&quot; as return <br>
value.)</p>

<p style="margin-top: 1em">Returning SVs, AVs and HVs
through RETVAL <br>
When you&rsquo;re using RETVAL to return an &quot;SV
*&quot;, there&rsquo;s some magic going on behind the scenes
that should be mentioned. When you&rsquo;re manipulating the
argument stack using the ST(x) <br>
macro, for example, you usually have to pay special
attention to reference counts. (For more about reference
counts, see perlguts.) To make your life easier, the typemap
file <br>
automatically makes &quot;RETVAL&quot; mortal when
you&rsquo;re returning an &quot;SV *&quot;. Thus, the
following two XSUBs are more or less equivalent:</p>

<p style="margin-top: 1em">void <br>
alpha() <br>
PPCODE: <br>
ST(0) = newSVpv(&quot;Hello World&quot;,0); <br>
sv_2mortal(ST(0)); <br>
XSRETURN(1);</p>

<p style="margin-top: 1em">SV * <br>
beta() <br>
CODE: <br>
RETVAL = newSVpv(&quot;Hello World&quot;,0); <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">This is quite useful as it
usually improves readability. While this works fine for an
&quot;SV *&quot;, it&rsquo;s unfortunately not as easy to
have &quot;AV *&quot; or &quot;HV *&quot; as a return value.
You <br>
should be able to write:</p>

<p style="margin-top: 1em">AV * <br>
array() <br>
CODE: <br>
RETVAL = newAV(); <br>
/* do something with RETVAL */ <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">But due to an unfixable bug
(fixing it would break lots of existing CPAN modules) in the
typemap file, the reference count of the &quot;AV *&quot; is
not properly decremented. Thus, the <br>
above XSUB would leak memory whenever it is being called.
The same problem exists for &quot;HV *&quot;, &quot;CV
*&quot;, and &quot;SVREF&quot; (which indicates a scalar
reference, not a general &quot;SV *&quot;). In <br>
XS code on perls starting with perl 5.16, you can override
the typemaps for any of these types with a version that has
proper handling of refcounts. In your &quot;TYPEMAP&quot;
section, do</p>

<p style="margin-top: 1em">AV* T_AVREF_REFCOUNT_FIXED</p>

<p style="margin-top: 1em">to get the repaired variant. For
backward compatibility with older versions of perl, you can
instead decrement the reference count manually when
you&rsquo;re returning one of the <br>
aforementioned types using &quot;sv_2mortal&quot;:</p>

<p style="margin-top: 1em">AV * <br>
array() <br>
CODE: <br>
RETVAL = newAV(); <br>
sv_2mortal((SV*)RETVAL); <br>
/* do something with RETVAL */ <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">Remember that you don&rsquo;t
have to do this for an &quot;SV *&quot;. The reference
documentation for all core typemaps can be found in
perlxstypemap.</p>

<p style="margin-top: 1em">The MODULE Keyword <br>
The MODULE keyword is used to start the XS code and to
specify the package of the functions which are being
defined. All text preceding the first MODULE keyword is
considered C <br>
code and is passed through to the output with POD stripped,
but otherwise untouched. Every XS module will have a
bootstrap function which is used to hook the XSUBs into
Perl. <br>
The package name of this bootstrap function will match the
value of the last MODULE statement in the XS source files.
The value of MODULE should always remain constant within
<br>
the same XS file, though this is not required.</p>

<p style="margin-top: 1em">The following example will start
the XS code and will place all functions in a package named
RPC.</p>

<p style="margin-top: 1em">MODULE = RPC</p>

<p style="margin-top: 1em">The PACKAGE Keyword <br>
When functions within an XS source file must be separated
into packages the PACKAGE keyword should be used. This
keyword is used with the MODULE keyword and must follow <br>
immediately after it when used.</p>

<p style="margin-top: 1em">MODULE = RPC PACKAGE = RPC</p>

<p style="margin-top: 1em">[ XS code in package RPC ]</p>

<p style="margin-top: 1em">MODULE = RPC PACKAGE = RPCB</p>

<p style="margin-top: 1em">[ XS code in package RPCB ]</p>

<p style="margin-top: 1em">MODULE = RPC PACKAGE = RPC</p>

<p style="margin-top: 1em">[ XS code in package RPC ]</p>

<p style="margin-top: 1em">The same package name can be
used more than once, allowing for non-contiguous code. This
is useful if you have a stronger ordering principle than
package names.</p>

<p style="margin-top: 1em">Although this keyword is
optional and in some cases provides redundant information it
should always be used. This keyword will ensure that the
XSUBs appear in the desired <br>
package.</p>

<p style="margin-top: 1em">The PREFIX Keyword <br>
The PREFIX keyword designates prefixes which should be
removed from the Perl function names. If the C function is
&quot;rpcb_gettime()&quot; and the PREFIX value is
&quot;rpcb_&quot; then Perl will <br>
see this function as &quot;gettime()&quot;.</p>

<p style="margin-top: 1em">This keyword should follow the
PACKAGE keyword when used. If PACKAGE is not used then
PREFIX should follow the MODULE keyword.</p>

<p style="margin-top: 1em">MODULE = RPC PREFIX = rpc_</p>

<p style="margin-top: 1em">MODULE = RPC PACKAGE = RPCB
PREFIX = rpcb_</p>

<p style="margin-top: 1em">The OUTPUT: Keyword <br>
The OUTPUT: keyword indicates that certain function
parameters should be updated (new values made visible to
Perl) when the XSUB terminates or that certain values should
be <br>
returned to the calling Perl function. For simple functions
which have no CODE: or PPCODE: section, such as the sin()
function above, the RETVAL variable is automatically <br>
designated as an output value. For more complex functions
the xsubpp compiler will need help to determine which
variables are output variables.</p>

<p style="margin-top: 1em">This keyword will normally be
used to complement the CODE: keyword. The RETVAL variable is
not recognized as an output variable when the CODE: keyword
is present. The OUTPUT: <br>
keyword is used in this situation to tell the compiler that
RETVAL really is an output variable.</p>

<p style="margin-top: 1em">The OUTPUT: keyword can also be
used to indicate that function parameters are output
variables. This may be necessary when a parameter has been
modified within the function and <br>
the programmer would like the update to be seen by Perl.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
time_t &amp;timep <br>
OUTPUT: <br>
timep</p>

<p style="margin-top: 1em">The OUTPUT: keyword will also
allow an output parameter to be mapped to a matching piece
of code rather than to a typemap.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
time_t &amp;timep <br>
OUTPUT: <br>
timep sv_setnv(ST(1), (double)timep);</p>

<p style="margin-top: 1em">xsubpp emits an automatic
&quot;SvSETMAGIC()&quot; for all parameters in the OUTPUT
section of the XSUB, except RETVAL. This is the usually
desired behavior, as it takes care of properly <br>
invoking &rsquo;set&rsquo; magic on output parameters
(needed for hash or array element parameters that must be
created if they didn&rsquo;t exist). If for some reason,
this behavior is not <br>
desired, the OUTPUT section may contain a &quot;SETMAGIC:
DISABLE&quot; line to disable it for the remainder of the
parameters in the OUTPUT section. Likewise, &quot;SETMAGIC:
ENABLE&quot; can be <br>
used to reenable it for the remainder of the OUTPUT section.
See perlguts for more details about &rsquo;set&rsquo;
magic.</p>

<p style="margin-top: 1em">The NO_OUTPUT Keyword <br>
The NO_OUTPUT can be placed as the first token of the XSUB.
This keyword indicates that while the C subroutine we
provide an interface to has a non-&quot;void&quot; return
type, the <br>
return value of this C subroutine should not be returned
from the generated Perl subroutine.</p>

<p style="margin-top: 1em">With this keyword present
&quot;The RETVAL Variable&quot; is created, and in the
generated call to the subroutine this variable is assigned
to, but the value of this variable is not going <br>
to be used in the auto-generated code.</p>

<p style="margin-top: 1em">This keyword makes sense only if
&quot;RETVAL&quot; is going to be accessed by the
user-supplied code. It is especially useful to make a
function interface more Perl-like, especially when <br>
the C return value is just an error condition indicator. For
example,</p>

<p style="margin-top: 1em">NO_OUTPUT int <br>
delete_file(char *name) <br>
POSTCALL: <br>
if (RETVAL != 0) <br>
croak(&quot;Error %d while deleting file
&rsquo;%s&rsquo;&quot;, RETVAL, name);</p>

<p style="margin-top: 1em">Here the generated XS function
returns nothing on success, and will die() with a meaningful
error message on error.</p>

<p style="margin-top: 1em">The CODE: Keyword <br>
This keyword is used in more complicated XSUBs which require
special handling for the C function. The RETVAL variable is
still declared, but it will not be returned unless it is
<br>
specified in the OUTPUT: section.</p>

<p style="margin-top: 1em">The following XSUB is for a C
function which requires special handling of its parameters.
The Perl usage is given first.</p>

<p style="margin-top: 1em">$status = rpcb_gettime(
&quot;localhost&quot;, $timep );</p>

<p style="margin-top: 1em">The XSUB follows.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
time_t timep <br>
CODE: <br>
RETVAL = rpcb_gettime( host, &amp;timep ); <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">The INIT: Keyword <br>
The INIT: keyword allows initialization to be inserted into
the XSUB before the compiler generates the call to the C
function. Unlike the CODE: keyword above, this keyword does
<br>
not affect the way the compiler handles RETVAL.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
time_t &amp;timep <br>
INIT: <br>
printf(&quot;# Host is %s0, host ); <br>
OUTPUT: <br>
timep</p>

<p style="margin-top: 1em">Another use for the INIT:
section is to check for preconditions before making a call
to the C function:</p>

<p style="margin-top: 1em">long long <br>
lldiv(a,b) <br>
long long a <br>
long long b <br>
INIT: <br>
if (a == 0 &amp;&amp; b == 0) <br>
XSRETURN_UNDEF; <br>
if (b == 0) <br>
croak(&quot;lldiv: cannot divide by 0&quot;);</p>

<p style="margin-top: 1em">The NO_INIT Keyword <br>
The NO_INIT keyword is used to indicate that a function
parameter is being used only as an output value. The xsubpp
compiler will normally generate code to read the values of
<br>
all function parameters from the argument stack and assign
them to C variables upon entry to the function. NO_INIT will
tell the compiler that some parameters will be used for <br>
output rather than for input and that they will be handled
before the function terminates.</p>

<p style="margin-top: 1em">The following example shows a
variation of the rpcb_gettime() function. This function uses
the timep variable only as an output variable and does not
care about its initial <br>
contents.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
time_t &amp;timep = NO_INIT <br>
OUTPUT: <br>
timep</p>

<p style="margin-top: 1em">The TYPEMAP: Keyword <br>
Starting with Perl 5.16, you can embed typemaps into your XS
code instead of or in addition to typemaps in a separate
file. Multiple such embedded typemaps will be processed in
<br>
order of appearance in the XS code and like local typemap
files take precendence over the default typemap, the
embedded typemaps may overwrite previous definitions of
TYPEMAP, <br>
INPUT, and OUTPUT stanzas. The syntax for embedded typemaps
is</p>

<p style="margin-top: 1em">TYPEMAP: &lt;&lt;HERE <br>
... your typemap code here ... <br>
HERE</p>

<p style="margin-top: 1em">where the &quot;TYPEMAP&quot;
keyword must appear in the first column of a new line.</p>

<p style="margin-top: 1em">Refer to perlxstypemap for
details on writing typemaps.</p>

<p style="margin-top: 1em">Initializing Function Parameters
<br>
C function parameters are normally initialized with their
values from the argument stack (which in turn contains the
parameters that were passed to the XSUB from Perl). The <br>
typemaps contain the code segments which are used to
translate the Perl values to the C parameters. The
programmer, however, is allowed to override the typemaps and
supply <br>
alternate (or additional) initialization code.
Initialization code starts with the first &quot;=&quot;,
&quot;;&quot; or &quot;+&quot; on a line in the INPUT:
section. The only exception happens if this &quot;;&quot;
<br>
terminates the line, then this &quot;;&quot; is quietly
ignored.</p>

<p style="margin-top: 1em">The following code demonstrates
how to supply initialization code for function parameters.
The initialization code is eval&rsquo;ed within double
quotes by the compiler before it is <br>
added to the output so anything which should be interpreted
literally [mainly &quot;$&quot;, &quot;@&quot;, or
&quot;\&quot;] must be protected with backslashes. The
variables $var, $arg, and $type can be <br>
used as in typemaps.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host = (char *)SvPV_nolen($arg); <br>
time_t &amp;timep = 0; <br>
OUTPUT: <br>
timep</p>

<p style="margin-top: 1em">This should not be used to
supply default values for parameters. One would normally use
this when a function parameter must be processed by another
library function before it <br>
can be used. Default parameters are covered in the next
section.</p>

<p style="margin-top: 1em">If the initialization begins
with &quot;=&quot;, then it is output in the declaration for
the input variable, replacing the initialization supplied by
the typemap. If the initialization <br>
begins with &quot;;&quot; or &quot;+&quot;, then it is
performed after all of the input variables have been
declared. In the &quot;;&quot; case the initialization
normally supplied by the typemap is not <br>
performed. For the &quot;+&quot; case, the declaration for
the variable will include the initialization from the
typemap. A global variable, %v, is available for the truly
rare case <br>
where information from one initialization is needed in
another initialization.</p>

<p style="margin-top: 1em">Here&rsquo;s a truly obscure
example:</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
time_t &amp;timep; /* {timep}=@{[$v{timep}=$arg]} */ <br>
char *host + SvOK($v{timep}) ? SvPV_nolen($arg) : NULL; <br>
OUTPUT: <br>
timep</p>

<p style="margin-top: 1em">The construct
&quot;{timep}=@{[$v{timep}=$arg]}&quot; used in the above
example has a two-fold purpose: first, when this line is
processed by xsubpp, the Perl snippet
&quot;$v{timep}=$arg&quot; <br>
is evaluated. Second, the text of the evaluated snippet is
output into the generated C file (inside a C comment)!
During the processing of &quot;char *host&quot; line, $arg
will evaluate <br>
to ST(0), and $v{timep} will evaluate to ST(1).</p>

<p style="margin-top: 1em">Default Parameter Values <br>
Default values for XSUB arguments can be specified by
placing an assignment statement in the parameter list. The
default value may be a number, a string or the special
string <br>
&quot;NO_INIT&quot;. Defaults should always be used on the
right-most parameters only.</p>

<p style="margin-top: 1em">To allow the XSUB for
rpcb_gettime() to have a default host value the parameters
to the XSUB could be rearranged. The XSUB will then call the
real rpcb_gettime() function with <br>
the parameters in the correct order. This XSUB can be called
from Perl with either of the following statements:</p>

<p style="margin-top: 1em">$status = rpcb_gettime( $timep,
$host );</p>

<p style="margin-top: 1em">$status = rpcb_gettime( $timep
);</p>

<p style="margin-top: 1em">The XSUB will look like the code
which follows. A CODE: block is used to call the real
rpcb_gettime() function with the parameters in the correct
order for that function.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(timep,host=&quot;localhost&quot;) <br>
char *host <br>
time_t timep = NO_INIT <br>
CODE: <br>
RETVAL = rpcb_gettime( host, &amp;timep ); <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">The PREINIT: Keyword <br>
The PREINIT: keyword allows extra variables to be declared
immediately before or after the declarations of the
parameters from the INPUT: section are emitted.</p>

<p style="margin-top: 1em">If a variable is declared inside
a CODE: section it will follow any typemap code that is
emitted for the input parameters. This may result in the
declaration ending up after C <br>
code, which is C syntax error. Similar errors may happen
with an explicit &quot;;&quot;-type or &quot;+&quot;-type
initialization of parameters is used (see &quot;Initializing
Function Parameters&quot;). <br>
Declaring these variables in an INIT: section will not
help.</p>

<p style="margin-top: 1em">In such cases, to force an
additional variable to be declared together with
declarations of other variables, place the declaration into
a PREINIT: section. The PREINIT: keyword <br>
may be used one or more times within an XSUB.</p>

<p style="margin-top: 1em">The following examples are
equivalent, but if the code is using complex typemaps then
the first example is safer.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(timep) <br>
time_t timep = NO_INIT <br>
PREINIT: <br>
char *host = &quot;localhost&quot;; <br>
CODE: <br>
RETVAL = rpcb_gettime( host, &amp;timep ); <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">For this particular case an
INIT: keyword would generate the same C code as the PREINIT:
keyword. Another correct, but error-prone example:</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(timep) <br>
time_t timep = NO_INIT <br>
CODE: <br>
char *host = &quot;localhost&quot;; <br>
RETVAL = rpcb_gettime( host, &amp;timep ); <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">Another way to declare
&quot;host&quot; is to use a C block in the CODE:
section:</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(timep) <br>
time_t timep = NO_INIT <br>
CODE: <br>
{ <br>
char *host = &quot;localhost&quot;; <br>
RETVAL = rpcb_gettime( host, &amp;timep ); <br>
} <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">The ability to put additional
declarations before the typemap entries are processed is
very handy in the cases when typemap conversions manipulate
some global state:</p>

<p style="margin-top: 1em">MyObject <br>
mutate(o) <br>
PREINIT: <br>
MyState st = global_state; <br>
INPUT: <br>
MyObject o; <br>
CLEANUP: <br>
reset_to(global_state, st);</p>

<p style="margin-top: 1em">Here we suppose that conversion
to &quot;MyObject&quot; in the INPUT: section and from
MyObject when processing RETVAL will modify a global
variable &quot;global_state&quot;. After these <br>
conversions are performed, we restore the old value of
&quot;global_state&quot; (to avoid memory leaks, for
example).</p>

<p style="margin-top: 1em">There is another way to trade
clarity for compactness: INPUT sections allow declaration of
C variables which do not appear in the parameter list of a
subroutine. Thus the above <br>
code for mutate() can be rewritten as</p>

<p style="margin-top: 1em">MyObject <br>
mutate(o) <br>
MyState st = global_state; <br>
MyObject o; <br>
CLEANUP: <br>
reset_to(global_state, st);</p>

<p style="margin-top: 1em">and the code for rpcb_gettime()
can be rewritten as</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(timep) <br>
time_t timep = NO_INIT <br>
char *host = &quot;localhost&quot;; <br>
C_ARGS: <br>
host, &amp;timep <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">The SCOPE: Keyword <br>
The SCOPE: keyword allows scoping to be enabled for a
particular XSUB. If enabled, the XSUB will invoke ENTER and
LEAVE automatically.</p>

<p style="margin-top: 1em">To support potentially complex
type mappings, if a typemap entry used by an XSUB contains a
comment like &quot;/*scope*/&quot; then scoping will be
automatically enabled for that XSUB.</p>

<p style="margin-top: 1em">To enable scoping:</p>

<p style="margin-top: 1em">SCOPE: ENABLE</p>

<p style="margin-top: 1em">To disable scoping:</p>

<p style="margin-top: 1em">SCOPE: DISABLE</p>

<p style="margin-top: 1em">The INPUT: Keyword <br>
The XSUB&rsquo;s parameters are usually evaluated
immediately after entering the XSUB. The INPUT: keyword can
be used to force those parameters to be evaluated a little
later. The <br>
INPUT: keyword can be used multiple times within an XSUB and
can be used to list one or more input variables. This
keyword is used with the PREINIT: keyword.</p>

<p style="margin-top: 1em">The following example shows how
the input parameter &quot;timep&quot; can be evaluated late,
after a PREINIT.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
PREINIT: <br>
time_t tt; <br>
INPUT: <br>
time_t timep <br>
CODE: <br>
RETVAL = rpcb_gettime( host, &amp;tt ); <br>
timep = tt; <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">The next example shows each
input parameter evaluated late.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
PREINIT: <br>
time_t tt; <br>
INPUT: <br>
char *host <br>
PREINIT: <br>
char *h; <br>
INPUT: <br>
time_t timep <br>
CODE: <br>
h = host; <br>
RETVAL = rpcb_gettime( h, &amp;tt ); <br>
timep = tt; <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">Since INPUT sections allow
declaration of C variables which do not appear in the
parameter list of a subroutine, this may be shortened
to:</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
time_t tt; <br>
char *host; <br>
char *h = host; <br>
time_t timep; <br>
CODE: <br>
RETVAL = rpcb_gettime( h, &amp;tt ); <br>
timep = tt; <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">(We used our knowledge that
input conversion for &quot;char *&quot; is a
&quot;simple&quot; one, thus &quot;host&quot; is initialized
on the declaration line, and our assignment &quot;h =
host&quot; is not performed <br>
too early. Otherwise one would need to have the assignment
&quot;h = host&quot; in a CODE: or INIT: section.)</p>

<p style="margin-top: 1em">The
IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords <br>
In the list of parameters for an XSUB, one can precede
parameter names by the
&quot;IN&quot;/&quot;OUTLIST&quot;/&quot;IN_OUTLIST&quot;/&quot;OUT&quot;/&quot;IN_OUT&quot;
keywords. &quot;IN&quot; keyword is the default, the other
<br>
keywords indicate how the Perl interface should differ from
the C interface.</p>

<p style="margin-top: 1em">Parameters preceded by
&quot;OUTLIST&quot;/&quot;IN_OUTLIST&quot;/&quot;OUT&quot;/&quot;IN_OUT&quot;
keywords are considered to be used by the C subroutine via
pointers. &quot;OUTLIST&quot;/&quot;OUT&quot; keywords
indicate that the C <br>
subroutine does not inspect the memory pointed by this
parameter, but will write through this pointer to provide
additional return values.</p>

<p style="margin-top: 1em">Parameters preceded by
&quot;OUTLIST&quot; keyword do not appear in the usage
signature of the generated Perl function.</p>

<p style="margin-top: 1em">Parameters preceded by
&quot;IN_OUTLIST&quot;/&quot;IN_OUT&quot;/&quot;OUT&quot; do
appear as parameters to the Perl function. With the
exception of &quot;OUT&quot;-parameters, these parameters
are converted to the <br>
corresponding C type, then pointers to these data are given
as arguments to the C function. It is expected that the C
function will write through these pointers.</p>

<p style="margin-top: 1em">The return list of the generated
Perl function consists of the C return value from the
function (unless the XSUB is of &quot;void&quot; return type
or &quot;The NO_OUTPUT Keyword&quot; was used) <br>
followed by all the &quot;OUTLIST&quot; and
&quot;IN_OUTLIST&quot; parameters (in the order of
appearance). On the return from the XSUB the
&quot;IN_OUT&quot;/&quot;OUT&quot; Perl parameter will be
modified to have <br>
the values written by the C function.</p>

<p style="margin-top: 1em">For example, an XSUB</p>

<p style="margin-top: 1em">void <br>
day_month(OUTLIST day, IN unix_time, OUTLIST month) <br>
int day <br>
int unix_time <br>
int month</p>

<p style="margin-top: 1em">should be used from Perl as</p>

<p style="margin-top: 1em">my ($day, $month) =
day_month(time);</p>

<p style="margin-top: 1em">The C signature of the
corresponding function should be</p>

<p style="margin-top: 1em">void day_month(int *day, int
unix_time, int *month);</p>

<p style="margin-top: 1em">The
&quot;IN&quot;/&quot;OUTLIST&quot;/&quot;IN_OUTLIST&quot;/&quot;IN_OUT&quot;/&quot;OUT&quot;
keywords can be mixed with ANSI-style declarations, as
in</p>

<p style="margin-top: 1em">void <br>
day_month(OUTLIST int day, int unix_time, OUTLIST int
month)</p>

<p style="margin-top: 1em">(here the optional
&quot;IN&quot; keyword is omitted).</p>

<p style="margin-top: 1em">The &quot;IN_OUT&quot;
parameters are identical with parameters introduced with
&quot;The &amp; Unary Operator&quot; and put into the
&quot;OUTPUT:&quot; section (see &quot;The OUTPUT:
Keyword&quot;). The &quot;IN_OUTLIST&quot; <br>
parameters are very similar, the only difference being that
the value C function writes through the pointer would not
modify the Perl parameter, but is put in the output
list.</p>

<p style="margin-top: 1em">The
&quot;OUTLIST&quot;/&quot;OUT&quot; parameter differ from
&quot;IN_OUTLIST&quot;/&quot;IN_OUT&quot; parameters only by
the initial value of the Perl parameter not being read (and
not being given to the C function - <br>
which gets some garbage instead). For example, the same C
function as above can be interfaced with as</p>

<p style="margin-top: 1em">void day_month(OUT int day, int
unix_time, OUT int month);</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">void <br>
day_month(day, unix_time, month) <br>
int &amp;day = NO_INIT <br>
int unix_time <br>
int &amp;month = NO_INIT <br>
OUTPUT: <br>
day <br>
month</p>

<p style="margin-top: 1em">However, the generated Perl
function is called in very C-ish style:</p>

<p style="margin-top: 1em">my ($day, $month); <br>
day_month($day, time, $month);</p>

<p style="margin-top: 1em">The &quot;length(NAME)&quot;
Keyword <br>
If one of the input arguments to the C function is the
length of a string argument &quot;NAME&quot;, one can
substitute the name of the length-argument by
&quot;length(NAME)&quot; in the XSUB <br>
declaration. This argument must be omitted when the
generated Perl function is called. E.g.,</p>

<p style="margin-top: 1em">void <br>
dump_chars(char *s, short l) <br>
{ <br>
short n = 0; <br>
while (n &lt; l) { <br>
printf(&quot;s[%d] = <br>
n++; <br>
} <br>
}</p>

<p style="margin-top: 1em">MODULE = x PACKAGE = x</p>

<p style="margin-top: 1em">void dump_chars(char *s, short
length(s))</p>

<p style="margin-top: 1em">should be called as
&quot;dump_chars($string)&quot;.</p>

<p style="margin-top: 1em">This directive is supported with
ANSI-type function declarations only.</p>

<p style="margin-top: 1em">Variable-length Parameter Lists
<br>
XSUBs can have variable-length parameter lists by specifying
an ellipsis &quot;(...)&quot; in the parameter list. This
use of the ellipsis is similar to that found in ANSI C. The
<br>
programmer is able to determine the number of arguments
passed to the XSUB by examining the &quot;items&quot;
variable which the xsubpp compiler supplies for all XSUBs.
By using this <br>
mechanism one can create an XSUB which accepts a list of
parameters of unknown length.</p>

<p style="margin-top: 1em">The host parameter for the
rpcb_gettime() XSUB can be optional so the ellipsis can be
used to indicate that the XSUB will take a variable number
of parameters. Perl should be <br>
able to call this XSUB with either of the following
statements.</p>

<p style="margin-top: 1em">$status = rpcb_gettime( $timep,
$host );</p>

<p style="margin-top: 1em">$status = rpcb_gettime( $timep
);</p>

<p style="margin-top: 1em">The XS code, with ellipsis,
follows.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(timep, ...) <br>
time_t timep = NO_INIT <br>
PREINIT: <br>
char *host = &quot;localhost&quot;; <br>
CODE: <br>
if( items &gt; 1 ) <br>
host = (char *)SvPV_nolen(ST(1)); <br>
RETVAL = rpcb_gettime( host, &amp;timep ); <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">The C_ARGS: Keyword <br>
The C_ARGS: keyword allows creating of XSUBS which have
different calling sequence from Perl than from C, without a
need to write CODE: or PPCODE: section. The contents of the
<br>
C_ARGS: paragraph is put as the argument to the called C
function without any change.</p>

<p style="margin-top: 1em">For example, suppose that a C
function is declared as</p>

<p style="margin-top: 1em">symbolic nth_derivative(int n,
symbolic function, int flags);</p>

<p style="margin-top: 1em">and that the default flags are
kept in a global C variable &quot;default_flags&quot;.
Suppose that you want to create an interface which is called
as</p>

<p style="margin-top: 1em">$second_deriv =
$function-&gt;nth_derivative(2);</p>

<p style="margin-top: 1em">To do this, declare the XSUB
as</p>

<p style="margin-top: 1em">symbolic <br>
nth_derivative(function, n) <br>
symbolic function <br>
int n <br>
C_ARGS: <br>
n, function, default_flags</p>

<p style="margin-top: 1em">The PPCODE: Keyword <br>
The PPCODE: keyword is an alternate form of the CODE:
keyword and is used to tell the xsubpp compiler that the
programmer is supplying the code to control the argument
stack for <br>
the XSUBs return values. Occasionally one will want an XSUB
to return a list of values rather than a single value. In
these cases one must use PPCODE: and then explicitly push
<br>
the list of values on the stack. The PPCODE: and CODE:
keywords should not be used together within the same
XSUB.</p>

<p style="margin-top: 1em">The actual difference between
PPCODE: and CODE: sections is in the initialization of
&quot;SP&quot; macro (which stands for the current Perl
stack pointer), and in the handling of data on <br>
the stack when returning from an XSUB. In CODE: sections SP
preserves the value which was on entry to the XSUB: SP is on
the function pointer (which follows the last parameter).
<br>
In PPCODE: sections SP is moved backward to the beginning of
the parameter list, which allows &quot;PUSH*()&quot; macros
to place output values in the place Perl expects them to be
when <br>
the XSUB returns back to Perl.</p>

<p style="margin-top: 1em">The generated trailer for a
CODE: section ensures that the number of return values Perl
will see is either 0 or 1 (depending on the
&quot;void&quot;ness of the return value of the C <br>
function, and heuristics mentioned in &quot;The RETVAL
Variable&quot;). The trailer generated for a PPCODE: section
is based on the number of return values and on the number of
times &quot;SP&quot; <br>
was updated by &quot;[X]PUSH*()&quot; macros.</p>

<p style="margin-top: 1em">Note that macros ST(i),
&quot;XST_m*()&quot; and &quot;XSRETURN*()&quot; work
equally well in CODE: sections and PPCODE: sections.</p>

<p style="margin-top: 1em">The following XSUB will call the
C rpcb_gettime() function and will return its two output
values, timep and status, to Perl as a single list.</p>

<p style="margin-top: 1em">void <br>
rpcb_gettime(host) <br>
char *host <br>
PREINIT: <br>
time_t timep; <br>
bool_t status; <br>
PPCODE: <br>
status = rpcb_gettime( host, &amp;timep ); <br>
EXTEND(SP, 2); <br>
PUSHs(sv_2mortal(newSViv(status))); <br>
PUSHs(sv_2mortal(newSViv(timep)));</p>

<p style="margin-top: 1em">Notice that the programmer must
supply the C code necessary to have the real rpcb_gettime()
function called and to have the return values properly
placed on the argument stack.</p>

<p style="margin-top: 1em">The &quot;void&quot; return type
for this function tells the xsubpp compiler that the RETVAL
variable is not needed or used and that it should not be
created. In most scenarios the void <br>
return type should be used with the PPCODE: directive.</p>

<p style="margin-top: 1em">The EXTEND() macro is used to
make room on the argument stack for 2 return values. The
PPCODE: directive causes the xsubpp compiler to create a
stack pointer available as &quot;SP&quot;, <br>
and it is this pointer which is being used in the EXTEND()
macro. The values are then pushed onto the stack with the
PUSHs() macro.</p>

<p style="margin-top: 1em">Now the rpcb_gettime() function
can be used from Perl with the following statement.</p>

<p style="margin-top: 1em">($status, $timep) =
rpcb_gettime(&quot;localhost&quot;);</p>

<p style="margin-top: 1em">When handling output parameters
with a PPCODE section, be sure to handle &rsquo;set&rsquo;
magic properly. See perlguts for details about
&rsquo;set&rsquo; magic.</p>

<p style="margin-top: 1em">Returning Undef And Empty Lists
<br>
Occasionally the programmer will want to return simply
&quot;undef&quot; or an empty list if a function fails
rather than a separate status value. The rpcb_gettime()
function offers just <br>
this situation. If the function succeeds we would like to
have it return the time and if it fails we would like to
have undef returned. In the following Perl code the value of
<br>
$timep will either be undef or it will be a valid time.</p>

<p style="margin-top: 1em">$timep = rpcb_gettime(
&quot;localhost&quot; );</p>

<p style="margin-top: 1em">The following XSUB uses the
&quot;SV *&quot; return type as a mnemonic only, and uses a
CODE: block to indicate to the compiler that the programmer
has supplied all the necessary code. <br>
The sv_newmortal() call will initialize the return value to
undef, making that the default return value.</p>

<p style="margin-top: 1em">SV * <br>
rpcb_gettime(host) <br>
char * host <br>
PREINIT: <br>
time_t timep; <br>
bool_t x; <br>
CODE: <br>
ST(0) = sv_newmortal(); <br>
if( rpcb_gettime( host, &amp;timep ) ) <br>
sv_setnv( ST(0), (double)timep);</p>

<p style="margin-top: 1em">The next example demonstrates
how one would place an explicit undef in the return value,
should the need arise.</p>

<p style="margin-top: 1em">SV * <br>
rpcb_gettime(host) <br>
char * host <br>
PREINIT: <br>
time_t timep; <br>
bool_t x; <br>
CODE: <br>
if( rpcb_gettime( host, &amp;timep ) ){ <br>
ST(0) = sv_newmortal(); <br>
sv_setnv( ST(0), (double)timep); <br>
} <br>
else{ <br>
ST(0) = &amp;PL_sv_undef; <br>
}</p>

<p style="margin-top: 1em">To return an empty list one must
use a PPCODE: block and then not push return values on the
stack.</p>

<p style="margin-top: 1em">void <br>
rpcb_gettime(host) <br>
char *host <br>
PREINIT: <br>
time_t timep; <br>
PPCODE: <br>
if( rpcb_gettime( host, &amp;timep ) ) <br>
PUSHs(sv_2mortal(newSViv(timep))); <br>
else{ <br>
/* Nothing pushed on stack, so an empty <br>
* list is implicitly returned. */ <br>
}</p>

<p style="margin-top: 1em">Some people may be inclined to
include an explicit &quot;return&quot; in the above XSUB,
rather than letting control fall through to the end. In
those situations &quot;XSRETURN_EMPTY&quot; should <br>
be used, instead. This will ensure that the XSUB stack is
properly adjusted. Consult perlapi for other
&quot;XSRETURN&quot; macros.</p>

<p style="margin-top: 1em">Since &quot;XSRETURN_*&quot;
macros can be used with CODE blocks as well, one can rewrite
this example as:</p>

<p style="margin-top: 1em">int <br>
rpcb_gettime(host) <br>
char *host <br>
PREINIT: <br>
time_t timep; <br>
CODE: <br>
RETVAL = rpcb_gettime( host, &amp;timep ); <br>
if (RETVAL == 0) <br>
XSRETURN_UNDEF; <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">In fact, one can put this check
into a POSTCALL: section as well. Together with PREINIT:
simplifications, this leads to:</p>

<p style="margin-top: 1em">int <br>
rpcb_gettime(host) <br>
char *host <br>
time_t timep; <br>
POSTCALL: <br>
if (RETVAL == 0) <br>
XSRETURN_UNDEF;</p>

<p style="margin-top: 1em">The REQUIRE: Keyword <br>
The REQUIRE: keyword is used to indicate the minimum version
of the xsubpp compiler needed to compile the XS module. An
XS module which contains the following statement will <br>
compile with only xsubpp version 1.922 or greater:</p>

<p style="margin-top: 1em">REQUIRE: 1.922</p>

<p style="margin-top: 1em">The CLEANUP: Keyword <br>
This keyword can be used when an XSUB requires special
cleanup procedures before it terminates. When the CLEANUP:
keyword is used it must follow any CODE:, PPCODE:, or
OUTPUT: <br>
blocks which are present in the XSUB. The code specified for
the cleanup block will be added as the last statements in
the XSUB.</p>

<p style="margin-top: 1em">The POSTCALL: Keyword <br>
This keyword can be used when an XSUB requires special
procedures executed after the C subroutine call is
performed. When the POSTCALL: keyword is used it must
precede OUTPUT: <br>
and CLEANUP: blocks which are present in the XSUB.</p>

<p style="margin-top: 1em">See examples in &quot;The
NO_OUTPUT Keyword&quot; and &quot;Returning Undef And Empty
Lists&quot;.</p>

<p style="margin-top: 1em">The POSTCALL: block does not
make a lot of sense when the C subroutine call is supplied
by user by providing either CODE: or PPCODE: section.</p>

<p style="margin-top: 1em">The BOOT: Keyword <br>
The BOOT: keyword is used to add code to the
extension&rsquo;s bootstrap function. The bootstrap function
is generated by the xsubpp compiler and normally holds the
statements <br>
necessary to register any XSUBs with Perl. With the BOOT:
keyword the programmer can tell the compiler to add extra
statements to the bootstrap function.</p>

<p style="margin-top: 1em">This keyword may be used any
time after the first MODULE keyword and should appear on a
line by itself. The first blank line after the keyword will
terminate the code block.</p>

<p style="margin-top: 1em">BOOT: <br>
# The following message will be printed when the <br>
# bootstrap function executes. <br>
printf(&quot;Hello from the bootstrap!0);</p>

<p style="margin-top: 1em">The VERSIONCHECK: Keyword <br>
The VERSIONCHECK: keyword corresponds to xsubpp&rsquo;s
&quot;-versioncheck&quot; and &quot;-noversioncheck&quot;
options. This keyword overrides the command line options.
Version checking is enabled by <br>
default. When version checking is enabled the XS module will
attempt to verify that its version matches the version of
the PM module.</p>

<p style="margin-top: 1em">To enable version checking:</p>

<p style="margin-top: 1em">VERSIONCHECK: ENABLE</p>

<p style="margin-top: 1em">To disable version checking:</p>

<p style="margin-top: 1em">VERSIONCHECK: DISABLE</p>

<p style="margin-top: 1em">Note that if the version of the
PM module is an NV (a floating point number), it will be
stringified with a possible loss of precision (currently
chopping to nine decimal places) <br>
so that it may not match the version of the XS module
anymore. Quoting the $VERSION declaration to make it a
string is recommended if long version numbers are used.</p>

<p style="margin-top: 1em">The PROTOTYPES: Keyword <br>
The PROTOTYPES: keyword corresponds to xsubpp&rsquo;s
&quot;-prototypes&quot; and &quot;-noprototypes&quot;
options. This keyword overrides the command line options.
Prototypes are enabled by default. <br>
When prototypes are enabled XSUBs will be given Perl
prototypes. This keyword may be used multiple times in an XS
module to enable and disable prototypes for different parts
of <br>
the module.</p>

<p style="margin-top: 1em">To enable prototypes:</p>

<p style="margin-top: 1em">PROTOTYPES: ENABLE</p>

<p style="margin-top: 1em">To disable prototypes:</p>

<p style="margin-top: 1em">PROTOTYPES: DISABLE</p>

<p style="margin-top: 1em">The PROTOTYPE: Keyword <br>
This keyword is similar to the PROTOTYPES: keyword above but
can be used to force xsubpp to use a specific prototype for
the XSUB. This keyword overrides all other prototype <br>
options and keywords but affects only the current XSUB.
Consult &quot;Prototypes&quot; in perlsub for information
about Perl prototypes.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(timep, ...) <br>
time_t timep = NO_INIT <br>
PROTOTYPE: $;$ <br>
PREINIT: <br>
char *host = &quot;localhost&quot;; <br>
CODE: <br>
if( items &gt; 1 ) <br>
host = (char *)SvPV_nolen(ST(1)); <br>
RETVAL = rpcb_gettime( host, &amp;timep ); <br>
OUTPUT: <br>
timep <br>
RETVAL</p>

<p style="margin-top: 1em">If the prototypes are enabled,
you can disable it locally for a given XSUB as in the
following example:</p>

<p style="margin-top: 1em">void <br>
rpcb_gettime_noproto() <br>
PROTOTYPE: DISABLE <br>
...</p>

<p style="margin-top: 1em">The ALIAS: Keyword <br>
The ALIAS: keyword allows an XSUB to have two or more unique
Perl names and to know which of those names was used when it
was invoked. The Perl names may be fully-qualified with <br>
package names. Each alias is given an index. The compiler
will setup a variable called &quot;ix&quot; which contain
the index of the alias which was used. When the XSUB is
called with <br>
its declared name &quot;ix&quot; will be 0.</p>

<p style="margin-top: 1em">The following example will
create aliases &quot;FOO::gettime()&quot; and
&quot;BAR::getit()&quot; for this function.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
time_t &amp;timep <br>
ALIAS: <br>
FOO::gettime = 1 <br>
BAR::getit = 2 <br>
INIT: <br>
printf(&quot;# ix = %d0, ix ); <br>
OUTPUT: <br>
timep</p>

<p style="margin-top: 1em">The OVERLOAD: Keyword <br>
Instead of writing an overloaded interface using pure Perl,
you can also use the OVERLOAD keyword to define additional
Perl names for your functions (like the ALIAS: keyword <br>
above). However, the overloaded functions must be defined
with three parameters (except for the nomethod() function
which needs four parameters). If any function has the <br>
OVERLOAD: keyword, several additional lines will be defined
in the c file generated by xsubpp in order to register with
the overload magic.</p>

<p style="margin-top: 1em">Since blessed objects are
actually stored as RV&rsquo;s, it is useful to use the
typemap features to preprocess parameters and extract the
actual SV stored within the blessed RV. See <br>
the sample for T_PTROBJ_SPECIAL below.</p>

<p style="margin-top: 1em">To use the OVERLOAD: keyword,
create an XS function which takes three input parameters (
or use the c style &rsquo;...&rsquo; definition) like
this:</p>

<p style="margin-top: 1em">SV * <br>
cmp (lobj, robj, swap) <br>
My_Module_obj lobj <br>
My_Module_obj robj <br>
IV swap <br>
OVERLOAD: cmp &lt;=&gt; <br>
{ /* function defined here */}</p>

<p style="margin-top: 1em">In this case, the function will
overload both of the three way comparison operators. For all
overload operations using non-alpha characters, you must
type the parameter without <br>
quoting, separating multiple overloads with whitespace. Note
that &quot;&quot; (the stringify overload) should be entered
as</p>

<p style="margin-top: 1em">The FALLBACK: Keyword <br>
In addition to the OVERLOAD keyword, if you need to control
how Perl autogenerates missing overloaded operators, you can
set the FALLBACK keyword in the module header section, <br>
like this:</p>

<p style="margin-top: 1em">MODULE = RPC PACKAGE = RPC</p>

<p style="margin-top: 1em">FALLBACK: TRUE <br>
...</p>

<p style="margin-top: 1em">where FALLBACK can take any of
the three values TRUE, FALSE, or UNDEF. If you do not set
any FALLBACK value when using OVERLOAD, it defaults to
UNDEF. FALLBACK is not used <br>
except when one or more functions using OVERLOAD have been
defined. Please see &quot;fallback&quot; in overload for
more details.</p>

<p style="margin-top: 1em">The INTERFACE: Keyword <br>
This keyword declares the current XSUB as a keeper of the
given calling signature. If some text follows this keyword,
it is considered as a list of functions which have this <br>
signature, and should be attached to the current XSUB.</p>

<p style="margin-top: 1em">For example, if you have 4 C
functions multiply(), divide(), add(), subtract() all having
the signature:</p>

<p style="margin-top: 1em">symbolic f(symbolic,
symbolic);</p>

<p style="margin-top: 1em">you can make them all to use the
same XSUB using this:</p>

<p style="margin-top: 1em">symbolic <br>
interface_s_ss(arg1, arg2) <br>
symbolic arg1 <br>
symbolic arg2 <br>
INTERFACE: <br>
multiply divide <br>
add subtract</p>

<p style="margin-top: 1em">(This is the complete XSUB code
for 4 Perl functions!) Four generated Perl function share
names with corresponding C functions.</p>

<p style="margin-top: 1em">The advantage of this approach
comparing to ALIAS: keyword is that there is no need to code
a switch statement, each Perl function (which shares the
same XSUB) knows which C <br>
function it should call. Additionally, one can attach an
extra function remainder() at runtime by using</p>

<p style="margin-top: 1em">CV *mycv =
newXSproto(&quot;Symbolic::remainder&quot;, <br>
XS_Symbolic_interface_s_ss, __FILE__, &quot;$$&quot;); <br>
XSINTERFACE_FUNC_SET(mycv, remainder);</p>

<p style="margin-top: 1em">say, from another XSUB. (This
example supposes that there was no INTERFACE_MACRO: section,
otherwise one needs to use something else instead of
&quot;XSINTERFACE_FUNC_SET&quot;, see the <br>
next section.)</p>

<p style="margin-top: 1em">The INTERFACE_MACRO: Keyword
<br>
This keyword allows one to define an INTERFACE using a
different way to extract a function pointer from an XSUB.
The text which follows this keyword should give the name of
<br>
macros which would extract/set a function pointer. The
extractor macro is given return type, &quot;CV*&quot;, and
&quot;XSANY.any_dptr&quot; for this &quot;CV*&quot;. The
setter macro is given cv, and the <br>
function pointer.</p>

<p style="margin-top: 1em">The default value is
&quot;XSINTERFACE_FUNC&quot; and
&quot;XSINTERFACE_FUNC_SET&quot;. An INTERFACE keyword with
an empty list of functions can be omitted if INTERFACE_MACRO
keyword is used.</p>

<p style="margin-top: 1em">Suppose that in the previous
example functions pointers for multiply(), divide(), add(),
subtract() are kept in a global C array &quot;fp[]&quot;
with offsets being &quot;multiply_off&quot;, <br>
&quot;divide_off&quot;, &quot;add_off&quot;,
&quot;subtract_off&quot;. Then one can use</p>

<p style="margin-top: 1em">#define
XSINTERFACE_FUNC_BYOFFSET(ret,cv,f)
((XSINTERFACE_CVT_ANON(ret))fp[CvXSUBANY(cv).any_i32]) <br>
#define XSINTERFACE_FUNC_BYOFFSET_set(cv,f)
CvXSUBANY(cv).any_i32 = CAT2( f, _off )</p>

<p style="margin-top: 1em">in C section,</p>

<p style="margin-top: 1em">symbolic <br>
interface_s_ss(arg1, arg2) <br>
symbolic arg1 <br>
symbolic arg2 <br>
INTERFACE_MACRO: <br>
XSINTERFACE_FUNC_BYOFFSET <br>
XSINTERFACE_FUNC_BYOFFSET_set <br>
INTERFACE: <br>
multiply divide <br>
add subtract</p>

<p style="margin-top: 1em">in XSUB section.</p>

<p style="margin-top: 1em">The INCLUDE: Keyword <br>
This keyword can be used to pull other files into the XS
module. The other files may have XS code. INCLUDE: can also
be used to run a command to generate the XS code to be <br>
pulled into the module.</p>

<p style="margin-top: 1em">The file Rpcb1.xsh contains our
&quot;rpcb_gettime()&quot; function:</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
time_t &amp;timep <br>
OUTPUT: <br>
timep</p>

<p style="margin-top: 1em">The XS module can use INCLUDE:
to pull that file into it.</p>

<p style="margin-top: 1em">INCLUDE: Rpcb1.xsh</p>

<p style="margin-top: 1em">If the parameters to the
INCLUDE: keyword are followed by a pipe (&quot;|&quot;) then
the compiler will interpret the parameters as a command.
This feature is mildly deprecated in favour <br>
of the &quot;INCLUDE_COMMAND:&quot; directive, as documented
below.</p>

<p style="margin-top: 1em">INCLUDE: cat Rpcb1.xsh |</p>

<p style="margin-top: 1em">Do not use this to run perl:
&quot;INCLUDE: perl |&quot; will run the perl that happens
to be the first in your path and not necessarily the same
perl that is used to run &quot;xsubpp&quot;. See <br>
&quot;The INCLUDE_COMMAND: Keyword&quot;.</p>

<p style="margin-top: 1em">The INCLUDE_COMMAND: Keyword
<br>
Runs the supplied command and includes its output into the
current XS document. &quot;INCLUDE_COMMAND&quot; assigns
special meaning to the $^X token in that it runs the same
perl <br>
interpreter that is running &quot;xsubpp&quot;:</p>

<p style="margin-top: 1em">INCLUDE_COMMAND: cat
Rpcb1.xsh</p>

<p style="margin-top: 1em">INCLUDE_COMMAND: $^X -e ...</p>

<p style="margin-top: 1em">The CASE: Keyword <br>
The CASE: keyword allows an XSUB to have multiple distinct
parts with each part acting as a virtual XSUB. CASE: is
greedy and if it is used then all other XS keywords must be
<br>
contained within a CASE:. This means nothing may precede the
first CASE: in the XSUB and anything following the last
CASE: is included in that case.</p>

<p style="margin-top: 1em">A CASE: might switch via a
parameter of the XSUB, via the &quot;ix&quot; ALIAS:
variable (see &quot;The ALIAS: Keyword&quot;), or maybe via
the &quot;items&quot; variable (see &quot;Variable-length
Parameter <br>
Lists&quot;). The last CASE: becomes the default case if it
is not associated with a conditional. The following example
shows CASE switched via &quot;ix&quot; with a function
&quot;rpcb_gettime()&quot; <br>
having an alias &quot;x_gettime()&quot;. When the function
is called as &quot;rpcb_gettime()&quot; its parameters are
the usual &quot;(char *host, time_t *timep)&quot;, but when
the function is called as <br>
&quot;x_gettime()&quot; its parameters are reversed,
&quot;(time_t *timep, char *host)&quot;.</p>

<p style="margin-top: 1em">long <br>
rpcb_gettime(a,b) <br>
CASE: ix == 1 <br>
ALIAS: <br>
x_gettime = 1 <br>
INPUT: <br>
# &rsquo;a&rsquo; is timep, &rsquo;b&rsquo; is host <br>
char *b <br>
time_t a = NO_INIT <br>
CODE: <br>
RETVAL = rpcb_gettime( b, &amp;a ); <br>
OUTPUT: <br>
a <br>
RETVAL <br>
CASE: <br>
# &rsquo;a&rsquo; is host, &rsquo;b&rsquo; is timep <br>
char *a <br>
time_t &amp;b = NO_INIT <br>
OUTPUT: <br>
b <br>
RETVAL</p>

<p style="margin-top: 1em">That function can be called with
either of the following statements. Note the different
argument lists.</p>

<p style="margin-top: 1em">$status = rpcb_gettime( $host,
$timep );</p>

<p style="margin-top: 1em">$status = x_gettime( $timep,
$host );</p>

<p style="margin-top: 1em">The EXPORT_XSUB_SYMBOLS: Keyword
<br>
The EXPORT_XSUB_SYMBOLS: keyword is likely something you
will never need. In perl versions earlier than 5.16.0, this
keyword does nothing. Starting with 5.16, XSUB symbols are
<br>
no longer exported by default. That is, they are
&quot;static&quot; functions. If you include</p>

<p style="margin-top: 1em">EXPORT_XSUB_SYMBOLS: ENABLE</p>

<p style="margin-top: 1em">in your XS code, the XSUBs
following this line will not be declared &quot;static&quot;.
You can later disable this with</p>

<p style="margin-top: 1em">EXPORT_XSUB_SYMBOLS: DISABLE</p>

<p style="margin-top: 1em">which, again, is the default
that you should probably never change. You cannot use this
keyword on versions of perl before 5.16 to make XSUBs
&quot;static&quot;.</p>

<p style="margin-top: 1em">The &amp; Unary Operator <br>
The &quot;&amp;&quot; unary operator in the INPUT: section
is used to tell xsubpp that it should convert a Perl value
to/from C using the C type to the left of &quot;&amp;&quot;,
but provide a pointer to <br>
this value when the C function is called.</p>

<p style="margin-top: 1em">This is useful to avoid a CODE:
block for a C function which takes a parameter by reference.
Typically, the parameter should be not a pointer type (an
&quot;int&quot; or &quot;long&quot; but not an <br>
&quot;int*&quot; or &quot;long*&quot;).</p>

<p style="margin-top: 1em">The following XSUB will generate
incorrect C code. The xsubpp compiler will turn this into
code which calls &quot;rpcb_gettime()&quot; with parameters
&quot;(char *host, time_t timep)&quot;, but <br>
the real &quot;rpcb_gettime()&quot; wants the
&quot;timep&quot; parameter to be of type
&quot;time_t*&quot; rather than &quot;time_t&quot;.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
time_t timep <br>
OUTPUT: <br>
timep</p>

<p style="margin-top: 1em">That problem is corrected by
using the &quot;&amp;&quot; operator. The xsubpp compiler
will now turn this into code which calls
&quot;rpcb_gettime()&quot; correctly with parameters
&quot;(char *host, time_t <br>
*timep)&quot;. It does this by carrying the
&quot;&amp;&quot; through, so the function call looks like
&quot;rpcb_gettime(host, &amp;timep)&quot;.</p>

<p style="margin-top: 1em">bool_t <br>
rpcb_gettime(host,timep) <br>
char *host <br>
time_t &amp;timep <br>
OUTPUT: <br>
timep</p>

<p style="margin-top: 1em">Inserting POD, Comments and C
Preprocessor Directives <br>
C preprocessor directives are allowed within BOOT:, PREINIT:
INIT:, CODE:, PPCODE:, POSTCALL:, and CLEANUP: blocks, as
well as outside the functions. Comments are allowed <br>
anywhere after the MODULE keyword. The compiler will pass
the preprocessor directives through untouched and will
remove the commented lines. POD documentation is allowed at
any <br>
point, both in the C and XS language sections. POD must be
terminated with a &quot;=cut&quot; command;
&quot;xsubpp&quot; will exit with an error if it does not.
It is very unlikely that human <br>
generated C code will be mistaken for POD, as most indenting
styles result in whitespace in front of any line starting
with &quot;=&quot;. Machine generated XS files may fall into
this <br>
trap unless care is taken to ensure that a space breaks the
sequence &quot;0&quot;.</p>

<p style="margin-top: 1em">Comments can be added to XSUBs
by placing a &quot;#&quot; as the first non-whitespace of a
line. Care should be taken to avoid making the comment look
like a C preprocessor directive, <br>
lest it be interpreted as such. The simplest way to prevent
this is to put whitespace in front of the &quot;#&quot;.</p>

<p style="margin-top: 1em">If you use preprocessor
directives to choose one of two versions of a function,
use</p>

<p style="margin-top: 1em">#if ... version1 <br>
#else /* ... version2 */ <br>
#endif</p>

<p style="margin-top: 1em">and not</p>

<p style="margin-top: 1em">#if ... version1 <br>
#endif <br>
#if ... version2 <br>
#endif</p>

<p style="margin-top: 1em">because otherwise xsubpp will
believe that you made a duplicate definition of the
function. Also, put a blank line before the #else/#endif so
it will not be seen as part of the <br>
function body.</p>

<p style="margin-top: 1em">Using XS With C++ <br>
If an XSUB name contains &quot;::&quot;, it is considered to
be a C++ method. The generated Perl function will assume
that its first argument is an object pointer. The object
pointer <br>
will be stored in a variable called THIS. The object should
have been created by C++ with the new() function and should
be blessed by Perl with the sv_setref_pv() macro. The <br>
blessing of the object by Perl can be handled by a typemap.
An example typemap is shown at the end of this section.</p>

<p style="margin-top: 1em">If the return type of the XSUB
includes &quot;static&quot;, the method is considered to be
a static method. It will call the C++ function using the
class::method() syntax. If the method <br>
is not static the function will be called using the
THIS-&gt;method() syntax.</p>

<p style="margin-top: 1em">The next examples will use the
following C++ class.</p>

<p style="margin-top: 1em">class color { <br>
public: <br>
color(); <br>
~color(); <br>
int blue(); <br>
void set_blue( int );</p>

<p style="margin-top: 1em">private: <br>
int c_blue; <br>
};</p>

<p style="margin-top: 1em">The XSUBs for the blue() and
set_blue() methods are defined with the class name but the
parameter for the object (THIS, or &quot;self&quot;) is
implicit and is not listed.</p>

<p style="margin-top: 1em">int <br>
color::blue()</p>

<p style="margin-top: 1em">void <br>
color::set_blue( val ) <br>
int val</p>

<p style="margin-top: 1em">Both Perl functions will expect
an object as the first parameter. In the generated C++ code
the object is called &quot;THIS&quot;, and the method call
will be performed on this object. <br>
So in the C++ code the blue() and set_blue() methods will be
called as this:</p>

<p style="margin-top: 1em">RETVAL = THIS-&gt;blue();</p>

<p style="margin-top: 1em">THIS-&gt;set_blue( val );</p>

<p style="margin-top: 1em">You could also write a single
get/set method using an optional argument:</p>

<p style="margin-top: 1em">int <br>
color::blue( val = NO_INIT ) <br>
int val <br>
PROTOTYPE $;$ <br>
CODE: <br>
if (items &gt; 1) <br>
THIS-&gt;set_blue( val ); <br>
RETVAL = THIS-&gt;blue(); <br>
OUTPUT: <br>
RETVAL</p>

<p style="margin-top: 1em">If the function&rsquo;s name is
DESTROY then the C++ &quot;delete&quot; function will be
called and &quot;THIS&quot; will be given as its parameter.
The generated C++ code for</p>

<p style="margin-top: 1em">void <br>
color::DESTROY()</p>

<p style="margin-top: 1em">will look like this:</p>

<p style="margin-top: 1em">color *THIS = ...; //
Initialized as in typemap</p>

<p style="margin-top: 1em">delete THIS;</p>

<p style="margin-top: 1em">If the function&rsquo;s name is
new then the C++ &quot;new&quot; function will be called to
create a dynamic C++ object. The XSUB will expect the class
name, which will be kept in a variable <br>
called &quot;CLASS&quot;, to be given as the first
argument.</p>

<p style="margin-top: 1em">color * <br>
color::new()</p>

<p style="margin-top: 1em">The generated C++ code will call
&quot;new&quot;.</p>

<p style="margin-top: 1em">RETVAL = new color();</p>

<p style="margin-top: 1em">The following is an example of a
typemap that could be used for this C++ example.</p>

<p style="margin-top: 1em">TYPEMAP <br>
color * O_OBJECT</p>

<p style="margin-top: 1em">OUTPUT <br>
# The Perl object is blessed into &rsquo;CLASS&rsquo;, which
should be a <br>
# char* having the name of the package for the blessing.
<br>
O_OBJECT <br>
sv_setref_pv( $arg, CLASS, (void*)$var );</p>

<p style="margin-top: 1em">INPUT <br>
O_OBJECT <br>
if( sv_isobject($arg) &amp;&amp; (SvTYPE(SvRV($arg)) ==
SVt_PVMG) ) <br>
$var = ($type)SvIV((SV*)SvRV( $arg )); <br>
else{ <br>
warn( <br>
XSRETURN_UNDEF; <br>
}</p>

<p style="margin-top: 1em">Interface Strategy <br>
When designing an interface between Perl and a C library a
straight translation from C to XS (such as created by
&quot;h2xs -x&quot;) is often sufficient. However, sometimes
the interface <br>
will look very C-like and occasionally nonintuitive,
especially when the C function modifies one of its
parameters, or returns failure inband (as in &quot;negative
return values mean <br>
failure&quot;). In cases where the programmer wishes to
create a more Perl-like interface the following strategy may
help to identify the more critical parts of the
interface.</p>

<p style="margin-top: 1em">Identify the C functions with
input/output or output parameters. The XSUBs for these
functions may be able to return lists to Perl.</p>

<p style="margin-top: 1em">Identify the C functions which
use some inband info as an indication of failure. They may
be candidates to return undef or an empty list in case of
failure. If the failure may <br>
be detected without a call to the C function, you may want
to use an INIT: section to report the failure. For failures
detectable after the C function returns one may want to <br>
use a POSTCALL: section to process the failure. In more
complicated cases use CODE: or PPCODE: sections.</p>

<p style="margin-top: 1em">If many functions use the same
failure indication based on the return value, you may want
to create a special typedef to handle this situation.
Put</p>

<p style="margin-top: 1em">typedef int
negative_is_failure;</p>

<p style="margin-top: 1em">near the beginning of XS file,
and create an OUTPUT typemap entry for
&quot;negative_is_failure&quot; which converts negative
values to &quot;undef&quot;, or maybe croak()s. After this
the return <br>
value of type &quot;negative_is_failure&quot; will create
more Perl-like interface.</p>

<p style="margin-top: 1em">Identify which values are used
by only the C and XSUB functions themselves, say, when a
parameter to a function should be a contents of a global
variable. If Perl does not need <br>
to access the contents of the value then it may not be
necessary to provide a translation for that value from C to
Perl.</p>

<p style="margin-top: 1em">Identify the pointers in the C
function parameter lists and return values. Some pointers
may be used to implement input/output or output parameters,
they can be handled in XS <br>
with the &quot;&amp;&quot; unary operator, and, possibly,
using the NO_INIT keyword. Some others will require handling
of types like &quot;int *&quot;, and one needs to decide
what a useful Perl <br>
translation will do in such a case. When the semantic is
clear, it is advisable to put the translation into a typemap
file.</p>

<p style="margin-top: 1em">Identify the structures used by
the C functions. In many cases it may be helpful to use the
T_PTROBJ typemap for these structures so they can be
manipulated by Perl as blessed <br>
objects. (This is handled automatically by &quot;h2xs
-x&quot;.)</p>

<p style="margin-top: 1em">If the same C type is used in
several different contexts which require different
translations, &quot;typedef&quot; several new types mapped
to this C type, and create separate typemap <br>
entries for these new types. Use these types in declarations
of return type and parameters to XSUBs.</p>

<p style="margin-top: 1em">Perl Objects And C Structures
<br>
When dealing with C structures one should select either
T_PTROBJ or T_PTRREF for the XS type. Both types are
designed to handle pointers to complex objects. The T_PTRREF
type <br>
will allow the Perl object to be unblessed while the
T_PTROBJ type requires that the object be blessed. By using
T_PTROBJ one can achieve a form of type-checking because the
<br>
XSUB will attempt to verify that the Perl object is of the
expected type.</p>

<p style="margin-top: 1em">The following XS code shows the
getnetconfigent() function which is used with ONC+ TIRPC.
The getnetconfigent() function will return a pointer to a C
structure and has the C <br>
prototype shown below. The example will demonstrate how the
C pointer will become a Perl reference. Perl will consider
this reference to be a pointer to a blessed object and <br>
will attempt to call a destructor for the object. A
destructor will be provided in the XS source to free the
memory used by getnetconfigent(). Destructors in XS can be
created <br>
by specifying an XSUB function whose name ends with the word
DESTROY. XS destructors can be used to free memory which may
have been malloc&rsquo;d by another XSUB.</p>

<p style="margin-top: 1em">struct netconfig
*getnetconfigent(const char *netid);</p>

<p style="margin-top: 1em">A &quot;typedef&quot; will be
created for &quot;struct netconfig&quot;. The Perl object
will be blessed in a class matching the name of the C type,
with the tag &quot;Ptr&quot; appended, and the name should
<br>
not have embedded spaces if it will be a Perl package name.
The destructor will be placed in a class corresponding to
the class of the object and the PREFIX keyword will be used
<br>
to trim the name to the word DESTROY as Perl will
expect.</p>

<p style="margin-top: 1em">typedef struct netconfig
Netconfig;</p>

<p style="margin-top: 1em">MODULE = RPC PACKAGE = RPC</p>

<p style="margin-top: 1em">Netconfig * <br>
getnetconfigent(netid) <br>
char *netid</p>

<p style="margin-top: 1em">MODULE = RPC PACKAGE =
NetconfigPtr PREFIX = rpcb_</p>

<p style="margin-top: 1em">void <br>
rpcb_DESTROY(netconf) <br>
Netconfig *netconf <br>
CODE: <br>
printf(&quot;Now in NetconfigPtr::DESTROY0); <br>
free( netconf );</p>

<p style="margin-top: 1em">This example requires the
following typemap entry. Consult perlxstypemap for more
information about adding new typemaps for an extension.</p>

<p style="margin-top: 1em">TYPEMAP <br>
Netconfig * T_PTROBJ</p>

<p style="margin-top: 1em">This example will be used with
the following Perl statements.</p>

<p style="margin-top: 1em">use RPC; <br>
$netconf = getnetconfigent(&quot;udp&quot;);</p>

<p style="margin-top: 1em">When Perl destroys the object
referenced by $netconf it will send the object to the
supplied XSUB DESTROY function. Perl cannot determine, and
does not care, that this object is <br>
a C struct and not a Perl object. In this sense, there is no
difference between the object created by the
getnetconfigent() XSUB and an object created by a normal
Perl <br>
subroutine.</p>

<p style="margin-top: 1em">Safely Storing Static Data in XS
<br>
Starting with Perl 5.8, a macro framework has been defined
to allow static data to be safely stored in XS modules that
will be accessed from a multi-threaded Perl.</p>

<p style="margin-top: 1em">Although primarily designed for
use with multi-threaded Perl, the macros have been designed
so that they will work with non-threaded Perl as well.</p>

<p style="margin-top: 1em">It is therefore strongly
recommended that these macros be used by all XS modules that
make use of static data.</p>

<p style="margin-top: 1em">The easiest way to get a
template set of macros to use is by specifying the
&quot;-g&quot; (&quot;--global&quot;) option with h2xs (see
h2xs).</p>

<p style="margin-top: 1em">Below is an example module that
makes use of the macros.</p>

<p style="margin-top: 1em">#include &quot;EXTERN.h&quot;
<br>
#include &quot;perl.h&quot; <br>
#include &quot;XSUB.h&quot;</p>

<p style="margin-top: 1em">/* Global Data */</p>

<p style="margin-top: 1em">#define MY_CXT_KEY
&quot;BlindMice::_guts&quot; XS_VERSION</p>

<p style="margin-top: 1em">typedef struct { <br>
int count; <br>
char name[3][100]; <br>
} my_cxt_t;</p>

<p style="margin-top: 1em">START_MY_CXT</p>

<p style="margin-top: 1em">MODULE = BlindMice PACKAGE =
BlindMice</p>

<p style="margin-top: 1em">BOOT: <br>
{ <br>
MY_CXT_INIT; <br>
MY_CXT.count = 0; <br>
strcpy(MY_CXT.name[0], &quot;None&quot;); <br>
strcpy(MY_CXT.name[1], &quot;None&quot;); <br>
strcpy(MY_CXT.name[2], &quot;None&quot;); <br>
}</p>

<p style="margin-top: 1em">int <br>
newMouse(char * name) <br>
char * name; <br>
PREINIT: <br>
dMY_CXT; <br>
CODE: <br>
if (MY_CXT.count &gt;= 3) { <br>
warn(&quot;Already have 3 blind mice&quot;); <br>
RETVAL = 0; <br>
} <br>
else { <br>
RETVAL = ++ MY_CXT.count; <br>
strcpy(MY_CXT.name[MY_CXT.count - 1], name); <br>
}</p>

<p style="margin-top: 1em">char * <br>
get_mouse_name(index) <br>
int index <br>
CODE: <br>
dMY_CXT; <br>
RETVAL = MY_CXT.lives ++; <br>
if (index &gt; MY_CXT.count) <br>
croak(&quot;There are only 3 blind mice.&quot;); <br>
else <br>
RETVAL = newSVpv(MY_CXT.name[index - 1]);</p>

<p style="margin-top: 1em">void <br>
CLONE(...) <br>
CODE: <br>
MY_CXT_CLONE;</p>

<p style="margin-top: 1em">REFERENCE</p>

<p style="margin-top: 1em">MY_CXT_KEY <br>
This macro is used to define a unique key to refer to the
static data for an XS module. The suggested naming scheme,
as used by h2xs, is to use a string that consists of the
<br>
module name, the string &quot;::_guts&quot; and the module
version number.</p>

<p style="margin-top: 1em">#define MY_CXT_KEY
&quot;MyModule::_guts&quot; XS_VERSION</p>

<p style="margin-top: 1em">typedef my_cxt_t <br>
This struct typedef must always be called
&quot;my_cxt_t&quot;. The other &quot;CXT*&quot; macros
assume the existence of the &quot;my_cxt_t&quot; typedef
name.</p>

<p style="margin-top: 1em">Declare a typedef named
&quot;my_cxt_t&quot; that is a structure that contains all
the data that needs to be interpreter-local.</p>

<p style="margin-top: 1em">typedef struct { <br>
int some_value; <br>
} my_cxt_t;</p>

<p style="margin-top: 1em">START_MY_CXT <br>
Always place the START_MY_CXT macro directly after the
declaration of &quot;my_cxt_t&quot;.</p>

<p style="margin-top: 1em">MY_CXT_INIT <br>
The MY_CXT_INIT macro initialises storage for the
&quot;my_cxt_t&quot; struct.</p>

<p style="margin-top: 1em">It must be called exactly once,
typically in a BOOT: section. If you are maintaining
multiple interpreters, it should be called once in each
interpreter instance, except for <br>
interpreters cloned from existing ones. (But see
&quot;MY_CXT_CLONE&quot; below.)</p>

<p style="margin-top: 1em">dMY_CXT <br>
Use the dMY_CXT macro (a declaration) in all the functions
that access MY_CXT.</p>

<p style="margin-top: 1em">MY_CXT <br>
Use the MY_CXT macro to access members of the
&quot;my_cxt_t&quot; struct. For example, if
&quot;my_cxt_t&quot; is</p>

<p style="margin-top: 1em">typedef struct { <br>
int index; <br>
} my_cxt_t;</p>

<p style="margin-top: 1em">then use this to access the
&quot;index&quot; member</p>

<p style="margin-top: 1em">dMY_CXT; <br>
MY_CXT.index = 2;</p>

<p style="margin-top: 1em">aMY_CXT/pMY_CXT <br>
&quot;dMY_CXT&quot; may be quite expensive to calculate, and
to avoid the overhead of invoking it in each function it is
possible to pass the declaration onto other functions using
<br>
the &quot;aMY_CXT&quot;/&quot;pMY_CXT&quot; macros, eg</p>

<p style="margin-top: 1em">void sub1() { <br>
dMY_CXT; <br>
MY_CXT.index = 1; <br>
sub2(aMY_CXT); <br>
}</p>

<p style="margin-top: 1em">void sub2(pMY_CXT) { <br>
MY_CXT.index = 2; <br>
}</p>

<p style="margin-top: 1em">Analogously to &quot;pTHX&quot;,
there are equivalent forms for when the macro is the first
or last in multiple arguments, where an underscore
represents a comma, i.e. &quot;_aMY_CXT&quot;, <br>
&quot;aMY_CXT_&quot;, &quot;_pMY_CXT&quot; and
&quot;pMY_CXT_&quot;.</p>

<p style="margin-top: 1em">MY_CXT_CLONE <br>
By default, when a new interpreter is created as a copy of
an existing one (eg via &quot;threads-&gt;create()&quot;),
both interpreters share the same physical my_cxt_t
structure. <br>
Calling &quot;MY_CXT_CLONE&quot; (typically via the
package&rsquo;s &quot;CLONE()&quot; function), causes a
byte-for-byte copy of the structure to be taken, and any
future dMY_CXT will cause the copy <br>
to be accessed instead.</p>

<p style="margin-top: 1em">MY_CXT_INIT_INTERP(my_perl) <br>
dMY_CXT_INTERP(my_perl) <br>
These are versions of the macros which take an explicit
interpreter as an argument.</p>

<p style="margin-top: 1em">Note that these macros will only
work together within the same source file; that is, a
dMY_CTX in one source file will access a different structure
than a dMY_CTX in another <br>
source file.</p>

<p style="margin-top: 1em">Thread-aware system interfaces
<br>
Starting from Perl 5.8, in C/C++ level Perl knows how to
wrap system/library interfaces that have thread-aware
versions (e.g. getpwent_r()) into frontend macros (e.g.
getpwent()) <br>
that correctly handle the multithreaded interaction with the
Perl interpreter. This will happen transparently, the only
thing you need to do is to instantiate a Perl <br>
interpreter.</p>

<p style="margin-top: 1em">This wrapping happens always
when compiling Perl core source (PERL_CORE is defined) or
the Perl core extensions (PERL_EXT is defined). When
compiling XS code outside of Perl <br>
core the wrapping does not take place. Note, however, that
intermixing the _r-forms (as Perl compiled for multithreaded
operation will do) and the _r-less forms is neither well-
<br>
defined (inconsistent results, data corruption, or even
crashes become more likely), nor is it very portable.</p>

<p style="margin-top: 1em">EXAMPLES <br>
File &quot;RPC.xs&quot;: Interface to some ONC+ RPC bind
library functions.</p>

<p style="margin-top: 1em">#include &quot;EXTERN.h&quot;
<br>
#include &quot;perl.h&quot; <br>
#include &quot;XSUB.h&quot;</p>

<p style="margin-top: 1em">#include &lt;rpc/rpc.h&gt;</p>

<p style="margin-top: 1em">typedef struct netconfig
Netconfig;</p>

<p style="margin-top: 1em">MODULE = RPC PACKAGE = RPC</p>

<p style="margin-top: 1em">SV * <br>
rpcb_gettime(host=&quot;localhost&quot;) <br>
char *host <br>
PREINIT: <br>
time_t timep; <br>
CODE: <br>
ST(0) = sv_newmortal(); <br>
if( rpcb_gettime( host, &amp;timep ) ) <br>
sv_setnv( ST(0), (double)timep );</p>

<p style="margin-top: 1em">Netconfig * <br>
getnetconfigent(netid=&quot;udp&quot;) <br>
char *netid</p>

<p style="margin-top: 1em">MODULE = RPC PACKAGE =
NetconfigPtr PREFIX = rpcb_</p>

<p style="margin-top: 1em">void <br>
rpcb_DESTROY(netconf) <br>
Netconfig *netconf <br>
CODE: <br>
printf(&quot;NetconfigPtr::DESTROY0); <br>
free( netconf );</p>

<p style="margin-top: 1em">File &quot;typemap&quot;: Custom
typemap for RPC.xs. (cf. perlxstypemap)</p>

<p style="margin-top: 1em">TYPEMAP <br>
Netconfig * T_PTROBJ</p>

<p style="margin-top: 1em">File &quot;RPC.pm&quot;: Perl
module for the RPC extension.</p>

<p style="margin-top: 1em">package RPC;</p>

<p style="margin-top: 1em">require Exporter; <br>
require DynaLoader; <br>
@ISA = qw(Exporter DynaLoader); <br>
@EXPORT = qw(rpcb_gettime getnetconfigent);</p>

<p style="margin-top: 1em">bootstrap RPC; <br>
1;</p>

<p style="margin-top: 1em">File &quot;rpctest.pl&quot;:
Perl test program for the RPC extension.</p>

<p style="margin-top: 1em">use RPC;</p>

<p style="margin-top: 1em">$netconf = getnetconfigent();
<br>
$a = rpcb_gettime(); <br>
print &quot;time = $a0; <br>
print &quot;netconf = $netconf0;</p>

<p style="margin-top: 1em">$netconf =
getnetconfigent(&quot;tcp&quot;); <br>
$a = rpcb_gettime(&quot;poplar&quot;); <br>
print &quot;time = $a0; <br>
print &quot;netconf = $netconf0;</p>

<p style="margin-top: 1em">XS VERSION <br>
This document covers features supported by
&quot;ExtUtils::ParseXS&quot; (also known as
&quot;xsubpp&quot;) 3.13_01.</p>

<p style="margin-top: 1em">AUTHOR <br>
Originally written by Dean Roehrich
&lt;roehrich@cray.com&gt;.</p>

<p style="margin-top: 1em">Maintained since 1996 by The
Perl Porters &lt;perlbug@perl.org&gt;.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLXS(1)</p>
<hr>
</body>
</html>
