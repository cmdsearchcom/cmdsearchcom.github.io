<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLXS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLXS(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLXS(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perlxs - XS language reference manual
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<h2 class="Ss" title="Ss" id="Introduction"><a class="selflink" href="#Introduction">Introduction</a></h2>
XS is an interface description file format used to create an extension interface
  between Perl and C code (or a C library) which one wishes to use with Perl.
  The XS interface is combined with the library to create a new library which
  can then be either dynamically loaded or statically linked into perl. The XS
  interface description is written in the XS language and is the core component
  of the Perl extension interface.
<div class="Pp"></div>
An <b>XSUB</b> forms the basic unit of the XS interface. After compilation by
  the <b>xsubpp</b> compiler, each XSUB amounts to a C function definition which
  will provide the glue between Perl calling conventions and C calling
  conventions.
<div class="Pp"></div>
The glue code pulls the arguments from the Perl stack, converts these Perl
  values to the formats expected by a C function, call this C function,
  transfers the return values of the C function back to Perl. Return values here
  may be a conventional C return value or any C function arguments that may
  serve as output parameters. These return values may be passed back to Perl
  either by putting them on the Perl stack, or by modifying the arguments
  supplied from the Perl side.
<div class="Pp"></div>
The above is a somewhat simplified view of what really happens. Since Perl
  allows more flexible calling conventions than C, XSUBs may do much more in
  practice, such as checking input parameters for validity, throwing exceptions
  (or returning undef/empty list) if the return value from the C function
  indicates failure, calling different C functions based on numbers and types of
  the arguments, providing an object-oriented interface, etc.
<div class="Pp"></div>
Of course, one could write such glue code directly in C. However, this would be
  a tedious task, especially if one needs to write glue for multiple C
  functions, and/or one is not familiar enough with the Perl stack discipline
  and other such arcana. XS comes to the rescue here: instead of writing this
  glue C code in long-hand, one can write a more concise short-hand
  <i>description</i> of what should be done by the glue, and let the XS compiler
  <b>xsubpp</b> handle the rest.
<div class="Pp"></div>
The XS language allows one to describe the mapping between how the C routine is
  used, and how the corresponding Perl routine is used. It also allows creation
  of Perl routines which are directly translated to C code and which are not
  related to a pre-existing C function. In cases when the C interface coincides
  with the Perl interface, the XSUB declaration is almost identical to a
  declaration of a C function (in K&amp;R style). In such circumstances, there
  is another tool called &quot;h2xs&quot; that is able to translate an entire C
  header file into a corresponding XS file that will provide glue to the
  functions/macros described in the header file.
<div class="Pp"></div>
The XS compiler is called <b>xsubpp</b>. This compiler creates the constructs
  necessary to let an XSUB manipulate Perl values, and creates the glue
  necessary to let Perl call the XSUB. The compiler uses <b>typemaps</b> to
  determine how to map C function parameters and output values to Perl values
  and back. The default typemap (which comes with Perl) handles many common C
  types. A supplementary typemap may also be needed to handle any special
  structures and types for the library being linked. For more information on
  typemaps, see perlxstypemap.
<div class="Pp"></div>
A file in XS format starts with a C language section which goes until the first
  &quot;MODULE =&quot; directive. Other XS directives and XSUB definitions may
  follow this line. The &quot;language&quot; used in this part of the file is
  usually referred to as the XS language. <b>xsubpp</b> recognizes and skips POD
  (see perlpod) in both the C and XS language sections, which allows the XS file
  to contain embedded documentation.
<div class="Pp"></div>
See perlxstut for a tutorial on the whole extension creation process.
<div class="Pp"></div>
Note: For some extensions, Dave Beazley's SWIG system may provide a
  significantly more convenient mechanism for creating the extension glue code.
  See &lt;http://www.swig.org/&gt; for more information.
<h2 class="Ss" title="Ss" id="On_The_Road"><a class="selflink" href="#On_The_Road">On
  The Road</a></h2>
Many of the examples which follow will concentrate on creating an interface
  between Perl and the ONC+ RPC bind library functions. The
  <i>rpcb_gettime()</i> function is used to demonstrate many features of the XS
  language. This function has two parameters; the first is an input parameter
  and the second is an output parameter. The function also returns a status
  value.
<div class="Pp"></div>
<pre>
        bool_t rpcb_gettime(const char *host, time_t *timep);
</pre>
<div class="Pp"></div>
From C this function will be called with the following statements.
<div class="Pp"></div>
<pre>
     #include &lt;rpc/rpc.h&gt;
     bool_t status;
     time_t timep;
     status = rpcb_gettime( &quot;localhost&quot;, &amp;timep );
</pre>
<div class="Pp"></div>
If an XSUB is created to offer a direct translation between this function and
  Perl, then this XSUB will be used from Perl with the following code. The
  $status and $timep variables will contain the output of the function.
<div class="Pp"></div>
<pre>
     use RPC;
     $status = rpcb_gettime( &quot;localhost&quot;, $timep );
</pre>
<div class="Pp"></div>
The following XS file shows an XS subroutine, or XSUB, which demonstrates one
  possible interface to the <i>rpcb_gettime()</i> function. This XSUB represents
  a direct translation between C and Perl and so preserves the interface even
  from Perl. This XSUB will be invoked from Perl with the usage shown above.
  Note that the first three #include statements, for &quot;EXTERN.h&quot;,
  &quot;perl.h&quot;, and &quot;XSUB.h&quot;, will always be present at the
  beginning of an XS file. This approach and others will be expanded later in
  this document.
<div class="Pp"></div>
<pre>
     #include &quot;EXTERN.h&quot;
     #include &quot;perl.h&quot;
     #include &quot;XSUB.h&quot;
     #include &lt;rpc/rpc.h&gt;
     MODULE = RPC  PACKAGE = RPC
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
<div class="Pp"></div>
Any extension to Perl, including those containing XSUBs, should have a Perl
  module to serve as the bootstrap which pulls the extension into Perl. This
  module will export the extension's functions and variables to the Perl program
  and will cause the extension's XSUBs to be linked into Perl. The following
  module will be used for most of the examples in this document and should be
  used from Perl with the &quot;use&quot; command as shown earlier. Perl modules
  are explained in more detail later in this document.
<div class="Pp"></div>
<pre>
     package RPC;
     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw( rpcb_gettime );
     bootstrap RPC;
     1;
</pre>
<div class="Pp"></div>
Throughout this document a variety of interfaces to the <i>rpcb_gettime()</i>
  XSUB will be explored. The XSUBs will take their parameters in different
  orders or will take different numbers of parameters. In each case the XSUB is
  an abstraction between Perl and the real C <i>rpcb_gettime()</i> function, and
  the XSUB must always ensure that the real <i>rpcb_gettime()</i> function is
  called with the correct parameters. This abstraction will allow the programmer
  to create a more Perl-like interface to the C function.
<h2 class="Ss" title="Ss" id="The_Anatomy_of_an_XSUB"><a class="selflink" href="#The_Anatomy_of_an_XSUB">The
  Anatomy of an XSUB</a></h2>
The simplest XSUBs consist of 3 parts: a description of the return value, the
  name of the XSUB routine and the names of its arguments, and a description of
  types or formats of the arguments.
<div class="Pp"></div>
The following XSUB allows a Perl program to access a C library function called
  <i>sin()</i>. The XSUB will imitate the C function which takes a single
  argument and returns a single value.
<div class="Pp"></div>
<pre>
     double
     sin(x)
       double x
</pre>
<div class="Pp"></div>
Optionally, one can merge the description of types and the list of argument
  names, rewriting this as
<div class="Pp"></div>
<pre>
     double
     sin(double x)
</pre>
<div class="Pp"></div>
This makes this XSUB look similar to an ANSI C declaration. An optional
  semicolon is allowed after the argument list, as in
<div class="Pp"></div>
<pre>
     double
     sin(double x);
</pre>
<div class="Pp"></div>
Parameters with C pointer types can have different semantic: C functions with
  similar declarations
<div class="Pp"></div>
<pre>
     bool string_looks_as_a_number(char *s);
     bool make_char_uppercase(char *c);
</pre>
<div class="Pp"></div>
are used in absolutely incompatible manner. Parameters to these functions could
  be described <b>xsubpp</b> like this:
<div class="Pp"></div>
<pre>
     char *  s
     char    &amp;c
</pre>
<div class="Pp"></div>
Both these XS declarations correspond to the &quot;char*&quot; C type, but they
  have different semantics, see &quot;The &amp; Unary Operator&quot;.
<div class="Pp"></div>
It is convenient to think that the indirection operator &quot;*&quot; should be
  considered as a part of the type and the address operator &quot;&amp;&quot;
  should be considered part of the variable. See perlxstypemap for more info
  about handling qualifiers and unary operators in C types.
<div class="Pp"></div>
The function name and the return type must be placed on separate lines and
  should be flush left-adjusted.
<div class="Pp"></div>
<pre>
  INCORRECT                        CORRECT
  double sin(x)                    double
    double x                       sin(x)
                                     double x
</pre>
<div class="Pp"></div>
The rest of the function description may be indented or left-adjusted. The
  following example shows a function with its body left-adjusted. Most examples
  in this document will indent the body for better readability.
<div class="Pp"></div>
<pre>
  CORRECT
  double
  sin(x)
  double x
</pre>
<div class="Pp"></div>
More complicated XSUBs may contain many other sections. Each section of an XSUB
  starts with the corresponding keyword, such as INIT: or CLEANUP:. However, the
  first two lines of an XSUB always contain the same data: descriptions of the
  return type and the names of the function and its parameters. Whatever
  immediately follows these is considered to be an INPUT: section unless
  explicitly marked with another keyword. (See &quot;The INPUT: Keyword&quot;.)
<div class="Pp"></div>
An XSUB section continues until another section-start keyword is found.
<h2 class="Ss" title="Ss" id="The_Argument_Stack"><a class="selflink" href="#The_Argument_Stack">The
  Argument Stack</a></h2>
The Perl argument stack is used to store the values which are sent as parameters
  to the XSUB and to store the XSUB's return value(s). In reality all Perl
  functions (including non-XSUB ones) keep their values on this stack all the
  same time, each limited to its own range of positions on the stack. In this
  document the first position on that stack which belongs to the active function
  will be referred to as position 0 for that function.
<div class="Pp"></div>
XSUBs refer to their stack arguments with the macro <b>ST(x)</b>, where <i>x</i>
  refers to a position in this XSUB's part of the stack. Position 0 for that
  function would be known to the XSUB as <i>ST</i>(0). The XSUB's incoming
  parameters and outgoing return values always begin at <i>ST</i>(0). For many
  simple cases the <b>xsubpp</b> compiler will generate the code necessary to
  handle the argument stack by embedding code fragments found in the typemaps.
  In more complex cases the programmer must supply the code.
<h2 class="Ss" title="Ss" id="The_RETVAL_Variable"><a class="selflink" href="#The_RETVAL_Variable">The
  RETVAL Variable</a></h2>
The RETVAL variable is a special C variable that is declared automatically for
  you. The C type of RETVAL matches the return type of the C library function.
  The <b>xsubpp</b> compiler will declare this variable in each XSUB with
  non-&quot;void&quot; return type. By default the generated C function will use
  RETVAL to hold the return value of the C library function being called. In
  simple cases the value of RETVAL will be placed in <i>ST</i>(0) of the
  argument stack where it can be received by Perl as the return value of the
  XSUB.
<div class="Pp"></div>
If the XSUB has a return type of &quot;void&quot; then the compiler will not
  declare a RETVAL variable for that function. When using a PPCODE: section no
  manipulation of the RETVAL variable is required, the section may use direct
  stack manipulation to place output values on the stack.
<div class="Pp"></div>
If PPCODE: directive is not used, &quot;void&quot; return value should be used
  only for subroutines which do not return a value, <i>even if</i> CODE:
  directive is used which sets <i>ST</i>(0) explicitly.
<div class="Pp"></div>
Older versions of this document recommended to use &quot;void&quot; return value
  in such cases. It was discovered that this could lead to segfaults in cases
  when XSUB was <i>truly</i> &quot;void&quot;. This practice is now deprecated,
  and may be not supported at some future version. Use the return value &quot;SV
  *&quot; in such cases. (Currently &quot;xsubpp&quot; contains some heuristic
  code which tries to disambiguate between &quot;truly-void&quot; and
  &quot;old-practice-declared-as-void&quot; functions. Hence your code is at
  mercy of this heuristics unless you use &quot;SV *&quot; as return value.)
<h2 class="Ss" title="Ss" id="Returning_SVs,_AVs_and_HVs_through_RETVAL"><a class="selflink" href="#Returning_SVs,_AVs_and_HVs_through_RETVAL">Returning
  SVs, AVs and HVs through RETVAL</a></h2>
When you're using RETVAL to return an &quot;SV *&quot;, there's some magic going
  on behind the scenes that should be mentioned. When you're manipulating the
  argument stack using the ST(x) macro, for example, you usually have to pay
  special attention to reference counts. (For more about reference counts, see
  perlguts.) To make your life easier, the typemap file automatically makes
  &quot;RETVAL&quot; mortal when you're returning an &quot;SV *&quot;. Thus, the
  following two XSUBs are more or less equivalent:
<div class="Pp"></div>
<pre>
  void
  alpha()
      PPCODE:
          ST(0) = newSVpv(&quot;Hello World&quot;,0);
          sv_2mortal(ST(0));
          XSRETURN(1);
  SV *
  beta()
      CODE:
          RETVAL = newSVpv(&quot;Hello World&quot;,0);
      OUTPUT:
          RETVAL
</pre>
<div class="Pp"></div>
This is quite useful as it usually improves readability. While this works fine
  for an &quot;SV *&quot;, it's unfortunately not as easy to have &quot;AV
  *&quot; or &quot;HV *&quot; as a return value. You <i>should</i> be able to
  write:
<div class="Pp"></div>
<pre>
  AV *
  array()
      CODE:
          RETVAL = newAV();
          /* do something with RETVAL */
      OUTPUT:
          RETVAL
</pre>
<div class="Pp"></div>
But due to an unfixable bug (fixing it would break lots of existing CPAN
  modules) in the typemap file, the reference count of the &quot;AV *&quot; is
  not properly decremented. Thus, the above XSUB would leak memory whenever it
  is being called. The same problem exists for &quot;HV *&quot;, &quot;CV
  *&quot;, and &quot;SVREF&quot; (which indicates a scalar reference, not a
  general &quot;SV *&quot;). In XS code on perls starting with perl 5.16, you
  can override the typemaps for any of these types with a version that has
  proper handling of refcounts. In your &quot;TYPEMAP&quot; section, do
<div class="Pp"></div>
<pre>
  AV*   T_AVREF_REFCOUNT_FIXED
</pre>
<div class="Pp"></div>
to get the repaired variant. For backward compatibility with older versions of
  perl, you can instead decrement the reference count manually when you're
  returning one of the aforementioned types using &quot;sv_2mortal&quot;:
<div class="Pp"></div>
<pre>
  AV *
  array()
      CODE:
          RETVAL = newAV();
          sv_2mortal((SV*)RETVAL);
          /* do something with RETVAL */
      OUTPUT:
          RETVAL
</pre>
<div class="Pp"></div>
Remember that you don't have to do this for an &quot;SV *&quot;. The reference
  documentation for all core typemaps can be found in perlxstypemap.
<h2 class="Ss" title="Ss" id="The_MODULE_Keyword"><a class="selflink" href="#The_MODULE_Keyword">The
  MODULE Keyword</a></h2>
The MODULE keyword is used to start the XS code and to specify the package of
  the functions which are being defined. All text preceding the first MODULE
  keyword is considered C code and is passed through to the output with POD
  stripped, but otherwise untouched. Every XS module will have a bootstrap
  function which is used to hook the XSUBs into Perl. The package name of this
  bootstrap function will match the value of the last MODULE statement in the XS
  source files. The value of MODULE should always remain constant within the
  same XS file, though this is not required.
<div class="Pp"></div>
The following example will start the XS code and will place all functions in a
  package named RPC.
<div class="Pp"></div>
<pre>
     MODULE = RPC
</pre>
<h2 class="Ss" title="Ss" id="The_PACKAGE_Keyword"><a class="selflink" href="#The_PACKAGE_Keyword">The
  PACKAGE Keyword</a></h2>
When functions within an XS source file must be separated into packages the
  PACKAGE keyword should be used. This keyword is used with the MODULE keyword
  and must follow immediately after it when used.
<div class="Pp"></div>
<pre>
     MODULE = RPC  PACKAGE = RPC
     [ XS code in package RPC ]
     MODULE = RPC  PACKAGE = RPCB
     [ XS code in package RPCB ]
     MODULE = RPC  PACKAGE = RPC
     [ XS code in package RPC ]
</pre>
<div class="Pp"></div>
The same package name can be used more than once, allowing for non-contiguous
  code. This is useful if you have a stronger ordering principle than package
  names.
<div class="Pp"></div>
Although this keyword is optional and in some cases provides redundant
  information it should always be used. This keyword will ensure that the XSUBs
  appear in the desired package.
<h2 class="Ss" title="Ss" id="The_PREFIX_Keyword"><a class="selflink" href="#The_PREFIX_Keyword">The
  PREFIX Keyword</a></h2>
The PREFIX keyword designates prefixes which should be removed from the Perl
  function names. If the C function is &quot;rpcb_gettime()&quot; and the PREFIX
  value is &quot;rpcb_&quot; then Perl will see this function as
  &quot;gettime()&quot;.
<div class="Pp"></div>
This keyword should follow the PACKAGE keyword when used. If PACKAGE is not used
  then PREFIX should follow the MODULE keyword.
<div class="Pp"></div>
<pre>
     MODULE = RPC  PREFIX = rpc_
     MODULE = RPC  PACKAGE = RPCB  PREFIX = rpcb_
</pre>
<h2 class="Ss" title="Ss" id="The_OUTPUT:_Keyword"><a class="selflink" href="#The_OUTPUT:_Keyword">The
  OUTPUT: Keyword</a></h2>
The OUTPUT: keyword indicates that certain function parameters should be updated
  (new values made visible to Perl) when the XSUB terminates or that certain
  values should be returned to the calling Perl function. For simple functions
  which have no CODE: or PPCODE: section, such as the <i>sin()</i> function
  above, the RETVAL variable is automatically designated as an output value. For
  more complex functions the <b>xsubpp</b> compiler will need help to determine
  which variables are output variables.
<div class="Pp"></div>
This keyword will normally be used to complement the CODE: keyword. The RETVAL
  variable is not recognized as an output variable when the CODE: keyword is
  present. The OUTPUT: keyword is used in this situation to tell the compiler
  that RETVAL really is an output variable.
<div class="Pp"></div>
The OUTPUT: keyword can also be used to indicate that function parameters are
  output variables. This may be necessary when a parameter has been modified
  within the function and the programmer would like the update to be seen by
  Perl.
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
<div class="Pp"></div>
The OUTPUT: keyword will also allow an output parameter to be mapped to a
  matching piece of code rather than to a typemap.
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep sv_setnv(ST(1), (double)timep);
</pre>
<div class="Pp"></div>
<b>xsubpp</b> emits an automatic &quot;SvSETMAGIC()&quot; for all parameters in
  the OUTPUT section of the XSUB, except RETVAL. This is the usually desired
  behavior, as it takes care of properly invoking 'set' magic on output
  parameters (needed for hash or array element parameters that must be created
  if they didn't exist). If for some reason, this behavior is not desired, the
  OUTPUT section may contain a &quot;SETMAGIC: DISABLE&quot; line to disable it
  for the remainder of the parameters in the OUTPUT section. Likewise,
  &quot;SETMAGIC: ENABLE&quot; can be used to reenable it for the remainder of
  the OUTPUT section. See perlguts for more details about 'set' magic.
<h2 class="Ss" title="Ss" id="The_NO_OUTPUT_Keyword"><a class="selflink" href="#The_NO_OUTPUT_Keyword">The
  NO_OUTPUT Keyword</a></h2>
The NO_OUTPUT can be placed as the first token of the XSUB. This keyword
  indicates that while the C subroutine we provide an interface to has a
  non-&quot;void&quot; return type, the return value of this C subroutine should
  not be returned from the generated Perl subroutine.
<div class="Pp"></div>
With this keyword present &quot;The RETVAL Variable&quot; is created, and in the
  generated call to the subroutine this variable is assigned to, but the value
  of this variable is not going to be used in the auto-generated code.
<div class="Pp"></div>
This keyword makes sense only if &quot;RETVAL&quot; is going to be accessed by
  the user-supplied code. It is especially useful to make a function interface
  more Perl-like, especially when the C return value is just an error condition
  indicator. For example,
<div class="Pp"></div>
<pre>
  NO_OUTPUT int
  delete_file(char *name)
    POSTCALL:
      if (RETVAL != 0)
          croak(&quot;Error %d while deleting file '%s'&quot;, RETVAL, name);
</pre>
<div class="Pp"></div>
Here the generated XS function returns nothing on success, and will <i>die()</i>
  with a meaningful error message on error.
<h2 class="Ss" title="Ss" id="The_CODE:_Keyword"><a class="selflink" href="#The_CODE:_Keyword">The
  CODE: Keyword</a></h2>
This keyword is used in more complicated XSUBs which require special handling
  for the C function. The RETVAL variable is still declared, but it will not be
  returned unless it is specified in the OUTPUT: section.
<div class="Pp"></div>
The following XSUB is for a C function which requires special handling of its
  parameters. The Perl usage is given first.
<div class="Pp"></div>
<pre>
     $status = rpcb_gettime( &quot;localhost&quot;, $timep );
</pre>
<div class="Pp"></div>
The XSUB follows.
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t timep
        CODE:
               RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<h2 class="Ss" title="Ss" id="The_INIT:_Keyword"><a class="selflink" href="#The_INIT:_Keyword">The
  INIT: Keyword</a></h2>
The INIT: keyword allows initialization to be inserted into the XSUB before the
  compiler generates the call to the C function. Unlike the CODE: keyword above,
  this keyword does not affect the way the compiler handles RETVAL.
<div class="Pp"></div>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        INIT:
          printf(&quot;# Host is %s\n&quot;, host );
        OUTPUT:
          timep
</pre>
<div class="Pp"></div>
Another use for the INIT: section is to check for preconditions before making a
  call to the C function:
<div class="Pp"></div>
<pre>
    long long
    lldiv(a,b)
        long long a
        long long b
      INIT:
        if (a == 0 &amp;&amp; b == 0)
            XSRETURN_UNDEF;
        if (b == 0)
            croak(&quot;lldiv: cannot divide by 0&quot;);
</pre>
<h2 class="Ss" title="Ss" id="The_NO_INIT_Keyword"><a class="selflink" href="#The_NO_INIT_Keyword">The
  NO_INIT Keyword</a></h2>
The NO_INIT keyword is used to indicate that a function parameter is being used
  only as an output value. The <b>xsubpp</b> compiler will normally generate
  code to read the values of all function parameters from the argument stack and
  assign them to C variables upon entry to the function. NO_INIT will tell the
  compiler that some parameters will be used for output rather than for input
  and that they will be handled before the function terminates.
<div class="Pp"></div>
The following example shows a variation of the <i>rpcb_gettime()</i> function.
  This function uses the timep variable only as an output variable and does not
  care about its initial contents.
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep = NO_INIT
        OUTPUT:
          timep
</pre>
<h2 class="Ss" title="Ss" id="The_TYPEMAP:_Keyword"><a class="selflink" href="#The_TYPEMAP:_Keyword">The
  TYPEMAP: Keyword</a></h2>
Starting with Perl 5.16, you can embed typemaps into your XS code instead of or
  in addition to typemaps in a separate file. Multiple such embedded typemaps
  will be processed in order of appearance in the XS code and like local typemap
  files take precendence over the default typemap, the embedded typemaps may
  overwrite previous definitions of TYPEMAP, INPUT, and OUTPUT stanzas. The
  syntax for embedded typemaps is
<div class="Pp"></div>
<pre>
      TYPEMAP: &lt;&lt;HERE
      ... your typemap code here ...
      HERE
</pre>
<div class="Pp"></div>
where the &quot;TYPEMAP&quot; keyword must appear in the first column of a new
  line.
<div class="Pp"></div>
Refer to perlxstypemap for details on writing typemaps.
<h2 class="Ss" title="Ss" id="Initializing_Function_Parameters"><a class="selflink" href="#Initializing_Function_Parameters">Initializing
  Function Parameters</a></h2>
C function parameters are normally initialized with their values from the
  argument stack (which in turn contains the parameters that were passed to the
  XSUB from Perl). The typemaps contain the code segments which are used to
  translate the Perl values to the C parameters. The programmer, however, is
  allowed to override the typemaps and supply alternate (or additional)
  initialization code. Initialization code starts with the first &quot;=&quot;,
  &quot;;&quot; or &quot;+&quot; on a line in the INPUT: section. The only
  exception happens if this &quot;;&quot; terminates the line, then this
  &quot;;&quot; is quietly ignored.
<div class="Pp"></div>
The following code demonstrates how to supply initialization code for function
  parameters. The initialization code is eval'ed within double quotes by the
  compiler before it is added to the output so anything which should be
  interpreted literally [mainly &quot;$&quot;, &quot;@&quot;, or &quot;\\&quot;]
  must be protected with backslashes. The variables $var, $arg, and $type can be
  used as in typemaps.
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host = (char *)SvPV_nolen($arg);
          time_t &amp;timep = 0;
        OUTPUT:
          timep
</pre>
<div class="Pp"></div>
This should not be used to supply default values for parameters. One would
  normally use this when a function parameter must be processed by another
  library function before it can be used. Default parameters are covered in the
  next section.
<div class="Pp"></div>
If the initialization begins with &quot;=&quot;, then it is output in the
  declaration for the input variable, replacing the initialization supplied by
  the typemap. If the initialization begins with &quot;;&quot; or &quot;+&quot;,
  then it is performed after all of the input variables have been declared. In
  the &quot;;&quot; case the initialization normally supplied by the typemap is
  not performed. For the &quot;+&quot; case, the declaration for the variable
  will include the initialization from the typemap. A global variable, %v, is
  available for the truly rare case where information from one initialization is
  needed in another initialization.
<div class="Pp"></div>
Here's a truly obscure example:
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          time_t &amp;timep; /* \$v{timep}=@{[$v{timep}=$arg]} */
          char *host + SvOK($v{timep}) ? SvPV_nolen($arg) : NULL;
        OUTPUT:
          timep
</pre>
<div class="Pp"></div>
The construct &quot;\$v{timep}=@{[$v{timep}=$arg]}&quot; used in the above
  example has a two-fold purpose: first, when this line is processed by
  <b>xsubpp</b>, the Perl snippet &quot;$v{timep}=$arg&quot; is evaluated.
  Second, the text of the evaluated snippet is output into the generated C file
  (inside a C comment)! During the processing of &quot;char *host&quot; line,
  $arg will evaluate to ST(0), and $v{timep} will evaluate to ST(1).
<h2 class="Ss" title="Ss" id="Default_Parameter_Values"><a class="selflink" href="#Default_Parameter_Values">Default
  Parameter Values</a></h2>
Default values for XSUB arguments can be specified by placing an assignment
  statement in the parameter list. The default value may be a number, a string
  or the special string &quot;NO_INIT&quot;. Defaults should always be used on
  the right-most parameters only.
<div class="Pp"></div>
To allow the XSUB for <i>rpcb_gettime()</i> to have a default host value the
  parameters to the XSUB could be rearranged. The XSUB will then call the real
  <i>rpcb_gettime()</i> function with the parameters in the correct order. This
  XSUB can be called from Perl with either of the following statements:
<div class="Pp"></div>
<pre>
     $status = rpcb_gettime( $timep, $host );
     $status = rpcb_gettime( $timep );
</pre>
<div class="Pp"></div>
The XSUB will look like the code which follows. A CODE: block is used to call
  the real <i>rpcb_gettime()</i> function with the parameters in the correct
  order for that function.
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(timep,host=&quot;localhost&quot;)
          char *host
          time_t timep = NO_INIT
        CODE:
               RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<h2 class="Ss" title="Ss" id="The_PREINIT:_Keyword"><a class="selflink" href="#The_PREINIT:_Keyword">The
  PREINIT: Keyword</a></h2>
The PREINIT: keyword allows extra variables to be declared immediately before or
  after the declarations of the parameters from the INPUT: section are emitted.
<div class="Pp"></div>
If a variable is declared inside a CODE: section it will follow any typemap code
  that is emitted for the input parameters. This may result in the declaration
  ending up after C code, which is C syntax error. Similar errors may happen
  with an explicit &quot;;&quot;-type or &quot;+&quot;-type initialization of
  parameters is used (see &quot;Initializing Function Parameters&quot;).
  Declaring these variables in an INIT: section will not help.
<div class="Pp"></div>
In such cases, to force an additional variable to be declared together with
  declarations of other variables, place the declaration into a PREINIT:
  section. The PREINIT: keyword may be used one or more times within an XSUB.
<div class="Pp"></div>
The following examples are equivalent, but if the code is using complex typemaps
  then the first example is safer.
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
        PREINIT:
          char *host = &quot;localhost&quot;;
        CODE:
          RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<div class="Pp"></div>
For this particular case an INIT: keyword would generate the same C code as the
  PREINIT: keyword. Another correct, but error-prone example:
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
        CODE:
          char *host = &quot;localhost&quot;;
          RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<div class="Pp"></div>
Another way to declare &quot;host&quot; is to use a C block in the CODE:
  section:
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
        CODE:
          {
            char *host = &quot;localhost&quot;;
            RETVAL = rpcb_gettime( host, &amp;timep );
          }
        OUTPUT:
          timep
          RETVAL
</pre>
<div class="Pp"></div>
The ability to put additional declarations before the typemap entries are
  processed is very handy in the cases when typemap conversions manipulate some
  global state:
<div class="Pp"></div>
<pre>
    MyObject
    mutate(o)
        PREINIT:
            MyState st = global_state;
        INPUT:
            MyObject o;
        CLEANUP:
            reset_to(global_state, st);
</pre>
<div class="Pp"></div>
Here we suppose that conversion to &quot;MyObject&quot; in the INPUT: section
  and from MyObject when processing RETVAL will modify a global variable
  &quot;global_state&quot;. After these conversions are performed, we restore
  the old value of &quot;global_state&quot; (to avoid memory leaks, for
  example).
<div class="Pp"></div>
There is another way to trade clarity for compactness: INPUT sections allow
  declaration of C variables which do not appear in the parameter list of a
  subroutine. Thus the above code for <i>mutate()</i> can be rewritten as
<div class="Pp"></div>
<pre>
    MyObject
    mutate(o)
          MyState st = global_state;
          MyObject o;
        CLEANUP:
          reset_to(global_state, st);
</pre>
<div class="Pp"></div>
and the code for <i>rpcb_gettime()</i> can be rewritten as
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
          char *host = &quot;localhost&quot;;
        C_ARGS:
          host, &amp;timep
        OUTPUT:
          timep
          RETVAL
</pre>
<h2 class="Ss" title="Ss" id="The_SCOPE:_Keyword"><a class="selflink" href="#The_SCOPE:_Keyword">The
  SCOPE: Keyword</a></h2>
The SCOPE: keyword allows scoping to be enabled for a particular XSUB. If
  enabled, the XSUB will invoke ENTER and LEAVE automatically.
<div class="Pp"></div>
To support potentially complex type mappings, if a typemap entry used by an XSUB
  contains a comment like &quot;/*scope*/&quot; then scoping will be
  automatically enabled for that XSUB.
<div class="Pp"></div>
To enable scoping:
<div class="Pp"></div>
<pre>
    SCOPE: ENABLE
</pre>
<div class="Pp"></div>
To disable scoping:
<div class="Pp"></div>
<pre>
    SCOPE: DISABLE
</pre>
<h2 class="Ss" title="Ss" id="The_INPUT:_Keyword"><a class="selflink" href="#The_INPUT:_Keyword">The
  INPUT: Keyword</a></h2>
The XSUB's parameters are usually evaluated immediately after entering the XSUB.
  The INPUT: keyword can be used to force those parameters to be evaluated a
  little later. The INPUT: keyword can be used multiple times within an XSUB and
  can be used to list one or more input variables. This keyword is used with the
  PREINIT: keyword.
<div class="Pp"></div>
The following example shows how the input parameter &quot;timep&quot; can be
  evaluated late, after a PREINIT.
<div class="Pp"></div>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
        PREINIT:
          time_t tt;
        INPUT:
          time_t timep
        CODE:
               RETVAL = rpcb_gettime( host, &amp;tt );
               timep = tt;
        OUTPUT:
          timep
          RETVAL
</pre>
<div class="Pp"></div>
The next example shows each input parameter evaluated late.
<div class="Pp"></div>
<pre>
    bool_t
    rpcb_gettime(host,timep)
        PREINIT:
          time_t tt;
        INPUT:
          char *host
        PREINIT:
          char *h;
        INPUT:
          time_t timep
        CODE:
               h = host;
               RETVAL = rpcb_gettime( h, &amp;tt );
               timep = tt;
        OUTPUT:
          timep
          RETVAL
</pre>
<div class="Pp"></div>
Since INPUT sections allow declaration of C variables which do not appear in the
  parameter list of a subroutine, this may be shortened to:
<div class="Pp"></div>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          time_t tt;
          char *host;
          char *h = host;
          time_t timep;
        CODE:
          RETVAL = rpcb_gettime( h, &amp;tt );
          timep = tt;
        OUTPUT:
          timep
          RETVAL
</pre>
<div class="Pp"></div>
(We used our knowledge that input conversion for &quot;char *&quot; is a
  &quot;simple&quot; one, thus &quot;host&quot; is initialized on the
  declaration line, and our assignment &quot;h = host&quot; is not performed too
  early. Otherwise one would need to have the assignment &quot;h = host&quot; in
  a CODE: or INIT: section.)
<h2 class="Ss" title="Ss" id="The_IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT_Keywords"><a class="selflink" href="#The_IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT_Keywords">The
  IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords</a></h2>
In the list of parameters for an XSUB, one can precede parameter names by the
  &quot;IN&quot;/&quot;OUTLIST&quot;/&quot;IN_OUTLIST&quot;/&quot;OUT&quot;/&quot;IN_OUT&quot;
  keywords. &quot;IN&quot; keyword is the default, the other keywords indicate
  how the Perl interface should differ from the C interface.
<div class="Pp"></div>
Parameters preceded by
  &quot;OUTLIST&quot;/&quot;IN_OUTLIST&quot;/&quot;OUT&quot;/&quot;IN_OUT&quot;
  keywords are considered to be used by the C subroutine <i>via</i>
  <i>pointers</i>. &quot;OUTLIST&quot;/&quot;OUT&quot; keywords indicate that
  the C subroutine does not inspect the memory pointed by this parameter, but
  will write through this pointer to provide additional return values.
<div class="Pp"></div>
Parameters preceded by &quot;OUTLIST&quot; keyword do not appear in the usage
  signature of the generated Perl function.
<div class="Pp"></div>
Parameters preceded by &quot;IN_OUTLIST&quot;/&quot;IN_OUT&quot;/&quot;OUT&quot;
  <i>do</i> appear as parameters to the Perl function. With the exception of
  &quot;OUT&quot;-parameters, these parameters are converted to the
  corresponding C type, then pointers to these data are given as arguments to
  the C function. It is expected that the C function will write through these
  pointers.
<div class="Pp"></div>
The return list of the generated Perl function consists of the C return value
  from the function (unless the XSUB is of &quot;void&quot; return type or
  &quot;The NO_OUTPUT Keyword&quot; was used) followed by all the
  &quot;OUTLIST&quot; and &quot;IN_OUTLIST&quot; parameters (in the order of
  appearance). On the return from the XSUB the
  &quot;IN_OUT&quot;/&quot;OUT&quot; Perl parameter will be modified to have the
  values written by the C function.
<div class="Pp"></div>
For example, an XSUB
<div class="Pp"></div>
<pre>
  void
  day_month(OUTLIST day, IN unix_time, OUTLIST month)
    int day
    int unix_time
    int month
</pre>
<div class="Pp"></div>
should be used from Perl as
<div class="Pp"></div>
<pre>
  my ($day, $month) = day_month(time);
</pre>
<div class="Pp"></div>
The C signature of the corresponding function should be
<div class="Pp"></div>
<pre>
  void day_month(int *day, int unix_time, int *month);
</pre>
<div class="Pp"></div>
The
  &quot;IN&quot;/&quot;OUTLIST&quot;/&quot;IN_OUTLIST&quot;/&quot;IN_OUT&quot;/&quot;OUT&quot;
  keywords can be mixed with ANSI-style declarations, as in
<div class="Pp"></div>
<pre>
  void
  day_month(OUTLIST int day, int unix_time, OUTLIST int month)
</pre>
<div class="Pp"></div>
(here the optional &quot;IN&quot; keyword is omitted).
<div class="Pp"></div>
The &quot;IN_OUT&quot; parameters are identical with parameters introduced with
  &quot;The &amp; Unary Operator&quot; and put into the &quot;OUTPUT:&quot;
  section (see &quot;The OUTPUT: Keyword&quot;). The &quot;IN_OUTLIST&quot;
  parameters are very similar, the only difference being that the value C
  function writes through the pointer would not modify the Perl parameter, but
  is put in the output list.
<div class="Pp"></div>
The &quot;OUTLIST&quot;/&quot;OUT&quot; parameter differ from
  &quot;IN_OUTLIST&quot;/&quot;IN_OUT&quot; parameters only by the initial value
  of the Perl parameter not being read (and not being given to the C function -
  which gets some garbage instead). For example, the same C function as above
  can be interfaced with as
<div class="Pp"></div>
<pre>
  void day_month(OUT int day, int unix_time, OUT int month);
</pre>
<div class="Pp"></div>
or
<div class="Pp"></div>
<pre>
  void
  day_month(day, unix_time, month)
      int &amp;day = NO_INIT
      int  unix_time
      int &amp;month = NO_INIT
    OUTPUT:
      day
      month
</pre>
<div class="Pp"></div>
However, the generated Perl function is called in very C-ish style:
<div class="Pp"></div>
<pre>
  my ($day, $month);
  day_month($day, time, $month);
</pre>
<h2 class="Ss" title="Ss" id="The_&quot;length(NAME)&quot;_Keyword"><a class="selflink" href="#The_&quot;length(NAME)&quot;_Keyword">The
  &quot;length(NAME)&quot; Keyword</a></h2>
If one of the input arguments to the C function is the length of a string
  argument &quot;NAME&quot;, one can substitute the name of the length-argument
  by &quot;length(NAME)&quot; in the XSUB declaration. This argument must be
  omitted when the generated Perl function is called. E.g.,
<div class="Pp"></div>
<pre>
  void
  dump_chars(char *s, short l)
  {
    short n = 0;
    while (n &lt; l) {
        printf(&quot;s[%d] = \&quot;\\%#03o\&quot;\n&quot;, n, (int)s[n]);
        n++;
    }
  }
  MODULE = x            PACKAGE = x
  void dump_chars(char *s, short length(s))
</pre>
<div class="Pp"></div>
should be called as &quot;dump_chars($string)&quot;.
<div class="Pp"></div>
This directive is supported with ANSI-type function declarations only.
<h2 class="Ss" title="Ss" id="Variable-length_Parameter_Lists"><a class="selflink" href="#Variable-length_Parameter_Lists">Variable-length
  Parameter Lists</a></h2>
XSUBs can have variable-length parameter lists by specifying an ellipsis
  &quot;(...)&quot; in the parameter list. This use of the ellipsis is similar
  to that found in ANSI C. The programmer is able to determine the number of
  arguments passed to the XSUB by examining the &quot;items&quot; variable which
  the <b>xsubpp</b> compiler supplies for all XSUBs. By using this mechanism one
  can create an XSUB which accepts a list of parameters of unknown length.
<div class="Pp"></div>
The <i>host</i> parameter for the <i>rpcb_gettime()</i> XSUB can be optional so
  the ellipsis can be used to indicate that the XSUB will take a variable number
  of parameters. Perl should be able to call this XSUB with either of the
  following statements.
<div class="Pp"></div>
<pre>
     $status = rpcb_gettime( $timep, $host );
     $status = rpcb_gettime( $timep );
</pre>
<div class="Pp"></div>
The XS code, with ellipsis, follows.
<div class="Pp"></div>
<pre>
     bool_t
     rpcb_gettime(timep, ...)
          time_t timep = NO_INIT
        PREINIT:
          char *host = &quot;localhost&quot;;
        CODE:
          if( items &gt; 1 )
               host = (char *)SvPV_nolen(ST(1));
          RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<h2 class="Ss" title="Ss" id="The_C_ARGS:_Keyword"><a class="selflink" href="#The_C_ARGS:_Keyword">The
  C_ARGS: Keyword</a></h2>
The C_ARGS: keyword allows creating of XSUBS which have different calling
  sequence from Perl than from C, without a need to write CODE: or PPCODE:
  section. The contents of the C_ARGS: paragraph is put as the argument to the
  called C function without any change.
<div class="Pp"></div>
For example, suppose that a C function is declared as
<div class="Pp"></div>
<pre>
    symbolic nth_derivative(int n, symbolic function, int flags);
</pre>
<div class="Pp"></div>
and that the default flags are kept in a global C variable
  &quot;default_flags&quot;. Suppose that you want to create an interface which
  is called as
<div class="Pp"></div>
<pre>
    $second_deriv = $function-&gt;nth_derivative(2);
</pre>
<div class="Pp"></div>
To do this, declare the XSUB as
<div class="Pp"></div>
<pre>
    symbolic
    nth_derivative(function, n)
        symbolic        function
        int             n
      C_ARGS:
        n, function, default_flags
</pre>
<h2 class="Ss" title="Ss" id="The_PPCODE:_Keyword"><a class="selflink" href="#The_PPCODE:_Keyword">The
  PPCODE: Keyword</a></h2>
The PPCODE: keyword is an alternate form of the CODE: keyword and is used to
  tell the <b>xsubpp</b> compiler that the programmer is supplying the code to
  control the argument stack for the XSUBs return values. Occasionally one will
  want an XSUB to return a list of values rather than a single value. In these
  cases one must use PPCODE: and then explicitly push the list of values on the
  stack. The PPCODE: and CODE: keywords should not be used together within the
  same XSUB.
<div class="Pp"></div>
The actual difference between PPCODE: and CODE: sections is in the
  initialization of &quot;SP&quot; macro (which stands for the <i>current</i>
  Perl stack pointer), and in the handling of data on the stack when returning
  from an XSUB. In CODE: sections SP preserves the value which was on entry to
  the XSUB: SP is on the function pointer (which follows the last parameter). In
  PPCODE: sections SP is moved backward to the beginning of the parameter list,
  which allows &quot;PUSH*()&quot; macros to place output values in the place
  Perl expects them to be when the XSUB returns back to Perl.
<div class="Pp"></div>
The generated trailer for a CODE: section ensures that the number of return
  values Perl will see is either 0 or 1 (depending on the &quot;void&quot;ness
  of the return value of the C function, and heuristics mentioned in &quot;The
  RETVAL Variable&quot;). The trailer generated for a PPCODE: section is based
  on the number of return values and on the number of times &quot;SP&quot; was
  updated by &quot;[X]PUSH*()&quot; macros.
<div class="Pp"></div>
Note that macros ST(i), &quot;XST_m*()&quot; and &quot;XSRETURN*()&quot; work
  equally well in CODE: sections and PPCODE: sections.
<div class="Pp"></div>
The following XSUB will call the C <i>rpcb_gettime()</i> function and will
  return its two output values, timep and status, to Perl as a single list.
<div class="Pp"></div>
<pre>
     void
     rpcb_gettime(host)
          char *host
        PREINIT:
          time_t  timep;
          bool_t  status;
        PPCODE:
          status = rpcb_gettime( host, &amp;timep );
          EXTEND(SP, 2);
          PUSHs(sv_2mortal(newSViv(status)));
          PUSHs(sv_2mortal(newSViv(timep)));
</pre>
<div class="Pp"></div>
Notice that the programmer must supply the C code necessary to have the real
  <i>rpcb_gettime()</i> function called and to have the return values properly
  placed on the argument stack.
<div class="Pp"></div>
The &quot;void&quot; return type for this function tells the <b>xsubpp</b>
  compiler that the RETVAL variable is not needed or used and that it should not
  be created. In most scenarios the void return type should be used with the
  PPCODE: directive.
<div class="Pp"></div>
The <i>EXTEND()</i> macro is used to make room on the argument stack for 2
  return values. The PPCODE: directive causes the <b>xsubpp</b> compiler to
  create a stack pointer available as &quot;SP&quot;, and it is this pointer
  which is being used in the <i>EXTEND()</i> macro. The values are then pushed
  onto the stack with the <i>PUSHs()</i> macro.
<div class="Pp"></div>
Now the <i>rpcb_gettime()</i> function can be used from Perl with the following
  statement.
<div class="Pp"></div>
<pre>
     ($status, $timep) = rpcb_gettime(&quot;localhost&quot;);
</pre>
<div class="Pp"></div>
When handling output parameters with a PPCODE section, be sure to handle 'set'
  magic properly. See perlguts for details about 'set' magic.
<h2 class="Ss" title="Ss" id="Returning_Undef_And_Empty_Lists"><a class="selflink" href="#Returning_Undef_And_Empty_Lists">Returning
  Undef And Empty Lists</a></h2>
Occasionally the programmer will want to return simply &quot;undef&quot; or an
  empty list if a function fails rather than a separate status value. The
  <i>rpcb_gettime()</i> function offers just this situation. If the function
  succeeds we would like to have it return the time and if it fails we would
  like to have undef returned. In the following Perl code the value of $timep
  will either be undef or it will be a valid time.
<div class="Pp"></div>
<pre>
     $timep = rpcb_gettime( &quot;localhost&quot; );
</pre>
<div class="Pp"></div>
The following XSUB uses the &quot;SV *&quot; return type as a mnemonic only, and
  uses a CODE: block to indicate to the compiler that the programmer has
  supplied all the necessary code. The <i>sv_newmortal()</i> call will
  initialize the return value to undef, making that the default return value.
<div class="Pp"></div>
<pre>
     SV *
     rpcb_gettime(host)
          char *  host
        PREINIT:
          time_t  timep;
          bool_t x;
        CODE:
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &amp;timep ) )
               sv_setnv( ST(0), (double)timep);
</pre>
<div class="Pp"></div>
The next example demonstrates how one would place an explicit undef in the
  return value, should the need arise.
<div class="Pp"></div>
<pre>
     SV *
     rpcb_gettime(host)
          char *  host
        PREINIT:
          time_t  timep;
          bool_t x;
        CODE:
          if( rpcb_gettime( host, &amp;timep ) ){
               ST(0) = sv_newmortal();
               sv_setnv( ST(0), (double)timep);
          }
          else{
               ST(0) = &amp;PL_sv_undef;
          }
</pre>
<div class="Pp"></div>
To return an empty list one must use a PPCODE: block and then not push return
  values on the stack.
<div class="Pp"></div>
<pre>
     void
     rpcb_gettime(host)
          char *host
        PREINIT:
          time_t  timep;
        PPCODE:
          if( rpcb_gettime( host, &amp;timep ) )
               PUSHs(sv_2mortal(newSViv(timep)));
          else{
              /* Nothing pushed on stack, so an empty
               * list is implicitly returned. */
          }
</pre>
<div class="Pp"></div>
Some people may be inclined to include an explicit &quot;return&quot; in the
  above XSUB, rather than letting control fall through to the end. In those
  situations &quot;XSRETURN_EMPTY&quot; should be used, instead. This will
  ensure that the XSUB stack is properly adjusted. Consult perlapi for other
  &quot;XSRETURN&quot; macros.
<div class="Pp"></div>
Since &quot;XSRETURN_*&quot; macros can be used with CODE blocks as well, one
  can rewrite this example as:
<div class="Pp"></div>
<pre>
     int
     rpcb_gettime(host)
          char *host
        PREINIT:
          time_t  timep;
        CODE:
          RETVAL = rpcb_gettime( host, &amp;timep );
          if (RETVAL == 0)
                XSRETURN_UNDEF;
        OUTPUT:
          RETVAL
</pre>
<div class="Pp"></div>
In fact, one can put this check into a POSTCALL: section as well. Together with
  PREINIT: simplifications, this leads to:
<div class="Pp"></div>
<pre>
     int
     rpcb_gettime(host)
          char *host
          time_t  timep;
        POSTCALL:
          if (RETVAL == 0)
                XSRETURN_UNDEF;
</pre>
<h2 class="Ss" title="Ss" id="The_REQUIRE:_Keyword"><a class="selflink" href="#The_REQUIRE:_Keyword">The
  REQUIRE: Keyword</a></h2>
The REQUIRE: keyword is used to indicate the minimum version of the
  <b>xsubpp</b> compiler needed to compile the XS module. An XS module which
  contains the following statement will compile with only <b>xsubpp</b> version
  1.922 or greater:
<div class="Pp"></div>
<pre>
        REQUIRE: 1.922
</pre>
<h2 class="Ss" title="Ss" id="The_CLEANUP:_Keyword"><a class="selflink" href="#The_CLEANUP:_Keyword">The
  CLEANUP: Keyword</a></h2>
This keyword can be used when an XSUB requires special cleanup procedures before
  it terminates. When the CLEANUP: keyword is used it must follow any CODE:,
  PPCODE:, or OUTPUT: blocks which are present in the XSUB. The code specified
  for the cleanup block will be added as the last statements in the XSUB.
<h2 class="Ss" title="Ss" id="The_POSTCALL:_Keyword"><a class="selflink" href="#The_POSTCALL:_Keyword">The
  POSTCALL: Keyword</a></h2>
This keyword can be used when an XSUB requires special procedures executed after
  the C subroutine call is performed. When the POSTCALL: keyword is used it must
  precede OUTPUT: and CLEANUP: blocks which are present in the XSUB.
<div class="Pp"></div>
See examples in &quot;The NO_OUTPUT Keyword&quot; and &quot;Returning Undef And
  Empty Lists&quot;.
<div class="Pp"></div>
The POSTCALL: block does not make a lot of sense when the C subroutine call is
  supplied by user by providing either CODE: or PPCODE: section.
<h2 class="Ss" title="Ss" id="The_BOOT:_Keyword"><a class="selflink" href="#The_BOOT:_Keyword">The
  BOOT: Keyword</a></h2>
The BOOT: keyword is used to add code to the extension's bootstrap function. The
  bootstrap function is generated by the <b>xsubpp</b> compiler and normally
  holds the statements necessary to register any XSUBs with Perl. With the BOOT:
  keyword the programmer can tell the compiler to add extra statements to the
  bootstrap function.
<div class="Pp"></div>
This keyword may be used any time after the first MODULE keyword and should
  appear on a line by itself. The first blank line after the keyword will
  terminate the code block.
<div class="Pp"></div>
<pre>
     BOOT:
     # The following message will be printed when the
     # bootstrap function executes.
     printf(&quot;Hello from the bootstrap!\n&quot;);
</pre>
<h2 class="Ss" title="Ss" id="The_VERSIONCHECK:_Keyword"><a class="selflink" href="#The_VERSIONCHECK:_Keyword">The
  VERSIONCHECK: Keyword</a></h2>
The VERSIONCHECK: keyword corresponds to <b>xsubpp</b>'s
  &quot;-versioncheck&quot; and &quot;-noversioncheck&quot; options. This
  keyword overrides the command line options. Version checking is enabled by
  default. When version checking is enabled the XS module will attempt to verify
  that its version matches the version of the PM module.
<div class="Pp"></div>
To enable version checking:
<div class="Pp"></div>
<pre>
    VERSIONCHECK: ENABLE
</pre>
<div class="Pp"></div>
To disable version checking:
<div class="Pp"></div>
<pre>
    VERSIONCHECK: DISABLE
</pre>
<div class="Pp"></div>
Note that if the version of the PM module is an NV (a floating point number), it
  will be stringified with a possible loss of precision (currently chopping to
  nine decimal places) so that it may not match the version of the XS module
  anymore. Quoting the $VERSION declaration to make it a string is recommended
  if long version numbers are used.
<h2 class="Ss" title="Ss" id="The_PROTOTYPES:_Keyword"><a class="selflink" href="#The_PROTOTYPES:_Keyword">The
  PROTOTYPES: Keyword</a></h2>
The PROTOTYPES: keyword corresponds to <b>xsubpp</b>'s &quot;-prototypes&quot;
  and &quot;-noprototypes&quot; options. This keyword overrides the command line
  options. Prototypes are enabled by default. When prototypes are enabled XSUBs
  will be given Perl prototypes. This keyword may be used multiple times in an
  XS module to enable and disable prototypes for different parts of the module.
<div class="Pp"></div>
To enable prototypes:
<div class="Pp"></div>
<pre>
    PROTOTYPES: ENABLE
</pre>
<div class="Pp"></div>
To disable prototypes:
<div class="Pp"></div>
<pre>
    PROTOTYPES: DISABLE
</pre>
<h2 class="Ss" title="Ss" id="The_PROTOTYPE:_Keyword"><a class="selflink" href="#The_PROTOTYPE:_Keyword">The
  PROTOTYPE: Keyword</a></h2>
This keyword is similar to the PROTOTYPES: keyword above but can be used to
  force <b>xsubpp</b> to use a specific prototype for the XSUB. This keyword
  overrides all other prototype options and keywords but affects only the
  current XSUB. Consult &quot;Prototypes&quot; in perlsub for information about
  Perl prototypes.
<div class="Pp"></div>
<pre>
    bool_t
    rpcb_gettime(timep, ...)
          time_t timep = NO_INIT
        PROTOTYPE: $;$
        PREINIT:
          char *host = &quot;localhost&quot;;
        CODE:
                  if( items &gt; 1 )
                       host = (char *)SvPV_nolen(ST(1));
                  RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<div class="Pp"></div>
If the prototypes are enabled, you can disable it locally for a given XSUB as in
  the following example:
<div class="Pp"></div>
<pre>
    void
    rpcb_gettime_noproto()
        PROTOTYPE: DISABLE
    ...
</pre>
<h2 class="Ss" title="Ss" id="The_ALIAS:_Keyword"><a class="selflink" href="#The_ALIAS:_Keyword">The
  ALIAS: Keyword</a></h2>
The ALIAS: keyword allows an XSUB to have two or more unique Perl names and to
  know which of those names was used when it was invoked. The Perl names may be
  fully-qualified with package names. Each alias is given an index. The compiler
  will setup a variable called &quot;ix&quot; which contain the index of the
  alias which was used. When the XSUB is called with its declared name
  &quot;ix&quot; will be 0.
<div class="Pp"></div>
The following example will create aliases &quot;FOO::gettime()&quot; and
  &quot;BAR::getit()&quot; for this function.
<div class="Pp"></div>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        ALIAS:
            FOO::gettime = 1
            BAR::getit = 2
        INIT:
          printf(&quot;# ix = %d\n&quot;, ix );
        OUTPUT:
          timep
</pre>
<h2 class="Ss" title="Ss" id="The_OVERLOAD:_Keyword"><a class="selflink" href="#The_OVERLOAD:_Keyword">The
  OVERLOAD: Keyword</a></h2>
Instead of writing an overloaded interface using pure Perl, you can also use the
  OVERLOAD keyword to define additional Perl names for your functions (like the
  ALIAS: keyword above). However, the overloaded functions must be defined with
  three parameters (except for the <i>nomethod()</i> function which needs four
  parameters). If any function has the OVERLOAD: keyword, several additional
  lines will be defined in the c file generated by xsubpp in order to register
  with the overload magic.
<div class="Pp"></div>
Since blessed objects are actually stored as RV's, it is useful to use the
  typemap features to preprocess parameters and extract the actual SV stored
  within the blessed RV. See the sample for T_PTROBJ_SPECIAL below.
<div class="Pp"></div>
To use the OVERLOAD: keyword, create an XS function which takes three input
  parameters ( or use the c style '...' definition) like this:
<div class="Pp"></div>
<pre>
    SV *
    cmp (lobj, robj, swap)
    My_Module_obj    lobj
    My_Module_obj    robj
    IV               swap
    OVERLOAD: cmp &lt;=&gt;
    { /* function defined here */}
</pre>
<div class="Pp"></div>
In this case, the function will overload both of the three way comparison
  operators. For all overload operations using non-alpha characters, you must
  type the parameter without quoting, separating multiple overloads with
  whitespace. Note that &quot;&quot; (the stringify overload) should be entered
  as \&quot;\&quot; (i.e. escaped).
<h2 class="Ss" title="Ss" id="The_FALLBACK:_Keyword"><a class="selflink" href="#The_FALLBACK:_Keyword">The
  FALLBACK: Keyword</a></h2>
In addition to the OVERLOAD keyword, if you need to control how Perl
  autogenerates missing overloaded operators, you can set the FALLBACK keyword
  in the module header section, like this:
<div class="Pp"></div>
<pre>
    MODULE = RPC  PACKAGE = RPC
    FALLBACK: TRUE
    ...
</pre>
<div class="Pp"></div>
where FALLBACK can take any of the three values TRUE, FALSE, or UNDEF. If you do
  not set any FALLBACK value when using OVERLOAD, it defaults to UNDEF. FALLBACK
  is not used except when one or more functions using OVERLOAD have been
  defined. Please see &quot;fallback&quot; in overload for more details.
<h2 class="Ss" title="Ss" id="The_INTERFACE:_Keyword"><a class="selflink" href="#The_INTERFACE:_Keyword">The
  INTERFACE: Keyword</a></h2>
This keyword declares the current XSUB as a keeper of the given calling
  signature. If some text follows this keyword, it is considered as a list of
  functions which have this signature, and should be attached to the current
  XSUB.
<div class="Pp"></div>
For example, if you have 4 C functions <i>multiply()</i>, <i>divide()</i>,
  <i>add()</i>, <i>subtract()</i> all having the signature:
<div class="Pp"></div>
<pre>
    symbolic f(symbolic, symbolic);
</pre>
<div class="Pp"></div>
you can make them all to use the same XSUB using this:
<div class="Pp"></div>
<pre>
    symbolic
    interface_s_ss(arg1, arg2)
        symbolic        arg1
        symbolic        arg2
    INTERFACE:
        multiply divide
        add subtract
</pre>
<div class="Pp"></div>
(This is the complete XSUB code for 4 Perl functions!) Four generated Perl
  function share names with corresponding C functions.
<div class="Pp"></div>
The advantage of this approach comparing to ALIAS: keyword is that there is no
  need to code a switch statement, each Perl function (which shares the same
  XSUB) knows which C function it should call. Additionally, one can attach an
  extra function <i>remainder()</i> at runtime by using
<div class="Pp"></div>
<pre>
    CV *mycv = newXSproto(&quot;Symbolic::remainder&quot;,
                          XS_Symbolic_interface_s_ss, __FILE__, &quot;$$&quot;);
    XSINTERFACE_FUNC_SET(mycv, remainder);
</pre>
<div class="Pp"></div>
say, from another XSUB. (This example supposes that there was no
  INTERFACE_MACRO: section, otherwise one needs to use something else instead of
  &quot;XSINTERFACE_FUNC_SET&quot;, see the next section.)
<h2 class="Ss" title="Ss" id="The_INTERFACE_MACRO:_Keyword"><a class="selflink" href="#The_INTERFACE_MACRO:_Keyword">The
  INTERFACE_MACRO: Keyword</a></h2>
This keyword allows one to define an INTERFACE using a different way to extract
  a function pointer from an XSUB. The text which follows this keyword should
  give the name of macros which would extract/set a function pointer. The
  extractor macro is given return type, &quot;CV*&quot;, and
  &quot;XSANY.any_dptr&quot; for this &quot;CV*&quot;. The setter macro is given
  cv, and the function pointer.
<div class="Pp"></div>
The default value is &quot;XSINTERFACE_FUNC&quot; and
  &quot;XSINTERFACE_FUNC_SET&quot;. An INTERFACE keyword with an empty list of
  functions can be omitted if INTERFACE_MACRO keyword is used.
<div class="Pp"></div>
Suppose that in the previous example functions pointers for <i>multiply()</i>,
  <i>divide()</i>, <i>add()</i>, <i>subtract()</i> are kept in a global C array
  &quot;fp[]&quot; with offsets being &quot;multiply_off&quot;,
  &quot;divide_off&quot;, &quot;add_off&quot;, &quot;subtract_off&quot;. Then
  one can use
<div class="Pp"></div>
<pre>
    #define XSINTERFACE_FUNC_BYOFFSET(ret,cv,f) \
        ((XSINTERFACE_CVT_ANON(ret))fp[CvXSUBANY(cv).any_i32])
    #define XSINTERFACE_FUNC_BYOFFSET_set(cv,f) \
        CvXSUBANY(cv).any_i32 = CAT2( f, _off )
</pre>
<div class="Pp"></div>
in C section,
<div class="Pp"></div>
<pre>
    symbolic
    interface_s_ss(arg1, arg2)
        symbolic        arg1
        symbolic        arg2
      INTERFACE_MACRO:
        XSINTERFACE_FUNC_BYOFFSET
        XSINTERFACE_FUNC_BYOFFSET_set
      INTERFACE:
        multiply divide
        add subtract
</pre>
<div class="Pp"></div>
in XSUB section.
<h2 class="Ss" title="Ss" id="The_INCLUDE:_Keyword"><a class="selflink" href="#The_INCLUDE:_Keyword">The
  INCLUDE: Keyword</a></h2>
This keyword can be used to pull other files into the XS module. The other files
  may have XS code. INCLUDE: can also be used to run a command to generate the
  XS code to be pulled into the module.
<div class="Pp"></div>
The file <i>Rpcb1.xsh</i> contains our &quot;rpcb_gettime()&quot; function:
<div class="Pp"></div>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
<div class="Pp"></div>
The XS module can use INCLUDE: to pull that file into it.
<div class="Pp"></div>
<pre>
    INCLUDE: Rpcb1.xsh
</pre>
<div class="Pp"></div>
If the parameters to the INCLUDE: keyword are followed by a pipe (&quot;|&quot;)
  then the compiler will interpret the parameters as a command. This feature is
  mildly deprecated in favour of the &quot;INCLUDE_COMMAND:&quot; directive, as
  documented below.
<div class="Pp"></div>
<pre>
    INCLUDE: cat Rpcb1.xsh |
</pre>
<div class="Pp"></div>
Do not use this to run perl: &quot;INCLUDE: perl |&quot; will run the perl that
  happens to be the first in your path and not necessarily the same perl that is
  used to run &quot;xsubpp&quot;. See &quot;The INCLUDE_COMMAND: Keyword&quot;.
<h2 class="Ss" title="Ss" id="The_INCLUDE_COMMAND:_Keyword"><a class="selflink" href="#The_INCLUDE_COMMAND:_Keyword">The
  INCLUDE_COMMAND: Keyword</a></h2>
Runs the supplied command and includes its output into the current XS document.
  &quot;INCLUDE_COMMAND&quot; assigns special meaning to the $^X token in that
  it runs the same perl interpreter that is running &quot;xsubpp&quot;:
<div class="Pp"></div>
<pre>
    INCLUDE_COMMAND: cat Rpcb1.xsh
    INCLUDE_COMMAND: $^X -e ...
</pre>
<h2 class="Ss" title="Ss" id="The_CASE:_Keyword"><a class="selflink" href="#The_CASE:_Keyword">The
  CASE: Keyword</a></h2>
The CASE: keyword allows an XSUB to have multiple distinct parts with each part
  acting as a virtual XSUB. CASE: is greedy and if it is used then all other XS
  keywords must be contained within a CASE:. This means nothing may precede the
  first CASE: in the XSUB and anything following the last CASE: is included in
  that case.
<div class="Pp"></div>
A CASE: might switch via a parameter of the XSUB, via the &quot;ix&quot; ALIAS:
  variable (see &quot;The ALIAS: Keyword&quot;), or maybe via the
  &quot;items&quot; variable (see &quot;Variable-length Parameter Lists&quot;).
  The last CASE: becomes the <b>default</b> case if it is not associated with a
  conditional. The following example shows CASE switched via &quot;ix&quot; with
  a function &quot;rpcb_gettime()&quot; having an alias &quot;x_gettime()&quot;.
  When the function is called as &quot;rpcb_gettime()&quot; its parameters are
  the usual &quot;(char *host, time_t *timep)&quot;, but when the function is
  called as &quot;x_gettime()&quot; its parameters are reversed, &quot;(time_t
  *timep, char *host)&quot;.
<div class="Pp"></div>
<pre>
    long
    rpcb_gettime(a,b)
      CASE: ix == 1
        ALIAS:
          x_gettime = 1
        INPUT:
          # 'a' is timep, 'b' is host
          char *b
          time_t a = NO_INIT
        CODE:
               RETVAL = rpcb_gettime( b, &amp;a );
        OUTPUT:
          a
          RETVAL
      CASE:
          # 'a' is host, 'b' is timep
          char *a
          time_t &amp;b = NO_INIT
        OUTPUT:
          b
          RETVAL
</pre>
<div class="Pp"></div>
That function can be called with either of the following statements. Note the
  different argument lists.
<div class="Pp"></div>
<pre>
        $status = rpcb_gettime( $host, $timep );
        $status = x_gettime( $timep, $host );
</pre>
<h2 class="Ss" title="Ss" id="The_EXPORT_XSUB_SYMBOLS:_Keyword"><a class="selflink" href="#The_EXPORT_XSUB_SYMBOLS:_Keyword">The
  EXPORT_XSUB_SYMBOLS: Keyword</a></h2>
The EXPORT_XSUB_SYMBOLS: keyword is likely something you will never need. In
  perl versions earlier than 5.16.0, this keyword does nothing. Starting with
  5.16, XSUB symbols are no longer exported by default. That is, they are
  &quot;static&quot; functions. If you include
<div class="Pp"></div>
<pre>
  EXPORT_XSUB_SYMBOLS: ENABLE
</pre>
<div class="Pp"></div>
in your XS code, the XSUBs following this line will not be declared
  &quot;static&quot;. You can later disable this with
<div class="Pp"></div>
<pre>
  EXPORT_XSUB_SYMBOLS: DISABLE
</pre>
<div class="Pp"></div>
which, again, is the default that you should probably never change. You cannot
  use this keyword on versions of perl before 5.16 to make XSUBs
  &quot;static&quot;.
<h2 class="Ss" title="Ss" id="The_&amp;_Unary_Operator"><a class="selflink" href="#The_&amp;_Unary_Operator">The
  &amp; Unary Operator</a></h2>
The &quot;&amp;&quot; unary operator in the INPUT: section is used to tell
  <b>xsubpp</b> that it should convert a Perl value to/from C using the C type
  to the left of &quot;&amp;&quot;, but provide a pointer to this value when the
  C function is called.
<div class="Pp"></div>
This is useful to avoid a CODE: block for a C function which takes a parameter
  by reference. Typically, the parameter should be not a pointer type (an
  &quot;int&quot; or &quot;long&quot; but not an &quot;int*&quot; or
  &quot;long*&quot;).
<div class="Pp"></div>
The following XSUB will generate incorrect C code. The <b>xsubpp</b> compiler
  will turn this into code which calls &quot;rpcb_gettime()&quot; with
  parameters &quot;(char *host, time_t timep)&quot;, but the real
  &quot;rpcb_gettime()&quot; wants the &quot;timep&quot; parameter to be of type
  &quot;time_t*&quot; rather than &quot;time_t&quot;.
<div class="Pp"></div>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t timep
        OUTPUT:
          timep
</pre>
<div class="Pp"></div>
That problem is corrected by using the &quot;&amp;&quot; operator. The
  <b>xsubpp</b> compiler will now turn this into code which calls
  &quot;rpcb_gettime()&quot; correctly with parameters &quot;(char *host, time_t
  *timep)&quot;. It does this by carrying the &quot;&amp;&quot; through, so the
  function call looks like &quot;rpcb_gettime(host, &amp;timep)&quot;.
<div class="Pp"></div>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
<h2 class="Ss" title="Ss" id="Inserting_POD,_Comments_and_C_Preprocessor_Directives"><a class="selflink" href="#Inserting_POD,_Comments_and_C_Preprocessor_Directives">Inserting
  POD, Comments and C Preprocessor Directives</a></h2>
C preprocessor directives are allowed within BOOT:, PREINIT: INIT:, CODE:,
  PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside the functions.
  Comments are allowed anywhere after the MODULE keyword. The compiler will pass
  the preprocessor directives through untouched and will remove the commented
  lines. POD documentation is allowed at any point, both in the C and XS
  language sections. POD must be terminated with a &quot;=cut&quot; command;
  &quot;xsubpp&quot; will exit with an error if it does not. It is very unlikely
  that human generated C code will be mistaken for POD, as most indenting styles
  result in whitespace in front of any line starting with &quot;=&quot;. Machine
  generated XS files may fall into this trap unless care is taken to ensure that
  a space breaks the sequence &quot;\n=&quot;.
<div class="Pp"></div>
Comments can be added to XSUBs by placing a &quot;#&quot; as the first
  non-whitespace of a line. Care should be taken to avoid making the comment
  look like a C preprocessor directive, lest it be interpreted as such. The
  simplest way to prevent this is to put whitespace in front of the
  &quot;#&quot;.
<div class="Pp"></div>
If you use preprocessor directives to choose one of two versions of a function,
  use
<div class="Pp"></div>
<pre>
    #if ... version1
    #else /* ... version2  */
    #endif
</pre>
<div class="Pp"></div>
and not
<div class="Pp"></div>
<pre>
    #if ... version1
    #endif
    #if ... version2
    #endif
</pre>
<div class="Pp"></div>
because otherwise <b>xsubpp</b> will believe that you made a duplicate
  definition of the function. Also, put a blank line before the #else/#endif so
  it will not be seen as part of the function body.
<h2 class="Ss" title="Ss" id="Using_XS_With_C++"><a class="selflink" href="#Using_XS_With_C++">Using
  XS With C++</a></h2>
If an XSUB name contains &quot;::&quot;, it is considered to be a C++ method.
  The generated Perl function will assume that its first argument is an object
  pointer. The object pointer will be stored in a variable called THIS. The
  object should have been created by C++ with the <i>new()</i> function and
  should be blessed by Perl with the <i>sv_setref_pv()</i> macro. The blessing
  of the object by Perl can be handled by a typemap. An example typemap is shown
  at the end of this section.
<div class="Pp"></div>
If the return type of the XSUB includes &quot;static&quot;, the method is
  considered to be a static method. It will call the C++ function using the
  <i>class::method()</i> syntax. If the method is not static the function will
  be called using the THIS-&gt; <i>method()</i> syntax.
<div class="Pp"></div>
The next examples will use the following C++ class.
<div class="Pp"></div>
<pre>
     class color {
          public:
          color();
          ~color();
          int blue();
          void set_blue( int );
          private:
          int c_blue;
     };
</pre>
<div class="Pp"></div>
The XSUBs for the <i>blue()</i> and <i>set_blue()</i> methods are defined with
  the class name but the parameter for the object (THIS, or &quot;self&quot;) is
  implicit and is not listed.
<div class="Pp"></div>
<pre>
     int
     color::blue()
     void
     color::set_blue( val )
          int val
</pre>
<div class="Pp"></div>
Both Perl functions will expect an object as the first parameter. In the
  generated C++ code the object is called &quot;THIS&quot;, and the method call
  will be performed on this object. So in the C++ code the <i>blue()</i> and
  <i>set_blue()</i> methods will be called as this:
<div class="Pp"></div>
<pre>
     RETVAL = THIS-&gt;blue();
     THIS-&gt;set_blue( val );
</pre>
<div class="Pp"></div>
You could also write a single get/set method using an optional argument:
<div class="Pp"></div>
<pre>
     int
     color::blue( val = NO_INIT )
         int val
         PROTOTYPE $;$
         CODE:
             if (items &gt; 1)
                 THIS-&gt;set_blue( val );
             RETVAL = THIS-&gt;blue();
         OUTPUT:
             RETVAL
</pre>
<div class="Pp"></div>
If the function's name is <b>DESTROY</b> then the C++ &quot;delete&quot;
  function will be called and &quot;THIS&quot; will be given as its parameter.
  The generated C++ code for
<div class="Pp"></div>
<pre>
     void
     color::DESTROY()
</pre>
<div class="Pp"></div>
will look like this:
<div class="Pp"></div>
<pre>
     color *THIS = ...; // Initialized as in typemap
     delete THIS;
</pre>
<div class="Pp"></div>
If the function's name is <b>new</b> then the C++ &quot;new&quot; function will
  be called to create a dynamic C++ object. The XSUB will expect the class name,
  which will be kept in a variable called &quot;CLASS&quot;, to be given as the
  first argument.
<div class="Pp"></div>
<pre>
     color *
     color::new()
</pre>
<div class="Pp"></div>
The generated C++ code will call &quot;new&quot;.
<div class="Pp"></div>
<pre>
     RETVAL = new color();
</pre>
<div class="Pp"></div>
The following is an example of a typemap that could be used for this C++
  example.
<div class="Pp"></div>
<pre>
    TYPEMAP
    color *             O_OBJECT
    OUTPUT
    # The Perl object is blessed into 'CLASS', which should be a
    # char* having the name of the package for the blessing.
    O_OBJECT
        sv_setref_pv( $arg, CLASS, (void*)$var );
    INPUT
    O_OBJECT
        if( sv_isobject($arg) &amp;&amp; (SvTYPE(SvRV($arg)) == SVt_PVMG) )
                $var = ($type)SvIV((SV*)SvRV( $arg ));
        else{
                warn( \&quot;${Package}::$func_name() -- $var is not a blessed SV reference\&quot; );
                XSRETURN_UNDEF;
        }
</pre>
<h2 class="Ss" title="Ss" id="Interface_Strategy"><a class="selflink" href="#Interface_Strategy">Interface
  Strategy</a></h2>
When designing an interface between Perl and a C library a straight translation
  from C to XS (such as created by &quot;h2xs -x&quot;) is often sufficient.
  However, sometimes the interface will look very C-like and occasionally
  nonintuitive, especially when the C function modifies one of its parameters,
  or returns failure inband (as in &quot;negative return values mean
  failure&quot;). In cases where the programmer wishes to create a more
  Perl-like interface the following strategy may help to identify the more
  critical parts of the interface.
<div class="Pp"></div>
Identify the C functions with input/output or output parameters. The XSUBs for
  these functions may be able to return lists to Perl.
<div class="Pp"></div>
Identify the C functions which use some inband info as an indication of failure.
  They may be candidates to return undef or an empty list in case of failure. If
  the failure may be detected without a call to the C function, you may want to
  use an INIT: section to report the failure. For failures detectable after the
  C function returns one may want to use a POSTCALL: section to process the
  failure. In more complicated cases use CODE: or PPCODE: sections.
<div class="Pp"></div>
If many functions use the same failure indication based on the return value, you
  may want to create a special typedef to handle this situation. Put
<div class="Pp"></div>
<pre>
  typedef int negative_is_failure;
</pre>
<div class="Pp"></div>
near the beginning of XS file, and create an OUTPUT typemap entry for
  &quot;negative_is_failure&quot; which converts negative values to
  &quot;undef&quot;, or maybe <i>croak()</i>s. After this the return value of
  type &quot;negative_is_failure&quot; will create more Perl-like interface.
<div class="Pp"></div>
Identify which values are used by only the C and XSUB functions themselves, say,
  when a parameter to a function should be a contents of a global variable. If
  Perl does not need to access the contents of the value then it may not be
  necessary to provide a translation for that value from C to Perl.
<div class="Pp"></div>
Identify the pointers in the C function parameter lists and return values. Some
  pointers may be used to implement input/output or output parameters, they can
  be handled in XS with the &quot;&amp;&quot; unary operator, and, possibly,
  using the NO_INIT keyword. Some others will require handling of types like
  &quot;int *&quot;, and one needs to decide what a useful Perl translation will
  do in such a case. When the semantic is clear, it is advisable to put the
  translation into a typemap file.
<div class="Pp"></div>
Identify the structures used by the C functions. In many cases it may be helpful
  to use the T_PTROBJ typemap for these structures so they can be manipulated by
  Perl as blessed objects. (This is handled automatically by &quot;h2xs
  -x&quot;.)
<div class="Pp"></div>
If the same C type is used in several different contexts which require different
  translations, &quot;typedef&quot; several new types mapped to this C type, and
  create separate <i>typemap</i> entries for these new types. Use these types in
  declarations of return type and parameters to XSUBs.
<h2 class="Ss" title="Ss" id="Perl_Objects_And_C_Structures"><a class="selflink" href="#Perl_Objects_And_C_Structures">Perl
  Objects And C Structures</a></h2>
When dealing with C structures one should select either <b>T_PTROBJ</b> or
  <b>T_PTRREF</b> for the XS type. Both types are designed to handle pointers to
  complex objects. The T_PTRREF type will allow the Perl object to be unblessed
  while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ
  one can achieve a form of type-checking because the XSUB will attempt to
  verify that the Perl object is of the expected type.
<div class="Pp"></div>
The following XS code shows the <i>getnetconfigent()</i> function which is used
  with ONC+ TIRPC. The <i>getnetconfigent()</i> function will return a pointer
  to a C structure and has the C prototype shown below. The example will
  demonstrate how the C pointer will become a Perl reference. Perl will consider
  this reference to be a pointer to a blessed object and will attempt to call a
  destructor for the object. A destructor will be provided in the XS source to
  free the memory used by <i>getnetconfigent()</i>. Destructors in XS can be
  created by specifying an XSUB function whose name ends with the word
  <b>DESTROY</b>. XS destructors can be used to free memory which may have been
  malloc'd by another XSUB.
<div class="Pp"></div>
<pre>
     struct netconfig *getnetconfigent(const char *netid);
</pre>
<div class="Pp"></div>
A &quot;typedef&quot; will be created for &quot;struct netconfig&quot;. The Perl
  object will be blessed in a class matching the name of the C type, with the
  tag &quot;Ptr&quot; appended, and the name should not have embedded spaces if
  it will be a Perl package name. The destructor will be placed in a class
  corresponding to the class of the object and the PREFIX keyword will be used
  to trim the name to the word DESTROY as Perl will expect.
<div class="Pp"></div>
<pre>
     typedef struct netconfig Netconfig;
     MODULE = RPC  PACKAGE = RPC
     Netconfig *
     getnetconfigent(netid)
          char *netid
     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_
     void
     rpcb_DESTROY(netconf)
          Netconfig *netconf
        CODE:
          printf(&quot;Now in NetconfigPtr::DESTROY\n&quot;);
          free( netconf );
</pre>
<div class="Pp"></div>
This example requires the following typemap entry. Consult perlxstypemap for
  more information about adding new typemaps for an extension.
<div class="Pp"></div>
<pre>
     TYPEMAP
     Netconfig *  T_PTROBJ
</pre>
<div class="Pp"></div>
This example will be used with the following Perl statements.
<div class="Pp"></div>
<pre>
     use RPC;
     $netconf = getnetconfigent(&quot;udp&quot;);
</pre>
<div class="Pp"></div>
When Perl destroys the object referenced by $netconf it will send the object to
  the supplied XSUB DESTROY function. Perl cannot determine, and does not care,
  that this object is a C struct and not a Perl object. In this sense, there is
  no difference between the object created by the <i>getnetconfigent()</i> XSUB
  and an object created by a normal Perl subroutine.
<h2 class="Ss" title="Ss" id="Safely_Storing_Static_Data_in_XS"><a class="selflink" href="#Safely_Storing_Static_Data_in_XS">Safely
  Storing Static Data in XS</a></h2>
Starting with Perl 5.8, a macro framework has been defined to allow static data
  to be safely stored in XS modules that will be accessed from a multi-threaded
  Perl.
<div class="Pp"></div>
Although primarily designed for use with multi-threaded Perl, the macros have
  been designed so that they will work with non-threaded Perl as well.
<div class="Pp"></div>
It is therefore strongly recommended that these macros be used by all XS modules
  that make use of static data.
<div class="Pp"></div>
The easiest way to get a template set of macros to use is by specifying the
  &quot;-g&quot; (&quot;--global&quot;) option with h2xs (see h2xs).
<div class="Pp"></div>
Below is an example module that makes use of the macros.
<div class="Pp"></div>
<pre>
    #include &quot;EXTERN.h&quot;
    #include &quot;perl.h&quot;
    #include &quot;XSUB.h&quot;
    /* Global Data */
    #define MY_CXT_KEY &quot;BlindMice::_guts&quot; XS_VERSION
    typedef struct {
        int count;
        char name[3][100];
    } my_cxt_t;
    START_MY_CXT
    MODULE = BlindMice           PACKAGE = BlindMice
    BOOT:
    {
        MY_CXT_INIT;
        MY_CXT.count = 0;
        strcpy(MY_CXT.name[0], &quot;None&quot;);
        strcpy(MY_CXT.name[1], &quot;None&quot;);
        strcpy(MY_CXT.name[2], &quot;None&quot;);
    }
    int
    newMouse(char * name)
        char * name;
        PREINIT:
          dMY_CXT;
        CODE:
          if (MY_CXT.count &gt;= 3) {
              warn(&quot;Already have 3 blind mice&quot;);
              RETVAL = 0;
          }
          else {
              RETVAL = ++ MY_CXT.count;
              strcpy(MY_CXT.name[MY_CXT.count - 1], name);
          }
    char *
    get_mouse_name(index)
      int index
      CODE:
        dMY_CXT;
        RETVAL = MY_CXT.lives ++;
        if (index &gt; MY_CXT.count)
          croak(&quot;There are only 3 blind mice.&quot;);
        else
          RETVAL = newSVpv(MY_CXT.name[index - 1]);
    void
    CLONE(...)
        CODE:
        MY_CXT_CLONE;
</pre>
<div class="Pp"></div>
<b>REFERENCE</b>
<dl class="Bl-tag">
  <dt class="It-tag">MY_CXT_KEY</dt>
  <dd class="It-tag">This macro is used to define a unique key to refer to the
      static data for an XS module. The suggested naming scheme, as used by
      h2xs, is to use a string that consists of the module name, the string
      &quot;::_guts&quot; and the module version number.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    #define MY_CXT_KEY &quot;MyModule::_guts&quot; XS_VERSION
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">typedef my_cxt_t</dt>
  <dd class="It-tag">This struct typedef <i>must</i> always be called
      &quot;my_cxt_t&quot;. The other &quot;CXT*&quot; macros assume the
      existence of the &quot;my_cxt_t&quot; typedef name.
    <div style="height: 1.00em;">&#x00A0;</div>
    Declare a typedef named &quot;my_cxt_t&quot; that is a structure that
      contains all the data that needs to be interpreter-local.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    typedef struct {
        int some_value;
    } my_cxt_t;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">START_MY_CXT</dt>
  <dd class="It-tag">Always place the START_MY_CXT macro directly after the
      declaration of &quot;my_cxt_t&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MY_CXT_INIT</dt>
  <dd class="It-tag">The MY_CXT_INIT macro initialises storage for the
      &quot;my_cxt_t&quot; struct.
    <div style="height: 1.00em;">&#x00A0;</div>
    It <i>must</i> be called exactly once, typically in a BOOT: section. If you
      are maintaining multiple interpreters, it should be called once in each
      interpreter instance, except for interpreters cloned from existing ones.
      (But see &quot;MY_CXT_CLONE&quot; below.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dMY_CXT</dt>
  <dd class="It-tag">Use the dMY_CXT macro (a declaration) in all the functions
      that access MY_CXT.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MY_CXT</dt>
  <dd class="It-tag">Use the MY_CXT macro to access members of the
      &quot;my_cxt_t&quot; struct. For example, if &quot;my_cxt_t&quot; is
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    typedef struct {
        int index;
    } my_cxt_t;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    then use this to access the &quot;index&quot; member
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    dMY_CXT;
    MY_CXT.index = 2;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">aMY_CXT/pMY_CXT</dt>
  <dd class="It-tag">&quot;dMY_CXT&quot; may be quite expensive to calculate,
      and to avoid the overhead of invoking it in each function it is possible
      to pass the declaration onto other functions using the
      &quot;aMY_CXT&quot;/&quot;pMY_CXT&quot; macros, eg
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    void sub1() {
        dMY_CXT;
        MY_CXT.index = 1;
        sub2(aMY_CXT);
    }
    void sub2(pMY_CXT) {
        MY_CXT.index = 2;
    }
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Analogously to &quot;pTHX&quot;, there are equivalent forms for when the
      macro is the first or last in multiple arguments, where an underscore
      represents a comma, i.e. &quot;_aMY_CXT&quot;, &quot;aMY_CXT_&quot;,
      &quot;_pMY_CXT&quot; and &quot;pMY_CXT_&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MY_CXT_CLONE</dt>
  <dd class="It-tag">By default, when a new interpreter is created as a copy of
      an existing one (eg via &quot;threads-&gt;create()&quot;), both
      interpreters share the same physical my_cxt_t structure. Calling
      &quot;MY_CXT_CLONE&quot; (typically via the package's &quot;CLONE()&quot;
      function), causes a byte-for-byte copy of the structure to be taken, and
      any future dMY_CXT will cause the copy to be accessed instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">MY_CXT_INIT_INTERP(my_perl)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dMY_CXT_INTERP(my_perl)</dt>
  <dd class="It-tag">These are versions of the macros which take an explicit
      interpreter as an argument.</dd>
</dl>
<div class="Pp"></div>
Note that these macros will only work together within the <i>same</i> source
  file; that is, a dMY_CTX in one source file will access a different structure
  than a dMY_CTX in another source file.
<h2 class="Ss" title="Ss" id="Thread-aware_system_interfaces"><a class="selflink" href="#Thread-aware_system_interfaces">Thread-aware
  system interfaces</a></h2>
Starting from Perl 5.8, in C/C++ level Perl knows how to wrap system/library
  interfaces that have thread-aware versions (e.g. <i>getpwent_r()</i>) into
  frontend macros (e.g. <i>getpwent()</i>) that correctly handle the
  multithreaded interaction with the Perl interpreter. This will happen
  transparently, the only thing you need to do is to instantiate a Perl
  interpreter.
<div class="Pp"></div>
This wrapping happens always when compiling Perl core source (PERL_CORE is
  defined) or the Perl core extensions (PERL_EXT is defined). When compiling XS
  code outside of Perl core the wrapping does not take place. Note, however,
  that intermixing the _r-forms (as Perl compiled for multithreaded operation
  will do) and the _r-less forms is neither well-defined (inconsistent results,
  data corruption, or even crashes become more likely), nor is it very portable.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
File &quot;RPC.xs&quot;: Interface to some ONC+ RPC bind library functions.
<div class="Pp"></div>
<pre>
     #include &quot;EXTERN.h&quot;
     #include &quot;perl.h&quot;
     #include &quot;XSUB.h&quot;
     #include &lt;rpc/rpc.h&gt;
     typedef struct netconfig Netconfig;
     MODULE = RPC  PACKAGE = RPC
     SV *
     rpcb_gettime(host=&quot;localhost&quot;)
          char *host
        PREINIT:
          time_t  timep;
        CODE:
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &amp;timep ) )
               sv_setnv( ST(0), (double)timep );
     Netconfig *
     getnetconfigent(netid=&quot;udp&quot;)
          char *netid
     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_
     void
     rpcb_DESTROY(netconf)
          Netconfig *netconf
        CODE:
          printf(&quot;NetconfigPtr::DESTROY\n&quot;);
          free( netconf );
</pre>
<div class="Pp"></div>
File &quot;typemap&quot;: Custom typemap for RPC.xs. (cf. perlxstypemap)
<div class="Pp"></div>
<pre>
     TYPEMAP
     Netconfig *  T_PTROBJ
</pre>
<div class="Pp"></div>
File &quot;RPC.pm&quot;: Perl module for the RPC extension.
<div class="Pp"></div>
<pre>
     package RPC;
     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw(rpcb_gettime getnetconfigent);
     bootstrap RPC;
     1;
</pre>
<div class="Pp"></div>
File &quot;rpctest.pl&quot;: Perl test program for the RPC extension.
<div class="Pp"></div>
<pre>
     use RPC;
     $netconf = getnetconfigent();
     $a = rpcb_gettime();
     print &quot;time = $a\n&quot;;
     print &quot;netconf = $netconf\n&quot;;
     $netconf = getnetconfigent(&quot;tcp&quot;);
     $a = rpcb_gettime(&quot;poplar&quot;);
     print &quot;time = $a\n&quot;;
     print &quot;netconf = $netconf\n&quot;;
</pre>
<h1 class="Sh" title="Sh" id="XS_VERSION"><a class="selflink" href="#XS_VERSION">XS
  VERSION</a></h1>
This document covers features supported by &quot;ExtUtils::ParseXS&quot; (also
  known as &quot;xsubpp&quot;) 3.13_01.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Originally written by Dean Roehrich &lt; <i>roehrich@cray.com</i>&gt;.
<div class="Pp"></div>
Maintained since 1996 by The Perl Porters &lt;
  <i>perlbug@perl.org</i>&gt;.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
