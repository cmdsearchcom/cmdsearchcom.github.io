<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:26:00 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>Mono(Mono 4.7.0) Mono(Mono 4.7.0)</p>

<p style="margin-top: 1em">NAME <br>
mono - Mono&rsquo;s ECMA-CLI native code generator
(Just-in-Time and Ahead-of-Time)</p>

<p style="margin-top: 1em">SYNOPSIS <br>
mono [options] file [arguments...]</p>

<p style="margin-top: 1em">mono-sgen [options] file
[arguments...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
mono is a runtime implementation of the ECMA Common Language
Infrastructure. This can be used to run ECMA and .NET
applications.</p>

<p style="margin-top: 1em">The runtime contains a native
code generator that transforms the Common Intermediate
Language into native code.</p>

<p style="margin-top: 1em">The code generator can operate
in two modes: just in time compilation (JIT) or ahead of
time compilation (AOT). Since code can be dynamically
loaded, the runtime environment and <br>
the JIT are always present, even if code is compiled ahead
of time.</p>

<p style="margin-top: 1em">The runtime loads the specified
file and optionally passes the arguments to it. The file is
an ECMA assembly. They typically have a .exe or .dll
extension.</p>

<p style="margin-top: 1em">The runtime provides a number of
configuration options for running applications, for
developing and debugging, and for testing and debugging the
runtime itself.</p>

<p style="margin-top: 1em">The mono command uses the Boehm
conservative garbage collector while the mono-sgen command
uses a moving and generational garbage collector.</p>

<p style="margin-top: 1em">PORTABILITY <br>
On Unix-based systems, Mono provides a mechanism to emulate
the Windows-style file access, this includes providing a
case insensitive view of the file system, directory
separator <br>
mapping (from &nbsp;to /) and stripping the drive
letters.</p>

<p style="margin-top: 1em">This functionality is enabled by
setting the MONO_IOMAP environment variable to one of all,
drive and case.</p>

<p style="margin-top: 1em">See the description for
MONO_IOMAP in the environment variables section for more
details.</p>

<p style="margin-top: 1em">RUNTIME OPTIONS <br>
The following options are available:</p>

<p style="margin-top: 1em">--aot, --aot[=options] <br>
This option is used to precompile the CIL code in the
specified assembly to native code. The generated code is
stored in a file with the extension .so. This file will be
<br>
automatically picked up by the runtime when the assembly is
executed. Ahead-of-Time compilation is most useful if you
use it in combination with the -O=all,-shared flag <br>
which enables all of the optimizations in the code generator
to be performed. Some of those optimizations are not
practical for Just-in-Time compilation since they might <br>
be very time consuming. Unlike the .NET Framework,
Ahead-of-Time compilation will not generate domain
independent code: it generates the same code that the
Just-in-Time <br>
compiler would produce. Since most applications use a single
domain, this is fine. If you want to optimize the generated
code for use in multi-domain applications, <br>
consider using the -O=shared flag. This pre-compiles the
methods, but the original assembly is still required to
execute as this one contains the metadata and exception <br>
information which is not available on the generated file.
When precompiling code, you might want to compile with all
optimizations (-O=all). Pre-compiled code is posi&acirc;
<br>
tion independent code. Pre compilation is just a mechanism
to reduce startup time, increase code sharing across
multiple mono processes and avoid just-in-time compilation
<br>
program startup costs. The original assembly must still be
present, as the metadata is contained there. AOT code
typically can not be moved from one computer to another <br>
(CPU-specific optimizations that are detected at runtime) so
you should not try to move the pre-generated assemblies or
package the pre-generated assemblies for deploy&acirc; <br>
ment. A few options are available as a parameter to the
--aot command line option. The options are separated by
commas, and more than one can be specified:</p>

<p style="margin-top: 1em">autoreg <br>
The AOT compiler will emit a (ELF only) library initializer
to automatically register the aot compiled module with the
runtime. This is only useful in static mode</p>

<p style="margin-top: 1em">asmonly <br>
Instructs the AOT compiler to output assembly code instead
of an object file.</p>

<p style="margin-top: 1em">bind-to-runtime-version <br>
If specified, forces the generated AOT files to be bound to
the runtime version of the compiling Mono. This will prevent
the AOT files from being consumed by a <br>
different Mono runtime. full This is currently an
experimental feature as it is not complete. This instructs
Mono to precompile code that has historically not <br>
been precompiled with AOT.</p>

<p style="margin-top: 1em">data-outfile=FILE.dll.aotdata
<br>
This instructs the AOT code generator to output certain data
constructs into a separate file. This can reduce the
executable images some five to twenty percent. <br>
Developers need to then ship the resulting aotdata as a
resource and register a hook to load the data on demand by
using the mono_install_load_aot_data_hook method.</p>

<p style="margin-top: 1em">direct-pinvoke <br>
When this option is specified, P/Invoke methods are invoked
directly instead of going through the operating system
symbol lookup operation.</p>

<p style="margin-top: 1em">llvm-path=&lt;PREFIX&gt; <br>
Same for the llvm tools &rsquo;opt&rsquo; and
&rsquo;llc&rsquo;.</p>

<p style="margin-top: 1em">msym-dir=&lt;PATH&gt; <br>
Instructs the AOT compiler to generate offline sequence
points .msym files. The generated .msym files will be stored
into a subfolder of &lt;PATH&gt; named as the compi&acirc;
<br>
lation AOTID.</p>

<p style="margin-top: 1em">mtriple=&lt;TRIPLE&gt; <br>
Use the GNU style target triple &lt;TRIPLE&gt; to determine
some code generation options, i.e.
--mtriple=armv7-linux-gnueabi will generate code that
targets ARMv7. This <br>
is currently only supported by the ARM backend. In LLVM
mode, this triple is passed on to the LLVM llc compiler.</p>

<p style="margin-top: 1em">nimt-trampolines=[number] <br>
When compiling in full aot mode, the IMT trampolines must be
precreated in the AOT image. You can add additional method
trampolines with this argument. Defaults <br>
to 128.</p>

<p style="margin-top: 1em">nodebug <br>
Instructs the AOT compiler to not output any debugging
information.</p>

<p style="margin-top: 1em">no-direct-calls <br>
This prevents the AOT compiler from generating a direct
calls to a method. The AOT compiler usually generates direct
calls for certain methods that do not require <br>
going through the PLT (for example, methods that are known
to not require a hook like a static constructor) or call
into simple internal calls.</p>

<p style="margin-top: 1em">dwarfdebug <br>
Instructs the AOT compiler to emit DWARF debugging
information. When used together with the nodebug option,
only DWARF debugging information is emitted, but not the
<br>
information that can be used at runtime.</p>

<p style="margin-top: 1em">nrgctx-trampolines=[number] <br>
When compiling in full aot mode, the generic sharing
trampolines must be precreated in the AOT image. You can add
additional method trampolines with this argument. <br>
Defaults to 1024.</p>

<p style="margin-top: 1em">ntrampolines=[number] <br>
When compiling in full aot mode, the method trampolines must
be precreated in the AOT image. You can add additional
method trampolines with this argument. <br>
Defaults to 1024.</p>

<p style="margin-top: 1em">outfile=[filename] <br>
Instructs the AOT compiler to save the output to the
specified file.</p>

<p style="margin-top: 1em">print-skipped-methods <br>
If the AOT compiler cannot compile a method for any reason,
enabling this flag will output the skipped methods to the
console.</p>


<p style="margin-top: 1em">readonly-value=namespace.typename.fieldname=type/value
<br>
Override the value of a static readonly field. Usually,
during JIT compilation, the static constructor is ran
eagerly, so the value of a static readonly field is <br>
known at compilation time and the compiler can do a number
of optimizations based on it. During AOT, instead, the
static constructor can&rsquo;t be ran, so this option <br>
can be used to set the value of such a field and enable the
same set of optimizations. Type can be any of i1, i2, i4 for
integers of the respective sizes (in <br>
bytes). Note that signed/unsigned numbers do not matter
here, just the storage size. This option can be specified
multiple times and it doesn&rsquo;t prevent the static <br>
constructor for the type defining the field to execute with
the usual rules at runtime (hence possibly computing a
different value for the field).</p>

<p style="margin-top: 1em">save-temps,keep-temps <br>
Instructs the AOT compiler to keep temporary files.</p>

<p style="margin-top: 1em">soft-debug <br>
This instructs the compiler to generate sequence point
checks that allow Mono&rsquo;s soft debugger to debug
applications even on systems where it is not possible to set
<br>
breakpoints or to single step (certain hardware
configurations like the cell phones and video gaming
consoles).</p>

<p style="margin-top: 1em">static Create an ELF object file
(.o) or .s file which can be statically linked into an
executable when embedding the mono runtime. When this option
is used, the object <br>
file needs to be registered with the embedded runtime using
the mono_aot_register_module function which takes as its
argument the mono_aot_module_&lt;ASSEMBLY <br>
NAME&gt;_info global symbol from the object file:</p>

<p style="margin-top: 1em">extern void
*mono_aot_module_hello_info;</p>

<p style="margin-top: 1em">mono_aot_register_module
(mono_aot_module_hello_info);</p>

<p style="margin-top: 1em">stats Print various stats
collected during AOT compilation.</p>

<p style="margin-top: 1em">threads=[number] <br>
This is an experimental option for the AOT compiler to use
multiple threads when compiling the methods.</p>

<p style="margin-top: 1em">tool-prefix=&lt;PREFIX&gt; <br>
Prepends &lt;PREFIX&gt; to the name of tools ran by the AOT
compiler, i.e. &rsquo;as&rsquo;/&rsquo;ld&rsquo;. For
example, --tool=prefix=arm-linux-gnueabi- will make the AOT
compiler run</p>

<p style="margin-top: 1em">write-symbols <br>
Instructs the AOT compiler to emit debug symbol
information.</p>

<p style="margin-top: 1em">For more information about AOT,
see: http://www.mono-project.com/docs/advanced/aot/</p>

<p style="margin-top: 1em">--attach=[options] <br>
Currently the only option supported by this command line
argument is disable which disables the attach
functionality.</p>

<p style="margin-top: 1em">--config filename <br>
Load the specified configuration file instead of the default
one(s). The default files are /etc/mono/config and
~/.mono/config or the file specified in the MONO_CONFIG <br>
environment variable, if set. See the mono-config(5) man
page for details on the format of this file.</p>

<p style="margin-top: 1em">--debugger-agent=[options] <br>
This instructs the Mono runtime to start a debugging agent
inside the Mono runtime and connect it to a client user
interface will control the Mono process. This option is <br>
typically used by IDEs, like the MonoDevelop IDE.</p>

<p style="margin-top: 1em">The configuration is specified
using one of more of the following options:</p>

<p style="margin-top: 1em">address=host:port <br>
Use this option to specify the IP address where your
debugger client is listening to.</p>

<p style="margin-top: 1em">loglevel=LEVEL <br>
Specifies the diagnostics log level for</p>

<p style="margin-top: 1em">logfile=filename <br>
Used to specify the file where the log will be stored, it
defaults to standard output.</p>

<p style="margin-top: 1em">server=[y/n] <br>
Defaults to no, with the default option Mono will actively
connect to the host/port configured with the address option.
If you set it to &rsquo;y&rsquo;, it instructs the Mono <br>
runtime to start debugging in server mode, where Mono
actively waits for the debugger front end to connect to the
Mono process. Mono will print out to stdout the <br>
IP address and port where it is listening.</p>

<p style="margin-top: 1em">setpgid=[y/n] <br>
If set to yes, Mono will call setpgid(0, 0) on startup, if
that function is available on the system. This is useful for
ensuring that signals delivered to a process <br>
that is executing the debuggee are not propagated to the
debuggee, e.g. when Ctrl-C sends SIGINT to the sdb tool.</p>

<p style="margin-top: 1em">suspend=[y/n] <br>
Defaults to yes, with the default option Mono will suspend
the vm on startup until it connects successfully to a
debugger front end. If you set it to &rsquo;n&rsquo;, in
con&acirc; <br>
junction with server=y, it instructs the Mono runtime to run
as normal, while caching metadata to send to the debugger
front end on connection..</p>

<p style="margin-top: 1em">transport=transport_name <br>
This is used to specify the transport that the debugger will
use to communicate. It must be specified and currently
requires this to be &rsquo;dt_socket&rsquo;.</p>

<p style="margin-top: 1em">--desktop <br>
Configures the virtual machine to be better suited for
desktop applications. Currently this sets the GC system to
avoid expanding the heap as much as possible at the <br>
expense of slowing down garbage collection a bit.</p>

<p style="margin-top: 1em">--full-aot <br>
This is an experimental flag that instructs the Mono runtime
to not generate any code at runtime and depend exclusively
on the code generated from using mono --aot=full <br>
previously. This is useful for platforms that do not permit
dynamic code generation. Notice that this feature will abort
execution at runtime if a codepath in your pro&acirc; <br>
gram, or Mono&rsquo;s class libraries attempts to generate
code dynamically. You should test your software upfront and
make sure that you do not use any dynamic features.</p>

<p style="margin-top: 1em">--gc=boehm, --gc=sgen <br>
Selects the Garbage Collector engine for Mono to use, Boehm
or SGen. Currently this merely ensures that you are running
either the mono or mono-sgen commands. This <br>
flag can be set in the MONO_ENV_OPTIONS environment variable
to force all of your child processes to use one particular
kind of GC with the Mono runtime.</p>

<p style="margin-top: 1em">--arch=32, --arch=64 <br>
(Mac OS X only): Selects the bitness of the Mono binary
used, if available. If the binary used is already for the
selected bitness, nothing changes. If not, the execution
<br>
switches to a binary with the selected bitness suffix
installed side by side (for example, &rsquo;/bin/mono
--arch=64&rsquo; will switch to &rsquo;/bin/mono64&rsquo;
iff &rsquo;/bin/mono&rsquo; is a 32-bit <br>
build).</p>

<p style="margin-top: 1em">--help, -h <br>
Displays usage instructions.</p>

<p style="margin-top: 1em">--llvm If the Mono runtime has
been compiled with LLVM support (not available in all
configurations), Mono will use the LLVM optimization and
code generation engine to JIT or AOT <br>
compile. For more information, consult:
http://www.mono-project.com/docs/advanced/mono-llvm/</p>

<p style="margin-top: 1em">--nollvm <br>
When using a Mono that has been compiled with LLVM support,
it forces Mono to fallback to its JIT engine and not use the
LLVM backend.</p>

<p style="margin-top: 1em">--optimize=MODE, -O=MODE <br>
MODE is a comma separated list of optimizations. They also
allow optimizations to be turned off by prefixing the
optimization name with a minus sign. In general, Mono <br>
has been tuned to use the default set of flags, before using
these flags for a deployment setting, you might want to
actually measure the benefits of using them. The fol&acirc;
<br>
lowing optimization flags are implemented in the core
engine: <br>
abcrem Array bound checks removal <br>
all Turn on all optimizations <br>
aot Usage of Ahead Of Time compiled code <br>
branch Branch optimizations <br>
cfold Constant folding <br>
cmov Conditional moves [arch-dependency] <br>
deadce Dead code elimination <br>
consprop Constant propagation <br>
copyprop Copy propagation <br>
fcmov Fast x86 FP compares [arch-dependency] <br>
float32 Perform 32-bit float arithmetic using 32-bit
operations <br>
gshared Enable generic code sharing. <br>
inline Inline method calls <br>
intrins Intrinsic method implementations <br>
linears Linear scan global reg allocation <br>
leaf Leaf procedures optimizations <br>
loop Loop related optimizations <br>
peephole Peephole postpass <br>
precomp Precompile all methods before executing Main <br>
sched Instruction scheduling <br>
shared Emit per-domain code <br>
sse2 SSE2 instructions on x86 [arch-dependency] <br>
tailc Tail recursion and tail calls <br>
For example, to enable all the optimization but dead code
elimination and inlining, you can use: <br>
-O=all,-deadce,-inline <br>
The flags that are flagged with [arch-dependency] indicate
that the given option if used in combination with Ahead of
Time compilation (--aot flag) would produce pre-com&acirc;
<br>
piled code that will depend on the current CPU and might not
be safely moved to another computer.</p>

<p style="margin-top: 1em">The following optimizations are
supported</p>

<p style="margin-top: 1em">float32 <br>
Requests that the runtime performn 32-bit floating point
operations using only 32-bits. By default the Mono runtime
tries to use the highest precision available <br>
for floating point operations, but while this might render
better results, the code might run slower. This options also
affects the code generated by the LLVM <br>
backend.</p>

<p style="margin-top: 1em">inline Controls whether the
runtime should attempt to inline (the default), or not
inline methods invocations</p>

<p style="margin-top: 1em">--runtime=VERSION <br>
Mono supports different runtime versions. The version used
depends on the program that is being run or on its
configuration file (named program.exe.config). This option
<br>
can be used to override such autodetection, by forcing a
different runtime version to be used. Note that this should
only be used to select a later compatible runtime ver&acirc;
<br>
sion than the one the program was compiled against. A
typical usage is for running a 1.1 program on a 2.0 version:
<br>
mono --runtime=v2.0.50727 program.exe</p>

<p style="margin-top: 1em">--security, --security=mode <br>
Activate the security manager, a currently experimental
feature in Mono and it is OFF by default. The new code
verifier can be enabled with this option as well.</p>

<p style="margin-top: 1em">Using security without
parameters is equivalent as calling it with the
&quot;cas&quot; parameter.</p>

<p style="margin-top: 1em">The following modes are
supported:</p>

<p style="margin-top: 1em">core-clr <br>
Enables the core-clr security system, typically used for
Moonlight/Silverlight applications. It provides a much
simpler security system than CAS, see <br>
http://www.mono-project.com/docs/web/moonlight/ for more
details and links to the descriptions of this new
system.</p>

<p style="margin-top: 1em">validil <br>
Enables the new verifier and performs basic verification for
code validity. In this mode, unsafe code and P/Invoke are
allowed. This mode provides a better safety <br>
guarantee but it is still possible for managed code to crash
Mono.</p>

<p style="margin-top: 1em">verifiable <br>
Enables the new verifier and performs full verification of
the code being executed. It only allows verifiable code to
be executed. Unsafe code is not allowed but <br>
P/Invoke is. This mode should not allow managed code to
crash mono. The verification is not as strict as ECMA 335
standard in order to stay compatible with the MS <br>
runtime.</p>

<p style="margin-top: 1em">The security system acts on user
code: code contained in mscorlib or the global assembly
cache is always trusted.</p>

<p style="margin-top: 1em">--server <br>
Configures the virtual machine to be better suited for
server operations (currently, allows a heavier threadpool
initialization).</p>

<p style="margin-top: 1em">--verify-all <br>
Verifies mscorlib and assemblies in the global assembly
cache for valid IL, and all user code for IL
verifiability.</p>

<p style="margin-top: 1em">This is different from
--security&rsquo;s verifiable or validil in that these
options only check user code and skip mscorlib and
assemblies located on the global assembly cache.</p>

<p style="margin-top: 1em">-V, --version <br>
Prints JIT version information (system configuration,
release number and branch names if available).</p>

<p style="margin-top: 1em">DEVELOPMENT OPTIONS <br>
The following options are used to help when developing a
JITed application.</p>

<p style="margin-top: 1em">--debug, --debug=OPTIONS <br>
Turns on the debugging mode in the runtime. If an assembly
was compiled with debugging information, it will produce
line number information for stack traces.</p>

<p style="margin-top: 1em">The optional OPTIONS argument is
a comma separated list of debugging options. These options
are turned off by default since they generate much larger
and slower code at <br>
runtime.</p>

<p style="margin-top: 1em">The following options are
supported:</p>

<p style="margin-top: 1em">casts Produces a detailed error
when throwing a InvalidCastException. This option needs to
be enabled as this generates more verbose code at execution
time.</p>

<p style="margin-top: 1em">mdb-optimizations <br>
Disable some JIT optimizations which are usually only
disabled when running inside the debugger. This can be
helpful if you want to attach to the running process <br>
with mdb.</p>

<p style="margin-top: 1em">gdb Generate and register
debugging information with gdb. This is only supported on
some platforms, and only when using gdb 7.0 or later.</p>


<p style="margin-top: 1em">--profile[=profiler[:profiler_args]]
<br>
Turns on profiling. For more information about profiling
applications and code coverage see the sections
&quot;PROFILING&quot; and &quot;CODE COVERAGE&quot;
below.</p>

<p style="margin-top: 1em">This option can be used multiple
times, each time will load an <br>
additional profiler. This allows developers to use modules
that extend the JIT through the Mono profiling
interface.</p>

<p style="margin-top: 1em">--trace[=expression] <br>
Shows method names as they are invoked. By default all
methods are traced. The trace can be customized to include
or exclude methods, classes or assemblies. A trace <br>
expression is a comma separated list of targets, each target
can be prefixed with a minus sign to turn off a particular
target. The words &lsquo;program&rsquo;, &lsquo;all&rsquo;
and &lsquo;disabled&rsquo; <br>
have special meaning. &lsquo;program&rsquo; refers to the
main program being executed, and &lsquo;all&rsquo; means all
the method calls. The &lsquo;disabled&rsquo; option is used
to start up with tracing <br>
disabled. It can be enabled at a later point in time in the
program by sending the SIGUSR2 signal to the runtime.
Assemblies are specified by their name, for example, to <br>
trace all calls in the System assembly, use:</p>

<p style="margin-top: 1em">mono --trace=System app.exe</p>

<p style="margin-top: 1em">Classes are specified with the
T: prefix. For example, to trace all calls to the
System.String class, use:</p>

<p style="margin-top: 1em">mono --trace=T:System.String
app.exe</p>

<p style="margin-top: 1em">And individual methods are
referenced with the M: prefix, and the standard method
notation:</p>

<p style="margin-top: 1em">mono
--trace=M:System.Console:WriteLine app.exe</p>

<p style="margin-top: 1em">Exceptions can also be traced,
it will cause a stack trace to be printed every time an
exception of the specified type is thrown. The exception
type can be specified with <br>
or without the namespace, and to trace all exceptions,
specify &rsquo;all&rsquo; as the type name.</p>

<p style="margin-top: 1em">mono --trace=E:System.Exception
app.exe</p>

<p style="margin-top: 1em">As previously noted, various
rules can be specified at once:</p>

<p style="margin-top: 1em">mono
--trace=T:System.String,T:System.Random app.exe</p>

<p style="margin-top: 1em">You can exclude pieces, the next
example traces calls to System.String except for the
System.String:Concat method.</p>

<p style="margin-top: 1em">mono
--trace=T:System.String,-M:System.String:Concat</p>

<p style="margin-top: 1em">You can trace managed to
unmanaged transitions using the wrapper qualifier:</p>

<p style="margin-top: 1em">mono --trace=wrapper app.exe</p>

<p style="margin-top: 1em">Finally, namespaces can be
specified using the N: prefix:</p>

<p style="margin-top: 1em">mono --trace=N:System.Xml</p>

<p style="margin-top: 1em">--no-x86-stack-align <br>
Don&rsquo;t align stack frames on the x86 architecture. By
default, Mono aligns stack frames to 16 bytes on x86, so
that local floating point and SIMD variables can be properly
<br>
aligned. This option turns off the alignment, which usually
saves one intruction per call, but might result in
significantly lower floating point and SIMD performance.</p>

<p style="margin-top: 1em">--jitmap <br>
Generate a JIT method map in a /tmp/perf-PID.map file. This
file is then used, for example, by the perf tool included in
recent Linux kernels. Each line in the file has:</p>

<p style="margin-top: 1em">HEXADDR HEXSIZE methodname</p>

<p style="margin-top: 1em">Currently this option is only
supported on Linux.</p>

<p style="margin-top: 1em">JIT MAINTAINER OPTIONS <br>
The maintainer options are only used by those developing the
runtime itself, and not typically of interest to runtime
users or developers.</p>

<p style="margin-top: 1em">--bisect=optimization:filename
<br>
This flag is used by the automatic optimization bug
bisector. It takes an optimization flag and a filename of a
file containing a list of full method names, one per line.
<br>
When it compiles one of the methods in the file it will use
the optimization given, in addition to the optimizations
that are otherwise enabled. Note that if the opti&acirc;
<br>
mization is enabled by default, you should disable it with
&lsquo;-O&lsquo;, otherwise it will just apply to every
method, whether it&rsquo;s in the file or not.</p>

<p style="margin-top: 1em">--break method <br>
Inserts a breakpoint before the method whose name is
&lsquo;method&rsquo; (namespace.class:methodname). Use
&lsquo;Main&rsquo; as method name to insert a breakpoint on
the application&rsquo;s main <br>
method. You can use it also with generics, for example
&quot;System.Collections.Generic.Queue&lsquo;1:Peek&quot;</p>

<p style="margin-top: 1em">--breakonex <br>
Inserts a breakpoint on exceptions. This allows you to debug
your application with a native debugger when an exception is
thrown.</p>

<p style="margin-top: 1em">--compile name <br>
This compiles a method (namespace.name:methodname), this is
used for testing the compiler performance or to examine the
output of the code generator.</p>

<p style="margin-top: 1em">--compileall <br>
Compiles all the methods in an assembly. This is used to
test the compiler performance or to examine the output of
the code generator</p>

<p style="margin-top: 1em">--graph=TYPE METHOD <br>
This generates a postscript file with a graph with the
details about the specified method
(namespace.name:methodname). This requires &lsquo;dot&rsquo;
and ghostview to be installed <br>
(it expects Ghostview to be called &quot;gv&quot;). The
following graphs are available: <br>
cfg Control Flow Graph (CFG) <br>
dtree Dominator Tree <br>
code CFG showing code <br>
ssa CFG showing code after SSA translation <br>
optcode CFG showing code after IR optimizations <br>
Some graphs will only be available if certain optimizations
are turned on.</p>

<p style="margin-top: 1em">--ncompile <br>
Instruct the runtime on the number of times that the method
specified by --compile (or all the methods if --compileall
is used) to be compiled. This is used for testing <br>
the code generator performance.</p>

<p style="margin-top: 1em">--stats <br>
Displays information about the work done by the runtime
during the execution of an application.</p>

<p style="margin-top: 1em">--wapi=hps|semdel <br>
Perform maintenance of the process shared data. semdel will
delete the global semaphore. hps will list the currently
used handles.</p>

<p style="margin-top: 1em">-v, --verbose <br>
Increases the verbosity level, each time it is listed,
increases the verbosity level to include more information
(including, for example, a disassembly of the native code
<br>
produced, code selector info etc.).</p>

<p style="margin-top: 1em">ATTACH SUPPORT <br>
The Mono runtime allows external processes to attach to a
running process and load assemblies into the running
program. To attach to the process, a special protocol is
imple&acirc; <br>
mented in the Mono.Management assembly.</p>

<p style="margin-top: 1em">With this support it is possible
to load assemblies that have an entry point (they are
created with -target:exe or -target:winexe) to be loaded and
executed in the Mono process.</p>

<p style="margin-top: 1em">The code is loaded into the root
domain, and it starts execution on the special runtime
attach thread. The attached program should create its own
threads and return after <br>
invocation.</p>

<p style="margin-top: 1em">This support allows for example
debugging applications by having the csharp shell attach to
running processes.</p>

<p style="margin-top: 1em">PROFILING <br>
The mono runtime includes a profiler that can be used to
explore various performance related problems in your
application. The profiler is activated by passing the
--profile <br>
command line argument to the Mono runtime, the format
is:</p>


<p style="margin-top: 1em">--profile[=profiler[:profiler_args]]</p>

<p style="margin-top: 1em">Mono has a built-in profiler
called &rsquo;default&rsquo; (and is also the default if no
arguments are specified), but developers can write custom
profilers, see the section &quot;CUSTOM PROFIL&acirc; <br>
ERS&quot; for more details.</p>

<p style="margin-top: 1em">If a profiler is not specified,
the default profiler is used. The profiler_args is a
profiler-specific string of options for the profiler itself.
The default profiler accepts <br>
the following options &rsquo;alloc&rsquo; to profile memory
consumption by the application; &rsquo;time&rsquo; to
profile the time spent on each routine; &rsquo;jit&rsquo; to
collect time spent JIT-compiling meth&acirc; <br>
ods and &rsquo;stat&rsquo; to perform sample statistical
profiling. If no options are provided the default is
&rsquo;alloc,time,jit&rsquo;.</p>

<p style="margin-top: 1em">By default the profile data is
printed to stdout: to change this, use the
&rsquo;file=filename&rsquo; option to output the data to
filename. For example:</p>

<p style="margin-top: 1em">mono --profile program.exe</p>

<p style="margin-top: 1em">That will run the program with
the default profiler and will do time and allocation
profiling.</p>

<p style="margin-top: 1em">mono
--profile=default:stat,alloc,file=prof.out program.exe</p>

<p style="margin-top: 1em">Will do sample statistical
profiling and allocation profiling on program.exe. The
profile data is put in prof.out. Note that the statistical
profiler has a very low overhead <br>
and should be the preferred profiler to use (for better
output use the full path to the mono binary when running and
make sure you have installed the addr2line utility that
comes <br>
from the binutils package).</p>

<p style="margin-top: 1em">LOG PROFILER <br>
This is the most advanced profiler.</p>

<p style="margin-top: 1em">The Mono log profiler can be
used to collect a lot of information about a program running
in the Mono runtime. This data can be used (both while the
process is running and <br>
later) to do analyses of the program behaviour, determine
resource usage, performance issues or even look for
particular execution patterns.</p>

<p style="margin-top: 1em">This is accomplished by logging
the events provided by the Mono runtime through the
profiling interface and periodically writing them to a file
which can be later inspected with <br>
the mprof-report(1) tool.</p>

<p style="margin-top: 1em">More information about how to
use the log profiler is available on the mprof-report(1)
page.</p>

<p style="margin-top: 1em">CUSTOM PROFILERS <br>
Mono provides a mechanism for loading other profiling
modules which in the form of shared libraries. These
profiling modules can hook up to various parts of the Mono
runtime to <br>
gather information about the code being executed.</p>

<p style="margin-top: 1em">To use a third party profiler
you must pass the name of the profiler to Mono, like
this:</p>

<p style="margin-top: 1em">mono --profile=custom
program.exe</p>

<p style="margin-top: 1em">In the above sample Mono will
load the user defined profiler from the shared library
&lsquo;mono-profiler-custom.so&rsquo;. This profiler module
must be on your dynamic linker library path.</p>

<p style="margin-top: 1em">A list of other third party
profilers is available from Mono&rsquo;s web site
(www.mono-project.com/docs/advanced/performance-tips/)</p>

<p style="margin-top: 1em">Custom profiles are written as
shared libraries. The shared library must be called
&lsquo;mono-profiler-NAME.so&rsquo; where &lsquo;NAME&rsquo;
is the name of your profiler.</p>

<p style="margin-top: 1em">For a sample of how to write
your own custom profiler look in the Mono source tree for in
the samples/profiler.c.</p>

<p style="margin-top: 1em">CODE COVERAGE <br>
Mono ships with a code coverage module. This module is
activated by using the Mono --profile=cov option. The format
is: --profile=cov[:assembly-name[/namespace]]
test-suite.exe</p>

<p style="margin-top: 1em">By default code coverage will
default to all the assemblies loaded, you can limit this by
specifying the assembly name, for example to perform code
coverage in the routines of <br>
your program use, for example the following command line
limits the code coverage to routines in the &quot;demo&quot;
assembly:</p>

<p style="margin-top: 1em">mono --profile=cov:demo
demo.exe</p>

<p style="margin-top: 1em">Notice that the assembly-name
does not include the extension.</p>

<p style="margin-top: 1em">You can further restrict the
code coverage output by specifying a namespace:</p>

<p style="margin-top: 1em">mono
--profile=cov:demo/My.Utilities demo.exe</p>

<p style="margin-top: 1em">Which will only perform code
coverage in the given assembly and namespace.</p>

<p style="margin-top: 1em">Typical output looks like
this:</p>

<p style="margin-top: 1em">Not covered: Class:.ctor () <br>
Not covered: Class:A () <br>
Not covered: Driver:.ctor () <br>
Not covered: Driver:method () <br>
Partial coverage: Driver:Main () <br>
offset 0x000a</p>

<p style="margin-top: 1em">The offsets displayed are IL
offsets.</p>

<p style="margin-top: 1em">A more powerful coverage tool is
available in the module &lsquo;monocov&rsquo;. See the
monocov(1) man page for details.</p>

<p style="margin-top: 1em">AOT PROFILING <br>
You can improve startup performance by using the AOT
profiler.</p>

<p style="margin-top: 1em">Typically the AOT compiler (mono
--aot) will not generate code for generic instantiations. To
solve this, you can run Mono with the AOT profiler to find
out all the generic <br>
instantiations that are used, and then instructing the AOT
compiler to produce code for these.</p>

<p style="margin-top: 1em">This command will run the
specified app.exe and produce the out.aotprof file with the
data describing the generic instantiations that are needed:
<br>
$ mono --profile=aot:output=out.aotprof app.exe</p>

<p style="margin-top: 1em">Once you have this data, you can
pass this to Mono&rsquo;s AOT compiler to instruct it to
generate code for it: <br>
$ mono --aot=profile=out.aotprof</p>

<p style="margin-top: 1em">DEBUGGING AIDS <br>
To debug managed applications, you can use the mdb command,
a command line debugger.</p>

<p style="margin-top: 1em">It is possible to obtain a stack
trace of all the active threads in Mono by sending the QUIT
signal to Mono, you can do this from the command line, like
this:</p>

<p style="margin-top: 1em">kill -QUIT pid</p>

<p style="margin-top: 1em">Where pid is the Process ID of
the Mono process you want to examine. The process will
continue running afterwards, but its state is not
guaranteed.</p>

<p style="margin-top: 1em">Important: this is a last-resort
mechanism for debugging applications and should not be used
to monitor or probe a production application. The integrity
of the runtime after <br>
sending this signal is not guaranteed and the application
might crash or terminate at any given point afterwards.</p>

<p style="margin-top: 1em">The --debug=casts option can be
used to get more detailed information for Invalid Cast
operations, it will provide information about the types
involved.</p>

<p style="margin-top: 1em">You can use the MONO_LOG_LEVEL
and MONO_LOG_MASK environment variables to get verbose
debugging output about the execution of your application
within Mono.</p>

<p style="margin-top: 1em">The MONO_LOG_LEVEL environment
variable if set, the logging level is changed to the set
value. Possible values are &quot;error&quot;,
&quot;critical&quot;, &quot;warning&quot;,
&quot;message&quot;, &quot;info&quot;, &quot;debug&quot;.
The <br>
default value is &quot;error&quot;. Messages with a logging
level greater then or equal to the log level will be printed
to stdout/stderr.</p>

<p style="margin-top: 1em">Use &quot;info&quot; to track
the dynamic loading of assemblies.</p>

<p style="margin-top: 1em">Use the MONO_LOG_MASK
environment variable to limit the extent of the messages you
get: If set, the log mask is changed to the set value.
Possible values are &quot;asm&quot; (assembly <br>
loader), &quot;type&quot;, &quot;dll&quot; (native library
loader), &quot;gc&quot; (garbage collector), &quot;cfg&quot;
(config file loader), &quot;aot&quot; (precompiler),
&quot;security&quot; (e.g. Moonlight CoreCLR support),
&quot;thread&acirc; <br>
pool&quot; (thread pool generic), &quot;io-threadpool&quot;
(thread pool I/O), &quot;io-layer&quot; (I/O layer -
sockets, handles, shared memory etc) and &quot;all&quot;.
The default value is &quot;all&quot;. Changing the <br>
mask value allows you to display only messages for a certain
component. You can use multiple masks by comma separating
them. For example to see config file messages and assembly
<br>
loader messages set you mask to &quot;asm,cfg&quot;.</p>

<p style="margin-top: 1em">The following is a common use to
track down problems with P/Invoke:</p>

<p style="margin-top: 1em">$
MONO_LOG_LEVEL=&quot;debug&quot;
MONO_LOG_MASK=&quot;dll&quot; mono glue.exe</p>

<p style="margin-top: 1em">DEBUGGING WITH LLDB <br>
If you are using LLDB, you can use the mono.py script to
print some internal data structures with it. To use this,
add this to your $HOME/.lldbinit file: <br>
command script import $PREFIX/lib/mono/lldb/mono.py</p>

<p style="margin-top: 1em">Where $PREFIX is the prefix
value that you used when you configured Mono (typically
/usr).</p>

<p style="margin-top: 1em">Once this is done, then you can
inspect some Mono Runtime data structures, for example: <br>
(lldb) p method</p>

<p style="margin-top: 1em">(MonoMethod *) $0 = 0x05026ac0
[mscorlib]System.OutOfMemoryException:.ctor()</p>

<p style="margin-top: 1em">SERIALIZATION <br>
Mono&rsquo;s XML serialization engine by default will use a
reflection-based approach to serialize which might be slow
for continuous processing (web service applications). The
seri&acirc; <br>
alization engine will determine when a class must use a
hand-tuned serializer based on a few parameters and if
needed it will produce a customized C# serializer for your
types at <br>
runtime. This customized serializer then gets dynamically
loaded into your application.</p>

<p style="margin-top: 1em">You can control this with the
MONO_XMLSERIALIZER_THS environment variable.</p>

<p style="margin-top: 1em">The possible values are
&lsquo;no&rsquo; to disable the use of a C# customized
serializer, or an integer that is the minimum number of uses
before the runtime will produce a custom serial&acirc; <br>
izer (0 will produce a custom serializer on the first
access, 50 will produce a serializer on the 50th use). Mono
will fallback to an interpreted serializer if the serializer
<br>
generation somehow fails. This behavior can be disabled by
setting the option &lsquo;nofallback&rsquo; (for example:
MONO_XMLSERIALIZER_THS=0,nofallback).</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
GC_DONT_GC <br>
Turns off the garbage collection in Mono. This should be
only used for debugging purposes</p>

<p style="margin-top: 1em">HTTP_PROXY <br>
(Also http_proxy) If set, web requests using the Mono Class
Library will be automatically proxied through the given URL.
Not supported on Windows, Mac OS, iOS or Android. <br>
See also NO_PROXY.</p>

<p style="margin-top: 1em">LLVM_COUNT <br>
When Mono is compiled with LLVM support, this instructs the
runtime to stop using LLVM after the specified number of
methods are JITed. This is a tool used in diagnostics <br>
to help isolate problems in the code generation backend. For
example LLVM_COUNT=10 would only compile 10 methods with
LLVM and then switch to the Mono JIT engine. <br>
LLVM_COUNT=0 would disable the LLVM engine altogether.</p>

<p style="margin-top: 1em">MONO_AOT_CACHE <br>
If set, this variable will instruct Mono to ahead-of-time
compile new assemblies on demand and store the result into a
cache in ~/.mono/aot-cache.</p>

<p style="margin-top: 1em">MONO_ASPNET_INHIBIT_SETTINGSMAP
<br>
Mono contains a feature which allows modifying settings in
the .config files shipped with Mono by using config section
mappers. The mappers and the mapping rules are <br>
defined in the $prefix/etc/mono/2.0/settings.map file and,
optionally, in the settings.map file found in the top-level
directory of your ASP.NET application. Both files <br>
are read by System.Web on application startup, if they are
found at the above locations. If you don&rsquo;t want the
mapping to be performed you can set this variable in your
<br>
environment before starting the application and no action
will be taken.</p>

<p style="margin-top: 1em">MONO_ASPNET_WEBCONFIG_CACHESIZE
<br>
Mono has a cache of ConfigSection objects for speeding up
WebConfigurationManager queries. Its default size is 100
items, and when more items are needed, cache evictions <br>
start happening. If evictions are too frequent this could
impose unnecessary overhead, which could be avoided by using
this environment variable to set up a higher cache <br>
size (or to lower memory requirements by decreasing it).</p>

<p style="margin-top: 1em">MONO_CAIRO_DEBUG_DISPOSE <br>
If set, causes Mono.Cairo to collect stack traces when
objects are allocated, so that the finalization/Dispose
warnings include information about the instance&rsquo;s
origin.</p>

<p style="margin-top: 1em">MONO_CFG_DIR <br>
If set, this variable overrides the default system
configuration directory ($PREFIX/etc). It&rsquo;s used to
locate machine.config file.</p>

<p style="margin-top: 1em">MONO_COM <br>
Sets the style of COM interop. If the value of this variable
is &quot;MS&quot; Mono will use string marhsalling routines
from the liboleaut32 for the BSTR type library, any other
<br>
values will use the mono-builtin BSTR string
marshalling.</p>

<p style="margin-top: 1em">MONO_CONFIG <br>
If set, this variable overrides the default runtime
configuration file ($PREFIX/etc/mono/config). The --config
command line options overrides the environment variable.</p>

<p style="margin-top: 1em">MONO_CPU_ARCH <br>
Override the automatic cpu detection mechanism. Currently
used only on arm. The format of the value is as follows:</p>

<p style="margin-top: 1em">&quot;armvV [thumb[2]]&quot;</p>

<p style="margin-top: 1em">where V is the architecture
number 4, 5, 6, 7 and the options can be currently be
&quot;thumb&quot; or &quot;thumb2&quot;. Example:</p>

<p style="margin-top: 1em">MONO_CPU_ARCH=&quot;armv4
thumb&quot; mono ...</p>

<p style="margin-top: 1em">MONO_ARM_FORCE_SOFT_FLOAT <br>
When Mono is built with a soft float fallback on ARM and
this variable is set to &quot;1&quot;, Mono will always emit
soft float code, even if a VFP unit is detected.</p>

<p style="margin-top: 1em">MONO_DARWIN_WATCHER_MAXFDS <br>
This is a debugging aid used to force limits on the
FileSystemWatcher implementation in Darwin. There is no
limit by default.</p>

<p style="margin-top: 1em">MONO_DISABLE_AIO <br>
If set, tells mono NOT to attempt using native asynchronous
I/O services. In that case, a default select/poll
implementation is used. Currently only epoll() is
supported.</p>

<p style="margin-top: 1em">MONO_DISABLE_MANAGED_COLLATION
<br>
If this environment variable is &lsquo;yes&rsquo;, the
runtime uses unmanaged collation (which actually means no
culture-sensitive collation). It internally disables managed
collation <br>
functionality invoked via the members of
System.Globalization.CompareInfo class. Collation is enabled
by default.</p>

<p style="margin-top: 1em">MONO_DISABLE_SHM <br>
Unix only: If set, disables the shared memory files used for
cross-process handles: process have only private handles.
This means that process and thread handles are not <br>
available to other processes, and named mutexes, named
events and named semaphores are not visible between
processes. This is can also be enabled by default by passing
<br>
the &quot;--disable-shared-handles&quot; option to
configure. This is the default from mono 2.8 onwards.</p>

<p style="margin-top: 1em">MONO_DISABLE_SHARED_AREA <br>
Unix only: If set, disable usage of shared memory for
exposing performance counters. This means it will not be
possible to both externally read performance counters from
<br>
this processes or read those of external processes.</p>

<p style="margin-top: 1em">MONO_DNS <br>
When set, enables the use of a fully managed DNS resolver
instead of the regular libc functions. This resolver
performs much better when multiple queries are run in
paral&acirc; <br>
lel.</p>

<p style="margin-top: 1em">Note that /etc/nsswitch.conf
will be ignored.</p>

<p style="margin-top: 1em">MONO_EGD_SOCKET <br>
For platforms that do not otherwise have a way of obtaining
random bytes this can be set to the name of a file system
socket on which an egd or prngd daemon is listening.</p>

<p style="margin-top: 1em">MONO_ENABLE_COOP <br>
This makes the Mono runtime and the SGen garbage collector
run in cooperative mode as opposed to run on preemptive
mode. Preemptive mode is the mode that Mono has used <br>
historically, going back to the Boehm days, where the
garbage collector would run at any point and suspend
execution of all threads as required to perform a garbage
col&acirc; <br>
lection. The cooperative mode on the other hand requires the
cooperation of all threads to stop at a safe point. This
makes for an easier to debug garbage collector. <br>
As of Mono 4.3.0 it is a work in progress, and while it
works, it has not been used extensively. This option enabled
the feature and allows us to find spots that need to <br>
be tuned for this mode of operation. Alternatively, this
mode can be enabled at compile time by using the
--with-cooperative-gc flag when calling configure.</p>

<p style="margin-top: 1em">MONO_ENV_OPTIONS <br>
This environment variable allows you to pass command line
arguments to a Mono process through the environment. This is
useful for example to force all of your Mono pro&acirc; <br>
cesses to use LLVM or SGEN without having to modify any
launch scripts.</p>

<p style="margin-top: 1em">MONO_SDB_ENV_OPTIONS <br>
Used to pass extra options to the debugger agent in the
runtime, as they were passed using --debugger-agent=.</p>

<p style="margin-top: 1em">MONO_EVENTLOG_TYPE <br>
Sets the type of event log provider to use (for
System.Diagnostics.EventLog). Possible values are:</p>

<p style="margin-top: 1em">local[:path] <br>
Persists event logs and entries to the local file system.
The directory in which to persist the event logs, event
sources and entries can be specified as part of <br>
the value. If the path is not explicitly set, it defaults to
&quot;/var/lib/mono/eventlog&quot; on unix and
&quot;%APPDATA%notlog&quot; on Windows.</p>

<p style="margin-top: 1em">win32 Uses the native win32 API
to write events and registers event logs and event sources
in the registry. This is only available on Windows. On Unix,
the directory <br>
permission for individual event log and event source
directories is set to 777 (with +t bit) allowing everyone to
read and write event log entries while only allow&acirc;
<br>
ing entries to be deleted by the user(s) that created
them.</p>

<p style="margin-top: 1em">null Silently discards any
events.</p>

<p style="margin-top: 1em">The default is &quot;null&quot;
on Unix (and versions of Windows before NT), and
&quot;win32&quot; on Windows NT (and higher).</p>

<p style="margin-top: 1em">MONO_EXTERNAL_ENCODINGS <br>
If set, contains a colon-separated list of text encodings to
try when turning externally-generated text (e.g.
command-line arguments or filenames) into Unicode. The <br>
encoding names come from the list provided by iconv, and the
special case &quot;default_locale&quot; which refers to the
current locale&rsquo;s default encoding.</p>

<p style="margin-top: 1em">When reading
externally-generated text strings UTF-8 is tried first, and
then this list is tried in order with the first successful
conversion ending the search. When <br>
writing external text (e.g. new filenames or arguments to
new processes) the first item in this list is used, or UTF-8
if the environment variable is not set.</p>

<p style="margin-top: 1em">The problem with using
MONO_EXTERNAL_ENCODINGS to process your files is that it
results in a problem: although its possible to get the right
file name it is not necessar&acirc; <br>
ily possible to open the file. In general if you have
problems with encodings in your filenames you should use the
&quot;convmv&quot; program.</p>

<p style="margin-top: 1em">MONO_GC_PARAMS <br>
When using Mono with the SGen garbage collector this
variable controls several parameters of the collector. The
variable&rsquo;s value is a comma separated list of
words.</p>

<p style="margin-top: 1em">max-heap-size=size <br>
Sets the maximum size of the heap. The size is specified in
bytes and must be a power of two. The suffixes
&lsquo;k&rsquo;, &lsquo;m&rsquo; and &lsquo;g&rsquo; can be
used to specify kilo-, mega- and <br>
gigabytes, respectively. The limit is the sum of the
nursery, major heap and large object heap. Once the limit is
reached the application will receive OutOfMemo&acirc; <br>
ryExceptions when trying to allocate. Not the full extent of
memory set in max-heap-size could be available to satisfy a
single allocation due to internal fragmen&acirc; <br>
tation. By default heap limits is disabled and the GC will
try to use all available memory.</p>

<p style="margin-top: 1em">nursery-size=size <br>
Sets the size of the nursery. The size is specified in bytes
and must be a power of two. The suffixes &lsquo;k&rsquo;,
&lsquo;m&rsquo; and &lsquo;g&rsquo; can be used to specify
kilo-, mega- and <br>
gigabytes, respectively. The nursery is the first generation
(of two). A larger nursery will usually speed up the program
but will obviously use more memory. The <br>
default nursery size 4 MB.</p>

<p style="margin-top: 1em">major=collector Specifies which
major collector to use. <br>
Options are &lsquo;marksweep&rsquo; for the Mark&amp;Sweep
collector, and &lsquo;marksweep-conc&rsquo; for concurrent
Mark&amp;Sweep. The non-concurrent Mark&amp;Sweep collector
is the default.</p>

<p style="margin-top: 1em">soft-heap-limit=size <br>
Once the heap size gets larger than this size, ignore what
the default major collection trigger metric says and only
allow four nursery size&rsquo;s of major heap growth <br>
between major collections.</p>

<p style="margin-top: 1em">evacuation-threshold=threshold
<br>
Sets the evacuation threshold in percent. This option is
only available on the Mark&amp;Sweep major collectors. The
value must be an integer in the range 0 to 100. <br>
The default is 66. If the sweep phase of the collection
finds that the occupancy of a specific heap block type is
less than this percentage, it will do a copying <br>
collection for that block type in the next major collection,
thereby restoring occupancy to close to 100 percent. A value
of 0 turns evacuation off.</p>

<p style="margin-top: 1em">(no-)lazy-sweep <br>
Enables or disables lazy sweep for the Mark&amp;Sweep
collector. If enabled, the sweeping of individual major heap
blocks is done piecemeal whenever the need arises, <br>
typically during nursery collections. Lazy sweeping is
enabled by default.</p>

<p style="margin-top: 1em">(no-)concurrent-sweep <br>
Enables or disables concurrent sweep for the Mark&amp;Sweep
collector. If enabled, the iteration of all major blocks to
determine which ones can be freed and which <br>
ones have to be kept and swept, is done concurrently with
the running program. Concurrent sweeping is enabled by
default.</p>

<p style="margin-top: 1em">stack-mark=mark-mode <br>
Specifies how application threads should be scanned. Options
are &lsquo;precise&lsquo; and &lsquo;conservative&lsquo;.
Precise marking allow the collector to know what values on
stack are <br>
references and what are not. Conservative marking threats
all values as potentially references and leave them
untouched. Precise marking reduces floating garbage <br>
and can speed up nursery collection and allocation rate, it
has the downside of requiring a significant extra memory per
compiled method. The right option, unfortu&acirc; <br>
nately, requires experimentation.</p>

<p style="margin-top: 1em">save-target-ratio=ratio <br>
Specifies the target save ratio for the major collector. The
collector lets a given amount of memory to be promoted from
the nursery due to minor collections before <br>
it triggers a major collection. This amount is based on how
much memory it expects to free. It is represented as a ratio
of the size of the heap after a major col&acirc; <br>
lection. Valid values are between 0.1 and 2.0. The default
is 0.5. Smaller values will keep the major heap size smaller
but will trigger more major collections. <br>
Likewise, bigger values will use more memory and result in
less frequent major collections. This option is
EXPERIMENTAL, so it might disappear in later versions of
<br>
mono.</p>

<p style="margin-top: 1em">default-allowance-ratio=ratio
<br>
Specifies the default allocation allowance when the
calculated size is too small. The allocation allowance is
how much memory the collector let be promoted before <br>
triggered a major collection. It is a ratio of the nursery
size. Valid values are between 1.0 and 10.0. The default is
4.0. Smaller values lead to smaller heaps <br>
and more frequent major collections. Likewise, bigger values
will allow the heap to grow faster but use more memory when
it reaches a stable size. This option is <br>
EXPERIMENTAL, so it might disappear in later versions of
mono.</p>

<p style="margin-top: 1em">minor=minor-collector <br>
Specifies which minor collector to use. Options are
&rsquo;simple&rsquo; which promotes all objects from the
nursery directly to the old generation and
&rsquo;split&rsquo; which lets <br>
object stay longer on the nursery before promoting.</p>

<p style="margin-top: 1em">alloc-ratio=ratio <br>
Specifies the ratio of memory from the nursery to be use by
the alloc space. This only can only be used with the split
minor collector. Valid values are integers <br>
between 1 and 100. Default is 60.</p>

<p style="margin-top: 1em">promotion-age=age <br>
Specifies the required age of an object must reach inside
the nursery before been promoted to the old generation. This
only can only be used with the split minor <br>
collector. Valid values are integers between 1 and 14.
Default is 2.</p>

<p style="margin-top: 1em">(no-)cementing <br>
Enables or disables cementing. This can dramatically shorten
nursery collection times on some benchmarks where pinned
objects are referred to from the major heap.</p>

<p style="margin-top: 1em">allow-synchronous-major <br>
This forbids the major collector from performing synchronous
major collections. The major collector might want to do a
synchronous collection due to excessive <br>
fragmentation. Disabling this might trigger OutOfMemory
error in situations that would otherwise not happen.</p>

<p style="margin-top: 1em">MONO_GC_DEBUG <br>
When using Mono with the SGen garbage collector this
environment variable can be used to turn on various
debugging features of the collector. The value of this
variable <br>
is a comma separated list of words. Do not use these options
in production.</p>

<p style="margin-top: 1em">number Sets the debug level to
the specified number.</p>

<p style="margin-top: 1em">print-allowance <br>
After each major collection prints memory consumption for
before and after the collection and the allowance for the
minor collector, i.e. how much the heap is <br>
allowed to grow from minor collections before the next major
collection is triggered.</p>

<p style="margin-top: 1em">print-pinning <br>
Gathers statistics on the classes whose objects are pinned
in the nursery and for which global remset entries are
added. Prints those statistics when shutting <br>
down.</p>

<p style="margin-top: 1em">collect-before-allocs</p>

<p style="margin-top: 1em">check-remset-consistency <br>
This performs a remset consistency check at various
opportunities, and also clears the nursery at collection
time, instead of the default, when buffers are allo&acirc;
<br>
cated (clear-at-gc). The consistency check ensures that
there are no major to minor references that are not on the
remembered sets.</p>

<p style="margin-top: 1em">mod-union-consistency-check <br>
Checks that the mod-union cardtable is consistent before
each finishing major collection pause. This check is only
applicable to concurrent major collectors.</p>

<p style="margin-top: 1em">check-mark-bits <br>
Checks that mark bits in the major heap are consistent at
the end of each major collection. Consistent mark bits mean
that if an object is marked, all objects that <br>
it had references to must also be marked.</p>

<p style="margin-top: 1em">check-nursery-pinned <br>
After nursery collections, and before starting concurrent
collections, check whether all nursery objects are pinned,
or not pinned - depending on context. Does <br>
nothing when the split nursery collector is used.</p>

<p style="margin-top: 1em">xdomain-checks <br>
Performs a check to make sure that no references are left to
an unloaded AppDomain.</p>

<p style="margin-top: 1em">clear-at-tlab-creation <br>
Clears the nursery incrementally when the thread local
allocation buffers (TLAB) are created. The default setting
clears the whole nursery at GC time.</p>

<p style="margin-top: 1em">debug-clear-at-tlab-creation
<br>
Clears the nursery incrementally when the thread local
allocation buffers (TLAB) are created, but at GC time fills
it with the byte &lsquo;0xff&lsquo;, which should result in
a <br>
crash more quickly if &lsquo;clear-at-tlab-creation&lsquo;
doesn&rsquo;t work properly.</p>

<p style="margin-top: 1em">clear-at-gc <br>
This clears the nursery at GC time instead of doing it when
the thread local allocation buffer (TLAB) is created. The
default is to clear the nursery at TLAB cre&acirc; <br>
ation time.</p>

<p style="margin-top: 1em">disable-minor <br>
Don&rsquo;t do minor collections. If the nursery is full, a
major collection is triggered instead, unless it, too, is
disabled.</p>

<p style="margin-top: 1em">disable-major <br>
Don&rsquo;t do major collections.</p>

<p style="margin-top: 1em">conservative-stack-mark <br>
Forces the GC to scan the stack conservatively, even if
precise scanning is available.</p>

<p style="margin-top: 1em">no-managed-allocator <br>
Disables the managed allocator.</p>

<p style="margin-top: 1em">check-scan-starts <br>
If set, does a plausibility check on the scan_starts before
and after each collection</p>

<p style="margin-top: 1em">verify-nursery-at-minor-gc <br>
If set, does a complete object walk of the nursery at the
start of each minor collection.</p>

<p style="margin-top: 1em">dump-nursery-at-minor-gc <br>
If set, dumps the contents of the nursery at the start of
each minor collection. Requires verify-nursery-at-minor-gc
to be set.</p>

<p style="margin-top: 1em">heap-dump=file <br>
Dumps the heap contents to the specified file. To visualize
the information, use the mono-heapviz tool.</p>

<p style="margin-top: 1em">binary-protocol=file <br>
Outputs the debugging output to the specified file. For this
to work, Mono needs to be compiled with the BINARY_PROTOCOL
define on sgen-gc.c. You can then use <br>
this command to explore the output <br>
sgen-grep-binprot 0x1234 0x5678 &lt; file</p>

<p style="margin-top: 1em">nursery-canaries <br>
If set, objects allocated in the nursery are suffixed with a
canary (guard) word, which is checked on each minor
collection. Can be used to detect/debug heap cor&acirc; <br>
ruption issues.</p>

<p style="margin-top: 1em">do-not-finalize(=classes) <br>
If enabled, finalizers will not be run. Everything else will
be unaffected: finalizable objects will still be put into
the finalization queue where they survive <br>
until they&rsquo;re scheduled to finalize. Once
they&rsquo;re not in the queue anymore they will be
collected regularly. If a list of comma-separated class
names is given, <br>
only objects from those classes will not be finalized.</p>

<p style="margin-top: 1em">log-finalizers <br>
Log verbosely around the finalization process to aid
debugging.</p>

<p style="margin-top: 1em">MONO_GAC_PREFIX <br>
Provides a prefix the runtime uses to look for Global
Assembly Caches. Directories are separated by the platform
path separator (colons on unix). MONO_GAC_PREFIX should <br>
point to the top directory of a prefixed install. Or to the
directory provided in the gacutil /gacdir command. Example:
/home/username/.mono:/usr/local/mono/</p>

<p style="margin-top: 1em">MONO_IOMAP <br>
Enables some filename rewriting support to assist
badly-written applications that hard-code Windows paths. Set
to a colon-separated list of &quot;drive&quot; to strip
drive let&acirc; <br>
ters, or &quot;case&quot; to do case-insensitive file
matching in every directory in a path. &quot;all&quot;
enables all rewriting methods. (Backslashes are always
mapped to slashes if this <br>
variable is set to a valid option). <br>
For example, this would work from the shell:</p>

<p style="margin-top: 1em">MONO_IOMAP=drive:case <br>
export MONO_IOMAP</p>

<p style="margin-top: 1em">If you are using mod_mono to
host your web applications, you can use the MonoIOMAP
directive instead, like this:</p>

<p style="margin-top: 1em">MonoIOMAP &lt;appalias&gt;
all</p>

<p style="margin-top: 1em">See mod_mono(8) for more
details.</p>

<p style="margin-top: 1em">Additionally. Mono includes a
profiler module which allows one to track what adjustements
to file paths IOMAP code needs to do. The tracking code
reports the managed loca&acirc; <br>
tion (full stack trace) from which the IOMAP-ed call was
made and, on process exit, the locations where all the
IOMAP-ed strings were created in managed code. The latter
<br>
report is only approximate as it is not always possible to
estimate the actual location where the string was created.
The code uses simple heuristics - it analyzes stack <br>
trace leading back to the string allocation location and
ignores all the managed code which lives in assemblies
installed in GAC as well as in the class libraries shipped
<br>
with Mono (since they are assumed to be free of
case-sensitivity issues). It then reports the first location
in the user&rsquo;s code - in most cases this will be the
place <br>
where the string is allocated or very close to the location.
The reporting code is implemented as a custom profiler
module (see the &quot;PROFILING&quot; section) and can be
loaded <br>
in the following way:</p>

<p style="margin-top: 1em">mono --profile=iomap
yourapplication.exe</p>

<p style="margin-top: 1em">Note, however, that Mono
currently supports only one profiler module at a time.</p>

<p style="margin-top: 1em">MONO_LLVM <br>
When Mono is using the LLVM code generation backend you can
use this environment variable to pass code generation
options to the LLVM compiler.</p>

<p style="margin-top: 1em">MONO_MANAGED_WATCHER <br>
If set to &quot;disabled&quot;, System.IO.FileSystemWatcher
will use a file watcher implementation which silently
ignores all the watching requests. If set to any other
value, Sys&acirc; <br>
tem.IO.FileSystemWatcher will use the default managed
implementation (slow). If unset, mono will try to use
inotify, FAM, Gamin, kevent under Unix systems and native
API <br>
calls on Windows, falling back to the managed implementation
on error.</p>

<p style="margin-top: 1em">MONO_MESSAGING_PROVIDER <br>
Mono supports a plugin model for its implementation of
System.Messaging making it possible to support a variety of
messaging implementations (e.g. AMQP, ActiveMQ). To <br>
specify which messaging implementation is to be used the
evironement variable needs to be set to the full class name
for the provider. E.g. to use the RabbitMQ based AMQP <br>
implementation the variable should be set to:</p>


<p style="margin-top: 1em">Mono.Messaging.RabbitMQ.RabbitMQMessagingProvider,Mono.Messaging.RabbitMQ</p>

<p style="margin-top: 1em">MONO_NO_SMP <br>
If set causes the mono process to be bound to a single
processor. This may be <br>
useful when debugging or working around race conditions.</p>

<p style="margin-top: 1em">MONO_NO_TLS <br>
Disable inlining of thread local accesses. Try setting this
if you get a segfault <br>
early on in the execution of mono.</p>

<p style="margin-top: 1em">MONO_PATH <br>
Provides a search path to the runtime where to look for
library <br>
files. This is a tool convenient for debugging applications,
but <br>
should not be used by deployed applications as it breaks the
assembly <br>
loader in subtle ways. <br>
Directories are separated by the platform path separator
(colons on unix). Example: <br>
/home/username/lib:/usr/local/mono/lib <br>
Relative paths are resolved based on the launch-time current
directory. <br>
Alternative solutions to MONO_PATH include: installing
libraries into <br>
the Global Assembly Cache (see gacutil(1)) or having the
dependent <br>
libraries side-by-side with the main executable. <br>
For a complete description of recommended practices for
application <br>
deployment, see <br>

http://www.mono-project.com/docs/getting-started/application-deployment/</p>

<p style="margin-top: 1em">MONO_SHARED_DIR <br>
If set its the directory where the &quot;.wapi&quot; handle
state is stored. <br>
This is the directory where the Windows I/O Emulation layer
stores its <br>
shared state data (files, events, mutexes, pipes). By
default Mono <br>
will store the &quot;.wapi&quot; directory in the
users&rsquo;s home directory.</p>

<p style="margin-top: 1em">MONO_SHARED_HOSTNAME <br>
Uses the string value of this variable as a replacement for
the host name when <br>
creating file names in the &quot;.wapi&quot; directory. This
helps if the host name of <br>
your machine is likely to be changed when a mono application
is running or if <br>
you have a .wapi directory shared among several different
computers. <br>
Mono typically uses the hostname to create the files that
are used to <br>
share state across multiple Mono processes. This is done to
support <br>
home directories that might be shared over the network.</p>

<p style="margin-top: 1em">MONO_STRICT_IO_EMULATION <br>
If set, extra checks are made during IO operations.
Currently, this <br>
includes only advisory locks around file writes.</p>

<p style="margin-top: 1em">MONO_THEME <br>
The name of the theme to be used by Windows.Forms. Available
themes today <br>
include &quot;clearlooks&quot;, &quot;nice&quot; and
&quot;win32&quot;. <br>
The default is &quot;win32&quot;.</p>

<p style="margin-top: 1em">MONO_TLS_SESSION_CACHE_TIMEOUT
<br>
The time, in seconds, that the SSL/TLS session cache will
keep it&rsquo;s entry to <br>
avoid a new negotiation between the client and a server.
Negotiation are very <br>
CPU intensive so an application-specific custom value may
prove useful for <br>
small embedded systems. <br>
The default is 180 seconds.</p>

<p style="margin-top: 1em">MONO_THREADS_PER_CPU <br>
The minimum number of threads in the general threadpool will
be <br>
MONO_THREADS_PER_CPU * number of CPUs. The default value for
this <br>
variable is 1.</p>

<p style="margin-top: 1em">MONO_XMLSERIALIZER_THS <br>
Controls the threshold for the XmlSerializer to produce a
custom <br>
serializer for a given class instead of using the
Reflection-based <br>
interpreter. The possible values are &lsquo;no&rsquo; to
disable the use of a <br>
custom serializer or a number to indicate when the
XmlSerializer <br>
should start serializing. The default value is 50, which
means that <br>
the a custom serializer will be produced on the 50th
use.</p>

<p style="margin-top: 1em">MONO_X509_REVOCATION_MODE <br>
Sets the revocation mode used when validating a X509
certificate chain (https, <br>
ftps, smtps...). The default is &rsquo;nocheck&rsquo;, which
performs no revocation check <br>
at all. The other possible values are &rsquo;offline&rsquo;,
which performs CRL check (not <br>
implemented yet) and &rsquo;online&rsquo; which uses OCSP
and CRL to verify the revocation <br>
status (not implemented yet).</p>

<p style="margin-top: 1em">NO_PROXY <br>
(Also no_proxy) If both HTTP_PROXY and NO_PROXY are <br>
set, NO_PROXY will be treated as a comma-separated list of
&quot;bypass&quot; domains <br>
which will not be sent through the proxy. Domains in
NO_PROXY may contain <br>
wildcards, as in &quot;*.mono-project.com&quot; or
&quot;build????.local&quot;. Not supported on <br>
Windows, Mac OS, iOS or Android.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES FOR
DEBUGGING <br>
MONO_ASPNET_NODELETE <br>
If set to any value, temporary source files generated by
ASP.NET support classes will not be removed. They will be
kept in the user&rsquo;s temporary directory.</p>

<p style="margin-top: 1em">MONO_DEBUG <br>
If set, enables some features of the runtime useful for
debugging. This variable should contain a comma separated
list of debugging options. Currently, the following <br>
options are supported:</p>

<p style="margin-top: 1em">align-small-structs <br>
Enables small structs alignment to 4/8 bytes.</p>

<p style="margin-top: 1em">arm-use-fallback-tls <br>
When this option is set on ARM, a fallback TLS will be used
instead of the default fast TLS.</p>

<p style="margin-top: 1em">break-on-unverified <br>
If this variable is set, when the Mono VM runs into a
verification problem, instead of throwing an exception it
will break into the debugger. This is useful when <br>
debugging verifier problems</p>

<p style="margin-top: 1em">casts This option can be used to
get more detailed information from InvalidCast exceptions,
it will provide information about the types involved.</p>

<p style="margin-top: 1em">check-pinvoke-callconv <br>
This option causes the runtime to check for calling
convention mismatches when using pinvoke, i.e. mixing
cdecl/stdcall. It only works on windows. If a mismatch is
<br>
detected, an ExecutionEngineException is thrown.</p>

<p style="margin-top: 1em">collect-pagefault-stats <br>
Collects information about pagefaults. This is used
internally to track the number of page faults produced to
load metadata. To display this information you must <br>
use this option with &quot;--stats&quot; command line
option.</p>

<p style="margin-top: 1em">debug-domain-unload <br>
When this option is set, the runtime will invalidate the
domain memory pool instead of destroying it.</p>

<p style="margin-top: 1em">disable_omit_fp <br>
Disables a compiler optimization where the frame pointer is
omitted from the stack. This optimization can interact badly
with debuggers.</p>

<p style="margin-top: 1em">dont-free-domains <br>
This is an Optimization for multi-AppDomain applications
(most commonly ASP.NET applications). Due to internal
limitations Mono, Mono by default does not use typed <br>
allocations on multi-appDomain applications as they could
leak memory when a domain is unloaded. Although this is a
fine default, for applications that use more <br>
than on AppDomain heavily (for example, ASP.NET
applications) it is worth trading off the small leaks for
the increased performance (additionally, since ASP.NET <br>
applications are not likely going to unload the application
domains on production systems, it is worth using this
feature).</p>

<p style="margin-top: 1em">dyn-runtime-invoke <br>
Instructs the runtime to try to use a generic runtime-invoke
wrapper instead of creating one invoke wrapper.</p>

<p style="margin-top: 1em">explicit-null-checks <br>
Makes the JIT generate an explicit NULL check on variable
dereferences instead of depending on the operating system to
raise a SIGSEGV or another form of trap event <br>
when an invalid memory location is accessed.</p>

<p style="margin-top: 1em">gdb Equivalent to setting the
MONO_XDEBUG variable, this emits symbols into a shared
library as the code is JITed that can be loaded into GDB to
inspect symbols.</p>

<p style="margin-top: 1em">gen-seq-points <br>
Automatically generates sequence points where the IL stack
is empty. These are places where the debugger can set a
breakpoint.</p>

<p style="margin-top: 1em">no-compact-seq-points <br>
Unless the option is used, the runtime generates sequence
points data that maps native offsets to IL offsets. Sequence
point data is used to display IL offset in <br>
stacktraces. Stacktraces with IL offsets can be symbolicated
using mono-symbolicate tool.</p>

<p style="margin-top: 1em">handle-sigint <br>
Captures the interrupt signal (Control-C) and displays a
stack trace when pressed. Useful to find out where the
program is executing at a given point. This only <br>
displays the stack trace of a single thread.</p>

<p style="margin-top: 1em">init-stacks <br>
Instructs the runtime to initialize the stack with some
known values (0x2a on x86-64) at the start of a method to
assist in debuggin the JIT engine.</p>

<p style="margin-top: 1em">keep-delegates <br>
This option will leak delegate trampolines that are no
longer referenced as to present the user with more
information about a delegate misuse. Basically a delegate
<br>
instance might be created, passed to unmanaged code, and no
references kept in managed code, which will garbage collect
the code. With this option it is possible <br>
to track down the source of the problems.</p>

<p style="margin-top: 1em">no-gdb-backtrace <br>
This option will disable the GDB backtrace emitted by the
runtime after a SIGSEGV or SIGABRT in unmanaged code.</p>

<p style="margin-top: 1em">partial-sharing <br>
When this option is set, the runtime can share generated
code between generic types effectively reducing the amount
of code generated.</p>

<p style="margin-top: 1em">reverse-pinvoke-exceptions <br>
This option will cause mono to abort with a descriptive
message when during stack unwinding after an exception it
reaches a native stack frame. This happens when a <br>
managed delegate is passed to native code, and the managed
delegate throws an exception. Mono will normally try to
unwind the stack to the first (managed) exception <br>
handler, and it will skip any native stack frames in the
process. This leads to undefined behaviour (since mono
doesn&rsquo;t know how to process native frames), leaks,
<br>
and possibly crashes too.</p>

<p style="margin-top: 1em">single-imm-size <br>
This guarantees that each time managed code is compiled the
same instructions and registers are used, regardless of the
size of used values.</p>

<p style="margin-top: 1em">soft-breakpoints <br>
This option allows using single-steps and breakpoints in
hardware where we cannot do it with signals.</p>

<p style="margin-top: 1em">suspend-on-sigsegv <br>
This option will suspend the program when a native SIGSEGV
is received. This is useful for debugging crashes which do
not happen under gdb, since a live process <br>
contains more information than a core file.</p>

<p style="margin-top: 1em">suspend-on-exception <br>
This option will suspend the program when an exception
occurs.</p>

<p style="margin-top: 1em">suspend-on-unhandled <br>
This option will suspend the program when an unhandled
exception occurs.</p>

<p style="margin-top: 1em">MONO_LOG_LEVEL <br>
The logging level, possible values are &lsquo;error&rsquo;,
&lsquo;critical&rsquo;, &lsquo;warning&rsquo;,
&lsquo;message&rsquo;, &lsquo;info&rsquo; and
&lsquo;debug&rsquo;. See the DEBUGGING section for more
details.</p>

<p style="margin-top: 1em">MONO_LOG_MASK <br>
Controls the domain of the Mono runtime that logging will
apply to. If set, the log mask is changed to the set value.
Possible values are &quot;asm&quot; (assembly loader),
&quot;type&quot;, <br>
&quot;dll&quot; (native library loader), &quot;gc&quot;
(garbage collector), &quot;cfg&quot; (config file loader),
&quot;aot&quot; (precompiler), &quot;security&quot; (e.g.
Moonlight CoreCLR support) and &quot;all&quot;. The <br>
default value is &quot;all&quot;. Changing the mask value
allows you to display only messages for a certain component.
You can use multiple masks by comma separating them. For
exam&acirc; <br>
ple to see config file messages and assembly loader messages
set you mask to &quot;asm,cfg&quot;.</p>

<p style="margin-top: 1em">MONO_LOG_DEST <br>
Controls where trace log messages are written. If not set
then the messages go to stdout. If set, the string either
specifies a path to a file that will have messages <br>
appended to it, or the string &quot;syslog&quot; in which
case the messages will be written to the system log. Under
Windows, this is simulated by writing to a file called <br>
&quot;mono.log&quot;. MONO_LOG_HEADER Controls whether trace
log messages not directed to syslog have the id, timestamp,
and pid as the prefix to the log message. To enable a <br>
header this environment variable need just be non-null.</p>

<p style="margin-top: 1em">MONO_TRACE <br>
Used for runtime tracing of method calls. The format of the
comma separated trace options is:</p>

<p style="margin-top: 1em">[-]M:method name <br>
[-]N:namespace <br>
[-]T:class name <br>
[-]all <br>
[-]program <br>
disabled Trace output off upon start.</p>

<p style="margin-top: 1em">You can toggle trace output
on/off sending a SIGUSR2 signal to the program.</p>

<p style="margin-top: 1em">MONO_TRACE_LISTENER <br>
If set, enables the System.Diagnostics.DefaultTraceListener,
which will print the output of the System.Diagnostics Trace
and Debug classes. It can be set to a filename, <br>
and to Console.Out or Console.Error to display output to
standard output or standard error, respectively. If
it&rsquo;s set to Console.Out or Console.Error you can
append an <br>
optional prefix that will be used when writing messages like
this: Console.Error:MyProgramName. See the
System.Diagnostics.DefaultTraceListener documentation for
more <br>
information.</p>

<p style="margin-top: 1em">MONO_WCF_TRACE <br>
This eases WCF diagnostics functionality by simply outputs
all log messages from WCF engine to &quot;stdout&quot;,
&quot;stderr&quot; or any file passed to this environment
variable. The log <br>
format is the same as usual diagnostic output.</p>

<p style="margin-top: 1em">MONO_XEXCEPTIONS <br>
This throws an exception when a X11 error is encountered; by
default a message is displayed but execution continues</p>

<p style="margin-top: 1em">MONO_XMLSERIALIZER_DEBUG <br>
Set this value to 1 to prevent the serializer from removing
the temporary files that are created for fast serialization;
This might be useful when debugging.</p>

<p style="margin-top: 1em">MONO_XSYNC <br>
This is used in the System.Windows.Forms implementation when
running with the X11 backend. This is used to debug problems
in Windows.Forms as it forces all of the com&acirc; <br>
mands send to X11 server to be done synchronously. The
default mode of operation is asynchronous which makes it
hard to isolate the root of certain problems.</p>

<p style="margin-top: 1em">MONO_XDEBUG <br>
When the the MONO_XDEBUG env var is set, debugging info for
JITted code is emitted into a shared library, loadable into
gdb. This enables, for example, to see managed <br>
frame names on gdb backtraces.</p>

<p style="margin-top: 1em">MONO_VERBOSE_METHOD <br>
Enables the maximum JIT verbosity for the specified method.
This is very helpfull to diagnose a miscompilation problems
of a specific method.</p>

<p style="margin-top: 1em">MONO_JIT_DUMP_METHOD <br>
Enables sending of the JITs intermediate representation for
a specified method to the IdealGraphVisualizer tool.</p>

<p style="margin-top: 1em">MONO_VERBOSE_HWCAP <br>
If set, makes the JIT output information about detected CPU
features (such as SSE, CMOV, FCMOV, etc) to stdout.</p>

<p style="margin-top: 1em">MONO_CONSERVATIVE_HWCAP <br>
If set, the JIT will not perform any hardware capability
detection. This may be useful to pinpoint the cause of JIT
issues. This is the default when Mono is built as an <br>
AOT cross compiler, so that the generated code will run on
most hardware.</p>

<p style="margin-top: 1em">VALGRIND <br>
If you want to use Valgrind, you will find the file
&lsquo;mono.supp&rsquo; useful, it contains the suppressions
for the GC which trigger incorrect warnings. Use it like
this: <br>
valgrind --suppressions=mono.supp mono ...</p>

<p style="margin-top: 1em">DTRACE <br>
On some platforms, Mono can expose a set of DTrace probes
(also known as user-land statically defined, USDT
Probes).</p>

<p style="margin-top: 1em">They are defined in the file
&lsquo;mono.d&rsquo;.</p>

<p style="margin-top: 1em">ves-init-begin, ves-init-end
<br>
Begin and end of runtime initialization.</p>

<p style="margin-top: 1em">method-compile-begin,
method-compile-end <br>
Begin and end of method compilation. The probe arguments are
class name, method name and signature, and in case of
method-compile-end success or failure of compilation.</p>

<p style="margin-top: 1em">gc-begin, gc-end <br>
Begin and end of Garbage Collection.</p>

<p style="margin-top: 1em">To verify the availability of
the probes, run: <br>
dtrace -P mono&rsquo;$target&rsquo; -l -c mono</p>

<p style="margin-top: 1em">PERMISSIONS <br>
Mono&rsquo;s Ping implementation for detecting network
reachability can create the ICMP packets itself without
requiring the system ping command to do the work. If you
want to enable <br>
this on Linux for non-root users, you need to give the Mono
binary special permissions.</p>

<p style="margin-top: 1em">As root, run this command: <br>
# setcap cap_net_raw=+ep /usr/bin/mono</p>

<p style="margin-top: 1em">FILES <br>
On Unix assemblies are loaded from the installation lib
directory. If you set &lsquo;prefix&rsquo; to /usr, the
assemblies will be located in /usr/lib. On Windows, the
assemblies are <br>
loaded from the directory where mono and mint live.</p>

<p style="margin-top: 1em">~/.mono/aot-cache <br>
The directory for the ahead-of-time compiler demand creation
assemblies are located.</p>

<p style="margin-top: 1em">/etc/mono/config, ~/.mono/config
<br>
Mono runtime configuration file. See the mono-config(5)
manual page for more information.</p>

<p style="margin-top: 1em">~/.config/.mono/certs,
/usr/share/.mono/certs <br>
Contains Mono certificate stores for users / machine. See
the certmgr(1) manual page for more information on managing
certificate stores and the mozroots(1) page for <br>
information on how to import the Mozilla root certificates
into the Mono certificate store.</p>


<p style="margin-top: 1em">~/.mono/assemblies/ASSEMBLY/ASSEMBLY.config
<br>
Files in this directory allow a user to customize the
configuration for a given system assembly, the format is the
one described in the mono-config(5) page.</p>

<p style="margin-top: 1em">~/.config/.mono/keypairs,
/usr/share/.mono/keypairs <br>
Contains Mono cryptographic keypairs for users / machine.
They can be accessed by using a CspParameters object with
DSACryptoServiceProvider and RSACryptoServiceProvider <br>
classes.</p>

<p style="margin-top: 1em">~/.config/.isolatedstorage,
~/.local/share/.isolatedstorage, /usr/share/.isolatedstorage
<br>
Contains Mono isolated storage for non-roaming users,
roaming users and local machine. Isolated storage can be
accessed using the classes from the
System.IO.IsolatedStor&acirc; <br>
age namespace.</p>

<p style="margin-top: 1em">&lt;assembly&gt;.config <br>
Configuration information for individual assemblies is
loaded by the runtime from side-by-side files with the
.config files, see the http://www.mono-project.com/Config
for <br>
more information.</p>

<p style="margin-top: 1em">Web.config, web.config <br>
ASP.NET applications are configured through these files, the
configuration is done on a per-directory basis. For more
information on this subject see the http://www.mono- <br>
project.com/Config_system.web page.</p>

<p style="margin-top: 1em">MAILING LISTS <br>
Mailing lists are listed at the
http://www.mono-project.com/community/help/mailing-lists/</p>

<p style="margin-top: 1em">WEB SITE <br>
http://www.mono-project.com</p>

<p style="margin-top: 1em">SEE ALSO <br>
certmgr(1), csharp(1), mcs(1), mdb(1), monocov(1),
monodis(1), mono-config(5), mozroots(1), mprof-report(1),
pdb2mdb(1), xsp(1), mod_mono(8).</p>

<p style="margin-top: 1em">For more information on AOT:
http://www.mono-project.com/docs/advanced/aot/</p>

<p style="margin-top: 1em">For ASP.NET-related
documentation, see the xsp(1) manual page</p>

<p style="margin-top: 1em">Mono(Mono 4.7.0)</p>
<hr>
</body>
</html>
