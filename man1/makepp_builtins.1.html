<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>MAKEPP_BUILTINS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MAKEPP_BUILTINS(1)</td>
    <td class="head-vol">Makepp</td>
    <td class="head-rtitle">MAKEPP_BUILTINS(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
makepp_builtins -- Builtin commands in makepp
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>A:</b>&#x00A0;<i>awk</i>,&#x00A0; <b>C:</b>&#x00A0;&amp;cat,
<br/>
 <i>chgrp</i>,
<br/>
 &amp;chmod,
<br/>
 <i>chown</i>,
<br/>
 &amp;cp,
<br/>
 <i>cpp</i>,
<br/>
 &amp;cut,&#x00A0; <b>D:</b>&#x00A0;<i>date</i>,&#x00A0;
  <b>E:</b>&#x00A0;&amp;echo,
<br/>
 &amp;expr,&#x00A0; <b>F:</b>&#x00A0;<i>false</i>,
<br/>
 <i>fmt</i>,&#x00A0; <b>G:</b>&#x00A0;&amp;grep,&#x00A0;
  <b>H:</b>&#x00A0;<i>head</i>,&#x00A0; <b>I:</b>&#x00A0;&amp;install,&#x00A0;
  <b>L:</b>&#x00A0;&amp;ln,&#x00A0; <b>M:</b>&#x00A0;<i>m4</i>,
<br/>
 &amp;mkdir,
<br/>
 &amp;mv,&#x00A0; <b>P:</b>&#x00A0;&amp;perl,
<br/>
 &amp;preprocess,
<br/>
 &amp;printf,&#x00A0; <b>R:</b>&#x00A0;&amp;rm,
<br/>
 <i>rmdir</i>,&#x00A0; <b>S:</b>&#x00A0;&amp;sed,
<br/>
 &amp;sort,&#x00A0; <b>T:</b>&#x00A0;<i>tail</i>,
<br/>
 &amp;template,
<br/>
 &amp;touch,
<br/>
 <i>tr</i>,&#x00A0; <b>U:</b>&#x00A0;&amp;uninstall,
<br/>
 &amp;uniq,&#x00A0; <b>Y:</b>&#x00A0;&amp;yes
<div class="Pp"></div>
There is a special Shell-like possibility to call built-in commands in a rule.
  The only metacharacters recognized are comment signs, backslashes, single and
  double quotes. Only one command may be given per line, and I/O redirection is
  not available (see &quot;-i&quot; and &quot;-o&quot; below instead).
<div class="Pp"></div>
These commands start with &quot;&amp;&quot;, which is the function character in
  Perl and not a valid first character in Shell. If no builtin command of that
  name can be found, this is also the syntax for calling an external script
  within the Perl instance performing the rule. See &quot;run&quot;.
<div class="Pp"></div>
These commands, as well as your self defined ones and Perl scripts can also be
  called as a make function, returning the standard output. This requires perl
  to be built for PerlIO. The newlines are converted to spaces, except when
  evaluated within a &quot;define&quot; statement.
<div class="Pp"></div>
<pre>
    FIRST-WORDS ;= $(&amp;cut -d' ' -f0 $(FILES))
</pre>
<div class="Pp"></div>
When these commands are not indented as rule actions, they get performed while
  reading the makefile. You can also access these commands stand-alone, e.g. if
  you need some features not available in the Unix counterpart, via the
  makeppbuiltin command.
<div class="Pp"></div>
These commands are mostly based on the GNU variant. But many options (like
  --backup, --interactive or --recursive) don't really make sense in a makefile.
  So, even though they'd be easy to implement in Perl, they have been left out.
  Also many Unix commands offer a variety of options that cover fairly
  complicated cases (e.g. sort field specifications) while still being
  inherently limited. Allowing access to Perl, which is present anyway, gives
  much more power here.
<div class="Pp"></div>
Lists of filenames may be empty, making it safe to call these commands with an
  unchecked list. Options in their short form may be glued together as in
  &quot;-ab&quot; instead of &quot;-a -b&quot;. In the long form arguments may
  be given either glued on with an &quot;=&quot; sign or separately. In the
  short form they may be given either glued on directly or separately.
<h2 class="Ss" title="Ss" id="Standard_options"><a class="selflink" href="#Standard_options">Standard
  options</a></h2>
A few options are common to several builtins, though the short form is sometimes
  hidden by a command's own option (as in &quot;&amp;cut -f&quot;):
<dl class="Bl-tag">
  <dt class="It-tag">-A <i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--args-file=<i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--arguments-file=<i>filename</i></dt>
  <dd class="It-tag">Read the file and parse it as possibly quoted whitespace-
      and/or newline-separated options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-f</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--force</dt>
  <dd class="It-tag">Force the creation of the file(s) intended by the
      parameters, even if a different kind of file or empty directory of that
      name already exists. This must precede the &quot;-o,
      --output=filename&quot; option if it is to have any effect on that.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-i <i>shellcommand</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--inpipe=<i>shellcommand</i></dt>
  <dd class="It-tag">Start the Shell command(s) and pipe the output into the
      builtin. There may optionally be a trailing &quot;|&quot; character, to
      indicate this is a pipe. With this option no filenames need to be given.
      But if you want to perform the builtin on both files and the pipe output,
      you must use &quot;-&quot; as a filename for the pipe output. The pipe is
      emptied, but, unless you also give &quot;--infail&quot;, the command is
      not waited for, so it can terminate in parallel. This option is necessary
      because there is no redirection syntax.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-I</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--infail</dt>
  <dd class="It-tag">If an &quot;--inpipe&quot; Shell command fails, that also
      causes the current builtin to fail. This doesn't currently work on
      Strawberry and Win ActiveState, because of the halfhearted way they
      emulate Unix fork/exec. Cygwin gets it right though.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-o <i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--output=<i>filename</i></dt>
  <dd class="It-tag">Write the output to this file, rather than stdout. Filename
      may have any of these forms:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&gt;<i>filename</i></dt>
  <dd class="It-tag">Simply write to file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&gt;&gt;<i>filename</i></dt>
  <dd class="It-tag">Append to (not necessarily) existing file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">+&lt;<i>filename</i></dt>
  <dd class="It-tag">Also open the file for input, allowing inplace editing.
      With this option variant no input filenames need to be given. But if you
      want to perform the builtin on more files, you must use &quot;-&quot; as
      an input filename for this one. In fact the output gets written to a
      temporary file which gets moved to filename at the end.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">|<i>shellcommand</i></dt>
  <dd class="It-tag">Pipe the builtin's output to the Shell command(s).</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
This option is necessary because there is no redirection syntax.</div>
<dl class="Bl-tag">
  <dt class="It-tag">-O</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--outfail</dt>
  <dd class="It-tag">If an &quot;--output&quot; Shell command fails, that also
      causes the current builtin to fail.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-r <i>number</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--record-size=<i>number</i></dt>
  <dd class="It-tag">Locally sets $/ for the current builtin. This splits input
      into records of length <i>number</i> rather than line by line. If
      <i>number</i> is zero, each input file as a whole is one record.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s <i>string</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--separator=<i>string</i></dt>
  <dd class="It-tag">Locally sets $/ for the current builtin. This splits input
      on <i>string</i> rather than line by line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-S</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--synclines</dt>
  <dd class="It-tag">Generate &quot;#line
      &quot;<i></i><i>&quot;NO&quot;</i><i></i>&quot; &quot;&quot;
      <i></i><i>&quot;FILE&quot;</i> <i></i>&quot;&quot;&quot; and &quot;#line
      &quot; <i></i><i>&quot;NO&quot;</i><i></i> lines, understood by many
      C-like languages.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-v</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--verbose</dt>
  <dd class="It-tag">Document the changes to the file system. This must precede
      other options if it is to document their effect. If you pass this option
      to makepp itself, it is as if you had given it for every single builtin
      command.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Builtin_commands"><a class="selflink" href="#Builtin_commands">Builtin
  commands</a></h2>
There are two motivations for having builtin commands in makepp. The first is to
  offer a set of utilities, which, unlike Shell commands, are guaranteed to work
  the same everywhere, like &quot;&amp;echo -n&quot; or &quot;&amp;mkdir
  -p&quot;, and saving you the hassle of finding the path to &amp;install and
  figuring out its wildly varying options. In a compilation environment, it's
  useful to have the &quot;--synclines&quot; option, which normally only
  &quot;m4&quot; provides, on all filters.
<div class="Pp"></div>
The other is a question of efficiency. In general costly fork/execs should be
  avoided where reasonably possible. On Unix emulations like Cygwin or
  BS2000/Posix, this becomes a noticeable win. But, even on Linux, when the
  makepp test suite was converted from external commands to builtins, there was
  an overall saving of 3% user CPU usage and 15% system CPU usage. (The tests
  are of course heavy on primitive actions and hardly call the compiler.)
<div class="Pp"></div>
Consistency is also an issue, though we're not going to reform Unix. Normally
  commands have various nuances of regular expressions. And many invent sort of
  languages, each different of course, for doing something (e.g.
  &quot;expr&quot;, &quot;sed&quot; ...), or complex options for specifying
  fields, delimiters, columns (e.g. &quot;cut&quot;, &quot;sort&quot; ...).
<div class="Pp"></div>
Here instead, anything fancy simply gets handled by Perl, giving both
  consistency across all commands, and far more power than a whole bunch of
  options. Better yet, any <i>Perlcode</i> these commands run for you, gets run
  in the package of the Makefile. So, rather than stuff Perl code into the rule
  action, you can define functions and variables and use them within the
  commands:
<div class="Pp"></div>
<pre>
    sub my_filter {
      # Return true iff $_ is desirable
    }
    %.out: %.in Makeppfile
        &amp;grep &amp;my_filter $(input) -o $(output)
</pre>
<div class="Pp"></div>
If you use Perl functions or variables in your commands, makepp does not
  recognize this as a dependency. It is generally safer to tell makepp
  everything, so rules which use Perl elements should depend on the makefile or
  module providing those elements, as shown in the above example.
<div class="Pp"></div>
On the other hand ignorance may be desirable if you have a program that mixes
  programmatic and configuration aspects in one file. An example would be a WSDL
  file containing both a web service interface definition and an IP address. You
  could preprocess this file with the &amp;template command to patch in the
  configuration, but not let makepp notice.
<dl class="Bl-tag">
  <dt class="It-tag">&amp;cat <i>[option ...] filename ...</i></dt>
  <dd class="It-tag">Concatenates all the files into a single one.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -f, --force, -i, --inpipe=shellcommand, -I,
      --infail, -o, --output=filename, -O, --outfail, -S, --synclines, -v,
      --verbose&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;chmod <i>[option ...] mode filename ...</i></dt>
  <dd class="It-tag">Sets <i>mode</i> for all given files. Mode must be an octal
      string.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -v, --verbose&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;cp <i>[option ...] sourcefile destfile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;cp <i>[option ...] sourcefile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;cp <i>[option ...] sourcefile ... destdir</i></dt>
  <dd class="It-tag">Copy <i>sourcefile</i> to <i>destfile</i>, one
      <i>sourcefile</i> to current directory or multiple <i>sourcefile</i>s to
      <i>destdir</i> with the same name.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -f, --force, -v, --verbose&quot;</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-l</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--link</dt>
  <dd class="It-tag">Try to link the files. If that fails, try symbolic link, if
      that is also requested, else copy.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symbolic</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symbolic-link</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symlink</dt>
  <dd class="It-tag">Try to symbolically link the files. If that fails,
    copy.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
See the note under &amp;ln.</div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;cut <i>[option ...] filename ...</i></dt>
  <dd class="It-tag">Print selected parts of lines from each file or selected
      lines, counting across all files. The output is separated by the delimiter
      which defaults to TAB for fields and empty string for characters.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, --force, -i, --inpipe=shellcommand, -I,
      --infail, -o, --output=filename, -O, --outfail, -r, --record-size=number,
      --separator=string, -S, --synclines, -v, --verbose&quot;</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-c <i>list</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--characters=<i>list</i></dt>
  <dd class="It-tag">Print all the characters specified by <i>list</i>.
      <i>List</i> may be any Perl expression returning a list of integers. The
      integers can be either positive, starting at zero to count from the
      beginning, or negative to count from the end. Unlike Unix &quot;cut&quot;,
      the order you request is respected.
    <div style="height: 1.00em;">&#x00A0;</div>
    Unlike in Perl's slice operator where a &quot;..&quot; range must be either
      positive or negative, &amp;cut allows starting with a positive and ending
      with a negative. But this is only available if your expression consists
      only of numbers, commas and &quot;..&quot;. E.g. &quot;1..-2&quot; means
      everything but the first (0) and the last (-1).
    <div style="height: 1.00em;">&#x00A0;</div>
    The list expression can look at the whole line in $_. Changes to that will
      be ignored, however, because when this expression is evaluated the line
      has already been split to Perl's autosplit variable @::F. The numbers you
      return are in fact indices to that list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-d <i>string</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--delimiter=<i>string</i></dt>
  <dd class="It-tag">Set a new delimiter for input fields and output. Unlike
      Unix &quot;cut&quot;, this may have any length.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-E</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--noescape</dt>
  <dd class="It-tag">Treat &quot;\&quot; as normal literals for &quot;-p,
      --printf=format&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-f <i>list</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--fields=<i>list</i></dt>
  <dd class="It-tag">Print all the groups specified by <i>list</i>. <i>List</i>
      is as described under &quot;-c, --characters=list&quot;. Note that this
      hides the standard option &quot;-f&quot; which must be given as
      &quot;--force&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-l <i>list</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--lines=<i>list</i></dt>
  <dd class="It-tag">Print all the lines specified by <i>list</i>. <i>List</i>
      is as described under &quot;-c, --characters=list&quot; with one major
      difference: The first line has number 1, there is no line 0. This is
      definitely inefficient for big files, if you have a mixed positive to
      negative range in your list, as it reads everything to memory. Otherwise
      Perl could optimize this, but I don't know if it does.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-m</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--matching</dt>
  <dd class="It-tag">Print only matching lines, i.e. ones which have enough
      characters or fields. This implies &quot;--only-delimited&quot;, which is
      why you will miss single-field lines with &quot;--fields=0&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-p <i>format</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--printf=<i>format</i></dt>
  <dd class="It-tag">Apply format (with \escapes) to all fields or
    characters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--only-delimited</dt>
  <dd class="It-tag">Print only lines containing delimiters.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    &amp;cut -c 10-20,-5,25- $(input)
    &amp;cut -c 'grep $$_ % 3, 0..99' $(input) # 1st 100 columns not multiple of 3
    &amp;cut -d: --fields 0,4 --printf='%10s is %s\n' /etc/passwd
</pre>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;echo <i>[option ...] string ...</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;printf <i>[option ...] format argument ...</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;yes <i>[option ...] string ...</i></dt>
  <dd class="It-tag">Writes all strings to stdout or the given outfile. Both
      &amp;echo and &amp;yes add a newline at the end. The strings, or for
      &amp;printf the format, may contain &quot;\&quot; escapes, as they are
      known from C or modern Unix or Shell &quot;echo&quot;. They are however as
      in Perl double-quotes, which means some differences, like that a single
      trailing &quot;\&quot; is not allowed. Perl has a few more interesting
      escapes, but the ones you might expect to do something different are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">\cA</dt>
  <dd class="It-tag">Is a control character ^A.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\u</dt>
  <dd class="It-tag">Upcases the following letter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\U</dt>
  <dd class="It-tag">Upcases the rest, or up to the next &quot;\E&quot; or
      &quot;\L&quot; if found.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\x<i>HH</i>, \x{<i>HHHH</i>}</dt>
  <dd class="It-tag">Is the character value of the given Hex code. Note that
      numeric codes are not portable to EBCDIC platforms!</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Unlike Unix &quot;yes&quot;, &amp;yes is exactly like &amp;echo, except that it
  repeats the output for as long as it can, typically until an &quot;--output '|
  <i>command</i>'&quot; terminates. And, if &amp;yes has no arguments, it
  defaults to &quot;y&quot;.
<div style="height: 1.00em;">&#x00A0;</div>
&quot;Standard options&quot;: &quot;-A, --args-file, --arguments-file=filename,
  -f, --force, -o, --output=filename, -O, --outfail, -v, --verbose&quot;
<dl class="Bl-tag">
  <dt class="It-tag">-E</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--noescape</dt>
  <dd class="It-tag">Treat &quot;\&quot; as normal literals.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-n</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--nonewline</dt>
  <dd class="It-tag">Do not add a newline after the last string. (Not understood
      by &amp;printf.)</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;expr <i>[option ...] perlcode ...</i></dt>
  <dd class="It-tag">Print the scalar value of perlcode, which may be written as
      one or several arguments. Note that builtin commands are not parsed by the
      Shell, so &quot;*&quot;, &quot;(&quot; or &quot;&gt;&quot; are not
      special. But string quotes are parsed by makepp, so Perl strings must be
      quoted twice, unless you want to use barewords. If the value is false,
      this fails. Note that -- unlike in Unix &quot;expr&quot; -- Perl's index
      function starts at 0 (false) and returns -1 (true) for failure.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -f, --force, -o, --output=filename, -O,
      --outfail, -v, --verbose&quot;</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-n</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--nonewline</dt>
  <dd class="It-tag">Do not add a newline after the output.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    &amp;expr ($(VAR) - 3) * 2 &lt; 1 &amp;&amp; -1 || 1
    &amp;expr &quot;$(VAR) - 3 * 2 &lt; 1 ? 'joy' : 'sorrow'&quot; -o $(output)
    -&amp;expr $(VAR) - 3 * 2 -o &gt;&gt;$(output)
</pre>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;grep <i>[option ...] perlcode filename ...</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;perl <i>[option ...] perlcode filename ...</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;sed <i>[option ...] perlcode filename ...</i></dt>
  <dd class="It-tag">All the files get read line by line (unless you gave a
      &quot;--separator&quot; option), and <i>perlcode</i> gets evaluated for
      each line, before it gets printed. &amp;sed is similar to &quot;perl
      -pe&quot;, while &amp;grep only outputs those lines for which
      <i>perlcode</i> returns a true value. &amp;perl is similar to &quot;perl
      -ne&quot;, only outputting whatever you explicitly print in the
      <i>perlcode</i>. The line content is available in $_, which may be
      modified.
    <div style="height: 1.00em;">&#x00A0;</div>
    Of these three, only &amp;grep will fail if it outputs nothing. Note that
      there is no ignore-case option, since you would do that with &quot;/
      <i>regexp</i>/i&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -f, --force, -i, --inpipe=shellcommand, -I,
      --infail, -o, --output=filename, -O, --outfail, -r, --record-size=number,
      -s, --separator=string, -S, --synclines, --verbose&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    The option &quot;--synclines&quot; only makes sence with &amp;perl if you
      use &amp;Mpp::Cmds::print to output $_. Only &amp;grep has extra
    options:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-c</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--count</dt>
  <dd class="It-tag">Suppress normal output; instead print a count of matching
      lines. With the &quot;-v, --invert-match&quot; option (see below), count
      non-matching lines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-l</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--list</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--files-with-matches</dt>
  <dd class="It-tag">Output only the name of those files with matches. When this
      is combined with &quot;-v, --invert-match&quot;, output the name of files
      with lines that don't match (a bit absurdly but compatible with Unix -vl).
      When this is combined with a doubled &quot;-vv&quot;, output the name of
      files with no matches.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-v</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--vice-versa</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--revert-match</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--invert-match</dt>
  <dd class="It-tag">Invert the sense of matching, to select non-matching lines.
      Note that this hides the standard option &quot;-v&quot; which must be
      given as &quot;--verbose&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-w <i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--waste-file=<i>filename</i></dt>
  <dd class="It-tag">An optional waste basket for collecting the rejected lines.
      This is not only for debugging your selection code, but also for splitting
      your input in two. As with the normal output, you may modify $_ before
      returning false.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    &amp;sed s/foo/bar/ f1 f2 f3 -o outfile # like sed s/foo/bar/ f1 f2 f3 &gt;outfile
    &amp;sed '$$_ = uc' f1 f2 f3 -o outfile # like tr '[:lower:]' '[:upper:]' f1 f2 f3
    &amp;grep '$$. % 3' f1 f2 f3 -o outfile # eliminate every 3rd line
    &amp;grep -c /match/i f1 f2 f3          # count the lines matching 'match' to STDOUT
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Without pushing you to mass generate accessors, here's how you could do it by
  simply putting a comment of RO or RW between each type and desired variable
  name, all on one line. The generated getter and optionally setter methods go
  into the next found public or protected section:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    # Create get and maybe set method from &quot;type /* R[OW] */ member;&quot;.
    sub cxx_accessors {
      $acc ||= '';              # Candidate for 5.10.0 state
      if( m!^\s*(.+?)\s*/\*\s*R([OW])\s*\*/\s*(.+?)\s*;! ) {
        $acc .= &quot;#line $.\n&quot;;   # Tell C++ where this came from
        $acc .= &quot;void set\u$3( const $1 &amp;__tmp ) { $3 = __tmp; }&quot;
          if $2 eq 'W';
        $acc .= &quot;const $1 &amp;get\u$3() const { return $3; }\n&quot;;
      } elsif( /^\s*(?:public|protected)\s*:/ ) {
        $_ .= $acc;
        $acc = '';
      }
    }
 
    %.cc: %.cc.in               # Use &amp;sed for I/O handling
        &amp;sed --sync-lines &amp;cxx_accessors $(input) -o $(output)
</pre>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;install <i>[option ...] sourcefile destfile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;install <i>[option ...] sourcefile ...
    destdir</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;install --directory <i>[option ...] directory
    ...</i></dt>
  <dd class="It-tag">Move or rename <i>sourcefile</i> to <i>destfile</i>, or
      multiple <i>sourcefile</i>s to <i>destdir</i> with the same name. This is
      the preferred way of transferring build results to their final
      installation locations.
    <div style="height: 1.00em;">&#x00A0;</div>
    Every file system modification performed by &amp;install gets logged to the
      end of the file pointed to by the environment variable $INSTALL_LOG, or,
      if that is not set but we are under a directory with a
      <i>RootMakeppfile(.mk)</i>, to a file of <i>.install_log</i> in that
      directory, or else to that file in the current directory. You may want to
      delete the logfile before a series of &amp;install invocations.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -v, --verbose&quot;</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-c</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--copy</dt>
  <dd class="It-tag">Copy the files rather than moving them. This is preferable,
      as it doesn't force makepp to rebuild the file next time. But it is not
      the default, for compatibility with other install programs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-d</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--directory</dt>
  <dd class="It-tag">In the third form form of this command create all the given
      directories and any necessary parent directories.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-g <i>group</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--group=<i>group</i></dt>
  <dd class="It-tag">Change the group ownership of the destination files. The
      group may be given by name or numerically.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-l</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--link</dt>
  <dd class="It-tag">Try to link the files. If that fails, copy.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--log=<i>filename</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--logfile=<i>filename</i></dt>
  <dd class="It-tag">Use <i>filename</i> instead of normal logfile.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-m <i>mode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--mode=<i>mode</i></dt>
  <dd class="It-tag">Sets <i>mode</i> for all destination files or directories.
      Mode must be an octal string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-o <i>owner</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--owner=<i>owner</i></dt>
  <dd class="It-tag">Change the ownership of the destination files. The owner
      may be given by name or numerically.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-r</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--resolve</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--resolve-symbolic</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--resolve-symbolic-link</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--resolve-symlink</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-S</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symbolic</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symbolic-link</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symlink</dt>
  <dd class="It-tag">Creates symbolic links instead of moving. These options are
      passed to &amp;ln and are described there.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--strip</dt>
  <dd class="It-tag">Calls the &quot;strip&quot; utility, which must be in the
      $PATH, on the destination files.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;ln <i>[option ...] sourcefile destfile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;ln <i>[option ...] sourcefile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;ln <i>[option ...] sourcefile ... destdir</i></dt>
  <dd class="It-tag">Link <i>sourcefile</i> to <i>destfile</i>, one
      <i>sourcefile</i> to current directory or multiple <i>sourcefile</i>s to
      <i>destdir</i> with the same name.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -f, --force, -v, --verbose&quot;</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-r</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--resolve</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--resolve-symbolic</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--resolve-symbolic-link</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--resolve-symlink</dt>
  <dd class="It-tag">This is what you always wanted &quot;ln -s&quot; to do.
      Create symbolic rather than hard links, not to the strings specified, but
      really to the given files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symbolic</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symbolic-link</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--symlink</dt>
  <dd class="It-tag">Create symbolic rather than hard links.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<b>Note:</b> On various file or operating systems, this operation is not
  supported. Or it is, e.g. by Cygwin, but not understood by native Windows
  compilers, if you use one. For a makefile you can't change, to get at least
  some sort of result, &amp;ln and &quot;&amp;cp -l -s&quot; can copy the files
  for you instead (not directories though). To achieve this, you need to export
  the following variable before calling makepp:
<dl class="Bl-tag">
  <dt class="It-tag">export MAKEPP_LN_CP=1</dt>
  <dd class="It-tag">&amp;ln --resolve or --symbolic will copy the files instead
      of creating a symbolic link.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">export MAKEPP_LN_CP=2</dt>
  <dd class="It-tag">&amp;ln will copy the files instead of creating a hard
      link.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">export MAKEPP_LN_CP=3</dt>
  <dd class="It-tag">All invocations of &amp;ln will copy the files instead of
      creating either kind of link.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;mkdir <i>[option ...] directory ...</i></dt>
  <dd class="It-tag">Create the directories.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -f, --force, -v, --verbose&quot;</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-m <i>mode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--mode=<i>mode</i></dt>
  <dd class="It-tag">Sets <i>mode</i> for all created directories, irrespective
      of the umask. Mode must be an octal string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-p</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--parent</dt>
  <dd class="It-tag">Also create any necessary parent directories. Ignore
      directory creation failure due to the directory already existing (even if
      it was created concurrently by another process).</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;mv <i>[option ...] sourcefile destfile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;mv <i>[option ...] sourcefile</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;mv <i>[option ...] sourcefile ... destdir</i></dt>
  <dd class="It-tag">Move or rename <i>sourcefile</i> to <i>destfile</i>, one
      <i>sourcefile</i> to current directory or multiple <i>sourcefile</i>s to
      <i>destdir</i> with the same name.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -f, --force, -v, --verbose&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;preprocess <i>[option ...] variable=definition ...
    filename ...</i></dt>
  <dd class="It-tag">This preprocesses the files exactly the same way makepp
      does for makefiles. This is more powerful than &amp;template but
      syntactically not suited to files with lots of &quot;$&quot;-signs, like
      Makefiles or scripts.
    <div style="height: 1.00em;">&#x00A0;</div>
    Conditional statements, as well as the statements
      &quot;include&quot;/&quot;_include&quot; (which here neither build the
      file nor search upwards),
      &quot;perl&quot;/&quot;makeperl&quot;/&quot;perl_begin&quot; or
      &quot;sub&quot;/&quot;makesub&quot;, or any statements you define within
      the file, are processed. Empty and comment lines are eliminated.
    <div style="height: 1.00em;">&#x00A0;</div>
    But, instead of learning build rules, it will output all remaining lines
      after &quot;$(...)&quot; expression expansion. To prevent statement from
      being recognized as such, you can precede them with an empty expression
      &quot;$()&quot;. The same applies to lines you want to stay empty or which
      shall retain a leading comment sign. Likewise, if a trailing backslash is
      not to join a line with the next, put &quot;$()&quot; after it.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    A normal line gets output as is.
    A line with $(MAKEEXPRESSIONS) gets expanded and output.
    ifdef WANTTHIS      # does not get output whether defined or not
    might not get output
    endif
    include some files
    _include some files that might not exist # or -include
    $()include empty expression prevents keyword from being recognized.
    # Comment lines and empty lines get swallowed.
 
    $()# Unless they get masked with an empty expression.
    $()
    Empty expression prevents \$()
    backslash continuation from being recognized.
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    might give:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    A normal line gets output as is.
    A line with whatever gets expanded and output.
    lots of slurped in content here...
    include empty expression prevents keyword from being recognized.
    # Unless they get masked with an empty expression.
 
    Empty expression prevents \
    backslash continuation from being recognized.
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -f, --force, -o, --output=filename, -O,
      --outfail, -S, --synclines, -v, --verbose&quot;</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-a</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--assignment</dt>
  <dd class="It-tag">Also treat assignments within the files as makepp would.
      Alas such lines can't be masked with an empty &quot;$()&quot;, because it
      is legal to construct variable names with expressions. This additionally
      recognizes the statements &quot;define&quot;,
      &quot;export&quot;/&quot;unexport&quot; and &quot;override&quot; (these
      can be masked with &quot;$()&quot;).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-h \\%<i>hash</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--hashref=\\%<i>hash</i></dt>
  <dd class="It-tag">This allows preallocation of the variable values, including
      long ones not easily passed in a command. The passed expression may be any
      Perl code that returns a hash reference. This is merged with any other
      variables passed to the command, including from another
      &quot;--hashref&quot; option.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;rm <i>[option ...] filename ...</i></dt>
  <dd class="It-tag">Delete files if you have directory write permission. This
      is what Unix &quot;rm -f&quot; would delete, since it has a special
      protection for interactive use not needed in a Makefile.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -v, --verbose&quot;</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-f</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--force</dt>
  <dd class="It-tag">This prevents complaining about inexistent files. That is a
      side effect this option has in Unix, and the only one that makes sense
      here.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-m</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--metainfo</dt>
  <dd class="It-tag">In addition to the given files, this also deletes the meta
      information makepp stores about them in the .makepp directory. Thus makepp
      forgets all it ever knew about the given files. If the .makepp directory
      becomes empty after this, it too is deleted.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
This will also delete given directories, but only if they are empty. To
  facilitate this, it will delete directories last, in the order of descending
  depth. So you can use &quot;**&quot; expressions to delete whole hierarchies.
  Here's an example to be found in many top level make files. Note that there is
  a &quot;makeppclean&quot; utility that can do this more efficiently.
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    $(phony cleanold):
        &amp;rm -fm $(only-stale **/*)
 
    $(phony clean): cleanold
        &amp;rm -f $(wildcard **/*.[ao])
 
    $(phony distclean): clean
        &amp;rm -fm $(only-targets **/*)
</pre>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;sort <i>[option ...] filename ...</i></dt>
  <dd class="It-tag">Sorts all files together in lexicographic order. This is
      inefficient for rather big files, because it happens completely in memory.
      It will fail if the combined size of all files exceeds the memory you are
      entitled to.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -f, --force, -i, --inpipe=shellcommand, -I,
      --infail, -o, --output=filename, -O, --outfail, --record-size=number, -s,
      --separator=string, -v, --verbose&quot;</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-c <i>perlcode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--compare=<i>perlcode</i></dt>
  <dd class="It-tag"><i>perlcode</i> represents a Perl sort block, with the two
      sorting candidates in $a and $b.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-n</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--numeric</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--numeric-sort</dt>
  <dd class="It-tag">This sorts sorts numerically on the beginnings of records.
      Leading whitespace is skipped. You can use &quot;--transform&quot; and
      &quot;--detransform&quot; if the numbers are not at the beginning.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-r</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--reverse</dt>
  <dd class="It-tag">Output the results in the reverse order. Note that this
      hides the standard option &quot;-r&quot; which must be given as
      &quot;--record-size&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-t <i>perlcode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--transform=<i>perlcode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-d <i>perlcode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--detransform=<i>perlcode</i></dt>
  <dd class="It-tag">If you have a complex code, sorting gets more and more
      expensive in proportion to the number of records <i>n</i>, because the
      code gets called O( <i>n</i> log(<i>n</i>)) times. To avoid that, you can
      allow Perl to concentrate on sorting, by first modifying the strings, such
      that complicated search criteria extraction happens once per record, and
      modifying them back, once they are sorted.
    <div style="height: 1.00em;">&#x00A0;</div>
    If these options are given, the &quot;--transform&quot; <i>perlcode</i> gets
      mapped to the records in $_ one after another, and can modify them. After
      sorting, the &quot;--detransform&quot; <i>perlcode</i> gets mapped to the
      modified records in $_ one after another, and can modify them back. You
      will usually use neither or both of these options, unless you want to
      output modified lines.
    <div style="height: 1.00em;">&#x00A0;</div>
    Turning the strings into a structure of extracted sort criteria, which your
      &quot;--compare&quot; <i>perlcode</i> can pick up is known as the
      Schwartzian Transform (ST). Packing everything into the string itself, so
      that no &quot;--compare&quot; <i>perlcode</i> is needed, allowing the
      whole sorting to happen without performing expensive Perl code, is known
      as the Guttmann-Rosler Transform (GRT). You can find tips by searching for
      those names on the web.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    # Expensively sort numerical expressions by value ($$ protects $ from makepp expansion)
    &amp;sort --compare 'eval( $$a ) &lt;=&gt; eval( $$b )' $(input) -o &gt;&gt;$(output)
 
    # ST for case insensitive sorting
    &amp;sort -t '[lc, $$_]' -c '$$a-&gt;[0] cmp $$b-&gt;[0]' -d '$$_-&gt;[1]' $(input) -o &gt;&gt;$(output)
 
    # GRT using modification functions defined elsewhere in the Makeppfile
    &amp;sort -t &amp;transform -d &amp;detransform $(input) -o &gt;&gt;$(output)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-u</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--uniq</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--unique</dt>
  <dd class="It-tag">After sorting, eliminate duplicates. These are either
      identical lines, or if the &quot;--compare&quot; option is given, ones
      which that <i>perlcode</i> reports as equivalent.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;template <i>[option ...] macro=definition ... filename
    ...</i></dt>
  <dd class="It-tag">This is a macro preprocessor, not quite as powerful as the
      C preprocessor or &quot;m4&quot;. See &amp;preprocess for a more powerful
      alternative. It was inspired by automake's macro replacement in
      <i>Makefile.am</i> and <i>Makefile.in</i>. But it goes beyond that. Any
      normal text goes through unchanged. Special constructs are by default
      delimited with &quot;@&quot;. They must fit on one line unless you pass
      one of &quot;-r, --record-size&quot; or &quot;--separator&quot;.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">@#<i> comment </i>@</dt>
  <dd class="It-tag">Note that despite borrowing from script &quot;#&quot; line
      end comment syntax, this one is an inline comment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@<i>MACRO</i>@</dt>
  <dd class="It-tag">This construct is replaced by the value of the
      <i>MACRO</i>. Macro names must start with a letter or underscore, followed
      by any number of letters, underscores, minuses or dots. Unlike in makepp
      names, underscore and minus are not equivalent.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@<i>MACRO</i>(<i>arg1,arg2</i>...)@</dt>
  <dd class="It-tag">Like the first one, but parametrized. The args replace $1
      through $9 or &quot;${ <i>number</i>}&quot; in the value. Or, if the value
      is a Perl function, they are passed as normal parameters. The result then
      replaces the whole construct. One level of macro nesting is possible in
      that the args in parenthesis may contain plain &quot;@MACRO@&quot;
      invocations, as in &quot;@f(@x@)@&quot;, where &quot;@x@&quot; gets
      expanded before being replaced into the body of &quot;f&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@include(<i>filename</i>)@</dt>
  <dd class="It-tag">This is the only predefined macro. It is replaced by the
      &amp;template-processed content of the named file. Like all macros this
      can occur in the middle of a line. Alas, because of that, &quot;-S,
      --synclines&quot; ignores the file inclusion, making everything seem to
      come from the including file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@<i>MACRO</i>=<i>definition</i>@</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@<i>MACRO</i>?=<i>definition</i>@</dt>
  <dd class="It-tag">This defines a macro within the file. This is replaced by
      nothing. The second form only takes effect if the macro was not defined,
      presumably on the command line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@<i>MACRO</i> { <i>Perlcode</i> }@</dt>
  <dd class="It-tag">This also defines a macro, the body of which is a Perl sub.
      The arguments, if there are any, get passed in as @_.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@{ <i>Perlcode</i> }@</dt>
  <dd class="It-tag">This runs the <i>Perlcode</i> immediately and gets replaced
      by the return value.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
So far we have only seen one syntax for embedding special things. There is
  another multiline syntax, and both allow a variation to suppress a newline.
  These are the builtin syntaxes (which can be configured by options below).
  Here <i>SPECIAL</i> stands for any of the constructs shown above:
<dl class="Bl-tag">
  <dt class="It-tag">@<i>SPECIAL</i>@</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@<i>SPECIAL</i>@\</dt>
  <dd class="It-tag">This can appear multiply anywhere on a line. The variant
      immediately followed by &quot;\&quot; only works at the end of the line.
      It also replaces the following line break.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@@<i>SPECIAL</i>@@ <i>Normal text</i> @@</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">@@<i>SPECIAL</i>@@ <i>Normal text</i> @@\</dt>
  <dd class="It-tag">This is like the previous one. However the normal text,
      which also gets replaced, can span multiple lines. You can put the special
      parts on comment lines around source code that is only needed in an
      uninstalled script, to be eliminated or replaced during the installation
      process:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    # @@# the next 2 lines will disappear @@
    echo You are running the uninstalled version of this script
    # @@
    # @@REPLAMCENT@@
    echo Something else will be here
    # @@
    </pre>
  </dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
A meaningless example showing the various possibilities:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    @m1=some definition@\
    @m2=foo $1 bar@\
    @middle_of_arg=iddl@\
    @m1@ @m2(m@middle_of_arg@e)@
    @@m2(many lines)@@
    ...
    @@ plain text 1 + 2 = @{ 1 + 2 }@
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
becomes
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    some definition foo middle bar
    foo many lines bar plain text 1 + 2 = 3
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
&quot;Standard options&quot;: &quot;-A, --args-file, --arguments-file=filename,
  -f, --force, -i, --inpipe=shellcommand, -I, --infail, -o, --output=filename,
  -O, --outfail, -r, --record-size=number, --separator=string, -S, --synclines,
  -v, --verbose&quot;
<dl class="Bl-tag">
  <dt class="It-tag">-d</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--defined</dt>
  <dd class="It-tag">Replace only instances of macros which are actually
      defined. Without this option the undefined ones will all be replaced by
      nothing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-h \\%<i>hash</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--hashref=\\%<i>hash</i></dt>
  <dd class="It-tag">This allows preallocation of the macro values, including
      long ones not easily passed in a command. The passed expression may be any
      Perl code that returns a hash reference. This is merged with any other
      macros passed to the command, including from another &quot;--hashref&quot;
      option. A hash value may also be a code reference, in that case the
      function gets called, as with &quot;@macro { <i>Perlcode</i> }@&quot;
      definitions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s <i>/prefix/suffix/</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--simple=<i>/prefix/suffix/</i></dt>
  <dd class="It-tag">Use <i>prefix</i> and <i>suffix</i> before and after
      <i>SPECIAL</i> respectively instead of &quot;@&quot;. The first character
      is the separator and need not be a slash. These values are Perl regexps.
      You must not introduce grouping like &quot;(...)&quot;, but
      &quot;(?:...)&quot; is ok.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-m <i>/prefix/suffix/afterprefix/[aftersuffix/]</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--multiline=<i>/prefix/suffix/afterprefix/[aftersuffix/]</i></dt>
  <dd class="It-tag">Use <i>prefix</i>, <i>suffix</i> and <i>afterprefix</i>
      before and after <i>SPECIAL</i> and at the end of the block respectively
      instead of &quot;@@&quot;. If <i>aftersuffix</i> is also given, the macro
      name must get repeated before it. The first character is the separator and
      need not be a slash. E.g. an XML-ish, to which you must add
      &quot;--defined&quot; if you want to preserve other tags, not defined by
      you:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    --defined --simple=|&lt;|/&gt;| --multiline=|&lt;|&gt;|&lt;/|&gt;|
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Or, better, use processing instructions &quot;&lt;?...?&gt;&quot;, intended
      for such a purpose:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    --defined --simple='|&lt;\?|\?&gt;|'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Or, if you want to combine this with &quot;&amp;entity;&quot; syntax for the
      simple macro replacements (preserving numeric entities
      &quot;&amp;#x263A;&quot; which are not comments):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    --defined --simple='_(?:&amp;(?!#)|&lt;\?)_(?:;|\?&gt;)_'
    </pre>
  </dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;touch <i>[option ...] filename ...</i></dt>
  <dd class="It-tag">Updates the modification and access timestamps of each file
      to now. If the file doesn't exist, it gets created.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -v, --verbose&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;uninstall <i>[option ...] [filename ...]</i></dt>
  <dd class="It-tag">Uninstall files previously installed by &amp;install. The
      <i>filename</i>s are logfiles written by &amp;install. If none are given,
      nor an &quot;--inpipe&quot; option, reads the default logfile of
      &amp;install.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -i, --inpipe=shellcommand, -I, --infail, -v,
      --verbose&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&amp;uniq <i>[option ...] filename ...</i></dt>
  <dd class="It-tag">Discard all but one of successive equal lines.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;Standard options&quot;: &quot;-A, --args-file,
      --arguments-file=filename, -f, --force, -i, --inpipe=shellcommand, -I,
      --infail, -o, --output=filename, -O, --outfail, -r, --record-size=number,
      -s, --separator=string, -S, --synclines, -v, --verbose&quot;</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-c <i>perlcode</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">--compare=<i>perlcode</i></dt>
  <dd class="It-tag">This <i>Perlcode</i> gets the previous and current lines in
      $a and $b and shall return true if it considers the two lines equal.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
    &amp;uniq --compare='lc( $$a ) eq lc $$b' $(inputs) -o $(output)
</pre>
</div>
<h2 class="Ss" title="Ss" id="Emulatable_commands"><a class="selflink" href="#Emulatable_commands">Emulatable
  commands</a></h2>
Various things are not built in, but can be achieved with other commands:
<dl class="Bl-tag">
  <dt class="It-tag">awk</dt>
  <dd class="It-tag">Use &amp;sed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">chgrp</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">chown</dt>
  <dd class="It-tag">These commands are mostly not portable! They will either
      quietly do nothing or fail, depending on the system. Generally only root
      may perform these operations, which is why they are only available through
      the &amp;install command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">cpp</dt>
  <dd class="It-tag">Use &amp;preprocess or &amp;template.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">date</dt>
  <dd class="It-tag">Either of these partially does the same thing:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    &amp;expr localtime
    &amp;expr gmtime
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">false</dt>
  <dd class="It-tag">Use &amp;expr with no argument or 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">head</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">tail</dt>
  <dd class="It-tag">You can achieve the same result with &amp;grep or
      &quot;&amp;cut --lines&quot;:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    &amp;grep 1..10 file            # first ten lines
    &amp;grep 10..eof file          # all lines from tenth onwards
    &amp;cut --lines -10..-1 file   # last ten lines
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that 1..10 in &amp;grep is Perl's line number flip-flop operator, which
      annoyingly starts at 1. Don't start at 0, or the flip-flop will never
      become true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">fmt</dt>
  <dd class="It-tag">This is mentioned here since Perl provides a related
      functionality. However I had problems using the &quot;format&quot;
      declaration in a makefile. What does work is the underlying
      &quot;formline&quot; function. E.g. to transform a csv file consisting of
      names and prices to a tabular format:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    sub csv2txt {
      formline &quot;\@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^###########.##\n&quot;, split ',';
      $_ = $^A;
      $^A = '';
    }
 
    %.txt: %.csv
        &amp;sed &amp;csv2txt $(input) -o $(output)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">m4</dt>
  <dd class="It-tag">Use &amp;preprocess or &amp;template.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">rmdir</dt>
  <dd class="It-tag">Use &amp;rm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">tr</dt>
  <dd class="It-tag">Use &amp;sed.</dd>
</dl>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Daniel Pfeiffer (occitan@esperanto.org)</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-28</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
