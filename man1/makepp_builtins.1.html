<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:23:44 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>MAKEPP_BUILTINS(1) Makepp MAKEPP_BUILTINS(1)</p>

<p style="margin-top: 1em">NAME <br>
makepp_builtins -- Builtin commands in makepp</p>

<p style="margin-top: 1em">DESCRIPTION <br>
A: awk, C: &amp;cat, <br>
chgrp, <br>
&amp;chmod, <br>
chown, <br>
&amp;cp, <br>
cpp, <br>
&amp;cut, D: date, E: &amp;echo, <br>
&amp;expr, F: false, <br>
fmt, G: &amp;grep, H: head, I: &amp;install, L: &amp;ln, M:
m4, <br>
&amp;mkdir, <br>
&amp;mv, P: &amp;perl, <br>
&amp;preprocess, <br>
&amp;printf, R: &amp;rm, <br>
rmdir, S: &amp;sed, <br>
&amp;sort, T: tail, <br>
&amp;template, <br>
&amp;touch, <br>
tr, U: &amp;uninstall, <br>
&amp;uniq, Y: &amp;yes</p>

<p style="margin-top: 1em">There is a special Shell-like
possibility to call built-in commands in a rule. The only
metacharacters recognized are comment signs, backslashes,
single and double quotes. Only <br>
one command may be given per line, and I/O redirection is
not available (see &quot;-i&quot; and &quot;-o&quot; below
instead).</p>

<p style="margin-top: 1em">These commands start with
&quot;&amp;&quot;, which is the function character in Perl
and not a valid first character in Shell. If no builtin
command of that name can be found, this is also <br>
the syntax for calling an external script within the Perl
instance performing the rule. See &quot;run&quot;.</p>

<p style="margin-top: 1em">These commands, as well as your
self defined ones and Perl scripts can also be called as a
make function, returning the standard output. This requires
perl to be built for <br>
PerlIO. The newlines are converted to spaces, except when
evaluated within a &quot;define&quot; statement.</p>

<p style="margin-top: 1em">FIRST-WORDS ;= $(&amp;cut
-d&rsquo; &rsquo; -f0 $(FILES))</p>

<p style="margin-top: 1em">When these commands are not
indented as rule actions, they get performed while reading
the makefile. You can also access these commands
stand-alone, e.g. if you need some <br>
features not available in the Unix counterpart, via the
makeppbuiltin command.</p>

<p style="margin-top: 1em">These commands are mostly based
on the GNU variant. But many options (like --backup,
--interactive or --recursive) don&rsquo;t really make sense
in a makefile. So, even though they&rsquo;d <br>
be easy to implement in Perl, they have been left out. Also
many Unix commands offer a variety of options that cover
fairly complicated cases (e.g. sort field specifications)
<br>
while still being inherently limited. Allowing access to
Perl, which is present anyway, gives much more power
here.</p>

<p style="margin-top: 1em">Lists of filenames may be empty,
making it safe to call these commands with an unchecked
list. Options in their short form may be glued together as
in &quot;-ab&quot; instead of &quot;-a -b&quot;. <br>
In the long form arguments may be given either glued on with
an &quot;=&quot; sign or separately. In the short form they
may be given either glued on directly or separately.</p>

<p style="margin-top: 1em">Standard options <br>
A few options are common to several builtins, though the
short form is sometimes hidden by a command&rsquo;s own
option (as in &quot;&amp;cut -f&quot;):</p>

<p style="margin-top: 1em">-A filename <br>
--args-file=filename <br>
--arguments-file=filename <br>
Read the file and parse it as possibly quoted whitespace-
and/or newline-separated options.</p>

<p style="margin-top: 1em">-f <br>
--force <br>
Force the creation of the file(s) intended by the
parameters, even if a different kind of file or empty
directory of that name already exists. This must precede the
&quot;-o, <br>
--output=filename&quot; option if it is to have any effect
on that.</p>

<p style="margin-top: 1em">-i shellcommand <br>
--inpipe=shellcommand <br>
Start the Shell command(s) and pipe the output into the
builtin. There may optionally be a trailing &quot;|&quot;
character, to indicate this is a pipe. With this option no
filenames <br>
need to be given. But if you want to perform the builtin on
both files and the pipe output, you must use &quot;-&quot;
as a filename for the pipe output. The pipe is emptied, but,
<br>
unless you also give &quot;--infail&quot;, the command is
not waited for, so it can terminate in parallel. This option
is necessary because there is no redirection syntax.</p>

<p style="margin-top: 1em">-I <br>
--infail <br>
If an &quot;--inpipe&quot; Shell command fails, that also
causes the current builtin to fail. This doesn&rsquo;t
currently work on Strawberry and Win ActiveState, because of
the halfhearted <br>
way they emulate Unix fork/exec. Cygwin gets it right
though.</p>

<p style="margin-top: 1em">-o filename <br>
--output=filename <br>
Write the output to this file, rather than stdout. Filename
may have any of these forms:</p>

<p style="margin-top: 1em">filename <br>
&gt;filename <br>
Simply write to file.</p>

<p style="margin-top: 1em">&gt;&gt;filename <br>
Append to (not necessarily) existing file.</p>

<p style="margin-top: 1em">+&lt;filename <br>
Also open the file for input, allowing inplace editing. With
this option variant no input filenames need to be given. But
if you want to perform the builtin on more <br>
files, you must use &quot;-&quot; as an input filename for
this one. In fact the output gets written to a temporary
file which gets moved to filename at the end.</p>

<p style="margin-top: 1em">|shellcommand <br>
Pipe the builtin&rsquo;s output to the Shell command(s).</p>

<p style="margin-top: 1em">This option is necessary because
there is no redirection syntax.</p>

<p style="margin-top: 1em">-O <br>
--outfail <br>
If an &quot;--output&quot; Shell command fails, that also
causes the current builtin to fail.</p>

<p style="margin-top: 1em">-r number <br>
--record-size=number <br>
Locally sets $/ for the current builtin. This splits input
into records of length number rather than line by line. If
number is zero, each input file as a whole is one <br>
record.</p>

<p style="margin-top: 1em">-s string <br>
--separator=string <br>
Locally sets $/ for the current builtin. This splits input
on string rather than line by line.</p>

<p style="margin-top: 1em">-S <br>
--synclines <br>
Generate &quot;#line &quot;&quot;NO&quot;&quot;
&quot;&quot;&quot;FILE&quot;&quot;&quot;&quot; and
&quot;#line &quot;&quot;NO&quot; lines, understood by many
C-like languages.</p>

<p style="margin-top: 1em">-v <br>
--verbose <br>
Document the changes to the file system. This must precede
other options if it is to document their effect. If you pass
this option to makepp itself, it is as if you had <br>
given it for every single builtin command.</p>

<p style="margin-top: 1em">Builtin commands <br>
There are two motivations for having builtin commands in
makepp. The first is to offer a set of utilities, which,
unlike Shell commands, are guaranteed to work the same <br>
everywhere, like &quot;&amp;echo -n&quot; or
&quot;&amp;mkdir -p&quot;, and saving you the hassle of
finding the path to &amp;install and figuring out its wildly
varying options. In a compilation environment, <br>
it&rsquo;s useful to have the &quot;--synclines&quot;
option, which normally only &quot;m4&quot; provides, on all
filters.</p>

<p style="margin-top: 1em">The other is a question of
efficiency. In general costly fork/execs should be avoided
where reasonably possible. On Unix emulations like Cygwin or
BS2000/Posix, this becomes a <br>
noticeable win. But, even on Linux, when the makepp test
suite was converted from external commands to builtins,
there was an overall saving of 3% user CPU usage and 15%
system <br>
CPU usage. (The tests are of course heavy on primitive
actions and hardly call the compiler.)</p>

<p style="margin-top: 1em">Consistency is also an issue,
though we&rsquo;re not going to reform Unix. Normally
commands have various nuances of regular expressions. And
many invent sort of languages, each <br>
different of course, for doing something (e.g.
&quot;expr&quot;, &quot;sed&quot; ...), or complex options
for specifying fields, delimiters, columns (e.g.
&quot;cut&quot;, &quot;sort&quot; ...).</p>

<p style="margin-top: 1em">Here instead, anything fancy
simply gets handled by Perl, giving both consistency across
all commands, and far more power than a whole bunch of
options. Better yet, any Perlcode <br>
these commands run for you, gets run in the package of the
Makefile. So, rather than stuff Perl code into the rule
action, you can define functions and variables and use them
<br>
within the commands:</p>

<p style="margin-top: 1em">sub my_filter { <br>
# Return true iff $_ is desirable <br>
} <br>
%.out: %.in Makeppfile <br>
&amp;grep &amp;my_filter $(input) -o $(output)</p>

<p style="margin-top: 1em">If you use Perl functions or
variables in your commands, makepp does not recognize this
as a dependency. It is generally safer to tell makepp
everything, so rules which use Perl <br>
elements should depend on the makefile or module providing
those elements, as shown in the above example.</p>

<p style="margin-top: 1em">On the other hand ignorance may
be desirable if you have a program that mixes programmatic
and configuration aspects in one file. An example would be a
WSDL file containing both <br>
a web service interface definition and an IP address. You
could preprocess this file with the &amp;template command to
patch in the configuration, but not let makepp notice.</p>

<p style="margin-top: 1em">&amp;cat [option ...] filename
... <br>
Concatenates all the files into a single one.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -i, --inpipe=shellcommand, -I, --infail, -o,
--output=filename, -O, --outfail, -S, --synclines, <br>
-v, --verbose&quot;</p>

<p style="margin-top: 1em">&amp;chmod [option ...] mode
filename ... <br>
Sets mode for all given files. Mode must be an octal
string.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -v,
--verbose&quot;</p>

<p style="margin-top: 1em">&amp;cp [option ...] sourcefile
destfile <br>
&amp;cp [option ...] sourcefile <br>
&amp;cp [option ...] sourcefile ... destdir <br>
Copy sourcefile to destfile, one sourcefile to current
directory or multiple sourcefiles to destdir with the same
name.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -v, --verbose&quot;</p>

<p style="margin-top: 1em">-l <br>
--link <br>
Try to link the files. If that fails, try symbolic link, if
that is also requested, else copy.</p>

<p style="margin-top: 1em">-s <br>
--symbolic <br>
--symbolic-link <br>
--symlink <br>
Try to symbolically link the files. If that fails, copy.</p>

<p style="margin-top: 1em">See the note under &amp;ln.</p>

<p style="margin-top: 1em">&amp;cut [option ...] filename
... <br>
Print selected parts of lines from each file or selected
lines, counting across all files. The output is separated by
the delimiter which defaults to TAB for fields and <br>
empty string for characters.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, --force,
-i, --inpipe=shellcommand, -I, --infail, -o,
--output=filename, -O, --outfail, -r, <br>
--record-size=number, --separator=string, -S, --synclines,
-v, --verbose&quot;</p>

<p style="margin-top: 1em">-c list <br>
--characters=list <br>
Print all the characters specified by list. List may be any
Perl expression returning a list of integers. The integers
can be either positive, starting at zero to count <br>
from the beginning, or negative to count from the end.
Unlike Unix &quot;cut&quot;, the order you request is
respected.</p>

<p style="margin-top: 1em">Unlike in Perl&rsquo;s slice
operator where a &quot;..&quot; range must be either
positive or negative, &amp;cut allows starting with a
positive and ending with a negative. But this is only <br>
available if your expression consists only of numbers,
commas and &quot;..&quot;. E.g. &quot;1..-2&quot; means
everything but the first (0) and the last (-1).</p>

<p style="margin-top: 1em">The list expression can look at
the whole line in $_. Changes to that will be ignored,
however, because when this expression is evaluated the line
has already been split <br>
to Perl&rsquo;s autosplit variable @::F. The numbers you
return are in fact indices to that list.</p>

<p style="margin-top: 1em">-d string <br>
--delimiter=string <br>
Set a new delimiter for input fields and output. Unlike Unix
&quot;cut&quot;, this may have any length.</p>

<p style="margin-top: 1em">-E <br>
--noescape <br>
Treat &quot;</p>

<p style="margin-top: 1em">-f list <br>
--fields=list <br>
Print all the groups specified by list. List is as described
under &quot;-c, --characters=list&quot;. Note that this
hides the standard option &quot;-f&quot; which must be given
as <br>
&quot;--force&quot;.</p>

<p style="margin-top: 1em">-l list <br>
--lines=list <br>
Print all the lines specified by list. List is as described
under &quot;-c, --characters=list&quot; with one major
difference: The first line has number 1, there is no line 0.
<br>
This is definitely inefficient for big files, if you have a
mixed positive to negative range in your list, as it reads
everything to memory. Otherwise Perl could <br>
optimize this, but I don&rsquo;t know if it does.</p>

<p style="margin-top: 1em">-m <br>
--matching <br>
Print only matching lines, i.e. ones which have enough
characters or fields. This implies
&quot;--only-delimited&quot;, which is why you will miss
single-field lines with <br>
&quot;--fields=0&quot;.</p>

<p style="margin-top: 1em">-p format <br>
--printf=format <br>
Apply format (with \scapes) to all fields or characters.</p>

<p style="margin-top: 1em">-s <br>
--only-delimited <br>
Print only lines containing delimiters.</p>

<p style="margin-top: 1em">&amp;cut -c 10-20,-5,25-
$(input) <br>
&amp;cut -c &rsquo;grep $$_ % 3, 0..99&rsquo; $(input) # 1st
100 columns not multiple of 3 <br>
&amp;cut -d: --fields 0,4 --printf=&rsquo;%10s is %s0
/etc/passwd</p>

<p style="margin-top: 1em">&amp;echo [option ...] string
... <br>
&amp;printf [option ...] format argument ... <br>
&amp;yes [option ...] string ... <br>
Writes all strings to stdout or the given outfile. Both
&amp;echo and &amp;yes add a newline at the end. The
strings, or for &amp;printf the format, may contain &quot;
<br>
are known from C or modern Unix or Shell &quot;echo&quot;.
They are however as in Perl double-quotes, which means some
differences, like that a single trailing &quot; <br>
Perl has a few more interesting escapes, but the ones you
might expect to do something different are:</p>

<p style="margin-top: 1em">Upcases the following
letter.</p>

<p style="margin-top: 1em">U Upcases the rest, or up to the
next &quot;</p>

<p style="margin-top: 1em">, HHH} <br>
Is the character value of the given Hex code. Note that
numeric codes are not portable to EBCDIC platforms!</p>

<p style="margin-top: 1em">Unlike Unix &quot;yes&quot;,
&amp;yes is exactly like &amp;echo, except that it repeats
the output for as long as it can, typically until an
&quot;--output &rsquo;| command&rsquo;&quot; terminates.
And, if &amp;yes <br>
has no arguments, it defaults to &quot;y&quot;.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -o, --output=filename, -O, --outfail, -v,
--verbose&quot;</p>

<p style="margin-top: 1em">-E <br>
--noescape <br>
Treat &quot;</p>

<p style="margin-top: 1em">-n <br>
--nonewline <br>
Do not add a newline after the last string. (Not understood
by &amp;printf.)</p>

<p style="margin-top: 1em">&amp;expr [option ...] perlcode
... <br>
Print the scalar value of perlcode, which may be written as
one or several arguments. Note that builtin commands are not
parsed by the Shell, so &quot;*&quot;, &quot;(&quot; or
&quot;&gt;&quot; are not <br>
special. But string quotes are parsed by makepp, so Perl
strings must be quoted twice, unless you want to use
barewords. If the value is false, this fails. Note that --
<br>
unlike in Unix &quot;expr&quot; -- Perl&rsquo;s index
function starts at 0 (false) and returns -1 (true) for
failure.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -o, --output=filename, -O, --outfail, -v,
--verbose&quot;</p>

<p style="margin-top: 1em">-n <br>
--nonewline <br>
Do not add a newline after the output.</p>

<p style="margin-top: 1em">&amp;expr ($(VAR) - 3) * 2 &lt;
1 &amp;&amp; -1 || 1 <br>
&amp;expr &quot;$(VAR) - 3 * 2 &lt; 1 ? &rsquo;joy&rsquo; :
&rsquo;sorrow&rsquo;&quot; -o $(output) <br>
-&amp;expr $(VAR) - 3 * 2 -o &gt;&gt;$(output)</p>

<p style="margin-top: 1em">&amp;grep [option ...] perlcode
filename ... <br>
&amp;perl [option ...] perlcode filename ... <br>
&amp;sed [option ...] perlcode filename ... <br>
All the files get read line by line (unless you gave a
&quot;--separator&quot; option), and perlcode gets evaluated
for each line, before it gets printed. &amp;sed is similar
to &quot;perl <br>
-pe&quot;, while &amp;grep only outputs those lines for
which perlcode returns a true value. &amp;perl is similar to
&quot;perl -ne&quot;, only outputting whatever you
explicitly print in the <br>
perlcode. The line content is available in $_, which may be
modified.</p>

<p style="margin-top: 1em">Of these three, only &amp;grep
will fail if it outputs nothing. Note that there is no
ignore-case option, since you would do that with
&quot;/regexp/i&quot;.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -i, --inpipe=shellcommand, -I, --infail, -o,
--output=filename, -O, --outfail, -r, <br>
--record-size=number, -s, --separator=string, -S,
--synclines, --verbose&quot;</p>

<p style="margin-top: 1em">The option
&quot;--synclines&quot; only makes sence with &amp;perl if
you use &amp;Mpp::Cmds::print to output $_. Only &amp;grep
has extra options:</p>

<p style="margin-top: 1em">-c <br>
--count <br>
Suppress normal output; instead print a count of matching
lines. With the &quot;-v, --invert-match&quot; option (see
below), count non-matching lines.</p>

<p style="margin-top: 1em">-l <br>
--list <br>
--files-with-matches <br>
Output only the name of those files with matches. When this
is combined with &quot;-v, --invert-match&quot;, output the
name of files with lines that don&rsquo;t match (a bit
absurdly <br>
but compatible with Unix -vl). When this is combined with a
doubled &quot;-vv&quot;, output the name of files with no
matches.</p>

<p style="margin-top: 1em">-v <br>
--vice-versa <br>
--revert-match <br>
--invert-match <br>
Invert the sense of matching, to select non-matching lines.
Note that this hides the standard option &quot;-v&quot;
which must be given as &quot;--verbose&quot;.</p>

<p style="margin-top: 1em">-w filename <br>
--waste-file=filename <br>
An optional waste basket for collecting the rejected lines.
This is not only for debugging your selection code, but also
for splitting your input in two. As with the <br>
normal output, you may modify $_ before returning false.</p>

<p style="margin-top: 1em">&amp;sed s/foo/bar/ f1 f2 f3 -o
outfile # like sed s/foo/bar/ f1 f2 f3 &gt;outfile <br>
&amp;sed &rsquo;$$_ = uc&rsquo; f1 f2 f3 -o outfile # like
tr &rsquo;[:lower:]&rsquo; &rsquo;[:upper:]&rsquo; f1 f2 f3
<br>
&amp;grep &rsquo;$$. % 3&rsquo; f1 f2 f3 -o outfile #
eliminate every 3rd line <br>
&amp;grep -c /match/i f1 f2 f3 # count the lines matching
&rsquo;match&rsquo; to STDOUT</p>

<p style="margin-top: 1em">Without pushing you to mass
generate accessors, here&rsquo;s how you could do it by
simply putting a comment of RO or RW between each type and
desired variable name, all on one <br>
line. The generated getter and optionally setter methods go
into the next found public or protected section:</p>

<p style="margin-top: 1em"># Create get and maybe set
method from &quot;type /* R[OW] */ member;&quot;. <br>
sub cxx_accessors { <br>
$acc ||= &rsquo;&rsquo;; # Candidate for 5.10.0 state <br>
if( m!^(.+?)/s*R([OW])(.+?);! ) { <br>
$acc .= &quot;#line $.0; # Tell C++ where this came from
<br>
$acc .= &quot;void set$3( const $1 &amp;__tmp ) { $3 =
__tmp; }&quot; <br>
if $2 eq &rsquo;W&rsquo;; <br>
$acc .= &quot;const $1 &amp;get$3() const { return $3; }0;
<br>
} elsif( /^(?:public|protected):/ ) { <br>
$_ .= $acc; <br>
$acc = &rsquo;&rsquo;; <br>
} <br>
}</p>

<p style="margin-top: 1em">%.cc: %.cc.in # Use &amp;sed for
I/O handling <br>
&amp;sed --sync-lines &amp;cxx_accessors $(input) -o
$(output)</p>

<p style="margin-top: 1em">&amp;install [option ...]
sourcefile destfile <br>
&amp;install [option ...] sourcefile ... destdir <br>
&amp;install --directory [option ...] directory ... <br>
Move or rename sourcefile to destfile, or multiple
sourcefiles to destdir with the same name. This is the
preferred way of transferring build results to their final
<br>
installation locations.</p>

<p style="margin-top: 1em">Every file system modification
performed by &amp;install gets logged to the end of the file
pointed to by the environment variable $INSTALL_LOG, or, if
that is not set but we are <br>
under a directory with a RootMakeppfile(.mk), to a file of
.install_log in that directory, or else to that file in the
current directory. You may want to delete the logfile <br>
before a series of &amp;install invocations.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -v,
--verbose&quot;</p>

<p style="margin-top: 1em">-c <br>
--copy <br>
Copy the files rather than moving them. This is preferable,
as it doesn&rsquo;t force makepp to rebuild the file next
time. But it is not the default, for compatibility with <br>
other install programs.</p>

<p style="margin-top: 1em">-d <br>
--directory <br>
In the third form form of this command create all the given
directories and any necessary parent directories.</p>

<p style="margin-top: 1em">-g group <br>
--group=group <br>
Change the group ownership of the destination files. The
group may be given by name or numerically.</p>

<p style="margin-top: 1em">-l <br>
--link <br>
Try to link the files. If that fails, copy.</p>

<p style="margin-top: 1em">--log=filename <br>
--logfile=filename <br>
Use filename instead of normal logfile.</p>

<p style="margin-top: 1em">-m mode <br>
--mode=mode <br>
Sets mode for all destination files or directories. Mode
must be an octal string.</p>

<p style="margin-top: 1em">-o owner <br>
--owner=owner <br>
Change the ownership of the destination files. The owner may
be given by name or numerically.</p>

<p style="margin-top: 1em">-r <br>
--resolve <br>
--resolve-symbolic <br>
--resolve-symbolic-link <br>
--resolve-symlink <br>
-S <br>
--symbolic <br>
--symbolic-link <br>
--symlink <br>
Creates symbolic links instead of moving. These options are
passed to &amp;ln and are described there.</p>

<p style="margin-top: 1em">-s <br>
--strip <br>
Calls the &quot;strip&quot; utility, which must be in the
$PATH, on the destination files.</p>

<p style="margin-top: 1em">&amp;ln [option ...] sourcefile
destfile <br>
&amp;ln [option ...] sourcefile <br>
&amp;ln [option ...] sourcefile ... destdir <br>
Link sourcefile to destfile, one sourcefile to current
directory or multiple sourcefiles to destdir with the same
name.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -v, --verbose&quot;</p>

<p style="margin-top: 1em">-r <br>
--resolve <br>
--resolve-symbolic <br>
--resolve-symbolic-link <br>
--resolve-symlink <br>
This is what you always wanted &quot;ln -s&quot; to do.
Create symbolic rather than hard links, not to the strings
specified, but really to the given files.</p>

<p style="margin-top: 1em">-s <br>
--symbolic <br>
--symbolic-link <br>
--symlink <br>
Create symbolic rather than hard links.</p>

<p style="margin-top: 1em">Note: On various file or
operating systems, this operation is not supported. Or it
is, e.g. by Cygwin, but not understood by native Windows
compilers, if you use one. For a <br>
makefile you can&rsquo;t change, to get at least some sort
of result, &amp;ln and &quot;&amp;cp -l -s&quot; can copy
the files for you instead (not directories though). To
achieve this, you need to <br>
export the following variable before calling makepp:</p>

<p style="margin-top: 1em">export MAKEPP_LN_CP=1 <br>
&amp;ln --resolve or --symbolic will copy the files instead
of creating a symbolic link.</p>

<p style="margin-top: 1em">export MAKEPP_LN_CP=2 <br>
&amp;ln will copy the files instead of creating a hard
link.</p>

<p style="margin-top: 1em">export MAKEPP_LN_CP=3 <br>
All invocations of &amp;ln will copy the files instead of
creating either kind of link.</p>

<p style="margin-top: 1em">&amp;mkdir [option ...]
directory ... <br>
Create the directories.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -v, --verbose&quot;</p>

<p style="margin-top: 1em">-m mode <br>
--mode=mode <br>
Sets mode for all created directories, irrespective of the
umask. Mode must be an octal string.</p>

<p style="margin-top: 1em">-p <br>
--parent <br>
Also create any necessary parent directories. Ignore
directory creation failure due to the directory already
existing (even if it was created concurrently by another
<br>
process).</p>

<p style="margin-top: 1em">&amp;mv [option ...] sourcefile
destfile <br>
&amp;mv [option ...] sourcefile <br>
&amp;mv [option ...] sourcefile ... destdir <br>
Move or rename sourcefile to destfile, one sourcefile to
current directory or multiple sourcefiles to destdir with
the same name.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -v, --verbose&quot;</p>

<p style="margin-top: 1em">&amp;preprocess [option ...]
variable=definition ... filename ... <br>
This preprocesses the files exactly the same way makepp does
for makefiles. This is more powerful than &amp;template but
syntactically not suited to files with lots of <br>
&quot;$&quot;-signs, like Makefiles or scripts.</p>

<p style="margin-top: 1em">Conditional statements, as well
as the statements &quot;include&quot;/&quot;_include&quot;
(which here neither build the file nor search upwards),
&quot;perl&quot;/&quot;makeperl&quot;/&quot;perl_begin&quot;
or <br>
&quot;sub&quot;/&quot;makesub&quot;, or any statements you
define within the file, are processed. Empty and comment
lines are eliminated.</p>

<p style="margin-top: 1em">But, instead of learning build
rules, it will output all remaining lines after
&quot;$(...)&quot; expression expansion. To prevent
statement from being recognized as such, you can <br>
precede them with an empty expression &quot;$()&quot;. The
same applies to lines you want to stay empty or which shall
retain a leading comment sign. Likewise, if a trailing <br>
backslash is not to join a line with the next, put
&quot;$()&quot; after it.</p>

<p style="margin-top: 1em">A normal line gets output as is.
<br>
A line with $(MAKEEXPRESSIONS) gets expanded and output.
<br>
ifdef WANTTHIS # does not get output whether defined or not
<br>
might not get output <br>
endif <br>
include some files <br>
_include some files that might not exist # or -include <br>
$()include empty expression prevents keyword from being
recognized. <br>
# Comment lines and empty lines get swallowed.</p>

<p style="margin-top: 1em">$()# Unless they get masked with
an empty expression. <br>
$() <br>
Empty expression prevents <br>
backslash continuation from being recognized.</p>

<p style="margin-top: 1em">might give:</p>

<p style="margin-top: 1em">A normal line gets output as is.
<br>
A line with whatever gets expanded and output. <br>
lots of slurped in content here... <br>
include empty expression prevents keyword from being
recognized. <br>
# Unless they get masked with an empty expression.</p>

<p style="margin-top: 1em">Empty expression prevents
backslash continuation from being recognized.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -o, --output=filename, -O, --outfail, -S,
--synclines, -v, --verbose&quot;</p>

<p style="margin-top: 1em">-a <br>
--assignment <br>
Also treat assignments within the files as makepp would.
Alas such lines can&rsquo;t be masked with an empty
&quot;$()&quot;, because it is legal to construct variable
names with <br>
expressions. This additionally recognizes the statements
&quot;define&quot;, &quot;export&quot;/&quot;unexport&quot;
and &quot;override&quot; (these can be masked with
&quot;$()&quot;).</p>

<p style="margin-top: 1em">-h \%hash <br>
--hashref=\%hash <br>
This allows preallocation of the variable values, including
long ones not easily passed in a command. The passed
expression may be any Perl code that returns a hash <br>
reference. This is merged with any other variables passed to
the command, including from another &quot;--hashref&quot;
option.</p>

<p style="margin-top: 1em">&amp;rm [option ...] filename
... <br>
Delete files if you have directory write permission. This is
what Unix &quot;rm -f&quot; would delete, since it has a
special protection for interactive use not needed in a
Makefile.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -v,
--verbose&quot;</p>

<p style="margin-top: 1em">-f <br>
--force <br>
This prevents complaining about inexistent files. That is a
side effect this option has in Unix, and the only one that
makes sense here.</p>

<p style="margin-top: 1em">-m <br>
--metainfo <br>
In addition to the given files, this also deletes the meta
information makepp stores about them in the .makepp
directory. Thus makepp forgets all it ever knew about the
<br>
given files. If the .makepp directory becomes empty after
this, it too is deleted.</p>

<p style="margin-top: 1em">This will also delete given
directories, but only if they are empty. To facilitate this,
it will delete directories last, in the order of descending
depth. So you can use <br>
&quot;**&quot; expressions to delete whole hierarchies.
Here&rsquo;s an example to be found in many top level make
files. Note that there is a &quot;makeppclean&quot; utility
that can do this more <br>
efficiently.</p>

<p style="margin-top: 1em">$(phony cleanold): <br>
&amp;rm -fm $(only-stale **/*)</p>

<p style="margin-top: 1em">$(phony clean): cleanold <br>
&amp;rm -f $(wildcard **/*.[ao])</p>

<p style="margin-top: 1em">$(phony distclean): clean <br>
&amp;rm -fm $(only-targets **/*)</p>

<p style="margin-top: 1em">&amp;sort [option ...] filename
... <br>
Sorts all files together in lexicographic order. This is
inefficient for rather big files, because it happens
completely in memory. It will fail if the combined size of
all <br>
files exceeds the memory you are entitled to.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -i, --inpipe=shellcommand, -I, --infail, -o,
--output=filename, -O, --outfail, <br>
--record-size=number, -s, --separator=string, -v,
--verbose&quot;</p>

<p style="margin-top: 1em">-c perlcode <br>
--compare=perlcode <br>
perlcode represents a Perl sort block, with the two sorting
candidates in $a and $b.</p>

<p style="margin-top: 1em">-n <br>
--numeric <br>
--numeric-sort <br>
This sorts sorts numerically on the beginnings of records.
Leading whitespace is skipped. You can use
&quot;--transform&quot; and &quot;--detransform&quot; if the
numbers are not at the <br>
beginning.</p>

<p style="margin-top: 1em">-r <br>
--reverse <br>
Output the results in the reverse order. Note that this
hides the standard option &quot;-r&quot; which must be given
as &quot;--record-size&quot;.</p>

<p style="margin-top: 1em">-t perlcode <br>
--transform=perlcode <br>
-d perlcode <br>
--detransform=perlcode <br>
If you have a complex code, sorting gets more and more
expensive in proportion to the number of records n, because
the code gets called O(n log(n)) times. To avoid that, <br>
you can allow Perl to concentrate on sorting, by first
modifying the strings, such that complicated search criteria
extraction happens once per record, and modifying them <br>
back, once they are sorted.</p>

<p style="margin-top: 1em">If these options are given, the
&quot;--transform&quot; perlcode gets mapped to the records
in $_ one after another, and can modify them. After sorting,
the &quot;--detransform&quot; <br>
perlcode gets mapped to the modified records in $_ one after
another, and can modify them back. You will usually use
neither or both of these options, unless you want to <br>
output modified lines.</p>

<p style="margin-top: 1em">Turning the strings into a
structure of extracted sort criteria, which your
&quot;--compare&quot; perlcode can pick up is known as the
Schwartzian Transform (ST). Packing <br>
everything into the string itself, so that no
&quot;--compare&quot; perlcode is needed, allowing the whole
sorting to happen without performing expensive Perl code, is
known as the <br>
Guttmann-Rosler Transform (GRT). You can find tips by
searching for those names on the web.</p>

<p style="margin-top: 1em"># Expensively sort numerical
expressions by value ($$ protects $ from makepp expansion)
<br>
&amp;sort --compare &rsquo;eval( $$a ) &lt;=&gt; eval( $$b
)&rsquo; $(input) -o &gt;&gt;$(output)</p>

<p style="margin-top: 1em"># ST for case insensitive
sorting <br>
&amp;sort -t &rsquo;[lc, $$_]&rsquo; -c &rsquo;$$a-&gt;[0]
cmp $$b-&gt;[0]&rsquo; -d &rsquo;$$_-&gt;[1]&rsquo; $(input)
-o &gt;&gt;$(output)</p>

<p style="margin-top: 1em"># GRT using modification
functions defined elsewhere in the Makeppfile <br>
&amp;sort -t &amp;transform -d &amp;detransform $(input) -o
&gt;&gt;$(output)</p>

<p style="margin-top: 1em">-u <br>
--uniq <br>
--unique <br>
After sorting, eliminate duplicates. These are either
identical lines, or if the &quot;--compare&quot; option is
given, ones which that perlcode reports as equivalent.</p>

<p style="margin-top: 1em">&amp;template [option ...]
macro=definition ... filename ... <br>
This is a macro preprocessor, not quite as powerful as the C
preprocessor or &quot;m4&quot;. See &amp;preprocess for a
more powerful alternative. It was inspired by
automake&rsquo;s macro <br>
replacement in Makefile.am and Makefile.in. But it goes
beyond that. Any normal text goes through unchanged. Special
constructs are by default delimited with &quot;@&quot;. They
<br>
must fit on one line unless you pass one of &quot;-r,
--record-size&quot; or &quot;--separator&quot;.</p>

<p style="margin-top: 1em">@# comment @ <br>
Note that despite borrowing from script &quot;#&quot; line
end comment syntax, this one is an inline comment.</p>

<p style="margin-top: 1em">@MACRO@ <br>
This construct is replaced by the value of the MACRO. Macro
names must start with a letter or underscore, followed by
any number of letters, underscores, minuses or <br>
dots. Unlike in makepp names, underscore and minus are not
equivalent.</p>

<p style="margin-top: 1em">@MACRO(arg1,arg2...)@ <br>
Like the first one, but parametrized. The args replace $1
through $9 or &quot;${number}&quot; in the value. Or, if the
value is a Perl function, they are passed as normal <br>
parameters. The result then replaces the whole construct.
One level of macro nesting is possible in that the args in
parenthesis may contain plain &quot;@MACRO@&quot; <br>
invocations, as in &quot;@f(@x@)@&quot;, where
&quot;@x@&quot; gets expanded before being replaced into the
body of &quot;f&quot;.</p>

<p style="margin-top: 1em">@include(filename)@ <br>
This is the only predefined macro. It is replaced by the
&amp;template-processed content of the named file. Like all
macros this can occur in the middle of a line. Alas, <br>
because of that, &quot;-S, --synclines&quot; ignores the
file inclusion, making everything seem to come from the
including file.</p>

<p style="margin-top: 1em">@MACRO=definition@ <br>
@MACRO?=definition@ <br>
This defines a macro within the file. This is replaced by
nothing. The second form only takes effect if the macro was
not defined, presumably on the command line.</p>

<p style="margin-top: 1em">@MACRO { Perlcode }@ <br>
This also defines a macro, the body of which is a Perl sub.
The arguments, if there are any, get passed in as @_.</p>

<p style="margin-top: 1em">@{ Perlcode }@ <br>
This runs the Perlcode immediately and gets replaced by the
return value.</p>

<p style="margin-top: 1em">So far we have only seen one
syntax for embedding special things. There is another
multiline syntax, and both allow a variation to suppress a
newline. These are the builtin <br>
syntaxes (which can be configured by options below). Here
SPECIAL stands for any of the constructs shown above:</p>

<p style="margin-top: 1em">@SPECIAL@ <br>
@SPECIAL@ This can appear multiply anywhere on a line. The
variant immediately followed by &quot;</p>

<p style="margin-top: 1em">@@SPECIAL@@ Normal text @@ <br>
@@SPECIAL@@ Normal text @@ This is like the previous one.
However the normal text, which also gets replaced, can span
multiple lines. You can put the special parts on comment
lines around source <br>
code that is only needed in an uninstalled script, to be
eliminated or replaced during the installation process:</p>

<p style="margin-top: 1em"># @@# the next 2 lines will
disappear @@ <br>
echo You are running the uninstalled version of this script
<br>
# @@ <br>
# @@REPLAMCENT@@ <br>
echo Something else will be here <br>
# @@</p>

<p style="margin-top: 1em">A meaningless example showing
the various possibilities:</p>

<p style="margin-top: 1em">@m1=some definition@ @m2=foo $1
bar@ @middle_of_arg=iddl@ @m1@ @m2(m@middle_of_arg@e)@ <br>
@@m2(many lines)@@ <br>
... <br>
@@ plain text 1 + 2 = @{ 1 + 2 }@</p>

<p style="margin-top: 1em">becomes</p>

<p style="margin-top: 1em">some definition foo middle bar
<br>
foo many lines bar plain text 1 + 2 = 3</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -i, --inpipe=shellcommand, -I, --infail, -o,
--output=filename, -O, --outfail, -r, <br>
--record-size=number, --separator=string, -S, --synclines,
-v, --verbose&quot;</p>

<p style="margin-top: 1em">-d <br>
--defined <br>
Replace only instances of macros which are actually defined.
Without this option the undefined ones will all be replaced
by nothing.</p>

<p style="margin-top: 1em">-h \%hash <br>
--hashref=\%hash <br>
This allows preallocation of the macro values, including
long ones not easily passed in a command. The passed
expression may be any Perl code that returns a hash <br>
reference. This is merged with any other macros passed to
the command, including from another &quot;--hashref&quot;
option. A hash value may also be a code reference, in that
<br>
case the function gets called, as with &quot;@macro {
Perlcode }@&quot; definitions.</p>

<p style="margin-top: 1em">-s /prefix/suffix/ <br>
--simple=/prefix/suffix/ <br>
Use prefix and suffix before and after SPECIAL respectively
instead of &quot;@&quot;. The first character is the
separator and need not be a slash. These values are Perl
regexps. <br>
You must not introduce grouping like &quot;(...)&quot;, but
&quot;(?:...)&quot; is ok.</p>

<p style="margin-top: 1em">-m
/prefix/suffix/afterprefix/[aftersuffix/] <br>
--multiline=/prefix/suffix/afterprefix/[aftersuffix/] <br>
Use prefix, suffix and afterprefix before and after SPECIAL
and at the end of the block respectively instead of
&quot;@@&quot;. If aftersuffix is also given, the macro name
must <br>
get repeated before it. The first character is the separator
and need not be a slash. E.g. an XML-ish, to which you must
add &quot;--defined&quot; if you want to preserve other <br>
tags, not defined by you:</p>

<p style="margin-top: 1em">--defined --simple=|&lt;|/&gt;|
--multiline=|&lt;|&gt;|&lt;/|&gt;|</p>

<p style="margin-top: 1em">Or, better, use processing
instructions &quot;&lt;?...?&gt;&quot;, intended for such a
purpose:</p>

<p style="margin-top: 1em">--defined
--simple=&rsquo;|&lt;&gt;|&rsquo;</p>

<p style="margin-top: 1em">Or, if you want to combine this
with &quot;&amp;entity;&quot; syntax for the simple macro
replacements (preserving numeric entities
&quot;&amp;#x263A;&quot; which are not comments):</p>

<p style="margin-top: 1em">--defined
--simple=&rsquo;_(?:&amp;(?!#)|&lt;&gt;)_&rsquo;</p>

<p style="margin-top: 1em">&amp;touch [option ...] filename
... <br>
Updates the modification and access timestamps of each file
to now. If the file doesn&rsquo;t exist, it gets
created.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -v,
--verbose&quot;</p>

<p style="margin-top: 1em">&amp;uninstall [option ...]
[filename ...] <br>
Uninstall files previously installed by &amp;install. The
filenames are logfiles written by &amp;install. If none are
given, nor an &quot;--inpipe&quot; option, reads the default
logfile of <br>
&amp;install.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -i,
--inpipe=shellcommand, -I, --infail, -v, --verbose&quot;</p>

<p style="margin-top: 1em">&amp;uniq [option ...] filename
... <br>
Discard all but one of successive equal lines.</p>

<p style="margin-top: 1em">&quot;Standard options&quot;:
&quot;-A, --args-file, --arguments-file=filename, -f,
--force, -i, --inpipe=shellcommand, -I, --infail, -o,
--output=filename, -O, --outfail, -r, <br>
--record-size=number, -s, --separator=string, -S,
--synclines, -v, --verbose&quot;</p>

<p style="margin-top: 1em">-c perlcode <br>
--compare=perlcode <br>
This Perlcode gets the previous and current lines in $a and
$b and shall return true if it considers the two lines
equal.</p>

<p style="margin-top: 1em">&amp;uniq --compare=&rsquo;lc(
$$a ) eq lc $$b&rsquo; $(inputs) -o $(output)</p>

<p style="margin-top: 1em">Emulatable commands <br>
Various things are not built in, but can be achieved with
other commands:</p>

<p style="margin-top: 1em">awk Use &amp;sed.</p>

<p style="margin-top: 1em">chgrp <br>
chown <br>
These commands are mostly not portable! They will either
quietly do nothing or fail, depending on the system.
Generally only root may perform these operations, which is
why <br>
they are only available through the &amp;install
command.</p>

<p style="margin-top: 1em">cpp Use &amp;preprocess or
&amp;template.</p>

<p style="margin-top: 1em">date <br>
Either of these partially does the same thing:</p>

<p style="margin-top: 1em">&amp;expr localtime <br>
&amp;expr gmtime</p>

<p style="margin-top: 1em">false <br>
Use &amp;expr with no argument or 0.</p>

<p style="margin-top: 1em">head <br>
tail <br>
You can achieve the same result with &amp;grep or
&quot;&amp;cut --lines&quot;:</p>

<p style="margin-top: 1em">&amp;grep 1..10 file # first ten
lines <br>
&amp;grep 10..eof file # all lines from tenth onwards <br>
&amp;cut --lines -10..-1 file # last ten lines</p>

<p style="margin-top: 1em">Note that 1..10 in &amp;grep is
Perl&rsquo;s line number flip-flop operator, which
annoyingly starts at 1. Don&rsquo;t start at 0, or the
flip-flop will never become true.</p>

<p style="margin-top: 1em">fmt This is mentioned here since
Perl provides a related functionality. However I had
problems using the &quot;format&quot; declaration in a
makefile. What does work is the underlying <br>
&quot;formline&quot; function. E.g. to transform a csv file
consisting of names and prices to a tabular format:</p>

<p style="margin-top: 1em">sub csv2txt { <br>
formline
&quot;@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
^###########.##0, split &rsquo;,&rsquo;; <br>
$_ = $^A; <br>
$^A = &rsquo;&rsquo;; <br>
}</p>

<p style="margin-top: 1em">%.txt: %.csv <br>
&amp;sed &amp;csv2txt $(input) -o $(output)</p>

<p style="margin-top: 1em">m4 Use &amp;preprocess or
&amp;template.</p>

<p style="margin-top: 1em">rmdir <br>
Use &amp;rm.</p>

<p style="margin-top: 1em">tr Use &amp;sed.</p>

<p style="margin-top: 1em">AUTHOR <br>
Daniel Pfeiffer (occitan@esperanto.org)</p>

<p style="margin-top: 1em">perl v5.24.1 2016-11-28
MAKEPP_BUILTINS(1)</p>
<hr>
</body>
</html>
