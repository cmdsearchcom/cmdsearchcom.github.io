<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:34:35 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>QEMU(1) QEMU(1)</p>

<p style="margin-top: 1em">NAME <br>
qemu-doc - QEMU Emulator User Documentation</p>

<p style="margin-top: 1em">SYNOPSIS <br>
usage: qemu-kvm [options] [disk_image]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The QEMU PC System emulator simulates the following
peripherals:</p>

<p style="margin-top: 1em">- i440FX host PCI bridge and
PIIX3 PCI to ISA bridge</p>

<p style="margin-top: 1em">- Cirrus CLGD 5446 PCI VGA card
or dummy VGA card with Bochs VESA extensions (hardware
level, including all non standard modes).</p>

<p style="margin-top: 1em">- PS/2 mouse and keyboard</p>

<p style="margin-top: 1em">- 2 PCI IDE interfaces with hard
disk and CD-ROM support</p>

<p style="margin-top: 1em">- Floppy disk</p>

<p style="margin-top: 1em">- PCI and ISA network
adapters</p>

<p style="margin-top: 1em">- Serial ports</p>

<p style="margin-top: 1em">- Creative SoundBlaster 16 sound
card</p>

<p style="margin-top: 1em">- ENSONIQ AudioPCI ES1370 sound
card</p>

<p style="margin-top: 1em">- Intel 82801AA AC97 Audio
compatible sound card</p>

<p style="margin-top: 1em">- Intel HD Audio Controller and
HDA codec</p>

<p style="margin-top: 1em">- Adlib (OPL2) - Yamaha YM3812
compatible chip</p>

<p style="margin-top: 1em">- Gravis Ultrasound GF1 sound
card</p>

<p style="margin-top: 1em">- CS4231A compatible sound
card</p>

<p style="margin-top: 1em">- PCI UHCI USB controller and a
virtual USB hub.</p>

<p style="margin-top: 1em">SMP is supported with up to 255
CPUs.</p>

<p style="margin-top: 1em">QEMU uses the PC BIOS from the
Bochs project and the Plex86/Bochs LGPL VGA BIOS.</p>

<p style="margin-top: 1em">QEMU uses YM3812 emulation by
Tatsuyuki Satoh.</p>

<p style="margin-top: 1em">QEMU uses GUS emulation
(GUSEMU32 &lt;http://www.deinmeister.de/gusemu/&gt;) by
Tibor &quot;TS&quot; Sch&Atilde;&frac14;tz.</p>

<p style="margin-top: 1em">Note that, by default, GUS
shares IRQ(7) with parallel ports and so QEMU must be told
to not have parallel ports to have working GUS.</p>

<p style="margin-top: 1em">qemu-kvm dos.img -soundhw gus
-parallel none</p>

<p style="margin-top: 1em">Alternatively:</p>

<p style="margin-top: 1em">qemu-kvm dos.img -device
gus,irq=5</p>

<p style="margin-top: 1em">Or some other unclaimed IRQ.</p>

<p style="margin-top: 1em">CS4231A is the chip used in
Windows Sound System and GUSMAX products</p>

<p style="margin-top: 1em">OPTIONS <br>
disk_image is a raw hard disk image for IDE hard disk 0.
Some targets do not need a disk image.</p>

<p style="margin-top: 1em">Standard options:</p>

<p style="margin-top: 1em">-h Display help and exit</p>

<p style="margin-top: 1em">-version <br>
Display version information and exit</p>

<p style="margin-top: 1em">-machine
[type=]name[,prop=value[,...]] <br>
Select the emulated machine by name. Use &quot;-machine
help&quot; to list available machines. Supported machine
properties are:</p>

<p style="margin-top: 1em">accel=accels1[:accels2[:...]]
<br>
This is used to enable an accelerator. Depending on the
target architecture, kvm, xen, or tcg can be available. By
default, tcg is used. If there is more than one <br>
accelerator specified, the next one is used if the previous
one fails to initialize.</p>

<p style="margin-top: 1em">kernel_irqchip=on|off <br>
Enables in-kernel irqchip support for the chosen accelerator
when available.</p>

<p style="margin-top: 1em">kvm_shadow_mem=size <br>
Defines the size of the KVM shadow MMU.</p>

<p style="margin-top: 1em">dump-guest-core=on|off <br>
Include guest memory in a core dump. The default is on.</p>

<p style="margin-top: 1em">mem-merge=on|off <br>
Enables or disables memory merge support. This feature, when
supported by the host, de-duplicates identical memory pages
among VMs instances (enabled by default).</p>

<p style="margin-top: 1em">-cpu model <br>
Select CPU model (&quot;-cpu help&quot; for list and
additional feature selection)</p>

<p style="margin-top: 1em">-smp
n[,cores=cores][,threads=threads][,sockets=sockets][,maxcpus=maxcpus]
<br>
Simulate an SMP system with n CPUs. On the PC target, up to
255 CPUs are supported. On Sparc32 target, Linux limits the
number of usable CPUs to 4. For the PC target, the <br>
number of cores per socket, the number of threads per cores
and the total number of sockets can be specified. Missing
values will be computed. If any on the three values is <br>
given, the total number of CPUs n can be omitted. maxcpus
specifies the maximum number of hotpluggable CPUs.</p>

<p style="margin-top: 1em">-numa opts <br>
Simulate a multi node NUMA system. If mem and cpus are
omitted, resources are split equally.</p>

<p style="margin-top: 1em">-add-fd
fd=fd,set=set[,opaque=opaque] <br>
Add a file descriptor to an fd set. Valid options are:</p>

<p style="margin-top: 1em">fd=fd <br>
This option defines the file descriptor of which a duplicate
is added to fd set. The file descriptor cannot be stdin,
stdout, or stderr.</p>

<p style="margin-top: 1em">set=set <br>
This option defines the ID of the fd set to add the file
descriptor to.</p>

<p style="margin-top: 1em">opaque=opaque <br>
This option defines a free-form string that can be used to
describe fd.</p>

<p style="margin-top: 1em">You can open an image using
pre-opened file descriptors from an fd set:</p>

<p style="margin-top: 1em">qemu-kvm <br>
-add-fd fd=3,set=2,opaque=&quot;rdwr:/path/to/file&quot;
<br>
-add-fd fd=4,set=2,opaque=&quot;rdonly:/path/to/file&quot;
<br>
-drive file=/dev/fdset/2,index=0,media=disk</p>

<p style="margin-top: 1em">-set group.id.arg=value <br>
Set parameter arg for item id of type group0</p>

<p style="margin-top: 1em">-global driver.prop=value <br>
Set default value of driver&rsquo;s property prop to value,
e.g.:</p>

<p style="margin-top: 1em">qemu-kvm -global
ide-drive.physical_block_size=4096 -drive
file=file,if=ide,index=0,media=disk</p>

<p style="margin-top: 1em">In particular, you can use this
to set driver properties for devices which are created
automatically by the machine model. To create a device which
is not created <br>
automatically and set properties on it, use -device.</p>

<p style="margin-top: 1em">-boot
[order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]
<br>
Specify boot order drives as a string of drive letters.
Valid drive letters depend on the target achitecture. The
x86 PC uses: a, b (floppy 1 and 2), c (first hard disk), d
<br>
(first CD-ROM), n-p (Etherboot from network adapter 1-4),
hard disk boot is the default. To apply a particular boot
order only on the first startup, specify it via once.</p>

<p style="margin-top: 1em">Interactive boot menus/prompts
can be enabled via menu=on as far as firmware/BIOS supports
them. The default is non-interactive boot.</p>

<p style="margin-top: 1em">A splash picture could be passed
to bios, enabling user to show it as logo, when option
splash=sp_name is given and menu=on, If firmware/BIOS
supports them. Currently Seabios <br>
for X86 system support it. limitation: The splash file could
be a jpeg file or a BMP file in 24 BPP format(true color).
The resolution should be supported by the SVGA mode, <br>
so the recommended is 320x240, 640x480, 800x640.</p>

<p style="margin-top: 1em">A timeout could be passed to
bios, guest will pause for rb_timeout ms when boot failed,
then reboot. If rb_timeout is &rsquo;-1&rsquo;, guest will
not reboot, qemu-kvm passes &rsquo;-1&rsquo; to <br>
bios by default. Currently Seabios for X86 system support
it.</p>

<p style="margin-top: 1em">Do strict boot via strict=on as
far as firmware/BIOS supports it. This only effects when
boot priority is changed by bootindex options. The default
is non-strict boot.</p>

<p style="margin-top: 1em"># try to boot from network
first, then from hard disk <br>
qemu-kvm -boot order=nc <br>
# boot from CD-ROM first, switch back to default order after
reboot <br>
qemu-kvm -boot once=d <br>
# boot with a splash picture for 5 seconds. <br>
qemu-kvm -boot
menu=on,splash=/root/boot.bmp,splash-time=5000</p>

<p style="margin-top: 1em">Note: The legacy format
&rsquo;-boot drives&rsquo; is still supported but its use is
discouraged as it may be removed from future versions.</p>

<p style="margin-top: 1em">-m megs <br>
Set virtual RAM size to megs megabytes. Default is 128 MiB.
Optionally, a suffix of &quot;M&quot; or &quot;G&quot; can
be used to signify a value in megabytes or gigabytes
respectively.</p>

<p style="margin-top: 1em">-mem-path path <br>
Allocate guest RAM from a temporarily created file in
path.</p>

<p style="margin-top: 1em">-mem-prealloc <br>
Preallocate memory when using -mem-path.</p>

<p style="margin-top: 1em">-k language <br>
Use keyboard layout language (for example &quot;fr&quot; for
French). This option is only needed where it is not easy to
get raw PC keycodes (e.g. on Macs, with some X11 servers or
<br>
with a VNC display). You don&rsquo;t normally need to use it
on PC/Linux or PC/Windows hosts.</p>

<p style="margin-top: 1em">The available layouts are:</p>

<p style="margin-top: 1em">ar de-ch es fo fr-ca hu ja mk no
pt-br sv <br>
da en-gb et fr fr-ch is lt nl pl ru th <br>
de en-us fi fr-be hr it lv nl-be pt sl tr</p>

<p style="margin-top: 1em">The default is
&quot;en-us&quot;.</p>

<p style="margin-top: 1em">-audio-help <br>
Will show the audio subsystem help: list of drivers, tunable
parameters.</p>

<p style="margin-top: 1em">-soundhw card1[,card2,...] or
-soundhw all <br>
Enable audio and selected sound hardware. Use
&rsquo;help&rsquo; to print all available sound
hardware.</p>

<p style="margin-top: 1em">qemu-kvm -soundhw sb16,adlib
disk.img <br>
qemu-kvm -soundhw es1370 disk.img <br>
qemu-kvm -soundhw ac97 disk.img <br>
qemu-kvm -soundhw hda disk.img <br>
qemu-kvm -soundhw all disk.img <br>
qemu-kvm -soundhw help</p>

<p style="margin-top: 1em">Note that Linux&rsquo;s
i810_audio OSS kernel (for AC97) module might require
manually specifying clocking.</p>

<p style="margin-top: 1em">modprobe i810_audio
clocking=48000</p>

<p style="margin-top: 1em">-balloon none <br>
Disable balloon device.</p>

<p style="margin-top: 1em">-balloon virtio[,addr=addr] <br>
Enable virtio balloon device (default), optionally with PCI
address addr.</p>

<p style="margin-top: 1em">-device
driver[,prop[=value][,...]] <br>
Add device driver. prop=value sets driver properties. Valid
properties depend on the driver. To get help on possible
drivers and properties, use &quot;-device help&quot; and
<br>
&quot;-device driver,help&quot;.</p>

<p style="margin-top: 1em">-name name <br>
Sets the name of the guest. This name will be displayed in
the SDL window caption. The name will also be used for the
VNC server. Also optionally set the top visible <br>
process name in Linux.</p>

<p style="margin-top: 1em">-uuid uuid <br>
Set system UUID.</p>

<p style="margin-top: 1em">Block device options:</p>

<p style="margin-top: 1em">-fda file <br>
-fdb file <br>
Use file as floppy disk 0/1 image. You can use the host
floppy by using /dev/fd0 as filename.</p>

<p style="margin-top: 1em">-hda file <br>
-hdb file <br>
-hdc file <br>
-hdd file <br>
Use file as hard disk 0, 1, 2 or 3 image.</p>

<p style="margin-top: 1em">-cdrom file <br>
Use file as CD-ROM image (you cannot use -hdc and -cdrom at
the same time). You can use the host CD-ROM by using
/dev/cdrom as filename.</p>

<p style="margin-top: 1em">-drive
option[,option[,option[,...]]] <br>
Define a new drive. Valid options are:</p>

<p style="margin-top: 1em">file=file <br>
This option defines which disk image to use with this drive.
If the filename contains comma, you must double it (for
instance, &quot;file=my,,file&quot; to use file
&quot;my,file&quot;).</p>

<p style="margin-top: 1em">Special files such as iSCSI
devices can be specified using protocol specific URLs. See
the section for &quot;Device URL Syntax&quot; for more
information.</p>

<p style="margin-top: 1em">if=interface <br>
This option defines on which type on interface the drive is
connected. Available types are: ide, scsi, sd, mtd, floppy,
pflash, virtio.</p>

<p style="margin-top: 1em">bus=bus,unit=unit <br>
These options define where is connected the drive by
defining the bus number and the unit id.</p>

<p style="margin-top: 1em">index=index <br>
This option defines where is connected the drive by using an
index in the list of available connectors of a given
interface type.</p>

<p style="margin-top: 1em">media=media <br>
This option defines the type of the media: disk or
cdrom.</p>

<p style="margin-top: 1em">cyls=c,heads=h,secs=s[,trans=t]
<br>
These options have the same definition as they have in
-hdachs.</p>

<p style="margin-top: 1em">snapshot=snapshot <br>
snapshot is &quot;on&quot; or &quot;off&quot; and allows to
enable snapshot for given drive (see -snapshot).</p>

<p style="margin-top: 1em">cache=cache <br>
cache is &quot;none&quot;, &quot;writeback&quot;,
&quot;unsafe&quot;, &quot;directsync&quot; or
&quot;writethrough&quot; and controls how the host cache is
used to access block data.</p>

<p style="margin-top: 1em">aio=aio <br>
aio is &quot;threads&quot;, or &quot;native&quot; and
selects between pthread based disk I/O and native Linux
AIO.</p>

<p style="margin-top: 1em">discard=discard <br>
discard is one of &quot;ignore&quot; (or &quot;off&quot;) or
&quot;unmap&quot; (or &quot;on&quot;) and controls whether
discard (also known as trim or unmap) requests are ignored
or passed to the filesystem. <br>
Some machine types may not support discard requests.</p>

<p style="margin-top: 1em">format=format <br>
Specify which disk format will be used rather than detecting
the format. Can be used to specifiy format=raw to avoid
interpreting an untrusted format header.</p>

<p style="margin-top: 1em">serial=serial <br>
This option specifies the serial number to assign to the
device.</p>

<p style="margin-top: 1em">addr=addr <br>
Specify the controller&rsquo;s PCI address (if=virtio
only).</p>

<p style="margin-top: 1em">werror=action,rerror=action <br>
Specify which action to take on write and read errors. Valid
actions are: &quot;ignore&quot; (ignore the error and try to
continue), &quot;stop&quot; (pause QEMU), &quot;report&quot;
(report the error <br>
to the guest), &quot;enospc&quot; (pause QEMU only if the
host disk is full; report the error to the guest otherwise).
The default setting is werror=enospc and rerror=report.</p>

<p style="margin-top: 1em">readonly <br>
Open drive file as read-only. Guest write attempts will
fail.</p>

<p style="margin-top: 1em">copy-on-read=copy-on-read <br>
copy-on-read is &quot;on&quot; or &quot;off&quot; and
enables whether to copy read backing file sectors into the
image file.</p>

<p style="margin-top: 1em">By default, the cache=writeback
mode is used. It will report data writes as completed as
soon as the data is present in the host page cache. This is
safe as long as your <br>
guest OS makes sure to correctly flush disk caches where
needed. If your guest OS does not handle volatile disk write
caches correctly and your host crashes or loses power, <br>
then the guest may experience data corruption.</p>

<p style="margin-top: 1em">For such guests, you should
consider using cache=writethrough. This means that the host
page cache will be used to read and write data, but write
notification will be sent to <br>
the guest only after QEMU has made sure to flush each write
to the disk. Be aware that this has a major impact on
performance.</p>

<p style="margin-top: 1em">The host page cache can be
avoided entirely with cache=none. This will attempt to do
disk IO directly to the guest&rsquo;s memory. QEMU may still
perform an internal copy of the <br>
data. Note that this is considered a writeback mode and the
guest OS must handle the disk write cache correctly in order
to avoid data corruption on host crashes.</p>

<p style="margin-top: 1em">The host page cache can be
avoided while only sending write notifications to the guest
when the data has been flushed to the disk using
cache=directsync.</p>

<p style="margin-top: 1em">In case you don&rsquo;t care
about data integrity over host failures, use cache=unsafe.
This option tells QEMU that it never needs to write any data
to the disk but can instead <br>
keep things in cache. If anything goes wrong, like your host
losing power, the disk storage getting disconnected
accidentally, etc. your image will most probably be rendered
<br>
unusable. When using the -snapshot option, unsafe caching is
always used.</p>

<p style="margin-top: 1em">Copy-on-read avoids accessing
the same backing file sectors repeatedly and is useful when
the backing file is over a slow network. By default
copy-on-read is off.</p>

<p style="margin-top: 1em">Instead of -cdrom you can
use:</p>

<p style="margin-top: 1em">qemu-kvm -drive
file=file,index=2,media=cdrom</p>

<p style="margin-top: 1em">Instead of -hda, -hdb, -hdc,
-hdd, you can use:</p>

<p style="margin-top: 1em">qemu-kvm -drive
file=file,index=0,media=disk <br>
qemu-kvm -drive file=file,index=1,media=disk <br>
qemu-kvm -drive file=file,index=2,media=disk <br>
qemu-kvm -drive file=file,index=3,media=disk</p>

<p style="margin-top: 1em">You can open an image using
pre-opened file descriptors from an fd set:</p>

<p style="margin-top: 1em">qemu-kvm <br>
-add-fd fd=3,set=2,opaque=&quot;rdwr:/path/to/file&quot;
<br>
-add-fd fd=4,set=2,opaque=&quot;rdonly:/path/to/file&quot;
<br>
-drive file=/dev/fdset/2,index=0,media=disk</p>

<p style="margin-top: 1em">You can connect a CDROM to the
slave of ide0:</p>

<p style="margin-top: 1em">qemu-kvm -drive
file=file,if=ide,index=1,media=cdrom</p>

<p style="margin-top: 1em">If you don&rsquo;t specify the
&quot;file=&quot; argument, you define an empty drive:</p>

<p style="margin-top: 1em">qemu-kvm -drive
if=ide,index=1,media=cdrom</p>

<p style="margin-top: 1em">You can connect a SCSI disk with
unit ID 6 on the bus #0:</p>

<p style="margin-top: 1em">qemu-kvm -drive
file=file,if=scsi,bus=0,unit=6</p>

<p style="margin-top: 1em">Instead of -fda, -fdb, you can
use:</p>

<p style="margin-top: 1em">qemu-kvm -drive
file=file,index=0,if=floppy <br>
qemu-kvm -drive file=file,index=1,if=floppy</p>

<p style="margin-top: 1em">By default, interface is
&quot;ide&quot; and index is automatically incremented:</p>

<p style="margin-top: 1em">qemu-kvm -drive file=a -drive
file=b&quot;</p>

<p style="margin-top: 1em">is interpreted like:</p>

<p style="margin-top: 1em">qemu-kvm -hda a -hdb b</p>

<p style="margin-top: 1em">-mtdblock file <br>
Use file as on-board Flash memory image.</p>

<p style="margin-top: 1em">-sd file <br>
Use file as SecureDigital card image.</p>

<p style="margin-top: 1em">-pflash file <br>
Use file as a parallel flash image.</p>

<p style="margin-top: 1em">-snapshot <br>
Write to temporary files instead of disk image files. In
this case, the raw disk image you use is not written back.
You can however force the write back by pressing C-a s.</p>

<p style="margin-top: 1em">-hdachs c,h,s,[,t] <br>
Force hard disk 0 physical geometry (1 &lt;= c &lt;= 16383,
1 &lt;= h &lt;= 16, 1 &lt;= s &lt;= 63) and optionally force
the BIOS translation mode (t=none, lba or auto). Usually
QEMU can guess <br>
all those parameters. This option is useful for old MS-DOS
disk images.</p>

<p style="margin-top: 1em">-fsdev
fsdriver,id=id,path=path,[security_model=security_model][,writeout=writeout][,readonly][,socket=socket|sock_fd=sock_fd]
<br>
Define a new file system device. Valid options are:</p>

<p style="margin-top: 1em">fsdriver <br>
This option specifies the fs driver backend to use.
Currently &quot;local&quot;, &quot;handle&quot; and
&quot;proxy&quot; file system drivers are supported.</p>

<p style="margin-top: 1em">id=id <br>
Specifies identifier for this device</p>

<p style="margin-top: 1em">path=path <br>
Specifies the export path for the file system device. Files
under this path will be available to the 9p client on the
guest.</p>

<p style="margin-top: 1em">security_model=security_model
<br>
Specifies the security model to be used for this export
path. Supported security models are &quot;passthrough&quot;,
&quot;mapped-xattr&quot;, &quot;mapped-file&quot; and
&quot;none&quot;. In &quot;passthrough&quot; <br>
security model, files are stored using the same credentials
as they are created on the guest. This requires QEMU to run
as root. In &quot;mapped-xattr&quot; security model, some of
<br>
the file attributes like uid, gid, mode bits and link target
are stored as file attributes. For &quot;mapped-file&quot;
these attributes are stored in the hidden .virtfs_metadata
<br>
directory. Directories exported by this security model
cannot interact with other unix tools. &quot;none&quot;
security model is same as passthrough except the sever
won&rsquo;t report <br>
failures if it fails to set file attributes like ownership.
Security model is mandatory only for local fsdriver. Other
fsdrivers (like handle, proxy) don&rsquo;t take security
<br>
model as a parameter.</p>

<p style="margin-top: 1em">writeout=writeout <br>
This is an optional argument. The only supported value is
&quot;immediate&quot;. This means that host page cache will
be used to read and write data but write notification will
be <br>
sent to the guest only when the data has been reported as
written by the storage subsystem.</p>

<p style="margin-top: 1em">readonly <br>
Enables exporting 9p share as a readonly mount for guests.
By default read-write access is given.</p>

<p style="margin-top: 1em">socket=socket <br>
Enables proxy filesystem driver to use passed socket file
for communicating with virtfs-proxy-helper</p>

<p style="margin-top: 1em">sock_fd=sock_fd <br>
Enables proxy filesystem driver to use passed socket
descriptor for communicating with virtfs-proxy-helper.
Usually a helper like libvirt will create socketpair and
pass <br>
one of the fds as sock_fd</p>

<p style="margin-top: 1em">-fsdev option is used along with
-device driver &quot;virtio-9p-pci&quot;.</p>

<p style="margin-top: 1em">-device
virtio-9p-pci,fsdev=id,mount_tag=mount_tag <br>
Options for virtio-9p-pci driver are:</p>

<p style="margin-top: 1em">fsdev=id <br>
Specifies the id value specified along with -fsdev
option</p>

<p style="margin-top: 1em">mount_tag=mount_tag <br>
Specifies the tag name to be used by the guest to mount this
export point</p>

<p style="margin-top: 1em">-virtfs
fsdriver[,path=path],mount_tag=mount_tag[,security_model=security_model][,writeout=writeout][,readonly][,socket=socket|sock_fd=sock_fd]
<br>
The general form of a Virtual File system pass-through
options are:</p>

<p style="margin-top: 1em">fsdriver <br>
This option specifies the fs driver backend to use.
Currently &quot;local&quot;, &quot;handle&quot; and
&quot;proxy&quot; file system drivers are supported.</p>

<p style="margin-top: 1em">id=id <br>
Specifies identifier for this device</p>

<p style="margin-top: 1em">path=path <br>
Specifies the export path for the file system device. Files
under this path will be available to the 9p client on the
guest.</p>

<p style="margin-top: 1em">security_model=security_model
<br>
Specifies the security model to be used for this export
path. Supported security models are &quot;passthrough&quot;,
&quot;mapped-xattr&quot;, &quot;mapped-file&quot; and
&quot;none&quot;. In &quot;passthrough&quot; <br>
security model, files are stored using the same credentials
as they are created on the guest. This requires QEMU to run
as root. In &quot;mapped-xattr&quot; security model, some of
<br>
the file attributes like uid, gid, mode bits and link target
are stored as file attributes. For &quot;mapped-file&quot;
these attributes are stored in the hidden .virtfs_metadata
<br>
directory. Directories exported by this security model
cannot interact with other unix tools. &quot;none&quot;
security model is same as passthrough except the sever
won&rsquo;t report <br>
failures if it fails to set file attributes like ownership.
Security model is mandatory only for local fsdriver. Other
fsdrivers (like handle, proxy) don&rsquo;t take security
<br>
model as a parameter.</p>

<p style="margin-top: 1em">writeout=writeout <br>
This is an optional argument. The only supported value is
&quot;immediate&quot;. This means that host page cache will
be used to read and write data but write notification will
be <br>
sent to the guest only when the data has been reported as
written by the storage subsystem.</p>

<p style="margin-top: 1em">readonly <br>
Enables exporting 9p share as a readonly mount for guests.
By default read-write access is given.</p>

<p style="margin-top: 1em">socket=socket <br>
Enables proxy filesystem driver to use passed socket file
for communicating with virtfs-proxy-helper. Usually a helper
like libvirt will create socketpair and pass one of <br>
the fds as sock_fd</p>

<p style="margin-top: 1em">sock_fd <br>
Enables proxy filesystem driver to use passed
&rsquo;sock_fd&rsquo; as the socket descriptor for
interfacing with virtfs-proxy-helper</p>

<p style="margin-top: 1em">-virtfs_synth <br>
Create synthetic file system image</p>

<p style="margin-top: 1em">USB options:</p>

<p style="margin-top: 1em">-usb <br>
Enable the USB driver (will be the default soon)</p>

<p style="margin-top: 1em">-usbdevice devname <br>
Add the USB device devname.</p>

<p style="margin-top: 1em">mouse <br>
Virtual Mouse. This will override the PS/2 mouse emulation
when activated.</p>

<p style="margin-top: 1em">tablet <br>
Pointer device that uses absolute coordinates (like a
touchscreen). This means QEMU is able to report the mouse
position without having to grab the mouse. Also overrides
<br>
the PS/2 mouse emulation when activated.</p>

<p style="margin-top: 1em">disk:[format=format]:file <br>
Mass storage device based on file. The optional format
argument will be used rather than detecting the format. Can
be used to specifiy &quot;format=raw&quot; to avoid
interpreting <br>
an untrusted format header.</p>

<p style="margin-top: 1em">host:bus.addr <br>
Pass through the host device identified by bus.addr (Linux
only).</p>

<p style="margin-top: 1em">host:vendor_id:product_id <br>
Pass through the host device identified by
vendor_id:product_id (Linux only).</p>


<p style="margin-top: 1em">serial:[vendorid=vendor_id][,productid=product_id]:dev
<br>
Serial converter to host character device dev, see
&quot;-serial&quot; for the available devices.</p>

<p style="margin-top: 1em">braille <br>
Braille device. This will use BrlAPI to display the braille
output on a real or fake device.</p>

<p style="margin-top: 1em">net:options <br>
Network adapter that supports CDC ethernet and RNDIS
protocols.</p>

<p style="margin-top: 1em">Display options:</p>

<p style="margin-top: 1em">-display type <br>
Select type of display to use. This option is a replacement
for the old style -sdl/-curses/... options. Valid values for
type are</p>

<p style="margin-top: 1em">sdl Display video output via SDL
(usually in a separate graphics window; see the SDL
documentation for other possibilities).</p>

<p style="margin-top: 1em">curses <br>
Display video output via curses. For graphics device models
which support a text mode, QEMU can display this output
using a curses/ncurses interface. Nothing is displayed <br>
when the graphics device is in graphical mode or if the
graphics device does not support a text mode. Generally only
the VGA device models support text mode.</p>

<p style="margin-top: 1em">none <br>
Do not display video output. The guest will still see an
emulated graphics card, but its output will not be displayed
to the QEMU user. This option differs from the <br>
-nographic option in that it only affects what is done with
video output; -nographic also changes the destination of the
serial and parallel port data.</p>

<p style="margin-top: 1em">vnc Start a VNC server on
display &lt;arg&gt;</p>

<p style="margin-top: 1em">-nographic <br>
Normally, QEMU uses SDL to display the VGA output. With this
option, you can totally disable graphical output so that
QEMU is a simple command line application. The emulated <br>
serial port is redirected on the console. Therefore, you can
still use QEMU to debug a Linux kernel with a serial
console.</p>

<p style="margin-top: 1em">-curses <br>
Normally, QEMU uses SDL to display the VGA output. With this
option, QEMU can display the VGA output when in text mode
using a curses/ncurses interface. Nothing is <br>
displayed in graphical mode.</p>

<p style="margin-top: 1em">-no-frame <br>
Do not use decorations for SDL windows and start them using
the whole available screen space. This makes the using QEMU
in a dedicated desktop workspace more convenient.</p>

<p style="margin-top: 1em">-alt-grab <br>
Use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt). Note
that this also affects the special keys (for fullscreen,
monitor-mode switching, etc).</p>

<p style="margin-top: 1em">-ctrl-grab <br>
Use Right-Ctrl to grab mouse (instead of Ctrl-Alt). Note
that this also affects the special keys (for fullscreen,
monitor-mode switching, etc).</p>

<p style="margin-top: 1em">-no-quit <br>
Disable SDL window close capability.</p>

<p style="margin-top: 1em">-sdl <br>
Enable SDL.</p>

<p style="margin-top: 1em">-spice option[,option[,...]]
<br>
Enable the spice remote desktop protocol. Valid options
are</p>

<p style="margin-top: 1em">port=&lt;nr&gt; <br>
Set the TCP port spice is listening on for plaintext
channels.</p>

<p style="margin-top: 1em">addr=&lt;addr&gt; <br>
Set the IP address spice is listening on. Default is any
address.</p>

<p style="margin-top: 1em">ipv4 <br>
ipv6 <br>
Force using the specified IP version.</p>

<p style="margin-top: 1em">password=&lt;secret&gt; <br>
Set the password you need to authenticate.</p>

<p style="margin-top: 1em">sasl <br>
Require that the client use SASL to authenticate with the
spice. The exact choice of authentication method used is
controlled from the system / user&rsquo;s SASL configuration
<br>
file for the &rsquo;qemu&rsquo; service. This is typically
found in /etc/sasl2/qemu.conf. If running QEMU as an
unprivileged user, an environment variable SASL_CONF_PATH
can be used <br>
to make it search alternate locations for the service
config. While some SASL auth methods can also provide data
encryption (eg GSSAPI), it is recommended that SASL <br>
always be combined with the &rsquo;tls&rsquo; and
&rsquo;x509&rsquo; settings to enable use of SSL and server
certificates. This ensures a data encryption preventing
compromise of authentication <br>
credentials.</p>

<p style="margin-top: 1em">disable-ticketing <br>
Allow client connects without authentication.</p>

<p style="margin-top: 1em">disable-copy-paste <br>
Disable copy paste between the client and the guest.</p>

<p style="margin-top: 1em">tls-port=&lt;nr&gt; <br>
Set the TCP port spice is listening on for encrypted
channels.</p>

<p style="margin-top: 1em">x509-dir=&lt;dir&gt; <br>
Set the x509 file directory. Expects same filenames as -vnc
$display,x509=$dir</p>

<p style="margin-top: 1em">x509-key-file=&lt;file&gt; <br>
x509-key-password=&lt;file&gt; <br>
x509-cert-file=&lt;file&gt; <br>
x509-cacert-file=&lt;file&gt; <br>
x509-dh-key-file=&lt;file&gt; <br>
The x509 file names can also be configured individually.</p>

<p style="margin-top: 1em">tls-ciphers=&lt;list&gt; <br>
Specify which ciphers to use.</p>


<p style="margin-top: 1em">tls-channel=[main|display|cursor|inputs|record|playback]
<br>

plaintext-channel=[main|display|cursor|inputs|record|playback]
<br>
Force specific channel to be used with or without TLS
encryption. The options can be specified multiple times to
configure multiple channels. The special name
&quot;default&quot; <br>
can be used to set the default mode. For channels which are
not explicitly forced into one mode the spice client is
allowed to pick tls/plaintext as he pleases.</p>


<p style="margin-top: 1em">image-compression=[auto_glz|auto_lz|quic|glz|lz|off]
<br>
Configure image compression (lossless). Default is
auto_glz.</p>


<p style="margin-top: 1em">jpeg-wan-compression=[auto|never|always]
<br>
zlib-glz-wan-compression=[auto|never|always] <br>
Configure wan image compression (lossy for slow links).
Default is auto.</p>


<p style="margin-top: 1em">streaming-video=[off|all|filter]
<br>
Configure video stream detection. Default is filter.</p>

<p style="margin-top: 1em">agent-mouse=[on|off] <br>
Enable/disable passing mouse events via vdagent. Default is
on.</p>

<p style="margin-top: 1em">playback-compression=[on|off]
<br>
Enable/disable audio stream compression (using celt 0.5.1).
Default is on.</p>

<p style="margin-top: 1em">seamless-migration=[on|off] <br>
Enable/disable spice seamless migration. Default is off.</p>

<p style="margin-top: 1em">-portrait <br>
Rotate graphical output 90 deg left (only PXA LCD).</p>

<p style="margin-top: 1em">-rotate deg <br>
Rotate graphical output some deg left (only PXA LCD).</p>

<p style="margin-top: 1em">-vga type <br>
Select type of VGA card to emulate. Valid values for type
are</p>

<p style="margin-top: 1em">cirrus <br>
Cirrus Logic GD5446 Video card. All Windows versions
starting from Windows 95 should recognize and use this
graphic card. For optimal performances, use 16 bit color
depth <br>
in the guest and the host OS. (This one is the default)</p>

<p style="margin-top: 1em">std Standard VGA card with Bochs
VBE extensions. If your guest OS supports the VESA 2.0 VBE
extensions (e.g. Windows XP) and if you want to use high
resolution modes (&gt;= <br>
1280x1024x16) then you should use this option.</p>

<p style="margin-top: 1em">vmware <br>
VMWare SVGA-II compatible adapter. Use it if you have
sufficiently recent XFree86/XOrg server or Windows guest
with a driver for this card.</p>

<p style="margin-top: 1em">qxl QXL paravirtual graphic
card. It is VGA compatible (including VESA 2.0 VBE support).
Works best with qxl guest drivers installed though.
Recommended choice when using <br>
the spice protocol.</p>

<p style="margin-top: 1em">none <br>
Disable VGA card.</p>

<p style="margin-top: 1em">-full-screen <br>
Start in full screen.</p>

<p style="margin-top: 1em">-g widthxheight[xdepth] <br>
Set the initial graphical resolution and depth (PPC, SPARC
only).</p>

<p style="margin-top: 1em">-vnc
display[,option[,option[,...]]] <br>
Normally, QEMU uses SDL to display the VGA output. With this
option, you can have QEMU listen on VNC display display and
redirect the VGA display over the VNC session. It <br>
is very useful to enable the usb tablet device when using
this option (option -usbdevice tablet). When using the VNC
display, you must use the -k parameter to set the <br>
keyboard layout if you are not using en-us. Valid syntax for
the display is</p>

<p style="margin-top: 1em">host:d <br>
TCP connections will only be allowed from host on display d.
By convention the TCP port is 5900+d. Optionally, host can
be omitted in which case the server will accept <br>
connections from any host.</p>

<p style="margin-top: 1em">unix:path <br>
Connections will be allowed over UNIX domain sockets where
path is the location of a unix socket to listen for
connections on.</p>

<p style="margin-top: 1em">none <br>
VNC is initialized but not started. The monitor
&quot;change&quot; command can be used to later start the
VNC server.</p>

<p style="margin-top: 1em">Following the display value
there may be one or more option flags separated by commas.
Valid options are</p>

<p style="margin-top: 1em">reverse <br>
Connect to a listening VNC client via a &quot;reverse&quot;
connection. The client is specified by the display. For
reverse network connections (host:d,&quot;reverse&quot;),
the d argument <br>
is a TCP port number, not a display number.</p>

<p style="margin-top: 1em">websocket <br>
Opens an additional TCP listening port dedicated to VNC
Websocket connections. By definition the Websocket port is
5700+display. If host is specified connections will <br>
only be allowed from this host. As an alternative the
Websocket port could be specified by using
&quot;websocket&quot;=port. TLS encryption for the Websocket
connection is <br>
supported if the required certificates are specified with
the VNC option x509.</p>

<p style="margin-top: 1em">password <br>
Require that password based authentication is used for
client connections.</p>

<p style="margin-top: 1em">The password must be set
separately using the &quot;set_password&quot; command in the
pcsys_monitor. The syntax to change your password is:
&quot;set_password &lt;protocol&gt; &lt;password&gt;&quot;
<br>
where &lt;protocol&gt; could be either &quot;vnc&quot; or
&quot;spice&quot;.</p>

<p style="margin-top: 1em">If you would like to change
&lt;protocol&gt; password expiration, you should use
&quot;expire_password &lt;protocol&gt;
&lt;expiration-time&gt;&quot; where expiration time could be
one of the <br>
following options: now, never, +seconds or UNIX time of
expiration, e.g. +60 to make password expire in 60 seconds,
or 1335196800 to make password expire on &quot;Mon Apr 23
<br>
12:00:00 EDT 2012&quot; (UNIX time for this date and
time).</p>

<p style="margin-top: 1em">You can also use keywords
&quot;now&quot; or &quot;never&quot; for the expiration time
to allow &lt;protocol&gt; password to expire immediately or
never expire.</p>

<p style="margin-top: 1em">tls Require that client use TLS
when communicating with the VNC server. This uses anonymous
TLS credentials so is susceptible to a man-in-the-middle
attack. It is recommended <br>
that this option be combined with either the x509 or
x509verify options.</p>

<p style="margin-top: 1em">x509=/path/to/certificate/dir
<br>
Valid if tls is specified. Require that x509 credentials are
used for negotiating the TLS session. The server will send
its x509 certificate to the client. It is <br>
recommended that a password be set on the VNC server to
provide authentication of the client when this is used. The
path following this option specifies where the x509 <br>
certificates are to be loaded from. See the vnc_security
section for details on generating certificates.</p>


<p style="margin-top: 1em">x509verify=/path/to/certificate/dir
<br>
Valid if tls is specified. Require that x509 credentials are
used for negotiating the TLS session. The server will send
its x509 certificate to the client, and request <br>
that the client send its own x509 certificate. The server
will validate the client&rsquo;s certificate against the CA
certificate, and reject clients when validation fails. If
<br>
the certificate authority is trusted, this is a sufficient
authentication mechanism. You may still wish to set a
password on the VNC server as a second authentication <br>
layer. The path following this option specifies where the
x509 certificates are to be loaded from. See the
vnc_security section for details on generating
certificates.</p>

<p style="margin-top: 1em">sasl <br>
Require that the client use SASL to authenticate with the
VNC server. The exact choice of authentication method used
is controlled from the system / user&rsquo;s SASL <br>
configuration file for the &rsquo;qemu&rsquo; service. This
is typically found in /etc/sasl2/qemu.conf. If running QEMU
as an unprivileged user, an environment variable <br>
SASL_CONF_PATH can be used to make it search alternate
locations for the service config. While some SASL auth
methods can also provide data encryption (eg GSSAPI), it is
<br>
recommended that SASL always be combined with the
&rsquo;tls&rsquo; and &rsquo;x509&rsquo; settings to enable
use of SSL and server certificates. This ensures a data
encryption preventing <br>
compromise of authentication credentials. See the
vnc_security section for details on using SASL
authentication.</p>

<p style="margin-top: 1em">acl Turn on access control lists
for checking of the x509 client certificate and SASL party.
For x509 certs, the ACL check is made against the
certificate&rsquo;s distinguished <br>
name. This is something that looks like
&quot;C=GB,O=ACME,L=Boston,CN=bob&quot;. For SASL party, the
ACL check is made against the username, which depending on
the SASL plugin, may <br>
include a realm component, eg &quot;bob&quot; or
&quot;bob@EXAMPLE.COM&quot;. When the acl flag is set, the
initial access list will be empty, with a &quot;deny&quot;
policy. Thus no one will be <br>
allowed to use the VNC server until the ACLs have been
loaded. This can be achieved using the &quot;acl&quot;
monitor command.</p>

<p style="margin-top: 1em">lossy <br>
Enable lossy compression methods (gradient, JPEG, ...). If
this option is set, VNC client may receive lossy framebuffer
updates depending on its encoding settings. <br>
Enabling this option can save a lot of bandwidth at the
expense of quality.</p>

<p style="margin-top: 1em">non-adaptive <br>
Disable adaptive encodings. Adaptive encodings are enabled
by default. An adaptive encoding will try to detect
frequently updated screen regions, and send updates in <br>
these regions using a lossy encoding (like JPEG). This can
be really helpful to save bandwidth when playing videos.
Disabling adaptive encodings allows to restore the <br>
original static behavior of encodings like Tight.</p>


<p style="margin-top: 1em">share=[allow-exclusive|force-shared|ignore]
<br>
Set display sharing policy. &rsquo;allow-exclusive&rsquo;
allows clients to ask for exclusive access. As suggested by
the rfb spec this is implemented by dropping other <br>
connections. Connecting multiple clients in parallel
requires all clients asking for a shared session (vncviewer:
-shared switch). This is the default.
&rsquo;force-shared&rsquo; <br>
disables exclusive client access. Useful for shared desktop
sessions, where you don&rsquo;t want someone forgetting
specify -shared disconnect everybody else.
&rsquo;ignore&rsquo; <br>
completely ignores the shared flag and allows everybody
connect unconditionally. Doesn&rsquo;t conform to the rfb
spec but is traditional QEMU behavior.</p>

<p style="margin-top: 1em">i386 target only:</p>

<p style="margin-top: 1em">-win2k-hack <br>
Use it when installing Windows 2000 to avoid a disk full
bug. After Windows 2000 is installed, you no longer need
this option (this option slows down the IDE transfers).</p>

<p style="margin-top: 1em">-no-fd-bootchk <br>
Disable boot signature checking for floppy disks in BIOS.
May be needed to boot from old floppy disks.</p>

<p style="margin-top: 1em">-no-acpi <br>
Disable ACPI (Advanced Configuration and Power Interface)
support. Use it if your guest OS complains about ACPI
problems (PC target machine only).</p>

<p style="margin-top: 1em">-acpitable
[sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n]
[,asl_compiler_id=str][,asl_compiler_rev=n][,data=file1[:file2]...]
<br>
Add ACPI table with specified header fields and context from
specified files. For file=, take whole ACPI table from the
specified files, including all ACPI headers (possible <br>
overridden by other options). For data=, only data portion
of the table is used, all header information is specified in
the command line. If a SLIC table is supplied to <br>
QEMU, then the SLIC&rsquo;s oem_id and oem_table_id fields
will override the same in the RSDT and the FADT (a.k.a.
FACP), in order to ensure the field matches required by the
<br>
Microsoft SLIC spec and the ACPI spec.</p>

<p style="margin-top: 1em">-smbios file=binary <br>
Load SMBIOS entry from binary file.</p>

<p style="margin-top: 1em">-smbios
type=0[,vendor=str][,version=str][,date=str][,release=%d.%d]
<br>
Specify SMBIOS type 0 fields</p>

<p style="margin-top: 1em">-smbios
type=1[,manufacturer=str][,product=str]
[,version=str][,serial=str][,uuid=uuid][,sku=str]
[,family=str] <br>
Specify SMBIOS type 1 fields</p>

<p style="margin-top: 1em">Network options:</p>

<p style="margin-top: 1em">-net
nic[,vlan=n][,macaddr=mac][,model=type]
[,name=name][,addr=addr][,vectors=v] <br>
Create a new Network Interface Card and connect it to VLAN n
(n = 0 is the default). The NIC is an e1000 by default on
the PC target. Optionally, the MAC address can be <br>
changed to mac, the device address set to addr (PCI cards
only), and a name can be assigned for use in monitor
commands. Optionally, for PCI cards, you can specify the
<br>
number v of MSI-X vectors that the card should have; this
option currently only affects virtio cards; set v = 0 to
disable MSI-X. If no -net option is specified, a single NIC
<br>
is created. QEMU can emulate several different models of
network card. Valid values for type are &quot;virtio&quot;,
&quot;i82551&quot;, &quot;i82557b&quot;,
&quot;i82559er&quot;, &quot;ne2k_pci&quot;,
&quot;ne2k_isa&quot;, &quot;pcnet&quot;, <br>
&quot;rtl8139&quot;, &quot;e1000&quot;,
&quot;smc91c111&quot;, &quot;lance&quot; and
&quot;mcf_fec&quot;. Not all devices are supported on all
targets. Use &quot;-net nic,model=help&quot; for a list of
available devices for your <br>
target.</p>

<p style="margin-top: 1em">-netdev
user,id=id[,option][,option][,...] <br>
-net user[,option][,option][,...] <br>
Use the user mode network stack which requires no
administrator privilege to run. Valid options are:</p>

<p style="margin-top: 1em">vlan=n <br>
Connect user mode stack to VLAN n (n = 0 is the
default).</p>

<p style="margin-top: 1em">id=id <br>
name=name <br>
Assign symbolic name for use in monitor commands.</p>

<p style="margin-top: 1em">net=addr[/mask] <br>
Set IP network address the guest will see. Optionally
specify the netmask, either in the form a.b.c.d or as number
of valid top-most bits. Default is 10.0.2.0/24.</p>

<p style="margin-top: 1em">host=addr <br>
Specify the guest-visible address of the host. Default is
the 2nd IP in the guest network, i.e. x.x.x.2.</p>

<p style="margin-top: 1em">restrict=on|off <br>
If this option is enabled, the guest will be isolated, i.e.
it will not be able to contact the host and no guest IP
packets will be routed over the host to the outside. <br>
This option does not affect any explicitly set forwarding
rules.</p>

<p style="margin-top: 1em">hostname=name <br>
Specifies the client hostname reported by the built-in DHCP
server.</p>

<p style="margin-top: 1em">dhcpstart=addr <br>
Specify the first of the 16 IPs the built-in DHCP server can
assign. Default is the 15th to 31st IP in the guest network,
i.e. x.x.x.15 to x.x.x.31.</p>

<p style="margin-top: 1em">dns=addr <br>
Specify the guest-visible address of the virtual nameserver.
The address must be different from the host address. Default
is the 3rd IP in the guest network, i.e. <br>
x.x.x.3.</p>

<p style="margin-top: 1em">dnssearch=domain <br>
Provides an entry for the domain-search list sent by the
built-in DHCP server. More than one domain suffix can be
transmitted by specifying this option multiple times. If
<br>
supported, this will cause the guest to automatically try to
append the given domain suffix(es) in case a domain name can
not be resolved.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">qemu-kvm -net
user,dnssearch=mgmt.example.org,dnssearch=example.org
[...]</p>

<p style="margin-top: 1em">tftp=dir <br>
When using the user mode network stack, activate a built-in
TFTP server. The files in dir will be exposed as the root of
a TFTP server. The TFTP client on the guest must <br>
be configured in binary mode (use the command
&quot;bin&quot; of the Unix TFTP client).</p>

<p style="margin-top: 1em">bootfile=file <br>
When using the user mode network stack, broadcast file as
the BOOTP filename. In conjunction with tftp, this can be
used to network boot a guest from a local directory.</p>

<p style="margin-top: 1em">Example (using pxelinux):</p>

<p style="margin-top: 1em">qemu-kvm -hda linux.img -boot n
-net user,tftp=/path/to/tftp/files,bootfile=/pxelinux.0</p>

<p style="margin-top: 1em">smb=dir[,smbserver=addr] <br>
When using the user mode network stack, activate a built-in
SMB server so that Windows OSes can access to the host files
in dir transparently. The IP address of the SMB <br>
server can be set to addr. By default the 4th IP in the
guest network is used, i.e. x.x.x.4.</p>

<p style="margin-top: 1em">In the guest Windows OS, the
line:</p>

<p style="margin-top: 1em">10.0.2.4 smbserver</p>

<p style="margin-top: 1em">must be added in the file
C:WINDOWSOSTS (for windows 9x/Me) or C:WINNTTEM32STCOSTS
(Windows NT/2000).</p>

<p style="margin-top: 1em">Then dir can be accessed in
\smbserverqemu.</p>

<p style="margin-top: 1em">Note that a SAMBA server must be
installed on the host OS. QEMU was tested successfully with
smbd versions from Red Hat 9, Fedora Core 3 and OpenSUSE
11.x.</p>


<p style="margin-top: 1em">hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport
<br>
Redirect incoming TCP or UDP connections to the host port
hostport to the guest IP address guestaddr on guest port
guestport. If guestaddr is not specified, its value is <br>
x.x.x.15 (default first address given by the built-in DHCP
server). By specifying hostaddr, the rule can be bound to a
specific host interface. If no connection type is <br>
set, TCP is used. This option can be given multiple
times.</p>

<p style="margin-top: 1em">For example, to redirect host
X11 connection from screen 1 to guest screen 0, use the
following:</p>

<p style="margin-top: 1em"># on the host <br>
qemu-kvm -net user,hostfwd=tcp:127.0.0.1:6001-:6000 [...]
<br>
# this host xterm should open in the guest X11 server <br>
xterm -display :1</p>

<p style="margin-top: 1em">To redirect telnet connections
from host port 5555 to telnet port on the guest, use the
following:</p>

<p style="margin-top: 1em"># on the host <br>
qemu-kvm -net user,hostfwd=tcp::5555-:23 [...] <br>
telnet localhost 5555</p>

<p style="margin-top: 1em">Then when you use on the host
&quot;telnet localhost 5555&quot;, you connect to the guest
telnet server.</p>

<p style="margin-top: 1em">guestfwd=[tcp]:server:port-dev
<br>
guestfwd=[tcp]:server:port-cmd:command <br>
Forward guest TCP connections to the IP address server on
port port to the character device dev or to a program
executed by cmd:command which gets spawned for each <br>
connection. This option can be given multiple times.</p>

<p style="margin-top: 1em">You can either use a chardev
directly and have that one used throughout QEMU&rsquo;s
lifetime, like in the following example:</p>

<p style="margin-top: 1em"># open 10.10.1.1:4321 on bootup,
connect 10.0.2.100:1234 to it whenever <br>
# the guest accesses it <br>
qemu-kvm -net
user,guestfwd=tcp:10.0.2.100:1234-tcp:10.10.1.1:4321
[...]</p>

<p style="margin-top: 1em">Or you can execute a command on
every TCP connection established by the guest, so that QEMU
behaves similar to an inetd process for that virtual
server:</p>

<p style="margin-top: 1em"># call &quot;netcat 10.10.1.1
4321&quot; on every TCP connection to 10.0.2.100:1234 <br>
# and connect the TCP stream to its stdin/stdout <br>
qemu-kvm -net
&rsquo;user,guestfwd=tcp:10.0.2.100:1234-cmd:netcat
10.10.1.1 4321&rsquo;</p>

<p style="margin-top: 1em">Note: Legacy stand-alone options
-tftp, -bootp, -smb and -redir are still processed and
applied to -net user. Mixing them with the new configuration
syntax gives undefined <br>
results. Their use for new applications is discouraged as
they will be removed from future versions.</p>

<p style="margin-top: 1em">-netdev
tap,id=id[,fd=h][,ifname=name][,script=file][,downscript=dfile][,helper=helper]
<br>
-net
tap[,vlan=n][,name=name][,fd=h][,ifname=name][,script=file][,downscript=dfile][,helper=helper]
<br>
Connect the host TAP network interface name to VLAN n.</p>

<p style="margin-top: 1em">Use the network script file to
configure it and the network script dfile to deconfigure it.
If name is not provided, the OS automatically provides one.
The default network <br>
configure script is /etc/qemu-ifup and the default network
deconfigure script is /etc/qemu-ifdown. Use script=no or
downscript=no to disable script execution.</p>

<p style="margin-top: 1em">If running QEMU as an
unprivileged user, use the network helper helper to
configure the TAP interface. The default network helper
executable is /path/to/qemu-bridge-helper.</p>

<p style="margin-top: 1em">fd=h can be used to specify the
handle of an already opened host TAP interface.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">#launch a QEMU instance with the
default network script <br>
qemu-kvm linux.img -net nic -net tap</p>

<p style="margin-top: 1em">#launch a QEMU instance with two
NICs, each one connected <br>
#to a TAP device <br>
qemu-kvm linux.img -net nic,vlan=0 -net
tap,vlan=0,ifname=tap0 -net nic,vlan=1 -net
tap,vlan=1,ifname=tap1</p>

<p style="margin-top: 1em">#launch a QEMU instance with the
default network helper to <br>
#connect a TAP device to bridge br0 <br>
qemu-kvm linux.img -net nic -net
tap,&quot;helper=/path/to/qemu-bridge-helper&quot;</p>

<p style="margin-top: 1em">-netdev
bridge,id=id[,br=bridge][,helper=helper] <br>
-net bridge[,vlan=n][,name=name][,br=bridge][,helper=helper]
<br>
Connect a host TAP network interface to a host bridge
device.</p>

<p style="margin-top: 1em">Use the network helper helper to
configure the TAP interface and attach it to the bridge. The
default network helper executable is
/path/to/qemu-bridge-helper and the default <br>
bridge device is br0.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">#launch a QEMU instance with the
default network helper to <br>
#connect a TAP device to bridge br0 <br>
qemu-kvm linux.img -net bridge -net nic,model=virtio</p>

<p style="margin-top: 1em">#launch a QEMU instance with the
default network helper to <br>
#connect a TAP device to bridge qemubr0 <br>
qemu-kvm linux.img -net bridge,br=qemubr0 -net
nic,model=virtio</p>

<p style="margin-top: 1em">-netdev
socket,id=id[,fd=h][,listen=[host]:port][,connect=host:port]
<br>
-net socket[,vlan=n][,name=name][,fd=h]
[,listen=[host]:port][,connect=host:port] <br>
Connect the VLAN n to a remote VLAN in another QEMU virtual
machine using a TCP socket connection. If listen is
specified, QEMU waits for incoming connections on port (host
<br>
is optional). connect is used to connect to another QEMU
instance using the listen option. fd=h specifies an already
opened TCP socket.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em"># launch a first QEMU instance
<br>
qemu-kvm linux.img -net nic,macaddr=52:54:00:12:34:56 -net
socket,listen=:1234 <br>
# connect the VLAN 0 of this instance to the VLAN 0 <br>
# of the first instance <br>
qemu-kvm linux.img -net nic,macaddr=52:54:00:12:34:57 -net
socket,connect=127.0.0.1:1234</p>

<p style="margin-top: 1em">-netdev
socket,id=id[,fd=h][,mcast=maddr:port[,localaddr=addr]] <br>
-net
socket[,vlan=n][,name=name][,fd=h][,mcast=maddr:port[,localaddr=addr]]
<br>
Create a VLAN n shared with another QEMU virtual machines
using a UDP multicast socket, effectively making a bus for
every QEMU with same multicast address maddr and port. <br>
NOTES:</p>

<p style="margin-top: 1em">1. Several QEMU can be running
on different hosts and share same bus (assuming correct
multicast setup for these hosts).</p>

<p style="margin-top: 1em">2. mcast support is compatible
with User Mode Linux (argument ethN=mcast), see
&lt;http://user-mode-linux.sf.net&gt;.</p>

<p style="margin-top: 1em">3. Use fd=h to specify an
already opened UDP multicast socket.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em"># launch one QEMU instance <br>
qemu-kvm linux.img -net nic,macaddr=52:54:00:12:34:56 -net
socket,mcast=230.0.0.1:1234 <br>
# launch another QEMU instance on same &quot;bus&quot; <br>
qemu-kvm linux.img -net nic,macaddr=52:54:00:12:34:57 -net
socket,mcast=230.0.0.1:1234 <br>
# launch yet another QEMU instance on same &quot;bus&quot;
<br>
qemu-kvm linux.img -net nic,macaddr=52:54:00:12:34:58 -net
socket,mcast=230.0.0.1:1234</p>

<p style="margin-top: 1em">Example (User Mode Linux
compat.):</p>

<p style="margin-top: 1em"># launch QEMU instance (note
mcast address selected <br>
# is UML&rsquo;s default) <br>
qemu-kvm linux.img -net nic,macaddr=52:54:00:12:34:56 -net
socket,mcast=239.192.168.1:1102 <br>
# launch UML <br>
/path/to/linux ubd0=/path/to/root_fs eth0=mcast</p>

<p style="margin-top: 1em">Example (send packets from
host&rsquo;s 1.2.3.4):</p>

<p style="margin-top: 1em">qemu-kvm linux.img -net
nic,macaddr=52:54:00:12:34:56 -net
socket,mcast=239.192.168.1:1102,localaddr=1.2.3.4</p>

<p style="margin-top: 1em">-netdev
vde,id=id[,sock=socketpath][,port=n][,group=groupname][,mode=octalmode]
<br>
-net vde[,vlan=n][,name=name][,sock=socketpath]
[,port=n][,group=groupname][,mode=octalmode] <br>
Connect VLAN n to PORT n of a vde switch running on host and
listening for incoming connections on socketpath. Use GROUP
groupname and MODE octalmode to change default <br>
ownership and permissions for communication port. This
option is only available if QEMU has been compiled with vde
support enabled.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em"># launch vde switch <br>
vde_switch -F -sock /tmp/myswitch <br>
# launch QEMU instance <br>
qemu-kvm linux.img -net nic -net vde,sock=/tmp/myswitch</p>

<p style="margin-top: 1em">-netdev
hubport,id=id,hubid=hubid <br>
Create a hub port on QEMU &quot;vlan&quot; hubid.</p>

<p style="margin-top: 1em">The hubport netdev lets you
connect a NIC to a QEMU &quot;vlan&quot; instead of a single
netdev. &quot;-net&quot; and &quot;-device&quot; with
parameter vlan create the required hub automatically.</p>

<p style="margin-top: 1em">-net
dump[,vlan=n][,file=file][,len=len] <br>
Dump network traffic on VLAN n to file file (qemu-vlan0.pcap
by default). At most len bytes (64k by default) per packet
are stored. The file format is libpcap, so it can be <br>
analyzed with tools such as tcpdump or Wireshark.</p>

<p style="margin-top: 1em">-net none <br>
Indicate that no network devices should be configured. It is
used to override the default configuration (-net nic -net
user) which is activated if no -net options are <br>
provided.</p>

<p style="margin-top: 1em">Character device options:</p>

<p style="margin-top: 1em">The general form of a character
device option is:</p>

<p style="margin-top: 1em">-chardev backend ,id=id
[,mux=on|off] [,options] <br>
Backend is one of: null, socket, udp, msmouse, vc, ringbuf,
file, pipe, console, serial, pty, stdio, braille, tty,
parallel, parport, spicevmc. spiceport. The specific <br>
backend will determine the applicable options.</p>

<p style="margin-top: 1em">All devices must have an id,
which can be any string up to 127 characters long. It is
used to uniquely identify this device in other command line
directives.</p>

<p style="margin-top: 1em">A character device may be used
in multiplexing mode by multiple front-ends. The key
sequence of Control-a and c will rotate the input focus
between attached front-ends. <br>
Specify mux=on to enable this mode.</p>

<p style="margin-top: 1em">Options to each backend are
described below.</p>

<p style="margin-top: 1em">-chardev null ,id=id <br>
A void device. This device will not emit any data, and will
drop any data it receives. The null backend does not take
any options.</p>

<p style="margin-top: 1em">-chardev socket ,id=id [TCP
options or unix options] [,server] [,nowait] [,telnet] <br>
Create a two-way stream socket, which can be either a TCP or
a unix socket. A unix socket will be created if path is
specified. Behaviour is undefined if TCP options are <br>
specified for a unix socket.</p>

<p style="margin-top: 1em">server specifies that the socket
shall be a listening socket.</p>

<p style="margin-top: 1em">nowait specifies that QEMU
should not block waiting for a client to connect to a
listening socket.</p>

<p style="margin-top: 1em">telnet specifies that traffic on
the socket should interpret telnet escape sequences.</p>

<p style="margin-top: 1em">TCP and unix socket options are
given below:</p>

<p style="margin-top: 1em">TCP options: port=port
[,host=host] [,to=to] [,ipv4] [,ipv6] [,nodelay] <br>
host for a listening socket specifies the local address to
be bound. For a connecting socket species the remote host to
connect to. host is optional for listening <br>
sockets. If not specified it defaults to 0.0.0.0.</p>

<p style="margin-top: 1em">port for a listening socket
specifies the local port to be bound. For a connecting
socket specifies the port on the remote host to connect to.
port can be given as <br>
either a port number or a service name. port is
required.</p>

<p style="margin-top: 1em">to is only relevant to listening
sockets. If it is specified, and port cannot be bound, QEMU
will attempt to bind to subsequent ports up to and including
to until it <br>
succeeds. to must be specified as a port number.</p>

<p style="margin-top: 1em">ipv4 and ipv6 specify that
either IPv4 or IPv6 must be used. If neither is specified
the socket may use either protocol.</p>

<p style="margin-top: 1em">nodelay disables the Nagle
algorithm.</p>

<p style="margin-top: 1em">unix options: path=path <br>
path specifies the local path of the unix socket. path is
required.</p>

<p style="margin-top: 1em">-chardev udp ,id=id [,host=host]
,port=port [,localaddr=localaddr] [,localport=localport]
[,ipv4] [,ipv6] <br>
Sends all traffic from the guest to a remote host over
UDP.</p>

<p style="margin-top: 1em">host specifies the remote host
to connect to. If not specified it defaults to
&quot;localhost&quot;.</p>

<p style="margin-top: 1em">port specifies the port on the
remote host to connect to. port is required.</p>

<p style="margin-top: 1em">localaddr specifies the local
address to bind to. If not specified it defaults to
0.0.0.0.</p>

<p style="margin-top: 1em">localport specifies the local
port to bind to. If not specified any available local port
will be used.</p>

<p style="margin-top: 1em">ipv4 and ipv6 specify that
either IPv4 or IPv6 must be used. If neither is specified
the device may use either protocol.</p>

<p style="margin-top: 1em">-chardev msmouse ,id=id <br>
Forward QEMU&rsquo;s emulated msmouse events to the guest.
msmouse does not take any options.</p>

<p style="margin-top: 1em">-chardev vc ,id=id
[[,width=width] [,height=height]] [[,cols=cols]
[,rows=rows]] <br>
Connect to a QEMU text console. vc may optionally be given a
specific size.</p>

<p style="margin-top: 1em">width and height specify the
width and height respectively of the console, in pixels.</p>

<p style="margin-top: 1em">cols and rows specify that the
console be sized to fit a text console with the given
dimensions.</p>

<p style="margin-top: 1em">-chardev ringbuf ,id=id
[,size=size] <br>
Create a ring buffer with fixed size size. size must be a
power of two, and defaults to &quot;64K&quot;).</p>

<p style="margin-top: 1em">-chardev file ,id=id ,path=path
<br>
Log all traffic received from the guest to a file.</p>

<p style="margin-top: 1em">path specifies the path of the
file to be opened. This file will be created if it does not
already exist, and overwritten if it does. path is
required.</p>

<p style="margin-top: 1em">-chardev pipe ,id=id ,path=path
<br>
Create a two-way connection to the guest. The behaviour
differs slightly between Windows hosts and other hosts:</p>

<p style="margin-top: 1em">On Windows, a single duplex pipe
will be created at \.pipeath.</p>

<p style="margin-top: 1em">On other hosts, 2 pipes will be
created called path.in and path.out. Data written to path.in
will be received by the guest. Data written by the guest can
be read from <br>
path.out. QEMU will not create these fifos, and requires
them to be present.</p>

<p style="margin-top: 1em">path forms part of the pipe path
as described above. path is required.</p>

<p style="margin-top: 1em">-chardev console ,id=id <br>
Send traffic from the guest to QEMU&rsquo;s standard output.
console does not take any options.</p>

<p style="margin-top: 1em">console is only available on
Windows hosts.</p>

<p style="margin-top: 1em">-chardev serial ,id=id
,path=path <br>
Send traffic from the guest to a serial device on the
host.</p>

<p style="margin-top: 1em">On Unix hosts serial will
actually accept any tty device, not only serial lines.</p>

<p style="margin-top: 1em">path specifies the name of the
serial device to open.</p>

<p style="margin-top: 1em">-chardev pty ,id=id <br>
Create a new pseudo-terminal on the host and connect to it.
pty does not take any options.</p>

<p style="margin-top: 1em">pty is not available on Windows
hosts.</p>

<p style="margin-top: 1em">-chardev stdio ,id=id
[,signal=on|off] <br>
Connect to standard input and standard output of the QEMU
process.</p>

<p style="margin-top: 1em">signal controls if signals are
enabled on the terminal, that includes exiting QEMU with the
key sequence Control-c. This option is enabled by default,
use signal=off to <br>
disable it.</p>

<p style="margin-top: 1em">stdio is not available on
Windows hosts.</p>

<p style="margin-top: 1em">-chardev braille ,id=id <br>
Connect to a local BrlAPI server. braille does not take any
options.</p>

<p style="margin-top: 1em">-chardev tty ,id=id ,path=path
<br>
tty is only available on Linux, Sun, FreeBSD, NetBSD,
OpenBSD and DragonFlyBSD hosts. It is an alias for
serial.</p>

<p style="margin-top: 1em">path specifies the path to the
tty. path is required.</p>

<p style="margin-top: 1em">-chardev parallel ,id=id
,path=path <br>
-chardev parport ,id=id ,path=path <br>
parallel is only available on Linux, FreeBSD and
DragonFlyBSD hosts.</p>

<p style="margin-top: 1em">Connect to a local parallel
port.</p>

<p style="margin-top: 1em">path specifies the path to the
parallel port device. path is required.</p>

<p style="margin-top: 1em">-chardev spicevmc ,id=id
,debug=debug, name=name <br>
spicevmc is only available when spice support is built
in.</p>

<p style="margin-top: 1em">debug debug level for
spicevmc</p>

<p style="margin-top: 1em">name name of spice channel to
connect to</p>

<p style="margin-top: 1em">Connect to a spice virtual
machine channel, such as vdiport.</p>

<p style="margin-top: 1em">-chardev spiceport ,id=id
,debug=debug, name=name <br>
spiceport is only available when spice support is built
in.</p>

<p style="margin-top: 1em">debug debug level for
spicevmc</p>

<p style="margin-top: 1em">name name of spice port to
connect to</p>

<p style="margin-top: 1em">Connect to a spice port,
allowing a Spice client to handle the traffic identified by
a name (preferably a fqdn).</p>

<p style="margin-top: 1em">Device URL Syntax:</p>

<p style="margin-top: 1em">In addition to using normal file
images for the emulated storage devices, QEMU can also use
networked resources such as iSCSI devices. These are
specified using a special URL <br>
syntax.</p>

<p style="margin-top: 1em">iSCSI <br>
iSCSI support allows QEMU to access iSCSI resources directly
and use as images for the guest storage. Both disk and cdrom
images are supported.</p>

<p style="margin-top: 1em">Syntax for specifying iSCSI LUNs
is
&quot;iscsi://&lt;target-ip&gt;[:&lt;port&gt;]/&lt;target-iqn&gt;/&lt;lun&gt;&quot;</p>

<p style="margin-top: 1em">By default qemu-kvm will use the
iSCSI initiator-name
&rsquo;iqn.2008-11.org.linux-kvm[:&lt;name&gt;]&rsquo; but
this can also be set from the command line or a
configuration file.</p>

<p style="margin-top: 1em">Example (without
authentication):</p>

<p style="margin-top: 1em">qemu-kvm -iscsi
initiator-name=iqn.2001-04.com.example:my-initiator -cdrom
iscsi://192.0.2.1/iqn.2001-04.com.example/2 -drive
file=iscsi://192.0.2.1/iqn.2001-04.com.example/1</p>

<p style="margin-top: 1em">Example (CHAP username/password
via URL):</p>

<p style="margin-top: 1em">qemu-kvm -drive
file=iscsi://user%password@192.0.2.1/iqn.2001-04.com.example/1</p>

<p style="margin-top: 1em">Example (CHAP username/password
via environment variables):</p>


<p style="margin-top: 1em">LIBISCSI_CHAP_USERNAME=&quot;user&quot;
LIBISCSI_CHAP_PASSWORD=&quot;password&quot; qemu-kvm -drive
file=iscsi://192.0.2.1/iqn.2001-04.com.example/1</p>

<p style="margin-top: 1em">iSCSI support is an optional
feature of QEMU and only available when compiled and linked
against libiscsi.</p>

<p style="margin-top: 1em">iSCSI parameters such as
username and password can also be specified via a
configuration file. See qemu-doc for more information and
examples.</p>

<p style="margin-top: 1em">NBD QEMU supports NBD (Network
Block Devices) both using TCP protocol as well as Unix
Domain Sockets.</p>

<p style="margin-top: 1em">Syntax for specifying a NBD
device using TCP
&quot;nbd:&lt;server-ip&gt;:&lt;port&gt;[:exportname=&lt;export&gt;]&quot;</p>

<p style="margin-top: 1em">Syntax for specifying a NBD
device using Unix Domain Sockets
&quot;nbd:unix:&lt;domain-socket&gt;[:exportname=&lt;export&gt;]&quot;</p>

<p style="margin-top: 1em">Example for TCP</p>

<p style="margin-top: 1em">qemu-kvm --drive
file=nbd:192.0.2.1:30000</p>

<p style="margin-top: 1em">Example for Unix Domain
Sockets</p>

<p style="margin-top: 1em">qemu-kvm --drive
file=nbd:unix:/tmp/nbd-socket</p>

<p style="margin-top: 1em">SSH QEMU supports SSH (Secure
Shell) access to remote disks.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">qemu-kvm -drive
file=ssh://user@host/path/to/disk.img <br>
qemu-kvm -drive
file.driver=ssh,file.user=user,file.host=host,file.port=22,file.path=/path/to/disk.img</p>

<p style="margin-top: 1em">Currently authentication must be
done using ssh-agent. Other authentication methods may be
supported in future.</p>

<p style="margin-top: 1em">Sheepdog <br>
Sheepdog is a distributed storage system for QEMU. QEMU
supports using either local sheepdog devices or remote
networked devices.</p>

<p style="margin-top: 1em">Syntax for specifying a sheepdog
device</p>


<p style="margin-top: 1em">sheepdog[+tcp|+unix]://[host:port]/vdiname[?socket=path][#snapid|#tag]</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">qemu-kvm --drive
file=sheepdog://192.0.2.1:30000/MyVirtualMachine</p>

<p style="margin-top: 1em">See also
&lt;http://http://www.osrg.net/sheepdog/&gt;.</p>

<p style="margin-top: 1em">GlusterFS <br>
GlusterFS is an user space distributed file system. QEMU
supports the use of GlusterFS volumes for hosting VM disk
images using TCP, Unix Domain Sockets and RDMA transport
<br>
protocols.</p>

<p style="margin-top: 1em">Syntax for specifying a VM disk
image on GlusterFS volume is</p>


<p style="margin-top: 1em">gluster[+transport]://[server[:port]]/volname/image[?socket=...]</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">qemu-kvm --drive
file=gluster://192.0.2.1/testvol/a.img</p>

<p style="margin-top: 1em">See also
&lt;http://www.gluster.org&gt;.</p>

<p style="margin-top: 1em">Bluetooth(R) options:</p>

<p style="margin-top: 1em">-bt hci[...] <br>
Defines the function of the corresponding Bluetooth HCI. -bt
options are matched with the HCIs present in the chosen
machine type. For example when emulating a machine with <br>
only one HCI built into it, only the first &quot;-bt
hci[...]&quot; option is valid and defines the HCI&rsquo;s
logic. The Transport Layer is decided by the machine type.
Currently the <br>
machines &quot;n800&quot; and &quot;n810&quot; have one HCI
and all other machines have none.</p>

<p style="margin-top: 1em">The following three types are
recognized:</p>

<p style="margin-top: 1em">-bt hci,null <br>
(default) The corresponding Bluetooth HCI assumes no
internal logic and will not respond to any HCI commands or
emit events.</p>

<p style="margin-top: 1em">-bt hci,host[:id] <br>
(&quot;bluez&quot; only) The corresponding HCI passes
commands / events to / from the physical HCI identified by
the name id (default: &quot;hci0&quot;) on the computer
running QEMU. Only <br>
available on &quot;bluez&quot; capable systems like
Linux.</p>

<p style="margin-top: 1em">-bt hci[,vlan=n] <br>
Add a virtual, standard HCI that will participate in the
Bluetooth scatternet n (default 0). Similarly to -net VLANs,
devices inside a bluetooth network n can only <br>
communicate with other devices in the same network
(scatternet).</p>

<p style="margin-top: 1em">-bt vhci[,vlan=n] <br>
(Linux-host only) Create a HCI in scatternet n (default 0)
attached to the host bluetooth stack instead of to the
emulated target. This allows the host and target machines
<br>
to participate in a common scatternet and communicate.
Requires the Linux &quot;vhci&quot; driver installed. Can be
used as following:</p>

<p style="margin-top: 1em">qemu-kvm [...OPTIONS...] -bt
hci,vlan=5 -bt vhci,vlan=5</p>

<p style="margin-top: 1em">-bt device:dev[,vlan=n] <br>
Emulate a bluetooth device dev and place it in network n
(default 0). QEMU can only emulate one type of bluetooth
devices currently:</p>

<p style="margin-top: 1em">keyboard <br>
Virtual wireless keyboard implementing the HIDP bluetooth
profile.</p>

<p style="margin-top: 1em">TPM device options:</p>

<p style="margin-top: 1em">The general form of a TPM device
option is:</p>

<p style="margin-top: 1em">-tpmdev backend ,id=id
[,options] <br>
Backend type must be: passthrough.</p>

<p style="margin-top: 1em">The specific backend type will
determine the applicable options. The &quot;-tpmdev&quot;
option creates the TPM backend and requires a
&quot;-device&quot; option that specifies the TPM frontend
<br>
interface model.</p>

<p style="margin-top: 1em">Options to each backend are
described below.</p>

<p style="margin-top: 1em">Use &rsquo;help&rsquo; to print
all available TPM backend types.</p>

<p style="margin-top: 1em">qemu-kvm -tpmdev help</p>

<p style="margin-top: 1em">-tpmdev passthrough, id=id,
path=path, cancel-path=cancel-path <br>
(Linux-host only) Enable access to the host&rsquo;s TPM
using the passthrough driver.</p>

<p style="margin-top: 1em">path specifies the path to the
host&rsquo;s TPM device, i.e., on a Linux host this would be
&quot;/dev/tpm0&quot;. path is optional and by default
&quot;/dev/tpm0&quot; is used.</p>

<p style="margin-top: 1em">cancel-path specifies the path
to the host TPM device&rsquo;s sysfs entry allowing for
cancellation of an ongoing TPM command. cancel-path is
optional and by default QEMU will <br>
search for the sysfs entry to use.</p>

<p style="margin-top: 1em">Some notes about using the
host&rsquo;s TPM with the passthrough driver:</p>

<p style="margin-top: 1em">The TPM device accessed by the
passthrough driver must not be used by any other application
on the host.</p>

<p style="margin-top: 1em">Since the host&rsquo;s firmware
(BIOS/UEFI) has already initialized the TPM, the VM&rsquo;s
firmware (BIOS/UEFI) will not be able to initialize the TPM
again and may therefore not show a <br>
TPM-specific menu that would otherwise allow the user to
configure the TPM, e.g., allow the user to enable/disable or
activate/deactivate the TPM. Further, if TPM ownership <br>
is released from within a VM then the host&rsquo;s TPM will
get disabled and deactivated. To enable and activate the TPM
again afterwards, the host has to be rebooted and the user
<br>
is required to enter the firmware&rsquo;s menu to enable and
activate the TPM. If the TPM is left disabled and/or
deactivated most TPM commands will fail.</p>

<p style="margin-top: 1em">To create a passthrough TPM use
the following two options:</p>

<p style="margin-top: 1em">-tpmdev passthrough,id=tpm0
-device tpm-tis,tpmdev=tpm0</p>

<p style="margin-top: 1em">Note that the
&quot;-tpmdev&quot; id is &quot;tpm0&quot; and is referenced
by &quot;tpmdev=tpm0&quot; in the device option.</p>

<p style="margin-top: 1em">Linux/Multiboot boot
specific:</p>

<p style="margin-top: 1em">When using these options, you
can use a given Linux or Multiboot kernel without installing
it in the disk image. It can be useful for easier testing of
various kernels.</p>

<p style="margin-top: 1em">-kernel bzImage <br>
Use bzImage as kernel image. The kernel can be either a
Linux kernel or in multiboot format.</p>

<p style="margin-top: 1em">-append cmdline <br>
Use cmdline as kernel command line</p>

<p style="margin-top: 1em">-initrd file <br>
Use file as initial ram disk.</p>

<p style="margin-top: 1em">-initrd &quot;file1
arg=foo,file2&quot; <br>
This syntax is only available with multiboot.</p>

<p style="margin-top: 1em">Use file1 and file2 as modules
and pass arg=foo as parameter to the first module.</p>

<p style="margin-top: 1em">-dtb file <br>
Use file as a device tree binary (dtb) image and pass it to
the kernel on boot.</p>

<p style="margin-top: 1em">Debug/Expert options:</p>

<p style="margin-top: 1em">-serial dev <br>
Redirect the virtual serial port to host character device
dev. The default device is &quot;vc&quot; in graphical mode
and &quot;stdio&quot; in non graphical mode.</p>

<p style="margin-top: 1em">This option can be used several
times to simulate up to 4 serial ports.</p>

<p style="margin-top: 1em">Use &quot;-serial none&quot; to
disable all serial ports.</p>

<p style="margin-top: 1em">Available character devices
are:</p>

<p style="margin-top: 1em">vc[:WxH] <br>
Virtual console. Optionally, a width and height can be given
in pixel with</p>

<p style="margin-top: 1em">vc:800x600</p>

<p style="margin-top: 1em">It is also possible to specify
width or height in characters:</p>

<p style="margin-top: 1em">vc:80Cx24C</p>

<p style="margin-top: 1em">pty [Linux only] Pseudo TTY (a
new PTY is automatically allocated)</p>

<p style="margin-top: 1em">none <br>
No device is allocated.</p>

<p style="margin-top: 1em">null <br>
void device</p>

<p style="margin-top: 1em">/dev/XXX <br>
[Linux only] Use host tty, e.g. /dev/ttyS0. The host serial
port parameters are set according to the emulated ones.</p>

<p style="margin-top: 1em">/dev/parportN <br>
[Linux only, parallel port only] Use host parallel port N.
Currently SPP and EPP parallel port features can be
used.</p>

<p style="margin-top: 1em">file:filename <br>
Write output to filename. No character can be read.</p>

<p style="margin-top: 1em">stdio <br>
[Unix only] standard input/output</p>

<p style="margin-top: 1em">pipe:filename <br>
name pipe filename</p>

<p style="margin-top: 1em">COMn <br>
[Windows only] Use host serial port n</p>


<p style="margin-top: 1em">udp:[remote_host]:remote_port[@[src_ip]:src_port]
<br>
This implements UDP Net Console. When remote_host or src_ip
are not specified they default to 0.0.0.0. When not using a
specified src_port a random port is <br>
automatically chosen.</p>

<p style="margin-top: 1em">If you just want a simple
readonly console you can use &quot;netcat&quot; or
&quot;nc&quot;, by starting QEMU with: &quot;-serial
udp::4555&quot; and nc as: &quot;nc -u -l -p 4555&quot;. Any
time QEMU writes <br>
something to that port it will appear in the netconsole
session.</p>

<p style="margin-top: 1em">If you plan to send characters
back via netconsole or you want to stop and start QEMU a lot
of times, you should have QEMU use the same source port each
time by using <br>
something like &quot;-serial udp::4555@4556&quot; to QEMU.
Another approach is to use a patched version of netcat which
can listen to a TCP port and send and receive characters via
<br>
udp. If you have a patched version of netcat which activates
telnet remote echo and single char transfer, then you can
use the following options to step up a netcat <br>
redirector to allow telnet on port 5555 to access the QEMU
port.</p>

<p style="margin-top: 1em">&quot;QEMU Options:&quot; <br>
-serial udp::4555@4556</p>

<p style="margin-top: 1em">&quot;netcat options:&quot; <br>
-u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T</p>

<p style="margin-top: 1em">&quot;telnet options:&quot; <br>
localhost 5555</p>


<p style="margin-top: 1em">tcp:[host]:port[,server][,nowait][,nodelay]
<br>
The TCP Net Console has two modes of operation. It can send
the serial I/O to a location or wait for a connection from a
location. By default the TCP Net Console is <br>
sent to host at the port. If you use the server option QEMU
will wait for a client socket application to connect to the
port before continuing, unless the &quot;nowait&quot; <br>
option was specified. The &quot;nodelay&quot; option
disables the Nagle buffering algorithm. If host is omitted,
0.0.0.0 is assumed. Only one TCP connection at a time is
<br>
accepted. You can use &quot;telnet&quot; to connect to the
corresponding character device.</p>

<p style="margin-top: 1em">&quot;Example to send tcp
console to 192.168.0.2 port 4444&quot; <br>
-serial tcp:192.168.0.2:4444</p>

<p style="margin-top: 1em">&quot;Example to listen and wait
on port 4444 for connection&quot; <br>
-serial tcp::4444,server</p>

<p style="margin-top: 1em">&quot;Example to not wait and
listen on ip 192.168.0.100 port 4444&quot; <br>
-serial tcp:192.168.0.100:4444,server,nowait</p>


<p style="margin-top: 1em">telnet:host:port[,server][,nowait][,nodelay]
<br>
The telnet protocol is used instead of raw tcp sockets. The
options work the same as if you had specified &quot;-serial
tcp&quot;. The difference is that the port acts like a <br>
telnet server or client using telnet option negotiation.
This will also allow you to send the MAGIC_SYSRQ sequence if
you use a telnet that supports sending the break <br>
sequence. Typically in unix telnet you do it with Control-]
and then type &quot;send break&quot; followed by pressing
the enter key.</p>

<p style="margin-top: 1em">unix:path[,server][,nowait] <br>
A unix domain socket is used instead of a tcp socket. The
option works the same as if you had specified &quot;-serial
tcp&quot; except the unix domain socket path is used for
<br>
connections.</p>

<p style="margin-top: 1em">mon:dev_string <br>
This is a special option to allow the monitor to be
multiplexed onto another serial port. The monitor is
accessed with key sequence of Control-a and then pressing c.
See <br>
monitor access pcsys_keys in the -nographic section for more
keys. dev_string should be any one of the serial devices
specified above. An example to multiplex the <br>
monitor onto a telnet server listening on port 4444 would
be:</p>

<p style="margin-top: 1em">&quot;-serial
mon:telnet::4444,server,nowait&quot; <br>
braille <br>
Braille device. This will use BrlAPI to display the braille
output on a real or fake device.</p>

<p style="margin-top: 1em">msmouse <br>
Three button serial mouse. Configure the guest to use
Microsoft protocol.</p>

<p style="margin-top: 1em">-parallel dev <br>
Redirect the virtual parallel port to host device dev (same
devices as the serial port). On Linux hosts, /dev/parportN
can be used to use hardware devices connected on the <br>
corresponding host parallel port.</p>

<p style="margin-top: 1em">This option can be used several
times to simulate up to 3 parallel ports.</p>

<p style="margin-top: 1em">Use &quot;-parallel none&quot;
to disable all parallel ports.</p>

<p style="margin-top: 1em">-monitor dev <br>
Redirect the monitor to host device dev (same devices as the
serial port). The default device is &quot;vc&quot; in
graphical mode and &quot;stdio&quot; in non graphical
mode.</p>

<p style="margin-top: 1em">-qmp dev <br>
Like -monitor but opens in &rsquo;control&rsquo; mode.</p>

<p style="margin-top: 1em">-mon
chardev=[name][,mode=readline|control][,default] <br>
Setup monitor on chardev name.</p>

<p style="margin-top: 1em">-debugcon dev <br>
Redirect the debug console to host device dev (same devices
as the serial port). The debug console is an I/O port which
is typically port 0xe9; writing to that I/O port <br>
sends output to this device. The default device is
&quot;vc&quot; in graphical mode and &quot;stdio&quot; in
non graphical mode.</p>

<p style="margin-top: 1em">-pidfile file <br>
Store the QEMU process PID in file. It is useful if you
launch QEMU from a script.</p>

<p style="margin-top: 1em">-singlestep <br>
Run the emulation in single step mode.</p>

<p style="margin-top: 1em">-S Do not start CPU at startup
(you must type &rsquo;c&rsquo; in the monitor).</p>

<p style="margin-top: 1em">-realtime mlock=on|off <br>
Run qemu-kvm with realtime features. mlocking qemu-kvm and
guest memory can be enabled via mlock=on (enabled by
default).</p>

<p style="margin-top: 1em">-gdb dev <br>
Wait for gdb connection on device dev. Typical connections
will likely be TCP-based, but also UDP, pseudo TTY, or even
stdio are reasonable use case. The latter is allowing <br>
to start QEMU from within gdb and establish the connection
via a pipe:</p>

<p style="margin-top: 1em">(gdb) target remote | exec
qemu-kvm -gdb stdio ...</p>

<p style="margin-top: 1em">-s Shorthand for -gdb tcp::1234,
i.e. open a gdbserver on TCP port 1234.</p>

<p style="margin-top: 1em">-d item1[,...] <br>
Enable logging of specified items. Use &rsquo;-d help&rsquo;
for a list of log items.</p>

<p style="margin-top: 1em">-D logfile <br>
Output log in logfile instead of to stderr</p>

<p style="margin-top: 1em">-L path <br>
Set the directory for the BIOS, VGA BIOS and keymaps.</p>

<p style="margin-top: 1em">-bios file <br>
Set the filename for the BIOS.</p>

<p style="margin-top: 1em">-enable-kvm <br>
Enable KVM full virtualization support. This option is only
available if KVM support is enabled when compiling.</p>

<p style="margin-top: 1em">-xen-domid id <br>
Specify xen guest domain id (XEN only).</p>

<p style="margin-top: 1em">-xen-create <br>
Create domain using xen hypercalls, bypassing xend. Warning:
should not be used when xend is in use (XEN only).</p>

<p style="margin-top: 1em">-xen-attach <br>
Attach to existing xen domain. xend will use this when
starting QEMU (XEN only).</p>

<p style="margin-top: 1em">-no-reboot <br>
Exit instead of rebooting.</p>

<p style="margin-top: 1em">-no-shutdown <br>
Don&rsquo;t exit QEMU on guest shutdown, but instead only
stop the emulation. This allows for instance switching to
monitor to commit changes to the disk image.</p>

<p style="margin-top: 1em">-loadvm file <br>
Start right away with a saved state (&quot;loadvm&quot; in
monitor)</p>

<p style="margin-top: 1em">-daemonize <br>
Daemonize the QEMU process after initialization. QEMU will
not detach from standard IO until it is ready to receive
connections on any of its devices. This option is a <br>
useful way for external programs to launch QEMU without
having to cope with initialization race conditions.</p>

<p style="margin-top: 1em">-option-rom file <br>
Load the contents of file as an option ROM. This option is
useful to load things like EtherBoot.</p>

<p style="margin-top: 1em">-clock method <br>
Force the use of the given methods for timer alarm. To see
what timers are available use &quot;-clock help&quot;.</p>

<p style="margin-top: 1em">-rtc
[base=utc|localtime|date][,clock=host|vm][,driftfix=none|slew]
<br>
Specify base as &quot;utc&quot; or &quot;localtime&quot; to
let the RTC start at the current UTC or local time,
respectively. &quot;localtime&quot; is required for correct
date in MS-DOS or Windows. To <br>
start at a specific point in time, provide date in the
format &quot;2006-06-17T16:01:21&quot; or
&quot;2006-06-17&quot;. The default base is UTC.</p>

<p style="margin-top: 1em">By default the RTC is driven by
the host system time. This allows to use the RTC as accurate
reference clock inside the guest, specifically if the host
time is smoothly <br>
following an accurate external reference clock, e.g. via
NTP. If you want to isolate the guest time from the host,
you can set clock to &quot;rt&quot; instead. To even prevent
it <br>
from progressing during suspension, you can set it to
&quot;vm&quot;.</p>

<p style="margin-top: 1em">Enable driftfix (i386 targets
only) if you experience time drift problems, specifically
with Windows&rsquo; ACPI HAL. This option will try to figure
out how many timer interrupts <br>
were not processed by the Windows guest and will re-inject
them.</p>

<p style="margin-top: 1em">-icount [N|auto] <br>
Enable virtual instruction counter. The virtual cpu will
execute one instruction every 2^N ns of virtual time. If
&quot;auto&quot; is specified then the virtual cpu speed
will be <br>
automatically adjusted to keep virtual time within a few
seconds of real time.</p>

<p style="margin-top: 1em">Note that while this option can
give deterministic behavior, it does not provide cycle
accurate emulation. Modern CPUs contain superscalar out of
order cores with complex <br>
cache hierarchies. The number of instructions executed often
has little or no correlation with actual performance.</p>

<p style="margin-top: 1em">-watchdog model <br>
Create a virtual hardware watchdog device. Once enabled (by
a guest action), the watchdog must be periodically polled by
an agent inside the guest or else the guest will be <br>
restarted.</p>

<p style="margin-top: 1em">The model is the model of
hardware watchdog to emulate. Choices for model are:
&quot;ib700&quot; (iBASE 700) which is a very simple ISA
watchdog with a single timer, or &quot;i6300esb&quot; <br>
(Intel 6300ESB I/O controller hub) which is a much more
featureful PCI-based dual-timer watchdog. Choose a model for
which your guest has drivers.</p>

<p style="margin-top: 1em">Use &quot;-watchdog help&quot;
to list available hardware models. Only one watchdog can be
enabled for a guest.</p>

<p style="margin-top: 1em">-watchdog-action action <br>
The action controls what QEMU will do when the watchdog
timer expires. The default is &quot;reset&quot; (forcefully
reset the guest). Other possible actions are:
&quot;shutdown&quot; (attempt <br>
to gracefully shutdown the guest), &quot;poweroff&quot;
(forcefully poweroff the guest), &quot;pause&quot; (pause
the guest), &quot;debug&quot; (print a debug message and
continue), or &quot;none&quot; (do <br>
nothing).</p>

<p style="margin-top: 1em">Note that the
&quot;shutdown&quot; action requires that the guest responds
to ACPI signals, which it may not be able to do in the sort
of situations where the watchdog would have <br>
expired, and thus &quot;-watchdog-action shutdown&quot; is
not recommended for production use.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">&quot;-watchdog i6300esb
-watchdog-action pause&quot; <br>
&quot;-watchdog ib700&quot; <br>
-echr numeric_ascii_value <br>
Change the escape character used for switching to the
monitor when using monitor and serial sharing. The default
is 0x01 when using the &quot;-nographic&quot; option. 0x01
is equal <br>
to pressing &quot;Control-a&quot;. You can select a
different character from the ascii control keys where 1
through 26 map to Control-a through Control-z. For instance
you could use <br>
the either of the following to change the escape character
to Control-t.</p>

<p style="margin-top: 1em">&quot;-echr 0x14&quot; <br>
&quot;-echr 20&quot; <br>
-virtioconsole c <br>
Set virtio console.</p>

<p style="margin-top: 1em">This option is maintained for
backward compatibility.</p>

<p style="margin-top: 1em">Please use &quot;-device
virtconsole&quot; for the new way of invocation.</p>

<p style="margin-top: 1em">-show-cursor <br>
Show cursor.</p>

<p style="margin-top: 1em">-tb-size n <br>
Set TB size.</p>

<p style="margin-top: 1em">-incoming port <br>
Prepare for incoming migration, listen on port.</p>

<p style="margin-top: 1em">-nodefaults <br>
Don&rsquo;t create default devices. Normally, QEMU sets the
default devices like serial port, parallel port, virtual
console, monitor device, VGA adapter, floppy and CD-ROM
drive <br>
and others. The &quot;-nodefaults&quot; option will disable
all those default devices.</p>

<p style="margin-top: 1em">-chroot dir <br>
Immediately before starting guest execution, chroot to the
specified directory. Especially useful in combination with
-runas.</p>

<p style="margin-top: 1em">-runas user <br>
Immediately before starting guest execution, drop root
privileges, switching to the specified user.</p>

<p style="margin-top: 1em">-prom-env variable=value <br>
Set OpenBIOS nvram variable to given value (PPC, SPARC
only).</p>

<p style="margin-top: 1em">-semihosting <br>
Semihosting mode (ARM, M68K, Xtensa only).</p>

<p style="margin-top: 1em">-old-param <br>
Old param mode (ARM only).</p>

<p style="margin-top: 1em">-sandbox arg <br>
Enable Seccomp mode 2 system call filter. &rsquo;on&rsquo;
will enable syscall filtering and &rsquo;off&rsquo; will
disable it. The default is &rsquo;off&rsquo;.</p>

<p style="margin-top: 1em">-readconfig file <br>
Read device configuration from file. This approach is useful
when you want to spawn QEMU process with many command line
options but you don&rsquo;t want to exceed the command line
<br>
character limit.</p>

<p style="margin-top: 1em">-writeconfig file <br>
Write device configuration to file. The file can be either
filename to save command line and device configuration into
file or dash &quot;-&quot;) character to print the output to
<br>
stdout. This can be later used as input file for
&quot;-readconfig&quot; option.</p>

<p style="margin-top: 1em">-nodefconfig <br>
Normally QEMU loads configuration files from sysconfdir and
datadir at startup. The &quot;-nodefconfig&quot; option will
prevent QEMU from loading any of those config files.</p>

<p style="margin-top: 1em">-no-user-config <br>
The &quot;-no-user-config&quot; option makes QEMU not load
any of the user-provided config files on sysconfdir, but
won&rsquo;t make it skip the QEMU-provided config files from
datadir.</p>

<p style="margin-top: 1em">-trace [events=file][,file=file]
<br>
Specify tracing options.</p>

<p style="margin-top: 1em">events=file <br>
Immediately enable events listed in file. The file must
contain one event name (as listed in the trace-events file)
per line. This option is only available if QEMU has <br>
been compiled with either simple or stderr tracing
backend.</p>

<p style="margin-top: 1em">file=file <br>
Log output traces to file.</p>

<p style="margin-top: 1em">This option is only available if
QEMU has been compiled with the simple tracing backend.</p>

<p style="margin-top: 1em">-enable-fips <br>
Enable FIPS 140-2 compliance mode.</p>

<p style="margin-top: 1em">-object
typename[,prop1=value1,...] <br>
Create an new object of type typename setting properties in
the order they are specified. Note that the &rsquo;id&rsquo;
property must be set. These objects are placed in the <br>
&rsquo;/objects&rsquo; path.</p>

<p style="margin-top: 1em">-msg timestamp[=on|off] <br>
prepend a timestamp to each log message.(default:on)</p>

<p style="margin-top: 1em">-dump-vmstate file <br>
Dump json-encoded vmstate information for current machine
type to file in file</p>

<p style="margin-top: 1em">During the graphical emulation,
you can use special key combinations to change modes. The
default key mappings are shown below, but if you use
&quot;-alt-grab&quot; then the modifier is <br>
Ctrl-Alt-Shift (instead of Ctrl-Alt) and if you use
&quot;-ctrl-grab&quot; then the modifier is the right Ctrl
key (instead of Ctrl-Alt):</p>

<p style="margin-top: 1em">Ctrl-Alt-f <br>
Toggle full screen</p>

<p style="margin-top: 1em">Ctrl-Alt-+ <br>
Enlarge the screen</p>

<p style="margin-top: 1em">Ctrl-Alt-- <br>
Shrink the screen</p>

<p style="margin-top: 1em">Ctrl-Alt-u <br>
Restore the screen&rsquo;s un-scaled dimensions</p>

<p style="margin-top: 1em">Ctrl-Alt-n <br>
Switch to virtual console &rsquo;n&rsquo;. Standard console
mappings are:</p>

<p style="margin-top: 1em">1 Target system display</p>

<p style="margin-top: 1em">2 Monitor</p>

<p style="margin-top: 1em">3 Serial port</p>

<p style="margin-top: 1em">Ctrl-Alt <br>
Toggle mouse and keyboard grab.</p>

<p style="margin-top: 1em">In the virtual consoles, you can
use Ctrl-Up, Ctrl-Down, Ctrl-PageUp and Ctrl-PageDown to
move in the back log.</p>

<p style="margin-top: 1em">During emulation, if you are
using the -nographic option, use Ctrl-a h to get terminal
commands:</p>

<p style="margin-top: 1em">Ctrl-a h <br>
Ctrl-a ? <br>
Print this help</p>

<p style="margin-top: 1em">Ctrl-a x <br>
Exit emulator</p>

<p style="margin-top: 1em">Ctrl-a s <br>
Save disk data back to file (if -snapshot)</p>

<p style="margin-top: 1em">Ctrl-a t <br>
Toggle console timestamps</p>

<p style="margin-top: 1em">Ctrl-a b <br>
Send break (magic sysrq in Linux)</p>

<p style="margin-top: 1em">Ctrl-a c <br>
Switch between console and monitor</p>

<p style="margin-top: 1em">Ctrl-a Ctrl-a <br>
Send Ctrl-a</p>

<p style="margin-top: 1em">The following options are
specific to the PowerPC emulation:</p>

<p style="margin-top: 1em">-g WxH[xDEPTH] <br>
Set the initial VGA graphic mode. The default is
800x600x15.</p>

<p style="margin-top: 1em">-prom-env string <br>
Set OpenBIOS variables in NVRAM, for example:</p>

<p style="margin-top: 1em">qemu-system-ppc -prom-env
&rsquo;auto-boot?=false&rsquo; -prom-env
&rsquo;boot-device=hd:2,yaboot&rsquo; -prom-env
&rsquo;boot-args=conf=hd:2,yaboot.conf&rsquo;</p>

<p style="margin-top: 1em">These variables are not used by
Open Hack&rsquo;Ware.</p>

<p style="margin-top: 1em">The following options are
specific to the Sparc32 emulation:</p>

<p style="margin-top: 1em">-g WxHx[xDEPTH] <br>
Set the initial TCX graphic mode. The default is 1024x768x8,
currently the only other possible mode is 1024x768x24.</p>

<p style="margin-top: 1em">-prom-env string <br>
Set OpenBIOS variables in NVRAM, for example:</p>

<p style="margin-top: 1em">qemu-system-sparc -prom-env
&rsquo;auto-boot?=false&rsquo; -prom-env
&rsquo;boot-device=sd(0,2,0):d&rsquo; -prom-env
&rsquo;boot-args=linux single&rsquo;</p>

<p style="margin-top: 1em">-M
[SS-4|SS-5|SS-10|SS-20|SS-600MP|LX|Voyager|SPARCClassic]
[|SPARCbook|SS-2|SS-1000|SS-2000] <br>
Set the emulated machine type. Default is SS-5.</p>

<p style="margin-top: 1em">The following options are
specific to the Sparc64 emulation:</p>

<p style="margin-top: 1em">-prom-env string <br>
Set OpenBIOS variables in NVRAM, for example:</p>

<p style="margin-top: 1em">qemu-system-sparc64 -prom-env
&rsquo;auto-boot?=false&rsquo;</p>

<p style="margin-top: 1em">-M [sun4u|sun4v|Niagara] <br>
Set the emulated machine type. The default is sun4u.</p>

<p style="margin-top: 1em">SEE ALSO <br>
The HTML documentation of QEMU for more precise information
and Linux user mode emulator invocation.</p>

<p style="margin-top: 1em">AUTHOR <br>
Fabrice Bellard</p>

<p style="margin-top: 1em">2017-07-05 QEMU(1)</p>
<hr>
</body>
</html>
