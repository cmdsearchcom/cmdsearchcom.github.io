<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:35:11 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>RE2C(1) RE2C(1)</p>

<p style="margin-top: 1em">NAME <br>
re2c - convert regular expressions to C/C++ code</p>

<p style="margin-top: 1em">SYNOPSIS <br>
re2c [OPTIONS] FILE</p>

<p style="margin-top: 1em">DESCRIPTION <br>
re2c is a lexer generator for C/C++. It finds regular
expression specifications inside of C/C++ comments and
replaces them with a hard-coded DFA. The user must supply
some inter&acirc; <br>
face code in order to control and customize the generated
DFA.</p>

<p style="margin-top: 1em">OPTIONS <br>
-? -h --help <br>
Invoke a short help.</p>

<p style="margin-top: 1em">-b --bit-vectors <br>
Implies -s. Use bit vectors as well in the attempt to coax
better code out of the compiler. Most useful for
specifications with more than a few keywords (e.g. for most
<br>
programming languages).</p>

<p style="margin-top: 1em">-c --conditions <br>
Used to support (f)lex-like condition support.</p>

<p style="margin-top: 1em">-d --debug-output <br>
Creates a parser that dumps information about the current
position and in which state the parser is while parsing the
input. This is useful to debug parser issues and <br>
states. If you use this switch you need to define a macro
YYDEBUG that is called like a function with two parameters:
void YYDEBUG (int state, char current). The first <br>
parameter receives the state or -1 and the second parameter
receives the input at the current cursor.</p>

<p style="margin-top: 1em">-D --emit-dot <br>
Emit Graphviz dot data. It can then be processed with e.g.
dot -Tpng input.dot &gt; output.png. Please note that
scanners with many states may crash dot.</p>

<p style="margin-top: 1em">-e --ecb <br>
Generate a parser that supports EBCDIC. The generated code
can deal with any character up to 0xFF. In this mode re2c
assumes that input character size is 1 byte. This <br>
switch is incompatible with -w, -x, -u and -8.</p>

<p style="margin-top: 1em">-f --storable-state <br>
Generate a scanner with support for storable state.</p>

<p style="margin-top: 1em">-F --flex-syntax <br>
Partial support for flex syntax. When this flag is active
then named definitions must be surrounded by curly braces
and can be defined without an equal sign and the
termi&acirc; <br>
nating semi colon. Instead names are treated as direct
double quoted strings.</p>

<p style="margin-top: 1em">-g --computed-gotos <br>
Generate a scanner that utilizes GCC&rsquo;s computed goto
feature. That is re2c generates jump tables whenever a
decision is of a certain complexity (e.g. a lot of if
condi&acirc; <br>
tions are otherwise necessary). This is only useable with
GCC and produces output that cannot be compiled with any
other compiler. Note that this implies -b and that the <br>
complexity threshold can be configured using the inplace
configuration cgoto:threshold.</p>

<p style="margin-top: 1em">-i --no-debug-info <br>
Do not output #line information. This is useful when you
want use a CMS tool with the re2c output which you might
want if you do not require your users to have re2c
them&acirc; <br>
selves when building from your source.</p>

<p style="margin-top: 1em">-o OUTPUT --output=OUTPUT <br>
Specify the OUTPUT file.</p>

<p style="margin-top: 1em">-r --reusable <br>
Allows reuse of scanner definitions with /*!use:re2c */
after /*!rules:re2c */. In this mode no /*!re2c */ block and
exactly one /*!rules:re2c */ must be present. The <br>
rules are being saved and used by every /*!use:re2c */ block
that follows. These blocks can contain inplace
configurations, especially re2c:flags:e, re2c:flags:w, <br>
re2c:flags:x, re2c:flags:u and re2c:flags:8. That way it is
possible to create the same scanner multiple times for
different character types, different input mechanisms <br>
or different output mechanisms. The /*!use:re2c */ blocks
can also contain additional rules that will be appended to
the set of rules in /*!rules:re2c */.</p>

<p style="margin-top: 1em">-s --nested-ifs <br>
Generate nested ifs for some switches. Many compilers need
this assist to generate better code.</p>

<p style="margin-top: 1em">-t HEADER --type-header=HEADER
<br>
Create a HEADER file that contains types for the (f)lex-like
condition support. This can only be activated when -c is in
use.</p>

<p style="margin-top: 1em">-u --unicode <br>
Generate a parser that supports UTF-32. The generated code
can deal with any valid Unicode character up to 0x10FFFF. In
this mode re2c assumes that input character size is <br>
4 bytes. This switch is incompatible with -e, -w, -x and -8.
This implies -s.</p>

<p style="margin-top: 1em">-v --version <br>
Show version information.</p>

<p style="margin-top: 1em">-V --vernum <br>
Show the version as a number XXYYZZ.</p>

<p style="margin-top: 1em">-w --wide-chars <br>
Generate a parser that supports UCS-2. The generated code
can deal with any valid Unicode character up to 0xFFFF. In
this mode re2c assumes that input character size is 2 <br>
bytes. This switch is incompatible with -e, -x, -u and -8.
This implies -s.</p>

<p style="margin-top: 1em">-x --utf-16 <br>
Generate a parser that supports UTF-16. The generated code
can deal with any valid Unicode character up to 0x10FFFF. In
this mode re2c assumes that input character size is <br>
2 bytes. This switch is incompatible with -e, -w, -u and -8.
This implies -s.</p>

<p style="margin-top: 1em">-8 --utf-8 <br>
Generate a parser that supports UTF-8. The generated code
can deal with any valid Unicode character up to 0x10FFFF. In
this mode re2c assumes that input character size is <br>
1 byte. This switch is incompatible with -e, -w, -x and
-u.</p>

<p style="margin-top: 1em">--case-insensitive <br>
All strings are case insensitive, so all &quot;-expressions
are treated in the same way &rsquo;-expressions are.</p>

<p style="margin-top: 1em">--case-inverted <br>
Invert the meaning of single and double quoted strings. With
this switch single quotes are case sensitive and double
quotes are case insensitive.</p>

<p style="margin-top: 1em">--no-generation-date <br>
Suppress date output in the generated file.</p>

<p style="margin-top: 1em">--no-generation-date <br>
Suppress version output in the generated file.</p>

<p style="margin-top: 1em">--encoding-policy POLICY <br>
Specify how re2c must treat Unicode surrogates. POLICY can
be one of the following: fail (abort with error when
surrogate encountered), substitute (silently substitute <br>
surrogate with error code point 0xFFFD), ignore (treat
surrogates as normal code points). By default re2c ignores
surrogates (for backward compatibility). Unicode standard
<br>
says that standalone surrogates are invalid code points, but
different libraries and programs treat them differently.</p>

<p style="margin-top: 1em">--input INPUT <br>
Specify re2c input API. INPUT can be one of the following:
default, custom.</p>

<p style="margin-top: 1em">-S --skeleton <br>
Instead of embedding re2c-generated code into C/C++ source,
generate a self-contained program for the same DFA. Most
useful for correctness and performance testing.</p>

<p style="margin-top: 1em">--empty-class POLICY <br>
What to do if user inputs empty character class. POLICY can
be one of the following: match-empty (match empty input:
pretty illogical, but this is the default for back&acirc;
<br>
wards compatibility reason), match-none (fail to match on
any input), error (compilation error). Note that there are
various ways to construct empty class, e.g: [], <br>
[^0-], [0-][0-].</p>

<p style="margin-top: 1em">--dfa-minimization &lt;table |
moore&gt; <br>
Internal algorithm used by re2c to minimize DFA (defaults to
moore). Both table filling and Moore&rsquo;s algorithms
should produce identical DFA (up to states relabelling).
<br>
Table filling algorithm is much simpler and slower; it
serves as a reference implementation.</p>

<p style="margin-top: 1em">-1 --single-pass <br>
Deprecated and does nothing (single pass is by default
now).</p>

<p style="margin-top: 1em">-W Turn on all warnings.</p>

<p style="margin-top: 1em">-Werror <br>
Turn warnings into errors. Note that this option along
doesn&rsquo;t turn on any warnings, it only affects those
warnings that have been turned on so far or will be turned
on <br>
later.</p>

<p style="margin-top: 1em">-W&lt;warning&gt; <br>
Turn on individual warning.</p>

<p style="margin-top: 1em">-Wno-&lt;warning&gt; <br>
Turn off individual warning.</p>

<p style="margin-top: 1em">-Werror-&lt;warning&gt; <br>
Turn on individual warning and treat it as error (this
implies -W&lt;warning&gt;).</p>

<p style="margin-top: 1em">-Wno-error-&lt;warning&gt; <br>
Don&rsquo;t treat this particular warning as error. This
doesn&rsquo;t turn off the warning itself.</p>

<p style="margin-top: 1em">-Wcondition-order <br>
Warn if the generated program makes implicit assumptions
about condition numbering. One should use either -t,
--type-header option or /*!types:re2c*/ directive to
generate <br>
mapping of condition names to numbers and use autogenerated
condition names.</p>

<p style="margin-top: 1em">-Wempty-character-class <br>
Warn if regular expression contains empty character class.
From the rational point of view trying to match empty
character class makes no sense: it should always fail. <br>
However, for backwards compatibility reasons re2c allows
empty character class and treats it as empty string. Use
--empty-class option to change default behaviour.</p>

<p style="margin-top: 1em">-Wmatch-empty-string <br>
Warn if regular expression in a rule is nullable (matches
empty string). If DFA runs in a loop and empty match is
unintentional (input position in not advanced manually),
<br>
lexer may get stuck in eternal loop.</p>

<p style="margin-top: 1em">-Wswapped-range <br>
Warn if range lower bound is greater that upper bound.
Default re2c behaviour is to silently swap range bounds.</p>

<p style="margin-top: 1em">-Wundefined-control-flow <br>
Warn if some input strings cause undefined control flow in
lexer (the faulty patterns are reported). This is the most
dangerous and common mistake. It can be easily fixed <br>
by adding default rule * (this rule has the lowest priority,
matches any code unit and consumes exactly one code
unit).</p>

<p style="margin-top: 1em">-Wuseless-escape <br>
Warn if a symbol is escaped when it shouldn&rsquo;t be. By
default re2c silently ignores escape, but this may as well
indicate a typo or an error in escape sequence.</p>

<p style="margin-top: 1em">INTERFACE CODE <br>
The user must supply interface code either in the form of
C/C++ code (macros, functions, variables, etc.) or in the
form of INPLACE CONFIGURATIONS. Which symbols must be
defined <br>
and which are optional depends on a particular use case.</p>

<p style="margin-top: 1em">YYCONDTYPE <br>
In -c mode you can use -t to generate a file that contains
the enumeration used as conditions. Each of the values
refers to a condition of a rule set.</p>

<p style="margin-top: 1em">YYCTXMARKER <br>
l-value of type YYCTYPE *. The generated code saves trailing
context backtracking information in YYCTXMARKER. The user
only needs to define this macro if a scanner speci&acirc;
<br>
fication uses trailing context in one or more of its regular
expressions.</p>

<p style="margin-top: 1em">YYCTYPE <br>
Type used to hold an input symbol (code unit). Usually char
or unsigned char for ASCII, EBCDIC and UTF-8, unsigned short
for UTF-16 or UCS-2 and unsigned int for UTF-32.</p>

<p style="margin-top: 1em">YYCURSOR <br>
l-value of type YYCTYPE * that points to the current input
symbol. The generated code advances YYCURSOR as symbols are
matched. On entry, YYCURSOR is assumed to point to <br>
the first character of the current token. On exit, YYCURSOR
will point to the first character of the following
token.</p>

<p style="margin-top: 1em">YYDEBUG (state, current) <br>
This is only needed if the -d flag was specified. It allows
one to easily debug the generated parser by calling a user
defined function for every state. The function <br>
should have the following signature: void YYDEBUG (int
state, char current). The first parameter receives the state
or -1 and the second parameter receives the input at <br>
the current cursor.</p>

<p style="margin-top: 1em">YYFILL (n) <br>
The generated code &quot;calls&quot;&quot; YYFILL (n) when
the buffer needs (re)filling: at least n additional
characters should be provided. YYFILL (n) should adjust
YYCURSOR, YYLIMIT, <br>
YYMARKER and YYCTXMARKER as needed. Note that for typical
programming languages n will be the length of the longest
keyword plus one. The user can place a comment of the <br>
form /*!max:re2c*/ to insert YYMAXFILL definition that is
set to the maximum length value.</p>

<p style="margin-top: 1em">YYGETCONDITION () <br>
This define is used to get the condition prior to entering
the scanner code when using -c switch. The value must be
initialized with a value from the enumeration YYCOND&acirc;
<br>
TYPE type.</p>

<p style="margin-top: 1em">YYGETSTATE () <br>
The user only needs to define this macro if the -f flag was
specified. In that case, the generated code
&quot;calls&quot; YYGETSTATE () at the very beginning of the
scanner in order <br>
to obtain the saved state. YYGETSTATE () must return a
signed integer. The value must be either -1, indicating that
the scanner is entered for the first time, or a value <br>
previously saved by YYSETSTATE (s). In the second case, the
scanner will resume operations right after where the last
YYFILL (n) was called.</p>

<p style="margin-top: 1em">YYLIMIT <br>
Expression of type YYCTYPE * that marks the end of the
buffer YYLIMIT[-1] is the last character in the buffer). The
generated code repeatedly compares YYCURSOR to YYLIMIT <br>
to determine when the buffer needs (re)filling.</p>

<p style="margin-top: 1em">YYMARKER <br>
l-value of type YYCTYPE *. The generated code saves
backtracking information in YYMARKER. Some easy scanners
might not use this.</p>

<p style="margin-top: 1em">YYMAXFILL <br>
This will be automatically defined by /*!max:re2c*/ blocks
as explained above.</p>

<p style="margin-top: 1em">YYSETCONDITION (c) <br>
This define is used to set the condition in transition
rules. This is only being used when -c is active and
transition rules are being used.</p>

<p style="margin-top: 1em">YYSETSTATE (s) <br>
The user only needs to define this macro if the -f flag was
specified. In that case, the generated code
&quot;calls&quot; YYSETSTATE just before calling YYFILL (n).
The parameter to <br>
YYSETSTATE is a signed integer that uniquely identifies the
specific instance of YYFILL (n) that is about to be called.
Should the user wish to save the state of the scan&acirc;
<br>
ner and have YYFILL (n) return to the caller, all he has to
do is store that unique identifier in a variable. Later,
when the scannered is called again, it will call <br>
YYGETSTATE () and resume execution right where it left off.
The generated code will contain both YYSETSTATE (s) and
YYGETSTATE even if YYFILL (n) is being disabled.</p>

<p style="margin-top: 1em">SYNTAX <br>
Code for re2c consists of a set of RULES, NAMED DEFINITIONS
and INPLACE CONFIGURATIONS.</p>

<p style="margin-top: 1em">RULES <br>
Rules consist of a regular expression (see REGULAR
EXPRESSIONS) along with a block of C/C++ code that is to be
executed when the associated regular expression is matched.
You can <br>
either start the code with an opening curly brace or the
sequence :=. When the code with a curly brace then re2c
counts the brace depth and stops looking for code
automatically. <br>
Otherwise curly braces are not allowed and re2c stops
looking for code at the first line that does not begin with
whitespace. If two or more rules overlap, the first rule is
pre&acirc; <br>
ferred. <br>
regular-expression { C/C++ code }</p>

<p style="margin-top: 1em">regular-expression := C/C++
code</p>

<p style="margin-top: 1em">There is one special rule:
default rule * <br>
* { C/C++ code }</p>

<p style="margin-top: 1em">* := C/C++ code</p>

<p style="margin-top: 1em">Note that default rule * differs
from [^]: default rule has the lowest priority, matches any
code unit (either valid or invalid) and always consumes one
character; while [^] <br>
matches any valid code point (not code unit) and can consume
multiple code units. In fact, when variable-length encoding
is used, * is the only possible way to match invalid <br>
input character (see ENCODINGS for details).</p>

<p style="margin-top: 1em">If -c is active then each
regular expression is preceded by a list of comma separated
condition names. Besides normal naming rules there are two
special cases: &lt;*&gt; (such rules <br>
are merged to all conditions) and &lt;&gt; (such the rule
cannot have an associated regular expression, its code is
merged to all actions). Non empty rules may further more
specify the <br>
new condition. In that case re2c will generate the necessary
code to change the condition automatically. Rules can use
:=&gt; as a shortcut to automatically generate code that not
<br>
only sets the new condition state but also continues
execution with the new state. A shortcut rule should not be
used in a loop where there is code between the start of the
loop <br>
and the re2c block unless re2c:cond:goto is changed to
continue. If code is necessary before all rules (though not
simple jumps) you can doso by using &lt;!&gt; pseudo-rules.
<br>
&lt;condition-list&gt; regular-expression { C/C++ code }</p>

<p style="margin-top: 1em">&lt;condition-list&gt;
regular-expression := C/C++ code</p>

<p style="margin-top: 1em">&lt;condition-list&gt; * { C/C++
code }</p>

<p style="margin-top: 1em">&lt;condition-list&gt; * :=
C/C++ code</p>

<p style="margin-top: 1em">&lt;condition-list&gt;
regular-expression =&gt; condition { C/C++ code }</p>

<p style="margin-top: 1em">&lt;condition-list&gt;
regular-expression =&gt; condition := C/C++ code</p>

<p style="margin-top: 1em">&lt;condition-list&gt; * =&gt;
condition { C/C++ code }</p>

<p style="margin-top: 1em">&lt;condition-list&gt; * =&gt;
condition := C/C++ code</p>

<p style="margin-top: 1em">&lt;condition-list&gt;
regular-expression :=&gt; condition</p>

<p style="margin-top: 1em">&lt;*&gt; regular-expression {
C/C++ code }</p>

<p style="margin-top: 1em">&lt;*&gt; regular-expression :=
C/C++ code</p>

<p style="margin-top: 1em">&lt;*&gt; * { C/C++ code }</p>

<p style="margin-top: 1em">&lt;*&gt; * := C/C++ code</p>

<p style="margin-top: 1em">&lt;*&gt; regular-expression
=&gt; condition { C/C++ code }</p>

<p style="margin-top: 1em">&lt;*&gt; regular-expression
=&gt; condition := C/C++ code</p>

<p style="margin-top: 1em">&lt;*&gt; * =&gt; condition {
C/C++ code }</p>

<p style="margin-top: 1em">&lt;*&gt; * =&gt; condition :=
C/C++ code</p>

<p style="margin-top: 1em">&lt;*&gt; regular-expression
:=&gt; condition</p>

<p style="margin-top: 1em">&lt;&gt; { C/C++ code }</p>

<p style="margin-top: 1em">&lt;&gt; := C/C++ code</p>

<p style="margin-top: 1em">&lt;&gt; =&gt; condition { C/C++
code }</p>

<p style="margin-top: 1em">&lt;&gt; =&gt; condition :=
C/C++ code</p>

<p style="margin-top: 1em">&lt;&gt; :=&gt; condition</p>

<p style="margin-top: 1em">&lt;&gt; :=&gt; condition</p>

<p style="margin-top: 1em">&lt;! condition-list&gt; { C/C++
code }</p>

<p style="margin-top: 1em">&lt;! condition-list&gt; :=
C/C++ code</p>

<p style="margin-top: 1em">&lt;!&gt; { C/C++ code }</p>

<p style="margin-top: 1em">&lt;!&gt; := C/C++ code</p>

<p style="margin-top: 1em">NAMED DEFINITIONS <br>
Named definitions are of the form: <br>
name = regular-expression;</p>

<p style="margin-top: 1em">If -F is active, then named
definitions are also of the form: <br>
name { regular-expression }</p>

<p style="margin-top: 1em">INPLACE CONFIGURATIONS <br>
re2c:condprefix = yyc; <br>
Allows one to specify the prefix used for condition labels.
That is this text is prepended to any condition label in the
generated output file.</p>

<p style="margin-top: 1em">re2c:condenumprefix = yyc; <br>
Allows one to specify the prefix used for condition values.
That is this text is prepended to any condition enum value
in the generated output file.</p>

<p style="margin-top: 1em">re2c:cond:divider = /*
*********************************** */ ; <br>
Allows one to customize the devider for condition blocks.
You can use @@ to put the name of the condition or customize
the placeholder using re2c:cond:divider@cond.</p>

<p style="margin-top: 1em">re2c:cond:divider@cond = @@;
<br>
Specifies the placeholder that will be replaced with the
condition name in re2c:cond:divider.</p>

<p style="margin-top: 1em">re2c:cond:goto = goto @@; ; <br>
Allows one to customize the condition goto statements used
with :=&gt; style rules. You can use @@ to put the name of
the condition or ustomize the placeholder using <br>
re2c:cond:goto@cond. You can also change this to continue;,
which would allow you to continue with the next loop cycle
including any code between loop start and re2c <br>
block.</p>

<p style="margin-top: 1em">re2c:cond:goto@cond = @@; <br>
Spcifies the placeholder that will be replaced with the
condition label in re2c:cond:goto.</p>

<p style="margin-top: 1em">re2c:indent:top = 0; <br>
Specifies the minimum number of indentation to use. Requires
a numeric value greater than or equal zero.</p>

<p style="margin-top: 1em">re2c:indent:string = ; <br>
Specifies the string to use for indentation. Requires a
string that should contain only whitespace unless you need
this for external tools. The easiest way to specify
spa&acirc; <br>
ces is to enclude them in single or double quotes. If you do
not want any indentation at all you can simply set this to
&quot;&quot;.</p>

<p style="margin-top: 1em">re2c:yych:conversion = 0; <br>
When this setting is non zero, then re2c automatically
generates conversion code whenever yych gets read. In this
case the type must be defined using re2c:define:YYCTYPE.</p>

<p style="margin-top: 1em">re2c:yych:emit = 1; <br>
Generation of yych can be suppressed by setting this to
0.</p>

<p style="margin-top: 1em">re2c:yybm:hex = 0; <br>
If set to zero then a decimal table is being used else a
hexadecimal table will be generated.</p>

<p style="margin-top: 1em">re2c:yyfill:enable = 1; <br>
Set this to zero to suppress generation of YYFILL (n). When
using this be sure to verify that the generated scanner does
not read behind input. Allowing this behavior <br>
might introduce sever security issues to you programs.</p>

<p style="margin-top: 1em">re2c:yyfill:check = 1; <br>
This can be set 0 to suppress output of the pre condition
using YYCURSOR and YYLIMIT which becomes useful when YYLIMIT
+ YYMAXFILL is always accessible.</p>

<p style="margin-top: 1em">re2c:define:YYFILL = YYFILL ;
<br>
Substitution for YYFILL. Note that by default re2c generates
argument in braces and semicolon after YYFILL. If you need
to make YYFILL an arbitrary statement rather than a <br>
call, set re2c:define:YYFILL:naked to non-zero and use
re2c:define:YYFILL@len to denote formal parameter inside of
YYFILL body.</p>

<p style="margin-top: 1em">re2c:define:YYFILL@len = @@ ;
<br>
Any occurrence of this text inside of YYFILL will be
replaced with the actual argument.</p>

<p style="margin-top: 1em">re2c:yyfill:parameter = 1; <br>
Controls argument in braces after YYFILL. If zero, argument
is omitted. If non-zero, argument is generated unless
re2c:define:YYFILL:naked is set to non-zero.</p>

<p style="margin-top: 1em">re2c:define:YYFILL:naked = 0;
<br>
Controls argument in braces and semicolon after YYFILL. If
zero, both argument and semicolon are omitted. If non-zero,
argument is generated unless re2c:yyfill:parameter <br>
is set to zero and semicolon is generated
unconditionally.</p>

<p style="margin-top: 1em">re2c:startlabel = 0; <br>
If set to a non zero integer then the start label of the
next scanner blocks will be generated even if not used by
the scanner itself. Otherwise the normal yy0 like start <br>
label is only being generated if needed. If set to a text
value then a label with that text will be generated
regardless of whether the normal start label is being used
or <br>
not. This setting is being reset to 0 after a start label
has been generated.</p>

<p style="margin-top: 1em">re2c:labelprefix = yy ; <br>
Allows one to change the prefix of numbered labels. The
default is yy and can be set any string that is a valid
label.</p>

<p style="margin-top: 1em">re2c:state:abort = 0; <br>
When not zero and switch -f is active then the YYGETSTATE
block will contain a default case that aborts and a -1 case
is used for initialization.</p>

<p style="margin-top: 1em">re2c:state:nextlabel = 0; <br>
Used when -f is active to control whether the YYGETSTATE
block is followed by a yyNext: label line. Instead of using
yyNext you can usually also use configuration start&acirc;
<br>
label to force a specific start label or default to yy0 as
start label. Instead of using a dedicated label it is often
better to separate the YYGETSTATE code from the <br>
actual scanner code by placing a /*!getstate:re2c*/
comment.</p>

<p style="margin-top: 1em">re2c:cgoto:threshold = 9; <br>
When -g is active this value specifies the complexity
threshold that triggers generation of jump tables rather
than using nested if&rsquo;s and decision bitfields. The
threshold <br>
is compared against a calculated estimation of if-s needed
where every used bitmap divides the threshold by 2.</p>

<p style="margin-top: 1em">re2c:yych:conversion = 0; <br>
When the input uses signed characters and -s or -b switches
are in effect re2c allows one to automatically convert to
the unsigned character type that is then necessary <br>
for its internal single character. When this setting is zero
or an empty string the conversion is disabled. Using a non
zero number the conversion is taken from YYCTYPE. <br>
If that is given by an inplace configuration that value is
being used. Otherwise it will be (YYCTYPE) and changes to
that configuration are no longer possible. When this <br>
setting is a string the braces must be specified. Now
assuming your input is a char * buffer and you are using
above mentioned switches you can set YYCTYPE to unsigned
<br>
char and this setting to either 1 or (unsigned char).</p>

<p style="margin-top: 1em">re2c:define:YYCONDTYPE =
YYCONDTYPE ; <br>
Enumeration used for condition support with -c mode.</p>

<p style="margin-top: 1em">re2c:define:YYCTXMARKER =
YYCTXMARKER ; <br>
Allows one to overwrite the define YYCTXMARKER and thus
avoiding it by setting the value to the actual code
needed.</p>

<p style="margin-top: 1em">re2c:define:YYCTYPE = YYCTYPE ;
<br>
Allows one to overwrite the define YYCTYPE and thus avoiding
it by setting the value to the actual code needed.</p>

<p style="margin-top: 1em">re2c:define:YYCURSOR = YYCURSOR
; <br>
Allows one to overwrite the define YYCURSOR and thus
avoiding it by setting the value to the actual code
needed.</p>

<p style="margin-top: 1em">re2c:define:YYDEBUG = YYDEBUG ;
<br>
Allows one to overwrite the define YYDEBUG and thus avoiding
it by setting the value to the actual code needed.</p>

<p style="margin-top: 1em">re2c:define:YYGETCONDITION =
YYGETCONDITION ; <br>
Substitution for YYGETCONDITION. Note that by default re2c
generates braces after YYGETCONDITION. Set
re2c:define:YYGETCONDITION:naked to non-zero to omit
braces.</p>


<p style="margin-top: 1em">re2c:define:YYGETCONDITION:naked
= 0; <br>
Controls braces after YYGETCONDITION. If zero, braces are
omitted. If non-zero, braces are generated.</p>

<p style="margin-top: 1em">re2c:define:YYSETCONDITION =
YYSETCONDITION ; <br>
Substitution for YYSETCONDITION. Note that by default re2c
generates argument in braces and semicolon after
YYSETCONDITION. If you need to make YYSETCONDITION an
arbitrary <br>
statement rather than a call, set
re2c:define:YYSETCONDITION:naked to non-zero and use
re2c:define:YYSETCONDITION@cond to denote formal parameter
inside of YYSETCONDITION <br>
body.</p>

<p style="margin-top: 1em">re2c:define:YYSETCONDITION@cond
= @@ ; <br>
Any occurrence of this text inside of YYSETCONDITION will be
replaced with the actual argument.</p>


<p style="margin-top: 1em">re2c:define:YYSETCONDITION:naked
= 0; <br>
Controls argument in braces and semicolon after
YYSETCONDITION. If zero, both argument and semicolon are
omitted. If non-zero, both argument and semicolon are
generated.</p>

<p style="margin-top: 1em">re2c:define:YYGETSTATE =
YYGETSTATE ; <br>
Substitution for YYGETSTATE. Note that by default re2c
generates braces after YYGETSTATE. Set
re2c:define:YYGETSTATE:naked to non-zero to omit braces.</p>

<p style="margin-top: 1em">re2c:define:YYGETSTATE:naked =
0; <br>
Controls braces after YYGETSTATE. If zero, braces are
omitted. If non-zero, braces are generated.</p>

<p style="margin-top: 1em">re2c:define:YYSETSTATE =
YYSETSTATE ; <br>
Substitution for YYSETSTATE. Note that by default re2c
generates argument in braces and semicolon after YYSETSTATE.
If you need to make YYSETSTATE an arbitrary statement <br>
rather than a call, set re2c:define:YYSETSTATE:naked to
non-zero and use re2c:define:YYSETSTATE@cond to denote
formal parameter inside of YYSETSTATE body.</p>

<p style="margin-top: 1em">re2c:define:YYSETSTATE@state =
@@ ; <br>
Any occurrence of this text inside of YYSETSTATE will be
replaced with the actual argument.</p>

<p style="margin-top: 1em">re2c:define:YYSETSTATE:naked =
0; <br>
Controls argument in braces and semicolon after YYSETSTATE.
If zero, both argument and semicolon are omitted. If
non-zero, both argument and semicolon are generated.</p>

<p style="margin-top: 1em">re2c:define:YYLIMIT = YYLIMIT ;
<br>
Allows one to overwrite the define YYLIMIT and thus avoiding
it by setting the value to the actual code needed.</p>

<p style="margin-top: 1em">re2c:define:YYMARKER = YYMARKER
; <br>
Allows one to overwrite the define YYMARKER and thus
avoiding it by setting the value to the actual code
needed.</p>

<p style="margin-top: 1em">re2c:label:yyFillLabel =
yyFillLabel ; <br>
Allows one to overwrite the name of the label
yyFillLabel.</p>

<p style="margin-top: 1em">re2c:label:yyNext = yyNext ;
<br>
Allows one to overwrite the name of the label yyNext.</p>

<p style="margin-top: 1em">re2c:variable:yyaccept =
yyaccept; <br>
Allows one to overwrite the name of the variable
yyaccept.</p>

<p style="margin-top: 1em">re2c:variable:yybm = yybm ; <br>
Allows one to overwrite the name of the variable yybm.</p>

<p style="margin-top: 1em">re2c:variable:yych = yych ; <br>
Allows one to overwrite the name of the variable yych.</p>

<p style="margin-top: 1em">re2c:variable:yyctable =
yyctable ; <br>
When both -c and -g are active then re2c uses this variable
to generate a static jump table for YYGETCONDITION.</p>

<p style="margin-top: 1em">re2c:variable:yystable =
yystable ; <br>
Deprecated.</p>

<p style="margin-top: 1em">re2c:variable:yytarget =
yytarget ; <br>
Allows one to overwrite the name of the variable
yytarget.</p>

<p style="margin-top: 1em">REGULAR EXPRESSIONS <br>
&quot;foo&quot; literal string &quot;foo&quot;. ANSI-C
escape sequences can be used.</p>

<p style="margin-top: 1em">&rsquo;foo&rsquo; literal string
&quot;foo&quot; (characters [a-zA-Z] treated
case-insensitive). ANSI-C escape sequences can be used.</p>

<p style="margin-top: 1em">[xyz] character class; in this
case, regular expression matches either x, y, or z.</p>

<p style="margin-top: 1em">[abj-oZ] <br>
character class with a range in it; matches a, b, any letter
from j through o or Z.</p>

<p style="margin-top: 1em">[^class] <br>
inverted character class.</p>

<p style="margin-top: 1em">r &nbsp;s match any r which
isn&rsquo;t s. r and s must be regular expressions which can
be expressed as character classes.</p>

<p style="margin-top: 1em">r* zero or more occurrences of
r.</p>

<p style="margin-top: 1em">r+ one or more occurrences of
r.</p>

<p style="margin-top: 1em">r? optional r.</p>

<p style="margin-top: 1em">(r) r; parentheses are used to
override precedence.</p>

<p style="margin-top: 1em">r s r followed by s
(concatenation).</p>

<p style="margin-top: 1em">r | s either r or s
(alternative).</p>

<p style="margin-top: 1em">r / s r but only if it is
followed by s. Note that s is not part of the matched text.
This type of regular expression is called &quot;trailing
context&quot;. Trailing context can only be <br>
the end of a rule and not part of a named definition.</p>

<p style="margin-top: 1em">r{n} matches r exactly n
times.</p>

<p style="margin-top: 1em">r{n,} matches r at least n
times.</p>

<p style="margin-top: 1em">r{n,m} matches r at least n
times, but not more than m times.</p>

<p style="margin-top: 1em">. match any character except
newline.</p>

<p style="margin-top: 1em">name matches named definition as
specified by name only if -F is off. If -F is active then
this behaves like it was enclosed in double quotes and
matches the string &quot;name&quot;.</p>

<p style="margin-top: 1em">Character classes and string
literals may contain octal or hexadecimal character
definitions and the following set of escape sequences: , 0 ,
. An octal <br>
character is defined by a backslash followed by its three
octal digits (e.g. 377). Hexadecimal characters from 0 to
0xFF are defined by backslash, a lower cased x and two
hexa&acirc; <br>
decimal digits (e.g. 2). Hexadecimal characters from 0x100
to 0xFFFF are defined by backslash, a lower cased or an
upper cased four hexadecimal digits (e.g. 1234). <br>
Hexadecimal characters from 0x10000 to 0xFFFFffff are
defined by backslash, an upper cased U and eight hexadecimal
digits (e.g. U12345678).</p>

<p style="margin-top: 1em">The only portable
&quot;any&quot; rule is the default rule *.</p>

<p style="margin-top: 1em">SCANNER WITH STORABLE STATES
<br>
When the -f flag is specified, re2c generates a scanner that
can store its current state, return to the caller, and later
resume operations exactly where it left off.</p>

<p style="margin-top: 1em">The default operation of re2c is
a &quot;pull&quot; model, where the scanner asks for extra
input whenever it needs it. However, this mode of operation
assumes that the scanner is the <br>
&quot;owner&quot; the parsing loop, and that may not always
be convenient.</p>

<p style="margin-top: 1em">Typically, if there is a
preprocessor ahead of the scanner in the stream, or for that
matter any other procedural source of data, the scanner
cannot &quot;ask&quot; for more data unless <br>
both scanner and source live in a separate threads.</p>

<p style="margin-top: 1em">The -f flag is useful for just
this situation: it lets users design scanners that work in a
&quot;push&quot; model, i.e. where data is fed to the
scanner chunk by chunk. When the scanner <br>
runs out of data to consume, it just stores its state, and
return to the caller. When more input data is fed to the
scanner, it resumes operations exactly where it left
off.</p>

<p style="margin-top: 1em">Changes needed compared to the
&quot;pull&quot; model:</p>

<p style="margin-top: 1em">&Acirc;&middot; User has to
supply macros YYSETSTATE () and YYGETSTATE (state).</p>

<p style="margin-top: 1em">&Acirc;&middot; The -f option
inhibits declaration of yych and yyaccept. So the user has
to declare these. Also the user has to save and restore
these. In the example exam&acirc; <br>
ples/push_model/push.re these are declared as fields of the
(C++) class of which the scanner is a method, so they do not
need to be saved/restored explicitly. For C they could <br>
e.g. be made macros that select fields from a structure
passed in as parameter. Alternatively, they could be
declared as local variables, saved with YYFILL (n) when it
decides <br>
to return and restored at entry to the function. Also, it
could be more efficient to save the state from YYFILL (n)
because YYSETSTATE (state) is called unconditionally. <br>
YYFILL (n) however does not get state as parameter, so we
would have to store state in a local variable by YYSETSTATE
(state).</p>

<p style="margin-top: 1em">&Acirc;&middot; Modify YYFILL
(n) to return (from the function calling it) if more input
is needed.</p>

<p style="margin-top: 1em">&Acirc;&middot; Modify caller to
recognise if more input is needed and respond
appropriately.</p>

<p style="margin-top: 1em">&Acirc;&middot; The generated
code will contain a switch block that is used to restores
the last state by jumping behind the corrspoding YYFILL (n)
call. This code is automatically generated <br>
in the epilog of the first /*!re2c */ block. It is possible
to trigger generation of the YYGETSTATE () block earlier by
placing a /*!getstate:re2c*/ comment. This is especially
<br>
useful when the scanner code should be wrapped inside a
loop.</p>

<p style="margin-top: 1em">Please see
examples/push_model/push.re for &quot;push&quot; model
scanner. The generated code can be tweaked using inplace
configurations state:abort and state:nextlabel.</p>

<p style="margin-top: 1em">SCANNER WITH CONDITION SUPPORT
<br>
You can precede regular expressions with a list of condition
names when using the -c switch. In this case re2c generates
scanner blocks for each conditon. Where each of the
gen&acirc; <br>
erated blocks has its own precondition. The precondition is
given by the interface define YYGETCONDITON() and must be of
type YYCONDTYPE.</p>

<p style="margin-top: 1em">There are two special rule
types. First, the rules of the condition &lt;*&gt; are
merged to all conditions (note that they have lower priority
than other rules of that condition). And <br>
second the empty condition list allows one to provide a code
block that does not have a scanner part. Meaning it does not
allow any regular expression. The condition value <br>
referring to this special block is always the one with the
enumeration value 0. This way the code of this special rule
can be used to initialize a scanner. It is in no way
neces&acirc; <br>
sary to have these rules: but sometimes it is helpful to
have a dedicated uninitialized condition state.</p>

<p style="margin-top: 1em">Non empty rules allow one to
specify the new condition, which makes them transition
rules. Besides generating calls for the define
YYSETCONDTITION no other special code is gener&acirc; <br>
ated.</p>

<p style="margin-top: 1em">There is another kind of special
rules that allow one to prepend code to any code block of
all rules of a certain set of conditions or to all code
blocks to all rules. This can <br>
be helpful when some operation is common among rules. For
instance this can be used to store the length of the scanned
string. These special setup rules start with an exclamation
<br>
mark followed by either a list of conditions &lt;!
condition, ... &gt; or a star &lt;!*&gt;. When re2c
generates the code for a rule whose state does not have a
setup rule and a star&rsquo;d setup <br>
rule is present, than that code will be used as setup
code.</p>

<p style="margin-top: 1em">ENCODINGS <br>
re2c supports the following encodings: ASCII (default),
EBCDIC (-e), UCS-2 (-w), UTF-16 (-x), UTF-32 (-u) and UTF-8
(-8). See also inplace configuration re2c:flags.</p>

<p style="margin-top: 1em">The following concepts should be
clarified when talking about encoding. Code point is an
abstract number, which represents single encoding symbol.
Code unit is the smallest unit <br>
of memory, which is used in the encoded text (it corresponds
to one character in the input stream). One or more code
units can be needed to represent a single code point,
depend&acirc; <br>
ing on the encoding. In fixed-length encoding, each code
point is represented with equal number of code units. In
variable-length encoding, different code points can be
repre&acirc; <br>
sented with different number of code units.</p>

<p style="margin-top: 1em">ASCII is a fixed-length
encoding. Its code space includes 0x100 code points, from 0
to 0xFF. One code point is represented with exactly one
1-byte code unit, which has the same <br>
value as the code point. Size of YYCTYPE must be 1 byte.</p>

<p style="margin-top: 1em">EBCDIC is a fixed-length
encoding. Its code space includes 0x100 code points, from 0
to 0xFF. One code point is represented with exactly one
1-byte code unit, which has the same <br>
value as the code point. Size of YYCTYPE must be 1 byte.</p>

<p style="margin-top: 1em">UCS-2 is a fixed-length
encoding. Its code space includes 0x10000 code points, from
0 to 0xFFFF. One code point is represented with exactly one
2-byte code unit, which has the <br>
same value as the code point. Size of YYCTYPE must be 2
bytes.</p>

<p style="margin-top: 1em">UTF-16 is a variable-length
encoding. Its code space includes all Unicode code points,
from 0 to 0xD7FF and from 0xE000 to 0x10FFFF. One code point
is represented with one or two <br>
2-byte code units. Size of YYCTYPE must be 2 bytes.</p>

<p style="margin-top: 1em">UTF-32 is a fixed-length
encoding. Its code space includes all Unicode code points,
from 0 to 0xD7FF and from 0xE000 to 0x10FFFF. One code point
is represented with exactly one <br>
4-byte code unit. Size of YYCTYPE must be 4 bytes.</p>

<p style="margin-top: 1em">UTF-8 is a variable-length
encoding. Its code space includes all Unicode code points,
from 0 to 0xD7FF and from 0xE000 to 0x10FFFF. One code point
is represented with sequence <br>
of one, two, three or four 1-byte code units. Size of
YYCTYPE must be 1 byte.</p>

<p style="margin-top: 1em">In Unicode, values from range
0xD800 to 0xDFFF (surrogates) are not valid Unicode code
points, any encoded sequence of code units, that would map
to Unicode code points in the <br>
range 0xD800-0xDFFF, is ill-formed. The user can control how
re2c treats such ill-formed sequences with --encoding-policy
&lt;policy&gt; flag (see OPTIONS for full explanation).</p>

<p style="margin-top: 1em">For some encodings, there are
code units, that never occur in valid encoded stream (e.g.
0xFF byte in UTF-8). If the generated scanner must check for
invalid input, the only true <br>
way to do so is to use default rule *. Note, that full range
rule [^] won&rsquo;t catch invalid code units when
variable-length encoding is used ([^] means &quot;all valid
code points&quot;, <br>
while default rule * means &quot;all possible code
units&quot;).</p>

<p style="margin-top: 1em">GENERIC INPUT API <br>
re2c usually operates on input using pointer-like primitives
YYCURSOR, YYMARKER, YYCTXMARKER and YYLIMIT.</p>

<p style="margin-top: 1em">Generic input API (enabled with
--input custom switch) allows one to customize input
operations. In this mode, re2c will express all operations
on input in terms of the following <br>
primitives:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;YYPEEK () &acirc; get current input character &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;YYSKIP () &acirc; advance to the next character
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;YYBACKUP () &acirc; backup current input position
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;YYBACKUPCTX () &acirc; backup current input position
for trailing context &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;YYRESTORE () &acirc; restore current input position
&acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;YYRESTORECTX () &acirc; restore current input
position for trailing context &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;YYLESSTHAN (n) &acirc; check if less than n input
characters are left &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">A couple of useful links that
provide some examples:</p>

<p style="margin-top: 1em">1.
http://skvadrik.github.io/aleph_null/posts/re2c/2015-01-13-input_model.html</p>

<p style="margin-top: 1em">2.
http://skvadrik.github.io/aleph_null/posts/re2c/2015-01-15-input_model_custom.html</p>

<p style="margin-top: 1em">SEE ALSO <br>
You can find more information about re2c on the website:
http://re2c.org. See also: flex(1), lex(1), quex
(http://quex.sourceforge.net).</p>

<p style="margin-top: 1em">AUTHORS <br>
Peter Bumbulis peter@csg.uwaterloo.ca</p>

<p style="margin-top: 1em">Brian Young bayoung@acm.org</p>

<p style="margin-top: 1em">Dan Nuffer
nuffer@users.sourceforge.net</p>

<p style="margin-top: 1em">Marcus Boerger
helly@users.sourceforge.net</p>

<p style="margin-top: 1em">Hartmut Kaiser
hkaiser@users.sourceforge.net</p>

<p style="margin-top: 1em">Emmanuel Mogenet
mgix@mgix.com</p>

<p style="margin-top: 1em">Ulya Trofimovich
skvadrik@gmail.com</p>

<p style="margin-top: 1em">VERSION INFORMATION <br>
This manpage describes re2c version 0.16, package date 21
Jan 2016.</p>
 
<p style="margin-top: 1em">RE2C(1)</p>
<hr>
</body>
</html>
