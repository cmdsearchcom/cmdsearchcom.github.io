<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>virt-resize(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">virt-resize(1)</td>
    <td class="head-vol">Virtualization Support</td>
    <td class="head-rtitle">virt-resize(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
virt-resize - Resize a virtual machine disk
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 virt-resize [--resize /dev/sdaN=[+/-]&lt;size&gt;[%]]
   [--expand /dev/sdaN] [--shrink /dev/sdaN]
   [--ignore /dev/sdaN] [--delete /dev/sdaN] [...] indisk outdisk
</pre>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Virt-resize is a tool which can resize a virtual machine disk, making it larger
  or smaller overall, and resizing or deleting any partitions contained within.
<div class="Pp"></div>
Virt-resize <b>cannot</b> resize disk images in-place. Virt-resize <b>should
  not</b> be used on live virtual machines - for consistent results, shut the
  virtual machine down before resizing it.
<div class="Pp"></div>
If you are not familiar with the associated tools: <i>virt-filesystems</i>(1)
  and <i>virt-df</i>(1), we recommend you go and read those manual pages first.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Copy &quot;olddisk&quot; to &quot;newdisk&quot;, extending
      one of the guest's partitions to fill the extra 5GB of space.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 virt-filesystems --long -h --all -a olddisk
 
 truncate -r olddisk newdisk
 truncate -s +5G newdisk
 
 # Note &quot;/dev/sda2&quot; is a partition inside the &quot;olddisk&quot; file.
 virt-resize --expand /dev/sda2 olddisk newdisk
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">As above, but make the /boot partition 200MB bigger, while
      giving the remaining space to /dev/sda2:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 virt-resize --resize /dev/sda1=+200M --expand /dev/sda2 \
   olddisk newdisk
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">As in the first example, but expand a logical volume as the
      final step. This is what you would typically use for Linux guests that use
      LVM:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 virt-resize --expand /dev/sda2 --LV-expand /dev/vg_guest/lv_root \
   olddisk newdisk
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">As in the first example, but the output format will be
      qcow2 instead of a raw disk:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 qemu-img create -f qcow2 -o preallocation=metadata newdisk.qcow2 15G
 virt-resize --expand /dev/sda2 olddisk newdisk.qcow2
    </pre>
  </dd>
</dl>
<h1 class="Sh" title="Sh" id="DETAILED_USAGE"><a class="selflink" href="#DETAILED_USAGE">DETAILED
  USAGE</a></h1>
<h2 class="Ss" title="Ss" id="EXPANDING_A_VIRTUAL_MACHINE_DISK"><a class="selflink" href="#EXPANDING_A_VIRTUAL_MACHINE_DISK">EXPANDING
  A VIRTUAL MACHINE DISK</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">1. Shut down the virtual machine</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2. Locate input disk image</dt>
  <dd class="It-tag">Locate the input disk image (ie. the file or device on the
      host containing the guest's disk). If the guest is managed by libvirt, you
      can use &quot;virsh dumpxml&quot; like this to find the disk image name:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # virsh dumpxml guestname | xpath /domain/devices/disk/source
 Found 1 nodes:
 -- NODE --
 &lt;source dev=&quot;/dev/vg/lv_guest&quot; /&gt;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3. Look at current sizing</dt>
  <dd class="It-tag">Use <i>virt-filesystems</i>(1) to display the current
      partitions and sizes:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # virt-filesystems --long --parts --blkdevs -h -a /dev/vg/lv_guest
 Name       Type       Size  Parent
 /dev/sda1  partition  101M  /dev/sda
 /dev/sda2  partition  7.9G  /dev/sda
 /dev/sda   device     8.0G  -
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    (This example is a virtual machine with an 8 GB disk which we would like to
      expand up to 10 GB).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4. Create output disk</dt>
  <dd class="It-tag">Virt-resize cannot do in-place disk modifications. You have
      to have space to store the resized output disk.
    <div style="height: 1.00em;">&#x00A0;</div>
    To store the resized disk image in a file, create a file of a suitable size:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # rm -f outdisk
 # truncate -s 10G outdisk
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Or use <i>lvcreate</i>(1) to create a logical volume:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # lvcreate -L 10G -n lv_name vg_name
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Or use <i>virsh</i>(1) vol-create-as to create a libvirt storage volume:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # virsh pool-list
 # virsh vol-create-as poolname newvol 10G
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5. Resize</dt>
  <dd class="It-tag">virt-resize takes two mandatory parameters, the input disk
      (eg. device, file, or a URI to a remote disk) and the output disk. The
      output disk is the one created in the previous step.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # virt-resize indisk outdisk
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This command just copies disk image &quot;indisk&quot; to disk image
      &quot;outdisk&quot; <i>without</i> resizing or changing any existing
      partitions. If &quot;outdisk&quot; is larger, then an extra, empty
      partition is created at the end of the disk covering the extra space. If
      &quot;outdisk&quot; is smaller, then it will give an error.
    <div style="height: 1.00em;">&#x00A0;</div>
    More realistically you'd want to expand existing partitions in the disk
      image by passing extra options (for the full list see the
      &quot;OPTIONS&quot; section below).
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;--expand&quot; is the most useful option. It expands the named
      partition within the disk to fill any extra space:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # virt-resize --expand /dev/sda2 indisk outdisk
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    (In this case, an extra partition is <i>not</i> created at the end of the
      disk, because there will be no unused space).
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;--resize&quot; is the other commonly used option. The following would
      increase the size of /dev/sda1 by 200M, and expand /dev/sda2 to fill the
      rest of the available space:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # virt-resize --resize /dev/sda1=+200M --expand /dev/sda2 \
     indisk outdisk
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If the expanded partition in the image contains a filesystem or LVM PV, then
      if virt-resize knows how, it will resize the contents, the equivalent of
      calling a command such as <i>pvresize</i>(8), <i>resize2fs</i>(8),
      <i>ntfsresize</i>(8), <i>btrfs</i>(8) or <i>xfs_growfs</i>(8). However
      virt-resize does not know how to resize some filesystems, so you would
      have to online resize them after booting the guest.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # virt-resize --expand /dev/sda2 nbd://example.com outdisk
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The input disk can be a URI, in order to use a remote disk as the source.
      The URI format is compatible with guestfish. See &quot;ADDING REMOTE
      STORAGE&quot; in <i>guestfish</i>(1).
    <div style="height: 1.00em;">&#x00A0;</div>
    Other options are covered below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">6. Test</dt>
  <dd class="It-tag">Thoroughly test the new disk image <i>before</i> discarding
      the old one.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you are using libvirt, edit the XML to point at the new disk:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # virsh edit guestname
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Change &lt;source ...&gt;, see
      http://libvirt.org/formatdomain.html#elementsDisks
    <div style="height: 1.00em;">&#x00A0;</div>
    Then start up the domain with the new, resized disk:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 # virsh start guestname
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and check that it still works. See also the &quot;NOTES&quot; section below
      for additional information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">7. Resize LVs etc inside the guest</dt>
  <dd class="It-tag">(This can also be done offline using <i>guestfish</i>(1))
    <div style="height: 1.00em;">&#x00A0;</div>
    Once the guest has booted you should see the new space available, at least
      for filesystems that virt-resize knows how to resize, and for PVs. The
      user may need to resize LVs inside PVs, and also resize filesystem types
      that virt-resize does not know how to expand.</dd>
</dl>
<h2 class="Ss" title="Ss" id="SHRINKING_A_VIRTUAL_MACHINE_DISK"><a class="selflink" href="#SHRINKING_A_VIRTUAL_MACHINE_DISK">SHRINKING
  A VIRTUAL MACHINE DISK</a></h2>
Shrinking is somewhat more complex than expanding, and only an overview is given
  here.
<div class="Pp"></div>
Firstly virt-resize will not attempt to shrink any partition content (PVs,
  filesystems). The user has to shrink content before passing the disk image to
  virt-resize, and virt-resize will check that the content has been shrunk
  properly.
<div class="Pp"></div>
(Shrinking can also be done offline using <i>guestfish</i>(1))
<div class="Pp"></div>
After shrinking PVs and filesystems, shut down the guest, and proceed with steps
  3 and 4 above to allocate a new disk image.
<div class="Pp"></div>
Then run virt-resize with any of the <i>--shrink</i> and/or <i>--resize</i>
  options.
<h2 class="Ss" title="Ss" id="IGNORING_OR_DELETING_PARTITIONS"><a class="selflink" href="#IGNORING_OR_DELETING_PARTITIONS">IGNORING
  OR DELETING PARTITIONS</a></h2>
virt-resize also gives a convenient way to ignore or delete partitions when
  copying from the input disk to the output disk. Ignoring a partition speeds up
  the copy where you don't care about the existing contents of a partition.
  Deleting a partition removes it completely, but note that it also renumbers
  any partitions after the one which is deleted, which can leave some guests
  unbootable.
<h2 class="Ss" title="Ss" id="QCOW2_AND_NON-SPARSE_RAW_FORMATS"><a class="selflink" href="#QCOW2_AND_NON-SPARSE_RAW_FORMATS">QCOW2
  AND NON-SPARSE RAW FORMATS</a></h2>
If the input disk is in qcow2 format, then you may prefer that the output is in
  qcow2 format as well. Alternately, virt-resize can convert the format on the
  fly. The output format is simply determined by the format of the empty output
  container that you provide. Thus to create qcow2 output, use:
<div class="Pp"></div>
<pre>
 qemu-img create -f qcow2 -o preallocation=metadata outdisk [size]
</pre>
<div class="Pp"></div>
instead of the truncate command.
<div class="Pp"></div>
Similarly, to get non-sparse raw output use:
<div class="Pp"></div>
<pre>
 fallocate -l size outdisk
</pre>
<div class="Pp"></div>
(on older systems that don't have the <i>fallocate</i>(1) command use &quot;dd
  if=/dev/zero of=outdisk bs=1M count=..&quot;)
<h2 class="Ss" title="Ss" id="LOGICAL_PARTITIONS"><a class="selflink" href="#LOGICAL_PARTITIONS">LOGICAL
  PARTITIONS</a></h2>
Logical partitions (a.k.a. <i>/dev/sda5+</i> on disks using DOS partition
  tables) cannot be resized.
<div class="Pp"></div>
To understand what is going on, firstly one of the four partitions
  <i>/dev/sda1-4</i> will have MBR partition type 05 or &quot;0f&quot;. This is
  called the <b>extended partition</b>. Use <i>virt-filesystems</i>(1) to see
  the MBR partition type.
<div class="Pp"></div>
Logical partitions live inside the extended partition.
<div class="Pp"></div>
The extended partition can be expanded, but not shrunk (unless you force it,
  which is not advisable). When the extended partition is copied across, all the
  logical partitions contained inside are copied over implicitly. Virt-resize
  does not look inside the extended partition, so it copies the logical
  partitions blindly.
<div class="Pp"></div>
You cannot specify a logical partition ( <i>/dev/sda5+</i>) at all on the
  command line. Doing so will give an error.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help</b></dt>
  <dd class="It-tag">Display help.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--align-first auto</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--align-first never</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--align-first always</b></dt>
  <dd class="It-tag">Align the first partition for improved performance (see
      also the <i>--alignment</i> option).
    <div style="height: 1.00em;">&#x00A0;</div>
    The default is <i>--align-first auto</i> which only aligns the first
      partition if it is safe to do so. That is, only when we know how to fix
      the bootloader automatically, and at the moment that can only be done for
      Windows guests.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>--align-first never</i> means we never move the first partition. This is
      the safest option. Try this if the guest does not boot after resizing.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>--align-first always</i> means we always align the first partition (if
      it needs to be aligned). For some guests this will break the bootloader,
      making the guest unbootable.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--alignment N</b></dt>
  <dd class="It-tag">Set the alignment of partitions to &quot;N&quot; sectors.
      The default in virt-resize &lt; 1.13.19 was 64 sectors, and after that is
      128 sectors.
    <div style="height: 1.00em;">&#x00A0;</div>
    Assuming 512 byte sector size inside the guest, here are some suitable
      values for this:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>--alignment 1</i> (512 bytes)</dt>
  <dd class="It-tag">The partitions would be packed together as closely as
      possible, but would be completely unaligned. In some cases this can cause
      very poor performance. See <i>virt-alignment-scan</i>(1) for further
      details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>--alignment 8</i> (4K)</dt>
  <dd class="It-tag">This would be the minimum acceptable alignment for
      reasonable performance on modern hosts.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>--alignment 128</i> (64K)</dt>
  <dd class="It-tag">This alignment provides good performance when the host is
      using high end network storage.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>--alignment 2048</i> (1M)</dt>
  <dd class="It-tag">This is the standard alignment used by all newly installed
      guests since around 2008.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--colors</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--colours</b></dt>
  <dd class="It-tag">Use ANSI colour sequences to colourize messages. This is
      the default when the output is a tty. If the output of the program is
      redirected to a file, ANSI colour sequences are disabled unless you use
      this option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--debug</b></dt>
  <dd class="It-tag">(Deprecated: use <i>-v</i> option instead)
    <div style="height: 1.00em;">&#x00A0;</div>
    Enable debugging messages.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--debug-gc</b></dt>
  <dd class="It-tag">Debug garbage collection and memory allocation. This is
      only useful when debugging memory problems in virt-resize or the OCaml
      libguestfs bindings.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--delete part</b></dt>
  <dd class="It-tag">Delete the named partition. It would be more accurate to
      describe this as &quot;don't copy it over&quot;, since virt-resize doesn't
      do in-place changes and the original disk image is left intact.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that when you delete a partition, then anything contained in the
      partition is also deleted. Furthermore, this causes any partitions that
      come after to be <i>renumbered</i>, which can easily make your guest
      unbootable.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can give this option multiple times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--expand part</b></dt>
  <dd class="It-tag">Expand the named partition so it uses up all extra space
      (space left over after any other resize changes that you request have been
      done).
    <div style="height: 1.00em;">&#x00A0;</div>
    If virt-resize knows how, it will expand the direct content of the
      partition. For example, if the partition is an LVM PV, it will expand the
      PV to fit (like calling <i>pvresize</i>(8)). Virt-resize leaves any other
      content it doesn't know about alone.
    <div style="height: 1.00em;">&#x00A0;</div>
    Currently virt-resize can resize:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">ext2, ext3 and ext4 filesystems.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">NTFS filesystems, if libguestfs was compiled with support
      for NTFS.
    <div style="height: 1.00em;">&#x00A0;</div>
    The filesystem must have been shut down consistently last time it was used.
      Additionally, <i>ntfsresize</i>(8) marks the resized filesystem as
      requiring a consistency check, so at the first boot after resizing Windows
      will check the disk.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LVM PVs (physical volumes). virt-resize does not usually
      resize anything inside the PV, but see the <i>--LV-expand</i> option. The
      user could also resize LVs as desired after boot.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Btrfs filesystems, if libguestfs was compiled with support
      for btrfs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">XFS filesystems, if libguestfs was compiled with support
      for XFS.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Note that you cannot use <i>--expand</i> and <i>--shrink</i> together.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--format</b> raw</dt>
  <dd class="It-tag">Specify the format of the input disk image. If this flag is
      not given then it is auto-detected from the image itself.
    <div style="height: 1.00em;">&#x00A0;</div>
    If working with untrusted raw-format guest disk images, you should ensure
      the format is always specified.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that this option <i>does not</i> affect the output format. See
      &quot;QCOW2 AND NON-SPARSE RAW FORMATS&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ignore part</b></dt>
  <dd class="It-tag">Ignore the named partition. Effectively this means the
      partition is allocated on the destination disk, but the content is not
      copied across from the source disk. The content of the partition will be
      blank (all zero bytes).
    <div style="height: 1.00em;">&#x00A0;</div>
    You can give this option multiple times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--LV-expand logvol</b></dt>
  <dd class="It-tag">This takes the logical volume and, as a final step, expands
      it to fill all the space available in its volume group. A typical usage,
      assuming a Linux guest with a single PV <i>/dev/sda2</i> and a root device
      called <i>/dev/vg_guest/lv_root</i> would be:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 virt-resize indisk outdisk \
   --expand /dev/sda2 --LV-expand /dev/vg_guest/lv_root
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This would first expand the partition (and PV), and then expand the root
      device to fill the extra space in the PV.
    <div style="height: 1.00em;">&#x00A0;</div>
    The contents of the LV are also resized if virt-resize knows how to do that.
      You can stop virt-resize from trying to expand the content by using the
      option <i>--no-expand-content</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use <i>virt-filesystems</i>(1) to list the filesystems in the guest.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can give this option multiple times, <i>but</i> it doesn't make sense to
      do this unless the logical volumes you specify are all in different volume
      groups.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--machine-readable</b></dt>
  <dd class="It-tag">This option is used to make the output more machine
      friendly when being parsed by other programs. See &quot;MACHINE READABLE
      OUTPUT&quot; below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dryrun</b></dt>
  <dd class="It-tag">Print a summary of what would be done, but don't do
      anything.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-copy-boot-loader</b></dt>
  <dd class="It-tag">By default, virt-resize copies over some sectors at the
      start of the disk (up to the beginning of the first partition). Commonly
      these sectors contain the Master Boot Record (MBR) and the boot loader,
      and are required in order for the guest to boot correctly.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you specify this flag, then this initial copy is not done. You may need
      to reinstall the boot loader in this case.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-extra-partition</b></dt>
  <dd class="It-tag">By default, virt-resize creates an extra partition if there
      is any extra, unused space after all resizing has happened. Use this
      option to prevent the extra partition from being created. If you do this
      then the extra space will be inaccessible until you run fdisk, parted, or
      some other partitioning tool in the guest.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that if the surplus space is smaller than 10 MB, no extra partition
      will be created.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-expand-content</b></dt>
  <dd class="It-tag">By default, virt-resize will try to expand the direct
      contents of partitions, if it knows how (see <i>--expand</i> option
      above).
    <div style="height: 1.00em;">&#x00A0;</div>
    If you give the <i>--no-expand-content</i> option then virt-resize will not
      attempt this.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-sparse</b></dt>
  <dd class="It-tag">Turn off sparse copying. See &quot;SPARSE COPYING&quot;
      below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ntfsresize-force</b></dt>
  <dd class="It-tag">Pass the <i>--force</i> option to <i>ntfsresize</i>(8),
      allowing resizing even if the NTFS disk is marked as needing a consistency
      check. You have to use this option if you want to resize a Windows guest
      multiple times without booting into Windows between each resize.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--output-format</b> raw</dt>
  <dd class="It-tag">Specify the format of the output disk image. If this flag
      is not given then it is auto-detected from the image itself.
    <div style="height: 1.00em;">&#x00A0;</div>
    If working with untrusted raw-format guest disk images, you should ensure
      the format is always specified.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that this option <i>does not create</i> the output format. This option
      just tells libguestfs what it is so it doesn't try to guess it. You still
      need to create the output disk with the right format. See &quot;QCOW2 AND
      NON-SPARSE RAW FORMATS&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quiet</b></dt>
  <dd class="It-tag">Don't print the summary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--resize part=size</b></dt>
  <dd class="It-tag">Resize the named partition (expanding or shrinking it) so
      that it has the given size.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;size&quot; can be expressed as an absolute number followed by b/K/M/G
      to mean bytes, Kilobytes, Megabytes, or Gigabytes; or as a percentage of
      the current size; or as a relative number or percentage. For example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 --resize /dev/sda2=10G
 --resize /dev/sda4=90%
 --resize /dev/sda2=+1G
 --resize /dev/sda2=-200M
 --resize /dev/sda1=+128K
 --resize /dev/sda1=+10%
 --resize /dev/sda1=-10%
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can increase the size of any partition. Virt-resize will expand the
      direct content of the partition if it knows how (see <i>--expand</i>
      above).
    <div style="height: 1.00em;">&#x00A0;</div>
    You can only <i>decrease</i> the size of partitions that contain filesystems
      or PVs which have already been shrunk. Virt-resize will check this has
      been done before proceeding, or else will print an error (see also
      <i>--resize-force</i>).
    <div style="height: 1.00em;">&#x00A0;</div>
    You can give this option multiple times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--resize-force part=size</b></dt>
  <dd class="It-tag">This is the same as <i>--resize</i> except that it will let
      you decrease the size of any partition. Generally this means you will lose
      any data which was at the end of the partition you shrink, but you may not
      care about that (eg. if shrinking an unused partition, or if you can
      easily recreate it such as a swap partition).
    <div style="height: 1.00em;">&#x00A0;</div>
    See also the <i>--ignore</i> option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--shrink part</b></dt>
  <dd class="It-tag">Shrink the named partition until the overall disk image
      fits in the destination. The named partition <b>must</b> contain a
      filesystem or PV which has already been shrunk using another tool (eg.
      <i>guestfish</i>(1) or other online tools). Virt-resize will check this
      and give an error if it has not been done.
    <div style="height: 1.00em;">&#x00A0;</div>
    The amount by which the overall disk must be shrunk (after carrying out all
      other operations requested by the user) is called the &quot;deficit&quot;.
      For example, a straight copy (assume no other operations) from a 5GB disk
      image to a 4GB disk image results in a 1GB deficit. In this case,
      virt-resize would give an error unless the user specified a partition to
      shrink and that partition had more than a gigabyte of free space.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that you cannot use <i>--expand</i> and <i>--shrink</i> together.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--unknown-filesystems ignore</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--unknown-filesystems warn</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--unknown-filesystems error</b></dt>
  <dd class="It-tag">Configure the behaviour of virt-resize when asking to
      expand a filesystem, and neither libguestfs has the support it, nor
      virt-resize knows how to expand the content of the filesystem.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>--unknown-filesystems ignore</i> will cause virt-resize to silently
      ignore such filesystems, and nothing is printed about them.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>--unknown-filesystems warn</i> (the default behaviour) will cause
      virt-resize to warn for each of the filesystem that cannot be expanded,
      but still continuing to resize the disk.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>--unknown-filesystems error</i> will cause virt-resize to error out at
      the first filesystem that cannot be expanded.
    <div style="height: 1.00em;">&#x00A0;</div>
    See also &quot;unknown/unavailable method for expanding the TYPE filesystem
      on DEVICE/LV&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--verbose</b></dt>
  <dd class="It-tag">Enable debugging messages.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--version</b></dt>
  <dd class="It-tag">Display version number and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x</b></dt>
  <dd class="It-tag">Enable tracing of libguestfs API calls.</dd>
</dl>
<h1 class="Sh" title="Sh" id="MACHINE_READABLE_OUTPUT"><a class="selflink" href="#MACHINE_READABLE_OUTPUT">MACHINE
  READABLE OUTPUT</a></h1>
The <i>--machine-readable</i> option can be used to make the output more machine
  friendly, which is useful when calling virt-resize from other programs, GUIs
  etc.
<div class="Pp"></div>
There are two ways to use this option.
<div class="Pp"></div>
Firstly use the option on its own to query the capabilities of the virt-resize
  binary. Typical output looks like this:
<div class="Pp"></div>
<pre>
 $ virt-resize --machine-readable
 virt-resize
 ntfsresize-force
 32bitok
 ntfs
 btrfs
</pre>
<div class="Pp"></div>
A list of features is printed, one per line, and the program exits with status
  0.
<div class="Pp"></div>
Secondly use the option in conjunction with other options to make the regular
  program output more machine friendly.
<div class="Pp"></div>
At the moment this means:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Progress bar messages can be parsed from stdout by looking
      for this regular expression:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 ^[0-9]+/[0-9]+$
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">The calling program should treat messages sent to stdout
      (except for progress bar messages) as status messages. They can be logged
      and/or displayed to the user.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">The calling program should treat messages sent to stderr as
      error messages. In addition, virt-resize exits with a non-zero status code
      if there was a fatal error.</dd>
</dl>
<div class="Pp"></div>
Versions of the program prior to 1.13.9 did not support the
  <i>--machine-readable</i> option and will return an error.
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
<h2 class="Ss" title="Ss" id="&quot;Partition_1_does_not_end_on_cylinder_boundary.&quot;"><a class="selflink" href="#&quot;Partition_1_does_not_end_on_cylinder_boundary.&quot;">&quot;Partition
  1 does not end on cylinder boundary.&quot;</a></h2>
Virt-resize aligns partitions to multiples of 128 sectors (see the
  <i>--alignment</i> parameter). Usually this means the partitions will not be
  aligned to the ancient CHS geometry. However CHS geometry is meaningless for
  disks manufactured since the early 1990s, and doubly so for virtual hard
  drives. Alignment of partitions to cylinders is not required by any modern
  operating system.
<h2 class="Ss" title="Ss" id="GUEST_BOOT_STUCK_AT_&quot;GRUB&quot;"><a class="selflink" href="#GUEST_BOOT_STUCK_AT_&quot;GRUB&quot;">GUEST
  BOOT STUCK AT &quot;GRUB&quot;</a></h2>
If a Linux guest does not boot after resizing, and the boot is stuck after
  printing &quot;GRUB&quot; on the console, try reinstalling grub.
<div class="Pp"></div>
<pre>
 guestfish -i -a newdisk
 &gt;&lt;fs&gt; cat /boot/grub/device.map
 # check the contents of this file are sensible or
 # edit the file if necessary
 &gt;&lt;fs&gt; grub-install / /dev/vda
 &gt;&lt;fs&gt; exit
</pre>
<div class="Pp"></div>
For more flexible guest reconfiguration, including if you need to specify other
  parameters to grub-install, use <i>virt-rescue</i>(1).
<h2 class="Ss" title="Ss" id="RESIZING_WINDOWS_BOOT_PARTITIONS"><a class="selflink" href="#RESIZING_WINDOWS_BOOT_PARTITIONS">RESIZING
  WINDOWS BOOT PARTITIONS</a></h2>
In Windows Vista and later versions, Microsoft switched to using a separate boot
  partition. In these VMs, typically <i>/dev/sda1</i> is the boot partition and
  <i>/dev/sda2</i> is the main (C:) drive. Resizing the first (boot) partition
  causes the bootloader to fail with 0xC0000225 error. Resizing the second
  partition (ie. C: drive) should work.
<h2 class="Ss" title="Ss" id="WINDOWS_CHKDSK"><a class="selflink" href="#WINDOWS_CHKDSK">WINDOWS
  CHKDSK</a></h2>
Windows disks which use NTFS must be consistent before virt-resize can be used.
  If the ntfsresize operation fails, try booting the original VM and running
  &quot;chkdsk /f&quot; on all NTFS partitions, then shut down the VM cleanly.
  For further information see:
  https://bugzilla.redhat.com/show_bug.cgi?id=975753
<div class="Pp"></div>
<i>After resize</i> Windows may initiate a lengthy &quot;chkdsk&quot; on first
  boot if NTFS partitions have been expanded. This is just a safety check and
  (unless it find errors) is nothing to worry about.
<h2 class="Ss" title="Ss" id="WINDOWS_UNMOUNTABLE_BOOT_VOLUME_BSOD"><a class="selflink" href="#WINDOWS_UNMOUNTABLE_BOOT_VOLUME_BSOD">WINDOWS
  UNMOUNTABLE_BOOT_VOLUME BSOD</a></h2>
After sysprepping a Windows guest and then resizing it with virt-resize, you may
  see the guest fail to boot with an &quot;UNMOUNTABLE_BOOT_VOLUME&quot; BSOD.
  This error is caused by having &quot;ExtendOemPartition=1&quot; in the
  sysprep.inf file. Removing this line before sysprepping should fix the
  problem.
<h2 class="Ss" title="Ss" id="WINDOWS_8"><a class="selflink" href="#WINDOWS_8">WINDOWS
  8</a></h2>
Windows 8 &quot;fast startup&quot; can prevent virt-resize from resizing NTFS
  partitions. See &quot;WINDOWS HIBERNATION AND WINDOWS 8 FAST STARTUP&quot; in
  <i>guestfs</i>(3).
<h2 class="Ss" title="Ss" id="SPARSE_COPYING"><a class="selflink" href="#SPARSE_COPYING">SPARSE
  COPYING</a></h2>
You should create a fresh, zeroed target disk image for virt-resize to use.
<div class="Pp"></div>
Virt-resize by default performs sparse copying. This means that it does not copy
  blocks from the source disk which are all zeroes. This improves speed and
  efficiency, but will produce incorrect results if the target disk image
  contains unzeroed data.
<div class="Pp"></div>
The main time this can be a problem is if the target is a host partition (eg.
  &quot;virt-resize&#x00A0;source.img&#x00A0;/dev/sda4&quot;) because the usual
  partitioning tools tend to leave whatever data happened to be on the disk
  before.
<div class="Pp"></div>
If you have to reuse a target which contains data already, you should use the
  <i>--no-sparse</i> option. Note this can be much slower.
<h2 class="Ss" title="Ss" id="&quot;unknown/unavailable_method_for_expanding_the_TYPE_filesystem_on_DEVICE/LV&quot;"><a class="selflink" href="#&quot;unknown/unavailable_method_for_expanding_the_TYPE_filesystem_on_DEVICE/LV&quot;">&quot;unknown/unavailable
  method for expanding the TYPE filesystem on DEVICE/LV&quot;</a></h2>
Virt-resize was asked to expand a partition or a logical volume containing a
  filesystem with the type &quot;TYPE&quot;, but there is no available nor known
  expanding method for that filesystem.
<div class="Pp"></div>
This may be due to either of the following:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">There corresponding filesystem is not available in
      libguestfs, because there is no proper package in the host with utilities
      for it. This is usually the case for &quot;btrfs&quot;, &quot;ntfs&quot;,
      and &quot;xfs&quot; filesystems.
    <div style="height: 1.00em;">&#x00A0;</div>
    Check the results of:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
 virt-resize --machine-readable
 guestfish -a /dev/null run : available
 guestfish -a /dev/null run : filesystem_available TYPE
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    In this case, it is enough to install the proper packages adding support for
      them. For example, &quot;libguestfs-xfs&quot; on Red Hat Enterprise Linux,
      CentOS, Debian, Ubuntu, and distributions derived from them, for
      supporting the &quot;xfs&quot; filesystem.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">Virt-resize has no support for expanding that type of
      filesystem.
    <div style="height: 1.00em;">&#x00A0;</div>
    In this case, there's nothing that can be done to let virt-resize expand
      that type of filesystem.</dd>
</dl>
<div class="Pp"></div>
In both cases, virt-resize will not expand the mentioned filesystem; the result
  (unless <i>--unknown-filesystems error</i> is specified) is that the
  partitions containing such filesystems will be actually bigger as requested,
  but the filesystems will still be usable at the their older sizes.
<h1 class="Sh" title="Sh" id="ALTERNATIVE_TOOLS"><a class="selflink" href="#ALTERNATIVE_TOOLS">ALTERNATIVE
  TOOLS</a></h1>
There are several proprietary tools for resizing partitions. We won't mention
  any here.
<div class="Pp"></div>
<i>parted</i>(8) and its graphical shell gparted can do some types of resizing
  operations on disk images. They can resize and move partitions, but I don't
  think they can do anything with the contents, and they certainly don't
  understand LVM.
<div class="Pp"></div>
<i>guestfish</i>(1) can do everything that virt-resize can do and a lot more,
  but at a much lower level. You will probably end up hand-calculating sector
  offsets, which is something that virt-resize was designed to avoid. If you
  want to see the guestfish-equivalent commands that virt-resize runs, use the
  <i>--debug</i> flag.
<div class="Pp"></div>
<i>dracut</i>(8) includes a module called &quot;dracut-modules-growroot&quot;
  which can be used to grow the root partition when the guest first boots up.
  There is documentation for this module in an associated README file.
<h1 class="Sh" title="Sh" id="EXIT_STATUS"><a class="selflink" href="#EXIT_STATUS">EXIT
  STATUS</a></h1>
This program returns 0 if successful, or non-zero if there was an error.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>virt-filesystems</i>(1), <i>virt-df</i>(1), <i>guestfs</i>(3),
  <i>guestfish</i>(1), <i>lvm</i>(8), <i>pvresize</i>(8), <i>lvresize</i>(8),
  <i>resize2fs</i>(8), <i>ntfsresize</i>(8), <i>btrfs</i>(8),
  <i>xfs_growfs</i>(8), <i>virsh</i>(1), <i>parted</i>(8), <i>truncate</i>(1),
  <i>fallocate</i>(1), <i>grub</i>(8), <i>grub-install</i>(8),
  <i>virt-rescue</i>(1), <i>virt-sparsify</i>(1), <i>virt-alignment-scan</i>(1),
  http://libguestfs.org/.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Richard W.M. Jones http://people.redhat.com/~rjones/
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (C) 2010-2012 Red Hat Inc.
<h1 class="Sh" title="Sh" id="LICENSE"><a class="selflink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any later
  version.
<div class="Pp"></div>
This program is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE. See the GNU General Public License for more details.
<div class="Pp"></div>
You should have received a copy of the GNU General Public License along with
  this program; if not, write to the Free Software Foundation, Inc., 51 Franklin
  Street, Fifth Floor, Boston, MA 02110-1301 USA.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
To get a list of bugs against libguestfs, use this link:
  https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools
<div class="Pp"></div>
To report a new bug against libguestfs, use this link:
  https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools
<div class="Pp"></div>
When reporting a bug, please supply:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The version of libguestfs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Where you got libguestfs (eg. which Linux distro, compiled
      from source, etc)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Describe the bug accurately and give a way to reproduce
    it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Run <i>libguestfs-test-tool</i>(1) and paste the
      <b>complete, unedited</b> output into the bug report.</dd>
</dl>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-08-08</td>
    <td class="foot-os">libguestfs-1.32.7</td>
  </tr>
</table>
</body>
</html>
