<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:04:45 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DOCKER(1) JUNE 2014 DOCKER(1)</p>

<p style="margin-top: 1em">NAME <br>
docker-build - Build an image from a Dockerfile</p>

<p style="margin-top: 1em">SYNOPSIS <br>
docker build [--build-arg[=[]]] [--cpu-shares[=0]]
[--cgroup-parent[=CGROUP-PARENT]] [--help]
[-f|--file[=PATH/Dockerfile]] [-squash] Experimental
[--force-rm] [--isola&acirc; <br>
tion[=default]] [--label[=[]]] [--no-cache] [--pull]
[--compress] [-q|--quiet] [--rm[=true]] [-t|--tag[=[]]]
[-m|--memory[=MEMORY]] [--memory-swap[=LIMIT]] [--net&acirc;
<br>
work[=&quot;default&quot;]] [--shm-size[=SHM-SIZE]]
[--cpu-period[=0]] [--cpu-quota[=0]]
[--cpuset-cpus[=CPUSET-CPUS]] [--cpuset-mems[=CPUSET-MEMS]]
[--ulimit[=[]]] [-v|--volume[=[]]] PATH <br>
| URL | -</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This will read the Dockerfile from the directory specified
in PATH. It also sends any other files and directories found
in the current directory to the Docker daemon. The
con&acirc; <br>
tents of this directory would be used by ADD commands found
within the Dockerfile.</p>

<p style="margin-top: 1em">Warning, this will send a lot of
data to the Docker daemon depending on the contents of the
current directory. The build is run by the Docker daemon,
not by the CLI, so the whole <br>
context must be transferred to the daemon. The Docker CLI
reports &quot;Sending build context to Docker daemon&quot;
when the context is sent to the daemon.</p>

<p style="margin-top: 1em">When the URL to a tarball
archive or to a single Dockerfile is given, no context is
sent from the client to the Docker daemon. In this case, the
Dockerfile at the root of the ar&acirc; <br>
chive and the rest of the archive will get used as the
context of the build. When a Git repository is set as the
URL, the repository is cloned locally and then sent as the
con&acirc; <br>
text.</p>

<p style="margin-top: 1em">OPTIONS <br>
-f, --file=PATH/Dockerfile <br>
Path to the Dockerfile to use. If the path is a relative
path and you are <br>
building from a local directory, then the path must be
relative to that <br>
directory. If you are building from a remote URL pointing to
either a <br>
tarball or a Git repository, then the path must be relative
to the root of <br>
the remote context. In all cases, the file must be within
the build context. <br>
The default is Dockerfile.</p>

<p style="margin-top: 1em">--squash=true|false <br>
Experimental Only <br>
Once the image is built, squash the new layers into a new
image with a single <br>
new layer. Squashing does not destroy any existing image,
rather it creates a new <br>
image with the content of the squshed layers. This
effectively makes it look <br>
like all Dockerfile commands were created with a single
layer. The build <br>
cache is preserved with this method.</p>

<p style="margin-top: 1em">Note: using this option means
the new image will not be able to take <br>
advantage of layer sharing with other images and may use
significantly more <br>
space.</p>

<p style="margin-top: 1em">Note: using this option you may
see significantly more space used due to <br>
storing two copies of the image, one for the build cache
with all the cache <br>
layers in tact, and one for the squashed version.</p>

<p style="margin-top: 1em">--build-arg=variable <br>
name and value of a buildarg.</p>

<p style="margin-top: 1em">For example, if you want to pass
a value for http_proxy, use <br>

--build-arg=http_proxy=&quot;http://some.proxy.url&quot;</p>

<p style="margin-top: 1em">Users pass these values at
build-time. Docker uses the buildargs as the <br>
environment context for command(s) run via the
Dockerfile&rsquo;s RUN instruction <br>
or for variable expansion in other Dockerfile instructions.
This is not meant <br>
for passing secret values.
&acirc;&uml;https://docs.docker.com/engine/reference/builder/#arg&acirc;&copy;</p>

<p style="margin-top: 1em">--force-rm=true|false <br>
Always remove intermediate containers, even after
unsuccessful builds. The default is false.</p>

<p style="margin-top: 1em">--isolation=&quot;default&quot;
<br>
Isolation specifies the type of isolation technology used by
containers.</p>

<p style="margin-top: 1em">--label=label <br>
Set metadata for an image</p>

<p style="margin-top: 1em">--no-cache=true|false <br>
Do not use cache when building the image. The default is
false.</p>

<p style="margin-top: 1em">--help <br>
Print usage statement</p>

<p style="margin-top: 1em">--pull=true|false <br>
Always attempt to pull a newer version of the image. The
default is false.</p>

<p style="margin-top: 1em">--compress=true|false <br>
Compress the build context using gzip. The default is
false.</p>

<p style="margin-top: 1em">-q, --quiet=true|false <br>
Suppress the build output and print image ID on success. The
default is false.</p>

<p style="margin-top: 1em">--rm=true|false <br>
Remove intermediate containers after a successful build. The
default is true.</p>

<p style="margin-top: 1em">-t, --tag=&quot;&quot; <br>
Repository names (and optionally with tags) to be applied to
the resulting <br>
image in case of success. Refer to docker-tag(1) for more
information <br>
about valid tag names.</p>

<p style="margin-top: 1em">-m, --memory=MEMORY <br>
Memory limit</p>

<p style="margin-top: 1em">--memory-swap=LIMIT <br>
A limit value equal to memory plus swap. Must be used with
the -m (--memory) flag. The swap LIMIT should always be
larger than -m (--memory) value.</p>

<p style="margin-top: 1em">The format of LIMIT is
&lt;number&gt;[&lt;unit&gt;]. Unit can be b (bytes), k
(kilobytes), m (megabytes), or g (gigabytes). If you
don&rsquo;t specify a unit, b is used. Set LIMIT to -1 to
enable <br>
unlimited swap.</p>

<p style="margin-top: 1em">--network=bridge <br>
Set the networking mode for the RUN instructions during
build. Supported standard <br>
values are: bridge, host, none and
container:&lt;name|id&gt;. Any other value <br>
is taken as a custom network&rsquo;s name or ID which this
container should connect to.</p>

<p style="margin-top: 1em">--shm-size=SHM-SIZE <br>
Size of /dev/shm. The format is &lt;number&gt;&lt;unit&gt;.
number must be greater than 0. <br>
Unit is optional and can be b (bytes), k (kilobytes), m
(megabytes), or g (gigabytes). If you omit the unit, the
system uses bytes. <br>
If you omit the size entirely, the system uses 64m.</p>

<p style="margin-top: 1em">--cpu-shares=0 <br>
CPU shares (relative weight).</p>

<p style="margin-top: 1em">By default, all containers get
the same proportion of CPU cycles. <br>
CPU shares is a &rsquo;relative weight&rsquo;, relative to
the default setting of 1024. <br>
This default value is defined here:</p>

<p style="margin-top: 1em">cat
/sys/fs/cgroup/cpu/cpu.shares <br>
1024</p>

<p style="margin-top: 1em">You can change this proportion
by adjusting the container&rsquo;s CPU share <br>
weighting relative to the weighting of all other running
containers.</p>

<p style="margin-top: 1em">To modify the proportion from
the default of 1024, use the --cpu-shares <br>
flag to set the weighting to 2 or higher.</p>

<p style="margin-top: 1em">Container CPU share Flag <br>
{C0} 60% of CPU --cpu-shares=614 (614 is 60% of 1024) <br>
{C1} 40% of CPU --cpu-shares=410 (410 is 40% of 1024)</p>

<p style="margin-top: 1em">The proportion is only applied
when CPU-intensive processes are running. <br>
When tasks in one container are idle, the other containers
can use the <br>
left-over CPU time. The actual amount of CPU time used
varies depending on <br>
the number of containers running on the system.</p>

<p style="margin-top: 1em">For example, consider three
containers, where one has --cpu-shares=1024 and <br>
two others have --cpu-shares=512. When processes in all
three <br>
containers attempt to use 100% of CPU, the first container
would receive <br>
50% of the total CPU time. If you add a fourth container
with --cpu-shares=1024, <br>
the first container only gets 33% of the CPU. The remaining
containers <br>
receive 16.5%, 16.5% and 33% of the CPU.</p>

<p style="margin-top: 1em">Container CPU share Flag CPU
time <br>
{C0} 100% --cpu-shares=1024 33% <br>
{C1} 50% --cpu-shares=512 16.5% <br>
{C2} 50% --cpu-shares=512 16.5% <br>
{C4} 100% --cpu-shares=1024 33%</p>

<p style="margin-top: 1em">On a multi-core system, the
shares of CPU time are distributed across the CPU <br>
cores. Even if a container is limited to less than 100% of
CPU time, it can <br>
use 100% of each individual CPU core.</p>

<p style="margin-top: 1em">For example, consider a system
with more than three cores. If you start one <br>
container {C0} with --cpu-shares=512 running one process,
and another container <br>
{C1} with --cpu-shares=1024 running two processes, this can
result in the following <br>
division of CPU shares:</p>

<p style="margin-top: 1em">PID container CPU CPU share <br>
100 {C0} 0 100% of CPU0 <br>
101 {C1} 1 100% of CPU1 <br>
102 {C1} 2 100% of CPU2</p>

<p style="margin-top: 1em">--cpu-period=0 <br>
Limit the CPU CFS (Completely Fair Scheduler) period.</p>

<p style="margin-top: 1em">Limit the container&rsquo;s CPU
usage. This flag causes the kernel to restrict the <br>
container&rsquo;s CPU usage to the period you specify.</p>

<p style="margin-top: 1em">--cpu-quota=0 <br>
Limit the CPU CFS (Completely Fair Scheduler) quota.</p>

<p style="margin-top: 1em">By default, containers run with
the full CPU resource. This flag causes the kernel to
restrict the container&rsquo;s CPU usage to the quota you
specify.</p>

<p style="margin-top: 1em">--cpuset-cpus=CPUSET-CPUS <br>
CPUs in which to allow execution (0-3, 0,1).</p>

<p style="margin-top: 1em">--cpuset-mems=CPUSET-MEMS <br>
Memory nodes (MEMs) in which to allow execution (0-3, 0,1).
Only effective on <br>
NUMA systems.</p>

<p style="margin-top: 1em">For example, if you have four
memory nodes on your system (0-3), use --cpuset-mems=0,1 to
ensure the processes in your Docker container only use
memory from the first two memory <br>
nodes.</p>

<p style="margin-top: 1em">--cgroup-parent=CGROUP-PARENT
<br>
Path to cgroups under which the container&rsquo;s cgroup are
created.</p>

<p style="margin-top: 1em">If the path is not absolute, the
path is considered relative to the cgroups path of the init
process. Cgroups are created if they do not already
exist.</p>

<p style="margin-top: 1em">--ulimit=[] <br>
Ulimit options</p>

<p style="margin-top: 1em">+-v, --volume=[] Create a bind
mount + (format: host-dir:container-dir[:&lt;suffix
options&gt;], where suffix options +are comma delimited and
selected from [ro] and [z|Z].). <br>
Read-write mode isn&rsquo;t supported at build time. +In
case rw is specified a warning is printed during the build
and it will be changed to ro preserving any SELinux mode
provided. <br>
+</p>

<p style="margin-top: 1em">For more information about
ulimit see
&acirc;&uml;https://docs.docker.com/engine/reference/commandline/run/#set-ulimits-in-container---ulimit&acirc;&copy;</p>

<p style="margin-top: 1em">EXAMPLES Building an image using
a Dockerfile located inside the current directory <br>
Docker images can be built using the build command and a
Dockerfile:</p>

<p style="margin-top: 1em">docker build .</p>

<p style="margin-top: 1em">During the build process Docker
creates intermediate images. In order to keep them, you must
explicitly set --rm=false.</p>

<p style="margin-top: 1em">docker build --rm=false .</p>

<p style="margin-top: 1em">A good practice is to make a
sub-directory with a related name and create the Dockerfile
in that directory. For example, a directory called mongo may
contain a Dockerfile to cre&acirc; <br>
ate a Docker MongoDB image. Likewise, another directory
called httpd may be used to store Dockerfiles for Apache web
server images.</p>

<p style="margin-top: 1em">It is also a good practice to
add the files required for the image to the sub-directory.
These files will then be specified with the COPY or ADD
instructions in the Dockerfile.</p>

<p style="margin-top: 1em">Note: If you include a tar file
(a good practice), then Docker will automatically extract
the contents of the tar file specified within the ADD
instruction into the specified <br>
target.</p>

<p style="margin-top: 1em">Building an image and naming
that image <br>
A good practice is to give a name to the image you are
building. Note that only a-z0-9-_. should be used for
consistency. There are no hard rules here but it is best to
give the <br>
names consideration.</p>

<p style="margin-top: 1em">The -t/--tag flag is used to
rename an image. Here are some examples:</p>

<p style="margin-top: 1em">Though it is not a good
practice, image names can be arbitrary:</p>

<p style="margin-top: 1em">docker build -t myimage .</p>

<p style="margin-top: 1em">A better approach is to provide
a fully qualified and meaningful repository, name, and tag
(where the tag in this context means the qualifier after the
&quot;:&quot;). In this example we <br>
build a JBoss image for the Fedora repository and give it
the version 1.0:</p>

<p style="margin-top: 1em">docker build -t fedora/jboss:1.0
.</p>

<p style="margin-top: 1em">The next example is for the
&quot;whenry&quot; user repository and uses Fedora and JBoss
and gives it the version 2.1 :</p>

<p style="margin-top: 1em">docker build -t
whenry/fedora-jboss:v2.1 .</p>

<p style="margin-top: 1em">If you do not provide a version
tag then Docker will assign latest:</p>

<p style="margin-top: 1em">docker build -t
whenry/fedora-jboss .</p>

<p style="margin-top: 1em">When you list the images, the
image above will have the tag latest.</p>

<p style="margin-top: 1em">You can apply multiple tags to
an image. For example, you can apply the latest tag to a
newly built image and add another tag that references a
specific version. For example, to <br>
tag an image both as whenry/fedora-jboss:latest and
whenry/fedora-jboss:v2.1, use the following:</p>

<p style="margin-top: 1em">docker build -t
whenry/fedora-jboss:latest -t whenry/fedora-jboss:v2.1 .</p>

<p style="margin-top: 1em">So renaming an image is
arbitrary but consideration should be given to a useful
convention that makes sense for consumers and should also
take into account Docker community con&acirc; <br>
ventions.</p>

<p style="margin-top: 1em">Building an image using a URL
<br>
This will clone the specified GitHub repository from the URL
and use it as context. The Dockerfile at the root of the
repository is used as Dockerfile. This only works if the
<br>
GitHub repository is a dedicated repository.</p>

<p style="margin-top: 1em">docker build
github.com/scollier/purpletest</p>

<p style="margin-top: 1em">Note: You can set an arbitrary
Git repository via the git:// scheme.</p>

<p style="margin-top: 1em">Building an image using a URL to
a tarball&rsquo;ed context <br>
This will send the URL itself to the Docker daemon. The
daemon will fetch the tarball archive, decompress it and use
its contents as the build context. The Dockerfile at the
<br>
root of the archive and the rest of the archive will get
used as the context of the build. If you pass an -f
PATH/Dockerfile option as well, the system will look for
that file <br>
inside the contents of the tarball.</p>

<p style="margin-top: 1em">docker build -f dev/Dockerfile
https://10.10.10.1/docker/context.tar.gz</p>

<p style="margin-top: 1em">Note: supported compression
formats are &rsquo;xz&rsquo;, &rsquo;bzip2&rsquo;,
&rsquo;gzip&rsquo; and &rsquo;identity&rsquo; (no
compression).</p>

<p style="margin-top: 1em">Specify isolation technology for
container (--isolation) <br>
This option is useful in situations where you are running
Docker containers on Windows. The --isolation=&lt;value&gt;
option sets a container&rsquo;s isolation technology. On
Linux, the only <br>
supported is the default option which uses Linux namespaces.
On Microsoft Windows, you can specify these values:</p>

<p style="margin-top: 1em">0</p>

<p style="margin-top: 1em">item default: Use the value
specified by the Docker daemon&rsquo;s --exec-opt . If the
daemon does not specify an isolation technology, Microsoft
Windows uses process as its <br>
default value. item process: Namespace isolation only. item
hyperv: Hyper-V hypervisor partition-based isolation.</p>

<p style="margin-top: 1em">Specifying the --isolation flag
without a value is the same as setting
--isolation=&quot;default&quot;.</p>

<p style="margin-top: 1em">HISTORY <br>
March 2014, Originally compiled by William Henry (whenry at
redhat dot com) based on docker.com source material and
internal work. June 2014, updated by Sven Dowideit
&acirc;&uml;Sven&acirc; <br>
Dowideit@home.org.au&acirc;&copy; June 2015, updated by
Sally O&rsquo;Malley
&acirc;&uml;somalley@redhat.com&acirc;&copy;</p>

<p style="margin-top: 1em">Docker Community Docker User
Manuals DOCKER(1)</p>
<hr>
</body>
</html>
