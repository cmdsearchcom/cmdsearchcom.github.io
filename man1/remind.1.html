<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:35:23 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>REMIND(1) General Commands Manual REMIND(1)</p>

<p style="margin-top: 1em">NAME <br>
remind - a sophisticated reminder service</p>

<p style="margin-top: 1em">SYNOPSIS <br>
remind [options] filename [date] [*rep] [time]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Remind reads the supplied filename and executes the commands
found in it. The commands are used to issue reminders and
alarms. Each reminder or alarm can consist of a message <br>
sent to standard output, or a program to be executed.</p>

<p style="margin-top: 1em">If filename is specified as a
single dash &rsquo;-&rsquo;, then Remind takes its input
from standard input. This also implicitly enables the -o
option, described below.</p>

<p style="margin-top: 1em">If filename happens to be a
directory rather than a plain file, then Remind reads all of
the files in that directory that match the pattern
&quot;*.rem&quot;. The files are read in sorted <br>
order; the sort order may depend on your locale, but should
match the sort order used by the shell to expand
&quot;*.rem&quot;.</p>

<p style="margin-top: 1em">Remind reads its files starting
from the beginning to the end, or until it encounters a line
whose sole content is &quot;__EOF__&quot; (without the
quotes.) Anything after the __EOF__ <br>
marker is completely ignored.</p>

<p style="margin-top: 1em">OPTIONS <br>
Remind has a slew of options. If you&rsquo;re new to the
program, ignore them for now and skip to the section
&quot;Reminder Files&quot;.</p>

<p style="margin-top: 1em">-n The -n option causes Remind
to print the next occurrence of each reminder in a simple
calendar format. You can sort this by date by piping the
output through sort(1).</p>

<p style="margin-top: 1em">-j[n] Runs Remind in
&quot;purge&quot; mode to get rid of expired reminders. See
the section PURGE MODE for details.</p>

<p style="margin-top: 1em">-r The -r option disables RUN
directives and the shell() function. As of Remind 3.00.17,
using -u implies -r.</p>

<p style="margin-top: 1em">-c[flags]n <br>
The -c option causes Remind to produce a calendar that is
sent to standard output. If you supply a number n, then a
calendar will be generated for n months, starting with <br>
the current month. By default, a calendar for only the
current month is produced.</p>

<p style="margin-top: 1em">You can precede n (if any) with
a set of flags. The flags are as follows:</p>

<p style="margin-top: 1em">&rsquo;+&rsquo; causes a
calendar for n weeks to be produced.</p>

<p style="margin-top: 1em">&rsquo;a&rsquo; causes Remind to
display reminders on the calendar on the day they actually
occur as well as on any preceding days specified by the
reminder&rsquo;s delta.</p>

<p style="margin-top: 1em">&rsquo;l&rsquo; causes Remind to
use VT100 line-drawing characters to draw the calendar. The
characters are hard-coded and will only work on terminals
that emulate the VT00 line-drawing <br>
character set.</p>

<p style="margin-top: 1em">&rsquo;u&rsquo; is similar to
&rsquo;l&rsquo;, but causes Remind to use UNICODE
line-drawing characters to draw the calendar. The characters
are hard-coded and will only work on terminals that are <br>
set to UTF-8 character encoding.</p>

<p style="margin-top: 1em">&rsquo;c&rsquo; causes Remind to
use VT100 escape sequences to approximate SPECIAL COLOR
reminders. The approximation is (of necessity) very coarse,
because the VT100 only has eight dif&acirc; <br>
ferent color sequences, each with one of two brightnesses. A
color component greater than 64 is considered
&quot;on&quot;, and if any of the three color components is
greater than <br>
128, the color is considered &quot;bright&quot;.</p>

<p style="margin-top: 1em">-wcol[,pad[,spc]]] <br>
The -w option specifies the output width, padding and
spacing of the formatted calendar output. Col specifies the
number of columns in the output device, and defaults to <br>
80. Pad specifies how many lines to use to &quot;pad&quot;
empty calendar boxes. This defaults to 5. If you have many
reminders on certain days that make your calendar too large
<br>
to fit on a page, you can try reducing pad to make the empty
boxes smaller. Spc specifies how many blank lines to leave
between the day number and the first reminder <br>
entry. It defaults to 1.</p>

<p style="margin-top: 1em">Any of col, pad or spc can be
omitted, providing you provide the correct number of commas.
Don&rsquo;t use any spaces in the option.</p>

<p style="margin-top: 1em">-s[a]n The -s option is very
similar to the -c option, except that the output calendar is
not formatted. It is listed in a &quot;simple format&quot;
that can be used as input for more <br>
sophisticated calendar-drawing programs. If n starts with
&quot;+&quot;, then it is interpreted as a number of
weeks.</p>

<p style="margin-top: 1em">If you immediately follow the s
with the letter a, then Remind displays reminders on the
calendar on the day they actually occur as well as on any
preceding days specified <br>
by the reminder&rsquo;s delta.</p>

<p style="margin-top: 1em">-p[a]n The -p option is very
similar to the -s option, except that the output contains
additional information for use by the Rem2PS program, which
creates a PostScript calendar. <br>
For this option, n cannot start with &quot;+&quot;; it must
specify a number of months. The format of the -p output is
described in the rem2ps(1) man page. If you immediately
fol&acirc; <br>
low the p with the letter a, then Remind displays reminders
on the calendar on the day they actually occur as well as on
any preceding days specified by the reminder&rsquo;s <br>
delta.</p>

<p style="margin-top: 1em">-l If you use the -l option in
conjunction with the -p option, then Remind outputs
additional information for back-end programs such as rem2ps.
This additional information <br>
lets the back-end programs correlate a reminder with the
source file and line number that produced it.</p>

<p style="margin-top: 1em">-m The -m option causes the -c
or -p options to produce a calendar whose first column is
Monday rather than Sunday. (This conforms to the
international standard.)</p>

<p style="margin-top: 1em">-v The -v option makes the
output of Remind slightly more verbose. Currently, this
causes Remind to echo a bad line in case of an error, and to
print a security message if a <br>
script tests the $RunOff system variable.</p>

<p style="margin-top: 1em">-o The -o option causes Remind
to ignore all ONCE directives.</p>

<p style="margin-top: 1em">-t The -t option causes Remind
to trigger all non-expired reminders, regardless of the
delta supplied for each reminder.</p>

<p style="margin-top: 1em">-tn If you supply a number n
after the -t option, then Remind pretends that each
non-expired reminder has a delta of n days and triggers
reminders accordingly.</p>

<p style="margin-top: 1em">-h The -h option
(&quot;hush...&quot;) suppresses certain warning and
information messages. In particular, if no reminders are
triggered, this mode produces no output.</p>

<p style="margin-top: 1em">-a The -a option causes Remind
not to immediately trigger timed reminders that trigger on
the current day. It also causes Remind not to place timed
reminders in a calendar. <br>
If you supply two or more -a options, then Remind will
trigger timed reminders that are in the future, but will not
trigger timed reminders whose time has passed. <br>
(Regardless of how many -a options you supply, Remind will
not include timed reminders in the calendar if at least one
-a option is used.)</p>

<p style="margin-top: 1em">-q The -q option causes Remind
not to queue timed reminders for later execution.</p>

<p style="margin-top: 1em">-f The -f option causes Remind
to remain in the foreground when processing queued
reminders, rather than forking off a background process to
handle them.</p>

<p style="margin-top: 1em">-e The -e option diverts error
messages (normally sent to the standard error stream) to the
standard output stream.</p>

<p style="margin-top: 1em">-dchars <br>
The -d option enables certain debugging modes. The chars
specify which modes to enable:</p>

<p style="margin-top: 1em">e Echo all input lines</p>

<p style="margin-top: 1em">x Trace all expression
evaluation</p>

<p style="margin-top: 1em">t Display all trigger date
computation</p>

<p style="margin-top: 1em">v Dump the variable table after
execution of the reminder script</p>

<p style="margin-top: 1em">l Echo lines when displaying
error messages</p>

<p style="margin-top: 1em">f Trace the reading of reminder
files</p>

<p style="margin-top: 1em">-g[a|d[a|d[a|d[a|d]]]] <br>
Normally, reminders are issued in the order in which they
are encountered in the reminder script. The -g option cause
Remind to sort reminders by date and time prior to <br>
issuing them. The optional a and d characters specify the
sort order (ascending or descending) for the date, time and
priority fields. See the section &quot;Sorting <br>
Reminders&quot; for more information.</p>

<p style="margin-top: 1em">-b[n] Set the time format for
the calendar and simple-calendar outputs. N can range from 0
to 2, with the default 0. A value of 0 causes times to be
inserted in 12-hour <br>
(am/pm) format. 1 causes times to be inserted in 24-hour
format, and 2 inhibits the automatic insertion of times in
the calendar output.</p>

<p style="margin-top: 1em">-x[n] Sets the iteration limit
for the SATISFY clause of a REM command. Defaults to
150.</p>

<p style="margin-top: 1em">-kcmd Instead of simply printing
MSG-type reminders, this causes them to be passed to the
specific cmd. You must use &rsquo;%s&rsquo; where you want
the body to appear, and may need to <br>
enclose this option in quotes. Note that all shell
characters in the body of the reminder are escaped with a
backslash, and the entire body of the reminder is passed as
a <br>
single argument. Note that this option overrides the -r
option and the RUN OFF command.</p>

<p style="margin-top: 1em">As an example, suppose you have
an X Window program called xmessage that pops up a window
and displays its invocation arguments. You could use:</p>

<p style="margin-top: 1em">remind &rsquo;-kxmessage %s
&amp;&rsquo; ...</p>

<p style="margin-top: 1em">to have all of your MSG-type
reminders processed using xmessage.</p>

<p style="margin-top: 1em">A word of warning: It is very
easy to spawn dozens of xmessage processes with the above
technique. So be very careful. Because all shell and
whitespace characters are <br>
escaped, the program you execute with the -k option must be
prepared to handle the entire message as a single
argument.</p>

<p style="margin-top: 1em">-z[n] Runs Remind in the daemon
mode. If n <br>
is supplied, it specifies how often (in minutes) Remind
should wake up to check if the reminder script has been
changed. N defaults to 1, and can range from 1 to 60. <br>
Note that the use of the -z option also enables the -f
option.</p>

<p style="margin-top: 1em">If you supply the option -z0,
Remind runs in a special mode called server mode. This is
documented in the tkremind man page; see tkremind(1).</p>

<p style="margin-top: 1em">-uname Runs Remind with the uid
and gid of the user specified by name. The option changes
the uid and gid as described, and sets the environment
variables HOME, SHELL and USER <br>
to the home directory, shell, and user name, respectively,
of the specified user. LOGNAME is also set to the specified
user name. This option is meant for use in shell <br>
scripts that mail reminders to all users. Note that as of
Remind 3.00.17, using -u implies -r -- the RUN directive and
shell() functions are disabled.</p>

<p style="margin-top: 1em">Non-root users can also use the
-u option. However, in this case, it only changes the
environment variables as described above. It does not change
the effective uid or <br>
gid.</p>

<p style="margin-top: 1em">-y Causes Remind to synthesize a
tag for any reminder that lacks a TAG clause.</p>

<p style="margin-top: 1em">-ivar=expr <br>
Sets the value of the specified var to expr, and preserves
var. Expr can be any valid Remind expression. See the
section &quot;Initializing Variables on the Command
Line&quot; for <br>
more details.</p>

<p style="margin-top: 1em">-ifunc(args)=definition <br>
Allows you to define a function on the command line.</p>

<p style="margin-top: 1em">If you supply a date on the
command line, it must consist of day month year, where day
is the day of the month, month is at least the first three
letters of the English name of <br>
the month, and year is a year (all 4 digits) from 1990 to
about 2075. You can leave out the day, which then defaults
to 1.</p>

<p style="margin-top: 1em">If you do supply a date on the
command line, then Remind uses it, rather than the actual
system date, as its notion of &quot;today.&quot; This lets
you create calendars for future months, <br>
or test to see how your reminders will be triggered in the
future. Similarly, you can supply a time (in 24-hour format
-- for example, 17:15) to set Remind&rsquo;s notion of
&quot;now&quot; to <br>
a particular time. Supplying a time on the command line also
implicitly enables the -q option and disables the -z
option.</p>

<p style="margin-top: 1em">If you would rather specify the
date more succinctly, you can supply it as YYYY-MM-DD or
YYYY/MM/DD. You can even supply a date and time on the
command line as one argument: <br>
YYYY-MM-DD@HH:MM.</p>

<p style="margin-top: 1em">In addition, you can supply a
repeat parameter, which has the form *num. This causes
Remind to be run num times, with the date incrementing on
each iteration. You may have to <br>
enclose the parameter in quotes to avoid shell expansion.
See the subsection &quot;Repeated Execution&quot; in the
section &quot;Calendar Mode&quot; for more information.</p>

<p style="margin-top: 1em">REMINDER FILES <br>
Remind uses scripts to control its operation. You can use
any text editor capable of creating plain ASCII files to
create a Remind script. The commands inside a script can
<br>
range from the very simple and almost immediately
understandable:</p>

<p style="margin-top: 1em">REM 6 Jan MSG Dianne&rsquo;s
birthday</p>

<p style="margin-top: 1em">to the baroque and obscure:</p>

<p style="margin-top: 1em">REM [date(thisyear, 1, 1) + 180]
++5 OMIT sat sun BEFORE MSG [ord(thisyear-1980)] payment due
%b!</p>

<p style="margin-top: 1em">A reminder file consists of
commands, with one command per line. Several lines can be
continued using the backslash character, as in the above
example. In this case, all of the <br>
concatenated lines are treated as a single line by Remind.
Note that if an error occurs, Remind reports the line number
of the last line of a continued line.</p>

<p style="margin-top: 1em">Remind ignores blank lines, and
lines beginning with the &rsquo;#&rsquo; or &rsquo;;&rsquo;
characters. You can use the semicolon as a comment character
if you wish to pass a Remind script through the <br>
C pre-processor, which interprets the &rsquo;#&rsquo;
character as the start of a pre-processing directive.</p>

<p style="margin-top: 1em">Note that Remind processes line
continuations before anything else. For example:</p>

<p style="margin-top: 1em"># This is a comment This line is
part of the comment because of line continuation and so on.
<br>
REM MSG This line is not ignored (no &nbsp;above)</p>

<p style="margin-top: 1em">Remind is not case sensitive;
you can generally use any mixture of upper- or lower-case
for commands, parameters, invocation options, etc.</p>

<p style="margin-top: 1em">THE REM COMMAND <br>
The most powerful command in a Remind script is the REM
command. This command is responsible for issuing reminders.
Its syntax is:</p>

<p style="margin-top: 1em">REM [ONCE] [date_spec] [back]
[delta] [repeat] [PRIORITY prio] [SKIP | BEFORE | AFTER]
[OMIT omit_list] [OMITFUNC omit_function] [AT time [tdelta]
[trepeat]] [SCHED <br>
sched_function] [WARN warn_function] [UNTIL expiry_date |
THROUGH last_date] [SCANFROM scan_date | FROM start_date]
[DURATION duration] [TAG tag] &lt;MSG | MSF | RUN | CAL |
<br>
SATISFY | SPECIAL special | PS | PSFILE&gt; body</p>

<p style="margin-top: 1em">The parts of the REM command can
be specified in any order, except that the body must come
immediately after the MSG, RUN, CAL, PS, PSFILE or SATISFY
keyword.</p>

<p style="margin-top: 1em">The REM token is optional,
providing that the remainder of the command cannot be
mistaken for another Remind command such as OMIT or RUN. The
portion of the REM command before <br>
the MSG, MSF RUN, CAL or SATISFY clause is called a
trigger.</p>

<p style="margin-top: 1em">MSG, MSF, RUN, CAL, SPECIAL, PS
and PSFILE</p>

<p style="margin-top: 1em">These keywords denote the type
of the reminder. (SATISFY is more complicated and will be
explained later.) A MSG-type reminder normally prints a
message to the standard output, <br>
after passing the body through a special substitution
filter, described in the section &quot;The Substitution
Filter.&quot; However, if you have used the -k command-line
option, then MSG- <br>
type reminders are passed to the appropriate program. Note
that the options -c, -s, -p and -n disable the -k
option.</p>

<p style="margin-top: 1em">Note that you can omit the
reminder type, in which case it defaults to MSG. So you can
write:</p>

<p style="margin-top: 1em">6 January Dianne&rsquo;s
Birthday</p>

<p style="margin-top: 1em">although this is not
recommended.</p>

<p style="margin-top: 1em">The MSF keyword is almost the
same as the MSG keyword, except that the reminder is
formatted to fit into a paragraph-like format. Three system
variables control the formatting <br>
of MSF-type reminders - they are $FirstIndent, $SubsIndent
and $FormWidth. They are discussed in the section
&quot;System Variables.&quot; The MSF keyword causes the
spacing of your <br>
reminder to be altered - extra spaces are discarded, and two
spaces are placed after periods and other characters, as
specified by the system variables $EndSent and $EndSentIg.
<br>
Note that if the body of the reminder includes newline
characters (placed there with the %_ sequence), then the
newlines are treated as the beginnings of new paragraphs,
and the <br>
$FirstIndent indentation is used for the next line. You can
use two consecutive newlines to have spaced paragraphs
emitted from a single reminder body.</p>

<p style="margin-top: 1em">A RUN-type reminder also passes
the body through the substitution filter, but then executes
the result as a system command. A CAL-type reminder is used
only to place entries in <br>
the calendar produced when Remind is run with the -c, -s or
-p options.</p>

<p style="margin-top: 1em">A PS or PSFILE-type reminder is
used to pass PostScript code directly to the printer when
producing PostScript calendars. This can be used to shade
certain calendar entries (see <br>
the psshade() function), include graphics in the calendar,
or almost any other purpose you can think of. You should not
use these types of reminders unless you are an expert <br>
PostScript programmer. The PS and PSFILE reminders are
ignored unless Remind is run with the -p option. See the
section &quot;More about PostScript&quot; for more
details.</p>

<p style="margin-top: 1em">A SPECIAL-type reminder is used
to pass &quot;out-of-band&quot; information from Remind to a
calendar-producing back-end. It should be followed by a word
indicating the type of special <br>
data being passed. The type of a special reminder depends on
the back-end. For the Rem2PS back-end, SPECIAL PostScript is
equivalent to a PS-type reminder, and SPECIAL PSFile <br>
is equivalent to a PSFILE-type reminder. The body of a
SPECIAL reminder is obviously dependent upon the
back-end.</p>

<p style="margin-top: 1em">DATE SPECIFICATIONS</p>

<p style="margin-top: 1em">A date_spec consists of zero to
four parts. These parts are day (day of month), month (month
name), year and weekday. Month and weekday are the English
names of months and <br>
weekdays. At least the first three characters must be used.
The following are examples of the various parts of a
date_spec:</p>

<p style="margin-top: 1em">day: 1, 22, 31, 14, 3</p>

<p style="margin-top: 1em">month: JANUARY, feb, March, ApR,
may, Aug</p>

<p style="margin-top: 1em">year: 1990, 1993, 2030, 95
(interpreted as 1995). The year can range from 1990 to
2075.</p>

<p style="margin-top: 1em">weekday: <br>
Monday, tue, Wed, THU, Friday, saturday, sundAy</p>

<p style="margin-top: 1em">Note that there can be several
weekday components separated by spaces in a date_spec.</p>

<p style="margin-top: 1em">INTERPRETATION OF DATE
SPECIFICATIONS</p>

<p style="margin-top: 1em">The following examples show how
date specifications are interpreted.</p>

<p style="margin-top: 1em">1. Null date specification - the
reminder is triggered every day. The trigger date for a
specific run is simply the current system date.</p>

<p style="margin-top: 1em">2. Only day present. The
reminder is triggered on the specified day of each month.
The trigger date for a particular run is the closest such
day to the current system date. <br>
For example: <br>
REM 1 MSG First of every month. <br>
REM 31 MSG 31st of every month that has 31 days.</p>

<p style="margin-top: 1em">3. Only month present. The
reminder is triggered every day of the specified month.
Example: <br>
REM Feb MSG Every day in February</p>

<p style="margin-top: 1em">4. day and month present.
Examples: <br>
REM 6 Jan MSG Every 6th of January <br>
REM Feb 29 MSG Every 29th of February</p>

<p style="margin-top: 1em">5. Only year present. Example:
<br>
REM 1991 MSG Every day in 1991</p>

<p style="margin-top: 1em">6. year and day present.
Examples: <br>
REM 1 1990 MSG 1st of every month in 1990 <br>
REM 1992 23 MSG 23rd of every month in 1992</p>

<p style="margin-top: 1em">7. year and month present.
Examples: <br>
REM Feb 1991 MSG Every day in Feb 1991 <br>
REM 1992 September MSG Every day in Sept 1992</p>

<p style="margin-top: 1em">8. year, month and day present.
Examples: <br>
REM 8 Jan 1991 MSG 8th January 1991. <br>
REM 1992 March 9 MSG 9th March 1992.</p>

<p style="margin-top: 1em">9. weekday only. Examples: <br>
REM Sat MSG Every Saturday <br>
REM Mon Tue Wed Thu Fri MSG Every working day <br>
REM Monday Wednesday MSG Every Monday and Wednesday</p>

<p style="margin-top: 1em">10. weekday and day present.
Examples: <br>
REM Sat 1 MSG First Saturday of every month <br>
REM Mon Tue Wed Thu Fri 15 MSG 1st working day after 15th of
every month</p>

<p style="margin-top: 1em">11. weekday and month present.
Examples: <br>
REM Mon March MSG Every Monday in March <br>
REM Mon Tue Wed Thu Fri Feb MSG Every working day in
February</p>

<p style="margin-top: 1em">12. weekday, month and day
present. Examples: <br>
REM Mon 1 March MSG First Monday in March <br>
REM Sat Sun 15 July MSG First Sat or Sun on or after 15
July</p>

<p style="margin-top: 1em">13. weekday and year present.
Example: <br>
REM Sat Sun 1991 MSG Every Saturday and Sunday in 1991</p>

<p style="margin-top: 1em">14. weekday, day and year
present. Examples: <br>
REM Mon 15 1990 MSG 1st Mon after 15th of every month in
1990 <br>
REM Mon Tue Wed Thu Fri 1 1990 MSG 1st working day of every
month in 1990</p>

<p style="margin-top: 1em">15. weekday, month and year
present. Example: <br>
REM Mon Wed 1991 Feb MSG Every Mon and Wed in Feb 1991.</p>

<p style="margin-top: 1em">16. weekday, day, month and year
present. Example: <br>
REM Mon Tue Wed Thu Fri 28 Oct 1990 MSG 1st working day on
or after 28 October 1990.</p>

<p style="margin-top: 1em">Note that when both weekday and
day are specified, Remind chooses the first date on or after
the specified day that also satisfies the weekday
constraint. It does this by pick&acirc; <br>
ing the first date on or after the specified day that is
listed in the list of weekdays. Thus, a reminder like:</p>

<p style="margin-top: 1em">REM Mon Tue 28 Oct 1990 MSG
Hi</p>

<p style="margin-top: 1em">would be issued only on Monday,
29 October, 1990. It would not be issued on Tuesday, 30
October, 1990, since the 29th is the first date to satisfy
the weekday constraints.</p>

<p style="margin-top: 1em">SHORT-HAND DATE
SPECIFICATIONS</p>

<p style="margin-top: 1em">In addition to spelling out the
day, month and year separately, you can specify YYYY-MM-DD
or YYYY/MM/DD. For example, the following statements are
equivalent:</p>

<p style="margin-top: 1em">REM 5 June 2010 MSG Cool! <br>
REM 2010-06-05 MSG Cool!</p>

<p style="margin-top: 1em">You can also specify a date and
time as YYYY-MM-DD@HH:MM. These statements are
equivalent:</p>

<p style="margin-top: 1em">REM 19 Dec 2010 AT 16:45 MSG Hi
<br>
REM 2010-12-19@16:45 MSG Hi</p>

<p style="margin-top: 1em">There&rsquo;s one subtlety with
short-hand date specifications: The following statements are
not equivalent:</p>

<p style="margin-top: 1em">REM 19 Dec 2010 AT 16:45 +60 MSG
Hi <br>
REM 2010-12-19@16:45 +60 MSG Hi</p>

<p style="margin-top: 1em">In the second statement, the
&quot;+60&quot; is a delta that applies to the date rather
than a tdelta that applies to the time. We recommend
explicitly using the AT keyword with timed <br>
reminders.</p>

<p style="margin-top: 1em">THE REMIND ALGORITHM</p>

<p style="margin-top: 1em">Remind uses the following
algorithm to compute a trigger date: Starting from the
current date, it examines each day, one at a time, until it
finds a date that satisfies the date <br>
specification, or proves to itself that no such date exists.
(Actually, Remind merely behaves as if it used this
algorithm; it would be much too slow in practice.
Internally, <br>
Remind uses much faster techniques to calculate a trigger
date.) See DETAILS ABOUT TRIGGER COMPUTATION for more
information.</p>

<p style="margin-top: 1em">BACKWARD SCANNING</p>

<p style="margin-top: 1em">Sometimes, it is necessary to
specify a date as being a set amount of time before another
date. For example, the last Monday in a given month is
computed as the first Monday in <br>
the next month, minus 7 days. The back specification in the
reminder is used in this case:</p>

<p style="margin-top: 1em">REM Mon 1 -7 MSG Last Monday of
every month.</p>

<p style="margin-top: 1em">A back is specified with one or
two dashes followed by an integer. This causes Remind to
move &quot;backwards&quot; from what would normally be the
trigger date. The difference between <br>
--7 and -7 will be explained when the OMIT keyword is
described.</p>

<p style="margin-top: 1em">ADVANCE WARNING</p>

<p style="margin-top: 1em">For some reminders, it is
appropriate to receive advance warning of the event. For
example, you may wish to be reminded of someone&rsquo;s
birthday several days in advance. The delta <br>
portion of the REM command achieves this. It is specified as
one or two &quot;+&quot; signs followed by a number n.
Again, the difference between the &quot;+&quot; and
&quot;++&quot; forms will be explained <br>
under the OMIT keyword. Remind will trigger the reminder on
computed trigger date, as well as on each of the n days
before the event. Here are some examples:</p>

<p style="margin-top: 1em">REM 6 Jan +5 MSG Remind me of
birthday 5 days in advance.</p>

<p style="margin-top: 1em">The above example would be
triggered every 6th of January, as well as the 1st through
5th of January.</p>

<p style="margin-top: 1em">PERIODIC REMINDERS</p>

<p style="margin-top: 1em">We have already seen some
built-in mechanisms for certain types of periodic reminders.
For example, an event occurring every Wednesday could be
specified as:</p>

<p style="margin-top: 1em">REM Wed MSG Event!</p>

<p style="margin-top: 1em">However, events that do not
repeat daily, weekly, monthly or yearly require another
approach. The repeat component of the REM command fills this
need. To use it, you must com&acirc; <br>
pletely specify a date (year, month and day, and optionally
weekday.) The repeat component is an asterisk followed by a
number specifying the repetition period in days.</p>

<p style="margin-top: 1em">For example, suppose you get
paid every second Wednesday, and your last payday was
Wednesday, 28 October, 1992. You can use:</p>

<p style="margin-top: 1em">REM 28 Oct 1992 *14 MSG
Payday</p>

<p style="margin-top: 1em">This issues the reminder every
14 days, starting from the calculated trigger date. You can
use delta and back with repeat. Note, however, that the back
is used only to compute <br>
the initial trigger date; thereafter, the reminder repeats
with the specified period. Similarly, if you specify a
weekday, it is used only to calculate the initial date, and
<br>
does not affect the repetition period.</p>

<p style="margin-top: 1em">SCANFROM and FROM</p>

<p style="margin-top: 1em">The SCANFROM and FROM keywords
are for advanced Remind programmers only, and will be
explained in the section &quot;Details about Trigger
Computation&quot; near the end of this manual. <br>
Note that SCANFROM is available only in versions of Remind
from 03.00.04 up. FROM is available only from 03.01.00 and
later.</p>

<p style="margin-top: 1em">PRIORITY</p>

<p style="margin-top: 1em">The PRIORITY keyword must be
followed by a number from 0 to 9999. It is used in calendar
mode and when sorting reminders. If two reminders have the
same trigger date and time, <br>
then they are sorted by priority. If the PRIORITY keyword is
not supplied, a default priority of 5000 is used. (This
default can be changed by adjusting the system variable <br>
$DefaultPrio. See the section &quot;System Variables&quot;
for more information.)</p>

<p style="margin-top: 1em">EXPIRY DATES</p>

<p style="margin-top: 1em">Some reminders should be issued
periodically for a certain time, but then expire. For
example, suppose you have a class every Friday, and that
your last class is on 11 December <br>
1992. You can use:</p>

<p style="margin-top: 1em">REM Fri UNTIL 11 Dec 1992 MSG
Class today.</p>

<p style="margin-top: 1em">Another example: Suppose you
have jury duty from 30 November 1992 until 4 December 1992.
The following reminder will issue the message every day of
your jury duty, as well as 2 <br>
days ahead of time:</p>

<p style="margin-top: 1em">REM 1992-11-30 *1 +2 UNTIL
1992-12-04 MSG Jury duty</p>

<p style="margin-top: 1em">Note that the repeat of *1 is
necessary; without it, the reminder would be issued only on
30 November (and the two days preceding.)</p>

<p style="margin-top: 1em">As a special case, you can use
the THROUGH keyword instead of *1 and UNTIL. The following
two REM commands are equivalent:</p>

<p style="margin-top: 1em">REM 1992-11-30 *1 +2 UNTIL
1992-12-04 MSG Jury duty</p>

<p style="margin-top: 1em">REM 1992-11-30 +2 THROUGH
1992-12-04 MSG Jury duty</p>

<p style="margin-top: 1em">THE ONCE KEYWORD</p>

<p style="margin-top: 1em">Sometimes, it is necessary to
ensure that reminders are run only once on a given day. For
example, if you have a reminder that makes a backup of your
files every Friday:</p>

<p style="margin-top: 1em">REM Fri RUN do_backup</p>

<p style="margin-top: 1em">(Here, do_backup is assumed to
be a program or shell script that does the work.) If you run
Remind from your .login script, for example, and log in
several times per day, the <br>
do_backup program will be run each time you log in. If,
however, you use the ONCE keyword in the reminder, the
Remind checks the last access date of the reminder script.
If it <br>
is the same as the current date, Remind assumes that it has
already been run, and will not issue reminders containing
the ONCE keyword.</p>

<p style="margin-top: 1em">Note that if you view or edit
your reminder script, the last access date will be updated,
and the ONCE keyword will not operate properly. If you start
Remind with the -o option, <br>
then the ONCE keyword will be ignored.</p>

<p style="margin-top: 1em">LOCALLY OMITTING WEEKDAYS</p>

<p style="margin-top: 1em">The OMIT portion of the REM
command is used to &quot;omit&quot; certain days when
counting the delta or back. It is specified using the
keyword OMIT followed by a list of weekdays. Its <br>
action is best illustrated with examples:</p>

<p style="margin-top: 1em">REM 1 +1 OMIT Sat Sun MSG
Important Event</p>

<p style="margin-top: 1em">This reminder is normally
triggered on the first of every month, as well as the day
preceding it. However, if the first of the month falls on a
Sunday or Monday, then the <br>
reminder is triggered starting from the previous Friday.
This is because the delta of +1 does not count Saturday or
Sunday when it counts backwards from the trigger date to
<br>
determine how much advance warning to give.</p>

<p style="margin-top: 1em">Contrast this with the use of
&quot;++1&quot; in the above command. In this case, the
reminder is triggered on the first of each month, as well as
the day preceding it. The omitted days <br>
are counted.</p>

<p style="margin-top: 1em">REM 1 -1 OMIT Sat Sun MSG Last
working day of month</p>

<p style="margin-top: 1em">Again, in the above example, the
back of -1 normally causes the trigger date to be the last
day of the month. However, because of the OMIT clause, if
the first of the month <br>
falls on a Sunday or Monday, the trigger date is moved
backwards past the weekend to Friday. (If you have globally
omitted holidays, the reminder will be moved back past them,
<br>
also. See &quot;The OMIT command&quot; for more
details.)</p>

<p style="margin-top: 1em">By comparison, if we had used
&quot;--1&quot;, the reminder would be triggered on the last
day of the month, regardless of the OMIT.</p>

<p style="margin-top: 1em">COMPUTED LOCAL OMITS</p>

<p style="margin-top: 1em">The OMITFUNC phrase of the REM
command allows you to supply a function that determines
whether or not a date is omitted. The function is passed a
single parameter of type DATE, <br>
and must return a non-zero integer if the date is considered
&quot;omitted&quot; and 0 otherwise. Here&rsquo;s an
example:</p>

<p style="margin-top: 1em">FSET _third(x) (day(x) % 3) ||
(wkdaynum(x) == 0) || (wkdaynum(x) == 6) <br>
REM OMITFUNC _third AFTER MSG Working day divisible by 3</p>

<p style="margin-top: 1em">In the example above, the
reminder is triggered every Monday to Friday whose
day-of-month number is divisible by three. Here&rsquo;s how
it works:</p>

<p style="margin-top: 1em">o The OMITFUNC _third portion
causes all days for which _third(x) returns non-zero to be
considered &quot;omitted&quot;. This causes all days whose
day-of-month number is not a mul&acirc; <br>
tiple of three to be omitted. Note that _third also returns
non-zero if the weekday is Sunday or Saturday.</p>

<p style="margin-top: 1em">o The AFTER keyword causes the
reminder to be moved after a block of omitted days.</p>

<p style="margin-top: 1em">The combination of OMITFUNC and
AFTER keyword causes the reminder to be issued on all days
whose day-of-month number is divisible by three, but not on
Saturday or Sunday.</p>

<p style="margin-top: 1em">Note that if you use OMITFUNC,
then a local OMIT is ignored as are all global OMITs. If you
want to omit specific weekdays, your omit function will need
to test for them specif&acirc; <br>
ically. If you want to take into account the global OMIT
context, then your omit function will need to test for that
explicitly (using the isomitted() function.)</p>

<p style="margin-top: 1em">Note that an incorrect OMITFUNC
might cause all days to be considered omitted. For that
reason, when Remind searches through omitted days, it
terminates the search after the <br>
SATISFY iteration limit (command-line option -x.)</p>

<p style="margin-top: 1em">TIMED REMINDERS</p>

<p style="margin-top: 1em">Timed reminders are those that
have an AT keyword followed by a time and optional tdelta
and trepeat. The time must be specified in 24-hour format,
with 0:00 representing mid&acirc; <br>
night, 12:00 representing noon, and 23:59 representing one
minute to midnight. You can use either a colon or a period
to separate the hours from the minutes. That is, 13:39 and
<br>
13.39 are equivalent.</p>

<p style="margin-top: 1em">Remind treats timed reminders
specially. If the trigger date for a timed reminder is the
same as the current system date, the reminder is queued for
later activation. When <br>
Remind has finished processing the reminder file, it puts
itself in the background, and activates timed reminders when
the system time reached the specified time.</p>

<p style="margin-top: 1em">If the trigger date is not the
same as the system date, the reminder is not queued.</p>

<p style="margin-top: 1em">For example, the following
reminder, triggered every working day, will emit a message
telling you to leave at 5:00pm:</p>

<p style="margin-top: 1em">REM Mon Tue Wed Thu Fri AT 17:00
MSG Time to leave!</p>

<p style="margin-top: 1em">The following reminder will be
triggered on Thursdays and Fridays, but will only be queued
on Fridays:</p>

<p style="margin-top: 1em">REM Fri ++1 AT 13:00 MSG Lunch
at 1pm Friday.</p>

<p style="margin-top: 1em">The tdelta and trepeat have the
same form as a repeat and delta, but are specified in
minutes. For example, this reminder will be triggered at
12:00pm as well as 45 minutes <br>
before:</p>

<p style="margin-top: 1em">REM AT 12:00 +45 MSG Example</p>

<p style="margin-top: 1em">The following will be issued
starting at 10:45, every half hour until 11:45, and again at
noon.</p>

<p style="margin-top: 1em">REM AT 12:00 +75 *30 MSG
Example2</p>

<p style="margin-top: 1em">The &quot;+75&quot; means that
the reminder is issued starting 75 minutes before noon; in
other words, at 10:45. The *30 specifies that the reminder
is subsequently to be issued every 30 <br>
minutes. Note that the reminder is always issued at the
specified time, even if the tdelta is not a multiple of the
trepeat. So the above example is issued at 10:45am, 11:15am,
<br>
11:45am, and 12:00pm. Note that in the time specification,
there is no distinction between the &quot;+&quot; and
&quot;++&quot; forms of tdelta.</p>

<p style="margin-top: 1em">Normally, Remind will issue
timed reminders as it processes the reminder script, as well
as queuing them for later. If you do not want Remind to
issue the reminders when pro&acirc; <br>
cessing the script, but only to queue them for later, use
the -a command-line option. If you do not want reminders to
be queued for later, use the -q command-line option.</p>

<p style="margin-top: 1em">Normally, Remind forks a
background process to handle queued reminders. If you want
Remind to remain in the foreground, use the -f command-line
option. This is useful, for <br>
example, in .xinitrc scripts, where you can use the
command:</p>

<p style="margin-top: 1em">remind -fa myreminders &amp;</p>

<p style="margin-top: 1em">This ensures that when you exit
X-Windows, the Remind process is killed.</p>

<p style="margin-top: 1em">WARNING ABOUT TIMED
REMINDERS</p>

<p style="margin-top: 1em">Note: If you use user-defined
functions or variables (described later) in the bodies of
timed reminders, then when the timed reminders are
activated, the variables and functions <br>
have the definitions that were in effect at the end of the
reminder script. These definitions may not necessarily be
those that were in effect at the time the reminder was <br>
queued.</p>

<p style="margin-top: 1em">THE SCHED AND WARN KEYWORDS</p>

<p style="margin-top: 1em">The SCHED keyword allows more
precise control over the triggering of timed reminders, and
the WARN keyword allows precise control over the advance
triggering of all types of <br>
reminders. However, discussion must be deferred until after
expressions and user-defined functions are explained. See
the subsection &quot;Precise Scheduling&quot; further
on.</p>

<p style="margin-top: 1em">TAG AND DURATION</p>

<p style="margin-top: 1em">The TAG keyword lets you
&quot;tag&quot; certain reminders. This facility is used by
certain back-ends or systems built around Remind, such as
TkRemind. These back-ends have specific <br>
rules about tags; see their documentation for details.</p>

<p style="margin-top: 1em">The TAG keyword is followed by a
tag consisting of up to 48 characters. You can have as many
TAG clauses as you like in a given REM statement.</p>

<p style="margin-top: 1em">If you supply the -y option to
Remind, then any reminder that lacks a TAG will have one
synthesized. The synthesized tag consists of the characters
&quot;__syn__&quot; followed by the <br>
hexadecimal representation of the MD5 sum of the REM command
line. This lets you give a more-or-less unique identifier to
each distinct REM command.</p>

<p style="margin-top: 1em">The DURATION keyword makes sense
only for timed reminders; it specifies the duration of an
event. Currently, this is not used, but it may be used in
future by back-ends or <br>
scheduling systems built around Remind. For example, if you
have a 90-minute meeting starting at 1:00pm, you could
use:</p>

<p style="margin-top: 1em">REM 5 March 1999 AT 13:00
DURATION 1:30 MSG Meeting</p>

<p style="margin-top: 1em">Note that duration is specified
in hours and minutes.</p>

<p style="margin-top: 1em">THE SUBSTITUTION FILTER <br>
Before being processed, the body of a REM command is passed
through a substitution filter. The filter scans for
sequences &quot;%x&quot; (where &quot;x&quot; is any letter
and certain other charac&acirc; <br>
ters) and performs substitutions as shown below. (All dates
refer to the trigger date of the reminder.)</p>

<p style="margin-top: 1em">%a is replaced with &quot;on
weekday, day month, year&quot; <br>
For example, consider the reminder:</p>

<p style="margin-top: 1em">REM 18 Oct 1990 +4 MSG Meeting
with Bob %a.</p>

<p style="margin-top: 1em">On 16 October 1990, it would
print &quot;Meeting with Bob on Thursday, 18 October,
1990.&quot;</p>

<p style="margin-top: 1em">On 17 October 1990, it would
print &quot;Meeting with Bob tomorrow.&quot;</p>

<p style="margin-top: 1em">On 18 October 1990, it would
print &quot;Meeting with Bob today.&quot;</p>

<p style="margin-top: 1em">%b is replaced with &quot;in
diff day&rsquo;s time&quot; where diff is the actual number
of days between the current date and the trigger date.
(OMITs have no effect.) <br>
For example, consider:</p>

<p style="margin-top: 1em">REM 18 Oct 1990 +4 MSG Meeting
with Bob %b.</p>

<p style="margin-top: 1em">On 16 October 1990, it would
print &quot;Meeting with Bob in 2 days&rsquo;
time.&quot;</p>

<p style="margin-top: 1em">On 17 October 1990, it would
print &quot;Meeting with Bob tomorrow.&quot;</p>

<p style="margin-top: 1em">On 18 October 1990, it would
print &quot;Meeting with Bob today.&quot;</p>

<p style="margin-top: 1em">%c is replaced with &quot;on
weekday&quot; <br>
Example: REM 18 Oct 1990 +4 MSG Meeting with Bob %c.</p>

<p style="margin-top: 1em">On 16 October 1990, it would
print &quot;Meeting with Bob on Thursday.&quot;</p>

<p style="margin-top: 1em">On 17 October 1990, it would
print &quot;Meeting with Bob tomorrow.&quot;</p>

<p style="margin-top: 1em">On 18 October 1990, it would
print &quot;Meeting with Bob today.&quot;</p>

<p style="margin-top: 1em">%d is replaced with
&quot;day&quot;, the day of the month.</p>

<p style="margin-top: 1em">%e is replaced with &quot;on
dd-mm-yyyy&quot;</p>

<p style="margin-top: 1em">%f is replaced with &quot;on
mm-dd-yyyy&quot;</p>

<p style="margin-top: 1em">%g is replaced with &quot;on
weekday, day month&quot;</p>

<p style="margin-top: 1em">%h is replaced with &quot;on
dd-mm&quot;</p>

<p style="margin-top: 1em">%i is replaced with &quot;on
mm-dd&quot;</p>

<p style="margin-top: 1em">%j is replaced with &quot;on
weekday, month day-th, year&quot; This form appends the
characters &quot;st&quot;, &quot;nd&quot;, &quot;rd&quot; or
&quot;th&quot; to the day of the month, as appropriate.</p>

<p style="margin-top: 1em">%k is replaced with &quot;on
weekday, month day-th&quot;</p>

<p style="margin-top: 1em">%l is replaced with &quot;on
yyyy-mm-dd&quot;</p>

<p style="margin-top: 1em">%m is replaced with
&quot;month&quot;, the name of the month.</p>

<p style="margin-top: 1em">%n is replaced with the number
(1 to 12) of the month.</p>

<p style="margin-top: 1em">%o is replaced with &quot;
(today)&quot; if and only if the current system date is the
same as the date being used by Remind as the current date.
Recall that you can specify a date <br>
for Remind to use on the command line. This substitution is
not generally useful in a REM command, but is useful in a
BANNER command. (See &quot;The BANNER Command.&quot;)</p>

<p style="margin-top: 1em">%p is replaced with
&quot;s&quot; if the diff between the current date and the
trigger date is not 1. You can use this to construct
reminders like: <br>
REM 1 Jan +4 MSG %x day%p to go before New Year!</p>

<p style="margin-top: 1em">%q is replaced with
&quot;&rsquo;s&quot; if the diff between the trigger date
and the current date is 1. Otherwise, it is replaced with
&quot;s&rsquo;&quot; This can be used as follows: <br>
REM 1 Jan +4 MSG New Year in %x day%q time!</p>

<p style="margin-top: 1em">%r is replaced with the day of
the month (01 to 31) padded with a leading zero if needed to
pad to two digits.</p>

<p style="margin-top: 1em">%s is replaced with
&quot;st&quot;, &quot;nd&quot;, &quot;rd&quot; or
&quot;th&quot; depending on the day of the month.</p>

<p style="margin-top: 1em">%t is replaced with the number
of the month (01 to 12) padded to two digits with a leading
zero.</p>

<p style="margin-top: 1em">%u is replaced with &quot;on
weekday, day-th month, year&quot; This is similar to %a
except that &quot;st&quot;, &quot;nd&quot;, &quot;rd&quot;
or &quot;th&quot; is added to the day as appropriate.</p>

<p style="margin-top: 1em">%v is replaced with &quot;on
weekday, day-th month&quot;</p>

<p style="margin-top: 1em">%w is replaced with
&quot;weekday&quot;, the name of the day of the week.</p>

<p style="margin-top: 1em">%x is replaced with the diff
between the current date and the trigger date. The diff is
defined as the actual number of days between these two
dates; OMITs are not counted. <br>
(Strict date subtraction is performed.)</p>

<p style="margin-top: 1em">%y is replaced with
&quot;year&quot;, the year of the trigger date.</p>

<p style="margin-top: 1em">%z is replaced with
&quot;yy&quot;, the last two digits of the year.</p>

<p style="margin-top: 1em">%_ (percent-underscore) is
replaced with a newline. You can use this to achieve
multi-line reminders.</p>

<p style="margin-top: 1em">%1 is replaced with
&quot;now&quot;, &quot;m minutes from now&quot;, &quot;m
minutes ago&quot;, &quot;h hours from now&quot;, &quot;h
hours ago&quot;, &quot;h hours and m minutes from now&quot;
or &quot;h hours and m minutes ago&quot;, as <br>
appropriate for a timed reminder. Note that unless you
specify the -a option, timed reminders will be triggered
like normal reminders, and thus a timed reminder that <br>
occurred earlier in the day may be triggered. This causes
the need for the &quot;...ago&quot; forms.</p>

<p style="margin-top: 1em">%2 is replaced with &quot;at
hh:mmam&quot; or &quot;..pm&quot; depending on the AT time
of the reminder.</p>

<p style="margin-top: 1em">%3 is replaced with &quot;at
hh:mm&quot; in 24-hour format.</p>

<p style="margin-top: 1em">%4 is replaced with
&quot;mm&quot; where mm is the number of minutes between
&quot;now&quot; and the time specified by AT. If the AT time
is earlier than the current time, then the result is <br>
negative.</p>

<p style="margin-top: 1em">%5 is replaced with
&quot;ma&quot; where ma is the absolute value of the number
produced by %4.</p>

<p style="margin-top: 1em">%6 is replaced with
&quot;ago&quot; or &quot;from now&quot;, depending on the
relationship between the AT time and the current time.</p>

<p style="margin-top: 1em">%7 is replaced with the number
of hours between the AT time and the current time. It is
always non-negative.</p>

<p style="margin-top: 1em">%8 is replaced with the number
of minutes between the AT time and the current time, after
the hours (%7) have been subtracted out. This is a number
ranging from 0 to 59.</p>

<p style="margin-top: 1em">%9 is replaced with
&quot;s&quot; if the value produced by %8 is not 1.</p>

<p style="margin-top: 1em">%0 is replaced with
&quot;s&quot; if the value produced by %7 is not 1.</p>

<p style="margin-top: 1em">%! is replaced with
&quot;is&quot; if the current time is before the AT time, or
&quot;was&quot; if it is after.</p>

<p style="margin-top: 1em">%@ is similar to %2 but displays
the current time.</p>

<p style="margin-top: 1em">%# is similar to %3 but displays
the current time.</p>

<p style="margin-top: 1em">%&quot; (percent-doublequote -
&quot;) is removed. This sequence is not used by the
substitution filter, but is used to tell Remind which text
to include in a calendar entry when the <br>
-c, -s or -p option is chosen. See &quot;Calendar
Mode&quot;</p>

<p style="margin-top: 1em">Notes:</p>

<p style="margin-top: 1em">o Remind normally prints a blank
line after each reminder; if the last character of the body
is &quot;%&quot;, the blank line will not be printed.</p>

<p style="margin-top: 1em">o Substitutions a, b, c, e, f,
g, h, i, j, k, l, u and v all are replaced with
&quot;today&quot; if the current date equals the trigger
date, or &quot;tomorrow&quot; if the trigger date is one
<br>
day after the current date. Thus, they are not the same as
substitutions built up from the simpler %w, %y, etc.
sequences.</p>

<p style="margin-top: 1em">o Any of the substitutions
dealing with time (0 through 9 and &rsquo;!&rsquo;) produce
undefined results if used in a reminder that does not have
an AT keyword. Also, if a reminder <br>
has a delta and may be triggered on several days, the time
substitutions ignore the date. Thus, the %1 substitution may
report that a meeting is in 15 minutes, for exam&acirc; <br>
ple, even though it may only be in 2 days time, because a
delta has triggered the reminder. It is recommended that you
use the time substitutions only in timed reminders <br>
with no delta that are designed to be queued for timed
activation.</p>

<p style="margin-top: 1em">o Capital letters can be used in
the substitution sequence, in which case the first character
of the substituted string is capitalized (if it is normally
a lower-case let&acirc; <br>
ter.)</p>

<p style="margin-top: 1em">o All other characters following
a &quot;%&quot; sign are simply copied. In particular, to
get a &quot;%&quot; sign out, use &quot;%%&quot; in the
body. To start the body of a reminder with a space, <br>
use &quot;% &quot;, since Remind normally scans for the
first non-space character after a MSG, CAL or RUN token.</p>

<p style="margin-top: 1em">THE OMIT COMMAND <br>
In addition to being a keyword in the REM command, OMIT is a
command in its own right. Its syntax is:</p>

<p style="margin-top: 1em">OMIT day month [year]</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">OMIT day1 month1 year1 THROUGH
day2 month2 year2</p>

<p style="margin-top: 1em">The OMIT command is used to
&quot;globally&quot; omit certain days (usually holidays).
These globally-omitted days are skipped by the &quot;-&quot;
and &quot;+&quot; forms of back and delta. Some
examples:</p>

<p style="margin-top: 1em">OMIT 1 Jan <br>
OMIT 7 Sep 1992</p>

<p style="margin-top: 1em">The first example specifies a
holiday that occurs on the same date each year - New
Year&rsquo;s Day. The second example specifies a holiday
that changes each year - Labour Day. For <br>
these types of holidays, you must create an OMIT command for
each year. (Later, in the description of expressions and
some of the more advanced features of Remind, you will see
<br>
how to automate this for some cases.)</p>

<p style="margin-top: 1em">As with the REM command, you can
use shorthand specifiers for dates; the following are
equivalent:</p>

<p style="margin-top: 1em">OMIT 7 Sep 1992 <br>
OMIT 1992-09-07</p>

<p style="margin-top: 1em">For convenience, you can use a
delta and MSG or RUN keyword in the OMIT command. The
following sequences are equivalent:</p>

<p style="margin-top: 1em">OMIT 1 Jan <br>
REM 1 Jan +4 MSG New year&rsquo;s day is %b!</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">OMIT 1 Jan +4 MSG New
year&rsquo;s day is %b!</p>

<p style="margin-top: 1em">The THROUGH keyword lets you
conveniently OMIT a range of days. The starting and ending
points must be fully-specified (ie, they must include day,
month and year.). For exam&acirc; <br>
ple, the following sequences are equivalent:</p>

<p style="margin-top: 1em">OMIT 3 Jan 2011 <br>
OMIT 4 Jan 2011 <br>
OMIT 5 Jan 2011</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">OMIT 3 Jan 2011 THROUGH 5 Jan
2011</p>

<p style="margin-top: 1em">You can make a THROUGH OMIT do
double-duty as a REM command:</p>

<p style="margin-top: 1em">OMIT 6 Sep 2010 THROUGH 10 Sep
2010 MSG Vacation</p>

<p style="margin-top: 1em">You can debug your global OMITs
with the following command:</p>

<p style="margin-top: 1em">OMIT DUMP</p>

<p style="margin-top: 1em">The OMIT DUMP command prints the
current global omits to standard output.</p>

<p style="margin-top: 1em">THE BEFORE, AFTER AND SKIP
KEYWORDS</p>

<p style="margin-top: 1em">Normally, days that are omitted,
whether by a global OMIT command or the local OMIT or
OMITFUNC keywords in a REM statement, only affect the
counting of the -back or the +delta. <br>
For example, suppose you have a meeting every Wednesday.
Suppose, too, that you have indicated 11 Nov as a
holiday:</p>

<p style="margin-top: 1em">OMIT 11 Nov +4 MSG Remembrance
Day <br>
REM Wed +1 MSG Code meeting %b.</p>

<p style="margin-top: 1em">The above sequence will issue a
reminder about a meeting for 11 November 1992, which is a
Wednesday. This is probably incorrect. There are three
options:</p>

<p style="margin-top: 1em">BEFORE This keyword moves the
reminder to before any omitted days. Thus, in the above
example, use of BEFORE would cause the meeting reminder to
be triggered on Tuesday, 10 No&acirc; <br>
vember 1992.</p>

<p style="margin-top: 1em">AFTER This keyword moves the
reminder to after any omitted days. In the above example,
the meeting reminder would be triggered on Thursday, 12
November 1992.</p>

<p style="margin-top: 1em">SKIP This keyword causes the
reminder to be skipped completely on any omitted days. Thus,
in the above example, the reminder would not be triggered on
11 November 1992. How&acirc; <br>
ever, it would be triggered as usual on the following
Wednesday, 18 November 1992.</p>

<p style="margin-top: 1em">The BEFORE and AFTER keywords
move the trigger date of a reminder to before or after a
block of omitted days, respectively. Suppose you normally
run a backup on the first day of <br>
the month. However, if the first day of the month is a
weekend or holiday, you run the backup on the first working
day following the weekend or holiday. You could use:</p>

<p style="margin-top: 1em">REM 1 OMIT Sat Sun AFTER RUN
do_backup</p>

<p style="margin-top: 1em">Let&rsquo;s examine how the
trigger date is computed. The 1 specifies the first day of
the month. The local OMIT keyword causes the AFTER keyword
to move the reminder forward past <br>
weekends. Finally, the AFTER keyword will keep moving the
reminder forward until it has passed any holidays specified
with global OMIT commands.</p>

<p style="margin-top: 1em">THE INCLUDE COMMAND <br>
Remind allows you to include other files in your reminder
script, similar to the C preprocessor #include directive.
For example, your system administrator may maintain a file
of <br>
holidays or system-wide reminders. You can include these in
your reminder script as follows:</p>

<p style="margin-top: 1em">INCLUDE
/usr/share/remind/holidays <br>
INCLUDE /usr/share/remind/reminders</p>

<p style="margin-top: 1em">(The actual pathnames vary from
system to system - ask your system administrator.)</p>

<p style="margin-top: 1em">INCLUDE files can be nested up
to a depth of 8.</p>

<p style="margin-top: 1em">If you specify a filename of
&quot;-&quot; in the INCLUDE command, Remind will begin
reading from standard input.</p>

<p style="margin-top: 1em">If you specify a directory as
the argument to INCLUDE, then Remind will process all files
in that directory that match the shell patterm
&quot;*.rem&quot;. The files are processed in <br>
sorted order; the sort order matches that used by the shell
when it expands &quot;*.rem&quot;.</p>

<p style="margin-top: 1em">THE RUN COMMAND <br>
If you include other files in your reminder script, you may
not always entirely trust the contents of the other files.
For example, they may contain RUN-type reminders that <br>
could be used to access your files or perform undesired
actions. The RUN command can restrict this: If you include
the command RUN OFF in your top-level reminder script, any
<br>
reminder or expression that would normally execute a system
command is disabled. RUN ON will re-enable the execution of
system commands. Note that the RUN ON command can only <br>
be used in your top-level reminder script; it will not work
in any files accessed by the INCLUDE command. This is to
protect you from someone placing a RUN ON command in an <br>
included file. However, the RUN OFF command can be used at
top level or in an included file.</p>

<p style="margin-top: 1em">If you run Remind with the -r
command-line option, RUN-type reminders and the shell()
function will be disabled, regardless of any RUN commands in
the reminder script. However, <br>
any command supplied with the -k option will still be
executed.</p>

<p style="margin-top: 1em">One use of the RUN command is to
provide a secure interface between Remind and the Elm mail
system. The Elm system can automatically scan incoming mail
for reminder or calendar <br>
entries, and place them in your calendar file. To use this
feature, you should set the calendar filename option under
Elm to be something like &quot;~/.reminders.in&quot;, not
your main <br>
reminder file! This is so that any RUN ON commands mailed to
you can never be activated.</p>

<p style="margin-top: 1em">Then, you can use the Elm scan
message for calendar entries command to place reminders
prefaced by &quot;-&gt;&quot; into .reminders.in. In your
main .reminders file, include the following <br>
lines:</p>

<p style="margin-top: 1em">RUN OFF # Disable RUN <br>
INCLUDE .reminders.in <br>
RUN ON # Re-enable RUN</p>

<p style="margin-top: 1em">In addition, Remind contains a
few other security features. It will not read a file that is
group- or world-writable. It will not run set-uid. If it
reads a file you don&rsquo;t <br>
own, it will disable RUN and the shell() function. And if it
is run as root, it will only read files owned by root.</p>

<p style="margin-top: 1em">THE BANNER COMMAND <br>
When Remind first issues a reminder, it prints a message
like this:</p>

<p style="margin-top: 1em">Reminders for Friday, 30th
October, 1992 (today):</p>

<p style="margin-top: 1em">(The banner is not printed if
any of the calendar-producing options is used, or if the -k
option is used.)</p>

<p style="margin-top: 1em">The BANNER command lets you
change the format. It should appear before any REM commands.
The format is:</p>

<p style="margin-top: 1em">BANNER format</p>

<p style="margin-top: 1em">The format is similar to the
body of a REM command. It is passed through the substitution
filter, with an implicit trigger of the current system date.
Thus, the default banner <br>
is equivalent to:</p>

<p style="margin-top: 1em">BANNER Reminders for %w, %d%s
%m, %y%o:</p>

<p style="margin-top: 1em">You can disable the banner
completely with BANNER %. Or you can create a custom
banner:</p>

<p style="margin-top: 1em">BANNER Hi - here are your
reminders for %y-%t-%r:</p>

<p style="margin-top: 1em">CONTROLLING THE OMIT CONTEXT
<br>
Sometimes, it is necessary to temporarily change the global
OMITs that are in force for a few reminders. Three commands
allow you to do this:</p>

<p style="margin-top: 1em">PUSH-OMIT-CONTEXT <br>
This command saves the current global OMITs on an internal
stack.</p>

<p style="margin-top: 1em">CLEAR-OMIT-CONTEXT <br>
This command clears all of the global OMITs, starting you
off with a &quot;clean slate.&quot;</p>

<p style="margin-top: 1em">POP-OMIT-CONTEXT <br>
This command restores the global OMITs that were saved by
the most recent PUSH-OMIT-CONTEXT.</p>

<p style="margin-top: 1em">For example, suppose you have a
block of reminders that require a clear OMIT context, and
that they also introduce unwanted global OMITs that could
interfere with later <br>
reminders. You could use the following fragment:</p>

<p style="margin-top: 1em">PUSH-OMIT-CONTEXT # Save the
current context <br>
CLEAR-OMIT-CONTEXT # Clean the slate <br>
# Block of reminders goes here <br>
POP-OMIT-CONTEXT # Restore the saved omit context</p>

<p style="margin-top: 1em">EXPRESSIONS <br>
In certain contexts, to be described later, Remind will
accept expressions for evaluation. Remind expressions
resemble C expressions, but operate on different types of
objects.</p>

<p style="margin-top: 1em">DATA TYPES</p>

<p style="margin-top: 1em">Remind expressions operate on
five types of objects:</p>

<p style="margin-top: 1em">INT The INT data type consists
of the integers representable in one machine word. The INT
data type corresponds to the C &quot;int&quot; type.</p>

<p style="margin-top: 1em">STRING The STRING data type
consists of strings of characters. It is somewhat comparable
to a C character array, but more closely resembles the
string type in BASIC.</p>

<p style="margin-top: 1em">TIME The TIME data type consists
of times of the day. The TIME data type is internally stored
as an integer representing the number of minutes since
midnight.</p>

<p style="margin-top: 1em">DATE The DATE data type consists
of dates (later than 1 January 1990.) Internally, DATE
objects are stored as the number of days since 1 January
1990.</p>

<p style="margin-top: 1em">DATETIME <br>
The DATETIME data type consists of a date and time together.
Internally, DATETIME objects are stored as the number of
minutes since midnight, 1 January 1990. You can <br>
think of a DATETIME object as being the combination of DATE
and TIME parts.</p>

<p style="margin-top: 1em">CONSTANTS</p>

<p style="margin-top: 1em">The following examples
illustrate constants in Remind expressions:</p>

<p style="margin-top: 1em">INT constants <br>
12, 36, -10, 0, 1209</p>

<p style="margin-top: 1em">STRING constants <br>
&quot;Hello there&quot;, &quot;This is a test&quot;,
&quot;0d48&quot;</p>

<p style="margin-top: 1em">Note that the empty string is
represented by &quot;&quot;, and that backslashes in a
string are not interpreted specially, as in they are in
C.</p>

<p style="margin-top: 1em">TIME constants <br>
12:33, 0:01, 14:15, 16:42, 12.16, 13.00, 1.11</p>

<p style="margin-top: 1em">Note that TIME constants are
written in 24-hour format. Either the period or colon can be
used to separate the minutes from the hours. However, Remind
will consistently <br>
output times using only one separator character. (The output
separator character is chosen at compile-time.)</p>

<p style="margin-top: 1em">DATE constants <br>
DATE constants are expressed as &rsquo;yyyy/mm/dd&rsquo; or
&rsquo;yyyy-mm-dd&rsquo;, and the single quotes must be
supplied. This distinguishes date constants from division or
subtraction of <br>
integers. Examples:</p>


<p style="margin-top: 1em">&Acirc;&acute;1993/02/22&rsquo;,
&rsquo;1992-12-25&rsquo;, &rsquo;1999/01/01&rsquo;</p>

<p style="margin-top: 1em">Note that DATE values are
printed without the quotes. Although either &rsquo;-&rsquo;
or &rsquo;/&rsquo; is accepted as a date separator on input,
when dates are printed, only one will be used. <br>
The choice of whether to use &rsquo;-&rsquo; or
&rsquo;/&rsquo; is made at compile-time. Note also that
versions of Remind prior to 03.00.01 did not support date
constants. In those versions, <br>
you must create dates using the date() function. Also,
versions prior to 03.00.02 did not support the
&rsquo;-&rsquo; date separator.</p>

<p style="margin-top: 1em">DATETIME constants <br>
DATETIME constants are expressed similarly to DATE constants
with the addition of an &quot;@HH:MM&quot; part. For
example:</p>


<p style="margin-top: 1em">&Acirc;&acute;2008-04-05@23:11&rsquo;,
&rsquo;1999/02/03@14:06&rsquo;,
&rsquo;2001-04-07@08:30&rsquo;</p>

<p style="margin-top: 1em">DATETIME values are printed
without the quotes. Notes about date and time separator
characters for DATE and TIME constants apply also to
DATETIME constants.</p>

<p style="margin-top: 1em">OPERATORS</p>

<p style="margin-top: 1em">Remind has the following
operators. Operators on the same line have equal precedence,
while operators on lower lines have lower precedence than
those on higher lines. The oper&acirc; <br>
ators approximately correspond to C operators.</p>

<p style="margin-top: 1em">! - (unary logical negation and
arithmetic negation) <br>
* / % <br>
+ - <br>
&lt; &lt;= &gt; &gt;= <br>
== != <br>
&amp;&amp; <br>
||</p>

<p style="margin-top: 1em">DESCRIPTION OF OPERATORS</p>

<p style="margin-top: 1em">! Logical negation. Can be
applied to an INT type. If the operand is non-zero, returns
zero. Otherwise, returns 1.</p>

<p style="margin-top: 1em">- Unary minus. Can be applied to
an INT. Returns the negative of the operand.</p>

<p style="margin-top: 1em">* Multiplication. Returns the
product of two INTs.</p>

<p style="margin-top: 1em">/ Integer division. Returns the
quotient of two INTs, discarding the remainder.</p>

<p style="margin-top: 1em">% Modulus. Returns the remainder
upon dividing one INT by another.</p>

<p style="margin-top: 1em">+ Has several uses. These
are:</p>

<p style="margin-top: 1em">INT + INT - returns the sum of
two INTs.</p>

<p style="margin-top: 1em">INT + TIME or TIME + INT -
returns a TIME obtained by adding INT minutes to the
original TIME.</p>

<p style="margin-top: 1em">INT + DATE or DATE + INT -
returns a DATE obtained by adding INT days to the original
DATE.</p>

<p style="margin-top: 1em">INT + DATETIME or DATETIME + INT
- returns a DATETIME obtained by adding INT minutes to the
original DATETIME.</p>

<p style="margin-top: 1em">STRING + STRING - returns a
STRING that is the concatenation of the two original
STRINGs.</p>

<p style="margin-top: 1em">STRING + anything or anything +
STRING - converts the non-STRING argument to a STRING, and
then performs concatenation. See the coerce() function.</p>

<p style="margin-top: 1em">- Has several uses. These
are:</p>

<p style="margin-top: 1em">INT - INT - returns the
difference of two INTs.</p>

<p style="margin-top: 1em">DATE - DATE - returns (as an
INT) the difference in days between two DATEs.</p>

<p style="margin-top: 1em">TIME - TIME - returns (as an
INT) the difference in minutes between two TIMEs.</p>

<p style="margin-top: 1em">DATETIME - DATETIME - returns
(as an INT) the difference in minutes between two
DATETIMEs.</p>

<p style="margin-top: 1em">DATE - INT - returns a DATE that
is INT days earlier than the original DATE.</p>

<p style="margin-top: 1em">TIME - INT - returns a TIME that
is INT minutes earlier than the original TIME.</p>

<p style="margin-top: 1em">DATETIME - INT - returns a
DATETIME that is INT minutes earlier than the original
DATETIME.</p>

<p style="margin-top: 1em">&lt;, &lt;=, &gt;, and &gt;=
<br>
These are the comparison operators. They can take operands
of any type, but both operands must be of the same type. The
comparison operators return 1 if the comparison <br>
is true, or 0 if it is false. Note that string comparison is
done following the lexical ordering of characters on your
system, and that upper and lower case are distinct <br>
for these operators.</p>

<p style="margin-top: 1em">==, != == tests for equality,
returning 1 if its operands are equal, and 0 if they are
not. != tests for inequality.</p>

<p style="margin-top: 1em">If the operands are not of the
same type, == returns 0 and != returns 1. Again, string
comparisons are case-sensitive.</p>

<p style="margin-top: 1em">&amp;&amp; This is the logical
AND operator. Both of its operands must be of type INT. It
returns 1 if both operands are non-zero, and 0
otherwise.</p>

<p style="margin-top: 1em">|| This is the logical OR
operator. Both of its operands must be of type INT. It
returns 1 if either operand is non-zero, and 0
otherwise.</p>

<p style="margin-top: 1em">NOTES</p>

<p style="margin-top: 1em">Operators of equal precedence
are always evaluated from left to right, except where
parentheses dictate otherwise. This is important, because
the enhanced &quot;+&quot; operator is not <br>
necessarily associative. For example:</p>

<p style="margin-top: 1em">1 + 2 + &quot;string&quot; + 3 +
4 yields &quot;3string34&quot; <br>
1 + (2 + &quot;string&quot;) + (3 + 4) yields
&quot;12string7&quot; <br>
12:59 + 1 + &quot;test&quot; yields &quot;13:00test&quot;
<br>
12:59 + (1 + &quot;test&quot;) yields
&quot;12:591test&quot;</p>

<p style="margin-top: 1em">The logical operators are not
so-called short-circuit operators, as they are in C. Both
operands are always evaluated. Thus, an expression such
as:</p>

<p style="margin-top: 1em">(f!=0) &amp;&amp; (100/f &lt;=
3)</p>

<p style="margin-top: 1em">will cause an error if f is
zero.</p>

<p style="margin-top: 1em">VARIABLES</p>

<p style="margin-top: 1em">Remind allows you to assign
values to variables. The SET command is used as follows:</p>

<p style="margin-top: 1em">SET var expr</p>

<p style="margin-top: 1em">Var is the name of a variable.
It must start with a letter or underscore, and consist only
of letters, digits and underscores. Only the first 12
characters of a variable name <br>
are significant. Variable names are not case sensitive;
thus, &quot;Afoo&quot; and &quot;afOo&quot; are the same
variable. Examples:</p>

<p style="margin-top: 1em">SET a 10 + (9*8) <br>
SET b &quot;This is a test&quot; <br>
SET mydir getenv(&quot;HOME&quot;) <br>
SET time 12:15 <br>
SET date today()</p>

<p style="margin-top: 1em">Note that variables themselves
have no type. They take on the type of whatever you store in
them.</p>

<p style="margin-top: 1em">To delete a variable, use the
UNSET command:</p>

<p style="margin-top: 1em">UNSET var [var...]</p>

<p style="margin-top: 1em">For example, to delete all the
variables declared above, use:</p>

<p style="margin-top: 1em">UNSET a b mydir time date</p>

<p style="margin-top: 1em">SYSTEM VARIABLES</p>

<p style="margin-top: 1em">In addition to the regular user
variables, Remind has several &quot;system variables&quot;
that are used to query or control the operating state of
Remind. System variables are available <br>
starting from version 03.00.07 of Remind.</p>

<p style="margin-top: 1em">All system variables begin with
a dollar sign &rsquo;$&rsquo;. They can be used in SET
commands and expressions just as regular variables can. All
system variables always hold values of a <br>
specified type. In addition, some system variables cannot be
modified, and you cannot create new system variables. System
variables can be initialized on the command line with <br>
the -i option, but you may need to quote them to avoid
having the shell interpret the dollar sign. System variable
names are not case-sensitive.</p>

<p style="margin-top: 1em">The following system variables
are defined. Those marked &quot;read-only&quot; cannot be
changed with the SET command. All system variables hold
values of type INT, unless otherwise <br>
specified.</p>

<p style="margin-top: 1em">$CalcUTC <br>
If 1 (the default), then Remind uses C library functions to
calculate the number of minutes between local and Universal
Time Coordinated. This affects astronomical calcu&acirc;
<br>
lations (sunrise() for example.) If 0, then you must supply
the number of minutes between local and Universal Time
Coordinated in the $MinsFromUTC system variable.</p>

<p style="margin-top: 1em">$CalMode (read-only) <br>
If non-zero, then the -c option was supplied on the command
line.</p>

<p style="margin-top: 1em">$Daemon (read-only) <br>
If the daemon mode -z was invoked, contains the number of
minutes between wakeups. If not running in daemon mode,
contains 0.</p>

<p style="margin-top: 1em">$DateSep <br>
This variable can be set only to &quot;/&quot; or
&quot;-&quot;. It holds the character used to separate
portions of a date when Remind prints a DATE or DATETIME
value.</p>

<p style="margin-top: 1em">$DefaultPrio <br>
The default priority assigned to reminders without a
PRIORITY clause. You can set this as required to adjust the
priorities of blocks of reminders without having to type
<br>
priorities for individual reminders. At startup,
$DefaultPrio is set to 5000; it can range from 0 to
9999.</p>

<p style="margin-top: 1em">$DontFork (read-only) <br>
If non-zero, then the -c option was supplied on the command
line.</p>

<p style="margin-top: 1em">$DontTrigAts (read-only) <br>
The number of times that the -a option was supplied on the
command line.</p>

<p style="margin-top: 1em">$DontQueue (read-only) <br>
If non-zero, then the -q option was supplied on the command
line.</p>

<p style="margin-top: 1em">$EndSent (STRING type) <br>
Contains a list of characters that end a sentence. The MSF
keyword inserts two spaces after these characters.
Initially, $EndSent is set to &quot;.!?&quot; (period,
exclamation <br>
mark, and question mark.)</p>

<p style="margin-top: 1em">$EndSentIg (STRING type) <br>
Contains a list of characters that should be ignored when
MSF decides whether or not to place two spaces after a
sentence. Initially, is set to
&quot;&rsquo;&gt;)]}&quot;+CHAR(34) (single- <br>
quote, greater-than, right parenthesis, right bracket, right
brace, and double-quote.)</p>

<p style="margin-top: 1em">For example, the default values
work as follows:</p>

<p style="margin-top: 1em">MSF He said, &quot;Huh! (Two
spaces will follow this.)&quot; Yup.</p>

<p style="margin-top: 1em">because the final parenthesis
and quote are ignored (for the purposes of spacing) when
they follow a period.</p>

<p style="margin-top: 1em">$FirstIndent <br>
The number of spaces by which to indent the first line of a
MSF-type reminder. The default is 0.</p>

<p style="margin-top: 1em">$FoldYear <br>
The standard Unix library functions may have difficulty
dealing with dates later than 2037. If this variable is set
to 1, then the UTC calculations &quot;fold back&quot; years
<br>
later than 2037 before using the Unix library functions. For
example, to find out whether or not daylight saving time is
in effect in June, 2077, the year is &quot;folded <br>
back&quot; to 2010, because both years begin on a Monday,
and both are non-leapyears. The rules for daylight saving
time are thus presumed to be identical for both years, and
<br>
the Unix library functions can handle 2010. By default, this
variable is 0. Set it to 1 if the sun or UTC functions
misbehave for years greater than 2037.</p>

<p style="margin-top: 1em">$FormWidth <br>
The maximum width of each line of text for formatting
MSF-type reminders. The default is 72. If an MSF-type
reminder contains a word too long to fit in this width, it
<br>
will not be truncated - the width limit will be ignored.</p>

<p style="margin-top: 1em">$HushMode (read-only) <br>
If non-zero, then the -h option was supplied on the command
line.</p>

<p style="margin-top: 1em">$IgnoreOnce (read-only) <br>
If non-zero, then the -o option was supplied on the command
line, or a date different from today&rsquo;s true date was
supplied. If non-zero, then ONCE directives will be <br>
ignored.</p>

<p style="margin-top: 1em">$InfDelta (read-only) <br>
If non-zero, then the -t option was supplied on the command
line.</p>

<p style="margin-top: 1em">$LatDeg, $LatMin, $LatSec <br>
These specify the latitude of your location. $LatDeg can
range from -90 to 90, and the others from -59 to 59.
Northern latitudes are positive; southern ones are
nega&acirc; <br>
tive. For southern latitudes, all three components should be
negative.</p>

<p style="margin-top: 1em">$Location (STRING type) <br>
This is a string specifying the name of your location. It is
usually the name of your town or city. It can be set to
whatever you like, but good style indicates that it <br>
should be kept consistent with the latitude and longitude
system variables.</p>

<p style="margin-top: 1em">$LongDeg, $LongMin, $LongSec
<br>
These specify the longitude of your location. $LongDeg can
range from -180 to 180. Western longitudes are positive;
eastern ones are negative. Note that all three com&acirc;
<br>
ponents should have the same sign: All positive for Western
longitudes and all negative for Eastern longitudes.</p>

<p style="margin-top: 1em">The latitude and longitude
information is required for the functions sunrise() and
sunset(). Default values can be compiled into Remind, or you
can SET the correct values <br>
at the start of your reminder scripts.</p>

<p style="margin-top: 1em">$MaxSatIter <br>
The maximum number of iterations for the SATISFY clause
(described later.) Must be at least 10.</p>

<p style="margin-top: 1em">$MinsFromUTC <br>
The number of minutes between Universal Time Coordinated and
local time. If $CalcUTC is non-zero, this is calculated upon
startup of Remind. Otherwise, you must set it <br>
explicitly. If $CalcUTC is zero, then $MinsFromUTC is used
in the astronomical calculations. You must adjust it for
daylight saving time yourself. Also, if you want to <br>
initialize $MinsFromUTC using the -i command-line option,
you must also set $CalcUTC to 0 with the -i option.</p>

<p style="margin-top: 1em">$NextMode (read-only) <br>
If non-zero, then the -n option was supplied on the command
line.</p>

<p style="margin-top: 1em">$NumQueued (read-only) <br>
Contains the number of reminders queued so far for
background timed triggering.</p>

<p style="margin-top: 1em">$NumTrig (read-only) <br>
Contains the number of reminders triggered for the current
date. One use for this variable is as follows: Suppose you
wish to shade in the box of a PostScript calendar <br>
whenever a holiday is triggered. You could save the value of
$NumTrig in a regular variable prior to executing a block of
holiday reminders. If the value of $NumTrig <br>
after the holiday block is greater than the saved value,
then at least one holiday was triggered, and you can execute
the command to shade in the calendar box. (See the <br>
section &quot;Calendar Mode&quot;.)</p>

<p style="margin-top: 1em">Note that $NumTrig is affected
only by REM commands; triggers in IFTRIG commands do not
affect it.</p>

<p style="margin-top: 1em">$PrefixLineNo (read-only) <br>
If non-zero, then the -l option was supplied on the command
line.</p>

<p style="margin-top: 1em">$PSCal (read-only) <br>
If non-zero, then the -p option was supplied on the command
line.</p>

<p style="margin-top: 1em">$RunOff (read-only) <br>
If non-zero, the RUN directives are disabled.</p>

<p style="margin-top: 1em">$SimpleCal (read-only) <br>
Set to a non-zero value if either of the -p or -s
command-line options was supplied.</p>

<p style="margin-top: 1em">$SortByDate (read-only) <br>
Set to 0 if no -g option is used, 1 if sorting by date in
ascending order, or 2 if sorting by date in descending
order.</p>

<p style="margin-top: 1em">$SortByPrio (read-only) <br>
Set to 0 if no -g option is used, 1 if sorting by priority
in ascending order, or 2 if sorting by priority in
descending order.</p>

<p style="margin-top: 1em">$SortByTime (read-only) <br>
Set to 0 if no -g option is used, 1 if sorting by time in
ascending order, or 2 if sorting by time in descending
order.</p>

<p style="margin-top: 1em">$SubsIndent <br>
The number of spaces by which all lines (except the first)
of an MSF-type reminder should be indented. The default is
0.</p>

<p style="margin-top: 1em">$T (read-only, DATE type) <br>
Exactly equivalent to trigdate(). (See BUILT-IN
FUNCTIONS.)</p>

<p style="margin-top: 1em">$Td (read-only) <br>
Equivalent to day(trigdate()).</p>

<p style="margin-top: 1em">$Tm (read-only) <br>
Equivalent to monnum(trigdate()).</p>

<p style="margin-top: 1em">$Tw (read-only) <br>
Equivalent to wkdaynum(trigdate()).</p>

<p style="margin-top: 1em">$Ty (read-only) <br>
Equivalent to year(trigdate()).</p>

<p style="margin-top: 1em">$TimeSep <br>
This variable can be set only to &quot;:&quot; or
&quot;.&quot;. It holds the character used to separate
portions of a time when Remind prints a TIME or DATETIME
value.</p>

<p style="margin-top: 1em">$UntimedFirst (read-only) <br>
Set to 1 if the -g option is used with a fourth sort
character of &quot;d&quot;; set to 0 otherwise.</p>

<p style="margin-top: 1em">$U (read-only, DATE type) <br>
Exactly equivalent to today(). (See BUILT-IN FUNCTIONS.)</p>

<p style="margin-top: 1em">$Ud (read-only) <br>
Equivalent to day(today()).</p>

<p style="margin-top: 1em">$Um (read-only) <br>
Equivalent to monnum(today()).</p>

<p style="margin-top: 1em">$Uw (read-only) <br>
Equivalent to wkdaynum(today()).</p>

<p style="margin-top: 1em">$Uy (read-only) <br>
Equivalent to year(today()).</p>

<p style="margin-top: 1em">Note: If any of the calendar
modes are in effect, then the values of $Daemon, $DontFork,
$DontTrigAts, $DontQueue, $HushMode, $IgnoreOnce, $InfDelta,
and $NextMode are not mean&acirc; <br>
ingful.</p>

<p style="margin-top: 1em">BUILT-IN FUNCTIONS</p>

<p style="margin-top: 1em">Remind has a plethora of
built-in functions. The syntax for a function call is the
same as in C - the function name, followed a comma-separated
list of arguments in parentheses. <br>
Function names are not case-sensitive. If a function takes
no arguments, it must be followed by &quot;()&quot; in the
function call. Otherwise, Remind will interpret it as a
variable <br>
name, and probably not work correctly.</p>

<p style="margin-top: 1em">In the descriptions below, short
forms are used to denote acceptable types for the arguments.
The characters &quot;i&quot;, &quot;s&quot;, &quot;d&quot;,
&quot;t&quot; and &quot;q&quot; denote INT, STRING, DATE,
TIME and DATE&acirc; <br>
TIME arguments, respectively. If an argument can be one of
several types, the characters are concatenated. For example,
&quot;di_arg&quot; denotes an argument that can be a DATE or
an <br>
INT. &quot;x_arg&quot; denotes an argument that can be of
any type. The type of the argument is followed by an
underscore and an identifier naming the argument.</p>

<p style="margin-top: 1em">The built-in functions are:</p>

<p style="margin-top: 1em">abs(i_num) <br>
Returns the absolute value of num.</p>

<p style="margin-top: 1em">access(s_file, si_mode) <br>
Tests the access permissions for the file file. Mode can be
a string, containing a mix of the characters &quot;rwx&quot;
for read, write and execute permission testing.
Alterna&acirc; <br>
tively, mode can be a number as described in the UNIX
access(2) system call. The function returns 0 if the file
can be accessed with the specified mode, and -1
otherwise.</p>

<p style="margin-top: 1em">args(s_fname) <br>
Returns the number of arguments expected by the user-defined
function fname, or -1 if no such user-defined function
exists. Note that this function examines only user- <br>
defined functions, not built-in functions. Its main use is
to determine whether or not a particular user-defined
function has been defined previously. The args() func&acirc;
<br>
tion is available only in versions of Remind from 03.00.04
and up.</p>

<p style="margin-top: 1em">asc(s_string) <br>
Returns an INT that is the ASCII code of the first character
in string. As a special case, asc(&quot;&quot;) returns
0.</p>

<p style="margin-top: 1em">baseyr() <br>
Returns the &quot;base year&quot; that was compiled into
Remind (normally 1990.) All dates are stored internally as
the number of days since 1 January of baseyr().</p>

<p style="margin-top: 1em">char(i_i1 [,i_i2...]) <br>
This function can take any number of INT arguments. It
returns a STRING consisting of the characters specified by
the arguments. Note that none of the arguments can be <br>
0, unless there is only one argument. As a special case,
char(0) returns &quot;&quot;.</p>

<p style="margin-top: 1em">Note that because Remind does
not support escaping of characters in strings, the only way
to get a double-quote in a string is to use char(34).</p>

<p style="margin-top: 1em">choose(i_index, x_arg1
[,x_arg2...]) <br>
Choose must take at least two arguments, the first of which
is an INT. If index is n, then the nth subsequent argument
is returned. If index is less than 1, then arg1 is <br>
returned. If index is greater than the number of subsequent
arguments, then the last argument is returned. Examples:</p>

<p style="margin-top: 1em">choose(0, &quot;foo&quot;, 1:13,
1000) returns &quot;foo&quot; <br>
choose(1, &quot;foo&quot;, 1:13, 1000) returns
&quot;foo&quot; <br>
choose(2, &quot;foo&quot;, 1:13, 1000) returns 1:13 <br>
choose(3, &quot;foo&quot;, 1:13, 1000) returns 1000 <br>
choose(4, &quot;foo&quot;, 1:13, 1000) returns 1000 <br>
Note that all arguments to choose() are always
evaluated.</p>

<p style="margin-top: 1em">coerce(s_type, x_arg) <br>
This function converts arg to the specified type, if such
conversion is possible. Type must be one of &quot;INT&quot;,
&quot;STRING&quot;, &quot;DATE&quot;, &quot;TIME&quot; or
&quot;DATETIME&quot; (case-insensitive). <br>
The conversion rules are as follows:</p>

<p style="margin-top: 1em">If arg is already of the type
specified, it is returned unchanged.</p>

<p style="margin-top: 1em">If type is &quot;STRING&quot;,
then arg is converted to a string consisting of its printed
representation.</p>

<p style="margin-top: 1em">If type is &quot;DATE&quot;,
then an INT arg is converted by interpreting it as the
number of days since 1 January baseyr(). A STRING arg is
converted by attempting to read it as <br>
if it were a printed date. A DATETIME is converted to a date
by dropping the time component. A TIME arg cannot be
converted to a date.</p>

<p style="margin-top: 1em">If type is &quot;TIME&quot;,
then an INT arg is converted by interpreting it as the
number of minutes since midnight. A STRING arg is converted
by attempting to read it as if it <br>
were a printed time. A DATETIME is converted to a time by
dropping the date component. A DATE arg cannot be converted
to a time.</p>

<p style="margin-top: 1em">If type is &quot;DATETIME&quot;,
then an INT arg is converted by interpreting it as the
number of minutes since midnight, 1 January baseyr(). A
STRING is converted by attempting to <br>
read it as if it were a printed datetime. Other types cannot
be converted to a datetime.</p>

<p style="margin-top: 1em">If type is &quot;INT&quot;, then
DATE, TIME and DATETIME arguments are converted using the
reverse of procedures described above. A STRING arg is
converted by parsing it as an <br>
integer.</p>

<p style="margin-top: 1em">current() <br>
Returns the current date and time as a DATETIME object. This
may be the actual date and time, or may be the date and time
supplied on the command line.</p>

<p style="margin-top: 1em">date(i_y, i_m, i_d) <br>
The date() function returns a DATE object with the year,
month and day components specified by y, m and d.</p>

<p style="margin-top: 1em">datepart(dq_datetime) <br>
Returns a DATE object representing the date portion of
datetime.</p>

<p style="margin-top: 1em">datetime(args) <br>
The datetime() function can take anywhere from two to five
arguments. It always returns a DATETIME generated from its
arguments.</p>

<p style="margin-top: 1em">If you supply two arguments, the
first must be a DATE and the second a TIME.</p>

<p style="margin-top: 1em">If you supply three arguments,
the first must be a DATE and the second and third must be
INTs. The second and third arguments are interpreted as
hours and minutes and <br>
converted to a TIME.</p>

<p style="margin-top: 1em">If you supply four arguments,
the first three must be INTs, interpreted as the year, month
and day. The fourth argument must be a TIME.</p>

<p style="margin-top: 1em">Finally, if you supply five
arguments, they must all be INTs and are interpreted as
year, month, day, hour and minute.</p>

<p style="margin-top: 1em">dawn([dq_date]) <br>
Returns the time of &quot;civil dawn&quot; on the specified
date. If date is omitted, defaults to today(). If a datetime
object is supplied, only the date component is used.</p>

<p style="margin-top: 1em">day(dq_date) <br>
This function takes a DATE or DATETIME as an argument, and
returns an INT that is the day-of-month component of
date.</p>

<p style="margin-top: 1em">daysinmon(i_m, i_y) <br>
Returns the number of days in month m (1-12) of the year
y.</p>

<p style="margin-top: 1em">defined(s_var) <br>
Returns 1 if the variable named by var is defined, or 0 if
it is not. <br>
Note that defined() takes a STRING argument; thus, to check
if variable X is defined, use:</p>

<p style="margin-top: 1em">defined(&quot;X&quot;)</p>

<p style="margin-top: 1em">and not:</p>

<p style="margin-top: 1em">defined(X)</p>

<p style="margin-top: 1em">The second example will attempt
to evaluate X, and will return an error if it is undefined
or not of type STRING.</p>

<p style="margin-top: 1em">dosubst(s_str [,d_date
[,t_time]]) or dosubst(s_str [,q_datetime]) <br>
Returns a STRING that is the result of passing str through
the substitution filter described earlier. The parameters
date and time (or datetime) establish the effective <br>
trigger date and time used by the substitution filter. If
date and time are omitted, they default to today() and
now().</p>

<p style="margin-top: 1em">Note that if str does not end
with &quot;%&quot;, a newline character will be added to the
end of the result. Also, calling dosubst() with a date that
is in the past (i.e., if date <br>
&lt; today()) will produce undefined results.</p>

<p style="margin-top: 1em">Dosubst() is only available
starting from version 03.00.04 of Remind.</p>

<p style="margin-top: 1em">dusk([dq_date]) <br>
Returns the time of &quot;civil twilight&quot; on the
specified date. If date is omitted, defaults to today().</p>

<p style="margin-top: 1em">easterdate(dqi_arg) <br>
If arg is an INT, then returns the date of Easter Sunday for
the specified year. If arg is a DATE or DATETIME, then
returns the date of the next Easter Sunday on or after <br>
arg. (The time component of a datetime is ignored.)</p>

<p style="margin-top: 1em">evaltrig(s_trigger [,dq_start])
<br>
Evaluates trigger as if it were a REM or IFTRIG trigger
specification and returns the trigger date as a DATE (or as
a DATETIME if there is an AT clause.) Returns a nega&acirc;
<br>
tive INT if no trigger could be computed.</p>

<p style="margin-top: 1em">Normally, evaltrig finds a
trigger date on or after today. If you supply the start
argument, then it scans starting from there.</p>

<p style="margin-top: 1em">For example, the expression:</p>

<p style="margin-top: 1em">evaltrig(&quot;Mon 1&quot;,
&rsquo;2008-10-07&rsquo;)</p>

<p style="margin-top: 1em">returns
&rsquo;2008-11-03&rsquo;, since that is the first date on or
after 7 October 2008 that satisfies &quot;Mon 1&quot;.</p>

<p style="margin-top: 1em">If you want to see how many days
it is from the first Monday in October, 2008 to the first
Monday in November, 2008, use:</p>

<p style="margin-top: 1em">evaltrig(&quot;Mon 1&quot;,
&rsquo;2008-11-01&rsquo;) - evaltrig(&quot;Mon 1&quot;,
&rsquo;2008-10-01&rsquo;)</p>

<p style="margin-top: 1em">and the answer is 28. The
trigger argument to evaltrig can have all the usual trigger
clauses (OMIT, AT, SKIP, etc.) but cannot have a SATISFY,
MSG, etc. reminder-type <br>
clause.</p>

<p style="margin-top: 1em">filedate(s_filename) <br>
Returns the modification date of filename. If filename does
not exist, or its modification date is before the year
baseyr(), then 1 January of baseyr() is returned.</p>

<p style="margin-top: 1em">filedatetime(s_filename) <br>
Returns the modification date and time of filename. If
filename does not exist, or its modification date is before
the year baseyr(), then midnight, 1 January of baseyr() <br>
is returned.</p>

<p style="margin-top: 1em">filedir() <br>
Returns the directory that contains the current file being
processed. It may be a relative or absolute pathname, but is
guaranteed to be correct for use in an INCLUDE <br>
command as follows:</p>

<p style="margin-top: 1em">INCLUDE [filedir()]/stuff</p>

<p style="margin-top: 1em">This includes the file
&quot;stuff&quot; in the same directory as the current file
being processed.</p>

<p style="margin-top: 1em">filename() <br>
Returns (as a STRING) the name of the current file being
processed by Remind. Inside included files, returns the name
of the included file.</p>

<p style="margin-top: 1em">getenv(s_envvar) <br>
Similar to the getenv(2) system call. Returns a string
representing the value of the specified environment
variable. Returns &quot;&quot; if the environment variable
is not <br>
defined. Note that the names of environment variables are
generally case-sensitive; thus, getenv(&quot;HOME&quot;) is
not the same as getenv(&quot;home&quot;).</p>

<p style="margin-top: 1em">hebdate(i_day, s_hebmon
[,idq_yrstart [,i_jahr [,i_aflag]]]) <br>
Support for Hebrew dates - see the section &quot;The Hebrew
Calendar&quot;</p>

<p style="margin-top: 1em">hebday(dq_date) <br>
Support for Hebrew dates - see the section &quot;The Hebrew
Calendar&quot;</p>

<p style="margin-top: 1em">hebmon(dq_date) <br>
Support for Hebrew dates - see the section &quot;The Hebrew
Calendar&quot;</p>

<p style="margin-top: 1em">hebyear(dq_date) <br>
Support for Hebrew dates - see the section &quot;The Hebrew
Calendar&quot;</p>

<p style="margin-top: 1em">hour(tq_time) <br>
Returns the hour component of time.</p>

<p style="margin-top: 1em">iif(si_test1, x_arg1, [si_test2,
x_arg2,...], x_default) <br>
If test1 is not zero or the null string, returns arg1.
Otherwise, if test2 is not zero or the null string, returns
arg2, and so on. If all of the test arguments are <br>
false, returns default. Note that all arguments are always
evaluated. This function accepts an odd number of arguments
- note that prior to version 03.00.05 of Remind, <br>
it accepted 3 arguments only. The 3-argument version of
iif() is compatible with previous versions of Remind.</p>

<p style="margin-top: 1em">index(s_search, s_target
[,i_start) <br>
Returns an INT that is the location of target in the string
search. The first character of a string is numbered 1. If
target does not exist in search, then 0 is <br>
returned.</p>

<p style="margin-top: 1em">The optional parameter start
specifies the position in search at which to start looking
for target.</p>

<p style="margin-top: 1em">isdst([d_date [,t_time]]) or
isdst(q_datetime) <br>
Returns a positive number if daylight saving time is in
effect on the specified date and time. Date defaults to
today() and time defaults to midnight.</p>

<p style="margin-top: 1em">Note that this function is only
as reliable as the C run-time library functions. It is
available starting with version 03.00.07 of Remind.</p>

<p style="margin-top: 1em">isleap(idq_arg) <br>
Returns 1 if arg is a leap year, and 0 otherwise. Arg can be
an INT, DATE or DATETIME object. If a DATE or DATETIME is
supplied, then the year component is used in the <br>
test.</p>

<p style="margin-top: 1em">isomitted(dq_date) <br>
Returns 1 if date is omitted, given the current global OMIT
context. Returns 0 otherwise. (If a datetime is supplied,
only the date part is used.) Note that any local <br>
OMIT or OMITFUNC clauses are not taken into account by this
function.</p>

<p style="margin-top: 1em">language() <br>
Returns a STRING naming the language supported by Remind.
(See &quot;Foreign Language Support.&quot;) By default,
Remind is compiled to support English messages, so this
function <br>
returns &quot;English&quot;. For other languages, this
function will return the English name of the language (e.g.
&quot;German&quot;) Note that language() is not available in
versions of <br>
Remind prior to 03.00.02.</p>

<p style="margin-top: 1em">lower(s_string) <br>
Returns a STRING with all upper-case characters in string
converted to lower-case.</p>

<p style="margin-top: 1em">max(x_arg1 [,x_arg2...) <br>
Can take any number of arguments, and returns the maximum.
The arguments can be of any type, but must all be of the
same type. They are compared as with the &gt; operator.</p>

<p style="margin-top: 1em">min(x_arg1 [,x_arg2...) <br>
Can take any number of arguments, and returns the minimum.
The arguments can be of any type, but must all be of the
same type. They are compared as with the &lt; operator.</p>

<p style="margin-top: 1em">minsfromutc([d_date [,t_time]])
or minsfromutc(q_datetime) <br>
Returns the number of minutes from Universal Time
Coordinated (formerly GMT) to local time on the specified
date and time. Date defaults to today() and time defaults to
<br>
midnight. If local time is before UTC, the result is
negative. Otherwise, the result is positive.</p>

<p style="margin-top: 1em">Note that this function is only
as reliable as the C run-time library functions. It is
available starting with version 03.00.07 of Remind.</p>

<p style="margin-top: 1em">minute(tq_time) <br>
Returns the minute component of time.</p>

<p style="margin-top: 1em">mon(dqi_arg) <br>
If arg is of DATE or DATETIME type, returns a string that
names the month component of the date. If arg is an INT from
1 to 12, returns a string that names the month.</p>

<p style="margin-top: 1em">monnum(dq_date) <br>
Returns an INT from 1 to 12, representing the month
component of date.</p>

<p style="margin-top: 1em">moondate(i_phase [,d_date
[,t_time]]) or moondate(i_phase, q_datetime) <br>
This function returns the date of the first occurrence of
the phase phase of the moon on or after date and time. Phase
can range from 0 to 3, with 0 signifying new moon, <br>
1 first quarter, 2 full moon, and 3 third quarter. If date
is omitted, it defaults to today(). If time is omitted, it
defaults to midnight.</p>

<p style="margin-top: 1em">For example, the following
returns the date of the next full moon:</p>

<p style="margin-top: 1em">SET fullmoon moondate(2)</p>

<p style="margin-top: 1em">moontime(i_phase [,d_date
[,t_time]]) or moontime(i_phase, q_datetime) <br>
This function returns the time of the first occurrence of
the phase phase of the moon on or after date and time. Phase
can range from 0 to 3, with 0 signifying new moon, <br>
1 first quarter, 2 full moon, and 3 third quarter. If date
is omitted, it defaults to today(). If time is omitted, it
defaults to midnight. Moontime() is intended to be <br>
used in conjunction with moondate(). The moondate() and
moontime() functions are accurate to within a couple of
minutes of the times in &quot;Old Farmer&rsquo;s
Almanac&quot; for Ottawa, <br>
Ontario.</p>

<p style="margin-top: 1em">For example, the following
returns the date and time of the next full moon:</p>

<p style="margin-top: 1em">MSG Next full moon at
[moontime(2)] on [moondate(2)]</p>

<p style="margin-top: 1em">moondatetime(i_phase [,d_date
[,t_time]]) or moondatetime(i_phase, q_datetime) <br>
This function is similar to moondate and moontime, but
returns a DATETIME result.</p>

<p style="margin-top: 1em">moonphase([d_date [,t_time]]) or
moonphase(q_datetime) <br>
This function returns the phase of the moon on date and
time, which default to today() and midnight, respectively.
The returned value is an integer from 0 to 359, repre&acirc;
<br>
senting the phase of the moon in degrees. 0 is a new moon,
180 is a full moon, 90 is first-quarter, etc.</p>

<p style="margin-top: 1em">nonomitted(dq_start, dq_end
[,s_wkday...]) <br>
This function returns the number of non-omitted days between
start and end. If start is non-omitted, then it is counted.
end is never counted.</p>

<p style="margin-top: 1em">Note that end must be greater
than or equal to start or an error is reported. In addition
to using the global OMIT context, you can supply additional
arguments that are <br>
names of weekdays to be omitted. However, in a REM command,
any local OMITFUNC clause is not taken into account by this
function.</p>

<p style="margin-top: 1em">For example, the following line
sets a to 11 (assuming no global OMITs):</p>

<p style="margin-top: 1em">set a
nonomitted(&rsquo;2007-08-01&rsquo;,
&rsquo;2007-08-16&rsquo;, &quot;Sat&quot;,
&quot;Sun&quot;)</p>

<p style="margin-top: 1em">because Thursday, 16 August 2007
is the 11th working day (not counting Saturday and Sunday)
after Wednesday, 1 August 2007.</p>

<p style="margin-top: 1em">nonomitted has various uses. For
example, many schools run on a six-day cycle and the day
number is not incremented on holidays. Suppose the school
year starts with Day <br>
1 on 4 September 2007. The following reminder will label day
numbers in a calendar:</p>

<p style="margin-top: 1em">IF today() &gt;=
&rsquo;2007-09-04&rsquo; <br>
set daynum nonomitted(&rsquo;2007-09-04&rsquo;, today(),
&quot;Sat&quot;, &quot;Sun&quot;) <br>
REM OMIT SAT SUN SKIP CAL Day [(daynum % 6) + 1] <br>
ENDIF</p>

<p style="margin-top: 1em">Obviously, the answer you get
from nonomitted depends on the global OMIT context. If you
use moveable OMITs, you may get inconsistent results.</p>

<p style="margin-top: 1em">Here is a more complex use for
nonomitted. My garbage collection follows two interleaved
14-day cycles: One Friday, garbage and paper recycling
(&quot;Black Box&quot;) are col&acirc; <br>
lected. The next Friday, garbage and plastic recycling
(&quot;Blue Box&quot;) are collected. If any of
Monday-Friday is a holiday, collection is delayed until the
Saturday. <br>
Here&rsquo;s a way to encode these rules:</p>

<p style="margin-top: 1em">fset _garbhol(x) wkdaynum(x) ==
5 &amp;&amp; nonomitted(x-4, x+1) &lt; 5 <br>
REM 12 November 1999 *14 AFTER OMITFUNC _garbhol MSG Black
Box <br>
REM 19 November 1999 *14 AFTER OMITFUNC _garbhol MSG Blue
Box</p>

<p style="margin-top: 1em">Here&rsquo;s how it works: The
_garbhol(x) user-defined function returns 1 if and only if
(1) x is a Friday and (2) there is at least one OMITted day
from the previous Monday <br>
up to and including the Friday.</p>

<p style="margin-top: 1em">The first REM statement sets up
the 14-day black-box cycle. The AFTER keyword makes it move
collection to the Saturday if _garbhol returns 1. The second
REM statement <br>
sets up the 14-day blue-box cycle with a similar adjustment
made by AFTER in conjunction with _garbhol.</p>

<p style="margin-top: 1em">now() Returns the current system
time, as a TIME type. This may be the actual time, or a time
supplied on the command line.</p>

<p style="margin-top: 1em">ord(i_num) <br>
Returns a string that is the ordinal number num. For
example, ord(2) returns &quot;2nd&quot;, and ord(213)
returns &quot;213th&quot;.</p>

<p style="margin-top: 1em">ostype() <br>
Returns &quot;UNIX&quot;. Remind used to run on OS/2 and
MS-DOS, but does not any longer.</p>

<p style="margin-top: 1em">plural(i_num [,s_str1
[,s_str2]]) <br>
Can take from one to three arguments. If one argument is
supplied, returns &quot;s&quot; if num is not 1, and
&quot;&quot; if num is 1.</p>

<p style="margin-top: 1em">If two arguments are supplied,
returns str1 + &quot;s&quot; if num is not 1. Otherwise,
returns str1.</p>

<p style="margin-top: 1em">If three arguments are supplied,
returns str1 if num is 1, and str2 otherwise.</p>

<p style="margin-top: 1em">psmoon(i_phase [,i_size [,s_note
[,i_notesize]]]) <br>
[DEPRECATED] Returns a STRING consisting of PostScript code
to draw a moon in the upper-left hand corner of the calendar
box. Phase specifies the phase of the moon, and <br>
is 0 (new moon), 1 (first quarter), 2 (full moon) or 3
(third quarter). If size is specified, it controls the
radius of the moon in PostScript units (1/72 inch.) If it
<br>
is not specified or is negative, the size of the day-number
font is used.</p>

<p style="margin-top: 1em">For example, the following four
lines place moon symbols on the PostScript calendar:</p>

<p style="margin-top: 1em">REM [moondate(0)] PS [psmoon(0)]
<br>
REM [moondate(1)] PS [psmoon(1)] <br>
REM [moondate(2)] PS [psmoon(2)] <br>
REM [moondate(3)] PS [psmoon(3)]</p>

<p style="margin-top: 1em">If note is specified, the text
is used to annotate the moon display. The font is the same
font used for calendar entries. If notesize is given, it
specifies the font <br>
size to use for the annotation, in PostScript units (1/72
inch.) If notesize is not given, it defaults to the size
used for calendar entries. (If you annotate the dis&acirc;
<br>
play, be careful not to overwrite the day number -- Remind
does not check for this.) For example, if you want the time
of each new moon displayed, you could use this in <br>
your reminder script:</p>

<p style="margin-top: 1em">REM [moondate(0)] PS [psmoon(0,
-1, moontime(0)+&quot;&quot;)]</p>

<p style="margin-top: 1em">Note how the time is coerced to
a string by concatenating the null string.</p>

<p style="margin-top: 1em">psshade(i_gray) or
psshade(i_red, i_green, i_blue) <br>
[DEPRECATED] Returns a STRING that consists of PostScript
commands to shade a calendar box. Num can range from 0
(completely black) to 100 (completely white.) If three <br>
arguments are given, they specify red, green and blue
intensity from 0 to 100. Here&rsquo;s an example of how to
use this:</p>

<p style="margin-top: 1em">REM Sat Sun PS [psshade(95)]</p>

<p style="margin-top: 1em">The above command emits
PostScript code to lightly shade the boxes for Saturday and
Sunday in a PostScript calendar.</p>

<p style="margin-top: 1em">Note that psmoon and psshade are
deprecated; instead you should use the SPECIAL SHADE and
SPECIAL MOON reminders as described in &quot;Out-of-Band
Reminders.&quot;</p>

<p style="margin-top: 1em">realcurrent() <br>
Returns (as a DATETIME) the true date and time of day as
provided by the operating system. This is in contrast to
current(), which may return a time supplied on the
com&acirc; <br>
mand line.</p>

<p style="margin-top: 1em">realnow() <br>
Returns the true time of day as provided by the operating
system. This is in contrast to now(), which may return a
time supplied on the command line.</p>

<p style="margin-top: 1em">realtoday() <br>
Returns the date as provided by the operating system. This
is in contrast to Remind&rsquo;s concept of
&quot;today&quot;, which may be changed if it is running in
calendar mode, or if a <br>
date has been supplied on the command line.</p>

<p style="margin-top: 1em">sgn(i_num) <br>
Returns -1 if num is negative, 1 if num is positive, and 0
if num is zero.</p>

<p style="margin-top: 1em">shell(s_cmd [,i_maxlen]) <br>
Executes cmd as a system command, and returns the first 511
characters of output resulting from cmd. Any whitespace
character in the output is converted to a space. Note <br>
that if RUN OFF has been executed, or the -r command-line
option has been used, shell() will result in an error, and
cmd will not be executed.</p>

<p style="margin-top: 1em">If maxlen is specified, then
shell() returns the first maxlen characters of output
(rather than the first 511). If maxlen is specified as a
negative number, then all the <br>
output from cmd is returned.</p>

<p style="margin-top: 1em">slide(d_start, i_amt
[,s_wkday...]) <br>
This function is the inverse of nonomitted. It adds amt days
(which can be negative) to start, not counting omitted days.
The optional wkday arguments are additional <br>
weekday names to omit.</p>

<p style="margin-top: 1em">Consider this example:</p>

<p style="margin-top: 1em">OMIT 14 May 2009 <br>
SET a slide(&rsquo;2009-05-13&rsquo;, 5, &quot;Sat&quot;,
&quot;Sun&quot;)</p>

<p style="margin-top: 1em">In this case, a is set to
2009-05-21. That&rsquo;s because we slide forward by 5 days,
not including Thursday, May 14 or Saturday and Sunday, May
16 and 17. You can go back&acirc; <br>
wards, too, so:</p>

<p style="margin-top: 1em">OMIT 14 May 2009 <br>
SET a slide(&rsquo;2009-05-21&rsquo;, -5, &quot;Sat&quot;,
&quot;Sun&quot;)</p>

<p style="margin-top: 1em">takes a back to 2009-05-13.</p>

<p style="margin-top: 1em">strlen(s_str) <br>
Returns the length of str.</p>

<p style="margin-top: 1em">substr(s_str, i_start [,i_end])
<br>
Returns a STRING consisting of all characters in str from
start up to and including end. Characters are numbered from
1. If end is not supplied, then it defaults to the <br>
length of str.</p>

<p style="margin-top: 1em">sunrise([dq_date]) <br>
Returns a TIME indicating the time of sunrise on the
specified date (default today().) In high latitudes, there
may be no sunrise on a particular day, in which case
sun&acirc; <br>
rise() returns the INT 0 if the sun never sets, or 1440 if
it never rises.</p>

<p style="margin-top: 1em">sunset([dq_date]) <br>
Returns a TIME indicating the time of sunset on the
specified date (default today().) In high latitudes, there
may be no sunset on a particular day, in which case
sun&acirc; <br>
set() returns the INT 0 if the sun never rises, or 1440 if
it never sets.</p>

<p style="margin-top: 1em">The functions sunrise() and
sunset() are based on an algorithm in &quot;Almanac for
Computers for the year 1978&quot; by L. E. Doggett, Nautical
Almanac Office, USNO. They require <br>
the latitude and longitude to be specified by setting the
appropriate system variables. (See &quot;System
Variables&quot;.) The sun functions should be accurate to
within about 4 <br>
minutes for latitudes lower than 60 degrees. The functions
are available starting from version 03.00.07 of Remind.</p>

<p style="margin-top: 1em">time(i_hr, i_min) <br>
Creates a TIME with the hour and minute components specified
by hr and min.</p>

<p style="margin-top: 1em">timepart(tq_datetime) <br>
Returns a TIME object representing the time portion of
datetime.</p>

<p style="margin-top: 1em">today() <br>
Returns Remind&rsquo;s notion of &quot;today.&quot; This may
be the actual system date, or a date supplied on the command
line, or the date of the calendar entry currently being
com&acirc; <br>
puted.</p>

<p style="margin-top: 1em">trigdate() <br>
Returns the calculated trigger date of the last REM or
IFTRIG command. If used in the body of a REM command,
returns that command&rsquo;s trigger date. If the most
recent REM <br>
command did not yield a computable trigger date, returns the
integer 0.</p>

<p style="margin-top: 1em">trigdatetime() <br>
Similar to trigdate(), but returns a DATETIME if the most
recent triggerable REM command had an AT clause. If there
was no AT clause, returns a DATE. If no trigger could <br>
be computed, returns the integer 0.</p>

<p style="margin-top: 1em">trigger(d_date [,t_time
[,i_utcflag]]) or trigger(q_datetime [,i_utcflag]) <br>
Returns a string suitable for use in a REM command or a
SCANFROM or UNTIL clause, allowing you to calculate trigger
dates in advance. Note that in earlier versions of <br>
Remind, trigger was required to convert a date into
something the REM command could consume. However, in this
version of Remind, you can omit it. Note that trigger() <br>
always returns its result in English, even for
foreign-language versions of Remind. This is to avoid
problems with certain C libraries that do not handle
accented charac&acirc; <br>
ters properly. Normally, the date and time are the local
date and time; however, if utcflag is non-zero, the date and
time are interpreted as UTC times, and are converted <br>
to local time. Examples:</p>


<p style="margin-top: 1em">trigger(&rsquo;1993/04/01&rsquo;)</p>

<p style="margin-top: 1em">returns &quot;1 April
1993&quot;,</p>


<p style="margin-top: 1em">trigger(&rsquo;1994/08/09&rsquo;,
12:33)</p>

<p style="margin-top: 1em">returns &quot;9 August 1994 AT
12:33&quot;, as does:</p>


<p style="margin-top: 1em">trigger(&rsquo;1994/08/09@12:33&rsquo;).</p>

<p style="margin-top: 1em">Finally:</p>


<p style="margin-top: 1em">trigger(&rsquo;1994/12/01&rsquo;,
03:00, 1)</p>

<p style="margin-top: 1em">returns &quot;30 November 1994
AT 22:00&quot; for EST, which is 5 hours behind UTC. The
value for your time zone may differ.</p>

<p style="margin-top: 1em">trigtime() <br>
Returns the time of the last REM command with an AT clause.
If the last REM did not have an AT clause, returns the
integer 0.</p>

<p style="margin-top: 1em">trigvalid() <br>
Returns 1 if the value returned by trigdate() is valid for
the most recent REM command, or 0 otherwise. Sometimes REM
commands cannot calculate a trigger date. For exam&acirc;
<br>
ple, the following REM command can never be triggered:</p>

<p style="margin-top: 1em">REM Mon OMIT Mon SKIP MSG
Impossible!</p>

<p style="margin-top: 1em">typeof(x_arg) <br>
Returns &quot;STRING&quot;, &quot;INT&quot;,
&quot;DATE&quot;, &quot;TIME&quot; or &quot;DATETIME&quot;,
depending on the type of arg.</p>

<p style="margin-top: 1em">tzconvert(q_datetime, s_srczone
[,s_dstzone]) <br>
Converts datetime from the time zone named by srczone to the
time zone named by dstzone. If dstzone is omitted, the
default system time zone is used. The return value is <br>
a DATETIME. Time zone names are system-dependent; consult
your operating system for legal values. Here is an
example:</p>


<p style="margin-top: 1em">tzconvert(&rsquo;2007-07-08@01:14&rsquo;,
&quot;Canada/Eastern&quot;, &quot;Canada/Pacific&quot;)</p>

<p style="margin-top: 1em">returns</p>

<p style="margin-top: 1em">2007-07-07@22:14</p>

<p style="margin-top: 1em">upper(s_string) <br>
Returns a STRING with all lower-case characters in string
converted to upper-case.</p>

<p style="margin-top: 1em">value(s_varname [,x_default])
<br>
Returns the value of the specified variable. For example,
value(&quot;X&quot;+&quot;Y&quot;) returns the value of
variable XY, if it is defined. If XY is not defined, an
error results.</p>

<p style="margin-top: 1em">However, if you supply a second
argument, it is returned if the varname is not defined. The
expression value(&quot;XY&quot;, 0) will return 0 if XY is
not defined, and the value of <br>
XY if it is defined.</p>

<p style="margin-top: 1em">version() <br>
Returns a string specifying the version of Remind. For
version 03.00.04, returns &quot;03.00.04&quot;. It is
guaranteed that as new versions of Remind are released, the
value <br>
returned by version() will strictly increase, according to
the rules for string ordering.</p>

<p style="margin-top: 1em">weekno([dq_date, [i_wkstart,
[i_daystart]]]) <br>
Returns the week number of the year. If no arguments are
supplied, returns the ISO 8601 week number for today(). If
one argument date is supplied, then returns the ISO <br>
8601 week number for that date. If two arguments are
supplied, then wkstart must range from 0 to 6, and
represents the first day of the week (with 0 being Sunday
and 6 <br>
being Saturday.). If wkstart is not supplied, then it
defaults to 1. If the third argument daystart is supplied,
then it specifies when Week 1 starts. If daystart is <br>
less than or equal to 7, then Week 1 starts on the first
wkstart on or after January daystart. Otherwise, Week 1
starts on the first wkstart on or after December <br>
daystart. If omitted, daystart defaults to 29 (following the
ISO 8601 definition.)</p>

<p style="margin-top: 1em">wkday(dqi_arg) <br>
If arg is a DATE or DATETIME, returns a string representing
the day of the week of the date. If arg is an INT from 0 to
6, returns the corresponding weekday (&quot;Sunday&quot; to
<br>
&quot;Saturday&quot;).</p>

<p style="margin-top: 1em">wkdaynum(dq_date) <br>
Returns a number from 0 to 6 representing the day-of-week of
the specified date. (0 represents Sunday, and 6 represents
Saturday.)</p>

<p style="margin-top: 1em">year(dq_date) <br>
Returns a INT that is the year component of date.</p>

<p style="margin-top: 1em">EXPRESSION PASTING <br>
An extremely powerful feature of Remind is its macro
capability, or &quot;expression pasting.&quot;</p>

<p style="margin-top: 1em">In almost any situation where
Remind is not expecting an expression, you can
&quot;paste&quot; an expression in. To do this, surround the
expression with square brackets. For example:</p>

<p style="margin-top: 1em">REM [mydate] MSG foo</p>

<p style="margin-top: 1em">This evaluates the expression
&quot;mydate&quot;, where &quot;mydate&quot; is presumably
some pre-computed variable, and then &quot;pastes&quot; the
result into the command-line for the parser to process.</p>

<p style="margin-top: 1em">A formal description of this is:
When Remind encounters a &quot;pasted-in&quot; expression,
it evaluates the expression, and coerces the result to a
STRING. It then substitutes the <br>
string for the pasted-in expression, and continues parsing.
Note, however, that expressions are evaluated only once, not
recursively. Thus, writing:</p>

<p style="margin-top: 1em">[&quot;[a+b]&quot;]</p>

<p style="margin-top: 1em">causes Remind to read the token
&quot;[a+b]&quot;. It does not interpret this as a pasted-in
expression. In fact, the only way to get a literal
left-bracket into a reminder is to use <br>
[&quot;[&quot;].</p>

<p style="margin-top: 1em">You can use expression pasting
almost anywhere. However, there are a few exceptions:</p>

<p style="margin-top: 1em">o If Remind is expecting an
expression, as in the SET command, or the IF command, you
should not include square brackets. For example, use:</p>

<p style="margin-top: 1em">SET a 4+5 <br>
and not: <br>
SET a [4+5]</p>

<p style="margin-top: 1em">o You cannot use expression
pasting for the first token on a line. For example, the
following will not work:</p>

<p style="margin-top: 1em">[&quot;SET&quot;] a 1</p>

<p style="margin-top: 1em">This restriction is because
Remind must be able to unambiguously determine the first
token of a line for the flow-control commands (to be
discussed later.)</p>

<p style="margin-top: 1em">In fact, if Remind cannot
determine the first token on a line, it assumes that it is a
REM command. If expression-pasting is used, Remind assumes
it is a REM command. <br>
Thus, the following three commands are equivalent:</p>

<p style="margin-top: 1em">REM 12 Nov 1993 AT 13:05 MSG
BOO! <br>
12 Nov 1993 AT 13:05 MSG BOO! <br>
[12] [&quot;Nov &quot; + 1993] AT [12:05+60] MSG BOO!</p>

<p style="margin-top: 1em">o You cannot use
expression-pasting to determine the type (MSG, CAL, etc.) of
a REM command. You can paste expressions before and after
the MSG, etc keywords, but cannot do <br>
something like this:</p>

<p style="margin-top: 1em">REM [&quot;12 Nov 1993 AT 13:05
&quot; + &quot;MSG&quot; + &quot; BOO!&quot;]</p>

<p style="margin-top: 1em">COMMON PITFALLS IN EXPRESSION
PASTING</p>

<p style="margin-top: 1em">Remember, when pasting in
expressions, that extra spaces are not inserted. Thus,
something like:</p>

<p style="margin-top: 1em">REM[expr]MSG[expr]</p>

<p style="margin-top: 1em">will probably fail.</p>

<p style="margin-top: 1em">If you use an expression to
calculate a delta or back, ensure that the result is a
positive number. Something like:</p>

<p style="margin-top: 1em">REM +[mydelta] Nov 12 1993 MSG
foo</p>

<p style="margin-top: 1em">will fail if mydelta happens to
be negative.</p>

<p style="margin-top: 1em">FLOW CONTROL COMMANDS <br>
Remind has commands that control the flow of a reminder
script. Normally, reminder scripts are processed
sequentially. However, IF and related commands allow you to
process <br>
files conditionally, and skip sections that you don&rsquo;t
want interpreted.</p>

<p style="margin-top: 1em">THE IF COMMAND</p>

<p style="margin-top: 1em">The IF command has the following
form:</p>

<p style="margin-top: 1em">IF expr <br>
t-command <br>
t-command... <br>
ELSE <br>
f-command <br>
f-command... <br>
ENDIF</p>

<p style="margin-top: 1em">Note that the commands are shown
indented for clarity. Also, the ELSE portion can be omitted.
IF commands can be nested up to a small limit, probably
around 8 or 16 levels of <br>
nesting, depending on your system.</p>

<p style="margin-top: 1em">If the expr evaluates to a
non-zero INT, or a non-null STRING, then the IF portion is
considered true, and the t-commands are executed. If expr
evaluates to zero or null, then <br>
the f-commands (if the ELSE portion is present) are
executed. If expr is not of type INT or STRING, then it is
an error.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">IF
defined(&quot;want_hols&quot;) <br>
INCLUDE /usr/share/remind/holidays <br>
ENDIF</p>

<p style="margin-top: 1em">IF today() &gt;
&rsquo;1992/2/10&rsquo; <br>
set missed_ap &quot;You missed it!&quot; <br>
ELSE <br>
set missed_ap &quot;Still have time...&quot; <br>
ENDIF</p>

<p style="margin-top: 1em">THE IFTRIG COMMAND</p>

<p style="margin-top: 1em">The IFTRIG command is similar to
an IF command, except that it computes a trigger (as in the
REM command), and evaluates to true if a corresponding REM
command would trigger. <br>
Examples:</p>

<p style="margin-top: 1em">IFTRIG 1 Nov <br>
; Executed on 1 Nov <br>
ELSE <br>
; Executed except on 1 Nov <br>
ENDIF</p>

<p style="margin-top: 1em">IFTRIG 1 -1 OMIT Sat Sun +4 <br>
; Executed on last working day of month, <br>
; and the 4 working days preceding it <br>
ELSE <br>
; Executed except on above days <br>
ENDIF</p>

<p style="margin-top: 1em">Note that the IFTRIG command
computes a trigger date, which can be retrieved with the
trigdate() function. You can use all of the normal trigger
components, such as UNTIL, <br>
delta, etc in the IFTRIG command.</p>

<p style="margin-top: 1em">USER-DEFINED FUNCTIONS <br>
In addition to the built-in functions, Remind allows you to
define your own functions. The FSET command does this for
you:</p>

<p style="margin-top: 1em">FSET fname(args) expr</p>

<p style="margin-top: 1em">Fname is the name of the
function, and follows the convention for naming variables.
Args is a comma-separated list of arguments, and expr is an
expression. Args can be empty, <br>
in which case you define a function taking no parameters.
Here are some examples:</p>

<p style="margin-top: 1em">FSET double(x) 2*x <br>
FSET yeardiff(date1, date2) year(date1) - year(date2) <br>
FSET since(x) ord(year(trigdate())-x)</p>

<p style="margin-top: 1em">The last function is useful in
birthday reminders. For example:</p>

<p style="margin-top: 1em">REM 1 Nov +12 MSG Dean&rsquo;s
[since(1984)] birthday is %b.</p>

<p style="margin-top: 1em">Dean was born in 1984. The above
example, on 1 November 1992, would print:</p>

<p style="margin-top: 1em">Dean&rsquo;s 8th birthday is
today.</p>

<p style="margin-top: 1em">Notes:</p>

<p style="margin-top: 1em">o If you access a variable in
expr that is not in the list of arguments, the
&quot;global&quot; value (if any) is used.</p>

<p style="margin-top: 1em">o Function and parameter names
are significant only to 12 characters.</p>

<p style="margin-top: 1em">o The value() function always
accesses the &quot;global&quot; value of a variable, even if
it has the same name as an argument. For example:</p>

<p style="margin-top: 1em">fset func(x)
value(&quot;x&quot;) <br>
set x 1 <br>
set y func(5)</p>

<p style="margin-top: 1em">The above sequence sets y to 1,
which is the global value of x.</p>

<p style="margin-top: 1em">o User-defined functions may
call other functions, including other user-defined
functions. However, recursive calls are not allowed.</p>

<p style="margin-top: 1em">o User-defined functions are not
syntax-checked when they are defined; parsing occurs only
when they are called.</p>

<p style="margin-top: 1em">o If a user-defined function has
the same name as a built-in function, it is ignored and the
built-in function is used. To prevent conflicts with future
versions of Remind <br>
(which may define more built-in functions), you may wish to
name all user-defined functions beginning with an
underscore.</p>

<p style="margin-top: 1em">PRECISE SCHEDULING <br>
The WARN keyword allows precise control over advance warning
in a more flexible manner than the delta mechanism. It
should be followed by the name of a user-defined function,
<br>
warn_function.</p>

<p style="margin-top: 1em">If a warn_function is supplied,
then it must take one argument of type INT. Remind ignores
any delta, and instead calls warn_function successively with
the arguments 1, 2, 3, <br>
...</p>

<p style="margin-top: 1em">Warn_function&rsquo;s return
value n is interpreted as follows:</p>

<p style="margin-top: 1em">o If n is positive, then the
reminder is triggered exactly n days before its trigger
date.</p>

<p style="margin-top: 1em">o If n is negative, then it is
triggered n days before its trigger date, not counting
OMITted days.</p>

<p style="margin-top: 1em">As an example, suppose you wish
to be warned of American Independence Day 5, 3, and 1 days
in advance. You could use this:</p>

<p style="margin-top: 1em">FSET _wfun(x) choose(x, 5, 3, 1,
0) <br>
REM 4 July WARN _wfun MSG American Independence Day is
%b.</p>

<p style="margin-top: 1em">NOTES</p>

<p style="margin-top: 1em">1 If an error occurs during the
evaluation of warn_function, then Remind stops calling it
and simply issues the reminder on its trigger date.</p>

<p style="margin-top: 1em">2 If the absolute-values of the
return values of warn_function are not monotonically
decreasing, Remind stops calling it and issues the reminder
on its trigger date.</p>

<p style="margin-top: 1em">3 Warn_function should (as a
matter of good style) return 0 as the final value in its
sequence of return values. However, a reminder will always
be triggered on its trigger <br>
date, regardless of what warn_function does.</p>

<p style="margin-top: 1em">Similarly to WARN, the SCHED
keyword allows precise control over the scheduling of timed
reminders. It should be followed by the name of a
user-defined function, sched_function.</p>

<p style="margin-top: 1em">If a scheduling function is
supplied, then it must take one argument of type INT. Rather
than using the AT time, time delta, and time repeat, Remind
calls the scheduling func&acirc; <br>
tion to determine when to trigger the reminder. The first
time the reminder is queued, the scheduling function is
called with an argument of 1. Each time the reminder is
trig&acirc; <br>
gered, it is re-scheduled by calling the scheduling function
again. On each call, the argument is incremented by one.</p>

<p style="margin-top: 1em">The return value of the
scheduling function must be an INT or a TIME. If the return
value is a TIME, then the reminder is re-queued to trigger
at that time. If it is a positive <br>
integer n, then the reminder is re-queued to trigger at the
previous trigger time plus n minutes. Finally, if it is a
negative integer or zero, then the reminder is re-queued to
<br>
trigger n minutes before the AT time. Note that there must
be an AT clause for the SCHED clause to do anything.</p>

<p style="margin-top: 1em">Here&rsquo;s an example:</p>

<p style="margin-top: 1em">FSET _sfun(x) choose(x, -60, 30,
15, 10, 3, 1, 1, 1, 1, 0) <br>
REM AT 13:00 SCHED _sfun MSG foo</p>

<p style="margin-top: 1em">The reminder would first be
triggered at 13:00-60 minutes, or at 12:00. It would next be
triggered 30 minutes later, at 12:30. Then, it would be
triggered at 12:45, 12:55, <br>
12:58, 12:59, 13:00, 13:01 and 13:02.</p>

<p style="margin-top: 1em">NOTES</p>

<p style="margin-top: 1em">1 If an error occurs during the
evaluation of sched_func, then Remind reverts to using the
AT time and the delta and repeat values, and never calls
sched_func again.</p>

<p style="margin-top: 1em">2 If processing sched_func
yields a time earlier than the current system time, it is
repeatedly called with increasing argument until it yields a
value greater than or equal <br>
to the current time. However, if the sequence of values
calculated during the repetition is not strictly increasing,
then Remind reverts to the default behaviour and <br>
never calls sched_func again.</p>

<p style="margin-top: 1em">3 It is quite possible using
sched_func to keep triggering a reminder even after the
AT-time. However, it is not possible to reschedule a
reminder past midnight - no cross&acirc; <br>
ing of date boundaries is allowed. Also, it is quite
possible to not trigger a reminder on the AT time when you
use a scheduling function. However, if your scheduling <br>
function is terminated (for reasons 1 and 2) before the AT
time of the reminder, it will be triggered at the AT time,
because normal processing takes over.</p>

<p style="margin-top: 1em">4 Your scheduling functions
should (as a matter of good style) return 0 when no more
scheduling is required. See the example.</p>

<p style="margin-top: 1em">5 All scheduling functions are
evaluated after the entire Remind script has been read in.
So whatever function definitions are in effect at the end of
the script are used.</p>

<p style="margin-top: 1em">THE SATISFY CLAUSE <br>
The form of REM that uses SATISFY is as follows:</p>

<p style="margin-top: 1em">REM trigger SATISFY expr</p>

<p style="margin-top: 1em">The way this works is as
follows: Remind first calculates a trigger date, in the
normal fashion. Next, it sets trigdate() to the calculated
trigger date. It then evaluates <br>
expr. If the result is not the null string or zero,
processing ends. Otherwise, Remind computes the next trigger
date, and re-tests expr. This iteration continues until expr
<br>
evaluates to non-zero or non-null, or until the iteration
limit specified with the -x command-line option is
reached.</p>

<p style="margin-top: 1em">If expr is not satisfied, then
trigvalid() is set to 0. Otherwise, trigvalid() is set to 1.
In any event, no error message is issued.</p>

<p style="margin-top: 1em">This is really useful only if
expr involves a call to the trigdate() function; otherwise,
expr will not change as Remind iterates.</p>

<p style="margin-top: 1em">An example of the usefulness of
SATISFY: Suppose you wish to be warned of every Friday the
13th. Your first attempt may be:</p>

<p style="margin-top: 1em"># WRONG! <br>
REM Fri 13 +2 MSG Friday the 13th is %b.</p>

<p style="margin-top: 1em">But this won&rsquo;t work. This
reminder triggers on the first Friday on or after the 13th
of each month. The way to do it is with a more complicated
sequence:</p>

<p style="margin-top: 1em">REM 13 SATISFY
wkdaynum(trigdate()) == 5 <br>
IF trigvalid() <br>
REM [trigdate()] +2 MSG Friday the 13th is %b. <br>
ENDIF</p>

<p style="margin-top: 1em">Let&rsquo;s see how this works.
The SATISFY clause iterates through all the 13ths of
successive months, until a trigger date is found whose
day-of-week is Friday (== 5). If a valid <br>
date was found, we use the calculated trigger date to set up
the next reminder.</p>

<p style="margin-top: 1em">We could also have written:</p>

<p style="margin-top: 1em">REM Fri SATISFY day(trigdate())
== 13</p>

<p style="margin-top: 1em">but this would result in more
iterations, since &quot;Fridays&quot; occur more often than
&quot;13ths of the month.&quot;</p>

<p style="margin-top: 1em">This technique of using one REM
command to calculate a trigger date to be used by another
command is quite powerful. For example, suppose you wanted
to OMIT Labour day, which is <br>
the first Monday in September. You could use:</p>

<p style="margin-top: 1em"># Note: SATISFY 1 is an idiom
for &quot;do nothing&quot; <br>
REM Mon 1 Sept SATISFY 1 <br>
OMIT [trigdate()]</p>

<p style="margin-top: 1em">CAVEAT: This only omits the next
Labour Day, not all Labour Days in the future. This could
cause strange results, as the OMIT context can change
depending on the current date. <br>
For example, if you use the following command after the
above commands:</p>

<p style="margin-top: 1em">REM Mon AFTER msg hello</p>

<p style="margin-top: 1em">the result will not be as you
expect. Consider producing a calendar for September, 1992.
Labour Day was on Monday, 7 September, 1992. However, when
Remind gets around to cal&acirc; <br>
culating the trigger for Tuesday, 8 September, 1992, the
OMIT command will now be omitting Labour Day for 1993, and
the &quot;Mon AFTER&quot; command will not be triggered.
(But see the <br>
description of SCANFROM in the section &quot;Details about
Trigger Computation.&quot;)</p>

<p style="margin-top: 1em">It is probably best to stay away
from computing OMIT trigger dates unless you keep these
pitfalls in mind.</p>

<p style="margin-top: 1em">For versions of Remind starting
from 03.00.07, you can include a MSG, RUN, etc. clause in a
SATISFY clause as follows:</p>

<p style="margin-top: 1em">REM trigger_stuff SATISFY [expr]
MSG body</p>

<p style="margin-top: 1em">Note that for this case only,
the expr after SATISFY must be enclosed in braces. It must
come after all the other components of the trigger, and
immediately before the MSG, RUN, <br>
etc. keyword. If expr cannot be satisfied, then the reminder
is not triggered.</p>

<p style="margin-top: 1em">Thus, the &quot;Friday the
13th&quot; example can be expressed more compactly as:</p>

<p style="margin-top: 1em">REM 13 +2 SATISFY
[wkdaynum(trigdate()) == 5] MSG Friday the 13th is %b.</p>

<p style="margin-top: 1em">And you can trigger a reminder
on Mondays, Wednesdays and Thursdays occurring on
odd-numbered days of the month with the following:</p>

<p style="margin-top: 1em">REM Mon Wed Thu SATISFY
[day(trigdate())%2] MSG Here it is!!!</p>

<p style="margin-top: 1em">Note that SATISFY and OMITFUNC
can often be used to solve the same problem, though in
different ways. Sometimes a SATISFY is cleaner and sometimes
an OMITFUNC; experiment and <br>
use whichever seems clearer.</p>

<p style="margin-top: 1em">DEBUGGING REMINDER SCRIPTS <br>
Although the command-line -d option is useful for debugging,
it is often overkill. For example, if you turn on the -dx
option for a reminder file with many complex expressions,
<br>
you&rsquo;ll get a huge amount of output. The DEBUG command
allows you to control the debugging flags under program
control. The format is:</p>

<p style="margin-top: 1em">DEBUG [+flagson] [-flagsoff]</p>

<p style="margin-top: 1em">Flagson and flagsoff consist of
strings of the characters &quot;extvlf&quot; that correspond
to the debugging options discussed in the command-line
options section. If preceded with a <br>
&quot;+&quot;, the corresponding group of debugging options
is switched on. Otherwise, they are switched off. For
example, you could use this sequence to debug a complicated
expression:</p>

<p style="margin-top: 1em">DEBUG +x <br>
set a very_complex_expression(many_args) <br>
DEBUG -x</p>

<p style="margin-top: 1em">THE DUMPVARS COMMAND</p>

<p style="margin-top: 1em">The command DUMPVARS displays
the values of variables in memory. Its format is:</p>

<p style="margin-top: 1em">DUMPVARS [var...]</p>

<p style="margin-top: 1em">If you supply a space-separated
list of variable names, the corresponding variables are
displayed. If you do not supply a list of variables, then
all variables in memory are <br>
displayed. To dump a system variable, put its name in the
list of variables to dump. If you put a lone dollar sign in
the list of variables to dump, then all system variables
<br>
will be dumped.</p>

<p style="margin-top: 1em">THE ERRMSG COMMAND</p>

<p style="margin-top: 1em">The ERRMSG command has the
following format:</p>

<p style="margin-top: 1em">ERRMSG body</p>

<p style="margin-top: 1em">The body is passed through the
substitution filter (with an implicit trigger date of
today()) and printed to the error output stream.
Example:</p>

<p style="margin-top: 1em">IF
!defined(&quot;critical_var&quot;) <br>
ERRMSG You must supply a value for &quot;critical_var&quot;
<br>
EXIT <br>
ENDIF</p>

<p style="margin-top: 1em">THE EXIT COMMAND</p>

<p style="margin-top: 1em">The above example also shows the
use of the EXIT command. This causes an unconditional exit
from script processing. Any queued timed reminders are
discarded. If you are in <br>
calendar mode (described next), then the calendar processing
is aborted.</p>

<p style="margin-top: 1em">If you supply an INT-type
expression after the EXIT command, it is returned to the
calling program as the exit status. Otherwise, an exit
status of 99 is returned.</p>

<p style="margin-top: 1em">THE FLUSH COMMAND</p>

<p style="margin-top: 1em">This command simply consists of
the word FLUSH on a line by itself. The command flushes the
standard output and standard error streams used by Remind.
This is not terribly use&acirc; <br>
ful to most people, but may be useful if you run Remind as a
subprocess of another program, and want to use pipes for
communication.</p>

<p style="margin-top: 1em">CALENDAR MODE <br>
If you supply the -c, -s or -p command-line option, then
Remind runs in &quot;calendar mode.&quot; In this mode,
Remind interprets the script repeatedly, performing one
iteration through <br>
the whole file for each day in the calendar. Reminders that
trigger are saved in internal buffers, and then inserted
into the calendar in the appropriate places.</p>

<p style="margin-top: 1em">If you also supply the -a
option, then Remind will not include timed reminders in the
calendar.</p>

<p style="margin-top: 1em">The -p option is used in
conjunction with the Rem2PS program to produce a calendar in
PostScript format. For example, the following command will
send PostScript code to standard <br>
output:</p>

<p style="margin-top: 1em">remind -p .reminders |
rem2ps</p>

<p style="margin-top: 1em">You can print a PostScript
calendar by piping this to the lpr command.</p>

<p style="margin-top: 1em">If you have a reminder script
called &quot;.reminders&quot;, and you execute this
command:</p>

<p style="margin-top: 1em">remind -c .reminders jan
1993</p>

<p style="margin-top: 1em">then Remind executes the script
31 times, once for each day in January. Each time it
executes the script, it increments the value of today(). Any
reminders whose trigger date <br>
matches today() are entered into the calendar.</p>

<p style="margin-top: 1em">MSG and CAL-type reminders, by
default, have their entire body inserted into the calendar.
RUN-type reminders are not normally inserted into the
calendar. However, if you <br>
enclose a portion of the body in the %&quot;...%&quot;
sequence, only that portion is inserted. For example,
consider the following:</p>

<p style="margin-top: 1em">REM 6 Jan MSG
%&quot;Dianne&rsquo;s birthday%&quot; is %b</p>

<p style="margin-top: 1em">In the normal mode, Remind would
print &quot;Dianne&rsquo;s birthday is today&quot; on 6
January. However, in the calendar mode, only the text
&quot;Dianne&rsquo;s birthday&quot; is inserted into the box
for 6 <br>
January.</p>

<p style="margin-top: 1em">If you explicitly use the
%&quot;...%&quot; sequence in a RUN-type reminder, then the
text between the delimiters is inserted into the calendar.
If you use the sequence %&quot;%&quot; in a MSG or <br>
CAL-type reminder, then no calendar entry is produced for
that reminder.</p>

<p style="margin-top: 1em">PRESERVING VARIABLES</p>

<p style="margin-top: 1em">Because Remind iterates through
the script for each day in the calendar, slow operations may
severely reduce the speed of producing a calendar.</p>

<p style="margin-top: 1em">For example, suppose you set the
variables &quot;me&quot; and &quot;hostname&quot; as
follows:</p>

<p style="margin-top: 1em">SET me shell(&quot;whoami&quot;)
<br>
SET hostname shell(&quot;hostname&quot;)</p>

<p style="margin-top: 1em">Normally, Remind clears all
variables between iterations in calendar mode. However, if
certain variables are slow to compute, and will not change
between iterations, you can <br>
&quot;preserve&quot; their values with the PRESERVE command.
Also, since function definitions are preserved between
calendar iterations, there is no need to redefine them on
each itera&acirc; <br>
tion. Thus, you could use the following sequence:</p>

<p style="margin-top: 1em">IF !
defined(&quot;initialized&quot;) <br>
set initialized 1 <br>
set me shell(&quot;whoami&quot;) <br>
set hostname shell(&quot;hostname&quot;) <br>
fset func(x) complex_expr <br>
preserve initialized me hostname <br>
ENDIF</p>

<p style="margin-top: 1em">The operation is as follows: On
the first iteration through the script,
&quot;initialized&quot; is not defined. Thus, the commands
between IF and ENDIF are executed. The PRESERVE com&acirc;
<br>
mand ensures that the values of initialized, me and hostname
are preserved for subsequent iterations. On the next
iteration, the commands are skipped, since initialized has
<br>
remained defined. Thus, time-consuming operations that do
not depend on the value of today() are done only once.</p>

<p style="margin-top: 1em">System variables (those whose
names start with &rsquo;$&rsquo;) are automatically
preserved between calendar iterations.</p>

<p style="margin-top: 1em">Note that for efficiency, Remind
caches the reminder script (and any INCLUDEd files) in
memory when producing a calendar.</p>

<p style="margin-top: 1em">Timed reminders are sorted and
placed into the calendar in time order. These are followed
by non-timed reminders. Remind automatically places the time
of timed reminders in the <br>
calendar according to the -b command-line option. Reminders
in calendar mode are sorted as if the -g option had been
used; you can change the sort order in calendar mode by <br>
explicitly using the -g option to specify a different order
from the default.</p>

<p style="margin-top: 1em">REPEATED EXECUTION</p>

<p style="margin-top: 1em">If you supply a repeat parameter
on the command line, and do not use the -c, -p, or -s
options, Remind operates in a similar manner to calendar
mode. It repeatedly executes the <br>
reminder script, incrementing today() with each iteration.
The same rules about preserving variables and function
definitions apply. Note that using repeat on the command
line <br>
also enables the -q option and disables any -z option. As an
example, if you want to see how Remind will behave for the
next week, you can type:</p>

<p style="margin-top: 1em">remind .reminders
&rsquo;*7&rsquo;</p>

<p style="margin-top: 1em">If you want to print the dates
of the next 1000 days, use:</p>

<p style="margin-top: 1em">(echo &rsquo;banner %&rsquo;;
echo &rsquo;msg [today()]%&rsquo;) | remind -
&rsquo;*1000&rsquo;</p>

<p style="margin-top: 1em">INITIALIZING VARIABLES ON THE
COMMAND LINE <br>
The -i option is used to initialize variables on the Remind
command line. The format is -ivar=expr, where expr is any
valid expression. Note that you may have to use quotes or
<br>
escapes to prevent the shell from interpreting special
characters in expr. You can have as many -i options as you
want on the command line, and they are processed in order.
<br>
Thus, if a variable is defined in one -i option, it can be
referred to by subsequent -i options.</p>

<p style="margin-top: 1em">Note that if you supply a date
on the command line, it is not parsed until all options have
been processed. Thus, if you use today() in any of the -i
expressions, it will return <br>
the same value as realtoday() and not the date supplied on
the command line.</p>

<p style="margin-top: 1em">Any variables defined on the
command line are preserved as with the PRESERVE command.</p>

<p style="margin-top: 1em">You should not have any spaces
between the -i option and the equal sign; otherwise, strange
variable names are created that can only be accessed with
the value() or defined() <br>
functions.</p>

<p style="margin-top: 1em">You can also define a function
on the command line by using:</p>

<p style="margin-top: 1em">-ifunc(args)=definition</p>

<p style="margin-top: 1em">Be sure to protect special
characters from shell interpretation.</p>

<p style="margin-top: 1em">MORE ABOUT POSTSCRIPT <br>
The PS and PSFILE reminders pass PostScript code directly to
the printer. They differ in that the PS-type reminder passes
its body directly to the PostScript output (after pro&acirc;
<br>
cessing by the substitution filter) while the
PSFILE-type&rsquo;s body should simply consist of a
filename. The Rem2PS program will open the file named in the
PSFILE-type reminder, <br>
and include its contents in the PostScript output.</p>

<p style="margin-top: 1em">The PostScript-type reminders
for a particular day are included in the PostScript output
in sorted order of priority. Note that the order of
PostScript commands has a major <br>
impact on the appearance of the calendars. For example,
PostScript code to shade a calendar box will obliterate code
to draw a moon symbol if the moon symbol code is placed in
<br>
the calendar first. For this reason, you should not provide
PS or PSFILE-type reminders with priorities; instead, you
should ensure that they appear in the reminder script in
<br>
the correct order. PostScript code should draw objects
working from the background to the foreground, so that
foreground objects properly overlay background ones. If you
prior&acirc; <br>
itize these reminders and run the script using descending
sort order for priorities, the PostScript output will not
work.</p>

<p style="margin-top: 1em">All of the PostScript code for a
particular date is enclosed in a save-restore pair. However,
if several PostScript-type reminders are triggered for a
single day, each section <br>
of PostScript is not enclosed in a save-restore pair -
instead, the entire body of included PostScript is
enclosed.</p>

<p style="margin-top: 1em">PostScript-type reminders are
executed by the PostScript printer before any regular
calendar entries. Thus, regular calendar entries will
overlay the PostScript-type reminders, <br>
allowing you to create shaded or graphical backgrounds for
particular days.</p>

<p style="margin-top: 1em">Before executing your PostScript
code, the origin of the PostScript coordinate system is
positioned to the bottom left-hand corner of the
&quot;box&quot; in the calendar representing <br>
today(). This location is exactly in the middle of the
intersection of the bottom and left black lines delineating
the box - you may have to account for the thickness of these
<br>
lines when calculating positions.</p>

<p style="margin-top: 1em">Several PostScript variables are
available to the PostScript code you supply. All distance
and size variables are in PostScript units (1/72 inch.) The
variables are:</p>

<p style="margin-top: 1em">LineWidth <br>
The width of the black grid lines making up the
calendar.</p>

<p style="margin-top: 1em">Border The border between the
center of the grid lines and the space used to print
calendar entries. This border is normally blank space.</p>

<p style="margin-top: 1em">BoxWidth and BoxHeight <br>
The width and height of the calendar box, from
center-to-center of the black gridlines.</p>

<p style="margin-top: 1em">InBoxHeight <br>
The height from the center of the bottom black gridline to
the top of the regular calendar entry area. The space from
here to the top of the box is used only to draw the <br>
day number.</p>

<p style="margin-top: 1em">/DayFont, /EntryFont,
/SmallFont, /TitleFont and /HeadFont <br>
The fonts used to draw the day numbers, the calendar
entries, the small calendars, the calendar title (month,
year) and the day-of-the-week headings, respectively.</p>

<p style="margin-top: 1em">DaySize, EntrySize, TitleSize
and HeadSize <br>
The sizes of the above fonts. (The size of the small
calendar font is not defined here.) For example, if you
wanted to print the Hebrew date next to the regular day
num&acirc; <br>
ber in the calendar, use:</p>

<p style="margin-top: 1em">REM PS Border BoxHeight Border
sub DaySize sub moveto /DayFont findfont DaySize scalefont
setfont ([hebday(today())] [hebmon(today())]) show</p>

<p style="margin-top: 1em">Note how /DayFont and DaySize
are used.</p>

<p style="margin-top: 1em">Note that if you supply
PostScript code, it is possible to produce invalid
PostScript files. Always test your PostScript thoroughly
with a PostScript viewer before sending it to <br>
the printer. You should not use any document structuring
comments in your PostScript code.</p>

<p style="margin-top: 1em">DAEMON MODE <br>
If you use the -z command-line option, Remind runs in the
&quot;daemon&quot; mode. In this mode, no &quot;normal&quot;
reminders are issued. Instead, only timed reminders are
collected and queued, <br>
and are then issued whenever they reach their trigger
time.</p>

<p style="margin-top: 1em">In addition, Remind wakes up
every few minutes to check the modification date on the
reminder script (the filename supplied on the command line.)
If Remind detects that the <br>
script has changed, it re-executes itself in daemon mode,
and interprets the changed script.</p>

<p style="margin-top: 1em">In daemon mode, Remind also
re-reads the remind script when it detects that the system
date has changed.</p>

<p style="margin-top: 1em">In daemon mode, Remind acts as
if the -f option had been used, so to run in the daemon mode
in the background, use:</p>

<p style="margin-top: 1em">remind -z .reminders &amp;</p>

<p style="margin-top: 1em">If you use sh or bash, you may
have to use the &quot;nohup&quot; command to ensure that the
daemon is not killed when you log out.</p>

<p style="margin-top: 1em">PURGE MODE <br>
If you supply the -j command-line option, Remind runs in
purge mode. In this mode, it tries to purge expired
reminders from your reminder files.</p>

<p style="margin-top: 1em">In purge mode, Remind reads your
reminder file and creates a new file by appending
&quot;.purged&quot; to the original file name. Note that
Remind never edits your original file; it <br>
always creates a new .purged file.</p>

<p style="margin-top: 1em">If you invoke Remind against a
directory instead of a file, then a .purged file is created
for each *.rem file in the directory.</p>

<p style="margin-top: 1em">Normally, Remind does not create
.purged files for INCLUDed files. However, if you supply a
numeric argument after -j, then Remind will create .purged
files for the specified <br>
level of INCLUDE. For example, if you invoke Remind with the
argument -j2, then .purged files will be created for the
file (or directory) specified on the command line, any <br>
files included by them, and any files included by those
files. However, .purged files will not be created for
third-or-higher level INCLUDE files.</p>

<p style="margin-top: 1em">Determining which reminders have
expired is extremely tricky. Remind does its best, but you
should always compare the .purged file to the original file
and hand-merge the <br>
changes back in.</p>

<p style="margin-top: 1em">Remind annotates the .purged
file as follows:</p>

<p style="margin-top: 1em">An expired reminder is prefixed
with: #!P: Expired:</p>

<p style="margin-top: 1em">In situations where Remind
cannot reliably determine that something was expired, you
may see the following comments inserted before the
problematic line:</p>

<p style="margin-top: 1em">#!P: Cannot purge SATISFY-type
reminders</p>

<p style="margin-top: 1em">#!P: The next IF evaluated
false... <br>
#!P: REM statements in IF block not checked for purging.</p>

<p style="margin-top: 1em">#!P: The previous IF evaluated
true. <br>
#!P: REM statements in ELSE block not checked for
purging</p>

<p style="margin-top: 1em">#!P: The next IFTRIG did not
trigger. <br>
#!P: REM statements in IFTRIG block not checked for
purging.</p>

<p style="margin-top: 1em">#!P: Next line has expired, but
contains expression... please verify</p>

<p style="margin-top: 1em">#!P: Next line may have expired,
but contains non-constant expression</p>

<p style="margin-top: 1em">#!P! Could not parse next line:
Some-Error-Message-Here</p>

<p style="margin-top: 1em">Remind always annotates .purged
files with lines beginning with &quot;#!P&quot;. If such
lines are encountered in the original file, they are not
copied to the .purged file.</p>

<p style="margin-top: 1em">SORTING REMINDERS <br>
The -g option causes Remind to sort reminders by trigger
date, time and priority before issuing them. Note that
reminders are still calculated in the order encountered in
the <br>
script. However, rather than being issued immediately, they
are saved in an internal buffer. When Remind has finished
processing the script, it issues the saved reminders in <br>
sorted order. The -g option can be followed by up to four
characters that must all be &quot;a&quot; or &quot;d&quot;.
The first character specifies the sort order by trigger date
(ascending or <br>
descending), the second specifies the sort order by trigger
time and the third specifies the sort order by priority. If
the fourth character is &quot;d&quot;, the untimed reminders
are <br>
sorted before timed reminders. The default is to sort all
fields in ascending order and to sort untimed reminders
after timed reminders.</p>

<p style="margin-top: 1em">In ascending order, reminders
are issued with the most imminent first. Descending order is
the reverse. Reminders are always sorted by trigger date,
and reminders with the same <br>
trigger date are then sorted by trigger time. If two
reminders have the same date and time, then the priority is
used to break ties. Reminders with the same date, time and
pri&acirc; <br>
ority are issued in the order they were encountered.</p>

<p style="margin-top: 1em">You can define a user-defined
function called SORTBANNER that takes one DATE-type
argument. In sort mode, the following sequence happens:</p>

<p style="margin-top: 1em">If Remind notices that the next
reminder to issue has a different trigger date from the
previous one (or if it is the first one to be issued), then
SORTBANNER is called with the <br>
trigger date as its argument. The result is coerced to a
string, and passed through the substitution filter with the
appropriate trigger date. The result is then displayed.</p>

<p style="margin-top: 1em">Here&rsquo;s an example -
consider the following fragment:</p>

<p style="margin-top: 1em"># Switch off the normal banner
<br>
BANNER % <br>
REM 11 March 1993 ++1 MSG Not so important <br>
REM 17 March 1993 ++7 MSG Way in the future <br>
REM 10 March 1993 MSG Important Reminder <br>
REM 11 March 1993 ++1 MSG Not so important - B <br>
FSET sortbanner(x) iif(x == today(), &quot;***** THINGS TO
DO TODAY *****&quot;, &quot;----- Things to do %b
-----&quot;)</p>

<p style="margin-top: 1em">Running this with the -gaa
option on 10 March 1993 produces the following output:</p>

<p style="margin-top: 1em">***** THINGS TO DO TODAY
*****</p>

<p style="margin-top: 1em">Important Reminder</p>

<p style="margin-top: 1em">----- Things to do tomorrow
-----</p>

<p style="margin-top: 1em">Not so important</p>

<p style="margin-top: 1em">Not so important - B</p>

<p style="margin-top: 1em">----- Things to do in 7
days&rsquo; time -----</p>

<p style="margin-top: 1em">Way in the future</p>

<p style="margin-top: 1em">You can use the args() built-in
function to determine whether or not SORTBANNER has been
defined. (This could be used, for example, to provide a
default definition for SORTBAN&acirc; <br>
NER in a system-wide file included at the end of the
user&rsquo;s file.) Here&rsquo;s an example:</p>

<p style="margin-top: 1em"># Create a default sortbanner
function if it hasn&rsquo;t already <br>
# been defined <br>
if args(&quot;sortbanner&quot;) != 1 <br>
fset sortbanner(x) &quot;--- Things to do %b ---&quot; <br>
endif</p>

<p style="margin-top: 1em">MSGPREFIX() AND MSGSUFFIX() <br>
You can define two functions in your script called
msgprefix() and msgsuffix(). They should each accept one
argument, a number from 0 to 9999.</p>

<p style="margin-top: 1em">In normal mode, for MSG- and
MSF-type reminders, the following sequence occurs when
Remind triggers a reminder:</p>

<p style="margin-top: 1em">o If msgprefix() is defined, it
is evaluated with the priority of the reminder as its
argument. The result is printed. It is not passed through
the substitution filter.</p>

<p style="margin-top: 1em">o The body of the reminder is
printed.</p>

<p style="margin-top: 1em">o If msgsuffix() is defined, it
is evaluated with the priority of the reminder as its
argument. The result is printed. It is not passed through
the substitution filter.</p>

<p style="margin-top: 1em">Here&rsquo;s an example: The
following definition causes priority-0 reminders to be
preceded by &quot;URGENT&quot;, and priority-6000 reminders
to be preceded by &quot;(not important)&quot;.</p>

<p style="margin-top: 1em">fset msgprefix(x) iif(x==0,
&quot;URGENT: &quot;, x==6000, &quot;(not important) &quot;,
&quot;&quot;)</p>

<p style="margin-top: 1em">In Calendar Mode (with the -c,
-s or -p options), an analogous pair of functions named
calprefix() and calsuffix() can be defined. They work with
all reminders that produce an <br>
entry in the calendar (i.e., CAL- and possibly RUN-type
reminders as well as MSG-type reminders.)</p>

<p style="margin-top: 1em">NOTES</p>

<p style="margin-top: 1em">Normally, the body of a reminder
is followed by a carriage return. Thus, the results of
msgsuffix() will appear on the next line. If you don&rsquo;t
want this, end the body of the <br>
reminder with a percentage sign, &quot;%&quot;. If you want
a space between your reminders, simply include a carriage
return (char(13)) as part of the msgsuffix() return
value.</p>

<p style="margin-top: 1em">If Remind has problems
evaluating msgprefix(), msgsuffix() or sortbanner(), you
will see a lot of error messages. For an example of this,
define the following:</p>

<p style="margin-top: 1em">fset msgprefix(x) x/0</p>

<p style="margin-top: 1em">FOREIGN LANGUAGE SUPPORT <br>
Your version of Remind may have been compiled to support a
language other than English. This support may or may not be
complete - for example, all error and usage messages may
<br>
still be in English. However, at a minimum, foreign-language
versions of Remind will output names of months and weekdays
in the foreign language. Also, the substitution mecha&acirc;
<br>
nism will substitute constructs suitable for the foreign
language rather than for English.</p>

<p style="margin-top: 1em">A foreign-language version of
Remind will accept either the English or foreign-language
names of weekdays and months in a reminder script. However,
for compatibility between <br>
versions of Remind, you should use only the English names in
your scripts. Also, if your C compiler or run-time libraries
are not &quot;8-bit clean&quot; or don&rsquo;t understand
the ISO-Latin <br>
character set, month or day names with accented letters may
not be recognized.</p>

<p style="margin-top: 1em">THE HEBREW CALENDAR <br>
Remind has support for the Hebrew calendar, which is a
luni-solar calendar. This allows you to create reminders for
Jewish holidays, jahrzeits (anniversaries of deaths) and
sma&acirc; <br>
chot (joyous occasions.)</p>

<p style="margin-top: 1em">THE HEBREW YEAR</p>

<p style="margin-top: 1em">The Hebrew year has 12 months,
alternately 30 and 29 days long. The months are: Tishrey,
Heshvan, Kislev, Tevet, Shvat, Adar, Nisan, Iyar, Sivan,
Tamuz, Av and Elul. In Bibli&acirc; <br>
cal times, the year started in Nisan, but Rosh Hashana
(Jewish New Year) is now celebrated on the 1st and 2nd of
Tishrey.</p>

<p style="margin-top: 1em">In a cycle of 19 years, there
are 7 leap years, being years 3, 6, 8, 11, 14, 17 and 19 of
the cycle. In a leap year, an extra month of 30 days is
added before Adar. The two <br>
Adars are called Adar A and Adar B.</p>

<p style="margin-top: 1em">For certain religious reasons,
the year cannot start on a Sunday, Wednesday or Friday. To
adjust for this, a day is taken off Kislev or added to
Heshvan. Thus, a regular year <br>
can have from 353 to 355 days, and a leap year from 383 to
385.</p>

<p style="margin-top: 1em">When Kislev or Heshvan is short,
it is called chaser, or lacking. When it is long, it is
called shalem, or full.</p>

<p style="margin-top: 1em">The Jewish date changes at
sunset. However, Remind will change the date at midnight,
not sunset. So in the period between sunset and midnight,
Remind will be a day earlier than <br>
the true Jewish date. This should not be much of a problem
in practice.</p>

<p style="margin-top: 1em">The computations for the Jewish
calendar were based on the program &quot;hdate&quot; written
by Amos Shapir of the Hebrew University of Jerusalem,
Israel. He also supplied the preceding <br>
explanation of the calendar.</p>

<p style="margin-top: 1em">HEBREW DATE FUNCTIONS</p>

<p style="margin-top: 1em">hebday(d_date) <br>
Returns the day of the Hebrew month corresponding to the
date parameter. For example, 12 April 1993 corresponds to 21
Nisan 5753. Thus, hebday(&rsquo;1993/04/12&rsquo;) returns
21.</p>

<p style="margin-top: 1em">hebmon(d_date) <br>
Returns the name of the Hebrew month corresponding to date.
For example, hebmon(&rsquo;1993/04/12&rsquo;) returns
&quot;Nisan&quot;.</p>

<p style="margin-top: 1em">hebyear(d_date) <br>
Returns the Hebrew year corresponding to date. For example,
hebyear(&rsquo;1993/04/12&rsquo;) returns 5753.</p>

<p style="margin-top: 1em">hebdate(i_day, s_hebmon
[,id_yrstart [,i_jahr [,i_aflag]]]) <br>
The hebdate() function is the most complex of the Hebrew
support functions. It can take from 2 to 5 arguments. It
returns a DATE corresponding to the Hebrew date.</p>

<p style="margin-top: 1em">The day parameter can range from
1 to 30, and specifies the day of the Hebrew month. The
hebmon parameter is a string that must name one of the
Hebrew months specified <br>
above. Note that the month must be spelled out in full, and
use the English transliteration shown previously. You can
also specify &quot;Adar A&quot; and &quot;Adar B.&quot;
Month names <br>
are not case-sensitive.</p>

<p style="margin-top: 1em">The yrstart parameter can either
be a DATE or an INT. If it is a DATE, then the hebdate()
scans for the first Hebrew date on or after that date. For
example:</p>

<p style="margin-top: 1em">hebdate(15, &quot;Nisan&quot;,
&rsquo;1990/01/01&rsquo;)</p>

<p style="margin-top: 1em">returns 1990/03/30, because that
is the first occurrence of 15 Nisan on or after 1 January
1990.</p>

<p style="margin-top: 1em">If yrstart is an INT, it is
interpreted as a Hebrew year. Thus:</p>

<p style="margin-top: 1em">hebdate(22, &quot;Kislev&quot;,
5756)</p>

<p style="margin-top: 1em">returns 1995/12/15, because that
date corresponds to 22 Kislev, 5756. Note that none of the
Hebrew date functions will work with dates outside
Remind&rsquo;s normal range for <br>
dates.</p>

<p style="margin-top: 1em">If yrstart is not supplied, it
defaults to today().</p>

<p style="margin-top: 1em">The jahr modifies the behaviour
of hebdate() as follows:</p>

<p style="margin-top: 1em">If jahr is 0 (the default), then
hebdate() keeps scanning until it finds a date that exactly
satisfies the other parameters. For example:</p>

<p style="margin-top: 1em">hebdate(30, &quot;Adar A&quot;,
1993/01/01)</p>

<p style="margin-top: 1em">returns 1995/03/02,
corresponding to 30 Adar A, 5755, because that is the next
occurrence of 30 Adar A after 1 January, 1993. This
behaviour is appropriate for Purim <br>
Katan, which only appears in leap years.</p>

<p style="margin-top: 1em">If jahr is 1, then the date is
modified as follows:</p>

<p style="margin-top: 1em">o 30 Heshvan is converted to 1
Kislev in years when Heshvan is chaser</p>

<p style="margin-top: 1em">o 30 Kislev is converted to 1
Tevet in years when Kislev is chaser</p>

<p style="margin-top: 1em">o 30 Adar A is converted to 1
Nisan in non-leapyears</p>

<p style="margin-top: 1em">o Other dates in Adar A are
moved to the corresponding day in Adar in non-leapyears</p>

<p style="margin-top: 1em">This behaviour is appropriate
for smachot (joyous occasions) and for some jahrzeits - see
&quot;JAHRZEITS.&quot;</p>

<p style="margin-top: 1em">if jahr is 2, then the date is
modified as follows:</p>

<p style="margin-top: 1em">o 30 Kislev and 30 Heshvan are
converted to 29 Kislev and 29 Heshvan, respectively, if the
month is chaser</p>

<p style="margin-top: 1em">o 30 Adar A is converted to 30
Shvat in non-leapyears</p>

<p style="margin-top: 1em">o Other dates in Adar A are
moved to the corresponding day in Adar in non-leapyears</p>

<p style="margin-top: 1em">if jahr is not 0, 1, or 2, it is
interpreted as a Hebrew year, and the behaviour is
calculated as described in the next section,
&quot;JAHRZEITS.&quot;</p>

<p style="margin-top: 1em">The aflag parameter modifies the
behaviour of the function for dates in Adar during leap
years. The aflag is only used if yrstart is a DATE type.</p>

<p style="margin-top: 1em">The aflag only affects date
calculations if hebmon is specified as &quot;Adar&quot;. In
leap years, the following algorithm is followed:</p>

<p style="margin-top: 1em">o If aflag is 0, then the date
is triggered in Adar B. This is the default.</p>

<p style="margin-top: 1em">o If aflag is 1, then the date
is triggered in Adar A. This may be appropriate for
jahrzeits in the Ashkenazi tradition; consult a rabbi.</p>

<p style="margin-top: 1em">o If aflag is 2, then the date
is triggered in both Adar A and Adar B of a leap year. Some
Ashkenazim perform jahrzeit in both Adar A and Adar B.</p>

<p style="margin-top: 1em">JAHRZEITS</p>

<p style="margin-top: 1em">A jahrzeit is a yearly
commemoration of someone&rsquo;s death. It normally takes
place on the anniversary of the death, but may be delayed if
burial is delayed - consult a rabbi for <br>
more information.</p>

<p style="margin-top: 1em">In addition, because some months
change length, it is not obvious which day the anniversary
of a death is. The following rules are used:</p>

<p style="margin-top: 1em">o If the death occurred on 30
Heshvan, and Heshvan in the year after the death is chaser,
then the jahrzeit is observed on 29 Heshvan in years when
Heshvan is chaser. Oth&acirc; <br>
erwise, the yahrzeit is observed on 1 Kislev when Heshvan is
chaser.</p>

<p style="margin-top: 1em">o If the death occurred on 30
Kislev, and Kislev in the year after the death is chaser,
then the jahrzeit is observed on 29 Kislev in years when
Kislev is chaser. Other&acirc; <br>
wise, the yahrzeit is observed on 1 Tevet when Kislev is
chaser.</p>

<p style="margin-top: 1em">o If the death occurred on 1-29
Adar A, it is observed on 1-29 Adar in non-leapyears.</p>

<p style="margin-top: 1em">o If the death occurred on 30
Adar A, it is observed on 30 Shvat in a non-leapyear.</p>

<p style="margin-top: 1em">Specifying a Hebrew year for the
jahr parameter causes the correct behaviour to be selected
for a death in that year. You may also have to specify
aflag, depending on your tra&acirc; <br>
dition.</p>

<p style="margin-top: 1em">The jahrzeit information was
supplied by Frank Yellin, who quoted &quot;The Comprehensive
Hebrew Calendar&quot; by Arthur Spier, and &quot;Calendrical
Calculations&quot; by E. M. Reingold and Nachum <br>
Dershowitz.</p>

<p style="margin-top: 1em">OUT-OF-BAND REMINDERS <br>
The SPECIAL keyword is used to transmit
&quot;out-of-band&quot; information to Remind backends, such
as tkremind or Rem2PS. They are used only when piping data
from a remind -p line. <br>
(Note that the COLOR special is an exception; it downgrades
to the equivalent of MSG in remind&rsquo;s normal mode of
operation.)</p>

<p style="margin-top: 1em">The various SPECIALs recognized
are particular for each backend; however, there are three
SPECIALs that all backends should attempt to support. They
are currently supported by <br>
Rem2PS, tkremind and rem2html.</p>

<p style="margin-top: 1em">The SHADE special replaces the
psshade() function. Use it like this: <br>
REM Sat Sun SPECIAL SHADE 128 <br>
REM Mon SPECIAL SHADE 255 0 0 <br>
The SHADE keyword is followed by either one or three
numbers, from 0 to 255. If one number is supplied, it is
interpreted as a grey-scale value from black (0) to white
(255). <br>
If three numbers are supplied, they are interpreted as RGB
components from minimum (0) to maximum (255). The example
above shades weekends a fairly dark grey and makes Mondays a
<br>
fully-saturated red. (These shadings appear in calendars
produced by Rem2PS, tkremind and rem2html.)</p>

<p style="margin-top: 1em">The MOON special replaces the
psmoon() function. Use it like this: <br>
REM [moondate(0)] SPECIAL MOON 0 <br>
REM [moondate(1)] SPECIAL MOON 1 <br>
REM [moondate(2)] SPECIAL MOON 2 <br>
REM [moondate(3)] SPECIAL MOON 3 <br>
These draw little moons on the various calendars. The
complete syntax of the MOON special is as follows: <br>
... SPECIAL MOON phase moonsize fontsize msg</p>

<p style="margin-top: 1em">Phase is a number from 0 to 3,
with 0 representing a new moon, 1 the first quarter, 2 a
full moon and 3 the last quarter.</p>

<p style="margin-top: 1em">moonsize is the diameter in
PostScript units of the moon to draw. If omitted or supplied
as -1, the backend chooses an appropriate size.</p>

<p style="margin-top: 1em">fontsize is the font size in
PostScript units of the msg</p>

<p style="margin-top: 1em">Msg is additional text that is
placed near the moon glyph.</p>

<p style="margin-top: 1em">Note that only the Rem2PS
backend supports moonsize and fontsize; the other backends
use fixed sizes.</p>

<p style="margin-top: 1em">The COLOR special lets you place
colored reminders in the calendar. Use it like this:</p>

<p style="margin-top: 1em">REM ... SPECIAL COLOR 255 0 0
This is a bright red reminder <br>
REM ... SPECIAL COLOR 0 128 0 This is a dark green
reminder</p>

<p style="margin-top: 1em">You can spell COLOR either the
American way (&quot;COLOR&quot;) or the British way
(&quot;COLOUR&quot;). This manual will use the American
way.</p>

<p style="margin-top: 1em">Immediately following COLOR
should be three decimal numbers ranging from 0 to 255
specifying red, green and blue intensities, respectively.
The rest of the line is the text to <br>
put in the calendar.</p>

<p style="margin-top: 1em">The COLOR special is
&quot;doubly special&quot;, because in its normal operating
mode, remind treats a COLOR special just like a MSG-type
reminder. Also, if you invoke Remind with -cc..., <br>
then it approximates SPECIAL COLOR reminders on your
terminal.</p>

<p style="margin-top: 1em">The WEEK special lets you place
annotations such as the week number in the calendar. For
example, this would number each Monday with the ISO 8601
week number. The week number <br>
is shown like this: &quot;(Wn)&quot; in this example, but
you can put whatever text you like after the WEEK
keyword.</p>

<p style="margin-top: 1em">REM Monday SPECIAL WEEK
(W[weekno()])</p>

<p style="margin-top: 1em">MISCELLANEOUS <br>
COMMAND ABBREVIATIONS</p>

<p style="margin-top: 1em">The following tokens can be
abbreviated:</p>

<p style="margin-top: 1em">o REM can be omitted - it is
implied if no other valid command is present.</p>

<p style="margin-top: 1em">o CLEAR-OMIT-CONTEXT --&gt;
CLEAR</p>

<p style="margin-top: 1em">o PUSH-OMIT-CONTEXT --&gt;
PUSH</p>

<p style="margin-top: 1em">o POP-OMIT-CONTEXT --&gt;
POP</p>

<p style="margin-top: 1em">o DUMPVARS --&gt; DUMP</p>

<p style="margin-top: 1em">o BANNER --&gt; BAN</p>

<p style="margin-top: 1em">o INCLUDE --&gt; INC</p>

<p style="margin-top: 1em">o SCANFROM --&gt; SCAN</p>

<p style="margin-top: 1em">NIFTY EXAMPLES</p>

<p style="margin-top: 1em">This section is a sampling of
what you can do with Remind.</p>

<p style="margin-top: 1em">REM 5 Feb 1991 AT 14:00 +45 *30
RUN mail -s &quot;Meeting at %2&quot; $LOGNAME &lt;/dev/null
&amp;</p>

<p style="margin-top: 1em">On 5 February, 1991, this
reminder will mail you reminders of a 2:00pm meeting at
1:15, 1:45 and 2:00. The subject of the mail message will be
&quot;Meeting at 2:00pm&quot; and the body <br>
of the message will be blank.</p>

<p style="margin-top: 1em">REM AT 17:00 RUN echo
&quot;5:00pm - GO HOME!&quot; | xless -g +0+0 &amp;</p>

<p style="margin-top: 1em">This reminder will pop up an
xless window at 5:00pm every day. The xless window will
contain the line &quot;5:00pm - GO HOME!&quot;</p>

<p style="margin-top: 1em">REM AT 23:59 RUN (sleep 120;
remind -a [filename()]) &amp;</p>

<p style="margin-top: 1em">This reminder will run at one
minute to midnight. It will cause a new Remind process to
start at one minute past midnight. This allows you to have a
continuous reminder service <br>
so you can work through the night and still get timed
reminders for early in the morning. Note that this trick is
no longer necessary, providing you run Remind in daemon
mode.</p>

<p style="margin-top: 1em">remind -c12 /dev/null Jan
1993</p>

<p style="margin-top: 1em">This invocation of Remind will
cause it to print a calendar for 1993, with all entries left
blank.</p>

<p style="margin-top: 1em">REM CAL
[trigdate()-date(year(trigdate()), 1, 1)+1]</p>

<p style="margin-top: 1em">This example puts an entry in
each box of a calendar showing the number (1-365 or 366) of
the day of the year.</p>

<p style="margin-top: 1em">REM Tue 2 Nov SATISFY
(year(trigdate())%4) == 0 <br>
IF trigvalid() <br>
REM [trigdate()] ++5 MSG U.S. Presidential Election!! <br>
ENDIF</p>

<p style="margin-top: 1em">This example warns you 5 days
ahead of each American presidential election. The first REM
command calculates the first Tuesday after the first Monday
in November. (This is <br>
equivalent to the first Tuesday on or after 2 November.) The
SATISFY clause ensures that the trigger date is issued only
in election years, which are multiples of 4. The second <br>
REM command actually issues the reminder.</p>

<p style="margin-top: 1em">DETAILS ABOUT TRIGGER
COMPUTATION</p>

<p style="margin-top: 1em">Here is a conceptual description
of how triggers are calculated. Note that Remind actually
uses a much more efficient procedure, but the results are
the same as if the concep&acirc; <br>
tual procedure had been followed.</p>

<p style="margin-top: 1em">Remind starts from the current
date (that is, the value of today()) and scans forward,
examining each day one at a time until it finds a date that
satisfies the trigger, or can <br>
prove that no such dates (on or later than today())
exist.</p>

<p style="margin-top: 1em">If Remind is executing a
SATISFY-type reminder, it evaluates the expression with
trigdate() set to the date found above. If the expression
evaluates to zero or the null string, <br>
Remind continues the scanning procedure described above,
starting with the day after the trigger found above.</p>

<p style="margin-top: 1em">The SCANFROM clause (having a
syntax similar to UNTIL) can modify the search strategy
used. In this case, Remind begins the scanning procedure at
scan_date, which is the date <br>
specified in the SCANFROM clause. For example:</p>

<p style="margin-top: 1em">REM Mon 1 SCANFROM 17 Jan 1992
MSG Foo</p>

<p style="margin-top: 1em">The example above will always
have a trigger date of Monday, 3 February 1992. That is
because Remind starts scanning from 17 January 1992, and
stops scanning as soon as it hits <br>
a date that satisfies &quot;Mon 1.&quot;</p>

<p style="margin-top: 1em">The main use of SCANFROM is in
situations where you want to calculate the positions of
floating holidays. Consider the Labour Day example shown
much earlier. Labour Day is the <br>
first Monday in September. It can move over a range of 7
days. Consider the following sequence:</p>

<p style="margin-top: 1em">REM Mon 1 Sept SCANFROM
[today()-7] SATISFY 1 <br>
OMIT [trigdate()]</p>

<p style="margin-top: 1em">REM Mon AFTER MSG Hello</p>

<p style="margin-top: 1em">The SCANFROM clause makes sure
that Remind begins scanning from 7 days before the current
date. This ensures that Labour Day for the current year will
continue to be triggered <br>
until 7 days after it has occurred. This allows you to
safely use the AFTER keyword as shown.</p>

<p style="margin-top: 1em">In general, use SCANFROM as
shown for safe movable OMITs. The amount you should scan
back by (7 days in the example above) depends on the number
of possible consecutive OMITted <br>
days that may occur, and on the range of the movable
holiday. Generally, a value of 7 is safe.</p>

<p style="margin-top: 1em">The FROM clause operates almost
like the counterpoint to UNTIL. It prevents the reminder
from triggering before the FROM date. For example, the
following reminder:</p>

<p style="margin-top: 1em">REM Mon Thu FROM 23 Jul 2007
UNTIL 2 Aug 2007 MSG Test</p>

<p style="margin-top: 1em">will trigger on Mondays and
Thursdays between 23 July 2007 and 2 August 2007
inclusive.</p>

<p style="margin-top: 1em">FROM is really just syntactic
sugar; you could implement the reminder above as
follows:</p>

<p style="margin-top: 1em">REM Mon Thu SCANFROM
[max(today(), &rsquo;2007-07-23&rsquo;)] UNTIL 2 Aug 2007
MSG Test</p>

<p style="margin-top: 1em">but that&rsquo;s a lot harder to
read. Internally, Remind treats FROM exactly as illustrated
using SCANFROM. For that reason, you cannot use both FROM
and SCANFROM.</p>

<p style="margin-top: 1em">Note that if you use one REM
command to calculate a trigger date, perform date
calculations (addition or subtraction, for example) and then
use the modified date in a subsequent <br>
REM command, the results may not be what you intended. This
is because you have circumvented the normal scanning
mechanism. You should try to write REM commands that compute
<br>
trigger dates that can be used unmodified in subsequent REM
commands. The file &quot;defs.rem&quot; that comes with the
Remind distribution contains examples.</p>

<p style="margin-top: 1em">DETAILS ABOUT TRIGVALID()</p>

<p style="margin-top: 1em">The trigvalid() function returns
1 if Remind could find a trigger date for the previous REM
or IFTRIG command. More specifically, it returns 1 if Remind
finds a date not before <br>
the starting date of the scanning that satisfies the
trigger. In addition, there is one special case in which
trigvalid() returns 1 and trigdate() returns a meaningful
result:</p>

<p style="margin-top: 1em">If the REM or IFTRIG command did
not contain an UNTIL clause, and contained all of the day,
month and year components, then Remind will correctly
compute a trigger date, even if <br>
it happens to be before the start of scanning. Note that
this behaviour is not true for versions of Remind prior to
03.00.01.</p>

<p style="margin-top: 1em">AUTHOR <br>
Remind is now supported by Roaring Penguin Software Inc.
(http://www.roaringpenguin.com)</p>

<p style="margin-top: 1em">Dianne Skoll
&lt;dfs@roaringpenguin.com&gt; wrote Remind. The moon code
was copied largely unmodified from &quot;moontool&quot; by
John Walker. The sunrise and sunset functions use ideas from
<br>
programs by Michael Schwartz and Marc T. Kaufman. The Hebrew
calendar support was taken from &quot;hdate&quot; by Amos
Shapir. OS/2 support was done by Darrel Hankerson, Russ
Herman, and <br>
Norman Walsh. The supported foreign languages and their
translators are listed below. Languages marked
&quot;complete&quot; support error messages and usage
instructions in that lan&acirc; <br>
guage; all others only support the substitution filter
mechanism and month/day names.</p>

<p style="margin-top: 1em">German -- Wolfgang Thronicke</p>

<p style="margin-top: 1em">Dutch -- Willem Kasdorp and
Erik-Jan Vens</p>

<p style="margin-top: 1em">Finnish -- Mikko Silvonen
(complete)</p>

<p style="margin-top: 1em">French -- Laurent Duperval
(complete)</p>

<p style="margin-top: 1em">Norwegian -- Trygve Randen</p>

<p style="margin-top: 1em">Danish -- Mogens Lynnerup</p>

<p style="margin-top: 1em">Polish -- Jerzy Sobczyk
(complete)</p>

<p style="margin-top: 1em">Brazilian Portuguese -- Marco
Paganini (complete)</p>

<p style="margin-top: 1em">Italian -- Valerio Aimale</p>

<p style="margin-top: 1em">Romanian -- Liviu Daia</p>

<p style="margin-top: 1em">Spanish -- Rafa Couto</p>

<p style="margin-top: 1em">Icelandic -- Bj&Atilde;&para;rn
Dav&Atilde;&Atilde;&deg;sson</p>

<p style="margin-top: 1em">BUGS <br>
There&rsquo;s no good reason why read-only system variables
are not implemented as functions, or why functions like
version(), etc. are not implemented as read-only system
variables.</p>

<p style="margin-top: 1em">Hebrew dates in Remind change at
midnight instead of sunset.</p>

<p style="margin-top: 1em">Language should be selectable at
run-time, not compile-time. Don&rsquo;t expect this to
happen soon!</p>

<p style="margin-top: 1em">Remind has some built-in limits
(for example, number of global OMITs.)</p>

<p style="margin-top: 1em">BIBLIOGRAPHY <br>
Nachum Dershowitz and Edward M. Reingold, &quot;Calendrical
Calculations&quot;, Software-Practice and Experience, Vol.
20(9), Sept. 1990, pp 899-928.</p>

<p style="margin-top: 1em">L. E. Doggett, Almanac for
computers for the year 1978, Nautical Almanac Office,
USNO.</p>

<p style="margin-top: 1em">Richard Siegel and Michael and
Sharon Strassfeld, The First Jewish Catalog, Jewish
Publication Society of America.</p>

<p style="margin-top: 1em">SEE ALSO <br>
rem, rem2ps, tkremind</p>

<p style="margin-top: 1em">4th Berkeley Distribution 31
August 2008 REMIND(1)</p>
<hr>
</body>
</html>
