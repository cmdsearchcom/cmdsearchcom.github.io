<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:44:26 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>XS(1) General Commands Manual XS(1)</p>

<p style="margin-top: 1em">NAME <br>
xs - extensible shell</p>

<p style="margin-top: 1em">SYNOPSIS <br>
xs [-silevxnpo] [-c command | file] [arguments]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Xs is a command interpreter and programming language which
combines the features of other Unix shells and the features
of a functional programming language such as Scheme. The
<br>
syntax is derived from rc(1). The xs shell is simply an
extension of the es(1) shell in this goal. Xs is intended
for use both as an interactive shell and a programming
lan&acirc; <br>
guage for scripts.</p>

<p style="margin-top: 1em">Xs is an extremely customizable
language. The semantics can be altered radically by
redefining functions that are called to implement internal
operations. This manual page <br>
describes the default, initial configuration. See the
section entitled Hook Functions for details on entry points
which can be redefined to give the shell extended
semantics.</p>

<p style="margin-top: 1em">LANGUAGE <br>
Xs is an interpreter which reads commands and executes them.
The simplest form of command in xs is a sequence of words
separated by white space (space and tab) characters. A <br>
word is either a string or a program fragment (see below).
The first word is the command to be executed; the remaining
words are passed as arguments to that command. If the <br>
first word is a string, it is a interpreted as the name of a
program or shell function to run. If the name is the name of
a shell function, that function is executed. Other&acirc;
<br>
wise, the name is used as the name of an executable file. If
the name begins with /, ./, or ../, then it is used as the
absolute path name of a file; if not, xs looks for an <br>
executable file in the directories named by $path.</p>

<p style="margin-top: 1em">Commands are terminated by
newline or semicolon (;). A command may also be terminated
by an ampersand (&amp;), which causes the command to be run
in the background: the shell does <br>
not wait for the command to finish before continuing
execution. Background processes have an implicit redirection
of /dev/null as their standard input that may be overridden
by <br>
an explicit redirection.</p>

<p style="margin-top: 1em">Quoting <br>
Xs gives several characters special meaning; special
characters automatically terminate words. The following
characters, along with space, tab, and newline, are
special:</p>

<p style="margin-top: 1em"># $ &amp; &Acirc;&acute; ( ) ;
&lt; : = &gt; &nbsp;^ &lsquo; { | }</p>

<p style="margin-top: 1em">The single quote (&rsquo;)
prevents special treatment of any character other than
itself. Any characters between single quotes, including
newlines, backslashes, and control charac&acirc; <br>
ters, are treated as an uninterpreted string. A quote
character itself may be quoted by placing two quotes in a
row. A single quote character is therefore represented by
the <br>
sequence &rsquo;&rsquo;&rsquo;&rsquo;. The empty string is
represented by &rsquo;&rsquo;. Thus:</p>

<p style="margin-top: 1em">echo &rsquo;What&rsquo;&rsquo;s
the plan, Stan?&rsquo;</p>

<p style="margin-top: 1em">prints out</p>

<p style="margin-top: 1em">What&rsquo;s the plan, Stan?</p>

<p style="margin-top: 1em">The backslash ( quotes the
immediately following character, if it is one of the special
characters, except for newline. In addition, xs recognizes
backslash sequences similar <br>
to those used in C strings:</p>

<p style="margin-top: 1em">alert (bell)</p>

<p style="margin-top: 1em">backspace</p>

<p style="margin-top: 1em">\ escape</p>

<p style="margin-top: 1em">form-feed</p>

<p style="margin-top: 1em">newline</p>

<p style="margin-top: 1em">carriage return</p>

<p style="margin-top: 1em">tab</p>

<p style="margin-top: 1em">hexadecimal character nn</p>

<p style="margin-top: 1em">0n octal character nnn</p>

<p style="margin-top: 1em">Comments <br>
The number sign (#) begins a comment in xs. All characters
up to but not including the next newline are ignored.</p>

<p style="margin-top: 1em">Line continuation <br>
A long logical line may be continued over several physical
lines by terminating each line (except the last) with a
backslash (. The backslash-newline sequence is treated as a
<br>
space. Note that line continuation does not work in
comments, where the backslash is treated as part of the
comment, and inside quoted strings, where the backslash and
newline <br>
are quoted.</p>

<p style="margin-top: 1em">Lists <br>
The primary data structure in xs is the list, which is a
sequence of words. Parentheses are used to group lists. The
empty list is represented by (). Lists have no
hierarchi&acirc; <br>
cal structure; a list inside another list is expanded so
that the outer list contains all the elements of the inner
list. (This is the same as perl&rsquo;s &quot;list
interpolation&quot;.) <br>
Thus, the following are all equivalent:</p>

<p style="margin-top: 1em">one two three <br>
(one two three) <br>
((one) () ((two three)))</p>

<p style="margin-top: 1em">Note that the null string,
&rsquo;&rsquo;, and the empty list, (), are two very
different things. Assigning the null string to variable is a
valid operation, but it does not remove its def&acirc; <br>
inition.</p>

<p style="margin-top: 1em">Since lists can span multiple
lines without explicit line continuations, they are ideal
for long commands. For example:</p>

<p style="margin-top: 1em">switch $x error { result 1 }
warning { break } good { echo no problem }</p>

<p style="margin-top: 1em">switch $x ( <br>
error { result 1 } <br>
warning { break } <br>
good { echo no problem } <br>
)</p>

<p style="margin-top: 1em">Finally, note that there are
some uses of parentheses not following ordinary list rules:
in let/local/%closure bindings, and in assignments</p>

<p style="margin-top: 1em">Concatenation <br>
Two lists may be joined by the concatenation operator (^). A
single word is a list of length one, so</p>

<p style="margin-top: 1em">echo foo^bar</p>

<p style="margin-top: 1em">produces the output</p>

<p style="margin-top: 1em">foobar</p>

<p style="margin-top: 1em">For lists of more than one
element, concatenation produces the cross (Cartesian)
product of the elements in both lists:</p>

<p style="margin-top: 1em">echo (a- b- c-)^(1 2)</p>

<p style="margin-top: 1em">produces the output</p>

<p style="margin-top: 1em">a-1 a-2 b-1 b-2 c-1 c-2</p>

<p style="margin-top: 1em">Variables <br>
A list may be assigned to a variable, using the notation</p>

<p style="margin-top: 1em">var = list</p>

<p style="margin-top: 1em">Unfortunately, whitespace is
required around the assignment operator, this allows it to
be treated as a normal string character normally. This is
true also for assignment in <br>
let-forms and the like. Any sequence of non-special
characters, except a sequence including only digits, may be
used as a variable name. Xs exports all user-defined
variables <br>
into the environment unless it is explicitly told not
to.</p>

<p style="margin-top: 1em">The value of a variable is
referenced with the notation:</p>

<p style="margin-top: 1em">$var</p>

<p style="margin-top: 1em">Any variable which has not been
assigned a value returns the empty list when referenced. In
addition, multiple references are allowed:</p>

<p style="margin-top: 1em">a = foo <br>
b = a <br>
echo $$b</p>

<p style="margin-top: 1em">prints</p>

<p style="margin-top: 1em">foo</p>

<p style="margin-top: 1em">A variable&rsquo;s definition
may also be removed by assigning the empty list to a
variable:</p>

<p style="margin-top: 1em">var=</p>

<p style="margin-top: 1em">Multiple variables may be
assigned with a single assignment statment. The left hand
side of the assignment operation consists of a list of
variables which are assigned, one by <br>
one, to the values in the list on the right hand side. If
there are more variables than values in the list, the empty
list is assigned to the remaining variables. If there are
<br>
fewer variables than elements in the list, the last variable
is bound to all the remaining list values.</p>

<p style="margin-top: 1em">For example,</p>

<p style="margin-top: 1em">(a b) = 1 2 3</p>

<p style="margin-top: 1em">has the same effect as</p>

<p style="margin-top: 1em">a = 1 <br>
b = 2 3</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">(a b c) = 1 2</p>

<p style="margin-top: 1em">is the same as</p>

<p style="margin-top: 1em">a = 1 <br>
b = 2 <br>
c =</p>

<p style="margin-top: 1em">Note that when assigning values
to more than one variable, <br>
the list of variables must be enclosed in parentheses.</p>

<p style="margin-top: 1em">For &lsquo;&lsquo;free
careting&rsquo;&rsquo; (see below) to work correctly, <br>
xs <br>
must make certain assumptions <br>
about what characters may appear in a variable name. <br>
Xs <br>
assumes that a variable name consists only of alphanumeric
characters, <br>
percent <br>
(%), <br>
star <br>
(*), <br>
dash <br>
(-), <br>
and underscore <br>
(_). <br>
To reference a variable with other <br>
characters in its name, quote the variable name. <br>
Thus:</p>

<p style="margin-top: 1em">echo
$&rsquo;we$Irdriab!le&rsquo;</p>

<p style="margin-top: 1em">A variable name produced by some
complex operation, such as concatenation, should be enclosed
in parentheses:</p>

<p style="margin-top: 1em">$(var)</p>

<p style="margin-top: 1em">Thus:</p>

<p style="margin-top: 1em">Good-Morning = Bonjour <br>
Guten = Good <br>
Morgen = Morning <br>
echo $($Guten^-^$Morgen)</p>

<p style="margin-top: 1em">prints</p>

<p style="margin-top: 1em">Bonjour</p>

<p style="margin-top: 1em">Each element of the list in
parentheses is treated as an independent variable and
expanded separately. Thus, given the above definitions,</p>

<p style="margin-top: 1em">echo $(Guten Morgen)</p>

<p style="margin-top: 1em">prints</p>

<p style="margin-top: 1em">Good Morning</p>

<p style="margin-top: 1em">To count the number of elements
in a variable, use</p>

<p style="margin-top: 1em">$#var</p>

<p style="margin-top: 1em">This returns a single-element
list with the number of elements in $var.</p>

<p style="margin-top: 1em">Subscripting <br>
Variables may be indexed with the notation</p>

<p style="margin-top: 1em">$var(n)</p>

<p style="margin-top: 1em">where n is a list of integers or
ranges. Subscript indexes are based at one. The list of
subscripts need not be in order or even unique. Thus, if</p>

<p style="margin-top: 1em">a = one two three</p>

<p style="margin-top: 1em">then</p>

<p style="margin-top: 1em">echo $a(3 3 3)</p>

<p style="margin-top: 1em">prints</p>

<p style="margin-top: 1em">three three three</p>

<p style="margin-top: 1em">Subscript indices which refer to
nonexistent elements expand to the empty list. Thus, given
the definition above</p>

<p style="margin-top: 1em">echo $a(3 1 4 1 5 9 2 6 5)</p>

<p style="margin-top: 1em">prints</p>

<p style="margin-top: 1em">three one one two</p>

<p style="margin-top: 1em">Subscript ranges are of the form
lo...hi and refer to all the elements between lo and hi. If
lo is omitted, then 1 is used as a default value; if hi is
omitted, the length of <br>
the list is used. Thus</p>

<p style="margin-top: 1em">* = $*(2 ...)</p>

<p style="margin-top: 1em">removes the first element of *,
similar to the effect of shift in rc(1) or sh(1).</p>

<p style="margin-top: 1em">The notation $n, where n is an
integer, is a shorthand for $*(n). Thus, xs&rsquo;s
arguments may be referred to as $1, $2, and so on.</p>

<p style="margin-top: 1em">Note that the list of subscripts
may be given by any xs expression, so</p>

<p style="margin-top: 1em">$var(&lsquo;{awk
&rsquo;BEGIN{for(i=1;i&lt;=10;i++)print i;exit
}&rsquo;})</p>

<p style="margin-top: 1em">returns the first 10 elements of
$var.</p>

<p style="margin-top: 1em">Free Carets <br>
Xs inserts carets (concatenation operators) for free in
certain situations, in order to save some typing on the
user&rsquo;s behalf. For example, the following are all
equivalent:</p>

<p style="margin-top: 1em">cc -O -g -c malloc.c alloca.c
<br>
cc -^(O g c) (malloc alloca)^.c <br>
opts=O g c; files=malloc alloca; cc -$opts $files.c</p>

<p style="margin-top: 1em">Xs inserts a free-caret between
the &lsquo;&lsquo;-&rsquo;&rsquo; and $opts, as well as
between $files and .c. The rule for free carets is as
follows: if a word or keyword is immediately followed by
<br>
another word, keyword, dollar-sign or backquote without any
intervening spaces, then xs inserts a caret between
them.</p>

<p style="margin-top: 1em">Flattened Lists <br>
To create a single-element list from a multi-element list,
with the components space-separated, use</p>

<p style="margin-top: 1em">$^var</p>

<p style="margin-top: 1em">Flattening is useful when the
normal list concatenation rules need to be bypassed. For
example, to append a single period at the end of $path,
use:</p>

<p style="margin-top: 1em">echo $^path.</p>

<p style="margin-top: 1em">Wildcard Expansion <br>
Xs expands wildcards in filenames if possible. When the
characters *, [ or ? occur in an argument or command, xs
looks at the argument as a pattern for matching against
files. <br>
(Contrary to the behavior some other shells exhibit, xs will
only perform pattern matching if a metacharacter occurs
unquoted and literally in the input. Thus,</p>

<p style="margin-top: 1em">foo = &rsquo;*&rsquo; <br>
echo $foo</p>

<p style="margin-top: 1em">will always echo just a star. In
order for non-literal metacharacters to be expanded, an eval
statement must be used in order to rescan the input.)
Pattern matching occurs <br>
according to the following rules: a * matches any number
(including zero) of characters. A ? matches any single
character, and a [ followed by a number of characters
followed <br>
by a ] matches a single character in that class. The rules
for character class matching are the same as those for
ed(1), with the exception that character class negation is
<br>
achieved with the tilde (~), not the caret (^), since the
caret already means something else in xs. The filename
component separator, slash (/), must appear explicitly in
pat&acirc; <br>
terns. * and ? do not match a dot character (.) at the
beginning of a filename component.</p>

<p style="margin-top: 1em">A tilde (~) as the first
character of an argument is used to refer to home
directories. A tilde alone or followed by a slash (/) is
replaced by the value of $home, which is usu&acirc; <br>
ally the home directory of the current user. A tilde
followed by a username is replaced with the home directory
of that user, according to getpwent(3).</p>

<p style="margin-top: 1em">Pattern Matching <br>
The tilde (~) operator is used in xs for matching strings
against wildcard patterns. The command</p>

<p style="margin-top: 1em">~ subject pattern pattern
...</p>

<p style="margin-top: 1em">returns a true value if and only
if the subject matches any of the patterns. The matching
follows the same rules as wildcard expansion, except that
slashes (/) are not consid&acirc; <br>
ered significant, leading dots (.) do not have to be matched
explicitly, and home directory expansion does not occur.
Thus</p>

<p style="margin-top: 1em">~ foo f*</p>

<p style="margin-top: 1em">returns zero (true), while</p>

<p style="margin-top: 1em">~ (bar baz) f*</p>

<p style="margin-top: 1em">returns one (false). The null
list is matched by the null list, so</p>

<p style="margin-top: 1em">~ $foo ()</p>

<p style="margin-top: 1em">checks to see whether $foo is
empty or not. This may also be achieved by the test</p>

<p style="margin-top: 1em">~ $#foo 0</p>

<p style="margin-top: 1em">Note that inside a ~ command xs
does not match patterns against file names, so it is not
necessary to quote the characters *, [ and ?. However, xs
does expand the subject <br>
against filenames if it contains metacharacters. Thus, the
command</p>

<p style="margin-top: 1em">~ * ?</p>

<p style="margin-top: 1em">returns true if any of the files
in the current directory have a single-character name. Note
that if the ~ command is given a list as its first argument,
then a successful match <br>
against any of the elements of that list will cause ~ to
return true. For example:</p>

<p style="margin-top: 1em">~ (foo goo zoo) z*</p>

<p style="margin-top: 1em">is true.</p>

<p style="margin-top: 1em">Pattern Extraction <br>
The double-tilde (~~) operator is used in xs for extracting
the parts of strings that match patterns. The command</p>

<p style="margin-top: 1em">~~ subject pattern pattern
...</p>

<p style="margin-top: 1em">returns the parts of each
matching subject which correspond to the wildcards.</p>

<p style="margin-top: 1em">Each subject is checked in order
against each pattern; if it matches the pattern, the parts
of the subject which matched each *, ?, or [] character
range are extracted, and pro&acirc; <br>
cessing moves on to the next subject. If the subject does
not match, the next pattern is tried.</p>

<p style="margin-top: 1em">For example, the result of the
extraction operation</p>

<p style="margin-top: 1em">~~ (foo.c foo.x bar.h)
*.[ch]</p>

<p style="margin-top: 1em">is the list (foo c bar h).</p>

<p style="margin-top: 1em">Arithmetic Substitution <br>
A single list element can be formed from an infix
arithmetical expression like so:</p>

<p style="margin-top: 1em">( expression ) <br>
The expression can use any of the <br>
+, -, * and / operators, and use variable substitution of
the form $var. Parentheses can be used in normal infix
fashion for order of evaluation. Numbers can be entered in
<br>
floating-point or integer, but are always decimal.
Calculation rules are similar to C - any operation involving
floats produces a float, any operation with integers
produces an <br>
integer; this includes division, so</p>

<p style="margin-top: 1em">.Cr &quot;echo :(1 / 2)&quot;
<br>
.Cr &quot;echo :(1.0 / 2)&quot; <br>
produce 0 and 0.5 (with trailing zeros) respectively.
Integers will wrap around at the same point as the native
platform&rsquo;s int, and floats at the same point as the
native plat&acirc; <br>
form&rsquo;s double.</p>

<p style="margin-top: 1em">Command Substitution <br>
A list may be formed from the output of a command by using
backquote substitution:</p>

<p style="margin-top: 1em">&lsquo;{ command }</p>

<p style="margin-top: 1em">returns a list formed from the
standard output of the command in braces. The characters
stored in the variable $ifs (for &lsquo;&lsquo;input field
separator&rsquo;&rsquo;) are used to split the output <br>
into list elements. By default, $ifs has the value
space-tab-newline. The braces may be omitted if the command
is a single word. Thus &lsquo;ls may be used instead of
&lsquo;{ls}. This <br>
last feature is useful when defining functions that expand
to useful argument lists. A frequent use is:</p>

<p style="margin-top: 1em">fn src { echo *.[chy] }</p>

<p style="margin-top: 1em">followed by</p>

<p style="margin-top: 1em">wc &lsquo;src</p>

<p style="margin-top: 1em">(This will print out a
word-count of all C and Yacc source files in the current
directory.)</p>

<p style="margin-top: 1em">In order to override the value
of $ifs for a single command substitution, use:</p>

<p style="margin-top: 1em">&lsquo;&lsquo; ifs-list {
command }</p>

<p style="margin-top: 1em">$ifs will be temporarily ignored
and the command&rsquo;s output will be split as specified by
the list following the double backquote. For example:</p>

<p style="margin-top: 1em">&lsquo;&lsquo; :{cat
/etc/passwd}</p>

<p style="margin-top: 1em">splits up /etc/passwd into
fields.</p>

<p style="margin-top: 1em">Return Values <br>
The return value of a command is obtained with the
construct</p>

<p style="margin-top: 1em">&lt;={ command }</p>

<p style="margin-top: 1em">The return value of an external
program is its exit status (which in other shells can be
found in special variables such as $? or $status), as either
a small integer or the name <br>
of signal. Thus</p>

<p style="margin-top: 1em">echo &lt;={test -f /etc/motd}
&lt;={test -w /vmunix} &lt;=a.out</p>

<p style="margin-top: 1em">might produce the output</p>

<p style="margin-top: 1em">0 1 sigsegv+core</p>

<p style="margin-top: 1em">along with any output or error
messages from the programs.</p>

<p style="margin-top: 1em">Xs functions and primitives can
produce &lsquo;&lsquo;rich return values,&rsquo;&rsquo; that
is, arbitrary lists as return values.</p>

<p style="margin-top: 1em">When return values are
interpreted as truth values, an extension of the normal
shell conventions apply. If any element of a list is not
equal to &lsquo;&lsquo;0&rsquo;&rsquo; (or the empty
string), <br>
that list is considered false.</p>

<p style="margin-top: 1em">The return value of an
assignment operation is the assigned value.</p>

<p style="margin-top: 1em">Logical Operators <br>
There are a number of operators in Xs which depend on the
exit status of a command.</p>

<p style="margin-top: 1em">command1 &amp;&amp; command2</p>

<p style="margin-top: 1em">executes the first command and
then executes the second command if and only if the first
command has a &lsquo;&lsquo;true&rsquo;&rsquo; return
value.</p>

<p style="margin-top: 1em">command1 || command2</p>

<p style="margin-top: 1em">executes the first command and
then executes the second command if and only if the first
command has a &lsquo;&lsquo;false&rsquo;&rsquo; return
value.</p>

<p style="margin-top: 1em">! command</p>

<p style="margin-top: 1em">inverts the truth value of the
exit status of a command.</p>

<p style="margin-top: 1em">Input and output <br>
The standard output of a command may be redirected to a file
with</p>

<p style="margin-top: 1em">command &gt; file</p>

<p style="margin-top: 1em">and the standard input may be
taken from a file with</p>

<p style="margin-top: 1em">command &lt; file</p>

<p style="margin-top: 1em">File descriptors other than 0
and 1 may be specified also. For example, to redirect
standard error to a file, use:</p>

<p style="margin-top: 1em">command &gt;[2] file</p>

<p style="margin-top: 1em">In order to duplicate a file
descriptor, use &gt;[n=m]. Thus to redirect both standard
output and standard error to the same file, use</p>

<p style="margin-top: 1em">command &gt; file &gt;[2=1]</p>

<p style="margin-top: 1em">To close a file descriptor that
may be open, use &gt;[n=]. For example, to close file
descriptor 7:</p>

<p style="margin-top: 1em">command &gt;[7=]</p>

<p style="margin-top: 1em">In order to place the output of
a command at the end of an already existing file, use:</p>

<p style="margin-top: 1em">command &gt;&gt; file</p>

<p style="margin-top: 1em">If the file does not exist, then
it is created.</p>

<p style="margin-top: 1em">To open a file for reading and
writing, use the &lt;&gt; redirection operator; for reading
and appending, use &lt;&gt;&gt;. Both of these operators use
file descriptor 0 (standard input) by <br>
default. Similarly, &gt;&lt; truncates a file and opens it
for reading and writing, and &gt;&gt;&lt; opens a file for
reading and appending; these operators use file descriptor 1
by default.</p>

<p style="margin-top: 1em">&lsquo;&lsquo;Here
documents&rsquo;&rsquo; are supported as in sh(1) with the
use of</p>

<p style="margin-top: 1em">command &lt;&lt;
&rsquo;eof-marker&rsquo;</p>

<p style="margin-top: 1em">If the end-of-file marker is
quoted, then no variable substitution occurs inside the here
document. Otherwise, every variable is substituted by its
space-separated-list value <br>
(see Flat Lists, below), and if a ^ character follows a
variable name, it is deleted. This allows the unambiguous
use of variables adjacent to text, as in</p>

<p style="margin-top: 1em">$variable^follow</p>

<p style="margin-top: 1em">To include a literal $ in a here
document created with an unquoted end-of-file marker, use
$$.</p>

<p style="margin-top: 1em">Additionally, xs supports
&lsquo;&lsquo;here strings&rsquo;&rsquo;, which are like
here documents, except that input is taken directly from a
string on the command line. Its use is illustrated here:</p>

<p style="margin-top: 1em">cat &lt;&lt;&lt; &rsquo;this is
a here string&rsquo; | wc</p>

<p style="margin-top: 1em">(This feature enables xs to
export functions that use here documents.)</p>

<p style="margin-top: 1em">Pipes <br>
Two or more commands may be combined in a pipeline by
placing the vertical bar (|) between them. The standard
output (file descriptor 1) of the command on the left is
tied to <br>
the standard input (file descriptor 0) of the command on the
right. The notation |[n=m] indicates that file descriptor n
of the left process is connected to file descriptor m of
<br>
the right process. |[n] is a shorthand for |[n=0]. As an
example, to pipe the standard error of a command to wc(1),
use:</p>

<p style="margin-top: 1em">command |[2] wc</p>

<p style="margin-top: 1em">The exit status of a pipeline is
considered true if and only if every command in the pipeline
exits true.</p>

<p style="margin-top: 1em">Input/Output Substitution <br>
Some commands, like cmp(1) or diff(1), take their input from
named files on the command line, and do not use standard
input. It is convenient sometimes to build nonlinear
pipe&acirc; <br>
lines so that a command like cmp can read the output of two
commands at once. Xs does it like this:</p>

<p style="margin-top: 1em">cmp &lt;{command1}
&lt;{command2}</p>

<p style="margin-top: 1em">compares the output of the two
commands. Note: on some systems, this form of redirection is
implemented with pipes, and since one cannot lseek(2) on a
pipe, commands that use <br>
lseek will hang. For example, most versions of diff seek on
their inputs.</p>

<p style="margin-top: 1em">Data can be sent down a pipe to
several commands using tee(1) and the output version of this
notation:</p>

<p style="margin-top: 1em">echo hi there | tee &gt;{sed
&rsquo;s/^/p1 /&rsquo;} &gt;{sed &rsquo;s/^/p2 /&rsquo;}</p>

<p style="margin-top: 1em">Program Fragments <br>
Xs allows the intermixing of code with strings. A program
fragment, which is a group of commands enclosed in braces ({
and }), may be used anywhere a word is expected, and is <br>
treated as an indivisible unit. For example, a program
fragment may be passed as an argument, stored in a variable,
or written to a file or pipe. If a program fragment appears
<br>
as the first word in a command, it is executed, and any
arguments are ignored. Thus the following all produce the
same output:</p>

<p style="margin-top: 1em">{ echo hello, world } <br>
{ echo hello, world } foo bar <br>
xs -c { echo hello, world } <br>
x = { echo hello, world }; $x <br>
echo { echo hello, world } | xs <br>
echo { echo hello, world } &gt; foo; xs &lt; foo</p>

<p style="margin-top: 1em">Since program fragments in the
first position in a command are executed, braces may be used
as a grouping mechanism for commands. For example, to run
several commands, with out&acirc; <br>
put from all of them redirected to the same file, one can
do</p>

<p style="margin-top: 1em">{ date; ps agux; who } &gt;
snapshot</p>

<p style="margin-top: 1em">In addition, program fragments
can continue across multiple physical lines without explicit
line continuations, so the above command could also be
written:</p>

<p style="margin-top: 1em">{ <br>
date <br>
ps agux <br>
who <br>
} &gt; snapshot</p>

<p style="margin-top: 1em">A lambda is a variant on a
program fragment which takes arguments. A lambda has the
form</p>

<p style="margin-top: 1em">{ | parameters | commands }</p>

<p style="margin-top: 1em">The parameters are one or more
variable names, to which arguments of the lambda are
assigned while the commands are run. The first argument is
assigned to the first variable, <br>
the second to the second, and so on. If there are more
arguments than parameters, the last named variable is
assigned all the remaining arguments; if there are fewer,
the param&acirc; <br>
eters for which there are no arguments are bound to the
empty list.</p>

<p style="margin-top: 1em">Lambdas, like other program
fragments, can appear anywhere in a list. A more complicated
example in the same spirit:</p>

<p style="margin-top: 1em">{ |cmd arg| $cmd $arg } { |*|
echo $* } hi</p>

<p style="margin-top: 1em">This command executes a lambda
which runs its first argument, named cmd, using its second
argument, named arg, as the argument for the first. The
first argument of this function <br>
is another lambda, seen previously, and the second argument
is the word hi.</p>

<p style="margin-top: 1em">These lambda expressions</p>

<p style="margin-top: 1em">{ |a b c| echo $c $b $a } 1 2
<br>
{ |a b c| echo $c $b $a } 1 2 3 4 5</p>

<p style="margin-top: 1em">produce this output:</p>

<p style="margin-top: 1em">2 1 <br>
3 4 5 2 1</p>

<p style="margin-top: 1em">Functions <br>
A function in xs is introduced with the syntax</p>

<p style="margin-top: 1em">fn name parameters { commands
}</p>

<p style="margin-top: 1em">If the function name appears as
the first word of a command, the commands are run, with the
named parameters bound to the arguments to the function.</p>

<p style="margin-top: 1em">The similarity between functions
and lambdas is not coincidental. A function in xs is a
variable of the form fn-name. If name for which the
appropriate fn- variable exists is <br>
found in the first position of a command, the value of the
variable is substituted for the first word. The above syntax
for creating functions is equivalent to the variable <br>
assignment</p>

<p style="margin-top: 1em">fn-name = { | parameters |
commands }</p>

<p style="margin-top: 1em">Functions may be deleted with
the syntax</p>

<p style="margin-top: 1em">fn name</p>

<p style="margin-top: 1em">which is equivalent to the
assignment</p>

<p style="margin-top: 1em">fn-name=</p>

<p style="margin-top: 1em">If, as the most common case, a
function variable is bound to a lambda, when the function is
invoked, the variable $0 is bound (dynamically, see below)
to the name of the func&acirc; <br>
tion.</p>

<p style="margin-top: 1em">Lambdas are just another form of
code fragment, and, as such, can be exported in the
environment, passed as arguments, etc. The central
difference between the two forms is that <br>
lambdas bind their arguments, while simple brace-enclosed
groups just ignore theirs.</p>

<p style="margin-top: 1em">Local Variables <br>
Variable assignments may be made local to a set of commands
with the local construct:</p>

<p style="margin-top: 1em">local (var = value; var = value
...) command</p>

<p style="margin-top: 1em">The command may be a program
fragment, so for example:</p>

<p style="margin-top: 1em">local (path = /bin /usr/bin; ifs
= ) { <br>
... <br>
}</p>

<p style="margin-top: 1em">sets path to a minimal useful
path and removes ifs for the duration of one long compound
command.</p>

<p style="margin-top: 1em">Local-bound variables are
exported into the environment, and will invoke appropriately
named settor functions (see below).</p>

<p style="margin-top: 1em">Lexically Scoped Variables <br>
In addition to local variables, xs supports a different form
of temporary variable binding, using let-bound, or
&lsquo;&lsquo;lexically scoped,&rsquo;&rsquo; variables.
(Lexical scoping is the form of <br>
binding used by most compiled programming languages, such as
C or Scheme.) A lexically scoped variable is introduced with
a let statement:</p>

<p style="margin-top: 1em">let (var = value; var = value
...) command</p>

<p style="margin-top: 1em">(Also, the &quot;= value&quot;
can be left out with same effect as &quot;var =&quot;)</p>

<p style="margin-top: 1em">All references to any of the
variables defined in a let statement by any code located
lexically (that is, textually) within the command portion of
the statement will refer to the <br>
let-bound variable rather than any environment or
local-bound variable; the immediate text of the let
statement is the complete extent of that binding. That is,
lexically bound <br>
variables surrounding code fragments follow those code
fragments around.</p>

<p style="margin-top: 1em">An example best shows the
difference between let and local (also known as
&lsquo;&lsquo;dynamic&rsquo;&rsquo;) binding: (note that
&lsquo;&lsquo;; &rsquo;&rsquo; is xs&rsquo;s default
prompt.)</p>

<p style="margin-top: 1em">; x = foo <br>
; let (x = bar) { <br>
echo $x <br>
fn lexical { echo $x } <br>
} <br>
bar <br>
; local (x = baz) { <br>
echo $x <br>
fn dynamic { echo $x } <br>
} <br>
baz <br>
; lexical <br>
bar <br>
; dynamic <br>
foo <br>
;</p>

<p style="margin-top: 1em">Lexically bound variables are
not exported into the environment, and never cause the
invocation of settor functions. Function (lambda) parameters
are lexically bound to their <br>
values.</p>

<p style="margin-top: 1em">For loops <br>
The command</p>

<p style="margin-top: 1em">for var list { command }</p>

<p style="margin-top: 1em">Runs the command once for each
element of the list, with the named variable bound lexically
to each element of the list, in order. Note that if list
consists of more than a sin&acirc; <br>
gle term, for example (a b c) it must be parenthesized.</p>

<p style="margin-top: 1em">If multiple bindings are given
in the for statement, the looping occurs in parallel and
stops when all lists are exhausted. When one list is
finished before the others, the cor&acirc; <br>
responding variable is bound to the empty list for the
remaining iterations. Thus the loop</p>

<p style="margin-top: 1em">for i (a b c); j (x y) { echo
$#i $i $#j $j}</p>

<p style="margin-top: 1em">produces the output</p>

<p style="margin-top: 1em">1 a 1 x <br>
1 b 1 y <br>
1 c 0</p>

<p style="margin-top: 1em">Settor Functions <br>
A settor function is a variable of the form set-var, which
is typically bound to a lambda. Whenever a value is assigned
to the named variable, the lambda is invoked with its <br>
arguments bound to the new value. While the settor function
is running, the variable $0 is bound to the name of the
variable being assigned. The result of the settor function
<br>
is used as the actual value in the assignment.</p>

<p style="margin-top: 1em">For example, the following
settor function is used to keep the shell variables home and
HOME synchronized.</p>

<p style="margin-top: 1em">set-HOME = { |*| <br>
local (set-home = ) <br>
home = $* <br>
result $* <br>
}</p>

<p style="margin-top: 1em">This settor function is called
when any assignment is made to the variable HOME. It assigns
the new value to the variable home, but disables any settor
function for home to pre&acirc; <br>
vent an infinite recursion. Then it returns its argument
unchanged for use in the actual assignment to HOME.</p>

<p style="margin-top: 1em">Settor functions do not apply to
lexically bound variables.</p>

<p style="margin-top: 1em">Primitives <br>
Primitives are internal xs operations that cannot or should
not (for reasons of performance) be written in the
interpreter&rsquo;s language. The set of primitives makes up
the run- <br>
time library for xs.</p>

<p style="margin-top: 1em">Primitives can be used with the
syntax</p>

<p style="margin-top: 1em">$&amp;name</p>

<p style="margin-top: 1em">A primitive can be used anywhere
a lambda is expected. The list of primitives is returned as
the result of running the primitive $&amp;primitives.</p>

<p style="margin-top: 1em">For details on specific
primitives, see the section entitled PRIMITIVES below.</p>

<p style="margin-top: 1em">Exceptions <br>
Exceptions in xs are used for many forms of non-structured
control flow, notably error reporting, signals, and flow of
control constructs such as escape.</p>

<p style="margin-top: 1em">Exceptions are passed up the
call chain to catching routines. A catcher may decide to
intercept an exception, retry the code that caused the
exception, or pass the exception <br>
along. There can only be one exception raised at any
time.</p>

<p style="margin-top: 1em">Exceptions are represented by
lists. The first word of an exception is, by convention, the
type of exception being raised. The following exceptions are
known:</p>

<p style="margin-top: 1em">eof Raised by %parse when the
end of input is reached.</p>

<p style="margin-top: 1em">error source message <br>
A run-time error. Almost all shell errors are reported with
the error exception. The default interactive loop and the
outermost level of the interpreter catch this <br>
exception and print the message. Source is the name of the
routine (typically a primitive) which raised the error.</p>

<p style="margin-top: 1em">retry When raised from a signal
catcher, causes the body of the catch clause to be run
again.</p>

<p style="margin-top: 1em">signal signame <br>
Raised when the shell itself receives a signal, and the
signal is listed in the variable signals. Signame is the
name of the signal that was raised.</p>

<p style="margin-top: 1em">See the builtin commands catch
and throw for details on how to manipulate exceptions.</p>

<p style="margin-top: 1em">SPECIAL VARIABLES <br>
Several variables are known to xs and are treated specially.
Redefining these variables can change interpreter semantics.
Note that only dynamically bound (top-level or local- <br>
bound) variables are interpreted in this way; the names of
lexically bound variables are unimportant.</p>

<p style="margin-top: 1em">* The argument list of xs. $1,
$2, etc. are the same as $*(1), $*(2), etc.</p>

<p style="margin-top: 1em">$0 Holds the value of argv[0]
with which xs was invoked. Additionally, $0 is set to the
name of a function for the duration of the execution of that
function, and $0 is also <br>
set to the name of the file being interpreted for the
duration of a . command.</p>

<p style="margin-top: 1em">apid The process ID of the last
process started in the background.</p>

<p style="margin-top: 1em">history <br>
The name of a file to which commands are appended as xs
reads them. This facilitates the use of a stand-alone
history program (such as history(1)) which parses the
con&acirc; <br>
tents of the history file and presents them to xs for
reinterpretation. If history is not set (the default), then
xs does not append commands to any file.</p>

<p style="margin-top: 1em">home The current user&rsquo;s
home directory, used in tilde (~) expansion, as the default
directory for the builtin cd command, and as the directory
in which xs looks to find its <br>
initialization file, .esrc, if xs has been started up as a
login shell. Like path and PATH, home and HOME are aliased
to each other.</p>

<p style="margin-top: 1em">ifs The default input field
separator, used for splitting up the output of backquote
commands for digestion as a list. The initial value of ifs
is space-tab-newline.</p>

<p style="margin-top: 1em">noexport <br>
A list of variables which xs will not export. All variables
except for the ones on this list and lexically bound
variables are exported.</p>

<p style="margin-top: 1em">path This is a list of
directories to search in for commands. The empty string
stands for the current directory. Note also that an
assignment to path causes an automatic <br>
assignment to PATH, and vice-versa. If neither path nor PATH
are set at startup time, path assumes a default value
suitable for your system. This is typically /usr/ucb <br>
/usr/bin /bin &rsquo;&rsquo;.</p>

<p style="margin-top: 1em">pid The process ID of the
currently running xs.</p>

<p style="margin-top: 1em">prompt This variable holds the
two prompts (in list form) that xs prints. $prompt(1) is
printed before each command is read, and $prompt(2) is
printed when input is expected to <br>
continue on the next line. (See %parse for details.) xs sets
$prompt to (&rsquo;; &rsquo; &rsquo;&rsquo;) by default. The
reason for this is that it enables an xs user to grab
commands from <br>
previous lines using a mouse, and to present them to xs for
re-interpretation; the semicolon prompt is simply ignored by
xs. The null $prompt(2) also has its justifica&acirc; <br>
tion: an xs script, when typed interactively, will not leave
$prompt(2)&rsquo;s on the screen, and can therefore be
grabbed by a mouse and placed directly into a file for use
<br>
as a shell script, without further editing being
necessary.</p>

<p style="margin-top: 1em">signals <br>
Contains a list of the signals which xs traps. Any signal
name which is added to this list causes that signal to raise
an xs exception. For example, to run some commands <br>
and make sure some cleanup routine is called even if the
user interrupts or disconnects during the script, one can
use the form:</p>

<p style="margin-top: 1em">local (signals = $signals sighup
sigint) { <br>
catch { |e| <br>
cleanup <br>
throw $e <br>
} { <br>
... <br>
} <br>
}</p>

<p style="margin-top: 1em">A signal name prefixed by a
hyphen (-) causes that signal to be ignored by xs and all of
its child processes, unless one of them resets its handler.
A signal prefixed by <br>
a slash (/) is ignored in the current shell, but retains
default behavior in child processes. In addition, the signal
sigint may be preceeded by the prefix (.) to indi&acirc;
<br>
cate that normal shell interrupt processing (i.e., the
printing of an extra newline) occurs. By default xs starts
up with the values</p>

<p style="margin-top: 1em">.sigint /sigquit /sigterm</p>

<p style="margin-top: 1em">in $signals; other values will
be on the list if the shell starts up with some signals
ignored.</p>

<p style="margin-top: 1em">The values of path and home are
derived from the environment values of PATH and HOME if
those values are present. This is for compatibility with
other Unix programs, such as <br>
sh(1). $PATH is assumed to be a colon-separated list.</p>

<p style="margin-top: 1em">SYNTACTIC SUGAR <br>
xs internally rewrites much of the syntax presented thus far
in terms of calls to shell functions. Most features of xs
that resemble traditional shell features are included in
<br>
this category. This rewriting occurs at parse time, as
commands are recognized by the interpreter. The shell
functions that are the results of rewriting are some of the
hook <br>
functions documented below.</p>

<p style="margin-top: 1em">The following tables list all of
the major rewriting which xs does, with the forms typically
entered by the user on the left and their internal form on
the right. There is no <br>
reason for the user to avoid using the right-hand side
forms, except that they are usually less convenient. To see
the internal form of a specific command, a user can run xs
<br>
with the -n and -x options; when invoked in this way, the
shell prints the internal form of its commands rather than
executing them.</p>

<p style="margin-top: 1em">Control Flow <br>
! cmd %not {cmd} <br>
cmd &amp; %background {cmd} <br>
cmd1 ; cmd2 %seq {cmd1} {cmd2} <br>
cmd1 &amp;&amp; cmd2 %and {cmd1} {cmd2} <br>
cmd1 || cmd2 %or {cmd1} {cmd2} <br>
fn name args { cmd } fn-^name = { |args| cmd}</p>

<p style="margin-top: 1em">Input/Output Commands <br>
cmd &lt; file %open 0 file {cmd} <br>
cmd &gt; file %create 1 file {cmd} <br>
cmd &gt;[n] file %create n file {cmd} <br>
cmd &gt;&gt; file %append 1 file {cmd} <br>
cmd &lt;&gt; file %open-write 0 file {cmd} <br>
cmd &lt;&gt;&gt; file %open-append 0 file {cmd} <br>
cmd &gt;&lt; file %open-create 1 file {cmd} <br>
cmd &gt;&gt;&lt; file %open-append 1 file {cmd} <br>
cmd &gt;[n=] %close n {cmd} <br>
cmd &gt;[m=n] %dup m n {cmd} <br>
cmd &lt;&lt; tag input tag %here 0 input {cmd} <br>
cmd &lt;&lt;&lt; string %here 0 string {cmd} <br>
cmd1 | cmd2 %pipe {cmd1} 1 0 {cmd2} <br>
cmd1 |[m=n] cmd2 %pipe {cmd1} m n {cmd2} <br>
cmd1 &gt;{ cmd2 } %writeto var {cmd2} {cmd1 $var} <br>
cmd1 &lt;{ cmd2 } %readfrom var {cmd2} {cmd1 $var}</p>

<p style="margin-top: 1em">Expressions <br>
$#var &lt;={%count $var} <br>
$^var &lt;={%flatten &rsquo; &rsquo; $var} <br>
&lsquo;{cmd args} &lt;={%backquote &lt;={%flatten
&rsquo;&rsquo; $ifs} {cmd args}} <br>
&lsquo;&lsquo;ifs {cmd args} &lt;={%backquote &lt;={%flatten
&rsquo;&rsquo; ifs} {cmd args}}</p>

<p style="margin-top: 1em">BUILTINS <br>
Builtin commands are shell functions that exist at shell
startup time. Most builtins are indistinguishable from
external commands, except that they run in the context of
the <br>
shell itself rather than as a child process. Many builtins
are implemented with primitives (see above).</p>

<p style="margin-top: 1em">Some builtin functions have
names that begin with a percent character (%). These are
commands with some special meaning to the shell, or are
meant for use only by users cus&acirc; <br>
tomizing the shell. (This distinction is somewhat fuzzy, and
the decisions about which functions have %-names are
somewhat arbitrary.)</p>

<p style="margin-top: 1em">All builtins can be redefined
and extended by the user.</p>

<p style="margin-top: 1em">Builtin Commands <br>
. [-einvx] file [args ...] <br>
Reads file as input to xs and executes its contents. The
options are a subset of the invocation options for the shell
(see below).</p>

<p style="margin-top: 1em">access [-n name] [-1e] [-rwx]
[-fdcblsp] path ... <br>
Tests if the named paths are accessible according to the
options presented. Normally, access returns zero (true) for
files which are accessible and a printable error mes&acirc;
<br>
sage (which evaluates as false, according to shell rules)
for files which are not accessible. If the -1 option is
used, the name of the first file which the test succeeds
<br>
for is returned; if the test succeeds for no file, the empty
list is returned. However, if the -e option was used, access
raises an error exception. If the -n option is <br>
used, the pathname arguments are treated as a list of
directories, and the name option argument is used as a file
in those directories (i.e., -n is used for path
search&acirc; <br>
ing).</p>

<p style="margin-top: 1em">The default test is whether a
file exists. These options change the test:</p>

<p style="margin-top: 1em">-r Is the file readable (by the
current user)?</p>

<p style="margin-top: 1em">-w Is the file writable?</p>

<p style="margin-top: 1em">-x Is the file executable?</p>

<p style="margin-top: 1em">-f Is the file a plain file?</p>

<p style="margin-top: 1em">-d Is the file a directory?</p>

<p style="margin-top: 1em">-c Is the file a character
device?</p>

<p style="margin-top: 1em">-b Is the file a block
device?</p>

<p style="margin-top: 1em">-l Is the file a symbolic
link?</p>

<p style="margin-top: 1em">-s Is the file a socket?</p>

<p style="margin-top: 1em">-p Is the file a named pipe
(FIFO)?</p>

<p style="margin-top: 1em">alias alias-name expansion...
<br>
Define a new function, alias-name , which calls expansion
The first command in expansion is replaced with it&rsquo;s
whatis value to prevent recursion. This can be used to <br>
serve a somewhat similar purpose as in bash. For example,
the following will force ls to use color, and make l be ls
in long form, with color (due to previous alias):</p>

<p style="margin-top: 1em">alias ls ls --color=yes <br>
alias l ls -l</p>

<p style="margin-top: 1em">break value <br>
Exits the current loop. Value is used as the return value
for the loop command.</p>

<p style="margin-top: 1em">catch catcher body <br>
Runs body. If it raises an exception, catcher is run and
passed the exception as an argument.</p>

<p style="margin-top: 1em">cd [directory] <br>
Changes the current directory to directory. With no
argument, cd changes the current directory to $home.</p>

<p style="margin-top: 1em">echo [-n] [--] args ... <br>
Prints its arguments to standard output, terminated by a
newline. Arguments are separated by spaces. If the first
argument is -n no final newline is printed. If the <br>
first argument is --, then all other arguments are echoed
literally; this is used for echoing a literal -n.</p>

<p style="margin-top: 1em">escape lambda <br>
Run lambda with one argument, an escape block which when
evaulated will return to the point after this escape. This
is more formally refered to as an escape continuation. <br>
In fact, it&rsquo;s behaviour is a simple subset of
exceptions, and is implemented fairly simply using catch.
Escape is useful to replace return/break like constructs;
for <br>
example</p>

<p style="margin-top: 1em">fn f { escape |fn-return| { <br>
...; return 0; <br>
... <br>
}</p>

<p style="margin-top: 1em">will exit the function with
result 0 when it reached the return.</p>

<p style="margin-top: 1em">eval list <br>
Concatenates the elements of list with spaces and feeds the
resulting string to the interpreter for rescanning and
execution.</p>

<p style="margin-top: 1em">exec cmd <br>
Replaces xs with the given command. If the exec contains
only redirections, then these redirections apply to the
current shell and the shell does not exit. For example,</p>

<p style="margin-top: 1em">exec {&gt;[2] err.out}</p>

<p style="margin-top: 1em">places further output to
standard error in the file err.out. Unlike some other
shells, xs requires that redirections in an exec be enclosed
in a program fragment.</p>

<p style="margin-top: 1em">exit [status] <br>
Causes the current shell to exit with the given exit status.
If no argument is given, zero (true) is used. (This is
different from other shells, that often use the sta&acirc;
<br>
tus of the last command executed.)</p>

<p style="margin-top: 1em">false Always returns a false
(non-zero) return value.</p>

<p style="margin-top: 1em">forever cmd <br>
Runs the command repeatedly, until the shell exits or the
command raises an exception. This is equivalent to a while
{true} {cmd} loop except that forever does not catch <br>
any exceptions, including break.</p>

<p style="margin-top: 1em">fork cmd <br>
Runs a command in a subshell. This insulates the parent
shell from the effects of state changing operations such as
cd and variable assignments. For example:</p>

<p style="margin-top: 1em">fork {cd ..; make}</p>

<p style="margin-top: 1em">runs make(1) in the parent
directory (..), but leaves the shell in the current
directory.</p>

<p style="margin-top: 1em">if [test then-action] [else
else-action] <br>
Evaluates the command test. If the result is true, the
command then is run and if completes. If the result of the
test is false, the else command is run. The else- <br>
action doesn&rsquo;t require braces no matter the number of
actions, so one can write code like:</p>

<p style="margin-top: 1em">... } else if {~ $a $b} { ... }
<br>
Note that:</p>

<p style="margin-top: 1em">...} <br>
else if {~ $a $b} { ... } <br>
, with the else on a seperate line, will only work if the
if-command has parentheses wrapping it&rsquo;s body and
else-statements.</p>

<p style="margin-top: 1em">limit [-h] [resource [value]]
<br>
Similar to the csh(1) limit builtin, this command operates
upon the resource limits of a process. With no arguments,
limit prints all the current limits; with one argu&acirc;
<br>
ment, limit prints the named limit; with two arguments, it
sets the named limit to the given value. The -h flag
displays/alters the hard limits. The resources which can
<br>
be shown or altered are cputime, filesize, datasize,
stacksize, coredumpsize and memoryuse. For example:</p>

<p style="margin-top: 1em">limit coredumpsize 0</p>

<p style="margin-top: 1em">disables core dumps.</p>

<p style="margin-top: 1em">The limit values must either be
the word &lsquo;&lsquo;unlimited&rsquo;&rsquo; or a number
with an optional suffix indicating units. For size limits,
the suffixes k (kilobytes), m (megabytes), <br>
and g (gigabytes) are recognized. For time limits, s
(seconds), m (minutes), and h (hours) are known; in
addition, times of the form hh:mm:ss and mm:ss are accepted.
See <br>
getrlimit(2) for details on resource limit semantics.</p>

<p style="margin-top: 1em">map action list <br>
Call action with a single argument for each element of list.
Since lists auto-expand, list contains the rest of the
arguments to the command. Returns the list of results <br>
of each action. If action returns a list, it is expanded
inside into a new process group. This builtin is useful for
making xs behave like a job-control shell in a hos&acirc;
<br>
tile environment. One example is the NeXT Terminal program,
which implicitly assumes that each shell it forks will put
itself into a new process group. Note that the <br>
controlling tty for the process must be on standard error
(file descriptor 2) when this operation is run.</p>

<p style="margin-top: 1em">omap action list <br>
Like map , but return the list of the outputs of action, in
the same form as if &lsquo;&lsquo; &rsquo;&rsquo; action
were called.</p>

<p style="margin-top: 1em">popd cd into the directory that
was last pushed by pushd , popping the directory off of an
internal stack. If it&rsquo;s internal stack is empty (for
example, if pushd has not been <br>
called), then stays in the current directory. Also prints
out the stack, starting from the top.</p>

<p style="margin-top: 1em">pushd [dir] <br>
Add directory&rsquo;s absolute path onto popd &rsquo;s
stack. Also outputs the stack.</p>

<p style="margin-top: 1em">result value ... <br>
Returns its arguments. This is xs&rsquo;s identity
function.</p>

<p style="margin-top: 1em">switch value [case1
action1]...[default-action] <br>
Go through the list of cases, testing if they are equal to
value. The matching action of the first case which matches
is executed. The break exception can be used to <br>
manually exit the switch, but is not necessary to signify
the end of an action (unlike in C).</p>

<p style="margin-top: 1em">until test body <br>
Identical to while, except test is negated</p>

<p style="margin-top: 1em">throw exception arg ... <br>
Raise the named exception, passing all of the arguments to
throw to the enclosing exception handler.</p>

<p style="margin-top: 1em">time cmd arg ... <br>
Prints, on the shell&rsquo;s standard error, the real, user,
and system time consumed by executing the command.</p>

<p style="margin-top: 1em">true Always returns a true
(zero) return value.</p>

<p style="margin-top: 1em">umask [mask] <br>
Sets the current umask (see umask(2)) to the octal mask. If
no argument is present, the current mask value is
printed.</p>

<p style="margin-top: 1em">unwind-protect body cleanup <br>
Runs body and, when it completes or raises an exception,
runs cleanup.</p>

<p style="margin-top: 1em">var var ... <br>
Prints definitions of the named variables, suitable for
being used as input to the shell.</p>

<p style="margin-top: 1em">vars [-vfs] [-epi] <br>
Prints all shell variables, functions, and settor functions
(in a form suitable for use as shell input), which match the
criteria specified by the options.</p>

<p style="margin-top: 1em">-v variables (that are not
functions or settor functions)</p>

<p style="margin-top: 1em">-f functions</p>

<p style="margin-top: 1em">-s settor functions</p>

<p style="margin-top: 1em">-e exported values</p>

<p style="margin-top: 1em">-p private (not exported)
values</p>

<p style="margin-top: 1em">-i internal (predefined and
builtin) values</p>

<p style="margin-top: 1em">-a all of the above</p>

<p style="margin-top: 1em">If none of -v, -f, or -s are
specified, -v is used. If none of -e, -p, or -i are
specified, -e is used.</p>

<p style="margin-top: 1em">wait [pid] <br>
Waits for the specified pid, which must have been started by
xs. If no pid is specified, waits for any child process to
exit.</p>

<p style="margin-top: 1em">whatis progam ... <br>
For each named program, prints the pathname, primitive,
lambda, or code fragment which would be run if the program
appeared as the first word of a command.</p>

<p style="margin-top: 1em">while test body <br>
Evaluates the test and, if it is true, runs the body and
repeats.</p>

<p style="margin-top: 1em">%read Reads from standard input
and returns either the empty list (in the case of
end-of-file) or a single element string with up to one line
of data, including possible redi&acirc; <br>
rections. This function reads one character at a time in
order to not read more data out of a pipe than it should.
The terminating newline (if present) is not included <br>
in the returned string.</p>

<p style="margin-top: 1em">Hook Functions <br>
A subset of the %-named functions are known as
&lsquo;&lsquo;hook functions.&rsquo;&rsquo; The hook
functions are called to implement some internal shell
operations, and are available as functions in <br>
order that their values can be changed. Typically, a call to
a hook function is from code generated by the syntactic
sugar rewritings.</p>

<p style="margin-top: 1em">%and cmd ... <br>
Runs the commands in order, stopping after the first one
that has a false return value. Returns the result of the
last command run.</p>

<p style="margin-top: 1em">%append fd file cmd <br>
Runs the command with file descriptor fd set up to append to
the file.</p>

<p style="margin-top: 1em">%background cmd <br>
Runs the command in the background. The shell variable apid
contains the process ID of the background process, which is
printed if the shell is interactive (according to <br>
%is-interactive).</p>

<p style="margin-top: 1em">%backquote separator cmd <br>
Runs the command in a child process and returns its standard
output as a list, separated (with the same rules used in
%split) into elements according to separator.</p>

<p style="margin-top: 1em">%batch-loop <br>
Parses commands from the current input source and passes the
commands to the function %dispatch, which is usually a
dynamically bound identifier. This function catches <br>
the exception eof which causes it to return. This function
is invoked by the shell on startup and from the dot (.) and
eval commands, when the input source is not inter&acirc;
<br>
active. (See also %interactive-loop.)</p>

<p style="margin-top: 1em">%close fd cmd <br>
Runs the command with the given file descriptor closed.</p>

<p style="margin-top: 1em">%count list <br>
Returns the number of arguments to the primitive.</p>

<p style="margin-top: 1em">%create fd file cmd <br>
Runs the command with file descriptor fd set up to write to
the file.</p>

<p style="margin-top: 1em">%dup newfd oldfd cmd <br>
Runs the command with the file descriptor oldfd copied (via
dup(2)) to file descriptor newfd.</p>

<p style="margin-top: 1em">%eval-noprint cmd <br>
Run the command. (Passed as the argument to %batch-loop and
%interactive-loop.)</p>

<p style="margin-top: 1em">%eval-print cmd <br>
Print and run the command. (Passed as the argument to
%batch-loop and %interactive-loop when the -x option is
used.)</p>

<p style="margin-top: 1em">%exec-failure file argv0 args
... <br>
This function, if it exists, is called in the context of a
child process if an executable file was found but execve(2)
could not run it. If the function returns, an error <br>
message is printed and the shell exits, but the function can
exec a program if it thinks it knows what to do. Note that
the name of the program appears twice in the argu&acirc;
<br>
ments to %exec-failure, once as a filename and once as the
first element of the argv array; in some cases the two will
be identical, but in others the former will be a <br>
full pathname and the latter will just be the basename. Some
versions of xs may provide a builtin version of this
function to handle #!-style shell scripts if the kernel <br>
does not.</p>

<p style="margin-top: 1em">%exit-on-false cmd <br>
Runs the command, and exits if any command (except those
executing as the tests of conditional statements) returns a
non-zero status. (This function is used as an argu&acirc;
<br>
ment to %batch-loop and %interactive-loop when the shell is
invoked with the -e option.)</p>

<p style="margin-top: 1em">%flatten separator list <br>
Concatenate the elements of list into one string, separated
by the string separator.</p>

<p style="margin-top: 1em">%here fd word ... cmd <br>
Runs the command with the words passed as input on file
descriptor fd.</p>

<p style="margin-top: 1em">%home [user] <br>
Returns the home directory of the named user, or $home if
there are no arguments.</p>

<p style="margin-top: 1em">%interactive-loop <br>
Prompts, parses commands from the current input source and
passes the commands to the function %dispatch, which is
usually a dynamically bound identifier. This function <br>
catches the exception eof which causes it to return. This
function is invoked by the shell on startup and from the dot
(.) commands, when the input source is interac&acirc; <br>
tive. (See also %batch-loop.)</p>

<p style="margin-top: 1em">%noeval-noprint cmd <br>
Do nothing. (Passed as the argument to %batch-loop and
%interactive-loop when the -n option is used.)</p>

<p style="margin-top: 1em">%noeval-print cmd <br>
Print but don&rsquo;t run the command. (Passed as the
argument to %batch-loop and %interactive-loop when the -x
and -n options are used.)</p>

<p style="margin-top: 1em">%not cmd <br>
Runs the command and returns false if its exit status was
true, otherwise returns true.</p>

<p style="margin-top: 1em">%one list <br>
If list is one element long, %one returns its value;
otherwise it raises an exception. %one is used to ensure
that redirection operations get passed exactly one
filename.</p>

<p style="margin-top: 1em">%open fd file cmd <br>
Runs the command with file open for reading on file
descriptor fd.</p>

<p style="margin-top: 1em">%open-append fd file cmd <br>
Runs the command with file open for reading and appending on
file descriptor fd.</p>

<p style="margin-top: 1em">%open-create fd file cmd <br>
Runs the command with file open for reading and writing on
file descriptor fd. If the file already exists, it is
truncated.</p>

<p style="margin-top: 1em">%open-write fd file cmd <br>
Runs the command with file open for reading and writing on
file descriptor fd.</p>

<p style="margin-top: 1em">%openfile mode fd file cmd <br>
Runs the command with file opened according to mode on file
descriptor fd. The modes (r, w, a, r+, w+, and a+) have the
same meanings in %openfile as they do in fopen(3). <br>
%openfile is invoked by the redirection hook functions:
%append, %create, %open, %open-append, %open-create, and
%open-write.</p>

<p style="margin-top: 1em">%or cmd ... <br>
Runs the commands in order, stopping after the first one
that has a true return value. Returns the result of the last
command run.</p>

<p style="margin-top: 1em">%parse prompt1 prompt2 <br>
Reads input from the current input source, printing prompt1
before reading anything and prompt2 before reading continued
lines. Returns a code fragment suitable for exe&acirc; <br>
cution. Raises the exception eof on end of input.</p>

<p style="margin-top: 1em">%pathsearch program <br>
Looks for an executable file named program in the
directories listed in $path. If such a file is found, it is
returned; if one is not found, an error exception is
raised.</p>

<p style="margin-top: 1em">%pipe cmd [outfd infd cmd] ...
<br>
Runs the commands, with the file descriptor outfd in the
left-hand process connected by a pipe to the file descriptor
infd in the right-hand process. If there are more <br>
than two commands, a multi-stage pipeline is created.</p>

<p style="margin-top: 1em">%prompt <br>
Called by %interactive-loop before every call to %parse.
This function allows the user to provide any actions that he
or she may wish to have executed before being <br>
prompted (e.g., updating the value of the prompt variable to
contain all or part of the current working directory).</p>

<p style="margin-top: 1em">%readfrom var input cmd <br>
Runs cmd with the variable var locally bound to the name of
a file which contains the output of running the command
input.</p>

<p style="margin-top: 1em">%seq cmd ... <br>
Runs the commands, in order.</p>

<p style="margin-top: 1em">%whatis program ... <br>
For each named program, returns the pathname, primitive,
lambda, or code fragment which would be run if the program
appeared as the first word of a command.</p>

<p style="margin-top: 1em">%writeto var output cmd <br>
Runs cmd with the variable var locally bound to the name of
a file which is used as the input for the command
output.</p>

<p style="margin-top: 1em">Utility Functions <br>
These functions are useful for people customizing the shell,
may be used by other builtin commands, and probably
don&rsquo;t make much sense to replace, though that is
always possible.</p>

<p style="margin-top: 1em">%apids Returns the process IDs
of all background processes that the shell has not yet
waited for.</p>

<p style="margin-top: 1em">%fsplit separator [args ...]
<br>
Splits its arguments into separate strings at every
occurrence of any of the characters in the string separator.
Repeated instances of separator characters cause null <br>
strings to appear in the result. (This function is used by
some builtin settor functions.)</p>

<p style="margin-top: 1em">%is-interactive <br>
Returns true if the current interpreter context is
interactive; that is, if shell command input is currently
coming from an interactive user. More precisely, this is
true <br>
if the innermost enclosing read-eval-print loop is
%interactive-loop rather than %batch-loop.</p>

<p style="margin-top: 1em">%newfd Returns a file descriptor
that the shell thinks is not currently in use.</p>

<p style="margin-top: 1em">%run program argv0 args ... <br>
Run the named program, which is not searched for in $path,
with the argument vector set to the remaining arguments.
This builtin can be used to set argv[0] (by conven&acirc;
<br>
tion, the name of the program) to something other than file
name.</p>

<p style="margin-top: 1em">%split separator [args ...] <br>
Splits its arguments into separate strings at every
occurrence of any of the characters in the string separator.
Repeated instances of separator characters are coalesced.
<br>
Backquote substitution splits with the same rules.</p>

<p style="margin-top: 1em">%var var ... <br>
For each named variable, returns a string which, if
interpreted by xs would assign to the variable its current
value.</p>

<p style="margin-top: 1em">PRIMITIVES <br>
Primitives exist in xs so that, in the presence of spoofing
and redefinitions, there is a way to refer to built-in
behaviors. This ability is necessary for the shell to be
able <br>
to unambiguously refer to itself, but is also useful for
users who have otherwise made their environment unnecessary
but don&rsquo;t want to kill the current shell.</p>

<p style="margin-top: 1em">Primitives are referenced with
the</p>

<p style="margin-top: 1em">$&amp;name</p>

<p style="margin-top: 1em">notation. In this section, the
&lsquo;&lsquo;$&amp;&rsquo;&rsquo; prefixes will be omitted
when primitive names are mentioned. Note that, by
convention, primitive names follow C identifier names where
xs <br>
variable and function names often contain
&lsquo;&lsquo;%&rsquo;&rsquo; and
&lsquo;&lsquo;-&rsquo;&rsquo; characters.</p>

<p style="margin-top: 1em">The following primitives
directly implement the builtin functions with the same
names:</p>

<p style="margin-top: 1em">access forever throw <br>
catch fork umask <br>
echo if wait <br>
exec newpgrp <br>
exit result</p>

<p style="margin-top: 1em">In addition, the primitive dot
implements the &lsquo;&lsquo;.&rsquo;&rsquo; builtin
function.</p>

<p style="margin-top: 1em">The cd primitive is used in the
implementation of the cd builtin, but does not understand no
arguments to imply $home. The vars and internals primitives
are used by the imple&acirc; <br>
mentation of the vars builtin.</p>

<p style="margin-top: 1em">The following primitives
implement the hook functions of the same names, with
&lsquo;&lsquo;%&rsquo;&rsquo; prefixes:</p>

<p style="margin-top: 1em">apids here read <br>
close home run <br>
count newfd seq <br>
dup openfile split <br>
flatten parse var <br>
fsplit pipe whatis</p>

<p style="margin-top: 1em">The following primitives
implement the similar named hook functions, with
&lsquo;&lsquo;%&rsquo;&rsquo; prefixes and internal
hyphens:</p>

<p style="margin-top: 1em">batchloop exitonfalse
isinteractive</p>

<p style="margin-top: 1em">The background primitive is used
to implement the %background hook function, but does not
print the process ID of the background process or set $apid.
The backquote primitive is <br>
used to implement the %backquote hook function, but returns
the exit status of the child as the first value of its
result instead of setting $bqstatus to it.</p>

<p style="margin-top: 1em">The following primitives
implement the similarly named settor functions:</p>

<p style="margin-top: 1em">sethistory setnoexport
setsignals</p>

<p style="margin-top: 1em">Some primitives are included in
xs conditionally, based on compile-time configuration
options. Those primitives, and the functions to which they
are bound, are</p>

<p style="margin-top: 1em">execfailure %exec-failure <br>
limit limit <br>
readfrom %readfrom <br>
time time <br>
writeto %writeto</p>

<p style="margin-top: 1em">The primitive resetterminal is
if xs is compiled with support for the readline or editline
libraries. It is used in the implementation of settor
functions of the TERM and TERM&acirc; <br>
CAP variables to notify the line editing packages that the
terminal configuration has changed.</p>

<p style="margin-top: 1em">Several primitives are not
directly associated with other function. They are:</p>

<p style="margin-top: 1em">$&amp;collect <br>
Invokes the garbage collector. The garbage collector in xs
runs rather frequently; there should be no reason for a user
to issue this command.</p>

<p style="margin-top: 1em">$&amp;noreturn lambda args ...
<br>
Call the lambda, but in such a way that it does not catch
the return exception. This primitive exists in order that
some control-flow operations in xs (e.g., while and <br>
&amp;&amp;) can be implemented as lambdas rather than
primitives.</p>

<p style="margin-top: 1em">$&amp;primitives <br>
Returns a list of the names of xs primitives.</p>

<p style="margin-top: 1em">$&amp;version <br>
Returns the current version number and release date for
xs.</p>

<p style="margin-top: 1em">OPTIONS <br>
-c Run the given command, placing the rest of the arguments
to xs in $*.</p>

<p style="margin-top: 1em">-s Read commands from standard
input; i.e., put the first argument to xs in $* rather than
using it as the name of a file to source.</p>

<p style="margin-top: 1em">-i Force xs to be an interactive
shell. Normally xs is only interactive if it is run with
commands coming from standard input and standard input is
connected to a terminal.</p>

<p style="margin-top: 1em">-l Run $home/.esrc on startup,
i.e., be a login shell. -l is implied if the name the shell
was run under (that is, argv[0]) starts with a dash (-).</p>

<p style="margin-top: 1em">-e Exit if any command (except
those executing as the tests of conditional statements)
returns a non-zero status.</p>

<p style="margin-top: 1em">-v Echo all input to standard
error.</p>

<p style="margin-top: 1em">Exit if any command (except
those executing as the tests of <br>
conditional statements) returns a non-zero status.</p>

<p style="margin-top: 1em">-v Echo all input to standard
error.</p>

<p style="margin-top: 1em">-x Print commands to standard
error before executing them.</p>

<p style="margin-top: 1em">-n Turn off execution of
commands. This can be used for checking the syntax of
scripts. When combined with -x, xs prints the entered
command based on the internal (parsed) <br>
representation.</p>

<p style="margin-top: 1em">-p Don&rsquo;t initialize
functions from the environment. This is used to help make
scripts that don&rsquo;t break unexpectedly when the
environment contains functions that would over&acirc; <br>
ride commands used in the script.</p>

<p style="margin-top: 1em">-o Don&rsquo;t open /dev/null on
file descriptors 0, 1, and 2, if any of those descriptors
are inherited closed.</p>

<p style="margin-top: 1em">-d Don&rsquo;t trap SIGQUIT or
SIGTERM. This is used for debugging.</p>

<p style="margin-top: 1em">MISC NOTES <br>
As with any other shell scripting language, process forking
takes up the majority of time:</p>

<p style="margin-top: 1em">x = 0; while {!~ $x 4000} { x =
:(x + 1) } <br>
is several magnitudes faster than:</p>

<p style="margin-top: 1em">x = 0; while {test $x -ne 4000}
{ x = :(x + 1) } <br>
Even though xs&rsquo;s arithmetic code is rather slow, in
this case the cost of fork+exec far outweighs it.</p>

<p style="margin-top: 1em">Elaborate tricks involving
stringifying closures and unstringying them later will
probably not work. In general, trying to manipulate the
scope of variables through similar tech&acirc; <br>
niques will probably not do what one expects.</p>

<p style="margin-top: 1em">FILES <br>
$home/.xsrc, /dev/null</p>

<p style="margin-top: 1em">BUGS <br>
The interpreter should be properly tail recursive; that is,
tail calls should not consume stack space.</p>

<p style="margin-top: 1em">break and return should have
lexical scope.</p>

<p style="margin-top: 1em">Woe betide the environment
string set by some other program to contain either the
character control-a or the sequence control-b followed by
control-a or control-b.</p>

<p style="margin-top: 1em">-x is not nearly as useful as it
should be.</p>

<p style="margin-top: 1em">Too many creatures have fept
in.</p>

<p style="margin-top: 1em">Please send bug reports to
fkfire@gmail.com.</p>

<p style="margin-top: 1em">SEE ALSO <br>
history(1), es(1), rc(1), sh(1), execve(2), getrlimit(2),
fopen(3), getpwent(3)</p>

<p style="margin-top: 1em">Paul Haahr and Byron Rakitzis,
Es &acirc; A shell with higher-order functions, Proceedings
of the Winter 1993 Usenix Conference, San Diego, CA.</p>

<p style="margin-top: 1em">Tom Duff, Rc &acirc; A Shell for
Plan 9 and UNIX Systems, Unix Research System, 10th Edition,
Volume 2. (Saunders College Publishing)</p>

<p style="margin-top: 1em">5 March 1992 XS(1)</p>
<hr>
</body>
</html>
