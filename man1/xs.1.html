<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>XS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XS(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">XS(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
xs - extensible shell
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>xs</b> [<b>-silevxnpo</b>] [<b>-c</b> <i>command</i> | <i>file</i>]
  [<i>arguments</i>]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>Xs</i> is a command interpreter and programming language which combines the
  features of other Unix shells and the features of a functional programming
  language such as Scheme. The syntax is derived from <i>rc</i>(1). The xs shell
  is simply an extension of the <i>es</i>(1) shell in this goal. <i>Xs</i> is
  intended for use both as an interactive shell and a programming language for
  scripts.
<div class="Pp"></div>
<i>Xs</i> is an extremely customizable language. The semantics can be altered
  radically by redefining functions that are called to implement internal
  operations. This manual page describes the default, initial configuration. See
  the section entitled <b>Hook Functions</b> for details on entry points which
  can be redefined to give the shell extended semantics.
<h1 class="Sh" title="Sh" id="LANGUAGE"><a class="selflink" href="#LANGUAGE">LANGUAGE</a></h1>
<i>Xs</i> is an interpreter which reads commands and executes them. The simplest
  form of command in <i>xs</i> is a sequence of words separated by white space
  (space and tab) characters. A word is either a string or a program fragment
  (see below). The first word is the command to be executed; the remaining words
  are passed as arguments to that command. If the first word is a string, it is
  a interpreted as the name of a program or shell function to run. If the name
  is the name of a shell function, that function is executed. Otherwise, the
  name is used as the name of an executable file. If the name begins with /, ./,
  or ../, then it is used as the absolute path name of a file; if not, <i>xs</i>
  looks for an executable file in the directories named by $path.
<div class="Pp"></div>
Commands are terminated by newline or semicolon (;). A command may also be
  terminated by an ampersand (&amp;), which causes the command to be run in the
  background: the shell does not wait for the command to finish before
  continuing execution. Background processes have an implicit redirection of
  /dev/null as their standard input that may be overridden by an explicit
  redirection.
<h2 class="Ss" title="Ss" id="Quoting"><a class="selflink" href="#Quoting">Quoting</a></h2>
<i>Xs</i> gives several characters special meaning; special characters
  automatically terminate words. The following characters, along with space,
  tab, and newline, are special:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
# $ &amp; &#x00B4; ( ) ; &lt; : = &gt; \ ^ ` { | }
</pre>
<br/>
<div class="Pp"></div>
The single quote (') prevents special treatment of any character other than
  itself. Any characters between single quotes, including newlines, backslashes,
  and control characters, are treated as an uninterpreted string. A quote
  character itself may be quoted by placing two quotes in a row. A single quote
  character is therefore represented by the sequence ''''. The empty string is
  represented by ''. Thus:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo 'What''s the plan, Stan?'
</pre>
<br/>
<div class="Pp"></div>
prints out
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
What's the plan, Stan?
</pre>
<br/>
<div class="Pp"></div>
The backslash (\) quotes the immediately following character, if it is one of
  the special characters, except for newline. In addition, <i>xs</i> recognizes
  backslash sequences similar to those used in C strings:
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">\a</dt>
  <dd class="It-tag">alert (bell)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\b</dt>
  <dd class="It-tag">backspace</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\e</dt>
  <dd class="It-tag">escape</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\f</dt>
  <dd class="It-tag">form-feed</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\n</dt>
  <dd class="It-tag">newline</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\r</dt>
  <dd class="It-tag">carriage return</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\t</dt>
  <dd class="It-tag">tab</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\x<i>nn</i></dt>
  <dd class="It-tag">hexadecimal character <i>nn</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">\<i>nnn</i></dt>
  <dd class="It-tag">octal character <i>nnn</i></dd>
</dl>
</div>
<h2 class="Ss" title="Ss" id="Comments"><a class="selflink" href="#Comments">Comments</a></h2>
The number sign (#) begins a comment in <i>xs</i>. All characters up to but not
  including the next newline are ignored.
<h2 class="Ss" title="Ss" id="Line_continuation"><a class="selflink" href="#Line_continuation">Line
  continuation</a></h2>
A long logical line may be continued over several physical lines by terminating
  each line (except the last) with a backslash (\). The backslash-newline
  sequence is treated as a space. Note that line continuation does not work in
  comments, where the backslash is treated as part of the comment, and inside
  quoted strings, where the backslash and newline are quoted.
<h2 class="Ss" title="Ss" id="Lists"><a class="selflink" href="#Lists">Lists</a></h2>
The primary data structure in <i>xs</i> is the list, which is a sequence of
  words. Parentheses are used to group lists. The empty list is represented by
  (). Lists have no hierarchical structure; a list inside another list is
  expanded so that the outer list contains all the elements of the inner list.
  (This is the same as perl's &quot;list interpolation&quot;.) Thus, the
  following are all equivalent:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
one two three
(one two three)
((one) () ((two three)))
</pre>
<br/>
<div class="Pp"></div>
Note that the null string, '', and the empty list, (), are two very different
  things. Assigning the null string to variable is a valid operation, but it
  does not remove its definition.
<div class="Pp"></div>
Since lists can span multiple lines without explicit line continuations, they
  are ideal for long commands. For example:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
switch $x \
   error   { result 1 } \
   warning { break } \
   good    { echo no problem  }
</pre>
<br/>
<div class="Pp"></div>
<br/>
<pre>
switch $x (
   error   { result 1 }
   warning { break }
   good    { echo no problem  }
)
</pre>
<br/>
<div class="Pp"></div>
Finally, note that there are some uses of parentheses not following ordinary
  list rules: in let/local/%closure bindings, and in assignments
<h2 class="Ss" title="Ss" id="Concatenation"><a class="selflink" href="#Concatenation">Concatenation</a></h2>
Two lists may be joined by the concatenation operator (^). A single word is a
  list of length one, so
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo foo^bar
</pre>
<br/>
<div class="Pp"></div>
produces the output
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
foobar
</pre>
<br/>
<div class="Pp"></div>
For lists of more than one element, concatenation produces the cross (Cartesian)
  product of the elements in both lists:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo (a- b- c-)^(1 2)
</pre>
<br/>
<div class="Pp"></div>
produces the output
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
a-1 a-2 b-1 b-2 c-1 c-2
</pre>
<br/>
<h2 class="Ss" title="Ss" id="Variables"><a class="selflink" href="#Variables">Variables</a></h2>
A list may be assigned to a variable, using the notation
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
<i>var</i> = <i>list</i>
</pre>
<br/>
<div class="Pp"></div>
Unfortunately, whitespace is required around the assignment operator, this
  allows it to be treated as a normal string character normally. This is true
  also for assignment in let-forms and the like. Any sequence of non-special
  characters, except a sequence including only digits, may be used as a variable
  name. <i>Xs</i> exports all user-defined variables into the environment unless
  it is explicitly told not to.
<div class="Pp"></div>
The value of a variable is referenced with the notation:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$ <i>var</i>
</pre>
<br/>
<div class="Pp"></div>
Any variable which has not been assigned a value returns the empty list when
  referenced. In addition, multiple references are allowed:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
a = foo
b = a
echo $$b
</pre>
<br/>
<div class="Pp"></div>
prints
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
foo
</pre>
<br/>
<div class="Pp"></div>
A variable's definition may also be removed by assigning the empty list to a
  variable:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
<i>var</i>=
</pre>
<br/>
<div class="Pp"></div>
Multiple variables may be assigned with a single assignment statment. The left
  hand side of the assignment operation consists of a list of variables which
  are assigned, one by one, to the values in the list on the right hand side. If
  there are more variables than values in the list, the empty list is assigned
  to the remaining variables. If there are fewer variables than elements in the
  list, the last variable is bound to all the remaining list values.
<div class="Pp"></div>
For example,
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
(a b) = 1 2 3
</pre>
<br/>
<div class="Pp"></div>
has the same effect as
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
a = 1
b = 2 3
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
</pre>
<div class="Pp"></div>
<pre>
and
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
(a b c) = 1 2
</pre>
<br/>
<div class="Pp"></div>
is the same as
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
a = 1
b = 2
c =
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
</pre>
<div class="Pp"></div>
<pre>
Note that when assigning values to more than one variable,
the list of variables must be enclosed in parentheses.
</pre>
<div class="Pp"></div>
<pre>
For ``free careting'' (see below) to work correctly,
<i>xs</i>
must make certain assumptions
about what characters may appear in a variable name.
<i>Xs</i>
assumes that a variable name consists only of alphanumeric characters,
percent
(%),
star
(*),
dash
(-),
and underscore
(_).
To reference a variable with other
characters in its name, quote the variable name.
Thus:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
echo $'we$Irdriab!le'
</pre>
<br/>
<div class="Pp"></div>
A variable name produced by some complex operation, such as concatenation,
  should be enclosed in parentheses:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$( <i>var</i>)
</pre>
<br/>
<div class="Pp"></div>
Thus:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
Good-Morning = Bonjour
Guten = Good
Morgen = Morning
echo $($Guten^-^$Morgen)
</pre>
<br/>
<div class="Pp"></div>
prints
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
Bonjour
</pre>
<br/>
<div class="Pp"></div>
Each element of the list in parentheses is treated as an independent variable
  and expanded separately. Thus, given the above definitions,
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo $(Guten Morgen)
</pre>
<br/>
<div class="Pp"></div>
prints
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
Good Morning
</pre>
<br/>
<div class="Pp"></div>
To count the number of elements in a variable, use
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$# <i>var</i>
</pre>
<br/>
<div class="Pp"></div>
This returns a single-element list with the number of elements in $ <i>var</i>.
<h2 class="Ss" title="Ss" id="Subscripting"><a class="selflink" href="#Subscripting">Subscripting</a></h2>
Variables may be indexed with the notation
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$ <i>var</i>(<i>n</i>)
</pre>
<br/>
<div class="Pp"></div>
where <i>n</i> is a list of integers or ranges. Subscript indexes are based at
  one. The list of subscripts need not be in order or even unique. Thus, if
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
a = one two three
</pre>
<br/>
<div class="Pp"></div>
then
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo $a(3 3 3)
</pre>
<br/>
<div class="Pp"></div>
prints
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
three three three
</pre>
<br/>
<div class="Pp"></div>
Subscript indices which refer to nonexistent elements expand to the empty list.
  Thus, given the definition above
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo $a(3 1 4 1 5 9 2 6 5)
</pre>
<br/>
<div class="Pp"></div>
prints
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
three one one two
</pre>
<br/>
<div class="Pp"></div>
Subscript ranges are of the form <i>lo</i>...<i>hi</i> and refer to all the
  elements between <i>lo</i> and <i>hi</i>. If <i>lo</i> is omitted, then 1 is
  used as a default value; if <i>hi</i> is omitted, the length of the list is
  used. Thus
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
* = $*(2 ...)
</pre>
<br/>
<div class="Pp"></div>
removes the first element of *, similar to the effect of shift in <i>rc</i>(1)
  or <i>sh</i>(1).
<div class="Pp"></div>
The notation $ <i>n</i>, where <i>n</i> is an integer, is a shorthand for $*(
  <i>n</i>). Thus, <i>xs</i>'s arguments may be referred to as $1, $2, and so
  on.
<div class="Pp"></div>
Note that the list of subscripts may be given by any <i>xs</i> expression, so
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$var(`{awk 'BEGIN{for(i=1;i&lt;=10;i++)print i;exit }'})
</pre>
<br/>
<div class="Pp"></div>
returns the first 10 elements of $var.
<h2 class="Ss" title="Ss" id="Free_Carets"><a class="selflink" href="#Free_Carets">Free
  Carets</a></h2>
<i>Xs</i> inserts carets (concatenation operators) for free in certain
  situations, in order to save some typing on the user's behalf. For example,
  the following are all equivalent:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
cc -O -g -c malloc.c alloca.c
cc -^(O g c) (malloc alloca)^.c
opts=O g c; files=malloc alloca; cc -$opts $files.c
</pre>
<br/>
<div class="Pp"></div>
<i>Xs</i> inserts a free-caret between the ``-'' and $opts, as well as between
  $files and .c. The rule for free carets is as follows: if a word or keyword is
  immediately followed by another word, keyword, dollar-sign or backquote
  without any intervening spaces, then <i>xs</i> inserts a caret between them.
<h2 class="Ss" title="Ss" id="Flattened_Lists"><a class="selflink" href="#Flattened_Lists">Flattened
  Lists</a></h2>
To create a single-element list from a multi-element list, with the components
  space-separated, use
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$^ <i>var</i>
</pre>
<br/>
<div class="Pp"></div>
Flattening is useful when the normal list concatenation rules need to be
  bypassed. For example, to append a single period at the end of $path, use:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo $^path.
</pre>
<br/>
<h2 class="Ss" title="Ss" id="Wildcard_Expansion"><a class="selflink" href="#Wildcard_Expansion">Wildcard
  Expansion</a></h2>
<i>Xs</i> expands wildcards in filenames if possible. When the characters *, [
  or ? occur in an argument or command, <i>xs</i> looks at the argument as a
  pattern for matching against files. (Contrary to the behavior some other
  shells exhibit, <i>xs</i> will only perform pattern matching if a
  metacharacter occurs unquoted and literally in the input. Thus,
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
foo = '*'
echo $foo
</pre>
<br/>
<div class="Pp"></div>
will always echo just a star. In order for non-literal metacharacters to be
  expanded, an eval statement must be used in order to rescan the input.)
  Pattern matching occurs according to the following rules: a * matches any
  number (including zero) of characters. A ? matches any single character, and a
  [ followed by a number of characters followed by a ] matches a single
  character in that class. The rules for character class matching are the same
  as those for <i>ed</i>(1), with the exception that character class negation is
  achieved with the tilde (~), not the caret (^), since the caret already means
  something else in <i>xs</i>. The filename component separator, slash (/), must
  appear explicitly in patterns. * and ? do not match a dot character (.) at the
  beginning of a filename component.
<div class="Pp"></div>
A tilde (~) as the first character of an argument is used to refer to home
  directories. A tilde alone or followed by a slash (/) is replaced by the value
  of $home, which is usually the home directory of the current user. A tilde
  followed by a username is replaced with the home directory of that user,
  according to <i>getpwent</i>(3).
<h2 class="Ss" title="Ss" id="Pattern_Matching"><a class="selflink" href="#Pattern_Matching">Pattern
  Matching</a></h2>
The tilde (~) operator is used in <i>xs</i> for matching strings against
  wildcard patterns. The command
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~  <i>subject</i> <i>pattern</i> <i>pattern</i> ...
</pre>
<br/>
<div class="Pp"></div>
returns a true value if and only if the subject matches any of the patterns. The
  matching follows the same rules as wildcard expansion, except that slashes (/)
  are not considered significant, leading dots (.) do not have to be matched
  explicitly, and home directory expansion does not occur. Thus
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ foo f*
</pre>
<br/>
<div class="Pp"></div>
returns zero (true), while
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ (bar baz) f*
</pre>
<br/>
<div class="Pp"></div>
returns one (false). The null list is matched by the null list, so
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ $foo ()
</pre>
<br/>
<div class="Pp"></div>
checks to see whether $foo is empty or not. This may also be achieved by the
  test
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ $#foo 0
</pre>
<br/>
<div class="Pp"></div>
Note that inside a ~ command <i>xs</i> does not match patterns against file
  names, so it is not necessary to quote the characters *, [ and ?. However,
  <i>xs</i> does expand the subject against filenames if it contains
  metacharacters. Thus, the command
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ * ?
</pre>
<br/>
<div class="Pp"></div>
returns true if any of the files in the current directory have a
  single-character name. Note that if the ~ command is given a list as its first
  argument, then a successful match against any of the elements of that list
  will cause ~ to return true. For example:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~ (foo goo zoo) z*
</pre>
<br/>
<div class="Pp"></div>
is true.
<h2 class="Ss" title="Ss" id="Pattern_Extraction"><a class="selflink" href="#Pattern_Extraction">Pattern
  Extraction</a></h2>
The double-tilde (~~) operator is used in <i>xs</i> for extracting the parts of
  strings that match patterns. The command
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~~  <i>subject</i> <i>pattern</i> <i>pattern</i> ...
</pre>
<br/>
<div class="Pp"></div>
returns the parts of each matching subject which correspond to the wildcards.
<div class="Pp"></div>
Each subject is checked in order against each pattern; if it matches the
  pattern, the parts of the subject which matched each *, ?, or [] character
  range are extracted, and processing moves on to the next subject. If the
  subject does not match, the next pattern is tried.
<div class="Pp"></div>
For example, the result of the extraction operation
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
~~ (foo.c foo.x bar.h) *.[ch]
</pre>
<br/>
<div class="Pp"></div>
is the list (foo c bar h).
<h2 class="Ss" title="Ss" id="Arithmetic_Substitution"><a class="selflink" href="#Arithmetic_Substitution">Arithmetic
  Substitution</a></h2>
A single list element can be formed from an infix arithmetical expression like
  so:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
(  <i> expression </i>)
The expression can use any of the 
</pre>
<br/>
+, -, * and / operators, and use variable substitution of the form $var.
  Parentheses can be used in normal infix fashion for order of evaluation.
  Numbers can be entered in floating-point or integer, but are always decimal.
  Calculation rules are similar to C - any operation involving floats produces a
  float, any operation with integers produces an integer; this includes
  division, so
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
    .Cr &quot;echo :(1 / 2)&quot;
    .Cr &quot;echo :(1.0 / 2)&quot;
</pre>
<br/>
produce 0 and 0.5 (with trailing zeros) respectively. Integers will wrap around
  at the same point as the native platform's int, and floats at the same point
  as the native platform's double.
<h2 class="Ss" title="Ss" id="Command_Substitution"><a class="selflink" href="#Command_Substitution">Command
  Substitution</a></h2>
A list may be formed from the output of a command by using backquote
  substitution:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
`{ <i> command </i>}
</pre>
<br/>
<div class="Pp"></div>
returns a list formed from the standard output of the command in braces. The
  characters stored in the variable $ifs (for ``input field separator'') are
  used to split the output into list elements. By default, $ifs has the value
  space-tab-newline. The braces may be omitted if the command is a single word.
  Thus `ls may be used instead of `{ls}. This last feature is useful when
  defining functions that expand to useful argument lists. A frequent use is:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn src { echo *.[chy] }
</pre>
<br/>
<div class="Pp"></div>
followed by
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
wc `src
</pre>
<br/>
<div class="Pp"></div>
(This will print out a word-count of all C and Yacc source files in the current
  directory.)
<div class="Pp"></div>
In order to override the value of $ifs for a single command substitution, use:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
`` <i> ifs-list </i>{<i> command </i>}
</pre>
<br/>
<div class="Pp"></div>
$ifs will be temporarily ignored and the command's output will be split as
  specified by the list following the double backquote. For example:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
`` :\n {cat /etc/passwd}
</pre>
<br/>
<div class="Pp"></div>
splits up /etc/passwd into fields.
<h2 class="Ss" title="Ss" id="Return_Values"><a class="selflink" href="#Return_Values">Return
  Values</a></h2>
The return value of a command is obtained with the construct
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
&lt;={ <i> command </i>}
</pre>
<br/>
<div class="Pp"></div>
The return value of an external program is its exit status (which in other
  shells can be found in special variables such as $? or $status), as either a
  small integer or the name of signal. Thus
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo &lt;={test -f /etc/motd} &lt;={test -w /vmunix} &lt;=a.out
</pre>
<br/>
<div class="Pp"></div>
might produce the output
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
0 1 sigsegv+core
</pre>
<br/>
<div class="Pp"></div>
along with any output or error messages from the programs.
<div class="Pp"></div>
<i>Xs</i> functions and primitives can produce ``rich return values,'' that is,
  arbitrary lists as return values.
<div class="Pp"></div>
When return values are interpreted as truth values, an extension of the normal
  shell conventions apply. If any element of a list is not equal to ``0'' (or
  the empty string), that list is considered false.
<div class="Pp"></div>
The return value of an assignment operation is the assigned value.
<h2 class="Ss" title="Ss" id="Logical_Operators"><a class="selflink" href="#Logical_Operators">Logical
  Operators</a></h2>
There are a number of operators in <i>Xs</i> which depend on the exit status of
  a command.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
<i>command1</i> &amp;&amp; <i>command2</i>
</pre>
<br/>
<div class="Pp"></div>
executes the first command and then executes the second command if and only if
  the first command has a ``true'' return value.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
<i>command1</i> || <i>command2</i>
</pre>
<br/>
<div class="Pp"></div>
executes the first command and then executes the second command if and only if
  the first command has a ``false'' return value.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
! <i> command</i>
</pre>
<br/>
<div class="Pp"></div>
inverts the truth value of the exit status of a command.
<h2 class="Ss" title="Ss" id="Input_and_output"><a class="selflink" href="#Input_and_output">Input
  and output</a></h2>
The standard output of a command may be redirected to a file with
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt; file
</pre>
<br/>
<div class="Pp"></div>
and the standard input may be taken from a file with
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &lt; file
</pre>
<br/>
<div class="Pp"></div>
File descriptors other than 0 and 1 may be specified also. For example, to
  redirect standard error to a file, use:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt;[2] file
</pre>
<br/>
<div class="Pp"></div>
In order to duplicate a file descriptor, use &gt;[ <i>n</i>=<i>m</i>]. Thus to
  redirect both standard output and standard error to the same file, use
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt; file &gt;[2=1]
</pre>
<br/>
<div class="Pp"></div>
To close a file descriptor that may be open, use &gt;[ <i>n</i>=]. For example,
  to close file descriptor 7:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt;[7=]
</pre>
<br/>
<div class="Pp"></div>
In order to place the output of a command at the end of an already existing
  file, use:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &gt;&gt; file
</pre>
<br/>
<div class="Pp"></div>
If the file does not exist, then it is created.
<div class="Pp"></div>
To open a file for reading and writing, use the &lt;&gt; redirection operator;
  for reading and appending, use &lt;&gt;&gt;. Both of these operators use file
  descriptor 0 (standard input) by default. Similarly, &gt;&lt; truncates a file
  and opens it for reading and writing, and &gt;&gt;&lt; opens a file for
  reading and appending; these operators use file descriptor 1 by default.
<div class="Pp"></div>
``Here documents'' are supported as in <i>sh</i>(1) with the use of
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command &lt;&lt; 'eof-marker'
</pre>
<br/>
<div class="Pp"></div>
If the end-of-file marker is quoted, then no variable substitution occurs inside
  the here document. Otherwise, every variable is substituted by its
  space-separated-list value (see <b>Flat Lists</b>, below), and if a ^
  character follows a variable name, it is deleted. This allows the unambiguous
  use of variables adjacent to text, as in
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$variable^follow
</pre>
<br/>
<div class="Pp"></div>
To include a literal $ in a here document created with an unquoted end-of-file
  marker, use $$.
<div class="Pp"></div>
Additionally, <i>xs</i> supports ``here strings'', which are like here
  documents, except that input is taken directly from a string on the command
  line. Its use is illustrated here:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
cat &lt;&lt;&lt; 'this is a here string' | wc
</pre>
<br/>
<div class="Pp"></div>
(This feature enables <i>xs</i> to export functions that use here documents.)
<h2 class="Ss" title="Ss" id="Pipes"><a class="selflink" href="#Pipes">Pipes</a></h2>
Two or more commands may be combined in a pipeline by placing the vertical bar
  (|) between them. The standard output (file descriptor 1) of the command on
  the left is tied to the standard input (file descriptor 0) of the command on
  the right. The notation |[ <i>n</i>=<i>m</i>] indicates that file descriptor
  <i>n</i> of the left process is connected to file descriptor <i>m</i> of the
  right process. |[ <i>n</i>] is a shorthand for |[ <i>n</i>=0]. As an example,
  to pipe the standard error of a command to <i>wc</i>(1), use:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
command |[2] wc
</pre>
<br/>
<div class="Pp"></div>
The exit status of a pipeline is considered true if and only if every command in
  the pipeline exits true.
<h2 class="Ss" title="Ss" id="Input/Output_Substitution"><a class="selflink" href="#Input/Output_Substitution">Input/Output
  Substitution</a></h2>
Some commands, like <i>cmp</i>(1) or <i>diff</i>(1), take their input from named
  files on the command line, and do not use standard input. It is convenient
  sometimes to build nonlinear pipelines so that a command like <i>cmp</i> can
  read the output of two commands at once. <i>Xs</i> does it like this:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
cmp &lt;{command1} &lt;{command2}
</pre>
<br/>
<div class="Pp"></div>
compares the output of the two commands. Note: on some systems, this form of
  redirection is implemented with pipes, and since one cannot <i>lseek</i>(2) on
  a pipe, commands that use <i>lseek</i> will hang. For example, most versions
  of <i>diff</i> seek on their inputs.
<div class="Pp"></div>
Data can be sent down a pipe to several commands using <i>tee</i>(1) and the
  output version of this notation:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
echo hi there | tee &gt;{sed 's/^/p1 /'} &gt;{sed 's/^/p2 /'}
</pre>
<br/>
<h2 class="Ss" title="Ss" id="Program_Fragments"><a class="selflink" href="#Program_Fragments">Program
  Fragments</a></h2>
<i>Xs</i> allows the intermixing of code with strings. A program fragment, which
  is a group of commands enclosed in braces ({ and }), may be used anywhere a
  word is expected, and is treated as an indivisible unit. For example, a
  program fragment may be passed as an argument, stored in a variable, or
  written to a file or pipe. If a program fragment appears as the first word in
  a command, it is executed, and any arguments are ignored. Thus the following
  all produce the same output:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
{ echo hello, world }
{ echo hello, world } foo bar
xs -c { echo hello, world }
x = { echo hello, world }; $x
echo { echo hello, world } | xs
echo { echo hello, world } &gt; foo; xs &lt; foo
</pre>
<br/>
<div class="Pp"></div>
Since program fragments in the first position in a command are executed, braces
  may be used as a grouping mechanism for commands. For example, to run several
  commands, with output from all of them redirected to the same file, one can do
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
{ date; ps agux; who } &gt; snapshot
</pre>
<br/>
<div class="Pp"></div>
In addition, program fragments can continue across multiple physical lines
  without explicit line continuations, so the above command could also be
  written:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
{
     date
     ps agux
     who
} &gt; snapshot
</pre>
<br/>
<div class="Pp"></div>
A <i>lambda</i> is a variant on a program fragment which takes arguments. A
  lambda has the form
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
{ |  <i>parameters</i> | <i>commands</i> }
</pre>
<br/>
<div class="Pp"></div>
The <i>parameters</i> are one or more variable names, to which arguments of the
  lambda are assigned while the <i>commands</i> are run. The first argument is
  assigned to the first variable, the second to the second, and so on. If there
  are more arguments than parameters, the last named variable is assigned all
  the remaining arguments; if there are fewer, the parameters for which there
  are no arguments are bound to the empty list.
<div class="Pp"></div>
Lambdas, like other program fragments, can appear anywhere in a list. A more
  complicated example in the same spirit:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
{ |cmd arg| $cmd $arg } { |*| echo $* } hi
</pre>
<br/>
<div class="Pp"></div>
This command executes a lambda which runs its first argument, named cmd, using
  its second argument, named arg, as the argument for the first. The first
  argument of this function is another lambda, seen previously, and the second
  argument is the word hi.
<div class="Pp"></div>
These lambda expressions
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
{ |a b c| echo $c $b $a } 1 2
{ |a b c| echo $c $b $a } 1 2 3 4 5
</pre>
<br/>
<div class="Pp"></div>
produce this output:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
2 1
3 4 5 2 1
</pre>
<br/>
<h2 class="Ss" title="Ss" id="Functions"><a class="selflink" href="#Functions">Functions</a></h2>
A function in <i>xs</i> is introduced with the syntax
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn <i> name parameters </i>{<i> commands </i>}
</pre>
<br/>
<div class="Pp"></div>
If the function name appears as the first word of a command, the commands are
  run, with the named parameters bound to the arguments to the function.
<div class="Pp"></div>
The similarity between functions and lambdas is not coincidental. A function in
  <i>xs</i> is a variable of the form fn- <i>name</i>. If name for which the
  appropriate fn- variable exists is found in the first position of a command,
  the value of the variable is substituted for the first word. The above syntax
  for creating functions is equivalent to the variable assignment
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn- <i>name</i> = { | <i>parameters</i> | <i>commands</i> }
</pre>
<br/>
<div class="Pp"></div>
Functions may be deleted with the syntax
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn <i> name</i>
</pre>
<br/>
<div class="Pp"></div>
which is equivalent to the assignment
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
fn- <i>name</i>=
</pre>
<br/>
<div class="Pp"></div>
If, as the most common case, a function variable is bound to a lambda, when the
  function is invoked, the variable $0 is bound (dynamically, see below) to the
  name of the function.
<div class="Pp"></div>
Lambdas are just another form of code fragment, and, as such, can be exported in
  the environment, passed as arguments, etc. The central difference between the
  two forms is that lambdas bind their arguments, while simple brace-enclosed
  groups just ignore theirs.
<h2 class="Ss" title="Ss" id="Local_Variables"><a class="selflink" href="#Local_Variables">Local
  Variables</a></h2>
Variable assignments may be made local to a set of commands with the local
  construct:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
local ( <i>var</i> = <i>value</i>; <i>var</i> = <i>value ...</i>) <i>command</i>
</pre>
<br/>
<div class="Pp"></div>
The command may be a program fragment, so for example:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
local (path = /bin /usr/bin; ifs = ) {
     ...
}
</pre>
<br/>
<div class="Pp"></div>
sets path to a minimal useful path and removes ifs for the duration of one long
  compound command.
<div class="Pp"></div>
Local-bound variables are exported into the environment, and will invoke
  appropriately named settor functions (see below).
<h2 class="Ss" title="Ss" id="Lexically_Scoped_Variables"><a class="selflink" href="#Lexically_Scoped_Variables">Lexically
  Scoped Variables</a></h2>
In addition to local variables, <i>xs</i> supports a different form of temporary
  variable binding, using let-bound, or ``lexically scoped,'' variables.
  (Lexical scoping is the form of binding used by most compiled programming
  languages, such as C or Scheme.) A lexically scoped variable is introduced
  with a let statement:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
let ( <i>var</i> = <i>value</i>; <i>var</i> = <i>value ...</i>) <i>command</i>
</pre>
<br/>
<div class="Pp"></div>
(Also, the &quot;= value&quot; can be left out with same effect as &quot;var
  =&quot;)
<div class="Pp"></div>
All references to any of the variables defined in a let statement by any code
  located lexically (that is, textually) within the <i>command</i> portion of
  the statement will refer to the let-bound variable rather than any environment
  or local-bound variable; the immediate text of the let statement is the
  complete extent of that binding. That is, lexically bound variables
  surrounding code fragments follow those code fragments around.
<div class="Pp"></div>
An example best shows the difference between let and local (also known as
  ``dynamic'') binding: (note that ``; '' is <i>xs</i>'s default prompt.)
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
; x = foo
; let (x = bar) {
     echo $x
     fn lexical { echo $x }
}
bar
; local (x = baz) {
     echo $x
     fn dynamic { echo $x }
}
baz
; lexical
bar
; dynamic
foo
; 
</pre>
<br/>
<div class="Pp"></div>
Lexically bound variables are not exported into the environment, and never cause
  the invocation of settor functions. Function (lambda) parameters are lexically
  bound to their values.
<h2 class="Ss" title="Ss" id="For_loops"><a class="selflink" href="#For_loops">For
  loops</a></h2>
The command
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
for  <i>var</i> <i>list</i> { <i>command</i> }
</pre>
<br/>
<div class="Pp"></div>
Runs the <i>command</i> once for each element of the <i>list</i>, with the named
  variable bound lexically to each element of the list, in order. Note that if
  list consists of more than a single term, for example (a b c) it must be
  parenthesized.
<div class="Pp"></div>
If multiple bindings are given in the for statement, the looping occurs in
  parallel and stops when all lists are exhausted. When one list is finished
  before the others, the corresponding variable is bound to the empty list for
  the remaining iterations. Thus the loop
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
for i (a b c); j (x y) { echo $#i $i $#j $j}
</pre>
<br/>
<div class="Pp"></div>
produces the output
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
1 a 1 x
1 b 1 y
1 c 0
</pre>
<br/>
<h2 class="Ss" title="Ss" id="Settor_Functions"><a class="selflink" href="#Settor_Functions">Settor
  Functions</a></h2>
A settor function is a variable of the form set- <i>var</i>, which is typically
  bound to a lambda. Whenever a value is assigned to the named variable, the
  lambda is invoked with its arguments bound to the new value. While the settor
  function is running, the variable $0 is bound to the name of the variable
  being assigned. The result of the settor function is used as the actual value
  in the assignment.
<div class="Pp"></div>
For example, the following settor function is used to keep the shell variables
  home and HOME synchronized.
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
set-HOME = { |*|
    local (set-home = )
        home = $*
    result $*
}
</pre>
<br/>
<div class="Pp"></div>
This settor function is called when any assignment is made to the variable HOME.
  It assigns the new value to the variable home, but disables any settor
  function for home to prevent an infinite recursion. Then it returns its
  argument unchanged for use in the actual assignment to HOME.
<div class="Pp"></div>
Settor functions do not apply to lexically bound variables.
<h2 class="Ss" title="Ss" id="Primitives"><a class="selflink" href="#Primitives">Primitives</a></h2>
Primitives are internal <i>xs</i> operations that cannot or should not (for
  reasons of performance) be written in the interpreter's language. The set of
  primitives makes up the run-time library for <i>xs</i>.
<div class="Pp"></div>
Primitives can be used with the syntax
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$&amp; <i>name</i>
</pre>
<br/>
<div class="Pp"></div>
A primitive can be used anywhere a lambda is expected. The list of primitives is
  returned as the result of running the primitive $&amp;primitives.
<div class="Pp"></div>
For details on specific primitives, see the section entitled <b>PRIMITIVES</b>
  below.
<h2 class="Ss" title="Ss" id="Exceptions"><a class="selflink" href="#Exceptions">Exceptions</a></h2>
Exceptions in <i>xs</i> are used for many forms of non-structured control flow,
  notably error reporting, signals, and flow of control constructs such as
  escape.
<div class="Pp"></div>
Exceptions are passed up the call chain to catching routines. A catcher may
  decide to intercept an exception, retry the code that caused the exception, or
  pass the exception along. There can only be one exception raised at any time.
<div class="Pp"></div>
Exceptions are represented by lists. The first word of an exception is, by
  convention, the type of exception being raised. The following exceptions are
  known:
<dl class="Bl-tag">
  <dt class="It-tag">eof</dt>
  <dd class="It-tag">Raised by %parse when the end of input is reached.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">error <i>source message</i></dt>
  <dd class="It-tag">A run-time error. Almost all shell errors are reported with
      the error exception. The default interactive loop and the outermost level
      of the interpreter catch this exception and print the message.
      <i>Source</i> is the name of the routine (typically a primitive) which
      raised the error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">retry</dt>
  <dd class="It-tag">When raised from a signal catcher, causes the body of the
      catch clause to be run again.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">signal <i>signame</i></dt>
  <dd class="It-tag">Raised when the shell itself receives a signal, and the
      signal is listed in the variable signals. <i>Signame</i> is the name of
      the signal that was raised.</dd>
</dl>
<div class="Pp"></div>
See the builtin commands catch and throw for details on how to manipulate
  exceptions.
<h1 class="Sh" title="Sh" id="SPECIAL_VARIABLES"><a class="selflink" href="#SPECIAL_VARIABLES">SPECIAL
  VARIABLES</a></h1>
Several variables are known to <i>xs</i> and are treated specially. Redefining
  these variables can change interpreter semantics. Note that only dynamically
  bound (top-level or local-bound) variables are interpreted in this way; the
  names of lexically bound variables are unimportant.
<dl class="Bl-tag">
  <dt class="It-tag">*</dt>
  <dd class="It-tag">The argument list of <i>xs</i>. $1, $2, etc. are the same
      as $*(1), $*(2), etc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$0</dt>
  <dd class="It-tag">Holds the value of argv[0] with which <i>xs</i> was
      invoked. Additionally, $0 is set to the name of a function for the
      duration of the execution of that function, and $0 is also set to the name
      of the file being interpreted for the duration of a . command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">apid</dt>
  <dd class="It-tag">The process ID of the last process started in the
      background.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">history</dt>
  <dd class="It-tag">The name of a file to which commands are appended as
      <i>xs</i> reads them. This facilitates the use of a stand-alone history
      program (such as <i>history</i>(1)) which parses the contents of the
      history file and presents them to <i>xs</i> for reinterpretation. If
      history is not set (the default), then <i>xs</i> does not append commands
      to any file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">home</dt>
  <dd class="It-tag">The current user's home directory, used in tilde (~)
      expansion, as the default directory for the builtin cd command, and as the
      directory in which <i>xs</i> looks to find its initialization file, .esrc,
      if <i>xs</i> has been started up as a login shell. Like path and PATH,
      home and HOME are aliased to each other.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ifs</dt>
  <dd class="It-tag">The default input field separator, used for splitting up
      the output of backquote commands for digestion as a list. The initial
      value of ifs is space-tab-newline.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">noexport</dt>
  <dd class="It-tag">A list of variables which <i>xs</i> will not export. All
      variables except for the ones on this list and lexically bound variables
      are exported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">path</dt>
  <dd class="It-tag">This is a list of directories to search in for commands.
      The empty string stands for the current directory. Note also that an
      assignment to path causes an automatic assignment to PATH, and vice-versa.
      If neither path nor PATH are set at startup time, path assumes a default
      value suitable for your system. This is typically /usr/ucb /usr/bin /bin
      ''.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pid</dt>
  <dd class="It-tag">The process ID of the currently running <i>xs</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">prompt</dt>
  <dd class="It-tag">This variable holds the two prompts (in list form) that
      <i>xs</i> prints. $prompt(1) is printed before each command is read, and
      $prompt(2) is printed when input is expected to continue on the next line.
      (See %parse for details.) <i>xs</i> sets $prompt to ('; ' '') by default.
      The reason for this is that it enables an <i>xs</i> user to grab commands
      from previous lines using a mouse, and to present them to <i>xs</i> for
      re-interpretation; the semicolon prompt is simply ignored by <i>xs</i>.
      The null $prompt(2) also has its justification: an <i>xs</i> script, when
      typed interactively, will not leave $prompt(2)'s on the screen, and can
      therefore be grabbed by a mouse and placed directly into a file for use as
      a shell script, without further editing being necessary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">signals</dt>
  <dd class="It-tag">Contains a list of the signals which <i>xs</i> traps. Any
      signal name which is added to this list causes that signal to raise an
      <i>xs</i> exception. For example, to run some commands and make sure some
      cleanup routine is called even if the user interrupts or disconnects
      during the script, one can use the form:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
local (signals = $signals sighup sigint) {
     catch { |e|
          cleanup
          throw $e
     } {
          ...
     }
}
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">A signal name prefixed by a hyphen (-) causes that signal
      to be ignored by <i>xs</i> and all of its child processes, unless one of
      them resets its handler. A signal prefixed by a slash (/) is ignored in
      the current shell, but retains default behavior in child processes. In
      addition, the signal sigint may be preceeded by the prefix (.) to indicate
      that normal shell interrupt processing (i.e., the printing of an extra
      newline) occurs. By default <i>xs</i> starts up with the values
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
.sigint /sigquit /sigterm
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">in $signals; other values will be on the list if the shell
      starts up with some signals ignored.</dd>
</dl>
<div class="Pp"></div>
The values of path and home are derived from the environment values of PATH and
  HOME if those values are present. This is for compatibility with other Unix
  programs, such as <i>sh</i>(1). $PATH is assumed to be a colon-separated list.
<h1 class="Sh" title="Sh" id="SYNTACTIC_SUGAR"><a class="selflink" href="#SYNTACTIC_SUGAR">SYNTACTIC
  SUGAR</a></h1>
<i>xs</i> internally rewrites much of the syntax presented thus far in terms of
  calls to shell functions. Most features of <i>xs</i> that resemble traditional
  shell features are included in this category. This rewriting occurs at parse
  time, as commands are recognized by the interpreter. The shell functions that
  are the results of rewriting are some of the hook functions documented below.
<div class="Pp"></div>
The following tables list all of the major rewriting which <i>xs</i> does, with
  the forms typically entered by the user on the left and their internal form on
  the right. There is no reason for the user to avoid using the right-hand side
  forms, except that they are usually less convenient. To see the internal form
  of a specific command, a user can run <i>xs</i> with the -n and -x options;
  when invoked in this way, the shell prints the internal form of its commands
  rather than executing them.
<h2 class="Ss" title="Ss" id="Control_Flow"><a class="selflink" href="#Control_Flow">Control
  Flow</a></h2>
<br/>
<pre>
!  <i>cmd</i>	%not {<i>cmd</i>}
<i>cmd</i> &amp;	%background {<i>cmd</i>}
<i>cmd1</i> ; <i>cmd2</i>	%seq {<i>cmd1</i>} {<i>cmd2</i>}
<i>cmd1</i> &amp;&amp; <i>cmd2</i>	%and {<i>cmd1</i>} {<i>cmd2</i>}
<i>cmd1</i> || <i>cmd2</i>	%or {<i>cmd1</i>} {<i>cmd2</i>}
fn  <i>name</i> <i>args</i> { <i>cmd</i> }	fn-^<i>name</i> = { |<i>args</i>| <i>cmd</i>}
</pre>
<br/>
<h2 class="Ss" title="Ss" id="Input/Output_Commands"><a class="selflink" href="#Input/Output_Commands">Input/Output
  Commands</a></h2>
<br/>
<pre>
<i>cmd</i> &lt; <i>file</i>	%open 0 <i>file</i> {<i>cmd</i>}
<i>cmd</i> &gt; <i>file</i>	%create 1 <i>file</i> {<i>cmd</i>}
<i>cmd</i> &gt;[<i>n</i>] <i>file</i>	%create <i>n</i> <i>file</i> {<i>cmd</i>}
<i>cmd</i> &gt;&gt; <i>file</i>	%append 1 <i>file</i> {<i>cmd</i>}
<i>cmd</i> &lt;&gt; <i>file</i>	%open-write 0 <i>file</i> {<i>cmd</i>}
<i>cmd</i> &lt;&gt;&gt; <i>file</i>	%open-append 0 <i>file</i> {<i>cmd</i>}
<i>cmd</i> &gt;&lt; <i>file</i>	%open-create 1 <i>file</i> {<i>cmd</i>}
<i>cmd</i> &gt;&gt;&lt; <i>file</i>	%open-append 1 <i>file</i> {<i>cmd</i>}
<i>cmd</i> &gt;[<i>n</i>=]	%close <i>n</i> {<i>cmd</i>}
<i>cmd</i> &gt;[<i>m</i>=<i>n</i>]	%dup <i>m</i> <i>n</i> {<i>cmd</i>}
<i>cmd</i> &lt;&lt; tag <i>input</i> tag	%here 0 <i>input</i> {<i>cmd</i>}
<i>cmd</i> &lt;&lt;&lt; <i>string</i>	%here 0 <i>string</i> {<i>cmd</i>}
<i>cmd1</i> | <i>cmd2</i>	%pipe {<i>cmd1</i>} 1 0 {<i>cmd2</i>}
<i>cmd1</i> |[<i>m</i>=<i>n</i>] <i>cmd2</i>	%pipe {<i>cmd1</i>} <i>m</i> <i>n</i> {<i>cmd2</i>}
<i>cmd1</i> &gt;{ <i>cmd2</i> }	%writeto <i>var</i> {<i>cmd2</i>} {<i>cmd1</i> $<i>var</i>}
<i>cmd1</i> &lt;{ <i>cmd2</i> }	%readfrom <i>var</i> {<i>cmd2</i>} {<i>cmd1</i> $<i>var</i>}
</pre>
<br/>
<h2 class="Ss" title="Ss" id="Expressions"><a class="selflink" href="#Expressions">Expressions</a></h2>
<br/>
<pre>
$# <i>var</i>	&lt;={%count $<i>var</i>}
$^ <i>var</i>	&lt;={%flatten ' ' $<i>var</i>}
`{ <i>cmd args</i>}	&lt;={%backquote &lt;={%flatten '' $ifs} {<i>cmd args</i>}}
`` <i>ifs</i> {<i>cmd args</i>}	&lt;={%backquote &lt;={%flatten '' <i>ifs</i>} {<i>cmd args</i>}}
</pre>
<br/>
<h1 class="Sh" title="Sh" id="BUILTINS"><a class="selflink" href="#BUILTINS">BUILTINS</a></h1>
Builtin commands are shell functions that exist at shell startup time. Most
  builtins are indistinguishable from external commands, except that they run in
  the context of the shell itself rather than as a child process. Many builtins
  are implemented with primitives (see above).
<div class="Pp"></div>
Some builtin functions have names that begin with a percent character (%). These
  are commands with some special meaning to the shell, or are meant for use only
  by users customizing the shell. (This distinction is somewhat fuzzy, and the
  decisions about which functions have %-names are somewhat arbitrary.)
<div class="Pp"></div>
All builtins can be redefined and extended by the user.
<h2 class="Ss" title="Ss" id="Builtin_Commands"><a class="selflink" href="#Builtin_Commands">Builtin
  Commands</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">. [-einvx] <i> file </i>[<i>args ...</i>]<i></i></dt>
  <dd class="It-tag">Reads <i>file</i> as input to <i>xs</i> and executes its
      contents. The options are a subset of the invocation options for the shell
      (see below).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">access [-n <i>name</i>] [-1e] [-rwx] [-fdcblsp] <i>path
    ...</i></dt>
  <dd class="It-tag">Tests if the named paths are accessible according to the
      options presented. Normally, access returns zero (true) for files which
      are accessible and a printable error message (which evaluates as false,
      according to shell rules) for files which are not accessible. If the -1
      option is used, the name of the first file which the test succeeds for is
      returned; if the test succeeds for no file, the empty list is returned.
      However, if the -e option was used, access raises an error exception. If
      the -n option is used, the pathname arguments are treated as a list of
      directories, and the <i>name</i> option argument is used as a file in
      those directories (i.e., -n is used for path searching).
    <div style="height: 1.00em;">&#x00A0;</div>
    The default test is whether a file exists. These options change the
    test:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-r</dt>
  <dd class="It-tag">Is the file readable (by the current user)?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-w</dt>
  <dd class="It-tag">Is the file writable?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-x</dt>
  <dd class="It-tag">Is the file executable?
    <div style="height: 0.70em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-f</dt>
  <dd class="It-tag">Is the file a plain file?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-d</dt>
  <dd class="It-tag">Is the file a directory?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-c</dt>
  <dd class="It-tag">Is the file a character device?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-b</dt>
  <dd class="It-tag">Is the file a block device?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-l</dt>
  <dd class="It-tag">Is the file a symbolic link?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s</dt>
  <dd class="It-tag">Is the file a socket?</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-p</dt>
  <dd class="It-tag">Is the file a named pipe (FIFO)?</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag">alias <i>alias-name</i> <i>expansion...</i></dt>
  <dd class="It-tag">Define a new function, <i>alias-name</i> , which calls
      <i>expansion</i> The first command in <i>expansion</i> is replaced with
      it's whatis value to prevent recursion. This can be used to serve a
      somewhat similar purpose as in bash. For example, the following will force
      ls to use color, and make l be ls in long form, with color (due to
      previous alias):
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
alias ls ls --color=yes
alias l ls -l
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">break <i>value</i></dt>
  <dd class="It-tag">Exits the current loop. <i>Value</i> is used as the return
      value for the loop command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">catch <i>catcher body</i></dt>
  <dd class="It-tag">Runs <i>body</i>. If it raises an exception, <i>catcher</i>
      is run and passed the exception as an argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">cd [<i>directory</i>]</dt>
  <dd class="It-tag">Changes the current directory to <i>directory</i>. With no
      argument, cd changes the current directory to $home.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">echo [-n] [--] <i>args ...</i></dt>
  <dd class="It-tag">Prints its arguments to standard output, terminated by a
      newline. Arguments are separated by spaces. If the first argument is -n no
      final newline is printed. If the first argument is --, then all other
      arguments are echoed literally; this is used for echoing a literal
    -n.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">escape <i>lambda</i></dt>
  <dd class="It-tag">Run lambda with one argument, an escape block which when
      evaulated will return to the point after this escape. This is more
      formally refered to as an escape continuation. In fact, it's behaviour is
      a simple subset of exceptions, and is implemented fairly simply using
      catch. Escape is useful to replace return/break like constructs; for
      example
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
fn f { escape |fn-return| {
    ...; return 0;
    ...
}
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">will exit the function with result 0 when it reached the
    return.</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">eval <i>list</i></dt>
  <dd class="It-tag">Concatenates the elements of <i>list</i> with spaces and
      feeds the resulting string to the interpreter for rescanning and
      execution.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">exec <i>cmd</i></dt>
  <dd class="It-tag">Replaces <i>xs</i> with the given command. If the exec
      contains only redirections, then these redirections apply to the current
      shell and the shell does not exit. For example,
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
exec {&gt;[2] err.out}
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">places further output to standard error in the file
      <i>err.out</i>. Unlike some other shells, <i>xs</i> requires that
      redirections in an exec be enclosed in a program fragment.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">exit [<i>status</i>]</dt>
  <dd class="It-tag">Causes the current shell to exit with the given exit
      <i>status</i>. If no argument is given, zero (true) is used. (This is
      different from other shells, that often use the status of the last command
      executed.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">false</dt>
  <dd class="It-tag">Always returns a false (non-zero) return value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">forever <i>cmd</i></dt>
  <dd class="It-tag">Runs the command repeatedly, until the shell exits or the
      command raises an exception. This is equivalent to a while {true} {
      <i>cmd</i>} loop except that forever does not catch any exceptions,
      including break.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">fork <i>cmd</i></dt>
  <dd class="It-tag">Runs a command in a subshell. This insulates the parent
      shell from the effects of state changing operations such as cd and
      variable assignments. For example:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
fork {cd ..; make}
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">runs <i>make</i>(1) in the parent directory (..), but
      leaves the shell in the current directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">if [<i>test then-action</i>]<i> </i>[else
    <i>else-action</i>] <i></i></dt>
  <dd class="It-tag">Evaluates the command <i>test</i>. If the result is true,
      the command <i>then</i> is run and if completes. If the result of the test
      is false, the <i>else</i> command is run. The else-action doesn't require
      braces no matter the number of actions, so one can write code like:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
... } else if {~ $a $b} { ... }
    </pre>
    <br/>
    Note that:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
...}
else if {~ $a $b} { ... }
    </pre>
    <br/>
    , with the else on a seperate line, will only work if the if-command has
      parentheses wrapping it's body and else-statements.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">limit [-h] <i></i>[<i>resource
    </i>[<i>value</i>]<i></i>]<i></i></dt>
  <dd class="It-tag">Similar to the <i>csh</i>(1) limit builtin, this command
      operates upon the resource limits of a process. With no arguments, limit
      prints all the current limits; with one argument, limit prints the named
      limit; with two arguments, it sets the named limit to the given value. The
      -h flag displays/alters the hard limits. The resources which can be shown
      or altered are cputime, filesize, datasize, stacksize, coredumpsize and
      memoryuse. For example:
    <div style="height: 1.67ex;">&#x00A0;</div>
    <br/>
    <pre>
limit coredumpsize 0
    </pre>
    <br/>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">disables core dumps.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The limit values must either be the word ``unlimited'' or a
      number with an optional suffix indicating units. For size limits, the
      suffixes k (kilobytes), m (megabytes), and g (gigabytes) are recognized.
      For time limits, s (seconds), m (minutes), and h (hours) are known; in
      addition, times of the form <i>hh</i>:<i>mm</i>:<i>ss</i> and
      <i>mm</i>:<i>ss</i> are accepted. See <i>getrlimit</i>(2) for details on
      resource limit semantics.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">map <i>action</i> <i>list</i></dt>
  <dd class="It-tag">Call <i>action</i> with a single argument for each element
      of <i>list</i>. Since lists auto-expand, list contains the rest of the
      arguments to the command. Returns the list of results of each action. If
      action returns a list, it is expanded inside into a new process group.
      This builtin is useful for making <i>xs</i> behave like a job-control
      shell in a hostile environment. One example is the NeXT Terminal program,
      which implicitly assumes that each shell it forks will put itself into a
      new process group. Note that the controlling tty for the process must be
      on standard error (file descriptor 2) when this operation is run.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">omap <i>action</i> <i>list</i></dt>
  <dd class="It-tag">Like <i>map</i> , but return the list of the outputs of
      action, in the same form as if `` '' action were called.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">popd</dt>
  <dd class="It-tag"><i>cd</i> into the directory that was last pushed by
      <i>pushd</i> , popping the directory off of an internal stack. If it's
      internal stack is empty (for example, if <i>pushd</i> has not been
      called), then stays in the current directory. Also prints out the stack,
      starting from the top.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pushd [<i>dir</i>]</dt>
  <dd class="It-tag">Add directory's absolute path onto <i>popd 's</i> stack.
      Also outputs the stack.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">result <i>value ...</i></dt>
  <dd class="It-tag">Returns its arguments. This is <i>xs</i>'s identity
      function.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">switch <i>value</i> <i></i>[<i>case1
    action1</i>]<i></i>...<i></i>[<i>default-action</i>]<i></i></dt>
  <dd class="It-tag">Go through the list of cases, testing if they are equal to
      <i>value</i>. The matching action of the first case which matches is
      executed. The break exception can be used to manually exit the switch, but
      is not necessary to signify the end of an action (unlike in C).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">until <i>test body</i></dt>
  <dd class="It-tag">Identical to while, except test is negated</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">throw <i>exception arg ...</i></dt>
  <dd class="It-tag">Raise the named exception, passing all of the arguments to
      throw to the enclosing exception handler.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">time <i>cmd arg ... </i></dt>
  <dd class="It-tag">Prints, on the shell's standard error, the real, user, and
      system time consumed by executing the command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">true</dt>
  <dd class="It-tag">Always returns a true (zero) return value.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">umask <i></i>[<i>mask</i>]</dt>
  <dd class="It-tag">Sets the current umask (see <i>umask</i>(2)) to the octal
      <i>mask</i>. If no argument is present, the current mask value is
    printed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">unwind-protect <i>body cleanup</i></dt>
  <dd class="It-tag">Runs <i>body</i> and, when it completes or raises an
      exception, runs <i>cleanup</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">var <i>var ...</i></dt>
  <dd class="It-tag">Prints definitions of the named variables, suitable for
      being used as input to the shell.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">vars [-vfs] [-epi]</dt>
  <dd class="It-tag">Prints all shell variables, functions, and settor functions
      (in a form suitable for use as shell input), which match the criteria
      specified by the options.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">-v</dt>
  <dd class="It-tag">variables (that are not functions or settor functions)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-f</dt>
  <dd class="It-tag">functions</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s</dt>
  <dd class="It-tag">settor functions
    <div style="height: 0.70em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-e</dt>
  <dd class="It-tag">exported values</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-p</dt>
  <dd class="It-tag">private (not exported) values</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-i</dt>
  <dd class="It-tag">internal (predefined and builtin) values
    <div style="height: 0.70em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-a</dt>
  <dd class="It-tag">all of the above</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If none of -v, -f, or -s are specified, -v is used. If none
      of -e, -p, or -i are specified, -e is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">wait <i></i>[<i>pid</i>]</dt>
  <dd class="It-tag">Waits for the specified <i>pid</i>, which must have been
      started by <i>xs</i>. If no <i>pid</i> is specified, waits for any child
      process to exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">whatis <i>progam ...</i></dt>
  <dd class="It-tag">For each named <i>program</i>, prints the pathname,
      primitive, lambda, or code fragment which would be run if the program
      appeared as the first word of a command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">while <i>test body</i></dt>
  <dd class="It-tag">Evaluates the <i>test</i> and, if it is true, runs the
      <i>body</i> and repeats.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%read</dt>
  <dd class="It-tag">Reads from standard input and returns either the empty list
      (in the case of end-of-file) or a single element string with up to one
      line of data, including possible redirections. This function reads one
      character at a time in order to not read more data out of a pipe than it
      should. The terminating newline (if present) is not included in the
      returned string.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Hook_Functions"><a class="selflink" href="#Hook_Functions">Hook
  Functions</a></h2>
A subset of the %-named functions are known as ``hook functions.'' The hook
  functions are called to implement some internal shell operations, and are
  available as functions in order that their values can be changed. Typically, a
  call to a hook function is from code generated by the syntactic sugar
  rewritings.
<dl class="Bl-tag">
  <dt class="It-tag">%and <i>cmd ...</i></dt>
  <dd class="It-tag">Runs the commands in order, stopping after the first one
      that has a false return value. Returns the result of the last command
    run.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%append <i>fd file cmd</i></dt>
  <dd class="It-tag">Runs the command with file descriptor <i>fd</i> set up to
      append to the <i>file</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%background <i>cmd</i></dt>
  <dd class="It-tag">Runs the command in the background. The shell variable apid
      contains the process ID of the background process, which is printed if the
      shell is interactive (according to %is-interactive).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%backquote <i>separator cmd</i></dt>
  <dd class="It-tag">Runs the command in a child process and returns its
      standard output as a list, separated (with the same rules used in %split)
      into elements according to <i>separator</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%batch-loop</dt>
  <dd class="It-tag">Parses commands from the current input source and passes
      the commands to the function <i>%dispatch</i>, which is usually a
      dynamically bound identifier. This function catches the exception eof
      which causes it to return. This function is invoked by the shell on
      startup and from the dot (.) and eval commands, when the input source is
      not interactive. (See also %interactive-loop.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%close <i>fd cmd</i></dt>
  <dd class="It-tag">Runs the command with the given file descriptor
    closed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%count <i>list</i></dt>
  <dd class="It-tag">Returns the number of arguments to the primitive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%create <i>fd file cmd</i></dt>
  <dd class="It-tag">Runs the command with file descriptor <i>fd</i> set up to
      write to the <i>file</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%dup <i>newfd oldfd cmd</i></dt>
  <dd class="It-tag">Runs the command with the file descriptor <i>oldfd</i>
      copied (via <i>dup</i>(2)) to file descriptor <i>newfd</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%eval-noprint <i>cmd</i></dt>
  <dd class="It-tag">Run the command. (Passed as the argument to %batch-loop and
      %interactive-loop.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%eval-print <i>cmd</i></dt>
  <dd class="It-tag">Print and run the command. (Passed as the argument to
      %batch-loop and %interactive-loop when the -x option is used.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%exec-failure <i>file argv0 args ...</i></dt>
  <dd class="It-tag">This function, if it exists, is called in the context of a
      child process if an executable file was found but <i>execve</i>(2) could
      not run it. If the function returns, an error message is printed and the
      shell exits, but the function can exec a program if it thinks it knows
      what to do. Note that the name of the program appears twice in the
      arguments to %exec-failure, once as a filename and once as the first
      element of the argv array; in some cases the two will be identical, but in
      others the former will be a full pathname and the latter will just be the
      basename. Some versions of <i>xs</i> may provide a builtin version of this
      function to handle #!-style shell scripts if the kernel does not.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%exit-on-false <i>cmd</i></dt>
  <dd class="It-tag">Runs the command, and exits if any command (except those
      executing as the tests of conditional statements) returns a non-zero
      status. (This function is used as an argument to %batch-loop and
      %interactive-loop when the shell is invoked with the -e option.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%flatten <i>separator list</i></dt>
  <dd class="It-tag">Concatenate the elements of <i>list</i> into one string,
      separated by the string <i>separator</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%here <i>fd word ... cmd</i></dt>
  <dd class="It-tag">Runs the command with the <i>word</i>s passed as input on
      file descriptor <i>fd</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%home [<i>user</i>]</dt>
  <dd class="It-tag">Returns the home directory of the named user, or $home if
      there are no arguments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%interactive-loop</dt>
  <dd class="It-tag">Prompts, parses commands from the current input source and
      passes the commands to the function <i>%dispatch</i>, which is usually a
      dynamically bound identifier. This function catches the exception eof
      which causes it to return. This function is invoked by the shell on
      startup and from the dot (.) commands, when the input source is
      interactive. (See also %batch-loop.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%noeval-noprint <i>cmd</i></dt>
  <dd class="It-tag">Do nothing. (Passed as the argument to %batch-loop and
      %interactive-loop when the -n option is used.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%noeval-print <i>cmd</i></dt>
  <dd class="It-tag">Print but don't run the command. (Passed as the argument to
      %batch-loop and %interactive-loop when the -x and -n options are
    used.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%not <i>cmd</i></dt>
  <dd class="It-tag">Runs the command and returns false if its exit status was
      true, otherwise returns true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%one <i>list</i></dt>
  <dd class="It-tag">If <i>list</i> is one element long, %one returns its value;
      otherwise it raises an exception. %one is used to ensure that redirection
      operations get passed exactly one filename.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%open <i>fd file cmd</i></dt>
  <dd class="It-tag">Runs the command with <i>file</i> open for reading on file
      descriptor <i>fd</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%open-append <i>fd file cmd</i></dt>
  <dd class="It-tag">Runs the command with <i>file</i> open for reading and
      appending on file descriptor <i>fd</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%open-create <i>fd file cmd</i></dt>
  <dd class="It-tag">Runs the command with <i>file</i> open for reading and
      writing on file descriptor <i>fd</i>. If the file already exists, it is
      truncated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%open-write <i>fd file cmd</i></dt>
  <dd class="It-tag">Runs the command with <i>file</i> open for reading and
      writing on file descriptor <i>fd</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%openfile <i>mode fd file cmd</i></dt>
  <dd class="It-tag">Runs the command with <i>file</i> opened according to
      <i>mode</i> on file descriptor <i>fd</i>. The modes (r, w, a, r+, w+, and
      a+) have the same meanings in %openfile as they do in <i>fopen</i>(3).
      %openfile is invoked by the redirection hook functions: %append, %create,
      %open, %open-append, %open-create, and %open-write.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%or <i>cmd ...</i></dt>
  <dd class="It-tag">Runs the commands in order, stopping after the first one
      that has a true return value. Returns the result of the last command
    run.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%parse <i>prompt1 prompt2</i></dt>
  <dd class="It-tag">Reads input from the current input source, printing
      <i>prompt1</i> before reading anything and <i>prompt2</i> before reading
      continued lines. Returns a code fragment suitable for execution. Raises
      the exception eof on end of input.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%pathsearch <i>program</i></dt>
  <dd class="It-tag">Looks for an executable file named <i>program</i> in the
      directories listed in $path. If such a file is found, it is returned; if
      one is not found, an error exception is raised.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%pipe <i>cmd </i>[<i>outfd infd cmd</i>] ...</dt>
  <dd class="It-tag">Runs the commands, with the file descriptor <i>outfd</i> in
      the left-hand process connected by a pipe to the file descriptor
      <i>infd</i> in the right-hand process. If there are more than two
      commands, a multi-stage pipeline is created.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%prompt</dt>
  <dd class="It-tag">Called by %interactive-loop before every call to %parse.
      This function allows the user to provide any actions that he or she may
      wish to have executed before being prompted (e.g., updating the value of
      the prompt variable to contain all or part of the current working
      directory).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%readfrom <i>var input cmd</i></dt>
  <dd class="It-tag">Runs <i>cmd</i> with the variable <i>var</i> locally bound
      to the name of a file which contains the output of running the command
      <i>input</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%seq <i>cmd ...</i></dt>
  <dd class="It-tag">Runs the commands, in order.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%whatis <i>program ...</i></dt>
  <dd class="It-tag">For each named <i>program</i>, returns the pathname,
      primitive, lambda, or code fragment which would be run if the program
      appeared as the first word of a command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%writeto <i>var output cmd</i></dt>
  <dd class="It-tag">Runs <i>cmd</i> with the variable <i>var</i> locally bound
      to the name of a file which is used as the input for the command
      <i>output</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Utility_Functions"><a class="selflink" href="#Utility_Functions">Utility
  Functions</a></h2>
These functions are useful for people customizing the shell, may be used by
  other builtin commands, and probably don't make much sense to replace, though
  that is always possible.
<dl class="Bl-tag">
  <dt class="It-tag">%apids</dt>
  <dd class="It-tag">Returns the process IDs of all background processes that
      the shell has not yet waited for.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%fsplit <i>separator </i>[<i>args ...</i>]</dt>
  <dd class="It-tag">Splits its arguments into separate strings at every
      occurrence of any of the characters in the string <i>separator</i>.
      Repeated instances of separator characters cause null strings to appear in
      the result. (This function is used by some builtin settor functions.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%is-interactive</dt>
  <dd class="It-tag">Returns true if the current interpreter context is
      interactive; that is, if shell command input is currently coming from an
      interactive user. More precisely, this is true if the innermost enclosing
      read-eval-print loop is %interactive-loop rather than %batch-loop.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%newfd</dt>
  <dd class="It-tag">Returns a file descriptor that the shell thinks is not
      currently in use.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%run <i>program argv0 args ...</i></dt>
  <dd class="It-tag">Run the named program, which is not searched for in $path,
      with the argument vector set to the remaining arguments. This builtin can
      be used to set argv[0] (by convention, the name of the program) to
      something other than file name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%split <i>separator </i>[<i>args ...</i>]</dt>
  <dd class="It-tag">Splits its arguments into separate strings at every
      occurrence of any of the characters in the string <i>separator</i>.
      Repeated instances of separator characters are coalesced. Backquote
      substitution splits with the same rules.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">%var <i>var ...</i></dt>
  <dd class="It-tag">For each named variable, returns a string which, if
      interpreted by <i>xs</i> would assign to the variable its current
    value.</dd>
</dl>
<h1 class="Sh" title="Sh" id="PRIMITIVES"><a class="selflink" href="#PRIMITIVES">PRIMITIVES</a></h1>
Primitives exist in <i>xs</i> so that, in the presence of spoofing and
  redefinitions, there is a way to refer to built-in behaviors. This ability is
  necessary for the shell to be able to unambiguously refer to itself, but is
  also useful for users who have otherwise made their environment unnecessary
  but don't want to kill the current shell.
<div class="Pp"></div>
Primitives are referenced with the
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
$&amp; <i>name</i>
</pre>
<br/>
<div class="Pp"></div>
notation. In this section, the ``$&amp;'' prefixes will be omitted when
  primitive names are mentioned. Note that, by convention, primitive names
  follow C identifier names where <i>xs</i> variable and function names often
  contain ``%'' and ``-'' characters.
<div class="Pp"></div>
The following primitives directly implement the builtin functions with the same
  names:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
access	forever	throw
catch	fork	umask
echo	if	wait
exec	newpgrp	
exit	result	
</pre>
<br/>
<div class="Pp"></div>
In addition, the primitive dot implements the ``.'' builtin function.
<div class="Pp"></div>
The cd primitive is used in the implementation of the cd builtin, but does not
  understand no arguments to imply $home. The vars and internals primitives are
  used by the implementation of the vars builtin.
<div class="Pp"></div>
The following primitives implement the hook functions of the same names, with
  ``%'' prefixes:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
apids	here	read
close	home	run
count	newfd	seq
dup	openfile	split
flatten	parse	var
fsplit	pipe	whatis
</pre>
<br/>
<div class="Pp"></div>
The following primitives implement the similar named hook functions, with ``%''
  prefixes and internal hyphens:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
batchloop	exitonfalse	isinteractive
</pre>
<br/>
<div class="Pp"></div>
The background primitive is used to implement the %background hook function, but
  does not print the process ID of the background process or set $apid. The
  backquote primitive is used to implement the %backquote hook function, but
  returns the exit status of the child as the first value of its result instead
  of setting $bqstatus to it.
<div class="Pp"></div>
The following primitives implement the similarly named settor functions:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
sethistory	setnoexport	setsignals
</pre>
<br/>
<div class="Pp"></div>
Some primitives are included in <i>xs</i> conditionally, based on compile-time
  configuration options. Those primitives, and the functions to which they are
  bound, are
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
execfailure	%exec-failure
limit	limit
readfrom	%readfrom
time	time
writeto	%writeto
</pre>
<br/>
<div class="Pp"></div>
The primitive resetterminal is if <i>xs</i> is compiled with support for the
  <i>readline</i> or <i>editline</i> libraries. It is used in the implementation
  of settor functions of the TERM and TERMCAP variables to notify the line
  editing packages that the terminal configuration has changed.
<div class="Pp"></div>
Several primitives are not directly associated with other function. They are:
<dl class="Bl-tag">
  <dt class="It-tag">$&amp;collect</dt>
  <dd class="It-tag">Invokes the garbage collector. The garbage collector in
      <i>xs</i> runs rather frequently; there should be no reason for a user to
      issue this command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$&amp;noreturn <i>lambda args ...</i></dt>
  <dd class="It-tag">Call the <i>lambda</i>, but in such a way that it does not
      catch the return exception. This primitive exists in order that some
      control-flow operations in <i>xs</i> (e.g., while and &amp;&amp;) can be
      implemented as lambdas rather than primitives.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$&amp;primitives</dt>
  <dd class="It-tag">Returns a list of the names of xs primitives.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$&amp;version</dt>
  <dd class="It-tag">Returns the current version number and release date for
      <i>xs</i>.</dd>
</dl>
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">-c</dt>
  <dd class="It-tag">Run the given <i>command</i>, placing the rest of the
      arguments to <i>xs</i> in $*.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-s</dt>
  <dd class="It-tag">Read commands from standard input; i.e., put the first
      argument to <i>xs</i> in $* rather than using it as the name of a file to
      source.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-i</dt>
  <dd class="It-tag">Force <i>xs</i> to be an interactive shell. Normally
      <i>xs</i> is only interactive if it is run with commands coming from
      standard input and standard input is connected to a terminal.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-l</dt>
  <dd class="It-tag">Run $home/.esrc on startup, i.e., be a login shell. -l is
      implied if the name the shell was run under (that is, argv[0]) starts with
      a dash (-).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-e</dt>
  <dd class="It-tag">Exit if any command (except those executing as the tests of
      conditional statements) returns a non-zero status.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-v</dt>
  <dd class="It-tag">Echo all input to standard error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Exit if any command (except those executing as the tests
    of</dt>
  <dd class="It-tag">conditional statements) returns a non-zero status.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-v</dt>
  <dd class="It-tag">Echo all input to standard error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-x</dt>
  <dd class="It-tag">Print commands to standard error before executing
    them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-n</dt>
  <dd class="It-tag">Turn off execution of commands. This can be used for
      checking the syntax of scripts. When combined with -x, <i>xs</i> prints
      the entered command based on the internal (parsed) representation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-p</dt>
  <dd class="It-tag">Don't initialize functions from the environment. This is
      used to help make scripts that don't break unexpectedly when the
      environment contains functions that would override commands used in the
      script.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-o</dt>
  <dd class="It-tag">Don't open /dev/null on file descriptors 0, 1, and 2, if
      any of those descriptors are inherited closed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-d</dt>
  <dd class="It-tag">Don't trap SIGQUIT or SIGTERM. This is used for
    debugging.</dd>
</dl>
<h1 class="Sh" title="Sh" id="MISC_NOTES"><a class="selflink" href="#MISC_NOTES">MISC
  NOTES</a></h1>
As with any other shell scripting language, process forking takes up the
  majority of time:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
x = 0; while {!~ $x 4000} { x = :(x + 1) }
</pre>
<br/>
is several magnitudes faster than:
<div style="height: 1.67ex;">&#x00A0;</div>
<br/>
<pre>
x = 0; while {test $x -ne 4000} { x = :(x + 1) }
</pre>
<br/>
Even though xs's arithmetic code is rather slow, in this case the cost of
  fork+exec far outweighs it.
<div class="Pp"></div>
Elaborate tricks involving stringifying closures and unstringying them later
  will probably not work. In general, trying to manipulate the scope of
  variables through similar techniques will probably not do what one expects.
<h1 class="Sh" title="Sh" id="FILES"><a class="selflink" href="#FILES">FILES</a></h1>
$home/.xsrc, /dev/null
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
The interpreter should be properly tail recursive; that is, tail calls should
  not consume stack space.
<div class="Pp"></div>
break and return should have lexical scope.
<div class="Pp"></div>
Woe betide the environment string set by some other program to contain either
  the character control-a or the sequence control-b followed by control-a or
  control-b.
<div class="Pp"></div>
-x is not nearly as useful as it should be.
<div class="Pp"></div>
Too many creatures have fept in.
<div class="Pp"></div>
Please send bug reports to fkfire@gmail.com.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>history</i>(1), <i>es</i>(1), <i>rc</i>(1), <i>sh</i>(1), <i>execve</i>(2),
  <i>getrlimit</i>(2), <i>fopen</i>(3), <i>getpwent</i>(3)
<div class="Pp"></div>
Paul Haahr and Byron Rakitzis, <i>Es &#x2014; A shell with higher-order
  functions,</i> Proceedings of the Winter 1993 Usenix Conference, San Diego,
  CA.
<div class="Pp"></div>
Tom Duff, <i>Rc &#x2014; A Shell for Plan 9 and UNIX Systems,</i> Unix Research
  System, 10th Edition, Volume 2. (Saunders College Publishing)</div>
<table class="foot">
  <tr>
    <td class="foot-date">5 March 1992</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
