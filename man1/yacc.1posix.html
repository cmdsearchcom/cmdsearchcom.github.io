<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:44:37 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>YACC(1POSIX) POSIX Programmer&rsquo;s Manual
YACC(1POSIX)</p>

<p style="margin-top: 1em">PROLOG <br>
This manual page is part of the POSIX Programmer&rsquo;s
Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of <br>
Linux behavior), or the interface may not be implemented on
Linux.</p>

<p style="margin-top: 1em">NAME <br>
yacc &acirc; yet another compiler compiler (DEVELOPMENT)</p>

<p style="margin-top: 1em">SYNOPSIS <br>
yacc [&acirc;dltv] [&acirc;b file_prefix] [&acirc;p
sym_prefix] grammar</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The yacc utility shall read a description of a context-free
grammar in grammar and write C source code, conforming to
the ISO C standard, to a code file, and optionally header
<br>
information into a header file, in the current directory.
The generated source code shall not depend on any undefined,
unspecified, or implementation-defined behavior, except in
<br>
cases where it is copied directly from the supplied grammar,
or in cases that are documented by the implementation. The C
code shall define a function and related routines and <br>
macros for an automaton that executes a parsing algorithm
meeting the requirements in Algorithms.</p>

<p style="margin-top: 1em">The form and meaning of the
grammar are described in the EXTENDED DESCRIPTION
section.</p>

<p style="margin-top: 1em">The C source code and header
file shall be produced in a form suitable as input for the C
compiler (see c99).</p>

<p style="margin-top: 1em">OPTIONS <br>
The yacc utility shall conform to the Base Definitions
volume of POSIX.1&acirc;2008, Section 12.2, Utility Syntax
Guidelines, except for Guideline 9.</p>

<p style="margin-top: 1em">The following options shall be
supported:</p>

<p style="margin-top: 1em">&acirc;b file_prefix <br>
Use file_prefix instead of y as the prefix for all output
filenames. The code file y.tab.c, the header file y.tab.h
(created when &acirc;d is specified), and the description
<br>
file y.output (created when &acirc;v is specified), shall be
changed to file_prefix.tab.c, file_prefix.tab.h, and
file_prefix.output, respectively.</p>

<p style="margin-top: 1em">&acirc;d Write the header file;
by default only the code file is written. The #define
statements associate the token codes assigned by yacc with
the user-declared token names. <br>
This allows source files other than y.tab.c to access the
token codes.</p>

<p style="margin-top: 1em">&acirc;l Produce a code file
that does not contain any #line constructs. If this option
is not present, it is unspecified whether the code file or
header file contains #line <br>
directives. This should only be used after the grammar and
the associated actions are fully debugged.</p>

<p style="margin-top: 1em">&acirc;p sym_prefix <br>
Use sym_prefix instead of yy as the prefix for all external
names produced by yacc. The names affected shall include the
functions yyparse(), yylex(), and yyerror(), <br>
and the variables yylval, yychar, and yydebug. (In the
remainder of this section, the six symbols cited are
referenced using their default names only as a notational
<br>
convenience.) Local names may also be affected by the
&acirc;p option; however, the &acirc;p option shall not
affect #define symbols generated by yacc.</p>

<p style="margin-top: 1em">&acirc;t Modify conditional
compilation directives to permit compilation of debugging
code in the code file. Runtime debugging statements shall
always be contained in the code <br>
file, but by default conditional compilation directives
prevent their compilation.</p>

<p style="margin-top: 1em">&acirc;v Write a file containing
a description of the parser and a report of conflicts
generated by ambiguities in the grammar.</p>

<p style="margin-top: 1em">OPERANDS <br>
The following operand is required:</p>

<p style="margin-top: 1em">grammar A pathname of a file
containing instructions, hereafter called grammar, for which
a parser is to be created. The format for the grammar is
described in the EXTENDED <br>
DESCRIPTION section.</p>

<p style="margin-top: 1em">STDIN <br>
Not used.</p>

<p style="margin-top: 1em">INPUT FILES <br>
The file grammar shall be a text file formatted as specified
in the EXTENDED DESCRIPTION section.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
The following environment variables shall affect the
execution of yacc:</p>

<p style="margin-top: 1em">LANG Provide a default value for
the internationalization variables that are unset or null.
(See the Base Definitions volume of POSIX.1&acirc;2008,
Section 8.2, Internationaliza&acirc; <br>
tion Variables for the precedence of internationalization
variables used to determine the values of locale
categories.)</p>

<p style="margin-top: 1em">LC_ALL If set to a non-empty
string value, override the values of all the other
internationalization variables.</p>

<p style="margin-top: 1em">LC_CTYPE Determine the locale
for the interpretation of sequences of bytes of text data as
characters (for example, single-byte as opposed to
multi-byte characters in arguments <br>
and input files).</p>

<p style="margin-top: 1em">LC_MESSAGES <br>
Determine the locale that should be used to affect the
format and contents of diagnostic messages written to
standard error.</p>

<p style="margin-top: 1em">NLSPATH Determine the location
of message catalogs for the processing of LC_MESSAGES.</p>

<p style="margin-top: 1em">The LANG and LC_* variables
affect the execution of the yacc utility as stated. The
main() function defined in Yacc Library shall call:</p>

<p style="margin-top: 1em">setlocale(LC_ALL,
&quot;&quot;)</p>

<p style="margin-top: 1em">and thus the program generated
by yacc shall also be affected by the contents of these
variables at runtime.</p>

<p style="margin-top: 1em">ASYNCHRONOUS EVENTS <br>
Default.</p>

<p style="margin-top: 1em">STDOUT <br>
Not used.</p>

<p style="margin-top: 1em">STDERR <br>
If shift/reduce or reduce/reduce conflicts are detected in
grammar, yacc shall write a report of those conflicts to the
standard error in an unspecified format.</p>

<p style="margin-top: 1em">Standard error shall also be
used for diagnostic messages.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
The code file, the header file, and the description file
shall be text files. All are described in the following
sections.</p>

<p style="margin-top: 1em">Code File <br>
This file shall contain the C source code for the yyparse()
function. It shall contain code for the various semantic
actions with macro substitution performed on them as <br>
described in the EXTENDED DESCRIPTION section. It also shall
contain a copy of the #define statements in the header file.
If a %union declaration is used, the declaration for <br>
YYSTYPE shall also be included in this file.</p>

<p style="margin-top: 1em">Header File <br>
The header file shall contain #define statements that
associate the token numbers with the token names. This
allows source files other than the code file to access the
token <br>
codes. If a %union declaration is used, the declaration for
YYSTYPE and an extern YYSTYPE yylval declaration shall also
be included in this file.</p>

<p style="margin-top: 1em">Description File <br>
The description file shall be a text file containing a
description of the state machine corresponding to the
parser, using an unspecified format. Limits for internal
tables (see <br>
Limits) shall also be reported, in an implementation-defined
manner. (Some implementations may use dynamic allocation
techniques and have no specific limit values to report.)</p>

<p style="margin-top: 1em">EXTENDED DESCRIPTION <br>
The yacc command accepts a language that is used to define a
grammar for a target language to be parsed by the tables and
code generated by yacc. The language accepted by yacc <br>
as a grammar for the target language is described below
using the yacc input language itself.</p>

<p style="margin-top: 1em">The input grammar includes rules
describing the input structure of the target language and
code to be invoked when these rules are recognized to
provide the associated semantic <br>
action. The code to be executed shall appear as bodies of
text that are intended to be C-language code. These bodies
of text shall not contain C-language trigraphs. The
C-lan&acirc; <br>
guage inclusions are presumed to form a correct function
when processed by yacc into its output files. The code
included in this way shall be executed during the
recognition of <br>
the target language.</p>

<p style="margin-top: 1em">Given a grammar, the yacc
utility generates the files described in the OUTPUT FILES
section. The code file can be compiled and linked using c99.
If the declaration and programs <br>
sections of the grammar file did not include definitions of
main(), yylex(), and yyerror(), the compiled output requires
linking with externally supplied versions of those
func&acirc; <br>
tions. Default versions of main() and yyerror() are supplied
in the yacc library and can be linked in by using the
&acirc;l y operand to c99. The yacc library interfaces need
not sup&acirc; <br>
port interfaces with other than the default yy symbol
prefix. The application provides the lexical analyzer
function, yylex(); the lex utility is specifically designed
to gener&acirc; <br>
ate such a routine.</p>

<p style="margin-top: 1em">Input Language <br>
The application shall ensure that every specification file
consists of three sections in order: declarations, grammar
rules, and programs, separated by double
&lt;percent-sign&gt; <br>
characters (&quot;%%&quot;). The declarations and programs
sections can be empty. If the latter is empty, the preceding
&quot;%%&quot; mark separating it from the rules section can
be omitted.</p>

<p style="margin-top: 1em">The input is free form text
following the structure of the grammar defined below.</p>

<p style="margin-top: 1em">Lexical Structure of the Grammar
<br>
The &lt;blank&gt;, &lt;newline&gt;, and &lt;form-feed&gt;
character shall be ignored, except that the application
shall ensure that they do not appear in names or
multi-character reserved symbols. <br>
Comments shall be enclosed in &quot;/* ... */&quot;, and can
appear wherever a name is valid.</p>

<p style="margin-top: 1em">Names are of arbitrary length,
made up of letters, periods (&rsquo;.&rsquo;), underscores
(&rsquo;_&rsquo;), and non-initial digits. Uppercase and
lowercase letters are distinct. Conforming applica&acirc;
<br>
tions shall not use names beginning in yy or YY since the
yacc parser uses such names. Many of the names appear in the
final output of yacc, and thus they should be chosen to <br>
conform with any additional rules created by the C compiler
to be used. In particular they appear in #define
statements.</p>

<p style="margin-top: 1em">A literal shall consist of a
single character enclosed in single-quote characters. All of
the escape sequences supported for character constants by
the ISO C standard shall be <br>
supported by yacc.</p>

<p style="margin-top: 1em">The relationship with the
lexical analyzer is discussed in detail below.</p>

<p style="margin-top: 1em">The application shall ensure
that the NUL character is not used in grammar rules or
literals.</p>

<p style="margin-top: 1em">Declarations Section <br>
The declarations section is used to define the symbols used
to define the target language and their relationship with
each other. In particular, much of the additional
informa&acirc; <br>
tion required to resolve ambiguities in the context-free
grammar for the target language is provided here.</p>

<p style="margin-top: 1em">Usually yacc assigns the
relationship between the symbolic names it generates and
their underlying numeric value. The declarations section
makes it possible to control the <br>
assignment of these values.</p>

<p style="margin-top: 1em">It is also possible to keep
semantic information associated with the tokens currently on
the parse stack in a user-defined C-language union, if the
members of the union are asso&acirc; <br>
ciated with the various names in the grammar. The
declarations section provides for this as well.</p>

<p style="margin-top: 1em">The first group of declarators
below all take a list of names as arguments. That list can
optionally be preceded by the name of a C union member
(called a tag below) appearing <br>
within &rsquo;&lt;&rsquo; and &rsquo;&gt;&rsquo;. (As an
exception to the typographical conventions of the rest of
this volume of POSIX.1&acirc;2008, in this case &lt;tag&gt;
does not represent a metavariable, but the <br>
literal angle bracket characters surrounding a symbol.) The
use of tag specifies that the tokens named on this line
shall be of the same C type as the union member referenced
by <br>
tag. This is discussed in more detail below.</p>

<p style="margin-top: 1em">For lists used to define tokens,
the first appearance of a given token can be followed by a
positive integer (as a string of decimal digits). If this is
done, the underlying <br>
value assigned to it for lexical purposes shall be taken to
be that number.</p>

<p style="margin-top: 1em">The following declares name to
be a token:</p>

<p style="margin-top: 1em">%token [&lt;tag&gt;] name
[number] [name [number]]...</p>

<p style="margin-top: 1em">If tag is present, the C type
for all tokens on this line shall be declared to be the type
referenced by tag. If a positive integer, number, follows a
name, that value shall be <br>
assigned to the token.</p>

<p style="margin-top: 1em">The following declares name to
be a token, and assigns precedence to it:</p>

<p style="margin-top: 1em">%left [&lt;tag&gt;] name
[number] [name [number]]... <br>
%right [&lt;tag&gt;] name [number] [name [number]]...</p>

<p style="margin-top: 1em">One or more lines, each
beginning with one of these symbols, can appear in this
section. All tokens on the same line have the same
precedence level and associativity; the lines <br>
are in order of increasing precedence or binding strength.
%left denotes that the operators on that line are left
associative, and %right similarly denotes right associative
<br>
operators. If tag is present, it shall declare a C type for
names as described for %token.</p>

<p style="margin-top: 1em">The following declares name to
be a token, and indicates that this cannot be used
associatively:</p>

<p style="margin-top: 1em">%nonassoc [&lt;tag&gt;] name
[number] [name [number]]...</p>

<p style="margin-top: 1em">If the parser encounters
associative use of this token it reports an error. If tag is
present, it shall declare a C type for names as described
for %token.</p>

<p style="margin-top: 1em">The following declares that
union member names are non-terminals, and thus it is
required to have a tag field at its beginning:</p>

<p style="margin-top: 1em">%type &lt;tag&gt; name...</p>

<p style="margin-top: 1em">Because it deals with
non-terminals only, assigning a token number or using a
literal is also prohibited. If this construct is present,
yacc shall perform type checking; if this <br>
construct is not present, the parse stack shall hold only
the int type.</p>

<p style="margin-top: 1em">Every name used in grammar not
defined by a %token, %left, %right, or %nonassoc declaration
is assumed to represent a non-terminal symbol. The yacc
utility shall report an error <br>
for any non-terminal symbol that does not appear on the left
side of at least one grammar rule.</p>

<p style="margin-top: 1em">Once the type, precedence, or
token number of a name is specified, it shall not be
changed. If the first declaration of a token does not assign
a token number, yacc shall assign <br>
a token number. Once this assignment is made, the token
number shall not be changed by explicit assignment.</p>

<p style="margin-top: 1em">The following declarators do not
follow the previous pattern.</p>

<p style="margin-top: 1em">The following declares the
non-terminal name to be the start symbol, which represents
the largest, most general structure described by the grammar
rules:</p>

<p style="margin-top: 1em">%start name</p>

<p style="margin-top: 1em">By default, it is the left-hand
side of the first grammar rule; this default can be
overridden with this declaration.</p>

<p style="margin-top: 1em">The following declares the yacc
value stack to be a union of the various types of values
desired.</p>

<p style="margin-top: 1em">%union { body of union (in C)
}</p>

<p style="margin-top: 1em">The body of the union shall not
contain unbalanced curly brace preprocessing tokens.</p>

<p style="margin-top: 1em">By default, the values returned
by actions (see below) and the lexical analyzer shall be of
type int. The yacc utility keeps track of types, and it
shall insert corresponding <br>
union member names in order to perform strict type checking
of the resulting parser.</p>

<p style="margin-top: 1em">Alternatively, given that at
least one &lt;tag&gt; construct is used, the union can be
declared in a header file (which shall be included in the
declarations section by using a <br>
#include construct within %{ and %}), and a typedef used to
define the symbol YYSTYPE to represent this union. The
effect of %union is to provide the declaration of YYSTYPE
<br>
directly from the yacc input.</p>

<p style="margin-top: 1em">C-language declarations and
definitions can appear in the declarations section, enclosed
by the following marks:</p>

<p style="margin-top: 1em">%{ ... %}</p>

<p style="margin-top: 1em">These statements shall be copied
into the code file, and have global scope within it so that
they can be used in the rules and program sections. The
statements shall not contain <br>
&quot;%}&quot; outside a comment, string literal, or
multi-character constant.</p>

<p style="margin-top: 1em">The application shall ensure
that the declarations section is terminated by the token
%%.</p>

<p style="margin-top: 1em">Grammar Rules in yacc <br>
The rules section defines the context-free grammar to be
accepted by the function yacc generates, and associates with
those rules C-language actions and additional precedence
<br>
information. The grammar is described below, and a formal
definition follows.</p>

<p style="margin-top: 1em">The rules section is comprised
of one or more grammar rules. A grammar rule has the
form:</p>

<p style="margin-top: 1em">A : BODY ;</p>

<p style="margin-top: 1em">The symbol A represents a
non-terminal name, and BODY represents a sequence of zero or
more names, literals, and semantic actions that can then be
followed by optional precedence <br>
rules. Only the names and literals participate in the
formation of the grammar; the semantic actions and
precedence rules are used in other ways. The &lt;colon&gt;
and the &lt;semicolon&gt; <br>
are yacc punctuation. If there are several successive
grammar rules with the same left-hand side, the
&lt;vertical-line&gt; (&rsquo;|&rsquo;) can be used to avoid
rewriting the left-hand side; in <br>
this case the &lt;semicolon&gt; appears only after the last
rule. The BODY part can be empty (or empty of names and
literals) to indicate that the non-terminal symbol matches
the empty <br>
string.</p>

<p style="margin-top: 1em">The yacc utility assigns a
unique number to each rule. Rules using the vertical bar
notation are distinct rules. The number assigned to the rule
appears in the description file.</p>

<p style="margin-top: 1em">The elements comprising a BODY
are:</p>

<p style="margin-top: 1em">name, literal <br>
These form the rules of the grammar: name is either a token
or a non-terminal; literal stands for itself (less the
lexically required quotation marks).</p>

<p style="margin-top: 1em">semantic action <br>
With each grammar rule, the user can associate actions to be
performed each time the rule is recognized in the input
process. (Note that the word
&lsquo;&lsquo;action&rsquo;&rsquo; can also <br>
refer to the actions of the parser&acirc;shift, reduce, and
so on.)</p>

<p style="margin-top: 1em">These actions can return values
and can obtain the values returned by previous actions.
These values are kept in objects of type YYSTYPE (see
%union). The result value <br>
of the action shall be kept on the parse stack with the
left-hand side of the rule, to be accessed by other
reductions as part of their right-hand side. By using the
<br>
&lt;tag&gt; information provided in the declarations
section, the code generated by yacc can be strictly type
checked and contain arbitrary information. In addition, the
lex&acirc; <br>
ical analyzer can provide the same kinds of values for
tokens, if desired.</p>

<p style="margin-top: 1em">An action is an arbitrary C
statement and as such can do input or output, call
subprograms, and alter external variables. An action is one
or more C statements enclosed <br>
in curly braces &rsquo;{&rsquo; and &rsquo;}&rsquo;. The
statements shall not contain unbalanced curly brace
preprocessing tokens.</p>

<p style="margin-top: 1em">Certain pseudo-variables can be
used in the action. These are macros for access to data
structures known internally to yacc.</p>

<p style="margin-top: 1em">$$ The value of the action can
be set by assigning it to $$. If type checking is enabled
and the type of the value to be assigned cannot be
determined, a diag&acirc; <br>
nostic message may be generated.</p>

<p style="margin-top: 1em">$number This refers to the value
returned by the component specified by the token number in
the right side of a rule, reading from left to right; number
can be zero <br>
or negative. If number is zero or negative, it refers to the
data associated with the name on the parser&rsquo;s stack
preceding the leftmost symbol of the current <br>
rule. (That is, &quot;$0&quot; refers to the name
immediately preceding the leftmost name in the current rule
to be found on the parser&rsquo;s stack and
&quot;$&acirc;1&quot; refers to the <br>
symbol to its left.) If number refers to an element past the
current point in the rule, or beyond the bottom of the
stack, the result is undefined. If type <br>
checking is enabled and the type of the value to be assigned
cannot be determined, a diagnostic message may be
generated.</p>

<p style="margin-top: 1em">$&lt;tag&gt;number <br>
These correspond exactly to the corresponding symbols
without the tag inclusion, but allow for strict type
checking (and preclude unwanted type conversions). <br>
The effect is that the macro is expanded to use tag to
select an element from the YYSTYPE union (using
dataname.tag). This is particularly useful if number <br>
is not positive.</p>

<p style="margin-top: 1em">$&lt;tag&gt;$ This imposes on
the reference the type of the union member referenced by
tag. This construction is applicable when a reference to a
left context value occurs <br>
in the grammar, and provides yacc with a means for selecting
a type.</p>

<p style="margin-top: 1em">Actions can occur anywhere in a
rule (not just at the end); an action can access values
returned by actions to its left, and in turn the value it
returns can be <br>
accessed by actions to its right. An action appearing in the
middle of a rule shall be equivalent to replacing the action
with a new non-terminal symbol and adding an <br>
empty rule with that non-terminal symbol on the left-hand
side. The semantic action associated with the new rule shall
be equivalent to the original action. The use of <br>
actions within rules might introduce conflicts that would
not otherwise exist.</p>

<p style="margin-top: 1em">By default, the value of a rule
shall be the value of the first element in it. If the first
element does not have a type (particularly in the case of a
literal) and <br>
type checking is turned on by %type, an error message shall
result.</p>

<p style="margin-top: 1em">precedence <br>
The keyword %prec can be used to change the precedence level
associated with a particular grammar rule. Examples of this
are in cases where a unary and binary operator <br>
have the same symbolic representation, but need to be given
different precedences, or where the handling of an ambiguous
if-else construction is necessary. The reserved <br>
symbol %prec can appear immediately after the body of the
grammar rule and can be followed by a token name or a
literal. It shall cause the precedence of the grammar <br>
rule to become that of the following token name or literal.
The action for the rule as a whole can follow %prec.</p>

<p style="margin-top: 1em">If a program section follows,
the application shall ensure that the grammar rules are
terminated by %%.</p>

<p style="margin-top: 1em">Programs Section <br>
The programs section can include the definition of the
lexical analyzer yylex(), and any other functions; for
example, those used in the actions specified in the grammar
rules. <br>
It is unspecified whether the programs section precedes or
follows the semantic actions in the output file; therefore,
if the application contains any macro definitions and
dec&acirc; <br>
larations intended to apply to the code in the semantic
actions, it shall place them within &quot;%{ ... %}&quot; in
the declarations section.</p>

<p style="margin-top: 1em">Input Grammar <br>
The following input to yacc yields a parser for the input to
yacc. This formal syntax takes precedence over the preceding
text syntax description.</p>

<p style="margin-top: 1em">The lexical structure is defined
less precisely; Lexical Structure of the Grammar defines
most terms. The correspondence between the previous terms
and the tokens below is as <br>
follows.</p>

<p style="margin-top: 1em">IDENTIFIER This corresponds to
the concept of name, given previously. It also includes
literals as defined previously.</p>

<p style="margin-top: 1em">C_IDENTIFIER <br>
This is a name, and additionally it is known to be followed
by a &lt;colon&gt;. A literal cannot yield this token.</p>

<p style="margin-top: 1em">NUMBER A string of digits (a
non-negative decimal integer).</p>

<p style="margin-top: 1em">TYPE, LEFT, MARK, LCURL, RCURL
<br>
These correspond directly to %type, %left, %%, %{, and
%}.</p>

<p style="margin-top: 1em">{ ... } This indicates
C-language source code, with the possible inclusion of
&rsquo;$&rsquo; macros as discussed previously.</p>

<p style="margin-top: 1em">/* Grammar for the input to
yacc. */ <br>
/* Basic entries. */ <br>
/* The following are recognized by the lexical analyzer.
*/</p>

<p style="margin-top: 1em">%token IDENTIFIER /* Includes
identifiers and literals */ <br>
%token C_IDENTIFIER /* identifier (but not literal) <br>
followed by a :. */ <br>
%token NUMBER /* [0-9][0-9]* */</p>

<p style="margin-top: 1em">/* Reserved words :
%type=&gt;TYPE %left=&gt;LEFT, and so on */</p>

<p style="margin-top: 1em">%token LEFT RIGHT NONASSOC TOKEN
PREC TYPE START UNION</p>

<p style="margin-top: 1em">%token MARK /* The %% mark. */
<br>
%token LCURL /* The %{ mark. */ <br>
%token RCURL /* The %} mark. */</p>

<p style="margin-top: 1em">/* 8-bit character literals
stand for themselves; */ <br>
/* tokens have to be defined for multi-byte characters.
*/</p>

<p style="margin-top: 1em">%start spec</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">spec : defs MARK rules tail <br>
; <br>
tail : MARK <br>
{ <br>
/* In this action, set up the rest of the file. */ <br>
} <br>
| /* Empty; the second MARK is optional. */ <br>
; <br>
defs : /* Empty. */ <br>
| defs def <br>
; <br>
def : START IDENTIFIER <br>
| UNION <br>
{ <br>
/* Copy union definition to output. */ <br>
} <br>
| LCURL <br>
{ <br>
/* Copy C code to output file. */ <br>
} <br>
RCURL <br>
| rword tag nlist <br>
; <br>
rword : TOKEN <br>
| LEFT <br>
| RIGHT <br>
| NONASSOC <br>
| TYPE <br>
; <br>
tag : /* Empty: union tag ID optional. */ <br>
| &rsquo;&lt;&rsquo; IDENTIFIER &rsquo;&gt;&rsquo; <br>
; <br>
nlist : nmno <br>
| nlist nmno <br>
; <br>
nmno : IDENTIFIER /* Note: literal invalid with % type. */
<br>
| IDENTIFIER NUMBER /* Note: invalid with % type. */ <br>
;</p>

<p style="margin-top: 1em">/* Rule section */</p>

<p style="margin-top: 1em">rules : C_IDENTIFIER rbody prec
<br>
| rules rule <br>
; <br>
rule : C_IDENTIFIER rbody prec <br>
| &rsquo;|&rsquo; rbody prec <br>
; <br>
rbody : /* empty */ <br>
| rbody IDENTIFIER <br>
| rbody act <br>
; <br>
act : &rsquo;{&rsquo; <br>
{ <br>
/* Copy action, translate $$, and so on. */ <br>
} <br>
&rsquo;}&rsquo; <br>
; <br>
prec : /* Empty */ <br>
| PREC IDENTIFIER <br>
| PREC IDENTIFIER act <br>
| prec &rsquo;;&rsquo; <br>
;</p>

<p style="margin-top: 1em">Conflicts <br>
The parser produced for an input grammar may contain states
in which conflicts occur. The conflicts occur because the
grammar is not LALR(1). An ambiguous grammar always contains
<br>
at least one LALR(1) conflict. The yacc utility shall
resolve all conflicts, using either default rules or
user-specified precedence rules.</p>

<p style="margin-top: 1em">Conflicts are either
shift/reduce conflicts or reduce/reduce conflicts. A
shift/reduce conflict is where, for a given state and
lookahead symbol, both a shift action and a reduce <br>
action are possible. A reduce/reduce conflict is where, for
a given state and lookahead symbol, reductions by two
different rules are possible.</p>

<p style="margin-top: 1em">The rules below describe how to
specify what actions to take when a conflict occurs. Not all
shift/reduce conflicts can be successfully resolved this way
because the conflict may <br>
be due to something other than ambiguity, so incautious use
of these facilities can cause the language accepted by the
parser to be much different from that which was intended.
<br>
The description file shall contain sufficient information to
understand the cause of the conflict. Where ambiguity is the
reason either the default or explicit rules should be <br>
adequate to produce a working parser.</p>

<p style="margin-top: 1em">The declared precedences and
associativities (see Declarations Section) are used to
resolve parsing conflicts as follows:</p>

<p style="margin-top: 1em">1. A precedence and
associativity is associated with each grammar rule; it is
the precedence and associativity of the last token or
literal in the body of the rule. If the %prec <br>
keyword is used, it overrides this default. Some grammar
rules might not have both precedence and associativity.</p>

<p style="margin-top: 1em">2. If there is a shift/reduce
conflict, and both the grammar rule and the input symbol
have precedence and associativity associated with them, then
the conflict is resolved in <br>
favor of the action (shift or reduce) associated with the
higher precedence. If the precedences are the same, then the
associativity is used; left associative implies reduce, <br>
right associative implies shift, and non-associative implies
an error in the string being parsed.</p>

<p style="margin-top: 1em">3. When there is a shift/reduce
conflict that cannot be resolved by rule 2, the shift is
done. Conflicts resolved this way are counted in the
diagnostic output described in <br>
Error Handling.</p>

<p style="margin-top: 1em">4. When there is a reduce/reduce
conflict, a reduction is done by the grammar rule that
occurs earlier in the input sequence. Conflicts resolved
this way are counted in the <br>
diagnostic output described in Error Handling.</p>

<p style="margin-top: 1em">Conflicts resolved by precedence
or associativity shall not be counted in the shift/reduce
and reduce/reduce conflicts reported by yacc on either
standard error or in the <br>
description file.</p>

<p style="margin-top: 1em">Error Handling <br>
The token error shall be reserved for error handling. The
name error can be used in grammar rules. It indicates places
where the parser can recover from a syntax error. The <br>
default value of error shall be 256. Its value can be
changed using a %token declaration. The lexical analyzer
should not return the value of error.</p>

<p style="margin-top: 1em">The parser shall detect a syntax
error when it is in a state where the action associated with
the lookahead symbol is error. A semantic action can cause
the parser to initiate <br>
error handling by executing the macro YYERROR. When YYERROR
is executed, the semantic action passes control back to the
parser. YYERROR cannot be used outside of semantic <br>
actions.</p>

<p style="margin-top: 1em">When the parser detects a syntax
error, it normally calls yyerror() with the character string
&quot;syntax error&quot; as its argument. The call shall not
be made if the parser is still <br>
recovering from a previous error when the error is detected.
The parser is considered to be recovering from a previous
error until the parser has shifted over at least three
nor&acirc; <br>
mal input symbols since the last error was detected or a
semantic action has executed the macro yyerrok. The parser
shall not call yyerror() when YYERROR is executed.</p>

<p style="margin-top: 1em">The macro function YYRECOVERING
shall return 1 if a syntax error has been detected and the
parser has not yet fully recovered from it. Otherwise, zero
shall be returned.</p>

<p style="margin-top: 1em">When a syntax error is detected
by the parser, the parser shall check if a previous syntax
error has been detected. If a previous error was detected,
and if no normal input sym&acirc; <br>
bols have been shifted since the preceding error was
detected, the parser checks if the lookahead symbol is an
endmarker (see Interface to the Lexical Analyzer). If it is,
the <br>
parser shall return with a non-zero value. Otherwise, the
lookahead symbol shall be discarded and normal parsing shall
resume.</p>

<p style="margin-top: 1em">When YYERROR is executed or when
the parser detects a syntax error and no previous error has
been detected, or at least one normal input symbol has been
shifted since the previ&acirc; <br>
ous error was detected, the parser shall pop back one state
at a time until the parse stack is empty or the current
state allows a shift over error. If the parser empties the
<br>
parse stack, it shall return with a non-zero value.
Otherwise, it shall shift over error and then resume normal
parsing. If the parser reads a lookahead symbol before the
error <br>
was detected, that symbol shall still be the lookahead
symbol when parsing is resumed.</p>

<p style="margin-top: 1em">The macro yyerrok in a semantic
action shall cause the parser to act as if it has fully
recovered from any previous errors. The macro yyclearin
shall cause the parser to discard <br>
the current lookahead token. If the current lookahead token
has not yet been read, yyclearin shall have no effect.</p>

<p style="margin-top: 1em">The macro YYACCEPT shall cause
the parser to return with the value zero. The macro YYABORT
shall cause the parser to return with a non-zero value.</p>

<p style="margin-top: 1em">Interface to the Lexical
Analyzer <br>
The yylex() function is an integer-valued function that
returns a token number representing the kind of token read.
If there is a value associated with the token returned by
<br>
yylex() (see the discussion of tag above), it shall be
assigned to the external variable yylval.</p>

<p style="margin-top: 1em">If the parser and yylex() do not
agree on these token numbers, reliable communication between
them cannot occur. For (single-byte character) literals, the
token is simply the <br>
numeric value of the character in the current character set.
The numbers for other tokens can either be chosen by yacc,
or chosen by the user. In either case, the #define
con&acirc; <br>
struct of C is used to allow yylex() to return these numbers
symbolically. The #define statements are put into the code
file, and the header file if that file is requested. The
<br>
set of characters permitted by yacc in an identifier is
larger than that permitted by C. Token names found to
contain such characters shall not be included in the #define
decla&acirc; <br>
rations.</p>

<p style="margin-top: 1em">If the token numbers are chosen
by yacc, the tokens other than literals shall be assigned
numbers greater than 256, although no order is implied. A
token can be explicitly <br>
assigned a number by following its first appearance in the
declarations section with a number. Names and literals not
defined this way retain their default definition. All token
<br>
numbers assigned by yacc shall be unique and distinct from
the token numbers used for literals and user-assigned
tokens. If duplicate token numbers cause conflicts in parser
gen&acirc; <br>
eration, yacc shall report an error; otherwise, it is
unspecified whether the token assignment is accepted or an
error is reported.</p>

<p style="margin-top: 1em">The end of the input is marked
by a special token called the endmarker, which has a token
number that is zero or negative. (These values are invalid
for any other token.) All <br>
lexical analyzers shall return zero or negative as a token
number upon reaching the end of their input. If the tokens
up to, but excluding, the endmarker form a structure that
<br>
matches the start symbol, the parser shall accept the input.
If the endmarker is seen in any other context, it shall be
considered an error.</p>

<p style="margin-top: 1em">Completing the Program <br>
In addition to yyparse() and yylex(), the functions
yyerror() and main() are required to make a complete
program. The application can supply main() and yyerror(), or
those rou&acirc; <br>
tines can be obtained from the yacc library.</p>

<p style="margin-top: 1em">Yacc Library <br>
The following functions shall appear only in the yacc
library accessible through the &acirc;l y operand to c99;
they can therefore be redefined by a conforming
application:</p>

<p style="margin-top: 1em">int main(void) <br>
This function shall call yyparse() and exit with an
unspecified value. Other actions within this function are
unspecified.</p>

<p style="margin-top: 1em">int yyerror(const char *s) <br>
This function shall write the NUL-terminated argument to
standard error, followed by a &lt;newline&gt;.</p>

<p style="margin-top: 1em">The order of the &acirc;l y and
&acirc;l l operands given to c99 is significant; the
application shall either provide its own main() function or
ensure that &acirc;l y precedes &acirc;l l.</p>

<p style="margin-top: 1em">Debugging the Parser <br>
The parser generated by yacc shall have diagnostic
facilities in it that can be optionally enabled at either
compile time or at runtime (if enabled at compile time). The
compi&acirc; <br>
lation of the runtime debugging code is under the control of
YYDEBUG, a preprocessor symbol. If YYDEBUG has a non-zero
value, the debugging code shall be included. If its value
<br>
is zero, the code shall not be included.</p>

<p style="margin-top: 1em">In parsers where the debugging
code has been included, the external int yydebug can be used
to turn debugging on (with a non-zero value) and off (zero
value) at runtime. The ini&acirc; <br>
tial value of yydebug shall be zero.</p>

<p style="margin-top: 1em">When &acirc;t is specified, the
code file shall be built such that, if YYDEBUG is not
already defined at compilation time (using the c99 &acirc;D
YYDEBUG option, for example), YYDEBUG shall <br>
be set explicitly to 1. When &acirc;t is not specified, the
code file shall be built such that, if YYDEBUG is not
already defined, it shall be set explicitly to zero.</p>

<p style="margin-top: 1em">The format of the debugging
output is unspecified but includes at least enough
information to determine the shift and reduce actions, and
the input symbols. It also provides <br>
information about error recovery.</p>

<p style="margin-top: 1em">Algorithms <br>
The parser constructed by yacc implements an LALR(1) parsing
algorithm as documented in the literature. It is unspecified
whether the parser is table-driven or direct-coded.</p>

<p style="margin-top: 1em">A parser generated by yacc shall
never request an input symbol from yylex() while in a state
where the only actions other than the error action are
reductions by a single rule.</p>

<p style="margin-top: 1em">The literature of parsing theory
defines these concepts.</p>

<p style="margin-top: 1em">Limits <br>
The yacc utility may have several internal tables. The
minimum maximums for these tables are shown in the following
table. The exact meaning of these values is implementation-
<br>
defined. The implementation shall define the relationship
between these values and between them and any error messages
that the implementation may generate should it run out of
<br>
space for any internal structure. An implementation may
combine groups of these resources into a single pool as long
as the total available to the user does not fall below the
<br>
sum of the sizes specified by this section.</p>

<p style="margin-top: 1em">Table: Internal Limits in
yacc</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; &acirc; Minimum &acirc; &acirc; <br>
&acirc; Limit &acirc; Maximum &acirc; Description &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;{NTERMS} &acirc; 126 &acirc; Number of tokens.
&acirc; <br>
&acirc;{NNONTERM} &acirc; 200 &acirc; Number of
non-terminals. &acirc; <br>
&acirc;{NPROD} &acirc; 300 &acirc; Number of rules. &acirc;
<br>
&acirc;{NSTATES} &acirc; 600 &acirc; Number of states.
&acirc; <br>
&acirc;{MEMSIZE} &acirc; 5200 &acirc; Length of rules. The
total &acirc; <br>
&acirc; &acirc; &acirc; length, in names (tokens and &acirc;
<br>
&acirc; &acirc; &acirc; non-terminals), of all the &acirc;
<br>
&acirc; &acirc; &acirc; rules of the grammar. The &acirc;
<br>
&acirc; &acirc; &acirc; left-hand side is counted for
&acirc; <br>
&acirc; &acirc; &acirc; each rule, even if it is not &acirc;
<br>
&acirc; &acirc; &acirc; explicitly repeated, as speci&acirc;
&acirc; <br>
&acirc; &acirc; &acirc; fied in Grammar Rules in yacc.
&acirc; <br>
&acirc;{ACTSIZE} &acirc; 4000 &acirc; Number of actions.
&lsquo;&lsquo;Actions&rsquo;&rsquo; &acirc; <br>
&acirc; &acirc; &acirc; here (and in the description &acirc;
<br>
&acirc; &acirc; &acirc; file) refer to parser actions
&acirc; <br>
&acirc; &acirc; &acirc; (shift, reduce, and so on) not
&acirc; <br>
&acirc; &acirc; &acirc; to semantic actions defined in
&acirc; <br>
&acirc; &acirc; &acirc; Grammar Rules in yacc. &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
EXIT STATUS <br>
The following exit values shall be returned:</p>

<p style="margin-top: 1em">0 Successful completion.</p>

<p style="margin-top: 1em">&gt;0 An error occurred.</p>

<p style="margin-top: 1em">CONSEQUENCES OF ERRORS <br>
If any errors are encountered, the run is aborted and yacc
exits with a non-zero status. Partial code files and header
files may be produced. The summary information in the <br>
description file shall always be produced if the &acirc;v
flag is present.</p>

<p style="margin-top: 1em">The following sections are
informative.</p>

<p style="margin-top: 1em">APPLICATION USAGE <br>
Historical implementations experience name conflicts on the
names yacc.tmp, yacc.acts, yacc.debug, y.tab.c, y.tab.h, and
y.output if more than one copy of yacc is running in a <br>
single directory at one time. The &acirc;b option was added
to overcome this problem. The related problem of allowing
multiple yacc parsers to be placed in the same file was
addressed <br>
by adding a &acirc;p option to override the previously
hard-coded yy variable prefix.</p>

<p style="margin-top: 1em">The description of the &acirc;p
option specifies the minimal set of function and variable
names that cause conflict when multiple parsers are linked
together. YYSTYPE does not need to <br>
be changed. Instead, the programmer can use &acirc;b to give
the header files for different parsers different names, and
then the file with the yylex() for a given parser can
include <br>
the header for that parser. Names such as yyclearerr do not
need to be changed because they are used only in the
actions; they do not have linkage. It is possible that an
imple&acirc; <br>
mentation has other names, either internal ones for
implementing things such as yyclearerr, or providing
non-standard features that it wants to change with
&acirc;p.</p>

<p style="margin-top: 1em">Unary operators that are the
same token as a binary operator in general need their
precedence adjusted. This is handled by the %prec advisory
symbol associated with the particu&acirc; <br>
lar grammar rule defining that unary operator. (See Grammar
Rules in yacc.) Applications are not required to use this
operator for unary operators, but the grammars that do not
<br>
require it are rare.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Access to the yacc library is obtained with library search
operands to c99. To use the yacc library main():</p>

<p style="margin-top: 1em">c99 y.tab.c &acirc;l y</p>

<p style="margin-top: 1em">Both the lex library and the
yacc library contain main(). To access the yacc main():</p>

<p style="margin-top: 1em">c99 y.tab.c lex.yy.c &acirc;l y
&acirc;l l</p>

<p style="margin-top: 1em">This ensures that the yacc
library is searched first, so that its main() is used.</p>

<p style="margin-top: 1em">The historical yacc libraries
have contained two simple functions that are normally coded
by the application programmer. These functions are similar
to the following code:</p>

<p style="margin-top: 1em">#include &lt;locale.h&gt; <br>
int main(void) <br>
{ <br>
extern int yyparse();</p>

<p style="margin-top: 1em">setlocale(LC_ALL,
&quot;&quot;);</p>

<p style="margin-top: 1em">/* If the following parser is
one created by lex, the <br>
application must be careful to ensure that LC_CTYPE <br>
and LC_COLLATE are set to the POSIX locale. */ <br>
(void) yyparse(); <br>
return (0); <br>
}</p>

<p style="margin-top: 1em">#include &lt;stdio.h&gt;</p>

<p style="margin-top: 1em">int yyerror(const char *msg)
<br>
{ <br>
(void) fprintf(stderr, &quot;%s0, msg); <br>
return (0); <br>
}</p>

<p style="margin-top: 1em">RATIONALE <br>
The references in Referenced Documents may be helpful in
constructing the parser generator. The referenced DeRemer
and Pennello article (along with the works it references)
<br>
describes a technique to generate parsers that conform to
this volume of POSIX.1&acirc;2008. Work in this area
continues to be done, so implementors should consult current
literature <br>
before doing any new implementations. The original Knuth
article is the theoretical basis for this kind of parser,
but the tables it generates are impractically large for
reason&acirc; <br>
able grammars and should not be used. The
&lsquo;&lsquo;equivalent to&rsquo;&rsquo; wording is
intentional to assure that the best tables that are LALR(1)
can be generated.</p>

<p style="margin-top: 1em">There has been confusion between
the class of grammars, the algorithms needed to generate
parsers, and the algorithms needed to parse the languages.
They are all reasonably <br>
orthogonal. In particular, a parser generator that accepts
the full range of LR(1) grammars need not generate a table
any more complex than one that accepts SLR(1) (a relatively
<br>
weak class of LR grammars) for a grammar that happens to be
SLR(1). Such an implementation need not recognize the case,
either; table compression can yield the SLR(1) table (or
<br>
one even smaller than that) without recognizing that the
grammar is SLR(1). The speed of an LR(1) parser for any
class is dependent more upon the table representation and
com&acirc; <br>
pression (or the code generation if a direct parser is
generated) than upon the class of grammar that the table
generator handles.</p>

<p style="margin-top: 1em">The speed of the parser
generator is somewhat dependent upon the class of grammar it
handles. However, the original Knuth article algorithms for
constructing LR parsers were <br>
judged by its author to be impractically slow at that time.
Although full LR is more complex than LALR(1), as computer
speeds and algorithms improve, the difference (in terms of
<br>
acceptable wall-clock execution time) is becoming less
significant.</p>

<p style="margin-top: 1em">Potential authors are cautioned
that the referenced DeRemer and Pennello article previously
cited identifies a bug (an over-simplification of the
computation of LALR(1) lookahead <br>
sets) in some of the LALR(1) algorithm statements that
preceded it to publication. They should take the time to
seek out that paper, as well as current relevant work,
particu&acirc; <br>
larly Aho&rsquo;s.</p>

<p style="margin-top: 1em">The &acirc;b option was added to
provide a portable method for permitting yacc to work on
multiple separate parsers in the same directory. If a
directory contains more than one yacc <br>
grammar, and both grammars are constructed at the same time
(by, for example, a parallel make program), conflict
results. While the solution is not historical practice, it
cor&acirc; <br>
rects a known deficiency in historical implementations.
Corresponding changes were made to all sections that
referenced the filenames y.tab.c (now &lsquo;&lsquo;the code
file&rsquo;&rsquo;), y.tab.h <br>
(now &lsquo;&lsquo;the header file&rsquo;&rsquo;), and
y.output (now &lsquo;&lsquo;the description
file&rsquo;&rsquo;).</p>

<p style="margin-top: 1em">The grammar for yacc input is
based on System V documentation. The textual description
shows there that the &rsquo;;&rsquo; is required at the end
of the rule. The grammar and the implemen&acirc; <br>
tation do not require this. (The use of C_IDENTIFIER causes
a reduce to occur in the right place.)</p>

<p style="margin-top: 1em">Also, in that implementation,
the constructs such as %token can be terminated by a
&lt;semicolon&gt;, but this is not permitted by the grammar.
The keywords such as %token can also <br>
appear in uppercase, which is again not discussed. In most
places where &rsquo;%&rsquo; is used, &lt;backslash&gt; can
be substituted, and there are alternate spellings for some
of the symbols <br>
(for example, %LEFT can be &quot;%&lt;&quot; or even
&quot;&lt;&quot;).</p>

<p style="margin-top: 1em">Historically, &lt;tag&gt; can
contain any characters except &rsquo;&gt;&rsquo;, including
white space, in the implementation. However, since the tag
must reference an ISO C standard union member, in <br>
practice conforming implementations need to support only the
set of characters for ISO C standard identifiers in this
context.</p>

<p style="margin-top: 1em">Some historical implementations
are known to accept actions that are terminated by a period.
Historical implementations often allow &rsquo;$&rsquo; in
names. A conforming implementation does <br>
not need to support either of these behaviors.</p>

<p style="margin-top: 1em">Deciding when to use %prec
illustrates the difficulty in specifying the behavior of
yacc. There may be situations in which the grammar is not,
strictly speaking, in error, and <br>
yet yacc cannot interpret it unambiguously. The resolution
of ambiguities in the grammar can in many instances be
resolved by providing additional information, such as using
<br>
%type or %union declarations. It is often easier and it
usually yields a smaller parser to take this alternative
when it is appropriate.</p>

<p style="margin-top: 1em">The size and execution time of a
program produced without the runtime debugging code is
usually smaller and slightly faster in historical
implementations.</p>

<p style="margin-top: 1em">Statistics messages from several
historical implementations include the following types of
information:</p>

<p style="margin-top: 1em">n/512 terminals, n/300
non-terminals <br>
n/600 grammar rules, n/1500 states <br>
n shift/reduce, n reduce/reduce conflicts reported <br>
n/350 working sets used <br>
Memory: states, etc. n/15000, parser n/15000 <br>
n/600 distinct lookahead sets <br>
n extra closures <br>
n shift entries, n exceptions <br>
n goto entries <br>
n entries saved by goto default <br>
Optimizer space used: input n/15000, output n/15000 <br>
n table entries, n zero <br>
Maximum spread: n, Maximum offset: n</p>

<p style="margin-top: 1em">The report of internal tables in
the description file is left implementation-defined because
all aspects of these limits are also implementation-defined.
Some implementations may <br>
use dynamic allocation techniques and have no specific limit
values to report.</p>

<p style="margin-top: 1em">The format of the y.output file
is not given because specification of the format was not
seen to enhance applications portability. The listing is
primarily intended to help human <br>
users understand and debug the parser; use of y.output by a
conforming application script would be unusual. Furthermore,
implementations have not produced consistent output and <br>
no popular format was apparent. The format selected by the
implementation should be human-readable, in addition to the
requirement that it be a text file.</p>

<p style="margin-top: 1em">Standard error reports are not
specifically described because they are seldom of use to
conforming applications and there was no reason to restrict
implementations.</p>

<p style="margin-top: 1em">Some implementations recognize
&quot;={&quot; as equivalent to &rsquo;{&rsquo; because it
appears in historical documentation. This construction was
recognized and documented as obsolete as long ago <br>
as 1978, in the referenced Yacc: Yet Another
Compiler-Compiler. This volume of POSIX.1&acirc;2008 chose
to leave it as obsolete and omit it.</p>

<p style="margin-top: 1em">Multi-byte characters should be
recognized by the lexical analyzer and returned as tokens.
They should not be returned as multi-byte character
literals. The token error that is <br>
used for error recovery is normally assigned the value 256
in the historical implementation. Thus, the token value 256,
which is used in many multi-byte character sets, is not <br>
available for use as the value of a user-defined token.</p>

<p style="margin-top: 1em">FUTURE DIRECTIONS <br>
None.</p>

<p style="margin-top: 1em">SEE ALSO <br>
c99, lex</p>

<p style="margin-top: 1em">The Base Definitions volume of
POSIX.1&acirc;2008, Chapter 8, Environment Variables,
Section 12.2, Utility Syntax Guidelines</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Portions of this text are reprinted and reproduced in
electronic form from IEEE Std 1003.1, 2013 Edition, Standard
for Information Technology -- Portable Operating System
Inter&acirc; <br>
face (POSIX), The Open Group Base Specifications Issue 7,
Copyright (C) 2013 by the Institute of Electrical and
Electronics Engineers, Inc and The Open Group. (This is <br>
POSIX.1-2008 with the 2013 Technical Corrigendum 1 applied.)
In the event of any discrepancy between this version and the
original IEEE and The Open Group Standard, the original <br>
IEEE and The Open Group Standard is the referee document.
The original Standard can be obtained online at
http://www.unix.org/online.html .</p>

<p style="margin-top: 1em">Any typographical or formatting
errors that appear in this page are most likely to have been
introduced during the conversion of the source files to man
page format. To report <br>
such errors, see
https://www.kernel.org/doc/man-pages/reporting_bugs.html
.</p>

<p style="margin-top: 1em">IEEE/The Open Group 2013
YACC(1POSIX)</p>
<hr>
</body>
</html>
