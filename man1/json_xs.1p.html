<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:20:03 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>JSON_XS(1p) User Contributed Perl Documentation
JSON_XS(1p)</p>

<p style="margin-top: 1em">NAME <br>
json_xs - JSON::XS commandline utility</p>

<p style="margin-top: 1em">SYNOPSIS <br>
json_xs [-v] [-f inputformat] [-t outputformat]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
json_xs converts between some input and output formats (one
of them is JSON).</p>

<p style="margin-top: 1em">The default input format is
&quot;json&quot; and the default output format is
&quot;json-pretty&quot;.</p>

<p style="margin-top: 1em">OPTIONS <br>
-v Be slightly more verbose.</p>

<p style="margin-top: 1em">-f fromformat <br>
Read a file in the given format from STDIN.</p>

<p style="margin-top: 1em">&quot;fromformat&quot; can be
one of:</p>

<p style="margin-top: 1em">json - a json text encoded,
either utf-8, utf16-be/le, utf32-be/le <br>
cbor - CBOR (RFC 7049, CBOR::XS), a kind of binary JSON <br>
storable - a Storable frozen value <br>
storable-file - a Storable file (Storable has two
incompatible formats) <br>
bencode - use Convert::Bencode, if available (used by
torrent files, among others) <br>
clzf - Compress::LZF format (requires that module to be
installed) <br>
eval - evaluate the given code as (non-utf-8) Perl,
basically the reverse of &quot;-t dump&quot; <br>
yaml - YAML (avoid at all costs, requires the YAML module :)
<br>
string - do not attempt to decode the file data <br>
none - nothing is read, creates an &quot;undef&quot; scalar
- mainly useful with &quot;-e&quot; <br>
-t toformat <br>
Write the file in the given format to STDOUT.</p>

<p style="margin-top: 1em">&quot;toformat&quot; can be one
of:</p>

<p style="margin-top: 1em">json, json-utf-8 - json, utf-8
encoded <br>
json-pretty - as above, but pretty-printed <br>
json-utf-16le, json-utf-16be - little endian/big endian
utf-16 <br>
json-utf-32le, json-utf-32be - little endian/big endian
utf-32 <br>
cbor - CBOR (RFC 7049, CBOR::XS), a kind of binary JSON <br>
storable - a Storable frozen value in network format <br>
storable-file - a Storable file in network format (Storable
has two incompatible formats) <br>
bencode - use Convert::Bencode, if available (used by
torrent files, among others) <br>
clzf - Compress::LZF format <br>
yaml - YAML <br>
dump - Data::Dump <br>
dumper - Data::Dumper <br>
string - writes the data out as if it were a string <br>
none - nothing gets written, mainly useful together with
&quot;-e&quot; <br>
Note that Data::Dumper doesn&rsquo;t handle self-referential
data structures correctly - use &quot;dump&quot;
instead.</p>

<p style="margin-top: 1em">-e code <br>
Evaluate perl code after reading the data and before writing
it out again - can be used to filter, create or extract
data. The data that has been written is in $_, and <br>
whatever is in there is written out afterwards.</p>

<p style="margin-top: 1em">EXAMPLES <br>
json_xs -t none &lt;isitreally.json</p>

<p style="margin-top: 1em">&quot;JSON Lint&quot; - tries to
parse the file isitreally.json as JSON - if it is valid
JSON, the command outputs nothing, otherwise it will print
an error message and exit with non-zero <br>
exit status.</p>

<p style="margin-top: 1em">&lt;src.json json_xs
&gt;pretty.json</p>

<p style="margin-top: 1em">Prettify the JSON file src.json
to dst.json.</p>

<p style="margin-top: 1em">json_xs -f storable-file
&lt;file</p>

<p style="margin-top: 1em">Read the serialised Storable
file file and print a human-readable JSON version of it to
STDOUT.</p>

<p style="margin-top: 1em">json_xs -f storable-file -t yaml
&lt;file</p>

<p style="margin-top: 1em">Same as above, but write YAML
instead (not using JSON at all :)</p>

<p style="margin-top: 1em">json_xs -f none -e &rsquo;$_ =
[1, 2, 3]&rsquo;</p>

<p style="margin-top: 1em">Dump the perl array as UTF-8
encoded JSON text.</p>

<p style="margin-top: 1em">&lt;torrentfile json_xs -f
bencode -e &rsquo;$_ = join &quot;0, map @$_,
@{$_-&gt;{&quot;announce-list&quot;}}&rsquo; -t string</p>

<p style="margin-top: 1em">Print the tracker list inside a
torrent file.</p>

<p style="margin-top: 1em">lwp-request
http://cpantesters.perl.org/show/JSON-XS.json | json_xs</p>

<p style="margin-top: 1em">Fetch the cpan-testers result
summary &quot;JSON::XS&quot; and pretty-print it.</p>

<p style="margin-top: 1em">AUTHOR <br>
Copyright (C) 2008 Marc Lehmann &lt;json@schmorp.de&gt;</p>

<p style="margin-top: 1em">perl v5.24.1 2016-11-28
JSON_XS(1p)</p>
<hr>
</body>
</html>
