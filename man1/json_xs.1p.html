<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>JSON_XS(1p)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">JSON_XS(1p)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">JSON_XS(1p)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
json_xs - JSON::XS commandline utility
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
   json_xs [-v] [-f inputformat] [-t outputformat]
</pre>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>json_xs</i> converts between some input and output formats (one of them is
  JSON).
<div class="Pp"></div>
The default input format is &quot;json&quot; and the default output format is
  &quot;json-pretty&quot;.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag">-v</dt>
  <dd class="It-tag">Be slightly more verbose.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-f fromformat</dt>
  <dd class="It-tag">Read a file in the given format from STDIN.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;fromformat&quot; can be one of:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">json - a json text encoded, either utf-8, utf16-be/le,
    utf32-be/le</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">cbor - CBOR (RFC 7049, CBOR::XS), a kind of binary
    JSON</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">storable - a Storable frozen value</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">storable-file - a Storable file (Storable has two
    incompatible formats)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">bencode - use Convert::Bencode, if available (used by
    torrent files, among others)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">clzf - Compress::LZF format (requires that module to be
    installed)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">eval - evaluate the given code as (non-utf-8) Perl,
    basically the reverse of &quot;-t dump&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">yaml - YAML (avoid at all costs, requires the YAML module
    :)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string - do not attempt to decode the file data</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">none - nothing is read, creates an &quot;undef&quot; scalar
    - mainly useful with &quot;-e&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">-t toformat</dt>
  <dd class="It-tag">Write the file in the given format to STDOUT.
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;toformat&quot; can be one of:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">json, json-utf-8 - json, utf-8 encoded</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">json-pretty - as above, but pretty-printed</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">json-utf-16le, json-utf-16be - little endian/big endian
    utf-16</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">json-utf-32le, json-utf-32be - little endian/big endian
    utf-32</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">cbor - CBOR (RFC 7049, CBOR::XS), a kind of binary
    JSON</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">storable - a Storable frozen value in network format</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">storable-file - a Storable file in network format (Storable
    has two incompatible formats)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">bencode - use Convert::Bencode, if available (used by
    torrent files, among others)</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">clzf - Compress::LZF format</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">yaml - YAML</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dump - Data::Dump</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">dumper - Data::Dumper</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">string - writes the data out as if it were a string</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">none - nothing gets written, mainly useful together with
    &quot;-e&quot;</dt>
  <dd class="It-tag">Note that Data::Dumper doesn't handle self-referential data
      structures correctly - use &quot;dump&quot; instead.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">-e code</dt>
  <dd class="It-tag">Evaluate perl code after reading the data and before
      writing it out again - can be used to filter, create or extract data. The
      data that has been written is in $_, and whatever is in there is written
      out afterwards.</dd>
</dl>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<pre>
   json_xs -t none &lt;isitreally.json
</pre>
<div class="Pp"></div>
&quot;JSON Lint&quot; - tries to parse the file <i>isitreally.json</i> as JSON -
  if it is valid JSON, the command outputs nothing, otherwise it will print an
  error message and exit with non-zero exit status.
<div class="Pp"></div>
<pre>
   &lt;src.json json_xs &gt;pretty.json
</pre>
<div class="Pp"></div>
Prettify the JSON file <i>src.json</i> to <i>dst.json</i>.
<div class="Pp"></div>
<pre>
   json_xs -f storable-file &lt;file
</pre>
<div class="Pp"></div>
Read the serialised Storable file <i>file</i> and print a human-readable JSON
  version of it to STDOUT.
<div class="Pp"></div>
<pre>
   json_xs -f storable-file -t yaml &lt;file
</pre>
<div class="Pp"></div>
Same as above, but write YAML instead (not using JSON at all :)
<div class="Pp"></div>
<pre>
   json_xs -f none -e '$_ = [1, 2, 3]'
</pre>
<div class="Pp"></div>
Dump the perl array as UTF-8 encoded JSON text.
<div class="Pp"></div>
<pre>
   &lt;torrentfile json_xs -f bencode -e '$_ = join &quot;\n&quot;, map @$_, @{$_-&gt;{&quot;announce-list&quot;}}' -t string
</pre>
<div class="Pp"></div>
Print the tracker list inside a torrent file.
<div class="Pp"></div>
<pre>
   lwp-request http://cpantesters.perl.org/show/JSON-XS.json | json_xs
</pre>
<div class="Pp"></div>
Fetch the cpan-testers result summary &quot;JSON::XS&quot; and pretty-print it.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Copyright (C) 2008 Marc Lehmann &lt;json@schmorp.de&gt;</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-28</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
