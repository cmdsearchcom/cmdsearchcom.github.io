<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:39:51 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>tclsh(1) Tcl Applications tclsh(1)</p>


<p style="margin-top: 1em">_________________________________________________________________________________________________________________________________________________________________________________________</p>

<p style="margin-top: 1em">NAME <br>
tclsh - Simple shell containing Tcl interpreter</p>

<p style="margin-top: 1em">SYNOPSIS <br>
tclsh ?-encoding name? ?fileName arg arg ...?
_________________________________________________________________</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Tclsh is a shell-like application that reads Tcl commands
from its standard input or from a file and evaluates them.
If invoked with no arguments then it runs interactively,
<br>
reading Tcl commands from standard input and printing
command results and error messages to standard output. It
runs until the exit command is invoked or until it reaches
end- <br>
of-file on its standard input. If there exists a file
.tclshrc (or tclshrc.tcl on the Windows platforms) in the
home directory of the user, interactive tclsh evaluates the
file <br>
as a Tcl script just before reading the first command from
standard input.</p>

<p style="margin-top: 1em">SCRIPT FILES <br>
If tclsh is invoked with arguments then the first few
arguments specify the name of a script file, and,
optionally, the encoding of the text data stored in that
script file. Any &acirc; <br>
additional arguments are made available to the script as
variables (see below). Instead of reading commands from
standard input tclsh will read Tcl commands from the named
file; <br>
tclsh will exit when it reaches the end of the file. The end
of the file may be marked either by the physical end of the
medium, or by the character, &acirc; 32&acirc;
(&acirc;001a&acirc;, control- <br>
Z). If this character is present in the file, the tclsh
application will read text up to but not including the
character. An application that requires this character in
the <br>
file may safely encode it as &acirc; 32&acirc;,
&acirc;a&acirc;, or &acirc;001a&acirc;; or may generate it
by use of commands such as format or binary. There is no
automatic evaluation of .tclshrc when the <br>
name of a script file is presented on the tclsh command
line, but the script file can always source it if
desired.</p>

<p style="margin-top: 1em">If you create a Tcl script in a
file whose first line is <br>
#!/usr/local/bin/tclsh <br>
then you can invoke the script file directly from your shell
if you mark the file as executable. This assumes that tclsh
has been installed in the default location in <br>
/usr/local/bin; if it is installed somewhere else then you
will have to modify the above line to match. Many UNIX
systems do not allow the #! line to exceed about 30
characters <br>
in length, so be sure that the tclsh executable can be
accessed with a short file name.</p>

<p style="margin-top: 1em">An even better approach is to
start your script files with the following three lines: <br>
#!/bin/sh <br>
# the next line restarts using tclsh exec tclsh
&quot;$0&quot; ${1+&quot;$@&quot;} <br>
This approach has three advantages over the approach in the
previous paragraph. First, the location of the tclsh binary
does not have to be hard-wired into the script: it can <br>
be anywhere in your shell search path. Second, it gets
around the 30-character file name limit in the previous
approach. Third, this approach will work even if tclsh is
itself <br>
a shell script (this is done on some systems in order to
handle multiple architectures or operating systems: the
tclsh script selects one of several binaries to run). The
three <br>
lines cause both sh and tclsh to process the script, but the
exec is only executed by sh. sh processes the script first;
it treats the second line as a comment and executes the <br>
third line. The exec statement cause the shell to stop
processing and instead to start up tclsh to reprocess the
entire script. When tclsh starts up, it treats all three
lines <br>
as comments, since the backslash at the end of the second
line causes the third line to be treated as part of the
comment on the second line.</p>

<p style="margin-top: 1em">You should note that it is also
common practice to install tclsh with its version number as
part of the name. This has the advantage of allowing
multiple versions of Tcl to <br>
exist on the same system at once, but also the disadvantage
of making it harder to write scripts that start up uniformly
across different versions of Tcl.</p>

<p style="margin-top: 1em">VARIABLES <br>
Tclsh sets the following Tcl variables:</p>

<p style="margin-top: 1em">argc Contains a count of the
number of arg arguments (0 if none), not including the name
of the script file.</p>

<p style="margin-top: 1em">argv Contains a Tcl list whose
elements are the arg arguments, in order, or an empty string
if there are no arg arguments.</p>

<p style="margin-top: 1em">argv0 Contains fileName if it
was specified. Otherwise, contains the name by which tclsh
was invoked.</p>

<p style="margin-top: 1em">tcl_interactive <br>
Contains 1 if tclsh is running interactively (no fileName
was specified and standard input is a terminal-like device),
0 otherwise.</p>

<p style="margin-top: 1em">PROMPTS <br>
When tclsh is invoked interactively it normally prompts for
each command with &acirc;% &acirc;. You can change the
prompt by setting the variables tcl_prompt1 and tcl_prompt2.
If variable <br>
tcl_prompt1 exists then it must consist of a Tcl script to
output a prompt; instead of outputting a prompt tclsh will
evaluate the script in tcl_prompt1. The variable <br>
tcl_prompt2 is used in a similar way when a newline is typed
but the current command is not yet complete; if tcl_prompt2
is not set then no prompt is output for incomplete
com&acirc; <br>
mands.</p>

<p style="margin-top: 1em">STANDARD CHANNELS <br>
See Tcl_StandardChannels for more explanations.</p>

<p style="margin-top: 1em">SEE ALSO <br>
encoding(n), fconfigure(n), tclvars(n)</p>

<p style="margin-top: 1em">KEYWORDS <br>
argument, interpreter, prompt, script file, shell</p>

<p style="margin-top: 1em">Tcl tclsh(1)</p>
<hr>
</body>
</html>
