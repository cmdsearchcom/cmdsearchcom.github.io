<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:28:10 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>OC(1) June 2016 OC(1)</p>

<p style="margin-top: 1em">NAME <br>
oc debug - Launch a new instance of a pod for debugging</p>

<p style="margin-top: 1em">SYNOPSIS <br>
oc debug [OPTIONS]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Launch a command shell to debug a running application</p>

<p style="margin-top: 1em">When debugging images and setup
problems, it&rsquo;s useful to get an exact copy of a
running pod configuration and troubleshoot with a shell.
Since a pod that is failing may not be <br>
started and not accessible to &rsquo;rsh&rsquo; or
&rsquo;exec&rsquo;, the &rsquo;debug&rsquo; command makes it
easy to create a carbon copy of that setup.</p>

<p style="margin-top: 1em">The default mode is to start a
shell inside of the first container of the referenced pod,
replication controller, or deployment config. The started
pod will be a copy of your <br>
source pod, with labels stripped, the command changed to
&rsquo;/bin/sh&rsquo;, and readiness and liveness checks
disabled. If you just want to run a command, add
&rsquo;--&rsquo; and a command to run. <br>
Passing a command will not create a TTY or send STDIN by
default. Other flags are supported for altering the
container or pod in common ways.</p>

<p style="margin-top: 1em">A common problem running
containers is a security policy that prohibits you from
running as a root user on the cluster. You can use this
command to test running a pod as non-root <br>
(with --as-user) or to run a non-root pod as root (with
--as-root).</p>

<p style="margin-top: 1em">The debug pod is deleted when
the the remote command completes or the user interrupts the
shell.</p>

<p style="margin-top: 1em">OPTIONS <br>
--as-root=false <br>
If true, try to run the container as the root user</p>

<p style="margin-top: 1em">--as-user=-1 <br>
Try to run the container as a specific user UID (note:
admins may limit your ability to use this flag)</p>

<p style="margin-top: 1em">-c, --container=&quot;&quot;
<br>
Container name; defaults to first container</p>

<p style="margin-top: 1em">-f, --filename=&quot;&quot; <br>
Filename or URL to file to read a template</p>

<p style="margin-top: 1em">--keep-annotations=false <br>
If true, keep the original pod annotations</p>

<p style="margin-top: 1em">--keep-init-containers=true <br>
Run the init containers for the pod. Defaults to true.</p>

<p style="margin-top: 1em">--keep-liveness=false <br>
If true, keep the original pod liveness probes</p>

<p style="margin-top: 1em">--keep-readiness=false <br>
If true, keep the original pod readiness probes</p>

<p style="margin-top: 1em">-I, --no-stdin=false <br>
Bypasses passing STDIN to the container, defaults to true if
no command specified</p>

<p style="margin-top: 1em">-T, --no-tty=false <br>
Disable pseudo-terminal allocation</p>

<p style="margin-top: 1em">--node-name=&quot;&quot; <br>
Set a specific node to run on - by default the pod will run
on any valid node</p>

<p style="margin-top: 1em">--one-container=false <br>
If true, run only the selected container, remove all
others</p>

<p style="margin-top: 1em">-o, --output=&quot;&quot; <br>
Output format. One of:
json|yaml|wide|name|go-template=...|go-template-file=...|jsonpath=...|jsonpath-file=...
See golang template [
&acirc;&uml;http://golang.org/pkg/text/tem&acirc; <br>
plate/#pkg-overview&acirc;&copy;] and jsonpath template [
&acirc;&uml;http://kubernetes.io/docs/user-guide/jsonpath/&acirc;&copy;].</p>

<p style="margin-top: 1em">--output-version=&quot;&quot;
<br>
Output the formatted object with the given version (default
api-version).</p>

<p style="margin-top: 1em">--template=&quot;&quot; <br>
Template string or path to template file to use when
-o=go-template, -o=go-template-file. The template format is
golang templates [
&acirc;&uml;http://golang.org/pkg/text/template/#pkg- <br>
overview&acirc;&copy;].</p>

<p style="margin-top: 1em">-t, --tty=false <br>
Force a pseudo-terminal to be allocated</p>

<p style="margin-top: 1em">OPTIONS INHERITED FROM PARENT
COMMANDS <br>
--api-version=&quot;&quot; <br>
DEPRECATED: The API version to use when talking to the
server</p>

<p style="margin-top: 1em">--as=&quot;&quot; <br>
Username to impersonate for the operation</p>


<p style="margin-top: 1em">--azure-container-registry-config=&quot;&quot;
<br>
Path to the file container Azure container registry
configuration information.</p>


<p style="margin-top: 1em">--certificate-authority=&quot;&quot;
<br>
Path to a cert. file for the certificate authority</p>


<p style="margin-top: 1em">--client-certificate=&quot;&quot;
<br>
Path to a client certificate file for TLS</p>

<p style="margin-top: 1em">--client-key=&quot;&quot; <br>
Path to a client key file for TLS</p>

<p style="margin-top: 1em">--cluster=&quot;&quot; <br>
The name of the kubeconfig cluster to use</p>

<p style="margin-top: 1em">--config=&quot;&quot; <br>
Path to the config file to use for CLI requests.</p>

<p style="margin-top: 1em">--context=&quot;&quot; <br>
The name of the kubeconfig context to use</p>

<p style="margin-top: 1em">--google-json-key=&quot;&quot;
<br>
The Google Cloud Platform Service Account JSON Key to use
for authentication.</p>


<p style="margin-top: 1em">--insecure-skip-tls-verify=false
<br>
If true, the server&rsquo;s certificate will not be checked
for validity. This will make your HTTPS connections
insecure</p>

<p style="margin-top: 1em">--log-flush-frequency=0 <br>
Maximum number of seconds between log flushes</p>

<p style="margin-top: 1em">--match-server-version=false
<br>
Require server version to match client version</p>

<p style="margin-top: 1em">-n, --namespace=&quot;&quot;
<br>
If present, the namespace scope for this CLI request</p>

<p style="margin-top: 1em">--request-timeout=&quot;0&quot;
<br>
The length of time to wait before giving up on a single
server request. Non-zero values should contain a
corresponding time unit (e.g. 1s, 2m, 3h). A value of zero
means <br>
don&rsquo;t timeout requests.</p>

<p style="margin-top: 1em">--server=&quot;&quot; <br>
The address and port of the Kubernetes API server</p>

<p style="margin-top: 1em">--token=&quot;&quot; <br>
Bearer token for authentication to the API server</p>

<p style="margin-top: 1em">--user=&quot;&quot; <br>
The name of the kubeconfig user to use</p>

<p style="margin-top: 1em">EXAMPLE <br>
# Debug a currently running deployment <br>
oc debug dc/test</p>

<p style="margin-top: 1em"># Test running a deployment as a
non-root user <br>
oc debug dc/test --as-user=1000000</p>

<p style="margin-top: 1em"># Debug a specific failing
container by running the env command in the
&rsquo;second&rsquo; container <br>
oc debug dc/test -c second -- /bin/env</p>

<p style="margin-top: 1em"># See the pod that would be
created to debug <br>
oc debug dc/test -o yaml</p>

<p style="margin-top: 1em">SEE ALSO <br>
oc(1),</p>

<p style="margin-top: 1em">HISTORY <br>
June 2016, Ported from the Kubernetes man-doc generator</p>

<p style="margin-top: 1em">Openshift Openshift CLI User
Manuals OC(1)</p>
<hr>
</body>
</html>
