<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:20:29 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>keytool(1) General Commands Manual keytool(1)</p>

<p style="margin-top: 1em">Name <br>
keytool - Key and Certificate Management Tool</p>

<p style="margin-top: 1em">Manages a keystore (database) of
cryptographic keys, X.509 certificate chains, and trusted
certificates.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
keytool [ commands ]</p>

<p style="margin-top: 1em">The keytool command interface
has changed in Java SE 6. See the Changes Section for a
detailed description. Note that previously defined commands
are still supported.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
keytool is a key and certificate management utility. It
allows users to administer their own public/private key
pairs and associated certificates for use in
self-authentication <br>
(where the user authenticates himself/herself to other
users/services) or data integrity and authentication
services, using digital signatures. It also allows users to
cache the <br>
public keys (in the form of certificates) of their
communicating peers.</p>

<p style="margin-top: 1em">A certificate is a digitally
signed statement from one entity (person, company, etc.),
saying that the public key (and some other information) of
some other entity has a particu&acirc; <br>
lar value. (See Certificates.) When data is digitally
signed, the signature can be verified to check the data
integrity and authenticity. Integrity means that the data
has not <br>
been modified or tampered with, and authenticity means the
data indeed comes from whoever claims to have created and
signed it.</p>

<p style="margin-top: 1em">keytool also enables users to
administer secret keys used in symmetric
encryption/decryption (e.g. DES).</p>

<p style="margin-top: 1em">keytool stores the keys and
certificates in a keystore.</p>

<p style="margin-top: 1em">COMMAND AND OPTION NOTES <br>
The various commands and their options are listed and
described below. Note:</p>

<p style="margin-top: 1em">o All command and option names
are preceded by a minus sign (-).</p>

<p style="margin-top: 1em">o The options for each command
may be provided in any order.</p>

<p style="margin-top: 1em">o All items not italicized or in
braces or square brackets are required to appear as is.</p>

<p style="margin-top: 1em">o Braces surrounding an option
generally signify that a default value will be used if the
option is not specified on the command line. Braces are also
used around the -v, <br>
-rfc, and -J options, which only have meaning if they appear
on the command line (that is, they don&rsquo;t have any
&quot;default&quot; values other than not existing).</p>

<p style="margin-top: 1em">o Brackets surrounding an option
signify that the user is prompted for the value(s) if the
option is not specified on the command line. (For a -keypass
option, if you do not <br>
specify the option on the command line, keytool will first
attempt to use the keystore password to recover the
private/secret key, and if this fails, will then prompt you
<br>
for the private/secret key password.)</p>

<p style="margin-top: 1em">o Items in italics (option
values) represent the actual values that must be supplied.
For example, here is the format of the -printcert command:
<br>
keytool -printcert {-file cert_file} {-v}</p>

<p style="margin-top: 1em">When specifying a -printcert
command, replace cert_file with the actual file name, as in:
<br>
keytool -printcert -file VScert.cer</p>

<p style="margin-top: 1em">o Option values must be quoted
if they contain a blank (space).</p>

<p style="margin-top: 1em">o The -help command is the
default. Thus, the command line <br>
keytool</p>

<p style="margin-top: 1em">is equivalent to <br>
keytool -help</p>

<p style="margin-top: 1em">Option Defaults <br>
Below are the defaults for various option values.</p>

<p style="margin-top: 1em">-alias &quot;mykey&quot;</p>

<p style="margin-top: 1em">-keyalg <br>
&quot;DSA&quot; (when using -genkeypair) <br>
&quot;DES&quot; (when using -genseckey)</p>

<p style="margin-top: 1em">-keysize <br>
2048 (when using -genkeypair and -keyalg is &quot;RSA&quot;)
<br>
1024 (when using -genkeypair and -keyalg is &quot;DSA&quot;)
<br>
256 (when using -genkeypair and -keyalg is &quot;EC&quot;)
<br>
56 (when using -genseckey and -keyalg is &quot;DES&quot;)
<br>
168 (when using -genseckey and -keyalg is
&quot;DESede&quot;)</p>

<p style="margin-top: 1em">-validity 90</p>

<p style="margin-top: 1em">-keystore the file named
.keystore in the user&rsquo;s home directory</p>

<p style="margin-top: 1em">-storetype the value of the
&quot;keystore.type&quot; property in the security
properties file, <br>
which is returned by the static getDefaultType method in
<br>
java.security.KeyStore</p>

<p style="margin-top: 1em">-file stdin if reading, stdout
if writing</p>

<p style="margin-top: 1em">-protected false</p>

<p style="margin-top: 1em">In generating a public/private
key pair, the signature algorithm (-sigalg option) is
derived from the algorithm of the underlying private
key:</p>

<p style="margin-top: 1em">o If the underlying private key
is of type &quot;DSA&quot;, the -sigalg option defaults to
&quot;SHA1withDSA&quot;</p>

<p style="margin-top: 1em">o If the underlying private key
is of type &quot;RSA&quot;, the -sigalg option defaults to
&quot;SHA256withRSA&quot;.</p>

<p style="margin-top: 1em">o If the underlying private key
is of type &quot;EC&quot;, the -sigalg option defaults to
&quot;SHA256withECDSA&quot;.</p>

<p style="margin-top: 1em">Please consult the Java
Cryptography Architecture API Specification &amp; Reference
@ <br>

http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA
for a full list of -keyalg and -sigalg you can choose
from.</p>

<p style="margin-top: 1em">Common Options <br>
The -v option can appear for all commands except -help. If
it appears, it signifies &quot;verbose&quot; mode; more
information will be provided in the output.</p>

<p style="margin-top: 1em">There is also a -Jjavaoption
option that may appear for any command. If it appears, the
specified javaoption string is passed through directly to
the Java interpreter. This <br>
option should not contain any spaces. It is useful for
adjusting the execution environment or memory usage. For a
list of possible interpreter options, type java -h or java
-X at <br>
the command line.</p>

<p style="margin-top: 1em">These options may appear for all
commands operating on a keystore:</p>

<p style="margin-top: 1em">-storetype storetype</p>

<p style="margin-top: 1em">This qualifier specifies the
type of keystore to be instantiated.</p>

<p style="margin-top: 1em">-keystore keystore</p>

<p style="margin-top: 1em">The keystore location.</p>

<p style="margin-top: 1em">If the JKS storetype is used and
a keystore file does not yet exist, then certain keytool
commands may result in a new keystore file being created.
For example, if keytool <br>
-genkeypair is invoked and the -keystore option is not
specified, the default keystore file named .keystore in the
user&rsquo;s home directory will be created if it does not
already <br>
exist. Similarly, if the -keystore ks_file option is
specified but ks_file does not exist, then it will be
created</p>

<p style="margin-top: 1em">Note that the input stream from
the -keystore option is passed to the KeyStore.load method.
If NONE is specified as the URL, then a null stream is
passed to the KeyStore.load <br>
method. NONE should be specified if the KeyStore is not
file-based (for example, if it resides on a hardware token
device).</p>

<p style="margin-top: 1em">-storepass[:env|:file]
argument</p>

<p style="margin-top: 1em">The password which is used to
protect the integrity of the keystore.</p>

<p style="margin-top: 1em">If the modifier env or file is
not specified, then the password has the value argument,
which must be at least 6 characters long. Otherwise, the
password is retrieved as fol&acirc; <br>
lows:</p>

<p style="margin-top: 1em">o env: Retrieve the password
from the environment variable named argument</p>

<p style="margin-top: 1em">o file: Retrieve the password
from the file named argument</p>

<p style="margin-top: 1em">Note: All other options that
require passwords, such as -keypass, -srckeypass,
-destkeypass -srcstorepass, and -deststorepass, accept the
env and file modifiers. (Remember to <br>
separate the password option and the modifier with a colon,
(:).)</p>

<p style="margin-top: 1em">The password must be provided to
all commands that access the keystore contents. For such
commands, if a -storepass option is not provided at the
command line, the user is <br>
prompted for it.</p>

<p style="margin-top: 1em">When retrieving information from
the keystore, the password is optional; if no password is
given, the integrity of the retrieved information cannot be
checked and a warning is <br>
displayed.</p>

<p style="margin-top: 1em">-providerName provider_name</p>

<p style="margin-top: 1em">Used to identify a cryptographic
service provider&rsquo;s name when listed in the security
properties file.</p>

<p style="margin-top: 1em">-providerClass
provider_class_name</p>

<p style="margin-top: 1em">Used to specify the name of
cryptographic service provider&rsquo;s master class file
when the service provider is not listed in the security
properties file.</p>

<p style="margin-top: 1em">-providerArg provider_arg</p>

<p style="margin-top: 1em">Used in conjunction with
-providerClass. Represents an optional string input argument
for the constructor of provider_class_name.</p>

<p style="margin-top: 1em">-protected</p>

<p style="margin-top: 1em">Either true or false. This value
should be specified as true if a password must be given via
a protected authentication path such as a dedicated PIN
reader.</p>

<p style="margin-top: 1em">Note: Since there are two
keystores involved in -importkeystore command, two options,
namely, -srcprotected and -destprotected are provided for
the source keystore and the <br>
destination keystore respectively.</p>

<p style="margin-top: 1em">-ext
{name{:critical}{=value}}</p>

<p style="margin-top: 1em">Denotes an X.509 certificate
extension. The option can be used in -genkeypair and
-gencert to embed extensions into the certificate generated,
or in -certreq to show what <br>
extensions are requested in the certificate request. The
option can appear multiple times. name can be a supported
extension name (see below) or an arbitrary OID number. <br>
value, if provided, denotes the parameter for the extension;
if omitted, denotes the default value (if defined) of the
extension or the extension requires no parameter. The <br>
:critical modifier, if provided, means the extension&rsquo;s
isCritical attribute is true; otherwise, false. You may use
:c in place of :critical.</p>

<p style="margin-top: 1em">Currently keytool supports these
named extensions (case-insensitive):</p>

<p style="margin-top: 1em">For name as OID, value is the
HEX dumped DER encoding of the extnValue for the extension
excluding the OCTET STRING type and length bytes. Any extra
character other than standard <br>
HEX numbers (0-9, a-f, A-F) are ignored in the HEX string.
Therefore, both &quot;01:02:03:04&quot; and
&quot;01020304&quot; are accepted as identical values. If
there is no value, the extension has <br>
an empty value field then.</p>

<p style="margin-top: 1em">A special name
&rsquo;honored&rsquo;, used in -gencert only, denotes how
the extensions included in the certificate request should be
honored. The value for this name is a comma separated <br>
list of &quot;all&quot; (all requested extensions are
honored), &quot;name{:[critical|non-critical]}&quot; (the
named extension is honored, but using a different isCritical
attribute) and &quot;-name&quot; <br>
(used with all, denotes an exception). Requested extensions
are not honored by default.</p>

<p style="margin-top: 1em">If, besides the -ext honored
option, another named or OID -ext option is provided, this
extension will be added to those already honored. However,
if this name (or OID) also <br>
appears in the honored value, its value and criticality
overrides the one in the request.</p>

<p style="margin-top: 1em">The subjectKeyIdentifier
extension is always created. For non self-signed
certificates, the authorityKeyIdentifier is always
created.</p>

<p style="margin-top: 1em">Note: Users should be aware that
some combinations of extensions (and other certificate
fields) may not conform to the Internet standard. See
Warning Regarding Certificate Con&acirc; <br>
formance for details.</p>

<p style="margin-top: 1em">COMMANDS <br>
Creating or Adding Data to the Keystore <br>
-gencert {-rfc} {-infile infile} {-outfile outfile} {-alias
alias} {-sigalg sigalg} {-dname dname} {-startdate startdate
{-ext ext}* {-validity valDays} [-keypass keypass] <br>
{-keystore keystore} [-storepass storepass] {-storetype
storetype} {-providername provider_name} {-providerClass
provider_class_name {-providerArg provider_arg}} {-v}
{-pro&acirc; <br>
tected} {-Jjavaoption}</p>

<p style="margin-top: 1em">Generates a certificate as a
response to a certificate request file (which can be created
by the keytool -certreq command). The command reads the
request from infile (if omit&acirc; <br>
ted, from the standard input), signs it using alias&rsquo;s
private key, and output the X.509 certificate into outfile
(if omitted, to the standard output). If -rfc is specified,
<br>
output format is BASE64-encoded PEM; otherwise, a binary DER
is created.</p>

<p style="margin-top: 1em">sigalg specifies the algorithm
that should be used to sign the certificate. startdate is
the start time/date that the certificate is valid. valDays
tells the number of days <br>
for which the certificate should be considered valid.</p>

<p style="margin-top: 1em">If dname is provided, it&rsquo;s
used as the subject of the generated certificate. Otherwise,
the one from the certificate request is used.</p>

<p style="margin-top: 1em">ext shows what X.509 extensions
will be embedded in the certificate. Read Common Options for
the grammar of -ext.</p>

<p style="margin-top: 1em">The -gencert command enables you
to create certificate chains. The following example creates
a certificate, e1, that contains three certificates in its
certificate chain.</p>

<p style="margin-top: 1em">The following commands creates
four key pairs named ca, ca1, ca2, and e1: <br>
keytool -alias ca -dname CN=CA -genkeypair <br>
keytool -alias ca1 -dname CN=CA -genkeypair <br>
keytool -alias ca2 -dname CN=CA -genkeypair <br>
keytool -alias e1 -dname CN=E1 -genkeypair</p>

<p style="margin-top: 1em">The following two commands
create a chain of signed certificates; ca signs ca1 and ca1
signs ca2, all of which are self-issued: <br>
keytool -alias ca1 -certreq | keytool -alias ca -gencert
-ext san=dns:ca1 | keytool -alias ca1 -importcert <br>
keytool -alias ca2 -certreq | $KT -alias ca1 -gencert -ext
san=dns:ca2 | $KT -alias ca2 -importcert</p>

<p style="margin-top: 1em">The following command creates
the certificate e1 and stores it in the file e1.cert, which
is signed by ca2. As a result, e1 should contain ca, ca1,
and ca2 in its certificate <br>
chain: <br>
keytool -alias e1 -certreq | keytool -alias ca2 -gencert
&gt; e1.cert</p>

<p style="margin-top: 1em">-genkeypair {-alias alias}
{-keyalg keyalg} {-keysize keysize} {-sigalg sigalg} [-dname
dname] [-keypass keypass] {-startdate value} {-ext ext}*
{-validity valDays} {-store&acirc; <br>
type storetype} {-keystore keystore} [-storepass storepass]
{-providerClass provider_class_name {-providerArg
provider_arg}} {-v} {-protected} {-Jjavaoption}</p>

<p style="margin-top: 1em">Generates a key pair (a public
key and associated private key). Wraps the public key into
an X.509 v3 self-signed certificate, which is stored as a
single-element certificate <br>
chain. This certificate chain and the private key are stored
in a new keystore entry identified by alias.</p>

<p style="margin-top: 1em">keyalg specifies the algorithm
to be used to generate the key pair, and keysize specifies
the size of each key to be generated. sigalg specifies the
algorithm that should be <br>
used to sign the self-signed certificate; this algorithm
must be compatible with keyalg.</p>

<p style="margin-top: 1em">dname specifies the X.500
Distinguished Name to be associated with alias, and is used
as the issuer and subject fields in the self-signed
certificate. If no distinguished name <br>
is provided at the command line, the user will be prompted
for one.</p>

<p style="margin-top: 1em">keypass is a password used to
protect the private key of the generated key pair. If no
password is provided, the user is prompted for it. If you
press RETURN at the prompt, <br>
the key password is set to the same password as that used
for the keystore. keypass must be at least 6 characters
long.</p>

<p style="margin-top: 1em">startdate specifies the issue
time of the certificate, also known as the &quot;Not
Before&quot; value of the X.509 certificate&rsquo;s Validity
field.</p>

<p style="margin-top: 1em">The option value can be set in
one of these two forms:</p>

<p style="margin-top: 1em">1. ([+-]nnn[ymdHMS])+</p>

<p style="margin-top: 1em">2. [yyyy/mm/dd] [HH:MM:SS]</p>

<p style="margin-top: 1em">With the first form, the issue
time is shifted by the specified value from the current
time. The value is a concatenation of a sequence of sub
values. Inside each sub value, <br>
the plus sign (&quot;+&quot;) means shifting forward, and
the minus sign (&quot;-&quot;) means shifting backward. The
time to be shifted is nnn units of years, months, days,
hours, minutes, or <br>
seconds (denoted by a single character of &quot;y&quot;,
&quot;m&quot;, &quot;d&quot;, &quot;H&quot;, &quot;M&quot;,
or &quot;S&quot; respectively). The exact value of the issue
time is calculated using the java.util.GregorianCalen&acirc;
<br>
dar.add(int field, int amount) method on each sub value,
from left to right. For example, by specifying
&quot;-startdate -1y+1m-1d&quot;, the issue time will be:
<br>
Calendar c = new GregorianCalendar(); <br>
c.add(Calendar.YEAR, -1); <br>
c.add(Calendar.MONTH, 1); <br>
c.add(Calendar.DATE, -1); <br>
return c.getTime()</p>

<p style="margin-top: 1em">With the second form, the user
sets the exact issue time in two parts, year/month/day and
hour:minute:second (using the local time zone). The user may
provide only one part, <br>
which means the other part is the same as the current date
(or time). User must provide the exact number of digits as
shown in the format definition (padding with 0 if <br>
shorter). When both the date and time are provided, there is
one (and only one) space character between the two parts.
The hour should always be provided in 24 hour format.</p>

<p style="margin-top: 1em">When the option is not provided,
the start date is the current time. The option can be
provided at most once.</p>

<p style="margin-top: 1em">valDays specifies the number of
days (starting at the date specified by -startdate, or the
current date if -startdate is not specified) for which the
certificate should be <br>
considered valid.</p>

<p style="margin-top: 1em">This command was named -genkey
in previous releases. This old name is still supported in
this release and will be supported in future releases, but
for clarity the new name, <br>
-genkeypair, is preferred going forward.</p>

<p style="margin-top: 1em">-genseckey {-alias alias}
{-keyalg keyalg} {-keysize keysize} [-keypass keypass]
{-storetype storetype} {-keystore keystore} [-storepass
storepass] {-providerClass <br>
provider_class_name {-providerArg provider_arg}} {-v}
{-protected} {-Jjavaoption}</p>

<p style="margin-top: 1em">Generates a secret key and
stores it in a new KeyStore.SecretKeyEntry identified by
alias.</p>

<p style="margin-top: 1em">keyalg specifies the algorithm
to be used to generate the secret key, and keysize specifies
the size of the key to be generated. keypass is a password
used to protect the <br>
secret key. If no password is provided, the user is prompted
for it. If you press RETURN at the prompt, the key password
is set to the same password as that used for the key&acirc;
<br>
store. keypass must be at least 6 characters long.</p>

<p style="margin-top: 1em">-importcert {-alias alias}
{-file cert_file} [-keypass keypass] {-noprompt}
{-trustcacerts} {-storetype storetype} {-keystore keystore}
[-storepass storepass] {-providerName <br>
provider_name} {-providerClass provider_class_name
{-providerArg provider_arg}} {-v} {-protected}
{-Jjavaoption}</p>

<p style="margin-top: 1em">Reads the certificate or
certificate chain (where the latter is supplied in a PKCS#7
formatted reply or a sequence of X.509 certificates) from
the file cert_file, and stores <br>
it in the keystore entry identified by alias. If no file is
given, the certificate or certificate chain is read from
stdin.</p>

<p style="margin-top: 1em">keytool can import X.509 v1, v2,
and v3 certificates, and PKCS#7 formatted certificate chains
consisting of certificates of that type. The data to be
imported must be provided <br>
either in binary encoding format, or in printable encoding
format (also known as Base64 encoding) as defined by the
Internet RFC 1421 standard. In the latter case, the
encod&acirc; <br>
ing must be bounded at the beginning by a string that starts
with &quot;-----BEGIN&quot;, and bounded at the end by a
string that starts with &quot;-----END&quot;.</p>

<p style="margin-top: 1em">You import a certificate for two
reasons:</p>

<p style="margin-top: 1em">1. to add it to the list of
trusted certificates, or</p>

<p style="margin-top: 1em">2. to import a certificate reply
received from a CA as the result of submitting a Certificate
Signing Request (see the -certreq command) to that CA.</p>

<p style="margin-top: 1em">Which type of import is intended
is indicated by the value of the -alias option:</p>

<p style="margin-top: 1em">1. If the alias does not point
to a key entry, then keytool assumes you are adding a
trusted certificate entry. In this case, the alias should
not already exist in the key&acirc; <br>
store. If the alias does already exist, then keytool outputs
an error, since there is already a trusted certificate for
that alias, and does not import the certificate.</p>

<p style="margin-top: 1em">2. If the alias points to a key
entry, then keytool assumes you are importing a certificate
reply. <br>
Importing a New Trusted Certificate</p>

<p style="margin-top: 1em">Before adding the certificate to
the keystore, keytool tries to verify it by attempting to
construct a chain of trust from that certificate to a
self-signed certificate <br>
(belonging to a root CA), using trusted certificates that
are already available in the keystore.</p>

<p style="margin-top: 1em">If the -trustcacerts option has
been specified, additional certificates are considered for
the chain of trust, namely the certificates in a file named
&quot;cacerts&quot;.</p>

<p style="margin-top: 1em">If keytool fails to establish a
trust path from the certificate to be imported up to a
self-signed certificate (either from the keystore or the
&quot;cacerts&quot; file), the certifi&acirc; <br>
cate information is printed out, and the user is prompted to
verify it, e.g., by comparing the displayed certificate
fingerprints with the fingerprints obtained from some <br>
other (trusted) source of information, which might be the
certificate owner himself/herself. Be very careful to ensure
the certificate is valid prior to importing it as a <br>
&quot;trusted&quot; certificate! -- see WARNING Regarding
Importing Trusted Certificates. The user then has the option
of aborting the import operation. If the -noprompt option is
<br>
given, however, there will be no interaction with the user.
Importing a Certificate Reply</p>

<p style="margin-top: 1em">When importing a certificate
reply, the certificate reply is validated using trusted
certificates from the keystore, and optionally using the
certificates configured in the <br>
&quot;cacerts&quot; keystore file (if the -trustcacerts
option was specified).</p>

<p style="margin-top: 1em">The methods of determining
whether the certificate reply is trusted are described in
the following:</p>

<p style="margin-top: 1em">o If the reply is a single X.509
certificate, keytool attempts to establish a trust chain,
starting at the certificate reply and ending at a
self-signed certificate <br>
(belonging to a root CA). The certificate reply and the
hierarchy of certificates used to authenticate the
certificate reply form the new certificate chain of alias.
If a <br>
trust chain cannot be established, the certificate reply is
not imported. In this case, keytool does not print out the
certificate and prompt the user to verify it, <br>
because it is very hard (if not impossible) for a user to
determine the authenticity of the certificate reply.</p>

<p style="margin-top: 1em">o If the reply is a PKCS#7
formatted certificate chain or a sequence of X.509
certificates, the chain is ordered with the user certificate
first followed by zero or more CA <br>
certificates. If the chain ends with a self-signed root CA
certificate and -trustcacerts option was specified, keytool
will attempt to match it with any of the trusted <br>
certificates in the keystore or the &quot;cacerts&quot;
keystore file. If the chain does not end with a self-signed
root CA certificate and the -trustcacerts option was
specified, <br>
keytool will try to find one from the trusted certificates
in the keystore or the &quot;cacerts&quot; keystore file and
add it to the end of the chain. If the certificate is not
<br>
found and -noprompt option is not specified, the information
of the last certificate in the chain is printed out, and the
user is prompted to verify it.</p>

<p style="margin-top: 1em">If the public key in the
certificate reply matches the user&rsquo;s public key
already stored with under alias, the old certificate chain
is replaced with the new certificate chain <br>
in the reply. The old chain can only be replaced if a valid
keypass, the password used to protect the private key of the
entry, is supplied. If no password is provided, and <br>
the private key password is different from the keystore
password, the user is prompted for it.</p>

<p style="margin-top: 1em">This command was named -import
in previous releases. This old name is still supported in
this release and will be supported in future releases, but
for clarify the new name, <br>
-importcert, is preferred going forward.</p>

<p style="margin-top: 1em">-importkeystore -srckeystore
srckeystore -destkeystore destkeystore {-srcstoretype
srcstoretype} {-deststoretype deststoretype} [-srcstorepass
srcstorepass] [-deststorepass <br>
deststorepass] {-srcprotected} {-destprotected} {-srcalias
srcalias {-destalias destalias} [-srckeypass srckeypass]
[-destkeypass destkeypass] } {-noprompt} {-srcProviderName
<br>
src_provider_name} {-destProviderName dest_provider_name}
{-providerClass provider_class_name {-providerArg
provider_arg}} {-v} {-protected} {-Jjavaoption}</p>

<p style="margin-top: 1em">Imports a single entry or all
entries from a source keystore to a destination
keystore.</p>

<p style="margin-top: 1em">When the srcalias option is
provided, the command imports the single entry identified by
the alias to the destination keystore. If a destination
alias is not provided with <br>
destalias, then srcalias is used as the destination alias.
If the source entry is protected by a password, srckeypass
will be used to recover the entry. If srckeypass is not <br>
provided, then keytool will attempt to use srcstorepass to
recover the entry. If srcstorepass is either not provided or
is incorrect, the user will be prompted for a password. <br>
The destination entry will be protected using destkeypass.
If destkeypass is not provided, the destination entry will
be protected with the source entry password.</p>

<p style="margin-top: 1em">If the srcalias option is not
provided, then all entries in the source keystore are
imported into the destination keystore. Each destination
entry will be stored under the <br>
alias from the source entry. If the source entry is
protected by a password, srcstorepass will be used to
recover the entry. If srcstorepass is either not provided or
is <br>
incorrect, the user will be prompted for a password. If a
source keystore entry type is not supported in the
destination keystore, or if an error occurs while storing an
entry <br>
into the destination keystore, the user will be prompted
whether to skip the entry and continue, or to quit. The
destination entry will be protected with the source entry
<br>
password.</p>

<p style="margin-top: 1em">If the destination alias already
exists in the destination keystore, the user is prompted to
either overwrite the entry, or to create a new entry under a
different alias name.</p>

<p style="margin-top: 1em">Note that if -noprompt is
provided, the user will not be prompted for a new
destination alias. Existing entries will automatically be
overwritten with the destination alias <br>
name. Finally, entries that can not be imported are
automatically skipped and a warning is output.</p>

<p style="margin-top: 1em">-printcertreq {-file file}</p>

<p style="margin-top: 1em">Prints the content of a PKCS #10
format certificate request, which can be generated by the
keytool -certreq command. The command reads the request from
file; if omitted, from <br>
the standard input.</p>

<p style="margin-top: 1em">Exporting Data <br>
-certreq {-alias alias} {-dname dname} {-sigalg sigalg}
{-file certreq_file} [-keypass keypass] {-storetype
storetype} {-keystore keystore} [-storepass storepass]
{-provider&acirc; <br>
Name provider_name} {-providerClass provider_class_name
{-providerArg provider_arg}} {-v} {-protected}
{-Jjavaoption}</p>

<p style="margin-top: 1em">Generates a Certificate Signing
Request (CSR), using the PKCS#10 format.</p>

<p style="margin-top: 1em">A CSR is intended to be sent to
a certificate authority (CA). The CA will authenticate the
certificate requestor (usually off-line) and will return a
certificate or certifi&acirc; <br>
cate chain, used to replace the existing certificate chain
(which initially consists of a self-signed certificate) in
the keystore.</p>

<p style="margin-top: 1em">The private key associated with
alias is used to create the PKCS#10 certificate request. In
order to access the private key, the appropriate password
must be provided, since <br>
private keys are protected in the keystore with a password.
If keypass is not provided at the command line, and is
different from the password used to protect the integrity of
<br>
the keystore, the user is prompted for it. If dname is
provided, it&rsquo;s used as the subject in the CSR.
Otherwise, the X.500 Distinguished Name associated with
alias is used.</p>

<p style="margin-top: 1em">sigalg specifies the algorithm
that should be used to sign the CSR.</p>

<p style="margin-top: 1em">The CSR is stored in the file
certreq_file. If no file is given, the CSR is output to
stdout.</p>

<p style="margin-top: 1em">Use the importcert command to
import the response from the CA.</p>

<p style="margin-top: 1em">-exportcert {-alias alias}
{-file cert_file} {-storetype storetype} {-keystore
keystore} [-storepass storepass] {-providerName
provider_name} {-providerClass <br>
provider_class_name {-providerArg provider_arg}} {-rfc} {-v}
{-protected} {-Jjavaoption}</p>

<p style="margin-top: 1em">Reads (from the keystore) the
certificate associated with alias, and stores it in the file
cert_file.</p>

<p style="margin-top: 1em">If no file is given, the
certificate is output to stdout.</p>

<p style="margin-top: 1em">The certificate is by default
output in binary encoding, but will instead be output in the
printable encoding format, as defined by the Internet RFC
1421 standard, if the -rfc <br>
option is specified.</p>

<p style="margin-top: 1em">If alias refers to a trusted
certificate, that certificate is output. Otherwise, alias
refers to a key entry with an associated certificate chain.
In that case, the first cer&acirc; <br>
tificate in the chain is returned. This certificate
authenticates the public key of the entity addressed by
alias.</p>

<p style="margin-top: 1em">This command was named -export
in previous releases. This old name is still supported in
this release and will be supported in future releases, but
for clarify the new name, <br>
-exportcert, is preferred going forward.</p>

<p style="margin-top: 1em">Displaying Data <br>
-list {-alias alias} {-storetype storetype} {-keystore
keystore} [-storepass storepass] {-providerName
provider_name} {-providerClass provider_class_name
{-providerArg <br>
provider_arg}} {-v | -rfc} {-protected} {-Jjavaoption}</p>

<p style="margin-top: 1em">Prints (to stdout) the contents
of the keystore entry identified by alias. If no alias is
specified, the contents of the entire keystore are
printed.</p>

<p style="margin-top: 1em">This command by default prints
the SHA1 fingerprint of a certificate. If the -v option is
specified, the certificate is printed in human-readable
format, with additional <br>
information such as the owner, issuer, serial number, and
any extensions. If the -rfc option is specified, certificate
contents are printed using the printable encoding for&acirc;
<br>
mat, as defined by the Internet RFC 1421 standard</p>

<p style="margin-top: 1em">You cannot specify both -v and
-rfc.</p>

<p style="margin-top: 1em">-printcert {-file cert_file |
-sslserver host[:port]} {-jarfile JAR_file {-rfc} {-v}
{-Jjavaoption}</p>

<p style="margin-top: 1em">Reads the certificate from the
file cert_file, the SSL server located at host:port, or the
signed JAR file JAR_file (with the option -jarfile and
prints its contents in a <br>
human-readable format. When no port is specified, the
standard HTTPS port 443 is assumed. Note that -sslserver and
-file options cannot be provided at the same time.
Other&acirc; <br>
wise, an error is reported. If neither option is given, the
certificate is read from stdin.</p>

<p style="margin-top: 1em">If -rfc is specified, keytool
prints the certificate in PEM mode as defined by the
Internet RFC 1421 standard.</p>

<p style="margin-top: 1em">If the certificate is read from
a file or stdin, it may be either binary encoded or in
printable encoding format, as defined by the Internet RFC
1421 standard</p>

<p style="margin-top: 1em">If the SSL server is behind a
firewall, -J-Dhttps.proxyHost=proxyhost and
-J-Dhttps.proxyPort=proxyport can be specified on the
command line for proxy tunneling. See the JSSE <br>
Reference Guide @ <br>

http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html
for more information.</p>

<p style="margin-top: 1em">Note: This option can be used
independently of a keystore.</p>

<p style="margin-top: 1em">-printcrl -file crl_ {-v}</p>

<p style="margin-top: 1em">Reads the certificate revocation
list (CRL) from the file crl_file.</p>

<p style="margin-top: 1em">A Certificate Revocation List
(CRL) is a list of digital certificates which have been
revoked by the Certificate Authority (CA) that issued them.
The CA generates crl_file.</p>

<p style="margin-top: 1em">Note: This option can be used
independently of a keystore.</p>

<p style="margin-top: 1em">Managing the Keystore <br>
-storepasswd [-new new_storepass] {-storetype storetype}
{-keystore keystore} [-storepass storepass] {-providerName
provider_name} {-providerClass provider_class_name <br>
{-providerArg provider_arg}} {-v} {-Jjavaoption}</p>

<p style="margin-top: 1em">Changes the password used to
protect the integrity of the keystore contents. The new
password is new_storepass, which must be at least 6
characters long.</p>

<p style="margin-top: 1em">-keypasswd {-alias alias}
[-keypass old_keypass] [-new new_keypass] {-storetype
storetype} {-keystore keystore} [-storepass storepass]
{-providerName provider_name} <br>
{-providerClass provider_class_name {-providerArg
provider_arg}} {-v} {-Jjavaoption}</p>

<p style="margin-top: 1em">Changes the password under which
the private/secret key identified by alias is protected,
from old_keypass to new_keypass, which must be at least 6
characters long.</p>

<p style="margin-top: 1em">If the -keypass option is not
provided at the command line, and the key password is
different from the keystore password, the user is prompted
for it.</p>

<p style="margin-top: 1em">If the -new option is not
provided at the command line, the user is prompted for
it.</p>

<p style="margin-top: 1em">-delete [-alias alias]
{-storetype storetype} {-keystore keystore} [-storepass
storepass] {-providerName provider_name} {-providerClass
provider_class_name {-providerArg <br>
provider_arg}} {-v} {-protected} {-Jjavaoption}</p>

<p style="margin-top: 1em">Deletes from the keystore the
entry identified by alias. The user is prompted for the
alias, if no alias is provided at the command line.</p>

<p style="margin-top: 1em">-changealias {-alias alias}
[-destalias destalias] [-keypass keypass] {-storetype
storetype} {-keystore keystore} [-storepass storepass]
{-providerName provider_name} <br>
{-providerClass provider_class_name {-providerArg
provider_arg}} {-v} {-protected} {-Jjavaoption}</p>

<p style="margin-top: 1em">Move an existing keystore entry
from the specified alias to a new alias, destalias. If no
destination alias is provided, the command will prompt for
one. If the original entry <br>
is protected with an entry password, the password can be
supplied via the &quot;-keypass&quot; option. If no key
password is provided, the storepass (if given) will be
attempted first. <br>
If that attempt fails, the user will be prompted for a
password.</p>

<p style="margin-top: 1em">Getting Help <br>
-help</p>

<p style="margin-top: 1em">Lists the basic commands and
their options.</p>

<p style="margin-top: 1em">For more information about a
specific command, enter the following, where command_name is
the name of the command: <br>
keytool -command_name -help</p>

<p style="margin-top: 1em">EXAMPLES <br>
Suppose you want to create a keystore for managing your
public/private key pair and certificates from entities you
trust.</p>

<p style="margin-top: 1em">Generating Your Key Pair <br>
The first thing you need to do is create a keystore and
generate the key pair. You could use a command such as the
following:</p>

<p style="margin-top: 1em">keytool -genkeypair -dname
&quot;cn=Mark Jones, ou=Java, o=Oracle, c=US&quot; <br>
-alias business -keypass &lt;new password for private
key&gt; -keystore /working/mykeystore <br>
-storepass &lt;new password for keystore&gt; -validity
180</p>

<p style="margin-top: 1em">(Please note: This must be typed
as a single line. Multiple lines are used in the examples
just for legibility purposes.)</p>

<p style="margin-top: 1em">This command creates the
keystore named &quot;mykeystore&quot; in the
&quot;working&quot; directory (assuming it doesn&rsquo;t
already exist), and assigns it the password specified by
&lt;new password for <br>
keystore&gt;. It generates a public/private key pair for the
entity whose &quot;distinguished name&quot; has a common
name of &quot;Mark Jones&quot;, organizational unit of
&quot;Java&quot;, organization of <br>
&quot;Oracle&quot; and two-letter country code of
&quot;US&quot;. It uses the default &quot;DSA&quot; key
generation algorithm to create the keys, both 1024 bits
long.</p>

<p style="margin-top: 1em">It creates a self-signed
certificate (using the default &quot;SHA1withDSA&quot;
signature algorithm) that includes the public key and the
distinguished name information. This certificate <br>
will be valid for 180 days, and is associated with the
private key in a keystore entry referred to by the alias
&quot;business&quot;. The private key is assigned the
password specified by <br>
&lt;new password for private key&gt;.</p>

<p style="margin-top: 1em">The command could be
significantly shorter if option defaults were accepted. As a
matter of fact, no options are required; defaults are used
for unspecified options that have <br>
default values, and you are prompted for any required
values. Thus, you could simply have the following:</p>

<p style="margin-top: 1em">keytool -genkeypair</p>

<p style="margin-top: 1em">In this case, a keystore entry
with alias &quot;mykey&quot; is created, with a
newly-generated key pair and a certificate that is valid for
90 days. This entry is placed in the keystore <br>
named &quot;.keystore&quot; in your home directory. (The
keystore is created if it doesn&rsquo;t already exist.) You
will be prompted for the distinguished name information, the
keystore pass&acirc; <br>
word, and the private key password.</p>

<p style="margin-top: 1em">The rest of the examples assume
you executed the -genkeypair command without options
specified, and that you responded to the prompts with values
equal to those given in the <br>
first -genkeypair command, above (for example, a
distinguished name of &quot;cn=Mark Jones, ou=Java,
o=Oracle, c=US&quot;).</p>

<p style="margin-top: 1em">Requesting a Signed Certificate
from a Certification Authority <br>
So far all we&rsquo;ve got is a self-signed certificate. A
certificate is more likely to be trusted by others if it is
signed by a Certification Authority (CA). To get such a
signa&acirc; <br>
ture, you first generate a Certificate Signing Request
(CSR), via the following:</p>

<p style="margin-top: 1em">keytool -certreq -file
MarkJ.csr</p>

<p style="margin-top: 1em">This creates a CSR (for the
entity identified by the default alias &quot;mykey&quot;)
and puts the request in the file named
&quot;MarkJ.csr&quot;. Submit this file to a CA, such as
VeriSign, Inc. <br>
The CA will authenticate you, the requestor (usually
off-line), and then will return a certificate, signed by
them, authenticating your public key. (In some cases, they
will <br>
actually return a chain of certificates, each one
authenticating the public key of the signer of the previous
certificate in the chain.)</p>

<p style="margin-top: 1em">Importing a Certificate for the
CA <br>
You need to replace your self-signed certificate with a
certificate chain, where each certificate in the chain
authenticates the public key of the signer of the previous
certifi&acirc; <br>
cate in the chain, up to a &quot;root&quot; CA.</p>

<p style="margin-top: 1em">Before you import the
certificate reply from a CA, you need one or more
&quot;trusted certificates&quot; in your keystore or in the
cacerts keystore file (which is described in importcert <br>
command):</p>

<p style="margin-top: 1em">o If the certificate reply is a
certificate chain, you just need the top certificate of the
chain (that is, the &quot;root&quot; CA certificate
authenticating that CA&rsquo;s public key).</p>

<p style="margin-top: 1em">o If the certificate reply is a
single certificate, you need a certificate for the issuing
CA (the one that signed it), and if that certificate is not
self-signed, you need a <br>
certificate for its signer, and so on, up to a self-signed
&quot;root&quot; CA certificate.</p>

<p style="margin-top: 1em">The &quot;cacerts&quot; keystore
file ships with several VeriSign root CA certificates, so
you probably won&rsquo;t need to import a VeriSign
certificate as a trusted certificate in your key&acirc; <br>
store. But if you request a signed certificate from a
different CA, and a certificate authenticating that
CA&rsquo;s public key hasn&rsquo;t been added to
&quot;cacerts&quot;, you will need to import <br>
a certificate from the CA as a &quot;trusted
certificate&quot;.</p>

<p style="margin-top: 1em">A certificate from a CA is
usually either self-signed, or signed by another CA (in
which case you also need a certificate authenticating that
CA&rsquo;s public key). Suppose company <br>
ABC, Inc., is a CA, and you obtain a file named
&quot;ABCCA.cer&quot; that is purportedly a self-signed
certificate from ABC, authenticating that CA&rsquo;s public
key.</p>

<p style="margin-top: 1em">Be very careful to ensure the
certificate is valid prior to importing it as a
&quot;trusted&quot; certificate! View it first (using the
keytool -printcert command, or the keytool <br>
-importcert command without the -noprompt option), and make
sure that the displayed certificate fingerprint(s) match the
expected ones. You can call the person who sent the
cer&acirc; <br>
tificate, and compare the fingerprint(s) that you see with
the ones that they show (or that a secure public key
repository shows). Only if the fingerprints are equal is it
guar&acirc; <br>
anteed that the certificate has not been replaced in transit
with somebody else&rsquo;s (for example, an
attacker&rsquo;s) certificate. If such an attack took place,
and you did not check <br>
the certificate before you imported it, you would end up
trusting anything the attacker has signed.</p>

<p style="margin-top: 1em">If you trust that the
certificate is valid, then you can add it to your keystore
via the following:</p>

<p style="margin-top: 1em">keytool -importcert -alias abc
-file ABCCA.cer</p>

<p style="margin-top: 1em">This creates a &quot;trusted
certificate&quot; entry in the keystore, with the data from
the file &quot;ABCCA.cer&quot;, and assigns the alias
&quot;abc&quot; to the entry.</p>

<p style="margin-top: 1em">Importing the Certificate Reply
from the CA <br>
Once you&rsquo;ve imported a certificate authenticating the
public key of the CA you submitted your certificate signing
request to (or there is already such a certificate in the
&quot;cac&acirc; <br>
erts&quot; file), you can import the certificate reply and
thereby replace your self-signed certificate with a
certificate chain. This chain is the one returned by the CA
in response <br>
to your request (if the CA reply is a chain), or one
constructed (if the CA reply is a single certificate) using
the certificate reply and trusted certificates that are
already <br>
available in the keystore where you import the reply or in
the &quot;cacerts&quot; keystore file.</p>

<p style="margin-top: 1em">For example, suppose you sent
your certificate signing request to VeriSign. You can then
import the reply via the following, which assumes the
returned certificate is named <br>
&quot;VSMarkJ.cer&quot;:</p>

<p style="margin-top: 1em">keytool -importcert
-trustcacerts -file VSMarkJ.cer</p>

<p style="margin-top: 1em">Exporting a Certificate
Authenticating Your Public Key <br>
Suppose you have used the jarsigner(1) tool to sign a Java
ARchive (JAR) file. Clients that want to use the file will
want to authenticate your signature.</p>

<p style="margin-top: 1em">One way they can do this is by
first importing your public key certificate into their
keystore as a &quot;trusted&quot; entry. You can export the
certificate and supply it to your clients. <br>
As an example, you can copy your certificate to a file named
MJ.cer via the following, assuming the entry is aliased by
&quot;mykey&quot;:</p>

<p style="margin-top: 1em">keytool -exportcert -alias mykey
-file MJ.cer</p>

<p style="margin-top: 1em">Given that certificate, and the
signed JAR file, a client can use the jarsigner tool to
authenticate your signature.</p>

<p style="margin-top: 1em">Importing Keystore <br>
The command &quot;importkeystore&quot; is used to import an
entire keystore into another keystore, which means all
entries from the source keystore, including keys and
certificates, are <br>
all imported to the destination keystore within a single
command. You can use this command to import entries from a
different type of keystore. During the import, all new
entries <br>
in the destination keystore will have the same alias names
and protection passwords (for secret keys and private keys).
If keytool has difficulties recover the private keys or <br>
secret keys from the source keystore, it will prompt you for
a password. If it detects alias duplication, it will ask you
for a new one, you can specify a new alias or simply <br>
allow keytool to overwrite the existing one.</p>

<p style="margin-top: 1em">For example, to import entries
from a normal JKS type keystore key.jks into a PKCS #11 type
hardware based keystore, you can use the command:</p>

<p style="margin-top: 1em">keytool -importkeystore <br>
-srckeystore key.jks -destkeystore NONE <br>
-srcstoretype JKS -deststoretype PKCS11 <br>
-srcstorepass &lt;source keystore password&gt;
-deststorepass &lt;destination keystore password&gt;</p>

<p style="margin-top: 1em">The importkeystore command can
also be used to import a single entry from a source keystore
to a destination keystore. In this case, besides the options
you see in the above <br>
example, you need to specify the alias you want to import.
With the srcalias option given, you can also specify the
destination alias name in the command line, as well as
protec&acirc; <br>
tion password for a secret/private key and the destination
protection password you want. The following command
demonstrates this:</p>

<p style="margin-top: 1em">keytool -importkeystore <br>
-srckeystore key.jks -destkeystore NONE <br>
-srcstoretype JKS -deststoretype PKCS11 <br>
-srcstorepass &lt;source keystore password&gt;
-deststorepass &lt;destination keystore password&gt; <br>
-srcalias myprivatekey -destalias myoldprivatekey <br>
-srckeypass &lt;source entry password&gt; -destkeypass
&lt;destination entry password&gt; <br>
-noprompt</p>

<p style="margin-top: 1em">Generating Certificates for a
Typical SSL Server <br>
The following are keytool commands to generate keypairs and
certificates for three entities, namely, Root CA (root),
Intermediate CA (ca), and SSL server (server). Ensure that
<br>
you store all the certificates in the same keystore. In
these examples, it is recommended that you specify RSA as
the key algorithm.</p>

<p style="margin-top: 1em">keytool -genkeypair -keystore
root.jks -alias root -ext bc:c <br>
keytool -genkeypair -keystore ca.jks -alias ca -ext bc:c
<br>
keytool -genkeypair -keystore server.jks -alias server</p>

<p style="margin-top: 1em">keytool -keystore root.jks
-alias root -exportcert -rfc &gt; root.pem</p>

<p style="margin-top: 1em">keytool -storepass
&lt;storepass&gt; -keystore ca.jks -certreq -alias ca |
keytool -storepass &lt;storepass&gt; -keystore root.jks
-gencert -alias root -ext BC=0 -rfc &gt; ca.pem <br>
keytool -keystore ca.jks -importcert -alias ca -file
ca.pem</p>

<p style="margin-top: 1em">keytool -storepass
&lt;storepass&gt; -keystore server.jks -certreq -alias
server | keytool -storepass &lt;storepass&gt; -keystore
ca.jks -gencert -alias ca -ext ku:c=dig,kE -rfc &gt;
server.pem <br>
cat root.pem ca.pem server.pem | keytool -keystore
server.jks -importcert -alias server</p>

<p style="margin-top: 1em">TERMINOLOGY and WARNINGS <br>
KeyStore <br>
A keystore is a storage facility for cryptographic keys and
certificates.</p>

<p style="margin-top: 1em">o KeyStore Entries</p>

<p style="margin-top: 1em">Keystores may have different
types of entries. The two most applicable entry types for
keytool include:</p>

<p style="margin-top: 1em">1. key entries - each holds very
sensitive cryptographic key information, which is stored in
a protected format to prevent unauthorized access.
Typically, a key stored in <br>
this type of entry is a secret key, or a private key
accompanied by the certificate &quot;chain&quot; for the
corresponding public key. The keytool can handle both types
of <br>
entries, while the jarsigner tool only handle the latter
type of entry, that is private keys and their associated
certificate chains.</p>

<p style="margin-top: 1em">2. trusted certificate entries -
each contains a single public key certificate belonging to
another party. It is called a &quot;trusted
certificate&quot; because the keystore owner <br>
trusts that the public key in the certificate indeed belongs
to the identity identified by the &quot;subject&quot;
(owner) of the certificate. The issuer of the certificate
<br>
vouches for this, by signing the certificate.</p>

<p style="margin-top: 1em">o KeyStore Aliases</p>

<p style="margin-top: 1em">All keystore entries (key and
trusted certificate entries) are accessed via unique
aliases.</p>

<p style="margin-top: 1em">An alias is specified when you
add an entity to the keystore using the -genseckey command
to generate a secret key, -genkeypair command to generate a
key pair (public and pri&acirc; <br>
vate key) or the -importcert command to add a certificate or
certificate chain to the list of trusted certificates.
Subsequent keytool commands must use this same alias to <br>
refer to the entity.</p>

<p style="margin-top: 1em">For example, suppose you use the
alias duke to generate a new public/private key pair and
wrap the public key into a self-signed certificate (see
Certificate Chains) via the <br>
following command: <br>
keytool -genkeypair -alias duke -keypass dukekeypasswd</p>

<p style="margin-top: 1em">This specifies an initial
password of &quot;dukekeypasswd&quot; required by subsequent
commands to access the private key associated with the alias
duke. If you later want to change <br>
duke&rsquo;s private key password, you use a command like
the following: <br>
keytool -keypasswd -alias duke -keypass dukekeypasswd -new
newpass</p>

<p style="margin-top: 1em">This changes the password from
&quot;dukekeypasswd&quot; to &quot;newpass&quot;.</p>

<p style="margin-top: 1em">Please note: A password should
not actually be specified on a command line or in a script
unless it is for testing purposes, or you are on a secure
system. If you don&rsquo;t spec&acirc; <br>
ify a required password option on a command line, you will
be prompted for it.</p>

<p style="margin-top: 1em">o KeyStore Implementation</p>

<p style="margin-top: 1em">The KeyStore class provided in
the java.security package supplies well-defined interfaces
to access and modify the information in a keystore. It is
possible for there to be <br>
multiple different concrete implementations, where each
implementation is that for a particular type of
keystore.</p>

<p style="margin-top: 1em">Currently, two command-line
tools (keytool and jarsigner) and a GUI-based tool named
Policy Tool make use of keystore implementations. Since
KeyStore is publicly available, <br>
users can write additional security applications that use
it.</p>

<p style="margin-top: 1em">There is a built-in default
implementation, provided by Oracle. It implements the
keystore as a file, utilizing a proprietary keystore type
(format) named &quot;JKS&quot;. It protects <br>
each private key with its individual password, and also
protects the integrity of the entire keystore with a
(possibly different) password.</p>

<p style="margin-top: 1em">Keystore implementations are
provider-based. More specifically, the application
interfaces supplied by KeyStore are implemented in terms of
a &quot;Service Provider Interface&quot; <br>
(SPI). That is, there is a corresponding abstract
KeystoreSpi class, also in the java.security package, which
defines the Service Provider Interface methods that
&quot;providers&quot; <br>
must implement. (The term &quot;provider&quot; refers to a
package or a set of packages that supply a concrete
implementation of a subset of services that can be accessed
by the Java <br>
Security API.) Thus, to provide a keystore implementation,
clients must implement a &quot;provider&quot; and supply a
KeystoreSpi subclass implementation, as described in How to
Imple&acirc; <br>
ment a Provider for the Java Cryptography Architecture @
<br>

http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/HowToImplAProvider.html.</p>

<p style="margin-top: 1em">Applications can choose
different types of keystore implementations from different
providers, using the &quot;getInstance&quot; factory method
supplied in the KeyStore class. A keystore <br>
type defines the storage and data format of the keystore
information, and the algorithms used to protect
private/secret keys in the keystore and the integrity of the
keystore <br>
itself. Keystore implementations of different types are not
compatible.</p>

<p style="margin-top: 1em">keytool works on any file-based
keystore implementation. (It treats the keystore location
that is passed to it at the command line as a filename and
converts it to a FileIn&acirc; <br>
putStream, from which it loads the keystore information.)
The jarsigner and policytool tools, on the other hand, can
read a keystore from any location that can be specified <br>
using a URL.</p>

<p style="margin-top: 1em">For keytool and jarsigner, you
can specify a keystore type at the command line, via the
-storetype option. For Policy Tool, you can specify a
keystore type via the &quot;Keystore&quot; <br>
menu.</p>

<p style="margin-top: 1em">If you don&rsquo;t explicitly
specify a keystore type, the tools choose a keystore
implementation based simply on the value of the
keystore.type property specified in the security <br>
properties file. The security properties file is called
java.security, and it resides in the security properties
directory, java.home/lib/security, where java.home is the
run&acirc; <br>
time environment&rsquo;s directory (the jre directory in the
SDK or the top-level directory of the Java 2 Runtime
Environment).</p>

<p style="margin-top: 1em">Each tool gets the keystore.type
value and then examines all the currently-installed
providers until it finds one that implements keystores of
that type. It then uses the key&acirc; <br>
store implementation from that provider.</p>

<p style="margin-top: 1em">The KeyStore class defines a
static method named getDefaultType that lets applications
and applets retrieve the value of the keystore.type
property. The following line of code <br>
creates an instance of the default keystore type (as
specified in the keystore.type property): <br>
KeyStore keyStore =
KeyStore.getInstance(KeyStore.getDefaultType());</p>

<p style="margin-top: 1em">The default keystore type is
&quot;jks&quot; (the proprietary type of the keystore
implementation provided by Oracle). This is specified by the
following line in the security properties <br>
file: <br>
keystore.type=jks</p>

<p style="margin-top: 1em">To have the tools utilize a
keystore implementation other than the default, you can
change that line to specify a different keystore type.</p>

<p style="margin-top: 1em">For example, if you have a
provider package that supplies a keystore implementation for
a keystore type called &quot;pkcs12&quot;, change the line
to <br>
keystore.type=pkcs12</p>

<p style="margin-top: 1em">Note: case doesn&rsquo;t matter
in keystore type designations. For example, &quot;JKS&quot;
would be considered the same as &quot;jks&quot;.</p>

<p style="margin-top: 1em">Certificate <br>
A certificate (also known as a public-key certificate) is a
digitally signed statement from one entity (the issuer),
saying that the public key (and some other information) of
<br>
another entity (the subject) has some specific value.</p>

<p style="margin-top: 1em">o Certificate Terms</p>

<p style="margin-top: 1em">Public Keys</p>

<p style="margin-top: 1em">These are numbers associated
with a particular entity, and are intended to be known to
everyone who needs to have trusted interactions with that
entity. Public keys are <br>
used to verify signatures.</p>

<p style="margin-top: 1em">Digitally Signed</p>

<p style="margin-top: 1em">If some data is digitally signed
it has been stored with the &quot;identity&quot; of an
entity, and a signature that proves that entity knows about
the data. The data is rendered <br>
unforgeable by signing with the entity&rsquo;s private
key.</p>

<p style="margin-top: 1em">Identity</p>

<p style="margin-top: 1em">A known way of addressing an
entity. In some systems the identity is the public key, in
others it can be anything from a Unix UID to an Email
address to an X.509 Distin&acirc; <br>
guished Name.</p>

<p style="margin-top: 1em">Signature</p>

<p style="margin-top: 1em">A signature is computed over
some data using the private key of an entity (the signer,
which in the case of a certificate is also known as the
issuer).</p>

<p style="margin-top: 1em">Private Keys</p>

<p style="margin-top: 1em">These are numbers, each of which
is supposed to be known only to the particular entity whose
private key it is (that is, it&rsquo;s supposed to be kept
secret). Private and pub&acirc; <br>
lic keys exist in pairs in all public key cryptography
systems (also referred to as &quot;public key crypto
systems&quot;). In a typical public key crypto system, such
as DSA, a pri&acirc; <br>
vate key corresponds to exactly one public key. Private keys
are used to compute signatures.</p>

<p style="margin-top: 1em">Entity</p>

<p style="margin-top: 1em">An entity is a person,
organization, program, computer, business, bank, or
something else you are trusting to some degree.</p>

<p style="margin-top: 1em">Basically, public key
cryptography requires access to users&rsquo; public keys. In
a large-scale networked environment it is impossible to
guarantee that prior relationships between <br>
communicating entities have been established or that a
trusted repository exists with all used public keys.
Certificates were invented as a solution to this public key
distri&acirc; <br>
bution problem. Now a Certification Authority (CA) can act
as a trusted third party. CAs are entities (for example,
businesses) that are trusted to sign (issue) certificates
<br>
for other entities. It is assumed that CAs will only create
valid and reliable certificates, as they are bound by legal
agreements. There are many public Certification
Author&acirc; <br>
ities, such as VeriSign @ <br>
http://www.verisign.com/, Thawte @ <br>
http://www.thawte.com/, Entrust @ <br>
http://www.entrust.com/, and so on. You can also run your
own Certification Authority using products such as Microsoft
Certificate Server or the Entrust CA product for your <br>
organization.</p>

<p style="margin-top: 1em">Using keytool, it is possible to
display, import, and export certificates. It is also
possible to generate self-signed certificates.</p>

<p style="margin-top: 1em">keytool currently handles X.509
certificates.</p>

<p style="margin-top: 1em">o X.509 Certificates</p>

<p style="margin-top: 1em">The X.509 standard defines what
information can go into a certificate, and describes how to
write it down (the data format). All the data in a
certificate is encoded using two <br>
related standards called ASN.1/DER. Abstract Syntax Notation
1 describes data. The Definite Encoding Rules describe a
single way to store and transfer that data.</p>

<p style="margin-top: 1em">All X.509 certificates have the
following data, in addition to the signature:</p>

<p style="margin-top: 1em">Version</p>

<p style="margin-top: 1em">This identifies which version of
the X.509 standard applies to this certificate, which
affects what information can be specified in it. Thus far,
three versions are <br>
defined. keytool can import and export v1, v2, and v3
certificates. It generates v3 certificates.</p>

<p style="margin-top: 1em">X.509 Version 1 has been
available since 1988, is widely deployed, and is the most
generic.</p>

<p style="margin-top: 1em">X.509 Version 2 introduced the
concept of subject and issuer unique identifiers to handle
the possibility of reuse of subject and/or issuer names over
time. Most certifi&acirc; <br>
cate profile documents strongly recommend that names not be
reused, and that certificates should not make use of unique
identifiers. Version 2 certificates are not widely <br>
used.</p>

<p style="margin-top: 1em">X.509 Version 3 is the most
recent (1996) and supports the notion of extensions, whereby
anyone can define an extension and include it in the
certificate. Some common <br>
extensions in use today are: KeyUsage (limits the use of the
keys to particular purposes such as
&quot;signing-only&quot;) and AlternativeNames (allows other
identities to also be <br>
associated with this public key, e.g. DNS names, Email
addresses, IP addresses). Extensions can be marked critical
to indicate that the extension should be checked and <br>
enforced/used. For example, if a certificate has the
KeyUsage extension marked critical and set to
&quot;keyCertSign&quot; then if this certificate is
presented during SSL communica&acirc; <br>
tion, it should be rejected, as the certificate extension
indicates that the associated private key should only be
used for signing certificates and not for SSL use.</p>

<p style="margin-top: 1em">Serial Number</p>

<p style="margin-top: 1em">The entity that created the
certificate is responsible for assigning it a serial number
to distinguish it from other certificates it issues. This
information is used in <br>
numerous ways, for example when a certificate is revoked its
serial number is placed in a Certificate Revocation List
(CRL).</p>

<p style="margin-top: 1em">Signature Algorithm
Identifier</p>

<p style="margin-top: 1em">This identifies the algorithm
used by the CA to sign the certificate.</p>

<p style="margin-top: 1em">Issuer Name</p>

<p style="margin-top: 1em">The X.500 Distinguished Name of
the entity that signed the certificate. This is normally a
CA. Using this certificate implies trusting the entity that
signed this certifi&acirc; <br>
cate. (Note that in some cases, such as root or top-level CA
certificates, the issuer signs its own certificate.)</p>

<p style="margin-top: 1em">Validity Period</p>

<p style="margin-top: 1em">Each certificate is valid only
for a limited amount of time. This period is described by a
start date and time and an end date and time, and can be as
short as a few sec&acirc; <br>
onds or almost as long as a century. The validity period
chosen depends on a number of factors, such as the strength
of the private key used to sign the certificate or the <br>
amount one is willing to pay for a certificate. This is the
expected period that entities can rely on the public value,
if the associated private key has not been compro&acirc;
<br>
mised.</p>

<p style="margin-top: 1em">Subject Name</p>

<p style="margin-top: 1em">The name of the entity whose
public key the certificate identifies. This name uses the
X.500 standard, so it is intended to be unique across the
Internet. This is the X.500 <br>
Distinguished Name (DN) of the entity, for example, <br>
CN=Java Duke, OU=Java Software Division, O=Oracle
Corporation, C=US</p>

<p style="margin-top: 1em">(These refer to the
subject&rsquo;s Common Name, Organizational Unit,
Organization, and Country.)</p>

<p style="margin-top: 1em">Subject Public Key
Information</p>

<p style="margin-top: 1em">This is the public key of the
entity being named, together with an algorithm identifier
which specifies which public key crypto system this key
belongs to and any associ&acirc; <br>
ated key parameters.</p>

<p style="margin-top: 1em">o Certificate Chains</p>

<p style="margin-top: 1em">keytool can create and manage
keystore &quot;key&quot; entries that each contain a private
key and an associated certificate &quot;chain&quot;. The
first certificate in the chain contains the <br>
public key corresponding to the private key.</p>

<p style="margin-top: 1em">When keys are first generated
(see the -genkeypair command), the chain starts off
containing a single element, a self-signed certificate. A
self-signed certificate is one for <br>
which the issuer (signer) is the same as the subject (the
entity whose public key is being authenticated by the
certificate). Whenever the -genkeypair command is called to
<br>
generate a new public/private key pair, it also wraps the
public key into a self-signed certificate.</p>

<p style="margin-top: 1em">Later, after a Certificate
Signing Request (CSR) has been generated (see the -certreq
command) and sent to a Certification Authority (CA), the
response from the CA is imported <br>
(see -importcert), and the self-signed certificate is
replaced by a chain of certificates. At the bottom of the
chain is the certificate (reply) issued by the CA
authenticat&acirc; <br>
ing the subject&rsquo;s public key. The next certificate in
the chain is one that authenticates the CA&rsquo;s public
key.</p>

<p style="margin-top: 1em">In many cases, this is a
self-signed certificate (that is, a certificate from the CA
authenticating its own public key) and the last certificate
in the chain. In other cases, <br>
the CA may return a chain of certificates. In this case, the
bottom certificate in the chain is the same (a certificate
signed by the CA, authenticating the public key of the <br>
key entry), but the second certificate in the chain is a
certificate signed by a different CA, authenticating the
public key of the CA you sent the CSR to. Then, the next
cer&acirc; <br>
tificate in the chain will be a certificate authenticating
the second CA&rsquo;s key, and so on, until a self-signed
&quot;root&quot; certificate is reached. Each certificate in
the chain <br>
(after the first) thus authenticates the public key of the
signer of the previous certificate in the chain.</p>

<p style="margin-top: 1em">Many CAs only return the issued
certificate, with no supporting chain, especially when there
is a flat hierarchy (no intermediates CAs). In this case,
the certificate chain <br>
must be established from trusted certificate information
already stored in the keystore.</p>

<p style="margin-top: 1em">A different reply format
(defined by the PKCS#7 standard) also includes the
supporting certificate chain, in addition to the issued
certificate. Both reply formats can be han&acirc; <br>
dled by keytool.</p>

<p style="margin-top: 1em">The top-level (root) CA
certificate is self-signed. However, the trust into the
root&rsquo;s public key does not come from the root
certificate itself (anybody could generate a <br>
self-signed certificate with the distinguished name of say,
the VeriSign root CA!), but from other sources like a
newspaper. The root CA public key is widely known. The only
<br>
reason it is stored in a certificate is because this is the
format understood by most tools, so the certificate in this
case is only used as a &quot;vehicle&quot; to transport the
root <br>
CA&rsquo;s public key. Before you add the root CA
certificate to your keystore, you should view it (using the
-printcert option) and compare the displayed fingerprint
with the <br>
well-known fingerprint (obtained from a newspaper, the root
CA&rsquo;s Web page, etc.).</p>

<p style="margin-top: 1em">o The cacerts Certificates
File</p>

<p style="margin-top: 1em">A certificates file named
&quot;cacerts&quot; resides in the security properties
directory, java.home/lib/security, where java.home is the
runtime environment&rsquo;s directory (the jre <br>
directory in the SDK or the top-level directory of the Java
2 Runtime Environment).</p>

<p style="margin-top: 1em">The &quot;cacerts&quot; file
represents a system-wide keystore with CA certificates.
System administrators can configure and manage that file
using keytool, specifying &quot;jks&quot; as the key&acirc;
<br>
store type. The &quot;cacerts&quot; keystore file ships with
a default set of root CA certificates; list them with the
following command: <br>
keytool -list -keystore java.home/lib/security/cacerts</p>

<p style="margin-top: 1em">The initial password of the
&quot;cacerts&quot; keystore file is &quot;changeit&quot;.
System administrators should change that password and the
default access permission of that file upon <br>
installing the SDK.</p>

<p style="margin-top: 1em">IMPORTANT: Verify Your cacerts
File: Since you trust the CAs in the cacerts file as
entities for signing and issuing certificates to other
entities, you must manage the cac&acirc; <br>
erts file carefully. The cacerts file should contain only
certificates of the CAs you trust. It is your responsibility
to verify the trusted root CA certificates bundled in <br>
the cacerts file and make your own trust decisions. To
remove an untrusted CA certificate from the cacerts file,
use the delete option of the keytool command. You can find
the <br>
cacerts file in the JRE installation directory. Contact your
system administrator if you do not have permission to edit
this file.</p>

<p style="margin-top: 1em">o The Internet RFC 1421
Certificate Encoding Standard</p>

<p style="margin-top: 1em">Certificates are often stored
using the printable encoding format defined by the Internet
RFC 1421 standard, instead of their binary encoding. This
certificate format, also <br>
known as &quot;Base 64 encoding&quot;, facilitates exporting
certificates to other applications by email or through some
other mechanism.</p>

<p style="margin-top: 1em">Certificates read by the
-importcert and -printcert commands can be in either this
format or binary encoded.</p>

<p style="margin-top: 1em">The -exportcert command by
default outputs a certificate in binary encoding, but will
instead output a certificate in the printable encoding
format, if the -rfc option is <br>
specified.</p>

<p style="margin-top: 1em">The -list command by default
prints the SHA1 fingerprint of a certificate. If the -v
option is specified, the certificate is printed in
human-readable format, while if the <br>
-rfc option is specified, the certificate is output in the
printable encoding format.</p>

<p style="margin-top: 1em">In its printable encoding
format, the encoded certificate is bounded at the beginning
by <br>
-----BEGIN CERTIFICATE-----</p>

<p style="margin-top: 1em">and at the end by <br>
-----END CERTIFICATE-----</p>

<p style="margin-top: 1em">X.500 Distinguished Names <br>
X.500 Distinguished Names are used to identify entities,
such as those which are named by the subject and issuer
(signer) fields of X.509 certificates. keytool supports the
fol&acirc; <br>
lowing subparts:</p>

<p style="margin-top: 1em">o commonName - common name of a
person, e.g., &quot;Susan Jones&quot;</p>

<p style="margin-top: 1em">o organizationUnit - small
organization (e.g., department or division) name, e.g.,
&quot;Purchasing&quot;</p>

<p style="margin-top: 1em">o organizationName - large
organization name, e.g., &quot;ABCSystems, Inc.&quot;</p>

<p style="margin-top: 1em">o localityName - locality (city)
name, e.g., &quot;Palo Alto&quot;</p>

<p style="margin-top: 1em">o stateName - state or province
name, e.g., &quot;California&quot;</p>

<p style="margin-top: 1em">o country - two-letter country
code, e.g., &quot;CH&quot;</p>

<p style="margin-top: 1em">When supplying a distinguished
name string as the value of a -dname option, as for the
-genkeypair command, the string must be in the following
format:</p>

<p style="margin-top: 1em">CN=cName, OU=orgUnit, O=org,
L=city, S=state, C=countryCode</p>

<p style="margin-top: 1em">where all the italicized items
represent actual values and the above keywords are
abbreviations for the following:</p>

<p style="margin-top: 1em">CN=commonName <br>
OU=organizationUnit <br>
O=organizationName <br>
L=localityName <br>
S=stateName <br>
C=country</p>

<p style="margin-top: 1em">A sample distinguished name
string is</p>

<p style="margin-top: 1em">CN=Mark Smith, OU=Java,
O=Oracle, L=Cupertino, S=California, C=US</p>

<p style="margin-top: 1em">and a sample command using such
a string is</p>

<p style="margin-top: 1em">keytool -genkeypair -dname
&quot;CN=Mark Smith, OU=Java, O=Oracle, L=Cupertino, <br>
S=California, C=US&quot; -alias mark</p>

<p style="margin-top: 1em">Case does not matter for the
keyword abbreviations. For example, &quot;CN&quot;,
&quot;cn&quot;, and &quot;Cn&quot; are all treated the
same.</p>

<p style="margin-top: 1em">Order matters; each subcomponent
must appear in the designated order. However, it is not
necessary to have all the subcomponents. You may use a
subset, for example:</p>

<p style="margin-top: 1em">CN=Steve Meier, OU=Java,
O=Oracle, C=US</p>

<p style="margin-top: 1em">If a distinguished name string
value contains a comma, the comma must be escaped by a
&quot;</p>

<p style="margin-top: 1em">cn=Peter Schuster, ou=Java
Product Development, o=Oracle, c=US</p>

<p style="margin-top: 1em">It is never necessary to specify
a distinguished name string on a command line. If it is
needed for a command, but not supplied on the command line,
the user is prompted for each <br>
of the subcomponents. In this case, a comma does not need to
be escaped by a &quot;</p>

<p style="margin-top: 1em">WARNING Regarding Importing
Trusted Certificates <br>
IMPORTANT: Be sure to check a certificate very carefully
before importing it as a trusted certificate!</p>

<p style="margin-top: 1em">View it first (using the
-printcert command, or the -importcert command without the
-noprompt option), and make sure that the displayed
certificate fingerprint(s) match the <br>
expected ones. For example, suppose someone sends or emails
you a certificate, and you put it in a file named /tmp/cert.
Before you consider adding the certificate to your list <br>
of trusted certificates, you can execute a -printcert
command to view its fingerprints, as in</p>

<p style="margin-top: 1em">keytool -printcert -file
/tmp/cert <br>
Owner: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll <br>
Issuer: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll <br>
Serial Number: 59092b34 <br>
Valid from: Thu Sep 25 18:01:13 PDT 1997 until: Wed Dec 24
17:01:13 PST 1997 <br>
Certificate Fingerprints: <br>
MD5: 11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F <br>
SHA1:
20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE
<br>
SHA256: 90:7B:70:0A:EA:DC:16:79:92:99:41:FF:8A:FE:EB:90:
<br>
17:75:E0:90:B2:24:4D:3A:2A:16:A6:E4:11:0F:67:A4</p>

<p style="margin-top: 1em">Then call or otherwise contact
the person who sent the certificate, and compare the
fingerprint(s) that you see with the ones that they show.
Only if the fingerprints are equal <br>
is it guaranteed that the certificate has not been replaced
in transit with somebody else&rsquo;s (for example, an
attacker&rsquo;s) certificate. If such an attack took place,
and you did <br>
not check the certificate before you imported it, you would
end up trusting anything the attacker has signed (for
example, a JAR file with malicious class files inside).</p>

<p style="margin-top: 1em">Note: it is not required that
you execute a -printcert command prior to importing a
certificate, since before adding a certificate to the list
of trusted certificates in the key&acirc; <br>
store, the -importcert command prints out the certificate
information and prompts you to verify it. You then have the
option of aborting the import operation. Note, however, this
<br>
is only the case if you invoke the -importcert command
without the -noprompt option. If the -noprompt option is
given, there is no interaction with the user.</p>

<p style="margin-top: 1em">Warning Regarding Passwords <br>
Most commands operating on a keystore require the store
password. Some commands require a private/secret key
password.</p>

<p style="margin-top: 1em">Passwords can be specified on
the command line (in the -storepass and -keypass options,
respectively). However, a password should not be specified
on a command line or in a <br>
script unless it is for testing purposes, or you are on a
secure system.</p>

<p style="margin-top: 1em">If you don&rsquo;t specify a
required password option on a command line, you will be
prompted for it.</p>

<p style="margin-top: 1em">Warning Regarding Certificate
Conformance <br>
The Internet standard RFC 5280 @ <br>
http://tools.ietf.org/rfc/rfc5280.txt has defined a profile
on conforming X.509 certificates, which includes what values
and value combinations are valid for certificate fields <br>
and extensions. keytool has not enforced all these rules so
it can generate certificates which do not conform to the
standard, and these certificates might be rejected by JRE or
<br>
other applications. Users should make sure that they provide
the correct options for -dname, -ext, etc.</p>

<p style="margin-top: 1em">SEE ALSO <br>
o jar(1) tool documentation</p>

<p style="margin-top: 1em">o jarsigner(1) tool
documentation</p>

<p style="margin-top: 1em">o the Security @ <br>
http://docs.oracle.com/javase/tutorial/security/index.html
trail of the Java Tutorial @ <br>
http://docs.oracle.com/javase/tutorial/ for examples of the
use of keytool</p>

<p style="margin-top: 1em">CHANGES <br>
The command interface for keytool changed in Java SE 6.</p>

<p style="margin-top: 1em">keytool no longer displays
password input when entered by users. Since password input
can no longer be viewed when entered, users will be prompted
to re-enter passwords any time <br>
a password is being set or changed (for example, when
setting the initial keystore password, or when changing a
key password).</p>

<p style="margin-top: 1em">Some commands have simply been
renamed, and other commands deemed obsolete are no longer
listed in this document. All previous commands (both renamed
and obsolete) are still sup&acirc; <br>
ported in this release and will continue to be supported in
future releases. The following summarizes all of the changes
made to the keytool command interface:</p>

<p style="margin-top: 1em">Renamed commands:</p>

<p style="margin-top: 1em">o -export, renamed to
-exportcert</p>

<p style="margin-top: 1em">o -genkey, renamed to
-genkeypair</p>

<p style="margin-top: 1em">o -import, renamed to
-importcert</p>

<p style="margin-top: 1em">Commands deemed obsolete and no
longer documented:</p>

<p style="margin-top: 1em">o -keyclone @ <br>

http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#keycloneCmd</p>

<p style="margin-top: 1em">o -identitydb @ <br>

http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#identitydbCmd</p>

<p style="margin-top: 1em">o -selfcert @ <br>

http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#selfcertCmd</p>

<p style="margin-top: 1em">16 Mar 2012 keytool(1)</p>
<hr>
</body>
</html>
