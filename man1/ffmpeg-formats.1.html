<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:09:37 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>FFMPEG-FORMATS(1) FFMPEG-FORMATS(1)</p>

<p style="margin-top: 1em">NAME <br>
ffmpeg-formats - FFmpeg formats</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This document describes the supported formats (muxers and
demuxers) provided by the libavformat library.</p>

<p style="margin-top: 1em">FORMAT OPTIONS <br>
The libavformat library provides some generic global
options, which can be set on all the muxers and demuxers. In
addition each muxer or demuxer may support so-called private
<br>
options, which are specific for that component.</p>

<p style="margin-top: 1em">Options may be set by specifying
-option value in the FFmpeg tools, or by setting the value
explicitly in the &quot;AVFormatContext&quot; options or
using the libavutil/opt.h API for <br>
programmatic use.</p>

<p style="margin-top: 1em">The list of supported options
follows:</p>

<p style="margin-top: 1em">avioflags flags (input/output)
<br>
Possible values:</p>

<p style="margin-top: 1em">direct <br>
Reduce buffering.</p>

<p style="margin-top: 1em">probesize integer (input) <br>
Set probing size in bytes, i.e. the size of the data to
analyze to get stream information. A higher value will
enable detecting more information in case it is dispersed
into <br>
the stream, but will increase latency. Must be an integer
not lesser than 32. It is 5000000 by default.</p>

<p style="margin-top: 1em">packetsize integer (output) <br>
Set packet size.</p>

<p style="margin-top: 1em">fflags flags (input/output) <br>
Set format flags.</p>

<p style="margin-top: 1em">Possible values:</p>

<p style="margin-top: 1em">ignidx <br>
Ignore index.</p>

<p style="margin-top: 1em">fastseek <br>
Enable fast, but inaccurate seeks for some formats.</p>

<p style="margin-top: 1em">genpts <br>
Generate PTS.</p>

<p style="margin-top: 1em">nofillin <br>
Do not fill in missing values that can be exactly
calculated.</p>

<p style="margin-top: 1em">noparse <br>
Disable AVParsers, this needs &quot;+nofillin&quot; too.</p>

<p style="margin-top: 1em">igndts <br>
Ignore DTS.</p>

<p style="margin-top: 1em">discardcorrupt <br>
Discard corrupted frames.</p>

<p style="margin-top: 1em">sortdts <br>
Try to interleave output packets by DTS.</p>

<p style="margin-top: 1em">keepside <br>
Do not merge side data.</p>

<p style="margin-top: 1em">latm <br>
Enable RTP MP4A-LATM payload.</p>

<p style="margin-top: 1em">nobuffer <br>
Reduce the latency introduced by optional buffering</p>

<p style="margin-top: 1em">bitexact <br>
Only write platform-, build- and time-independent data. This
ensures that file and data checksums are reproducible and
match between platforms. Its primary use is for <br>
regression testing.</p>

<p style="margin-top: 1em">shortest <br>
Stop muxing at the end of the shortest stream. It may be
needed to increase max_interleave_delta to avoid flushing
the longer streams before EOF.</p>

<p style="margin-top: 1em">seek2any integer (input) <br>
Allow seeking to non-keyframes on demuxer level when
supported if set to 1. Default is 0.</p>

<p style="margin-top: 1em">analyzeduration integer (input)
<br>
Specify how many microseconds are analyzed to probe the
input. A higher value will enable detecting more accurate
information, but will increase latency. It defaults to <br>
5,000,000 microseconds = 5 seconds.</p>

<p style="margin-top: 1em">cryptokey hexadecimal string
(input) <br>
Set decryption key.</p>

<p style="margin-top: 1em">indexmem integer (input) <br>
Set max memory used for timestamp index (per stream).</p>

<p style="margin-top: 1em">rtbufsize integer (input) <br>
Set max memory used for buffering real-time frames.</p>

<p style="margin-top: 1em">fdebug flags (input/output) <br>
Print specific debug info.</p>

<p style="margin-top: 1em">Possible values:</p>

<p style="margin-top: 1em">ts <br>
max_delay integer (input/output) <br>
Set maximum muxing or demuxing delay in microseconds.</p>

<p style="margin-top: 1em">fpsprobesize integer (input)
<br>
Set number of frames used to probe fps.</p>

<p style="margin-top: 1em">audio_preload integer (output)
<br>
Set microseconds by which audio packets should be
interleaved earlier.</p>

<p style="margin-top: 1em">chunk_duration integer (output)
<br>
Set microseconds for each chunk.</p>

<p style="margin-top: 1em">chunk_size integer (output) <br>
Set size in bytes for each chunk.</p>

<p style="margin-top: 1em">err_detect, f_err_detect flags
(input) <br>
Set error detection flags. &quot;f_err_detect&quot; is
deprecated and should be used only via the ffmpeg tool.</p>

<p style="margin-top: 1em">Possible values:</p>

<p style="margin-top: 1em">crccheck <br>
Verify embedded CRCs.</p>

<p style="margin-top: 1em">bitstream <br>
Detect bitstream specification deviations.</p>

<p style="margin-top: 1em">buffer <br>
Detect improper bitstream length.</p>

<p style="margin-top: 1em">explode <br>
Abort decoding on minor error detection.</p>

<p style="margin-top: 1em">careful <br>
Consider things that violate the spec and have not been seen
in the wild as errors.</p>

<p style="margin-top: 1em">compliant <br>
Consider all spec non compliancies as errors.</p>

<p style="margin-top: 1em">aggressive <br>
Consider things that a sane encoder should not do as an
error.</p>

<p style="margin-top: 1em">max_interleave_delta integer
(output) <br>
Set maximum buffering duration for interleaving. The
duration is expressed in microseconds, and defaults to
1000000 (1 second).</p>

<p style="margin-top: 1em">To ensure all the streams are
interleaved correctly, libavformat will wait until it has at
least one packet for each stream before actually writing any
packets to the output <br>
file. When some streams are &quot;sparse&quot; (i.e. there
are large gaps between successive packets), this can result
in excessive buffering.</p>

<p style="margin-top: 1em">This field specifies the maximum
difference between the timestamps of the first and the last
packet in the muxing queue, above which libavformat will
output a packet <br>
regardless of whether it has queued a packet for all the
streams.</p>

<p style="margin-top: 1em">If set to 0, libavformat will
continue buffering packets until it has a packet for each
stream, regardless of the maximum timestamp difference
between the buffered packets.</p>

<p style="margin-top: 1em">use_wallclock_as_timestamps
integer (input) <br>
Use wallclock as timestamps if set to 1. Default is 0.</p>

<p style="margin-top: 1em">avoid_negative_ts integer
(output) <br>
Possible values:</p>

<p style="margin-top: 1em">make_non_negative <br>
Shift timestamps to make them non-negative. Also note that
this affects only leading negative timestamps, and not
non-monotonic negative timestamps.</p>

<p style="margin-top: 1em">make_zero <br>
Shift timestamps so that the first timestamp is 0.</p>

<p style="margin-top: 1em">auto (default) <br>
Enables shifting when required by the target format.</p>

<p style="margin-top: 1em">disabled <br>
Disables shifting of timestamp.</p>

<p style="margin-top: 1em">When shifting is enabled, all
output timestamps are shifted by the same amount. Audio,
video, and subtitles desynching and relative timestamp
differences are preserved <br>
compared to how they would have been without shifting.</p>

<p style="margin-top: 1em">skip_initial_bytes integer
(input) <br>
Set number of bytes to skip before reading header and frames
if set to 1. Default is 0.</p>

<p style="margin-top: 1em">correct_ts_overflow integer
(input) <br>
Correct single timestamp overflows if set to 1. Default is
1.</p>

<p style="margin-top: 1em">flush_packets integer (output)
<br>
Flush the underlying I/O stream after each packet. Default 1
enables it, and has the effect of reducing the latency; 0
disables it and may slightly increase performance in <br>
some cases.</p>

<p style="margin-top: 1em">output_ts_offset offset (output)
<br>
Set the output time offset.</p>

<p style="margin-top: 1em">offset must be a time duration
specification, see the Time duration section in the
ffmpeg-utils(1) manual.</p>

<p style="margin-top: 1em">The offset is added by the muxer
to the output timestamps.</p>

<p style="margin-top: 1em">Specifying a positive offset
means that the corresponding streams are delayed bt the time
duration specified in offset. Default value is 0 (meaning
that no offset is <br>
applied).</p>

<p style="margin-top: 1em">format_whitelist list (input)
<br>
&quot;,&quot; separated list of allowed demuxers. By default
all are allowed.</p>

<p style="margin-top: 1em">dump_separator string (input)
<br>
Separator used to separate the fields printed on the command
line about the Stream parameters. For example to separate
the fields with newlines and indention:</p>

<p style="margin-top: 1em">ffprobe -dump_separator &quot;
<br>
&quot; -i ~/videos/matrixbench_mpeg2.mpg</p>

<p style="margin-top: 1em">max_streams integer (input) <br>
Specifies the maximum number of streams. This can be used to
reject files that would require too many resources due to a
large number of streams.</p>

<p style="margin-top: 1em">Format stream specifiers <br>
Format stream specifiers allow selection of one or more
streams that match specific properties.</p>

<p style="margin-top: 1em">Possible forms of stream
specifiers are:</p>

<p style="margin-top: 1em">stream_index <br>
Matches the stream with this index.</p>

<p style="margin-top: 1em">stream_type[:stream_index] <br>
stream_type is one of following: &rsquo;v&rsquo; for video,
&rsquo;a&rsquo; for audio, &rsquo;s&rsquo; for subtitle,
&rsquo;d&rsquo; for data, and &rsquo;t&rsquo; for
attachments. If stream_index is given, then it matches the
stream <br>
number stream_index of this type. Otherwise, it matches all
streams of this type.</p>

<p style="margin-top: 1em">p:program_id[:stream_index] <br>
If stream_index is given, then it matches the stream with
number stream_index in the program with the id program_id.
Otherwise, it matches all streams in the program.</p>

<p style="margin-top: 1em">#stream_id <br>
Matches the stream by a format-specific ID.</p>

<p style="margin-top: 1em">The exact semantics of stream
specifiers is defined by the
&quot;avformat_match_stream_specifier()&quot; function
declared in the libavformat/avformat.h header.</p>

<p style="margin-top: 1em">DEMUXERS <br>
Demuxers are configured elements in FFmpeg that can read the
multimedia streams from a particular type of file.</p>

<p style="margin-top: 1em">When you configure your FFmpeg
build, all the supported demuxers are enabled by default.
You can list all available ones using the configure option
&quot;--list-demuxers&quot;.</p>

<p style="margin-top: 1em">You can disable all the demuxers
using the configure option &quot;--disable-demuxers&quot;,
and selectively enable a single demuxer with the option
&quot;--enable-demuxer=DEMUXER&quot;, or disable <br>
it with the option
&quot;--disable-demuxer=DEMUXER&quot;.</p>

<p style="margin-top: 1em">The option &quot;-formats&quot;
of the ff* tools will display the list of enabled
demuxers.</p>

<p style="margin-top: 1em">The description of some of the
currently available demuxers follows.</p>

<p style="margin-top: 1em">aa <br>
Audible Format 2, 3, and 4 demuxer.</p>

<p style="margin-top: 1em">This demuxer is used to demux
Audible Format 2, 3, and 4 (.aa) files.</p>

<p style="margin-top: 1em">applehttp <br>
Apple HTTP Live Streaming demuxer.</p>

<p style="margin-top: 1em">This demuxer presents all
AVStreams from all variant streams. The id field is set to
the bitrate variant index number. By setting the discard
flags on AVStreams (by pressing &rsquo;a&rsquo; <br>
or &rsquo;v&rsquo; in ffplay), the caller can decide which
variant streams to actually receive. The total bitrate of
the variant that the stream belongs to is available in a
metadata key <br>
named &quot;variant_bitrate&quot;.</p>

<p style="margin-top: 1em">apng <br>
Animated Portable Network Graphics demuxer.</p>

<p style="margin-top: 1em">This demuxer is used to demux
APNG files. All headers, but the PNG signature, up to (but
not including) the first fcTL chunk are transmitted as
extradata. Frames are then split <br>
as being all the chunks between two fcTL ones, or between
the last fcTL and IEND chunks.</p>

<p style="margin-top: 1em">-ignore_loop bool <br>
Ignore the loop variable in the file if set.</p>

<p style="margin-top: 1em">-max_fps int <br>
Maximum framerate in frames per second (0 for no limit).</p>

<p style="margin-top: 1em">-default_fps int <br>
Default framerate in frames per second when none is
specified in the file (0 meaning as fast as possible).</p>

<p style="margin-top: 1em">asf <br>
Advanced Systems Format demuxer.</p>

<p style="margin-top: 1em">This demuxer is used to demux
ASF files and MMS network streams.</p>

<p style="margin-top: 1em">-no_resync_search bool <br>
Do not try to resynchronize by looking for a certain
optional start code.</p>

<p style="margin-top: 1em">concat <br>
Virtual concatenation script demuxer.</p>

<p style="margin-top: 1em">This demuxer reads a list of
files and other directives from a text file and demuxes them
one after the other, as if all their packets had been muxed
together.</p>

<p style="margin-top: 1em">The timestamps in the files are
adjusted so that the first file starts at 0 and each next
file starts where the previous one finishes. Note that it is
done globally and may cause <br>
gaps if all streams do not have exactly the same length.</p>

<p style="margin-top: 1em">All files must have the same
streams (same codecs, same time base, etc.).</p>

<p style="margin-top: 1em">The duration of each file is
used to adjust the timestamps of the next file: if the
duration is incorrect (because it was computed using the
bit-rate or because the file is <br>
truncated, for example), it can cause artifacts. The
&quot;duration&quot; directive can be used to override the
duration stored in each file.</p>

<p style="margin-top: 1em">Syntax</p>

<p style="margin-top: 1em">The script is a text file in
extended-ASCII, with one directive per line. Empty lines,
leading spaces and lines starting with &rsquo;#&rsquo; are
ignored. The following directive is <br>
recognized:</p>

<p style="margin-top: 1em">&quot;file path&quot; <br>
Path to a file to read; special characters and spaces must
be escaped with backslash or single quotes.</p>

<p style="margin-top: 1em">All subsequent file-related
directives apply to that file.</p>

<p style="margin-top: 1em">&quot;ffconcat version 1.0&quot;
<br>
Identify the script type and version. It also sets the safe
option to 1 if it was -1.</p>

<p style="margin-top: 1em">To make FFmpeg recognize the
format automatically, this directive must appear exactly as
is (no extra space or byte-order-mark) on the very first
line of the script.</p>

<p style="margin-top: 1em">&quot;duration dur&quot; <br>
Duration of the file. This information can be specified from
the file; specifying it here may be more efficient or help
if the information from the file is not available or <br>
accurate.</p>

<p style="margin-top: 1em">If the duration is set for all
files, then it is possible to seek in the whole concatenated
video.</p>

<p style="margin-top: 1em">&quot;inpoint timestamp&quot;
<br>
In point of the file. When the demuxer opens the file it
instantly seeks to the specified timestamp. Seeking is done
so that all streams can be presented successfully at In <br>
point.</p>

<p style="margin-top: 1em">This directive works best with
intra frame codecs, because for non-intra frame ones you
will usually get extra packets before the actual In point
and the decoded content will <br>
most likely contain frames before In point too.</p>

<p style="margin-top: 1em">For each file, packets before
the file In point will have timestamps less than the
calculated start timestamp of the file (negative in case of
the first file), and the <br>
duration of the files (if not specified by the
&quot;duration&quot; directive) will be reduced based on
their specified In point.</p>

<p style="margin-top: 1em">Because of potential packets
before the specified In point, packet timestamps may overlap
between two concatenated files.</p>

<p style="margin-top: 1em">&quot;outpoint timestamp&quot;
<br>
Out point of the file. When the demuxer reaches the
specified decoding timestamp in any of the streams, it
handles it as an end of file condition and skips the current
and <br>
all the remaining packets from all streams.</p>

<p style="margin-top: 1em">Out point is exclusive, which
means that the demuxer will not output packets with a
decoding timestamp greater or equal to Out point.</p>

<p style="margin-top: 1em">This directive works best with
intra frame codecs and formats where all streams are tightly
interleaved. For non-intra frame codecs you will usually get
additional packets <br>
with presentation timestamp after Out point therefore the
decoded content will most likely contain frames after Out
point too. If your streams are not tightly interleaved you
<br>
may not get all the packets from all streams before Out
point and you may only will be able to decode the earliest
stream until Out point.</p>

<p style="margin-top: 1em">The duration of the files (if
not specified by the &quot;duration&quot; directive) will be
reduced based on their specified Out point.</p>

<p style="margin-top: 1em">&quot;file_packet_metadata
key=value&quot; <br>
Metadata of the packets of the file. The specified metadata
will be set for each file packet. You can specify this
directive multiple times to add multiple metadata
entries.</p>

<p style="margin-top: 1em">&quot;stream&quot; <br>
Introduce a stream in the virtual file. All subsequent
stream-related directives apply to the last introduced
stream. Some streams properties must be set in order to
allow <br>
identifying the matching streams in the subfiles. If no
streams are defined in the script, the streams from the
first file are copied.</p>

<p style="margin-top: 1em">&quot;exact_stream_id id&quot;
<br>
Set the id of the stream. If this directive is given, the
string with the corresponding id in the subfiles will be
used. This is especially useful for MPEG-PS (VOB) files,
<br>
where the order of the streams is not reliable.</p>

<p style="margin-top: 1em">Options</p>

<p style="margin-top: 1em">This demuxer accepts the
following option:</p>

<p style="margin-top: 1em">safe <br>
If set to 1, reject unsafe file paths. A file path is
considered safe if it does not contain a protocol
specification and is relative and all components only
contain <br>
characters from the portable character set (letters, digits,
period, underscore and hyphen) and have no period at the
beginning of a component.</p>

<p style="margin-top: 1em">If set to 0, any file name is
accepted.</p>

<p style="margin-top: 1em">The default is 1.</p>

<p style="margin-top: 1em">-1 is equivalent to 1 if the
format was automatically probed and 0 otherwise.</p>

<p style="margin-top: 1em">auto_convert <br>
If set to 1, try to perform automatic conversions on packet
data to make the streams concatenable. The default is 1.</p>

<p style="margin-top: 1em">Currently, the only conversion
is adding the h264_mp4toannexb bitstream filter to H.264
streams in MP4 format. This is necessary in particular if
there are resolution <br>
changes.</p>

<p style="margin-top: 1em">segment_time_metadata <br>
If set to 1, every packet will contain the
lavf.concat.start_time and the lavf.concat.duration packet
metadata values which are the start_time and the duration of
the <br>
respective file segments in the concatenated output
expressed in microseconds. The duration metadata is only set
if it is known based on the concat file. The default is
0.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Use absolute
filenames and include some comments:</p>

<p style="margin-top: 1em"># my first filename <br>
file /mnt/share/file-1.wav <br>
# my second filename including whitespace <br>
file &rsquo;/mnt/share/file 2.wav&rsquo; <br>
# my third filename including whitespace plus single quote
<br>
file &rsquo;/mnt/share/file
3&rsquo;&acute;&rsquo;.wav&rsquo;</p>

<p style="margin-top: 1em">&Acirc;&middot; Allow for input
format auto-probing, use safe filenames and set the duration
of the first file:</p>

<p style="margin-top: 1em">ffconcat version 1.0</p>

<p style="margin-top: 1em">file file-1.wav <br>
duration 20.0</p>

<p style="margin-top: 1em">file subdir/file-2.wav</p>

<p style="margin-top: 1em">flv <br>
Adobe Flash Video Format demuxer.</p>

<p style="margin-top: 1em">This demuxer is used to demux
FLV files and RTMP network streams.</p>

<p style="margin-top: 1em">-flv_metadata bool <br>
Allocate the streams according to the onMetaData array
content.</p>

<p style="margin-top: 1em">gif <br>
Animated GIF demuxer.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">min_delay <br>
Set the minimum valid delay between frames in hundredths of
seconds. Range is 0 to 6000. Default value is 2.</p>

<p style="margin-top: 1em">max_gif_delay <br>
Set the maximum valid delay between frames in hundredth of
seconds. Range is 0 to 65535. Default value is 65535 (nearly
eleven minutes), the maximum value allowed by the <br>
specification.</p>

<p style="margin-top: 1em">default_delay <br>
Set the default delay between frames in hundredths of
seconds. Range is 0 to 6000. Default value is 10.</p>

<p style="margin-top: 1em">ignore_loop <br>
GIF files can contain information to loop a certain number
of times (or infinitely). If ignore_loop is set to 1, then
the loop setting from the input will be ignored and <br>
looping will not occur. If set to 0, then looping will occur
and will cycle the number of times according to the GIF.
Default value is 1.</p>

<p style="margin-top: 1em">For example, with the overlay
filter, place an infinitely looping GIF over another
video:</p>

<p style="margin-top: 1em">ffmpeg -i input.mp4 -ignore_loop
0 -i input.gif -filter_complex overlay=shortest=1
out.mkv</p>

<p style="margin-top: 1em">Note that in the above example
the shortest option for overlay filter is used to end the
output video at the length of the shortest input file, which
in this case is input.mp4 as <br>
the GIF in this example loops infinitely.</p>

<p style="margin-top: 1em">image2 <br>
Image file demuxer.</p>

<p style="margin-top: 1em">This demuxer reads from a list
of image files specified by a pattern. The syntax and
meaning of the pattern is specified by the option
pattern_type.</p>

<p style="margin-top: 1em">The pattern may contain a suffix
which is used to automatically determine the format of the
images contained in the files.</p>

<p style="margin-top: 1em">The size, the pixel format, and
the format of each image must be the same for all the files
in the sequence.</p>

<p style="margin-top: 1em">This demuxer accepts the
following options:</p>

<p style="margin-top: 1em">framerate <br>
Set the frame rate for the video stream. It defaults to
25.</p>

<p style="margin-top: 1em">loop <br>
If set to 1, loop over the input. Default value is 0.</p>

<p style="margin-top: 1em">pattern_type <br>
Select the pattern type used to interpret the provided
filename.</p>

<p style="margin-top: 1em">pattern_type accepts one of the
following values.</p>

<p style="margin-top: 1em">none <br>
Disable pattern matching, therefore the video will only
contain the specified image. You should use this option if
you do not want to create sequences from multiple <br>
images and your filenames may contain special pattern
characters.</p>

<p style="margin-top: 1em">sequence <br>
Select a sequence pattern type, used to specify a sequence
of files indexed by sequential numbers.</p>

<p style="margin-top: 1em">A sequence pattern may contain
the string &quot;%d&quot; or &quot;%0Nd&quot;, which
specifies the position of the characters representing a
sequential number in each filename matched by the <br>
pattern. If the form &quot;%d0Nd&quot; is used, the string
representing the number in each filename is 0-padded and N
is the total number of 0-padded digits representing the <br>
number. The literal character &rsquo;%&rsquo; can be
specified in the pattern with the string &quot;%%&quot;.</p>

<p style="margin-top: 1em">If the sequence pattern contains
&quot;%d&quot; or &quot;%0Nd&quot;, the first filename of
the file list specified by the pattern must contain a number
inclusively contained between <br>
start_number and start_number+start_number_range-1, and all
the following numbers must be sequential.</p>

<p style="margin-top: 1em">For example the pattern
&quot;img-%03d.bmp&quot; will match a sequence of filenames
of the form img-001.bmp, img-002.bmp, ..., img-010.bmp,
etc.; the pattern &quot;i%%m%%g-%d.jpg&quot; will <br>
match a sequence of filenames of the form i%m%g-1.jpg,
i%m%g-2.jpg, ..., i%m%g-10.jpg, etc.</p>

<p style="margin-top: 1em">Note that the pattern must not
necessarily contain &quot;%d&quot; or &quot;%0Nd&quot;, for
example to convert a single image file img.jpeg you can
employ the command:</p>

<p style="margin-top: 1em">ffmpeg -i img.jpeg img.png</p>

<p style="margin-top: 1em">glob <br>
Select a glob wildcard pattern type.</p>

<p style="margin-top: 1em">The pattern is interpreted like
a &quot;glob()&quot; pattern. This is only selectable if
libavformat was compiled with globbing support.</p>

<p style="margin-top: 1em">glob_sequence (deprecated, will
be removed) <br>
Select a mixed glob wildcard/sequence pattern.</p>

<p style="margin-top: 1em">If your version of libavformat
was compiled with globbing support, and the provided pattern
contains at least one glob meta character among
&quot;%*?[]{}&quot; that is preceded by <br>
an unescaped &quot;%&quot;, the pattern is interpreted like
a &quot;glob()&quot; pattern, otherwise it is interpreted
like a sequence pattern.</p>

<p style="margin-top: 1em">All glob special characters
&quot;%*?[]{}&quot; must be prefixed with &quot;%&quot;. To
escape a literal &quot;%&quot; you shall use
&quot;%%&quot;.</p>

<p style="margin-top: 1em">For example the pattern
&quot;foo-%*.jpeg&quot; will match all the filenames
prefixed by &quot;foo-&quot; and terminating with
&quot;.jpeg&quot;, and &quot;foo-%?%?%?.jpeg&quot; will
match all the filenames <br>
prefixed with &quot;foo-&quot;, followed by a sequence of
three characters, and terminating with
&quot;.jpeg&quot;.</p>

<p style="margin-top: 1em">This pattern type is deprecated
in favor of glob and sequence.</p>

<p style="margin-top: 1em">Default value is
glob_sequence.</p>

<p style="margin-top: 1em">pixel_format <br>
Set the pixel format of the images to read. If not specified
the pixel format is guessed from the first image file in the
sequence.</p>

<p style="margin-top: 1em">start_number <br>
Set the index of the file matched by the image file pattern
to start to read from. Default value is 0.</p>

<p style="margin-top: 1em">start_number_range <br>
Set the index interval range to check when looking for the
first image file in the sequence, starting from
start_number. Default value is 5.</p>

<p style="margin-top: 1em">ts_from_file <br>
If set to 1, will set frame timestamp to modification time
of image file. Note that monotonity of timestamps is not
provided: images go in the same order as without this <br>
option. Default value is 0. If set to 2, will set frame
timestamp to the modification time of the image file in
nanosecond precision.</p>

<p style="margin-top: 1em">video_size <br>
Set the video size of the images to read. If not specified
the video size is guessed from the first image file in the
sequence.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">&Acirc;&middot; Use ffmpeg for
creating a video from the images in the file sequence
img-001.jpeg, img-002.jpeg, ..., assuming an input frame
rate of 10 frames per second:</p>

<p style="margin-top: 1em">ffmpeg -framerate 10 -i
&rsquo;img-%03d.jpeg&rsquo; out.mkv</p>

<p style="margin-top: 1em">&Acirc;&middot; As above, but
start by reading from a file with index 100 in the
sequence:</p>

<p style="margin-top: 1em">ffmpeg -framerate 10
-start_number 100 -i &rsquo;img-%03d.jpeg&rsquo; out.mkv</p>

<p style="margin-top: 1em">&Acirc;&middot; Read images
matching the &quot;*.png&quot; glob pattern , that is all
the files terminating with the &quot;.png&quot; suffix:</p>

<p style="margin-top: 1em">ffmpeg -framerate 10
-pattern_type glob -i &quot;*.png&quot; out.mkv</p>

<p style="margin-top: 1em">libgme <br>
The Game Music Emu library is a collection of video game
music file emulators.</p>

<p style="margin-top: 1em">See
&lt;http://code.google.com/p/game-music-emu/&gt; for more
information.</p>

<p style="margin-top: 1em">Some files have multiple tracks.
The demuxer will pick the first track by default. The
track_index option can be used to select a different track.
Track indexes start at 0. The <br>
demuxer exports the number of tracks as tracks meta data
entry.</p>

<p style="margin-top: 1em">For very large files, the
max_size option may have to be adjusted.</p>

<p style="margin-top: 1em">libopenmpt <br>
libopenmpt based module demuxer</p>

<p style="margin-top: 1em">See
&lt;https://lib.openmpt.org/libopenmpt/&gt; for more
information.</p>

<p style="margin-top: 1em">Some files have multiple
subsongs (tracks) this can be set with the subsong
option.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">subsong <br>
Set the subsong index. This can be either &rsquo;all&rsquo;,
&rsquo;auto&rsquo;, or the index of the subsong. Subsong
indexes start at 0. The default is &rsquo;auto&rsquo;.</p>

<p style="margin-top: 1em">The default value is to let
libopenmpt choose.</p>

<p style="margin-top: 1em">layout <br>
Set the channel layout. Valid values are 1, 2, and 4 channel
layouts. The default value is STEREO.</p>

<p style="margin-top: 1em">sample_rate <br>
Set the sample rate for libopenmpt to output. Range is from
1000 to INT_MAX. The value default is 48000.</p>

<p style="margin-top: 1em">mov/mp4/3gp/QuickTime <br>
QuickTime / MP4 demuxer.</p>

<p style="margin-top: 1em">This demuxer accepts the
following options:</p>

<p style="margin-top: 1em">enable_drefs <br>
Enable loading of external tracks, disabled by default.
Enabling this can theoretically leak information in some use
cases.</p>

<p style="margin-top: 1em">use_absolute_path <br>
Allows loading of external tracks via absolute paths,
disabled by default. Enabling this poses a security risk. It
should only be enabled if the source is known to be non <br>
malicious.</p>

<p style="margin-top: 1em">mpegts <br>
MPEG-2 transport stream demuxer.</p>

<p style="margin-top: 1em">This demuxer accepts the
following options:</p>

<p style="margin-top: 1em">resync_size <br>
Set size limit for looking up a new synchronization. Default
value is 65536.</p>

<p style="margin-top: 1em">fix_teletext_pts <br>
Override teletext packet PTS and DTS values with the
timestamps calculated from the PCR of the first program
which the teletext stream is part of and is not discarded.
<br>
Default value is 1, set this option to 0 if you want your
teletext packet PTS and DTS values untouched.</p>

<p style="margin-top: 1em">ts_packetsize <br>
Output option carrying the raw packet size in bytes. Show
the detected raw packet size, cannot be set by the user.</p>

<p style="margin-top: 1em">scan_all_pmts <br>
Scan and combine all PMTs. The value is an integer with
value from -1 to 1 (-1 means automatic setting, 1 means
enabled, 0 means disabled). Default value is -1.</p>

<p style="margin-top: 1em">mpjpeg <br>
MJPEG encapsulated in multi-part MIME demuxer.</p>

<p style="margin-top: 1em">This demuxer allows reading of
MJPEG, where each frame is represented as a part of
multipart/x-mixed-replace stream.</p>

<p style="margin-top: 1em">strict_mime_boundary <br>
Default implementation applies a relaxed standard to
multi-part MIME boundary detection, to prevent regression
with numerous existing endpoints not generating a proper
MIME <br>
MJPEG stream. Turning this option on by setting it to 1 will
result in a stricter check of the boundary value.</p>

<p style="margin-top: 1em">rawvideo <br>
Raw video demuxer.</p>

<p style="margin-top: 1em">This demuxer allows one to read
raw video data. Since there is no header specifying the
assumed video parameters, the user must specify them in
order to be able to decode the <br>
data correctly.</p>

<p style="margin-top: 1em">This demuxer accepts the
following options:</p>

<p style="margin-top: 1em">framerate <br>
Set input video frame rate. Default value is 25.</p>

<p style="margin-top: 1em">pixel_format <br>
Set the input video pixel format. Default value is
&quot;yuv420p&quot;.</p>

<p style="margin-top: 1em">video_size <br>
Set the input video size. This value must be specified
explicitly.</p>

<p style="margin-top: 1em">For example to read a rawvideo
file input.raw with ffplay, assuming a pixel format of
&quot;rgb24&quot;, a video size of &quot;320x240&quot;, and
a frame rate of 10 images per second, use the <br>
command:</p>

<p style="margin-top: 1em">ffplay -f rawvideo -pixel_format
rgb24 -video_size 320x240 -framerate 10 input.raw</p>

<p style="margin-top: 1em">sbg <br>
SBaGen script demuxer.</p>

<p style="margin-top: 1em">This demuxer reads the script
language used by SBaGen &lt;http://uazu.net/sbagen/&gt; to
generate binaural beats sessions. A SBG script looks like
that:</p>

<p style="margin-top: 1em">-SE <br>
a: 300-2.5/3 440+4.5/0 <br>
b: 300-2.5/0 440+4.5/3 <br>
off: - <br>
NOW == a <br>
+0:07:00 == b <br>
+0:14:00 == a <br>
+0:21:00 == b <br>
+0:30:00 off</p>

<p style="margin-top: 1em">A SBG script can mix absolute
and relative timestamps. If the script uses either only
absolute timestamps (including the script start time) or
only relative ones, then its layout <br>
is fixed, and the conversion is straightforward. On the
other hand, if the script mixes both kind of timestamps,
then the NOW reference for relative timestamps will be taken
from <br>
the current time of day at the time the script is read, and
the script layout will be frozen according to that
reference. That means that if the script is directly played,
the <br>
actual times will match the absolute timestamps up to the
sound controller&rsquo;s clock accuracy, but if the user
somehow pauses the playback or seeks, all times will be
shifted <br>
accordingly.</p>

<p style="margin-top: 1em">tedcaptions <br>
JSON captions used for &lt;http://www.ted.com/&gt;.</p>

<p style="margin-top: 1em">TED does not provide links to
the captions, but they can be guessed from the page. The
file tools/bookmarklets.html from the FFmpeg source tree
contains a bookmarklet to expose <br>
them.</p>

<p style="margin-top: 1em">This demuxer accepts the
following option:</p>

<p style="margin-top: 1em">start_time <br>
Set the start time of the TED talk, in milliseconds. The
default is 15000 (15s). It is used to sync the captions with
the downloadable videos, because they include a 15s <br>
intro.</p>

<p style="margin-top: 1em">Example: convert the captions to
a format most players understand:</p>

<p style="margin-top: 1em">ffmpeg -i
http://www.ted.com/talks/subtitles/id/1/lang/en
talk1-en.srt</p>

<p style="margin-top: 1em">MUXERS <br>
Muxers are configured elements in FFmpeg which allow writing
multimedia streams to a particular type of file.</p>

<p style="margin-top: 1em">When you configure your FFmpeg
build, all the supported muxers are enabled by default. You
can list all available muxers using the configure option
&quot;--list-muxers&quot;.</p>

<p style="margin-top: 1em">You can disable all the muxers
with the configure option &quot;--disable-muxers&quot; and
selectively enable / disable single muxers with the options
&quot;--enable-muxer=MUXER&quot; / <br>
&quot;--disable-muxer=MUXER&quot;.</p>

<p style="margin-top: 1em">The option &quot;-formats&quot;
of the ff* tools will display the list of enabled
muxers.</p>

<p style="margin-top: 1em">A description of some of the
currently available muxers follows.</p>

<p style="margin-top: 1em">aiff <br>
Audio Interchange File Format muxer.</p>

<p style="margin-top: 1em">Options</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">write_id3v2 <br>
Enable ID3v2 tags writing when set to 1. Default is 0
(disabled).</p>

<p style="margin-top: 1em">id3v2_version <br>
Select ID3v2 version to write. Currently only version 3 and
4 (aka. ID3v2.3 and ID3v2.4) are supported. The default is
version 4.</p>

<p style="margin-top: 1em">asf <br>
Advanced Systems Format muxer.</p>

<p style="margin-top: 1em">Note that Windows Media Audio
(wma) and Windows Media Video (wmv) use this muxer too.</p>

<p style="margin-top: 1em">Options</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">packet_size <br>
Set the muxer packet size. By tuning this setting you may
reduce data fragmentation or muxer overhead depending on
your source. Default value is 3200, minimum is 100, maximum
<br>
is 64k.</p>

<p style="margin-top: 1em">chromaprint <br>
Chromaprint fingerprinter</p>

<p style="margin-top: 1em">This muxer feeds audio data to
the Chromaprint library, which generates a fingerprint for
the provided audio data. It takes a single signed
native-endian 16-bit raw audio stream.</p>

<p style="margin-top: 1em">Options</p>

<p style="margin-top: 1em">silence_threshold <br>
Threshold for detecting silence, ranges from 0 to 32767. -1
for default (required for use with the AcoustID
service).</p>

<p style="margin-top: 1em">algorithm <br>
Algorithm index to fingerprint with.</p>

<p style="margin-top: 1em">fp_format <br>
Format to output the fingerprint as. Accepts the following
options:</p>

<p style="margin-top: 1em">raw Binary raw fingerprint</p>

<p style="margin-top: 1em">compressed <br>
Binary compressed fingerprint</p>

<p style="margin-top: 1em">base64 <br>
Base64 compressed fingerprint</p>

<p style="margin-top: 1em">crc <br>
CRC (Cyclic Redundancy Check) testing format.</p>

<p style="margin-top: 1em">This muxer computes and prints
the Adler-32 CRC of all the input audio and video frames. By
default audio frames are converted to signed 16-bit raw
audio and video frames to raw <br>
video before computing the CRC.</p>

<p style="margin-top: 1em">The output of the muxer consists
of a single line of the form: CRC=0xCRC, where CRC is a
hexadecimal number 0-padded to 8 digits containing the CRC
for all the decoded input <br>
frames.</p>

<p style="margin-top: 1em">See also the framecrc muxer.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">For example to compute the CRC
of the input, and store it in the file out.crc:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f crc
out.crc</p>

<p style="margin-top: 1em">You can print the CRC to stdout
with the command:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f crc -</p>

<p style="margin-top: 1em">You can select the output format
of each frame with ffmpeg by specifying the audio and video
codec and format. For example to compute the CRC of the
input audio converted to PCM <br>
unsigned 8-bit and the input video converted to MPEG-2
video, use the command:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -c:a pcm_u8 -c:v
mpeg2video -f crc -</p>

<p style="margin-top: 1em">flv <br>
Adobe Flash Video Format muxer.</p>

<p style="margin-top: 1em">This muxer accepts the following
options:</p>

<p style="margin-top: 1em">flvflags flags <br>
Possible values:</p>

<p style="margin-top: 1em">aac_seq_header_detect <br>
Place AAC sequence header based on audio stream data.</p>

<p style="margin-top: 1em">no_sequence_end <br>
Disable sequence end tag.</p>

<p style="margin-top: 1em">framecrc <br>
Per-packet CRC (Cyclic Redundancy Check) testing format.</p>

<p style="margin-top: 1em">This muxer computes and prints
the Adler-32 CRC for each audio and video packet. By default
audio frames are converted to signed 16-bit raw audio and
video frames to raw video <br>
before computing the CRC.</p>

<p style="margin-top: 1em">The output of the muxer consists
of a line for each audio and video packet of the form:</p>

<p style="margin-top: 1em">&lt;stream_index&gt;,
&lt;packet_dts&gt;, &lt;packet_pts&gt;,
&lt;packet_duration&gt;, &lt;packet_size&gt;,
0x&lt;CRC&gt;</p>

<p style="margin-top: 1em">CRC is a hexadecimal number
0-padded to 8 digits containing the CRC of the packet.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">For example to compute the CRC
of the audio and video frames in INPUT, converted to raw
audio and video packets, and store it in the file
out.crc:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f framecrc
out.crc</p>

<p style="margin-top: 1em">To print the information to
stdout, use the command:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f framecrc
-</p>

<p style="margin-top: 1em">With ffmpeg, you can select the
output format to which the audio and video frames are
encoded before computing the CRC for each packet by
specifying the audio and video codec. <br>
For example, to compute the CRC of each decoded input audio
frame converted to PCM unsigned 8-bit and of each decoded
input video frame converted to MPEG-2 video, use the <br>
command:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -c:a pcm_u8 -c:v
mpeg2video -f framecrc -</p>

<p style="margin-top: 1em">See also the crc muxer.</p>

<p style="margin-top: 1em">framehash <br>
Per-packet hash testing format.</p>

<p style="margin-top: 1em">This muxer computes and prints a
cryptographic hash for each audio and video packet. This can
be used for packet-by-packet equality checks without having
to individually do a <br>
binary comparison on each.</p>

<p style="margin-top: 1em">By default audio frames are
converted to signed 16-bit raw audio and video frames to raw
video before computing the hash, but the output of explicit
conversions to other codecs <br>
can also be used. It uses the SHA-256 cryptographic hash
function by default, but supports several other
algorithms.</p>

<p style="margin-top: 1em">The output of the muxer consists
of a line for each audio and video packet of the form:</p>

<p style="margin-top: 1em">&lt;stream_index&gt;,
&lt;packet_dts&gt;, &lt;packet_pts&gt;,
&lt;packet_duration&gt;, &lt;packet_size&gt;,
&lt;hash&gt;</p>

<p style="margin-top: 1em">hash is a hexadecimal number
representing the computed hash for the packet.</p>

<p style="margin-top: 1em">hash algorithm <br>
Use the cryptographic hash function specified by the string
algorithm. Supported values include &quot;MD5&quot;,
&quot;murmur3&quot;, &quot;RIPEMD128&quot;,
&quot;RIPEMD160&quot;, &quot;RIPEMD256&quot;,
&quot;RIPEMD320&quot;, <br>
&quot;SHA160&quot;, &quot;SHA224&quot;, &quot;SHA256&quot;
(default), &quot;SHA512/224&quot;, &quot;SHA512/256&quot;,
&quot;SHA384&quot;, &quot;SHA512&quot;, &quot;CRC32&quot;
and &quot;adler32&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">To compute the SHA-256 hash of
the audio and video frames in INPUT, converted to raw audio
and video packets, and store it in the file out.sha256:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f framehash
out.sha256</p>

<p style="margin-top: 1em">To print the information to
stdout, using the MD5 hash function, use the command:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f framehash
-hash md5 -</p>

<p style="margin-top: 1em">See also the hash muxer.</p>

<p style="margin-top: 1em">framemd5 <br>
Per-packet MD5 testing format.</p>

<p style="margin-top: 1em">This is a variant of the
framehash muxer. Unlike that muxer, it defaults to using the
MD5 hash function.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">To compute the MD5 hash of the
audio and video frames in INPUT, converted to raw audio and
video packets, and store it in the file out.md5:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f framemd5
out.md5</p>

<p style="margin-top: 1em">To print the information to
stdout, use the command:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f framemd5
-</p>

<p style="margin-top: 1em">See also the framehash and md5
muxers.</p>

<p style="margin-top: 1em">gif <br>
Animated GIF muxer.</p>

<p style="margin-top: 1em">It accepts the following
options:</p>

<p style="margin-top: 1em">loop <br>
Set the number of times to loop the output. Use
&quot;-1&quot; for no loop, 0 for looping indefinitely
(default).</p>

<p style="margin-top: 1em">final_delay <br>
Force the delay (expressed in centiseconds) after the last
frame. Each frame ends with a delay until the next frame.
The default is &quot;-1&quot;, which is a special value to
tell the <br>
muxer to re-use the previous delay. In case of a loop, you
might want to customize this value to mark a pause for
instance.</p>

<p style="margin-top: 1em">For example, to encode a gif
looping 10 times, with a 5 seconds delay between the
loops:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -loop 10
-final_delay 500 out.gif</p>

<p style="margin-top: 1em">Note 1: if you wish to extract
the frames into separate GIF files, you need to force the
image2 muxer:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -c:v gif -f
image2 &quot;out%d.gif&quot;</p>

<p style="margin-top: 1em">Note 2: the GIF format has a
very large time base: the delay between two frames can
therefore not be smaller than one centi second.</p>

<p style="margin-top: 1em">hash <br>
Hash testing format.</p>

<p style="margin-top: 1em">This muxer computes and prints a
cryptographic hash of all the input audio and video frames.
This can be used for equality checks without having to do a
complete binary <br>
comparison.</p>

<p style="margin-top: 1em">By default audio frames are
converted to signed 16-bit raw audio and video frames to raw
video before computing the hash, but the output of explicit
conversions to other codecs <br>
can also be used. Timestamps are ignored. It uses the
SHA-256 cryptographic hash function by default, but supports
several other algorithms.</p>

<p style="margin-top: 1em">The output of the muxer consists
of a single line of the form: algo=hash, where algo is a
short string representing the hash function used, and hash
is a hexadecimal number <br>
representing the computed hash.</p>

<p style="margin-top: 1em">hash algorithm <br>
Use the cryptographic hash function specified by the string
algorithm. Supported values include &quot;MD5&quot;,
&quot;murmur3&quot;, &quot;RIPEMD128&quot;,
&quot;RIPEMD160&quot;, &quot;RIPEMD256&quot;,
&quot;RIPEMD320&quot;, <br>
&quot;SHA160&quot;, &quot;SHA224&quot;, &quot;SHA256&quot;
(default), &quot;SHA512/224&quot;, &quot;SHA512/256&quot;,
&quot;SHA384&quot;, &quot;SHA512&quot;, &quot;CRC32&quot;
and &quot;adler32&quot;.</p>

<p style="margin-top: 1em">Examples</p>

<p style="margin-top: 1em">To compute the SHA-256 hash of
the input converted to raw audio and video, and store it in
the file out.sha256:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f hash
out.sha256</p>

<p style="margin-top: 1em">To print an MD5 hash to stdout
use the command:</p>

<p style="margin-top: 1em">ffmpeg -i INPUT -f hash -hash
md5 -</p>

<p style="margin-top: 1em">See also the framehash
muxer.</p>

<p style="margin-top: 1em">hls <br>
Apple HTTP Live Streaming muxer that segments MPEG-TS
according to the HTTP Live Streaming (HLS)
specification.</p>

<p style="margin-top: 1em">It creates a playlist file, and
one or more segment files. The output filename specifies the
playlist filename.</p>

<p style="margin-top: 1em">By default, the muxer creates a
file for each segment produced. These files have the same
name as the playlist, followed by a sequential number and a
.ts extension.</p>

<p style="margin-top: 1em">For example, to convert an input
file with ffmpeg:</p>

<p style="margin-top: 1em">ffmpeg -i in.nut out.m3u8</p>

<p style="margin-top: 1em">This example will produce the
playlist, out.m3u8, and segment files: out0.ts, out1.ts,
out2.ts, etc.</p>

<p style="margin-top: 1em">See also the segment muxer,
which provides a more generic and flexible implementation of
a segmenter, and can be used to perform HLS
segmentation.</p>

<p style="margin-top: 1em">Options</p>

<p style="margin-top: 1em">This muxer supports the
following options:</p>

<p style="margin-top: 1em">hls_init_time seconds <br>
Set the initial target segment length in seconds. Default
value is 0. Segment will be cut on the next key frame after
this time has passed on the first m3u8 list. After the <br>
initial playlist is filled ffmpeg will cut segments at
duration equal to &quot;hls_time&quot;</p>

<p style="margin-top: 1em">hls_time seconds <br>
Set the target segment length in seconds. Default value is
2. Segment will be cut on the next key frame after this time
has passed.</p>

<p style="margin-top: 1em">hls_list_size size <br>
Set the maximum number of playlist entries. If set to 0 the
list file will contain all the segments. Default value is
5.</p>

<p style="margin-top: 1em">hls_ts_options options_list <br>
Set output format options using a :-separated list of
key=value parameters. Values containing &quot;:&quot;
special characters must be escaped.</p>

<p style="margin-top: 1em">hls_wrap wrap <br>
Set the number after which the segment filename number (the
number specified in each segment file) wraps. If set to 0
the number will be never wrapped. Default value is 0.</p>

<p style="margin-top: 1em">This option is useful to avoid
to fill the disk with many segment files, and limits the
maximum number of segment files written to disk to wrap.</p>

<p style="margin-top: 1em">start_number number <br>
Start the playlist sequence number from number. Default
value is 0.</p>

<p style="margin-top: 1em">hls_allow_cache allowcache <br>
Explicitly set whether the client MAY <i>s0(1) or MUST NOT
s0(0) cache media segments.</i></p>

<p style="margin-top: 1em"><i>hls_base_url baseurl <br>
Append baseurl to every entry in the playlist. Useful to
generate playlists with absolute paths.</i></p>

<p style="margin-top: 1em"><i>Note that the playlist
sequence number must be unique for each segment and it is
not to be confused with the segment filename sequence number
which can be cyclic, for example <br>
if the wrap option is specified.</i></p>

<p style="margin-top: 1em"><i>hls_segment_filename filename
<br>
Set the segment filename. Unless &quot;hls_flags
single_file&quot; is set, filename is used as a string
format with the segment number:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.nut
-hls_segment_filename &rsquo;file%03d.ts&rsquo;
out.m3u8</i></p>

<p style="margin-top: 1em"><i>This example will produce the
playlist, out.m3u8, and segment files: file000.ts,
file001.ts, file002.ts, etc.</i></p>

<p style="margin-top: 1em"><i>use_localtime <br>
Use strftime on filename to expand the segment filename with
localtime. The segment number (%d) is not available in this
mode.</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.nut
-use_localtime 1 -hls_segment_filename
&rsquo;file-%Y%m%d-%s.ts&rsquo; out.m3u8</i></p>

<p style="margin-top: 1em"><i>This example will produce the
playlist, out.m3u8, and segment files:
file-20160215-1455569023.ts, file-20160215-1455569024.ts,
etc.</i></p>

<p style="margin-top: 1em"><i>use_localtime_mkdir <br>
Used together with -use_localtime, it will create up to one
subdirectory which is expanded in filename.</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.nut
-use_localtime 1 -use_localtime_mkdir 1
-hls_segment_filename &rsquo;%Y%m%d/file-%Y%m%d-%s.ts&rsquo;
out.m3u8</i></p>

<p style="margin-top: 1em"><i>This example will create a
directory 201560215 (if it does not exist), and then produce
the playlist, out.m3u8, and segment files:
201560215/file-20160215-1455569023.ts, <br>
201560215/file-20160215-1455569024.ts, etc.</i></p>

<p style="margin-top: 1em"><i>hls_key_info_file
key_info_file <br>
Use the information in key_info_file for segment encryption.
The first line of key_info_file specifies the key URI
written to the playlist. The key URL is used to access the
<br>
encryption key during playback. The second line specifies
the path to the key file used to obtain the key during the
encryption process. The key file is read as a single <br>
packed array of 16 octets in binary format. The optional
third line specifies the initialization vector (IV) as a
hexadecimal string to be used instead of the segment <br>
sequence number (default) for encryption. Changes to
key_info_file will result in segment encryption with the new
key/IV and an entry in the playlist for the new key
URI/IV.</i></p>

<p style="margin-top: 1em"><i>Key info file format:</i></p>

<p style="margin-top: 1em"><i>&lt;key URI&gt; <br>
&lt;key file path&gt; <br>
&lt;IV&gt; (optional)</i></p>

<p style="margin-top: 1em"><i>Example key URIs:</i></p>

<p style="margin-top: 1em"><i>http://server/file.key <br>
/path/to/file.key <br>
file.key</i></p>

<p style="margin-top: 1em"><i>Example key file
paths:</i></p>

<p style="margin-top: 1em"><i>file.key <br>
/path/to/file.key</i></p>

<p style="margin-top: 1em"><i>Example IV:</i></p>


<p style="margin-top: 1em"><i>0123456789ABCDEF0123456789ABCDEF</i></p>

<p style="margin-top: 1em"><i>Key info file
example:</i></p>

<p style="margin-top: 1em"><i>http://server/file.key <br>
/path/to/file.key <br>
0123456789ABCDEF0123456789ABCDEF</i></p>

<p style="margin-top: 1em"><i>Example shell script:</i></p>

<p style="margin-top: 1em"><i>#!/bin/sh <br>
BASE_URL=${1:-&rsquo;.&rsquo;} <br>
openssl rand 16 &gt; file.key <br>
echo $BASE_URL/file.key &gt; file.keyinfo <br>
echo file.key &gt;&gt; file.keyinfo <br>
echo $(openssl rand -hex 16) &gt;&gt; file.keyinfo <br>
ffmpeg -f lavfi -re -i testsrc -c:v h264 -hls_flags
delete_segments -hls_key_info_file file.keyinfo
out.m3u8</i></p>

<p style="margin-top: 1em"><i>hls_flags single_file <br>
If this flag is set, the muxer will store all segments in a
single MPEG-TS file, and will use byte ranges in the
playlist. HLS playlists generated with this way will have
the <br>
version number 4. For example:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.nut -hls_flags
single_file out.m3u8</i></p>

<p style="margin-top: 1em"><i>Will produce the playlist,
out.m3u8, and a single segment file, out.ts.</i></p>

<p style="margin-top: 1em"><i>hls_flags delete_segments
<br>
Segment files removed from the playlist are deleted after a
period of time equal to the duration of the segment plus the
duration of the playlist.</i></p>

<p style="margin-top: 1em"><i>hls_flags append_list <br>
Append new segments into the end of old segment list, and
remove the &quot;#EXT-X-ENDLIST&quot; from the old segment
list.</i></p>

<p style="margin-top: 1em"><i>hls_flags round_durations
<br>
Round the duration info in the playlist file segment info to
integer values, instead of using floating point.</i></p>

<p style="margin-top: 1em"><i>hls_flags discont_starts <br>
Add the &quot;#EXT-X-DISCONTINUITY&quot; tag to the
playlist, before the first segment&rsquo;s
information.</i></p>

<p style="margin-top: 1em"><i>hls_flags omit_endlist <br>
Do not append the &quot;EXT-X-ENDLIST&quot; tag at the end
of the playlist.</i></p>

<p style="margin-top: 1em"><i>hls_flags split_by_time <br>
Allow segments to start on frames other than keyframes. This
improves behavior on some players when the time between
keyframes is inconsistent, but may make things worse on <br>
others, and can cause some oddities during seeking. This
flag should be used with the &quot;hls_time&quot;
option.</i></p>

<p style="margin-top: 1em"><i>hls_flags program_date_time
<br>
Generate &quot;EXT-X-PROGRAM-DATE-TIME&quot; tags.</i></p>

<p style="margin-top: 1em"><i>hls_playlist_type event <br>
Emit &quot;#EXT-X-PLAYLIST-TYPE:EVENT&quot; in the m3u8
header. Forces hls_list_size to 0; the playlist can only be
appended to.</i></p>

<p style="margin-top: 1em"><i>hls_playlist_type vod <br>
Emit &quot;#EXT-X-PLAYLIST-TYPE:VOD&quot; in the m3u8
header. Forces hls_list_size to 0; the playlist must not
change.</i></p>

<p style="margin-top: 1em"><i>method <br>
Use the given HTTP method to create the hls files.</i></p>

<p style="margin-top: 1em"><i>ffmpeg -re -i in.ts -f hls
-method PUT http://example.com/live/out.m3u8</i></p>

<p style="margin-top: 1em"><i>This example will upload all
the mpegts segment files to the HTTP server using the HTTP
PUT method, and update the m3u8 files every
&quot;refresh&quot; times using the same method. <br>
Note that the HTTP server must support the given method for
uploading files.</i></p>

<p style="margin-top: 1em"><i>ico <br>
ICO file muxer.</i></p>

<p style="margin-top: 1em"><i>Microsoft&rsquo;s icon file
format (ICO) has some strict limitations that should be
noted:</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Size cannot
exceed 256 pixels in any dimension</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Only BMP and
PNG images can be stored</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; If a BMP
image is used, it must be one of the following pixel
formats:</i></p>

<p style="margin-top: 1em"><i>BMP Bit Depth FFmpeg Pixel
Format <br>
1bit pal8 <br>
4bit pal8 <br>
8bit pal8 <br>
16bit rgb555le <br>
24bit bgr24 <br>
32bit bgra</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; If a BMP
image is used, it must use the BITMAPINFOHEADER DIB
header</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; If a PNG
image is used, it must use the rgba pixel format</i></p>

<p style="margin-top: 1em"><i>image2 <br>
Image file muxer.</i></p>

<p style="margin-top: 1em"><i>The image file muxer writes
video frames to image files.</i></p>

<p style="margin-top: 1em"><i>The output filenames are
specified by a pattern, which can be used to produce
sequentially numbered series of files. The pattern may
contain the string &quot;%d&quot; or &quot;%0Nd&quot;, this
<br>
string specifies the position of the characters representing
a numbering in the filenames. If the form &quot;%0Nd&quot;
is used, the string representing the number in each filename
is <br>
0-padded to N digits. The literal character &rsquo;%&rsquo;
can be specified in the pattern with the string
&quot;%%&quot;.</i></p>

<p style="margin-top: 1em"><i>If the pattern contains
&quot;%d&quot; or &quot;%0Nd&quot;, the first filename of
the file list specified will contain the number 1, all the
following numbers will be sequential.</i></p>

<p style="margin-top: 1em"><i>The pattern may contain a
suffix which is used to automatically determine the format
of the image files to write.</i></p>

<p style="margin-top: 1em"><i>For example the pattern
&quot;img-%03d.bmp&quot; will specify a sequence of
filenames of the form img-001.bmp, img-002.bmp, ...,
img-010.bmp, etc. The pattern &quot;img%%-%d.jpg&quot; will
specify <br>
a sequence of filenames of the form img%-1.jpg, img%-2.jpg,
..., img%-10.jpg, etc.</i></p>

<p style="margin-top: 1em"><i>Examples</i></p>

<p style="margin-top: 1em"><i>The following example shows
how to use ffmpeg for creating a sequence of files
img-001.jpeg, img-002.jpeg, ..., taking one image every
second from the input video:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.avi -vsync 1 -r
1 -f image2 &rsquo;img-%03d.jpeg&rsquo;</i></p>

<p style="margin-top: 1em"><i>Note that with ffmpeg, if the
format is not specified with the &quot;-f&quot; option and
the output filename specifies an image file format, the
image2 muxer is automatically selected, so <br>
the previous command can be written as:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.avi -vsync 1 -r
1 &rsquo;img-%03d.jpeg&rsquo;</i></p>

<p style="margin-top: 1em"><i>Note also that the pattern
must not necessarily contain &quot;%d&quot; or
&quot;%0Nd&quot;, for example to create a single image file
img.jpeg from the input video you can employ the
command:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.avi -f image2
-frames:v 1 img.jpeg</i></p>

<p style="margin-top: 1em"><i>The strftime option allows
you to expand the filename with date and time information.
Check the documentation of the &quot;strftime()&quot;
function for the syntax.</i></p>

<p style="margin-top: 1em"><i>For example to generate image
files from the &quot;strftime()&quot;
&quot;%Y-%m-%d_%H-%M-%S&quot; pattern, the following ffmpeg
command can be used:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -f v4l2 -r 1 -i
/dev/video0 -f image2 -strftime 1
&quot;%Y-%m-%d_%H-%M-%S.jpg&quot;</i></p>

<p style="margin-top: 1em"><i>Options</i></p>

<p style="margin-top: 1em"><i>start_number <br>
Start the sequence from the specified number. Default value
is 0.</i></p>

<p style="margin-top: 1em"><i>update <br>
If set to 1, the filename will always be interpreted as just
a filename, not a pattern, and the corresponding file will
be continuously overwritten with new images. Default <br>
value is 0.</i></p>

<p style="margin-top: 1em"><i>strftime <br>
If set to 1, expand the filename with date and time
information from &quot;strftime()&quot;. Default value is
0.</i></p>

<p style="margin-top: 1em"><i>The image muxer supports the
.Y.U.V image file format. This format is special in that
that each image frame consists of three files, for each of
the YUV420P components. To read <br>
or write this image file format, specify the name of the
&rsquo;.Y&rsquo; file. The muxer will automatically open the
&rsquo;.U&rsquo; and &rsquo;.V&rsquo; files as
required.</i></p>

<p style="margin-top: 1em"><i>matroska <br>
Matroska container muxer.</i></p>

<p style="margin-top: 1em"><i>This muxer implements the
matroska and webm container specs.</i></p>

<p style="margin-top: 1em"><i>Metadata</i></p>

<p style="margin-top: 1em"><i>The recognized metadata
settings in this muxer are:</i></p>

<p style="margin-top: 1em"><i>title <br>
Set title name provided to a single track.</i></p>

<p style="margin-top: 1em"><i>language <br>
Specify the language of the track in the Matroska languages
form.</i></p>

<p style="margin-top: 1em"><i>The language can be either
the 3 letters bibliographic ISO-639-2 (ISO 639-2/B) form
(like &quot;fre&quot; for French), or a language code mixed
with a country code for specialities in <br>
languages (like &quot;fre-ca&quot; for Canadian
French).</i></p>

<p style="margin-top: 1em"><i>stereo_mode <br>
Set stereo 3D video layout of two views in a single video
track.</i></p>

<p style="margin-top: 1em"><i>The following values are
recognized:</i></p>

<p style="margin-top: 1em"><i>mono <br>
video is not stereo</i></p>

<p style="margin-top: 1em"><i>left_right <br>
Both views are arranged side by side, Left-eye view is on
the left</i></p>

<p style="margin-top: 1em"><i>bottom_top <br>
Both views are arranged in top-bottom orientation, Left-eye
view is at bottom</i></p>

<p style="margin-top: 1em"><i>top_bottom <br>
Both views are arranged in top-bottom orientation, Left-eye
view is on top</i></p>

<p style="margin-top: 1em"><i>checkerboard_rl <br>
Each view is arranged in a checkerboard interleaved pattern,
Left-eye view being first</i></p>

<p style="margin-top: 1em"><i>checkerboard_lr <br>
Each view is arranged in a checkerboard interleaved pattern,
Right-eye view being first</i></p>

<p style="margin-top: 1em"><i>row_interleaved_rl <br>
Each view is constituted by a row based interleaving,
Right-eye view is first row</i></p>

<p style="margin-top: 1em"><i>row_interleaved_lr <br>
Each view is constituted by a row based interleaving,
Left-eye view is first row</i></p>

<p style="margin-top: 1em"><i>col_interleaved_rl <br>
Both views are arranged in a column based interleaving
manner, Right-eye view is first column</i></p>

<p style="margin-top: 1em"><i>col_interleaved_lr <br>
Both views are arranged in a column based interleaving
manner, Left-eye view is first column</i></p>

<p style="margin-top: 1em"><i>anaglyph_cyan_red <br>
All frames are in anaglyph format viewable through red-cyan
filters</i></p>

<p style="margin-top: 1em"><i>right_left <br>
Both views are arranged side by side, Right-eye view is on
the left</i></p>

<p style="margin-top: 1em"><i>anaglyph_green_magenta <br>
All frames are in anaglyph format viewable through
green-magenta filters</i></p>

<p style="margin-top: 1em"><i>block_lr <br>
Both eyes laced in one Block, Left-eye view is first</i></p>

<p style="margin-top: 1em"><i>block_rl <br>
Both eyes laced in one Block, Right-eye view is
first</i></p>

<p style="margin-top: 1em"><i>For example a 3D WebM clip
can be created using the following command line:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i
sample_left_right_clip.mpg -an -c:v libvpx -metadata
stereo_mode=left_right -y stereo_clip.webm</i></p>

<p style="margin-top: 1em"><i>Options</i></p>

<p style="margin-top: 1em"><i>This muxer supports the
following options:</i></p>

<p style="margin-top: 1em"><i>reserve_index_space <br>
By default, this muxer writes the index for seeking (called
cues in Matroska terms) at the end of the file, because it
cannot know in advance how much space to leave for the <br>
index at the beginning of the file. However for some use
cases -- e.g. streaming where seeking is possible but slow
-- it is useful to put the index at the beginning of the
<br>
file.</i></p>

<p style="margin-top: 1em"><i>If this option is set to a
non-zero value, the muxer will reserve a given amount of
space in the file header and then try to write the cues
there when the muxing finishes. If <br>
the available space does not suffice, muxing will fail. A
safe size for most use cases should be about 50kB per hour
of video.</i></p>

<p style="margin-top: 1em"><i>Note that cues are only
written if the output is seekable and this option will have
no effect if it is not.</i></p>

<p style="margin-top: 1em"><i>md5 <br>
MD5 testing format.</i></p>

<p style="margin-top: 1em"><i>This is a variant of the hash
muxer. Unlike that muxer, it defaults to using the MD5 hash
function.</i></p>

<p style="margin-top: 1em"><i>Examples</i></p>

<p style="margin-top: 1em"><i>To compute the MD5 hash of
the input converted to raw audio and video, and store it in
the file out.md5:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i INPUT -f md5
out.md5</i></p>

<p style="margin-top: 1em"><i>You can print the MD5 to
stdout with the command:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i INPUT -f md5
-</i></p>

<p style="margin-top: 1em"><i>See also the hash and
framemd5 muxers.</i></p>

<p style="margin-top: 1em"><i>mov, mp4, ismv <br>
MOV/MP4/ISMV (Smooth Streaming) muxer.</i></p>

<p style="margin-top: 1em"><i>The mov/mp4/ismv muxer
supports fragmentation. Normally, a MOV/MP4 file has all the
metadata about all packets stored in one location (written
at the end of the file, it can be <br>
moved to the start for better playback by adding faststart
to the movflags, or using the qt-faststart tool). A
fragmented file consists of a number of fragments, where
packets <br>
and metadata about these packets are stored together.
Writing a fragmented file has the advantage that the file is
decodable even if the writing is interrupted (while a normal
<br>
MOV/MP4 is undecodable if it is not properly finished), and
it requires less memory when writing very long files (since
writing normal MOV/MP4 files stores info about every <br>
single packet in memory until the file is closed). The
downside is that it is less compatible with other
applications.</i></p>

<p style="margin-top: 1em"><i>Options</i></p>

<p style="margin-top: 1em"><i>Fragmentation is enabled by
setting one of the AVOptions that define how to cut the file
into fragments:</i></p>

<p style="margin-top: 1em"><i>-moov_size bytes <br>
Reserves space for the moov atom at the beginning of the
file instead of placing the moov atom at the end. If the
space reserved is insufficient, muxing will fail.</i></p>

<p style="margin-top: 1em"><i>-movflags frag_keyframe <br>
Start a new fragment at each video keyframe.</i></p>

<p style="margin-top: 1em"><i>-frag_duration duration <br>
Create fragments that are duration microseconds
long.</i></p>

<p style="margin-top: 1em"><i>-frag_size size <br>
Create fragments that contain up to size bytes of payload
data.</i></p>

<p style="margin-top: 1em"><i>-movflags frag_custom <br>
Allow the caller to manually choose when to cut fragments,
by calling &quot;av_write_frame(ctx, NULL)&quot; to write a
fragment with the packets written so far. (This is only
useful <br>
with other applications integrating libavformat, not from
ffmpeg.)</i></p>

<p style="margin-top: 1em"><i>-min_frag_duration duration
<br>
Don&rsquo;t create fragments that are shorter than duration
microseconds long.</i></p>

<p style="margin-top: 1em"><i>If more than one condition is
specified, fragments are cut when one of the specified
conditions is fulfilled. The exception to this is
&quot;-min_frag_duration&quot;, which has to be <br>
fulfilled for any of the other conditions to apply.</i></p>

<p style="margin-top: 1em"><i>Additionally, the way the
output file is written can be adjusted through a few other
options:</i></p>

<p style="margin-top: 1em"><i>-movflags empty_moov <br>
Write an initial moov atom directly at the start of the
file, without describing any samples in it. Generally, an
mdat/moov pair is written at the start of the file, as a
<br>
normal MOV/MP4 file, containing only a short portion of the
file. With this option set, there is no initial mdat atom,
and the moov atom only describes the tracks but has a <br>
zero duration.</i></p>

<p style="margin-top: 1em"><i>This option is implicitly set
when writing ismv (Smooth Streaming) files.</i></p>

<p style="margin-top: 1em"><i>-movflags separate_moof <br>
Write a separate moof (movie fragment) atom for each track.
Normally, packets for all tracks are written in a moof atom
(which is slightly more efficient), but with this <br>
option set, the muxer writes one moof/mdat pair for each
track, making it easier to separate tracks.</i></p>

<p style="margin-top: 1em"><i>This option is implicitly set
when writing ismv (Smooth Streaming) files.</i></p>

<p style="margin-top: 1em"><i>-movflags faststart <br>
Run a second pass moving the index (moov atom) to the
beginning of the file. This operation can take a while, and
will not work in various situations such as fragmented <br>
output, thus it is not enabled by default.</i></p>

<p style="margin-top: 1em"><i>-movflags rtphint <br>
Add RTP hinting tracks to the output file.</i></p>

<p style="margin-top: 1em"><i>-movflags disable_chpl <br>
Disable Nero chapter markers (chpl atom). Normally, both
Nero chapters and a QuickTime chapter track are written to
the file. With this option set, only the QuickTime <br>
chapter track will be written. Nero chapters can cause
failures when the file is reprocessed with certain tagging
programs, like mp3Tag 2.61a and iTunes 11.3, most likely
<br>
other versions are affected as well.</i></p>

<p style="margin-top: 1em"><i>-movflags omit_tfhd_offset
<br>
Do not write any absolute base_data_offset in tfhd atoms.
This avoids tying fragments to absolute byte positions in
the file/streams.</i></p>

<p style="margin-top: 1em"><i>-movflags default_base_moof
<br>
Similarly to the omit_tfhd_offset, this flag avoids writing
the absolute base_data_offset field in tfhd atoms, but does
so by using the new default-base-is-moof flag instead. <br>
This flag is new from 14496-12:2012. This may make the
fragments easier to parse in certain circumstances (avoiding
basing track fragment location calculations on the <br>
implicit end of the previous track fragment).</i></p>

<p style="margin-top: 1em"><i>-write_tmcd <br>
Specify &quot;on&quot; to force writing a timecode track,
&quot;off&quot; to disable it and &quot;auto&quot; to write
a timecode track only for mov and mp4 output
(default).</i></p>

<p style="margin-top: 1em"><i>Example</i></p>

<p style="margin-top: 1em"><i>Smooth Streaming content can
be pushed in real time to a publishing point on IIS with
this muxer. Example:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -re &lt;&lt;normal
input/transcoding options&gt;&gt; -movflags
isml+frag_keyframe -f ismv
http://server/publishingpoint.isml/Streams(Encoder1)</i></p>

<p style="margin-top: 1em"><i>Audible AAX</i></p>

<p style="margin-top: 1em"><i>Audible AAX files are
encrypted M4B files, and they can be decrypted by specifying
a 4 byte activation secret.</i></p>

<p style="margin-top: 1em"><i>ffmpeg -activation_bytes
1CEB00DA -i test.aax -vn -c:a copy output.mp4</i></p>

<p style="margin-top: 1em"><i>mp3 <br>
The MP3 muxer writes a raw MP3 stream with the following
optional features:</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; An ID3v2
metadata header at the beginning (enabled by default).
Versions 2.3 and 2.4 are supported, the
&quot;id3v2_version&quot; private option controls which one
is used (3 or 4). <br>
Setting &quot;id3v2_version&quot; to 0 disables the ID3v2
header completely.</i></p>

<p style="margin-top: 1em"><i>The muxer supports writing
attached pictures (APIC frames) to the ID3v2 header. The
pictures are supplied to the muxer in form of a video stream
with a single packet. There <br>
can be any number of those streams, each will correspond to
a single APIC frame. The stream metadata tags title and
comment map to APIC description and picture type <br>
respectively. See &lt;http://id3.org/id3v2.4.0-frames&gt;
for allowed picture types.</i></p>

<p style="margin-top: 1em"><i>Note that the APIC frames
must be written at the beginning, so the muxer will buffer
the audio frames until it gets all the pictures. It is
therefore advised to provide the <br>
pictures as soon as possible to avoid excessive
buffering.</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; A Xing/LAME
frame right after the ID3v2 header (if present). It is
enabled by default, but will be written only if the output
is seekable. The &quot;write_xing&quot; private option can
<br>
be used to disable it. The frame contains various
information that may be useful to the decoder, like the
audio duration or encoder delay.</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; A legacy
ID3v1 tag at the end of the file (disabled by default). It
may be enabled with the &quot;write_id3v1&quot; private
option, but as its capabilities are very limited, its usage
<br>
is not recommended.</i></p>

<p style="margin-top: 1em"><i>Examples:</i></p>

<p style="margin-top: 1em"><i>Write an mp3 with an ID3v2.3
header and an ID3v1 footer:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i INPUT
-id3v2_version 3 -write_id3v1 1 out.mp3</i></p>

<p style="margin-top: 1em"><i>To attach a picture to an mp3
file select both the audio and the picture stream with
&quot;map&quot;:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i input.mp3 -i
cover.png -c copy -map 0 -map 1 <br>
-metadata:s:v title=&quot;Album cover&quot; -metadata:s:v
comment=&quot;Cover (Front)&quot; out.mp3</i></p>

<p style="margin-top: 1em"><i>Write a &quot;clean&quot; MP3
without any extra features:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i input.wav
-write_xing 0 -id3v2_version 0 out.mp3</i></p>

<p style="margin-top: 1em"><i>mpegts <br>
MPEG transport stream muxer.</i></p>

<p style="margin-top: 1em"><i>This muxer implements ISO
13818-1 and part of ETSI EN 300 468.</i></p>

<p style="margin-top: 1em"><i>The recognized metadata
settings in mpegts muxer are &quot;service_provider&quot;
and &quot;service_name&quot;. If they are not set the
default for &quot;service_provider&quot; is
&quot;FFmpeg&quot; and the default for <br>
&quot;service_name&quot; is &quot;Service01&quot;.</i></p>

<p style="margin-top: 1em"><i>Options</i></p>

<p style="margin-top: 1em"><i>The muxer options
are:</i></p>

<p style="margin-top: 1em"><i>mpegts_original_network_id
number <br>
Set the original_network_id (default 0x0001). This is unique
identifier of a network in DVB. Its main use is in the
unique identification of a service through the path <br>
Original_Network_ID, Transport_Stream_ID.</i></p>

<p style="margin-top: 1em"><i>mpegts_transport_stream_id
number <br>
Set the transport_stream_id (default 0x0001). This
identifies a transponder in DVB.</i></p>

<p style="margin-top: 1em"><i>mpegts_service_id number <br>
Set the service_id (default 0x0001) also known as program in
DVB.</i></p>

<p style="margin-top: 1em"><i>mpegts_service_type number
<br>
Set the program service_type (default digital_tv), see below
a list of pre defined values.</i></p>

<p style="margin-top: 1em"><i>mpegts_pmt_start_pid number
<br>
Set the first PID for PMT (default 0x1000, max
0x1f00).</i></p>

<p style="margin-top: 1em"><i>mpegts_start_pid number <br>
Set the first PID for data packets (default 0x0100, max
0x0f00).</i></p>

<p style="margin-top: 1em"><i>mpegts_m2ts_mode number <br>
Enable m2ts mode if set to 1. Default value is -1 which
disables m2ts mode.</i></p>

<p style="margin-top: 1em"><i>muxrate number <br>
Set a constant muxrate (default VBR).</i></p>

<p style="margin-top: 1em"><i>pcr_period numer <br>
Override the default PCR retransmission time (default 20ms),
ignored if variable muxrate is selected.</i></p>

<p style="margin-top: 1em"><i>pat_period number <br>
Maximal time in seconds between PAT/PMT tables.</i></p>

<p style="margin-top: 1em"><i>sdt_period number <br>
Maximal time in seconds between SDT tables.</i></p>

<p style="margin-top: 1em"><i>pes_payload_size number <br>
Set minimum PES packet payload in bytes.</i></p>

<p style="margin-top: 1em"><i>mpegts_flags flags <br>
Set flags (see below).</i></p>

<p style="margin-top: 1em"><i>mpegts_copyts number <br>
Preserve original timestamps, if value is set to 1. Default
value is -1, which results in shifting timestamps so that
they start from 0.</i></p>

<p style="margin-top: 1em"><i>tables_version number <br>
Set PAT, PMT and SDT version (default 0, valid values are
from 0 to 31, inclusively). This option allows updating
stream structure so that standard consumer may detect the
<br>
change. To do so, reopen output AVFormatContext (in case of
API usage) or restart ffmpeg instance, cyclically changing
tables_version value:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i source1.ts -codec
copy -f mpegts -tables_version 0 udp://1.1.1.1:1111 <br>
ffmpeg -i source2.ts -codec copy -f mpegts -tables_version 1
udp://1.1.1.1:1111 <br>
... <br>
ffmpeg -i source3.ts -codec copy -f mpegts -tables_version
31 udp://1.1.1.1:1111 <br>
ffmpeg -i source1.ts -codec copy -f mpegts -tables_version 0
udp://1.1.1.1:1111 <br>
ffmpeg -i source2.ts -codec copy -f mpegts -tables_version 1
udp://1.1.1.1:1111 <br>
...</i></p>

<p style="margin-top: 1em"><i>Option mpegts_service_type
accepts the following values:</i></p>

<p style="margin-top: 1em"><i>hex_value <br>
Any hexdecimal value between 0x01 to 0xff as defined in ETSI
300 468.</i></p>

<p style="margin-top: 1em"><i>digital_tv <br>
Digital TV service.</i></p>

<p style="margin-top: 1em"><i>digital_radio <br>
Digital Radio service.</i></p>

<p style="margin-top: 1em"><i>teletext <br>
Teletext service.</i></p>

<p style="margin-top: 1em"><i>advanced_codec_digital_radio
<br>
Advanced Codec Digital Radio service.</i></p>

<p style="margin-top: 1em"><i>mpeg2_digital_hdtv <br>
MPEG2 Digital HDTV service.</i></p>

<p style="margin-top: 1em"><i>advanced_codec_digital_sdtv
<br>
Advanced Codec Digital SDTV service.</i></p>

<p style="margin-top: 1em"><i>advanced_codec_digital_hdtv
<br>
Advanced Codec Digital HDTV service.</i></p>

<p style="margin-top: 1em"><i>Option mpegts_flags may take
a set of such flags:</i></p>

<p style="margin-top: 1em"><i>resend_headers <br>
Reemit PAT/PMT before writing the next packet.</i></p>

<p style="margin-top: 1em"><i>latm <br>
Use LATM packetization for AAC.</i></p>

<p style="margin-top: 1em"><i>pat_pmt_at_frames <br>
Reemit PAT and PMT at each video frame.</i></p>

<p style="margin-top: 1em"><i>system_b <br>
Conform to System B (DVB) instead of System A
(ATSC).</i></p>

<p style="margin-top: 1em"><i>Example</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i file.mpg -c copy
-mpegts_original_network_id 0x1122
-mpegts_transport_stream_id 0x3344 -mpegts_service_id 0x5566
-mpegts_pmt_start_pid 0x1500 -mpegts_start_pid 0x150
-metadata service_provider=&quot;Some provider&quot;
-metadata service_name=&quot;Some Channel&quot; -y
out.ts</i></p>

<p style="margin-top: 1em"><i>mxf, mxf_d10 <br>
MXF muxer.</i></p>

<p style="margin-top: 1em"><i>Options</i></p>

<p style="margin-top: 1em"><i>The muxer options
are:</i></p>

<p style="margin-top: 1em"><i>store_user_comments bool <br>
Set if user comments should be stored if available or never.
IRT D-10 does not allow user comments. The default is thus
to write them for mxf but not for mxf_d10</i></p>

<p style="margin-top: 1em"><i>null <br>
Null muxer.</i></p>

<p style="margin-top: 1em"><i>This muxer does not generate
any output file, it is mainly useful for testing or
benchmarking purposes.</i></p>

<p style="margin-top: 1em"><i>For example to benchmark
decoding with ffmpeg you can use the command:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -benchmark -i INPUT -f
null out.null</i></p>

<p style="margin-top: 1em"><i>Note that the above command
does not read or write the out.null file, but specifying the
output file is required by the ffmpeg syntax.</i></p>

<p style="margin-top: 1em"><i>Alternatively you can write
the command as:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -benchmark -i INPUT -f
null -</i></p>

<p style="margin-top: 1em"><i>nut <br>
-syncpoints flags <br>
Change the syncpoint usage in nut:</i></p>

<p style="margin-top: 1em"><i>default use the normal
low-overhead seeking aids. <br>
none do not use the syncpoints at all, reducing the overhead
but making the stream non-seekable; <br>
Use of this option is not recommended, as the resulting
files are very damage <br>
sensitive and seeking is not possible. Also in general the
overhead from <br>
syncpoints is negligible. Note, -C&lt;write_index&gt; 0 can
be used to disable <br>
all growing data tables, allowing to mux endless streams
with limited memory <br>
and without these disadvantages.</i></p>

<p style="margin-top: 1em"><i>timestamped extend the
syncpoint with a wallclock field.</i></p>

<p style="margin-top: 1em"><i>The none and timestamped
flags are experimental.</i></p>

<p style="margin-top: 1em"><i>-write_index bool <br>
Write index at the end, the default is to write an
index.</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i INPUT -f_strict
experimental -syncpoints none - | processor</i></p>

<p style="margin-top: 1em"><i>ogg <br>
Ogg container muxer.</i></p>

<p style="margin-top: 1em"><i>-page_duration duration <br>
Preferred page duration, in microseconds. The muxer will
attempt to create pages that are approximately duration
microseconds long. This allows the user to compromise
between <br>
seek granularity and container overhead. The default is 1
second. A value of 0 will fill all segments, making pages as
large as possible. A value of 1 will effectively use 1 <br>
packet-per-page in most situations, giving a small seek
granularity at the cost of additional container
overhead.</i></p>

<p style="margin-top: 1em"><i>-serial_offset value <br>
Serial value from which to set the streams serial number.
Setting it to different and sufficiently large values
ensures that the produced ogg files can be safely
chained.</i></p>

<p style="margin-top: 1em"><i>segment, stream_segment,
ssegment <br>
Basic stream segmenter.</i></p>

<p style="margin-top: 1em"><i>This muxer outputs streams to
a number of separate files of nearly fixed duration. Output
filename pattern can be set in a fashion similar to image2,
or by using a &quot;strftime&quot; <br>
template if the strftime option is enabled.</i></p>

<p style="margin-top: 1em"><i>&quot;stream_segment&quot; is
a variant of the muxer used to write to streaming output
formats, i.e. which do not require global headers, and is
recommended for outputting e.g. to MPEG <br>
transport stream segments. &quot;ssegment&quot; is a shorter
alias for &quot;stream_segment&quot;.</i></p>

<p style="margin-top: 1em"><i>Every segment starts with a
keyframe of the selected reference stream, which is set
through the reference_stream option.</i></p>

<p style="margin-top: 1em"><i>Note that if you want
accurate splitting for a video file, you need to make the
input key frames correspond to the exact splitting times
expected by the segmenter, or the segment <br>
muxer will start the new segment with the key frame found
next after the specified start time.</i></p>

<p style="margin-top: 1em"><i>The segment muxer works best
with a single constant frame rate video.</i></p>

<p style="margin-top: 1em"><i>Optionally it can generate a
list of the created segments, by setting the option
segment_list. The list type is specified by the
segment_list_type option. The entry filenames in <br>
the segment list are set by default to the basename of the
corresponding segment files.</i></p>

<p style="margin-top: 1em"><i>See also the hls muxer, which
provides a more specific implementation for HLS
segmentation.</i></p>

<p style="margin-top: 1em"><i>Options</i></p>

<p style="margin-top: 1em"><i>The segment muxer supports
the following options:</i></p>

<p style="margin-top: 1em"><i>increment_tc 1|0 <br>
if set to 1, increment timecode between each segment If this
is selected, the input need to have a timecode in the first
video stream. Default value is 0.</i></p>

<p style="margin-top: 1em"><i>reference_stream specifier
<br>
Set the reference stream, as specified by the string
specifier. If specifier is set to &quot;auto&quot;, the
reference is chosen automatically. Otherwise it must be a
stream specifier <br>
(see the &lsquo;&lsquo;Stream specifiers&rsquo;&rsquo;
chapter in the ffmpeg manual) which specifies the reference
stream. The default value is &quot;auto&quot;.</i></p>

<p style="margin-top: 1em"><i>segment_format format <br>
Override the inner container format, by default it is
guessed by the filename extension.</i></p>

<p style="margin-top: 1em"><i>segment_format_options
options_list <br>
Set output format options using a :-separated list of
key=value parameters. Values containing the &quot;:&quot;
special character must be escaped.</i></p>

<p style="margin-top: 1em"><i>segment_list name <br>
Generate also a listfile named name. If not specified no
listfile is generated.</i></p>

<p style="margin-top: 1em"><i>segment_list_flags flags <br>
Set flags affecting the segment list generation.</i></p>

<p style="margin-top: 1em"><i>It currently supports the
following flags:</i></p>

<p style="margin-top: 1em"><i>cache <br>
Allow caching (only affects M3U8 list files).</i></p>

<p style="margin-top: 1em"><i>live <br>
Allow live-friendly file generation.</i></p>

<p style="margin-top: 1em"><i>segment_list_size size <br>
Update the list file so that it contains at most size
segments. If 0 the list file will contain all the segments.
Default value is 0.</i></p>

<p style="margin-top: 1em"><i>segment_list_entry_prefix
prefix <br>
Prepend prefix to each entry. Useful to generate absolute
paths. By default no prefix is applied.</i></p>

<p style="margin-top: 1em"><i>segment_list_type type <br>
Select the listing format.</i></p>

<p style="margin-top: 1em"><i>The following values are
recognized:</i></p>

<p style="margin-top: 1em"><i>flat <br>
Generate a flat list for the created segments, one segment
per line.</i></p>

<p style="margin-top: 1em"><i>csv, ext <br>
Generate a list for the created segments, one segment per
line, each line matching the format (comma-separated
values):</i></p>


<p style="margin-top: 1em"><i>&lt;segment_filename&gt;,&lt;segment_start_time&gt;,&lt;segment_end_time&gt;</i></p>

<p style="margin-top: 1em"><i>segment_filename is the name
of the output file generated by the muxer according to the
provided pattern. CSV escaping (according to RFC4180) is
applied if required.</i></p>

<p style="margin-top: 1em"><i>segment_start_time and
segment_end_time specify the segment start and end time
expressed in seconds.</i></p>

<p style="margin-top: 1em"><i>A list file with the suffix
&quot;.csv&quot; or &quot;.ext&quot; will auto-select this
format.</i></p>

<p style="margin-top: 1em"><i>ext is deprecated in favor or
csv.</i></p>

<p style="margin-top: 1em"><i>ffconcat <br>
Generate an ffconcat file for the created segments. The
resulting file can be read using the FFmpeg concat
demuxer.</i></p>

<p style="margin-top: 1em"><i>A list file with the suffix
&quot;.ffcat&quot; or &quot;.ffconcat&quot; will auto-select
this format.</i></p>

<p style="margin-top: 1em"><i>m3u8 <br>
Generate an extended M3U8 file, version 3, compliant with
&lt;http://tools.ietf.org/id/draft-pantos-http-live-streaming&gt;.</i></p>

<p style="margin-top: 1em"><i>A list file with the suffix
&quot;.m3u8&quot; will auto-select this format.</i></p>

<p style="margin-top: 1em"><i>If not specified the type is
guessed from the list file name suffix.</i></p>

<p style="margin-top: 1em"><i>segment_time time <br>
Set segment duration to time, the value must be a duration
specification. Default value is &quot;2&quot;. See also the
segment_times option.</i></p>

<p style="margin-top: 1em"><i>Note that splitting may not
be accurate, unless you force the reference stream
key-frames at the given time. See the introductory notice
and the examples below.</i></p>

<p style="margin-top: 1em"><i>segment_atclocktime 1|0 <br>
If set to &quot;1&quot; split at regular clock time
intervals starting from 00:00 o&rsquo;clock. The time value
specified in segment_time is used for setting the length of
the splitting <br>
interval.</i></p>

<p style="margin-top: 1em"><i>For example with segment_time
set to &quot;900&quot; this makes it possible to create
files at 12:00 o&rsquo;clock, 12:15, 12:30, etc.</i></p>

<p style="margin-top: 1em"><i>Default value is
&quot;0&quot;.</i></p>

<p style="margin-top: 1em"><i>segment_clocktime_offset
duration <br>
Delay the segment splitting times with the specified
duration when using segment_atclocktime.</i></p>

<p style="margin-top: 1em"><i>For example with segment_time
set to &quot;900&quot; and segment_clocktime_offset set to
&quot;300&quot; this makes it possible to create files at
12:05, 12:20, 12:35, etc.</i></p>

<p style="margin-top: 1em"><i>Default value is
&quot;0&quot;.</i></p>


<p style="margin-top: 1em"><i>segment_clocktime_wrap_duration
duration <br>
Force the segmenter to only start a new segment if a packet
reaches the muxer within the specified duration after the
segmenting clock time. This way you can make the <br>
segmenter more resilient to backward local time jumps, such
as leap seconds or transition to standard time from daylight
savings time.</i></p>

<p style="margin-top: 1em"><i>Assuming that the delay
between the packets of your source is less than 0.5 second
you can detect a leap second by specifying 0.5 as the
duration.</i></p>

<p style="margin-top: 1em"><i>Default is the maximum
possible duration which means starting a new segment
regardless of the elapsed time since the last clock
time.</i></p>

<p style="margin-top: 1em"><i>segment_time_delta delta <br>
Specify the accuracy time when selecting the start time for
a segment, expressed as a duration specification. Default
value is &quot;0&quot;.</i></p>

<p style="margin-top: 1em"><i>When delta is specified a
key-frame will start a new segment if its PTS satisfies the
relation:</i></p>

<p style="margin-top: 1em"><i>PTS &gt;= start_time -
time_delta</i></p>

<p style="margin-top: 1em"><i>This option is useful when
splitting video content, which is always split at GOP
boundaries, in case a key frame is found just before the
specified split time.</i></p>

<p style="margin-top: 1em"><i>In particular may be used in
combination with the ffmpeg option force_key_frames. The key
frame times specified by force_key_frames may not be set
accurately because of <br>
rounding issues, with the consequence that a key frame time
may result set just before the specified time. For constant
frame rate videos a value of 1/(2*frame_rate) should <br>
address the worst case mismatch between the specified time
and the time set by force_key_frames.</i></p>

<p style="margin-top: 1em"><i>segment_times times <br>
Specify a list of split points. times contains a list of
comma separated duration specifications, in increasing
order. See also the segment_time option.</i></p>

<p style="margin-top: 1em"><i>segment_frames frames <br>
Specify a list of split video frame numbers. frames contains
a list of comma separated integer numbers, in increasing
order.</i></p>

<p style="margin-top: 1em"><i>This option specifies to
start a new segment whenever a reference stream key frame is
found and the sequential number (starting from 0) of the
frame is greater or equal to <br>
the next value in the list.</i></p>

<p style="margin-top: 1em"><i>segment_wrap limit <br>
Wrap around segment index once it reaches limit.</i></p>

<p style="margin-top: 1em"><i>segment_start_number number
<br>
Set the sequence number of the first segment. Defaults to
0.</i></p>

<p style="margin-top: 1em"><i>strftime 1|0 <br>
Use the &quot;strftime&quot; function to define the name of
the new segments to write. If this is selected, the output
segment name must contain a &quot;strftime&quot; function
template. Default <br>
value is 0.</i></p>

<p style="margin-top: 1em"><i>break_non_keyframes 1|0 <br>
If enabled, allow segments to start on frames other than
keyframes. This improves behavior on some players when the
time between keyframes is inconsistent, but may make <br>
things worse on others, and can cause some oddities during
seeking. Defaults to 0.</i></p>

<p style="margin-top: 1em"><i>reset_timestamps 1|0 <br>
Reset timestamps at the begin of each segment, so that each
segment will start with near-zero timestamps. It is meant to
ease the playback of the generated segments. May not <br>
work with some combinations of muxers/codecs. It is set to 0
by default.</i></p>

<p style="margin-top: 1em"><i>initial_offset offset <br>
Specify timestamp offset to apply to the output packet
timestamps. The argument must be a time duration
specification, and defaults to 0.</i></p>

<p style="margin-top: 1em"><i>write_empty_segments 1|0 <br>
If enabled, write an empty segment if there are no packets
during the period a segment would usually span. Otherwise,
the segment will be filled with the next packet written.
<br>
Defaults to 0.</i></p>

<p style="margin-top: 1em"><i>Examples</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Remux the
content of file in.mkv to a list of segments out-000.nut,
out-001.nut, etc., and write the list of generated segments
to out.list:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.mkv -codec copy
-map 0 -f segment -segment_list out.list out%03d.nut</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Segment input
and set output format options for the output
segments:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.mkv -f segment
-segment_time 10 -segment_format_options movflags=+faststart
out%03d.mp4</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Segment the
input file according to the split points specified by the
segment_times option:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.mkv -codec copy
-map 0 -f segment -segment_list out.csv -segment_times
1,2,3,5,8,13,21 out%03d.nut</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Use the
ffmpeg force_key_frames option to force key frames in the
input at the specified location, together with the segment
option segment_time_delta to account for possible <br>
roundings operated when setting key frame times.</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.mkv
-force_key_frames 1,2,3,5,8,13,21 -codec:v mpeg4 -codec:a
pcm_s16le -map 0 -f segment -segment_list out.csv
-segment_times 1,2,3,5,8,13,21 -segment_time_delta 0.05
out%03d.nut</i></p>

<p style="margin-top: 1em"><i>In order to force key frames
on the input file, transcoding is required.</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Segment the
input file by splitting the input file according to the
frame numbers sequence specified with the segment_frames
option:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.mkv -codec copy
-map 0 -f segment -segment_list out.csv -segment_frames
100,200,300,500,800 out%03d.nut</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Convert the
in.mkv to TS segments using the &quot;libx264&quot; and
&quot;aac&quot; encoders:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i in.mkv -map 0
-codec:v libx264 -codec:a aac -f ssegment -segment_list
out.list out%03d.ts</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Segment the
input file, and create an M3U8 live playlist (can be used as
live HLS source):</i></p>

<p style="margin-top: 1em"><i>ffmpeg -re -i in.mkv -codec
copy -map 0 -f segment -segment_list playlist.m3u8
-segment_list_flags +live -segment_time 10
out%03d.mkv</i></p>

<p style="margin-top: 1em"><i>smoothstreaming <br>
Smooth Streaming muxer generates a set of files (Manifest,
chunks) suitable for serving with conventional web
server.</i></p>

<p style="margin-top: 1em"><i>window_size <br>
Specify the number of fragments kept in the manifest.
Default 0 (keep all).</i></p>

<p style="margin-top: 1em"><i>extra_window_size <br>
Specify the number of fragments kept outside of the manifest
before removing from disk. Default 5.</i></p>

<p style="margin-top: 1em"><i>lookahead_count <br>
Specify the number of lookahead fragments. Default
2.</i></p>

<p style="margin-top: 1em"><i>min_frag_duration <br>
Specify the minimum fragment duration (in microseconds).
Default 5000000.</i></p>

<p style="margin-top: 1em"><i>remove_at_exit <br>
Specify whether to remove all fragments when finished.
Default 0 (do not remove).</i></p>

<p style="margin-top: 1em"><i>fifo <br>
The fifo pseudo-muxer allows the separation of encoding and
muxing by using first-in-first-out queue and running the
actual muxer in a separate thread. This is especially useful
<br>
in combination with the tee muxer and can be used to send
data to several destinations with different
reliability/writing speed/latency.</i></p>

<p style="margin-top: 1em"><i>API users should be aware
that callback functions (interrupt_callback, io_open and
io_close) used within its AVFormatContext must be
thread-safe.</i></p>

<p style="margin-top: 1em"><i>The behavior of the fifo
muxer if the queue fills up or if the output fails is
selectable,</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; output can be
transparently restarted with configurable delay between
retries based on real time or time of the processed
stream.</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; encoding can
be blocked during temporary failure, or continue
transparently dropping packets in case fifo queue fills
up.</i></p>

<p style="margin-top: 1em"><i>fifo_format <br>
Specify the format name. Useful if it cannot be guessed from
the output name suffix.</i></p>

<p style="margin-top: 1em"><i>queue_size <br>
Specify size of the queue (number of packets). Default value
is 60.</i></p>

<p style="margin-top: 1em"><i>format_opts <br>
Specify format options for the underlying muxer. Muxer
options can be specified as a list of key=value pairs
separated by &rsquo;:&rsquo;.</i></p>

<p style="margin-top: 1em"><i>drop_pkts_on_overflow bool
<br>
If set to 1 (true), in case the fifo queue fills up, packets
will be dropped rather than blocking the encoder. This makes
it possible to continue streaming without delaying <br>
the input, at the cost of omitting part of the stream. By
default this option is set to 0 (false), so in such cases
the encoder will be blocked until the muxer processes some
<br>
of the packets and none of them is lost.</i></p>

<p style="margin-top: 1em"><i>attempt_recovery bool <br>
If failure occurs, attempt to recover the output. This is
especially useful when used with network output, since it
makes it possible to restart streaming transparently. By
<br>
default this option is set to 0 (false).</i></p>

<p style="margin-top: 1em"><i>max_recovery_attempts <br>
Sets maximum number of successive unsuccessful recovery
attempts after which the output fails permanently. By
default this option is set to 0 (unlimited).</i></p>

<p style="margin-top: 1em"><i>recovery_wait_time duration
<br>
Waiting time before the next recovery attempt after previous
unsuccessful recovery attempt. Default value is 5
seconds.</i></p>

<p style="margin-top: 1em"><i>recovery_wait_streamtime bool
<br>
If set to 0 (false), the real time is used when waiting for
the recovery attempt (i.e. the recovery will be attempted
after at least recovery_wait_time seconds). If set to 1 <br>
(true), the time of the processed stream is taken into
account instead (i.e. the recovery will be attempted after
at least recovery_wait_time seconds of the stream is <br>
omitted). By default, this option is set to 0
(false).</i></p>

<p style="margin-top: 1em"><i>recover_any_error bool <br>
If set to 1 (true), recovery will be attempted regardless of
type of the error causing the failure. By default this
option is set to 0 (false) and in case of certain (usually
<br>
permanent) errors the recovery is not attempted even when
attempt_recovery is set to 1.</i></p>

<p style="margin-top: 1em"><i>restart_with_keyframe bool
<br>
Specify whether to wait for the keyframe after recovering
from queue overflow or failure. This option is set to 0
(false) by default.</i></p>

<p style="margin-top: 1em"><i>Examples</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Stream
something to rtmp server, continue processing the stream at
real-time rate even in case of temporary failure (network
outage) and attempt to recover streaming every <br>
second indefinitely.</i></p>

<p style="margin-top: 1em"><i>ffmpeg -re -i ... -c:v
libx264 -c:a aac -f fifo -fifo_format flv -map 0:v -map 0:a
<br>
-drop_pkts_on_overflow 1 -attempt_recovery 1
-recovery_wait_time 1
rtmp://example.com/live/stream_name</i></p>

<p style="margin-top: 1em"><i>tee <br>
The tee muxer can be used to write the same data to several
files or any other kind of muxer. It can be used, for
example, to both stream a video to the network and save it
to <br>
disk at the same time.</i></p>

<p style="margin-top: 1em"><i>It is different from
specifying several outputs to the ffmpeg command-line tool
because the audio and video data will be encoded only once
with the tee muxer; encoding can be a <br>
very expensive process. It is not useful when using the
libavformat API directly because it is then possible to feed
the same packets to several muxers directly.</i></p>

<p style="margin-top: 1em"><i>The slave outputs are
specified in the file name given to the muxer, separated by
&rsquo;|&rsquo;. If any of the slave name contains the
&rsquo;|&rsquo; separator, leading or trailing spaces or any
<br>
special character, it must be escaped (see the &quot;Quoting
and escaping&quot; section in the ffmpeg-utils(1)
manual).</i></p>

<p style="margin-top: 1em"><i>Muxer options can be
specified for each slave by prepending them as a list of
key=value pairs separated by &rsquo;:&rsquo;, between square
brackets. If the options values contain a special <br>
character or the &rsquo;:&rsquo; separator, they must be
escaped; note that this is a second level escaping.</i></p>

<p style="margin-top: 1em"><i>The following special options
are also recognized:</i></p>

<p style="margin-top: 1em"><i>f Specify the format name.
Useful if it cannot be guessed from the output name
suffix.</i></p>

<p style="margin-top: 1em"><i>bsfs[/spec] <br>
Specify a list of bitstream filters to apply to the
specified output.</i></p>

<p style="margin-top: 1em"><i>It is possible to specify to
which streams a given bitstream filter applies, by appending
a stream specifier to the option separated by &quot;/&quot;.
spec must be a stream specifier <br>
(see Format stream specifiers). If the stream specifier is
not specified, the bitstream filters will be applied to all
streams in the output.</i></p>

<p style="margin-top: 1em"><i>Several bitstream filters can
be specified, separated by &quot;,&quot;.</i></p>

<p style="margin-top: 1em"><i>select <br>
Select the streams that should be mapped to the slave
output, specified by a stream specifier. If not specified,
this defaults to all the input streams. You may use multiple
<br>
stream specifiers separated by commas (&quot;,&quot;) e.g.:
&quot;a:0,v&quot;</i></p>

<p style="margin-top: 1em"><i>onfail <br>
Specify behaviour on output failure. This can be set to
either &quot;abort&quot; (which is default) or
&quot;ignore&quot;. &quot;abort&quot; will cause whole
process to fail in case of failure on this <br>
slave output. &quot;ignore&quot; will ignore failure on this
output, so other outputs will continue without being
affected.</i></p>

<p style="margin-top: 1em"><i>Examples</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Encode
something and both archive it in a WebM file and stream it
as MPEG-TS over UDP (the streams need to be explicitly
mapped):</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i ... -c:v libx264
-c:a mp2 -f tee -map 0:v -map 0:a <br>

&quot;archive-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/&quot;</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; As above, but
continue streaming even if output to local file fails (for
example local drive fills up):</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i ... -c:v libx264
-c:a mp2 -f tee -map 0:v -map 0:a <br>

&quot;[onfail=ignore]archive-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/&quot;</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; Use ffmpeg to
encode the input, and send the output to three different
destinations. The &quot;dump_extra&quot; bitstream filter is
used to add extradata information to all the output <br>
video keyframes packets, as requested by the MPEG-TS format.
The select option is applied to out.aac in order to make it
contain only audio packets.</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i ... -map 0 -flags
+global_header -c:v libx264 -c:a aac -strict experimental
<br>
-f tee
&quot;[bsfs/v=dump_extra]out.ts|[movflags=+faststart]out.mp4|[select=a]out.aac&quot;</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; As below, but
select only stream &quot;a:1&quot; for the audio output.
Note that a second level escaping must be performed, as
&quot;:&quot; is a special character used to separate
options.</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i ... -map 0 -flags
+global_header -c:v libx264 -c:a aac -strict experimental
<br>
-f tee
&quot;[bsfs/v=dump_extra]out.ts|[movflags=+faststart]out.mp4|[select=&acute;a:1&acute;]out.aac&quot;</i></p>

<p style="margin-top: 1em"><i>Note: some codecs may need
different options depending on the output format; the
auto-detection of this can not work with the tee muxer. The
main example is the global_header <br>
flag.</i></p>

<p style="margin-top: 1em"><i>webm_dash_manifest <br>
WebM DASH Manifest muxer.</i></p>

<p style="margin-top: 1em"><i>This muxer implements the
WebM DASH Manifest specification to generate the DASH
manifest XML. It also supports manifest generation for DASH
live streams.</i></p>

<p style="margin-top: 1em"><i>For more information
see:</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; WebM DASH
Specification:
&lt;https://sites.google.com/a/webmproject.org/wiki/adaptive-streaming/webm-dash-specification&gt;</i></p>

<p style="margin-top: 1em"><i>&Acirc;&middot; ISO DASH
Specification:
&lt;http://standards.iso.org/ittf/PubliclyAvailableStandards/c065274_ISO_IEC_23009-1_2014.zip&gt;</i></p>

<p style="margin-top: 1em"><i>Options</i></p>

<p style="margin-top: 1em"><i>This muxer supports the
following options:</i></p>

<p style="margin-top: 1em"><i>adaptation_sets <br>
This option has the following syntax:
&quot;id=x,streams=a,b,c id=y,streams=d,e&quot; where x and
y are the unique identifiers of the adaptation sets and
a,b,c,d and e are the indices <br>
of the corresponding audio and video streams. Any number of
adaptation sets can be added using this option.</i></p>

<p style="margin-top: 1em"><i>live <br>
Set this to 1 to create a live stream DASH Manifest.
Default: 0.</i></p>

<p style="margin-top: 1em"><i>chunk_start_index <br>
Start index of the first chunk. This will go in the
startNumber attribute of the SegmentTemplate element in the
manifest. Default: 0.</i></p>

<p style="margin-top: 1em"><i>chunk_duration_ms <br>
Duration of each chunk in milliseconds. This will go in the
duration attribute of the SegmentTemplate element in the
manifest. Default: 1000.</i></p>

<p style="margin-top: 1em"><i>utc_timing_url <br>
URL of the page that will return the UTC timestamp in ISO
format. This will go in the value attribute of the UTCTiming
element in the manifest. Default: None.</i></p>

<p style="margin-top: 1em"><i>time_shift_buffer_depth <br>
Smallest time (in seconds) shifting buffer for which any
Representation is guaranteed to be available. This will go
in the timeShiftBufferDepth attribute of the MPD element.
<br>
Default: 60.</i></p>

<p style="margin-top: 1em"><i>minimum_update_period <br>
Minimum update period (in seconds) of the manifest. This
will go in the minimumUpdatePeriod attribute of the MPD
element. Default: 0.</i></p>

<p style="margin-top: 1em"><i>Example</i></p>

<p style="margin-top: 1em"><i>ffmpeg -f webm_dash_manifest
-i video1.webm -f webm_dash_manifest -i video2.webm -f
webm_dash_manifest -i audio1.webm -f webm_dash_manifest -i
audio2.webm -map 0 -map 1 -map 2 -map 3 -c copy -f
webm_dash_manifest -adaptation_sets &quot;id=0,streams=0,1
id=1,streams=2,3&quot; manifest.xml</i></p>

<p style="margin-top: 1em"><i>webm_chunk <br>
WebM Live Chunk Muxer.</i></p>

<p style="margin-top: 1em"><i>This muxer writes out WebM
headers and chunks as separate files which can be consumed
by clients that support WebM Live streams via DASH.</i></p>

<p style="margin-top: 1em"><i>Options</i></p>

<p style="margin-top: 1em"><i>This muxer supports the
following options:</i></p>

<p style="margin-top: 1em"><i>chunk_start_index <br>
Index of the first chunk (defaults to 0).</i></p>

<p style="margin-top: 1em"><i>header <br>
Filename of the header where the initialization data will be
written.</i></p>

<p style="margin-top: 1em"><i>audio_chunk_duration <br>
Duration of each audio chunk in milliseconds (defaults to
5000).</i></p>

<p style="margin-top: 1em"><i>Example</i></p>

<p style="margin-top: 1em"><i>ffmpeg -f v4l2 -i /dev/video0
-f alsa -i hw:0 -map 0:0 -c:v libvpx-vp9 -s 640x360
-keyint_min 30 -g 30 -f webm_chunk -header
webm_live_video_360.hdr -chunk_start_index 1
webm_live_video_360_%d.chk -map 1:0 -c:a libvorbis -b:a 128k
-f webm_chunk -header webm_live_audio_128.hdr
-chunk_start_index 1 -audio_chunk_duration 1000
webm_live_audio_128_%d.chk</i></p>

<p style="margin-top: 1em"><i>METADATA <br>
FFmpeg is able to dump metadata from media files into a
simple UTF-8-encoded INI-like text file and then load it
back using the metadata muxer/demuxer.</i></p>

<p style="margin-top: 1em"><i>The file format is as
follows:</i></p>

<p style="margin-top: 1em"><i>1. A file consists of a
header and a number of metadata tags divided into sections,
each on its own line.</i></p>

<p style="margin-top: 1em"><i>2. The header is a
;FFMETADATA string, followed by a version number (now
1).</i></p>

<p style="margin-top: 1em"><i>3. Metadata tags are of the
form key=value</i></p>

<p style="margin-top: 1em"><i>4. Immediately after header
follows global metadata</i></p>

<p style="margin-top: 1em"><i>5. After global metadata
there may be sections with per-stream/per-chapter
metadata.</i></p>

<p style="margin-top: 1em"><i>6. A section starts with the
section name in uppercase (i.e. STREAM or CHAPTER) in
brackets ([, ]) and ends with next section or end of
file.</i></p>

<p style="margin-top: 1em"><i>7. At the beginning of a
chapter section there may be an optional timebase to be used
for start/end values. It must be in form TIMEBASE=num/den,
where num and den are integers. <br>
If the timebase is missing then start/end times are assumed
to be in milliseconds.</i></p>

<p style="margin-top: 1em"><i>Next a chapter section must
contain chapter start and end times in form START=num,
END=num, where num is a positive integer.</i></p>

<p style="margin-top: 1em"><i>8. Empty lines and lines
starting with ; or # are ignored.</i></p>

<p style="margin-top: 1em"><i>9. Metadata keys or values
containing special characters (=, ;, #, &nbsp;and a newline)
must be escaped with a backslash .</i></p>

<p style="margin-top: 1em"><i>10. Note that whitespace in
metadata (e.g. foo = bar) is considered to be a part of the
tag (in the example above key is foo , value is <br>
bar).</i></p>

<p style="margin-top: 1em"><i>A ffmetadata file might look
like this:</i></p>

<p style="margin-top: 1em"><i>;FFMETADATA1 <br>
title=bike\shed <br>
;this is a comment <br>
artist=FFmpeg troll team</i></p>

<p style="margin-top: 1em"><i>[CHAPTER] <br>
TIMEBASE=1/1000 <br>
START=0 <br>
#chapter ends at 0:01:00 <br>
END=60000 <br>
title=chapter [STREAM] <br>
title=multi line</i></p>

<p style="margin-top: 1em"><i>By using the ffmetadata muxer
and demuxer it is possible to extract metadata from an input
file to an ffmetadata file, and then transcode the file into
an output file with the <br>
edited ffmetadata file.</i></p>

<p style="margin-top: 1em"><i>Extracting an ffmetadata file
with ffmpeg goes as follows:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i INPUT -f ffmetadata
FFMETADATAFILE</i></p>

<p style="margin-top: 1em"><i>Reinserting edited metadata
information from the FFMETADATAFILE file can be done
as:</i></p>

<p style="margin-top: 1em"><i>ffmpeg -i INPUT -i
FFMETADATAFILE -map_metadata 1 -codec copy OUTPUT</i></p>

<p style="margin-top: 1em"><i>SEE ALSO <br>
ffmpeg(1), ffplay(1), ffprobe(1), ffserver(1),
libavformat(3)</i></p>

<p style="margin-top: 1em"><i>AUTHORS <br>
The FFmpeg developers.</i></p>

<p style="margin-top: 1em"><i>For details about the
authorship, see the Git history of the project
(git://source.ffmpeg.org/ffmpeg), e.g. by typing the command
git log in the FFmpeg source directory, or <br>
browsing the online repository at
&lt;http://source.ffmpeg.org&gt;.</i></p>

<p style="margin-top: 1em"><i>Maintainers for the specific
components are listed in the file MAINTAINERS in the source
code tree.</i></p>
 
<p style="margin-top: 1em"><i>FFMPEG-FORMATS(1)</i></p>
<hr>
</body>
</html>
