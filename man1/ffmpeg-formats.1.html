<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>FFMPEG-FORMATS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">FFMPEG-FORMATS(1)</td>
    <td class="head-vol"> </td>
    <td class="head-rtitle">FFMPEG-FORMATS(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
ffmpeg-formats - FFmpeg formats
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document describes the supported formats (muxers and demuxers) provided by
  the libavformat library.
<h1 class="Sh" title="Sh" id="FORMAT_OPTIONS"><a class="selflink" href="#FORMAT_OPTIONS">FORMAT
  OPTIONS</a></h1>
The libavformat library provides some generic global options, which can be set
  on all the muxers and demuxers. In addition each muxer or demuxer may support
  so-called private options, which are specific for that component.
<div class="Pp"></div>
Options may be set by specifying - <i>option</i> <i>value</i> in the FFmpeg
  tools, or by setting the value explicitly in the &quot;AVFormatContext&quot;
  options or using the <i>libavutil/opt.h</i> API for programmatic use.
<div class="Pp"></div>
The list of supported options follows:
<dl class="Bl-tag">
  <dt class="It-tag"><b>avioflags</b> <i>flags</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">Possible values:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>direct</b></dt>
  <dd class="It-tag">Reduce buffering.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>probesize</b> <i>integer</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Set probing size in bytes, i.e. the size of the data to
      analyze to get stream information. A higher value will enable detecting
      more information in case it is dispersed into the stream, but will
      increase latency. Must be an integer not lesser than 32. It is 5000000 by
      default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>packetsize</b> <i>integer</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set packet size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fflags</b> <i>flags</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">Set format flags.
    <div style="height: 1.00em;">&#x00A0;</div>
    Possible values:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>ignidx</b></dt>
  <dd class="It-tag">Ignore index.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fastseek</b></dt>
  <dd class="It-tag">Enable fast, but inaccurate seeks for some formats.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>genpts</b></dt>
  <dd class="It-tag">Generate PTS.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nofillin</b></dt>
  <dd class="It-tag">Do not fill in missing values that can be exactly
      calculated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>noparse</b></dt>
  <dd class="It-tag">Disable AVParsers, this needs &quot;+nofillin&quot;
    too.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>igndts</b></dt>
  <dd class="It-tag">Ignore DTS.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>discardcorrupt</b></dt>
  <dd class="It-tag">Discard corrupted frames.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sortdts</b></dt>
  <dd class="It-tag">Try to interleave output packets by DTS.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>keepside</b></dt>
  <dd class="It-tag">Do not merge side data.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>latm</b></dt>
  <dd class="It-tag">Enable RTP MP4A-LATM payload.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nobuffer</b></dt>
  <dd class="It-tag">Reduce the latency introduced by optional buffering</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bitexact</b></dt>
  <dd class="It-tag">Only write platform-, build- and time-independent data.
      This ensures that file and data checksums are reproducible and match
      between platforms. Its primary use is for regression testing.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>shortest</b></dt>
  <dd class="It-tag">Stop muxing at the end of the shortest stream. It may be
      needed to increase max_interleave_delta to avoid flushing the longer
      streams before EOF.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>seek2any</b> <i>integer</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Allow seeking to non-keyframes on demuxer level when
      supported if set to 1. Default is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>analyzeduration</b> <i>integer</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Specify how many microseconds are analyzed to probe the
      input. A higher value will enable detecting more accurate information, but
      will increase latency. It defaults to 5,000,000 microseconds = 5
    seconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cryptokey</b> <i>hexadecimal string</i>
    <b>(</b><i>input</i> <b>)</b></dt>
  <dd class="It-tag">Set decryption key.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>indexmem</b> <i>integer</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Set max memory used for timestamp index (per stream).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rtbufsize</b> <i>integer</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Set max memory used for buffering real-time frames.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fdebug</b> <i>flags</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">Print specific debug info.
    <div style="height: 1.00em;">&#x00A0;</div>
    Possible values:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>ts</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>max_delay</b> <i>integer</i>
    <b>(</b><i>input/output</i><b>)</b></dt>
  <dd class="It-tag">Set maximum muxing or demuxing delay in microseconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fpsprobesize</b> <i>integer</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Set number of frames used to probe fps.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>audio_preload</b> <i>integer</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set microseconds by which audio packets should be
      interleaved earlier.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>chunk_duration</b> <i>integer</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set microseconds for each chunk.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>chunk_size</b> <i>integer</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set size in bytes for each chunk.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>err_detect, f_err_detect</b> <i>flags</i>
    <b>(</b><i>input</i> <b>)</b></dt>
  <dd class="It-tag">Set error detection flags. &quot;f_err_detect&quot; is
      deprecated and should be used only via the <b>ffmpeg</b> tool.
    <div style="height: 1.00em;">&#x00A0;</div>
    Possible values:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>crccheck</b></dt>
  <dd class="It-tag">Verify embedded CRCs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bitstream</b></dt>
  <dd class="It-tag">Detect bitstream specification deviations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>buffer</b></dt>
  <dd class="It-tag">Detect improper bitstream length.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>explode</b></dt>
  <dd class="It-tag">Abort decoding on minor error detection.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>careful</b></dt>
  <dd class="It-tag">Consider things that violate the spec and have not been
      seen in the wild as errors.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>compliant</b></dt>
  <dd class="It-tag">Consider all spec non compliancies as errors.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>aggressive</b></dt>
  <dd class="It-tag">Consider things that a sane encoder should not do as an
      error.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>max_interleave_delta</b> <i>integer</i>
    <b>(</b><i>output</i> <b>)</b></dt>
  <dd class="It-tag">Set maximum buffering duration for interleaving. The
      duration is expressed in microseconds, and defaults to 1000000 (1 second).
    <div style="height: 1.00em;">&#x00A0;</div>
    To ensure all the streams are interleaved correctly, libavformat will wait
      until it has at least one packet for each stream before actually writing
      any packets to the output file. When some streams are &quot;sparse&quot;
      (i.e. there are large gaps between successive packets), this can result in
      excessive buffering.
    <div style="height: 1.00em;">&#x00A0;</div>
    This field specifies the maximum difference between the timestamps of the
      first and the last packet in the muxing queue, above which libavformat
      will output a packet regardless of whether it has queued a packet for all
      the streams.
    <div style="height: 1.00em;">&#x00A0;</div>
    If set to 0, libavformat will continue buffering packets until it has a
      packet for each stream, regardless of the maximum timestamp difference
      between the buffered packets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>use_wallclock_as_timestamps</b> <i>integer</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Use wallclock as timestamps if set to 1. Default is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>avoid_negative_ts</b> <i>integer</i>
    <b>(</b><i>output</i> <b>)</b></dt>
  <dd class="It-tag">Possible values:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>make_non_negative</b></dt>
  <dd class="It-tag">Shift timestamps to make them non-negative. Also note that
      this affects only leading negative timestamps, and not non-monotonic
      negative timestamps.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>make_zero</b></dt>
  <dd class="It-tag">Shift timestamps so that the first timestamp is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>auto (default)</b></dt>
  <dd class="It-tag">Enables shifting when required by the target format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>disabled</b></dt>
  <dd class="It-tag">Disables shifting of timestamp.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
When shifting is enabled, all output timestamps are shifted by the same amount.
  Audio, video, and subtitles desynching and relative timestamp differences are
  preserved compared to how they would have been without shifting.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>skip_initial_bytes</b> <i>integer</i>
    <b>(</b><i>input</i> <b>)</b></dt>
  <dd class="It-tag">Set number of bytes to skip before reading header and
      frames if set to 1. Default is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>correct_ts_overflow</b> <i>integer</i>
    <b>(</b><i>input</i> <b>)</b></dt>
  <dd class="It-tag">Correct single timestamp overflows if set to 1. Default is
      1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>flush_packets</b> <i>integer</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Flush the underlying I/O stream after each packet. Default
      1 enables it, and has the effect of reducing the latency; 0 disables it
      and may slightly increase performance in some cases.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>output_ts_offset</b> <i>offset</i>
    <b>(</b><i>output</i><b>)</b></dt>
  <dd class="It-tag">Set the output time offset.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>offset</i> must be a time duration specification, see <b>the Time
      duration section in the </b> <b><i>ffmpeg-utils</i></b><b>(1) manual</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The offset is added by the muxer to the output timestamps.
    <div style="height: 1.00em;">&#x00A0;</div>
    Specifying a positive offset means that the corresponding streams are
      delayed bt the time duration specified in <i>offset</i>. Default value is
      0 (meaning that no offset is applied).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>format_whitelist</b> <i>list</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">&quot;,&quot; separated list of allowed demuxers. By
      default all are allowed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dump_separator</b> <i>string</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Separator used to separate the fields printed on the
      command line about the Stream parameters. For example to separate the
      fields with newlines and indention:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffprobe -dump_separator &quot;
                                  &quot;  -i ~/videos/matrixbench_mpeg2.mpg
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>max_streams</b> <i>integer</i>
    <b>(</b><i>input</i><b>)</b></dt>
  <dd class="It-tag">Specifies the maximum number of streams. This can be used
      to reject files that would require too many resources due to a large
      number of streams.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Format_stream_specifiers"><a class="selflink" href="#Format_stream_specifiers">Format
  stream specifiers</a></h2>
Format stream specifiers allow selection of one or more streams that match
  specific properties.
<div class="Pp"></div>
Possible forms of stream specifiers are:
<dl class="Bl-tag">
  <dt class="It-tag"><i>stream_index</i></dt>
  <dd class="It-tag">Matches the stream with this index.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>stream_type</i><b>[:</b><i>stream_index</i><b>]</b></dt>
  <dd class="It-tag"><i>stream_type</i> is one of following: 'v' for video, 'a'
      for audio, 's' for subtitle, 'd' for data, and 't' for attachments. If
      <i>stream_index</i> is given, then it matches the stream number
      <i>stream_index</i> of this type. Otherwise, it matches all streams of
      this type.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>p:</b><i>program_id</i><b>[:</b><i>stream_index</i><b>]</b></dt>
  <dd class="It-tag">If <i>stream_index</i> is given, then it matches the stream
      with number <i>stream_index</i> in the program with the id
      <i>program_id</i>. Otherwise, it matches all streams in the program.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>#</b><i>stream_id</i></dt>
  <dd class="It-tag">Matches the stream by a format-specific ID.</dd>
</dl>
<div class="Pp"></div>
The exact semantics of stream specifiers is defined by the
  &quot;avformat_match_stream_specifier()&quot; function declared in the
  <i>libavformat/avformat.h</i> header.
<h1 class="Sh" title="Sh" id="DEMUXERS"><a class="selflink" href="#DEMUXERS">DEMUXERS</a></h1>
Demuxers are configured elements in FFmpeg that can read the multimedia streams
  from a particular type of file.
<div class="Pp"></div>
When you configure your FFmpeg build, all the supported demuxers are enabled by
  default. You can list all available ones using the configure option
  &quot;--list-demuxers&quot;.
<div class="Pp"></div>
You can disable all the demuxers using the configure option
  &quot;--disable-demuxers&quot;, and selectively enable a single demuxer with
  the option &quot;--enable-demuxer= <i>DEMUXER</i>&quot;, or disable it with
  the option &quot;--disable-demuxer= <i>DEMUXER</i>&quot;.
<div class="Pp"></div>
The option &quot;-formats&quot; of the ff* tools will display the list of
  enabled demuxers.
<div class="Pp"></div>
The description of some of the currently available demuxers follows.
<h2 class="Ss" title="Ss" id="aa"><a class="selflink" href="#aa">aa</a></h2>
Audible Format 2, 3, and 4 demuxer.
<div class="Pp"></div>
This demuxer is used to demux Audible Format 2, 3, and 4 (.aa) files.
<h2 class="Ss" title="Ss" id="applehttp"><a class="selflink" href="#applehttp">applehttp</a></h2>
Apple HTTP Live Streaming demuxer.
<div class="Pp"></div>
This demuxer presents all AVStreams from all variant streams. The id field is
  set to the bitrate variant index number. By setting the discard flags on
  AVStreams (by pressing 'a' or 'v' in ffplay), the caller can decide which
  variant streams to actually receive. The total bitrate of the variant that the
  stream belongs to is available in a metadata key named
  &quot;variant_bitrate&quot;.
<h2 class="Ss" title="Ss" id="apng"><a class="selflink" href="#apng">apng</a></h2>
Animated Portable Network Graphics demuxer.
<div class="Pp"></div>
This demuxer is used to demux APNG files. All headers, but the PNG signature, up
  to (but not including) the first fcTL chunk are transmitted as extradata.
  Frames are then split as being all the chunks between two fcTL ones, or
  between the last fcTL and IEND chunks.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ignore_loop</b> <i>bool</i></dt>
  <dd class="It-tag">Ignore the loop variable in the file if set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-max_fps</b> <i>int</i></dt>
  <dd class="It-tag">Maximum framerate in frames per second (0 for no
    limit).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-default_fps</b> <i>int</i></dt>
  <dd class="It-tag">Default framerate in frames per second when none is
      specified in the file (0 meaning as fast as possible).</dd>
</dl>
<h2 class="Ss" title="Ss" id="asf"><a class="selflink" href="#asf">asf</a></h2>
Advanced Systems Format demuxer.
<div class="Pp"></div>
This demuxer is used to demux ASF files and MMS network streams.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-no_resync_search</b> <i>bool</i></dt>
  <dd class="It-tag">Do not try to resynchronize by looking for a certain
      optional start code.</dd>
</dl>
<h2 class="Ss" title="Ss" id="concat"><a class="selflink" href="#concat">concat</a></h2>
Virtual concatenation script demuxer.
<div class="Pp"></div>
This demuxer reads a list of files and other directives from a text file and
  demuxes them one after the other, as if all their packets had been muxed
  together.
<div class="Pp"></div>
The timestamps in the files are adjusted so that the first file starts at 0 and
  each next file starts where the previous one finishes. Note that it is done
  globally and may cause gaps if all streams do not have exactly the same
  length.
<div class="Pp"></div>
All files must have the same streams (same codecs, same time base, etc.).
<div class="Pp"></div>
The duration of each file is used to adjust the timestamps of the next file: if
  the duration is incorrect (because it was computed using the bit-rate or
  because the file is truncated, for example), it can cause artifacts. The
  &quot;duration&quot; directive can be used to override the duration stored in
  each file.
<div class="Pp"></div>
<i>Syntax</i>
<div class="Pp"></div>
The script is a text file in extended-ASCII, with one directive per line. Empty
  lines, leading spaces and lines starting with '#' are ignored. The following
  directive is recognized:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;file
    </b><b>path</b><b>&quot;</b><b></b></dt>
  <dd class="It-tag">Path to a file to read; special characters and spaces must
      be escaped with backslash or single quotes.
    <div style="height: 1.00em;">&#x00A0;</div>
    All subsequent file-related directives apply to that file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;ffconcat version 1.0&quot;</b><b></b></dt>
  <dd class="It-tag">Identify the script type and version. It also sets the
      <b>safe</b> option to 1 if it was -1.
    <div style="height: 1.00em;">&#x00A0;</div>
    To make FFmpeg recognize the format automatically, this directive must
      appear exactly as is (no extra space or byte-order-mark) on the very first
      line of the script.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;duration
    </b><b>dur</b><b>&quot;</b><b></b></dt>
  <dd class="It-tag">Duration of the file. This information can be specified
      from the file; specifying it here may be more efficient or help if the
      information from the file is not available or accurate.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the duration is set for all files, then it is possible to seek in the
      whole concatenated video.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;inpoint
    </b><b>timestamp</b><b>&quot;</b><b></b></dt>
  <dd class="It-tag">In point of the file. When the demuxer opens the file it
      instantly seeks to the specified timestamp. Seeking is done so that all
      streams can be presented successfully at In point.
    <div style="height: 1.00em;">&#x00A0;</div>
    This directive works best with intra frame codecs, because for non-intra
      frame ones you will usually get extra packets before the actual In point
      and the decoded content will most likely contain frames before In point
      too.
    <div style="height: 1.00em;">&#x00A0;</div>
    For each file, packets before the file In point will have timestamps less
      than the calculated start timestamp of the file (negative in case of the
      first file), and the duration of the files (if not specified by the
      &quot;duration&quot; directive) will be reduced based on their specified
      In point.
    <div style="height: 1.00em;">&#x00A0;</div>
    Because of potential packets before the specified In point, packet
      timestamps may overlap between two concatenated files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;outpoint
    </b><b>timestamp</b><b>&quot;</b><b></b></dt>
  <dd class="It-tag">Out point of the file. When the demuxer reaches the
      specified decoding timestamp in any of the streams, it handles it as an
      end of file condition and skips the current and all the remaining packets
      from all streams.
    <div style="height: 1.00em;">&#x00A0;</div>
    Out point is exclusive, which means that the demuxer will not output packets
      with a decoding timestamp greater or equal to Out point.
    <div style="height: 1.00em;">&#x00A0;</div>
    This directive works best with intra frame codecs and formats where all
      streams are tightly interleaved. For non-intra frame codecs you will
      usually get additional packets with presentation timestamp after Out point
      therefore the decoded content will most likely contain frames after Out
      point too. If your streams are not tightly interleaved you may not get all
      the packets from all streams before Out point and you may only will be
      able to decode the earliest stream until Out point.
    <div style="height: 1.00em;">&#x00A0;</div>
    The duration of the files (if not specified by the &quot;duration&quot;
      directive) will be reduced based on their specified Out point.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;file_packet_metadata
    </b><b>key=value</b><b>&quot;</b><b></b></dt>
  <dd class="It-tag">Metadata of the packets of the file. The specified metadata
      will be set for each file packet. You can specify this directive multiple
      times to add multiple metadata entries.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;stream&quot;</b><b></b></dt>
  <dd class="It-tag">Introduce a stream in the virtual file. All subsequent
      stream-related directives apply to the last introduced stream. Some
      streams properties must be set in order to allow identifying the matching
      streams in the subfiles. If no streams are defined in the script, the
      streams from the first file are copied.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b><b>&quot;exact_stream_id
    </b><b>id</b><b>&quot;</b><b></b></dt>
  <dd class="It-tag">Set the id of the stream. If this directive is given, the
      string with the corresponding id in the subfiles will be used. This is
      especially useful for MPEG-PS (VOB) files, where the order of the streams
      is not reliable.</dd>
</dl>
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
This demuxer accepts the following option:
<dl class="Bl-tag">
  <dt class="It-tag"><b>safe</b></dt>
  <dd class="It-tag">If set to 1, reject unsafe file paths. A file path is
      considered safe if it does not contain a protocol specification and is
      relative and all components only contain characters from the portable
      character set (letters, digits, period, underscore and hyphen) and have no
      period at the beginning of a component.
    <div style="height: 1.00em;">&#x00A0;</div>
    If set to 0, any file name is accepted.
    <div style="height: 1.00em;">&#x00A0;</div>
    The default is 1.
    <div style="height: 1.00em;">&#x00A0;</div>
    -1 is equivalent to 1 if the format was automatically probed and 0
      otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>auto_convert</b></dt>
  <dd class="It-tag">If set to 1, try to perform automatic conversions on packet
      data to make the streams concatenable. The default is 1.
    <div style="height: 1.00em;">&#x00A0;</div>
    Currently, the only conversion is adding the h264_mp4toannexb bitstream
      filter to H.264 streams in MP4 format. This is necessary in particular if
      there are resolution changes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_time_metadata</b></dt>
  <dd class="It-tag">If set to 1, every packet will contain the
      <i>lavf.concat.start_time</i> and the <i>lavf.concat.duration</i> packet
      metadata values which are the start_time and the duration of the
      respective file segments in the concatenated output expressed in
      microseconds. The duration metadata is only set if it is known based on
      the concat file. The default is 0.</dd>
</dl>
<div class="Pp"></div>
<i>Examples</i>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Use absolute filenames and include some comments:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # my first filename
        file /mnt/share/file-1.wav
        # my second filename including whitespace
        file '/mnt/share/file 2.wav'
        # my third filename including whitespace plus single quote
        file '/mnt/share/file 3'\''.wav'
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Allow for input format auto-probing, use safe filenames and
      set the duration of the first file:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffconcat version 1.0
        
        file file-1.wav
        duration 20.0
        
        file subdir/file-2.wav
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="flv"><a class="selflink" href="#flv">flv</a></h2>
Adobe Flash Video Format demuxer.
<div class="Pp"></div>
This demuxer is used to demux FLV files and RTMP network streams.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-flv_metadata</b> <i>bool</i></dt>
  <dd class="It-tag">Allocate the streams according to the onMetaData array
      content.</dd>
</dl>
<h2 class="Ss" title="Ss" id="gif"><a class="selflink" href="#gif">gif</a></h2>
Animated GIF demuxer.
<div class="Pp"></div>
It accepts the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>min_delay</b></dt>
  <dd class="It-tag">Set the minimum valid delay between frames in hundredths of
      seconds. Range is 0 to 6000. Default value is 2.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>max_gif_delay</b></dt>
  <dd class="It-tag">Set the maximum valid delay between frames in hundredth of
      seconds. Range is 0 to 65535. Default value is 65535 (nearly eleven
      minutes), the maximum value allowed by the specification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>default_delay</b></dt>
  <dd class="It-tag">Set the default delay between frames in hundredths of
      seconds. Range is 0 to 6000. Default value is 10.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ignore_loop</b></dt>
  <dd class="It-tag">GIF files can contain information to loop a certain number
      of times (or infinitely). If <b>ignore_loop</b> is set to 1, then the loop
      setting from the input will be ignored and looping will not occur. If set
      to 0, then looping will occur and will cycle the number of times according
      to the GIF. Default value is 1.</dd>
</dl>
<div class="Pp"></div>
For example, with the overlay filter, place an infinitely looping GIF over
  another video:
<div class="Pp"></div>
<pre>
        ffmpeg -i input.mp4 -ignore_loop 0 -i input.gif -filter_complex overlay=shortest=1 out.mkv
</pre>
<div class="Pp"></div>
Note that in the above example the shortest option for overlay filter is used to
  end the output video at the length of the shortest input file, which in this
  case is <i>input.mp4</i> as the GIF in this example loops infinitely.
<h2 class="Ss" title="Ss" id="image2"><a class="selflink" href="#image2">image2</a></h2>
Image file demuxer.
<div class="Pp"></div>
This demuxer reads from a list of image files specified by a pattern. The syntax
  and meaning of the pattern is specified by the option <i>pattern_type</i>.
<div class="Pp"></div>
The pattern may contain a suffix which is used to automatically determine the
  format of the images contained in the files.
<div class="Pp"></div>
The size, the pixel format, and the format of each image must be the same for
  all the files in the sequence.
<div class="Pp"></div>
This demuxer accepts the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>framerate</b></dt>
  <dd class="It-tag">Set the frame rate for the video stream. It defaults to
    25.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>loop</b></dt>
  <dd class="It-tag">If set to 1, loop over the input. Default value is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pattern_type</b></dt>
  <dd class="It-tag">Select the pattern type used to interpret the provided
      filename.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>pattern_type</i> accepts one of the following values.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>none</b></dt>
  <dd class="It-tag">Disable pattern matching, therefore the video will only
      contain the specified image. You should use this option if you do not want
      to create sequences from multiple images and your filenames may contain
      special pattern characters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sequence</b></dt>
  <dd class="It-tag">Select a sequence pattern type, used to specify a sequence
      of files indexed by sequential numbers.
    <div style="height: 1.00em;">&#x00A0;</div>
    A sequence pattern may contain the string &quot;%d&quot; or &quot;%0
      <i>N</i>d&quot;, which specifies the position of the characters
      representing a sequential number in each filename matched by the pattern.
      If the form &quot;%d0 <i>N</i>d&quot; is used, the string representing the
      number in each filename is 0-padded and <i>N</i> is the total number of
      0-padded digits representing the number. The literal character '%' can be
      specified in the pattern with the string &quot;%%&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the sequence pattern contains &quot;%d&quot; or &quot;%0 <i>N</i>d&quot;,
      the first filename of the file list specified by the pattern must contain
      a number inclusively contained between <i>start_number</i> and
      <i>start_number</i>+ <i>start_number_range</i>-1, and all the following
      numbers must be sequential.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example the pattern &quot;img-%03d.bmp&quot; will match a sequence of
      filenames of the form <i>img-001.bmp</i>, <i>img-002.bmp</i>, ...,
      <i>img-010.bmp</i>, etc.; the pattern &quot;i%%m%%g-%d.jpg&quot; will
      match a sequence of filenames of the form <i>i%m%g-1.jpg</i>,
      <i>i%m%g-2.jpg</i>, ..., <i>i%m%g-10.jpg</i>, etc.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the pattern must not necessarily contain &quot;%d&quot; or
      &quot;%0 <i>N</i>d&quot;, for example to convert a single image file
      <i>img.jpeg</i> you can employ the command:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i img.jpeg img.png
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>glob</b></dt>
  <dd class="It-tag">Select a glob wildcard pattern type.
    <div style="height: 1.00em;">&#x00A0;</div>
    The pattern is interpreted like a &quot;glob()&quot; pattern. This is only
      selectable if libavformat was compiled with globbing support.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>glob_sequence</b> <i>(deprecated, will be
    removed)</i></dt>
  <dd class="It-tag">Select a mixed glob wildcard/sequence pattern.
    <div style="height: 1.00em;">&#x00A0;</div>
    If your version of libavformat was compiled with globbing support, and the
      provided pattern contains at least one glob meta character among
      &quot;%*?[]{}&quot; that is preceded by an unescaped &quot;%&quot;, the
      pattern is interpreted like a &quot;glob()&quot; pattern, otherwise it is
      interpreted like a sequence pattern.
    <div style="height: 1.00em;">&#x00A0;</div>
    All glob special characters &quot;%*?[]{}&quot; must be prefixed with
      &quot;%&quot;. To escape a literal &quot;%&quot; you shall use
      &quot;%%&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example the pattern &quot;foo-%*.jpeg&quot; will match all the filenames
      prefixed by &quot;foo-&quot; and terminating with &quot;.jpeg&quot;, and
      &quot;foo-%?%?%?.jpeg&quot; will match all the filenames prefixed with
      &quot;foo-&quot;, followed by a sequence of three characters, and
      terminating with &quot;.jpeg&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    This pattern type is deprecated in favor of <i>glob</i> and
    <i>sequence</i>.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Default value is <i>glob_sequence</i>.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pixel_format</b></dt>
  <dd class="It-tag">Set the pixel format of the images to read. If not
      specified the pixel format is guessed from the first image file in the
      sequence.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>start_number</b></dt>
  <dd class="It-tag">Set the index of the file matched by the image file pattern
      to start to read from. Default value is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>start_number_range</b></dt>
  <dd class="It-tag">Set the index interval range to check when looking for the
      first image file in the sequence, starting from <i>start_number</i>.
      Default value is 5.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ts_from_file</b></dt>
  <dd class="It-tag">If set to 1, will set frame timestamp to modification time
      of image file. Note that monotonity of timestamps is not provided: images
      go in the same order as without this option. Default value is 0. If set to
      2, will set frame timestamp to the modification time of the image file in
      nanosecond precision.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>video_size</b></dt>
  <dd class="It-tag">Set the video size of the images to read. If not specified
      the video size is guessed from the first image file in the sequence.</dd>
</dl>
<div class="Pp"></div>
<i>Examples</i>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Use <b>ffmpeg</b> for creating a video from the images in
      the file sequence <i>img-001.jpeg</i>, <i>img-002.jpeg</i>, ..., assuming
      an input frame rate of 10 frames per second:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -framerate 10 -i 'img-%03d.jpeg' out.mkv
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">As above, but start by reading from a file with index 100
      in the sequence:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -framerate 10 -start_number 100 -i 'img-%03d.jpeg' out.mkv
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Read images matching the &quot;*.png&quot; glob pattern ,
      that is all the files terminating with the &quot;.png&quot; suffix:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -framerate 10 -pattern_type glob -i &quot;*.png&quot; out.mkv
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="libgme"><a class="selflink" href="#libgme">libgme</a></h2>
The Game Music Emu library is a collection of video game music file emulators.
<div class="Pp"></div>
See &lt; <b>http://code.google.com/p/game-music-emu/</b>&gt; for more
  information.
<div class="Pp"></div>
Some files have multiple tracks. The demuxer will pick the first track by
  default. The <b>track_index</b> option can be used to select a different
  track. Track indexes start at 0. The demuxer exports the number of tracks as
  <i>tracks</i> meta data entry.
<div class="Pp"></div>
For very large files, the <b>max_size</b> option may have to be adjusted.
<h2 class="Ss" title="Ss" id="libopenmpt"><a class="selflink" href="#libopenmpt">libopenmpt</a></h2>
libopenmpt based module demuxer
<div class="Pp"></div>
See &lt; <b>https://lib.openmpt.org/libopenmpt/</b>&gt; for more information.
<div class="Pp"></div>
Some files have multiple subsongs (tracks) this can be set with the
  <b>subsong</b> option.
<div class="Pp"></div>
It accepts the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>subsong</b></dt>
  <dd class="It-tag">Set the subsong index. This can be either 'all', 'auto', or
      the index of the subsong. Subsong indexes start at 0. The default is
      'auto'.
    <div style="height: 1.00em;">&#x00A0;</div>
    The default value is to let libopenmpt choose.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>layout</b></dt>
  <dd class="It-tag">Set the channel layout. Valid values are 1, 2, and 4
      channel layouts. The default value is STEREO.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sample_rate</b></dt>
  <dd class="It-tag">Set the sample rate for libopenmpt to output. Range is from
      1000 to INT_MAX. The value default is 48000.</dd>
</dl>
<h2 class="Ss" title="Ss" id="mov/mp4/3gp/QuickTime"><a class="selflink" href="#mov/mp4/3gp/QuickTime">mov/mp4/3gp/QuickTime</a></h2>
QuickTime / MP4 demuxer.
<div class="Pp"></div>
This demuxer accepts the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>enable_drefs</b></dt>
  <dd class="It-tag">Enable loading of external tracks, disabled by default.
      Enabling this can theoretically leak information in some use cases.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>use_absolute_path</b></dt>
  <dd class="It-tag">Allows loading of external tracks via absolute paths,
      disabled by default. Enabling this poses a security risk. It should only
      be enabled if the source is known to be non malicious.</dd>
</dl>
<h2 class="Ss" title="Ss" id="mpegts"><a class="selflink" href="#mpegts">mpegts</a></h2>
MPEG-2 transport stream demuxer.
<div class="Pp"></div>
This demuxer accepts the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>resync_size</b></dt>
  <dd class="It-tag">Set size limit for looking up a new synchronization.
      Default value is 65536.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fix_teletext_pts</b></dt>
  <dd class="It-tag">Override teletext packet PTS and DTS values with the
      timestamps calculated from the PCR of the first program which the teletext
      stream is part of and is not discarded. Default value is 1, set this
      option to 0 if you want your teletext packet PTS and DTS values
    untouched.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ts_packetsize</b></dt>
  <dd class="It-tag">Output option carrying the raw packet size in bytes. Show
      the detected raw packet size, cannot be set by the user.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>scan_all_pmts</b></dt>
  <dd class="It-tag">Scan and combine all PMTs. The value is an integer with
      value from -1 to 1 (-1 means automatic setting, 1 means enabled, 0 means
      disabled). Default value is -1.</dd>
</dl>
<h2 class="Ss" title="Ss" id="mpjpeg"><a class="selflink" href="#mpjpeg">mpjpeg</a></h2>
MJPEG encapsulated in multi-part MIME demuxer.
<div class="Pp"></div>
This demuxer allows reading of MJPEG, where each frame is represented as a part
  of multipart/x-mixed-replace stream.
<dl class="Bl-tag">
  <dt class="It-tag"><b>strict_mime_boundary</b></dt>
  <dd class="It-tag">Default implementation applies a relaxed standard to
      multi-part MIME boundary detection, to prevent regression with numerous
      existing endpoints not generating a proper MIME MJPEG stream. Turning this
      option on by setting it to 1 will result in a stricter check of the
      boundary value.</dd>
</dl>
<h2 class="Ss" title="Ss" id="rawvideo"><a class="selflink" href="#rawvideo">rawvideo</a></h2>
Raw video demuxer.
<div class="Pp"></div>
This demuxer allows one to read raw video data. Since there is no header
  specifying the assumed video parameters, the user must specify them in order
  to be able to decode the data correctly.
<div class="Pp"></div>
This demuxer accepts the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>framerate</b></dt>
  <dd class="It-tag">Set input video frame rate. Default value is 25.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pixel_format</b></dt>
  <dd class="It-tag">Set the input video pixel format. Default value is
      &quot;yuv420p&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>video_size</b></dt>
  <dd class="It-tag">Set the input video size. This value must be specified
      explicitly.</dd>
</dl>
<div class="Pp"></div>
For example to read a rawvideo file <i>input.raw</i> with <b>ffplay</b>,
  assuming a pixel format of &quot;rgb24&quot;, a video size of
  &quot;320x240&quot;, and a frame rate of 10 images per second, use the
  command:
<div class="Pp"></div>
<pre>
        ffplay -f rawvideo -pixel_format rgb24 -video_size 320x240 -framerate 10 input.raw
</pre>
<h2 class="Ss" title="Ss" id="sbg"><a class="selflink" href="#sbg">sbg</a></h2>
SBaGen script demuxer.
<div class="Pp"></div>
This demuxer reads the script language used by SBaGen &lt;
  <b>http://uazu.net/sbagen/</b>&gt; to generate binaural beats sessions. A SBG
  script looks like that:
<div class="Pp"></div>
<pre>
        -SE
        a: 300-2.5/3 440+4.5/0
        b: 300-2.5/0 440+4.5/3
        off: -
        NOW      == a
        +0:07:00 == b
        +0:14:00 == a
        +0:21:00 == b
        +0:30:00    off
</pre>
<div class="Pp"></div>
A SBG script can mix absolute and relative timestamps. If the script uses either
  only absolute timestamps (including the script start time) or only relative
  ones, then its layout is fixed, and the conversion is straightforward. On the
  other hand, if the script mixes both kind of timestamps, then the <i>NOW</i>
  reference for relative timestamps will be taken from the current time of day
  at the time the script is read, and the script layout will be frozen according
  to that reference. That means that if the script is directly played, the
  actual times will match the absolute timestamps up to the sound controller's
  clock accuracy, but if the user somehow pauses the playback or seeks, all
  times will be shifted accordingly.
<h2 class="Ss" title="Ss" id="tedcaptions"><a class="selflink" href="#tedcaptions">tedcaptions</a></h2>
JSON captions used for &lt; <b>http://www.ted.com/</b>&gt;.
<div class="Pp"></div>
TED does not provide links to the captions, but they can be guessed from the
  page. The file <i>tools/bookmarklets.html</i> from the FFmpeg source tree
  contains a bookmarklet to expose them.
<div class="Pp"></div>
This demuxer accepts the following option:
<dl class="Bl-tag">
  <dt class="It-tag"><b>start_time</b></dt>
  <dd class="It-tag">Set the start time of the TED talk, in milliseconds. The
      default is 15000 (15s). It is used to sync the captions with the
      downloadable videos, because they include a 15s intro.</dd>
</dl>
<div class="Pp"></div>
Example: convert the captions to a format most players understand:
<div class="Pp"></div>
<pre>
        ffmpeg -i http://www.ted.com/talks/subtitles/id/1/lang/en talk1-en.srt
</pre>
<h1 class="Sh" title="Sh" id="MUXERS"><a class="selflink" href="#MUXERS">MUXERS</a></h1>
Muxers are configured elements in FFmpeg which allow writing multimedia streams
  to a particular type of file.
<div class="Pp"></div>
When you configure your FFmpeg build, all the supported muxers are enabled by
  default. You can list all available muxers using the configure option
  &quot;--list-muxers&quot;.
<div class="Pp"></div>
You can disable all the muxers with the configure option
  &quot;--disable-muxers&quot; and selectively enable / disable single muxers
  with the options &quot;--enable-muxer= <i>MUXER</i>&quot; /
  &quot;--disable-muxer= <i>MUXER</i>&quot;.
<div class="Pp"></div>
The option &quot;-formats&quot; of the ff* tools will display the list of
  enabled muxers.
<div class="Pp"></div>
A description of some of the currently available muxers follows.
<h2 class="Ss" title="Ss" id="aiff"><a class="selflink" href="#aiff">aiff</a></h2>
Audio Interchange File Format muxer.
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
It accepts the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>write_id3v2</b></dt>
  <dd class="It-tag">Enable ID3v2 tags writing when set to 1. Default is 0
      (disabled).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>id3v2_version</b></dt>
  <dd class="It-tag">Select ID3v2 version to write. Currently only version 3 and
      4 (aka. ID3v2.3 and ID3v2.4) are supported. The default is version 4.</dd>
</dl>
<h2 class="Ss" title="Ss" id="asf"><a class="selflink" href="#asf">asf</a></h2>
Advanced Systems Format muxer.
<div class="Pp"></div>
Note that Windows Media Audio (wma) and Windows Media Video (wmv) use this muxer
  too.
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
It accepts the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>packet_size</b></dt>
  <dd class="It-tag">Set the muxer packet size. By tuning this setting you may
      reduce data fragmentation or muxer overhead depending on your source.
      Default value is 3200, minimum is 100, maximum is 64k.</dd>
</dl>
<h2 class="Ss" title="Ss" id="chromaprint"><a class="selflink" href="#chromaprint">chromaprint</a></h2>
Chromaprint fingerprinter
<div class="Pp"></div>
This muxer feeds audio data to the Chromaprint library, which generates a
  fingerprint for the provided audio data. It takes a single signed
  native-endian 16-bit raw audio stream.
<div class="Pp"></div>
<i>Options</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>silence_threshold</b></dt>
  <dd class="It-tag">Threshold for detecting silence, ranges from 0 to 32767. -1
      for default (required for use with the AcoustID service).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>algorithm</b></dt>
  <dd class="It-tag">Algorithm index to fingerprint with.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fp_format</b></dt>
  <dd class="It-tag">Format to output the fingerprint as. Accepts the following
      options:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>raw</b></dt>
  <dd class="It-tag">Binary raw fingerprint</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>compressed</b></dt>
  <dd class="It-tag">Binary compressed fingerprint</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>base64</b></dt>
  <dd class="It-tag">Base64 compressed fingerprint</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<h2 class="Ss" title="Ss" id="crc"><a class="selflink" href="#crc">crc</a></h2>
CRC (Cyclic Redundancy Check) testing format.
<div class="Pp"></div>
This muxer computes and prints the Adler-32 CRC of all the input audio and video
  frames. By default audio frames are converted to signed 16-bit raw audio and
  video frames to raw video before computing the CRC.
<div class="Pp"></div>
The output of the muxer consists of a single line of the form: CRC=0x
  <i>CRC</i>, where <i>CRC</i> is a hexadecimal number 0-padded to 8 digits
  containing the CRC for all the decoded input frames.
<div class="Pp"></div>
See also the <b>framecrc</b> muxer.
<div class="Pp"></div>
<i>Examples</i>
<div class="Pp"></div>
For example to compute the CRC of the input, and store it in the file
  <i>out.crc</i>:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f crc out.crc
</pre>
<div class="Pp"></div>
You can print the CRC to stdout with the command:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f crc -
</pre>
<div class="Pp"></div>
You can select the output format of each frame with <b>ffmpeg</b> by specifying
  the audio and video codec and format. For example to compute the CRC of the
  input audio converted to PCM unsigned 8-bit and the input video converted to
  MPEG-2 video, use the command:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -c:a pcm_u8 -c:v mpeg2video -f crc -
</pre>
<h2 class="Ss" title="Ss" id="flv"><a class="selflink" href="#flv">flv</a></h2>
Adobe Flash Video Format muxer.
<div class="Pp"></div>
This muxer accepts the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>flvflags</b> <i>flags</i></dt>
  <dd class="It-tag">Possible values:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>aac_seq_header_detect</b></dt>
  <dd class="It-tag">Place AAC sequence header based on audio stream data.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>no_sequence_end</b></dt>
  <dd class="It-tag">Disable sequence end tag.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<h2 class="Ss" title="Ss" id="framecrc"><a class="selflink" href="#framecrc">framecrc</a></h2>
Per-packet CRC (Cyclic Redundancy Check) testing format.
<div class="Pp"></div>
This muxer computes and prints the Adler-32 CRC for each audio and video packet.
  By default audio frames are converted to signed 16-bit raw audio and video
  frames to raw video before computing the CRC.
<div class="Pp"></div>
The output of the muxer consists of a line for each audio and video packet of
  the form:
<div class="Pp"></div>
<pre>
        &lt;stream_index&gt;, &lt;packet_dts&gt;, &lt;packet_pts&gt;, &lt;packet_duration&gt;, &lt;packet_size&gt;, 0x&lt;CRC&gt;
</pre>
<div class="Pp"></div>
<i>CRC</i> is a hexadecimal number 0-padded to 8 digits containing the CRC of
  the packet.
<div class="Pp"></div>
<i>Examples</i>
<div class="Pp"></div>
For example to compute the CRC of the audio and video frames in <i>INPUT</i>,
  converted to raw audio and video packets, and store it in the file
  <i>out.crc</i>:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f framecrc out.crc
</pre>
<div class="Pp"></div>
To print the information to stdout, use the command:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f framecrc -
</pre>
<div class="Pp"></div>
With <b>ffmpeg</b>, you can select the output format to which the audio and
  video frames are encoded before computing the CRC for each packet by
  specifying the audio and video codec. For example, to compute the CRC of each
  decoded input audio frame converted to PCM unsigned 8-bit and of each decoded
  input video frame converted to MPEG-2 video, use the command:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -c:a pcm_u8 -c:v mpeg2video -f framecrc -
</pre>
<div class="Pp"></div>
See also the <b>crc</b> muxer.
<h2 class="Ss" title="Ss" id="framehash"><a class="selflink" href="#framehash">framehash</a></h2>
Per-packet hash testing format.
<div class="Pp"></div>
This muxer computes and prints a cryptographic hash for each audio and video
  packet. This can be used for packet-by-packet equality checks without having
  to individually do a binary comparison on each.
<div class="Pp"></div>
By default audio frames are converted to signed 16-bit raw audio and video
  frames to raw video before computing the hash, but the output of explicit
  conversions to other codecs can also be used. It uses the SHA-256
  cryptographic hash function by default, but supports several other algorithms.
<div class="Pp"></div>
The output of the muxer consists of a line for each audio and video packet of
  the form:
<div class="Pp"></div>
<pre>
        &lt;stream_index&gt;, &lt;packet_dts&gt;, &lt;packet_pts&gt;, &lt;packet_duration&gt;, &lt;packet_size&gt;, &lt;hash&gt;
</pre>
<div class="Pp"></div>
<i>hash</i> is a hexadecimal number representing the computed hash for the
  packet.
<dl class="Bl-tag">
  <dt class="It-tag"><b>hash</b> <i>algorithm</i></dt>
  <dd class="It-tag">Use the cryptographic hash function specified by the string
      <i>algorithm</i>. Supported values include &quot;MD5&quot;,
      &quot;murmur3&quot;, &quot;RIPEMD128&quot;, &quot;RIPEMD160&quot;,
      &quot;RIPEMD256&quot;, &quot;RIPEMD320&quot;, &quot;SHA160&quot;,
      &quot;SHA224&quot;, &quot;SHA256&quot; (default), &quot;SHA512/224&quot;,
      &quot;SHA512/256&quot;, &quot;SHA384&quot;, &quot;SHA512&quot;,
      &quot;CRC32&quot; and &quot;adler32&quot;.</dd>
</dl>
<div class="Pp"></div>
<i>Examples</i>
<div class="Pp"></div>
To compute the SHA-256 hash of the audio and video frames in <i>INPUT</i>,
  converted to raw audio and video packets, and store it in the file
  <i>out.sha256</i>:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f framehash out.sha256
</pre>
<div class="Pp"></div>
To print the information to stdout, using the MD5 hash function, use the
  command:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f framehash -hash md5 -
</pre>
<div class="Pp"></div>
See also the <b>hash</b> muxer.
<h2 class="Ss" title="Ss" id="framemd5"><a class="selflink" href="#framemd5">framemd5</a></h2>
Per-packet MD5 testing format.
<div class="Pp"></div>
This is a variant of the <b>framehash</b> muxer. Unlike that muxer, it defaults
  to using the MD5 hash function.
<div class="Pp"></div>
<i>Examples</i>
<div class="Pp"></div>
To compute the MD5 hash of the audio and video frames in <i>INPUT</i>, converted
  to raw audio and video packets, and store it in the file <i>out.md5</i>:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f framemd5 out.md5
</pre>
<div class="Pp"></div>
To print the information to stdout, use the command:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f framemd5 -
</pre>
<div class="Pp"></div>
See also the <b>framehash</b> and <b>md5</b> muxers.
<h2 class="Ss" title="Ss" id="gif"><a class="selflink" href="#gif">gif</a></h2>
Animated GIF muxer.
<div class="Pp"></div>
It accepts the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>loop</b></dt>
  <dd class="It-tag">Set the number of times to loop the output. Use
      &quot;-1&quot; for no loop, 0 for looping indefinitely (default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>final_delay</b></dt>
  <dd class="It-tag">Force the delay (expressed in centiseconds) after the last
      frame. Each frame ends with a delay until the next frame. The default is
      &quot;-1&quot;, which is a special value to tell the muxer to re-use the
      previous delay. In case of a loop, you might want to customize this value
      to mark a pause for instance.</dd>
</dl>
<div class="Pp"></div>
For example, to encode a gif looping 10 times, with a 5 seconds delay between
  the loops:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -loop 10 -final_delay 500 out.gif
</pre>
<div class="Pp"></div>
Note 1: if you wish to extract the frames into separate GIF files, you need to
  force the <b>image2</b> muxer:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -c:v gif -f image2 &quot;out%d.gif&quot;
</pre>
<div class="Pp"></div>
Note 2: the GIF format has a very large time base: the delay between two frames
  can therefore not be smaller than one centi second.
<h2 class="Ss" title="Ss" id="hash"><a class="selflink" href="#hash">hash</a></h2>
Hash testing format.
<div class="Pp"></div>
This muxer computes and prints a cryptographic hash of all the input audio and
  video frames. This can be used for equality checks without having to do a
  complete binary comparison.
<div class="Pp"></div>
By default audio frames are converted to signed 16-bit raw audio and video
  frames to raw video before computing the hash, but the output of explicit
  conversions to other codecs can also be used. Timestamps are ignored. It uses
  the SHA-256 cryptographic hash function by default, but supports several other
  algorithms.
<div class="Pp"></div>
The output of the muxer consists of a single line of the form:
  <i>algo</i>=<i>hash</i>, where <i>algo</i> is a short string representing the
  hash function used, and <i>hash</i> is a hexadecimal number representing the
  computed hash.
<dl class="Bl-tag">
  <dt class="It-tag"><b>hash</b> <i>algorithm</i></dt>
  <dd class="It-tag">Use the cryptographic hash function specified by the string
      <i>algorithm</i>. Supported values include &quot;MD5&quot;,
      &quot;murmur3&quot;, &quot;RIPEMD128&quot;, &quot;RIPEMD160&quot;,
      &quot;RIPEMD256&quot;, &quot;RIPEMD320&quot;, &quot;SHA160&quot;,
      &quot;SHA224&quot;, &quot;SHA256&quot; (default), &quot;SHA512/224&quot;,
      &quot;SHA512/256&quot;, &quot;SHA384&quot;, &quot;SHA512&quot;,
      &quot;CRC32&quot; and &quot;adler32&quot;.</dd>
</dl>
<div class="Pp"></div>
<i>Examples</i>
<div class="Pp"></div>
To compute the SHA-256 hash of the input converted to raw audio and video, and
  store it in the file <i>out.sha256</i>:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f hash out.sha256
</pre>
<div class="Pp"></div>
To print an MD5 hash to stdout use the command:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f hash -hash md5 -
</pre>
<div class="Pp"></div>
See also the <b>framehash</b> muxer.
<h2 class="Ss" title="Ss" id="hls"><a class="selflink" href="#hls">hls</a></h2>
Apple HTTP Live Streaming muxer that segments MPEG-TS according to the HTTP Live
  Streaming (HLS) specification.
<div class="Pp"></div>
It creates a playlist file, and one or more segment files. The output filename
  specifies the playlist filename.
<div class="Pp"></div>
By default, the muxer creates a file for each segment produced. These files have
  the same name as the playlist, followed by a sequential number and a .ts
  extension.
<div class="Pp"></div>
For example, to convert an input file with <b>ffmpeg</b>:
<div class="Pp"></div>
<pre>
        ffmpeg -i in.nut out.m3u8
</pre>
<div class="Pp"></div>
This example will produce the playlist, <i>out.m3u8</i>, and segment files:
  <i>out0.ts</i>, <i>out1.ts</i>, <i>out2.ts</i>, etc.
<div class="Pp"></div>
See also the <b>segment</b> muxer, which provides a more generic and flexible
  implementation of a segmenter, and can be used to perform HLS segmentation.
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
This muxer supports the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_init_time</b> <i>seconds</i></dt>
  <dd class="It-tag">Set the initial target segment length in seconds. Default
      value is <i>0</i>. Segment will be cut on the next key frame after this
      time has passed on the first m3u8 list. After the initial playlist is
      filled <b>ffmpeg</b> will cut segments at duration equal to
      &quot;hls_time&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_time</b> <i>seconds</i></dt>
  <dd class="It-tag">Set the target segment length in seconds. Default value is
      2. Segment will be cut on the next key frame after this time has
    passed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_list_size</b> <i>size</i></dt>
  <dd class="It-tag">Set the maximum number of playlist entries. If set to 0 the
      list file will contain all the segments. Default value is 5.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_ts_options</b> <i>options_list</i></dt>
  <dd class="It-tag">Set output format options using a :-separated list of
      key=value parameters. Values containing &quot;:&quot; special characters
      must be escaped.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_wrap</b> <i>wrap</i></dt>
  <dd class="It-tag">Set the number after which the segment filename number (the
      number specified in each segment file) wraps. If set to 0 the number will
      be never wrapped. Default value is 0.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is useful to avoid to fill the disk with many segment files, and
      limits the maximum number of segment files written to disk to
    <i>wrap</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>start_number</b> <i>number</i></dt>
  <dd class="It-tag">Start the playlist sequence number from <i>number</i>.
      Default value is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_allow_cache</b> <i>allowcache</i></dt>
  <dd class="It-tag">Explicitly set whether the client MAY \fIs0(1) or MUST NOT
      \fIs0(0) cache media segments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_base_url</b> <i>baseurl</i></dt>
  <dd class="It-tag">Append <i>baseurl</i> to every entry in the playlist.
      Useful to generate playlists with absolute paths.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the playlist sequence number must be unique for each segment and
      it is not to be confused with the segment filename sequence number which
      can be cyclic, for example if the <b>wrap</b> option is specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_segment_filename</b> <i>filename</i></dt>
  <dd class="It-tag">Set the segment filename. Unless &quot;hls_flags
      single_file&quot; is set, <i>filename</i> is used as a string format with
      the segment number:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.nut -hls_segment_filename 'file%03d.ts' out.m3u8
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This example will produce the playlist, <i>out.m3u8</i>, and segment files:
      <i>file000.ts</i>, <i>file001.ts</i>, <i>file002.ts</i>, etc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>use_localtime</b></dt>
  <dd class="It-tag">Use strftime on <i>filename</i> to expand the segment
      filename with localtime. The segment number (%d) is not available in this
      mode.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.nut -use_localtime 1 -hls_segment_filename 'file-%Y%m%d-%s.ts' out.m3u8
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This example will produce the playlist, <i>out.m3u8</i>, and segment files:
      <i>file-20160215-1455569023.ts</i>, <i>file-20160215-1455569024.ts</i>,
      etc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>use_localtime_mkdir</b></dt>
  <dd class="It-tag">Used together with -use_localtime, it will create up to one
      subdirectory which is expanded in <i>filename</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.nut -use_localtime 1 -use_localtime_mkdir 1 -hls_segment_filename '%Y%m%d/file-%Y%m%d-%s.ts' out.m3u8
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This example will create a directory 201560215 (if it does not exist), and
      then produce the playlist, <i>out.m3u8</i>, and segment files:
      <i>201560215/file-20160215-1455569023.ts</i>,
      <i>201560215/file-20160215-1455569024.ts</i>, etc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_key_info_file</b> <i>key_info_file</i></dt>
  <dd class="It-tag">Use the information in <i>key_info_file</i> for segment
      encryption. The first line of <i>key_info_file</i> specifies the key URI
      written to the playlist. The key URL is used to access the encryption key
      during playback. The second line specifies the path to the key file used
      to obtain the key during the encryption process. The key file is read as a
      single packed array of 16 octets in binary format. The optional third line
      specifies the initialization vector (IV) as a hexadecimal string to be
      used instead of the segment sequence number (default) for encryption.
      Changes to <i>key_info_file</i> will result in segment encryption with the
      new key/IV and an entry in the playlist for the new key URI/IV.
    <div style="height: 1.00em;">&#x00A0;</div>
    Key info file format:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        &lt;key URI&gt;
        &lt;key file path&gt;
        &lt;IV&gt; (optional)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Example key URIs:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        http://server/file.key
        /path/to/file.key
        file.key
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Example key file paths:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        file.key
        /path/to/file.key
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Example IV:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        0123456789ABCDEF0123456789ABCDEF
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Key info file example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        http://server/file.key
        /path/to/file.key
        0123456789ABCDEF0123456789ABCDEF
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Example shell script:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        #!/bin/sh
        BASE_URL=${1:-'.'}
        openssl rand 16 &gt; file.key
        echo $BASE_URL/file.key &gt; file.keyinfo
        echo file.key &gt;&gt; file.keyinfo
        echo $(openssl rand -hex 16) &gt;&gt; file.keyinfo
        ffmpeg -f lavfi -re -i testsrc -c:v h264 -hls_flags delete_segments \
          -hls_key_info_file file.keyinfo out.m3u8
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_flags single_file</b></dt>
  <dd class="It-tag">If this flag is set, the muxer will store all segments in a
      single MPEG-TS file, and will use byte ranges in the playlist. HLS
      playlists generated with this way will have the version number 4. For
      example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.nut -hls_flags single_file out.m3u8
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Will produce the playlist, <i>out.m3u8</i>, and a single segment file,
      <i>out.ts</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_flags delete_segments</b></dt>
  <dd class="It-tag">Segment files removed from the playlist are deleted after a
      period of time equal to the duration of the segment plus the duration of
      the playlist.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_flags append_list</b></dt>
  <dd class="It-tag">Append new segments into the end of old segment list, and
      remove the &quot;#EXT-X-ENDLIST&quot; from the old segment list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_flags round_durations</b></dt>
  <dd class="It-tag">Round the duration info in the playlist file segment info
      to integer values, instead of using floating point.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_flags discont_starts</b></dt>
  <dd class="It-tag">Add the &quot;#EXT-X-DISCONTINUITY&quot; tag to the
      playlist, before the first segment's information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_flags omit_endlist</b></dt>
  <dd class="It-tag">Do not append the &quot;EXT-X-ENDLIST&quot; tag at the end
      of the playlist.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_flags split_by_time</b></dt>
  <dd class="It-tag">Allow segments to start on frames other than keyframes.
      This improves behavior on some players when the time between keyframes is
      inconsistent, but may make things worse on others, and can cause some
      oddities during seeking. This flag should be used with the
      &quot;hls_time&quot; option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_flags program_date_time</b></dt>
  <dd class="It-tag">Generate &quot;EXT-X-PROGRAM-DATE-TIME&quot; tags.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_playlist_type event</b></dt>
  <dd class="It-tag">Emit &quot;#EXT-X-PLAYLIST-TYPE:EVENT&quot; in the m3u8
      header. Forces <b>hls_list_size</b> to 0; the playlist can only be
      appended to.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hls_playlist_type vod</b></dt>
  <dd class="It-tag">Emit &quot;#EXT-X-PLAYLIST-TYPE:VOD&quot; in the m3u8
      header. Forces <b>hls_list_size</b> to 0; the playlist must not
    change.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>method</b></dt>
  <dd class="It-tag">Use the given HTTP method to create the hls files.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -re -i in.ts -f hls -method PUT http://example.com/live/out.m3u8
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This example will upload all the mpegts segment files to the HTTP server
      using the HTTP PUT method, and update the m3u8 files every
      &quot;refresh&quot; times using the same method. Note that the HTTP server
      must support the given method for uploading files.</dd>
</dl>
<h2 class="Ss" title="Ss" id="ico"><a class="selflink" href="#ico">ico</a></h2>
ICO file muxer.
<div class="Pp"></div>
Microsoft's icon file format (ICO) has some strict limitations that should be
  noted:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Size cannot exceed 256 pixels in any dimension</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Only BMP and PNG images can be stored</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If a BMP image is used, it must be one of the following
      pixel formats:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        BMP Bit Depth      FFmpeg Pixel Format
        1bit               pal8
        4bit               pal8
        8bit               pal8
        16bit              rgb555le
        24bit              bgr24
        32bit              bgra
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If a BMP image is used, it must use the BITMAPINFOHEADER
      DIB header</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If a PNG image is used, it must use the rgba pixel
    format</dd>
</dl>
<h2 class="Ss" title="Ss" id="image2"><a class="selflink" href="#image2">image2</a></h2>
Image file muxer.
<div class="Pp"></div>
The image file muxer writes video frames to image files.
<div class="Pp"></div>
The output filenames are specified by a pattern, which can be used to produce
  sequentially numbered series of files. The pattern may contain the string
  &quot;%d&quot; or &quot;%0 <i>N</i>d&quot;, this string specifies the position
  of the characters representing a numbering in the filenames. If the form
  &quot;%0 <i>N</i>d&quot; is used, the string representing the number in each
  filename is 0-padded to <i>N</i> digits. The literal character '%' can be
  specified in the pattern with the string &quot;%%&quot;.
<div class="Pp"></div>
If the pattern contains &quot;%d&quot; or &quot;%0 <i>N</i>d&quot;, the first
  filename of the file list specified will contain the number 1, all the
  following numbers will be sequential.
<div class="Pp"></div>
The pattern may contain a suffix which is used to automatically determine the
  format of the image files to write.
<div class="Pp"></div>
For example the pattern &quot;img-%03d.bmp&quot; will specify a sequence of
  filenames of the form <i>img-001.bmp</i>, <i>img-002.bmp</i>, ...,
  <i>img-010.bmp</i>, etc. The pattern &quot;img%%-%d.jpg&quot; will specify a
  sequence of filenames of the form <i>img%-1.jpg</i>, <i>img%-2.jpg</i>, ...,
  <i>img%-10.jpg</i>, etc.
<div class="Pp"></div>
<i>Examples</i>
<div class="Pp"></div>
The following example shows how to use <b>ffmpeg</b> for creating a sequence of
  files <i>img-001.jpeg</i>, <i>img-002.jpeg</i>, ..., taking one image every
  second from the input video:
<div class="Pp"></div>
<pre>
        ffmpeg -i in.avi -vsync 1 -r 1 -f image2 'img-%03d.jpeg'
</pre>
<div class="Pp"></div>
Note that with <b>ffmpeg</b>, if the format is not specified with the
  &quot;-f&quot; option and the output filename specifies an image file format,
  the image2 muxer is automatically selected, so the previous command can be
  written as:
<div class="Pp"></div>
<pre>
        ffmpeg -i in.avi -vsync 1 -r 1 'img-%03d.jpeg'
</pre>
<div class="Pp"></div>
Note also that the pattern must not necessarily contain &quot;%d&quot; or
  &quot;%0 <i>N</i>d&quot;, for example to create a single image file
  <i>img.jpeg</i> from the input video you can employ the command:
<div class="Pp"></div>
<pre>
        ffmpeg -i in.avi -f image2 -frames:v 1 img.jpeg
</pre>
<div class="Pp"></div>
The <b>strftime</b> option allows you to expand the filename with date and time
  information. Check the documentation of the &quot;strftime()&quot; function
  for the syntax.
<div class="Pp"></div>
For example to generate image files from the &quot;strftime()&quot;
  &quot;%Y-%m-%d_%H-%M-%S&quot; pattern, the following <b>ffmpeg</b> command can
  be used:
<div class="Pp"></div>
<pre>
        ffmpeg -f v4l2 -r 1 -i /dev/video0 -f image2 -strftime 1 &quot;%Y-%m-%d_%H-%M-%S.jpg&quot;
</pre>
<div class="Pp"></div>
<i>Options</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>start_number</b></dt>
  <dd class="It-tag">Start the sequence from the specified number. Default value
      is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>update</b></dt>
  <dd class="It-tag">If set to 1, the filename will always be interpreted as
      just a filename, not a pattern, and the corresponding file will be
      continuously overwritten with new images. Default value is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>strftime</b></dt>
  <dd class="It-tag">If set to 1, expand the filename with date and time
      information from &quot;strftime()&quot;. Default value is 0.</dd>
</dl>
<div class="Pp"></div>
The image muxer supports the .Y.U.V image file format. This format is special in
  that that each image frame consists of three files, for each of the YUV420P
  components. To read or write this image file format, specify the name of the
  '.Y' file. The muxer will automatically open the '.U' and '.V' files as
  required.
<h2 class="Ss" title="Ss" id="matroska"><a class="selflink" href="#matroska">matroska</a></h2>
Matroska container muxer.
<div class="Pp"></div>
This muxer implements the matroska and webm container specs.
<div class="Pp"></div>
<i>Metadata</i>
<div class="Pp"></div>
The recognized metadata settings in this muxer are:
<dl class="Bl-tag">
  <dt class="It-tag"><b>title</b></dt>
  <dd class="It-tag">Set title name provided to a single track.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>language</b></dt>
  <dd class="It-tag">Specify the language of the track in the Matroska languages
      form.
    <div style="height: 1.00em;">&#x00A0;</div>
    The language can be either the 3 letters bibliographic ISO-639-2 (ISO
      639-2/B) form (like &quot;fre&quot; for French), or a language code mixed
      with a country code for specialities in languages (like &quot;fre-ca&quot;
      for Canadian French).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>stereo_mode</b></dt>
  <dd class="It-tag">Set stereo 3D video layout of two views in a single video
      track.
    <div style="height: 1.00em;">&#x00A0;</div>
    The following values are recognized:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>mono</b></dt>
  <dd class="It-tag">video is not stereo</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>left_right</b></dt>
  <dd class="It-tag">Both views are arranged side by side, Left-eye view is on
      the left</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bottom_top</b></dt>
  <dd class="It-tag">Both views are arranged in top-bottom orientation, Left-eye
      view is at bottom</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>top_bottom</b></dt>
  <dd class="It-tag">Both views are arranged in top-bottom orientation, Left-eye
      view is on top</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>checkerboard_rl</b></dt>
  <dd class="It-tag">Each view is arranged in a checkerboard interleaved
      pattern, Left-eye view being first</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>checkerboard_lr</b></dt>
  <dd class="It-tag">Each view is arranged in a checkerboard interleaved
      pattern, Right-eye view being first</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>row_interleaved_rl</b></dt>
  <dd class="It-tag">Each view is constituted by a row based interleaving,
      Right-eye view is first row</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>row_interleaved_lr</b></dt>
  <dd class="It-tag">Each view is constituted by a row based interleaving,
      Left-eye view is first row</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>col_interleaved_rl</b></dt>
  <dd class="It-tag">Both views are arranged in a column based interleaving
      manner, Right-eye view is first column</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>col_interleaved_lr</b></dt>
  <dd class="It-tag">Both views are arranged in a column based interleaving
      manner, Left-eye view is first column</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>anaglyph_cyan_red</b></dt>
  <dd class="It-tag">All frames are in anaglyph format viewable through red-cyan
      filters</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>right_left</b></dt>
  <dd class="It-tag">Both views are arranged side by side, Right-eye view is on
      the left</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>anaglyph_green_magenta</b></dt>
  <dd class="It-tag">All frames are in anaglyph format viewable through
      green-magenta filters</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>block_lr</b></dt>
  <dd class="It-tag">Both eyes laced in one Block, Left-eye view is first</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>block_rl</b></dt>
  <dd class="It-tag">Both eyes laced in one Block, Right-eye view is first</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<div class="Pp"></div>
For example a 3D WebM clip can be created using the following command line:
<div class="Pp"></div>
<pre>
        ffmpeg -i sample_left_right_clip.mpg -an -c:v libvpx -metadata stereo_mode=left_right -y stereo_clip.webm
</pre>
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
This muxer supports the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>reserve_index_space</b></dt>
  <dd class="It-tag">By default, this muxer writes the index for seeking (called
      cues in Matroska terms) at the end of the file, because it cannot know in
      advance how much space to leave for the index at the beginning of the
      file. However for some use cases -- e.g. streaming where seeking is
      possible but slow -- it is useful to put the index at the beginning of the
      file.
    <div style="height: 1.00em;">&#x00A0;</div>
    If this option is set to a non-zero value, the muxer will reserve a given
      amount of space in the file header and then try to write the cues there
      when the muxing finishes. If the available space does not suffice, muxing
      will fail. A safe size for most use cases should be about 50kB per hour of
      video.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that cues are only written if the output is seekable and this option
      will have no effect if it is not.</dd>
</dl>
<h2 class="Ss" title="Ss" id="md5"><a class="selflink" href="#md5">md5</a></h2>
MD5 testing format.
<div class="Pp"></div>
This is a variant of the <b>hash</b> muxer. Unlike that muxer, it defaults to
  using the MD5 hash function.
<div class="Pp"></div>
<i>Examples</i>
<div class="Pp"></div>
To compute the MD5 hash of the input converted to raw audio and video, and store
  it in the file <i>out.md5</i>:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f md5 out.md5
</pre>
<div class="Pp"></div>
You can print the MD5 to stdout with the command:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f md5 -
</pre>
<div class="Pp"></div>
See also the <b>hash</b> and <b>framemd5</b> muxers.
<h2 class="Ss" title="Ss" id="mov,_mp4,_ismv"><a class="selflink" href="#mov,_mp4,_ismv">mov,
  mp4, ismv</a></h2>
MOV/MP4/ISMV (Smooth Streaming) muxer.
<div class="Pp"></div>
The mov/mp4/ismv muxer supports fragmentation. Normally, a MOV/MP4 file has all
  the metadata about all packets stored in one location (written at the end of
  the file, it can be moved to the start for better playback by adding
  <i>faststart</i> to the <i>movflags</i>, or using the <b>qt-faststart</b>
  tool). A fragmented file consists of a number of fragments, where packets and
  metadata about these packets are stored together. Writing a fragmented file
  has the advantage that the file is decodable even if the writing is
  interrupted (while a normal MOV/MP4 is undecodable if it is not properly
  finished), and it requires less memory when writing very long files (since
  writing normal MOV/MP4 files stores info about every single packet in memory
  until the file is closed). The downside is that it is less compatible with
  other applications.
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
Fragmentation is enabled by setting one of the AVOptions that define how to cut
  the file into fragments:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-moov_size</b> <i>bytes</i></dt>
  <dd class="It-tag">Reserves space for the moov atom at the beginning of the
      file instead of placing the moov atom at the end. If the space reserved is
      insufficient, muxing will fail.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-movflags frag_keyframe</b></dt>
  <dd class="It-tag">Start a new fragment at each video keyframe.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-frag_duration</b> <i>duration</i></dt>
  <dd class="It-tag">Create fragments that are <i>duration</i> microseconds
      long.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-frag_size</b> <i>size</i></dt>
  <dd class="It-tag">Create fragments that contain up to <i>size</i> bytes of
      payload data.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-movflags frag_custom</b></dt>
  <dd class="It-tag">Allow the caller to manually choose when to cut fragments,
      by calling &quot;av_write_frame(ctx, NULL)&quot; to write a fragment with
      the packets written so far. (This is only useful with other applications
      integrating libavformat, not from <b>ffmpeg</b>.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-min_frag_duration</b> <i>duration</i></dt>
  <dd class="It-tag">Don't create fragments that are shorter than
      <i>duration</i> microseconds long.</dd>
</dl>
<div class="Pp"></div>
If more than one condition is specified, fragments are cut when one of the
  specified conditions is fulfilled. The exception to this is
  &quot;-min_frag_duration&quot;, which has to be fulfilled for any of the other
  conditions to apply.
<div class="Pp"></div>
Additionally, the way the output file is written can be adjusted through a few
  other options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-movflags empty_moov</b></dt>
  <dd class="It-tag">Write an initial moov atom directly at the start of the
      file, without describing any samples in it. Generally, an mdat/moov pair
      is written at the start of the file, as a normal MOV/MP4 file, containing
      only a short portion of the file. With this option set, there is no
      initial mdat atom, and the moov atom only describes the tracks but has a
      zero duration.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is implicitly set when writing ismv (Smooth Streaming)
    files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-movflags separate_moof</b></dt>
  <dd class="It-tag">Write a separate moof (movie fragment) atom for each track.
      Normally, packets for all tracks are written in a moof atom (which is
      slightly more efficient), but with this option set, the muxer writes one
      moof/mdat pair for each track, making it easier to separate tracks.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is implicitly set when writing ismv (Smooth Streaming)
    files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-movflags faststart</b></dt>
  <dd class="It-tag">Run a second pass moving the index (moov atom) to the
      beginning of the file. This operation can take a while, and will not work
      in various situations such as fragmented output, thus it is not enabled by
      default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-movflags rtphint</b></dt>
  <dd class="It-tag">Add RTP hinting tracks to the output file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-movflags disable_chpl</b></dt>
  <dd class="It-tag">Disable Nero chapter markers (chpl atom). Normally, both
      Nero chapters and a QuickTime chapter track are written to the file. With
      this option set, only the QuickTime chapter track will be written. Nero
      chapters can cause failures when the file is reprocessed with certain
      tagging programs, like mp3Tag 2.61a and iTunes 11.3, most likely other
      versions are affected as well.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-movflags omit_tfhd_offset</b></dt>
  <dd class="It-tag">Do not write any absolute base_data_offset in tfhd atoms.
      This avoids tying fragments to absolute byte positions in the
      file/streams.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-movflags default_base_moof</b></dt>
  <dd class="It-tag">Similarly to the omit_tfhd_offset, this flag avoids writing
      the absolute base_data_offset field in tfhd atoms, but does so by using
      the new default-base-is-moof flag instead. This flag is new from
      14496-12:2012. This may make the fragments easier to parse in certain
      circumstances (avoiding basing track fragment location calculations on the
      implicit end of the previous track fragment).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-write_tmcd</b></dt>
  <dd class="It-tag">Specify &quot;on&quot; to force writing a timecode track,
      &quot;off&quot; to disable it and &quot;auto&quot; to write a timecode
      track only for mov and mp4 output (default).</dd>
</dl>
<div class="Pp"></div>
<i>Example</i>
<div class="Pp"></div>
Smooth Streaming content can be pushed in real time to a publishing point on IIS
  with this muxer. Example:
<div class="Pp"></div>
<pre>
        ffmpeg -re &lt;&lt;normal input/transcoding options&gt;&gt; -movflags isml+frag_keyframe -f ismv http://server/publishingpoint.isml/Streams(Encoder1)
</pre>
<div class="Pp"></div>
<i>Audible AAX</i>
<div class="Pp"></div>
Audible AAX files are encrypted M4B files, and they can be decrypted by
  specifying a 4 byte activation secret.
<div class="Pp"></div>
<pre>
        ffmpeg -activation_bytes 1CEB00DA -i test.aax -vn -c:a copy output.mp4
</pre>
<h2 class="Ss" title="Ss" id="mp3"><a class="selflink" href="#mp3">mp3</a></h2>
The MP3 muxer writes a raw MP3 stream with the following optional features:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">An ID3v2 metadata header at the beginning (enabled by
      default). Versions 2.3 and 2.4 are supported, the
      &quot;id3v2_version&quot; private option controls which one is used (3 or
      4). Setting &quot;id3v2_version&quot; to 0 disables the ID3v2 header
      completely.
    <div style="height: 1.00em;">&#x00A0;</div>
    The muxer supports writing attached pictures (APIC frames) to the ID3v2
      header. The pictures are supplied to the muxer in form of a video stream
      with a single packet. There can be any number of those streams, each will
      correspond to a single APIC frame. The stream metadata tags <i>title</i>
      and <i>comment</i> map to APIC <i>description</i> and <i>picture type</i>
      respectively. See &lt; <b>http://id3.org/id3v2.4.0-frames</b>&gt; for
      allowed picture types.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the APIC frames must be written at the beginning, so the muxer
      will buffer the audio frames until it gets all the pictures. It is
      therefore advised to provide the pictures as soon as possible to avoid
      excessive buffering.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A Xing/LAME frame right after the ID3v2 header (if
      present). It is enabled by default, but will be written only if the output
      is seekable. The &quot;write_xing&quot; private option can be used to
      disable it. The frame contains various information that may be useful to
      the decoder, like the audio duration or encoder delay.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A legacy ID3v1 tag at the end of the file (disabled by
      default). It may be enabled with the &quot;write_id3v1&quot; private
      option, but as its capabilities are very limited, its usage is not
      recommended.</dd>
</dl>
<div class="Pp"></div>
Examples:
<div class="Pp"></div>
Write an mp3 with an ID3v2.3 header and an ID3v1 footer:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -id3v2_version 3 -write_id3v1 1 out.mp3
</pre>
<div class="Pp"></div>
To attach a picture to an mp3 file select both the audio and the picture stream
  with &quot;map&quot;:
<div class="Pp"></div>
<pre>
        ffmpeg -i input.mp3 -i cover.png -c copy -map 0 -map 1
        -metadata:s:v title=&quot;Album cover&quot; -metadata:s:v comment=&quot;Cover (Front)&quot; out.mp3
</pre>
<div class="Pp"></div>
Write a &quot;clean&quot; MP3 without any extra features:
<div class="Pp"></div>
<pre>
        ffmpeg -i input.wav -write_xing 0 -id3v2_version 0 out.mp3
</pre>
<h2 class="Ss" title="Ss" id="mpegts"><a class="selflink" href="#mpegts">mpegts</a></h2>
MPEG transport stream muxer.
<div class="Pp"></div>
This muxer implements ISO 13818-1 and part of ETSI EN 300 468.
<div class="Pp"></div>
The recognized metadata settings in mpegts muxer are
  &quot;service_provider&quot; and &quot;service_name&quot;. If they are not set
  the default for &quot;service_provider&quot; is &quot;FFmpeg&quot; and the
  default for &quot;service_name&quot; is &quot;Service01&quot;.
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
The muxer options are:
<dl class="Bl-tag">
  <dt class="It-tag"><b>mpegts_original_network_id</b> <i>number</i></dt>
  <dd class="It-tag">Set the original_network_id (default 0x0001). This is
      unique identifier of a network in DVB. Its main use is in the unique
      identification of a service through the path Original_Network_ID,
      Transport_Stream_ID.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mpegts_transport_stream_id</b> <i>number</i></dt>
  <dd class="It-tag">Set the transport_stream_id (default 0x0001). This
      identifies a transponder in DVB.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mpegts_service_id</b> <i>number</i></dt>
  <dd class="It-tag">Set the service_id (default 0x0001) also known as program
      in DVB.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mpegts_service_type</b> <i>number</i></dt>
  <dd class="It-tag">Set the program service_type (default <i>digital_tv</i>),
      see below a list of pre defined values.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mpegts_pmt_start_pid</b> <i>number</i></dt>
  <dd class="It-tag">Set the first PID for PMT (default 0x1000, max
    0x1f00).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mpegts_start_pid</b> <i>number</i></dt>
  <dd class="It-tag">Set the first PID for data packets (default 0x0100, max
      0x0f00).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mpegts_m2ts_mode</b> <i>number</i></dt>
  <dd class="It-tag">Enable m2ts mode if set to 1. Default value is -1 which
      disables m2ts mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>muxrate</b> <i>number</i></dt>
  <dd class="It-tag">Set a constant muxrate (default VBR).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pcr_period</b> <i>numer</i></dt>
  <dd class="It-tag">Override the default PCR retransmission time (default
      20ms), ignored if variable muxrate is selected.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pat_period</b> <i>number</i></dt>
  <dd class="It-tag">Maximal time in seconds between PAT/PMT tables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sdt_period</b> <i>number</i></dt>
  <dd class="It-tag">Maximal time in seconds between SDT tables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pes_payload_size</b> <i>number</i></dt>
  <dd class="It-tag">Set minimum PES packet payload in bytes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mpegts_flags</b> <i>flags</i></dt>
  <dd class="It-tag">Set flags (see below).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mpegts_copyts</b> <i>number</i></dt>
  <dd class="It-tag">Preserve original timestamps, if value is set to 1. Default
      value is -1, which results in shifting timestamps so that they start from
      0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tables_version</b> <i>number</i></dt>
  <dd class="It-tag">Set PAT, PMT and SDT version (default 0, valid values are
      from 0 to 31, inclusively). This option allows updating stream structure
      so that standard consumer may detect the change. To do so, reopen output
      AVFormatContext (in case of API usage) or restart ffmpeg instance,
      cyclically changing tables_version value:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i source1.ts -codec copy -f mpegts -tables_version 0 udp://1.1.1.1:1111
        ffmpeg -i source2.ts -codec copy -f mpegts -tables_version 1 udp://1.1.1.1:1111
        ...
        ffmpeg -i source3.ts -codec copy -f mpegts -tables_version 31 udp://1.1.1.1:1111
        ffmpeg -i source1.ts -codec copy -f mpegts -tables_version 0 udp://1.1.1.1:1111
        ffmpeg -i source2.ts -codec copy -f mpegts -tables_version 1 udp://1.1.1.1:1111
        ...
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
Option <b>mpegts_service_type</b> accepts the following values:
<dl class="Bl-tag">
  <dt class="It-tag"><b>hex_value</b></dt>
  <dd class="It-tag">Any hexdecimal value between 0x01 to 0xff as defined in
      ETSI 300 468.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>digital_tv</b></dt>
  <dd class="It-tag">Digital TV service.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>digital_radio</b></dt>
  <dd class="It-tag">Digital Radio service.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>teletext</b></dt>
  <dd class="It-tag">Teletext service.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>advanced_codec_digital_radio</b></dt>
  <dd class="It-tag">Advanced Codec Digital Radio service.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mpeg2_digital_hdtv</b></dt>
  <dd class="It-tag">MPEG2 Digital HDTV service.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>advanced_codec_digital_sdtv</b></dt>
  <dd class="It-tag">Advanced Codec Digital SDTV service.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>advanced_codec_digital_hdtv</b></dt>
  <dd class="It-tag">Advanced Codec Digital HDTV service.</dd>
</dl>
<div class="Pp"></div>
Option <b>mpegts_flags</b> may take a set of such flags:
<dl class="Bl-tag">
  <dt class="It-tag"><b>resend_headers</b></dt>
  <dd class="It-tag">Reemit PAT/PMT before writing the next packet.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>latm</b></dt>
  <dd class="It-tag">Use LATM packetization for AAC.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pat_pmt_at_frames</b></dt>
  <dd class="It-tag">Reemit PAT and PMT at each video frame.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>system_b</b></dt>
  <dd class="It-tag">Conform to System B (DVB) instead of System A (ATSC).</dd>
</dl>
<div class="Pp"></div>
<i>Example</i>
<div class="Pp"></div>
<pre>
        ffmpeg -i file.mpg -c copy \
             -mpegts_original_network_id 0x1122 \
             -mpegts_transport_stream_id 0x3344 \
             -mpegts_service_id 0x5566 \
             -mpegts_pmt_start_pid 0x1500 \
             -mpegts_start_pid 0x150 \
             -metadata service_provider=&quot;Some provider&quot; \
             -metadata service_name=&quot;Some Channel&quot; \
             -y out.ts
</pre>
<h2 class="Ss" title="Ss" id="mxf,_mxf_d10"><a class="selflink" href="#mxf,_mxf_d10">mxf,
  mxf_d10</a></h2>
MXF muxer.
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
The muxer options are:
<dl class="Bl-tag">
  <dt class="It-tag"><b>store_user_comments</b> <i>bool</i></dt>
  <dd class="It-tag">Set if user comments should be stored if available or
      never. IRT D-10 does not allow user comments. The default is thus to write
      them for mxf but not for mxf_d10</dd>
</dl>
<h2 class="Ss" title="Ss" id="null"><a class="selflink" href="#null">null</a></h2>
Null muxer.
<div class="Pp"></div>
This muxer does not generate any output file, it is mainly useful for testing or
  benchmarking purposes.
<div class="Pp"></div>
For example to benchmark decoding with <b>ffmpeg</b> you can use the command:
<div class="Pp"></div>
<pre>
        ffmpeg -benchmark -i INPUT -f null out.null
</pre>
<div class="Pp"></div>
Note that the above command does not read or write the <i>out.null</i> file, but
  specifying the output file is required by the <b>ffmpeg</b> syntax.
<div class="Pp"></div>
Alternatively you can write the command as:
<div class="Pp"></div>
<pre>
        ffmpeg -benchmark -i INPUT -f null -
</pre>
<h2 class="Ss" title="Ss" id="nut"><a class="selflink" href="#nut">nut</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-syncpoints</b> <i>flags</i></dt>
  <dd class="It-tag">Change the syncpoint usage in nut:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>default</i> <b>use the normal low-overhead seeking
    aids.</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>none</i> <b>do not use the syncpoints at all, reducing
    the overhead but making the stream non-seekable;</b></dt>
  <dd class="It-tag">
    <pre>
    Use of this option is not recommended, as the resulting files are very damage
    sensitive and seeking is not possible. Also in general the overhead from
    syncpoints is negligible. Note, -C&lt;write_index&gt; 0 can be used to disable
    all growing data tables, allowing to mux endless streams with limited memory
    and without these disadvantages.
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>timestamped</i> <b>extend the syncpoint with a wallclock
    field.</b></dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
The <i>none</i> and <i>timestamped</i> flags are experimental.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-write_index</b> <i>bool</i></dt>
  <dd class="It-tag">Write index at the end, the default is to write an
    index.</dd>
</dl>
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f_strict experimental -syncpoints none - | processor
</pre>
<h2 class="Ss" title="Ss" id="ogg"><a class="selflink" href="#ogg">ogg</a></h2>
Ogg container muxer.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-page_duration</b> <i>duration</i></dt>
  <dd class="It-tag">Preferred page duration, in microseconds. The muxer will
      attempt to create pages that are approximately <i>duration</i>
      microseconds long. This allows the user to compromise between seek
      granularity and container overhead. The default is 1 second. A value of 0
      will fill all segments, making pages as large as possible. A value of 1
      will effectively use 1 packet-per-page in most situations, giving a small
      seek granularity at the cost of additional container overhead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-serial_offset</b> <i>value</i></dt>
  <dd class="It-tag">Serial value from which to set the streams serial number.
      Setting it to different and sufficiently large values ensures that the
      produced ogg files can be safely chained.</dd>
</dl>
<h2 class="Ss" title="Ss" id="segment,_stream_segment,_ssegment"><a class="selflink" href="#segment,_stream_segment,_ssegment">segment,
  stream_segment, ssegment</a></h2>
Basic stream segmenter.
<div class="Pp"></div>
This muxer outputs streams to a number of separate files of nearly fixed
  duration. Output filename pattern can be set in a fashion similar to
  <b>image2</b>, or by using a &quot;strftime&quot; template if the
  <b>strftime</b> option is enabled.
<div class="Pp"></div>
&quot;stream_segment&quot; is a variant of the muxer used to write to streaming
  output formats, i.e. which do not require global headers, and is recommended
  for outputting e.g. to MPEG transport stream segments. &quot;ssegment&quot; is
  a shorter alias for &quot;stream_segment&quot;.
<div class="Pp"></div>
Every segment starts with a keyframe of the selected reference stream, which is
  set through the <b>reference_stream</b> option.
<div class="Pp"></div>
Note that if you want accurate splitting for a video file, you need to make the
  input key frames correspond to the exact splitting times expected by the
  segmenter, or the segment muxer will start the new segment with the key frame
  found next after the specified start time.
<div class="Pp"></div>
The segment muxer works best with a single constant frame rate video.
<div class="Pp"></div>
Optionally it can generate a list of the created segments, by setting the option
  <i>segment_list</i>. The list type is specified by the
  <i>segment_list_type</i> option. The entry filenames in the segment list are
  set by default to the basename of the corresponding segment files.
<div class="Pp"></div>
See also the <b>hls</b> muxer, which provides a more specific implementation for
  HLS segmentation.
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
The segment muxer supports the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>increment_tc</b> <i>1|0</i></dt>
  <dd class="It-tag">if set to 1, increment timecode between each segment If
      this is selected, the input need to have a timecode in the first video
      stream. Default value is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>reference_stream</b> <i>specifier</i></dt>
  <dd class="It-tag">Set the reference stream, as specified by the string
      <i>specifier</i>. If <i>specifier</i> is set to &quot;auto&quot;, the
      reference is chosen automatically. Otherwise it must be a stream specifier
      (see the ``Stream specifiers'' chapter in the ffmpeg manual) which
      specifies the reference stream. The default value is
    &quot;auto&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_format</b> <i>format</i></dt>
  <dd class="It-tag">Override the inner container format, by default it is
      guessed by the filename extension.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_format_options</b> <i>options_list</i></dt>
  <dd class="It-tag">Set output format options using a :-separated list of
      key=value parameters. Values containing the &quot;:&quot; special
      character must be escaped.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_list</b> <i>name</i></dt>
  <dd class="It-tag">Generate also a listfile named <i>name</i>. If not
      specified no listfile is generated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_list_flags</b> <i>flags</i></dt>
  <dd class="It-tag">Set flags affecting the segment list generation.
    <div style="height: 1.00em;">&#x00A0;</div>
    It currently supports the following flags:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>cache</b></dt>
  <dd class="It-tag">Allow caching (only affects M3U8 list files).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>live</b></dt>
  <dd class="It-tag">Allow live-friendly file generation.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_list_size</b> <i>size</i></dt>
  <dd class="It-tag">Update the list file so that it contains at most
      <i>size</i> segments. If 0 the list file will contain all the segments.
      Default value is 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_list_entry_prefix</b> <i>prefix</i></dt>
  <dd class="It-tag">Prepend <i>prefix</i> to each entry. Useful to generate
      absolute paths. By default no prefix is applied.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_list_type</b> <i>type</i></dt>
  <dd class="It-tag">Select the listing format.
    <div style="height: 1.00em;">&#x00A0;</div>
    The following values are recognized:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>flat</b></dt>
  <dd class="It-tag">Generate a flat list for the created segments, one segment
      per line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>csv, ext</b></dt>
  <dd class="It-tag">Generate a list for the created segments, one segment per
      line, each line matching the format (comma-separated values):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        &lt;segment_filename&gt;,&lt;segment_start_time&gt;,&lt;segment_end_time&gt;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>segment_filename</i> is the name of the output file generated by the
      muxer according to the provided pattern. CSV escaping (according to
      RFC4180) is applied if required.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>segment_start_time</i> and <i>segment_end_time</i> specify the segment
      start and end time expressed in seconds.
    <div style="height: 1.00em;">&#x00A0;</div>
    A list file with the suffix &quot;.csv&quot; or &quot;.ext&quot; will
      auto-select this format.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>ext</b> is deprecated in favor or <b>csv</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ffconcat</b></dt>
  <dd class="It-tag">Generate an ffconcat file for the created segments. The
      resulting file can be read using the FFmpeg <b>concat</b> demuxer.
    <div style="height: 1.00em;">&#x00A0;</div>
    A list file with the suffix &quot;.ffcat&quot; or &quot;.ffconcat&quot; will
      auto-select this format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>m3u8</b></dt>
  <dd class="It-tag">Generate an extended M3U8 file, version 3, compliant with
      &lt; <b>http://tools.ietf.org/id/draft-pantos-http-live-streaming</b>&gt;.
    <div style="height: 1.00em;">&#x00A0;</div>
    A list file with the suffix &quot;.m3u8&quot; will auto-select this
    format.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
If not specified the type is guessed from the list file name suffix.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_time</b> <i>time</i></dt>
  <dd class="It-tag">Set segment duration to <i>time</i>, the value must be a
      duration specification. Default value is &quot;2&quot;. See also the
      <b>segment_times</b> option.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that splitting may not be accurate, unless you force the reference
      stream key-frames at the given time. See the introductory notice and the
      examples below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_atclocktime</b> <i>1|0</i></dt>
  <dd class="It-tag">If set to &quot;1&quot; split at regular clock time
      intervals starting from 00:00 o'clock. The <i>time</i> value specified in
      <b>segment_time</b> is used for setting the length of the splitting
      interval.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example with <b>segment_time</b> set to &quot;900&quot; this makes it
      possible to create files at 12:00 o'clock, 12:15, 12:30, etc.
    <div style="height: 1.00em;">&#x00A0;</div>
    Default value is &quot;0&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_clocktime_offset</b> <i>duration</i></dt>
  <dd class="It-tag">Delay the segment splitting times with the specified
      duration when using <b>segment_atclocktime</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example with <b>segment_time</b> set to &quot;900&quot; and
      <b>segment_clocktime_offset</b> set to &quot;300&quot; this makes it
      possible to create files at 12:05, 12:20, 12:35, etc.
    <div style="height: 1.00em;">&#x00A0;</div>
    Default value is &quot;0&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_clocktime_wrap_duration</b> <i>duration</i></dt>
  <dd class="It-tag">Force the segmenter to only start a new segment if a packet
      reaches the muxer within the specified duration after the segmenting clock
      time. This way you can make the segmenter more resilient to backward local
      time jumps, such as leap seconds or transition to standard time from
      daylight savings time.
    <div style="height: 1.00em;">&#x00A0;</div>
    Assuming that the delay between the packets of your source is less than 0.5
      second you can detect a leap second by specifying 0.5 as the duration.
    <div style="height: 1.00em;">&#x00A0;</div>
    Default is the maximum possible duration which means starting a new segment
      regardless of the elapsed time since the last clock time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_time_delta</b> <i>delta</i></dt>
  <dd class="It-tag">Specify the accuracy time when selecting the start time for
      a segment, expressed as a duration specification. Default value is
      &quot;0&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    When delta is specified a key-frame will start a new segment if its PTS
      satisfies the relation:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        PTS &gt;= start_time - time_delta
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is useful when splitting video content, which is always split at
      GOP boundaries, in case a key frame is found just before the specified
      split time.
    <div style="height: 1.00em;">&#x00A0;</div>
    In particular may be used in combination with the <i>ffmpeg</i> option
      <i>force_key_frames</i>. The key frame times specified by
      <i>force_key_frames</i> may not be set accurately because of rounding
      issues, with the consequence that a key frame time may result set just
      before the specified time. For constant frame rate videos a value of 1/(2*
      <i>frame_rate</i>) should address the worst case mismatch between the
      specified time and the time set by <i>force_key_frames</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_times</b> <i>times</i></dt>
  <dd class="It-tag">Specify a list of split points. <i>times</i> contains a
      list of comma separated duration specifications, in increasing order. See
      also the <b>segment_time</b> option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_frames</b> <i>frames</i></dt>
  <dd class="It-tag">Specify a list of split video frame numbers. <i>frames</i>
      contains a list of comma separated integer numbers, in increasing order.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option specifies to start a new segment whenever a reference stream key
      frame is found and the sequential number (starting from 0) of the frame is
      greater or equal to the next value in the list.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_wrap</b> <i>limit</i></dt>
  <dd class="It-tag">Wrap around segment index once it reaches
    <i>limit</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>segment_start_number</b> <i>number</i></dt>
  <dd class="It-tag">Set the sequence number of the first segment. Defaults to
      0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>strftime</b> <i>1|0</i></dt>
  <dd class="It-tag">Use the &quot;strftime&quot; function to define the name of
      the new segments to write. If this is selected, the output segment name
      must contain a &quot;strftime&quot; function template. Default value is
    0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>break_non_keyframes</b> <i>1|0</i></dt>
  <dd class="It-tag">If enabled, allow segments to start on frames other than
      keyframes. This improves behavior on some players when the time between
      keyframes is inconsistent, but may make things worse on others, and can
      cause some oddities during seeking. Defaults to 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>reset_timestamps</b> <i>1|0</i></dt>
  <dd class="It-tag">Reset timestamps at the begin of each segment, so that each
      segment will start with near-zero timestamps. It is meant to ease the
      playback of the generated segments. May not work with some combinations of
      muxers/codecs. It is set to 0 by default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>initial_offset</b> <i>offset</i></dt>
  <dd class="It-tag">Specify timestamp offset to apply to the output packet
      timestamps. The argument must be a time duration specification, and
      defaults to 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>write_empty_segments</b> <i>1|0</i></dt>
  <dd class="It-tag">If enabled, write an empty segment if there are no packets
      during the period a segment would usually span. Otherwise, the segment
      will be filled with the next packet written. Defaults to 0.</dd>
</dl>
<div class="Pp"></div>
<i>Examples</i>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Remux the content of file <i>in.mkv</i> to a list of
      segments <i>out-000.nut</i>, <i>out-001.nut</i>, etc., and write the list
      of generated segments to <i>out.list</i>:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.mkv -codec copy -map 0 -f segment -segment_list out.list out%03d.nut
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Segment input and set output format options for the output
      segments:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.mkv -f segment -segment_time 10 -segment_format_options movflags=+faststart out%03d.mp4
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Segment the input file according to the split points
      specified by the <i>segment_times</i> option:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.mkv -codec copy -map 0 -f segment -segment_list out.csv -segment_times 1,2,3,5,8,13,21 out%03d.nut
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Use the <b>ffmpeg</b> <b>force_key_frames</b> option to
      force key frames in the input at the specified location, together with the
      segment option <b>segment_time_delta</b> to account for possible roundings
      operated when setting key frame times.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.mkv -force_key_frames 1,2,3,5,8,13,21 -codec:v mpeg4 -codec:a pcm_s16le -map 0 \
        -f segment -segment_list out.csv -segment_times 1,2,3,5,8,13,21 -segment_time_delta 0.05 out%03d.nut
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    In order to force key frames on the input file, transcoding is
    required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Segment the input file by splitting the input file
      according to the frame numbers sequence specified with the
      <b>segment_frames</b> option:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.mkv -codec copy -map 0 -f segment -segment_list out.csv -segment_frames 100,200,300,500,800 out%03d.nut
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Convert the <i>in.mkv</i> to TS segments using the
      &quot;libx264&quot; and &quot;aac&quot; encoders:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i in.mkv -map 0 -codec:v libx264 -codec:a aac -f ssegment -segment_list out.list out%03d.ts
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Segment the input file, and create an M3U8 live playlist
      (can be used as live HLS source):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -re -i in.mkv -codec copy -map 0 -f segment -segment_list playlist.m3u8 \
        -segment_list_flags +live -segment_time 10 out%03d.mkv
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="smoothstreaming"><a class="selflink" href="#smoothstreaming">smoothstreaming</a></h2>
Smooth Streaming muxer generates a set of files (Manifest, chunks) suitable for
  serving with conventional web server.
<dl class="Bl-tag">
  <dt class="It-tag"><b>window_size</b></dt>
  <dd class="It-tag">Specify the number of fragments kept in the manifest.
      Default 0 (keep all).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>extra_window_size</b></dt>
  <dd class="It-tag">Specify the number of fragments kept outside of the
      manifest before removing from disk. Default 5.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>lookahead_count</b></dt>
  <dd class="It-tag">Specify the number of lookahead fragments. Default 2.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>min_frag_duration</b></dt>
  <dd class="It-tag">Specify the minimum fragment duration (in microseconds).
      Default 5000000.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>remove_at_exit</b></dt>
  <dd class="It-tag">Specify whether to remove all fragments when finished.
      Default 0 (do not remove).</dd>
</dl>
<h2 class="Ss" title="Ss" id="fifo"><a class="selflink" href="#fifo">fifo</a></h2>
The fifo pseudo-muxer allows the separation of encoding and muxing by using
  first-in-first-out queue and running the actual muxer in a separate thread.
  This is especially useful in combination with the <b>tee</b> muxer and can be
  used to send data to several destinations with different reliability/writing
  speed/latency.
<div class="Pp"></div>
API users should be aware that callback functions (interrupt_callback, io_open
  and io_close) used within its AVFormatContext must be thread-safe.
<div class="Pp"></div>
The behavior of the fifo muxer if the queue fills up or if the output fails is
  selectable,
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">output can be transparently restarted with configurable
      delay between retries based on real time or time of the processed
    stream.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">encoding can be blocked during temporary failure, or
      continue transparently dropping packets in case fifo queue fills up.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>fifo_format</b></dt>
  <dd class="It-tag">Specify the format name. Useful if it cannot be guessed
      from the output name suffix.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>queue_size</b></dt>
  <dd class="It-tag">Specify size of the queue (number of packets). Default
      value is 60.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>format_opts</b></dt>
  <dd class="It-tag">Specify format options for the underlying muxer. Muxer
      options can be specified as a list of <i>key</i>=<i>value</i> pairs
      separated by ':'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>drop_pkts_on_overflow</b> <i>bool</i></dt>
  <dd class="It-tag">If set to 1 (true), in case the fifo queue fills up,
      packets will be dropped rather than blocking the encoder. This makes it
      possible to continue streaming without delaying the input, at the cost of
      omitting part of the stream. By default this option is set to 0 (false),
      so in such cases the encoder will be blocked until the muxer processes
      some of the packets and none of them is lost.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>attempt_recovery</b> <i>bool</i></dt>
  <dd class="It-tag">If failure occurs, attempt to recover the output. This is
      especially useful when used with network output, since it makes it
      possible to restart streaming transparently. By default this option is set
      to 0 (false).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>max_recovery_attempts</b></dt>
  <dd class="It-tag">Sets maximum number of successive unsuccessful recovery
      attempts after which the output fails permanently. By default this option
      is set to 0 (unlimited).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>recovery_wait_time</b> <i>duration</i></dt>
  <dd class="It-tag">Waiting time before the next recovery attempt after
      previous unsuccessful recovery attempt. Default value is 5 seconds.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>recovery_wait_streamtime</b> <i>bool</i></dt>
  <dd class="It-tag">If set to 0 (false), the real time is used when waiting for
      the recovery attempt (i.e. the recovery will be attempted after at least
      recovery_wait_time seconds). If set to 1 (true), the time of the processed
      stream is taken into account instead (i.e. the recovery will be attempted
      after at least <i>recovery_wait_time</i> seconds of the stream is
      omitted). By default, this option is set to 0 (false).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>recover_any_error</b> <i>bool</i></dt>
  <dd class="It-tag">If set to 1 (true), recovery will be attempted regardless
      of type of the error causing the failure. By default this option is set to
      0 (false) and in case of certain (usually permanent) errors the recovery
      is not attempted even when <i>attempt_recovery</i> is set to 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>restart_with_keyframe</b> <i>bool</i></dt>
  <dd class="It-tag">Specify whether to wait for the keyframe after recovering
      from queue overflow or failure. This option is set to 0 (false) by
      default.</dd>
</dl>
<div class="Pp"></div>
<i>Examples</i>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Stream something to rtmp server, continue processing the
      stream at real-time rate even in case of temporary failure (network
      outage) and attempt to recover streaming every second indefinitely.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -re -i ... -c:v libx264 -c:a aac -f fifo -fifo_format flv -map 0:v -map 0:a
          -drop_pkts_on_overflow 1 -attempt_recovery 1 -recovery_wait_time 1 rtmp://example.com/live/stream_name
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="tee"><a class="selflink" href="#tee">tee</a></h2>
The tee muxer can be used to write the same data to several files or any other
  kind of muxer. It can be used, for example, to both stream a video to the
  network and save it to disk at the same time.
<div class="Pp"></div>
It is different from specifying several outputs to the <b>ffmpeg</b>
  command-line tool because the audio and video data will be encoded only once
  with the tee muxer; encoding can be a very expensive process. It is not useful
  when using the libavformat API directly because it is then possible to feed
  the same packets to several muxers directly.
<div class="Pp"></div>
The slave outputs are specified in the file name given to the muxer, separated
  by '|'. If any of the slave name contains the '|' separator, leading or
  trailing spaces or any special character, it must be escaped (see <b>the
  &quot;Quoting and escaping&quot;</b> <b>section in the
  </b><b><i>ffmpeg-utils</i></b> <b>(1) manual</b>).
<div class="Pp"></div>
Muxer options can be specified for each slave by prepending them as a list of
  <i>key</i>=<i>value</i> pairs separated by ':', between square brackets. If
  the options values contain a special character or the ':' separator, they must
  be escaped; note that this is a second level escaping.
<div class="Pp"></div>
The following special options are also recognized:
<dl class="Bl-tag">
  <dt class="It-tag"><b>f</b></dt>
  <dd class="It-tag">Specify the format name. Useful if it cannot be guessed
      from the output name suffix.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bsfs[/</b><i>spec</i><b>]</b></dt>
  <dd class="It-tag">Specify a list of bitstream filters to apply to the
      specified output.
    <div style="height: 1.00em;">&#x00A0;</div>
    It is possible to specify to which streams a given bitstream filter applies,
      by appending a stream specifier to the option separated by &quot;/&quot;.
      <i>spec</i> must be a stream specifier (see <b>Format</b> <b>stream
      specifiers</b>). If the stream specifier is not specified, the bitstream
      filters will be applied to all streams in the output.
    <div style="height: 1.00em;">&#x00A0;</div>
    Several bitstream filters can be specified, separated by &quot;,&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>select</b></dt>
  <dd class="It-tag">Select the streams that should be mapped to the slave
      output, specified by a stream specifier. If not specified, this defaults
      to all the input streams. You may use multiple stream specifiers separated
      by commas (&quot;,&quot;) e.g.: &quot;a:0,v&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>onfail</b></dt>
  <dd class="It-tag">Specify behaviour on output failure. This can be set to
      either &quot;abort&quot; (which is default) or &quot;ignore&quot;.
      &quot;abort&quot; will cause whole process to fail in case of failure on
      this slave output. &quot;ignore&quot; will ignore failure on this output,
      so other outputs will continue without being affected.</dd>
</dl>
<div class="Pp"></div>
<i>Examples</i>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Encode something and both archive it in a WebM file and
      stream it as MPEG-TS over UDP (the streams need to be explicitly mapped):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i ... -c:v libx264 -c:a mp2 -f tee -map 0:v -map 0:a
          &quot;archive-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/&quot;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">As above, but continue streaming even if output to local
      file fails (for example local drive fills up):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i ... -c:v libx264 -c:a mp2 -f tee -map 0:v -map 0:a
          &quot;[onfail=ignore]archive-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/&quot;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Use <b>ffmpeg</b> to encode the input, and send the output
      to three different destinations. The &quot;dump_extra&quot; bitstream
      filter is used to add extradata information to all the output video
      keyframes packets, as requested by the MPEG-TS format. The select option
      is applied to <i>out.aac</i> in order to make it contain only audio
      packets.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i ... -map 0 -flags +global_header -c:v libx264 -c:a aac -strict experimental
               -f tee &quot;[bsfs/v=dump_extra]out.ts|[movflags=+faststart]out.mp4|[select=a]out.aac&quot;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">As below, but select only stream &quot;a:1&quot; for the
      audio output. Note that a second level escaping must be performed, as
      &quot;:&quot; is a special character used to separate options.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ffmpeg -i ... -map 0 -flags +global_header -c:v libx264 -c:a aac -strict experimental
               -f tee &quot;[bsfs/v=dump_extra]out.ts|[movflags=+faststart]out.mp4|[select=\'a:1\']out.aac&quot;
    </pre>
  </dd>
</dl>
<div class="Pp"></div>
Note: some codecs may need different options depending on the output format; the
  auto-detection of this can not work with the tee muxer. The main example is
  the <b>global_header</b> flag.
<h2 class="Ss" title="Ss" id="webm_dash_manifest"><a class="selflink" href="#webm_dash_manifest">webm_dash_manifest</a></h2>
WebM DASH Manifest muxer.
<div class="Pp"></div>
This muxer implements the WebM DASH Manifest specification to generate the DASH
  manifest XML. It also supports manifest generation for DASH live streams.
<div class="Pp"></div>
For more information see:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">WebM DASH Specification:
      &lt;<b>https://sites.google.com/a/webmproject.org/wiki/adaptive-streaming/webm-dash-specification</b>&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">ISO DASH Specification:
      &lt;<b>http://standards.iso.org/ittf/PubliclyAvailableStandards/c065274_ISO_IEC_23009-1_2014.zip</b>&gt;</dd>
</dl>
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
This muxer supports the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>adaptation_sets</b></dt>
  <dd class="It-tag">This option has the following syntax:
      &quot;id=x,streams=a,b,c id=y,streams=d,e&quot; where x and y are the
      unique identifiers of the adaptation sets and a,b,c,d and e are the
      indices of the corresponding audio and video streams. Any number of
      adaptation sets can be added using this option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>live</b></dt>
  <dd class="It-tag">Set this to 1 to create a live stream DASH Manifest.
      Default: 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>chunk_start_index</b></dt>
  <dd class="It-tag">Start index of the first chunk. This will go in the
      <b>startNumber</b> attribute of the <b>SegmentTemplate</b> element in the
      manifest. Default: 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>chunk_duration_ms</b></dt>
  <dd class="It-tag">Duration of each chunk in milliseconds. This will go in the
      <b>duration</b> attribute of the <b>SegmentTemplate</b> element in the
      manifest. Default: 1000.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>utc_timing_url</b></dt>
  <dd class="It-tag">URL of the page that will return the UTC timestamp in ISO
      format. This will go in the <b>value</b> attribute of the <b>UTCTiming</b>
      element in the manifest. Default: None.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>time_shift_buffer_depth</b></dt>
  <dd class="It-tag">Smallest time (in seconds) shifting buffer for which any
      Representation is guaranteed to be available. This will go in the
      <b>timeShiftBufferDepth</b> attribute of the <b>MPD</b> element. Default:
      60.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>minimum_update_period</b></dt>
  <dd class="It-tag">Minimum update period (in seconds) of the manifest. This
      will go in the <b>minimumUpdatePeriod</b> attribute of the <b>MPD</b>
      element. Default: 0.</dd>
</dl>
<div class="Pp"></div>
<i>Example</i>
<div class="Pp"></div>
<pre>
        ffmpeg -f webm_dash_manifest -i video1.webm \
               -f webm_dash_manifest -i video2.webm \
               -f webm_dash_manifest -i audio1.webm \
               -f webm_dash_manifest -i audio2.webm \
               -map 0 -map 1 -map 2 -map 3 \
               -c copy \
               -f webm_dash_manifest \
               -adaptation_sets &quot;id=0,streams=0,1 id=1,streams=2,3&quot; \
               manifest.xml
</pre>
<h2 class="Ss" title="Ss" id="webm_chunk"><a class="selflink" href="#webm_chunk">webm_chunk</a></h2>
WebM Live Chunk Muxer.
<div class="Pp"></div>
This muxer writes out WebM headers and chunks as separate files which can be
  consumed by clients that support WebM Live streams via DASH.
<div class="Pp"></div>
<i>Options</i>
<div class="Pp"></div>
This muxer supports the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>chunk_start_index</b></dt>
  <dd class="It-tag">Index of the first chunk (defaults to 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>header</b></dt>
  <dd class="It-tag">Filename of the header where the initialization data will
      be written.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>audio_chunk_duration</b></dt>
  <dd class="It-tag">Duration of each audio chunk in milliseconds (defaults to
      5000).</dd>
</dl>
<div class="Pp"></div>
<i>Example</i>
<div class="Pp"></div>
<pre>
        ffmpeg -f v4l2 -i /dev/video0 \
               -f alsa -i hw:0 \
               -map 0:0 \
               -c:v libvpx-vp9 \
               -s 640x360 -keyint_min 30 -g 30 \
               -f webm_chunk \
               -header webm_live_video_360.hdr \
               -chunk_start_index 1 \
               webm_live_video_360_%d.chk \
               -map 1:0 \
               -c:a libvorbis \
               -b:a 128k \
               -f webm_chunk \
               -header webm_live_audio_128.hdr \
               -chunk_start_index 1 \
               -audio_chunk_duration 1000 \
               webm_live_audio_128_%d.chk
</pre>
<h1 class="Sh" title="Sh" id="METADATA"><a class="selflink" href="#METADATA">METADATA</a></h1>
FFmpeg is able to dump metadata from media files into a simple UTF-8-encoded
  INI-like text file and then load it back using the metadata muxer/demuxer.
<div class="Pp"></div>
The file format is as follows:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">A file consists of a header and a number of metadata tags
      divided into sections, each on its own line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">The header is a <b>;FFMETADATA</b> string, followed by a
      version number (now 1).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Metadata tags are of the form <b>key=value</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">Immediately after header follows global metadata</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5.</dt>
  <dd class="It-tag">After global metadata there may be sections with
      per-stream/per-chapter metadata.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">6.</dt>
  <dd class="It-tag">A section starts with the section name in uppercase (i.e.
      STREAM or CHAPTER) in brackets ( <b>[</b>, <b>]</b>) and ends with next
      section or end of file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">7.</dt>
  <dd class="It-tag">At the beginning of a chapter section there may be an
      optional timebase to be used for start/end values. It must be in form
      <b>TIMEBASE=</b> <i>num</i><b>/</b><i>den</i>, where <i>num</i> and
      <i>den</i> are integers. If the timebase is missing then start/end times
      are assumed to be in milliseconds.
    <div style="height: 1.00em;">&#x00A0;</div>
    Next a chapter section must contain chapter start and end times in form
      <b>START=</b> <i>num</i>, <b>END=</b><i>num</i>, where <i>num</i> is a
      positive integer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">8.</dt>
  <dd class="It-tag">Empty lines and lines starting with <b>;</b> or <b>#</b>
      are ignored.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">9.</dt>
  <dd class="It-tag">Metadata keys or values containing special characters
      (<b>=</b>, <b>;</b>, <b>#</b>, <b>\</b> and a newline) must be escaped
      with a backslash <b>\</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">10.</dt>
  <dd class="It-tag">Note that whitespace in metadata (e.g. <b>foo = bar</b>) is
      considered to be a part of the tag (in the example above key is <b>foo</b>
      , value is
    <br/>
     <b>bar</b>).</dd>
</dl>
<div class="Pp"></div>
A ffmetadata file might look like this:
<div class="Pp"></div>
<pre>
        ;FFMETADATA1
        title=bike\\shed
        ;this is a comment
        artist=FFmpeg troll team
        
        [CHAPTER]
        TIMEBASE=1/1000
        START=0
        #chapter ends at 0:01:00
        END=60000
        title=chapter \#1
        [STREAM]
        title=multi\
        line
</pre>
<div class="Pp"></div>
By using the ffmetadata muxer and demuxer it is possible to extract metadata
  from an input file to an ffmetadata file, and then transcode the file into an
  output file with the edited ffmetadata file.
<div class="Pp"></div>
Extracting an ffmetadata file with <i>ffmpeg</i> goes as follows:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -f ffmetadata FFMETADATAFILE
</pre>
<div class="Pp"></div>
Reinserting edited metadata information from the FFMETADATAFILE file can be done
  as:
<div class="Pp"></div>
<pre>
        ffmpeg -i INPUT -i FFMETADATAFILE -map_metadata 1 -codec copy OUTPUT
</pre>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>ffmpeg</i>(1), <i>ffplay</i>(1), <i>ffprobe</i>(1), <i>ffserver</i>(1),
  <i>libavformat</i>(3)
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
The FFmpeg developers.
<div class="Pp"></div>
For details about the authorship, see the Git history of the project
  (git://source.ffmpeg.org/ffmpeg), e.g. by typing the command <b>git log</b> in
  the FFmpeg source directory, or browsing the online repository at &lt;
  <b>http://source.ffmpeg.org</b>&gt;.
<div class="Pp"></div>
Maintainers for the specific components are listed in the file
  <i>MAINTAINERS</i> in the source code tree.</div>
<table class="foot">
  <tr>
    <td class="foot-date"> </td>
    <td class="foot-os"> </td>
  </tr>
</table>
</body>
</html>
