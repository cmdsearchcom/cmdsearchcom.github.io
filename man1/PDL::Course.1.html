<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:21 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>COURSE(1) User Contributed Perl Documentation
COURSE(1)</p>

<p style="margin-top: 1em">NAME <br>
PDL::Course - A journey through PDL&rsquo;s documentation,
from beginner to advanced.</p>

<p style="margin-top: 1em">AUTHOR, DATE <br>
This is written by David Mertens with edits by Daniel
Carrera.</p>

<p style="margin-top: 1em">Preface <br>
PDL&rsquo;s documentation is extensive. Some sections cover
deep core magic while others cover more usual topics like IO
and numerical computation. How are these related? Where
should <br>
you begin?</p>

<p style="margin-top: 1em">This document is an attempt to
pull all the key PDL documentation together in a coherent
study course, starting from the beginner level, up to the
expert.</p>

<p style="margin-top: 1em">I&rsquo;ve broken down
everything by level of expertise, and within expertise
I&rsquo;ve covered documentation, library, and workflow
modules. The documentation modules are useful for what <br>
they tell you; the library modules are useful for the
functions that they define for you; the workflow modules are
useful for the way that they allow you to get your work done
in <br>
new and different ways.</p>

<p style="margin-top: 1em">Introductory <br>
If you are new to PDL, these documentation modules will get
you started down the right path for using PDL.</p>

<p style="margin-top: 1em">Documentation <br>
Modules that tell you how to start using PDL. Many of these
are library modules technically, but they are included when
you &quot;use PDL&quot;, so I&rsquo;ve included them for
their <br>
documentation.</p>

<p style="margin-top: 1em">After the first three, most of
the docs listed below are rather dry. Perhaps they would be
better summarized by tables or better synopses. You should
at least scan through them <br>
to familiarize yourself with the basic capabilities of
PDL.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Philosophy,
PDL::QuickStart</p>

<p style="margin-top: 1em">A couple of brief introductions
to PDL. The second one is a bit more hands-on. If you are
new to PDL, you should start with these.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Basic</p>

<p style="margin-top: 1em">Covers basic piddle-creation
routines like &quot;sequence&quot;, &quot;rvals&quot;, and
&quot;logxvals&quot; to name a random few. Also covers
&quot;hist&quot; and &quot;transpose&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Ufunc</p>

<p style="margin-top: 1em">Explains a large collection of
built-in functions which, given an N-dimension piddle, will
create a piddle with N-1 dimensions.</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::NiceSlice</p>

<p style="margin-top: 1em">PDL came of age right around the
turn of the millennium and NiceSlice came on the scene
slightly after that. Some of the docs still haven&rsquo;t
caught up. NiceSlice is the <br>
&rsquo;modern&rsquo; way to slice and dice your piddles.
Read the Synopsis, then scroll down to The New Slicing
Syntax. After you&rsquo;ve read to the bottom, return to and
read the stuff at <br>
the top.</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::Primitive</p>

<p style="margin-top: 1em">Defines a whole slew of useful
built-in functions. These are the sorts of things that
beginners are likely to write to the list and say, &quot;How
do I do xxx?&quot; You would be <br>
well on your way to learning the ropes after you&rsquo;ve
gotten through this document.</p>

<p style="margin-top: 1em">&Acirc;&middot; Selections from
PDL::Core</p>

<p style="margin-top: 1em">Like PDL::Primitive, defines a
large set of useful functions. Unfortunately, some of the
functions are quite esoteric, but are mixed in with the rest
of the simple and easy <br>
ones. Skim the whole document, skipping over the complicated
functions for now. I would point out in particular the
function &quot;approx&quot;.</p>

<p style="margin-top: 1em">Workflow <br>
&Acirc;&middot; The perldl or pdl2 Shell</p>

<p style="margin-top: 1em">The Perldl Shell is a REPL
(Read-Evaluate-Print-Loop, in other words, a prompt or
shell) that allows you to work with PDL (or any Perl, for
that matter) in &rsquo;real time&rsquo;, <br>
loading data from files, plotting, manipulating... Anything
you can do in a script, you can do in the PDL Shell, with
instant feedback!</p>

<p style="margin-top: 1em">Libraries <br>
&Acirc;&middot; PDL</p>

<p style="margin-top: 1em">The main workhorse module.
You&rsquo;ll include this in nearly every PDL program you
write.</p>

<p style="margin-top: 1em">Normal Usage <br>
The sorts of modules that you&rsquo;ll likely use on a
normal basis in scripts or from within the perldl shell.
Some of these modules you may never use, but you should
still be aware <br>
that they exist, just in case you need their
functionality.</p>

<p style="margin-top: 1em">Documentation <br>
&Acirc;&middot; PDL::Slices</p>

<p style="margin-top: 1em">In addition to explaining the
original slicing and dicing functions - for which you can
usually use PDL::NiceSlice - this also covers many
dimension-handling functions such <br>
as &quot;mv&quot;, &quot;xchg&quot;, and
&quot;reorder&quot;. This also thoroughly documents the
&quot;range&quot; function, which can be very powerful, and
covers a number of internal functions, which can <br>
probably be skipped.</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::Indexing</p>

<p style="margin-top: 1em">This covers a lot of the deeper
conceptual ground that you&rsquo;ll need to grasp to really
use PDL to its full potential. It gets more complex as you
go along, so don&rsquo;t be <br>
troubled if you find yourself loosing interest half way
through. However, reading this document all the way through
will bring you much closer to PDL enlightenment.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::IO</p>

<p style="margin-top: 1em">PDL has quite a few IO modules,
most of which are discussed in this summary module.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Tips</p>

<p style="margin-top: 1em">A collection of some of
Tuomas&rsquo;s ideas for making good use of PDL.</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::BadValues</p>

<p style="margin-top: 1em">Explains what bad values are and
how and why they are implemented.</p>

<p style="margin-top: 1em">&Acirc;&middot; Selections from
Inline::Pdlpp</p>

<p style="margin-top: 1em">Although writing PDL::PP code is
considered an Advanced topic, and is covered in the next
section, you should be aware that it is possible (and
surprisingly simple) to write <br>
PDL-aware code. You needn&rsquo;t read the whole thing at
this point, but to get some feel for how it works, you
should read everything up through the first example. A copy
of <br>
this documentation is contained in PDL::PP-Inline.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Objects</p>

<p style="margin-top: 1em">Explains how to subclass a
piddle object.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Index</p>

<p style="margin-top: 1em">This was discussed in the
Preface. It is an automatically generated file that lists
all of the PDL modules on your computer. There are many
modules that may be on your <br>
machine but which are not documented here, such as bindings
to the FFTW library, or GSL. Give it a read!</p>

<p style="margin-top: 1em">Libraries <br>
&Acirc;&middot; PDL::Complex</p>

<p style="margin-top: 1em">Complex number support. No, PDL
does not have complex number support built into the core,
but this should help you out.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::FFT</p>

<p style="margin-top: 1em">PDL&rsquo;s own Fast Fourier
Transform. If you have FFTW, then you should probably make
use of it; this is PDL&rsquo;s internal implementation and
should always be available.</p>

<p style="margin-top: 1em">&Acirc;&middot; GSL</p>

<p style="margin-top: 1em">PDL does not have bindings for
every sub-library in the GNU Scientific Library, but it has
quite a few. If you have GSL installed on your machine then
chances are decent that <br>
your PDL has the GSL bindings. For a full list of the GSL
bindings, check PDL::Index.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Func</p>

<p style="margin-top: 1em">A somewhat uniform interface to
the different interpolation modules in PDL.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Bad</p>

<p style="margin-top: 1em">Includes some basic bad-value
functionality, including functions to query if a piddle has
bad values (&quot;isbad&quot;) and functions to set certain
elements as bad (&quot;setbadat&quot; and <br>
&quot;setbadif&quot;). Among other places, bad values are
used in PDL::Graphics::PLplot&rsquo;s xyplot to make a gap
in a line plot.</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::DiskCache</p>

<p style="margin-top: 1em">A cool module that allows you to
tie a Perl array to a collection of files on your disk,
which will be loaded into and out of memory as piddles. If
you find yourself writing <br>
scripts to process many data files, especially if that data
processing is not necessarily in sequential order, you
should consider using PDL::DiskCache.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Char</p>

<p style="margin-top: 1em">A PDL subclass that allows you
to store and manipulate collections of fixed-length
character strings using PDL.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Image2D</p>

<p style="margin-top: 1em">A whole collection of methods
for manipulating images whose image data are stored in a
piddle. These include methods for convolutions (smoothing),
polygon fills, scaling, <br>
rotation, and warping, among others.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::ImageND</p>

<p style="margin-top: 1em">Contains a few functions that
are conceptually related to image processing, but which can
be defined for higher-dimensional data. For examples this
module defines high- <br>
dimensional convolution and interpolation, among others.</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::ImageRGB</p>

<p style="margin-top: 1em">Defines some useful functions
for working with RBG image data. It&rsquo;s not very
feature-full, but it may have something you need, and if
not, you can always add more!</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::Transform</p>

<p style="margin-top: 1em">Creates the transform class,
which allows you to create various coordinate transforms.
For example, if you data is a collection of Cartesian
coordinates, you could create a <br>
transform object to convert them to Spherical-Polar
coordinates (although many such standard coordinate
transformations are predefined for you, in this case
it&rsquo;s called <br>
&quot;t_spherical&quot;).</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::Opt::Simplex</p>

<p style="margin-top: 1em">This package states that it
&quot;implements the commonly used simplex optimization
algorithm.&quot; I&rsquo;m going to assume that if you need
this algorithm then you already know what it <br>
is.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Math</p>

<p style="margin-top: 1em">A collection of fairly standard
math functions, like the inverse trigonometric functions,
hyperbolic functions and their inverses, and others. This
module is included in the <br>
standard call to &quot;use PDL&quot;, but not in the Lite
versions.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Matrix</p>

<p style="margin-top: 1em">Provides a few functions that
use the standard mathematical Matrix notation of row-column
indexing rather than the PDL-standard column-row. It appears
that this module has <br>
not been heavily tested with other modules, so although it
should work with other modules, don&rsquo;t be surprised if
something breaks when you use it (and feel free to offer any
<br>
fixes that you may develop).</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::MatrixOps</p>

<p style="margin-top: 1em">Provides many standard matrix
operations for piddles, such as computing eigenvalues,
inverting square matrices, LU-decomposition, and solving a
system of linear equations. <br>
Though it is not built on PDL::Matrix, it should generally
work with that module. Also, the methods provided by this
module do not depend on external libraries such as <br>
Slatec or GSL.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Reduce</p>

<p style="margin-top: 1em">Implements an interface to all
the functions that return piddles with one less dimension
(for example, &quot;sumover&quot;), such that they can be
called by suppling their name, as a <br>
string.</p>

<p style="margin-top: 1em">Workflow <br>
&Acirc;&middot; PDL::AutoLoader</p>

<p style="margin-top: 1em">Enables Matlab-style
autoloading. When you call an unknown function, instead of
complaining and croaking, PDL will go hunt around in the
directories you specify in search of <br>
a like-named file. Particularly useful when used with the
Perldl Shell.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Dbg</p>

<p style="margin-top: 1em">Declares the &quot;px&quot;
function, which can be handy for debugging your PDL scripts
and/or perldl shell commands.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Options</p>

<p style="margin-top: 1em">Suppose you define a powerful,
versatile function. Chances are good that you&rsquo;ll
accept the arguments in the form of a hash or hashref. Now
you face the problem of <br>
processing that hashref. PDL::Options assists you in writing
code to process those options. (You&rsquo;d think Perl would
have tons of these sorts of modules lying around, but I <br>
couldn&rsquo;t find any.) Note this module does not depend
on PDL for its usage or installation.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::pdldoc</p>

<p style="margin-top: 1em">Ever fired-up the perldl shell
just to look up the help for a particular function? You can
use &quot;pdldoc&quot; instead. This shell script extracts
information from the help index <br>
without needing to start the perldl shell.</p>

<p style="margin-top: 1em">Advanced Usage <br>
The sorts of modules and documentation that you&rsquo;ll use
if you write modules that use PDL, or if you work on PDL
maintenance. These modules can be difficult to use, but
enable <br>
you to tackle some of your harder problems.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Lite,
PDL::LiteF</p>

<p style="margin-top: 1em">Lite-weight replacements for
&quot;use PDL&quot;, from the standpoint of namespace
pollution and load time.</p>

<p style="margin-top: 1em">&Acirc;&middot;
Inline::Pdlpp</p>

<p style="margin-top: 1em">This was mentioned earlier.
Before you begin reading about PDL::PP (next), you should
remind yourself about how to use this. Inline::Pdlpp will
help you experiment with <br>
PDL::PP without having to go through the trouble of building
a module and constructing makefiles (but see PDL::pptemplate
for help on that).</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::PP</p>

<p style="margin-top: 1em">The PDL Pre-Processor, which
vastly simplifies making you C or Fortran code play with
Perl and piddles. Most of PDL&rsquo;s basic functionality is
written using PDL::PP, so if <br>
you&rsquo;re thinking about how you might integrate some
numerical library written in C, look no further.</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::pptemplate</p>

<p style="margin-top: 1em">A script that automates the
creation of modules that use PDL::PP, which should make your
life as a module author a bit simpler.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::CallExt</p>

<p style="margin-top: 1em">Allows you to call functions
using external shared libraries. This is an alternative to
using PDL::PP. The major difference between PDL::PP and
PDL::CallExt is that the <br>
former will handle threading over implicit thread dimensions
for you, whereas PDL::CallExt simply calls an external
function. PDL::PP is generally the recommended way to <br>
interface your code with PDL, but it wouldn&rsquo;t be Perl
if there wasn&rsquo;t another way to do it.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Config</p>

<p style="margin-top: 1em">Defines the %PDL::Config hash,
which has lots of useful information pertinent to your PDL
build.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Doc</p>

<p style="margin-top: 1em">Explanation of the PDL
documentation conventions, and an interface to the PDL
Documentation parser. Following these guidelines when
writing documentation for PDL functions <br>
will ensure that your wonderful documentation is accessible
from the perldl shell and from calls to &quot;barf&quot;.
(Did you notice that &quot;barf&quot; used your
documentation? Time to <br>
reread PDL::Core...)</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::Exporter</p>

<p style="margin-top: 1em">A simple replacement for the
standard Exporter module. The only major difference is that
the default imported modules are those marked
&rsquo;:Func&rsquo;.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Types</p>

<p style="margin-top: 1em">Defines some useful functions
for getting a piddle&rsquo;s type, as well as getting
information about that type.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::Version</p>

<p style="margin-top: 1em">Simply defines the scalar
$PDL::Version::Version with the current version of PDL, as
defined in PDL.pm. This is most useful if you distribute
your own module on CPAN, use <br>
PDL::Lite or PDL::LiteF and want to make sure that your
users have a recent-enough version of PDL. Since the
variable is defined in PDL.pm, you don&rsquo;t need this
module if you <br>
&quot;use PDL&quot;.</p>

<p style="margin-top: 1em">Expert Usage <br>
&Acirc;&middot; PDL::Core::Dev</p>

<p style="margin-top: 1em">Provides some decently useful
functions that are pretty much only needed by the PDL
Porters.</p>

<p style="margin-top: 1em">&Acirc;&middot; PDL::API</p>

<p style="margin-top: 1em">Explains how to make a piddle by
hand, from Perl or your C source code, using the PDL
API.</p>

<p style="margin-top: 1em">&Acirc;&middot;
PDL::Internals</p>

<p style="margin-top: 1em">Explains the nitty-gritty of the
PDL data structures. After reading this (a few times :), you
should be able to create a piddle completely from scratch
(i.e. without using <br>
the PDL API). Put a little differently, if you want to
understand how PDL::PP works, you&rsquo;ll need to read
this.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright 2010 David Mertens (dcmertens.perl@gmail.com). You
can distribute and/or modify this document under the same
terms as the current Perl license.</p>

<p style="margin-top: 1em">See:
http://dev.perl.org/licenses/</p>

<p style="margin-top: 1em">perl v5.24.1 2015-08-12
COURSE(1)</p>
<hr>
</body>
</html>
