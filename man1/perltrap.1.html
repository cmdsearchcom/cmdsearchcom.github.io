<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLTRAP(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLTRAP(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLTRAP(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perltrap - Perl traps for the unwary
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The biggest trap of all is forgetting to &quot;use warnings&quot; or use the
  <b>-w</b> switch; see perllexwarn and perlrun. The second biggest trap is not
  making your entire program runnable under &quot;use strict&quot;. The third
  biggest trap is not reading the list of changes in this version of Perl; see
  perldelta.
<h2 class="Ss" title="Ss" id="Awk_Traps"><a class="selflink" href="#Awk_Traps">Awk
  Traps</a></h2>
Accustomed <b>awk</b> users should take special note of the following:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A Perl program executes only once, not once for each input
      line. You can do an implicit loop with &quot;-n&quot; or
    &quot;-p&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The English module, loaded via
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    use English;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    allows you to refer to special variables (like $/) with names (like $RS), as
      though they were in <b>awk</b>; see perlvar for details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Semicolons are required after all simple statements in Perl
      (except at the end of a block). Newline is not a statement delimiter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Curly brackets are required on &quot;if&quot;s and
      &quot;while&quot;s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Variables begin with &quot;$&quot;, &quot;@&quot; or
      &quot;%&quot; in Perl.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Arrays index from 0. Likewise string positions in
      <i>substr()</i> and <i>index()</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You have to decide whether your array has numeric or string
      indices.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Hash values do not spring into existence upon mere
      reference.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You have to decide whether you want to use string or
      numeric comparisons.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Reading an input line does not split it for you. You get to
      split it to an array yourself. And the <i>split()</i> operator has
      different arguments than <b>awk</b>'s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The current input line is normally in $_, not $0. It
      generally does not have the newline stripped. ($0 is the name of the
      program executed.) See perlvar.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">$&lt;<i>digit</i>&gt; does not refer to fields--it refers
      to substrings matched by the last match pattern.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The <i>print()</i> statement does not add field and record
      separators unless you set $, and &quot;$\&quot;. You can set $OFS and $ORS
      if you're using the English module.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You must open your files before you print to them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The range operator is &quot;..&quot;, not comma. The comma
      operator works as in C.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The match operator is &quot;=~&quot;, not &quot;~&quot;.
      (&quot;~&quot; is the one's complement operator, as in C.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The exponentiation operator is &quot;**&quot;, not
      &quot;^&quot;. &quot;^&quot; is the XOR operator, as in C. (You know, one
      could get the feeling that <b>awk</b> is basically incompatible with
    C.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The concatenation operator is &quot;.&quot;, not the null
      string. (Using the null string would render &quot;/pat/ /pat/&quot;
      unparsable, because the third slash would be interpreted as a division
      operator--the tokenizer is in fact slightly context sensitive for
      operators like &quot;/&quot;, &quot;?&quot;, and &quot;&gt;&quot;. And in
      fact, &quot;.&quot; itself can be the beginning of a number.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The &quot;next&quot;, &quot;exit&quot;, and
      &quot;continue&quot; keywords work differently.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The following variables work differently:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
      Awk       Perl
      ARGC      scalar @ARGV (compare with $#ARGV)
      ARGV[0]   $0
      FILENAME  $ARGV
      FNR       $. - something
      FS        (whatever you like)
      NF        $#Fld, or some such
      NR        $.
      OFMT      $#
      OFS       $,
      ORS       $\
      RLENGTH   length($&amp;)
      RS        $/
      RSTART    length($`)
      SUBSEP    $;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You cannot set $RS to a pattern, only a string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">When in doubt, run the <b>awk</b> construct through
      <b>a2p</b> and see what it gives you.</dd>
</dl>
<h2 class="Ss" title="Ss" id="C/C++_Traps"><a class="selflink" href="#C/C++_Traps">C/C++
  Traps</a></h2>
Cerebral C and C++ programmers should take note of the following:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Curly brackets are required on &quot;if&quot;'s and
      &quot;while&quot;'s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You must use &quot;elsif&quot; rather than &quot;else
      if&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The &quot;break&quot; and &quot;continue&quot; keywords
      from C become in Perl &quot;last&quot; and &quot;next&quot;, respectively.
      Unlike in C, these do <i>not</i> work within a &quot;do { } while&quot;
      construct. See &quot;Loop Control&quot; in perlsyn.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The switch statement is called &quot;given/when&quot; and
      only available in perl 5.10 or newer. See &quot;Switch Statements&quot; in
      perlsyn.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Variables begin with &quot;$&quot;, &quot;@&quot; or
      &quot;%&quot; in Perl.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Comments begin with &quot;#&quot;, not &quot;/*&quot; or
      &quot;//&quot;. Perl may interpret C/C++ comments as division operators,
      unterminated regular expressions or the defined-or operator.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can't take the address of anything, although a similar
      operator in Perl is the backslash, which creates a reference.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;ARGV&quot; must be capitalized. $ARGV[0] is C's
      &quot;argv[1]&quot;, and &quot;argv[0]&quot; ends up in $0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">System calls such as <i>link()</i>, <i>unlink()</i>,
      <i>rename()</i>, etc. return nonzero for success, not 0. (
      <i>system()</i>, however, returns zero for success.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Signal handlers deal with signal names, not numbers. Use
      &quot;kill -l&quot; to find their names on your system.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Sed_Traps"><a class="selflink" href="#Sed_Traps">Sed
  Traps</a></h2>
Seasoned <b>sed</b> programmers should take note of the following:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">A Perl program executes only once, not once for each input
      line. You can do an implicit loop with &quot;-n&quot; or
    &quot;-p&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Backreferences in substitutions use &quot;$&quot; rather
      than &quot;\&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The pattern matching metacharacters &quot;(&quot;,
      &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The range operator is &quot;...&quot;, rather than
    comma.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Shell_Traps"><a class="selflink" href="#Shell_Traps">Shell
  Traps</a></h2>
Sharp shell programmers should take note of the following:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The backtick operator does variable interpolation without
      regard to the presence of single quotes in the command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The backtick operator does no translation of the return
      value, unlike <b>csh</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Shells (especially <b>csh</b>) do several levels of
      substitution on each command line. Perl does substitution in only certain
      constructs such as double quotes, backticks, angle brackets, and search
      patterns.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Shells interpret scripts a little bit at a time. Perl
      compiles the entire program before executing it (except for
      &quot;BEGIN&quot; blocks, which execute at compile time).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The arguments are available via @ARGV, not $1, $2,
    etc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The environment is not automatically made available as
      separate scalar variables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The shell's &quot;test&quot; uses &quot;=&quot;,
      &quot;!=&quot;, &quot;&lt;&quot; etc for string comparisons and
      &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric
      comparisons. This is the reverse of Perl, which uses &quot;eq&quot;,
      &quot;ne&quot;, &quot;lt&quot; for string comparisons, and &quot;==&quot;,
      &quot;!=&quot; &quot;&lt;&quot; etc for numeric comparisons.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Perl_Traps"><a class="selflink" href="#Perl_Traps">Perl
  Traps</a></h2>
Practicing Perl Programmers should take note of the following:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Remember that many operations behave differently in a list
      context than they do in a scalar one. See perldata for details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Avoid barewords if you can, especially all lowercase ones.
      You can't tell by just looking at it whether a bareword is a function or a
      string. By using quotes on strings and parentheses on function calls, you
      won't ever get them confused.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You cannot discern from mere inspection which builtins are
      unary operators (like <i>chop()</i> and <i>chdir()</i>) and which are list
      operators (like <i>print()</i> and <i>unlink()</i>). (Unless prototyped,
      user-defined subroutines can <b>only</b> be list operators, never unary
      ones.) See perlop and perlsub.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">People have a hard time remembering that some functions
      default to $_, or @ARGV, or whatever, but that others which you might
      expect to do not.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The &lt;FH&gt; construct is not the name of the filehandle,
      it is a readline operation on that handle. The data read is assigned to $_
      only if the file read is the sole condition in a while loop:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    while (&lt;FH&gt;)      { }
    while (defined($_ = &lt;FH&gt;)) { }..
    &lt;FH&gt;;  # data discarded!
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Remember not to use &quot;=&quot; when you need
      &quot;=~&quot;; these two constructs are quite different:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $x =  /foo/;
    $x =~ /foo/;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The &quot;do {}&quot; construct isn't a real loop that you
      can use loop control on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Use &quot;my()&quot; for local variables whenever you can
      get away with it (but see perlform for where you can't). Using
      &quot;local()&quot; actually gives a local value to a global variable,
      which leaves you open to unforeseen side-effects of dynamic scoping.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">If you localize an exported variable in a module, its
      exported value will not change. The local name becomes an alias to a new
      value but the external name is still an alias for the original.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Perl4_to_Perl5_Traps"><a class="selflink" href="#Perl4_to_Perl5_Traps">Perl4
  to Perl5 Traps</a></h2>
Practicing Perl4 Programmers should take note of the following Perl4-to-Perl5
  specific traps.
<div class="Pp"></div>
They're crudely ordered according to the following list:
<dl class="Bl-tag">
  <dt class="It-tag">Discontinuance, Deprecation, and BugFix traps</dt>
  <dd class="It-tag">Anything that's been fixed as a perl4 bug, removed as a
      perl4 feature or deprecated as a perl4 feature with the intent to
      encourage usage of some other perl5 feature.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Parsing Traps</dt>
  <dd class="It-tag">Traps that appear to stem from the new parser.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Numerical Traps</dt>
  <dd class="It-tag">Traps having to do with numerical or mathematical
      operators.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">General data type traps</dt>
  <dd class="It-tag">Traps involving perl standard data types.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Context Traps - scalar, list contexts</dt>
  <dd class="It-tag">Traps related to context within lists, scalar
      statements/declarations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Precedence Traps</dt>
  <dd class="It-tag">Traps related to the precedence of parsing, evaluation, and
      execution of code.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">General Regular Expression Traps using s///, etc.</dt>
  <dd class="It-tag">Traps related to the use of pattern matching.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Subroutine, Signal, Sorting Traps</dt>
  <dd class="It-tag">Traps related to the use of signals and signal handlers,
      general subroutines, and sorting, along with sorting subroutines.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">OS Traps</dt>
  <dd class="It-tag">OS-specific traps.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">DBM Traps</dt>
  <dd class="It-tag">Traps specific to the use of &quot;dbmopen()&quot;, and
      specific dbm implementations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Unclassified Traps</dt>
  <dd class="It-tag">Everything else.</dd>
</dl>
<div class="Pp"></div>
If you find an example of a conversion trap that is not listed here, please
  submit it to &lt; <i>perlbug@perl.org</i>&gt; for inclusion. Also note that at
  least some of these can be caught with the &quot;use warnings&quot; pragma or
  the <b>-w</b> switch.
<h2 class="Ss" title="Ss" id="Discontinuance,_Deprecation,_and_BugFix_traps"><a class="selflink" href="#Discontinuance,_Deprecation,_and_BugFix_traps">Discontinuance,
  Deprecation, and BugFix traps</a></h2>
Anything that has been discontinued, deprecated, or fixed as a bug from perl4.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Symbols starting with &quot;_&quot; no longer forced into
      main
    <div style="height: 1.00em;">&#x00A0;</div>
    Symbols starting with &quot;_&quot; are no longer forced into package main,
      except for $_ itself (and @_, etc.).
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    package test;
    $_legacy = 1;
    package main;
    print &quot;\$_legacy is &quot;,$_legacy,&quot;\n&quot;;
    # perl4 prints: $_legacy is 1
    # perl5 prints: $_legacy is
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Double-colon valid package separator in variable name
    <div style="height: 1.00em;">&#x00A0;</div>
    Double-colon is now a valid package separator in a variable name. Thus these
      behave differently in perl4 vs. perl5, because the packages don't exist.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $a=1;$b=2;$c=3;$var=4;
    print &quot;$a::$b::$c &quot;;
    print &quot;$var::abc::xyz\n&quot;;
    # perl4 prints: 1::2::3 4::abc::xyz
    # perl5 prints: 3
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Given that &quot;::&quot; is now the preferred package delimiter, it is
      debatable whether this should be classed as a bug or not. (The older
      package delimiter, ' ,is used here)
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $x = 10;
    print &quot;x=${'x}\n&quot;;
    # perl4 prints: x=10
    # perl5 prints: Can't find string terminator &quot;'&quot; anywhere before EOF
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can avoid this problem, and remain compatible with perl4, if you always
      explicitly include the package name:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $x = 10;
    print &quot;x=${main'x}\n&quot;;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Also see precedence traps, for parsing $:.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">2nd and 3rd args to &quot;splice()&quot; are now in scalar
      context
    <div style="height: 1.00em;">&#x00A0;</div>
    The second and third arguments of &quot;splice()&quot; are now evaluated in
      scalar context (as the Camel says) rather than list context.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    sub sub1{return(0,2) }          # return a 2-element list
    sub sub2{ return(1,2,3)}        # return a 3-element list
    @a1 = (&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);
    @a2 = splice(@a1,&amp;sub1,&amp;sub2);
    print join(' ',@a2),&quot;\n&quot;;
    # perl4 prints: a b
    # perl5 prints: c d e
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Can't do &quot;goto&quot; into a block that is optimized
      away
    <div style="height: 1.00em;">&#x00A0;</div>
    You can't do a &quot;goto&quot; into a block that is optimized away. Darn.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    goto marker1;
    for(1){
    marker1:
        print &quot;Here I is!\n&quot;;
    }
    # perl4 prints: Here I is!
    # perl5 errors: Can't &quot;goto&quot; into the middle of a foreach loop
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Can't use whitespace as variable name or quote delimiter
    <div style="height: 1.00em;">&#x00A0;</div>
    It is no longer syntactically legal to use whitespace as the name of a
      variable, or as a delimiter for any kind of quote construct. Double darn.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $a = (&quot;foo bar&quot;);
    $b = q baz ;
    print &quot;a is $a, b is $b\n&quot;;
    # perl4 prints: a is foo bar, b is baz
    # perl5 errors: Bareword found where operator expected
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;while/if BLOCK BLOCK&quot; gone
    <div style="height: 1.00em;">&#x00A0;</div>
    The archaic while/if BLOCK BLOCK syntax is no longer supported.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    if { 1 } {
        print &quot;True!&quot;;
    }
    else {
        print &quot;False!&quot;;
    }
    # perl4 prints: True!
    # perl5 errors: syntax error at test.pl line 1, near &quot;if {&quot;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;**&quot; binds tighter than unary minus
    <div style="height: 1.00em;">&#x00A0;</div>
    The &quot;**&quot; operator now binds more tightly than unary minus. It was
      documented to work this way before, but didn't.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    print -4**2,&quot;\n&quot;;
    # perl4 prints: 16
    # perl5 prints: -16
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;foreach&quot; changed when iterating over a list
    <div style="height: 1.00em;">&#x00A0;</div>
    The meaning of &quot;foreach{}&quot; has changed slightly when it is
      iterating over a list which is not an array. This used to assign the list
      to a temporary array, but no longer does so (for efficiency). This means
      that you'll now be iterating over the actual values, not over copies of
      the values. Modifications to the loop variable can change the original
      values.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @list = ('ab','abc','bcd','def');
    foreach $var (grep(/ab/,@list)){
        $var = 1;
    }
    print (join(':',@list));
    # perl4 prints: ab:abc:bcd:def
    # perl5 prints: 1:1:bcd:def
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    To retain Perl4 semantics you need to assign your list explicitly to a
      temporary array and then iterate over that. For example, you might need to
      change
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    foreach $var (grep(/ab/,@list)){
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    to
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    foreach $var (@tmp = grep(/ab/,@list)){
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Otherwise changing $var will clobber the values of @list. (This most often
      happens when you use $_ for the loop variable, and call subroutines in the
      loop that don't properly localize $_.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;split&quot; with no args behavior changed
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;split&quot; with no arguments now behaves like &quot;split ' '&quot;
      (which doesn't return an initial null field if $_ starts with whitespace),
      it used to behave like &quot;split /\s+/&quot; (which does).
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $_ = ' hi mom';
    print join(':', split);
    # perl4 prints: :hi:mom
    # perl5 prints: hi:mom
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><b>-e</b> behavior fixed
    <div style="height: 1.00em;">&#x00A0;</div>
    Perl 4 would ignore any text which was attached to an <b>-e</b> switch,
      always taking the code snippet from the following arg. Additionally, it
      would silently accept an <b>-e</b> switch without a following arg. Both of
      these behaviors have been fixed.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    perl -e'print &quot;attached to -e&quot;' 'print &quot;separate arg&quot;'
    # perl4 prints: separate arg
    # perl5 prints: attached to -e
    perl -e
    # perl4 prints:
    # perl5 dies: No code specified for -e.
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;push&quot; returns number of elements in resulting
      list
    <div style="height: 1.00em;">&#x00A0;</div>
    In Perl 4 the return value of &quot;push&quot; was undocumented, but it was
      actually the last value being pushed onto the target list. In Perl 5 the
      return value of &quot;push&quot; is documented, but has changed, it is the
      number of elements in the resulting list.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @x = ('existing');
    print push(@x, 'first new', 'second new');
    # perl4 prints: second new
    # perl5 prints: 3
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Some error messages differ
    <div style="height: 1.00em;">&#x00A0;</div>
    Some error messages will be different.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;split()&quot; honors subroutine args
    <div style="height: 1.00em;">&#x00A0;</div>
    In Perl 4, if in list context the delimiters to the first argument of
      &quot;split()&quot; were &quot;??&quot;, the result would be placed in @_
      as well as being returned. Perl 5 has more respect for your subroutine
      arguments.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Bugs removed
    <div style="height: 1.00em;">&#x00A0;</div>
    Some bugs may have been inadvertently removed. :-)</dd>
</dl>
<h2 class="Ss" title="Ss" id="Parsing_Traps"><a class="selflink" href="#Parsing_Traps">Parsing
  Traps</a></h2>
Perl4-to-Perl5 traps from having to do with parsing.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Space between . and = triggers syntax error
    <div style="height: 1.00em;">&#x00A0;</div>
    Note the space between . and =
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $string . = &quot;more string&quot;;
    print $string;
    # perl4 prints: more string
    # perl5 prints: syntax error at - line 1, near &quot;. =&quot;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Better parsing in perl 5
    <div style="height: 1.00em;">&#x00A0;</div>
    Better parsing in perl 5
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    sub foo {}
    &amp;foo
    print(&quot;hello, world\n&quot;);
    # perl4 prints: hello, world
    # perl5 prints: syntax error
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Function parsing
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;if it looks like a function, it is a function&quot; rule.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
  print
    ($foo == 1) ? &quot;is one\n&quot; : &quot;is zero\n&quot;;
    # perl4 prints: is zero
    # perl5 warns: &quot;Useless use of a constant in void context&quot; if using -w
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">String interpolation of $#array differs
    <div style="height: 1.00em;">&#x00A0;</div>
    String interpolation of the $#array construct differs when braces are to
      used around the name.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @a = (1..3);
    print &quot;${#a}&quot;;
    # perl4 prints: 2
    # perl5 fails with syntax error
    @a = (1..3);
    print &quot;$#{a}&quot;;
    # perl4 prints: {a}
    # perl5 prints: 2
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Perl guesses on &quot;map&quot;, &quot;grep&quot; followed
      by &quot;{&quot; if it starts BLOCK or hash ref
    <div style="height: 1.00em;">&#x00A0;</div>
    When perl sees &quot;map {&quot; (or &quot;grep {&quot;), it has to guess
      whether the &quot;{&quot; starts a BLOCK or a hash reference. If it
      guesses wrong, it will report a syntax error near the &quot;}&quot; and
      the missing (or unexpected) comma.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use unary &quot;+&quot; before &quot;{&quot; on a hash reference, and unary
      &quot;+&quot; applied to the first thing in a BLOCK (after &quot;{&quot;),
      for perl to guess right all the time. (See &quot;map&quot; in
    perlfunc.)</dd>
</dl>
<h2 class="Ss" title="Ss" id="Numerical_Traps"><a class="selflink" href="#Numerical_Traps">Numerical
  Traps</a></h2>
Perl4-to-Perl5 traps having to do with numerical operators, operands, or output
  from same.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Formatted output and significant digits
    <div style="height: 1.00em;">&#x00A0;</div>
    Formatted output and significant digits. In general, Perl 5 tries to be more
      precise. For example, on a Solaris Sparc:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    print 7.373504 - 0, &quot;\n&quot;;
    printf &quot;%20.18f\n&quot;, 7.373504 - 0;
    # Perl4 prints:
    7.3750399999999996141
    7.375039999999999614
    # Perl5 prints:
    7.373504
    7.373503999999999614
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Notice how the first result looks better in Perl 5.
    <div style="height: 1.00em;">&#x00A0;</div>
    Your results may vary, since your floating point formatting routines and
      even floating point format may be slightly different.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Auto-increment operator over signed int limit deleted
    <div style="height: 1.00em;">&#x00A0;</div>
    This specific item has been deleted. It demonstrated how the auto-increment
      operator would not catch when a number went over the signed int limit.
      Fixed in version 5.003_04. But always be wary when using large integers.
      If in doubt:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
   use Math::BigInt;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Assignment of return values from numeric equality tests
      doesn't work
    <div style="height: 1.00em;">&#x00A0;</div>
    Assignment of return values from numeric equality tests does not work in
      perl5 when the test evaluates to false (0). Logical tests now return a
      null, instead of 0
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $p = ($test == 1);
    print $p,&quot;\n&quot;;
    # perl4 prints: 0
    # perl5 prints:
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Also see &quot;//, etc.&quot;&quot; in &quot;General Regular Expression
      Traps using s for another example of this new feature...</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Bitwise string ops
    <div style="height: 1.00em;">&#x00A0;</div>
    When bitwise operators which can operate upon either numbers or strings
      (&quot;&amp; | ^ ~&quot;) are given only strings as arguments, perl4 would
      treat the operands as bitstrings so long as the program contained a call
      to the &quot;vec()&quot; function. perl5 treats the string operands as
      bitstrings. (See &quot;Bitwise String Operators&quot; in perlop for more
      details.)
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $fred = &quot;10&quot;;
    $barney = &quot;12&quot;;
    $betty = $fred &amp; $barney;
    print &quot;$betty\n&quot;;
    # Uncomment the next line to change perl4's behavior
    # ($dummy) = vec(&quot;dummy&quot;, 0, 0);
    # Perl4 prints:
    8
    # Perl5 prints:
    10
    # If vec() is used anywhere in the program, both print:
    10
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="General_data_type_traps"><a class="selflink" href="#General_data_type_traps">General
  data type traps</a></h2>
Perl4-to-Perl5 traps involving most data-types, and their usage within certain
  expressions and/or context.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Negative array subscripts now count from the end of array
    <div style="height: 1.00em;">&#x00A0;</div>
    Negative array subscripts now count from the end of the array.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @a = (1, 2, 3, 4, 5);
    print &quot;The third element of the array is $a[3] also expressed as $a[-2] \n&quot;;
    # perl4 prints: The third element of the array is 4 also expressed as
    # perl5 prints: The third element of the array is 4 also expressed as 4
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Setting $#array lower now discards array elements
    <div style="height: 1.00em;">&#x00A0;</div>
    Setting $#array lower now discards array elements, and makes them impossible
      to recover.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @a = (a,b,c,d,e);
    print &quot;Before: &quot;,join('',@a);
    $#a =1;
    print &quot;, After: &quot;,join('',@a);
    $#a =3;
    print &quot;, Recovered: &quot;,join('',@a),&quot;\n&quot;;
    # perl4 prints: Before: abcde, After: ab, Recovered: abcd
    # perl5 prints: Before: abcde, After: ab, Recovered: ab
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Hashes get defined before use
    <div style="height: 1.00em;">&#x00A0;</div>
    Hashes get defined before use
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    local($s,@a,%h);
    die &quot;scalar \$s defined&quot; if defined($s);
    die &quot;array \@a defined&quot; if defined(@a);
    die &quot;hash \%h defined&quot; if defined(%h);
    # perl4 prints:
    # perl5 dies: hash %h defined
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Perl will now generate a warning when it sees defined(@a) and
    defined(%h).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Glob assignment from localized variable to variable
    <div style="height: 1.00em;">&#x00A0;</div>
    glob assignment from variable to variable will fail if the assigned variable
      is localized subsequent to the assignment
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @a = (&quot;This is Perl 4&quot;);
    *b = *a;
    local(@a);
    print @b,&quot;\n&quot;;
    # perl4 prints: This is Perl 4
    # perl5 prints:
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Assigning &quot;undef&quot; to glob
    <div style="height: 1.00em;">&#x00A0;</div>
    Assigning &quot;undef&quot; to a glob has no effect in Perl 5. In Perl 4 it
      undefines the associated scalar (but may have other side effects including
      SEGVs). Perl 5 will also warn if &quot;undef&quot; is assigned to a
      typeglob. (Note that assigning &quot;undef&quot; to a typeglob is
      different than calling the &quot;undef&quot; function on a typeglob
      (&quot;undef *foo&quot;), which has quite a few effects.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $foo = &quot;bar&quot;;
    *foo = undef;
    print $foo;
    # perl4 prints:
    # perl4 warns: &quot;Use of uninitialized variable&quot; if using -w
    # perl5 prints: bar
    # perl5 warns: &quot;Undefined value assigned to typeglob&quot; if using -w
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Changes in unary negation (of strings)
    <div style="height: 1.00em;">&#x00A0;</div>
    Changes in unary negation (of strings) This change effects both the return
      value and what it does to auto(magic)increment.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $x = &quot;aaa&quot;;
    print ++$x,&quot; : &quot;;
    print -$x,&quot; : &quot;;
    print ++$x,&quot;\n&quot;;
    # perl4 prints: aab : -0 : 1
    # perl5 prints: aab : -aab : aac
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Modifying of constants prohibited
    <div style="height: 1.00em;">&#x00A0;</div>
    perl 4 lets you modify constants:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $foo = &quot;x&quot;;
    &amp;mod($foo);
    for ($x = 0; $x &lt; 3; $x++) {
        &amp;mod(&quot;a&quot;);
    }
    sub mod {
        print &quot;before: $_[0]&quot;;
        $_[0] = &quot;m&quot;;
        print &quot;  after: $_[0]\n&quot;;
    }
    # perl4:
    # before: x  after: m
    # before: a  after: m
    # before: m  after: m
    # before: m  after: m
    # Perl5:
    # before: x  after: m
    # Modification of a read-only value attempted at foo.pl line 12.
    # before: a
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;defined $var&quot; behavior changed
    <div style="height: 1.00em;">&#x00A0;</div>
    The behavior is slightly different for:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    print &quot;$x&quot;, defined $x
    # perl 4: 1
    # perl 5: &lt;no output, $x is not called into existence&gt;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Variable Suicide
    <div style="height: 1.00em;">&#x00A0;</div>
    Variable suicide behavior is more consistent under Perl 5. Perl5 exhibits
      the same behavior for hashes and scalars, that perl4 exhibits for only
      scalars.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $aGlobal{ &quot;aKey&quot; } = &quot;global value&quot;;
    print &quot;MAIN:&quot;, $aGlobal{&quot;aKey&quot;}, &quot;\n&quot;;
    $GlobalLevel = 0;
    &amp;test( *aGlobal );
    sub test {
        local( *theArgument ) = @_;
        local( %aNewLocal ); # perl 4 != 5.001l,m
        $aNewLocal{&quot;aKey&quot;} = &quot;this should never appear&quot;;
        print &quot;SUB: &quot;, $theArgument{&quot;aKey&quot;}, &quot;\n&quot;;
        $aNewLocal{&quot;aKey&quot;} = &quot;level $GlobalLevel&quot;;   # what should print
        $GlobalLevel++;
        if( $GlobalLevel&lt;4 ) {
            &amp;test( *aNewLocal );
        }
    }
    # Perl4:
    # MAIN:global value
    # SUB: global value
    # SUB: level 0
    # SUB: level 1
    # SUB: level 2
    # Perl5:
    # MAIN:global value
    # SUB: global value
    # SUB: this should never appear
    # SUB: this should never appear
    # SUB: this should never appear
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="Context_Traps_-_scalar,_list_contexts"><a class="selflink" href="#Context_Traps_-_scalar,_list_contexts">Context
  Traps - scalar, list contexts</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Elements of argument lists for formats evaluated in list
      context
    <div style="height: 1.00em;">&#x00A0;</div>
    The elements of argument lists for formats are now evaluated in list
      context. This means you can interpolate list values now.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @fmt = (&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;);
    format STDOUT=
    @&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt;
    @fmt;
    .
    write;
    # perl4 errors:  Please use commas to separate fields in file
    # perl5 prints: foo     bar      baz
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;caller()&quot; returns false value in scalar context
      if no caller present
    <div style="height: 1.00em;">&#x00A0;</div>
    The &quot;caller()&quot; function now returns a false value in a scalar
      context if there is no caller. This lets library files determine if
      they're being required.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    caller() ? (print &quot;You rang?\n&quot;) : (print &quot;Got a 0\n&quot;);
    # perl4 errors: There is no caller
    # perl5 prints: Got a 0
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Comma operator in scalar context gives scalar context to
      args
    <div style="height: 1.00em;">&#x00A0;</div>
    The comma operator in a scalar context is now guaranteed to give a scalar
      context to its last argument. It gives scalar or void context to any
      preceding arguments, depending on circumstances.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @y= ('a','b','c');
    $x = (1, 2, @y);
    print &quot;x = $x\n&quot;;
    # Perl4 prints:  x = c   # Interpolates array @y into the list
    # Perl5 prints:  x = 3   # Evaluates array @y in scalar context
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;sprintf()&quot; prototyped as &quot;($;@)&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;sprintf()&quot; is prototyped as ($;@), so its first argument is given
      scalar context. Thus, if passed an array, it will probably not do what you
      want, unlike Perl 4:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @z = ('%s%s', 'foo', 'bar');
    $x = sprintf(@z);
    print $x;
    # perl4 prints: foobar
    # perl5 prints: 3
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;printf()&quot; works the same as it did in Perl 4, though:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @z = ('%s%s', 'foo', 'bar');
    printf STDOUT (@z);
    # perl4 prints: foobar
    # perl5 prints: foobar
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="Precedence_Traps"><a class="selflink" href="#Precedence_Traps">Precedence
  Traps</a></h2>
Perl4-to-Perl5 traps involving precedence order.
<div class="Pp"></div>
Perl 4 has almost the same precedence rules as Perl 5 for the operators that
  they both have. Perl 4 however, seems to have had some inconsistencies that
  made the behavior differ from what was documented.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LHS vs. RHS of any assignment operator
    <div style="height: 1.00em;">&#x00A0;</div>
    LHS vs. RHS of any assignment operator. LHS is evaluated first in perl4,
      second in perl5; this can affect the relationship between side-effects in
      sub-expressions.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @arr = ( 'left', 'right' );
    $a{shift @arr} = shift @arr;
    print join( ' ', keys %a );
    # perl4 prints: left
    # perl5 prints: right
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Semantic errors introduced due to precedence
    <div style="height: 1.00em;">&#x00A0;</div>
    These are now semantic errors because of precedence:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @list = (1,2,3,4,5);
    %map = (&quot;a&quot;,1,&quot;b&quot;,2,&quot;c&quot;,3,&quot;d&quot;,4);
    $n = shift @list + 2;   # first item in list plus 2
    print &quot;n is $n, &quot;;
    $m = keys %map + 2;     # number of items in hash plus 2
    print &quot;m is $m\n&quot;;
    # perl4 prints: n is 3, m is 6
    # perl5 errors and fails to compile
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Precedence of assignment operators same as the precedence
      of assignment
    <div style="height: 1.00em;">&#x00A0;</div>
    The precedence of assignment operators is now the same as the precedence of
      assignment. Perl 4 mistakenly gave them the precedence of the associated
      operator. So you now must parenthesize them in expressions like
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    /foo/ ? ($a += 2) : ($a -= 2);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Otherwise
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    /foo/ ? $a += 2 : $a -= 2
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    would be erroneously parsed as
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    (/foo/ ? $a += 2 : $a) -= 2;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    On the other hand,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $a += /foo/ ? 1 : 2;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    now works as a C programmer would expect.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;open&quot; requires parentheses around filehandle
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    open FOO || die;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    is now incorrect. You need parentheses around the filehandle. Otherwise,
      perl5 leaves the statement as its default precedence:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    open(FOO || die);
    # perl4 opens or dies
    # perl5 opens FOO, dying only if 'FOO' is false, i.e. never
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">$: precedence over $:: gone
    <div style="height: 1.00em;">&#x00A0;</div>
    perl4 gives the special variable, $: precedence, where perl5 treats $:: as
      main &quot;package&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $a = &quot;x&quot;; print &quot;$::a&quot;;
    # perl 4 prints: -:a
    # perl 5 prints: x
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Precedence of file test operators documented
    <div style="height: 1.00em;">&#x00A0;</div>
    perl4 had buggy precedence for the file test operators vis-a-vis the
      assignment operators. Thus, although the precedence table for perl4 leads
      one to believe &quot;-e $foo .= &quot;q&quot;&quot; should parse as
      &quot;((-e $foo) .= &quot;q&quot;)&quot;, it actually parses as &quot;(-e
      ($foo .= &quot;q&quot;))&quot;. In perl5, the precedence is as documented.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    -e $foo .= &quot;q&quot;
    # perl4 prints: no output
    # perl5 prints: Can't modify -e in concatenation
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;keys&quot;, &quot;each&quot;, &quot;values&quot; are
      regular named unary operators
    <div style="height: 1.00em;">&#x00A0;</div>
    In perl4, <i>keys()</i>, <i>each()</i> and <i>values()</i> were special
      high-precedence operators that operated on a single hash, but in perl5,
      they are regular named unary operators. As documented, named unary
      operators have lower precedence than the arithmetic and concatenation
      operators &quot;+ - .&quot;, but the perl4 variants of these operators
      actually bind tighter than &quot;+ - .&quot;. Thus, for:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    %foo = 1..10;
    print keys %foo - 1
    # perl4 prints: 4
    # perl5 prints: Type of arg 1 to keys must be hash (not subtraction)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The perl4 behavior was probably more useful, if less consistent.</dd>
</dl>
<h2 class="Ss" title="Ss" id="General_Regular_Expression_Traps_using_s///,_etc."><a class="selflink" href="#General_Regular_Expression_Traps_using_s///,_etc.">General
  Regular Expression Traps using s///, etc.</a></h2>
All types of RE traps.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;s'$lhs'$rhs'&quot; interpolates on either side
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;s'$lhs'$rhs'&quot; now does no interpolation on either side. It used
      to interpolate $lhs but not $rhs. (And still does not match a literal '$'
      in string)
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $a=1;$b=2;
    $string = '1 2 $a $b';
    $string =~ s'$a'$b';
    print $string,&quot;\n&quot;;
    # perl4 prints: $b 2 $a $b
    # perl5 prints: 1 2 $a $b
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;m//g&quot; attaches its state to the searched string
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;m//g&quot; now attaches its state to the searched string rather than
      the regular expression. (Once the scope of a block is left for the sub,
      the state of the searched string is lost)
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $_ = &quot;ababab&quot;;
    while(m/ab/g){
        &amp;doit(&quot;blah&quot;);
    }
    sub doit{local($_) = shift; print &quot;Got $_ &quot;}
    # perl4 prints: Got blah Got blah Got blah Got blah
    # perl5 prints: infinite loop blah...
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;m//o&quot; used within an anonymous sub
    <div style="height: 1.00em;">&#x00A0;</div>
    Currently, if you use the &quot;m//o&quot; qualifier on a regular expression
      within an anonymous sub, <i>all</i> closures generated from that anonymous
      sub will use the regular expression as it was compiled when it was used
      the very first time in any such closure. For instance, if you say
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    sub build_match {
        my($left,$right) = @_;
        return sub { $_[0] =~ /$left stuff $right/o; };
    }
    $good = build_match('foo','bar');
    $bad = build_match('baz','blarch');
    print $good-&gt;('foo stuff bar') ? &quot;ok\n&quot; : &quot;not ok\n&quot;;
    print $bad-&gt;('baz stuff blarch') ? &quot;ok\n&quot; : &quot;not ok\n&quot;;
    print $bad-&gt;('foo stuff bar') ? &quot;not ok\n&quot; : &quot;ok\n&quot;;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    For most builds of Perl5, this will print: ok not ok not ok
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>build_match()</i> will always return a sub which matches the contents of
      $left and $right as they were the <i>first</i> time that
      <i>build_match()</i> was called, not as they are in the current call.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">$+ isn't set to whole match
    <div style="height: 1.00em;">&#x00A0;</div>
    If no parentheses are used in a match, Perl4 sets $+ to the whole match,
      just like $&amp;. Perl5 does not.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    &quot;abcdef&quot; =~ /b.*e/;
    print &quot;\$+ = $+\n&quot;;
    # perl4 prints: bcde
    # perl5 prints:
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Substitution now returns null string if it fails
    <div style="height: 1.00em;">&#x00A0;</div>
    substitution now returns the null string if it fails
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $string = &quot;test&quot;;
    $value = ($string =~ s/foo//);
    print $value, &quot;\n&quot;;
    # perl4 prints: 0
    # perl5 prints:
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Also see &quot;Numerical Traps&quot; for another example of this new
      feature.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;s`lhs`rhs`&quot; is now a normal substitution
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;s`lhs`rhs`&quot; (using backticks) is now a normal substitution, with
      no backtick expansion
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $string = &quot;&quot;;
    $string =~ s`^`hostname`;
    print $string, &quot;\n&quot;;
    # perl4 prints: &lt;the local hostname&gt;
    # perl5 prints: hostname
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Stricter parsing of variables in regular expressions
    <div style="height: 1.00em;">&#x00A0;</div>
    Stricter parsing of variables used in regular expressions
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    s/^([^$grpc]*$grpc[$opt$plus$rep]?)//o;
    # perl4: compiles w/o error
    # perl5: with Scalar found where operator expected ..., near &quot;$opt$plus&quot;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    an added component of this example, apparently from the same script, is the
      actual value of the s'd string after the substitution. &quot;[$opt]&quot;
      is a character class in perl4 and an array subscript in perl5
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $grpc = 'a';
    $opt  = 'r';
    $_ = 'bar';
    s/^([^$grpc]*$grpc[$opt]?)/foo/;
    print;
    # perl4 prints: foo
    # perl5 prints: foobar
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;m?x?&quot; matches only once
    <div style="height: 1.00em;">&#x00A0;</div>
    Under perl5, &quot;m?x?&quot; matches only once, like &quot;?x?&quot;. Under
      perl4, it matched repeatedly, like &quot;/x/&quot; or &quot;m!x!&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $test = &quot;once&quot;;
    sub match { $test =~ m?once?; }
    &amp;match();
    if( &amp;match() ) {
        # m?x? matches more then once
        print &quot;perl4\n&quot;;
    } else {
        # m?x? matches only once
        print &quot;perl5\n&quot;;
    }
    # perl4 prints: perl4
    # perl5 prints: perl5
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Failed matches don't reset the match variables
    <div style="height: 1.00em;">&#x00A0;</div>
    Unlike in Ruby, failed matches in Perl do not reset the match variables ($1,
      $2, ..., &quot;$`&quot;, ...).</dd>
</dl>
<h2 class="Ss" title="Ss" id="Subroutine,_Signal,_Sorting_Traps"><a class="selflink" href="#Subroutine,_Signal,_Sorting_Traps">Subroutine,
  Signal, Sorting Traps</a></h2>
The general group of Perl4-to-Perl5 traps having to do with Signals, Sorting,
  and their related subroutines, as well as general subroutine traps. Includes
  some OS-Specific traps.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Barewords that used to look like strings look like
      subroutine calls
    <div style="height: 1.00em;">&#x00A0;</div>
    Barewords that used to look like strings to Perl will now look like
      subroutine calls if a subroutine by that name is defined before the
      compiler sees them.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    sub SeeYa { warn&quot;Hasta la vista, baby!&quot; }
    $SIG{'TERM'} = SeeYa;
    print &quot;SIGTERM is now $SIG{'TERM'}\n&quot;;
    # perl4 prints: SIGTERM is now main'SeeYa
    # perl5 prints: SIGTERM is now main::1 (and warns &quot;Hasta la vista, baby!&quot;)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Use <b>-w</b> to catch this one</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Reverse is no longer allowed as the name of a sort
      subroutine
    <div style="height: 1.00em;">&#x00A0;</div>
    reverse is no longer allowed as the name of a sort subroutine.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    sub reverse{ print &quot;yup &quot;; $a &lt;=&gt; $b }
    print sort reverse (2,1,3);
    # perl4 prints: yup yup 123
    # perl5 prints: 123
    # perl5 warns (if using -w): Ambiguous call resolved as CORE::reverse()
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;warn()&quot; won't let you specify a filehandle.
    <div style="height: 1.00em;">&#x00A0;</div>
    Although it _always_ printed to STDERR, <i>warn()</i> would let you specify
      a filehandle in perl4. With perl5 it does not.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    warn STDERR &quot;Foo!&quot;;
    # perl4 prints: Foo!
    # perl5 prints: String found where operator expected
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="OS_Traps"><a class="selflink" href="#OS_Traps">OS
  Traps</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">SysV resets signal handler correctly
    <div style="height: 1.00em;">&#x00A0;</div>
    Under HPUX, and some other SysV OSes, one had to reset any signal handler,
      within the signal handler function, each time a signal was handled with
      perl4. With perl5, the reset is now done correctly. Any code relying on
      the handler _not_ being reset will have to be reworked.
    <div style="height: 1.00em;">&#x00A0;</div>
    Since version 5.002, Perl uses <i>sigaction()</i> under SysV.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    sub gotit {
        print &quot;Got @_... &quot;;
    }
    $SIG{'INT'} = 'gotit';
    $| = 1;
    $pid = fork;
    if ($pid) {
        kill('INT', $pid);
        sleep(1);
        kill('INT', $pid);
    } else {
        while (1) {sleep(10);}
    }
    # perl4 (HPUX) prints: Got INT...
    # perl5 (HPUX) prints: Got INT... Got INT...
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">SysV &quot;seek()&quot; appends correctly
    <div style="height: 1.00em;">&#x00A0;</div>
    Under SysV OSes, &quot;seek()&quot; on a file opened to append
      &quot;&gt;&gt;&quot; now does the right thing w.r.t. the <i>fopen()</i>
      manpage. e.g., - When a file is opened for append, it is impossible to
      overwrite information already in the file.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    open(TEST,&quot;&gt;&gt;seek.test&quot;);
    $start = tell TEST;
    foreach(1 .. 9){
        print TEST &quot;$_ &quot;;
    }
    $end = tell TEST;
    seek(TEST,$start,0);
    print TEST &quot;18 characters here&quot;;
    # perl4 (solaris) seek.test has: 18 characters here
    # perl5 (solaris) seek.test has: 1 2 3 4 5 6 7 8 9 18 characters here
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="Interpolation_Traps"><a class="selflink" href="#Interpolation_Traps">Interpolation
  Traps</a></h2>
Perl4-to-Perl5 traps having to do with how things get interpolated within
  certain expressions, statements, contexts, or whatever.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;@&quot; always interpolates an array in
      double-quotish strings
    <div style="height: 1.00em;">&#x00A0;</div>
    @ now always interpolates an array in double-quotish strings.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    print &quot;To: someone@somewhere.com\n&quot;;
    # perl4 prints: To:someone@somewhere.com
    # perl &lt; 5.6.1, error : In string, @somewhere now must be written as \@somewhere
    # perl &gt;= 5.6.1, warning : Possible unintended interpolation of @somewhere in string
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Double-quoted strings may no longer end with an unescaped $
    <div style="height: 1.00em;">&#x00A0;</div>
    Double-quoted strings may no longer end with an unescaped $.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $foo = &quot;foo$&quot;;
    print &quot;foo is $foo\n&quot;;
    # perl4 prints: foo is foo$
    # perl5 errors: Final $ should be \$ or $name
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note: perl5 DOES NOT error on the terminating @ in $bar</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Arbitrary expressions are evaluated inside braces within
      double quotes
    <div style="height: 1.00em;">&#x00A0;</div>
    Perl now sometimes evaluates arbitrary expressions inside braces that occur
      within double quotes (usually when the opening brace is preceded by
      &quot;$&quot; or &quot;@&quot;).
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @www = &quot;buz&quot;;
    $foo = &quot;foo&quot;;
    $bar = &quot;bar&quot;;
    sub foo { return &quot;bar&quot; };
    print &quot;|@{w.w.w}|${main'foo}|&quot;;
    # perl4 prints: |@{w.w.w}|foo|
    # perl5 prints: |buz|bar|
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that you can &quot;use strict;&quot; to ward off such trappiness under
      perl5.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">$$x now tries to dereference $x
    <div style="height: 1.00em;">&#x00A0;</div>
    The construct &quot;this is $$x&quot; used to interpolate the pid at that
      point, but now tries to dereference $x. $$ by itself still works fine,
      however.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $s = &quot;a reference&quot;;
    $x = *s;
    print &quot;this is $$x\n&quot;;
    # perl4 prints: this is XXXx   (XXX is the current pid)
    # perl5 prints: this is a reference
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Creation of hashes on the fly with &quot;eval
      &quot;EXPR&quot;&quot; requires protection
    <div style="height: 1.00em;">&#x00A0;</div>
    Creation of hashes on the fly with &quot;eval &quot;EXPR&quot;&quot; now
      requires either both &quot;$&quot;'s to be protected in the specification
      of the hash name, or both curlies to be protected. If both curlies are
      protected, the result will be compatible with perl4 and perl5. This is a
      very common practice, and should be changed to use the block form of
      &quot;eval{}&quot; if possible.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $hashname = &quot;foobar&quot;;
    $key = &quot;baz&quot;;
    $value = 1234;
    eval &quot;\$$hashname{'$key'} = q|$value|&quot;;
    (defined($foobar{'baz'})) ?  (print &quot;Yup&quot;) : (print &quot;Nope&quot;);
    # perl4 prints: Yup
    # perl5 prints: Nope
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Changing
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    eval &quot;\$$hashname{'$key'} = q|$value|&quot;;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    to
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    eval &quot;\$\$hashname{'$key'} = q|$value|&quot;;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    causes the following result:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    # perl4 prints: Nope
    # perl5 prints: Yup
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    or, changing to
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    eval &quot;\$$hashname\{'$key'\} = q|$value|&quot;;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    causes the following result:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    # perl4 prints: Yup
    # perl5 prints: Yup
    # and is compatible for both versions
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Bugs in earlier perl versions
    <div style="height: 1.00em;">&#x00A0;</div>
    perl4 programs which unconsciously rely on the bugs in earlier perl
      versions.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    perl -e '$bar=q/not/; print &quot;This is $foo{$bar} perl5&quot;'
    # perl4 prints: This is not perl5
    # perl5 prints: This is perl5
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Array and hash brackets during interpolation
    <div style="height: 1.00em;">&#x00A0;</div>
    You also have to be careful about array and hash brackets during
      interpolation.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    print &quot;$foo[&quot;
    perl 4 prints: [
    perl 5 prints: syntax error
    print &quot;$foo{&quot;
    perl 4 prints: {
    perl 5 prints: syntax error
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Perl 5 is expecting to find an index or key name following the respective
      brackets, as well as an ending bracket of the appropriate type. In order
      to mimic the behavior of Perl 4, you must escape the bracket like so.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    print &quot;$foo\[&quot;;
    print &quot;$foo\{&quot;;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Interpolation of &quot;\$$foo{bar}&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Similarly, watch out for: &quot;\$$foo{bar}&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $foo = &quot;baz&quot;;
    print &quot;\$$foo{bar}\n&quot;;
    # perl4 prints: $baz{bar}
    # perl5 prints: $
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Perl 5 is looking for $foo{bar} which doesn't exist, but perl 4 is happy
      just to expand $foo to &quot;baz&quot; by itself. Watch out for this
      especially in &quot;eval&quot;'s.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;qq()&quot; string passed to &quot;eval&quot; will not
      find string terminator
    <div style="height: 1.00em;">&#x00A0;</div>
    &quot;qq()&quot; string passed to &quot;eval&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    eval qq(
        foreach \$y (keys %\$x\) {
            \$count++;
        }
    );
    # perl4 runs this ok
    # perl5 prints: Can't find string terminator &quot;)&quot;
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="DBM_Traps"><a class="selflink" href="#DBM_Traps">DBM
  Traps</a></h2>
General DBM traps.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Perl5 must have been linked with same dbm/ndbm as the
      default for &quot;dbmopen()&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Existing dbm databases created under perl4 (or any other dbm/ndbm tool) may
      cause the same script, run under perl5, to fail. The build of perl5 must
      have been linked with the same dbm/ndbm as the default for
      &quot;dbmopen()&quot; to function properly without &quot;tie&quot;'ing to
      an extension dbm implementation.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    dbmopen (%dbm, &quot;file&quot;, undef);
    print &quot;ok\n&quot;;
    # perl4 prints: ok
    # perl5 prints: ok (IFF linked with -ldbm or -lndbm)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">DBM exceeding limit on the key/value size will cause perl5
      to exit immediately
    <div style="height: 1.00em;">&#x00A0;</div>
    Existing dbm databases created under perl4 (or any other dbm/ndbm tool) may
      cause the same script, run under perl5, to fail. The error generated when
      exceeding the limit on the key/value size will cause perl5 to exit
      immediately.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    dbmopen(DB, &quot;testdb&quot;,0600) || die &quot;couldn't open db! $!&quot;;
    $DB{'trap'} = &quot;x&quot; x 1024;  # value too large for most dbm/ndbm
    print &quot;YUP\n&quot;;
    # perl4 prints:
    dbm store returned -1, errno 28, key &quot;trap&quot; at - line 3.
    YUP
    # perl5 prints:
    dbm store returned -1, errno 28, key &quot;trap&quot; at - line 3.
    </pre>
  </dd>
</dl>
<h2 class="Ss" title="Ss" id="Unclassified_Traps"><a class="selflink" href="#Unclassified_Traps">Unclassified
  Traps</a></h2>
Everything else.
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;require&quot;/&quot;do&quot; trap using returned
      value
    <div style="height: 1.00em;">&#x00A0;</div>
    If the file doit.pl has:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    sub foo {
        $rc = do &quot;./do.pl&quot;;
        return 8;
    }
    print &amp;foo, &quot;\n&quot;;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    And the do.pl file has the following single line:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    return 3;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Running doit.pl gives the following:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    # perl 4 prints: 3 (aborts the subroutine early)
    # perl 5 prints: 8
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Same behavior if you replace &quot;do&quot; with &quot;require&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&quot;split&quot; on empty string with LIMIT specified
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $string = '';
    @list = split(/foo/, $string, 2)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Perl4 returns a one element list containing the empty string but Perl5
      returns an empty list.</dd>
</dl>
<div class="Pp"></div>
As always, if any of these are ever officially declared as bugs, they'll be
  fixed and removed.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
