<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:12 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLTRAP(1) Perl Programmers Reference Guide
PERLTRAP(1)</p>

<p style="margin-top: 1em">NAME <br>
perltrap - Perl traps for the unwary</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The biggest trap of all is forgetting to &quot;use
warnings&quot; or use the -w switch; see perllexwarn and
perlrun. The second biggest trap is not making your entire
program runnable <br>
under &quot;use strict&quot;. The third biggest trap is not
reading the list of changes in this version of Perl; see
perldelta.</p>

<p style="margin-top: 1em">Awk Traps <br>
Accustomed awk users should take special note of the
following:</p>

<p style="margin-top: 1em">&Acirc;&middot; A Perl program
executes only once, not once for each input line. You can do
an implicit loop with &quot;-n&quot; or &quot;-p&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; The English
module, loaded via</p>

<p style="margin-top: 1em">use English;</p>

<p style="margin-top: 1em">allows you to refer to special
variables (like $/) with names (like $RS), as though they
were in awk; see perlvar for details.</p>

<p style="margin-top: 1em">&Acirc;&middot; Semicolons are
required after all simple statements in Perl (except at the
end of a block). Newline is not a statement delimiter.</p>

<p style="margin-top: 1em">&Acirc;&middot; Curly brackets
are required on &quot;if&quot;s and &quot;while&quot;s.</p>

<p style="margin-top: 1em">&Acirc;&middot; Variables begin
with &quot;$&quot;, &quot;@&quot; or &quot;%&quot; in
Perl.</p>

<p style="margin-top: 1em">&Acirc;&middot; Arrays index
from 0. Likewise string positions in substr() and
index().</p>

<p style="margin-top: 1em">&Acirc;&middot; You have to
decide whether your array has numeric or string indices.</p>

<p style="margin-top: 1em">&Acirc;&middot; Hash values do
not spring into existence upon mere reference.</p>

<p style="margin-top: 1em">&Acirc;&middot; You have to
decide whether you want to use string or numeric
comparisons.</p>

<p style="margin-top: 1em">&Acirc;&middot; Reading an input
line does not split it for you. You get to split it to an
array yourself. And the split() operator has different
arguments than awk&rsquo;s.</p>

<p style="margin-top: 1em">&Acirc;&middot; The current
input line is normally in $_, not $0. It generally does not
have the newline stripped. ($0 is the name of the program
executed.) See perlvar.</p>

<p style="margin-top: 1em">&Acirc;&middot; $&lt;digit&gt;
does not refer to fields--it refers to substrings matched by
the last match pattern.</p>

<p style="margin-top: 1em">&Acirc;&middot; The print()
statement does not add field and record separators unless
you set $, and &quot;$</p>

<p style="margin-top: 1em">&Acirc;&middot; You must open
your files before you print to them.</p>

<p style="margin-top: 1em">&Acirc;&middot; The range
operator is &quot;..&quot;, not comma. The comma operator
works as in C.</p>

<p style="margin-top: 1em">&Acirc;&middot; The match
operator is &quot;=~&quot;, not &quot;~&quot;.
(&quot;~&quot; is the one&rsquo;s complement operator, as in
C.)</p>

<p style="margin-top: 1em">&Acirc;&middot; The
exponentiation operator is &quot;**&quot;, not
&quot;^&quot;. &quot;^&quot; is the XOR operator, as in C.
(You know, one could get the feeling that awk is basically
incompatible with C.)</p>

<p style="margin-top: 1em">&Acirc;&middot; The
concatenation operator is &quot;.&quot;, not the null
string. (Using the null string would render &quot;/pat/
/pat/&quot; unparsable, because the third slash would be
interpreted as a <br>
division operator--the tokenizer is in fact slightly context
sensitive for operators like &quot;/&quot;, &quot;?&quot;,
and &quot;&gt;&quot;. And in fact, &quot;.&quot; itself can
be the beginning of a number.)</p>

<p style="margin-top: 1em">&Acirc;&middot; The
&quot;next&quot;, &quot;exit&quot;, and &quot;continue&quot;
keywords work differently.</p>

<p style="margin-top: 1em">&Acirc;&middot; The following
variables work differently:</p>

<p style="margin-top: 1em">Awk Perl <br>
ARGC scalar @ARGV (compare with $#ARGV) <br>
ARGV[0] $0 <br>
FILENAME $ARGV <br>
FNR $. - something <br>
FS (whatever you like) <br>
NF $#Fld, or some such <br>
NR $. <br>
OFMT $# <br>
OFS $, <br>
ORS $ RLENGTH length($&amp;) <br>
RS $/ <br>
RSTART length($&lsquo;) <br>
SUBSEP $;</p>

<p style="margin-top: 1em">&Acirc;&middot; You cannot set
$RS to a pattern, only a string.</p>

<p style="margin-top: 1em">&Acirc;&middot; When in doubt,
run the awk construct through a2p and see what it gives
you.</p>

<p style="margin-top: 1em">C/C++ Traps <br>
Cerebral C and C++ programmers should take note of the
following:</p>

<p style="margin-top: 1em">&Acirc;&middot; Curly brackets
are required on &quot;if&quot;&rsquo;s and
&quot;while&quot;&rsquo;s.</p>

<p style="margin-top: 1em">&Acirc;&middot; You must use
&quot;elsif&quot; rather than &quot;else if&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; The
&quot;break&quot; and &quot;continue&quot; keywords from C
become in Perl &quot;last&quot; and &quot;next&quot;,
respectively. Unlike in C, these do not work within a
&quot;do { } while&quot; construct. See &quot;Loop <br>
Control&quot; in perlsyn.</p>

<p style="margin-top: 1em">&Acirc;&middot; The switch
statement is called &quot;given/when&quot; and only
available in perl 5.10 or newer. See &quot;Switch
Statements&quot; in perlsyn.</p>

<p style="margin-top: 1em">&Acirc;&middot; Variables begin
with &quot;$&quot;, &quot;@&quot; or &quot;%&quot; in
Perl.</p>

<p style="margin-top: 1em">&Acirc;&middot; Comments begin
with &quot;#&quot;, not &quot;/*&quot; or &quot;//&quot;.
Perl may interpret C/C++ comments as division operators,
unterminated regular expressions or the defined-or
operator.</p>

<p style="margin-top: 1em">&Acirc;&middot; You can&rsquo;t
take the address of anything, although a similar operator in
Perl is the backslash, which creates a reference.</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;ARGV&quot;
must be capitalized. $ARGV[0] is C&rsquo;s
&quot;argv[1]&quot;, and &quot;argv[0]&quot; ends up in
$0.</p>

<p style="margin-top: 1em">&Acirc;&middot; System calls
such as link(), unlink(), rename(), etc. return nonzero for
success, not 0. (system(), however, returns zero for
success.)</p>

<p style="margin-top: 1em">&Acirc;&middot; Signal handlers
deal with signal names, not numbers. Use &quot;kill -l&quot;
to find their names on your system.</p>

<p style="margin-top: 1em">Sed Traps <br>
Seasoned sed programmers should take note of the
following:</p>

<p style="margin-top: 1em">&Acirc;&middot; A Perl program
executes only once, not once for each input line. You can do
an implicit loop with &quot;-n&quot; or &quot;-p&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; Backreferences
in substitutions use &quot;$&quot; rather than &quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; The pattern
matching metacharacters &quot;(&quot;, &quot;)&quot;, and
&quot;|&quot; do not have backslashes in front.</p>

<p style="margin-top: 1em">&Acirc;&middot; The range
operator is &quot;...&quot;, rather than comma.</p>

<p style="margin-top: 1em">Shell Traps <br>
Sharp shell programmers should take note of the
following:</p>

<p style="margin-top: 1em">&Acirc;&middot; The backtick
operator does variable interpolation without regard to the
presence of single quotes in the command.</p>

<p style="margin-top: 1em">&Acirc;&middot; The backtick
operator does no translation of the return value, unlike
csh.</p>

<p style="margin-top: 1em">&Acirc;&middot; Shells
(especially csh) do several levels of substitution on each
command line. Perl does substitution in only certain
constructs such as double quotes, backticks, angle <br>
brackets, and search patterns.</p>

<p style="margin-top: 1em">&Acirc;&middot; Shells interpret
scripts a little bit at a time. Perl compiles the entire
program before executing it (except for &quot;BEGIN&quot;
blocks, which execute at compile time).</p>

<p style="margin-top: 1em">&Acirc;&middot; The arguments
are available via @ARGV, not $1, $2, etc.</p>

<p style="margin-top: 1em">&Acirc;&middot; The environment
is not automatically made available as separate scalar
variables.</p>

<p style="margin-top: 1em">&Acirc;&middot; The
shell&rsquo;s &quot;test&quot; uses &quot;=&quot;,
&quot;!=&quot;, &quot;&lt;&quot; etc for string comparisons
and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc
for numeric comparisons. This is the reverse of Perl, which
uses &quot;eq&quot;, &quot;ne&quot;, <br>
&quot;lt&quot; for string comparisons, and &quot;==&quot;,
&quot;!=&quot; &quot;&lt;&quot; etc for numeric
comparisons.</p>

<p style="margin-top: 1em">Perl Traps <br>
Practicing Perl Programmers should take note of the
following:</p>

<p style="margin-top: 1em">&Acirc;&middot; Remember that
many operations behave differently in a list context than
they do in a scalar one. See perldata for details.</p>

<p style="margin-top: 1em">&Acirc;&middot; Avoid barewords
if you can, especially all lowercase ones. You can&rsquo;t
tell by just looking at it whether a bareword is a function
or a string. By using quotes on strings and <br>
parentheses on function calls, you won&rsquo;t ever get them
confused.</p>

<p style="margin-top: 1em">&Acirc;&middot; You cannot
discern from mere inspection which builtins are unary
operators (like chop() and chdir()) and which are list
operators (like print() and unlink()). (Unless <br>
prototyped, user-defined subroutines can only be list
operators, never unary ones.) See perlop and perlsub.</p>

<p style="margin-top: 1em">&Acirc;&middot; People have a
hard time remembering that some functions default to $_, or
@ARGV, or whatever, but that others which you might expect
to do not.</p>

<p style="margin-top: 1em">&Acirc;&middot; The &lt;FH&gt;
construct is not the name of the filehandle, it is a
readline operation on that handle. The data read is assigned
to $_ only if the file read is the sole condition <br>
in a while loop:</p>

<p style="margin-top: 1em">while (&lt;FH&gt;) { } <br>
while (defined($_ = &lt;FH&gt;)) { }.. <br>
&lt;FH&gt;; # data discarded!</p>

<p style="margin-top: 1em">&Acirc;&middot; Remember not to
use &quot;=&quot; when you need &quot;=~&quot;; these two
constructs are quite different:</p>

<p style="margin-top: 1em">$x = /foo/; <br>
$x =~ /foo/;</p>

<p style="margin-top: 1em">&Acirc;&middot; The &quot;do
{}&quot; construct isn&rsquo;t a real loop that you can use
loop control on.</p>

<p style="margin-top: 1em">&Acirc;&middot; Use
&quot;my()&quot; for local variables whenever you can get
away with it (but see perlform for where you can&rsquo;t).
Using &quot;local()&quot; actually gives a local value to a
global variable, <br>
which leaves you open to unforeseen side-effects of dynamic
scoping.</p>

<p style="margin-top: 1em">&Acirc;&middot; If you localize
an exported variable in a module, its exported value will
not change. The local name becomes an alias to a new value
but the external name is still an alias <br>
for the original.</p>

<p style="margin-top: 1em">Perl4 to Perl5 Traps <br>
Practicing Perl4 Programmers should take note of the
following Perl4-to-Perl5 specific traps.</p>

<p style="margin-top: 1em">They&rsquo;re crudely ordered
according to the following list:</p>

<p style="margin-top: 1em">Discontinuance, Deprecation, and
BugFix traps <br>
Anything that&rsquo;s been fixed as a perl4 bug, removed as
a perl4 feature or deprecated as a perl4 feature with the
intent to encourage usage of some other perl5 feature.</p>

<p style="margin-top: 1em">Parsing Traps <br>
Traps that appear to stem from the new parser.</p>

<p style="margin-top: 1em">Numerical Traps <br>
Traps having to do with numerical or mathematical
operators.</p>

<p style="margin-top: 1em">General data type traps <br>
Traps involving perl standard data types.</p>

<p style="margin-top: 1em">Context Traps - scalar, list
contexts <br>
Traps related to context within lists, scalar
statements/declarations.</p>

<p style="margin-top: 1em">Precedence Traps <br>
Traps related to the precedence of parsing, evaluation, and
execution of code.</p>

<p style="margin-top: 1em">General Regular Expression Traps
using s///, etc. <br>
Traps related to the use of pattern matching.</p>

<p style="margin-top: 1em">Subroutine, Signal, Sorting
Traps <br>
Traps related to the use of signals and signal handlers,
general subroutines, and sorting, along with sorting
subroutines.</p>

<p style="margin-top: 1em">OS Traps <br>
OS-specific traps.</p>

<p style="margin-top: 1em">DBM Traps <br>
Traps specific to the use of &quot;dbmopen()&quot;, and
specific dbm implementations.</p>

<p style="margin-top: 1em">Unclassified Traps <br>
Everything else.</p>

<p style="margin-top: 1em">If you find an example of a
conversion trap that is not listed here, please submit it to
&lt;perlbug@perl.org&gt; for inclusion. Also note that at
least some of these can be caught <br>
with the &quot;use warnings&quot; pragma or the -w
switch.</p>

<p style="margin-top: 1em">Discontinuance, Deprecation, and
BugFix traps <br>
Anything that has been discontinued, deprecated, or fixed as
a bug from perl4.</p>

<p style="margin-top: 1em">&Acirc;&middot; Symbols starting
with &quot;_&quot; no longer forced into main</p>

<p style="margin-top: 1em">Symbols starting with
&quot;_&quot; are no longer forced into package main, except
for $_ itself (and @_, etc.).</p>

<p style="margin-top: 1em">package test; <br>
$_legacy = 1;</p>

<p style="margin-top: 1em">package main; <br>
print &quot;legacy is &quot;,$_legacy,&quot;0;</p>

<p style="margin-top: 1em"># perl4 prints: $_legacy is 1
<br>
# perl5 prints: $_legacy is</p>

<p style="margin-top: 1em">&Acirc;&middot; Double-colon
valid package separator in variable name</p>

<p style="margin-top: 1em">Double-colon is now a valid
package separator in a variable name. Thus these behave
differently in perl4 vs. perl5, because the packages
don&rsquo;t exist.</p>

<p style="margin-top: 1em">$a=1;$b=2;$c=3;$var=4; <br>
print &quot;$a::$b::$c &quot;; <br>
print &quot;$var::abc::xyz0;</p>

<p style="margin-top: 1em"># perl4 prints: 1::2::3
4::abc::xyz <br>
# perl5 prints: 3</p>

<p style="margin-top: 1em">Given that &quot;::&quot; is now
the preferred package delimiter, it is debatable whether
this should be classed as a bug or not. (The older package
delimiter, &rsquo; ,is used here)</p>

<p style="margin-top: 1em">$x = 10; <br>
print &quot;x=${&rsquo;x}0;</p>

<p style="margin-top: 1em"># perl4 prints: x=10 <br>
# perl5 prints: Can&rsquo;t find string terminator
&quot;&rsquo;&quot; anywhere before EOF</p>

<p style="margin-top: 1em">You can avoid this problem, and
remain compatible with perl4, if you always explicitly
include the package name:</p>

<p style="margin-top: 1em">$x = 10; <br>
print &quot;x=${main&rsquo;x}0;</p>

<p style="margin-top: 1em">Also see precedence traps, for
parsing $:.</p>

<p style="margin-top: 1em">&Acirc;&middot; 2nd and 3rd args
to &quot;splice()&quot; are now in scalar context</p>

<p style="margin-top: 1em">The second and third arguments
of &quot;splice()&quot; are now evaluated in scalar context
(as the Camel says) rather than list context.</p>

<p style="margin-top: 1em">sub sub1{return(0,2) } # return
a 2-element list <br>
sub sub2{ return(1,2,3)} # return a 3-element list <br>
@a1 =
(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);
<br>
@a2 = splice(@a1,&amp;sub1,&amp;sub2); <br>
print join(&rsquo; &rsquo;,@a2),&quot;0;</p>

<p style="margin-top: 1em"># perl4 prints: a b <br>
# perl5 prints: c d e</p>

<p style="margin-top: 1em">&Acirc;&middot; Can&rsquo;t do
&quot;goto&quot; into a block that is optimized away</p>

<p style="margin-top: 1em">You can&rsquo;t do a
&quot;goto&quot; into a block that is optimized away.
Darn.</p>

<p style="margin-top: 1em">goto marker1;</p>

<p style="margin-top: 1em">for(1){ <br>
marker1: <br>
print &quot;Here I is!0; <br>
}</p>

<p style="margin-top: 1em"># perl4 prints: Here I is! <br>
# perl5 errors: Can&rsquo;t &quot;goto&quot; into the middle
of a foreach loop</p>

<p style="margin-top: 1em">&Acirc;&middot; Can&rsquo;t use
whitespace as variable name or quote delimiter</p>

<p style="margin-top: 1em">It is no longer syntactically
legal to use whitespace as the name of a variable, or as a
delimiter for any kind of quote construct. Double darn.</p>

<p style="margin-top: 1em">$a = (&quot;foo bar&quot;); <br>
$b = q baz ; <br>
print &quot;a is $a, b is $b0;</p>

<p style="margin-top: 1em"># perl4 prints: a is foo bar, b
is baz <br>
# perl5 errors: Bareword found where operator expected</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;while/if
BLOCK BLOCK&quot; gone</p>

<p style="margin-top: 1em">The archaic while/if BLOCK BLOCK
syntax is no longer supported.</p>

<p style="margin-top: 1em">if { 1 } { <br>
print &quot;True!&quot;; <br>
} <br>
else { <br>
print &quot;False!&quot;; <br>
}</p>

<p style="margin-top: 1em"># perl4 prints: True! <br>
# perl5 errors: syntax error at test.pl line 1, near
&quot;if {&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;**&quot;
binds tighter than unary minus</p>

<p style="margin-top: 1em">The &quot;**&quot; operator now
binds more tightly than unary minus. It was documented to
work this way before, but didn&rsquo;t.</p>

<p style="margin-top: 1em">print -4**2,&quot;0;</p>

<p style="margin-top: 1em"># perl4 prints: 16 <br>
# perl5 prints: -16</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;foreach&quot; changed when iterating over a list</p>

<p style="margin-top: 1em">The meaning of
&quot;foreach{}&quot; has changed slightly when it is
iterating over a list which is not an array. This used to
assign the list to a temporary array, but no longer does
<br>
so (for efficiency). This means that you&rsquo;ll now be
iterating over the actual values, not over copies of the
values. Modifications to the loop variable can change the
<br>
original values.</p>

<p style="margin-top: 1em">@list =
(&rsquo;ab&rsquo;,&rsquo;abc&rsquo;,&rsquo;bcd&rsquo;,&rsquo;def&rsquo;);
<br>
foreach $var (grep(/ab/,@list)){ <br>
$var = 1; <br>
} <br>
print (join(&rsquo;:&rsquo;,@list));</p>

<p style="margin-top: 1em"># perl4 prints: ab:abc:bcd:def
<br>
# perl5 prints: 1:1:bcd:def</p>

<p style="margin-top: 1em">To retain Perl4 semantics you
need to assign your list explicitly to a temporary array and
then iterate over that. For example, you might need to
change</p>

<p style="margin-top: 1em">foreach $var
(grep(/ab/,@list)){</p>

<p style="margin-top: 1em">to</p>

<p style="margin-top: 1em">foreach $var (@tmp =
grep(/ab/,@list)){</p>

<p style="margin-top: 1em">Otherwise changing $var will
clobber the values of @list. (This most often happens when
you use $_ for the loop variable, and call subroutines in
the loop that don&rsquo;t <br>
properly localize $_.)</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;split&quot; with no args behavior changed</p>

<p style="margin-top: 1em">&quot;split&quot; with no
arguments now behaves like &quot;split &rsquo; &rsquo;&quot;
(which doesn&rsquo;t return an initial null field if $_
starts with whitespace), it used to behave like &quot;split
/&quot; (which <br>
does).</p>

<p style="margin-top: 1em">$_ = &rsquo; hi mom&rsquo;; <br>
print join(&rsquo;:&rsquo;, split);</p>

<p style="margin-top: 1em"># perl4 prints: :hi:mom <br>
# perl5 prints: hi:mom</p>

<p style="margin-top: 1em">&Acirc;&middot; -e behavior
fixed</p>

<p style="margin-top: 1em">Perl 4 would ignore any text
which was attached to an -e switch, always taking the code
snippet from the following arg. Additionally, it would
silently accept an -e switch <br>
without a following arg. Both of these behaviors have been
fixed.</p>

<p style="margin-top: 1em">perl -e&rsquo;print
&quot;attached to -e&quot;&rsquo; &rsquo;print
&quot;separate arg&quot;&rsquo;</p>

<p style="margin-top: 1em"># perl4 prints: separate arg
<br>
# perl5 prints: attached to -e</p>

<p style="margin-top: 1em">perl -e</p>

<p style="margin-top: 1em"># perl4 prints: <br>
# perl5 dies: No code specified for -e.</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;push&quot;
returns number of elements in resulting list</p>

<p style="margin-top: 1em">In Perl 4 the return value of
&quot;push&quot; was undocumented, but it was actually the
last value being pushed onto the target list. In Perl 5 the
return value of &quot;push&quot; is <br>
documented, but has changed, it is the number of elements in
the resulting list.</p>

<p style="margin-top: 1em">@x = (&rsquo;existing&rsquo;);
<br>
print push(@x, &rsquo;first new&rsquo;, &rsquo;second
new&rsquo;);</p>

<p style="margin-top: 1em"># perl4 prints: second new <br>
# perl5 prints: 3</p>

<p style="margin-top: 1em">&Acirc;&middot; Some error
messages differ</p>

<p style="margin-top: 1em">Some error messages will be
different.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;split()&quot; honors subroutine args</p>

<p style="margin-top: 1em">In Perl 4, if in list context
the delimiters to the first argument of &quot;split()&quot;
were &quot;??&quot;, the result would be placed in @_ as
well as being returned. Perl 5 has more <br>
respect for your subroutine arguments.</p>

<p style="margin-top: 1em">&Acirc;&middot; Bugs removed</p>

<p style="margin-top: 1em">Some bugs may have been
inadvertently removed. :-)</p>

<p style="margin-top: 1em">Parsing Traps <br>
Perl4-to-Perl5 traps from having to do with parsing.</p>

<p style="margin-top: 1em">&Acirc;&middot; Space between .
and = triggers syntax error</p>

<p style="margin-top: 1em">Note the space between . and
=</p>

<p style="margin-top: 1em">$string . = &quot;more
string&quot;; <br>
print $string;</p>

<p style="margin-top: 1em"># perl4 prints: more string <br>
# perl5 prints: syntax error at - line 1, near &quot;.
=&quot;</p>

<p style="margin-top: 1em">&Acirc;&middot; Better parsing
in perl 5</p>

<p style="margin-top: 1em">Better parsing in perl 5</p>

<p style="margin-top: 1em">sub foo {} <br>
&amp;foo <br>
print(&quot;hello, world0);</p>

<p style="margin-top: 1em"># perl4 prints: hello, world
<br>
# perl5 prints: syntax error</p>

<p style="margin-top: 1em">&Acirc;&middot; Function
parsing</p>

<p style="margin-top: 1em">&quot;if it looks like a
function, it is a function&quot; rule.</p>

<p style="margin-top: 1em">print <br>
($foo == 1) ? &quot;is one0 : &quot;is zero0;</p>

<p style="margin-top: 1em"># perl4 prints: is zero <br>
# perl5 warns: &quot;Useless use of a constant in void
context&quot; if using -w</p>

<p style="margin-top: 1em">&Acirc;&middot; String
interpolation of $#array differs</p>

<p style="margin-top: 1em">String interpolation of the
$#array construct differs when braces are to used around the
name.</p>

<p style="margin-top: 1em">@a = (1..3); <br>
print &quot;${#a}&quot;;</p>

<p style="margin-top: 1em"># perl4 prints: 2 <br>
# perl5 fails with syntax error</p>

<p style="margin-top: 1em">@a = (1..3); <br>
print &quot;$#{a}&quot;;</p>

<p style="margin-top: 1em"># perl4 prints: {a} <br>
# perl5 prints: 2</p>

<p style="margin-top: 1em">&Acirc;&middot; Perl guesses on
&quot;map&quot;, &quot;grep&quot; followed by &quot;{&quot;
if it starts BLOCK or hash ref</p>

<p style="margin-top: 1em">When perl sees &quot;map {&quot;
(or &quot;grep {&quot;), it has to guess whether the
&quot;{&quot; starts a BLOCK or a hash reference. If it
guesses wrong, it will report a syntax error near the
&quot;}&quot; and <br>
the missing (or unexpected) comma.</p>

<p style="margin-top: 1em">Use unary &quot;+&quot; before
&quot;{&quot; on a hash reference, and unary &quot;+&quot;
applied to the first thing in a BLOCK (after &quot;{&quot;),
for perl to guess right all the time. (See &quot;map&quot;
in perlfunc.)</p>

<p style="margin-top: 1em">Numerical Traps <br>
Perl4-to-Perl5 traps having to do with numerical operators,
operands, or output from same.</p>

<p style="margin-top: 1em">&Acirc;&middot; Formatted output
and significant digits</p>

<p style="margin-top: 1em">Formatted output and significant
digits. In general, Perl 5 tries to be more precise. For
example, on a Solaris Sparc:</p>

<p style="margin-top: 1em">print 7.373504 - 0, &quot;0;
<br>
printf &quot;%20.18f0, 7.373504 - 0;</p>

<p style="margin-top: 1em"># Perl4 prints: <br>
7.3750399999999996141 <br>
7.375039999999999614</p>

<p style="margin-top: 1em"># Perl5 prints: <br>
7.373504 <br>
7.373503999999999614</p>

<p style="margin-top: 1em">Notice how the first result
looks better in Perl 5.</p>

<p style="margin-top: 1em">Your results may vary, since
your floating point formatting routines and even floating
point format may be slightly different.</p>

<p style="margin-top: 1em">&Acirc;&middot; Auto-increment
operator over signed int limit deleted</p>

<p style="margin-top: 1em">This specific item has been
deleted. It demonstrated how the auto-increment operator
would not catch when a number went over the signed int
limit. Fixed in version <br>
5.003_04. But always be wary when using large integers. If
in doubt:</p>

<p style="margin-top: 1em">use Math::BigInt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Assignment of
return values from numeric equality tests doesn&rsquo;t
work</p>

<p style="margin-top: 1em">Assignment of return values from
numeric equality tests does not work in perl5 when the test
evaluates to false (0). Logical tests now return a null,
instead of 0</p>

<p style="margin-top: 1em">$p = ($test == 1); <br>
print $p,&quot;0;</p>

<p style="margin-top: 1em"># perl4 prints: 0 <br>
# perl5 prints:</p>

<p style="margin-top: 1em">Also see &quot;//,
etc.&quot;&quot; in &quot;General Regular Expression Traps
using s for another example of this new feature...</p>

<p style="margin-top: 1em">&Acirc;&middot; Bitwise string
ops</p>

<p style="margin-top: 1em">When bitwise operators which can
operate upon either numbers or strings (&quot;&amp; | ^
~&quot;) are given only strings as arguments, perl4 would
treat the operands as bitstrings so long <br>
as the program contained a call to the &quot;vec()&quot;
function. perl5 treats the string operands as bitstrings.
(See &quot;Bitwise String Operators&quot; in perlop for more
details.)</p>

<p style="margin-top: 1em">$fred = &quot;10&quot;; <br>
$barney = &quot;12&quot;; <br>
$betty = $fred &amp; $barney; <br>
print &quot;$betty0; <br>
# Uncomment the next line to change perl4&rsquo;s behavior
<br>
# ($dummy) = vec(&quot;dummy&quot;, 0, 0);</p>

<p style="margin-top: 1em"># Perl4 prints: <br>
8</p>

<p style="margin-top: 1em"># Perl5 prints: <br>
10</p>

<p style="margin-top: 1em"># If vec() is used anywhere in
the program, both print: <br>
10</p>

<p style="margin-top: 1em">General data type traps <br>
Perl4-to-Perl5 traps involving most data-types, and their
usage within certain expressions and/or context.</p>

<p style="margin-top: 1em">&Acirc;&middot; Negative array
subscripts now count from the end of array</p>

<p style="margin-top: 1em">Negative array subscripts now
count from the end of the array.</p>

<p style="margin-top: 1em">@a = (1, 2, 3, 4, 5); <br>
print &quot;The third element of the array is $a[3] also
expressed as $a[-2] 0;</p>

<p style="margin-top: 1em"># perl4 prints: The third
element of the array is 4 also expressed as <br>
# perl5 prints: The third element of the array is 4 also
expressed as 4</p>

<p style="margin-top: 1em">&Acirc;&middot; Setting $#array
lower now discards array elements</p>

<p style="margin-top: 1em">Setting $#array lower now
discards array elements, and makes them impossible to
recover.</p>

<p style="margin-top: 1em">@a = (a,b,c,d,e); <br>
print &quot;Before: &quot;,join(&rsquo;&rsquo;,@a); <br>
$#a =1; <br>
print &quot;, After: &quot;,join(&rsquo;&rsquo;,@a); <br>
$#a =3; <br>
print &quot;, Recovered:
&quot;,join(&rsquo;&rsquo;,@a),&quot;0;</p>

<p style="margin-top: 1em"># perl4 prints: Before: abcde,
After: ab, Recovered: abcd <br>
# perl5 prints: Before: abcde, After: ab, Recovered: ab</p>

<p style="margin-top: 1em">&Acirc;&middot; Hashes get
defined before use</p>

<p style="margin-top: 1em">Hashes get defined before
use</p>

<p style="margin-top: 1em">local($s,@a,%h); <br>
die &quot;scalar defined&quot; if defined($s); <br>
die &quot;array @a defined&quot; if defined(@a); <br>
die &quot;hash h defined&quot; if defined(%h);</p>

<p style="margin-top: 1em"># perl4 prints: <br>
# perl5 dies: hash %h defined</p>

<p style="margin-top: 1em">Perl will now generate a warning
when it sees defined(@a) and defined(%h).</p>

<p style="margin-top: 1em">&Acirc;&middot; Glob assignment
from localized variable to variable</p>

<p style="margin-top: 1em">glob assignment from variable to
variable will fail if the assigned variable is localized
subsequent to the assignment</p>

<p style="margin-top: 1em">@a = (&quot;This is Perl
4&quot;); <br>
*b = *a; <br>
local(@a); <br>
print @b,&quot;0;</p>

<p style="margin-top: 1em"># perl4 prints: This is Perl 4
<br>
# perl5 prints:</p>

<p style="margin-top: 1em">&Acirc;&middot; Assigning
&quot;undef&quot; to glob</p>

<p style="margin-top: 1em">Assigning &quot;undef&quot; to a
glob has no effect in Perl 5. In Perl 4 it undefines the
associated scalar (but may have other side effects including
SEGVs). Perl 5 will also warn <br>
if &quot;undef&quot; is assigned to a typeglob. (Note that
assigning &quot;undef&quot; to a typeglob is different than
calling the &quot;undef&quot; function on a typeglob
(&quot;undef *foo&quot;), which has quite <br>
a few effects.</p>

<p style="margin-top: 1em">$foo = &quot;bar&quot;; <br>
*foo = undef; <br>
print $foo;</p>

<p style="margin-top: 1em"># perl4 prints: <br>
# perl4 warns: &quot;Use of uninitialized variable&quot; if
using -w <br>
# perl5 prints: bar <br>
# perl5 warns: &quot;Undefined value assigned to
typeglob&quot; if using -w</p>

<p style="margin-top: 1em">&Acirc;&middot; Changes in unary
negation (of strings)</p>

<p style="margin-top: 1em">Changes in unary negation (of
strings) This change effects both the return value and what
it does to auto(magic)increment.</p>

<p style="margin-top: 1em">$x = &quot;aaa&quot;; <br>
print ++$x,&quot; : &quot;; <br>
print -$x,&quot; : &quot;; <br>
print ++$x,&quot;0;</p>

<p style="margin-top: 1em"># perl4 prints: aab : -0 : 1
<br>
# perl5 prints: aab : -aab : aac</p>

<p style="margin-top: 1em">&Acirc;&middot; Modifying of
constants prohibited</p>

<p style="margin-top: 1em">perl 4 lets you modify
constants:</p>

<p style="margin-top: 1em">$foo = &quot;x&quot;; <br>
&amp;mod($foo); <br>
for ($x = 0; $x &lt; 3; $x++) { <br>
&amp;mod(&quot;a&quot;); <br>
} <br>
sub mod { <br>
print &quot;before: $_[0]&quot;; <br>
$_[0] = &quot;m&quot;; <br>
print &quot; after: $_[0]0; <br>
}</p>

<p style="margin-top: 1em"># perl4: <br>
# before: x after: m <br>
# before: a after: m <br>
# before: m after: m <br>
# before: m after: m</p>

<p style="margin-top: 1em"># Perl5: <br>
# before: x after: m <br>
# Modification of a read-only value attempted at foo.pl line
12. <br>
# before: a</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;defined
$var&quot; behavior changed</p>

<p style="margin-top: 1em">The behavior is slightly
different for:</p>

<p style="margin-top: 1em">print &quot;$x&quot;, defined
$x</p>

<p style="margin-top: 1em"># perl 4: 1 <br>
# perl 5: &lt;no output, $x is not called into
existence&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Variable
Suicide</p>

<p style="margin-top: 1em">Variable suicide behavior is
more consistent under Perl 5. Perl5 exhibits the same
behavior for hashes and scalars, that perl4 exhibits for
only scalars.</p>

<p style="margin-top: 1em">$aGlobal{ &quot;aKey&quot; } =
&quot;global value&quot;; <br>
print &quot;MAIN:&quot;, $aGlobal{&quot;aKey&quot;},
&quot;0; <br>
$GlobalLevel = 0; <br>
&amp;test( *aGlobal );</p>

<p style="margin-top: 1em">sub test { <br>
local( *theArgument ) = @_; <br>
local( %aNewLocal ); # perl 4 != 5.001l,m <br>
$aNewLocal{&quot;aKey&quot;} = &quot;this should never
appear&quot;; <br>
print &quot;SUB: &quot;, $theArgument{&quot;aKey&quot;},
&quot;0; <br>
$aNewLocal{&quot;aKey&quot;} = &quot;level
$GlobalLevel&quot;; # what should print <br>
$GlobalLevel++; <br>
if( $GlobalLevel&lt;4 ) { <br>
&amp;test( *aNewLocal ); <br>
} <br>
}</p>

<p style="margin-top: 1em"># Perl4: <br>
# MAIN:global value <br>
# SUB: global value <br>
# SUB: level 0 <br>
# SUB: level 1 <br>
# SUB: level 2</p>

<p style="margin-top: 1em"># Perl5: <br>
# MAIN:global value <br>
# SUB: global value <br>
# SUB: this should never appear <br>
# SUB: this should never appear <br>
# SUB: this should never appear</p>

<p style="margin-top: 1em">Context Traps - scalar, list
contexts <br>
&Acirc;&middot; Elements of argument lists for formats
evaluated in list context</p>

<p style="margin-top: 1em">The elements of argument lists
for formats are now evaluated in list context. This means
you can interpolate list values now.</p>

<p style="margin-top: 1em">@fmt =
(&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;); <br>
format STDOUT= <br>
@&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt; <br>
@fmt; <br>
. <br>
write;</p>

<p style="margin-top: 1em"># perl4 errors: Please use
commas to separate fields in file <br>
# perl5 prints: foo bar baz</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;caller()&quot; returns false value in scalar context
if no caller present</p>

<p style="margin-top: 1em">The &quot;caller()&quot;
function now returns a false value in a scalar context if
there is no caller. This lets library files determine if
they&rsquo;re being required.</p>

<p style="margin-top: 1em">caller() ? (print &quot;You
rang?0) : (print &quot;Got a 00);</p>

<p style="margin-top: 1em"># perl4 errors: There is no
caller <br>
# perl5 prints: Got a 0</p>

<p style="margin-top: 1em">&Acirc;&middot; Comma operator
in scalar context gives scalar context to args</p>

<p style="margin-top: 1em">The comma operator in a scalar
context is now guaranteed to give a scalar context to its
last argument. It gives scalar or void context to any
preceding arguments, depending <br>
on circumstances.</p>

<p style="margin-top: 1em">@y=
(&rsquo;a&rsquo;,&rsquo;b&rsquo;,&rsquo;c&rsquo;); <br>
$x = (1, 2, @y); <br>
print &quot;x = $x0;</p>

<p style="margin-top: 1em"># Perl4 prints: x = c #
Interpolates array @y into the list <br>
# Perl5 prints: x = 3 # Evaluates array @y in scalar
context</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;sprintf()&quot; prototyped as &quot;($;@)&quot;</p>

<p style="margin-top: 1em">&quot;sprintf()&quot; is
prototyped as ($;@), so its first argument is given scalar
context. Thus, if passed an array, it will probably not do
what you want, unlike Perl 4:</p>

<p style="margin-top: 1em">@z = (&rsquo;%s%s&rsquo;,
&rsquo;foo&rsquo;, &rsquo;bar&rsquo;); <br>
$x = sprintf(@z); <br>
print $x;</p>

<p style="margin-top: 1em"># perl4 prints: foobar <br>
# perl5 prints: 3</p>

<p style="margin-top: 1em">&quot;printf()&quot; works the
same as it did in Perl 4, though:</p>

<p style="margin-top: 1em">@z = (&rsquo;%s%s&rsquo;,
&rsquo;foo&rsquo;, &rsquo;bar&rsquo;); <br>
printf STDOUT (@z);</p>

<p style="margin-top: 1em"># perl4 prints: foobar <br>
# perl5 prints: foobar</p>

<p style="margin-top: 1em">Precedence Traps <br>
Perl4-to-Perl5 traps involving precedence order.</p>

<p style="margin-top: 1em">Perl 4 has almost the same
precedence rules as Perl 5 for the operators that they both
have. Perl 4 however, seems to have had some inconsistencies
that made the behavior differ <br>
from what was documented.</p>

<p style="margin-top: 1em">&Acirc;&middot; LHS vs. RHS of
any assignment operator</p>

<p style="margin-top: 1em">LHS vs. RHS of any assignment
operator. LHS is evaluated first in perl4, second in perl5;
this can affect the relationship between side-effects in
sub-expressions.</p>

<p style="margin-top: 1em">@arr = ( &rsquo;left&rsquo;,
&rsquo;right&rsquo; ); <br>
$a{shift @arr} = shift @arr; <br>
print join( &rsquo; &rsquo;, keys %a );</p>

<p style="margin-top: 1em"># perl4 prints: left <br>
# perl5 prints: right</p>

<p style="margin-top: 1em">&Acirc;&middot; Semantic errors
introduced due to precedence</p>

<p style="margin-top: 1em">These are now semantic errors
because of precedence:</p>

<p style="margin-top: 1em">@list = (1,2,3,4,5); <br>
%map =
(&quot;a&quot;,1,&quot;b&quot;,2,&quot;c&quot;,3,&quot;d&quot;,4);
<br>
$n = shift @list + 2; # first item in list plus 2 <br>
print &quot;n is $n, &quot;; <br>
$m = keys %map + 2; # number of items in hash plus 2 <br>
print &quot;m is $m0;</p>

<p style="margin-top: 1em"># perl4 prints: n is 3, m is 6
<br>
# perl5 errors and fails to compile</p>

<p style="margin-top: 1em">&Acirc;&middot; Precedence of
assignment operators same as the precedence of
assignment</p>

<p style="margin-top: 1em">The precedence of assignment
operators is now the same as the precedence of assignment.
Perl 4 mistakenly gave them the precedence of the associated
operator. So you now <br>
must parenthesize them in expressions like</p>

<p style="margin-top: 1em">/foo/ ? ($a += 2) : ($a -=
2);</p>

<p style="margin-top: 1em">Otherwise</p>

<p style="margin-top: 1em">/foo/ ? $a += 2 : $a -= 2</p>

<p style="margin-top: 1em">would be erroneously parsed
as</p>

<p style="margin-top: 1em">(/foo/ ? $a += 2 : $a) -= 2;</p>

<p style="margin-top: 1em">On the other hand,</p>

<p style="margin-top: 1em">$a += /foo/ ? 1 : 2;</p>

<p style="margin-top: 1em">now works as a C programmer
would expect.</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;open&quot;
requires parentheses around filehandle</p>

<p style="margin-top: 1em">open FOO || die;</p>

<p style="margin-top: 1em">is now incorrect. You need
parentheses around the filehandle. Otherwise, perl5 leaves
the statement as its default precedence:</p>

<p style="margin-top: 1em">open(FOO || die);</p>

<p style="margin-top: 1em"># perl4 opens or dies <br>
# perl5 opens FOO, dying only if &rsquo;FOO&rsquo; is false,
i.e. never</p>

<p style="margin-top: 1em">&Acirc;&middot; $: precedence
over $:: gone</p>

<p style="margin-top: 1em">perl4 gives the special
variable, $: precedence, where perl5 treats $:: as main
&quot;package&quot;</p>

<p style="margin-top: 1em">$a = &quot;x&quot;; print
&quot;$::a&quot;;</p>

<p style="margin-top: 1em"># perl 4 prints: -:a <br>
# perl 5 prints: x</p>

<p style="margin-top: 1em">&Acirc;&middot; Precedence of
file test operators documented</p>

<p style="margin-top: 1em">perl4 had buggy precedence for
the file test operators vis-a-vis the assignment operators.
Thus, although the precedence table for perl4 leads one to
believe &quot;-e $foo .= <br>
&quot;q&quot;&quot; should parse as &quot;((-e $foo) .=
&quot;q&quot;)&quot;, it actually parses as &quot;(-e ($foo
.= &quot;q&quot;))&quot;. In perl5, the precedence is as
documented.</p>

<p style="margin-top: 1em">-e $foo .= &quot;q&quot;</p>

<p style="margin-top: 1em"># perl4 prints: no output <br>
# perl5 prints: Can&rsquo;t modify -e in concatenation</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;keys&quot;, &quot;each&quot;, &quot;values&quot; are
regular named unary operators</p>

<p style="margin-top: 1em">In perl4, keys(), each() and
values() were special high-precedence operators that
operated on a single hash, but in perl5, they are regular
named unary operators. As <br>
documented, named unary operators have lower precedence than
the arithmetic and concatenation operators &quot;+ -
.&quot;, but the perl4 variants of these operators actually
bind <br>
tighter than &quot;+ - .&quot;. Thus, for:</p>

<p style="margin-top: 1em">%foo = 1..10; <br>
print keys %foo - 1</p>

<p style="margin-top: 1em"># perl4 prints: 4 <br>
# perl5 prints: Type of arg 1 to keys must be hash (not
subtraction)</p>

<p style="margin-top: 1em">The perl4 behavior was probably
more useful, if less consistent.</p>

<p style="margin-top: 1em">General Regular Expression Traps
using s///, etc. <br>
All types of RE traps.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;s&rsquo;$lhs&rsquo;$rhs&rsquo;&quot; interpolates on
either side</p>


<p style="margin-top: 1em">&quot;s&rsquo;$lhs&rsquo;$rhs&rsquo;&quot;
now does no interpolation on either side. It used to
interpolate $lhs but not $rhs. (And still does not match a
literal &rsquo;$&rsquo; in string)</p>

<p style="margin-top: 1em">$a=1;$b=2; <br>
$string = &rsquo;1 2 $a $b&rsquo;; <br>
$string =~ s&rsquo;$a&rsquo;$b&rsquo;; <br>
print $string,&quot;0;</p>

<p style="margin-top: 1em"># perl4 prints: $b 2 $a $b <br>
# perl5 prints: 1 2 $a $b</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;m//g&quot;
attaches its state to the searched string</p>

<p style="margin-top: 1em">&quot;m//g&quot; now attaches
its state to the searched string rather than the regular
expression. (Once the scope of a block is left for the sub,
the state of the searched string is <br>
lost)</p>

<p style="margin-top: 1em">$_ = &quot;ababab&quot;; <br>
while(m/ab/g){ <br>
&amp;doit(&quot;blah&quot;); <br>
} <br>
sub doit{local($_) = shift; print &quot;Got $_ &quot;}</p>

<p style="margin-top: 1em"># perl4 prints: Got blah Got
blah Got blah Got blah <br>
# perl5 prints: infinite loop blah...</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;m//o&quot;
used within an anonymous sub</p>

<p style="margin-top: 1em">Currently, if you use the
&quot;m//o&quot; qualifier on a regular expression within an
anonymous sub, all closures generated from that anonymous
sub will use the regular expression as <br>
it was compiled when it was used the very first time in any
such closure. For instance, if you say</p>

<p style="margin-top: 1em">sub build_match { <br>
my($left,$right) = @_; <br>
return sub { $_[0] =~ /$left stuff $right/o; }; <br>
} <br>
$good = build_match(&rsquo;foo&rsquo;,&rsquo;bar&rsquo;);
<br>
$bad = build_match(&rsquo;baz&rsquo;,&rsquo;blarch&rsquo;);
<br>
print $good-&gt;(&rsquo;foo stuff bar&rsquo;) ? &quot;ok0 :
&quot;not ok0; <br>
print $bad-&gt;(&rsquo;baz stuff blarch&rsquo;) ? &quot;ok0
: &quot;not ok0; <br>
print $bad-&gt;(&rsquo;foo stuff bar&rsquo;) ? &quot;not ok0
: &quot;ok0;</p>

<p style="margin-top: 1em">For most builds of Perl5, this
will print: ok not ok not ok</p>

<p style="margin-top: 1em">build_match() will always return
a sub which matches the contents of $left and $right as they
were the first time that build_match() was called, not as
they are in the <br>
current call.</p>

<p style="margin-top: 1em">&Acirc;&middot; $+ isn&rsquo;t
set to whole match</p>

<p style="margin-top: 1em">If no parentheses are used in a
match, Perl4 sets $+ to the whole match, just like $&amp;.
Perl5 does not.</p>

<p style="margin-top: 1em">&quot;abcdef&quot; =~ /b.*e/;
<br>
print &quot; = $+0;</p>

<p style="margin-top: 1em"># perl4 prints: bcde <br>
# perl5 prints:</p>

<p style="margin-top: 1em">&Acirc;&middot; Substitution now
returns null string if it fails</p>

<p style="margin-top: 1em">substitution now returns the
null string if it fails</p>

<p style="margin-top: 1em">$string = &quot;test&quot;; <br>
$value = ($string =~ s/foo//); <br>
print $value, &quot;0;</p>

<p style="margin-top: 1em"># perl4 prints: 0 <br>
# perl5 prints:</p>

<p style="margin-top: 1em">Also see &quot;Numerical
Traps&quot; for another example of this new feature.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;s&lsquo;lhs&lsquo;rhs&lsquo;&quot; is now a normal
substitution</p>


<p style="margin-top: 1em">&quot;s&lsquo;lhs&lsquo;rhs&lsquo;&quot;
(using backticks) is now a normal substitution, with no
backtick expansion</p>

<p style="margin-top: 1em">$string = &quot;&quot;; <br>
$string =~ s&lsquo;^&lsquo;hostname&lsquo;; <br>
print $string, &quot;0;</p>

<p style="margin-top: 1em"># perl4 prints: &lt;the local
hostname&gt; <br>
# perl5 prints: hostname</p>

<p style="margin-top: 1em">&Acirc;&middot; Stricter parsing
of variables in regular expressions</p>

<p style="margin-top: 1em">Stricter parsing of variables
used in regular expressions</p>


<p style="margin-top: 1em">s/^([^$grpc]*$grpc[$opt$plus$rep]?)//o;</p>

<p style="margin-top: 1em"># perl4: compiles w/o error <br>
# perl5: with Scalar found where operator expected ..., near
&quot;$opt$plus&quot;</p>

<p style="margin-top: 1em">an added component of this
example, apparently from the same script, is the actual
value of the s&rsquo;d string after the substitution.
&quot;[$opt]&quot; is a character class in perl4 <br>
and an array subscript in perl5</p>

<p style="margin-top: 1em">$grpc = &rsquo;a&rsquo;; <br>
$opt = &rsquo;r&rsquo;; <br>
$_ = &rsquo;bar&rsquo;; <br>
s/^([^$grpc]*$grpc[$opt]?)/foo/; <br>
print;</p>

<p style="margin-top: 1em"># perl4 prints: foo <br>
# perl5 prints: foobar</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;m?x?&quot;
matches only once</p>

<p style="margin-top: 1em">Under perl5, &quot;m?x?&quot;
matches only once, like &quot;?x?&quot;. Under perl4, it
matched repeatedly, like &quot;/x/&quot; or
&quot;m!x!&quot;.</p>

<p style="margin-top: 1em">$test = &quot;once&quot;; <br>
sub match { $test =~ m?once?; } <br>
&amp;match(); <br>
if( &amp;match() ) { <br>
# m?x? matches more then once <br>
print &quot;perl40; <br>
} else { <br>
# m?x? matches only once <br>
print &quot;perl50; <br>
}</p>

<p style="margin-top: 1em"># perl4 prints: perl4 <br>
# perl5 prints: perl5</p>

<p style="margin-top: 1em">&Acirc;&middot; Failed matches
don&rsquo;t reset the match variables</p>

<p style="margin-top: 1em">Unlike in Ruby, failed matches
in Perl do not reset the match variables ($1, $2, ...,
&quot;$&lsquo;&quot;, ...).</p>

<p style="margin-top: 1em">Subroutine, Signal, Sorting
Traps <br>
The general group of Perl4-to-Perl5 traps having to do with
Signals, Sorting, and their related subroutines, as well as
general subroutine traps. Includes some OS-Specific <br>
traps.</p>

<p style="margin-top: 1em">&Acirc;&middot; Barewords that
used to look like strings look like subroutine calls</p>

<p style="margin-top: 1em">Barewords that used to look like
strings to Perl will now look like subroutine calls if a
subroutine by that name is defined before the compiler sees
them.</p>

<p style="margin-top: 1em">sub SeeYa { warn&quot;Hasta la
vista, baby!&quot; } <br>
$SIG{&rsquo;TERM&rsquo;} = SeeYa; <br>
print &quot;SIGTERM is now $SIG{&rsquo;TERM&rsquo;}0;</p>

<p style="margin-top: 1em"># perl4 prints: SIGTERM is now
main&rsquo;SeeYa <br>
# perl5 prints: SIGTERM is now main::1 (and warns
&quot;Hasta la vista, baby!&quot;)</p>

<p style="margin-top: 1em">Use -w to catch this one</p>

<p style="margin-top: 1em">&Acirc;&middot; Reverse is no
longer allowed as the name of a sort subroutine</p>

<p style="margin-top: 1em">reverse is no longer allowed as
the name of a sort subroutine.</p>

<p style="margin-top: 1em">sub reverse{ print &quot;yup
&quot;; $a &lt;=&gt; $b } <br>
print sort reverse (2,1,3);</p>

<p style="margin-top: 1em"># perl4 prints: yup yup 123 <br>
# perl5 prints: 123 <br>
# perl5 warns (if using -w): Ambiguous call resolved as
CORE::reverse()</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;warn()&quot; won&rsquo;t let you specify a
filehandle.</p>

<p style="margin-top: 1em">Although it _always_ printed to
STDERR, warn() would let you specify a filehandle in perl4.
With perl5 it does not.</p>

<p style="margin-top: 1em">warn STDERR
&quot;Foo!&quot;;</p>

<p style="margin-top: 1em"># perl4 prints: Foo! <br>
# perl5 prints: String found where operator expected</p>

<p style="margin-top: 1em">OS Traps <br>
&Acirc;&middot; SysV resets signal handler correctly</p>

<p style="margin-top: 1em">Under HPUX, and some other SysV
OSes, one had to reset any signal handler, within the signal
handler function, each time a signal was handled with perl4.
With perl5, the <br>
reset is now done correctly. Any code relying on the handler
_not_ being reset will have to be reworked.</p>

<p style="margin-top: 1em">Since version 5.002, Perl uses
sigaction() under SysV.</p>

<p style="margin-top: 1em">sub gotit { <br>
print &quot;Got @_... &quot;; <br>
} <br>
$SIG{&rsquo;INT&rsquo;} = &rsquo;gotit&rsquo;;</p>

<p style="margin-top: 1em">$| = 1; <br>
$pid = fork; <br>
if ($pid) { <br>
kill(&rsquo;INT&rsquo;, $pid); <br>
sleep(1); <br>
kill(&rsquo;INT&rsquo;, $pid); <br>
} else { <br>
while (1) {sleep(10);} <br>
}</p>

<p style="margin-top: 1em"># perl4 (HPUX) prints: Got
INT... <br>
# perl5 (HPUX) prints: Got INT... Got INT...</p>

<p style="margin-top: 1em">&Acirc;&middot; SysV
&quot;seek()&quot; appends correctly</p>

<p style="margin-top: 1em">Under SysV OSes,
&quot;seek()&quot; on a file opened to append
&quot;&gt;&gt;&quot; now does the right thing w.r.t. the
fopen() manpage. e.g., - When a file is opened for append,
it is impossible <br>
to overwrite information already in the file.</p>


<p style="margin-top: 1em">open(TEST,&quot;&gt;&gt;seek.test&quot;);
<br>
$start = tell TEST; <br>
foreach(1 .. 9){ <br>
print TEST &quot;$_ &quot;; <br>
} <br>
$end = tell TEST; <br>
seek(TEST,$start,0); <br>
print TEST &quot;18 characters here&quot;;</p>

<p style="margin-top: 1em"># perl4 (solaris) seek.test has:
18 characters here <br>
# perl5 (solaris) seek.test has: 1 2 3 4 5 6 7 8 9 18
characters here</p>

<p style="margin-top: 1em">Interpolation Traps <br>
Perl4-to-Perl5 traps having to do with how things get
interpolated within certain expressions, statements,
contexts, or whatever.</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;@&quot;
always interpolates an array in double-quotish strings</p>

<p style="margin-top: 1em">@ now always interpolates an
array in double-quotish strings.</p>

<p style="margin-top: 1em">print &quot;To:
someone@somewhere.com0;</p>

<p style="margin-top: 1em"># perl4 prints:
To:someone@somewhere.com <br>
# perl &lt; 5.6.1, error : In string, @somewhere now must be
written as @somewhere <br>
# perl &gt;= 5.6.1, warning : Possible unintended
interpolation of @somewhere in string</p>

<p style="margin-top: 1em">&Acirc;&middot; Double-quoted
strings may no longer end with an unescaped $</p>

<p style="margin-top: 1em">Double-quoted strings may no
longer end with an unescaped $.</p>

<p style="margin-top: 1em">$foo = &quot;foo$&quot;; <br>
print &quot;foo is $foo0;</p>

<p style="margin-top: 1em"># perl4 prints: foo is foo$ <br>
# perl5 errors: Final $ should be or $name</p>

<p style="margin-top: 1em">Note: perl5 DOES NOT error on
the terminating @ in $bar</p>

<p style="margin-top: 1em">&Acirc;&middot; Arbitrary
expressions are evaluated inside braces within double
quotes</p>

<p style="margin-top: 1em">Perl now sometimes evaluates
arbitrary expressions inside braces that occur within double
quotes (usually when the opening brace is preceded by
&quot;$&quot; or &quot;@&quot;).</p>

<p style="margin-top: 1em">@www = &quot;buz&quot;; <br>
$foo = &quot;foo&quot;; <br>
$bar = &quot;bar&quot;; <br>
sub foo { return &quot;bar&quot; }; <br>
print &quot;|@{w.w.w}|${main&rsquo;foo}|&quot;;</p>

<p style="margin-top: 1em"># perl4 prints: |@{w.w.w}|foo|
<br>
# perl5 prints: |buz|bar|</p>

<p style="margin-top: 1em">Note that you can &quot;use
strict;&quot; to ward off such trappiness under perl5.</p>

<p style="margin-top: 1em">&Acirc;&middot; $$x now tries to
dereference $x</p>

<p style="margin-top: 1em">The construct &quot;this is
$$x&quot; used to interpolate the pid at that point, but now
tries to dereference $x. $$ by itself still works fine,
however.</p>

<p style="margin-top: 1em">$s = &quot;a reference&quot;;
<br>
$x = *s; <br>
print &quot;this is $$x0;</p>

<p style="margin-top: 1em"># perl4 prints: this is XXXx
(XXX is the current pid) <br>
# perl5 prints: this is a reference</p>

<p style="margin-top: 1em">&Acirc;&middot; Creation of
hashes on the fly with &quot;eval &quot;EXPR&quot;&quot;
requires protection</p>

<p style="margin-top: 1em">Creation of hashes on the fly
with &quot;eval &quot;EXPR&quot;&quot; now requires either
both &quot;$&quot;&rsquo;s to be protected in the
specification of the hash name, or both curlies to be
protected. If <br>
both curlies are protected, the result will be compatible
with perl4 and perl5. This is a very common practice, and
should be changed to use the block form of
&quot;eval{}&quot; if <br>
possible.</p>

<p style="margin-top: 1em">$hashname = &quot;foobar&quot;;
<br>
$key = &quot;baz&quot;; <br>
$value = 1234; <br>
eval &quot;hashname{&rsquo;$key&rsquo;} = q|$value|&quot;;
<br>
(defined($foobar{&rsquo;baz&rsquo;})) ? (print
&quot;Yup&quot;) : (print &quot;Nope&quot;);</p>

<p style="margin-top: 1em"># perl4 prints: Yup <br>
# perl5 prints: Nope</p>

<p style="margin-top: 1em">Changing</p>

<p style="margin-top: 1em">eval
&quot;hashname{&rsquo;$key&rsquo;} = q|$value|&quot;;</p>

<p style="margin-top: 1em">to</p>

<p style="margin-top: 1em">eval
&quot;shname{&rsquo;$key&rsquo;} = q|$value|&quot;;</p>

<p style="margin-top: 1em">causes the following result:</p>

<p style="margin-top: 1em"># perl4 prints: Nope <br>
# perl5 prints: Yup</p>

<p style="margin-top: 1em">or, changing to</p>

<p style="margin-top: 1em">eval
&quot;hashname&rsquo;$key&rsquo; = q|$value|&quot;;</p>

<p style="margin-top: 1em">causes the following result:</p>

<p style="margin-top: 1em"># perl4 prints: Yup <br>
# perl5 prints: Yup <br>
# and is compatible for both versions</p>

<p style="margin-top: 1em">&Acirc;&middot; Bugs in earlier
perl versions</p>

<p style="margin-top: 1em">perl4 programs which
unconsciously rely on the bugs in earlier perl versions.</p>

<p style="margin-top: 1em">perl -e &rsquo;$bar=q/not/;
print &quot;This is $foo{$bar} perl5&quot;&rsquo;</p>

<p style="margin-top: 1em"># perl4 prints: This is not
perl5 <br>
# perl5 prints: This is perl5</p>

<p style="margin-top: 1em">&Acirc;&middot; Array and hash
brackets during interpolation</p>

<p style="margin-top: 1em">You also have to be careful
about array and hash brackets during interpolation.</p>

<p style="margin-top: 1em">print &quot;$foo[&quot;</p>

<p style="margin-top: 1em">perl 4 prints: [ <br>
perl 5 prints: syntax error</p>

<p style="margin-top: 1em">print &quot;$foo{&quot;</p>

<p style="margin-top: 1em">perl 4 prints: { <br>
perl 5 prints: syntax error</p>

<p style="margin-top: 1em">Perl 5 is expecting to find an
index or key name following the respective brackets, as well
as an ending bracket of the appropriate type. In order to
mimic the behavior of <br>
Perl 4, you must escape the bracket like so.</p>

<p style="margin-top: 1em">print &quot;$foo <br>
print &quot;$foo&quot;;</p>

<p style="margin-top: 1em">&Acirc;&middot; Interpolation of
&quot;foo{bar}&quot;</p>

<p style="margin-top: 1em">Similarly, watch out for:
&quot;foo{bar}&quot;</p>

<p style="margin-top: 1em">$foo = &quot;baz&quot;; <br>
print &quot;foo{bar}0;</p>

<p style="margin-top: 1em"># perl4 prints: $baz{bar} <br>
# perl5 prints: $</p>

<p style="margin-top: 1em">Perl 5 is looking for $foo{bar}
which doesn&rsquo;t exist, but perl 4 is happy just to
expand $foo to &quot;baz&quot; by itself. Watch out for this
especially in &quot;eval&quot;&rsquo;s.</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;qq()&quot;
string passed to &quot;eval&quot; will not find string
terminator</p>

<p style="margin-top: 1em">&quot;qq()&quot; string passed
to &quot;eval&quot;</p>

<p style="margin-top: 1em">eval qq( <br>
foreach (keys % { <br>
ount++; <br>
} <br>
);</p>

<p style="margin-top: 1em"># perl4 runs this ok <br>
# perl5 prints: Can&rsquo;t find string terminator
&quot;)&quot;</p>

<p style="margin-top: 1em">DBM Traps <br>
General DBM traps.</p>

<p style="margin-top: 1em">&Acirc;&middot; Perl5 must have
been linked with same dbm/ndbm as the default for
&quot;dbmopen()&quot;</p>

<p style="margin-top: 1em">Existing dbm databases created
under perl4 (or any other dbm/ndbm tool) may cause the same
script, run under perl5, to fail. The build of perl5 must
have been linked with <br>
the same dbm/ndbm as the default for &quot;dbmopen()&quot;
to function properly without &quot;tie&quot;&rsquo;ing to an
extension dbm implementation.</p>

<p style="margin-top: 1em">dbmopen (%dbm, &quot;file&quot;,
undef); <br>
print &quot;ok0;</p>

<p style="margin-top: 1em"># perl4 prints: ok <br>
# perl5 prints: ok (IFF linked with -ldbm or -lndbm)</p>

<p style="margin-top: 1em">&Acirc;&middot; DBM exceeding
limit on the key/value size will cause perl5 to exit
immediately</p>

<p style="margin-top: 1em">Existing dbm databases created
under perl4 (or any other dbm/ndbm tool) may cause the same
script, run under perl5, to fail. The error generated when
exceeding the limit on <br>
the key/value size will cause perl5 to exit immediately.</p>

<p style="margin-top: 1em">dbmopen(DB,
&quot;testdb&quot;,0600) || die &quot;couldn&rsquo;t open
db! $!&quot;; <br>
$DB{&rsquo;trap&rsquo;} = &quot;x&quot; x 1024; # value too
large for most dbm/ndbm <br>
print &quot;YUP0;</p>

<p style="margin-top: 1em"># perl4 prints: <br>
dbm store returned -1, errno 28, key &quot;trap&quot; at -
line 3. <br>
YUP</p>

<p style="margin-top: 1em"># perl5 prints: <br>
dbm store returned -1, errno 28, key &quot;trap&quot; at -
line 3.</p>

<p style="margin-top: 1em">Unclassified Traps <br>
Everything else.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;require&quot;/&quot;do&quot; trap using returned
value</p>

<p style="margin-top: 1em">If the file doit.pl has:</p>

<p style="margin-top: 1em">sub foo { <br>
$rc = do &quot;./do.pl&quot;; <br>
return 8; <br>
} <br>
print &amp;foo, &quot;0;</p>

<p style="margin-top: 1em">And the do.pl file has the
following single line:</p>

<p style="margin-top: 1em">return 3;</p>

<p style="margin-top: 1em">Running doit.pl gives the
following:</p>

<p style="margin-top: 1em"># perl 4 prints: 3 (aborts the
subroutine early) <br>
# perl 5 prints: 8</p>

<p style="margin-top: 1em">Same behavior if you replace
&quot;do&quot; with &quot;require&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot;
&quot;split&quot; on empty string with LIMIT specified</p>

<p style="margin-top: 1em">$string = &rsquo;&rsquo;; <br>
@list = split(/foo/, $string, 2)</p>

<p style="margin-top: 1em">Perl4 returns a one element list
containing the empty string but Perl5 returns an empty
list.</p>

<p style="margin-top: 1em">As always, if any of these are
ever officially declared as bugs, they&rsquo;ll be fixed and
removed.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLTRAP(1)</p>
<hr>
</body>
</html>
