<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:00 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLOP(1) Perl Programmers Reference Guide PERLOP(1)</p>

<p style="margin-top: 1em">NAME <br>
perlop - Perl operators and precedence</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Operator Precedence and Associativity <br>
Operator precedence and associativity work in Perl more or
less like they do in mathematics.</p>

<p style="margin-top: 1em">Operator precedence means some
operators are evaluated before others. For example, in
&quot;2 + 4 * 5&quot;, the multiplication has higher
precedence so &quot;4 * 5&quot; is evaluated first <br>
yielding &quot;2 + 20 == 22&quot; and not &quot;6 * 5 ==
30&quot;.</p>

<p style="margin-top: 1em">Operator associativity defines
what happens if a sequence of the same operators is used one
after another: whether the evaluator will evaluate the left
operations first or the <br>
right. For example, in &quot;8 - 4 - 2&quot;, subtraction is
left associative so Perl evaluates the expression left to
right. &quot;8 - 4&quot; is evaluated first making the
expression &quot;4 - 2 == <br>
2&quot; and not &quot;8 - 2 == 6&quot;.</p>

<p style="margin-top: 1em">Perl operators have the
following associativity and precedence, listed from highest
precedence to lowest. Operators borrowed from C keep the
same precedence relationship with <br>
each other, even where C&rsquo;s precedence is slightly
screwy. (This makes learning Perl easier for C folks.) With
very few exceptions, these all operate on scalar values
only, not <br>
array values.</p>

<p style="margin-top: 1em">left terms and list operators
(leftward) <br>
left -&gt; <br>
nonassoc ++ -- <br>
right ** <br>
right ! ~ &nbsp;and unary + and - <br>
left =~ !~ <br>
left * / % x <br>
left + - . <br>
left &lt;&lt; &gt;&gt; <br>
nonassoc named unary operators <br>
nonassoc &lt; &gt; &lt;= &gt;= lt gt le ge <br>
nonassoc == != &lt;=&gt; eq ne cmp ~~ <br>
left &amp; <br>
left | ^ <br>
left &amp;&amp; <br>
left || // <br>
nonassoc .. ... <br>
right ?: <br>
right = += -= *= etc. <br>
left , =&gt; <br>
nonassoc list operators (rightward) <br>
right not <br>
left and <br>
left or xor</p>

<p style="margin-top: 1em">In the following sections, these
operators are covered in precedence order.</p>

<p style="margin-top: 1em">Many operators can be overloaded
for objects. See overload.</p>

<p style="margin-top: 1em">Terms and List Operators
(Leftward) <br>
A TERM has the highest precedence in Perl. They include
variables, quote and quote-like operators, any expression in
parentheses, and any function whose arguments are <br>
parenthesized. Actually, there aren&rsquo;t really functions
in this sense, just list operators and unary operators
behaving as functions because you put parentheses around the
<br>
arguments. These are all documented in perlfunc.</p>

<p style="margin-top: 1em">If any list operator (print(),
etc.) or any unary operator (chdir(), etc.) is followed by a
left parenthesis as the next token, the operator and
arguments within parentheses are <br>
taken to be of highest precedence, just like a normal
function call.</p>

<p style="margin-top: 1em">In the absence of parentheses,
the precedence of list operators such as &quot;print&quot;,
&quot;sort&quot;, or &quot;chmod&quot; is either very high
or very low depending on whether you are looking at the <br>
left side or the right side of the operator. For example,
in</p>

<p style="margin-top: 1em">@ary = (1, 3, sort 4, 2); <br>
print @ary; # prints 1324</p>

<p style="margin-top: 1em">the commas on the right of the
sort are evaluated before the sort, but the commas on the
left are evaluated after. In other words, list operators
tend to gobble up all arguments <br>
that follow, and then act like a simple TERM with regard to
the preceding expression. Be careful with parentheses:</p>

<p style="margin-top: 1em"># These evaluate exit before
doing the print: <br>
print($foo, exit); # Obviously not what you want. <br>
print $foo, exit; # Nor is this.</p>

<p style="margin-top: 1em"># These do the print before
evaluating exit: <br>
(print $foo), exit; # This is what you want. <br>
print($foo), exit; # Or this. <br>
print ($foo), exit; # Or even this.</p>

<p style="margin-top: 1em">Also note that</p>

<p style="margin-top: 1em">print ($foo &amp; 255) + 1,
&quot;0;</p>

<p style="margin-top: 1em">probably doesn&rsquo;t do what
you expect at first glance. The parentheses enclose the
argument list for &quot;print&quot; which is evaluated
(printing the result of &quot;$foo &amp; 255&quot;). Then
one is <br>
added to the return value of &quot;print&quot; (usually 1).
The result is something like this:</p>

<p style="margin-top: 1em">1 + 1, &quot;0; # Obviously not
what you meant.</p>

<p style="margin-top: 1em">To do what you meant properly,
you must write:</p>

<p style="margin-top: 1em">print(($foo &amp; 255) + 1,
&quot;0);</p>

<p style="margin-top: 1em">See &quot;Named Unary
Operators&quot; for more discussion of this.</p>

<p style="margin-top: 1em">Also parsed as terms are the
&quot;do {}&quot; and &quot;eval {}&quot; constructs, as
well as subroutine and method calls, and the anonymous
constructors &quot;[]&quot; and &quot;{}&quot;.</p>

<p style="margin-top: 1em">See also &quot;Quote and
Quote-like Operators&quot; toward the end of this section,
as well as &quot;I/O Operators&quot;.</p>

<p style="margin-top: 1em">The Arrow Operator <br>
&quot;&quot;-&gt;&quot;&quot; is an infix dereference
operator, just as it is in C and C++. If the right side is
either a &quot;[...]&quot;, &quot;{...}&quot;, or a
&quot;(...)&quot; subscript, then the left side must be
either a <br>
hard or symbolic reference to an array, a hash, or a
subroutine respectively. (Or technically speaking, a
location capable of holding a hard reference, if it&rsquo;s
an array or hash <br>
reference being used for assignment.) See perlreftut and
perlref.</p>

<p style="margin-top: 1em">Otherwise, the right side is a
method name or a simple scalar variable containing either
the method name or a subroutine reference, and the left side
must be either an object (a <br>
blessed reference) or a class name (that is, a package
name). See perlobj.</p>

<p style="margin-top: 1em">Auto-increment and
Auto-decrement <br>
&quot;++&quot; and &quot;--&quot; work as in C. That is, if
placed before a variable, they increment or decrement the
variable by one before returning the value, and if placed
after, increment or <br>
decrement after returning the value.</p>

<p style="margin-top: 1em">$i = 0; $j = 0; <br>
print $i++; # prints 0 <br>
print ++$j; # prints 1</p>

<p style="margin-top: 1em">Note that just as in C, Perl
doesn&rsquo;t define when the variable is incremented or
decremented. You just know it will be done sometime before
or after the value is returned. This <br>
also means that modifying a variable twice in the same
statement will lead to undefined behavior. Avoid statements
like:</p>

<p style="margin-top: 1em">$i = $i ++; <br>
print ++ $i + $i ++;</p>

<p style="margin-top: 1em">Perl will not guarantee what the
result of the above statements is.</p>

<p style="margin-top: 1em">The auto-increment operator has
a little extra builtin magic to it. If you increment a
variable that is numeric, or that has ever been used in a
numeric context, you get a <br>
normal increment. If, however, the variable has been used in
only string contexts since it was set, and has a value that
is not the empty string and matches the pattern <br>
&quot;/^[a-zA-Z]*[0-9]*&quot;, the increment is done as a
string, preserving each character within its range, with
carry:</p>

<p style="margin-top: 1em">print ++($foo = &quot;99&quot;);
# prints &quot;100&quot; <br>
print ++($foo = &quot;a0&quot;); # prints &quot;a1&quot;
<br>
print ++($foo = &quot;Az&quot;); # prints &quot;Ba&quot;
<br>
print ++($foo = &quot;zz&quot;); # prints
&quot;aaa&quot;</p>

<p style="margin-top: 1em">&quot;undef&quot; is always
treated as numeric, and in particular is changed to 0 before
incrementing (so that a post-increment of an undef value
will return 0 rather than &quot;undef&quot;).</p>

<p style="margin-top: 1em">The auto-decrement operator is
not magical.</p>

<p style="margin-top: 1em">Exponentiation <br>
Binary &quot;**&quot; is the exponentiation operator. It
binds even more tightly than unary minus, so -2**4 is
-(2**4), not (-2)**4. (This is implemented using C&rsquo;s
pow(3) function, which <br>
actually works on doubles internally.)</p>

<p style="margin-top: 1em">Symbolic Unary Operators <br>
Unary &quot;!&quot; performs logical negation, that is,
&quot;not&quot;. See also &quot;not&quot; for a lower
precedence version of this.</p>

<p style="margin-top: 1em">Unary &quot;-&quot; performs
arithmetic negation if the operand is numeric, including any
string that looks like a number. If the operand is an
identifier, a string consisting of a minus <br>
sign concatenated with the identifier is returned.
Otherwise, if the string starts with a plus or minus, a
string starting with the opposite sign is returned. One
effect of <br>
these rules is that -bareword is equivalent to the string
&quot;-bareword&quot;. If, however, the string begins with a
non-alphabetic character (excluding &quot;+&quot; or
&quot;-&quot;), Perl will attempt <br>
to convert the string to a numeric and the arithmetic
negation is performed. If the string cannot be cleanly
converted to a numeric, Perl will give the warning Argument
&quot;the <br>
string&quot; isn&rsquo;t numeric in negation (-) at ....</p>

<p style="margin-top: 1em">Unary &quot;~&quot; performs
bitwise negation, that is, 1&rsquo;s complement. For
example, &quot;0666 &amp; ~027&quot; is 0640. (See also
&quot;Integer Arithmetic&quot; and &quot;Bitwise String
Operators&quot;.) Note that the <br>
width of the result is platform-dependent: ~0 is 32 bits
wide on a 32-bit platform, but 64 bits wide on a 64-bit
platform, so if you are expecting a certain bit width,
remember <br>
to use the &quot;&amp;&quot; operator to mask off the excess
bits.</p>

<p style="margin-top: 1em">When complementing strings, if
all characters have ordinal values under 256, then their
complements will, also. But if they do not, all characters
will be in either 32- or <br>
64-bit complements, depending on your architecture. So for
example, &quot;~&quot;1}&quot;&quot; is
&quot;FFF_FC4E}&quot; on 32-bit machines and
&quot;FFF_FFFF_FFFF_FC4E}&quot; on 64-bit machines.</p>

<p style="margin-top: 1em">Unary &quot;+&quot; has no
effect whatsoever, even on strings. It is useful
syntactically for separating a function name from a
parenthesized expression that would otherwise be <br>
interpreted as the complete list of function arguments. (See
examples above under &quot;Terms and List Operators
(Leftward)&quot;.)</p>

<p style="margin-top: 1em">Unary &quot; <br>
forms do convey the notion of protecting the next thing from
interpolation.</p>

<p style="margin-top: 1em">Binding Operators <br>
Binary &quot;=~&quot; binds a scalar expression to a pattern
match. Certain operations search or modify the string $_ by
default. This operator makes that kind of operation work on
some <br>
other string. The right argument is a search pattern,
substitution, or transliteration. The left argument is what
is supposed to be searched, substituted, or transliterated
<br>
instead of the default $_. When used in scalar context, the
return value generally indicates the success of the
operation. The exceptions are substitution (s///) and <br>
transliteration (y///) with the &quot;/r&quot;
(non-destructive) option, which cause the return value to be
the result of the substitution. Behavior in list context
depends on the <br>
particular operator. See &quot;Regexp Quote-Like
Operators&quot; for details and perlretut for examples using
these operators.</p>

<p style="margin-top: 1em">If the right argument is an
expression rather than a search pattern, substitution, or
transliteration, it is interpreted as a search pattern at
run time. Note that this means <br>
that its contents will be interpolated twice, so</p>

<p style="margin-top: 1em">&rsquo;\&rsquo; =~
q&rsquo;\&rsquo;;</p>

<p style="margin-top: 1em">is not ok, as the regex engine
will end up trying to compile the pattern &quot;</p>

<p style="margin-top: 1em">Binary &quot;!~&quot; is just
like &quot;=~&quot; except the return value is negated in
the logical sense.</p>

<p style="margin-top: 1em">Binary &quot;!~&quot; with a
non-destructive substitution (s///r) or transliteration
(y///r) is a syntax error.</p>

<p style="margin-top: 1em">Multiplicative Operators <br>
Binary &quot;*&quot; multiplies two numbers.</p>

<p style="margin-top: 1em">Binary &quot;/&quot; divides two
numbers.</p>

<p style="margin-top: 1em">Binary &quot;%&quot; is the
modulo operator, which computes the division remainder of
its first argument with respect to its second argument.
Given integer operands $a and $b: If $b is <br>
positive, then &quot;$a % $b&quot; is $a minus the largest
multiple of $b less than or equal to $a. If $b is negative,
then &quot;$a % $b&quot; is $a minus the smallest multiple
of $b that is not <br>
less than $a (that is, the result will be less than or equal
to zero). If the operands $a and $b are floating point
values and the absolute value of $b (that is
&quot;abs($b)&quot;) is <br>
less than &quot;(UV_MAX + 1)&quot;, only the integer portion
of $a and $b will be used in the operation (Note: here
&quot;UV_MAX&quot; means the maximum of the unsigned integer
type). If the <br>
absolute value of the right operand (&quot;abs($b)&quot;) is
greater than or equal to &quot;(UV_MAX + 1)&quot;,
&quot;%&quot; computes the floating-point remainder $r in
the equation &quot;($r = $a - $i*$b)&quot; where <br>
$i is a certain integer that makes $r have the same sign as
the right operand $b (not as the left operand $a like C
function &quot;fmod()&quot;) and the absolute value less
than that of <br>
$b. Note that when &quot;use integer&quot; is in scope,
&quot;%&quot; gives you direct access to the modulo operator
as implemented by your C compiler. This operator is not as
well defined for <br>
negative operands, but it will execute faster.</p>

<p style="margin-top: 1em">Binary &quot;x&quot; is the
repetition operator. In scalar context or if the left
operand is not enclosed in parentheses, it returns a string
consisting of the left operand repeated the <br>
number of times specified by the right operand. In list
context, if the left operand is enclosed in parentheses or
is a list formed by &quot;qw/STRING/&quot;, it repeats the
list. If the <br>
right operand is zero or negative, it returns an empty
string or an empty list, depending on the context.</p>

<p style="margin-top: 1em">print &rsquo;-&rsquo; x 80; #
print row of dashes</p>

<p style="margin-top: 1em">print &quot;&quot; x ($tab/8),
&rsquo; &rsquo; x ($tab%8); # tab over</p>

<p style="margin-top: 1em">@ones = (1) x 80; # a list of 80
1&rsquo;s <br>
@ones = (5) x @ones; # set all elements to 5</p>

<p style="margin-top: 1em">Additive Operators <br>
Binary &quot;+&quot; returns the sum of two numbers.</p>

<p style="margin-top: 1em">Binary &quot;-&quot; returns the
difference of two numbers.</p>

<p style="margin-top: 1em">Binary &quot;.&quot;
concatenates two strings.</p>

<p style="margin-top: 1em">Shift Operators <br>
Binary &quot;&lt;&lt;&quot; returns the value of its left
argument shifted left by the number of bits specified by the
right argument. Arguments should be integers. (See also
&quot;Integer <br>
Arithmetic&quot;.)</p>

<p style="margin-top: 1em">Binary &quot;&gt;&gt;&quot;
returns the value of its left argument shifted right by the
number of bits specified by the right argument. Arguments
should be integers. (See also &quot;Integer <br>
Arithmetic&quot;.)</p>

<p style="margin-top: 1em">Note that both
&quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot; in Perl are
implemented directly using &quot;&lt;&lt;&quot; and
&quot;&gt;&gt;&quot; in C. If &quot;use integer&quot; (see
&quot;Integer Arithmetic&quot;) is in force then signed C
integers are used, <br>
else unsigned C integers are used. Either way, the
implementation isn&rsquo;t going to generate results larger
than the size of the integer type Perl was built with (32
bits or 64 <br>
bits).</p>

<p style="margin-top: 1em">The result of overflowing the
range of the integers is undefined because it is undefined
also in C. In other words, using 32-bit integers, &quot;1
&lt;&lt; 32&quot; is undefined. Shifting by a <br>
negative number of bits is also undefined.</p>

<p style="margin-top: 1em">If you get tired of being
subject to your platform&rsquo;s native integers, the
&quot;use bigint&quot; pragma neatly sidesteps the issue
altogether:</p>

<p style="margin-top: 1em">print 20 &lt;&lt; 20; # 20971520
<br>
print 20 &lt;&lt; 40; # 5120 on 32-bit machines, <br>
# 21990232555520 on 64-bit machines <br>
use bigint; <br>
print 20 &lt;&lt; 100; #
25353012004564588029934064107520</p>

<p style="margin-top: 1em">Named Unary Operators <br>
The various named unary operators are treated as functions
with one argument, with optional parentheses.</p>

<p style="margin-top: 1em">If any list operator (print(),
etc.) or any unary operator (chdir(), etc.) is followed by a
left parenthesis as the next token, the operator and
arguments within parentheses are <br>
taken to be of highest precedence, just like a normal
function call. For example, because named unary operators
are higher precedence than &quot;||&quot;:</p>

<p style="margin-top: 1em">chdir $foo || die; # (chdir
$foo) || die <br>
chdir($foo) || die; # (chdir $foo) || die <br>
chdir ($foo) || die; # (chdir $foo) || die <br>
chdir +($foo) || die; # (chdir $foo) || die</p>

<p style="margin-top: 1em">but, because * is higher
precedence than named operators:</p>

<p style="margin-top: 1em">chdir $foo * 20; # chdir ($foo *
20) <br>
chdir($foo) * 20; # (chdir $foo) * 20 <br>
chdir ($foo) * 20; # (chdir $foo) * 20 <br>
chdir +($foo) * 20; # chdir ($foo * 20)</p>

<p style="margin-top: 1em">rand 10 * 20; # rand (10 * 20)
<br>
rand(10) * 20; # (rand 10) * 20 <br>
rand (10) * 20; # (rand 10) * 20 <br>
rand +(10) * 20; # rand (10 * 20)</p>

<p style="margin-top: 1em">Regarding precedence, the
filetest operators, like &quot;-f&quot;, &quot;-M&quot;,
etc. are treated like named unary operators, but they
don&rsquo;t follow this functional parenthesis rule. That
means, <br>
for example, that &quot;-f($file).&quot;.bak&quot;&quot; is
equivalent to &quot;-f &quot;$file.bak&quot;&quot;.</p>

<p style="margin-top: 1em">See also &quot;Terms and List
Operators (Leftward)&quot;.</p>

<p style="margin-top: 1em">Relational Operators <br>
Perl operators that return true or false generally return
values that can be safely used as numbers. For example, the
relational operators in this section and the equality <br>
operators in the next one return 1 for true and a special
version of the defined empty string, &quot;&quot;, which
counts as a zero but is exempt from warnings about improper
numeric <br>
conversions, just as &quot;0 but true&quot; is.</p>

<p style="margin-top: 1em">Binary &quot;&lt;&quot; returns
true if the left argument is numerically less than the right
argument.</p>

<p style="margin-top: 1em">Binary &quot;&gt;&quot; returns
true if the left argument is numerically greater than the
right argument.</p>

<p style="margin-top: 1em">Binary &quot;&lt;=&quot; returns
true if the left argument is numerically less than or equal
to the right argument.</p>

<p style="margin-top: 1em">Binary &quot;&gt;=&quot; returns
true if the left argument is numerically greater than or
equal to the right argument.</p>

<p style="margin-top: 1em">Binary &quot;lt&quot; returns
true if the left argument is stringwise less than the right
argument.</p>

<p style="margin-top: 1em">Binary &quot;gt&quot; returns
true if the left argument is stringwise greater than the
right argument.</p>

<p style="margin-top: 1em">Binary &quot;le&quot; returns
true if the left argument is stringwise less than or equal
to the right argument.</p>

<p style="margin-top: 1em">Binary &quot;ge&quot; returns
true if the left argument is stringwise greater than or
equal to the right argument.</p>

<p style="margin-top: 1em">Equality Operators <br>
Binary &quot;==&quot; returns true if the left argument is
numerically equal to the right argument.</p>

<p style="margin-top: 1em">Binary &quot;!=&quot; returns
true if the left argument is numerically not equal to the
right argument.</p>

<p style="margin-top: 1em">Binary &quot;&lt;=&gt;&quot;
returns -1, 0, or 1 depending on whether the left argument
is numerically less than, equal to, or greater than the
right argument. If your platform supports NaNs <br>
(not-a-numbers) as numeric values, using them with
&quot;&lt;=&gt;&quot; returns undef. NaN is not
&quot;&lt;&quot;, &quot;==&quot;, &quot;&gt;&quot;,
&quot;&lt;=&quot; or &quot;&gt;=&quot; anything (even NaN),
so those 5 return false. NaN != NaN returns <br>
true, as does NaN != anything else. If your platform
doesn&rsquo;t support NaNs then NaN is just a string with
numeric value 0.</p>

<p style="margin-top: 1em">$ perl -le &rsquo;$a =
&quot;NaN&quot;; print &quot;No NaN support here&quot; if $a
== $a&rsquo; <br>
$ perl -le &rsquo;$a = &quot;NaN&quot;; print &quot;NaN
support here&quot; if $a != $a&rsquo;</p>

<p style="margin-top: 1em">(Note that the bigint, bigrat,
and bignum pragmas all support &quot;NaN&quot;.)</p>

<p style="margin-top: 1em">Binary &quot;eq&quot; returns
true if the left argument is stringwise equal to the right
argument.</p>

<p style="margin-top: 1em">Binary &quot;ne&quot; returns
true if the left argument is stringwise not equal to the
right argument.</p>

<p style="margin-top: 1em">Binary &quot;cmp&quot; returns
-1, 0, or 1 depending on whether the left argument is
stringwise less than, equal to, or greater than the right
argument.</p>

<p style="margin-top: 1em">Binary &quot;~~&quot; does a
smartmatch between its arguments. Smart matching is
described in the next section.</p>

<p style="margin-top: 1em">&quot;lt&quot;, &quot;le&quot;,
&quot;ge&quot;, &quot;gt&quot; and &quot;cmp&quot; use the
collation (sort) order specified by the current locale if a
legacy &quot;use locale&quot; (but not &quot;use locale
&rsquo;:not_characters&rsquo;&quot;) is in effect. <br>
See perllocale. Do not mix these with Unicode, only with
legacy binary encodings. The standard Unicode::Collate and
Unicode::Collate::Locale modules offer much more powerful
<br>
solutions to collation issues.</p>

<p style="margin-top: 1em">Smartmatch Operator <br>
First available in Perl 5.10.1 (the 5.10.0 version behaved
differently), binary &quot;~~&quot; does a
&quot;smartmatch&quot; between its arguments. This is mostly
used implicitly in the &quot;when&quot; <br>
construct described in perlsyn, although not all
&quot;when&quot; clauses call the smartmatch operator.
Unique among all of Perl&rsquo;s operators, the smartmatch
operator can recurse.</p>

<p style="margin-top: 1em">It is also unique in that all
other Perl operators impose a context (usually string or
numeric context) on their operands, autoconverting those
operands to those imposed <br>
contexts. In contrast, smartmatch infers contexts from the
actual types of its operands and uses that type information
to select a suitable comparison mechanism.</p>

<p style="margin-top: 1em">The &quot;~~&quot; operator
compares its operands &quot;polymorphically&quot;,
determining how to compare them according to their actual
types (numeric, string, array, hash, etc.) Like the equality
<br>
operators with which it shares the same precedence,
&quot;~~&quot; returns 1 for true and &quot;&quot; for
false. It is often best read aloud as &quot;in&quot;,
&quot;inside of&quot;, or &quot;is contained in&quot;,
because the <br>
left operand is often looked for inside the right operand.
That makes the order of the operands to the smartmatch
operand often opposite that of the regular match operator.
In <br>
other words, the &quot;smaller&quot; thing is usually placed
in the left operand and the larger one in the right.</p>

<p style="margin-top: 1em">The behavior of a smartmatch
depends on what type of things its arguments are, as
determined by the following table. The first row of the
table whose types apply determines the <br>
smartmatch behavior. Because what actually happens is mostly
determined by the type of the second operand, the table is
sorted on the right operand instead of on the left.</p>

<p style="margin-top: 1em">Left Right Description and
pseudocode <br>

===============================================================
<br>
Any undef check whether Any is undefined <br>
like: !defined Any</p>

<p style="margin-top: 1em">Any Object invoke ~~ overloading
on Object, or die</p>

<p style="margin-top: 1em">Right operand is an ARRAY:</p>

<p style="margin-top: 1em">Left Right Description and
pseudocode <br>

===============================================================
<br>
ARRAY1 ARRAY2 recurse on paired elements of ARRAY1 and
ARRAY2[2] <br>
like: (ARRAY1[0] ~~ ARRAY2[0]) <br>
&amp;&amp; (ARRAY1[1] ~~ ARRAY2[1]) &amp;&amp; ... <br>
HASH ARRAY any ARRAY elements exist as HASH keys <br>
like: grep { exists HASH-&gt;{$_} } ARRAY <br>
Regexp ARRAY any ARRAY elements pattern match Regexp <br>
like: grep { /Regexp/ } ARRAY <br>
undef ARRAY undef in ARRAY <br>
like: grep { !defined } ARRAY <br>
Any ARRAY smartmatch each ARRAY element[3] <br>
like: grep { Any ~~ $_ } ARRAY</p>

<p style="margin-top: 1em">Right operand is a HASH:</p>

<p style="margin-top: 1em">Left Right Description and
pseudocode <br>

===============================================================
<br>
HASH1 HASH2 all same keys in both HASHes <br>
like: keys HASH1 == <br>
grep { exists HASH2-&gt;{$_} } keys HASH1 <br>
ARRAY HASH any ARRAY elements exist as HASH keys <br>
like: grep { exists HASH-&gt;{$_} } ARRAY <br>
Regexp HASH any HASH keys pattern match Regexp <br>
like: grep { /Regexp/ } keys HASH <br>
undef HASH always false (undef can&rsquo;t be a key) <br>
like: 0 == 1 <br>
Any HASH HASH key existence <br>
like: exists HASH-&gt;{Any}</p>

<p style="margin-top: 1em">Right operand is CODE:</p>

<p style="margin-top: 1em">Left Right Description and
pseudocode <br>

===============================================================
<br>
ARRAY CODE sub returns true on all ARRAY elements[1] <br>
like: !grep { !CODE-&gt;($_) } ARRAY <br>
HASH CODE sub returns true on all HASH keys[1] <br>
like: !grep { !CODE-&gt;($_) } keys HASH <br>
Any CODE sub passed Any returns true <br>
like: CODE-&gt;(Any)</p>

<p style="margin-top: 1em">Right operand is a Regexp:</p>

<p style="margin-top: 1em">Left Right Description and
pseudocode <br>

===============================================================
<br>
ARRAY Regexp any ARRAY elements match Regexp <br>
like: grep { /Regexp/ } ARRAY <br>
HASH Regexp any HASH keys match Regexp <br>
like: grep { /Regexp/ } keys HASH <br>
Any Regexp pattern match <br>
like: Any =~ /Regexp/</p>

<p style="margin-top: 1em">Other:</p>

<p style="margin-top: 1em">Left Right Description and
pseudocode <br>

===============================================================
<br>
Object Any invoke ~~ overloading on Object, <br>
or fall back to...</p>

<p style="margin-top: 1em">Any Num numeric equality <br>
like: Any == Num <br>
Num nummy[4] numeric equality <br>
like: Num == nummy <br>
undef Any check whether undefined <br>
like: !defined(Any) <br>
Any Any string equality <br>
like: Any eq Any</p>

<p style="margin-top: 1em">Notes:</p>

<p style="margin-top: 1em">1. Empty hashes or arrays match.
<br>
2. That is, each element smartmatches the element of the
same index in the other array.[3] <br>
3. If a circular reference is found, fall back to
referential equality. <br>
4. Either an actual number, or a string that looks like
one.</p>

<p style="margin-top: 1em">The smartmatch implicitly
dereferences any non-blessed hash or array reference, so the
&quot;HASH&quot; and &quot;ARRAY&quot; entries apply in
those cases. For blessed references, the &quot;Object&quot;
<br>
entries apply. Smartmatches involving hashes only consider
hash keys, never hash values.</p>

<p style="margin-top: 1em">The &quot;like&quot; code entry
is not always an exact rendition. For example, the
smartmatch operator short-circuits whenever possible, but
&quot;grep&quot; does not. Also, &quot;grep&quot; in scalar
<br>
context returns the number of matches, but &quot;~~&quot;
returns only true or false.</p>

<p style="margin-top: 1em">Unlike most operators, the
smartmatch operator knows to treat &quot;undef&quot;
specially:</p>

<p style="margin-top: 1em">use v5.10.1; <br>
@array = (1, 2, 3, undef, 4, 5); <br>
say &quot;some elements undefined&quot; if undef ~~
@array;</p>

<p style="margin-top: 1em">Each operand is considered in a
modified scalar context, the modification being that array
and hash variables are passed by reference to the operator,
which implicitly <br>
dereferences them. Both elements of each pair are the
same:</p>

<p style="margin-top: 1em">use v5.10.1;</p>

<p style="margin-top: 1em">my %hash = (red =&gt; 1, blue
=&gt; 2, green =&gt; 3, <br>
orange =&gt; 4, yellow =&gt; 5, purple =&gt; 6, <br>
black =&gt; 7, grey =&gt; 8, white =&gt; 9);</p>

<p style="margin-top: 1em">my @array = qw(red blue
green);</p>

<p style="margin-top: 1em">say &quot;some array elements in
hash keys&quot; if @array ~~ %hash; <br>
say &quot;some array elements in hash keys&quot; if @array
~~ hash;</p>

<p style="margin-top: 1em">say &quot;red in array&quot; if
&quot;red&quot; ~~ @array; <br>
say &quot;red in array&quot; if &quot;red&quot; ~~
@array;</p>

<p style="margin-top: 1em">say &quot;some keys end in
e&quot; if /e$/ ~~ %hash; <br>
say &quot;some keys end in e&quot; if /e$/ ~~ hash;</p>

<p style="margin-top: 1em">Two arrays smartmatch if each
element in the first array smartmatches (that is, is
&quot;in&quot;) the corresponding element in the second
array, recursively.</p>

<p style="margin-top: 1em">use v5.10.1; <br>
my @little = qw(red blue green); <br>
my @bigger = (&quot;red&quot;, &quot;blue&quot;, [
&quot;orange&quot;, &quot;green&quot; ] ); <br>
if (@little ~~ @bigger) { # true! <br>
say &quot;little is contained in bigger&quot;; <br>
}</p>

<p style="margin-top: 1em">Because the smartmatch operator
recurses on nested arrays, this will still report that
&quot;red&quot; is in the array.</p>

<p style="margin-top: 1em">use v5.10.1; <br>
my @array = qw(red blue green); <br>
my $nested_array = [[[[[[[ @array ]]]]]]]; <br>
say &quot;red in array&quot; if &quot;red&quot; ~~
$nested_array;</p>

<p style="margin-top: 1em">If two arrays smartmatch each
other, then they are deep copies of each others&rsquo;
values, as this example reports:</p>

<p style="margin-top: 1em">use v5.12.0; <br>
my @a = (0, 1, 2, [3, [4, 5], 6], 7); <br>
my @b = (0, 1, 2, [3, [4, 5], 6], 7);</p>

<p style="margin-top: 1em">if (@a ~~ @b &amp;&amp; @b ~~
@a) { <br>
say &quot;a and b are deep copies of each other&quot;; <br>
} <br>
elsif (@a ~~ @b) { <br>
say &quot;a smartmatches in b&quot;; <br>
} <br>
elsif (@b ~~ @a) { <br>
say &quot;b smartmatches in a&quot;; <br>
} <br>
else { <br>
say &quot;a and b don&rsquo;t smartmatch each other at
all&quot;; <br>
}</p>

<p style="margin-top: 1em">If you were to set &quot;$b[3] =
4&quot;, then instead of reporting that &quot;a and b are
deep copies of each other&quot;, it now reports that &quot;b
smartmatches in a&quot;. That because the corresponding <br>
position in @a contains an array that (eventually) has a 4
in it.</p>

<p style="margin-top: 1em">Smartmatching one hash against
another reports whether both contain the same keys, no more
and no less. This could be used to see whether two records
have the same field names, <br>
without caring what values those fields might have. For
example:</p>

<p style="margin-top: 1em">use v5.10.1; <br>
sub make_dogtag { <br>
state $REQUIRED_FIELDS = { name=&gt;1, rank=&gt;1,
serial_num=&gt;1 };</p>

<p style="margin-top: 1em">my ($class, $init_fields) =
@_;</p>

<p style="margin-top: 1em">die &quot;Must supply (only)
name, rank, and serial number&quot; <br>
unless $init_fields ~~ $REQUIRED_FIELDS;</p>

<p style="margin-top: 1em">... <br>
}</p>

<p style="margin-top: 1em">or, if other non-required fields
are allowed, use ARRAY ~~ HASH:</p>

<p style="margin-top: 1em">use v5.10.1; <br>
sub make_dogtag { <br>
state $REQUIRED_FIELDS = { name=&gt;1, rank=&gt;1,
serial_num=&gt;1 };</p>

<p style="margin-top: 1em">my ($class, $init_fields) =
@_;</p>

<p style="margin-top: 1em">die &quot;Must supply (at least)
name, rank, and serial number&quot; <br>
unless [keys %{$init_fields}] ~~ $REQUIRED_FIELDS;</p>

<p style="margin-top: 1em">... <br>
}</p>

<p style="margin-top: 1em">The smartmatch operator is most
often used as the implicit operator of a &quot;when&quot;
clause. See the section on &quot;Switch Statements&quot; in
perlsyn.</p>

<p style="margin-top: 1em">Smartmatching of Objects</p>

<p style="margin-top: 1em">To avoid relying on an
object&rsquo;s underlying representation, if the
smartmatch&rsquo;s right operand is an object that
doesn&rsquo;t overload &quot;~~&quot;, it raises the
exception &quot;&quot;Smartmatching a <br>
non-overloaded object breaks encapsulation&quot;&quot;.
That&rsquo;s because one has no business digging around to
see whether something is &quot;in&quot; an object. These are
all illegal on objects <br>
without a &quot;~~&quot; overload:</p>

<p style="margin-top: 1em">%hash ~~ $object <br>
42 ~~ $object <br>
&quot;fred&quot; ~~ $object</p>

<p style="margin-top: 1em">However, you can change the way
an object is smartmatched by overloading the &quot;~~&quot;
operator. This is allowed to extend the usual smartmatch
semantics. For objects that do have an <br>
&quot;~~&quot; overload, see overload.</p>

<p style="margin-top: 1em">Using an object as the left
operand is allowed, although not very useful. Smartmatching
rules take precedence over overloading, so even if the
object in the left operand has <br>
smartmatch overloading, this will be ignored. A left operand
that is a non-overloaded object falls back on a string or
numeric comparison of whatever the &quot;ref&quot; operator
returns. <br>
That means that</p>

<p style="margin-top: 1em">$object ~~ X</p>

<p style="margin-top: 1em">does not invoke the overload
method with &quot;X&quot; as an argument. Instead the above
table is consulted as normal, and based on the type of
&quot;X&quot;, overloading may or may not be invoked. <br>
For simple strings or numbers, in becomes equivalent to
this:</p>

<p style="margin-top: 1em">$object ~~ $number ref($object)
== $number <br>
$object ~~ $string ref($object) eq $string</p>

<p style="margin-top: 1em">For example, this reports that
the handle smells IOish (but please don&rsquo;t really do
this!):</p>

<p style="margin-top: 1em">use IO::Handle; <br>
my $fh = IO::Handle-&gt;new(); <br>
if ($fh ~~ /O <br>
say &quot;handle smells IOish&quot;; <br>
}</p>

<p style="margin-top: 1em">That&rsquo;s because it treats
$fh as a string like &quot;IO::Handle=GLOB(0x8039e0)&quot;,
then pattern matches against that.</p>

<p style="margin-top: 1em">Bitwise And <br>
Binary &quot;&amp;&quot; returns its operands ANDed together
bit by bit. (See also &quot;Integer Arithmetic&quot; and
&quot;Bitwise String Operators&quot;.)</p>

<p style="margin-top: 1em">Note that &quot;&amp;&quot; has
lower priority than relational operators, so for example the
parentheses are essential in a test like</p>

<p style="margin-top: 1em">print &quot;Even0 if ($x &amp;
1) == 0;</p>

<p style="margin-top: 1em">Bitwise Or and Exclusive Or <br>
Binary &quot;|&quot; returns its operands ORed together bit
by bit. (See also &quot;Integer Arithmetic&quot; and
&quot;Bitwise String Operators&quot;.)</p>

<p style="margin-top: 1em">Binary &quot;^&quot; returns its
operands XORed together bit by bit. (See also &quot;Integer
Arithmetic&quot; and &quot;Bitwise String
Operators&quot;.)</p>

<p style="margin-top: 1em">Note that &quot;|&quot; and
&quot;^&quot; have lower priority than relational operators,
so for example the brackets are essential in a test like</p>

<p style="margin-top: 1em">print &quot;false0 if (8 | 2) !=
10;</p>

<p style="margin-top: 1em">C-style Logical And <br>
Binary &quot;&amp;&amp;&quot; performs a short-circuit
logical AND operation. That is, if the left operand is
false, the right operand is not even evaluated. Scalar or
list context propagates <br>
down to the right operand if it is evaluated.</p>

<p style="margin-top: 1em">C-style Logical Or <br>
Binary &quot;||&quot; performs a short-circuit logical OR
operation. That is, if the left operand is true, the right
operand is not even evaluated. Scalar or list context
propagates down <br>
to the right operand if it is evaluated.</p>

<p style="margin-top: 1em">Logical Defined-Or <br>
Although it has no direct equivalent in C, Perl&rsquo;s
&quot;//&quot; operator is related to its C-style or. In
fact, it&rsquo;s exactly the same as &quot;||&quot;, except
that it tests the left hand side&rsquo;s <br>
definedness instead of its truth. Thus, &quot;EXPR1 //
EXPR2&quot; returns the value of &quot;EXPR1&quot; if
it&rsquo;s defined, otherwise, the value of
&quot;EXPR2&quot; is returned. (&quot;EXPR1&quot; is
evaluated in <br>
scalar context, &quot;EXPR2&quot; in the context of
&quot;//&quot; itself). Usually, this is the same result as
&quot;defined(EXPR1) ? EXPR1 : EXPR2&quot; (except that the
ternary-operator form can be used as <br>
a lvalue, while &quot;EXPR1 // EXPR2&quot; cannot). This is
very useful for providing default values for variables. If
you actually want to test if at least one of $a and $b is
defined, <br>
use &quot;defined($a // $b)&quot;.</p>

<p style="margin-top: 1em">The &quot;||&quot;,
&quot;//&quot; and &quot;&amp;&amp;&quot; operators return
the last value evaluated (unlike C&rsquo;s &quot;||&quot;
and &quot;&amp;&amp;&quot;, which return 0 or 1). Thus, a
reasonably portable way to find out the home directory <br>
might be:</p>

<p style="margin-top: 1em">$home = $ENV{HOME} <br>
// $ENV{LOGDIR} <br>
// (getpwuid($&lt;))[7] <br>
// die &quot;You&rsquo;re homeless!0;</p>

<p style="margin-top: 1em">In particular, this means that
you shouldn&rsquo;t use this for selecting between two
aggregates for assignment:</p>

<p style="margin-top: 1em">@a = @b || @c; # this is wrong
<br>
@a = scalar(@b) || @c; # really meant this <br>
@a = @b ? @b : @c; # this works fine, though</p>

<p style="margin-top: 1em">As alternatives to
&quot;&amp;&amp;&quot; and &quot;||&quot; when used for
control flow, Perl provides the &quot;and&quot; and
&quot;or&quot; operators (see below). The short-circuit
behavior is identical. The precedence of <br>
&quot;and&quot; and &quot;or&quot; is much lower, however,
so that you can safely use them after a list operator
without the need for parentheses:</p>

<p style="margin-top: 1em">unlink &quot;alpha&quot;,
&quot;beta&quot;, &quot;gamma&quot; <br>
or gripe(), next LINE;</p>

<p style="margin-top: 1em">With the C-style operators that
would have been written like this:</p>

<p style="margin-top: 1em">unlink(&quot;alpha&quot;,
&quot;beta&quot;, &quot;gamma&quot;) <br>
|| (gripe(), next LINE);</p>

<p style="margin-top: 1em">It would be even more readable
to write that this way:</p>


<p style="margin-top: 1em">unless(unlink(&quot;alpha&quot;,
&quot;beta&quot;, &quot;gamma&quot;)) { <br>
gripe(); <br>
next LINE; <br>
}</p>

<p style="margin-top: 1em">Using &quot;or&quot; for
assignment is unlikely to do what you want; see below.</p>

<p style="margin-top: 1em">Range Operators <br>
Binary &quot;..&quot; is the range operator, which is really
two different operators depending on the context. In list
context, it returns a list of values counting (up by ones)
from the <br>
left value to the right value. If the left value is greater
than the right value then it returns the empty list. The
range operator is useful for writing &quot;foreach
(1..10)&quot; <br>
loops and for doing slice operations on arrays. In the
current implementation, no temporary array is created when
the range operator is used as the expression in
&quot;foreach&quot; loops, <br>
but older versions of Perl might burn a lot of memory when
you write something like this:</p>

<p style="margin-top: 1em">for (1 .. 1_000_000) { <br>
# code <br>
}</p>

<p style="margin-top: 1em">The range operator also works on
strings, using the magical auto-increment, see below.</p>

<p style="margin-top: 1em">In scalar context,
&quot;..&quot; returns a boolean value. The operator is
bistable, like a flip-flop, and emulates the line-range
(comma) operator of sed, awk, and various editors. Each <br>
&quot;..&quot; operator maintains its own boolean state,
even across calls to a subroutine that contains it. It is
false as long as its left operand is false. Once the left
operand is <br>
true, the range operator stays true until the right operand
is true, AFTER which the range operator becomes false again.
It doesn&rsquo;t become false till the next time the range
<br>
operator is evaluated. It can test the right operand and
become false on the same evaluation it became true (as in
awk), but it still returns true once. If you don&rsquo;t
want it to <br>
test the right operand until the next evaluation, as in sed,
just use three dots (&quot;...&quot;) instead of two. In all
other regards, &quot;...&quot; behaves just like
&quot;..&quot; does.</p>

<p style="margin-top: 1em">The right operand is not
evaluated while the operator is in the &quot;false&quot;
state, and the left operand is not evaluated while the
operator is in the &quot;true&quot; state. The precedence is
<br>
a little lower than || and &amp;&amp;. The value returned is
either the empty string for false, or a sequence number
(beginning with 1) for true. The sequence number is reset
for each <br>
range encountered. The final sequence number in a range has
the string &quot;E0&quot; appended to it, which
doesn&rsquo;t affect its numeric value, but gives you
something to search for if you <br>
want to exclude the endpoint. You can exclude the beginning
point by waiting for the sequence number to be greater than
1.</p>

<p style="margin-top: 1em">If either operand of scalar
&quot;..&quot; is a constant expression, that operand is
considered true if it is equal (&quot;==&quot;) to the
current input line number (the $. variable).</p>

<p style="margin-top: 1em">To be pedantic, the comparison
is actually &quot;int(EXPR) == int(EXPR)&quot;, but that is
only an issue if you use a floating point expression; when
implicitly using $. as described in <br>
the previous paragraph, the comparison is &quot;int(EXPR) ==
int($.)&quot; which is only an issue when $. is set to a
floating point value and you are not reading from a file.
<br>
Furthermore, &quot;span&quot; .. &quot;spat&quot; or
&quot;2.18 .. 3.14&quot; will not do what you want in scalar
context because each of the operands are evaluated using
their integer representation.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">As a scalar operator:</p>

<p style="margin-top: 1em">if (101 .. 200) { print; } #
print 2nd hundred lines, short for <br>
# if ($. == 101 .. $. == 200) { print; }</p>

<p style="margin-top: 1em">next LINE if (1 .. /^$/); # skip
header lines, short for <br>
# next LINE if ($. == 1 .. /^$/); <br>
# (typically in a loop labeled LINE)</p>

<p style="margin-top: 1em">s/^/&gt; / if (/^$/ .. eof()); #
quote body</p>

<p style="margin-top: 1em"># parse mail messages <br>
while (&lt;&gt;) { <br>
$in_header = 1 .. /^$/; <br>
$in_body = /^$/ .. eof; <br>
if ($in_header) { <br>
# do something <br>
} else { # in body <br>
# do something else <br>
} <br>
} continue { <br>
close ARGV if eof; # reset $. each file <br>
}</p>

<p style="margin-top: 1em">Here&rsquo;s a simple example to
illustrate the difference between the two range
operators:</p>

<p style="margin-top: 1em">@lines = (&quot; - Foo&quot;,
<br>
&quot;01 - Bar&quot;, <br>
&quot;1 - Baz&quot;, <br>
&quot; - Quux&quot;);</p>

<p style="margin-top: 1em">foreach (@lines) { <br>
if (/0/ .. /1/) { <br>
print &quot;$_0; <br>
} <br>
}</p>

<p style="margin-top: 1em">This program will print only the
line containing &quot;Bar&quot;. If the range operator is
changed to &quot;...&quot;, it will also print the
&quot;Baz&quot; line.</p>

<p style="margin-top: 1em">And now some examples as a list
operator:</p>

<p style="margin-top: 1em">for (101 .. 200) { print } #
print $_ 100 times <br>
@foo = @foo[0 .. $#foo]; # an expensive no-op <br>
@foo = @foo[$#foo-4 .. $#foo]; # slice last 5 items</p>

<p style="margin-top: 1em">The range operator (in list
context) makes use of the magical auto-increment algorithm
if the operands are strings. You can say</p>

<p style="margin-top: 1em">@alphabet = (&quot;A&quot; ..
&quot;Z&quot;);</p>

<p style="margin-top: 1em">to get all normal letters of the
English alphabet, or</p>

<p style="margin-top: 1em">$hexdigit = (0 .. 9,
&quot;a&quot; .. &quot;f&quot;)[$num &amp; 15];</p>

<p style="margin-top: 1em">to get a hexadecimal digit,
or</p>

<p style="margin-top: 1em">@z2 = (&quot;01&quot; ..
&quot;31&quot;); <br>
print $z2[$mday];</p>

<p style="margin-top: 1em">to get dates with leading
zeros.</p>

<p style="margin-top: 1em">If the final value specified is
not in the sequence that the magical increment would
produce, the sequence goes until the next value would be
longer than the final value <br>
specified.</p>

<p style="margin-top: 1em">If the initial value specified
isn&rsquo;t part of a magical increment sequence (that is, a
non-empty string matching &quot;/^[a-zA-Z]*[0-9]*&quot;),
only the initial value will be returned. <br>
So the following will only return an alpha:</p>

<p style="margin-top: 1em">use charnames &quot;greek&quot;;
<br>
my @greek_small = (&quot;lpha}&quot; ..
&quot;mega}&quot;);</p>

<p style="margin-top: 1em">To get the 25 traditional
lowercase Greek letters, including both sigmas, you could
use this instead:</p>

<p style="margin-top: 1em">use charnames &quot;greek&quot;;
<br>
my @greek_small = map { chr } ( ord(&quot;lpha}&quot;) <br>
.. <br>
ord(&quot;mega}&quot;) <br>
);</p>

<p style="margin-top: 1em">However, because there are many
other lowercase Greek characters than just those, to match
lowercase Greek characters in a regular expression, you
would use the pattern <br>
&quot;/(?:(?={Greek}){Lower})+/&quot;.</p>

<p style="margin-top: 1em">Because each operand is
evaluated in integer form, &quot;2.18 .. 3.14&quot; will
return two elements in list context.</p>

<p style="margin-top: 1em">@list = (2.18 .. 3.14); # same
as @list = (2 .. 3);</p>

<p style="margin-top: 1em">Conditional Operator <br>
Ternary &quot;?:&quot; is the conditional operator, just as
in C. It works much like an if-then-else. If the argument
before the ? is true, the argument before the : is returned,
<br>
otherwise the argument after the : is returned. For
example:</p>

<p style="margin-top: 1em">printf &quot;I have %d dog%s.0,
$n, <br>
($n == 1) ? &quot;&quot; : &quot;s&quot;;</p>

<p style="margin-top: 1em">Scalar or list context
propagates downward into the 2nd or 3rd argument, whichever
is selected.</p>

<p style="margin-top: 1em">$a = $ok ? $b : $c; # get a
scalar <br>
@a = $ok ? @b : @c; # get an array <br>
$a = $ok ? @b : @c; # oops, that&rsquo;s just a count!</p>

<p style="margin-top: 1em">The operator may be assigned to
if both the 2nd and 3rd arguments are legal lvalues (meaning
that you can assign to them):</p>

<p style="margin-top: 1em">($a_or_b ? $a : $b) = $c;</p>

<p style="margin-top: 1em">Because this operator produces
an assignable result, using assignments without parentheses
will get you in trouble. For example, this:</p>

<p style="margin-top: 1em">$a % 2 ? $a += 10 : $a += 2</p>

<p style="margin-top: 1em">Really means this:</p>

<p style="margin-top: 1em">(($a % 2) ? ($a += 10) : $a) +=
2</p>

<p style="margin-top: 1em">Rather than this:</p>

<p style="margin-top: 1em">($a % 2) ? ($a += 10) : ($a +=
2)</p>

<p style="margin-top: 1em">That should probably be written
more simply as:</p>

<p style="margin-top: 1em">$a += ($a % 2) ? 10 : 2;</p>

<p style="margin-top: 1em">Assignment Operators <br>
&quot;=&quot; is the ordinary assignment operator.</p>

<p style="margin-top: 1em">Assignment operators work as in
C. That is,</p>

<p style="margin-top: 1em">$a += 2;</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">$a = $a + 2;</p>

<p style="margin-top: 1em">although without duplicating any
side effects that dereferencing the lvalue might trigger,
such as from tie(). Other assignment operators work
similarly. The following are <br>
recognized:</p>

<p style="margin-top: 1em">**= += *= &amp;= &lt;&lt;=
&amp;&amp;= <br>
-= /= |= &gt;&gt;= ||= <br>
.= %= ^= //= <br>
x=</p>

<p style="margin-top: 1em">Although these are grouped by
family, they all have the precedence of assignment.</p>

<p style="margin-top: 1em">Unlike in C, the scalar
assignment operator produces a valid lvalue. Modifying an
assignment is equivalent to doing the assignment and then
modifying the variable that was <br>
assigned to. This is useful for modifying a copy of
something, like this:</p>

<p style="margin-top: 1em">($tmp = $global) =~
tr/13579/24680/;</p>

<p style="margin-top: 1em">Although as of 5.14, that can be
also be accomplished this way:</p>

<p style="margin-top: 1em">use v5.14; <br>
$tmp = ($global =~ tr/13579/24680/r);</p>

<p style="margin-top: 1em">Likewise,</p>

<p style="margin-top: 1em">($a += 2) *= 3;</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">$a += 2; <br>
$a *= 3;</p>

<p style="margin-top: 1em">Similarly, a list assignment in
list context produces the list of lvalues assigned to, and a
list assignment in scalar context returns the number of
elements produced by the <br>
expression on the right hand side of the assignment.</p>

<p style="margin-top: 1em">Comma Operator <br>
Binary &quot;,&quot; is the comma operator. In scalar
context it evaluates its left argument, throws that value
away, then evaluates its right argument and returns that
value. This is <br>
just like C&rsquo;s comma operator.</p>

<p style="margin-top: 1em">In list context, it&rsquo;s just
the list argument separator, and inserts both its arguments
into the list. These arguments are also evaluated from left
to right.</p>

<p style="margin-top: 1em">The &quot;=&gt;&quot; operator
is a synonym for the comma except that it causes a word on
its left to be interpreted as a string if it begins with a
letter or underscore and is composed only <br>
of letters, digits and underscores. This includes operands
that might otherwise be interpreted as operators, constants,
single number v-strings or function calls. If in doubt <br>
about this behavior, the left operand can be quoted
explicitly.</p>

<p style="margin-top: 1em">Otherwise, the &quot;=&gt;&quot;
operator behaves exactly as the comma operator or list
argument separator, according to context.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">use constant FOO =&gt;
&quot;something&quot;;</p>

<p style="margin-top: 1em">my %h = ( FOO =&gt; 23 );</p>

<p style="margin-top: 1em">is equivalent to:</p>

<p style="margin-top: 1em">my %h = (&quot;FOO&quot;,
23);</p>

<p style="margin-top: 1em">It is NOT:</p>

<p style="margin-top: 1em">my %h = (&quot;something&quot;,
23);</p>

<p style="margin-top: 1em">The &quot;=&gt;&quot; operator
is helpful in documenting the correspondence between keys
and values in hashes, and other paired elements in
lists.</p>

<p style="margin-top: 1em">%hash = ( $key =&gt; $value );
<br>
login( $username =&gt; $password );</p>

<p style="margin-top: 1em">The special quoting behavior
ignores precedence, and hence may apply to part of the left
operand:</p>

<p style="margin-top: 1em">print time.shift =&gt;
&quot;bbb&quot;;</p>

<p style="margin-top: 1em">That example prints something
like &quot;1314363215shiftbbb&quot;, because the
&quot;=&gt;&quot; implicitly quotes the &quot;shift&quot;
immediately on its left, ignoring the fact that
&quot;time.shift&quot; is the entire <br>
left operand.</p>

<p style="margin-top: 1em">List Operators (Rightward) <br>
On the right side of a list operator, the comma has very low
precedence, such that it controls all comma-separated
expressions found there. The only operators with lower <br>
precedence are the logical operators &quot;and&quot;,
&quot;or&quot;, and &quot;not&quot;, which may be used to
evaluate calls to list operators without the need for
parentheses:</p>

<p style="margin-top: 1em">open HANDLE, &quot;&lt;
:utf8&quot;, &quot;filename&quot; or die &quot;Can&rsquo;t
open: $!0;</p>

<p style="margin-top: 1em">However, some people find that
code harder to read than writing it with parentheses:</p>

<p style="margin-top: 1em">open(HANDLE, &quot;&lt;
:utf8&quot;, &quot;filename&quot;) or die &quot;Can&rsquo;t
open: $!0;</p>

<p style="margin-top: 1em">in which case you might as well
just use the more customary &quot;||&quot; operator:</p>

<p style="margin-top: 1em">open(HANDLE, &quot;&lt;
:utf8&quot;, &quot;filename&quot;) || die &quot;Can&rsquo;t
open: $!0;</p>

<p style="margin-top: 1em">See also discussion of list
operators in &quot;Terms and List Operators
(Leftward)&quot;.</p>

<p style="margin-top: 1em">Logical Not <br>
Unary &quot;not&quot; returns the logical negation of the
expression to its right. It&rsquo;s the equivalent of
&quot;!&quot; except for the very low precedence.</p>

<p style="margin-top: 1em">Logical And <br>
Binary &quot;and&quot; returns the logical conjunction of
the two surrounding expressions. It&rsquo;s equivalent to
&quot;&amp;&amp;&quot; except for the very low precedence.
This means that it short-circuits: <br>
the right expression is evaluated only if the left
expression is true.</p>

<p style="margin-top: 1em">Logical or and Exclusive Or <br>
Binary &quot;or&quot; returns the logical disjunction of the
two surrounding expressions. It&rsquo;s equivalent to
&quot;||&quot; except for the very low precedence. This
makes it useful for control <br>
flow:</p>

<p style="margin-top: 1em">print FH $data or die
&quot;Can&rsquo;t write to FH: $!&quot;;</p>

<p style="margin-top: 1em">This means that it
short-circuits: the right expression is evaluated only if
the left expression is false. Due to its precedence, you
must be careful to avoid using it as <br>
replacement for the &quot;||&quot; operator. It usually
works out better for flow control than in assignments:</p>

<p style="margin-top: 1em">$a = $b or $c; # bug: this is
wrong <br>
($a = $b) or $c; # really means this <br>
$a = $b || $c; # better written this way</p>

<p style="margin-top: 1em">However, when it&rsquo;s a
list-context assignment and you&rsquo;re trying to use
&quot;||&quot; for control flow, you probably need
&quot;or&quot; so that the assignment takes higher
precedence.</p>

<p style="margin-top: 1em">@info = stat($file) || die; #
oops, scalar sense of stat! <br>
@info = stat($file) or die; # better, now @info gets its
due</p>

<p style="margin-top: 1em">Then again, you could always use
parentheses.</p>

<p style="margin-top: 1em">Binary &quot;xor&quot; returns
the exclusive-OR of the two surrounding expressions. It
cannot short-circuit (of course).</p>

<p style="margin-top: 1em">There is no low precedence
operator for defined-OR.</p>

<p style="margin-top: 1em">C Operators Missing From Perl
<br>
Here is what C has that Perl doesn&rsquo;t:</p>

<p style="margin-top: 1em">unary &amp; Address-of operator.
(But see the &quot;</p>

<p style="margin-top: 1em">unary * Dereference-address
operator. (Perl&rsquo;s prefix dereferencing operators are
typed: $, @, %, and &amp;.)</p>

<p style="margin-top: 1em">(TYPE) Type-casting
operator.</p>

<p style="margin-top: 1em">Quote and Quote-like Operators
<br>
While we usually think of quotes as literal values, in Perl
they function as operators, providing various kinds of
interpolating and pattern matching capabilities. Perl
provides <br>
customary quote characters for these behaviors, but also
provides a way for you to choose your quote character for
any of them. In the following table, a &quot;{}&quot;
represents any <br>
pair of delimiters you choose.</p>

<p style="margin-top: 1em">Customary Generic Meaning
Interpolates <br>
&rsquo;&rsquo; q{} Literal no <br>
&quot;&quot; qq{} Literal yes <br>
&lsquo;&lsquo; qx{} Command yes* <br>
qw{} Word list no <br>
// m{} Pattern match yes* <br>
qr{} Pattern yes* <br>
s{}{} Substitution yes* <br>
tr{}{} Transliteration no (but see below) <br>
y{}{} Transliteration no (but see below) <br>
&lt;&lt;EOF here-doc yes*</p>

<p style="margin-top: 1em">* unless the delimiter is
&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">Non-bracketing delimiters use
the same character fore and aft, but the four sorts of ASCII
brackets (round, angle, square, curly) all nest, which means
that</p>

<p style="margin-top: 1em">q{foo{bar}baz}</p>

<p style="margin-top: 1em">is the same as</p>

<p style="margin-top: 1em">&rsquo;foo{bar}baz&rsquo;</p>

<p style="margin-top: 1em">Note, however, that this does
not always work for quoting Perl code:</p>

<p style="margin-top: 1em">$s = q{ if($a eq &quot;}&quot;)
... }; # WRONG</p>

<p style="margin-top: 1em">is a syntax error. The
&quot;Text::Balanced&quot; module (standard as of v5.8, and
from CPAN before then) is able to do this properly.</p>

<p style="margin-top: 1em">There can be whitespace between
the operator and the quoting characters, except when
&quot;#&quot; is being used as the quoting character.
&quot;q#foo#&quot; is parsed as the string &quot;foo&quot;,
while &quot;q <br>
#foo#&quot; is the operator &quot;q&quot; followed by a
comment. Its argument will be taken from the next line. This
allows you to write:</p>

<p style="margin-top: 1em">s {foo} # Replace foo <br>
{bar} # with bar.</p>

<p style="margin-top: 1em">The following escape sequences
are available in constructs that interpolate, and in
transliterations:</p>

<p style="margin-top: 1em">Sequence Note Description <br>
tab (HT, TAB) <br>
newline (NL) <br>
return (CR) <br>
form feed (FF) <br>
backspace (BS) <br>
alarm (bell) (BEL) <br>
\ escape (ESC) <br>
} [1,8] hex char (example: SMILEY) <br>
b [2,8] restricted range hex char (example: ESC) <br>
ame} [3] named Unicode character or character sequence <br>
+263D} [4,8] Unicode character (example: FIRST QUARTER MOON)
) <br>
33 [7,8] restricted range octal char (example: ESC)</p>

<p style="margin-top: 1em">[1] The result is the character
specified by the hexadecimal number between the braces. See
&quot;[8]&quot; below for details on which character.</p>

<p style="margin-top: 1em">Only hexadecimal digits are
valid between the braces. If an invalid character is
encountered, a warning will be issued and the invalid
character and all subsequent characters <br>
(valid or invalid) within the braces will be discarded.</p>

<p style="margin-top: 1em">If there are no valid digits
between the braces, the generated character is the NULL
character (&quot;&quot;). However, an explicit empty brace
(&quot;&quot;) will not cause a warning <br>
(currently).</p>

<p style="margin-top: 1em">[2] The result is the character
specified by the hexadecimal number in the range 0x00 to
0xFF. See &quot;[8]&quot; below for details on which
character.</p>

<p style="margin-top: 1em">Only hexadecimal digits are
valid following &quot; When &quot;s followed by fewer than
two valid digits, any valid digits will be zero-padded. This
means that &quot;&quot; will be <br>
interpreted as &quot;7&quot;, and a lone &lt; will be
interpreted as &quot;0&quot;. Except at the end of a string,
having fewer than two valid digits will result in a warning.
Note that <br>
although the warning says the illegal character is ignored,
it is only ignored as part of the escape and will still be
used as the subsequent character in the string. For <br>
example:</p>

<p style="margin-top: 1em">Original Result Warns? <br>
&quot;&quot; &quot;7&quot; no <br>
&quot;0&quot; no <br>
&quot;q&quot; &quot;7q&quot; yes <br>
&quot; &quot;0q&quot; yes</p>

<p style="margin-top: 1em">[3] The result is the Unicode
character or character sequence given by name. See
charnames.</p>

<p style="margin-top: 1em">[4] &quot;+hexadecimal
number}&quot; means the Unicode character whose Unicode code
point is hexadecimal number.</p>

<p style="margin-top: 1em">[5] The character following
&quot; <br>
Sequence Value <br>
... <br>
In other words, it&rsquo;s the character whose code point
has had 64 xor&rsquo;d with its uppercase. &quot;
&quot;@&quot; is 64, so xor&rsquo;ing 64 itself produces
0.</p>

<p style="margin-top: 1em">Also, &quot; <br>
On ASCII platforms, the resulting characters from the list
above are the complete set of ASCII controls. This
isn&rsquo;t the case on EBCDIC platforms; see &quot;OPERATOR
DIFFERENCES&quot; <br>
in perlebcdic for the complete list of what these sequences
mean on both ASCII and EBCDIC platforms.</p>

<p style="margin-top: 1em">Use of any other character
following the &quot;c&quot; besides those listed above is
discouraged, and some are deprecated with the intention of
removing those in a later Perl version. <br>
What happens for any of these other characters currently
though, is that the value is derived by xor&rsquo;ing with
the seventh bit, which is 64.</p>

<p style="margin-top: 1em">To get platform independent
controls, you can use &quot;</p>

<p style="margin-top: 1em">[6] The result is the character
specified by the octal number between the braces. See
&quot;[8]&quot; below for details on which character.</p>

<p style="margin-top: 1em">If a character that isn&rsquo;t
an octal digit is encountered, a warning is raised, and the
value is based on the octal digits before it, discarding it
and all following characters <br>
up to the closing brace. It is a fatal error if there are no
octal digits at all.</p>

<p style="margin-top: 1em">[7] The result is the character
specified by the three-digit octal number in the range 000
to 777 (but best to not use above 077, see next paragraph).
See &quot;[8]&quot; below for <br>
details on which character.</p>

<p style="margin-top: 1em">Some contexts allow 2 or even 1
digit, but any usage without exactly three digits, the first
being a zero, may give unintended results. (For example, in
a regular expression <br>
it may be confused with a backreference; see &quot;Octal
escapes&quot; in perlrebackslash.) Starting in Perl 5.14,
you may use &quot;. <br>
Otherwise, it is best to use this construct only for
ordinals &quot; 77&quot; and below, remembering to pad to
the left with zeros to make three digits. For larger
ordinals, either <br>
use &quot;.</p>

<p style="margin-top: 1em">Having fewer than 3 digits may
lead to a misleading warning message that says that what
follows is ignored. For example, &quot;128&quot; in the
ASCII character set is equivalent to <br>
the two characters &quot;0&quot;, but the warning
&quot;Illegal octal digit &rsquo;8&rsquo; ignored&quot; will
be thrown. If &quot;0&quot; is what you want, you can avoid
this warning by padding your octal <br>
number with 0&rsquo;s: &quot; 128&quot;.</p>

<p style="margin-top: 1em">[8] Several constructs above
specify a character by a number. That number gives the
character&rsquo;s position in the character set encoding
(indexed from 0). This is called <br>
synonymously its ordinal, code position, or code point. Perl
works on platforms that have a native encoding currently of
either ASCII/Latin1 or EBCDIC, each of which allow <br>
specification of 256 characters. In general, if the number
is 255 (0xFF, 0377) or below, Perl interprets this in the
platform&rsquo;s native encoding. If the number is 256 <br>
(0x100, 0400) or above, Perl interprets it as a Unicode code
point and the result is the corresponding Unicode character.
For example &quot;&quot; and &quot;e <br>
number 80 in decimal, which is less than 256, so the number
is interpreted in the native character set encoding. In
ASCII the character in the 80th position (indexed from 0)
<br>
is the letter &quot;P&quot;, and in EBCDIC it is the
ampersand symbol &quot;&amp;&quot;. &quot;&quot; and &quot;o
<br>
matter what the native encoding is. The name of the
character in the 256th position (indexed by 0) in Unicode is
&quot;LATIN CAPITAL LETTER A WITH MACRON&quot;.</p>

<p style="margin-top: 1em">There are a couple of exceptions
to the above rule. &quot;+hex number}&quot; is always
interpreted as a Unicode code point, so that
&quot;+0050}&quot; is &quot;P&quot; even on EBCDIC
platforms. <br>
And if &quot;use encoding&quot; is in effect, the number is
considered to be in that encoding, and is translated from
that into the platform&rsquo;s native encoding if there is a
<br>
corresponding native character; otherwise to Unicode.</p>

<p style="margin-top: 1em">NOTE: Unlike C and other
languages, Perl has no &quot;scape sequence for the vertical
tab (VT - ASCII 11), but you may use &quot; expression
patterns in Perl, see perlre.)</p>

<p style="margin-top: 1em">The following escape sequences
are available in constructs that interpolate, but not in
transliterations.</p>

<p style="margin-top: 1em">lowercase next character only
<br>
titlecase (not uppercase!) next character only <br>
lowercase all characters till &nbsp;or end of string <br>
U uppercase all characters till &nbsp;or end of string <br>
foldcase all characters till &nbsp;or end of string <br>
Q quote (disable) pattern metacharacters till &nbsp;or <br>
end of string &nbsp; <br>
end either case modification or quoted section <br>
(whichever was last seen)</p>

<p style="margin-top: 1em">See &quot;quotemeta&quot; in
perlfunc for the exact definition of characters that are
quoted by &quot;Q&quot;.</p>

<p style="margin-top: 1em">&quot; &quot;U&quot;, &quot;,
and &quot;Q&quot; can stack, in which case you need one
&quot;</p>

<p style="margin-top: 1em">say&quot;This Qquoting business
Uhere isn&rsquo;t quite&nbsp;done yet,&nbsp;is it?&quot;;
<br>
This
quoting&nbsp;Business&nbsp;HERE&nbsp;ISN&acute;T&nbsp;QUITE&nbsp;done&nbsp;yet
is it?</p>

<p style="margin-top: 1em">If &quot;use locale&quot; is in
effect (but not &quot;use locale
&rsquo;:not_characters&rsquo;&quot;), the case map used by
&quot; &quot; &quot;&quot;, and &quot;U&quot; is taken from
the current locale. See perllocale. If <br>
Unicode (for example, &quot;&quot; or code points of 0x100
or beyond) is being used, the case map used by &quot; &quot;
&quot;&quot;, and &quot;U&quot; is as defined by Unicode.
That means that case- <br>
mapping a single character can sometimes produce several
characters. Under &quot;use locale&quot;, &quot; produces
the same results as &quot; All systems use the virtual
&quot;0 to represent a line terminator, called a
&quot;newline&quot;. There is no such thing as an unvarying,
physical newline character. It is only an illusion <br>
that the operating system, device drivers, C
libraries,&quot; as and Perl all conspire to preserve. Not
all systems read &quot; ASCII CR and &quot;0 as ASCII LF.
For example, on the <br>
ancient Macs (pre-MacOS X) of yesteryear, these used to be
reversed, and on systems without line terminator, printing
&quot;0 might emit no actual data. In general, use &quot;0
when <br>
you mean a &quot;newline&quot; for your system, but use the
literal ASCII when you need an exact character. For example,
most networking protocols expect and prefer a CR+LF (&quot;
15 12&quot; or <br>
&quot; burned some day.</p>

<p style="margin-top: 1em">For constructs that do
interpolate, variables beginning with
&quot;&quot;$&quot;&quot; or &quot;&quot;@&quot;&quot; are
interpolated. Subscripted variables such as $a[3] or
&quot;$href-&gt;{key}[0]&quot; are also interpolated, as
<br>
are array and hash slices. But method calls such as
&quot;$obj-&gt;meth&quot; are not.</p>

<p style="margin-top: 1em">Interpolating an array or slice
interpolates the elements in order, separated by the value
of $&quot;, so is equivalent to interpolating &quot;join
$&quot;, @array&quot;. &quot;Punctuation&quot; arrays such
<br>
as &quot;@*&quot; are usually interpolated only if the name
is enclosed in braces &quot;@{*}&quot;, but the arrays @_,
&quot;@+&quot;, and &quot;@-&quot; are interpolated even
without braces.</p>

<p style="margin-top: 1em">For double-quoted strings, the
quoting from &quot;Q&quot; is applied after interpolation
and escapes are processed.</p>

<p style="margin-top: 1em">&quot;abcQfoobar$s&quot;</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">&quot;abc&quot; .
quotemeta(&quot;foobar$s&quot;) . &quot;xyz&quot;</p>

<p style="margin-top: 1em">For the pattern of regex
operators (&quot;qr//&quot;, &quot;m//&quot; and
&quot;s///&quot;), the quoting from &quot;Q&quot; is applied
after interpolation is processed, but before escapes are
processed. This allows <br>
the pattern to match literally (except for &quot;$&quot; and
&quot;@&quot;). For example, the following matches:</p>

<p style="margin-top: 1em">&rsquo;&rsquo; =~ /Q/</p>

<p style="margin-top: 1em">Because &quot;$&quot; or
&quot;@&quot; trigger interpolation, you&rsquo;ll need to
use something like &quot;/Quser\@Qhost/&quot; to match them
literally.</p>

<p style="margin-top: 1em">Patterns are subject to an
additional level of interpretation as a regular expression.
This is done as a second pass, after variables are
interpolated, so that regular <br>
expressions may be incorporated into the pattern from the
variables. If this is not what you want, use &quot;Q&quot;
to interpolate a variable literally.</p>

<p style="margin-top: 1em">Apart from the behavior
described above, Perl does not expand multiple levels of
interpolation. In particular, contrary to the expectations
of shell programmers, back-quotes do <br>
NOT interpolate within double quotes, nor do single quotes
impede evaluation of variables when used within double
quotes.</p>

<p style="margin-top: 1em">Regexp Quote-Like Operators <br>
Here are the quote-like operators that apply to pattern
matching and related activities.</p>

<p style="margin-top: 1em">qr/STRING/msixpodual <br>
This operator quotes (and possibly compiles) its STRING as a
regular expression. STRING is interpolated the same way as
PATTERN in &quot;m/PATTERN/&quot;. If &quot;&rsquo;&quot; is
used as the <br>
delimiter, no interpolation is done. Returns a Perl value
which may be used instead of the corresponding
&quot;/STRING/msixpodual&quot; expression. The returned
value is a <br>
normalized version of the original pattern. It magically
differs from a string containing the same characters:
&quot;ref(qr/x/)&quot; returns &quot;Regexp&quot;; however,
dereferencing it is <br>
not well defined (you currently get the normalized version
of the original pattern, but this may change).</p>

<p style="margin-top: 1em">For example,</p>

<p style="margin-top: 1em">$rex = qr/my.STRING/is; <br>
print $rex; # prints (?si-xm:my.STRING) <br>
s/$rex/foo/;</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">s/my.STRING/foo/is;</p>

<p style="margin-top: 1em">The result may be used as a
subpattern in a match:</p>

<p style="margin-top: 1em">$re = qr/$pattern/; <br>
$string =~ /foo${re}bar/; # can be interpolated in other
patterns <br>
$string =~ $re; # or used standalone <br>
$string =~ /$re/; # or this way</p>

<p style="margin-top: 1em">Since Perl may compile the
pattern at the moment of execution of the qr() operator,
using qr() may have speed advantages in some situations,
notably if the result of qr() <br>
is used standalone:</p>

<p style="margin-top: 1em">sub match { <br>
my $patterns = shift; <br>
my @compiled = map qr/$_/i, @$patterns; <br>
grep { <br>
my $success = 0; <br>
foreach my $pat (@compiled) { <br>
$success = 1, last if /$pat/; <br>
} <br>
$success; <br>
} @_; <br>
}</p>

<p style="margin-top: 1em">Precompilation of the pattern
into an internal representation at the moment of qr() avoids
a need to recompile the pattern every time a match
&quot;/$pat/&quot; is attempted. <br>
(Perl has many other internal optimizations, but none would
be triggered in the above example if we did not use qr()
operator.)</p>

<p style="margin-top: 1em">Options (specified by the
following modifiers) are:</p>

<p style="margin-top: 1em">m Treat string as multiple
lines. <br>
s Treat string as single line. (Make . match a newline) <br>
i Do case-insensitive pattern matching. <br>
x Use extended regular expressions. <br>
p When matching preserve a copy of the matched string so
<br>
that ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined.
<br>
o Compile pattern only once. <br>
a ASCII-restrict: Use ASCII for , further restricts /i
matching so that no ASCII character will <br>
match a non-ASCII one <br>
l Use the locale <br>
u Use Unicode rules <br>
d Use Unicode or native charset, as in 5.12 and earlier</p>

<p style="margin-top: 1em">If a precompiled pattern is
embedded in a larger pattern then the effect of
&quot;msixpluad&quot; will be propagated appropriately. The
effect the &quot;o&quot; modifier has is not <br>
propagated, being restricted to those patterns explicitly
using it.</p>

<p style="margin-top: 1em">The last four modifiers listed
above, added in Perl 5.14, control the character set
semantics, but &quot;/a&quot; is the only one you are likely
to want to specify explicitly; the <br>
other three are selected automatically by various
pragmas.</p>

<p style="margin-top: 1em">See perlre for additional
information on valid syntax for STRING, and for a detailed
look at the semantics of regular expressions. In particular,
all modifiers except <br>
the largely obsolete &quot;/o&quot; are further explained in
&quot;Modifiers&quot; in perlre. &quot;/o&quot; is described
in the next section.</p>

<p style="margin-top: 1em">m/PATTERN/msixpodualgc <br>
/PATTERN/msixpodualgc <br>
Searches a string for a pattern match, and in scalar context
returns true if it succeeds, false if it fails. If no string
is specified via the &quot;=~&quot; or &quot;!~&quot;
operator, the <br>
$_ string is searched. (The string specified with
&quot;=~&quot; need not be an lvalue--it may be the result
of an expression evaluation, but remember the &quot;=~&quot;
binds rather <br>
tightly.) See also perlre.</p>

<p style="margin-top: 1em">Options are as described in
&quot;qr//&quot; above; in addition, the following match
process modifiers are available:</p>

<p style="margin-top: 1em">g Match globally, i.e., find all
occurrences. <br>
c Do not reset search position on a failed match when /g is
in effect.</p>

<p style="margin-top: 1em">If &quot;/&quot; is the
delimiter then the initial &quot;m&quot; is optional. With
the &quot;m&quot; you can use any pair of non-whitespace
(ASCII) characters as delimiters. This is particularly <br>
useful for matching path names that contain &quot;/&quot;,
to avoid LTS (leaning toothpick syndrome). If &quot;?&quot;
is the delimiter, then a match-only-once rule applies,
described in <br>
&quot;m?PATTERN?&quot; below. If &quot;&rsquo;&quot; is the
delimiter, no interpolation is performed on the PATTERN.
When using a character valid in an identifier, whitespace is
required after <br>
the &quot;m&quot;.</p>

<p style="margin-top: 1em">PATTERN may contain variables,
which will be interpolated every time the pattern search is
evaluated, except for when the delimiter is a single quote.
(Note that $(, $), <br>
and $| are not interpolated because they look like
end-of-string tests.) Perl will not recompile the pattern
unless an interpolated variable that it contains changes.
<br>
You can force Perl to skip the test and never recompile by
adding a &quot;/o&quot; (which stands for &quot;once&quot;)
after the trailing delimiter. Once upon a time, Perl would
recompile <br>
regular expressions unnecessarily, and this modifier was
useful to tell it not to do so, in the interests of speed.
But now, the only reasons to use &quot;/o&quot; are
either:</p>

<p style="margin-top: 1em">1. The variables are thousands
of characters long and you know that they don&rsquo;t
change, and you need to wring out the last little bit of
speed by having Perl skip testing <br>
for that. (There is a maintenance penalty for doing this, as
mentioning &quot;/o&quot; constitutes a promise that you
won&rsquo;t change the variables in the pattern. If you do
<br>
change them, Perl won&rsquo;t even notice.)</p>

<p style="margin-top: 1em">2. you want the pattern to use
the initial values of the variables regardless of whether
they change or not. (But there are saner ways of
accomplishing this than using <br>
&quot;/o&quot;.)</p>

<p style="margin-top: 1em">The bottom line is that using
&quot;/o&quot; is almost never a good idea.</p>

<p style="margin-top: 1em">The empty pattern // <br>
If the PATTERN evaluates to the empty string, the last
successfully matched regular expression is used instead. In
this case, only the &quot;g&quot; and &quot;c&quot; flags on
the empty <br>
pattern are honored; the other flags are taken from the
original pattern. If no match has previously succeeded, this
will (silently) act instead as a genuine empty <br>
pattern (which will always match).</p>

<p style="margin-top: 1em">Note that it&rsquo;s possible to
confuse Perl into thinking &quot;//&quot; (the empty regex)
is really &quot;//&quot; (the defined-or operator). Perl is
usually pretty good about this, but some <br>
pathological cases might trigger this, such as
&quot;$a///&quot; (is that &quot;($a) / (//)&quot; or
&quot;$a // /&quot;?) and &quot;print $fh //&quot;
(&quot;print $fh(//&quot; or &quot;print($fh //&quot;?). In
all of these <br>
examples, Perl will assume you meant defined-or. If you
meant the empty regex, just use parentheses or spaces to
disambiguate, or even prefix the empty regex with an
&quot;m&quot; <br>
(so &quot;//&quot; becomes &quot;m//&quot;).</p>

<p style="margin-top: 1em">Matching in list context <br>
If the &quot;/g&quot; option is not used, &quot;m//&quot; in
list context returns a list consisting of the subexpressions
matched by the parentheses in the pattern, that is, ($1, $2,
$3...). <br>
(Note that here $1 etc. are also set, and that this differs
from Perl 4&rsquo;s behavior.) When there are no parentheses
in the pattern, the return value is the list &quot;(1)&quot;
for <br>
success. With or without parentheses, an empty list is
returned upon failure.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">open(TTY,
&quot;+&lt;/dev/tty&quot;) <br>
|| die &quot;can&rsquo;t access /dev/tty: $!&quot;;</p>

<p style="margin-top: 1em">&lt;TTY&gt; =~ /^y/i &amp;&amp;
foo(); # do foo if desired</p>

<p style="margin-top: 1em">if (/Version: *([0-9.]*)/) {
$version = $1; }</p>

<p style="margin-top: 1em">next if m#^/usr/spool/uucp#;</p>

<p style="margin-top: 1em"># poor man&rsquo;s grep <br>
$arg = shift; <br>
while (&lt;&gt;) { <br>
print if /$arg/o; # compile only once (no longer needed!)
<br>
}</p>

<p style="margin-top: 1em">if (($F1, $F2, $Etc) = ($foo =~
/^()(.*)/))</p>

<p style="margin-top: 1em">This last example splits $foo
into the first two words and the remainder of the line, and
assigns those three fields to $F1, $F2, and $Etc. The
conditional is true if <br>
any variables were assigned; that is, if the pattern
matched.</p>

<p style="margin-top: 1em">The &quot;/g&quot; modifier
specifies global pattern matching--that is, matching as many
times as possible within the string. How it behaves depends
on the context. In list <br>
context, it returns a list of the substrings matched by any
capturing parentheses in the regular expression. If there
are no parentheses, it returns a list of all the <br>
matched strings, as if there were parentheses around the
whole pattern.</p>

<p style="margin-top: 1em">In scalar context, each
execution of &quot;m//g&quot; finds the next match,
returning true if it matches, and false if there is no
further match. The position after the last match <br>
can be read or set using the &quot;pos()&quot; function; see
&quot;pos&quot; in perlfunc. A failed match normally resets
the search position to the beginning of the string, but you
can avoid <br>
that by adding the &quot;/c&quot; modifier (for example,
&quot;m//gc&quot;). Modifying the target string also resets
the search position.</p>

<p style="margin-top: 1em">G assertion <br>
You can intermix &quot;m//g&quot; matches with
&quot;m/G.../g&quot;, where &quot;G&quot; is a zero-width
assertion that matches the exact position where the previous
&quot;m//g&quot;, if any, left off. <br>
Without the &quot;/g&quot; modifier, the &quot;G&quot;
assertion still anchors at &quot;pos()&quot; as it was at
the start of the operation (see &quot;pos&quot; in
perlfunc), but the match is of course only <br>
attempted once. Using &quot;G&quot; without &quot;/g&quot;
on a target string that has not previously had a
&quot;/g&quot; match applied to it is the same as using the
&quot;0 <br>
beginning of the string. Note also that, currently,
&quot;G&quot; is only properly supported when anchored at
the very beginning of the pattern.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em"># list context <br>
($one,$five,$fifteen) = (&lsquo;uptime&lsquo; =~
/(+.+)/g);</p>

<p style="margin-top: 1em"># scalar context <br>
local $/ = &quot;&quot;; <br>
while ($paragraph = &lt;&gt;) { <br>
while ($paragraph =~
/{Ll}[&rsquo;&quot;)]*[.!?]+[&rsquo;&quot;)]*g) { <br>
$sentences++; <br>
} <br>
} <br>
say $sentences;</p>

<p style="margin-top: 1em">Here&rsquo;s another way to
check for sentences in a paragraph:</p>

<p style="margin-top: 1em">my $sentence_rx = qr{ <br>
(?: (?&lt;= ^ ) | (?&lt;= ) ) # after start-of-string or
whitespace <br>
{Lu} # capital letter <br>
.*? # a bunch of anything <br>
(?&lt;= ) # that ends in non-whitespace [ D M <br>
(?&lt;! S ) # but isn&rsquo;t a common ] r abbreviation M
<br>
(?&lt;! r) s S <br>
(?&lt;! r) a S <br>
(?&lt;! t ) <br>
[.?!] # followed by a sentence ender <br>
(?= $ | ) # in front of end-of-string or whitespace <br>
}sx; <br>
local $/ = &quot;&quot;; <br>
while (my $paragraph = &lt;&gt;) { <br>
say &quot;NEW PARAGRAPH&quot;; <br>
my $count = 0; <br>
while ($paragraph =~ /($sentence_rx)/g) { <br>
printf &quot;got sentence %d: &lt;%s&gt;0, ++$count, $1;
<br>
} <br>
}</p>

<p style="margin-top: 1em">Here&rsquo;s how to use
&quot;m//gc&quot; with &quot;G&quot;:</p>

<p style="margin-top: 1em">$_ = &quot;ppooqppqq&quot;; <br>
while ($i++ &lt; 2) { <br>
print &quot;1: &rsquo;&quot;; <br>
print $1 while /(o)/gc; print &quot;&rsquo;, pos=&quot;,
pos, &quot;0; <br>
print &quot;2: &rsquo;&quot;; <br>
print $1 if /G(q)/gc; print &quot;&rsquo;, pos=&quot;, pos,
&quot;0; <br>
print &quot;3: &rsquo;&quot;; <br>
print $1 while /(p)/gc; print &quot;&rsquo;, pos=&quot;,
pos, &quot;0; <br>
} <br>
print &quot;Final: &rsquo;$1&rsquo;, pos=&quot;,pos,&quot;0
if /G(.)/;</p>

<p style="margin-top: 1em">The last example should
print:</p>

<p style="margin-top: 1em">1: &rsquo;oo&rsquo;, pos=4 <br>
2: &rsquo;q&rsquo;, pos=5 <br>
3: &rsquo;pp&rsquo;, pos=7 <br>
1: &rsquo;&rsquo;, pos=7 <br>
2: &rsquo;q&rsquo;, pos=8 <br>
3: &rsquo;&rsquo;, pos=8 <br>
Final: &rsquo;q&rsquo;, pos=8</p>

<p style="margin-top: 1em">Notice that the final match
matched &quot;q&quot; instead of &quot;p&quot;, which a
match without the &quot;G&quot; anchor would have done. Also
note that the final match did not update &quot;pos&quot;.
&quot;pos&quot; <br>
is only updated on a &quot;/g&quot; match. If the final
match did indeed match &quot;p&quot;, it&rsquo;s a good bet
that you&rsquo;re running a very old (pre-5.6.0) version of
Perl.</p>

<p style="margin-top: 1em">A useful idiom for
&quot;lex&quot;-like scanners is &quot;/G.../gc&quot;. You
can combine several regexps like this to process a string
part-by-part, doing different actions depending on <br>
which regexp matched. Each regexp tries to match where the
previous one leaves off.</p>

<p style="margin-top: 1em">$_ = &lt;&lt;&rsquo;EOL&rsquo;;
<br>
$url = URI::URL-&gt;new( &quot;http://example.com/&quot; );
die if $url eq &quot;xXx&quot;; <br>
EOL</p>

<p style="margin-top: 1em">LOOP: { , . ; ] <br>
print(&quot; digits&quot;), redo LOOP if /G+? / g c ; , . ;
] <br>
print(&quot; lowercase&quot;), redo LOOP if /G{Ll}+? / g c ;
, . ; ] <br>
print(&quot; UPPERCASE&quot;), redo LOOP if /G{Lu}+? / g c ;
<br>
print(&quot; Capitalized&quot;), redo LOOP if , . ; ]
/G{Lu}{Ll}+? / g c ; , . ; ] <br>
print(&quot; MiXeD&quot;), redo LOOP if /GL+? / g c ; <br>
print(&quot; alphanumeric&quot;), redo LOOP if , . ; ]
/G[{Alpha}N]+? / g c ; <br>
print(&quot; line-noise&quot;), redo LOOP if /GW+/gc; <br>
print &quot;. That&rsquo;s all!0; <br>
}</p>

<p style="margin-top: 1em">Here is the output (split into
several lines):</p>

<p style="margin-top: 1em">line-noise lowercase line-noise
UPPERCASE line-noise UPPERCASE <br>
line-noise lowercase line-noise lowercase line-noise
lowercase <br>
lowercase line-noise lowercase lowercase line-noise
lowercase <br>
lowercase line-noise MiXeD line-noise. That&rsquo;s all!</p>

<p style="margin-top: 1em">m?PATTERN?msixpodualgc <br>
?PATTERN?msixpodualgc <br>
This is just like the &quot;m/PATTERN/&quot; search, except
that it matches only once between calls to the reset()
operator. This is a useful optimization when you want to see
<br>
only the first occurrence of something in each file of a set
of files, for instance. Only &quot;m??&quot; patterns local
to the current package are reset.</p>

<p style="margin-top: 1em">while (&lt;&gt;) { <br>
if (m?^$?) { <br>
# blank line between header and body <br>
} <br>
} continue { <br>
reset if eof; # clear m?? status for next file <br>
}</p>

<p style="margin-top: 1em">Another example switched the
first &quot;latin1&quot; encoding it finds to
&quot;utf8&quot; in a pod file:</p>

<p style="margin-top: 1em">s//utf8/ if m? ^ =encoding K
latin1 ?x;</p>

<p style="margin-top: 1em">The match-once behavior is
controlled by the match delimiter being &quot;?&quot;; with
any other delimiter this is the normal &quot;m//&quot;
operator.</p>

<p style="margin-top: 1em">For historical reasons, the
leading &quot;m&quot; in &quot;m?PATTERN?&quot; is optional,
but the resulting &quot;?PATTERN?&quot; syntax is
deprecated, will warn on usage and might be removed from a
<br>
future stable release of Perl (without further notice!).</p>


<p style="margin-top: 1em">s/PATTERN/REPLACEMENT/msixpodualgcer
<br>
Searches a string for a pattern, and if found, replaces that
pattern with the replacement text and returns the number of
substitutions made. Otherwise it returns false <br>
(specifically, the empty string).</p>

<p style="margin-top: 1em">If the &quot;/r&quot;
(non-destructive) option is used then it runs the
substitution on a copy of the string and instead of
returning the number of substitutions, it returns the <br>
copy whether or not a substitution occurred. The original
string is never changed when &quot;/r&quot; is used. The
copy will always be a plain string, even if the input is an
<br>
object or a tied variable.</p>

<p style="margin-top: 1em">If no string is specified via
the &quot;=~&quot; or &quot;!~&quot; operator, the $_
variable is searched and modified. Unless the &quot;/r&quot;
option is used, the string specified must be a scalar <br>
variable, an array element, a hash element, or an assignment
to one of those; that is, some sort of scalar lvalue.</p>

<p style="margin-top: 1em">If the delimiter chosen is a
single quote, no interpolation is done on either the PATTERN
or the REPLACEMENT. Otherwise, if the PATTERN contains a $
that looks like a <br>
variable rather than an end-of-string test, the variable
will be interpolated into the pattern at run-time. If you
want the pattern compiled only once the first time the <br>
variable is interpolated, use the &quot;/o&quot; option. If
the pattern evaluates to the empty string, the last
successfully executed regular expression is used instead.
See <br>
perlre for further explanation on these.</p>

<p style="margin-top: 1em">Options are as with m// with the
addition of the following replacement specific options:</p>

<p style="margin-top: 1em">e Evaluate the right side as an
expression. <br>
ee Evaluate the right side as a string then eval the result.
<br>
r Return substitution and leave the original string
untouched.</p>

<p style="margin-top: 1em">Any non-whitespace delimiter may
replace the slashes. Add space after the &quot;s&quot; when
using a character allowed in identifiers. If single quotes
are used, no <br>
interpretation is done on the replacement string (the
&quot;/e&quot; modifier overrides this, however). Unlike
Perl 4, Perl 5 treats backticks as normal delimiters; the
<br>
replacement text is not evaluated as a command. If the
PATTERN is delimited by bracketing quotes, the REPLACEMENT
has its own pair of quotes, which may or may not be <br>
bracketing quotes, for example, &quot;s(foo)(bar)&quot; or
&quot;s&lt;foo&gt;/bar/&quot;. A &quot;/e&quot; will cause
the replacement portion to be treated as a full-fledged Perl
expression and evaluated <br>
right then and there. It is, however, syntax checked at
compile-time. A second &quot;e&quot; modifier will cause the
replacement portion to be &quot;eval&quot;ed before being
run as a Perl <br>
expression.</p>

<p style="margin-top: 1em">Examples:r e</p>

<p style="margin-top: 1em">s/e; # don&rsquo;t change
wintergreen n</p>

<p style="margin-top: 1em">$path =~
s|/usr/bin|/usr/local/bin|;</p>

<p style="margin-top: 1em">s/Login: $foo/Login: $bar/; #
run-time pattern</p>

<p style="margin-top: 1em">($foo = $bar) =~ s/this/that/; #
copy first, then change <br>
($foo = &quot;$bar&quot;) =~ s/this/that/; # convert to
string, copy, then change <br>
$foo = $bar =~ s/this/that/r; # Same as above using /r <br>
$foo = $bar =~ s/this/that/r <br>
=~ s/that/the other/r; # Chained substitutes using /r <br>
@foo = map { s/this/that/r } @bar # /r is very useful in
maps M</p>

<p style="margin-top: 1em">$count = ($paragraph =~
s/Misterrg); # get .change-count</p>

<p style="margin-top: 1em">$_ = &rsquo;abc123xyz&rsquo;;
<br>
s/+/$&amp;*2/e; # yields &rsquo;abc246xyz&rsquo; <br>
s/+/sprintf(&quot;%5d&quot;,$&amp;)/e; # yields &rsquo;abc
246xyz&rsquo; <br>
s/144eg; # yields &rsquo;aabbcc 224466xxyyzz&rsquo;</p>

<p style="margin-top: 1em">s/%(.)/$percent{$1}/g; # change
percent escapes; no /e <br>
s/%(.)/$percent{$1} || $&amp;/ge; # expr now, so /e <br>
s/^=(936</p>

<p style="margin-top: 1em">$_ = &rsquo;abc123xyz&rsquo;;
<br>
$a = s/abc/def/r; # $a is &rsquo;def123xyz&rsquo; and <br>
# $_ remains &rsquo;abc123xyz&rsquo;.</p>

<p style="margin-top: 1em"># expand variables in $_, but
dynamics only, using <br>
# symbolic dereferencing <br>
s/+)/${$1}/g;</p>

<p style="margin-top: 1em"># Add one to the value of any
numbers in the string <br>
s/(+)/1 + $1/eg;</p>

<p style="margin-top: 1em"># Titlecase words in the last 30
characters only { A l p <br>
substr($str, -30) =~ s/h a } + )</p>

<p style="margin-top: 1em"># This will expand any embedded
scalar variable <br>
# (including lexicals) in $_ : First $1 is interpolated <br>
# to the variable name, and then evaluated <br>
s/(w+)/$1/eeg;</p>

<p style="margin-top: 1em"># Delete (most) C comments. <br>
$program =~ s { <br>
/ # Match the opening delimiter. <br>
.*? # Match a minimal number of characters. <br>
# Match the closing delimiter. <br>
} []gsx;</p>

<p style="margin-top: 1em">s/^(.*?)$/$1/; # trim whitespace
in $_, expensively</p>

<p style="margin-top: 1em">for ($variable) { # trim
whitespace in $variable, cheap <br>
s/^/; <br>
s/; <br>
}</p>

<p style="margin-top: 1em">s/([^ ]*) *([^ ]*)/$2 $1/; #
reverse 1st two fields</p>

<p style="margin-top: 1em">Note the use of $ instead of
&nbsp;in the last example. Unlike sed, we use the
&lt;digit&gt; form in only the left hand side. Anywhere else
it&rsquo;s $&lt;digit&gt;.</p>

<p style="margin-top: 1em">Occasionally, you can&rsquo;t
use just a &quot;/g&quot; to get all the changes to occur
that you might want. Here are two common cases:</p>

<p style="margin-top: 1em"># put commas in the right places
in an integer <br>
1 while s/()()(?!)/$1,$2/g;</p>

<p style="margin-top: 1em"># expand tabs to 8-column
spacing <br>
1 while s/+/&rsquo; &rsquo; x (length($&amp;)*8 -
length($&lsquo;)%8)/e;</p>

<p style="margin-top: 1em">&quot;s///le&quot; is treated as
a substitution followed by the &quot;le&quot; operator, not
the &quot;/le&quot; flags. This may change in a future
version of Perl. It produces a warning if warnings <br>
are enabled. To disambiguate, use a space or change the
order of the flags:</p>

<p style="margin-top: 1em">s/foo/bar/ le 5; #
&quot;le&quot; infix operator <br>
s/foo/bar/el; # &quot;e&quot; and &quot;l&quot; flags</p>

<p style="margin-top: 1em">Quote-Like Operators <br>
q/STRING/ <br>
&rsquo;STRING&rsquo; <br>
A single-quoted, literal string. A backslash represents a
backslash unless followed by the delimiter or another
backslash, in which case the delimiter or backslash is <br>
interpolated.</p>

<p style="margin-top: 1em">$foo = q!I said, &quot;You said,
&rsquo;She said it.&rsquo;&quot;!; <br>
$bar = q(&rsquo;This is it.&rsquo;); <br>
$baz = &rsquo;0; # a two-character string</p>

<p style="margin-top: 1em">qq/STRING/ <br>
&quot;STRING&quot; <br>
A double-quoted, interpolated string.</p>

<p style="margin-top: 1em">$_ .= qq <br>
(*** The previous line contains the naughty word
&quot;$1&quot;.0 t c l | j a v a <br>
if /| p y t h o n ) <br>
$baz = &quot;0; # a one-character string</p>

<p style="margin-top: 1em">qx/STRING/ <br>
&lsquo;STRING&lsquo; <br>
A string which is (possibly) interpolated and then executed
as a system command with &quot;/bin/sh&quot; or its
equivalent. Shell wildcards, pipes, and redirections will be
honored. <br>
The collected standard output of the command is returned;
standard error is unaffected. In scalar context, it comes
back as a single (potentially multi-line) string, or <br>
undef if the command failed. In list context, returns a list
of lines (however you&rsquo;ve defined lines with $/ or
$INPUT_RECORD_SEPARATOR), or an empty list if the command
<br>
failed.</p>

<p style="margin-top: 1em">Because backticks do not affect
standard error, use shell file descriptor syntax (assuming
the shell supports this) if you care to address this. To
capture a command&rsquo;s <br>
STDERR and STDOUT together:</p>

<p style="margin-top: 1em">$output = &lsquo;cmd
2&gt;&amp;1&lsquo;;</p>

<p style="margin-top: 1em">To capture a command&rsquo;s
STDOUT but discard its STDERR:</p>

<p style="margin-top: 1em">$output = &lsquo;cmd
2&gt;/dev/null&lsquo;;</p>

<p style="margin-top: 1em">To capture a command&rsquo;s
STDERR but discard its STDOUT (ordering is important
here):</p>

<p style="margin-top: 1em">$output = &lsquo;cmd 2&gt;&amp;1
1&gt;/dev/null&lsquo;;</p>

<p style="margin-top: 1em">To exchange a command&rsquo;s
STDOUT and STDERR in order to capture the STDERR but leave
its STDOUT to come out the old STDERR:</p>

<p style="margin-top: 1em">$output = &lsquo;cmd 3&gt;&amp;1
1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-&lsquo;;</p>

<p style="margin-top: 1em">To read both a command&rsquo;s
STDOUT and its STDERR separately, it&rsquo;s easiest to
redirect them separately to files, and then read from those
files when the program is done:</p>

<p style="margin-top: 1em">system(&quot;program args
1&gt;program.stdout 2&gt;program.stderr&quot;);</p>

<p style="margin-top: 1em">The STDIN filehandle used by the
command is inherited from Perl&rsquo;s STDIN. For
example:</p>

<p style="margin-top: 1em">open(SPLAT, &quot;stuff&quot;)
|| die &quot;can&rsquo;t open stuff: $!&quot;; <br>
open(STDIN, &quot;&lt;&amp;SPLAT&quot;) || die
&quot;can&rsquo;t dupe SPLAT: $!&quot;; <br>
print STDOUT &lsquo;sort&lsquo;;</p>

<p style="margin-top: 1em">will print the sorted contents
of the file named &quot;stuff&quot;.</p>

<p style="margin-top: 1em">Using single-quote as a
delimiter protects the command from Perl&rsquo;s
double-quote interpolation, passing it on to the shell
instead:</p>

<p style="margin-top: 1em">$perl_info = qx(ps $$); #
that&rsquo;s Perl&rsquo;s $$ <br>
$shell_info = qx&rsquo;ps $$&rsquo;; # that&rsquo;s the new
shell&rsquo;s $$</p>

<p style="margin-top: 1em">How that string gets evaluated
is entirely subject to the command interpreter on your
system. On most platforms, you will have to protect shell
metacharacters if you want <br>
them treated literally. This is in practice difficult to do,
as it&rsquo;s unclear how to escape which characters. See
perlsec for a clean and safe example of a manual fork() and
<br>
exec() to emulate backticks safely.</p>

<p style="margin-top: 1em">On some platforms (notably
DOS-like ones), the shell may not be capable of dealing with
multiline commands, so putting newlines in the string may
not get you what you want. <br>
You may be able to evaluate multiple commands in a single
line by separating them with the command separator
character, if your shell supports that (for example,
&quot;;&quot; on many <br>
Unix shells and &quot;&amp;&quot; on the Windows NT
&quot;cmd&quot; shell).</p>

<p style="margin-top: 1em">Beginning with v5.6.0, Perl will
attempt to flush all files opened for output before starting
the child process, but this may not be supported on some
platforms (see <br>
perlport). To be safe, you may need to set $| ($AUTOFLUSH in
English) or call the &quot;autoflush()&quot; method of
&quot;IO::Handle&quot; on any open handles.</p>

<p style="margin-top: 1em">Beware that some command shells
may place restrictions on the length of the command line.
You must ensure your strings don&rsquo;t exceed this limit
after any necessary <br>
interpolations. See the platform-specific release notes for
more details about your particular environment.</p>

<p style="margin-top: 1em">Using this operator can lead to
programs that are difficult to port, because the shell
commands called vary between systems, and may in fact not be
present at all. As one <br>
example, the &quot;type&quot; command under the POSIX shell
is very different from the &quot;type&quot; command under
DOS. That doesn&rsquo;t mean you should go out of your way
to avoid backticks <br>
when they&rsquo;re the right way to get something done. Perl
was made to be a glue language, and one of the things it
glues together is commands. Just understand what
you&rsquo;re <br>
getting yourself into.</p>

<p style="margin-top: 1em">See &quot;I/O Operators&quot;
for more discussion.</p>

<p style="margin-top: 1em">qw/STRING/ <br>
Evaluates to a list of the words extracted out of STRING,
using embedded whitespace as the word delimiters. It can be
understood as being roughly equivalent to:</p>

<p style="margin-top: 1em">split(&quot; &quot;,
q/STRING/);</p>

<p style="margin-top: 1em">the differences being that it
generates a real list at compile time, and in scalar context
it returns the last element in the list. So this
expression:</p>

<p style="margin-top: 1em">qw(foo bar baz)</p>

<p style="margin-top: 1em">is semantically equivalent to
the list:</p>

<p style="margin-top: 1em">&quot;foo&quot;,
&quot;bar&quot;, &quot;baz&quot;</p>

<p style="margin-top: 1em">Some frequently seen
examples:</p>

<p style="margin-top: 1em">use POSIX qw( setlocale
localeconv ) <br>
@EXPORT = qw( foo bar baz );</p>

<p style="margin-top: 1em">A common mistake is to try to
separate the words with comma or to put comments into a
multi-line &quot;qw&quot;-string. For this reason, the
&quot;use warnings&quot; pragma and the -w switch <br>
(that is, the $^W variable) produces warnings if the STRING
contains the &quot;,&quot; or the &quot;#&quot;
character.</p>


<p style="margin-top: 1em">tr/SEARCHLIST/REPLACEMENTLIST/cdsr
<br>
y/SEARCHLIST/REPLACEMENTLIST/cdsr <br>
Transliterates all occurrences of the characters found in
the search list with the corresponding character in the
replacement list. It returns the number of characters <br>
replaced or deleted. If no string is specified via the
&quot;=~&quot; or &quot;!~&quot; operator, the $_ string is
transliterated.</p>

<p style="margin-top: 1em">If the &quot;/r&quot;
(non-destructive) option is present, a new copy of the
string is made and its characters transliterated, and this
copy is returned no matter whether it was <br>
modified or not: the original string is always left
unchanged. The new copy is always a plain string, even if
the input string is an object or a tied variable.</p>

<p style="margin-top: 1em">Unless the &quot;/r&quot; option
is used, the string specified with &quot;=~&quot; must be a
scalar variable, an array element, a hash element, or an
assignment to one of those; in other words, <br>
an lvalue.</p>

<p style="margin-top: 1em">A character range may be
specified with a hyphen, so &quot;tr/A-J/0-9/&quot; does the
same replacement as &quot;tr/ACEGIBDFHJ/0246813579/&quot;.
For sed devotees, &quot;y&quot; is provided as a synonym
<br>
for &quot;tr&quot;. If the SEARCHLIST is delimited by
bracketing quotes, the REPLACEMENTLIST has its own pair of
quotes, which may or may not be bracketing quotes; for
example, <br>
&quot;tr[aeiouy][yuoiea]&quot; or
&quot;tr(+&minus;*/)/ABCD/&quot;.</p>

<p style="margin-top: 1em">Note that &quot;tr&quot; does
not do regular expression character classes such as
&quot;&quot; or &quot;L&quot;. The &quot;tr&quot; operator
is not equivalent to the tr(1) utility. If you want to map
strings <br>
between lower/upper cases, see &quot;lc&quot; in perlfunc
and &quot;uc&quot; in perlfunc, and in general consider
using the &quot;s&quot; operator if you need regular
expressions. The &quot;U&quot;, &quot;&quot;, &quot; <br>
and &quot;tring-interpolation escapes on the right side of a
substitution operator will perform correct case-mappings,
but &quot;tr[a-z][A-Z]&quot; will not (except sometimes on
legacy <br>
7-bit data).</p>

<p style="margin-top: 1em">Note also that the whole range
idea is rather unportable between character sets--and even
within character sets they may cause results you probably
didn&rsquo;t expect. A sound <br>
principle is to use only ranges that begin from and end at
either alphabets of equal case (a-e, A-E), or digits (0-4).
Anything else is unsafe. If in doubt, spell out the <br>
character sets in full.</p>

<p style="margin-top: 1em">Options:</p>

<p style="margin-top: 1em">c Complement the SEARCHLIST.
<br>
d Delete found but unreplaced characters. <br>
s Squash duplicate replaced characters. <br>
r Return the modified string and leave the original string
<br>
untouched.</p>

<p style="margin-top: 1em">If the &quot;/c&quot; modifier
is specified, the SEARCHLIST character set is complemented.
If the &quot;/d&quot; modifier is specified, any characters
specified by SEARCHLIST not found in <br>
REPLACEMENTLIST are deleted. (Note that this is slightly
more flexible than the behavior of some tr programs, which
delete anything they find in the SEARCHLIST, period.) If
<br>
the &quot;/s&quot; modifier is specified, sequences of
characters that were transliterated to the same character
are squashed down to a single instance of the character.</p>

<p style="margin-top: 1em">If the &quot;/d&quot; modifier
is used, the REPLACEMENTLIST is always interpreted exactly
as specified. Otherwise, if the REPLACEMENTLIST is shorter
than the SEARCHLIST, the final <br>
character is replicated till it is long enough. If the
REPLACEMENTLIST is empty, the SEARCHLIST is replicated. This
latter is useful for counting characters in a class or <br>
for squashing character sequences in a class.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">$ARGV[1] =~ tr/A-Z/a-z/; #
canonicalize to lower case ASCII</p>

<p style="margin-top: 1em">$cnt = tr/*/*/; # count the
stars in $_</p>

<p style="margin-top: 1em">$cnt = $sky =~ tr/*/*/; # count
the stars in $sky</p>

<p style="margin-top: 1em">$cnt = tr/0-9//; # count the
digits in $_</p>

<p style="margin-top: 1em">tr/a-zA-Z//s; # bookkeeper -&gt;
bokeper</p>

<p style="margin-top: 1em">($HOST = $host) =~ tr/a-z/A-Z/;
<br>
$HOST = $host =~ tr/a-z/A-Z/r; # same thing</p>

<p style="margin-top: 1em">$HOST = $host =~ tr/a-z/A-Z/r #
chained with s///r <br>
=~ s/:/ -p/r;</p>

<p style="margin-top: 1em">tr/a-zA-Z/ /cs; # change
non-alphas to single space</p>

<p style="margin-top: 1em">@stripped = map tr/a-zA-Z/ /csr,
@original; <br>
# /r with map</p>

<p style="margin-top: 1em">tr [200-377] <br>
[ 00-177]; # wickedly delete 8th bit</p>

<p style="margin-top: 1em">If multiple transliterations are
given for a character, only the first one is used:</p>

<p style="margin-top: 1em">tr/AAA/XYZ/</p>

<p style="margin-top: 1em">will transliterate any A to
X.</p>

<p style="margin-top: 1em">Because the transliteration
table is built at compile time, neither the SEARCHLIST nor
the REPLACEMENTLIST are subjected to double quote
interpolation. That means that if <br>
you want to use variables, you must use an eval():</p>

<p style="margin-top: 1em">eval
&quot;tr/$oldlist/$newlist/&quot;; <br>
die $@ if $@;</p>

<p style="margin-top: 1em">eval
&quot;tr/$oldlist/$newlist/, 1&quot; or die $@;</p>

<p style="margin-top: 1em">&lt;&lt;EOF <br>
A line-oriented form of quoting is based on the shell
&quot;here-document&quot; syntax. Following a
&quot;&lt;&lt;&quot; you specify a string to terminate the
quoted material, and all lines following <br>
the current line down to the terminating string are the
value of the item.</p>

<p style="margin-top: 1em">The terminating string may be
either an identifier (a word), or some quoted text. An
unquoted identifier works like double quotes. There may not
be a space between the &quot;&lt;&lt;&quot; <br>
and the identifier, unless the identifier is explicitly
quoted. (If you put a space it will be treated as a null
identifier, which is valid, and matches the first empty <br>
line.) The terminating string must appear by itself
(unquoted and with no surrounding whitespace) on the
terminating line.</p>

<p style="margin-top: 1em">If the terminating string is
quoted, the type of quotes used determine the treatment of
the text.</p>

<p style="margin-top: 1em">Double Quotes <br>
Double quotes indicate that the text will be interpolated
using exactly the same rules as normal double quoted
strings.</p>

<p style="margin-top: 1em">print &lt;&lt;EOF; <br>
The price is $Price. <br>
EOF</p>

<p style="margin-top: 1em">print &lt;&lt; &quot;EOF&quot;;
# same as above <br>
The price is $Price. <br>
EOF</p>

<p style="margin-top: 1em">Single Quotes <br>
Single quotes indicate the text is to be treated literally
with no interpolation of its content. This is similar to
single quoted strings except that backslashes have no <br>
special meaning, with &quot;\&quot; being treated as two
backslashes and not one as they would in every other quoting
construct.</p>

<p style="margin-top: 1em">Just as in the shell, a
backslashed bareword following the &quot;&lt;&lt;&quot;
means the same thing as a single-quoted string does:</p>

<p style="margin-top: 1em">$cost =
&lt;&lt;&rsquo;VISTA&rsquo;; # hasta la ... <br>
That&rsquo;ll be $10 please, ma&rsquo;am. <br>
VISTA</p>

<p style="margin-top: 1em">$cost = &lt;&lt;STA; # Same
thing! <br>
That&rsquo;ll be $10 please, ma&rsquo;am. <br>
VISTA</p>

<p style="margin-top: 1em">This is the only form of quoting
in perl where there is no need to worry about escaping
content, something that code generators can and do make good
use of.</p>

<p style="margin-top: 1em">Backticks <br>
The content of the here doc is treated just as it would be
if the string were embedded in backticks. Thus the content
is interpolated as though it were double quoted and <br>
then executed via the shell, with the results of the
execution returned.</p>

<p style="margin-top: 1em">print &lt;&lt;
&lsquo;EOC&lsquo;; # execute command and get results <br>
echo hi there <br>
EOC</p>

<p style="margin-top: 1em">It is possible to stack multiple
here-docs in a row:</p>

<p style="margin-top: 1em">print &lt;&lt;&quot;foo&quot;,
&lt;&lt;&quot;bar&quot;; # you can stack them <br>
I said foo. <br>
foo <br>
I said bar. <br>
bar</p>

<p style="margin-top: 1em">myfunc(&lt;&lt;
&quot;THIS&quot;, 23, &lt;&lt;&rsquo;THAT&rsquo;); <br>
Here&rsquo;s a line <br>
or two. <br>
THIS <br>
and here&rsquo;s another. <br>
THAT</p>

<p style="margin-top: 1em">Just don&rsquo;t forget that you
have to put a semicolon on the end to finish the statement,
as Perl doesn&rsquo;t know you&rsquo;re not going to try to
do this:</p>

<p style="margin-top: 1em">print &lt;&lt;ABC <br>
179231 <br>
ABC <br>
+ 20;</p>

<p style="margin-top: 1em">If you want to remove the line
terminator from your here-docs, use &quot;chomp()&quot;.</p>

<p style="margin-top: 1em">chomp($string =
&lt;&lt;&rsquo;END&rsquo;); <br>
This is a string. <br>
END</p>

<p style="margin-top: 1em">If you want your here-docs to be
indented with the rest of the code, you&rsquo;ll need to
remove leading whitespace from each line manually:</p>

<p style="margin-top: 1em">($quote =
&lt;&lt;&rsquo;FINIS&rsquo;) =~ s/^/gm; <br>
The Road goes ever on and on, <br>
down from the door where it began. <br>
FINIS</p>

<p style="margin-top: 1em">If you use a here-doc within a
delimited construct, such as in &quot;s///eg&quot;, the
quoted material must come on the lines following the final
delimiter. So instead of</p>

<p style="margin-top: 1em">s/this/&lt;&lt;E .
&rsquo;that&rsquo; <br>
the other <br>
E <br>
. &rsquo;more &rsquo;/eg;</p>

<p style="margin-top: 1em">you have to write</p>

<p style="margin-top: 1em">s/this/&lt;&lt;E .
&rsquo;that&rsquo; <br>
. &rsquo;more &rsquo;/eg; <br>
the other <br>
E</p>

<p style="margin-top: 1em">If the terminating identifier is
on the last line of the program, you must be sure there is a
newline after it; otherwise, Perl will give the warning
Can&rsquo;t find string <br>
terminator &quot;END&quot; anywhere before EOF....</p>

<p style="margin-top: 1em">Additionally, quoting rules for
the end-of-string identifier are unrelated to Perl&rsquo;s
quoting rules. &quot;q()&quot;, &quot;qq()&quot;, and the
like are not supported in place of &rsquo;&rsquo; and
&quot;&quot;, and <br>
the only interpolation is for backslashing the quoting
character:</p>

<p style="margin-top: 1em">print &lt;&lt; &quot;abc <br>
testing... <br>
abc&quot;def</p>

<p style="margin-top: 1em">Finally, quoted strings cannot
span multiple lines. The general rule is that the identifier
must be a string literal. Stick with that, and you should be
safe.</p>

<p style="margin-top: 1em">Gory details of parsing quoted
constructs <br>
When presented with something that might have several
different interpretations, Perl uses the DWIM (that&rsquo;s
&quot;Do What I Mean&quot;) principle to pick the most
probable interpretation. <br>
This strategy is so successful that Perl programmers often
do not suspect the ambivalence of what they write. But from
time to time, Perl&rsquo;s notions differ substantially from
<br>
what the author honestly meant.</p>

<p style="margin-top: 1em">This section hopes to clarify
how Perl handles quoted constructs. Although the most common
reason to learn this is to unravel labyrinthine regular
expressions, because the <br>
initial steps of parsing are the same for all quoting
operators, they are all discussed together.</p>

<p style="margin-top: 1em">The most important Perl parsing
rule is the first one discussed below: when processing a
quoted construct, Perl first finds the end of that
construct, then interprets its <br>
contents. If you understand this rule, you may skip the rest
of this section on the first reading. The other rules are
likely to contradict the user&rsquo;s expectations much less
<br>
frequently than this first one.</p>

<p style="margin-top: 1em">Some passes discussed below are
performed concurrently, but because their results are the
same, we consider them individually. For different quoting
constructs, Perl performs <br>
different numbers of passes, from one to four, but these
passes are always performed in the same order.</p>

<p style="margin-top: 1em">Finding the end <br>
The first pass is finding the end of the quoted construct,
where the information about the delimiters is used in
parsing. During this search, text between the starting and
<br>
ending delimiters is copied to a safe location. The text
copied gets delimiter-independent.</p>

<p style="margin-top: 1em">If the construct is a here-doc,
the ending delimiter is a line that has a terminating string
as the content. Therefore &quot;&lt;&lt;EOF&quot; is
terminated by &quot;EOF&quot; immediately followed by <br>
&quot;0 and starting from the first column of the
terminating line. When searching for the terminating line of
a here-doc, nothing is skipped. In other words, lines after
the <br>
here-doc syntax are compared with the terminating string
line by line.</p>

<p style="margin-top: 1em">For the constructs except
here-docs, single characters are used as starting and ending
delimiters. If the starting delimiter is an opening
punctuation (that is &quot;(&quot;, &quot;[&quot;,
&quot;{&quot;, <br>
or &quot;&lt;&quot;), the ending delimiter is the
corresponding closing punctuation (that is &quot;)&quot;,
&quot;]&quot;, &quot;}&quot;, or &quot;&gt;&quot;). If the
starting delimiter is an unpaired character like
&quot;/&quot; or a <br>
closing punctuation, the ending delimiter is same as the
starting delimiter. Therefore a &quot;/&quot; terminates a
&quot;qq//&quot; construct, while a &quot;]&quot; terminates
&quot;qq[]&quot; and &quot;qq]]&quot; <br>
constructs.</p>

<p style="margin-top: 1em">When searching for
single-character delimiters, escaped delimiters and
&quot;\&quot; are skipped. For example, while searching for
terminating &quot;/&quot;, combinations of &quot;\&quot; and
&quot;&quot; are <br>
skipped. If the delimiters are bracketing, nested pairs are
also skipped. For example, while searching for closing
&quot;]&quot; paired with the opening &quot;[&quot;,
combinations of &quot;\&quot;, <br>
&quot;]&quot;, and &quot; skipped. During the search for the
end, backslashes that escape delimiters or backslashes are
removed (exactly speaking, they are not copied to the safe
location).</p>

<p style="margin-top: 1em">For constructs with three-part
delimiters (&quot;s///&quot;, &quot;y///&quot;, and
&quot;tr///&quot;), the search is repeated once more. If the
first delimiter is not an opening punctuation, three <br>
delimiters must be same such as &quot;s!!!&quot; and
&quot;tr)))&quot;, in which case the second delimiter
terminates the left part and starts the right part at once.
If the left part is <br>
delimited by bracketing punctuation (that is &quot;()&quot;,
&quot;[]&quot;, &quot;{}&quot;, or &quot;&lt;&gt;&quot;),
the right part needs another pair of delimiters such as
&quot;s(){}&quot; and &quot;tr[]//&quot;. In these cases,
<br>
whitespace and comments are allowed between both parts,
though the comment must follow at least one whitespace
character; otherwise a character expected as the start of
the <br>
comment may be regarded as the starting delimiter of the
right part.</p>

<p style="margin-top: 1em">During this search no attention
is paid to the semantics of the construct. Thus:</p>


<p style="margin-top: 1em">&quot;$hash{&quot;$foo/$bar&quot;}&quot;</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">m/ <br>
bar # NOT a comment, this slash / terminated m//! <br>
/x</p>

<p style="margin-top: 1em">do not form legal quoted
expressions. The quoted part ends on the first
&quot;&quot;&quot; and &quot;/&quot;, and the rest happens
to be a syntax error. Because the slash that terminated
&quot;m//&quot; was <br>
followed by a &quot;SPACE&quot;, the example above is not
&quot;m//x&quot;, but rather &quot;m//&quot; with no
&quot;/x&quot; modifier. So the embedded &quot;#&quot; is
interpreted as a literal &quot;#&quot;.</p>

<p style="margin-top: 1em">Also no attention is paid to
&quot; &quot;/&quot; is not recognized as a delimiter.
Instead, use &quot; 34&quot; or &quot;c&quot; at the end of
quoted constructs.</p>

<p style="margin-top: 1em">Interpolation <br>
The next step is interpolation in the text obtained, which
is now delimiter-independent. There are multiple cases.</p>


<p style="margin-top: 1em">&quot;&lt;&lt;&rsquo;EOF&rsquo;&quot;
<br>
No interpolation is performed. Note that the combination
&quot;\&quot; is left intact, since escaped delimiters are
not available for here-docs.</p>

<p style="margin-top: 1em">&quot;m&rsquo;&rsquo;&quot;, the
pattern of &quot;s&rsquo;&rsquo;&rsquo;&quot; <br>
No interpolation is performed at this stage. Any backslashed
sequences including &quot;\&quot; are treated at the stage
to &quot;parsing regular expressions&quot;.</p>

<p style="margin-top: 1em">&rsquo;&rsquo;, &quot;q//&quot;,
&quot;tr&rsquo;&rsquo;&rsquo;&quot;,
&quot;y&rsquo;&rsquo;&rsquo;&quot;, the replacement of
&quot;s&rsquo;&rsquo;&rsquo;&quot; <br>
The only interpolation is removal of &quot; <br>
&quot;1&quot; in the replacement of
&quot;s&rsquo;&rsquo;&rsquo;&quot; does not work as $1.</p>

<p style="margin-top: 1em">&quot;tr///&quot;,
&quot;y///&quot; <br>
No variable interpolation occurs. String modifying
combinations for case and quoting such as &quot;Q&quot;,
&quot;U&quot;, and &quot; <br>
&quot;200&quot; and &quot;&quot; and backslashed characters
such as &quot;\&quot; and &quot;&minus;&quot; are converted
to appropriate literals. The character &quot;-&quot; is
treated specially and therefore &quot;&minus;&quot; is <br>
treated as a literal &quot;-&quot;.</p>

<p style="margin-top: 1em">&quot;&quot;,
&quot;&lsquo;&lsquo;&quot;, &quot;qq//&quot;,
&quot;qx//&quot;, &quot;&lt;file*glob&gt;&quot;,
&quot;&lt;&lt;&quot;EOF&quot;&quot; <br>
&quot;Q&quot;, &quot;U&quot;, &quot;&quot;, &quot; &quot;
&quot; (possibly paired with &quot; <br>
(quotemeta(&quot;baz&quot; . $bar))&quot; internally. The
other escape sequences such as &quot;200&quot; and
&quot;&quot; and backslashed characters such as
&quot;\&quot; and &quot;&minus;&quot; are replaced with
appropriate <br>
expansions.</p>

<p style="margin-top: 1em">Let it be stressed that whatever
falls between &quot;Q&quot; and &quot; <br>
and &quot;E&quot;, so the result is the same as for
&quot;\\E&quot;. As a general rule, backslashes between
&quot;Q&quot; and &quot; <br>
to &quot;quotemeta(&quot;&quot;)&quot;, which is the same as
&quot;\&quot; (since TAB is not alphanumeric). Note also
that:</p>

<p style="margin-top: 1em">$str = &rsquo;&rsquo;; <br>
return &quot;Q$str&quot;;</p>

<p style="margin-top: 1em">may be closer to the conjectural
intention of the writer of &quot;Q</p>

<p style="margin-top: 1em">Interpolated scalars and arrays
are converted internally to the &quot;join&quot; and
&quot;.&quot; catenation operations. Thus, &quot;$foo XXX
&rsquo;@arr&rsquo;&quot; becomes:</p>

<p style="margin-top: 1em">$foo . &quot; XXX &rsquo;&quot;
. (join $&quot;, @arr) . &quot;&rsquo;&quot;;</p>

<p style="margin-top: 1em">All operations above are
performed simultaneously, left to right.</p>

<p style="margin-top: 1em">Because the result of &quot;Q
STRING <br>
quoted to became &quot;\; if not, it is interpreted as the
start of an interpolated scalar.</p>

<p style="margin-top: 1em">Note also that the interpolation
code needs to make a decision on where the interpolated
scalar ends. For instance, whether &quot;a $b -&gt;
{c}&quot; really means:</p>

<p style="margin-top: 1em">&quot;a &quot; . $b . &quot;
-&gt; {c}&quot;;</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">&quot;a &quot; . $b -&gt;
{c};</p>

<p style="margin-top: 1em">Most of the time, the longest
possible text that does not include spaces between
components and which contains matching braces or brackets.
because the outcome may be <br>
determined by voting based on heuristic estimators, the
result is not strictly predictable. Fortunately, it&rsquo;s
usually correct for ambiguous cases.</p>

<p style="margin-top: 1em">the replacement of
&quot;s///&quot; <br>
Processing of &quot;Q&quot;, &quot;U&quot;, &quot;&quot;,
&quot; &quot; &quot; and interpolation happens as with
&quot;qq//&quot; constructs.</p>

<p style="margin-top: 1em">It is at this step that
&quot;1&quot; is begrudgingly converted to $1 in the
replacement text of &quot;s///&quot;, in order to correct
the incorrigible sed hackers who haven&rsquo;t picked up the
<br>
saner idiom yet. A warning is emitted if the &quot;use
warnings&quot; pragma or the -w command-line flag (that is,
the $^W variable) was set.</p>

<p style="margin-top: 1em">&quot;RE&quot; in
&quot;?RE?&quot;, &quot;/RE/&quot;, &quot;m/RE/&quot;,
&quot;s/RE/foo/&quot;, <br>
Processing of &quot;Q&quot;, &quot;U&quot;, &quot;&quot;,
&quot; &quot; &quot;, &quot;</p>

<p style="margin-top: 1em">Processing of &quot; is
also done here, and compiled into an intermediate form for
the regex compiler. (This is because, as mentioned below,
the regex compilation may <br>
be done at execution time, and &quot; is a
compile-time construct.)</p>

<p style="margin-top: 1em">However any other combinations
of &quot; <br>
As &quot; &quot; <br>
Moreover, inside &quot;(?{BLOCK})&quot;, &quot;(?# comment
)&quot;, and a &quot;#&quot;-comment in a
&quot;//x&quot;-regular expression, no processing is
performed whatsoever. This is the first step at which <br>
the presence of the &quot;//x&quot; modifier is
relevant.</p>

<p style="margin-top: 1em">Interpolation in patterns has
several quirks: $|, $(, $), &quot;@+&quot; and
&quot;@-&quot; are not interpolated, and constructs
$var[SOMETHING] are voted (by several different estimators)
<br>
to be either an array element or $var followed by an RE
alternative. This is where the notation
&quot;${arr[$bar]}&quot; comes handy:
&quot;/${arr[0-9]}/&quot; is interpreted as array <br>
element &quot;-9&quot;, not as a regular expression from the
variable $arr followed by a digit, which would be the
interpretation of &quot;/$arr[0-9]/&quot;. Since voting
among different <br>
estimators may occur, the result is not predictable.</p>

<p style="margin-top: 1em">The lack of processing of
&quot;\&quot; creates specific restrictions on the
post-processed text. If the delimiter is &quot;/&quot;, one
cannot get the combination &quot;&quot; into the result of
<br>
this step. &quot;/&quot; will finish the regular expression,
&quot;&quot; will be stripped to &quot;/&quot; on the
previous step, and &quot;\/&quot; will be left as is.
Because &quot;/&quot; is equivalent to &quot;&quot; <br>
inside a regular expression, this does not matter unless the
delimiter happens to be character special to the RE engine,
such as in &quot;s*foo*bar*&quot;, &quot;m[foo]&quot;, or
&quot;?foo?&quot;; or <br>
an alphanumeric char, as in:</p>

<p style="margin-top: 1em">m m ^ a b mmx;</p>

<p style="margin-top: 1em">In the RE above, which is
intentionally obfuscated for illustration, the delimiter is
&quot;m&quot;, the modifier is &quot;mx&quot;, and after
delimiter-removal the RE is the same as for &quot;m/ <br>
^ a b /mx&quot;. There&rsquo;s more than one reason
you&rsquo;re encouraged to restrict your delimiters to
non-alphanumeric, non-whitespace choices.</p>

<p style="margin-top: 1em">This step is the last one for
all constructs except regular expressions, which are
processed further.</p>

<p style="margin-top: 1em">parsing regular expressions <br>
Previous steps were performed during the compilation of Perl
code, but this one happens at run time, although it may be
optimized to be calculated at compile time if <br>
appropriate. After preprocessing described above, and
possibly after evaluation if concatenation, joining, casing
translation, or metaquoting are involved, the resulting <br>
string is passed to the RE engine for compilation.</p>

<p style="margin-top: 1em">Whatever happens in the RE
engine might be better discussed in perlre, but for the sake
of continuity, we shall do so here.</p>

<p style="margin-top: 1em">This is another step where the
presence of the &quot;//x&quot; modifier is relevant. The RE
engine scans the string from left to right and converts it
to a finite automaton.</p>

<p style="margin-top: 1em">Backslashed characters are
either replaced with corresponding literal strings (as with
&quot;&quot;), or else they generate) special nodes in the
finite automaton (as with &quot;. <br>
Characters special to the RE engine (such as &quot;|&quot;)
generate corresponding nodes or groups of nodes.
&quot;(?#...)&quot; comments are ignored. All the rest is
either converted to <br>
literal strings to match, or else is ignored (as is
whitespace and &quot;#&quot;-style comments if
&quot;//x&quot; is present).</p>

<p style="margin-top: 1em">Parsing of the bracketed
character class construct, &quot;[...]&quot;, is rather
different than the rule used for the rest of the pattern.
The terminator of this construct is found <br>
using the same rules as for finding the terminator of a
&quot;{}&quot;-delimited construct, the only exception being
that &quot;]&quot; immediately following &quot;[&quot; is
treated as though preceded by <br>
a backslash. Similarly, the terminator of
&quot;(?{...})&quot; is found using the same rules as for
finding the terminator of a &quot;{}&quot;-delimited
construct.</p>

<p style="margin-top: 1em">It is possible to inspect both
the string given to RE engine and the resulting finite
automaton. See the arguments
&quot;debug&quot;/&quot;debugcolor&quot; in the &quot;use
re&quot; pragma, as well as <br>
Perl&rsquo;s -Dr command-line switch documented in
&quot;Command Switches&quot; in perlrun.</p>

<p style="margin-top: 1em">Optimization of regular
expressions <br>
This step is listed for completeness only. Since it does not
change semantics, details of this step are not documented
and are subject to change without notice. This step <br>
is performed over the finite automaton that was generated
during the previous pass.</p>

<p style="margin-top: 1em">It is at this stage that
&quot;split()&quot; silently optimizes &quot;/^/&quot; to
mean &quot;/^/m&quot;.</p>

<p style="margin-top: 1em">I/O Operators <br>
There are several I/O operators you should know about.</p>

<p style="margin-top: 1em">A string enclosed by backticks
(grave accents) first undergoes double-quote interpolation.
It is then interpreted as an external command, and the
output of that command is the <br>
value of the backtick string, like in a shell. In scalar
context, a single string consisting of all output is
returned. In list context, a list of values is returned, one
per <br>
line of output. (You can set $/ to use a different line
terminator.) The command is executed each time the
pseudo-literal is evaluated. The status value of the command
is <br>
returned in $? (see perlvar for the interpretation of $?).
Unlike in csh, no translation is done on the return
data--newlines remain newlines. Unlike in any of the shells,
<br>
single quotes do not hide variable names in the command from
interpretation. To pass a literal dollar-sign through to the
shell you need to hide it with a backslash. The <br>
generalized form of backticks is &quot;qx//&quot;. (Because
backticks always undergo shell expansion as well, see
perlsec for security concerns.)</p>

<p style="margin-top: 1em">In scalar context, evaluating a
filehandle in angle brackets yields the next line from that
file (the newline, if any, included), or &quot;undef&quot;
at end-of-file or on error. When $/ <br>
is set to &quot;undef&quot; (sometimes known as file-slurp
mode) and the file is empty, it returns &rsquo;&rsquo; the
first time, followed by &quot;undef&quot; subsequently.</p>

<p style="margin-top: 1em">Ordinarily you must assign the
returned value to a variable, but there is one situation
where an automatic assignment happens. If and only if the
input symbol is the only thing <br>
inside the conditional of a &quot;while&quot; statement
(even if disguised as a &quot;for(;;)&quot; loop), the value
is automatically assigned to the global variable $_,
destroying whatever was <br>
there previously. (This may seem like an odd thing to you,
but you&rsquo;ll use the construct in almost every Perl
script you write.) The $_ variable is not implicitly
localized. <br>
You&rsquo;ll have to put a &quot;local $_;&quot; before the
loop if you want that to happen.</p>

<p style="margin-top: 1em">The following lines are
equivalent:</p>

<p style="margin-top: 1em">while (defined($_ =
&lt;STDIN&gt;)) { print; } <br>
while ($_ = &lt;STDIN&gt;) { print; } <br>
while (&lt;STDIN&gt;) { print; } <br>
for (;&lt;STDIN&gt;;) { print; } <br>
print while defined($_ = &lt;STDIN&gt;); <br>
print while ($_ = &lt;STDIN&gt;); <br>
print while &lt;STDIN&gt;;</p>

<p style="margin-top: 1em">This also behaves similarly, but
assigns to a lexical variable instead of to $_:</p>

<p style="margin-top: 1em">while (my $line = &lt;STDIN&gt;)
{ print $line }</p>

<p style="margin-top: 1em">In these loop constructs, the
assigned value (whether assignment is automatic or explicit)
is then tested to see whether it is defined. The defined
test avoids problems where <br>
the line has a string value that would be treated as false
by Perl; for example a &quot;&quot; or a &quot;0&quot; with
no trailing newline. If you really mean for such values to
terminate the loop, <br>
they should be tested for explicitly:</p>

<p style="margin-top: 1em">while (($_ = &lt;STDIN&gt;) ne
&rsquo;0&rsquo;) { ... } <br>
while (&lt;STDIN&gt;) { last unless $_; ... }</p>

<p style="margin-top: 1em">In other boolean contexts,
&quot;&lt;FILEHANDLE&gt;&quot; without an explicit
&quot;defined&quot; test or comparison elicits a warning if
the &quot;use warnings&quot; pragma or the -w command-line
switch (the $^W <br>
variable) is in effect.</p>

<p style="margin-top: 1em">The filehandles STDIN, STDOUT,
and STDERR are predefined. (The filehandles
&quot;stdin&quot;, &quot;stdout&quot;, and
&quot;stderr&quot; will also work except in packages, where
they would be interpreted as <br>
local identifiers rather than global.) Additional
filehandles may be created with the open() function, amongst
others. See perlopentut and &quot;open&quot; in perlfunc for
details on <br>
this.</p>

<p style="margin-top: 1em">If a &lt;FILEHANDLE&gt; is used
in a context that is looking for a list, a list comprising
all input lines is returned, one line per list element.
It&rsquo;s easy to grow to a rather large <br>
data space this way, so use with care.</p>

<p style="margin-top: 1em">&lt;FILEHANDLE&gt; may also be
spelled &quot;readline(*FILEHANDLE)&quot;. See
&quot;readline&quot; in perlfunc.</p>

<p style="margin-top: 1em">The null filehandle &lt;&gt; is
special: it can be used to emulate the behavior of sed and
awk, and any other Unix filter program that takes a list of
filenames, doing the same to each <br>
line of input from all of them. Input from &lt;&gt; comes
either from standard input, or from each file listed on the
command line. Here&rsquo;s how it works: the first time
&lt;&gt; is <br>
evaluated, the @ARGV array is checked, and if it is empty,
$ARGV[0] is set to &quot;-&quot;, which when opened gives
you standard input. The @ARGV array is then processed as a
list of <br>
filenames. The loop</p>

<p style="margin-top: 1em">while (&lt;&gt;) { <br>
... # code for each line <br>
}</p>

<p style="margin-top: 1em">is equivalent to the following
Perl-like pseudo code:</p>

<p style="margin-top: 1em">unshift(@ARGV, &rsquo;-&rsquo;)
unless @ARGV; <br>
while ($ARGV = shift) { <br>
open(ARGV, $ARGV); <br>
while (&lt;ARGV&gt;) { <br>
... # code for each line <br>
} <br>
}</p>

<p style="margin-top: 1em">except that it isn&rsquo;t so
cumbersome to say, and will actually work. It really does
shift the @ARGV array and put the current filename into the
$ARGV variable. It also uses <br>
filehandle ARGV internally. &lt;&gt; is just a synonym for
&lt;ARGV&gt;, which is magical. (The pseudo code above
doesn&rsquo;t work because it treats &lt;ARGV&gt; as
non-magical.)</p>

<p style="margin-top: 1em">Since the null filehandle uses
the two argument form of &quot;open&quot; in perlfunc it
interprets special characters, so if you have a script like
this:</p>

<p style="margin-top: 1em">while (&lt;&gt;) { <br>
print; <br>
}</p>

<p style="margin-top: 1em">and call it with &quot;perl
dangerous.pl &rsquo;rm -rfv *|&rsquo;&quot;, it actually
opens a pipe, executes the &quot;rm&quot; command and reads
&quot;rm&quot;&rsquo;s output from that pipe. If you want
all items in @ARGV to <br>
be interpreted as file names, you can use the module
&quot;ARGV::readonly&quot; from CPAN.</p>

<p style="margin-top: 1em">You can modify @ARGV before the
first &lt;&gt; as long as the array ends up containing the
list of filenames you really want. Line numbers ($.)
continue as though the input were one <br>
big happy file. See the example in &quot;eof&quot; in
perlfunc for how to reset line numbers on each file.</p>

<p style="margin-top: 1em">If you want to set @ARGV to your
own list of files, go right ahead. This sets @ARGV to all
plain text files if no @ARGV was given:</p>

<p style="margin-top: 1em">@ARGV = grep { -f &amp;&amp; -T
} glob(&rsquo;*&rsquo;) unless @ARGV;</p>

<p style="margin-top: 1em">You can even set them to pipe
commands. For example, this automatically filters compressed
arguments through gzip:</p>

<p style="margin-top: 1em">@ARGV = map { /.(gz|Z)$/ ?
&quot;gzip -dc &lt; $_ |&quot; : $_ } @ARGV;</p>

<p style="margin-top: 1em">If you want to pass switches
into your script, you can use one of the Getopts modules or
put a loop on the front like this:</p>

<p style="margin-top: 1em">while ($_ = $ARGV[0], /^-/) {
<br>
shift; <br>
last if /^--$/; <br>
if (/^-D(.*)/) { $debug = $1 } <br>
if (/^-v/) { $verbose++ } <br>
# ... # other switches <br>
}</p>

<p style="margin-top: 1em">while (&lt;&gt;) { <br>
# ... # code for each line <br>
}</p>

<p style="margin-top: 1em">The &lt;&gt; symbol will return
&quot;undef&quot; for end-of-file only once. If you call it
again after this, it will assume you are processing another
@ARGV list, and if you haven&rsquo;t set @ARGV, <br>
will read input from STDIN.</p>

<p style="margin-top: 1em">If what the angle brackets
contain is a simple scalar variable (for example,
&lt;$foo&gt;), then that variable contains the name of the
filehandle to input from, or its typeglob, or a <br>
reference to the same. For example:</p>

<p style="margin-top: 1em">$fh = TDIN; <br>
$line = &lt;$fh&gt;;</p>

<p style="margin-top: 1em">If what&rsquo;s within the angle
brackets is neither a filehandle nor a simple scalar
variable containing a filehandle name, typeglob, or typeglob
reference, it is interpreted as a <br>
filename pattern to be globbed, and either a list of
filenames or the next filename in the list is returned,
depending on context. This distinction is determined on
syntactic <br>
grounds alone. That means &quot;&lt;$x&gt;&quot; is always a
readline() from an indirect handle, but
&quot;&lt;$hash{key}&gt;&quot; is always a glob().
That&rsquo;s because $x is a simple scalar variable, but
<br>
$hash{key} is not--it&rsquo;s a hash element. Even
&quot;&lt;$x &gt;&quot; (note the extra space) is treated as
&quot;glob(&quot;$x &quot;)&quot;, not
&quot;readline($x)&quot;.</p>

<p style="margin-top: 1em">One level of double-quote
interpretation is done first, but you can&rsquo;t say
&quot;&lt;$foo&gt;&quot; because that&rsquo;s an indirect
filehandle as explained in the previous paragraph. (In older
<br>
versions of Perl, programmers would insert curly brackets to
force interpretation as a filename glob:
&quot;&lt;${foo}&gt;&quot;. These days, it&rsquo;s
considered cleaner to call the internal <br>
function directly as &quot;glob($foo)&quot;, which is
probably the right way to have done it in the first place.)
For example:</p>

<p style="margin-top: 1em">while (&lt;*.c&gt;) { <br>
chmod 0644, $_; <br>
}</p>

<p style="margin-top: 1em">is roughly equivalent to:
&rsquo;\012\012\012\012&rsquo;|&quot;);</p>

<p style="margin-top: 1em">open(FOO, &quot;echo *.c | tr -s
&rsquo; <br>
while (&lt;FOO&gt;) { <br>
chomp; <br>
chmod 0644, $_; <br>
}</p>

<p style="margin-top: 1em">except that the globbing is
actually done internally using the standard
&quot;File::Glob&quot; extension. Of course, the shortest
way to do the above is:</p>

<p style="margin-top: 1em">chmod 0644, &lt;*.c&gt;;</p>

<p style="margin-top: 1em">A (file)glob evaluates its
(embedded) argument only when it is starting a new list. All
values must be read before it will start over. In list
context, this isn&rsquo;t important <br>
because you automatically get them all anyway. However, in
scalar context the operator returns the next value each time
it&rsquo;s called, or &quot;undef&quot; when the list has
run out. As <br>
with filehandle reads, an automatic &quot;defined&quot; is
generated when the glob occurs in the test part of a
&quot;while&quot;, because legal glob returns (for example,
a file called 0) would <br>
otherwise terminate the loop. Again, &quot;undef&quot; is
returned only once. So if you&rsquo;re expecting a single
value from a glob, it is much better to say</p>

<p style="margin-top: 1em">($file) = &lt;blurch*&gt;;</p>

<p style="margin-top: 1em">than</p>

<p style="margin-top: 1em">$file = &lt;blurch*&gt;;</p>

<p style="margin-top: 1em">because the latter will
alternate between returning a filename and returning
false.</p>

<p style="margin-top: 1em">If you&rsquo;re trying to do
variable interpolation, it&rsquo;s definitely better to use
the glob() function, because the older notation can cause
people to become confused with the indirect <br>
filehandle notation.</p>

<p style="margin-top: 1em">@files =
glob(&quot;$dir/*.[ch]&quot;); <br>
@files = glob($files[$i]);</p>

<p style="margin-top: 1em">Constant Folding <br>
Like C, Perl does a certain amount of expression evaluation
at compile time whenever it determines that all arguments to
an operator are static and have no side effects. In <br>
particular, string concatenation happens at compile time
between literals that don&rsquo;t do variable substitution.
Backslash interpolation also happens at compile time. You
can say</p>

<p style="margin-top: 1em">&rsquo;Now is the time for
all&rsquo; <br>
. &quot;0 <br>
. &rsquo;good men to come to.&rsquo;</p>

<p style="margin-top: 1em">and this all reduces to one
string internally. Likewise, if you say</p>

<p style="margin-top: 1em">foreach $file (@filenames) {
<br>
if (-s $file &gt; 5 + 100 * 2**16) { } <br>
}</p>

<p style="margin-top: 1em">the compiler precomputes the
number which that expression represents so that the
interpreter won&rsquo;t have to.</p>

<p style="margin-top: 1em">No-ops <br>
Perl doesn&rsquo;t officially have a no-op operator, but the
bare constants 0 and 1 are special-cased not to produce a
warning in void context, so you can for example safely
do</p>

<p style="margin-top: 1em">1 while foo();</p>

<p style="margin-top: 1em">Bitwise String Operators <br>
Bitstrings of any size may be manipulated by the bitwise
operators (&quot;~ | &amp; ^&quot;).</p>

<p style="margin-top: 1em">If the operands to a binary
bitwise op are strings of different sizes, | and ^ ops act
as though the shorter operand had additional zero bits on
the right, while the &amp; op acts as <br>
though the longer operand were truncated to the length of
the shorter. The granularity for such extension or
truncation is one or more bytes.</p>

<p style="margin-top: 1em"># ASCII-based examples <br>
print &quot;j p 0 ^ &quot; a h&quot;; # prints &quot;JAPH0
<br>
print &quot;JA&quot; | &quot; ph0; # prints &quot;japh0 <br>
print &quot;japh0unk&quot; &amp; &rsquo;_____&rsquo;; #
prints &quot;JAPH0; <br>
print &rsquo;p N$&rsquo; ^ &quot; E&lt;H0; # prints
&quot;Perl0;</p>

<p style="margin-top: 1em">If you are intending to
manipulate bitstrings, be certain that you&rsquo;re
supplying bitstrings: If an operand is a number, that will
imply a numeric bitwise operation. You may <br>
explicitly show which type of operation you intend by using
&quot;&quot; or &quot;0+&quot;, as in the examples
below.</p>

<p style="margin-top: 1em">$foo = 150 | 105; # yields 255
(0x96 | 0x69 is 0xFF) <br>
$foo = &rsquo;150&rsquo; | 105; # yields 255 <br>
$foo = 150 | &rsquo;105&rsquo;; # yields 255 <br>
$foo = &rsquo;150&rsquo; | &rsquo;105&rsquo;; # yields
string &rsquo;155&rsquo; (under ASCII)</p>

<p style="margin-top: 1em">$baz = 0+$foo &amp; 0+$bar; #
both ops explicitly numeric <br>
$biz = &quot;$foo&quot; ^ &quot;$bar&quot;; # both ops
explicitly stringy</p>

<p style="margin-top: 1em">See &quot;vec&quot; in perlfunc
for information on how to manipulate individual bits in a
bit vector.</p>

<p style="margin-top: 1em">Integer Arithmetic <br>
By default, Perl assumes that it must do most of its
arithmetic in floating point. But by saying</p>

<p style="margin-top: 1em">use integer;</p>

<p style="margin-top: 1em">you may tell the compiler to use
integer operations (see integer for a detailed explanation)
from here to the end of the enclosing BLOCK. An inner BLOCK
may countermand this by <br>
saying</p>

<p style="margin-top: 1em">no integer;</p>

<p style="margin-top: 1em">which lasts until the end of
that BLOCK. Note that this doesn&rsquo;t mean everything is
an integer, merely that Perl will use integer operations for
arithmetic, comparison, and <br>
bitwise operators. For example, even under &quot;use
integer&quot;, if you take the sqrt(2), you&rsquo;ll still
get 1.4142135623731 or so.</p>

<p style="margin-top: 1em">Used on numbers, the bitwise
operators (&quot;&amp;&quot;, &quot;|&quot;, &quot;^&quot;,
&quot;~&quot;, &quot;&lt;&lt;&quot;, and
&quot;&gt;&gt;&quot;) always produce integral results. (But
see also &quot;Bitwise String Operators&quot;.) However,
&quot;use integer&quot; <br>
still has meaning for them. By default, their results are
interpreted as unsigned integers, but if &quot;use
integer&quot; is in effect, their results are interpreted as
signed integers. <br>
For example, &quot;~0&quot; usually evaluates to a large
integral value. However, &quot;use integer; ~0&quot; is
&quot;-1&quot; on two&rsquo;s-complement machines.</p>

<p style="margin-top: 1em">Floating-point Arithmetic <br>
While &quot;use integer&quot; provides integer-only
arithmetic, there is no analogous mechanism to provide
automatic rounding or truncation to a certain number of
decimal places. For <br>
rounding to a certain number of digits, sprintf() or
printf() is usually the easiest route. See perlfaq4.</p>

<p style="margin-top: 1em">Floating-point numbers are only
approximations to what a mathematician would call real
numbers. There are infinitely more reals than floats, so
some corners must be cut. For <br>
example:</p>

<p style="margin-top: 1em">printf &quot;%.20g0,
123456789123456789; <br>
# produces 123456789123456784</p>

<p style="margin-top: 1em">Testing for exact floating-point
equality or inequality is not a good idea. Here&rsquo;s a
(relatively expensive) work-around to compare whether two
floating-point numbers are equal <br>
to a particular number of decimal places. See Knuth, volume
II, for a more robust treatment of this topic.</p>

<p style="margin-top: 1em">sub fp_equal { <br>
my ($X, $Y, $POINTS) = @_; <br>
my ($tX, $tY); <br>
$tX = sprintf(&quot;%.${POINTS}g&quot;, $X); <br>
$tY = sprintf(&quot;%.${POINTS}g&quot;, $Y); <br>
return $tX eq $tY; <br>
}</p>

<p style="margin-top: 1em">The POSIX module (part of the
standard perl distribution) implements ceil(), floor(), and
other mathematical and trigonometric functions. The
Math::Complex module (part of the <br>
standard perl distribution) defines mathematical functions
that work on both the reals and the imaginary numbers.
Math::Complex not as efficient as POSIX, but POSIX
can&rsquo;t work <br>
with complex numbers.</p>

<p style="margin-top: 1em">Rounding in financial
applications can have serious implications, and the rounding
method used should be specified precisely. In these cases,
it probably pays not to trust <br>
whichever system rounding is being used by Perl, but to
instead implement the rounding function you need
yourself.</p>

<p style="margin-top: 1em">Bigger Numbers <br>
The standard &quot;Math::BigInt&quot;,
&quot;Math::BigRat&quot;, and &quot;Math::BigFloat&quot;
modules, along with the &quot;bigint&quot;,
&quot;bigrat&quot;, and &quot;bitfloat&quot; pragmas,
provide variable-precision arithmetic and <br>
overloaded operators, although they&rsquo;re currently
pretty slow. At the cost of some space and considerable
speed, they avoid the normal pitfalls associated with
limited-precision <br>
representations.</p>

<p style="margin-top: 1em">use 5.010; <br>
use bigint; # easy interface to Math::BigInt <br>
$x = 123456789123456789; <br>
say $x * $x; <br>
+15241578780673678515622620750190521</p>

<p style="margin-top: 1em">Or with rationals:</p>

<p style="margin-top: 1em">use 5.010; <br>
use bigrat; <br>
$a = 3/22; <br>
$b = 4/6; <br>
say &quot;a/b is &quot;, $a/$b; <br>
say &quot;a*b is &quot;, $a*$b; <br>
a/b is 9/44 <br>
a*b is 1/11</p>

<p style="margin-top: 1em">Several modules let you
calculate with (bound only by memory and CPU time) unlimited
or fixed precision. There are also some non-standard modules
that provide faster <br>
implementations via external C libraries.</p>

<p style="margin-top: 1em">Here is a short, but incomplete
summary:</p>

<p style="margin-top: 1em">Math::Fraction big, unlimited
fractions like 9973 / 12967 <br>
Math::String treat string sequences like numbers <br>
Math::FixedPrecision calculate with a fixed precision <br>
Math::Currency for currency calculations <br>
Bit::Vector manipulate bit vectors fast (uses C) <br>
Math::BigIntFast Bit::Vector wrapper for big numbers <br>
Math::Pari provides access to the Pari C library <br>
Math::BigInteger uses an external C library <br>
Math::Cephes uses external Cephes C library (no big numbers)
<br>
Math::Cephes::Fraction fractions via the Cephes library <br>
Math::GMP another one using an external C library</p>

<p style="margin-top: 1em">Choose wisely.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLOP(1)</p>
<hr>
</body>
</html>
