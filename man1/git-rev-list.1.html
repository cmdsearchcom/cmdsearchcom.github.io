<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:13:37 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GIT-REV-LIST(1) Git Manual GIT-REV-LIST(1)</p>

<p style="margin-top: 1em">NAME <br>
git-rev-list - Lists commit objects in reverse chronological
order</p>

<p style="margin-top: 1em">SYNOPSIS <br>
git rev-list [ --max-count=&lt;number&gt; ] <br>
[ --skip=&lt;number&gt; ] <br>
[ --max-age=&lt;timestamp&gt; ] <br>
[ --min-age=&lt;timestamp&gt; ] <br>
[ --sparse ] <br>
[ --merges ] <br>
[ --no-merges ] <br>
[ --min-parents=&lt;number&gt; ] <br>
[ --no-min-parents ] <br>
[ --max-parents=&lt;number&gt; ] <br>
[ --no-max-parents ] <br>
[ --first-parent ] <br>
[ --remove-empty ] <br>
[ --full-history ] <br>
[ --not ] <br>
[ --all ] <br>
[ --branches[=&lt;pattern&gt;] ] <br>
[ --tags[=&lt;pattern&gt;] ] <br>
[ --remotes[=&lt;pattern&gt;] ] <br>
[ --glob=&lt;glob-pattern&gt; ] <br>
[ --ignore-missing ] <br>
[ --stdin ] <br>
[ --quiet ] <br>
[ --topo-order ] <br>
[ --parents ] <br>
[ --timestamp ] <br>
[ --left-right ] <br>
[ --left-only ] <br>
[ --right-only ] <br>
[ --cherry-mark ] <br>
[ --cherry-pick ] <br>
[ --encoding[=&lt;encoding&gt;] ] <br>
[ --(author|committer|grep)=&lt;pattern&gt; ] <br>
[ --regexp-ignore-case | -i ] <br>
[ --extended-regexp | -E ] <br>
[ --fixed-strings | -F ] <br>
[ --date=(local|relative|default|iso|rfc|short) ] <br>
[ [--objects | --objects-edge] [ --unpacked ] ] <br>
[ --pretty | --header ] <br>
[ --bisect ] <br>
[ --bisect-vars ] <br>
[ --bisect-all ] <br>
[ --merge ] <br>
[ --reverse ] <br>
[ --walk-reflogs ] <br>
[ --no-walk ] [ --do-walk ] <br>
&lt;commit&gt;... [ -- &lt;paths&gt;... ]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
List commits that are reachable by following the parent
links from the given commit(s), but exclude commits that are
reachable from the one(s) given with a ^ in front of them.
<br>
The output is given in reverse chronological order by
default.</p>

<p style="margin-top: 1em">You can think of this as a set
operation. Commits given on the command line form a set of
commits that are reachable from any of them, and then
commits reachable from any of the <br>
ones given with ^ in front are subtracted from that set. The
remaining commits are what comes out in the command&acirc;s
output. Various other options and paths parameters can be
used <br>
to further limit the result.</p>

<p style="margin-top: 1em">Thus, the following command:</p>

<p style="margin-top: 1em">$ git rev-list foo bar ^baz</p>

<p style="margin-top: 1em">means &quot;list all the commits
which are reachable from foo or bar, but not from
baz&quot;.</p>

<p style="margin-top: 1em">A special notation
&quot;&lt;commit1&gt;..&lt;commit2&gt;&quot; can be used as
a short-hand for &quot;^&rsquo;&lt;commit1&gt;&rsquo;
&lt;commit2&gt;&quot;. For example, either of the following
may be used interchangeably:</p>

<p style="margin-top: 1em">$ git rev-list origin..HEAD <br>
$ git rev-list HEAD ^origin</p>

<p style="margin-top: 1em">Another special notation is
&quot;&lt;commit1&gt;...&lt;commit2&gt;&quot; which is
useful for merges. The resulting set of commits is the
symmetric difference between the two operands. The following
<br>
two commands are equivalent:</p>

<p style="margin-top: 1em">$ git rev-list A B --not $(git
merge-base --all A B) <br>
$ git rev-list A...B</p>

<p style="margin-top: 1em">rev-list is a very essential Git
command, since it provides the ability to build and traverse
commit ancestry graphs. For this reason, it has a lot of
different options that <br>
enables it to be used by commands as different as git bisect
and git repack.</p>

<p style="margin-top: 1em">OPTIONS <br>
Commit Limiting <br>
Besides specifying a range of commits that should be listed
using the special notations explained in the description,
additional commit limiting may be applied.</p>

<p style="margin-top: 1em">Using more options generally
further limits the output (e.g. --since=&lt;date1&gt; limits
to commits newer than &lt;date1&gt;, and using it with
--grep=&lt;pattern&gt; further limits to commits <br>
whose log message has a line that matches &lt;pattern&gt;),
unless otherwise noted.</p>

<p style="margin-top: 1em">Note that these are applied
before commit ordering and formatting options, such as
--reverse.</p>

<p style="margin-top: 1em">-&lt;number&gt;, -n
&lt;number&gt;, --max-count=&lt;number&gt; <br>
Limit the number of commits to output.</p>

<p style="margin-top: 1em">--skip=&lt;number&gt; <br>
Skip number commits before starting to show the commit
output.</p>

<p style="margin-top: 1em">--since=&lt;date&gt;,
--after=&lt;date&gt; <br>
Show commits more recent than a specific date.</p>

<p style="margin-top: 1em">--until=&lt;date&gt;,
--before=&lt;date&gt; <br>
Show commits older than a specific date.</p>

<p style="margin-top: 1em">--max-age=&lt;timestamp&gt;,
--min-age=&lt;timestamp&gt; <br>
Limit the commits output to specified time range.</p>

<p style="margin-top: 1em">--author=&lt;pattern&gt;,
--committer=&lt;pattern&gt; <br>
Limit the commits output to ones with author/committer
header lines that match the specified pattern (regular
expression). With more than one --author=&lt;pattern&gt;,
commits <br>
whose author matches any of the given patterns are chosen
(similarly for multiple --committer=&lt;pattern&gt;).</p>

<p style="margin-top: 1em">--grep-reflog=&lt;pattern&gt;
<br>
Limit the commits output to ones with reflog entries that
match the specified pattern (regular expression). With more
than one --grep-reflog, commits whose reflog message <br>
matches any of the given patterns are chosen. It is an error
to use this option unless --walk-reflogs is in use.</p>

<p style="margin-top: 1em">--grep=&lt;pattern&gt; <br>
Limit the commits output to ones with log message that
matches the specified pattern (regular expression). With
more than one --grep=&lt;pattern&gt;, commits whose message
matches <br>
any of the given patterns are chosen (but see
--all-match).</p>

<p style="margin-top: 1em">When --show-notes is in effect,
the message from the notes as if it is part of the log
message.</p>

<p style="margin-top: 1em">--all-match <br>
Limit the commits output to ones that match all given
--grep, instead of ones that match at least one.</p>

<p style="margin-top: 1em">-i, --regexp-ignore-case <br>
Match the regexp limiting patterns without regard to letters
case.</p>

<p style="margin-top: 1em">--basic-regexp <br>
Consider the limiting patterns to be basic regular
expressions; this is the default.</p>

<p style="margin-top: 1em">-E, --extended-regexp <br>
Consider the limiting patterns to be extended regular
expressions instead of the default basic regular
expressions.</p>

<p style="margin-top: 1em">-F, --fixed-strings <br>
Consider the limiting patterns to be fixed strings
(don&acirc;t interpret pattern as a regular expression).</p>

<p style="margin-top: 1em">--perl-regexp <br>
Consider the limiting patterns to be Perl-compatible regexp.
Requires libpcre to be compiled in.</p>

<p style="margin-top: 1em">--remove-empty <br>
Stop when a given path disappears from the tree.</p>

<p style="margin-top: 1em">--merges <br>
Print only merge commits. This is exactly the same as
--min-parents=2.</p>

<p style="margin-top: 1em">--no-merges <br>
Do not print commits with more than one parent. This is
exactly the same as --max-parents=1.</p>

<p style="margin-top: 1em">--min-parents=&lt;number&gt;,
--max-parents=&lt;number&gt;, --no-min-parents,
--no-max-parents <br>
Show only commits which have at least (or at most) that many
commits. In particular, --max-parents=1 is the same as
--no-merges, --min-parents=2 is the same as --merges. <br>
--max-parents=0 gives all root commits and --min-parents=3
all octopus merges.</p>

<p style="margin-top: 1em">--no-min-parents and
--no-max-parents reset these limits (to no limit) again.
Equivalent forms are --min-parents=0 (any commit has 0 or
more parents) and --max-parents=-1 <br>
(negative numbers denote no upper limit).</p>

<p style="margin-top: 1em">--first-parent <br>
Follow only the first parent commit upon seeing a merge
commit. This option can give a better overview when viewing
the evolution of a particular topic branch, because merges
<br>
into a topic branch tend to be only about adjusting to
updated upstream from time to time, and this option allows
you to ignore the individual commits brought in to your <br>
history by such a merge.</p>

<p style="margin-top: 1em">--not <br>
Reverses the meaning of the ^ prefix (or lack thereof) for
all following revision specifiers, up to the next --not.</p>

<p style="margin-top: 1em">--all <br>
Pretend as if all the refs in refs/ are listed on the
command line as &lt;commit&gt;.</p>

<p style="margin-top: 1em">--branches[=&lt;pattern&gt;]
<br>
Pretend as if all the refs in refs/heads are listed on the
command line as &lt;commit&gt;. If &lt;pattern&gt; is given,
limit branches to ones matching given shell glob. If pattern
lacks <br>
?, *, or [, /* at the end is implied.</p>

<p style="margin-top: 1em">--tags[=&lt;pattern&gt;] <br>
Pretend as if all the refs in refs/tags are listed on the
command line as &lt;commit&gt;. If &lt;pattern&gt; is given,
limit tags to ones matching given shell glob. If pattern
lacks ?, <br>
*, or [, /* at the end is implied.</p>

<p style="margin-top: 1em">--remotes[=&lt;pattern&gt;] <br>
Pretend as if all the refs in refs/remotes are listed on the
command line as &lt;commit&gt;. If &lt;pattern&gt; is given,
limit remote-tracking branches to ones matching given shell
<br>
glob. If pattern lacks ?, *, or [, /* at the end is
implied.</p>

<p style="margin-top: 1em">--glob=&lt;glob-pattern&gt; <br>
Pretend as if all the refs matching shell glob
&lt;glob-pattern&gt; are listed on the command line as
&lt;commit&gt;. Leading refs/, is automatically prepended if
missing. If pattern <br>
lacks ?, *, or [, /* at the end is implied.</p>

<p style="margin-top: 1em">--ignore-missing <br>
Upon seeing an invalid object name in the input, pretend as
if the bad input was not given.</p>

<p style="margin-top: 1em">--stdin <br>
In addition to the &lt;commit&gt; listed on the command
line, read them from the standard input. If a -- separator
is seen, stop reading commits and start reading paths to
limit <br>
the result.</p>

<p style="margin-top: 1em">--quiet <br>
Don&acirc;t print anything to standard output. This form is
primarily meant to allow the caller to test the exit status
to see if a range of objects is fully connected (or not). It
<br>
is faster than redirecting stdout to /dev/null as the output
does not have to be formatted.</p>

<p style="margin-top: 1em">--cherry-mark <br>
Like --cherry-pick (see below) but mark equivalent commits
with = rather than omitting them, and inequivalent ones with
+.</p>

<p style="margin-top: 1em">--cherry-pick <br>
Omit any commit that introduces the same change as another
commit on the &quot;other side&quot; when the set of commits
are limited with symmetric difference.</p>

<p style="margin-top: 1em">For example, if you have two
branches, A and B, a usual way to list all commits on only
one side of them is with --left-right (see the example below
in the description of the <br>
--left-right option). It however shows the commits that were
cherry-picked from the other branch (for example, &quot;3rd
on b&quot; may be cherry-picked from branch A). With this
<br>
option, such pairs of commits are excluded from the
output.</p>

<p style="margin-top: 1em">--left-only, --right-only <br>
List only commits on the respective side of a symmetric
range, i.e. only those which would be marked &lt; resp. &gt;
by --left-right.</p>

<p style="margin-top: 1em">For example, --cherry-pick
--right-only A...B omits those commits from B which are in A
or are patch-equivalent to a commit in A. In other words,
this lists the + commits <br>
from git cherry A B. More precisely, --cherry-pick
--right-only --no-merges gives the exact list.</p>

<p style="margin-top: 1em">--cherry <br>
A synonym for --right-only --cherry-mark --no-merges; useful
to limit the output to the commits on our side and mark
those that have been applied to the other side of a <br>
forked history with git log --cherry upstream...mybranch,
similar to git cherry upstream mybranch.</p>

<p style="margin-top: 1em">-g, --walk-reflogs <br>
Instead of walking the commit ancestry chain, walk reflog
entries from the most recent one to older ones. When this
option is used you cannot specify commits to exclude (that
<br>
is, ^commit, commit1..commit2, nor commit1...commit2
notations cannot be used).</p>

<p style="margin-top: 1em">With --pretty format other than
oneline (for obvious reasons), this causes the output to
have two extra lines of information taken from the reflog.
By default, commit@{Nth} <br>
notation is used in the output. When the starting commit is
specified as commit@{now}, output also uses
commit@{timestamp} notation instead. Under --pretty=oneline,
the <br>
commit message is prefixed with this information on the same
line. This option cannot be combined with --reverse. See
also git-reflog(1).</p>

<p style="margin-top: 1em">--merge <br>
After a failed merge, show refs that touch files having a
conflict and don&acirc;t exist on all heads to merge.</p>

<p style="margin-top: 1em">--boundary <br>
Output uninteresting commits at the boundary, which are
usually not shown.</p>

<p style="margin-top: 1em">History Simplification <br>
Sometimes you are only interested in parts of the history,
for example the commits modifying a particular &lt;path&gt;.
But there are two parts of History Simplification, one part
is <br>
selecting the commits and the other is how to do it, as
there are various strategies to simplify the history.</p>

<p style="margin-top: 1em">The following options select the
commits to be shown:</p>

<p style="margin-top: 1em">&lt;paths&gt; <br>
Commits modifying the given &lt;paths&gt; are selected.</p>

<p style="margin-top: 1em">--simplify-by-decoration <br>
Commits that are referred by some branch or tag are
selected.</p>

<p style="margin-top: 1em">Note that extra commits can be
shown to give a meaningful history.</p>

<p style="margin-top: 1em">The following options affect the
way the simplification is performed:</p>

<p style="margin-top: 1em">Default mode <br>
Simplifies the history to the simplest history explaining
the final state of the tree. Simplest because it prunes some
side branches if the end result is the same (i.e. <br>
merging branches with the same content)</p>

<p style="margin-top: 1em">--full-history <br>
Same as the default mode, but does not prune some
history.</p>

<p style="margin-top: 1em">--dense <br>
Only the selected commits are shown, plus some to have a
meaningful history.</p>

<p style="margin-top: 1em">--sparse <br>
All commits in the simplified history are shown.</p>

<p style="margin-top: 1em">--simplify-merges <br>
Additional option to --full-history to remove some needless
merges from the resulting history, as there are no selected
commits contributing to this merge.</p>

<p style="margin-top: 1em">--ancestry-path <br>
When given a range of commits to display (e.g.
commit1..commit2 or commit2 ^commit1), only display commits
that exist directly on the ancestry chain between the
commit1 and <br>
commit2, i.e. commits that are both descendants of commit1,
and ancestors of commit2.</p>

<p style="margin-top: 1em">A more detailed explanation
follows.</p>

<p style="margin-top: 1em">Suppose you specified foo as the
&lt;paths&gt;. We shall call commits that modify foo
!TREESAME, and the rest TREESAME. (In a diff filtered for
foo, they look different and equal, <br>
respectively.)</p>

<p style="margin-top: 1em">In the following, we will always
refer to the same example history to illustrate the
differences between simplification settings. We assume that
you are filtering for a file foo <br>
in this commit graph:</p>

<p style="margin-top: 1em">.-A---M---N---O---P <br>
/ / / / / <br>
I B C D E &nbsp; <br>
/ / / / <br>
&lsquo;-------------&rsquo;</p>

<p style="margin-top: 1em">The horizontal line of history
A---P is taken to be the first parent of each merge. The
commits are:</p>

<p style="margin-top: 1em">&Acirc;&middot; I is the initial
commit, in which foo exists with contents &quot;asdf&quot;,
and a file quux exists with contents &quot;quux&quot;.
Initial commits are compared to an empty tree, so I is <br>
!TREESAME.</p>

<p style="margin-top: 1em">&Acirc;&middot; In A, foo
contains just &quot;foo&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; B contains the
same change as A. Its merge M is trivial and hence TREESAME
to all parents.</p>

<p style="margin-top: 1em">&Acirc;&middot; C does not
change foo, but its merge N changes it to
&quot;foobar&quot;, so it is not TREESAME to any parent.</p>

<p style="margin-top: 1em">&Acirc;&middot; D sets foo to
&quot;baz&quot;. Its merge O combines the strings from N and
D to &quot;foobarbaz&quot;; i.e., it is not TREESAME to any
parent.</p>

<p style="margin-top: 1em">&Acirc;&middot; E changes quux
to &quot;xyzzy&quot;, and its merge P combines the strings
to &quot;quux xyzzy&quot;. Despite appearing interesting, P
is TREESAME to all parents.</p>

<p style="margin-top: 1em">rev-list walks backwards through
history, including or excluding commits based on whether
--full-history and/or parent rewriting (via --parents or
--children) are used. The <br>
following settings are available.</p>

<p style="margin-top: 1em">Default mode <br>
Commits are included if they are not TREESAME to any parent
(though this can be changed, see --sparse below). If the
commit was a merge, and it was TREESAME to one parent, <br>
follow only that parent. (Even if there are several TREESAME
parents, follow only one of them.) Otherwise, follow all
parents.</p>

<p style="margin-top: 1em">This results in:</p>

<p style="margin-top: 1em">.-A---N---O <br>
/ / / <br>
I---------D</p>

<p style="margin-top: 1em">Note how the rule to only follow
the TREESAME parent, if one is available, removed B from
consideration entirely. C was considered via N, but is
TREESAME. Root commits are <br>
compared to an empty tree, so I is !TREESAME.</p>

<p style="margin-top: 1em">Parent/child relations are only
visible with --parents, but that does not affect the commits
selected in default mode, so we have shown the parent
lines.</p>

<p style="margin-top: 1em">--full-history without parent
rewriting <br>
This mode differs from the default in one point: always
follow all parents of a merge, even if it is TREESAME to one
of them. Even if more than one side of the merge has <br>
commits that are included, this does not imply that the
merge itself is! In the example, we get</p>

<p style="margin-top: 1em">I A B N D O</p>

<p style="margin-top: 1em">P and M were excluded because
they are TREESAME to a parent. E, C and B were all walked,
but only B was !TREESAME, so the others do not appear.</p>

<p style="margin-top: 1em">Note that without parent
rewriting, it is not really possible to talk about the
parent/child relationships between the commits, so we show
them disconnected.</p>

<p style="margin-top: 1em">--full-history with parent
rewriting <br>
Ordinary commits are only included if they are !TREESAME
(though this can be changed, see --sparse below).</p>

<p style="margin-top: 1em">Merges are always included.
However, their parent list is rewritten: Along each parent,
prune away commits that are not included themselves. This
results in</p>

<p style="margin-top: 1em">.-A---M---N---O---P <br>
/ / / / / <br>
I B / D / &nbsp; <br>
/ / / / <br>
&lsquo;-------------&rsquo;</p>

<p style="margin-top: 1em">Compare to --full-history
without rewriting above. Note that E was pruned away because
it is TREESAME, but the parent list of P was rewritten to
contain E&rsquo;s parent I. The <br>
same happened for C and N. Note also that P was included
despite being TREESAME.</p>

<p style="margin-top: 1em">In addition to the above
settings, you can change whether TREESAME affects
inclusion:</p>

<p style="margin-top: 1em">--dense <br>
Commits that are walked are included if they are not
TREESAME to any parent.</p>

<p style="margin-top: 1em">--sparse <br>
All commits that are walked are included.</p>

<p style="margin-top: 1em">Note that without
--full-history, this still simplifies merges: if one of the
parents is TREESAME, we follow only that one, so the other
sides of the merge are never walked.</p>

<p style="margin-top: 1em">--simplify-merges <br>
First, build a history graph in the same way that
--full-history with parent rewriting does (see above).</p>

<p style="margin-top: 1em">Then simplify each commit C to
its replacement C&rsquo; in the final history according to
the following rules:</p>

<p style="margin-top: 1em">&Acirc;&middot; Set C&rsquo; to
C.</p>

<p style="margin-top: 1em">&Acirc;&middot; Replace each
parent P of C&rsquo; with its simplification P&rsquo;. In
the process, drop parents that are ancestors of other
parents, and remove duplicates.</p>

<p style="margin-top: 1em">&Acirc;&middot; If after this
parent rewriting, C&rsquo; is a root or merge commit (has
zero or &gt;1 parents), a boundary commit, or !TREESAME, it
remains. Otherwise, it is replaced with its <br>
only parent.</p>

<p style="margin-top: 1em">The effect of this is best shown
by way of comparing to --full-history with parent rewriting.
The example turns into:</p>

<p style="margin-top: 1em">.-A---M---N---O <br>
/ / / <br>
I B D &nbsp; <br>
/ / <br>
&lsquo;---------&rsquo;</p>

<p style="margin-top: 1em">Note the major differences in N
and P over --full-history:</p>

<p style="margin-top: 1em">&Acirc;&middot; N&rsquo;s parent
list had I removed, because it is an ancestor of the other
parent M. Still, N remained because it is !TREESAME.</p>

<p style="margin-top: 1em">&Acirc;&middot; P&rsquo;s parent
list similarly had I removed. P was then removed completely,
because it had one parent and is TREESAME.</p>

<p style="margin-top: 1em">Finally, there is a fifth
simplification mode available:</p>

<p style="margin-top: 1em">--ancestry-path <br>
Limit the displayed commits to those directly on the
ancestry chain between the &quot;from&quot; and
&quot;to&quot; commits in the given commit range. I.e. only
display commits that are ancestor <br>
of the &quot;to&quot; commit, and descendants of the
&quot;from&quot; commit.</p>

<p style="margin-top: 1em">As an example use case, consider
the following commit history:</p>

<p style="margin-top: 1em">D---E-------F <br>
/ &nbsp; B---C---G---H---I---J <br>
/ A-------K---------------L--M</p>

<p style="margin-top: 1em">A regular D..M computes the set
of commits that are ancestors of M, but excludes the ones
that are ancestors of D. This is useful to see what happened
to the history leading <br>
to M since D, in the sense that &quot;what does M have that
did not exist in D&quot;. The result in this example would
be all the commits, except A and B (and D itself, of
course).</p>

<p style="margin-top: 1em">When we want to find out what
commits in M are contaminated with the bug introduced by D
and need fixing, however, we might want to view only the
subset of D..M that are <br>
actually descendants of D, i.e. excluding C and K. This is
exactly what the --ancestry-path option does. Applied to the
D..M range, it results in:</p>

<p style="margin-top: 1em">E-------F &nbsp; <br>
G---H---I---J <br>
L--M</p>

<p style="margin-top: 1em">The --simplify-by-decoration
option allows you to view only the big picture of the
topology of the history, by omitting commits that are not
referenced by tags. Commits are <br>
marked as !TREESAME (in other words, kept after history
simplification rules described above) if (1) they are
referenced by tags, or (2) they change the contents of the
paths <br>
given on the command line. All other commits are marked as
TREESAME (subject to be simplified away).</p>

<p style="margin-top: 1em">Bisection Helpers <br>
--bisect <br>
Limit output to the one commit object which is roughly
halfway between included and excluded commits. Note that the
bad bisection ref refs/bisect/bad is added to the included
<br>
commits (if it exists) and the good bisection refs
refs/bisect/good-* are added to the excluded commits (if
they exist). Thus, supposing there are no refs in
refs/bisect/, if</p>

<p style="margin-top: 1em">$ git rev-list --bisect foo ^bar
^baz</p>

<p style="margin-top: 1em">outputs midpoint, the output of
the two commands</p>

<p style="margin-top: 1em">$ git rev-list foo ^midpoint
<br>
$ git rev-list midpoint ^bar ^baz</p>

<p style="margin-top: 1em">would be of roughly the same
length. Finding the change which introduces a regression is
thus reduced to a binary search: repeatedly generate and
test new &rsquo;midpoint&acirc;s until the <br>
commit chain is of length one.</p>

<p style="margin-top: 1em">--bisect-vars <br>
This calculates the same as --bisect, except that refs in
refs/bisect/ are not used, and except that this outputs text
ready to be eval&acirc;ed by the shell. These lines will
<br>
assign the name of the midpoint revision to the variable
bisect_rev, and the expected number of commits to be tested
after bisect_rev is tested to bisect_nr, the expected <br>
number of commits to be tested if bisect_rev turns out to be
good to bisect_good, the expected number of commits to be
tested if bisect_rev turns out to be bad to bisect_bad, <br>
and the number of commits we are bisecting right now to
bisect_all.</p>

<p style="margin-top: 1em">--bisect-all <br>
This outputs all the commit objects between the included and
excluded commits, ordered by their distance to the included
and excluded commits. Refs in refs/bisect/ are not <br>
used. The farthest from them is displayed first. (This is
the only one displayed by --bisect.)</p>

<p style="margin-top: 1em">This is useful because it makes
it easy to choose a good commit to test when you want to
avoid to test some of them for some reason (they may not
compile for example).</p>

<p style="margin-top: 1em">This option can be used along
with --bisect-vars, in this case, after all the sorted
commit objects, there will be the same text as if
--bisect-vars had been used alone.</p>

<p style="margin-top: 1em">Commit Ordering <br>
By default, the commits are shown in reverse chronological
order.</p>

<p style="margin-top: 1em">--date-order <br>
Show no parents before all of its children are shown, but
otherwise show commits in the commit timestamp order.</p>

<p style="margin-top: 1em">--topo-order <br>
Show no parents before all of its children are shown, and
avoid showing commits on multiple lines of history
intermixed.</p>

<p style="margin-top: 1em">For example, in a commit history
like this:</p>

<p style="margin-top: 1em">---1----2----4----7 &nbsp; <br>
3----5----6----8---</p>

<p style="margin-top: 1em">where the numbers denote the
order of commit timestamps, git rev-list and friends with
--date-order show the commits in the timestamp order: 8 7 6
5 4 3 2 1.</p>

<p style="margin-top: 1em">With --topo-order, they would
show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older
commits are shown before newer ones in order to avoid
showing the commits from two <br>
parallel development track mixed together.</p>

<p style="margin-top: 1em">--reverse <br>
Output the commits in reverse order. Cannot be combined with
--walk-reflogs.</p>

<p style="margin-top: 1em">Object Traversal <br>
These options are mostly targeted for packing of Git
repositories.</p>

<p style="margin-top: 1em">--objects <br>
Print the object IDs of any object referenced by the listed
commits. --objects foo ^bar thus means &quot;send me all
object IDs which I need to download if I have the commit
<br>
object bar, but not foo&quot;.</p>

<p style="margin-top: 1em">--objects-edge <br>
Similar to --objects, but also print the IDs of excluded
commits prefixed with a &quot;-&quot; character. This is
used by git-pack-objects(1) to build &quot;thin&quot; pack,
which records <br>
objects in deltified form based on objects contained in
these excluded commits to reduce network traffic.</p>

<p style="margin-top: 1em">--unpacked <br>
Only useful with --objects; print the object IDs that are
not in packs.</p>

<p style="margin-top: 1em">--no-walk[=(sorted|unsorted)]
<br>
Only show the given commits, but do not traverse their
ancestors. This has no effect if a range is specified. If
the argument &quot;unsorted&quot; is given, the commits are
show in the <br>
order they were given on the command line. Otherwise (if
&quot;sorted&quot; or no argument was given), the commits
are show in reverse chronological order by commit time.</p>

<p style="margin-top: 1em">--do-walk <br>
Overrides a previous --no-walk.</p>

<p style="margin-top: 1em">Commit Formatting <br>
Using these options, git-rev-list(1) will act similar to the
more specialized family of commit log tools: git-log(1),
git-show(1), and git-whatchanged(1)</p>

<p style="margin-top: 1em">--pretty[=&lt;format&gt;],
--format=&lt;format&gt; <br>
Pretty-print the contents of the commit logs in a given
format, where &lt;format&gt; can be one of oneline, short,
medium, full, fuller, email, raw and format:&lt;string&gt;.
See the <br>
&quot;PRETTY FORMATS&quot; section for some additional
details for each format. When omitted, the format defaults
to medium.</p>

<p style="margin-top: 1em">Note: you can specify the
default pretty format in the repository configuration (see
git-config(1)).</p>

<p style="margin-top: 1em">--abbrev-commit <br>
Instead of showing the full 40-byte hexadecimal commit
object name, show only a partial prefix. Non default number
of digits can be specified with
&quot;--abbrev=&lt;n&gt;&quot; (which also <br>
modifies diff output, if it is displayed).</p>

<p style="margin-top: 1em">This should make
&quot;--pretty=oneline&quot; a whole lot more readable for
people using 80-column terminals.</p>

<p style="margin-top: 1em">--no-abbrev-commit <br>
Show the full 40-byte hexadecimal commit object name. This
negates --abbrev-commit and those options which imply it
such as &quot;--oneline&quot;. It also overrides the <br>
log.abbrevCommit variable.</p>

<p style="margin-top: 1em">--oneline <br>
This is a shorthand for &quot;--pretty=oneline
--abbrev-commit&quot; used together.</p>

<p style="margin-top: 1em">--encoding[=&lt;encoding&gt;]
<br>
The commit objects record the encoding used for the log
message in their encoding header; this option can be used to
tell the command to re-code the commit log message in the
<br>
encoding preferred by the user. For non plumbing commands
this defaults to UTF-8.</p>

<p style="margin-top: 1em">--notes[=&lt;ref&gt;] <br>
Show the notes (see git-notes(1)) that annotate the commit,
when showing the commit log message. This is the default for
git log, git show and git whatchanged commands when <br>
there is no --pretty, --format nor --oneline option given on
the command line.</p>

<p style="margin-top: 1em">By default, the notes shown are
from the notes refs listed in the core.notesRef and
notes.displayRef variables (or corresponding environment
overrides). See git-config(1) for <br>
more details.</p>

<p style="margin-top: 1em">With an optional &lt;ref&gt;
argument, show this notes ref instead of the default notes
ref(s). The ref is taken to be in refs/notes/ if it is not
qualified.</p>

<p style="margin-top: 1em">Multiple --notes options can be
combined to control which notes are being displayed.
Examples: &quot;--notes=foo&quot; will show only notes from
&quot;refs/notes/foo&quot;; &quot;--notes=foo --notes&quot;
<br>
will show both notes from &quot;refs/notes/foo&quot; and
from the default notes ref(s).</p>

<p style="margin-top: 1em">--no-notes <br>
Do not show notes. This negates the above --notes option, by
resetting the list of notes refs from which notes are shown.
Options are parsed in the order given on the command <br>
line, so e.g. &quot;--notes --notes=foo --no-notes
--notes=bar&quot; will only show notes from
&quot;refs/notes/bar&quot;.</p>

<p style="margin-top: 1em">--show-notes[=&lt;ref&gt;],
--[no-]standard-notes <br>
These options are deprecated. Use the above
--notes/--no-notes options instead.</p>

<p style="margin-top: 1em">--show-signature <br>
Check the validity of a signed commit object by passing the
signature to gpg --verify and show the output.</p>

<p style="margin-top: 1em">--relative-date <br>
Synonym for --date=relative.</p>


<p style="margin-top: 1em">--date=(relative|local|default|iso|rfc|short|raw)
<br>
Only takes effect for dates shown in human-readable format,
such as when using &quot;--pretty&quot;. log.date config
variable sets a default value for log command&acirc;s --date
option.</p>

<p style="margin-top: 1em">--date=relative shows dates
relative to the current time, e.g. &quot;2 hours
ago&quot;.</p>

<p style="margin-top: 1em">--date=local shows timestamps in
user&acirc;s local timezone.</p>

<p style="margin-top: 1em">--date=iso (or --date=iso8601)
shows timestamps in ISO 8601 format.</p>

<p style="margin-top: 1em">--date=rfc (or --date=rfc2822)
shows timestamps in RFC 2822 format, often found in E-mail
messages.</p>

<p style="margin-top: 1em">--date=short shows only date but
not time, in YYYY-MM-DD format.</p>

<p style="margin-top: 1em">--date=raw shows the date in the
internal raw Git format %s %z format.</p>

<p style="margin-top: 1em">--date=default shows timestamps
in the original timezone (either committer&acirc;s or
author&acirc;s).</p>

<p style="margin-top: 1em">--header <br>
Print the contents of the commit in raw-format; each record
is separated with a NUL character.</p>

<p style="margin-top: 1em">--parents <br>
Print also the parents of the commit (in the form
&quot;commit parent...&quot;). Also enables parent
rewriting, see History Simplification below.</p>

<p style="margin-top: 1em">--children <br>
Print also the children of the commit (in the form
&quot;commit child...&quot;). Also enables parent rewriting,
see History Simplification below.</p>

<p style="margin-top: 1em">--timestamp <br>
Print the raw commit timestamp.</p>

<p style="margin-top: 1em">--left-right <br>
Mark which side of a symmetric diff a commit is reachable
from. Commits from the left side are prefixed with &lt; and
those from the right with &gt;. If combined with --boundary,
<br>
those commits are prefixed with -.</p>

<p style="margin-top: 1em">For example, if you have this
topology:</p>

<p style="margin-top: 1em">y---b---b branch B <br>
/ &nbsp;/ <br>
/ . <br>
/ / o---x---a---a branch A</p>

<p style="margin-top: 1em">you would get an output like
this:</p>

<p style="margin-top: 1em">$ git rev-list --left-right
--boundary --pretty=oneline A...B</p>

<p style="margin-top: 1em">&gt;bbbbbbb... 3rd on b <br>
&gt;bbbbbbb... 2nd on b <br>
&lt;aaaaaaa... 3rd on a <br>
&lt;aaaaaaa... 2nd on a <br>
-yyyyyyy... 1st on b <br>
-xxxxxxx... 1st on a</p>

<p style="margin-top: 1em">--graph <br>
Draw a text-based graphical representation of the commit
history on the left hand side of the output. This may cause
extra lines to be printed in between commits, in order <br>
for the graph history to be drawn properly.</p>

<p style="margin-top: 1em">This enables parent rewriting,
see History Simplification below.</p>

<p style="margin-top: 1em">This implies the --topo-order
option by default, but the --date-order option may also be
specified.</p>

<p style="margin-top: 1em">--count <br>
Print a number stating how many commits would have been
listed, and suppress all other output. When used together
with --left-right, instead print the counts for left and
<br>
right commits, separated by a tab. When used together with
--cherry-mark, omit patch equivalent commits from these
counts and print the count for equivalent commits separated
<br>
by a tab.</p>

<p style="margin-top: 1em">PRETTY FORMATS <br>
If the commit is a merge, and if the pretty-format is not
oneline, email or raw, an additional line is inserted before
the Author: line. This line begins with &quot;Merge: &quot;
and the <br>
sha1s of ancestral commits are printed, separated by spaces.
Note that the listed commits may not necessarily be the list
of the direct parent commits if you have limited your <br>
view of history: for example, if you are only interested in
changes related to a certain directory or file.</p>

<p style="margin-top: 1em">There are several built-in
formats, and you can define additional formats by setting a
pretty.&lt;name&gt; config option to either another format
name, or a format: string, as <br>
described below (see git-config(1)). Here are the details of
the built-in formats:</p>

<p style="margin-top: 1em">&Acirc;&middot; oneline</p>

<p style="margin-top: 1em">&lt;sha1&gt; &lt;title
line&gt;</p>

<p style="margin-top: 1em">This is designed to be as
compact as possible.</p>

<p style="margin-top: 1em">&Acirc;&middot; short</p>

<p style="margin-top: 1em">commit &lt;sha1&gt; <br>
Author: &lt;author&gt;</p>

<p style="margin-top: 1em">&lt;title line&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; medium</p>

<p style="margin-top: 1em">commit &lt;sha1&gt; <br>
Author: &lt;author&gt; <br>
Date: &lt;author date&gt;</p>

<p style="margin-top: 1em">&lt;title line&gt;</p>

<p style="margin-top: 1em">&lt;full commit message&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; full</p>

<p style="margin-top: 1em">commit &lt;sha1&gt; <br>
Author: &lt;author&gt; <br>
Commit: &lt;committer&gt;</p>

<p style="margin-top: 1em">&lt;title line&gt;</p>

<p style="margin-top: 1em">&lt;full commit message&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; fuller</p>

<p style="margin-top: 1em">commit &lt;sha1&gt; <br>
Author: &lt;author&gt; <br>
AuthorDate: &lt;author date&gt; <br>
Commit: &lt;committer&gt; <br>
CommitDate: &lt;committer date&gt;</p>

<p style="margin-top: 1em">&lt;title line&gt;</p>

<p style="margin-top: 1em">&lt;full commit message&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; email</p>

<p style="margin-top: 1em">From &lt;sha1&gt; &lt;date&gt;
<br>
From: &lt;author&gt; <br>
Date: &lt;author date&gt; <br>
Subject: [PATCH] &lt;title line&gt;</p>

<p style="margin-top: 1em">&lt;full commit message&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; raw</p>

<p style="margin-top: 1em">The raw format shows the entire
commit exactly as stored in the commit object. Notably, the
SHA-1s are displayed in full, regardless of whether --abbrev
or --no-abbrev are <br>
used, and parents information show the true parent commits,
without taking grafts nor history simplification into
account.</p>

<p style="margin-top: 1em">&Acirc;&middot;
format:&lt;string&gt;</p>

<p style="margin-top: 1em">The format:&lt;string&gt; format
allows you to specify which information you want to show. It
works a little bit like printf format, with the notable
exception that you get a <br>
newline with %n instead of 0</p>

<p style="margin-top: 1em">E.g, format:&quot;The author of
%h was %an, %ar%nThe title was &gt;&gt;%s&lt;&lt;%n&quot;
would show something like this:</p>

<p style="margin-top: 1em">The author of fe6e0ee was Junio
C Hamano, 23 hours ago <br>
The title was &gt;&gt;t4119: test autocomputing -p&lt;n&gt;
for traditional diff input.&lt;&lt;</p>

<p style="margin-top: 1em">The placeholders are:</p>

<p style="margin-top: 1em">&Acirc;&middot; %H: commit
hash</p>

<p style="margin-top: 1em">&Acirc;&middot; %h: abbreviated
commit hash</p>

<p style="margin-top: 1em">&Acirc;&middot; %T: tree
hash</p>

<p style="margin-top: 1em">&Acirc;&middot; %t: abbreviated
tree hash</p>

<p style="margin-top: 1em">&Acirc;&middot; %P: parent
hashes</p>

<p style="margin-top: 1em">&Acirc;&middot; %p: abbreviated
parent hashes</p>

<p style="margin-top: 1em">&Acirc;&middot; %an: author
name</p>

<p style="margin-top: 1em">&Acirc;&middot; %aN: author name
(respecting .mailmap, see git-shortlog(1) or
git-blame(1))</p>

<p style="margin-top: 1em">&Acirc;&middot; %ae: author
email</p>

<p style="margin-top: 1em">&Acirc;&middot; %aE: author
email (respecting .mailmap, see git-shortlog(1) or
git-blame(1))</p>

<p style="margin-top: 1em">&Acirc;&middot; %ad: author date
(format respects --date= option)</p>

<p style="margin-top: 1em">&Acirc;&middot; %aD: author
date, RFC2822 style</p>

<p style="margin-top: 1em">&Acirc;&middot; %ar: author
date, relative</p>

<p style="margin-top: 1em">&Acirc;&middot; %at: author
date, UNIX timestamp</p>

<p style="margin-top: 1em">&Acirc;&middot; %ai: author
date, ISO 8601 format</p>

<p style="margin-top: 1em">&Acirc;&middot; %cn: committer
name</p>

<p style="margin-top: 1em">&Acirc;&middot; %cN: committer
name (respecting .mailmap, see git-shortlog(1) or
git-blame(1))</p>

<p style="margin-top: 1em">&Acirc;&middot; %ce: committer
email</p>

<p style="margin-top: 1em">&Acirc;&middot; %cE: committer
email (respecting .mailmap, see git-shortlog(1) or
git-blame(1))</p>

<p style="margin-top: 1em">&Acirc;&middot; %cd: committer
date</p>

<p style="margin-top: 1em">&Acirc;&middot; %cD: committer
date, RFC2822 style</p>

<p style="margin-top: 1em">&Acirc;&middot; %cr: committer
date, relative</p>

<p style="margin-top: 1em">&Acirc;&middot; %ct: committer
date, UNIX timestamp</p>

<p style="margin-top: 1em">&Acirc;&middot; %ci: committer
date, ISO 8601 format</p>

<p style="margin-top: 1em">&Acirc;&middot; %d: ref names,
like the --decorate option of git-log(1)</p>

<p style="margin-top: 1em">&Acirc;&middot; %e: encoding</p>

<p style="margin-top: 1em">&Acirc;&middot; %s: subject</p>

<p style="margin-top: 1em">&Acirc;&middot; %f: sanitized
subject line, suitable for a filename</p>

<p style="margin-top: 1em">&Acirc;&middot; %b: body</p>

<p style="margin-top: 1em">&Acirc;&middot; %B: raw body
(unwrapped subject and body)</p>

<p style="margin-top: 1em">&Acirc;&middot; %N: commit
notes</p>

<p style="margin-top: 1em">&Acirc;&middot; %GG: raw
verification message from GPG for a signed commit</p>

<p style="margin-top: 1em">&Acirc;&middot; %G?: show
&quot;G&quot; for a Good signature, &quot;B&quot; for a Bad
signature, &quot;U&quot; for a good, untrusted signature and
&quot;N&quot; for no signature</p>

<p style="margin-top: 1em">&Acirc;&middot; %GS: show the
name of the signer for a signed commit</p>

<p style="margin-top: 1em">&Acirc;&middot; %GK: show the
key used to sign a signed commit</p>

<p style="margin-top: 1em">&Acirc;&middot; %gD: reflog
selector, e.g., refs/stash@{1}</p>

<p style="margin-top: 1em">&Acirc;&middot; %gd: shortened
reflog selector, e.g., stash@{1}</p>

<p style="margin-top: 1em">&Acirc;&middot; %gn: reflog
identity name</p>

<p style="margin-top: 1em">&Acirc;&middot; %gN: reflog
identity name (respecting .mailmap, see git-shortlog(1) or
git-blame(1))</p>

<p style="margin-top: 1em">&Acirc;&middot; %ge: reflog
identity email</p>

<p style="margin-top: 1em">&Acirc;&middot; %gE: reflog
identity email (respecting .mailmap, see git-shortlog(1) or
git-blame(1))</p>

<p style="margin-top: 1em">&Acirc;&middot; %gs: reflog
subject</p>

<p style="margin-top: 1em">&Acirc;&middot; %Cred: switch
color to red</p>

<p style="margin-top: 1em">&Acirc;&middot; %Cgreen: switch
color to green</p>

<p style="margin-top: 1em">&Acirc;&middot; %Cblue: switch
color to blue</p>

<p style="margin-top: 1em">&Acirc;&middot; %Creset: reset
color</p>

<p style="margin-top: 1em">&Acirc;&middot; %C(...): color
specification, as described in color.branch.* config option;
adding auto, at the beginning will emit color only when
colors are enabled for log output (by <br>
color.diff, color.ui, or --color, and respecting the auto
settings of the former if we are going to a terminal). auto
alone (i.e. %C(auto)) will turn on auto coloring <br>
on the next placeholders until the color is switched
again.</p>

<p style="margin-top: 1em">&Acirc;&middot; %m: left, right
or boundary mark</p>

<p style="margin-top: 1em">&Acirc;&middot; %n: newline</p>

<p style="margin-top: 1em">&Acirc;&middot; %%: a raw %</p>

<p style="margin-top: 1em">&Acirc;&middot; %x00: print a
byte from a hex code</p>

<p style="margin-top: 1em">&Acirc;&middot;
%w([&lt;w&gt;[,&lt;i1&gt;[,&lt;i2&gt;]]]): switch line
wrapping, like the -w option of git-shortlog(1).</p>

<p style="margin-top: 1em">&Acirc;&middot;
%&lt;(&lt;N&gt;[,trunc|ltrunc|mtrunc]): make the next
placeholder take at least N columns, padding spaces on the
right if necessary. Optionally truncate at the beginning
(ltrunc), <br>
the middle (mtrunc) or the end (trunc) if the output is
longer than N columns. Note that truncating only works
correctly with N &gt;= 2.</p>

<p style="margin-top: 1em">&Acirc;&middot;
%&lt;|(&lt;N&gt;): make the next placeholder take at least
until Nth columns, padding spaces on the right if
necessary</p>

<p style="margin-top: 1em">&Acirc;&middot;
%&gt;(&lt;N&gt;), %&gt;|(&lt;N&gt;): similar to
%&lt;(&lt;N&gt;), %&lt;|(&lt;N&gt;) respectively, but
padding spaces on the left</p>

<p style="margin-top: 1em">&Acirc;&middot;
%&gt;&gt;(&lt;N&gt;), %&gt;&gt;|(&lt;N&gt;): similar to
%&gt;(&lt;N&gt;), %&gt;|(&lt;N&gt;) respectively, except
that if the next placeholder takes more spaces than given
and there are spaces on its left, use <br>
those spaces</p>

<p style="margin-top: 1em">&Acirc;&middot;
%&gt;&lt;(&lt;N&gt;), %&gt;&lt;|(&lt;N&gt;): similar to %
&lt;(&lt;N&gt;), %&lt;|(&lt;N&gt;) respectively, but padding
both sides (i.e. the text is centered)</p>

<p style="margin-top: 1em">Note <br>
Some placeholders may depend on other options given to the
revision traversal engine. For example, the %g* reflog
options will insert an empty string unless we are traversing
<br>
reflog entries (e.g., by git log -g). The %d placeholder
will use the &quot;short&quot; decoration format if
--decorate was not already provided on the command line.</p>

<p style="margin-top: 1em">If you add a + (plus sign) after
% of a placeholder, a line-feed is inserted immediately
before the expansion if and only if the placeholder expands
to a non-empty string.</p>

<p style="margin-top: 1em">If you add a - (minus sign)
after % of a placeholder, line-feeds that immediately
precede the expansion are deleted if and only if the
placeholder expands to an empty string.</p>

<p style="margin-top: 1em">If you add a &lsquo; &lsquo;
(space) after % of a placeholder, a space is inserted
immediately before the expansion if and only if the
placeholder expands to a non-empty string.</p>

<p style="margin-top: 1em">&Acirc;&middot; tformat:</p>

<p style="margin-top: 1em">The tformat: format works
exactly like format:, except that it provides
&quot;terminator&quot; semantics instead of
&quot;separator&quot; semantics. In other words, each commit
has the message <br>
terminator character (usually a newline) appended, rather
than a separator placed between entries. This means that the
final entry of a single-line format will be properly <br>
terminated with a new line, just as the &quot;oneline&quot;
format does. For example:</p>

<p style="margin-top: 1em">$ git log -2 --pretty=format:%h
4da45bef | perl -pe &rsquo;$_ .= &quot; -- NO NEWLINE0
unless /0&rsquo; <br>
4da45be <br>
7134973 -- NO NEWLINE</p>

<p style="margin-top: 1em">$ git log -2 --pretty=tformat:%h
4da45bef | perl -pe &rsquo;$_ .= &quot; -- NO NEWLINE0
unless /0&rsquo; <br>
4da45be <br>
7134973</p>

<p style="margin-top: 1em">In addition, any unrecognized
string that has a % in it is interpreted as if it has
tformat: in front of it. For example, these two are
equivalent:</p>

<p style="margin-top: 1em">$ git log -2 --pretty=tformat:%h
4da45bef <br>
$ git log -2 --pretty=%h 4da45bef</p>

<p style="margin-top: 1em">GIT <br>
Part of the git(1) suite</p>

<p style="margin-top: 1em">Git 1.8.3.1 03/23/2016
GIT-REV-LIST(1)</p>
<hr>
</body>
</html>
