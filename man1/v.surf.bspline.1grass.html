<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>v.surf.bspline(1grass)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">v.surf.bspline(1grass)</td>
    <td class="head-vol">Grass User's Manual</td>
    <td class="head-rtitle">v.surf.bspline(1grass)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
<i></i><b>v.surf.bspline</b> - Performs bicubic or bilinear spline interpolation
  with Tykhonov regularization.
<h1 class="Sh" title="Sh" id="KEYWORDS"><a class="selflink" href="#KEYWORDS">KEYWORDS</a></h1>
vector, surface, interpolation, LIDAR
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>v.surf.bspline</b>
<div>&#x00A0;</div>
<b>v.surf.bspline --help</b>
<div>&#x00A0;</div>
<b>v.surf.bspline</b> [-<b>ce</b>] <b>input</b>=<i>name</i>
  [<b>layer</b>=<i>string</i>] [ <b>column</b>=<i>name</i>]
  [<b>sparse_input</b>= <i>name</i>] [<b>output</b>=<i>name</i>]
  [<b>raster_output</b>= <i>name</i>] [<b>mask</b>=<i>name</i>]
  [<b>ew_step</b>=<i>float</i>] [<b>ns_step</b>=<i>float</i>]
  [<b>method</b>=<i>string</i>] [ <b>lambda_i</b>=<i>float</i>]
  [<b>solver</b>=<i>name</i>] [<b>maxit</b>=<i>integer</i>]
  [<b>error</b>=<i>float</i>] [ <b>memory</b>=<i>integer</i>]
  [--<b>overwrite</b>] [-- <b>help</b>] [--<b>verbose</b>] [--<b>quiet</b>]
  [--<b>ui</b>]
<h2 class="Ss" title="Ss" id="Flags:"><a class="selflink" href="#Flags:">Flags:</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Find the best Tykhonov regularizing parameter using a
      &quot;leave-one-out&quot; cross validation method</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Estimate point density and distance
    <div>&#x00A0;</div>
    Estimate point density and distance for the input vector points within the
      current region extends and quit</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--overwrite</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Allow output files to overwrite existing files</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Print usage summary</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--verbose</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Verbose module output</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quiet</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Quiet module output</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ui</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Force launching GUI dialog</dd>
</dl>
<h2 class="Ss" title="Ss" id="Parameters:"><a class="selflink" href="#Parameters:">Parameters:</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>input</b>=<i>name</i> <b>[required]</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Name of input vector point map
    <div>&#x00A0;</div>
    Or data source for direct OGR access</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>layer</b>=<i>string</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Layer number or name
    <div>&#x00A0;</div>
    Vector features can have category values in different layers. This number
      determines which layer to use. When used with direct OGR access this is
      the layer name.
    <div>&#x00A0;</div>
    Default: <i>1</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>column</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Name of the attribute column with values to be used for approximation
    <div>&#x00A0;</div>
    If not given and input is 3D vector map then z-coordinates are used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sparse_input</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Name of input vector map with sparse points
    <div>&#x00A0;</div>
    Or data source for direct OGR access</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>output</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Name for output vector map</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>raster_output</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Name for output raster map</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mask</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Raster map to use for masking (applies to raster output only)
    <div>&#x00A0;</div>
    Only cells that are not NULL and not zero are interpolated</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ew_step</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Length of each spline step in the east-west direction
    <div>&#x00A0;</div>
    Default: <i>4</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ns_step</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Length of each spline step in the north-south direction
    <div>&#x00A0;</div>
    Default: <i>4</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>method</b>=<i>string</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Spline interpolation algorithm
    <div>&#x00A0;</div>
    Options: <i>bilinear, bicubic</i>
    <div>&#x00A0;</div>
    Default: <i>bilinear</i>
    <div>&#x00A0;</div>
     <b>bilinear</b>: Bilinear interpolation
    <div>&#x00A0;</div>
     <b>bicubic</b>: Bicubic interpolation</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>lambda_i</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Tykhonov regularization parameter (affects smoothing)
    <div>&#x00A0;</div>
    Default: <i>0.01</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>solver</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    The type of solver which should solve the symmetric linear equation system
    <div>&#x00A0;</div>
    Options: <i>cholesky, cg</i>
    <div>&#x00A0;</div>
    Default: <i>cholesky</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>maxit</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Maximum number of iteration used to solve the linear equation system
    <div>&#x00A0;</div>
    Default: <i>10000</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>error</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Error break criteria for iterative solver
    <div>&#x00A0;</div>
    Default: <i>0.000001</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>memory</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Maximum memory to be used (in MB)
    <div>&#x00A0;</div>
    Cache size for raster rows
    <div>&#x00A0;</div>
    Default: <i>300</i></dd>
</dl>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>v.surf.bspline</i> performs a bilinear/bicubic spline interpolation with
  Tykhonov regularization. The <b>input</b> is a 2D or 3D vector <i>points</i>
  map. Values to interpolate can be the z values of 3D points or the values in a
  user-specified attribute column in a 2D or 3D vector map. Output can be a
  raster ( <b>raster_output</b>) or vector (<b>output</b>) map. Optionally, a
  &quot;sparse point&quot; vector map can be input which indicates the location
  of <b>output</b> vector points.
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
From a theoretical perspective, the interpolating procedure takes place in two
  parts: the first is an estimate of the linear coefficients of a spline
  function is derived from the observation points using a least squares
  regression; the second is the computation of the interpolated surface (or
  interpolated vector points). As used here, the splines are 2D piece-wise
  non-zero polynomial functions calculated within a limited, 2D area. The length
  of each spline step is defined by <b>ew_step</b> for the east-west direction
  and <b>ns_step</b> for the north-south direction. For optimal performance, the
  length of spline step should be no less than the distance between observation
  points. Each vector point observation is modeled as a linear function of the
  non-zero splines in the area around the observation. The least squares
  regression predicts the the coefficients of these linear functions.
  Regularization, avoids the need to have one observation and one coefficient
  for each spline (in order to avoid instability).
<div class="Pp"></div>
With regularly distributed data points, a spline step corresponding to the
  maximum distance between two points in both the east and north directions is
  sufficient. But often data points are not regularly distributed and require
  statistial regularization or estimation. In such cases, v.surf.bspline will
  attempt to minimize the gradient of bilinear splines or the curvature of
  bicubic splines in areas lacking point observations. As a general rule, spline
  step length should be greater than the mean distance between observation
  points (twice the distance between points is a good starting point). Separate
  east-west and north-south spline step length arguments allows the user to
  account for some degree of anisotropy in the distribution of observation
  points. Short spline step lengths - especially spline step lengths that are
  less than the distance between observation points - can greatly increase the
  processing time.
<div class="Pp"></div>
Moreover, the maximum number of splines for each direction at each time is
  fixed, regardless of the spline step length. As the total number of splines
  used increases (i.e., with small spline step lengths), the region is
  automatically split into subregions for interpolation. Each subregion can
  contain no more than 150x150 splines. To avoid subregion boundary problems,
  subregions are created to partially overlap each other. A weighted mean of
  observations, based on point locations, is calculated within each subregion.
<div class="Pp"></div>
The Tykhonov regularization parameter ( <b>lambda_i</b>) acts to smooth the
  interpolation. With a small <b>lambda_i</b>, the interpolated surface closely
  follows observation points; a larger value will produce a smoother
  interpolation.
<div class="Pp"></div>
The input can be a 2D or 3D vector points map. If input is 3D and <b>column</b>
  is not given than z-coordinates are used for interpolation. Parameter
  <b>column</b> is required when input is 2D vector map.
<div class="Pp"></div>
<i>v.surf.bspline</i> can produce a <b>raster_output</b> OR a <b>output</b> (but
  NOT simultaneously). Note that topology is not build for output vector point
  map. The topology can be built if required by <i>v.build</i>.
<div class="Pp"></div>
If output is a vector points map and a <b>sparse</b> vector points map is not
  specified, the output vector map will contain points at the same locations as
  observation points in the input map, but the values of the output points are
  interpolated values. If instead a <b>sparse</b> vector points map is
  specified, the output vector map will contain points at the same locations as
  the sparse vector map points, and values will be those of the interpolated
  raster surface at those points.
<div class="Pp"></div>
A cross validation &quot;leave-one-out&quot; analysis is available to help to
  determine the optimal <b>lambda_i</b> value that produces an interpolation
  that best fits the original observation data. The more points used for
  cross-validation, the longer the time needed for computation. Empirical
  testing indicates a threshold of a maximum of 100 points is recommended. Note
  that cross validation can run very slowly if more than 100 observations are
  used. The cross-validation output reports <i>mean</i> and <i>rms</i> of the
  residuals from the true point value and the estimated from the interpolation
  for a fixed series of <b>lambda_i</b> values. No vector nor raster output will
  be created when cross-validation is selected.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<h2 class="Ss" title="Ss" id="Basic_interpolation"><a class="selflink" href="#Basic_interpolation">Basic
  interpolation</a></h2>
<pre>
v.surf.bspline input=point_vector output=interpolate_surface method=bicubic
</pre>
A bicubic spline interpolation will be done and a vector points map with
  estimated (i.e., interpolated) values will be created.
<h2 class="Ss" title="Ss" id="Basic_interpolation_and_raster_output_with_a_longer_spline_step"><a class="selflink" href="#Basic_interpolation_and_raster_output_with_a_longer_spline_step">Basic
  interpolation and raster output with a longer spline step</a></h2>
<pre>
v.surf.bspline input=point_vector raster=interpolate_surface ew_step=25 ns_step=25
</pre>
A bilinear spline interpolation will be done with a spline step length of 25 map
  units. An interpolated raster map will be created at the current region
  resolution.
<h2 class="Ss" title="Ss" id="Estimation_of_lambda_i_parameter_with_a_cross_validation_process"><a class="selflink" href="#Estimation_of_lambda_i_parameter_with_a_cross_validation_process">Estimation
  of lambda_i parameter with a cross validation process</a></h2>
<pre>
v.surf.bspline -c input=point_vector
</pre>
<h2 class="Ss" title="Ss" id="Estimation_on_sparse_points"><a class="selflink" href="#Estimation_on_sparse_points">Estimation
  on sparse points</a></h2>
<pre>
v.surf.bspline input=point_vector sparse=sparse_points output=interpolate_surface
</pre>
An output map of vector points will be created, corresponding to the sparse
  vector map, with interpolated values.
<h2 class="Ss" title="Ss" id="Using_attribute_values_instead_z-coordinates"><a class="selflink" href="#Using_attribute_values_instead_z-coordinates">Using
  attribute values instead z-coordinates</a></h2>
<pre>
v.surf.bspline input=point_vector raster=interpolate_surface layer=1 \
  column=attrib_column
</pre>
The interpolation will be done using the values in <i>attrib_column</i>, in the
  table associated with layer 1.
<h2 class="Ss" title="Ss" id="North_carolina_location_example_using_z-coordinates_for_interpolation"><a class="selflink" href="#North_carolina_location_example_using_z-coordinates_for_interpolation">North
  carolina location example using z-coordinates for interpolation</a></h2>
<pre>
g.region region=rural_1m res=2 -p
v.surf.bspline input=elev_lid792_bepts raster=elev_lid792_rast \
  ew_step=5 ns_step=5 method=bicubic lambda_i=0.1
</pre>
<h1 class="Sh" title="Sh" id="KNOWN_ISSUES"><a class="selflink" href="#KNOWN_ISSUES">KNOWN
  ISSUES</a></h1>
Known issues:
<div class="Pp"></div>
In order to avoid RAM memory problems, an auxiliary table is needed for
  recording some intermediate calculations. This requires the <i>GROUP BY</i>
  SQL function is used, which is not supported by the DBF driver. For this
  reason, vector map output ( <b>output</b>) is not permitted with the DBF
  driver. There are no problems with the raster map output from the DBF driver.
<h1 class="Sh" title="Sh" id="REFERENCES"><a class="selflink" href="#REFERENCES">REFERENCES</a></h1>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Brovelli M. A., Cannata M., and Longoni U.M., 2004, LIDAR
      Data Filtering and DTM Interpolation Within GRASS, Transactions in GIS,
      April 2004, vol. 8, iss. 2, pp. 155-174(20), Blackwell Publishing Ltd</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Brovelli M. A. and Cannata M., 2004, Digital Terrain model
      reconstruction in urban areas from airborne laser scanning data: the
      method and an example for Pavia (Northern Italy). Computers and
      Geosciences 30, pp.325-331</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Brovelli M. A e Longoni U.M., 2003, Software per il
      filtraggio di dati LIDAR, Rivista dell&#x2019;Agenzia del Territorio, n.
      3-2003, pp. 11-22 (ISSN 1593-2192)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Antolin R. and Brovelli M.A., 2007, LiDAR data Filtering
      with GRASS GIS for the Determination of Digital Terrain Models.
      Proceedings of Jornadas de SIG Libre, Girona, Espa&#x00F1;a. CD ISBN:
      978-84-690-3886-9</dd>
</dl>
</div>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i></i> <i>v.surf.idw,</i> <i>v.surf.rst</i> <i></i>
<div class="Pp"></div>
Overview: Interpolation and Resampling in GRASS GIS
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Original version (s.bspline.reg) in GRASS 5.4: Maria Antonia Brovelli,
  Massimiliano Cannata, Ulisse Longoni, Mirko Reguzzoni
<div>&#x00A0;</div>
Update for GRASS 6 and improvements: Roberto Antolin
<div class="Pp"></div>
<i>Last changed: $Date: 2016-08-03 13:53:17 +0200 (Wed, 03 Aug 2016) $</i>
<h1 class="Sh" title="Sh" id="SOURCE_CODE"><a class="selflink" href="#SOURCE_CODE">SOURCE
  CODE</a></h1>
Available at: v.surf.bspline source code (history)
<div class="Pp"></div>
Main index | Vector index | Topics index | Keywords index | Graphical index |
  Full index
<div class="Pp"></div>
&#x00A9; 2003-2016 GRASS Development Team, GRASS GIS 7.2.0 Reference
  Manual</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os">GRASS 7.2.0</td>
  </tr>
</table>
</body>
</html>
