<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>dskutil(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">dskutil(1)</td>
    <td class="head-vol">Emulators</td>
    <td class="head-rtitle">dskutil(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
dskutil - Simple sector edtor for discs and disc images.
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>dskutil</b> [<i>-type TYPE</i>] [<i>-side SIDE</i>] [<i>-comp COMP</i>]
  [<i>-dstep</i>] [<i>-retry COUNT</i>] [<i>-format FMT</i>] <i>DISKIMAGE</i>
<div class="Pp"></div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
dskutil is an interactive command-driven sector editor, patterned after the
  venerable CP/M sector editor DU90. This explains some of its idiosyncracies,
  such as the fact that commands deal in logical track numbers but physical
  sector numbers.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-type TYPE</b></dt>
  <dd class="It-tag">Determines which LibDsk driver is to be used to access the
      disc.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>auto</b></dt>
  <dd class="It-tag">Select according to the disc image file. This is the
      default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dsk</b></dt>
  <dd class="It-tag">Use the DSK (CPCEmu format) image driver.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>edsk</b></dt>
  <dd class="It-tag">Use the extended version of the DSK format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>floppy</b></dt>
  <dd class="It-tag">Use the floppy driver.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>myz80</b></dt>
  <dd class="It-tag">Use the hard disk (MYZ80 format) image driver. (This format
      cannot be autodetected.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cfi</b></dt>
  <dd class="It-tag">Use the CFI (DOS fdcopy format) image driver. (This format
      cannot be autodetected.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>apridisk</b></dt>
  <dd class="It-tag">Use the ApriDisk image driver (from the utility of the same
      name). (This format cannot be autodetected.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>raw</b></dt>
  <dd class="It-tag">Use the raw driver.</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-comp COMP</b></dt>
  <dd class="It-tag">Select the compression method used on the disc image file
      (has no effect when reading a floppy disc).</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>auto</b></dt>
  <dd class="It-tag">Detect from the first few bytes of the file. This is the
      default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sq</b></dt>
  <dd class="It-tag">Huffman coded (SQ / USQ).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gz</b></dt>
  <dd class="It-tag">Gzipped (gzip / gunzip).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bz2</b></dt>
  <dd class="It-tag">Burrows-Wheeler compressed (bzip2 / bunzip2).</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-side SIDE</b></dt>
  <dd class="It-tag">Determines which side (0 or 1) of the source disc is to be
      scanned. If this option is not present both sides will be scanned.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-dstep</b></dt>
  <dd class="It-tag">Double-step the source drive (used to read 360k discs in
      1.2Mb drives). Only supported by the Linux floppy driver.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-retry COUNT</b></dt>
  <dd class="It-tag">Set the number of times to attempt a read/write/format in
      case of error.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-format FMT</b></dt>
  <dd class="It-tag">Do not autodetect the disc format; use the named format.
      The format need only be an approximation to the actual format used by the
      disc.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-first CYL</b></dt>
  <dd class="It-tag">Start scanning at the specified cylinder.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-last CYL</b></dt>
  <dd class="It-tag">Scan up to and including the specified cylinder.</dd>
</dl>
<h1 class="Sh" title="Sh" id="COMMANDS"><a class="selflink" href="#COMMANDS">COMMANDS</a></h1>
The following single-letter commands are used. Operands in brackets such as
  [filename] are optional. Numeric inputs are shown as nn for decimal, and xx
  for hex. In either case, prefixing the number with &quot;#&quot; selects the
  alternate number system.
<div class="Pp"></div>
Multiple commands on a line are allowed, separated by semicolons.
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag">+[x]</dt>
  <dd class="It-tag">Increase the current sector number by <i>[x]</i> and read
      the resulting sector, incrementing the track if necessary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-[x]</dt>
  <dd class="It-tag">Decrease the current sector number by <i>[x]</i> and read
      the resulting sector, decrementing the track if necessary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">#</dt>
  <dd class="It-tag">Display the disc geometry for the current drive/disc
    image.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">$[variable[=value]]</dt>
  <dd class="It-tag">View and amend the geometry. &quot;$&quot; by itself shows
      all possible variables with their current values; &quot;$variable&quot;
      shows the value of one variable; and &quot;$variable=value&quot; sets a
      new value. Note that changing the size of the sector with
      &quot;$secsize=nn&quot; will cause the current sector buffer and clip
      buffer to be cleared.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">=ascii</dt>
  <dd class="It-tag">Search for an ASCII string, starting at the current sector.
      Hex codes can be included in the ASCII by surrounding them with angle
      brackets - for example, to search for the word &quot;Hello&quot; at the
      start of a line, you could use &quot;=&lt;0A&gt;Hello&quot;. The search
      string is case-sensitive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&lt;</dt>
  <dd class="It-tag">Save the currently-loaded sector to a clip buffer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&gt;</dt>
  <dd class="It-tag">Restore the contents of the clip buffer to the current
      sector buffer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">?</dt>
  <dd class="It-tag">Display a command summary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">A[from,to]</dt>
  <dd class="It-tag">Dump the contents of the sector buffer as ASCII. If
      <i>from</i> and <i>to</i> are included, then only values between those
      offsets will be shown.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">CHoffset,value,value,value...</dt>
  <dd class="It-tag">Change bytes in the current sector buffer. The offset and
      values are in hex.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">CAoffset,ascii</dt>
  <dd class="It-tag">Replace bytes in the current sector buffer with an ASCII
      string. As with the &quot;=&quot; command, the ASCII can contain embedded
      hex bytes in angle brackets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">CHfrom-to,value,value,value...</dt>
  <dd class="It-tag">The same as CH above, but fills the range from <i>from</i>
      to <i>to</i> with the byte sequence, repeating or truncating it as
      necessary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">CAfrom-to,ascii</dt>
  <dd class="It-tag">The same as CHfrom-to, except that the byte sequence is
      specified as ASCII.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">D[from,to]</dt>
  <dd class="It-tag">Dump the contents of the sector buffer as ASCII and
    hex.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Gxx</dt>
  <dd class="It-tag">Go to logical sector number <i>xx</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">H[from,to]</dt>
  <dd class="It-tag">Dump the contents of the sector buffer as hex.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Kfilename</dt>
  <dd class="It-tag">Save all &quot;yanked&quot; sectors (see Y below) to the
      specified file. This also clears them from memory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Lfilename[,type[,compression]]</dt>
  <dd class="It-tag">Open a new drive or disc image. If this has a different
      sector size from the current sector size, the sector buffer and clip
      buffer will be cleared.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">N[geometry]</dt>
  <dd class="It-tag">Change geometry. N by itself re-runs the automatic probe; N
      with the name of a geometry selects one of the formats known to
    LibDsk.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">R</dt>
  <dd class="It-tag">(Re)read the current sector.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Snn</dt>
  <dd class="It-tag">Set the current sector number, and read.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Tnn</dt>
  <dd class="It-tag">Set the current track number. Does not read.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">V</dt>
  <dd class="It-tag">Compare the contents of the sector buffer with the current
      sector on disc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">W</dt>
  <dd class="It-tag">Write the sector buffer to disc.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">X</dt>
  <dd class="It-tag">Leave dskutil.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Y</dt>
  <dd class="It-tag">Append the current sector to a &quot;yank&quot; buffer. It
      can then be saved with the K command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Z[nn]</dt>
  <dd class="It-tag">Sleep for <i>nn</i> seconds; if <i>nn</i> is not present,
      sleeps for one second.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">/nn</dt>
  <dd class="It-tag">This must be the last command on a line. It repeats the
      preceding line <i>nn</i> times.</dd>
</dl>
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
On platforms with no sleep(3) function, the Z command works by busy-waiting.
<div class="Pp"></div>
Commands are always input using fgets(3), even when the host system provides a
  more sophisticated input method such as readline(3).
<div class="Pp"></div>
While the current feature set is a fairly good match for DU90 (less the features
  specific to the CP/M filesystem) it doesn't cover all the features of LibDsk.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
John Elliott &lt;jce@seasip.demon.co.uk&gt;.</div>
<table class="foot">
  <tr>
    <td class="foot-date">23 January 2008</td>
    <td class="foot-os">Version 1.2.1</td>
  </tr>
</table>
</body>
</html>
