<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:35:39 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>r.in.lidar(1grass) Grass User&rsquo;s Manual
r.in.lidar(1grass)</p>

<p style="margin-top: 1em">NAME <br>
r.in.lidar - Creates a raster map from LAS LiDAR points
using univariate statistics.</p>

<p style="margin-top: 1em">KEYWORDS <br>
raster, import, LIDAR, statistics, conversion, aggregation,
binning</p>

<p style="margin-top: 1em">SYNOPSIS <br>
r.in.lidar <br>
r.in.lidar --help <br>
r.in.lidar [-penosgijdv] [input=name] output=name
[file=name] [method=string] [type=string] [base_raster=name]
[zrange=min,max] [zscale=float] [inten&acirc; <br>
sity_range=min,max] [intensity_scale=float]
[percent=integer] [pth=integer] [trim=float]
[resolution=float] [return_filter=string]
[class_filter=integer[,inte&acirc; <br>
ger,...]] [--overwrite] [--help] [--verbose] [--quiet]
[--ui]</p>

<p style="margin-top: 1em">Flags: <br>
-p <br>
Print LAS file info and exit</p>

<p style="margin-top: 1em">-e <br>
Use the extent of the input for the raster extent <br>
Set internally computational region extents based on the
point cloud</p>

<p style="margin-top: 1em">-n <br>
Set computation region to match the new raster map <br>
Set computation region to match the 2D extent and resolution
of the newly created new raster map</p>

<p style="margin-top: 1em">-o <br>
Override projection check (use current location&acirc;s
projection) <br>
Assume that the dataset has same projection as the current
location</p>

<p style="margin-top: 1em">-s <br>
Scan data file for extent then exit</p>

<p style="margin-top: 1em">-g <br>
In scan mode, print using shell script style</p>

<p style="margin-top: 1em">-i <br>
Use intensity values rather than Z values <br>
Uses intensity values everywhere as if they would be Z
coordinates</p>

<p style="margin-top: 1em">-j <br>
Use Z values for filtering, but intensity values for
statistics</p>

<p style="margin-top: 1em">-d <br>
Use base raster resolution instead of computational region
<br>
For getting values from base raster, use its actual
resolution instead of computational region resolution</p>

<p style="margin-top: 1em">-v <br>
Use only valid points <br>
Points invalid according to APSRS LAS specification will be
filtered out</p>

<p style="margin-top: 1em">--overwrite <br>
Allow output files to overwrite existing files</p>

<p style="margin-top: 1em">--help <br>
Print usage summary</p>

<p style="margin-top: 1em">--verbose <br>
Verbose module output</p>

<p style="margin-top: 1em">--quiet <br>
Quiet module output</p>

<p style="margin-top: 1em">--ui <br>
Force launching GUI dialog</p>

<p style="margin-top: 1em">Parameters: <br>
input=name <br>
LAS input file <br>
LiDAR input files in LAS format (*.las or *.laz)</p>

<p style="margin-top: 1em">output=name [required] <br>
Name for output raster map</p>

<p style="margin-top: 1em">file=name <br>
File containing names of LAS input files <br>
LiDAR input files in LAS format (*.las or *.laz)</p>

<p style="margin-top: 1em">method=string <br>
Statistic to use for raster values <br>
Options: n, min, max, range, sum, mean, stddev, variance,
coeff_var, median, percentile, skewness, trimmean <br>
Default: mean <br>
n: Number of points in cell <br>
min: Minimum value of point values in cell <br>
max: Maximum value of point values in cell <br>
range: Range of point values in cell <br>
sum: Sum of point values in cell <br>
mean: Mean (average) value of point values in cell <br>
stddev: Standard deviation of point values in cell <br>
variance: Variance of point values in cell <br>
coeff_var: Coefficient of variance of point values in cell
<br>
median: Median value of point values in cell <br>
percentile: pth (nth) percentile of point values in cell
<br>
skewness: Skewness of point values in cell <br>
trimmean: Trimmed mean of point values in cell</p>

<p style="margin-top: 1em">type=string <br>
Storage type for resultant raster map <br>
Options: CELL, FCELL, DCELL <br>
Default: FCELL</p>

<p style="margin-top: 1em">base_raster=name <br>
Subtract raster values from the Z coordinates <br>
The scale for Z is applied beforehand, the range filter for
Z afterwards</p>

<p style="margin-top: 1em">zrange=min,max <br>
Filter range for Z data (min,max)</p>

<p style="margin-top: 1em">zscale=float <br>
Scale to apply to Z data <br>
Default: 1.0</p>

<p style="margin-top: 1em">intensity_range=min,max <br>
Filter range for intensity values (min,max)</p>

<p style="margin-top: 1em">intensity_scale=float <br>
Scale to apply to intensity values <br>
Default: 1.0</p>

<p style="margin-top: 1em">percent=integer <br>
Percent of map to keep in memory <br>
Options: 1-100 <br>
Default: 100</p>

<p style="margin-top: 1em">pth=integer <br>
pth percentile of the values <br>
Options: 1-100</p>

<p style="margin-top: 1em">trim=float <br>
Discard given percentage of the smallest and largest values
<br>
Discard &lt;trim&gt; percent of the smallest and
&lt;trim&gt; percent of the largest observations <br>
Options: 0-50</p>

<p style="margin-top: 1em">resolution=float <br>
Output raster resolution</p>

<p style="margin-top: 1em">return_filter=string <br>
Only import points of selected return type <br>
If not specified, all points are imported <br>
Options: first, last, mid</p>


<p style="margin-top: 1em">class_filter=integer[,integer,...]
<br>
Only import points of selected class(es) <br>
Input is comma separated integers. If not specified, all
points are imported.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The r.in.lidar module loads LAS LiDAR point clouds into a
new raster map using binning. The user may choose from a
variety of statistical methods which will be used for
binning <br>
when creating the new raster.</p>

<p style="margin-top: 1em">Since a new raster map is
created during the binning, the binning of points depends on
the current computational region settings (extent and
resolution) by default (see more <br>
about binning below). When using the -e flag, the binning
will be done in the extent of the point cloud, so the
resulting raster will have extent based on the input point
cloud. <br>
When the resolution=value parameter is used, the binning is
done using the provided resolution and the resulting raster
will have that resolution (see more below for more
infor&acirc; <br>
mation about extent and resolution management).</p>

<p style="margin-top: 1em">r.in.lidar is designed for
processing massive point cloud datasets, for example raw
LiDAR or sidescan sonar swath data. It has been tested with
large datasets (see below for mem&acirc; <br>
ory management notes).</p>

<p style="margin-top: 1em">Binning <br>
The main different of r.in.lidar in comparison to r.in.lidar
is that r.in.lidar creates a raster instead of just
importing the points into GRASS GIS. However, r.in.lidar
does not <br>
merely rasterizes the points from the point cloud.
r.in.lidar uses binning to derive values for individual
raster cells, so the value of a cell is typically an
aggregation of <br>
values of individual points falling into one cell. In
general binning is the conversion of points into a regular
grid. The binning of points with X and Y coordinates starts
<br>
with the overlay of a grid of bins over the points.</p>

<p style="margin-top: 1em">In the basic case, binning is a
method which counts the number of points which fall into one
raster cell, i.e. bin. The number of points per cell (bin)
indicates the density of <br>
points in the point cloud. The cell (bin) is always square
or rectangular in case of r.in.lidar because the result is
GRASS GIS 2D raster. The result of binning where the
num&acirc; <br>
ber of point per cell is counted is sometimes called 2D (two
dimensional) histogram because a histogram is used in
univariate statistics (in one dimension) to count the number
<br>
samples falling into a given bin.</p>

<p style="margin-top: 1em">Figure: The binning on left was
used to count number of points per (sometimes also called 2D
histogram). The numbers in cells are examples of counts, the
rest is represented by <br>
the color. The binning on right was used with mean to create
a surface based on the values associated with the points.
The numbers show examples of cell values. Note also the <br>
cells without any points which were assigned the NULL value.
The basic concept of binning is extended when the points
have another value associated with them. For LiDAR data <br>
this value can be the Z coordinate or intensity. The value
for a given cell (bin) is computed using univariate
statistics from the values of all points in the cell. For
example, <br>
computing the mean value of Z coordinates can yield a raster
representing the digital elevation model. Another example is
the range of Z coordinates which can be used as a rough <br>
estimate of vegetation height.</p>

<p style="margin-top: 1em">Statistics <br>
Available statistics for populating the output raster map
are:</p>

<p style="margin-top: 1em">n <br>
This computes the number (count) of points per cell. The
result is a indicator of spatially variable density of
points in the given area.</p>

<p style="margin-top: 1em">min <br>
This finds the minimum of point values in each cell. It can
be useful when finding topography in a forested or urban
environment and there is a lot of points per one cells <br>
(terrain is oversampled considering the desired resolution).
It can also create surfaces independent on the noise from
premature hits as it will always select the lowest <br>
point.</p>

<p style="margin-top: 1em">max <br>
This finds the maximum of point values in each cell. In
connection with base_raster it can yield maximum vegetation
of feature height per cell. For this purpose, it is
usu&acirc; <br>
ally much more appropriate than mean which would yield
heights mostly influenced by the vertical distribution of
points.</p>

<p style="margin-top: 1em">range <br>
This computes the range of point values in each cell. The
range of Z coordinates per cell can be used as a rough
estimate of vegetation height when the cells are small <br>
enough, slopes low and the area is mostly vegetated.
However, for more profound analysis, the base raster
together with different statistics is recommended.</p>

<p style="margin-top: 1em">sum <br>
This computes the sum of point values per cell. This is
useful especially when intensity is used as a value (flags
-i and -j).</p>

<p style="margin-top: 1em">mean <br>
This is a mean (average) value of point values in cell. When
used with Z coordinates (the default) and points from the
ground class, the resulting raster is a digital eleva&acirc;
<br>
tion model. When intensity is used as a point value, the
resulting raster contains mean intensity per cell. Note that
mean gives heights influenced by the vertical distri&acirc;
<br>
bution of points</p>

<p style="margin-top: 1em">stddev <br>
This computes the standard deviation of point values for
each cell.</p>

<p style="margin-top: 1em">variance <br>
This computes the variance of point values for each cell.
Variance and derivatives use the biased estimator (n) [note
that this might be subject to change].</p>

<p style="margin-top: 1em">coeff_var <br>
This computes the coefficient of variance of point values
for each cell. Coefficient of variance is given in
percentage and defined as (stddev/mean)*100.</p>

<p style="margin-top: 1em">median <br>
This computes the median of point values for each cell</p>

<p style="margin-top: 1em">percentile <br>
pth (nth) percentile of points in cell</p>

<p style="margin-top: 1em">skewness <br>
This is a skewness of point values in cell</p>

<p style="margin-top: 1em">trimmean <br>
This is a trimmed mean of point values in cell. Trimmed mean
also know as truncated mean is a mean computed after
discarding values at the low end and at the high end. How
<br>
many values to discard is given by the trim option in
percent. In statistics the usual percentage of trimmed
values ranges from 5 to 25 percent. Note that different
statis&acirc; <br>
tics have different memory requirements (see below for
details).</p>

<p style="margin-top: 1em">Filtering <br>
Points falling outside the current computational region will
be skipped. This includes points falling exactly on the
southern region bound. To capture those adjust the region
<br>
with: <br>
g.region s=s-0.000001 <br>
See g.region for details about computation region handling
in GRASS GIS.</p>

<p style="margin-top: 1em">The zrange parameter may be used
for filtering the input data by vertical extent. Example
uses include filtering out extreme outliers and outliers on
relatively flat terrain. <br>
This parameter can be also used for cutting the point cloud
into vertical sections preparing it for further processing
by separate sections, together as if it would be an imagery
<br>
group (see i.group), or combined into a 3D raster using
r.to.rast3. In for these last examples, it might actually be
more advantageous to use r3.in.lidar module. The zrange <br>
parameter is especially powerful when used together with the
base_raster parameter. The zrange is applied to Z values
after the base_raster reduction.</p>

<p style="margin-top: 1em">Figure: This is the principle of
zrange filter. Points with the Z coordinate value below the
lower value in the range (here 180) are filtered out (blue
points) and same applies <br>
for points above higher value in the range (here 250). All
other points are preserved (green points).</p>

<p style="margin-top: 1em">A LiDAR pulse can have multiple
returns. The first return values can be used to obtain a
digital surface model (DSM) where e.g. canopy cover is
represented. The last return val&acirc; <br>
ues can be used to obtain a digital terrain model (DTM)
where e.g. the forest floor instead of canopy cover is
represented. The return_filter option allows selecting one
of <br>
first, mid, or last returns. Return number and number of
returns in the pulse associated with each point are compared
to determine if the point is first, mid, or last return.</p>

<p style="margin-top: 1em">LiDAR points often come as
already classified into standardized classes. For example,
class number 2 represents ground. For other classes see LAS
format specification in refer&acirc; <br>
ences. The class_filter option allows selecting one or more
classes using numbers (integers) separated by comma.</p>

<p style="margin-top: 1em">In varied terrain the user may
find that min maps make for a good noise filter as most
LIDAR noise is from premature hits. The min map may also be
useful to find the underlying <br>
topography in a forested or urban environment if the cells
are oversampled.</p>

<p style="margin-top: 1em">The user can use a combination
of r.in.lidar output maps to create custom raster-based
filters, for examplee, use r.mapcalc to create a
mean-(2*stddev) map. (In this example the <br>
user may want to include a lower bound filter in r.mapcalc
to remove highly variable points (small n) or run
r.neighbors to smooth the stddev map before further
use.)</p>

<p style="margin-top: 1em">Note that proper filtering of
the input points in not only critical for the analysis
itself but it can also speed up the processing.</p>

<p style="margin-top: 1em">Reduction to a base raster <br>
For analysis of features on the terrain surface, especially
vegetation it is advantageous to remove the influence of the
terrain on heights because the height above the terrain <br>
is important (e.g. height of a tree) rather than height of
the top of the tree above the see level. In this case, the
base raster would be digital elevation model which can be
<br>
one derived from the point cloud, or obtained in some other
way. LiDAR data often come with precomputed DEMs (quality
should be checked in this case) and there is often a DEM
<br>
available for a given area (fit with the point cloud,
especially vertical, and resolution should be checked).</p>

<p style="margin-top: 1em">Figure: This is a profile of
base raster (in orange) representing digital elevation model
and selected points, e.g. first return, from point cloud
(green dots). By default the <br>
points would create a digital surface model (thin brown
line) but after reducing the Z coordinates using the base
raster, the created surface is a derived from the height of
<br>
points relative to the base raster. The usage of base raster
is not limited to digital elevation model. The base raster
can be any surface which has some relation to the point <br>
values, for example digital surface model representing top
of the canopy.</p>

<p style="margin-top: 1em">Setting extent and resolution
<br>
Since the creation of raster maps depends on the
computational region settings (extent and resolution), as
default the current region extents and resolution are used
for the <br>
import. When using the -e flag along with the
resolution=value parameter, the region used for the new
raster will be based the point cloud extent and the provided
resolution. It <br>
is therefore recommended to first use the -s flag to get the
extents of the LiDAR point cloud to be imported, then adjust
the current region extent and resolution accordingly, <br>
and only then proceed with the actual import. Another option
is to automatically set the region extents based on the LAS
dataset itself (-e flag) along with the desired raster <br>
resolution. The best option is to know the point cloud
extent ahead, e.g. from tiling scheme, and use it. See below
for details.</p>

<p style="margin-top: 1em">Since the r.in.lidar generates a
raster map through binning from the original LiDAR points,
the target computational region extent and resolution have
to be determined. A typical <br>
workflow would involve the examination of the LAS
data&acirc;s associated documentation or the scan of the LAS
data file with r.in.lidar&acirc;s -s (or -g) flag to find
the input data&acirc;s <br>
bounds.</p>

<p style="margin-top: 1em">Another option is to
automatically set the region extents based on the LAS
dataset extent (-e flag) along with the desired raster
resolution using the resolution parameter.</p>

<p style="margin-top: 1em">Using the -s scan flag, the
extent of the input data (and thus point density) is
printed. To check this is recommended before performing the
full import. The -g shell style flag <br>
prints the extent suitable as command line parameters for
g.region.</p>

<p style="margin-top: 1em">A simpler option is to
automatically set the region extents based on the LAS
dataset (-e flag) along with the target raster resolution
using the resolution parameter. Also here <br>
it is recommended to verify and optimize the resulting
region settings with g.region prior to importing the
dataset.</p>

<p style="margin-top: 1em">NOTES <br>
Format and projection support <br>
The typical file extensions for the LAS format are .las and
.laz (compressed). The compressed LAS (.laz) format can be
imported only if libLAS has been compiled with LASzip
sup&acirc; <br>
port. It is also recommended to compile libLAS with GDAL
which is used to test if the LAS projection matches that of
the GRASS location.</p>

<p style="margin-top: 1em">LAS file import preparations
<br>
Note that the scanning (-s or -g flags) needs to iterate
over the whole point cloud. This will take a long time for
large datasets, so if the user knows the approximate extent
of <br>
the dataset, for example because it dataset for one county
or tiling scheme is available as vector polygons, it is much
more advantageous to provide the extent information <br>
instead of retrieving it from the dataset. The same applies
to the -e flag which also needs to perform scanning before
the binning begins.</p>

<p style="margin-top: 1em">Also note that the scanning does
not apply any filters, so the extent determined by scanning
can be theoretically bigger than the extent actively used
during the binning. This <br>
behavior ensures that the newly created raster has always
the same extent regardless the filters used. However, for
most cases (considering the point cloud and the resolution
<br>
used) there is no difference between the extent without
filters applied and the extent if the filters would be
applied.</p>

<p style="margin-top: 1em">Memory consumption <br>
While the input file can be arbitrarily large, r.in.lidar
will use a large amount of system memory (RAM) for large
raster regions (&gt; 10000x10000 pixels). If the module
refuses <br>
to start complaining that there isn&acirc;t enough memory,
use the percent parameter to run the module in several
passes. In addition using a less precise map format (CELL
[integer] <br>
or FCELL [floating point]) will use less memory than a DCELL
[double precision floating point] output map. For method=n,
the CELL format is used automatically.</p>

<p style="margin-top: 1em">The mean and range methods will
use average amount of memory (comparing to other methods).
Methods such as n, min, max, and sum will use less memory,
while stddev, variance, and <br>
coeff_var will use more.</p>

<p style="margin-top: 1em">The memory usage for regular
statistics mentioned above is based solely on region
(raster) size. However, the aggregate functions median,
percentile, skewness and trimmean will <br>
use more memory and may not be appropriate for use with
arbitrarily large input files without a small value for the
percent option because unlike the other statistics memory
use <br>
for these also depends on the number of data points.</p>

<p style="margin-top: 1em">The default map type=FCELL is
intended as compromise between preserving data precision and
limiting system resource consumption.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Simple example of binning of point from a LAS file into a
newly created raster map in an existing location/mapset
(using metric units): <br>
# set the computational region automatically, resol. for
binning is 5m <br>
r.in.lidar -e -o input=points.las resolution=5
output=lidar_dem_mean <br>
g.region raster=lidar_dem_mean -p <br>
r.univar lidar_dem_mean</p>

<p style="margin-top: 1em">Finding suitable extent and
resolution <br>
Using the -s scan flag, the extent of the input data (and
thus point density) is printed. To check this is recommended
before performing the full import. The -g shell style flag
<br>
prints the extent suitable as command line parameters for
g.region.</p>

<p style="margin-top: 1em">A simpler option is to
automatically set the region extents based on the LAS
dataset (-e flag) along with the target raster resolution
using the resolution parameter. Also here <br>
it is recommended to verify and optimize the resulting
region settings with g.region prior to importing the
dataset.</p>

<p style="margin-top: 1em">For the output raster map, a
suitable resolution can be found by dividing the number of
input points by the area covered (this requires an iterative
approach as outlined here): <br>
# print LAS metadata (Number of Points) <br>
r.in.lidar -p input=points.las <br>
# Number of Point Records: 1287775 <br>
# scan for LAS points cloud extent <br>
r.in.lidar -sg input=points.las output=dummy -o <br>
# n=2193507.740000 s=2190053.450000 e=6070237.920000
w=6066629.860000 b=-3.600000 t=906.000000 <br>
# set computation region to this extent <br>
g.region n=2193507.740000 s=2190053.450000 e=6070237.920000
w=6066629.860000 -p <br>
# print resulting extent <br>
g.region -p <br>
# rows: 3454 <br>
# cols: 3608 <br>
# points_per_cell = n_points / (rows * cols) <br>
# Here: 1287775 / (3454 * 3608) = 0.1033359 LiDAR
points/raster cell <br>
# As this is too low, we need to select a lower raster
resolution <br>
g.region res=5 -ap <br>
# rows: 692 <br>
# cols: 723 <br>
# Now: 1287775 / (692 * 723) = 2.573923 LiDAR points/raster
cell <br>
# import as mean <br>
r.in.lidar input=points.las output=lidar_dem_mean
method=mean -o <br>
# import as max <br>
r.in.lidar input=points.las output=lidar_dem_max method=max
-o <br>
# import as p&acirc;th percentile of the values <br>
r.in.lidar input=points.las output=lidar_dem_percentile_95
method=percentile pth=95 -o <br>
Mean value DEM in perspective view, imported from LAS
file</p>

<p style="margin-top: 1em">Further hints: how to calculate
number of LiDAR points/square meter: <br>
g.region -e <br>
# Metric location: <br>
# points_per_sq_m = n_points / (ns_extent * ew_extent) <br>
# Lat/Lon location: <br>
# points_per_sq_m = n_points / (ns_extent *
ew_extent*cos(lat) * (1852*60)^2)</p>

<p style="margin-top: 1em">Serpent Mound dataset <br>
This example is analogous to the example used in the GRASS
wiki page for importing LAS as raster DEM.</p>

<p style="margin-top: 1em">The sample LAS data are in the
file &quot;Serpent Mound Model LAS Data.las&quot;, available
at appliedimagery.com: <br>
# print LAS file info <br>
r.in.lidar -p input=&quot;Serpent Mound Model LAS
Data.las&quot; <br>
# using v.in.lidar to create a new location <br>
# create location with projection information of the LAS
data <br>
v.in.lidar -i input=&quot;Serpent Mound Model LAS
Data.las&quot; location=Serpent_Mound <br>
# quit and restart GRASS in the newly created location
&quot;Serpent_Mound&quot; <br>
# scan the extents of the LAS data <br>
r.in.lidar -sg input=&quot;Serpent Mound Model LAS
Data.las&quot; <br>
# set the region to the extents of the LAS data, align to
resolution <br>
g.region n=4323641.57 s=4320942.61 w=289020.90 e=290106.02
res=1 -ap <br>
# import as raster DEM <br>
r.in.lidar input=&quot;Serpent Mound Model LAS
Data.las&quot; output=Serpent_Mound_Model_LAS_Data
method=mean</p>

<p style="margin-top: 1em">Figure: Elevation for the whole
area of Serpent Mound dataset</p>

<p style="margin-top: 1em">Height above ground <br>
The mean height above ground of the points can be computed
for each raster cell (the ground elevation is given by the
raster map elevation): <br>
g.region raster=elevation -p <br>
r.in.lidar input=points.las output=mean_height_above_ground
base_raster=elevation method=mean <br>
In this type of computation, it might be advantageous to
change the resolution to match the precision of the points
rather than deriving it from the base raster.</p>

<p style="margin-top: 1em">Multiple file input <br>
The file option requres a file that contains a list of file
names with the full path. For example, a list of files in
the directory /home/user/data: <br>
points1.laz <br>
points2.laz <br>
points3.laz <br>
would be lised in the file as: <br>
/home/user/data/points1.laz <br>
/home/user/data/points2.laz <br>
/home/user/data/points3.laz <br>
On Linux and OSX, this file can be automatically generated
with the command: <br>
ls /home/user/data/*.laz &gt; /home/user/data/filelist.txt
<br>
On Windows: <br>
dir /b c:sersseratalaz &gt; c:sersseratalelist.txt <br>
The mean height above ground example above would then be:
<br>
g.region raster=elevation -p <br>
r.in.lidar file=/home/user/data/filelist.txt
output=mean_height_above_ground base_raster=elevation
method=mean <br>
In Python, the list of files can be created using the glob
Python module: <br>
import glob <br>
import gscript <br>
file_list_name = &acirc;/home/user/data/filelist.txt&acirc;
<br>
with open(, mode=&acirc;w&acirc;) as file_list: <br>
for path in
glob.iglob(&acirc;/home/user/data/lidar/*.las&acirc;): <br>
file_list.write(path + &quot;0) <br>
gscript.run_command(&acirc;r.in.lidar&acirc;,
file=file_list_name, <br>
output=&acirc;mean_height_above_ground&acirc;, <br>
base_raster=&acirc;elevation&acirc;
method=&acirc;mean&acirc;)</p>

<p style="margin-top: 1em">KNOWN ISSUES <br>
&Acirc;&middot; The &quot;nan&quot; value (as defined in C
language) can leak into coeff_var raster maps. Cause is
unknown. Possible work-around is: r.null setnull=nan or
r.mapcalc &acirc;no_nan = <br>
if(map == map, map, null())&acirc;.</p>

<p style="margin-top: 1em">&Acirc;&middot; Only one method
can be applied for a single run and multiple map output from
a single run (e.g. method=string[,string,...]
output=name[,name,...] or n=string <br>
mean=string) is no supported. <br>
If you encounter any problems (or solutions!) please contact
the GRASS Development Team.</p>

<p style="margin-top: 1em">SEE ALSO <br>
g.region, r.in.xyz, r.mapcalc, r.univar, v.in.lidar,
r3.in.lidar, v.vect.stats <br>
v.lidar.correction, v.lidar.edgedetection, v.lidar.growing,
v.outlier, v.surf.bspline <br>
Trimmed mean (Truncated mean, Wikipedia article),
OpenTopography (LiDAR point cloud repository)</p>

<p style="margin-top: 1em">REFERENCES <br>
&Acirc;&middot; V. Petras, A. Petrasova, J. Jeziorska, H.
Mitasova (2016): Processing UAV and lidar point clouds in
GRASS GIS. XXIII ISPRS Congress 2016 [ISPRS Archives,
ResearchGate]</p>

<p style="margin-top: 1em">&Acirc;&middot; ASPRS LAS
format</p>

<p style="margin-top: 1em">&Acirc;&middot; LAS library</p>

<p style="margin-top: 1em">&Acirc;&middot; LAS library C
API documentation</p>

<p style="margin-top: 1em">AUTHORS <br>
Markus Metz <br>
Vaclav Petras, NCSU GeoForAll Lab (base_raster option,
documentation) <br>
based on r.in.xyz by Hamish Bowman and Volker Wichmann</p>

<p style="margin-top: 1em">Last changed: $Date: 2016-08-22
04:16:33 +0200 (Mon, 22 Aug 2016) $</p>

<p style="margin-top: 1em">SOURCE CODE <br>
Available at: r.in.lidar source code (history)</p>

<p style="margin-top: 1em">Main index | Raster index |
Topics index | Keywords index | Graphical index | Full
index</p>

<p style="margin-top: 1em">&Acirc;&copy; 2003-2016 GRASS
Development Team, GRASS GIS 7.2.0 Reference Manual</p>

<p style="margin-top: 1em">GRASS 7.2.0
r.in.lidar(1grass)</p>
<hr>
</body>
</html>
