<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>r.in.lidar(1grass)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">r.in.lidar(1grass)</td>
    <td class="head-vol">Grass User's Manual</td>
    <td class="head-rtitle">r.in.lidar(1grass)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
<i></i><b>r.in.lidar</b> - Creates a raster map from LAS LiDAR points using
  univariate statistics.
<h1 class="Sh" title="Sh" id="KEYWORDS"><a class="selflink" href="#KEYWORDS">KEYWORDS</a></h1>
raster, import, LIDAR, statistics, conversion, aggregation, binning
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>r.in.lidar</b>
<div>&#x00A0;</div>
<b>r.in.lidar --help</b>
<div>&#x00A0;</div>
<b>r.in.lidar</b> [-<b>penosgijdv</b>] [<b>input</b>=<i>name</i>]
  <b>output</b>=<i>name</i> [<b>file</b>=<i>name</i>]
  [<b>method</b>=<i>string</i>] [ <b>type</b>=<i>string</i>]
  [<b>base_raster</b>= <i>name</i>] [<b>zrange</b>=<i>min,max</i>]
  [<b>zscale</b>= <i>float</i>] [<b>intensity_range</b>=<i>min,max</i>]
  [<b>intensity_scale</b>= <i>float</i>] [<b>percent</b>=<i>integer</i>]
  [<b>pth</b>= <i>integer</i>] [<b>trim</b>=<i>float</i>]
  [<b>resolution</b>=<i>float</i>] [ <b>return_filter</b>=<i>string</i>]
  [<b>class_filter</b>= <i>integer</i>[,<i>integer</i>,...]]
  [--<b>overwrite</b>] [-- <b>help</b>] [--<b>verbose</b>] [--<b>quiet</b>]
  [--<b>ui</b>]
<h2 class="Ss" title="Ss" id="Flags:"><a class="selflink" href="#Flags:">Flags:</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Print LAS file info and exit</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Use the extent of the input for the raster extent
    <div>&#x00A0;</div>
    Set internally computational region extents based on the point cloud</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Set computation region to match the new raster map
    <div>&#x00A0;</div>
    Set computation region to match the 2D extent and resolution of the newly
      created new raster map</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Override projection check (use current location&#x2019;s projection)
    <div>&#x00A0;</div>
    Assume that the dataset has same projection as the current location</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Scan data file for extent then exit</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    In scan mode, print using shell script style</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Use intensity values rather than Z values
    <div>&#x00A0;</div>
    Uses intensity values everywhere as if they would be Z coordinates</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-j</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Use Z values for filtering, but intensity values for statistics</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Use base raster resolution instead of computational region
    <div>&#x00A0;</div>
    For getting values from base raster, use its actual resolution instead of
      computational region resolution</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Use only valid points
    <div>&#x00A0;</div>
    Points invalid according to APSRS LAS specification will be filtered
    out</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--overwrite</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Allow output files to overwrite existing files</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Print usage summary</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--verbose</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Verbose module output</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quiet</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Quiet module output</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ui</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Force launching GUI dialog</dd>
</dl>
<h2 class="Ss" title="Ss" id="Parameters:"><a class="selflink" href="#Parameters:">Parameters:</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>input</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    LAS input file
    <div>&#x00A0;</div>
    LiDAR input files in LAS format (*.las or *.laz)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>output</b>=<i>name</i> <b>[required]</b></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Name for output raster map</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>file</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    File containing names of LAS input files
    <div>&#x00A0;</div>
    LiDAR input files in LAS format (*.las or *.laz)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>method</b>=<i>string</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Statistic to use for raster values
    <div>&#x00A0;</div>
    Options: <i>n, min, max, range, sum, mean, stddev, variance, coeff_var,
      median, percentile, skewness, trimmean</i>
    <div>&#x00A0;</div>
    Default: <i>mean</i>
    <div>&#x00A0;</div>
     <b>n</b>: Number of points in cell
    <div>&#x00A0;</div>
     <b>min</b>: Minimum value of point values in cell
    <div>&#x00A0;</div>
     <b>max</b>: Maximum value of point values in cell
    <div>&#x00A0;</div>
     <b>range</b>: Range of point values in cell
    <div>&#x00A0;</div>
     <b>sum</b>: Sum of point values in cell
    <div>&#x00A0;</div>
     <b>mean</b>: Mean (average) value of point values in cell
    <div>&#x00A0;</div>
     <b>stddev</b>: Standard deviation of point values in cell
    <div>&#x00A0;</div>
     <b>variance</b>: Variance of point values in cell
    <div>&#x00A0;</div>
     <b>coeff_var</b>: Coefficient of variance of point values in cell
    <div>&#x00A0;</div>
     <b>median</b>: Median value of point values in cell
    <div>&#x00A0;</div>
     <b>percentile</b>: pth (nth) percentile of point values in cell
    <div>&#x00A0;</div>
     <b>skewness</b>: Skewness of point values in cell
    <div>&#x00A0;</div>
     <b>trimmean</b>: Trimmed mean of point values in cell</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>type</b>=<i>string</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Storage type for resultant raster map
    <div>&#x00A0;</div>
    Options: <i>CELL, FCELL, DCELL</i>
    <div>&#x00A0;</div>
    Default: <i>FCELL</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>base_raster</b>=<i>name</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Subtract raster values from the Z coordinates
    <div>&#x00A0;</div>
    The scale for Z is applied beforehand, the range filter for Z
    afterwards</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zrange</b>=<i>min,max</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Filter range for Z data (min,max)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zscale</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Scale to apply to Z data
    <div>&#x00A0;</div>
    Default: <i>1.0</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>intensity_range</b>=<i>min,max</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Filter range for intensity values (min,max)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>intensity_scale</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Scale to apply to intensity values
    <div>&#x00A0;</div>
    Default: <i>1.0</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>percent</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Percent of map to keep in memory
    <div>&#x00A0;</div>
    Options: <i>1-100</i>
    <div>&#x00A0;</div>
    Default: <i>100</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pth</b>=<i>integer</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    pth percentile of the values
    <div>&#x00A0;</div>
    Options: <i>1-100</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>trim</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Discard given percentage of the smallest and largest values
    <div>&#x00A0;</div>
    Discard &lt;trim&gt; percent of the smallest and &lt;trim&gt; percent of the
      largest observations
    <div>&#x00A0;</div>
    Options: <i>0-50</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>resolution</b>=<i>float</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Output raster resolution</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>return_filter</b>=<i>string</i></dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Only import points of selected return type
    <div>&#x00A0;</div>
    If not specified, all points are imported
    <div>&#x00A0;</div>
    Options: <i>first, last, mid</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>class_filter</b>=<i>integer[,</i><i>integer</i>,...]</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    Only import points of selected class(es)
    <div>&#x00A0;</div>
    Input is comma separated integers. If not specified, all points are
      imported.</dd>
</dl>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <i>r.in.lidar</i> module loads LAS LiDAR point clouds into a new raster map
  using binning. The user may choose from a variety of statistical methods which
  will be used for binning when creating the new raster.
<div class="Pp"></div>
Since a new raster map is created during the binning, the binning of points
  depends on the current computational region settings (extent and resolution)
  by default (see more about binning below). When using the <b>-e</b> flag, the
  binning will be done in the extent of the point cloud, so the resulting raster
  will have extent based on the input point cloud. When the
  <i>resolution=value</i> parameter is used, the binning is done using the
  provided resolution and the resulting raster will have that resolution (see
  more below for more information about extent and resolution management).
<div class="Pp"></div>
<i>r.in.lidar</i> is designed for processing massive point cloud datasets, for
  example raw LiDAR or sidescan sonar swath data. It has been tested with large
  datasets (see below for memory management notes).
<h2 class="Ss" title="Ss" id="Binning"><a class="selflink" href="#Binning">Binning</a></h2>
The main different of <i>r.in.lidar</i> in comparison to <i>r.in.lidar</i> is
  that <i>r.in.lidar</i> creates a raster instead of just importing the points
  into GRASS GIS. However, <i>r.in.lidar</i> does not merely rasterizes the
  points from the point cloud. <i>r.in.lidar</i> uses binning to derive values
  for individual raster cells, so the value of a cell is typically an
  aggregation of values of individual points falling into one cell. In general
  binning is the conversion of points into a regular grid. The binning of points
  with X and Y coordinates starts with the overlay of a grid of bins over the
  points.
<div class="Pp"></div>
In the basic case, binning is a method which counts the number of points which
  fall into one raster cell, i.e. bin. The number of points per cell (bin)
  indicates the density of points in the point cloud. The cell (bin) is always
  square or rectangular in case of <i>r.in.lidar</i> because the result is GRASS
  GIS 2D raster. The result of binning where the number of point per cell is
  counted is sometimes called 2D (two dimensional) histogram because a histogram
  is used in univariate statistics (in one dimension) to count the number
  samples falling into a given bin.
<div class="Pp"></div>
<i></i> <i>Figure: The binning on left was used to count number of points
  per</i> <i>(sometimes also called 2D histogram). The numbers in cells are</i>
  <i>examples of counts, the rest is represented by the color.</i> <i>The
  binning on right was used with mean to create a surface</i> <i>based on the
  values associated with the points. The numbers</i> <i>show examples of cell
  values. Note also the cells without any points</i> <i>which were assigned the
  NULL value.</i> <i></i> The basic concept of binning is extended when the
  points have another value associated with them. For LiDAR data this value can
  be the Z coordinate or intensity. The value for a given cell (bin) is computed
  using univariate statistics from the values of all points in the cell. For
  example, computing the mean value of Z coordinates can yield a raster
  representing the digital elevation model. Another example is the range of Z
  coordinates which can be used as a rough estimate of vegetation height.
<h2 class="Ss" title="Ss" id="Statistics"><a class="selflink" href="#Statistics">Statistics</a></h2>
Available statistics for populating the output raster map are:
<dl class="Bl-tag">
  <dt class="It-tag">n</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This computes the number (count) of points per cell. The result is a
      indicator of spatially variable density of points in the given area.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">min</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This finds the minimum of point values in each cell. It can be useful when
      finding topography in a forested or urban environment and there is a lot
      of points per one cells (terrain is oversampled considering the desired
      resolution). It can also create surfaces independent on the noise from
      premature hits as it will always select the lowest point.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">max</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This finds the maximum of point values in each cell. In connection with
      <b>base_raster</b> it can yield maximum vegetation of feature height per
      cell. For this purpose, it is usually much more appropriate than
      <i>mean</i> which would yield heights mostly influenced by the vertical
      distribution of points.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">range</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This computes the range of point values in each cell. The range of Z
      coordinates per cell can be used as a rough estimate of vegetation height
      when the cells are small enough, slopes low and the area is mostly
      vegetated. However, for more profound analysis, the base raster together
      with different statistics is recommended.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">sum</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This computes the sum of point values per cell. This is useful especially
      when intensity is used as a value (flags <b>-i</b> and <b>-j</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">mean</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This is a mean (average) value of point values in cell. When used with Z
      coordinates (the default) and points from the ground class, the resulting
      raster is a digital elevation model. When intensity is used as a point
      value, the resulting raster contains mean intensity per cell. Note that
      <i>mean</i> gives heights influenced by the vertical distribution of
      points</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">stddev</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This computes the standard deviation of point values for each cell.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">variance</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This computes the variance of point values for each cell. Variance and
      derivatives use the biased estimator (n) [note that this might be subject
      to change].</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">coeff_var</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This computes the coefficient of variance of point values for each cell.
      Coefficient of variance is given in percentage and defined as
      (stddev/mean)*100.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">median</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This computes the median of point values for each cell</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">percentile</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    p <i>th</i> (nth) percentile of points in cell</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">skewness</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This is a skewness of point values in cell</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">trimmean</dt>
  <dd class="It-tag">
    <div>&#x00A0;</div>
    This is a trimmed mean of point values in cell. Trimmed mean also know as
      truncated mean is a mean computed after discarding values at the low end
      and at the high end. How many values to discard is given by the
      <b>trim</b> option in percent. In statistics the usual percentage of
      trimmed values ranges from 5 to 25 percent. Note that different statistics
      have different memory requirements (see below for details).</dd>
</dl>
<h2 class="Ss" title="Ss" id="Filtering"><a class="selflink" href="#Filtering">Filtering</a></h2>
Points falling outside the current computational region will be skipped. This
  includes points falling <i>exactly</i> on the southern region bound. To
  capture those adjust the region with:
<div>&#x00A0;</div>
<pre>
g.region s=s-0.000001
</pre>
See <i>g.region</i> for details about computation region handling in GRASS GIS.
<div class="Pp"></div>
The <b>zrange</b> parameter may be used for filtering the input data by vertical
  extent. Example uses include filtering out extreme outliers and outliers on
  relatively flat terrain. This parameter can be also used for cutting the point
  cloud into vertical sections preparing it for further processing by separate
  sections, together as if it would be an imagery group (see <i>i.group</i>), or
  combined into a 3D raster using <i>r.to.rast3</i>. In for these last examples,
  it might actually be more advantageous to use <i>r3.in.lidar</i> module. The
  <b>zrange</b> parameter is especially powerful when used together with the
  <b>base_raster</b> parameter. The <b>zrange</b> is applied to Z values after
  the <b>base_raster</b> reduction.
<div class="Pp"></div>
<i></i> <i>Figure: This is the principle of zrange filter. Points with the</i>
  <i>Z coordinate value below the lower value in the range (here 180)</i> <i>are
  filtered out (blue points) and same applies for points above</i> <i>higher
  value in the range (here 250). All other points are preserved</i> <i>(green
  points).</i> <i></i>
<div class="Pp"></div>
A LiDAR pulse can have multiple returns. The first return values can be used to
  obtain a digital surface model (DSM) where e.g. canopy cover is represented.
  The last return values can be used to obtain a digital terrain model (DTM)
  where e.g. the forest floor instead of canopy cover is represented. The
  <b>return_filter</b> option allows selecting one of first, mid, or last
  returns. Return number and number of returns in the pulse associated with each
  point are compared to determine if the point is first, mid, or last return.
<div class="Pp"></div>
LiDAR points often come as already classified into standardized classes. For
  example, class number 2 represents ground. For other classes see LAS format
  specification in references. The <b>class_filter</b> option allows selecting
  one or more classes using numbers (integers) separated by comma.
<div class="Pp"></div>
In varied terrain the user may find that <i>min</i> maps make for a good noise
  filter as most LIDAR noise is from premature hits. The <i>min</i> map may also
  be useful to find the underlying topography in a forested or urban environment
  if the cells are oversampled.
<div class="Pp"></div>
The user can use a combination of <i>r.in.lidar</i> <b>output</b> maps to create
  custom raster-based filters, for examplee, use <i>r.mapcalc</i> to create a
  mean-(2*stddev) map. (In this example the user may want to include a lower
  bound filter in <i>r.mapcalc</i> to remove highly variable points (small
  <i>n</i>) or run <i>r.neighbors</i> to smooth the stddev map before further
  use.)
<div class="Pp"></div>
Note that proper filtering of the input points in not only critical for the
  analysis itself but it can also speed up the processing.
<h2 class="Ss" title="Ss" id="Reduction_to_a_base_raster"><a class="selflink" href="#Reduction_to_a_base_raster">Reduction
  to a base raster</a></h2>
For analysis of features on the terrain surface, especially vegetation it is
  advantageous to remove the influence of the terrain on heights because the
  height above the terrain is important (e.g. height of a tree) rather than
  height of the top of the tree above the see level. In this case, the base
  raster would be digital elevation model which can be one derived from the
  point cloud, or obtained in some other way. LiDAR data often come with
  precomputed DEMs (quality should be checked in this case) and there is often a
  DEM available for a given area (fit with the point cloud, especially vertical,
  and resolution should be checked).
<div class="Pp"></div>
<i></i> <i>Figure: This is a profile of base raster (in orange) representing</i>
  <i>digital elevation model and selected points, e.g. first return,</i> <i>from
  point cloud (green dots). By default the points would create</i> <i>a digital
  surface model (thin brown line) but after reducing the</i> <i>Z coordinates
  using the base raster, the created surface is a</i> <i>derived from the height
  of points relative to the base raster.</i> <i></i> The usage of base raster is
  not limited to digital elevation model. The base raster can be any surface
  which has some relation to the point values, for example digital surface model
  representing top of the canopy.
<h2 class="Ss" title="Ss" id="Setting_extent_and_resolution"><a class="selflink" href="#Setting_extent_and_resolution">Setting
  extent and resolution</a></h2>
Since the creation of raster maps depends on the computational region settings
  (extent and resolution), as default the current region extents and resolution
  are used for the import. When using the <i>-e</i> flag along with the
  <i>resolution=value</i> parameter, the region used for the new raster will be
  based the point cloud extent and the provided resolution. It is therefore
  recommended to first use the <i>-s</i> flag to get the extents of the LiDAR
  point cloud to be imported, then adjust the current region extent and
  resolution accordingly, and only then proceed with the actual import. Another
  option is to automatically set the region extents based on the LAS dataset
  itself ( <i>-e</i> flag) along with the desired raster resolution. The best
  option is to know the point cloud extent ahead, e.g. from tiling scheme, and
  use it. See below for details.
<div class="Pp"></div>
Since the <i>r.in.lidar</i> generates a raster map through binning from the
  original LiDAR points, the target computational region extent and resolution
  have to be determined. A typical workflow would involve the examination of the
  LAS data&#x2019;s associated documentation or the scan of the LAS data file
  with <i>r.in.lidar</i>&#x2019;s <b>-s</b> (or <b>-g</b>) flag to find the
  input data&#x2019;s bounds.
<div class="Pp"></div>
Another option is to automatically set the region extents based on the LAS
  dataset extent ( <b>-e</b> flag) along with the desired raster resolution
  using the <i>resolution</i> parameter.
<div class="Pp"></div>
Using the <b>-s</b> scan flag, the extent of the input data (and thus point
  density) is printed. To check this is recommended before performing the full
  import. The <b>-g</b> shell style flag prints the extent suitable as command
  line parameters for <i>g.region</i>.
<div class="Pp"></div>
A simpler option is to automatically set the region extents based on the LAS
  dataset ( <b>-e</b> flag) along with the target raster resolution using the
  <i>resolution</i> parameter. Also here it is recommended to verify and
  optimize the resulting region settings with <i>g.region</i> prior to importing
  the dataset.
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
<h2 class="Ss" title="Ss" id="Format_and_projection_support"><a class="selflink" href="#Format_and_projection_support">Format
  and projection support</a></h2>
The typical file extensions for the LAS format are .las and .laz (compressed).
  The compressed LAS (.laz) format can be imported only if libLAS has been
  compiled with LASzip support. It is also recommended to compile libLAS with
  GDAL which is used to test if the LAS projection matches that of the GRASS
  location.
<h2 class="Ss" title="Ss" id="LAS_file_import_preparations"><a class="selflink" href="#LAS_file_import_preparations">LAS
  file import preparations</a></h2>
Note that the scanning ( <b>-s</b> or <b>-g</b> flags) needs to iterate over the
  whole point cloud. This will take a long time for large datasets, so if the
  user knows the approximate extent of the dataset, for example because it
  dataset for one county or tiling scheme is available as vector polygons, it is
  much more advantageous to provide the extent information instead of retrieving
  it from the dataset. The same applies to the <b>-e</b> flag which also needs
  to perform scanning before the binning begins.
<div class="Pp"></div>
Also note that the scanning does not apply any filters, so the extent determined
  by scanning can be theoretically bigger than the extent actively used during
  the binning. This behavior ensures that the newly created raster has always
  the same extent regardless the filters used. However, for most cases
  (considering the point cloud and the resolution used) there is no difference
  between the extent without filters applied and the extent if the filters would
  be applied.
<h2 class="Ss" title="Ss" id="Memory_consumption"><a class="selflink" href="#Memory_consumption">Memory
  consumption</a></h2>
While the <b>input</b> file can be arbitrarily large, <i>r.in.lidar</i> will use
  a large amount of system memory (RAM) for large raster regions (&gt;
  10000x10000 pixels). If the module refuses to start complaining that there
  isn&#x2019;t enough memory, use the <b>percent</b> parameter to run the module
  in several passes. In addition using a less precise map format (CELL [integer]
  or FCELL [floating point]) will use less memory than a DCELL [double precision
  floating point] <b>output</b> map. For <b>method</b>=<i>n</i>, the CELL format
  is used automatically.
<div class="Pp"></div>
The <i>mean</i> and <i>range</i> methods will use average amount of memory
  (comparing to other methods). Methods such as <i>n, min, max</i>, and
  <i>sum</i> will use less memory, while <i>stddev, variance</i>, and
  <i>coeff_var</i> will use more.
<div class="Pp"></div>
The memory usage for regular statistics mentioned above is based solely on
  region (raster) size. However, the aggregate functions <i>median, percentile,
  skewness</i> and <i>trimmean</i> will use more memory and may not be
  appropriate for use with arbitrarily large input files without a small value
  for the <b>percent</b> option because unlike the other statistics memory use
  for these also depends on the number of data points.
<div class="Pp"></div>
The default map <b>type</b>=FCELL is intended as compromise between preserving
  data precision and limiting system resource consumption.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
Simple example of binning of point from a LAS file into a newly created raster
  map in an existing location/mapset (using metric units):
<div>&#x00A0;</div>
<pre>
# set the computational region automatically, resol. for binning is 5m
r.in.lidar -e -o input=points.las resolution=5 output=lidar_dem_mean
g.region raster=lidar_dem_mean -p
r.univar lidar_dem_mean
</pre>
<h2 class="Ss" title="Ss" id="Finding_suitable_extent_and_resolution"><a class="selflink" href="#Finding_suitable_extent_and_resolution">Finding
  suitable extent and resolution</a></h2>
Using the <b>-s</b> scan flag, the extent of the input data (and thus point
  density) is printed. To check this is recommended before performing the full
  import. The <b>-g</b> shell style flag prints the extent suitable as command
  line parameters for <i>g.region</i>.
<div class="Pp"></div>
A simpler option is to automatically set the region extents based on the LAS
  dataset ( <b>-e</b> flag) along with the target raster resolution using the
  <i>resolution</i> parameter. Also here it is recommended to verify and
  optimize the resulting region settings with <i>g.region</i> prior to importing
  the dataset.
<div class="Pp"></div>
For the output raster map, a <b>suitable resolution</b> can be found by dividing
  the number of input points by the area covered (this requires an iterative
  approach as outlined here):
<div>&#x00A0;</div>
<pre>
# print LAS metadata (Number of Points)
r.in.lidar -p input=points.las
#   Number of Point Records: 1287775
# scan for LAS points cloud extent
r.in.lidar -sg input=points.las output=dummy -o
# n=2193507.740000 s=2190053.450000 e=6070237.920000 w=6066629.860000 b=-3.600000 t=906.000000
# set computation region to this extent
g.region n=2193507.740000 s=2190053.450000 e=6070237.920000 w=6066629.860000 -p
# print resulting extent
g.region -p
#  rows:       3454
#  cols:       3608
# points_per_cell = n_points / (rows * cols)
# Here: 1287775 / (3454 * 3608) = 0.1033359 LiDAR points/raster cell
# As this is too low, we need to select a lower raster resolution
g.region res=5 -ap
#  rows:       692
#  cols:       723
#  Now: 1287775 / (692 * 723) = 2.573923 LiDAR points/raster cell
# import as mean
r.in.lidar input=points.las output=lidar_dem_mean method=mean -o
# import as max
r.in.lidar input=points.las output=lidar_dem_max method=max -o
# import as p&#x2019;th percentile of the values
r.in.lidar input=points.las output=lidar_dem_percentile_95 \
           method=percentile pth=95 -o
</pre>
<div>&#x00A0;</div>
<i>Mean value DEM in perspective view, imported from LAS file</i>
<div class="Pp"></div>
Further hints: how to calculate number of LiDAR points/square meter:
<div>&#x00A0;</div>
<pre>
g.region -e
  # Metric location:
  # points_per_sq_m = n_points / (ns_extent * ew_extent)
  # Lat/Lon location:
  # points_per_sq_m = n_points / (ns_extent * ew_extent*cos(lat) * (1852*60)^2)
</pre>
<h2 class="Ss" title="Ss" id="Serpent_Mound_dataset"><a class="selflink" href="#Serpent_Mound_dataset">Serpent
  Mound dataset</a></h2>
This example is analogous to the example used in the GRASS wiki page for
  importing LAS as raster DEM.
<div class="Pp"></div>
The sample LAS data are in the file &quot;Serpent Mound Model LAS
  Data.las&quot;, available at appliedimagery.com:
<div>&#x00A0;</div>
<pre>
# print LAS file info
r.in.lidar -p input=&quot;Serpent Mound Model LAS Data.las&quot;
# using v.in.lidar to create a new location
# create location with projection information of the LAS data
v.in.lidar -i input=&quot;Serpent Mound Model LAS Data.las&quot; location=Serpent_Mound
# quit and restart GRASS in the newly created location &quot;Serpent_Mound&quot;
# scan the extents of the LAS data
r.in.lidar -sg input=&quot;Serpent Mound Model LAS Data.las&quot;
# set the region to the extents of the LAS data, align to resolution
g.region n=4323641.57 s=4320942.61 w=289020.90 e=290106.02 res=1 -ap
# import as raster DEM
r.in.lidar input=&quot;Serpent Mound Model LAS Data.las&quot; \
           output=Serpent_Mound_Model_LAS_Data method=mean
</pre>
<div class="Pp"></div>
<i>Figure: Elevation for the whole area of Serpent Mound dataset</i>
<h2 class="Ss" title="Ss" id="Height_above_ground"><a class="selflink" href="#Height_above_ground">Height
  above ground</a></h2>
The mean height above ground of the points can be computed for each raster cell
  (the ground elevation is given by the raster map elevation):
<div>&#x00A0;</div>
<pre>
g.region raster=elevation -p
r.in.lidar input=points.las output=mean_height_above_ground base_raster=elevation method=mean
</pre>
In this type of computation, it might be advantageous to change the resolution
  to match the precision of the points rather than deriving it from the base
  raster.
<h2 class="Ss" title="Ss" id="Multiple_file_input"><a class="selflink" href="#Multiple_file_input">Multiple
  file input</a></h2>
The file option requres a file that contains a list of file names with the full
  path. For example, a list of files in the directory /home/user/data:
<div>&#x00A0;</div>
<pre>
points1.laz
points2.laz
points3.laz
</pre>
would be lised in the file as:
<div>&#x00A0;</div>
<pre>
/home/user/data/points1.laz
/home/user/data/points2.laz
/home/user/data/points3.laz
</pre>
On Linux and OSX, this file can be automatically generated with the command:
<div>&#x00A0;</div>
<pre>
ls /home/user/data/*.laz &gt; /home/user/data/filelist.txt
</pre>
On Windows:
<div>&#x00A0;</div>
<pre>
dir /b c:\users\user\data\*.laz &gt; c:\users\user\data\filelist.txt
</pre>
The mean height above ground example above would then be:
<div>&#x00A0;</div>
<pre>
g.region raster=elevation -p
r.in.lidar file=/home/user/data/filelist.txt output=mean_height_above_ground base_raster=elevation method=mean
</pre>
In Python, the list of files can be created using the <i>glob</i> Python module:
<div>&#x00A0;</div>
<pre>
import glob
import gscript
file_list_name = &#x2019;/home/user/data/filelist.txt&#x2019;
with open(, mode=&#x2019;w&#x2019;) as file_list:
    for path in glob.iglob(&#x2019;/home/user/data/lidar/*.las&#x2019;):
        file_list.write(path + &quot;\n&quot;)
gscript.run_command(&#x2019;r.in.lidar&#x2019;, file=file_list_name,
                    output=&#x2019;mean_height_above_ground&#x2019;,
                    base_raster=&#x2019;elevation&#x2019; method=&#x2019;mean&#x2019;)
</pre>
<h1 class="Sh" title="Sh" id="KNOWN_ISSUES"><a class="selflink" href="#KNOWN_ISSUES">KNOWN
  ISSUES</a></h1>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">The &quot;nan&quot; value (as defined in C language) can
      leak into <i>coeff_var</i> raster maps. Cause is unknown. Possible
      work-around is: r.null setnull=nan or r.mapcalc &#x2019;no_nan = if(map ==
      map, map, null())&#x2019;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Only one method can be applied for a single run and
      multiple map output from a single run (e.g. method=string[,string,...]
      output=name[,name,...] or n=string mean=string) is no supported.</dd>
</dl>
</div>
If you encounter any problems (or solutions!) please contact the GRASS
  Development Team.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i></i> <i>g.region,</i> <i>r.in.xyz,</i> <i>r.mapcalc,</i> <i>r.univar,</i>
  <i>v.in.lidar,</i> <i>r3.in.lidar,</i> <i>v.vect.stats</i>
<div>&#x00A0;</div>
v.lidar.correction, v.lidar.edgedetection, v.lidar.growing, v.outlier,
  v.surf.bspline
<div>&#x00A0;</div>
Trimmed mean (Truncated mean, Wikipedia article), OpenTopography (LiDAR point
  cloud repository)
<h1 class="Sh" title="Sh" id="REFERENCES"><a class="selflink" href="#REFERENCES">REFERENCES</a></h1>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">V. Petras, A. Petrasova, J. Jeziorska, H. Mitasova (2016):
      <i>Processing UAV and lidar point clouds in GRASS GIS</i>. XXIII ISPRS
      Congress 2016 [ISPRS Archives, ResearchGate]</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">ASPRS LAS format</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LAS library</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">LAS library C API documentation</dd>
</dl>
</div>
<h1 class="Sh" title="Sh" id="AUTHORS"><a class="selflink" href="#AUTHORS">AUTHORS</a></h1>
Markus Metz
<div>&#x00A0;</div>
Vaclav Petras, NCSU GeoForAll Lab (base_raster option, documentation)
<div>&#x00A0;</div>
based on <i>r.in.xyz</i> by Hamish Bowman and Volker Wichmann
<div>&#x00A0;</div>
<div class="Pp"></div>
<i>Last changed: $Date: 2016-08-22 04:16:33 +0200 (Mon, 22 Aug 2016) $</i>
<h1 class="Sh" title="Sh" id="SOURCE_CODE"><a class="selflink" href="#SOURCE_CODE">SOURCE
  CODE</a></h1>
Available at: r.in.lidar source code (history)
<div class="Pp"></div>
Main index | Raster index | Topics index | Keywords index | Graphical index |
  Full index
<div class="Pp"></div>
&#x00A9; 2003-2016 GRASS Development Team, GRASS GIS 7.2.0 Reference
  Manual</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os">GRASS 7.2.0</td>
  </tr>
</table>
</body>
</html>
