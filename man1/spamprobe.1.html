<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>spamprobe(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">spamprobe(1)</td>
    <td class="head-vol">SpamProbe</td>
    <td class="head-rtitle">spamprobe(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
spamprobe - a bayesian spam filter
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>spamprobe</b> [options] &lt;command&gt; [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="INTRODUCTION"><a class="selflink" href="#INTRODUCTION">INTRODUCTION</a></h1>
SpamProbe can be used in conjunction with procmail or similar program to filter
  email. SpamProbe uses a statistical algorithm to identify the key words and
  phrases in email and determine which emails are legitimate and which are spam.
  The algorithm used by SpamProbe is based on an excellent article by Paul
  Graham. He describes the basic idea and his results. You can read his article
  here:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 http://www.paulgraham.com/spam.html
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="COMMAND_LINE_USAGE"><a class="selflink" href="#COMMAND_LINE_USAGE">COMMAND
  LINE USAGE</a></h1>
SpamProbe accepts a small set of commands and a growing set of options on the
  command line in addition to zero or more file names of mboxes. The general
  usage is:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe [options] &lt;command&gt; [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
The recognized options are:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -a char
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 By default SpamProbe converts non-ascii characters (characters
<br/>
 with the most significant bit set to 1) into the letter 'z'. This
<br/>
 is useful for lumping all Asian characters into a single word for
<br/>
 easy recognition. The -a option allows you to change the
<br/>
 character to something else if you don't like the letter 'z' for
<br/>
 some reason.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -c
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Tells spamprobe to create the database directory if it does not
<br/>
 already exist. Normally spamprobe exits with a usage error if
<br/>
 the database directory does not already exist.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -C number
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Tells SpamProbe to assign a default, somewhat neutral, probability
<br/>
 to any term that does not have a weighted (good count doubled)
<br/>
 count of at least number in the database. This prevents terms
<br/>
 which have been seen only a few times from having an unreasonable
<br/>
 influence on the score of an email containing them.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 The default value is 5. For example if number is 5 then in order
<br/>
 for a term to use its calculated probability it must have been
<br/>
 seen 3 times in good mails, or 2 times in good mails and once in
<br/>
 spam, or 5 times in spam, or some other combination adding up to
<br/>
 at least 5.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -d directory
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 By default SpamProbe stores its database in a directory named
<br/>
 .spamprobe under your home directory. The -d option allows you to
<br/>
 specify a different directory to use. This is necessary if your
<br/>
 home directory is NFS mounted for example.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 The directory name can be prefixed with a special code to force
<br/>
 SpamProbe to use a particular type of data file format. The type
<br/>
 codes depend on how your copy of SpamProbe was compiled. Defined
<br/>
 types include:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Example Description
<br/>
 -d pbl:path Forces the use of PBL data file.
<br/>
 -d hash:path Forces the use of an mmapped hash file.
<br/>
 -d split:path Forces the use of a hash file and ISAM
<br/>
 file (may provide better precision than
<br/>
 plain hash in some cases).
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 The hash: option can also specify a desired file size in megabytes
<br/>
 before the path. For example -d hash:19:path would cause
<br/>
 SpamProbe to use a 19 MB hash file. The size must be in the range
<br/>
 of 1-100. The default hash file size is 16 MB. Because hash
<br/>
 files have a fixed size and capacity they should be cleaned
<br/>
 relatively often using the cleanup command (see below) to prevent
<br/>
 them from becoming full or being slowed by too many hash key
<br/>
 collisions.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Hash files provide better performance than either of the ISAM
<br/>
 options (PBL or Berkeley DB). However hash files do not store the
<br/>
 original terms. Only a 32 bit hash key is stored with each term.
<br/>
 This prevents a user from exploring the terms in the database
<br/>
 using the dump command to see what words are particularly spammy
<br/>
 or hammy.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -D directory
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Tells SpamProbe to use the database in the specified directory
<br/>
 (must be different than the one specified with the -d option) as a
<br/>
 shared database from which to draw terms that are not defined in
<br/>
 the user's own database. This can be used to provide a baseline
<br/>
 database shared by all users on a system (in the -D directory) and
<br/>
 a private database unique to each user of the system
<br/>
 ($HOME/.spamprobe or -d directory).
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -g field_name
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Tells SpamProbe what header to look for previous score and message
<br/>
 digest in. Default is X-SpamProbe. Field name is not case
<br/>
 sensitive. Used by all commands except receive.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -h
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 By default SpamProbe removes HTML markup from the text in emails
<br/>
 to help avoid false positives. The -h option allows you to
<br/>
 override this behavior and force SpamProbe to include words from
<br/>
 within HTML tags in its word counts. Note that SpamProbe always
<br/>
 counts any URLs in hrefs within tags whether -h is used or not.
<br/>
 Use of this option is discouraged. It can increase the rate of
<br/>
 spam detection slightly but unless the user receives a significant
<br/>
 amount of HTML emails it also tends to increase the number of
<br/>
 false positives.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -H option
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 By default SpamProbe only scans a meaningful subset of headers
<br/>
 from the email message when searching for words to score. The -H
<br/>
 option allows the user to specify additional headers to scan.
<br/>
 Legal values are &quot;all&quot;, &quot;nox&quot;, &quot;none&quot;, or
  &quot;normal&quot;. &quot;all&quot; scans
<br/>
 all headers, &quot;nox&quot; scans all headers except those starting with
<br/>
 X-, &quot;none&quot; does not scan headers, and &quot;normal&quot; scans the
  normal
<br/>
 set of headers.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 In addition to those values you can also explicitly add a header
<br/>
 to the list of headers to process by adding the header name in
<br/>
 lower case preceded by a plus sign. Multiple headers can be
<br/>
 specified by using multiple -H options. For example, to include
<br/>
 only the From and Received headers in your train command you could
<br/>
 run spamprobe as follows:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe -Hnone -H+from -H+received train
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 You can also selectively ignore headers that would otherwise be
<br/>
 processed by using -H-headername. For example to process all
<br/>
 headers except for Subject you could run spamprobe as follows:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe -Hall -H-subject train
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 To process the normal set of headers but also add the SpamAssassin
<br/>
 header X-SpamStatus you could run spamprobe as follows:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe -H+x-spam-status train
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -l number
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Changes the spam probability threshold for emails from the default
<br/>
 (0.7) to number. The number must be a between 0 and 1. Generally
<br/>
 the value should be above 0.5 to avoid a high false positive rate.
<br/>
 Lower numbers tend to produce more false positives while higher
<br/>
 numbers tend to reduce accuracy.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -m
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Forces SpamProbe to use mbox format for reading emails in receive
<br/>
 mode. Normally SpamProbe assumes that the input to receive mode
<br/>
 contains a single message so it doesn't look for message breaks.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -M
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Forces SpamProbe to treat the entire input as a single message.
<br/>
 This ignores From lines and Content-Length headers in the input.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -o option_name
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Enables special options by name. Currently the only special
<br/>
 options are:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -o graham
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Causes SpamProbe to emulate the filtering algorithm originally
<br/>
 outlined in A Plan For Spam.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -o honor-status-header
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Causes SpamProbe to ignore messages if they have a Status:
<br/>
 header containing a capital D. Some mail servers use this
<br/>
 status to indicate a message that has been flagged for
<br/>
 deletion but has not yet been purged from the file.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 DO NOT use this option with the receive or train command in
<br/>
 your procmailrc file! Doing so could allow spammers to bypass
<br/>
 the filter. This option is meant to be used with the
<br/>
 train-spam and train-good commands in scripts that
<br/>
 periodically update the database.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -o honor-xstatus-header
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Causes SpamProbe to ignore messages if they have a X-Status:
<br/>
 header containing a capital D. Some mail servers use this
<br/>
 status to indicate a message that has been flagged for
<br/>
 deletion but has not yet been purged from the file.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 DO NOT use this option with the receive or train command in
<br/>
 your procmailrc file! Doing so could allow spammers to bypass
<br/>
 the filter. This option is meant to be used with the
<br/>
 train-spam and train-good commands in scripts that
<br/>
 periodically update the database.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -o ignore-body
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Causes SpamProbe to ignore terms from the message body when
<br/>
 computing a score. This is not normally recommended but might
<br/>
 be useful in conjunction with some other filter. For example,
<br/>
 the whitelist option (see below) implicitly ignores the
<br/>
 message body.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -o orig-score
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Causes SpamProbe to use its original scoring algorithm that
<br/>
 produces excellent results but tends to generate scores of
<br/>
 either 0 or 1 for all messages.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -o suspicious-tags
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Causes SpamProbe to scan the contents of &quot;suspicious&quot; tags for
<br/>
 tokens rather than simply throwing them out. Currently only
<br/>
 font tags are scanned but other tags may be added to this list
<br/>
 in later versions.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -o tokenized
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Causes SpamProbe to read tokens one per line rather than
<br/>
 processing the input as mbox format. This allows users to
<br/>
 completely replace the standard spamprobe tokenizer if they
<br/>
 wish and instead use some external program as a tokenizer.
<br/>
 For example in your procmailrc file you could use:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 SCORE=| tokenize.pl | /bin/spamprobe -o tokenized train
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 In this mode SpamProbe considers a blank line to indicate the
<br/>
 end of one message's tokens and the start of a new message's
<br/>
 tokens. SpamProbe computes a message digest based on the
<br/>
 lines of text containing the tokens.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -o whitelist
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Causes SpamProbe to use information from the email's headers
<br/>
 to identify whether or not the email is from a legitimate
<br/>
 correspondent. The message body is ignored as are any never
<br/>
 before seen terms and phrases in the headers. This option can
<br/>
 be used with the score command in a procmailrc file to use a
<br/>
 bayesian white list in conjunction with some other filter or
<br/>
 rule external to SpamProbe.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 The -o option can be used multiple times and all requested options
<br/>
 will be applied. Note that some options might conflict with each
<br/>
 other in which case the last option would take precedence.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -p number
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Changes the maximum number of words per phrase. Default value is
<br/>
 two. Increasing the limit improves accuracy somewhat but
<br/>
 increases database size. Experiments indicate that increasing
<br/>
 beyond two is not worth the extra cost in space.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -P number
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Causes spamprobe to perform a purge of all terms with junk count
<br/>
 less than or equal 2 after every number messages are processed.
<br/>
 Using this option when classifying a large collection of spam can
<br/>
 prevent the database from growing overly large at the cost of more
<br/>
 processing time and possible loss of precision.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -r number
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Changes the number of times that a single word/phrase can occur
<br/>
 in the top words array used to calculate the score for each
<br/>
 message. Allowing repeats reduces the number of words overall
<br/>
 (since a single word occupies more than one slot) but allows words
<br/>
 which occur frequently in the message to have a higher weight.
<br/>
 Generally this is changed only for optimization purposes.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -R
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Causes spamprobe to treat the input as a single message and to
<br/>
 base its exit code on whether or not that message was spam. The
<br/>
 exit code will be 0 if the message was spam or 1 if the message
<br/>
 was good.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -s number
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 SpamProbe maintains an in memory cache of the words it has seen in
<br/>
 previous messages to reduce disk I/O and improve performance. By
<br/>
 default the cache will contain the most recently accessed 2,500
<br/>
 terms. This number can be changed using the -s option. Using a
<br/>
 larger the cache size will cause SpamProbe to use more memory and,
<br/>
 potentially, to perform less database I/O.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 A value of zero causes SpamProbe to use 100,000 as the limit which
<br/>
 effectively means that the cache will only be flushed at program
<br/>
 exit (unless you have really enormous mailbox files). The cache
<br/>
 doesn't affect receive, dump, or export but has a significant
<br/>
 impact on the others.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -T
<br/>
 Causes SpamProbe to write out the top terms associated with each
<br/>
 message in addition to its normal output. Works with find-good,
<br/>
 find-spam, and score.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -v
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Tells SpamProbe to write debugging information to stderr. This
<br/>
 can be useful for debugging or for seeing which terms SpamProbe
<br/>
 used to score each email.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -V
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Prints version and copyright information and then exits.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -w number
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Changes the number of most significant words/phrases used by
<br/>
 SpamProbe to calculate the score for each message. Generally this
<br/>
 is changed only for optimization purposes.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -x
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Normally SpamProbe uses only a fixed number of top terms (as set
<br/>
 by the -w command line option) when scoring emails. The -x option
<br/>
 can be used to allow the array to be extended past the max size if
<br/>
 more terms are available with probabilities &lt;= 0.1 or &gt;= 0.9.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -X
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 An interesting variation on the scoring settings. Equivalent to
<br/>
 using &quot;-w5 -r5 -x&quot; so that generally only words with probabilites
<br/>
 &lt;= 0.1 or &gt;= 0.9 are used and word frequencies in the email count
<br/>
 heavily towards the score. Tests have shown that this setting
<br/>
 tends to be safer (fewer false positives) and have higher recall
<br/>
 (proper classification of spams previously scored as spam)
<br/>
 although its predictive power isn't quite as good as the default
<br/>
 settings. WARNING: This setting might work best with a fairly
<br/>
 large corpus, it has not been tested with a small corpus so it
<br/>
 might be very inaccurate with fewer than 1000 total messages.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -Y
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Assume traditional Berkeley mailbox format, ignoring any
<br/>
 Content-Length: fields.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -7
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Tells SpamProbe to ignore any characters with the most significant
<br/>
 bit set to 1 instead of mapping them to the letter 'z'.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 -8
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Tells SpamProbe to store all characters even if their most
<br/>
 significant bit is set to 1.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
SpamProbe recognizes the following commands:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe help [command]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 With no arguments spamprobe lists all of the valid commands.
<br/>
 If one or more commands are specified after the word help,
<br/>
 spamprobe will print a more verbose description of each command.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe create-db
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 If no database currently exists spamprobe will attempt to create
<br/>
 one and then exit. This can be used to bootstrap a new
<br/>
 installation. Strictly speaking this command is not necessary
<br/>
 since the train-spam, train-good, and auto-train commands will also
<br/>
 create a database if none already exists but some users like to
<br/>
 create a database as a separate installation step.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe create-config
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Writes a new configuration file named spamprobe.hdl into the
<br/>
 database directory (normally $HOME/.spamprobe). Any existing
<br/>
 configuration file will be overwritten so be sure to make a copy
<br/>
 before invoking this command.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe receive [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Tells SpamProbe to read its standard input (or a file specified
<br/>
 after the receive command) and score it using the current
<br/>
 databases. Once the message has been scored the message is
<br/>
 classified as either spam or non-spam and its word counts are
<br/>
 written to the appropriate database. The message's score is
<br/>
 written to stdout along with a single word. For example:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 SPAM 0.9999999 595f0150587edd7b395691964069d7af
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 or
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 GOOD 0.0200000 595f0150587edd7b395691964069d7af
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 The string of numbers and letters after the score is the message's
<br/>
 &quot;digest&quot;, a 32 character number which uniquely identifies the
<br/>
 message. The digest is used by SpamProbe to recognize messages
<br/>
 that it has processed previously so that it can keep its word
<br/>
 counts consistent if the message is reclassified.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Using the -T option additionally lists the terms used to produce
<br/>
 the score along with their counts (number of times they were found
<br/>
 in the message).
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe train [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Functionally identical to receive except that the database is only
<br/>
 modified if the message was &quot;difficult&quot; to classify. In practice
<br/>
 this can reduce the number of database updates to as little as 10%
<br/>
 of messages received.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe score [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Similar to receive except that the database is not modified in
<br/>
 any way.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe summarize [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Similar to score except that it prints a short summary and score
<br/>
 for each message. This can be useful when testing. Using the -T
<br/>
 option additionally lists the terms used to produce the score along
<br/>
 with their counts (number of times they were found in the message).
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe find-spam [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Similar to score except that it prints a short summary and score
<br/>
 for each message that is determined to be spam. This can be useful
<br/>
 when testing. Using the -T option additionally lists the terms
<br/>
 used to produce the score along with their counts (number of times
<br/>
 they were found in the message).
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe find-good [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Similar to score except that it prints a short summary and score
<br/>
 for each message that is determined to be good. This can be useful
<br/>
 when testing. Using the -T option additionally lists the terms
<br/>
 used to produce the score along with their counts (number of times
<br/>
 they were found in the message).
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe auto-train {SPAM|GOOD filename...}...
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Attempts to efficiently build a database from all of the named
<br/>
 files. You may specify one or more file of each type. Prior to
<br/>
 each set of file names you must include the word SPAM or GOOD to
<br/>
 indicate what type of mail is contained in the files which follow
<br/>
 on the command line.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 The case of the SPAM and GOOD keywords is important. Any number of
<br/>
 file names can be specified between the keywords. The command line
<br/>
 format is very flexible. You can even use a find command in
<br/>
 backticks to process whole directory trees of files. For example:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe auto-train SPAM spams/* GOOD `find hams -type f`
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 SpamProbe pre-scans the files to determine how many emails of each
<br/>
 type exist and then trains on hams and spams in a random sequence
<br/>
 that balances the inflow of each type so that the train command can
<br/>
 work most effectively. For example if you had 400 hams and 400
<br/>
 spams, auto-train will generally process one spam, then one ham,
<br/>
 etc. If you had 4000 spams and 400 hams then auto-train will
<br/>
 generally process 10 spams, then one ham, etc.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Since this command will likely take a long time to run it is often
<br/>
 desireable to use it with the -v option to see progress information
<br/>
 as the messages are processed.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe -v auto-train SPAM spams/* GOOD hams/*
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe good [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Scans each file (or stdin if no file is specified) and reclassifies
<br/>
 every email in the file as non-spam. The databases are updated
<br/>
 appropriately. Messages previously classified as good (recognized
<br/>
 using their MD5 digest or message ids) are ignored. Messages
<br/>
 previously classified as spam are reclassified as good.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe train-good [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Functionally identical to &quot;good&quot; command except that it only
<br/>
 updates the database for messages that are either incorrectly
<br/>
 classified (i.e. classified as spam) or are &quot;difficult&quot; to
<br/>
 classify. In practice this can reduce amount of database updates
<br/>
 to as little as 10% of messages.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe spam [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Scans each file (or stdin if no file is specified) and reclassifies
<br/>
 every email in the file as spam. The databases are updated
<br/>
 appropriately. Messages previously classified as spam (recognized
<br/>
 using their MD5 digest of message ids) are ignored. Messages
<br/>
 previously classified as good are reclassified as spam.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe train-spam [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Functionally identical to &quot;spam&quot; command except that it only
<br/>
 updates the database for messages that are either incorrectly
<br/>
 classified (i.e. classified as good) or are &quot;difficult&quot; to
<br/>
 classify. In practice this can reduce amount of database updates
<br/>
 to as little as 10% of messages.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe remove [filename...]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Scans each file (or stdin if no file is specified) and removes its
<br/>
 term counts from the database. Messages which are not in the
<br/>
 database (recognized using their MD5 digest of message ids) are
<br/>
 ignored.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe cleanup [ junk_count [ max_age ] ]...
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Scans the database and removes all terms with junk_count or less
<br/>
 (default 2) which have not had their counts modified in at least
<br/>
 max_age days (default 7). You can specify multiple count/age pairs
<br/>
 on a single command line but must specify both a count and an age
<br/>
 for all but the last count. This should be run periodically to
<br/>
 keep the database from growing endlessly.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 For my own email I use cron to run the cleanup command every day
<br/>
 and delete all terms with count of 2 or less that have not been
<br/>
 modified in the last two weeks. Here is the excerpt from my
<br/>
 crontab:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 3 0 * * * /home/brian/bin/spamprobe cleanup 2 14
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Alternatively you might want to use a much higher count (1000 in
<br/>
 this example) for terms that have not been seen in roughly six
<br/>
 months:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 3 0 * * * /home/brian/bin/spamprobe cleanup 1000 180 2 14
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Because of the way that PBL and BerkeleyDB work the database file
<br/>
 will not actually shrink, but newly added terms will be able to use
<br/>
 the space previously occupied by any removed terms so that the
<br/>
 file's growth should be significantly slower if this command is
<br/>
 used.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 To actually shrink the database you can build a new one using the
<br/>
 BerkeleyDB utility programs db_dump and db_load (Berkeley DB only)
<br/>
 or the spamprobe import and export commands (either database
<br/>
 library). For example:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 cd ~
<br/>
 mkdir new.spamprobe
<br/>
 spamprobe export | spamprobe -d new.spamprobe import
<br/>
 mv .spamprobe old.spamprobe
<br/>
 mv new.spamprobe .spamprobe
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 The -P option can also be used to limit the rate of growth of the
<br/>
 database when importing a large number of emails. For example if
<br/>
 you want to classify 1000 emails and want SP to purge rare terms
<br/>
 every 100 messages use a command such as:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe -P 100 good goodmailboxname
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Using -P slows down the classification but can avoid the need to
<br/>
 use the db_dump trick. Using -P only makes sense when classifying
<br/>
 a large number of messages.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe purge [ junk_count ]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Similar to cleanup but forces the immediate deletion of all terms
<br/>
 with total count less than junk_count (default is 2) no matter how
<br/>
 long it has been since they were modified (i.e. even if they were
<br/>
 just added today). This could be handy immediately after
<br/>
 classifying a large mailbox of historical spam or good email to
<br/>
 make room for the next batch.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe purge-terms regex
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Similar to purge except that it removes from the database all terms
<br/>
 which match the specified regular expression. Be careful with this
<br/>
 command because it could remove many more terms than you expect.
<br/>
 Use dump with the same regex before running this command to see
<br/>
 exactly what will be deleted.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe edit-term term good_count spam_count
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Can be used to specifically set the good and spam counts of a term.
<br/>
 Whether this is truly useful is doubtful but it is provided for
<br/>
 completeness sake. For example it could be used to force a
<br/>
 particular word to be very spammy or very good:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe edit-term nigeria 0 1000000
<br/>
 spamprobe edit-term burton 10000000 0
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe dump [ regex ]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Prints the contents of the word counts database one word per line
<br/>
 in human readable format with spam probability, good count, spam
<br/>
 count, flags, and word in columns separated by whitespace. PBL and
<br/>
 Berkeley DB sort terms alphabetically. The standard unix sort
<br/>
 command can be used to sort the terms as desired. For example to
<br/>
 list all words from &quot;most good&quot; to &quot;least good&quot; use this
  command:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe dump | sort -k 1n -k 2nr
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 To list all words from &quot;most spammy&quot; to &quot;least spammy&quot; use
  this
<br/>
 command:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe dump | sort -k 1nr -k 3nr
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Optionally you can specify a regular expression. If specified
<br/>
 SpamProbe will only dump terms matching the regular expression.
<br/>
 For example:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe dump 'finance'
<br/>
 spamprobe dump '
<br/>
 spamprobe dump 'HSubject_.*finance'
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe tokenize [ filename ]
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Prints the tokens found in the file one word per line in human
<br/>
 readable format with spam probability, good count, spam count,
<br/>
 message count, and word in columns separated by whitespace. Terms
<br/>
 are listed in the order in which they were encountered in the
<br/>
 message. The standard unix sort command can be used to sort the
<br/>
 terms as desired. For example to list all words from &quot;most good&quot;
<br/>
 to &quot;least good&quot; use this command:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe tokenize filename | sort -k 1n -k 2nr
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 To list all words from &quot;most spammy&quot; to &quot;least spammy&quot; use
  this
<br/>
 command:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe tokenize filename | sort -k 1nr -k 3nr
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe export
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Similar to the dump command but prints the counts and words in a
<br/>
 comma separated format with the words surrounded by double quotes.
<br/>
 This can be more useful for importing into some databases.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe import
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Reads the specified files which must contain export data written by
<br/>
 the export command. The terms and counts from this file are added
<br/>
 to the database. This can be used to convert a database from a
<br/>
 prior version.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe exec command
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Obtains an exclusive lock on the database and then executes the
<br/>
 command using system(3). If multiple arguments are given after
<br/>
 &quot;exec&quot; they are combined to form the command to be executed. This
<br/>
 command can be used when you want to perform some operation on the
<br/>
 database without interference from incoming mail. For example, to
<br/>
 back up your .spamprobe directory using tar you could do something
<br/>
 like this:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 cd
<br/>
 spamprobe exec tar cf spamprobe-data.tar.gz .spamprobe
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 If you simply want to hold the lock while interactively running
<br/>
 commands in a different xterm you could use &quot;spamprobe exec read&quot;.
<br/>
 The linux read program simply reads a line of text from your
<br/>
 terminal so the lock would effectively be held until you pressed
<br/>
 the enter key. Another option would be to use a shell as the
<br/>
 command and type the commands into that shell:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe /bin/bash
<br/>
 ls
<br/>
 date
<br/>
 exit
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Be careful not to run spamprobe in the shell though since the
<br/>
 spamprobe in the shell will wind up deadlocked waiting for the
<br/>
 spamprobe running the exec command to release its lock.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe exec-shared command
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 Same as exec except that a shared lock is used. This may be more
<br/>
 appropriate if you are backing up your database since operations
<br/>
 like score (but not train or receive) could still be performed on
<br/>
 the database while the backup was running.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SETUP_OF_SPAMPROBE_FOR_USERS"><a class="selflink" href="#SETUP_OF_SPAMPROBE_FOR_USERS">SETUP
  OF SPAMPROBE FOR USERS</a></h1>
Once you have a spamprobe executable copy it to someplace in your PATH so that
  procmail can find it. Then create a directory for SpamProbe to store its
  databases in. By default SpamProbe wants to use the directory ~/.spamprobe.
  You must create this directory manually in order to run SpamProbe or else
  specify some other directory using the -d option. Something like this should
  suffice:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 mkdir ~/.spamprobe
<div style="height: 1.00em;">&#x00A0;</div>
SpamProbe can use either the PBL or Berkeley DB library for its databases. Both
  are fast on local file systems but very slow over NFS. Please ensure that your
  spamprobe directory is on a local file system to ensure good performance.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="NOTES_USING_HASH_DATABASE"><a class="selflink" href="#NOTES_USING_HASH_DATABASE">NOTES
  USING HASH DATABASE</a></h1>
SpamProbe can use a simple, fixed size hash data file as an alternative to PBL
  or BDB. There are two advantages to the hash format. The first is speed. In my
  experiments the hash file format is around 2x the speed of PBL (ranged from
  1.8x to 3.5x). The second advantage is that the hash data file size is fixed.
  You choose a size when you create the file and it never changes. File size can
  be anywhere from 1-100 MB. You need to choose a size large enough to hold your
  terms with room to spare. More on that later.
<div style="height: 1.00em;">&#x00A0;</div>
The hash file format also has significant disadvantages. Becuase the file size
  is fixed you must monitor the file to ensure that it does not become overly
  full. When the file becomes more than half full performance will suffer. Also
  the hash format does not store original terms so you cannot use the dump
  command to learn what terms are spammy or hammy in your database. Finally, the
  hash format is imprecise. Hash collisions can cause the counts from different
  terms to be mixed together which can reduce accuracy.
<div style="height: 1.00em;">&#x00A0;</div>
To create a hash data file you add a prefix to the directory name in the -d
  command line option. You can specify just the directory like this:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe -d hash:$HOME/.spamprobe
<div style="height: 1.00em;">&#x00A0;</div>
or you can add a size in megabytes for the file like this:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe -d hash:42:$HOME/.spamprobe
<div style="height: 1.00em;">&#x00A0;</div>
The size is only used when a file is first created. SP auto detects the size of
  an existing hash file. You need to allow enough space for twice as many terms
  as you are likely to have in your file. In my database I have 2.2 million
  terms. That required a database of are 53 MB. SP uses 12 bytes per term in the
  hash file so you can estimate the file size you'll need by multiplying the
  number of terms by 24.
<div style="height: 1.00em;">&#x00A0;</div>
The hash format does not store the original terms. Instead it stores the 32 bit
  hash code for each term. You can do just about anything with a hash file that
  you could with a PBL file including import/export, edit-term, cleanup, purge,
  etc. You can use export your PBL database and import it to build a hash file
  (note that you cannot go the other direction) and you can export one hash file
  and import into a new one to enlarge your file.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="MAILDIR_FORMAT"><a class="selflink" href="#MAILDIR_FORMAT">MAILDIR
  FORMAT</a></h1>
SpamProbe will accept a maildir directory name anywhere that an Mbox or MBX file
  name can be specified. When SpamProbe encounters a Maildir mailbox (directory)
  name it will automatically process all of the non-hidden files in the cur and
  new subdirectories of the mailbox. There is no need to individually specify
  these subdirectories.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="GETTING_STARTED"><a class="selflink" href="#GETTING_STARTED">GETTING
  STARTED</a></h1>
SpamProbe is not a stand alone mail filter. It doesn't sort your mail or split
  it into different mailboxes. Instead it relies on some other program such as
  procmail to actually file your mail for you. What SpamProbe does do is track
  the word counts in good and spam emails and generate a score for each email
  that indicates whether or not it is likely to be spam. Scores range from 0 to
  1 with any score of 0.9 or higher indicating a probable spam.
<div style="height: 1.00em;">&#x00A0;</div>
Personally I use SpamProbe with procmail to filter my incoming email into mail
  boxes. I have procmail score each inbound email using SpamProbe and insert a
  special header into each email containing its score. Then I have procmail move
  spams into a special mailbox.
<div style="height: 1.00em;">&#x00A0;</div>
No spam filter is perfect and SpamProbe sometimes makes mistakes. To correct
  those mistakes I have a special mailbox that I put undetected spams into. I
  run SpamProbe periodically and have it reclassify any emails in that mailbox
  as spam so that it will make a better guess the next time around.
<div style="height: 1.00em;">&#x00A0;</div>
This is not a procmail primer. You will need to ensure that you have procmail
  and formail installed before you can use this technique. Also I recommend that
  you read the procmail documentation so that you can fully understand this
  example and adapt it to your own needs. That having been said, my .procmailrc
  file looks like this:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 MAILDIR=$HOME/IMAP
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 :0 c
<br/>
 saved
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 :0
<br/>
 SCORE=| /home/brian/bin/spamprobe train
<br/>
 :0 wf
<br/>
 | formail -I &quot;X-SpamProbe: $SCORE&quot;
<br/>
 :0 a:
<br/>
 *^X-SpamProbe: SPAM
<br/>
 spamprobe
<div style="height: 1.00em;">&#x00A0;</div>
I use IMAP to fetch my email so my mailboxes all live in a directory named IMAP
  on my mail server.
<div style="height: 1.00em;">&#x00A0;</div>
NOTE: The first stanza copies all incoming emails into a special mbox called
  saved. SpamProbe IS BETA SOFTWARE and though it works well for me it is
  possible that it could somehow lose emails. Caution is always a good idea.
  That having been said, with the procmailrc file as shown above the worst that
  could happen if SpamProbe crashes is that the email would not be scored
  properly and procmail would deliver it to your inbox. Of course if procmail
  crashes all bets are off.
<div style="height: 1.00em;">&#x00A0;</div>
The second stanza runs spamprobe in &quot;train&quot; mode to score the email,
  classify it as either spam or good, and possibly update the database. The
  train command tries to minimize the number of database updates by only
  updating the database with terms from an incoming message if there was
  insufficient confidence in the message's score. The train command always
  updates the database on the first 1500 of each type received. This ensures
  that sufficient email is classified to allow the filter to operate reliably.
<div style="height: 1.00em;">&#x00A0;</div>
The next stanza runs formail to add a custom header to the email containing the
  SpamProbe score. The final stanza uses the contents of the custom header to
  file detected spams into a special mbox named spamprobe.
<div style="height: 1.00em;">&#x00A0;</div>
As an alternative to using the train command, you can run spamprobe in
  &quot;receive&quot; mode. In that mode SpamProbe scores the email and then
  classifies it as either spam or good based on the score. It always
  automatically adds the word counts for the email to the appropriate database.
  This is essentially like running in score mode followed immediately by either
  spam or good mode. It produces more database I/O and a bigger database but
  ensures that every message has its terms reflected in the database. Personally
  I use train mode. A sample procmailrc file using the receive command looks
  like this:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 MAILDIR=$HOME/IMAP
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 :0 c
<br/>
 saved
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 :0
<br/>
 SCORE=| /home/brian/bin/spamprobe receive
<br/>
 :0 wf
<br/>
 | formail -I &quot;X-SpamProbe: $SCORE&quot;
<br/>
 :0 a:
<br/>
 *^X-SpamProbe: SPAM
<br/>
 spamprobe
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="MAKING_CORRECTIONS"><a class="selflink" href="#MAKING_CORRECTIONS">MAKING
  CORRECTIONS</a></h1>
SpamProbe is not perfect. It is able to detect over 99% of the spams that I
  receive but some still slip through. To correct these missed emails I run
  SpamProbe periodically and have it scan a special mbox. Since I use IMAP to
  retrieve my emails I can simply drop undetected spams into this mbox from my
  mail client. If you use POP or some other system then you will need to find a
  way get the undetected spams into a mbox that spamprobe can see.
<div style="height: 1.00em;">&#x00A0;</div>
Periodically I run a script that scans three special mboxes to correct errors in
  judgment:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #!/bin/sh
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 IMAPDIR=$HOME/IMAP
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe remove $IMAPDIR/remove
<br/>
 spamprobe good $IMAPDIR/nonspam
<br/>
 spamprobe spam $IMAPDIR/spam
<br/>
 spamprobe train-spam $IMAPDIR/spamprobe
<div style="height: 1.00em;">&#x00A0;</div>
From this example you can see that I use three special mboxes to make
  corrections. I copy emails that I don't want spamprobe to store into the
  remove mbox. This is useful if you receive email from a friend or colleague
  that looks like spam and you don't want it to dilute the effectiveness of the
  terms it contains.
<div style="height: 1.00em;">&#x00A0;</div>
Undetected spams go into the spam mbox. SpamProbe will reclassify those emails
  as spam and correct its database accordingly. Note that doing this does not
  guarantee that the spam will always be scored as spam in the future. Some
  spams are too bland to detect perfectly. Fortunately those are very rare.
<div style="height: 1.00em;">&#x00A0;</div>
The nonspam mbox is for any false positives. These are always possible and it is
  important to have a way to reclassify them when they do occur.
<div style="height: 1.00em;">&#x00A0;</div>
If you are using receive mode rather than train mode then the above script can
  be modified to remove the train-spam line. For example:
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 #!/bin/sh
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 IMAPDIR=$HOME/IMAP
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe remove $IMAPDIR/remove
<br/>
 spamprobe good $IMAPDIR/nonspam
<br/>
 spamprobe spam $IMAPDIR/spam
<div style="height: 1.00em;">&#x00A0;</div>
Finally you'll need to build a starting database. Since SpamProbe relies on word
  counts from past emails it requires a decent sized database to be accurate. To
  build the database select some of your mboxes containing past emails. Ideally
  you should have one mbox of spams and one or more of non-spams. If you don't
  have any spams handy then don't worry, SpamProbe will gradually become more
  accurate as you receive more spams. Expect a fairly high false negative (i.e.
  missed spams) rate as you first start using SpamProbe.
<div style="height: 1.00em;">&#x00A0;</div>
To import your starting messages use commands such as these. The example assumes
  that you have non-spams stored in a file named mbox in your home directory and
  some spams stored in a file named nasty-spams. Replace these names with real
  ones.
<div style="height: 1.00em;">&#x00A0;</div>
<br/>
 spamprobe good ~/mbox
<br/>
 spamprobe spam ~/nasty-spams
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
procmail(1)</div>
<table class="foot">
  <tr>
    <td class="foot-date">December 2005</td>
    <td class="foot-os">Version 1.4</td>
  </tr>
</table>
</body>
</html>
