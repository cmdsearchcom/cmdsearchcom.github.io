<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:34:55 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p style="margin-top: 1em">RAGEL(1) Ragel State Machine
Compiler RAGEL(1)</p>

<p style="margin-top: 1em">NAME <br>
ragel - compile regular languages into executable state
machines</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ragel [options] file</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Ragel compiles executable finite state machines from regular
languages. Ragel can generate C, C++, Objective-C, D, Go, or
Java code. Ragel state machines can not only recognize <br>
byte sequences as regular expression machines do, but can
also execute code at arbitrary points in the recognition of
a regular language. User code is embedded using inline <br>
operators that do not disrupt the regular language
syntax.</p>

<p style="margin-top: 1em">The core language consists of
standard regular expression operators, such as union,
concatenation and kleene star, accompanied by action
embedding operators. Ragel also provides <br>
operators that let you control any non-determinism that you
create, construct scanners using the longest match paradigm,
and build state machines using the statechart model. It <br>
is also possible to influence the execution of a state
machine from inside an embedded action by jumping or calling
to other parts of the machine and reprocessing input.</p>

<p style="margin-top: 1em">Ragel provides a very flexibile
interface to the host language that attempts to place
minimal restrictions on how the generated code is used and
integrated into the application. <br>
The generated code has no dependencies.</p>

<p style="margin-top: 1em">OPTIONS <br>
-h, -H, -?, --help <br>
Display help and exit.</p>

<p style="margin-top: 1em">-v Print version information and
exit.</p>

<p style="margin-top: 1em">-o file <br>
Write output to file. If -o is not given, a default file
name is chosen by replacing the file extenstion of the input
file. For source files ending in .rh the suffix .h is <br>
used. For all other source files a suffix based on the
output language is used (.c, .cpp, .m, etc.). If -o is not
given for Graphviz output the generated dot file is
writ&acirc; <br>
ten to standard output.</p>

<p style="margin-top: 1em">-s Print some statistics on
standard error.</p>

<p style="margin-top: 1em">--error-format=gnu <br>
Print error messages using the format
&quot;file:line:column:&quot; (default)</p>

<p style="margin-top: 1em">--error-format=msvc <br>
Print error messages using the format
&quot;file(line,column):&quot;</p>

<p style="margin-top: 1em">-d Do not remove duplicate
actions from action lists.</p>

<p style="margin-top: 1em">-I dir <br>
Add dir to the list of directories to search for included
and imported files</p>

<p style="margin-top: 1em">-n Do not perform state
minimization.</p>

<p style="margin-top: 1em">-m Perform minimization once, at
the end of the state machine compilation.</p>

<p style="margin-top: 1em">-l Minimize after nearly every
operation. Lists of like operations such as unions are
minimized once at the end. This is the default minimization
option.</p>

<p style="margin-top: 1em">-e Minimize after every
operation.</p>

<p style="margin-top: 1em">-x Compile the state machines
and emit an XML representation of the host data and the
machines.</p>

<p style="margin-top: 1em">-V Generate a dot file for
Graphviz.</p>

<p style="margin-top: 1em">-p Display printable characters
on labels.</p>

<p style="margin-top: 1em">-L Inhibit writing of #line
directives.</p>

<p style="margin-top: 1em">-S &lt;spec&gt; <br>
FSM specification to output.</p>

<p style="margin-top: 1em">-M &lt;machine&gt; <br>
Machine definition/instantiation to output.</p>

<p style="margin-top: 1em">-C The host language is C, C++,
Obj-C or Obj-C++. This is the default host language
option.</p>

<p style="margin-top: 1em">--asm --gas-x86-64-sys-v <br>
GNU AS, x86_64, System V ABI ASM is generated in a code
style equiv to -G2</p>

<p style="margin-top: 1em">-D The host language is D.</p>

<p style="margin-top: 1em">-Z The host language is Go.</p>

<p style="margin-top: 1em">-J The host language is
Java.</p>

<p style="margin-top: 1em">-R The host language is
Ruby.</p>

<p style="margin-top: 1em">-A The host language is C#</p>

<p style="margin-top: 1em">-O The host language is
OCaml.</p>

<p style="margin-top: 1em">-U The host language is
Rust.</p>

<p style="margin-top: 1em">-Y The host language is
Julia.</p>

<p style="margin-top: 1em">-K The host language is
Crack.</p>

<p style="margin-top: 1em">-P The host language is
JavaScript.</p>

<p style="margin-top: 1em">-T0 (C/D/Java/Ruby/C#) Generate
a table driven FSM. This is the default code style. The
table driven FSM represents the state machine as static
data. There are tables of <br>
states, transitions, indicies and actions. The current state
is stored in a variable. The execution is a loop that looks
that given the current state and current charac&acirc; <br>
ter to process looks up the transition to take using a
binary search, executes any actions and moves to the target
state. In general, the table driven FSM produces a <br>
smaller binary and requires a less expensive host language
compile but results in slower running code. The table driven
FSM is suitable for any FSM.</p>

<p style="margin-top: 1em">-T1 (C/D/Ruby/C#) Generate a
faster table driven FSM by expanding action lists in the
action execute code.</p>

<p style="margin-top: 1em">-F0 (C/D/Ruby/C#) Generate a
flat table driven FSM. Transitions are represented as an
array indexed by the current alphabet character. This
eliminates the need for a binary <br>
search to locate transitions and produces faster code,
however it is only suitable for small alphabets.</p>

<p style="margin-top: 1em">-F1 (C/D/Ruby/C#) Generate a
faster flat table driven FSM by expanding action lists in
the action execute code.</p>

<p style="margin-top: 1em">-G0 (C/D/C#) Generate a goto
driven FSM. The goto driven FSM represents the state machine
as a series of goto statements. While in the machine, the
current state is stored by <br>
the processor&rsquo;s instruction pointer. The execution is
a flat function where control is passed from state to state
using gotos. In general, the goto FSM produces faster <br>
code but results in a larger binary and a more expensive
host language compile.</p>

<p style="margin-top: 1em">-G1 (C/D/C#) Generate a faster
goto driven FSM by expanding action lists in the action
execute code.</p>

<p style="margin-top: 1em">-G2 (C/D/Go) Generate a really
fast goto driven FSM by embedding action lists in the state
machine control code.</p>

<p style="margin-top: 1em">--nfa-conds-depth=D <br>
Search for high-cost conditions inside a prefix of the
machine (depth D from start state). Search is rooted at NFA
union contructs.</p>

<p style="margin-top: 1em">--nfa-term-check <br>
Search for condition-based general repetitions that will not
function properly and must be NFA reps. Search is rooted at
NFA union constructs.</p>

<p style="margin-top: 1em">--nfa-intermed-state-limit=L
<br>
Report fail if number of states exceeds this during
compilation.</p>

<p style="margin-top: 1em">--nfa-final-state-limit=L <br>
Report a fail if number states in final machine exceeds
this.</p>

<p style="margin-top: 1em">--nfa-breadth-check=E1,E2,..
<br>
Report breadth cost of named entry points by (and start).
Reporting starts at NFA union contructs.</p>

<p style="margin-top: 1em">--input-histogram=FN <br>
Input char histogram for breadth check. If unspecified a
flat histogram is used.</p>

<p style="margin-top: 1em">RAGEL INPUT <br>
NOTE: This is a very brief description of Ragel input. Ragel
is described in more detail in the user guide available from
the homepage (see below).</p>

<p style="margin-top: 1em">Ragel normally passes input
files straight to the output. When it sees an FSM
specification that contains machine instantiations it stops
to generate the state machine. If there <br>
are write statements (such as &quot;write exec&quot;) then
ragel emits the corresponding code. There can be any number
of FSM specifications in an input file. A multi-line FSM
specifica&acirc; <br>
tion starts with &rsquo;%%{&rsquo; and ends with
&rsquo;}%%&rsquo;. A single line FSM specification starts
with %% and ends at the first newline.</p>

<p style="margin-top: 1em">FSM STATEMENTS <br>
Machine Name: <br>
Set the the name of the machine. If given, it must be the
first statement.</p>

<p style="margin-top: 1em">Alphabet Type: <br>
Set the data type of the alphabet.</p>

<p style="margin-top: 1em">GetKey: <br>
Specify how to retrieve the alphabet character from the
element type.</p>

<p style="margin-top: 1em">Include: <br>
Include a machine of same name as the current or of a
different name in either the current file or some other
file.</p>

<p style="margin-top: 1em">Action Definition: <br>
Define an action that can be invoked by the FSM.</p>

<p style="margin-top: 1em">Fsm Definition, Instantiation
and Longest Match Instantiation: <br>
Used to build FSMs. Syntax description in next few
sections.</p>

<p style="margin-top: 1em">Access: <br>
Specify how to access the persistent state machine
variables.</p>

<p style="margin-top: 1em">Write: Write some component of
the machine.</p>

<p style="margin-top: 1em">Variable: <br>
Override the default variable names (p, pe, cs, act,
etc).</p>

<p style="margin-top: 1em">BASIC MACHINES <br>
The basic machines are the base operands of the regular
language expressions.</p>

<p style="margin-top: 1em">&rsquo;hello&rsquo; <br>
Concat literal. Produces a concatenation of the characters
in the string. Supports escape sequences with
&rsquo;&acute;. The result will have a start state and a
transition to a <br>
new state for each character in the string. The last state
in the sequence will be made final. To make the string
case-insensitive, append an &rsquo;i&rsquo; to the string,
as in <br>
&rsquo;cmd&rsquo;i.</p>

<p style="margin-top: 1em">&quot;hello&quot; <br>
Identical to single quote version.</p>

<p style="margin-top: 1em">[hello] <br>
Or literal. Produces a union of characters. Supports
character ranges with &rsquo;-&rsquo;, negating the sense of
the union with an initial &rsquo;^&rsquo; and escape
sequences with &rsquo;&acute;. The <br>
result will have two states with a transition between them
for each character or range.</p>

<p style="margin-top: 1em">NOTE: &rsquo;&rsquo;,
&quot;&quot;, and [] produce null FSMs. Null machines have
one state that is both a start state and a final state and
match the zero length string. A null machine may be created
<br>
with the null builtin machine.</p>

<p style="margin-top: 1em">integer <br>
Makes a two state machine with one transition on the given
integer number.</p>

<p style="margin-top: 1em">hex Makes a two state machine
with one transition on the given hexidecimal number.</p>

<p style="margin-top: 1em">/simple_regex/ <br>
A simple regular expression. Supports the notation
&rsquo;.&rsquo;, &rsquo;*&rsquo; and &rsquo;[]&rsquo;,
character ranges with &rsquo;-&rsquo;, negating the sense of
an OR expression with and initial &rsquo;^&rsquo; and escape
<br>
sequences with &rsquo;&acute;. Also supports one trailing
flag: i. Use it to produce a case-insensitive regular
expression, as in /GET/i.</p>

<p style="margin-top: 1em">lit .. lit <br>
Specifies a range. The allowable upper and lower bounds are
concat literals of length one and number machines. For
example, 0x10..0x20, 0..63, and
&rsquo;a&rsquo;..&rsquo;z&rsquo; are valid <br>
ranges.</p>

<p style="margin-top: 1em">variable_name <br>
References the machine definition assigned to the variable
name given.</p>

<p style="margin-top: 1em">builtin_machine <br>
There are several builtin machines available. They are all
two state machines for the purpose of matching common
classes of characters. They are:</p>

<p style="margin-top: 1em">any Any character in the
alphabet.</p>

<p style="margin-top: 1em">ascii Ascii characters
0..127.</p>

<p style="margin-top: 1em">extend Ascii extended
characters. This is the range -128..127 for signed alphabets
and the range 0..255 for unsigned alphabets.</p>

<p style="margin-top: 1em">alpha Alphabetic characters
/[A-Za-z]/.</p>

<p style="margin-top: 1em">digit Digits /[0-9]/.</p>

<p style="margin-top: 1em">alnum Alpha numerics
/[0-9A-Za-z]/.</p>

<p style="margin-top: 1em">lower Lowercase characters
/[a-z]/.</p>

<p style="margin-top: 1em">upper Uppercase characters
/[A-Z]/.</p>

<p style="margin-top: 1em">xdigit Hexidecimal digits
/[0-9A-Fa-f]/.</p>

<p style="margin-top: 1em">cntrl Control characters
0..31.</p>

<p style="margin-top: 1em">graph Graphical characters
/[!-~]/.</p>

<p style="margin-top: 1em">print Printable characters /[
-~]/.</p>

<p style="margin-top: 1em">punct Punctuation. Graphical
characters that are not alpha-numerics /[!-/:-@/.</p>

<p style="margin-top: 1em">space Whitespace /[/.</p>

<p style="margin-top: 1em">null Zero length string.
Equivalent to &rsquo;&rsquo;, &quot;&quot; and [].</p>

<p style="margin-top: 1em">empty Empty set. Matches
nothing.</p>

<p style="margin-top: 1em">BRIEF OPERATOR REFERENCE <br>
Operators are grouped by precedence, group 1 being the
lowest and group 6 the highest.</p>

<p style="margin-top: 1em">GROUP 1:</p>

<p style="margin-top: 1em">expr , expr <br>
Join machines together without drawing any transitions,
setting up a start state or any final states. Start state
must be explicitly specified with the &quot;start&quot;
label. <br>
Final states may be specified with the an epsilon
transitions to the implicitly created &quot;final&quot;
state.</p>

<p style="margin-top: 1em">GROUP 2:</p>

<p style="margin-top: 1em">expr | expr <br>
Produces a machine that matches any string in machine one or
machine two.</p>

<p style="margin-top: 1em">expr &amp; expr <br>
Produces a machine that matches any string that is in both
machine one and machine two.</p>

<p style="margin-top: 1em">expr - expr <br>
Produces a machine that matches any string that is in
machine one but not in machine two.</p>

<p style="margin-top: 1em">expr -- expr <br>
Strong Subtraction. Matches any string in machine one that
does not have any string in machine two as a substring.</p>

<p style="margin-top: 1em">GROUP 3:</p>

<p style="margin-top: 1em">expr . expr <br>
Produces a machine that matches all the strings in machine
one followed by all the strings in machine two.</p>

<p style="margin-top: 1em">expr :&gt; expr <br>
Entry-Guarded Concatenation: terminates machine one upon
entry to machine two.</p>

<p style="margin-top: 1em">expr :&gt;&gt; expr <br>
Finish-Guarded Concatenation: terminates machine one when
machine two finishes.</p>

<p style="margin-top: 1em">expr &lt;: expr <br>
Left-Guarded Concatenation: gives a higher priority to
machine one.</p>

<p style="margin-top: 1em">NOTE: Concatenation is the
default operator. Two machines next to each other with no
operator between them results in the concatenation
operation.</p>

<p style="margin-top: 1em">GROUP 4:</p>

<p style="margin-top: 1em">label: expr <br>
Attaches a label to an expression. Labels can be used by
epsilon transitions and fgoto and fcall statements in
actions. Also note that the referencing of a machine
defini&acirc; <br>
tion causes the implicit creation of label by the same
name.</p>

<p style="margin-top: 1em">GROUP 5:</p>

<p style="margin-top: 1em">expr -&gt; label <br>
Draws an epsilon transition to the state defined by label.
Label must be a name in the current scope. Epsilon
transitions are resolved when comma operators are evaluated
<br>
and at the root of the expression tree of machine
assignment/instantiation.</p>

<p style="margin-top: 1em">GROUP 6: Actions</p>

<p style="margin-top: 1em">An action may be a name
predefined with an action statement or may be specified
directly with &rsquo;{&rsquo; and &rsquo;}&rsquo; in the
expression.</p>

<p style="margin-top: 1em">expr &gt; action <br>
Embeds action into starting transitions.</p>

<p style="margin-top: 1em">expr @ action <br>
Embeds action into transitions that go into a final
state.</p>

<p style="margin-top: 1em">expr $ action <br>
Embeds action into all transitions. Does not include pending
out transitions.</p>

<p style="margin-top: 1em">expr % action <br>
Embeds action into pending out transitions from final
states.</p>

<p style="margin-top: 1em">GROUP 6: EOF Actions</p>

<p style="margin-top: 1em">When a machine&rsquo;s finish
routine is called the current state&rsquo;s EOF actions are
executed.</p>

<p style="margin-top: 1em">expr &gt;/ action <br>
Embed an EOF action into the start state.</p>

<p style="margin-top: 1em">expr &lt;/ action <br>
Embed an EOF action into all states except the start
state.</p>

<p style="margin-top: 1em">expr $/ action <br>
Embed an EOF action into all states.</p>

<p style="margin-top: 1em">expr %/ action <br>
Embed an EOF action into final states.</p>

<p style="margin-top: 1em">expr @/ action <br>
Embed an EOF action into all states that are not final.</p>

<p style="margin-top: 1em">expr &lt;&gt;/ action <br>
Embed an EOF action into all states that are not the start
state and that are not final (middle states).</p>

<p style="margin-top: 1em">GROUP 6: Global Error
Actions</p>

<p style="margin-top: 1em">Global error actions are stored
in states until the final state machine has been fully
constructed. They are then transferred to error transitions,
giving the effect of a default <br>
action.</p>

<p style="margin-top: 1em">expr &gt;! action <br>
Embed a global error action into the start state.</p>

<p style="margin-top: 1em">expr &lt;! action <br>
Embed a global error action into all states except the start
state.</p>

<p style="margin-top: 1em">expr $! action <br>
Embed a global error action into all states.</p>

<p style="margin-top: 1em">expr %! action <br>
Embed a global error action into the final states.</p>

<p style="margin-top: 1em">expr @! action <br>
Embed a global error action into all states which are not
final.</p>

<p style="margin-top: 1em">expr &lt;&gt;! action <br>
Embed a global error action into all states which are not
the start state and are not final (middle states).</p>

<p style="margin-top: 1em">GROUP 6: Local Error Actions</p>

<p style="margin-top: 1em">Local error actions are stored
in states until the named machine is fully constructed. They
are then transferred to error transitions, giving the effect
of a default action for a <br>
section of the total machine. Note that the name may be
omitted, in which case the action will be transferred to
error actions upon construction of the current machine.</p>

<p style="margin-top: 1em">expr &gt;^ action <br>
Embed a local error action into the start state.</p>

<p style="margin-top: 1em">expr &lt;^ action <br>
Embed a local error action into all states except the start
state.</p>

<p style="margin-top: 1em">expr $^ action <br>
Embed a local error action into all states.</p>

<p style="margin-top: 1em">expr %^ action <br>
Embed a local error action into the final states.</p>

<p style="margin-top: 1em">expr @^ action <br>
Embed a local error action into all states which are not
final.</p>

<p style="margin-top: 1em">expr &lt;&gt;^ action <br>
Embed a local error action into all states which are not the
start state and are not final (middle states).</p>

<p style="margin-top: 1em">GROUP 6: To-State Actions</p>

<p style="margin-top: 1em">To state actions are stored in
states and executed any time the machine moves into a state.
This includes regular transitions, and transfers of control
such as fgoto. Note that <br>
setting the current state from outside the machine (for
example during initialization) does not count as a
transition into a state.</p>

<p style="margin-top: 1em">expr &gt;~ action <br>
Embed a to-state action action into the start state.</p>

<p style="margin-top: 1em">expr &lt;~ action <br>
Embed a to-state action into all states except the start
state.</p>

<p style="margin-top: 1em">expr $~ action <br>
Embed a to-state action into all states.</p>

<p style="margin-top: 1em">expr %~ action <br>
Embed a to-state action into the final states.</p>

<p style="margin-top: 1em">expr @~ action <br>
Embed a to-state action into all states which are not
final.</p>

<p style="margin-top: 1em">expr &lt;&gt;~ action <br>
Embed a to-state action into all states which are not the
start state and are not final (middle states).</p>

<p style="margin-top: 1em">GROUP 6: From-State Actions</p>

<p style="margin-top: 1em">From state actions are executed
whenever a state takes a transition on a character. This
includes the error transition and a transition to self.</p>

<p style="margin-top: 1em">expr &gt;* action <br>
Embed a from-state action into the start state.</p>

<p style="margin-top: 1em">expr &lt;* action <br>
Embed a from-state action into every state except the start
state.</p>

<p style="margin-top: 1em">expr $* action <br>
Embed a from-state action into all states.</p>

<p style="margin-top: 1em">expr %* action <br>
Embed a from-state action into the final states.</p>

<p style="margin-top: 1em">expr @* action <br>
Embed a from-state action into all states which are not
final.</p>

<p style="margin-top: 1em">expr &lt;&gt;* action <br>
Embed a from-state action into all states which are not the
start state and are not final (middle states).</p>

<p style="margin-top: 1em">GROUP 6: Priority Assignment</p>

<p style="margin-top: 1em">Priorities are assigned to names
within transitions. Only priorities on the same name are
allowed to interact. In the first form of priorities the
name defaults to the name of <br>
the machine definition the priority is assigned in.
Transitions do not have default priorities.</p>

<p style="margin-top: 1em">expr &gt; int <br>
Assigns the priority int in all transitions leaving the
start state.</p>

<p style="margin-top: 1em">expr @ int <br>
Assigns the priority int in all transitions that go into a
final state.</p>

<p style="margin-top: 1em">expr $ int <br>
Assigns the priority int in all existing transitions.</p>

<p style="margin-top: 1em">expr % int <br>
Assigns the priority int in all pending out transitions.</p>

<p style="margin-top: 1em">A second form of priority
assignment allows the programmer to specify the name to
which the priority is assigned, allowing interactions to
cross machine definition boundaries.</p>

<p style="margin-top: 1em">expr &gt; (name,int) <br>
Assigns the priority int to name in all transitions leaving
the start state.</p>

<p style="margin-top: 1em">expr @ (name, int) <br>
Assigns the priority int to name in all transitions that go
into a final state.</p>

<p style="margin-top: 1em">expr $ (name, int) <br>
Assigns the priority int to name in all existing
transitions.</p>

<p style="margin-top: 1em">expr % (name, int) <br>
Assigns the priority int to name in all pending out
transitions.</p>

<p style="margin-top: 1em">GROUP 7:</p>

<p style="margin-top: 1em">expr * Produces the kleene star
of a machine. Matches zero or more repetitions of the
machine.</p>

<p style="margin-top: 1em">expr ** <br>
Longest-Match Kleene Star. This version of kleene star puts
a higher priority on staying in the machine over wrapping
around and starting over. This operator is equivalent <br>
to ( ( expr ) $0 %1 )*.</p>

<p style="margin-top: 1em">expr ? Produces a machine that
accepts the machine given or the null string. This operator
is equivalent to ( expr | &rsquo;&rsquo; ).</p>

<p style="margin-top: 1em">expr + Produces the machine
concatenated with the kleen star of itself. Matches one or
more repetitions of the machine. This operator is equivalent
to ( expr . expr* ).</p>

<p style="margin-top: 1em">expr {n} <br>
Produces a machine that matches exactly n repetitions of
expr.</p>

<p style="margin-top: 1em">expr {,n} <br>
Produces a machine that matches anywhere from zero to n
repetitions of expr.</p>

<p style="margin-top: 1em">expr {n,} <br>
Produces a machine that matches n or more repetitions of
expr.</p>

<p style="margin-top: 1em">expr {n,m} <br>
Produces a machine that matches n to m repetitions of
expr.</p>

<p style="margin-top: 1em">GROUP 8:</p>

<p style="margin-top: 1em">! expr Produces a machine that
matches any string not matched by the given machine. This
operator is equivalent to ( *extend - expr ).</p>

<p style="margin-top: 1em">^ expr Character-Level Negation.
Matches any single character not matched by the single
character machine expr.</p>

<p style="margin-top: 1em">GROUP 9:</p>

<p style="margin-top: 1em">( expr ) <br>
Forces precedence on operators.</p>

<p style="margin-top: 1em">VALUES AVAILABLE IN CODE BLOCKS
<br>
fc The current character. Equivalent to *p.</p>

<p style="margin-top: 1em">fpc A pointer to the current
character. Equivalent to p.</p>

<p style="margin-top: 1em">fcurs An integer value
representing the current state.</p>

<p style="margin-top: 1em">ftargs An integer value
representing the target state.</p>

<p style="margin-top: 1em">fentry(&lt;label&gt;) <br>
An integer value representing the entry point
&lt;label&gt;.</p>

<p style="margin-top: 1em">STATEMENTS AVAILABLE IN CODE
BLOCKS <br>
fhold; Do not advance over the current character. Equivalent
to --p;.</p>

<p style="margin-top: 1em">fexec &lt;expr&gt;; <br>
Sets the current character to something else. Equivalent to
p = (&lt;expr&gt;)-1;</p>

<p style="margin-top: 1em">fgoto &lt;label&gt;; <br>
Jump to the machine defined by &lt;label&gt;.</p>

<p style="margin-top: 1em">fgoto *&lt;expr&gt;; <br>
Jump to the entry point given by &lt;expr&gt;. The
expression must evaluate to an integer value representing a
state.</p>

<p style="margin-top: 1em">fnext &lt;label&gt;; <br>
Set the next state to be the entry point defined by
&lt;label&gt;. The fnext statement does not immediately jump
to the specified state. Any action code following the
statement <br>
is executed.</p>

<p style="margin-top: 1em">fnext *&lt;expr&gt;; <br>
Set the next state to be the entry point given by
&lt;expr&gt;. The expression must evaluate to an integer
value representing a state.</p>

<p style="margin-top: 1em">fcall &lt;label&gt;; <br>
Call the machine defined by &lt;label&gt;. The next fret
will jump to the target of the transition on which the
action is invoked.</p>

<p style="margin-top: 1em">fcall *&lt;expr&gt;; <br>
Call the entry point given by &lt;expr&gt;. The next fret
will jump to the target of the transition on which the
action is invoked.</p>

<p style="margin-top: 1em">fret; Return to the target state
of the transition on which the last fcall was made.</p>

<p style="margin-top: 1em">fbreak; <br>
Save the current state and immediately break out of the
machine.</p>

<p style="margin-top: 1em">CREDITS <br>
Ragel was written by Adrian Thurston
&lt;thurston@complang.org&gt;. Objective-C output
contributed by Erich Ocean. D output contributed by Alan
West. Ruby output contributed by Victor <br>
Hugo Borja. C Sharp code generation contributed by Daniel
Tang. Contributions to Java code generation by Colin
Fleming. Go code generation contributed by Justine
Tunney.</p>

<p style="margin-top: 1em">SEE ALSO <br>
re2c(1), flex(1)</p>

<p style="margin-top: 1em">Homepage:
http://www.complang.org/ragel/</p>

<p style="margin-top: 1em">Ragel 7.0.0.9 August 2016
RAGEL(1)</p>
<hr>
</body>
</html>
