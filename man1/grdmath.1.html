<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>GRDMATH(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GRDMATH(1)</td>
    <td class="head-vol">GMT</td>
    <td class="head-rtitle">GRDMATH(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
grdmath - Reverse Polish Notation (RPN) calculator for grids (element by
  element)
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>grdmath</b> [
  <b>-A</b><i>min_area</i>[/<i>min_level</i>/<i>max_level</i>][<b>+ag</b>|<b>i</b>|<b>s</b>
  | <b>S</b>][<b>+r</b>|<b>l</b>][<b>p</b><i>percent</i>] ] [
  <b>-D</b><i>resolution</i>[ <b>+</b>] ] [ <b>-I</b><i>increment</i> ] [
  <b>-M</b> ] [ <b>-N</b> ] [ <b>-R</b><i>region</i> ] [ <b>-V</b>[<i>level</i>]
  ] [ <b>-bi</b>binary ] [ <b>-di</b>nodata ] [ <b>-f</b>flags ] [
  <b>-h</b>headers ] [ <b>-i</b>flags ] [ <b>-n</b>flags ] [ <b>-r</b> ] [
  <b>-x</b>[[-] <i>n</i>] ] <i>operand</i> [ <i>operand</i> ] <b>OPERATOR</b> [
  <i>operand</i> ] <b>OPERATOR</b> &#x2026; <b>=</b> <i>outgrdfile</i>
<div style="height: 1.00em;">&#x00A0;</div>
<b>Note:</b> No space is allowed between the option flag and the associated
  arguments.
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>grdmath</b> will perform operations like add, subtract, multiply, and divide
  on one or more grid files or constants using Reverse Polish Notation (RPN)
  syntax (e.g., Hewlett-Packard calculator-style). Arbitrarily complicated
  expressions may therefore be evaluated; the final result is written to an
  output grid file. Grid operations are element-by-element, not matrix
  manipulations. Some operators only require one operand (see below). If no grid
  files are used in the expression then options <b>-R</b>, <b>-I</b> must be set
  (and optionally <b>-r</b>). The expression <b>=</b> <i>outgrdfile</i> can
  occur as many times as the depth of the stack allows in order to save
  intermediate results. Complicated or frequently occurring expressions may be
  coded as a macro for future use or stored and recalled via named memory
  locations.
<h1 class="Sh" title="Sh" id="REQUIRED_ARGUMENTS"><a class="selflink" href="#REQUIRED_ARGUMENTS">REQUIRED
  ARGUMENTS</a></h1>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b><i>operand</i></b></dt>
  <dd class="It-tag">If <i>operand</i> can be opened as a file it will be read
      as a grid file. If not a file, it is interpreted as a numerical constant
      or a special symbol (see below).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><i>outgrdfile</i></b></dt>
  <dd class="It-tag">The name of a 2-D grid file that will hold the final
      result. (See GRID FILE FORMATS below).</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="OPTIONAL_ARGUMENTS"><a class="selflink" href="#OPTIONAL_ARGUMENTS">OPTIONAL
  ARGUMENTS</a></h1>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-A</b><i>min_area</i>[/<i>min_level</i>/<i>max_level</i>][<b>+ag</b>|<b>i</b>|<b>s</b>|<b>S</b>][<b>+r</b>|<b>l</b>][<b>+p</b><i>percent</i>]</dt>
  <dd class="It-tag">Features with an area smaller than <i>min_area</i> in km^2
      or of hierarchical level that is lower than <i>min_level</i> or higher
      than <i>max_level</i> will not be plotted [Default is 0/0/4 (all
      features)]. Level 2 (lakes) contains regular lakes and wide river bodies
      which we normally include as lakes; append <b>+r</b> to just get
      river-lakes or <b>+l</b> to just get regular lakes. By default
      (<b>+ai</b>) we select the ice shelf boundary as the coastline for
      Antarctica; append <b>+ag</b> to instead select the ice grounding line as
      coastline. For expert users who wish to print their own Antarctica
      coastline and islands via <i>psxy</i> you can use <b>+as</b> to skip all
      GSHHG features below 60S or <b>+aS</b> to instead skip all features north
      of 60S. Finally, append <b>+p</b><i>percent</i> to exclude polygons whose
      percentage area of the corresponding full-resolution feature is less than
      <i>percent</i>. See GSHHG INFORMATION below for more details. ( <b>-A</b>
      is only relevant to the <b>LDISTG</b> operator)</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D</b><i>resolution</i>[<b>+</b>]</dt>
  <dd class="It-tag">Selects the resolution of the data set to use with the
      operator LDISTG (( <b>f</b>)ull, (<b>h</b>)igh, (<b>i</b>)ntermediate,
      (<b>l</b>)ow, and (<b>c</b>)rude). The resolution drops off by 80% between
      data sets [Default is <b>l</b>]. Append <b>+</b> to automatically select a
      lower resolution should the one requested not be available [abort if not
      found].</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-I</b><i>xinc</i>[<i>unit</i>][<b>+e</b>|<b>n</b>][/<i>yinc</i>[<i>unit</i>][<b>+e</b>|<b>n</b>]]</dt>
  <dd class="It-tag"><i>x_inc</i> [and optionally <i>y_inc</i>] is the grid
      spacing. Optionally, append a suffix modifier. <b>Geographical (degrees)
      coordinates</b>: Append <b>m</b> to indicate arc minutes or <b>s</b> to
      indicate arc seconds. If one of the units <b>e</b>, <b>f</b>, <b>k</b>,
      <b>M</b>, <b>n</b> or <b>u</b> is appended instead, the increment is
      assumed to be given in meter, foot, km, Mile, nautical mile or US survey
      foot, respectively, and will be converted to the equivalent degrees
      longitude at the middle latitude of the region (the conversion depends on
      PROJ_ELLIPSOID). If <i>y_inc</i> is given but set to 0 it will be reset
      equal to <i>x_inc</i>; otherwise it will be converted to degrees latitude.
      <b>All coordinates</b>: If <b>+e</b> is appended then the corresponding
      max <i>x</i> (<i>east</i>) or <i>y</i> (<i>north</i>) may be slightly
      adjusted to fit exactly the given increment [by default the increment may
      be adjusted slightly to fit the given domain]. Finally, instead of giving
      an increment you may specify the <i>number of nodes</i> desired by
      appending <b>+n</b> to the supplied integer argument; the increment is
      then recalculated from the number of nodes and the domain. The resulting
      increment value depends on whether you have selected a gridline-registered
      or pixel-registered grid; see App-file-formats for details. Note: if
      <b>-R</b> <i>grdfile</i> is used then the grid spacing has already been
      initialized; use <b>-I</b> to override the values.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M</b></dt>
  <dd class="It-tag">By default any derivatives calculated are in z_units/ x(or
      y)_units. However, the user may choose this option to convert dx,dy in
      degrees of longitude,latitude into meters using a flat Earth
      approximation, so that gradients are in z_units/meter.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-N</b></dt>
  <dd class="It-tag">Turn off strict domain match checking when multiple grids
      are manipulated [Default will insist that each grid domain is within 1e-4
      * grid_spacing of the domain of the first grid listed].</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R</b><i>xmin</i>/<i>xmax</i>/<i>ymin</i>/<i>ymax</i>[<b>+r</b>][<b>+u</b><i>unit</i>]
    (more &#x2026;)</dt>
  <dd class="It-tag">Specify the region of interest.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b>[<i>level</i>] (more &#x2026;)</dt>
  <dd class="It-tag">Select verbosity level [c].</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bi</b>[<i>ncols</i>][<b>t</b>] (more &#x2026;)</dt>
  <dd class="It-tag">Select native binary input. The binary input option only
      applies to the data files needed by operators <b>LDIST</b>, <b>PDIST</b>,
      and <b>INSIDE</b>.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-di</b><i>nodata</i> (more &#x2026;)</dt>
  <dd class="It-tag">Replace input columns that equal <i>nodata</i> with
    NaN.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b>[<b>i</b>|<b>o</b>]<i>colinfo</i> (more
    &#x2026;)</dt>
  <dd class="It-tag">Specify data types of input and/or output columns.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g</b>[<b>a</b>]<b>x</b>|<b>y</b>|<b>d</b>|<b>X</b>|<b>Y</b>|<b>D</b>|[<i>col</i>]<b>z</b>[+|-]<i>gap</i>[<b>u</b>]
    (more &#x2026;)</dt>
  <dd class="It-tag">Determine data gaps and line breaks.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b>[<b>i</b>|<b>o</b>][<i>n</i>][<b>+c</b>][<b>+d</b>][<b>+r</b><i>remark</i>][<b>+r</b><i>title</i>]
    (more &#x2026;)</dt>
  <dd class="It-tag">Skip or produce header record(s).</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b><i>cols</i>[<b>+l</b>][<b>+s</b><i>scale</i>][<b>+o</b><i>offset</i>][,<i>&#x2026;</i>]
    (more &#x2026;)</dt>
  <dd class="It-tag">Select input columns and transformations (0 is first
      column).</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b>[<b>b</b>|<b>c</b>|<b>l</b>|<b>n</b>][<b>+a</b>][<b>+b</b><i>BC</i>][<b>+c</b>][<b>+t</b><i>threshold</i>]
    (more &#x2026;)</dt>
  <dd class="It-tag">Select interpolation mode for grids.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b> (more &#x2026;)</dt>
  <dd class="It-tag">Set pixel node registration [gridline]. Only used with
      <b>-R</b> <b>-I</b>.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-x</b>[[-]<i>n</i>] (more &#x2026;)</dt>
  <dd class="It-tag">Limit number of cores used in multi-threaded algorithms
      (OpenMP required).</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-^</b> or just <b>-</b></dt>
  <dd class="It-tag">Print a short message about the syntax of the command, then
      exits (NOTE: on Windows just use <b>-</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-+</b> or just <b>+</b></dt>
  <dd class="It-tag">Print an extensive usage (help) message, including the
      explanation of any module-specific option (but not the GMT common
      options), then exits.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-?</b> or no arguments</dt>
  <dd class="It-tag">Print a complete usage (help) message, including the
      explanation of all options, then exits.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="OPERATORS"><a class="selflink" href="#OPERATORS">OPERATORS</a></h1>
Choose among the following 209 operators. &#x201C;args&#x201D; are the number of
  input and output arguments.
<table class="tbl">
  <colgroup>
    <col style="width: 15.00ex;"/>
    <col style="width: 4.00ex;"/>
    <col style="width: 88.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>Operator</td>
    <td>args</td>
    <td>Returns</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ABS</b></td>
    <td>1 1</td>
    <td>abs (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ACOS</b></td>
    <td>1 1</td>
    <td>acos (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ACOSH</b></td>
    <td>1 1</td>
    <td>acosh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ACOT</b></td>
    <td>1 1</td>
    <td>acot (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ACSC</b></td>
    <td>1 1</td>
    <td>acsc (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ADD</b></td>
    <td>2 1</td>
    <td>A + B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>AND</b></td>
    <td>2 1</td>
    <td>B if A == NaN, else A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ARC</b></td>
    <td>2 1</td>
    <td>Return arc(A,B) on [0 pi]</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>AREA</b></td>
    <td>0 1</td>
    <td>Area of each gridnode cell (in km^2 if geographic)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ASEC</b></td>
    <td>1 1</td>
    <td>asec (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ASIN</b></td>
    <td>1 1</td>
    <td>asin (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ASINH</b></td>
    <td>1 1</td>
    <td>asinh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ATAN</b></td>
    <td>1 1</td>
    <td>atan (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ATAN2</b></td>
    <td>2 1</td>
    <td>atan2 (A, B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ATANH</b></td>
    <td>1 1</td>
    <td>atanh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BCDF</b></td>
    <td>3 1</td>
    <td>Binomial cumulative distribution function for p = A, n = B, and x =
      C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BPDF</b></td>
    <td>3 1</td>
    <td>Binomial probability density function for p = A, n = B, and x = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BEI</b></td>
    <td>1 1</td>
    <td>bei (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BER</b></td>
    <td>1 1</td>
    <td>ber (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITAND</b></td>
    <td>2 1</td>
    <td>A &amp; B (bitwise AND operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITLEFT</b></td>
    <td>2 1</td>
    <td>A &lt;&lt; B (bitwise left-shift operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITNOT</b></td>
    <td>1 1</td>
    <td>~A (bitwise NOT operator, i.e., return two&#x2019;s complement)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITOR</b></td>
    <td>2 1</td>
    <td>A | B (bitwise OR operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITRIGHT</b></td>
    <td>2 1</td>
    <td>A &gt;&gt; B (bitwise right-shift operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITTEST</b></td>
    <td>2 1</td>
    <td>1 if bit B of A is set, else 0 (bitwise TEST operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITXOR</b></td>
    <td>2 1</td>
    <td>A ^ B (bitwise XOR operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CAZ</b></td>
    <td>2 1</td>
    <td>Cartesian azimuth from grid nodes to stack x,y (i.e., A, B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CBAZ</b></td>
    <td>2 1</td>
    <td>Cartesian back-azimuth from grid nodes to stack x,y (i.e., A, B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CDIST</b></td>
    <td>2 1</td>
    <td>Cartesian distance between grid nodes and stack x,y (i.e., A, B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CDIST2</b></td>
    <td>2 1</td>
    <td>As CDIST but only to nodes that are != 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CEIL</b></td>
    <td>1 1</td>
    <td>ceil (A) (smallest integer &gt;= A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CHICRIT</b></td>
    <td>2 1</td>
    <td>Chi-squared critical value for alpha = A and nu = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CHICDF</b></td>
    <td>2 1</td>
    <td>Chi-squared cumulative distribution function for chi2 = A and nu =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CHIPDF</b></td>
    <td>2 1</td>
    <td>Chi-squared probability density function for chi2 = A and nu = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COMB</b></td>
    <td>2 1</td>
    <td>Combinations n_C_r, with n = A and r = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CORRCOEFF</b></td>
    <td>2 1</td>
    <td>Correlation coefficient r(A, B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COS</b></td>
    <td>1 1</td>
    <td>cos (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COSD</b></td>
    <td>1 1</td>
    <td>cos (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COSH</b></td>
    <td>1 1</td>
    <td>cosh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COT</b></td>
    <td>1 1</td>
    <td>cot (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COTD</b></td>
    <td>1 1</td>
    <td>cot (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CSC</b></td>
    <td>1 1</td>
    <td>csc (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CSCD</b></td>
    <td>1 1</td>
    <td>csc (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CURV</b></td>
    <td>1 1</td>
    <td>Curvature of A (Laplacian)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>D2DX2</b></td>
    <td>1 1</td>
    <td>d^2(A)/dx^2 2nd derivative</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>D2DY2</b></td>
    <td>1 1</td>
    <td>d^2(A)/dy^2 2nd derivative</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>D2DXY</b></td>
    <td>1 1</td>
    <td>d^2(A)/dxdy 2nd derivative</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>D2R</b></td>
    <td>1 1</td>
    <td>Converts Degrees to Radians</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DDX</b></td>
    <td>1 1</td>
    <td>d(A)/dx Central 1st derivative</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DDY</b></td>
    <td>1 1</td>
    <td>d(A)/dy Central 1st derivative</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DEG2KM</b></td>
    <td>1 1</td>
    <td>Converts Spherical Degrees to Kilometers</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DENAN</b></td>
    <td>2 1</td>
    <td>Replace NaNs in A with values from B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DILOG</b></td>
    <td>1 1</td>
    <td>dilog (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DIV</b></td>
    <td>2 1</td>
    <td>A / B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DUP</b></td>
    <td>1 2</td>
    <td>Places duplicate of A on the stack</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ECDF</b></td>
    <td>2 1</td>
    <td>Exponential cumulative distribution function for x = A and lambda =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ECRIT</b></td>
    <td>2 1</td>
    <td>Exponential distribution critical value for alpha = A and lambda =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EPDF</b></td>
    <td>2 1</td>
    <td>Exponential probability density function for x = A and lambda = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ERF</b></td>
    <td>1 1</td>
    <td>Error function erf (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ERFC</b></td>
    <td>1 1</td>
    <td>Complementary Error function erfc (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EQ</b></td>
    <td>2 1</td>
    <td>1 if A == B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ERFINV</b></td>
    <td>1 1</td>
    <td>Inverse error function of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EXCH</b></td>
    <td>2 2</td>
    <td>Exchanges A and B on the stack</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EXP</b></td>
    <td>1 1</td>
    <td>exp (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FACT</b></td>
    <td>1 1</td>
    <td>A! (A factorial)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EXTREMA</b></td>
    <td>1 1</td>
    <td>Local Extrema: +2/-2 is max/min, +1/-1 is saddle with max/min in x, 0
      elsewhere</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FCDF</b></td>
    <td>3 1</td>
    <td>F cumulative distribution function for F = A, nu1 = B, and nu2 = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FCRIT</b></td>
    <td>3 1</td>
    <td>F distribution critical value for alpha = A, nu1 = B, and nu2 = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FLIPLR</b></td>
    <td>1 1</td>
    <td>Reverse order of values in each row</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FLIPUD</b></td>
    <td>1 1</td>
    <td>Reverse order of values in each column</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FLOOR</b></td>
    <td>1 1</td>
    <td>floor (A) (greatest integer &lt;= A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FMOD</b></td>
    <td>2 1</td>
    <td>A % B (remainder after truncated division)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FPDF</b></td>
    <td>3 1</td>
    <td>F probability density function for F = A, nu1 = B, and nu2 = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>GE</b></td>
    <td>2 1</td>
    <td>1 if A &gt;= B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>GT</b></td>
    <td>2 1</td>
    <td>1 if A &gt; B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>HYPOT</b></td>
    <td>2 1</td>
    <td>hypot (A, B) = sqrt (A*A + B*B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>I0</b></td>
    <td>1 1</td>
    <td>Modified Bessel function of A (1st kind, order 0)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>I1</b></td>
    <td>1 1</td>
    <td>Modified Bessel function of A (1st kind, order 1)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>IFELSE</b></td>
    <td>3 1</td>
    <td>B if A != 0, else C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>IN</b></td>
    <td>2 1</td>
    <td>Modified Bessel function of A (1st kind, order B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>INRANGE</b></td>
    <td>3 1</td>
    <td>1 if B &lt;= A &lt;= C, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>INSIDE</b></td>
    <td>1 1</td>
    <td>1 when inside or on polygon(s) in A, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>INV</b></td>
    <td>1 1</td>
    <td>1 / A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ISFINITE</b></td>
    <td>1 1</td>
    <td>1 if A is finite, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ISNAN</b></td>
    <td>1 1</td>
    <td>1 if A == NaN, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>J0</b></td>
    <td>1 1</td>
    <td>Bessel function of A (1st kind, order 0)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>J1</b></td>
    <td>1 1</td>
    <td>Bessel function of A (1st kind, order 1)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>JN</b></td>
    <td>2 1</td>
    <td>Bessel function of A (1st kind, order B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>K0</b></td>
    <td>1 1</td>
    <td>Modified Kelvin function of A (2nd kind, order 0)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>K1</b></td>
    <td>1 1</td>
    <td>Modified Bessel function of A (2nd kind, order 1)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>KEI</b></td>
    <td>1 1</td>
    <td>kei (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>KER</b></td>
    <td>1 1</td>
    <td>ker (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>KM2DEG</b></td>
    <td>1 1</td>
    <td>Converts Kilometers to Spherical Degrees</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>KN</b></td>
    <td>2 1</td>
    <td>Modified Bessel function of A (2nd kind, order B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>KURT</b></td>
    <td>1 1</td>
    <td>Kurtosis of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LCDF</b></td>
    <td>1 1</td>
    <td>Laplace cumulative distribution function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LCRIT</b></td>
    <td>1 1</td>
    <td>Laplace distribution critical value for alpha = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LDIST</b></td>
    <td>1 1</td>
    <td>Compute minimum distance (in km if -fg) from lines in multi-segment
      ASCII file A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LDIST2</b></td>
    <td>2 1</td>
    <td>As LDIST, from lines in ASCII file B but only to nodes where A != 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LDISTG</b></td>
    <td>0 1</td>
    <td>As LDIST, but operates on the GSHHG dataset (see -A, -D for
      options).</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LE</b></td>
    <td>2 1</td>
    <td>1 if A &lt;= B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LOG</b></td>
    <td>1 1</td>
    <td>log (A) (natural log)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LOG10</b></td>
    <td>1 1</td>
    <td>log10 (A) (base 10)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LOG1P</b></td>
    <td>1 1</td>
    <td>log (1+A) (accurate for small A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LOG2</b></td>
    <td>1 1</td>
    <td>log2 (A) (base 2)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LMSSCL</b></td>
    <td>1 1</td>
    <td>LMS scale estimate (LMS STD) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LMSSCLW</b></td>
    <td>2 1</td>
    <td>Weighted LMS scale estimate (LMS STD) of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LOWER</b></td>
    <td>1 1</td>
    <td>The lowest (minimum) value of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LPDF</b></td>
    <td>1 1</td>
    <td>Laplace probability density function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LRAND</b></td>
    <td>2 1</td>
    <td>Laplace random noise with mean A and std. deviation B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LT</b></td>
    <td>2 1</td>
    <td>1 if A &lt; B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MAD</b></td>
    <td>1 1</td>
    <td>Median Absolute Deviation (L1 STD) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MAX</b></td>
    <td>2 1</td>
    <td>Maximum of A and B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MEAN</b></td>
    <td>1 1</td>
    <td>Mean value of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MEANW</b></td>
    <td>2 1</td>
    <td>Weighted mean value of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MEDIAN</b></td>
    <td>1 1</td>
    <td>Median value of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MEDIANW</b></td>
    <td>2 1</td>
    <td>Weighted median value of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MIN</b></td>
    <td>2 1</td>
    <td>Minimum of A and B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MOD</b></td>
    <td>2 1</td>
    <td>A mod B (remainder after floored division)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MODE</b></td>
    <td>1 1</td>
    <td>Mode value (Least Median of Squares) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MODEW</b></td>
    <td>2 1</td>
    <td>Weighted mode value (Least Median of Squares) of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MUL</b></td>
    <td>2 1</td>
    <td>A * B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NAN</b></td>
    <td>2 1</td>
    <td>NaN if A == B, else A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NEG</b></td>
    <td>1 1</td>
    <td>-A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NEQ</b></td>
    <td>2 1</td>
    <td>1 if A != B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NORM</b></td>
    <td>1 1</td>
    <td>Normalize (A) so max(A)-min(A) = 1</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NOT</b></td>
    <td>1 1</td>
    <td>NaN if A == NaN, 1 if A == 0, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NRAND</b></td>
    <td>2 1</td>
    <td>Normal, random values with mean A and std. deviation B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>OR</b></td>
    <td>2 1</td>
    <td>NaN if B == NaN, else A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PCDF</b></td>
    <td>2 1</td>
    <td>Poisson cumulative distribution function for x = A and lambda = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PDIST</b></td>
    <td>1 1</td>
    <td>Compute minimum distance (in km if -fg) from points in ASCII file A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PDIST2</b></td>
    <td>2 1</td>
    <td>As PDIST, from points in ASCII file B but only to nodes where A !=
      0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PERM</b></td>
    <td>2 1</td>
    <td>Permutations n_P_r, with n = A and r = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PLM</b></td>
    <td>3 1</td>
    <td>Associated Legendre polynomial P(A) degree B order C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PLMg</b></td>
    <td>3 1</td>
    <td>Normalized associated Legendre polynomial P(A) degree B order C
      (geophysical convention)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>POINT</b></td>
    <td>1 2</td>
    <td>Compute mean x and y from ASCII file A and place them on the stack</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>POP</b></td>
    <td>1 0</td>
    <td>Delete top element from the stack</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>POW</b></td>
    <td>2 1</td>
    <td>A ^ B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PPDF</b></td>
    <td>2 1</td>
    <td>Poisson distribution P(x,lambda), with x = A and lambda = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PQUANT</b></td>
    <td>2 1</td>
    <td>The B&#x2019;th Quantile (0-100%) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PQUANTW</b></td>
    <td>3 1</td>
    <td>The C&#x2019;th weighted quantile (0-100%) of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PSI</b></td>
    <td>1 1</td>
    <td>Psi (or Digamma) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PV</b></td>
    <td>3 1</td>
    <td>Legendre function Pv(A) of degree v = real(B) + imag(C)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>QV</b></td>
    <td>3 1</td>
    <td>Legendre function Qv(A) of degree v = real(B) + imag(C)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>R2</b></td>
    <td>2 1</td>
    <td>R2 = A^2 + B^2</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>R2D</b></td>
    <td>1 1</td>
    <td>Convert Radians to Degrees</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RAND</b></td>
    <td>2 1</td>
    <td>Uniform random values between A and B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RCDF</b></td>
    <td>1 1</td>
    <td>Rayleigh cumulative distribution function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RCRIT</b></td>
    <td>1 1</td>
    <td>Rayleigh distribution critical value for alpha = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RINT</b></td>
    <td>1 1</td>
    <td>rint (A) (round to integral value nearest to A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RMS</b></td>
    <td>1 1</td>
    <td>Root-mean-square of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RMSW</b></td>
    <td>1 1</td>
    <td>Root-mean-square of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RPDF</b></td>
    <td>1 1</td>
    <td>Rayleigh probability density function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ROLL</b></td>
    <td>2 0</td>
    <td>Cyclicly shifts the top A stack items by an amount B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ROTX</b></td>
    <td>2 1</td>
    <td>Rotate A by the (constant) shift B in x-direction</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ROTY</b></td>
    <td>2 1</td>
    <td>Rotate A by the (constant) shift B in y-direction</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SDIST</b></td>
    <td>2 1</td>
    <td>Spherical (Great circle|geodesic) distance (in km) between nodes and
      stack (A, B) </td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SDIST2</b></td>
    <td>2 1</td>
    <td>As SDIST but only to nodes that are != 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SAZ</b></td>
    <td>2 1</td>
    <td>Spherical azimuth from grid nodes to stack lon, lat (i.e., A, B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SBAZ</b></td>
    <td>2 1</td>
    <td>Spherical back-azimuth from grid nodes to stack lon, lat (i.e., A,
      B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SEC</b></td>
    <td>1 1</td>
    <td>sec (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SECD</b></td>
    <td>1 1</td>
    <td>sec (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SIGN</b></td>
    <td>1 1</td>
    <td>sign (+1 or -1) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SIN</b></td>
    <td>1 1</td>
    <td>sin (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SINC</b></td>
    <td>1 1</td>
    <td>sinc (A) (sin (pi*A)/(pi*A))</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SIND</b></td>
    <td>1 1</td>
    <td>sin (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SINH</b></td>
    <td>1 1</td>
    <td>sinh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SKEW</b></td>
    <td>1 1</td>
    <td>Skewness of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SQR</b></td>
    <td>1 1</td>
    <td>A^2</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SQRT</b></td>
    <td>1 1</td>
    <td>sqrt (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>STD</b></td>
    <td>1 1</td>
    <td>Standard deviation of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>STDW</b></td>
    <td>2 1</td>
    <td>Weighted standard deviation of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>STEP</b></td>
    <td>1 1</td>
    <td>Heaviside step function: H(A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>STEPX</b></td>
    <td>1 1</td>
    <td>Heaviside step function in x: H(x-A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>STEPY</b></td>
    <td>1 1</td>
    <td>Heaviside step function in y: H(y-A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SUB</b></td>
    <td>2 1</td>
    <td>A - B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SUM</b></td>
    <td>1 1</td>
    <td>Sum of all values in A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TAN</b></td>
    <td>1 1</td>
    <td>tan (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TAND</b></td>
    <td>1 1</td>
    <td>tan (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TANH</b></td>
    <td>1 1</td>
    <td>tanh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TAPER</b></td>
    <td>2 1</td>
    <td>Unit weights cosine-tapered to zero within A and B of x and y grid
      margins</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TCDF</b></td>
    <td>2 1</td>
    <td>Student&#x2019;s t cumulative distribution function for t = A, and nu =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TCRIT</b></td>
    <td>2 1</td>
    <td>Student&#x2019;s t distribution critical value for alpha = A and nu =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TN</b></td>
    <td>2 1</td>
    <td>Chebyshev polynomial Tn(-1&lt;t&lt;+1,n), with t = A, and n = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TPDF</b></td>
    <td>2 1</td>
    <td>Student&#x2019;s t probability density function for t = A, and nu =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TRIM</b></td>
    <td>3 1</td>
    <td>Alpha-trim C to NaN if values fall in tails A and B (in percentage)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>UPPER</b></td>
    <td>1 1</td>
    <td>The highest (maximum) value of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>VAR</b></td>
    <td>1 1</td>
    <td>Variance of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>VARW</b></td>
    <td>2 1</td>
    <td>Weighted variance of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>WCDF</b></td>
    <td>3 1</td>
    <td>Weibull cumulative distribution function for x = A, scale = B, and shape
      = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>WCRIT</b></td>
    <td>3 1</td>
    <td>Weibull distribution critical value for alpha = A, scale = B, and shape
      = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>WPDF</b></td>
    <td>3 1</td>
    <td>Weibull density distribution P(x,scale,shape), with x = A, scale = B,
      and shape = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>WRAP</b></td>
    <td>1 1</td>
    <td>wrap A in radians onto [-pi,pi]</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>XOR</b></td>
    <td>2 1</td>
    <td>0 if A == NaN and B == NaN, NaN if B == NaN, else A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>Y0</b></td>
    <td>1 1</td>
    <td>Bessel function of A (2nd kind, order 0)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>Y1</b></td>
    <td>1 1</td>
    <td>Bessel function of A (2nd kind, order 1)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>YLM</b></td>
    <td>2 2</td>
    <td>Re and Im orthonormalized spherical harmonics degree A order B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>YLMg</b></td>
    <td>2 2</td>
    <td>Cos and Sin normalized spherical harmonics degree A order B (geophysical
      convention)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>YN</b></td>
    <td>2 1</td>
    <td>Bessel function of A (2nd kind, order B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ZCDF</b></td>
    <td>1 1</td>
    <td>Normal cumulative distribution function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ZPDF</b></td>
    <td>1 1</td>
    <td>Normal probability density function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ZCRIT</b></td>
    <td>1 1</td>
    <td>Normal distribution critical value for alpha = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<h1 class="Sh" title="Sh" id="SYMBOLS"><a class="selflink" href="#SYMBOLS">SYMBOLS</a></h1>
The following symbols have special meaning:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 49.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PI</b></td>
    <td>3.1415926&#x2026;</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>E</b></td>
    <td>2.7182818&#x2026;</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EULER</b></td>
    <td>0.5772156&#x2026;</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EPS_F</b></td>
    <td>1.192092896e-07 (single precision epsilon</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>XMIN</b></td>
    <td>Minimum x value</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>XMAX</b></td>
    <td>Maximum x value</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>XRANGE</b></td>
    <td>Range of x values</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>XINC</b></td>
    <td>x increment</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NX</b></td>
    <td>The number of x nodes</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>YMIN</b></td>
    <td>Minimum y value</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>YMAX</b></td>
    <td>Maximum y value</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>YRANGE</b></td>
    <td>Range of y values</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>YINC</b></td>
    <td>y increment</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NY</b></td>
    <td>The number of y nodes</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>X</b></td>
    <td>Grid with x-coordinates</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>Y</b></td>
    <td>Grid with y-coordinates</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>XNORM</b></td>
    <td>Grid with normalized [-1 to +1] x-coordinates</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>YNORM</b></td>
    <td>Grid with normalized [-1 to +1] y-coordinates</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>XCOL</b></td>
    <td>Grid with column numbers 0, 1, &#x2026;, NX-1</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>YROW</b></td>
    <td>Grid with row numbers 0, 1, &#x2026;, NY-1</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NODE</b></td>
    <td>Grid with node numbers 0, 1, &#x2026;, (NX*NY)-1</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<h1 class="Sh" title="Sh" id="NOTES_ON_OPERATORS"><a class="selflink" href="#NOTES_ON_OPERATORS">NOTES
  ON OPERATORS</a></h1>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">For Cartesian grids the operators <b>MEAN</b>,
      <b>MEDIAN</b>, <b>MODE</b>, <b>LMSSCL</b>, <b>MAD</b>, <b>PQUANT</b>,
      <b>RMS</b>, <b>STD</b>, and <b>VAR</b> return the expected value from the
      given matrix. However, for geographic grids we perform a spherically
      weighted calculation where each node value is weighted by the geographic
      area represented by that node.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">The operator <b>SDIST</b> calculates spherical distances in
      km between the (lon, lat) point on the stack and all node positions in the
      grid. The grid domain and the (lon, lat) point are expected to be in
      degrees. Similarly, the <b>SAZ</b> and <b>SBAZ</b> operators calculate
      spherical azimuth and back-azimuths in degrees, respectively. The
      operators <b>LDIST</b> and <b>PDIST</b> compute spherical distances in km
      if <b>-fg</b> is set or implied, else they return Cartesian distances.
      Note: If the current PROJ_ELLIPSOID is ellipsoidal then geodesics are used
      in calculations of distances, which can be slow. You can trade speed with
      accuracy by changing the algorithm used to compute the geodesic (see
      PROJ_GEODESIC).
    <div style="height: 1.00em;">&#x00A0;</div>
    The operator <b>LDISTG</b> is a version of <b>LDIST</b> that operates on the
      GSHHG data. Instead of reading an ASCII file, it directly accesses one of
      the GSHHG data sets as determined by the <b>-D</b> and <b>-A</b>
    options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">The operator <b>POINT</b> reads a ASCII table, computes the
      mean x and mean y values and places these on the stack. If geographic data
      then we use the mean 3-D vector to determine the mean location.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">4.</dt>
  <dd class="It-tag">The operator <b>PLM</b> calculates the associated Legendre
      polynomial of degree L and order M (0 &lt;= M &lt;= L), and its argument
      is the sine of the latitude. <b>PLM</b> is not normalized and includes the
      Condon-Shortley phase (-1)^M. <b>PLMg</b> is normalized in the way that is
      most commonly used in geophysics. The C-S phase can be added by using -M
      as argument. <b>PLM</b> will overflow at higher degrees, whereas
      <b>PLMg</b> is stable until ultra high degrees (at least 3000).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">5.</dt>
  <dd class="It-tag">The operators <b>YLM</b> and <b>YLMg</b> calculate
      normalized spherical harmonics for degree L and order M (0 &lt;= M &lt;=
      L) for all positions in the grid, which is assumed to be in degrees.
      <b>YLM</b> and <b>YLMg</b> return two grids, the real (cosine) and
      imaginary (sine) component of the complex spherical harmonic. Use the
      <b>POP</b> operator (and <b>EXCH</b>) to get rid of one of them, or save
      both by giving two consecutive = file.nc calls.
    <div style="height: 1.00em;">&#x00A0;</div>
    The orthonormalized complex harmonics <b>YLM</b> are most commonly used in
      physics and seismology. The square of <b>YLM</b> integrates to 1 over a
      sphere. In geophysics, <b>YLMg</b> is normalized to produce unit power
      when averaging the cosine and sine terms (separately!) over a sphere
      (i.e., their squares each integrate to 4 pi). The Condon-Shortley phase
      (-1)^M is not included in <b>YLM</b> or <b>YLMg</b>, but it can be added
      by using -M as argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">6.</dt>
  <dd class="It-tag">All the derivatives are based on central finite
      differences, with natural boundary conditions, and are Cartesian
      derivatives.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">7.</dt>
  <dd class="It-tag">Files that have the same names as some operators, e.g.,
      <b>ADD</b>, <b>SIGN</b>, <b>=</b>, etc. should be identified by prepending
      the current directory (i.e., ./LOG).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">8.</dt>
  <dd class="It-tag">Piping of files is not allowed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">9.</dt>
  <dd class="It-tag">The stack depth limit is hard-wired to 100.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">10.</dt>
  <dd class="It-tag">All functions expecting a positive radius (e.g.,
      <b>LOG</b>, <b>KEI</b>, etc.) are passed the absolute value of their
      argument. (9) The bitwise operators ( <b>BITAND</b>, <b>BITLEFT</b>,
      <b>BITNOT</b>, <b>BITOR</b>, <b>BITRIGHT</b>, <b>BITTEST</b>, and
      <b>BITXOR</b>) convert a grid&#x2019;s single precision values to unsigned
      32-bit ints to perform the bitwise operations. Consequently, the largest
      whole integer value that can be stored in a float grid is 2^24 or
      16,777,216. Any higher result will be masked to fit in the lower 24 bits.
      Thus, bit operations are effectively limited to 24 bit. All bitwise
      operators return NaN if given NaN arguments or bit-settings &lt;= 0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">11.</dt>
  <dd class="It-tag">When OpenMP support is compiled in, a few operators will
      take advantage of the ability to spread the load onto several cores. At
      present, the list of such operators is: <b>LDIST</b>, <b>LDIST2</b>,
      <b>PDIST</b>, <b>PDIST2</b>, <b>SAZ</b>, <b>SBAZ</b>, <b>SDIST</b>,
      <b>YLM</b>, and <b>grd_YLMg</b>.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="GRID_VALUES_PRECISION"><a class="selflink" href="#GRID_VALUES_PRECISION">GRID
  VALUES PRECISION</a></h1>
Regardless of the precision of the input data, GMT programs that create grid
  files will internally hold the grids in 4-byte floating point arrays. This is
  done to conserve memory and furthermore most if not all real data can be
  stored using 4-byte floating point values. Data with higher precision (i.e.,
  double precision values) will lose that precision once GMT operates on the
  grid or writes out new grids. To limit loss of precision when processing data
  you should always consider normalizing the data prior to processing.
<h1 class="Sh" title="Sh" id="GRID_FILE_FORMATS"><a class="selflink" href="#GRID_FILE_FORMATS">GRID
  FILE FORMATS</a></h1>
By default GMT writes out grid as single precision floats in a COARDS-complaint
  netCDF file format. However, GMT is able to produce grid files in many other
  commonly used grid file formats and also facilitates so called
  &#x201C;packing&#x201D; of grids, writing out floating point data as 1- or
  2-byte integers. (more &#x2026;)
<h1 class="Sh" title="Sh" id="GEOGRAPHICAL_AND_TIME_COORDINATES"><a class="selflink" href="#GEOGRAPHICAL_AND_TIME_COORDINATES">GEOGRAPHICAL
  AND TIME COORDINATES</a></h1>
When the output grid type is netCDF, the coordinates will be labeled
  &#x201C;longitude&#x201D;, &#x201C;latitude&#x201D;, or &#x201C;time&#x201D;
  based on the attributes of the input data or grid (if any) or on the <b>-f</b>
  or <b>-R</b> options. For example, both <b>-f0x</b> <b>-f1t</b> and
  <b>-R</b>90w/90e/0t/3t will result in a longitude/time grid. When the x, y, or
  z coordinate is time, it will be stored in the grid as relative time since
  epoch as specified by TIME_UNIT and TIME_EPOCH in the gmt.conf file or on the
  command line. In addition, the <b>unit</b> attribute of the time variable will
  indicate both this unit and epoch.
<h1 class="Sh" title="Sh" id="STORE,_RECALL_AND_CLEAR"><a class="selflink" href="#STORE,_RECALL_AND_CLEAR">STORE,
  RECALL AND CLEAR</a></h1>
You may store intermediate calculations to a named variable that you may recall
  and place on the stack at a later time. This is useful if you need access to a
  computed quantity many times in your expression as it will shorten the overall
  expression and improve readability. To save a result you use the special
  operator <b>STO</b>@<i>label</i>, where <i>label</i> is the name you choose to
  give the quantity. To recall the stored result to the stack at a later time,
  use [ <b>RCL</b>]@<i>label</i>, i.e., <b>RCL</b> is optional. To clear memory
  you may use <b>CLR</b>@<i>label</i>. Note that <b>STO</b> and <b>CLR</b> leave
  the stack unchanged.
<h1 class="Sh" title="Sh" id="GSHHS_INFORMATION"><a class="selflink" href="#GSHHS_INFORMATION">GSHHS
  INFORMATION</a></h1>
The coastline database is GSHHG (formerly GSHHS) which is compiled from three
  sources: World Vector Shorelines (WVS), CIA World Data Bank II (WDBII), and
  Atlas of the Cryosphere (AC, for Antarctica only). Apart from Antarctica, all
  level-1 polygons (ocean-land boundary) are derived from the more accurate WVS
  while all higher level polygons (level 2-4, representing land/lake,
  lake/island-in-lake, and island-in-lake/lake-in-island-in-lake boundaries) are
  taken from WDBII. The Antarctica coastlines come in two flavors: ice-front or
  grounding line, selectable via the <b>-A</b> option. Much processing has taken
  place to convert WVS, WDBII, and AC data into usable form for GMT: assembling
  closed polygons from line segments, checking for duplicates, and correcting
  for crossings between polygons. The area of each polygon has been determined
  so that the user may choose not to draw features smaller than a minimum area
  (see <b>-A</b>); one may also limit the highest hierarchical level of polygons
  to be included (4 is the maximum). The 4 lower-resolution databases were
  derived from the full resolution database using the Douglas-Peucker
  line-simplification algorithm. The classification of rivers and borders follow
  that of the WDBII. See the GMT Cookbook and Technical Reference Appendix K for
  further details.
<h1 class="Sh" title="Sh" id="MACROS"><a class="selflink" href="#MACROS">MACROS</a></h1>
Users may save their favorite operator combinations as macros via the file
  <i>grdmath.macros</i> in their current or user directory. The file may contain
  any number of macros (one per record); comment lines starting with # are
  skipped. The format for the macros is <b>name</b> = <b>arg1 arg2 &#x2026;
  arg2</b> : <i>comment</i> where <b>name</b> is how the macro will be used.
  When this operator appears on the command line we simply replace it with the
  listed argument list. No macro may call another macro. As an example, the
  following macro expects three arguments (radius x0 y0) and sets the modes that
  are inside the given circle to 1 and those outside to 0:
<div style="height: 1.00em;">&#x00A0;</div>
INCIRCLE = CDIST EXCH DIV 1 LE : usage: r x y INCIRCLE to return 1 inside circle
<div style="height: 1.00em;">&#x00A0;</div>
Note: Because geographic or time constants may be present in a macro, it is
  required that the optional comment flag (:) must be followed by a space.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
To compute all distances to north pole:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt grdmath -Rg -I1 0 90 SDIST = dist_to_NP.nc
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To take log10 of the average of 2 files, use
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt grdmath file1.nc file2.nc ADD 0.5 MUL LOG10 = file3.nc
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Given the file ages.nc, which holds seafloor ages in m.y., use the relation
  depth(in m) = 2500 + 350 * sqrt (age) to estimate normal seafloor depths:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt grdmath ages.nc SQRT 350 MUL 2500 ADD = depths.nc
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To find the angle a (in degrees) of the largest principal stress from the stress
  tensor given by the three files s_xx.nc s_yy.nc, and s_xy.nc from the relation
  tan (2*a) = 2 * s_xy / (s_xx - s_yy), use
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt grdmath 2 s_xy.nc MUL s_xx.nc s_yy.nc SUB DIV ATAN 2 DIV = direction.nc
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To calculate the fully normalized spherical harmonic of degree 8 and order 4 on
  a 1 by 1 degree world map, using the real amplitude 0.4 and the imaginary
  amplitude 1.1:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt grdmath -R0/360/-90/90 -I1 8 4 YLM 1.1 MUL EXCH 0.4 MUL ADD = harm.nc
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To extract the locations of local maxima that exceed 100 mGal in the file
  faa.nc:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt grdmath faa.nc DUP EXTREMA 2 EQ MUL DUP 100 GT MUL 0 NAN = z.nc
gmt grd2xyz z.nc -s &gt; max.xyz
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To demonstrate the use of named variables, consider this radial wave where we
  store and recall the normalized radial arguments in radians:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt grdmath -R0/10/0/10 -I0.25 5 5 CDIST 2 MUL PI MUL 5 DIV STO@r COS @r SIN MUL = wave.nc
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To creat a dumb file saved as a 32 bits float GeoTiff using GDAL, run
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt grdmath -Rd -I10 X Y MUL = lixo.tiff=gd:GTiff
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<h1 class="Sh" title="Sh" id="REFERENCES"><a class="selflink" href="#REFERENCES">REFERENCES</a></h1>
Abramowitz, M., and I. A. Stegun, 1964, <i>Handbook of Mathematical</i>
  <i>Functions</i>, Applied Mathematics Series, vol. 55, Dover, New York.
<div style="height: 1.00em;">&#x00A0;</div>
Holmes, S. A., and W. E. Featherstone, 2002, A unified approach to the Clenshaw
  summation and the recursive computation of very high degree and order
  normalised associated Legendre functions. <i>Journal of Geodesy</i>, 76,
  279-299.
<div style="height: 1.00em;">&#x00A0;</div>
Press, W. H., S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery, 1992,
  <i>Numerical Recipes</i>, 2nd edition, Cambridge Univ., New York.
<div style="height: 1.00em;">&#x00A0;</div>
Spanier, J., and K. B. Oldman, 1987, <i>An Atlas of Functions</i>, Hemisphere
  Publishing Corp.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
gmt, gmtmath, grd2xyz, grdedit, grdinfo, xyz2grd
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2017, P. Wessel, W. H. F. Smith, R. Scharroo, J. Luis, and F. Wobbe</div>
<table class="foot">
  <tr>
    <td class="foot-date">June 24, 2017</td>
    <td class="foot-os">5.4.2</td>
  </tr>
</table>
</body>
</html>
