<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>DOCKER(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DOCKER(1)</td>
    <td class="head-vol">JUNE 2014</td>
    <td class="head-rtitle">DOCKER(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
docker-run - Run a command in a new container
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>docker run</b> [ <b>-a</b>|<b>--attach</b>[=<i>[]</i>]] [
  <b>--add-host</b>[=<i>[]</i>]] [
  <b>--blkio-weight</b>[=<i>[BLKIO-WEIGHT]</i>]] [
  <b>--blkio-weight-device</b>[= <i>[]</i>]] [ <b>--cpu-shares</b>[=<i>0</i>]] [
  <b>--cap-add</b>[=<i>[]</i>]] [ <b>--cap-drop</b>[=<i>[]</i>]] [
  <b>--cgroup-parent</b>[= <i>CGROUP-PATH</i>]] [
  <b>--cidfile</b>[=<i>CIDFILE</i>]] [ <b>--cpu-period</b>[=<i>0</i>]] [
  <b>--cpu-quota</b>[= <i>0</i>]] [ <b>--cpuset-cpus</b>[=<i>CPUSET-CPUS</i>]] [
  <b>--cpuset-mems</b>[=<i>CPUSET-MEMS</i>]] [ <b>-d</b>|<b>--detach</b>] [
  <b>--detach-keys</b>[= <i>[]</i>]] [ <b>--device</b>[=<i>[]</i>]] [
  <b>--device-read-bps</b>[= <i>[]</i>]] [
  <b>--device-read-iops</b>[=<i>[]</i>]] [
  <b>--device-write-bps</b>[=<i>[]</i>]] [
  <b>--device-write-iops</b>[=<i>[]</i>]] [ <b>--dns</b>[=<i>[]</i>]] [
  <b>--dns-opt</b>[= <i>[]</i>]] [ <b>--dns-search</b>[=<i>[]</i>]] [
  <b>-e</b>|<b>--env</b>[=<i>[]</i>]] [ <b>--entrypoint</b>[=<i>ENTRYPOINT</i>]]
  [ <b>--env-file</b>[=<i>[]</i>]] [ <b>--expose</b>[=<i>[]</i>]] [
  <b>--group-add</b>[= <i>[]</i>]] [
  <b>-h</b>|<b>--hostname</b>[=<i>HOSTNAME</i>]] [ <b>--help</b>] [
  <b>-i</b>|<b>--interactive</b>] [ <b>--ip</b>[=<i>IPv4-ADDRESS</i>]] [
  <b>--ip6</b>[= <i>IPv6-ADDRESS</i>]] [ <b>--ipc</b>[=<i>IPC</i>]] [
  <b>--isolation</b>[= <i>default</i>]] [
  <b>--kernel-memory</b>[=<i>KERNEL-MEMORY</i>]] [
  <b>-l</b>|<b>--label</b>[=<i>[]</i>]] [ <b>--label-file</b>[=<i>[]</i>]] [
  <b>--link</b>[= <i>[]</i>]] [ <b>--link-local-ip</b>[=<i>[]</i>]] [
  <b>--log-driver</b>[= <i>[]</i>]] [ <b>--log-opt</b>[=<i>[]</i>]] [
  <b>-m</b>|<b>--memory</b>[=<i>MEMORY</i>]] [
  <b>--mac-address</b>[=<i>MAC-ADDRESS</i>]] [
  <b>--memory-reservation</b>[=<i>MEMORY-RESERVATION</i>]] [
  <b>--memory-swap</b>[= <i>LIMIT</i>]] [
  <b>--memory-swappiness</b>[=<i>MEMORY-SWAPPINESS</i>]] [
  <b>--name</b>[=<i>NAME</i>]] [ <b>--network-alias</b>[=<i>[]</i>]] [
  <b>--network</b>[= <i>&quot;bridge&quot;</i>]] [ <b>--oom-kill-disable</b>] [
  <b>--oom-score-adj</b>[=<i>0</i>]] [ <b>-P</b>|<b>--publish-all</b>] [
  <b>-p</b>| <b>--publish</b>[=<i>[]</i>]] [ <b>--pid</b>[=<i>[PID]</i>]] [
  <b>--userns</b>[= <i>[]</i>]] [ <b>--pids-limit</b>[=<i>PIDS_LIMIT</i>]] [
  <b>--privileged</b>] [ <b>--read-only</b>] [
  <b>--restart</b>[=<i>RESTART</i>]] [ <b>--rm</b>] [
  <b>--security-opt</b>[=<i>[]</i>]] [ <b>--storage-opt</b>[=<i>[]</i>]] [
  <b>--stop-signal</b>[= <i>SIGNAL</i>]] [ <b>--shm-size</b>[=<i>[]</i>]] [
  <b>--sig-proxy</b>[= <i>true</i>]] [ <b>--sysctl</b>[=<i>[]</i>]] [
  <b>-t</b>|<b>--tty</b>] [
  <b>--tmpfs</b>[=<i>[CONTAINER-DIR[:&lt;OPTIONS&gt;]</i>]] [
  <b>-u</b>|<b>--user</b>[= <i>USER</i>]] [ <b>--ulimit</b>[=<i>[]</i>]] [
  <b>--uts</b>[= <i>[]</i>]] [
  <b>-v</b>|<b>--volume</b>[=<i>[[HOST-DIR:]CONTAINER-DIR[:OPTIONS]]</i>]] [
  <b>--volume-driver</b>[= <i>DRIVER</i>]] [ <b>--volumes-from</b>[=<i>[]</i>]]
  [ <b>-w</b>|<b>--workdir</b>[=<i>WORKDIR</i>]] IMAGE [COMMAND] [ARG...]
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Run a process in a new container. <b>docker run</b> starts a process with its
  own file system, its own networking, and its own isolated process tree. The
  IMAGE which starts the process may define defaults related to the process that
  will be run in the container, the networking to expose, and more, but
  <b>docker run</b> gives final control to the operator or administrator who
  starts the container from the image. For that reason <b>docker run</b> has
  more options than any other Docker command.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
If the IMAGE is not already loaded then <b>docker run</b> will pull the IMAGE,
  and all image dependencies, from the repository in the same way running
  <b>docker</b> <b>pull</b> IMAGE, before it starts the container from that
  image.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<b>-a</b>, <b>--attach</b>=[]
<br/>
 Attach to STDIN, STDOUT or STDERR.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
In foreground mode (the default when <b>-d</b> is not specified), <b>docker
  run</b> can start the process in the container and attach the console to the
  process's standard input, output, and standard error. It can even pretend to
  be a TTY (this is what most commandline executables expect) and pass along
  signals. The <b>-a</b> option can be set for each of stdin, stdout, and
  stderr.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--add-host</b>=[]
<br/>
 Add a custom host-to-IP mapping (host:ip)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Add a line to /etc/hosts. The format is hostname:ip. The <b>--add-host</b>
  option can be set multiple times.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--blkio-weight</b>=<i>0</i>
<br/>
 Block IO weight (relative weight) accepts a weight value between 10 and 1000.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--blkio-weight-device</b>=[]
<br/>
 Block IO weight (relative device weight, format: <b></b>DEVICE_NAME:WEIGHT).
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--cpu-shares</b>=<i>0</i>
<br/>
 CPU shares (relative weight)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
By default, all containers get the same proportion of CPU cycles. This
  proportion can be modified by changing the container's CPU share weighting
  relative to the weighting of all other running containers.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
To modify the proportion from the default of 1024, use the <b>--cpu-shares</b>
  flag to set the weighting to 2 or higher.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The proportion will only apply when CPU-intensive processes are running. When
  tasks in one container are idle, other containers can use the left-over CPU
  time. The actual amount of CPU time will vary depending on the number of
  containers running on the system.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
For example, consider three containers, one has a cpu-share of 1024 and two
  others have a cpu-share setting of 512. When processes in all three containers
  attempt to use 100% of CPU, the first container would receive 50% of the total
  CPU time. If you add a fourth container with a cpu-share of 1024, the first
  container only gets 33% of the CPU. The remaining containers receive 16.5%,
  16.5% and 33% of the CPU.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
On a multi-core system, the shares of CPU time are distributed over all CPU
  cores. Even if a container is limited to less than 100% of CPU time, it can
  use 100% of each individual CPU core.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
For example, consider a system with more than three cores. If you start one
  container <b>{C0}</b> with <b>-c=512</b> running one process, and another
  container <b>{C1}</b> with <b>-c=1024</b> running two processes, this can
  result in the following division of CPU shares:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
PID    container    CPU CPU share
100    {C0}     0   100% of CPU0
101    {C1}     1   100% of CPU1
102    {C1}     2   100% of CPU2
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--cap-add</b>=[]
<br/>
 Add Linux capabilities
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--cap-drop</b>=[]
<br/>
 Drop Linux capabilities
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--cgroup-parent</b>=&quot;&quot;
<br/>
 Path to cgroups under which the cgroup for the container will be created. If
  the path is not absolute, the path is considered to be relative to the cgroups
  path of the init process. Cgroups will be created if they do not already
  exist.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--cidfile</b>=&quot;&quot;
<br/>
 Write the container ID to the file
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--cpu-period</b>=<i>0</i>
<br/>
 Limit the CPU CFS (Completely Fair Scheduler) period
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Limit the container's CPU usage. This flag tell the kernel to restrict the
  container's CPU usage to the period you specify.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--cpuset-cpus</b>=&quot;&quot;
<br/>
 CPUs in which to allow execution (0-3, 0,1)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--cpuset-mems</b>=&quot;&quot;
<br/>
 Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on
  NUMA systems.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
If you have four memory nodes on your system (0-3), use <b></b>--cpuset-mems=0,1
  then processes in your Docker container will only use memory from the first
  two memory nodes.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--cpu-quota</b>=<i>0</i>
<br/>
 Limit the CPU CFS (Completely Fair Scheduler) quota
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Limit the container's CPU usage. By default, containers run with the full CPU
  resource. This flag tell the kernel to restrict the container's CPU usage to
  the quota you specify.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-d</b>, <b>--detach</b>=<i>true</i>|<i>false</i>
<br/>
 Detached mode: run the container in the background and print the new container
  ID. The default is <i>false</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
At any time you can run <b>docker ps</b> in the other shell to view a list of
  the running containers. You can reattach to a detached container with
  <b>docker attach</b>. If you choose to run a container in the detached mode,
  then you cannot use the <b>-rm</b> option.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
When attached in the tty mode, you can detach from the container (and leave it
  running) using a configurable key sequence. The default sequence is
  <b></b>CTRL-p CTRL-q. You configure the key sequence using the
  <b>--detach-keys</b> option or a configuration file. See <b>config-json(5)</b>
  for documentation on using a configuration file.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--detach-keys</b>=&quot;&quot;
<br/>
 Override the key sequence for detaching a container. Format is a single
  character <b></b>[a-Z] or <b></b>ctrl-&lt;value&gt; where <b></b>&lt;value&gt;
  is one of: <b></b>a-z, <b></b>@, <b></b>^, <b></b>[, <b></b>, or <b></b>_.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--device</b>=[]
<br/>
 Add a host device to the container (e.g. --device=/dev/sdc:/dev/xvdc:rwm)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--device-read-bps</b>=[]
<br/>
 Limit read rate from a device (e.g. --device-read-bps=/dev/sda:1mb)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--device-read-iops</b>=[]
<br/>
 Limit read rate from a device (e.g. --device-read-iops=/dev/sda:1000)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--device-write-bps</b>=[]
<br/>
 Limit write rate to a device (e.g. --device-write-bps=/dev/sda:1mb)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--device-write-iops</b>=[]
<br/>
 Limit write rate to a device (e.g. --device-write-iops=/dev/sda:1000)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--dns-search</b>=[]
<br/>
 Set custom DNS search domains (Use --dns-search=. if you don't wish to set the
  search domain)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--dns-opt</b>=[]
<br/>
 Set custom DNS options
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--dns</b>=[]
<br/>
 Set custom DNS servers
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
This option can be used to override the DNS configuration passed to the
  container. Typically this is necessary when the host DNS configuration is
  invalid for the container (e.g., 127.0.0.1). When this is the case the
  <b>--dns</b> flags is necessary for every run.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-e</b>, <b>--env</b>=[]
<br/>
 Set environment variables
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
This option allows you to specify arbitrary environment variables that are
  available for the process that will be launched inside of the container.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--entrypoint</b>=&quot;&quot;
<br/>
 Overwrite the default ENTRYPOINT of the image
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
This option allows you to overwrite the default entrypoint of the image that is
  set in the Dockerfile. The ENTRYPOINT of an image is similar to a COMMAND
  because it specifies what executable to run when the container starts, but it
  is (purposely) more difficult to override. The ENTRYPOINT gives a container
  its default nature or behavior, so that when you set an ENTRYPOINT you can run
  the container as if it were that binary, complete with default options, and
  you can pass in more options via the COMMAND. But, sometimes an operator may
  want to run something else inside the container, so you can override the
  default ENTRYPOINT at runtime by using a <b>--entrypoint</b> and a string to
  specify the new ENTRYPOINT.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--env-file</b>=[]
<br/>
 Read in a line delimited file of environment variables
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--expose</b>=[]
<br/>
 Expose a port, or a range of ports (e.g. --expose=3300-3310) informs Docker
  that the container listens on the specified network ports at runtime. Docker
  uses this information to interconnect containers using links and to set up
  port redirection on the host system.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--group-add</b>=[]
<br/>
 Add additional groups to run as
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-h</b>, <b>--hostname</b>=&quot;&quot;
<br/>
 Container host name
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Sets the container host name that is available inside the container.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--help</b>
<br/>
 Print usage statement
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-i</b>, <b>--interactive</b>=<i>true</i>|<i>false</i>
<br/>
 Keep STDIN open even if not attached. The default is <i>false</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
When set to true, keep stdin open even if not attached. The default is false.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--ip</b>=&quot;&quot;
<br/>
 Sets the container's interface IPv4 address (e.g. 172.23.0.9)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
It can only be used in conjunction with <b>--net</b> for user-defined networks
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--ip6</b>=&quot;&quot;
<br/>
 Sets the container's interface IPv6 address (e.g. 2001:db8::1b99)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
It can only be used in conjunction with <b>--net</b> for user-defined networks
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--ipc</b>=&quot;&quot;
<br/>
 Default is to create a private IPC namespace (POSIX SysV IPC) for the container
<br/>
 'container:&lt;name|id&gt;': reuses another container shared memory, semaphores
  and message queues
<br/>
 'host': use the host shared memory,semaphores and message queues inside the
  container. Note: the host mode gives the container full access to local shared
  memory and is therefore considered insecure.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--isolation</b>=&quot;<i>default</i>&quot;
<br/>
 Isolation specifies the type of isolation technology used by containers. Note
  that the default on Windows server is <b></b>process, and the default on
  Windows client is <b></b>hyperv. Linux only supports <b></b>default.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-l</b>, <b>--label</b>=[]
<br/>
 Set metadata on the container (e.g., --label com.example.key=value)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--kernel-memory</b>=&quot;&quot;
<br/>
 Kernel memory limit (format: <b></b>&lt;number&gt;[&lt;unit&gt;], where unit =
  b, k, m or g)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Constrains the kernel memory available to a container. If a limit of 0 is
  specified (not using <b></b>--kernel-memory), the container's kernel memory is
  not limited. If you specify a limit, it may be rounded up to a multiple of the
  operating system's page size and the value can be very large, millions of
  trillions.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--label-file</b>=[]
<br/>
 Read in a line delimited file of labels
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--link</b>=[]
<br/>
 Add link to another container in the form of &lt;name or id&gt;:alias or just
  &lt;name or id&gt; in which case the alias will match the name
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
If the operator uses <b>--link</b> when starting the new client container, then
  the client container can access the exposed port via a private networking
  interface. Docker will set some environment variables in the client container
  to help indicate which interface and port to use.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--link-local-ip</b>=[]
<br/>
 Add one or more link-local IPv4/IPv6 addresses to the container's interface
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--log-driver</b>=&quot;<i>json-file</i>|<i>syslog</i>|<i>journald</i>|<i>gelf</i>|<i>fluentd</i>|<i>awslogs</i>|<i>splunk</i>|<i>etwlogs</i>|<i>gcplogs</i>|<i>none</i>&quot;
<br/>
 Logging driver for the container. Default is defined by daemon
  <b></b>--log-driver flag.
<br/>
 <b>Warning</b>: the <b></b>docker logs command works only for the
  <b></b>json-file and
<br/>
 <b></b>journald logging drivers.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--log-opt</b>=[]
<br/>
 Logging driver specific options.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-m</b>, <b>--memory</b>=&quot;&quot;
<br/>
 Memory limit (format: &lt;number&gt;[&lt;unit&gt;], where unit = b, k, m or g)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Allows you to constrain the memory available to a container. If the host
  supports swap memory, then the <b>-m</b> memory setting can be larger than
  physical RAM. If a limit of 0 is specified (not using <b>-m</b>), the
  container's memory is not limited. The actual limit may be rounded up to a
  multiple of the operating system's page size (the value would be very large,
  that's millions of trillions).
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--memory-reservation</b>=&quot;&quot;
<br/>
 Memory soft limit (format: &lt;number&gt;[&lt;unit&gt;], where unit = b, k, m
  or g)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
After setting memory reservation, when the system detects memory contention or
  low memory, containers are forced to restrict their consumption to their
  reservation. So you should always set the value below <b>--memory</b>,
  otherwise the hard limit will take precedence. By default, memory reservation
  will be the same as memory limit.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--memory-swap</b>=&quot;LIMIT&quot;
<br/>
 A limit value equal to memory plus swap. Must be used with the <b>-m</b> (
  <b>--memory</b>) flag. The swap <b></b>LIMIT should always be larger than
  <b>-m</b> ( <b>--memory</b>) value. By default, the swap <b></b>LIMIT will be
  set to double the value of --memory.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The format of <b></b>LIMIT is <b></b>&lt;number&gt;[&lt;unit&gt;]. Unit can be
  <b></b>b (bytes), <b></b>k (kilobytes), <b></b>m (megabytes), or <b></b>g
  (gigabytes). If you don't specify a unit, <b></b>b is used. Set LIMIT to
  <b></b>-1 to enable unlimited swap.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--mac-address</b>=&quot;&quot;
<br/>
 Container MAC address (e.g. 92:d0:c6:0a:29:33)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Remember that the MAC address in an Ethernet network must be unique. The IPv6
  link-local address will be based on the device's MAC address according to
  RFC4862.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--name</b>=&quot;&quot;
<br/>
 Assign a name to the container
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The operator can identify a container in three ways:
<br/>
 UUID long identifier
  (&#x201C;f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778&#x201D;)
<br/>
 UUID short identifier (&#x201C;f78375b1c487&#x201D;)
<br/>
 Name (&#x201C;jonah&#x201D;)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The UUID identifiers come from the Docker daemon, and if a name is not assigned
  to the container with <b>--name</b> then the daemon will also generate a
  random string name. The name is useful when defining links (see <b>--link</b>)
  (or any other place you need to identify a container). This works for both
  background and foreground Docker containers.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--net</b>=&quot;<i>bridge</i>&quot;
<br/>
 Set the Network mode for the container
<br/>
 'bridge': create a network stack on the default Docker bridge
<br/>
 'none': no networking
<br/>
 'container:&lt;name|id&gt;': reuse another container's network stack
<br/>
 'host': use the Docker host network stack. Note: the host mode gives the
  container full access to local system services such as D-bus and is therefore
  considered insecure.
<br/>
 '&lt;network-name&gt;|&lt;network-id&gt;': connect to a user-defined network
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--network-alias</b>=[]
<br/>
 Add network-scoped alias for the container
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--oom-kill-disable</b>=<i>true</i>|<i>false</i>
<br/>
 Whether to disable OOM Killer for the container or not.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--oom-score-adj</b>=&quot;&quot;
<br/>
 Tune the host's OOM preferences for containers (accepts -1000 to 1000)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-P</b>, <b>--publish-all</b>=<i>true</i>|<i>false</i>
<br/>
 Publish all exposed ports to random ports on the host interfaces. The default
  is <i>false</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
When set to true publish all exposed ports to the host interfaces. The default
  is false. If the operator uses -P (or -p) then Docker will make the exposed
  port accessible on the host and the ports will be available to any client that
  can reach the host. When using -P, Docker will bind any exposed port to a
  random port on the host within an <i>ephemeral port range</i> defined by
  <b></b>/proc/sys/net/ipv4/ip_local_port_range. To find the mapping between the
  host ports and the exposed ports, use <b></b>docker port.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-p</b>, <b>--publish</b>=[]
<br/>
 Publish a container's port, or range of ports, to the host.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Format: <b></b>ip:hostPort:containerPort | ip::containerPort |
  hostPort:containerPort | containerPort Both hostPort and containerPort can be
  specified as a range of ports. When specifying ranges for both, the number of
  container ports in the range must match the number of host ports in the range.
  (e.g., <b></b>docker run -p 1234-1236:1222-1224 --name thisWorks -t busybox
  but not <b></b>docker run -p 1230-1236:1230-1240 --name
  RangeContainerPortsBiggerThanRangeHostPorts -t busybox) With ip: <b></b>docker
  run -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT --name CONTAINER -t someimage Use
  <b></b>docker port to see the actual mapping: <b></b>docker port CONTAINER
  $CONTAINERPORT
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--pid</b>=&quot;&quot;
<br/>
 Set the PID mode for the container
<br/>
 Default is to create a private PID namespace for the container
<br/>
 'container:&lt;name|id&gt;': join another container's PID namespace
<br/>
 'host': use the host's PID namespace for the container. Note: the host mode
  gives the container full access to local PID and is therefore considered
  insecure.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--userns</b>=&quot;&quot;
<br/>
 Set the usernamespace mode for the container when <b></b>userns-remap option is
  enabled.
<br/>
 <b>host</b>: use the host usernamespace and enable all privileged options
  (e.g., <b></b>pid=host or <b></b>--privileged).
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--pids-limit</b>=&quot;&quot;
<br/>
 Tune the container's pids limit. Set <b></b>-1 to have unlimited pids for the
  container.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--uts</b>=<i>host</i>
<br/>
 Set the UTS mode for the container
<br/>
 <b>host</b>: use the host's UTS namespace inside the container.
<br/>
 Note: the host mode gives the container access to changing the host's hostname
  and is therefore considered insecure.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--privileged</b>=<i>true</i>|<i>false</i>
<br/>
 Give extended privileges to this container. The default is <i>false</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
By default, Docker containers are &#x201C;unprivileged&#x201D; (=false) and
  cannot, for example, run a Docker daemon inside the Docker container. This is
  because by default a container is not allowed to access any devices. A
  &#x201C;privileged&#x201D; container is given access to all devices.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
When the operator executes <b>docker run --privileged</b>, Docker will enable
  access to all devices on the host as well as set some configuration in
  AppArmor to allow the container nearly all the same access to the host as
  processes running outside of a container on the host.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--read-only</b>=<i>true</i>|<i>false</i>
<br/>
 Mount the container's root filesystem as read only.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
By default a container will have its root filesystem writable allowing processes
  to write files anywhere. By specifying the <b></b>--read-only flag the
  container will have its root filesystem mounted as read only prohibiting any
  writes.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--restart</b>=&quot;<i>no</i>&quot;
<br/>
 Restart policy to apply when a container exits (no, on-failure[:max-retry],
  always, unless-stopped).
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--rm</b>=<i>true</i>|<i>false</i>
<br/>
 Automatically remove the container when it exits (incompatible with -d). The
  default is <i>false</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--security-opt</b>=[]
<br/>
 Security Options
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
&quot;label=user:USER&quot;   : Set the label user for the container
&quot;label=role:ROLE&quot;   : Set the label role for the container
&quot;label=type:TYPE&quot;   : Set the label type for the container
&quot;label=level:LEVEL&quot; : Set the label level for the container
&quot;label=disable&quot;     : Turn off label confinement for the container
&quot;no-new-privileges&quot; : Disable container processes from gaining additional privileges
<div class="Pp"></div>
&quot;seccomp=unconfined&quot; : Turn off seccomp confinement for the container
&quot;seccomp=profile.json :  White listed syscalls seccomp Json file to be used as a seccomp filter
<div class="Pp"></div>
&quot;apparmor=unconfined&quot; : Turn off apparmor confinement for the container
&quot;apparmor=your-profile&quot; : Set the apparmor confinement profile for the container
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--storage-opt</b>=[]
<br/>
 Storage driver options per container
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
$ docker run -it --storage-opt size=120G fedora /bin/bash
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
This (size) will allow to set the container rootfs size to 120G at creation
  time. User cannot pass a size less than the Default BaseFS Size.
<br/>
 This option is only available for the <b></b>devicemapper, <b></b>btrfs, and
  <b></b>zfs graph drivers.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--stop-signal</b>=<i>SIGTERM</i>
<br/>
 Signal to stop a container. Default is SIGTERM.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--shm-size</b>=&quot;&quot;
<br/>
 Size of <b></b>/dev/shm. The format is <b></b>&lt;number&gt;&lt;unit&gt;.
<br/>
 <b></b>number must be greater than <b></b>0. Unit is optional and can be
  <b></b>b (bytes), <b></b>k (kilobytes), <b></b>m(megabytes), or <b></b>g
  (gigabytes).
<br/>
 If you omit the unit, the system uses bytes. If you omit the size entirely, the
  system uses <b></b>64m.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--sysctl</b>=SYSCTL
<br/>
 Configure namespaced kernel parameters at runtime
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
IPC Namespace - current sysctls allowed:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
kernel.msgmax, kernel.msgmnb, kernel.msgmni, kernel.sem, kernel.shmall,
  kernel.shmmax, kernel.shmmni, kernel.shm_rmid_forced
<br/>
 Sysctls beginning with fs.mqueue.*
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
If you use the <b></b>--ipc=host option these sysctls will not be allowed.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Network Namespace - current sysctls allowed:
<br/>
 Sysctls beginning with net.*
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
If you use the <b></b>--net=host option these sysctls will not be allowed.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--sig-proxy</b>=<i>true</i>|<i>false</i>
<br/>
 Proxy received signals to the process (non-TTY mode only). SIGCHLD, SIGSTOP,
  and SIGKILL are not proxied. The default is <i>true</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--memory-swappiness</b>=&quot;&quot;
<br/>
 Tune a container's memory swappiness behavior. Accepts an integer between 0 and
  100.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-t</b>, <b>--tty</b>=<i>true</i>|<i>false</i>
<br/>
 Allocate a pseudo-TTY. The default is <i>false</i>.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
When set to true Docker can allocate a pseudo-tty and attach to the standard
  input of any container. This can be used, for example, to run a throwaway
  interactive shell. The default is false.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The <b>-t</b> option is incompatible with a redirection of the docker client
  standard input.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--tmpfs</b>=[] Create a tmpfs mount
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Mount a temporary filesystem ( <b></b>tmpfs) mount into a container, for
  example:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
$ docker run -d --tmpfs /tmp:rw,size=787448k,mode=1777 my_image
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
This command mounts a <b></b>tmpfs at <b></b>/tmp within the container. The
  supported mount options are the same as the Linux default <b></b>mount flags.
  If you do not specify any options, the systems uses the following options:
  <b></b>rw,noexec,nosuid,nodev,size=65536k.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-u</b>, <b>--user</b>=&quot;&quot;
<br/>
 Sets the username or UID used and optionally the groupname or GID for the
  specified command.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The followings examples are all valid:
<br/>
 --user [user | user:group | uid | uid:gid | user:gid | uid:group ]
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Without this argument the command will be run as root in the container.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--ulimit</b>=[]
<br/>
 Ulimit options
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-v</b>|<b>--volume</b>[=<i>[[HOST-DIR:]CONTAINER-DIR[:OPTIONS]]</i>]
<br/>
 Create a bind mount. If you specify, <b></b>-v /HOST-DIR:/CONTAINER-DIR, Docker
<br/>
 bind mounts <b></b>/HOST-DIR in the host to <b></b>/CONTAINER-DIR in the Docker
<br/>
 container. If 'HOST-DIR' is omitted, Docker automatically creates the new
<br/>
 volume on the host. The <b></b>OPTIONS are a comma delimited list and can be:
<dl class="Bl-tag">
  <dt class="It-tag">0[step?]</dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    item [rw|ro] item [z|Z] item [
      <b></b>[r]shared|<b></b>[r]slave|<b></b>[r]private] item [nocopy]</dd>
</dl>
<div class="Pp"></div>
The <b></b>CONTAINER-DIR must be an absolute path such as <b></b>/src/docs. The
  <b></b>HOST-DIR can be an absolute path or a <b></b>name value. A <b></b>name
  value must start with an alphanumeric character, followed by <b></b>a-z0-9,
  <b></b>_ (underscore), <b></b>. (period) or <b></b>- (hyphen). An absolute
  path starts with a <b></b>/ (forward slash).
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
If you supply a <b></b>HOST-DIR that is an absolute path, Docker bind-mounts to
  the path you specify. If you supply a <b></b>name, Docker creates a named
  volume by that <b></b>name. For example, you can specify either <b></b>/foo or
  <b></b>foo for a <b></b>HOST-DIR value. If you supply the <b></b>/foo value,
  Docker creates a bind-mount. If you supply the <b></b>foo specification,
  Docker creates a named volume.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
You can specify multiple <b>-v</b> options to mount one or more mounts to a
  container. To use these same mounts in other containers, specify the
  <b>--volumes-from</b> option also.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
You can add <b></b>:ro or <b></b>:rw suffix to a volume to mount it read-only or
  read-write mode, respectively. By default, the volumes are mounted read-write.
  See examples.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Labeling systems like SELinux require that proper labels are placed on volume
  content mounted into a container. Without a label, the security system might
  prevent the processes running inside the container from using the content. By
  default, Docker does not change the labels set by the OS.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
To change a label in the container context, you can add either of two suffixes
  <b></b>:z or <b></b>:Z to the volume mount. These suffixes tell Docker to
  relabel file objects on the shared volumes. The <b></b>z option tells Docker
  that two containers share the volume content. As a result, Docker labels the
  content with a shared content label. Shared volume labels allow all containers
  to read/write content. The <b></b>Z option tells Docker to label the content
  with a private unshared label. Only the current container can use a private
  volume.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
By default bind mounted volumes are <b></b>private. That means any mounts done
  inside container will not be visible on host and vice-a-versa. One can change
  this behavior by specifying a volume mount propagation property. Making a
  volume <b></b>shared mounts done under that volume inside container will be
  visible on host and vice-a-versa. Making a volume <b></b>slave enables only
  one way mount propagation and that is mounts done on host under that volume
  will be visible inside container but not the other way around.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
To control mount propagation property of volume one can use <b></b>:[r]shared,
  <b></b>:[r]slave or <b></b>:[r]private propagation flag. Propagation property
  can be specified only for bind mounted volumes and not for internal volumes or
  named volumes. For mount propagation to work source mount point (mount point
  where source dir is mounted on) has to have right propagation properties. For
  shared volumes, source mount point has to be shared. And for slave volumes,
  source mount has to be either shared or slave.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Use <b></b>df &lt;source-dir&gt; to figure out the source mount and then use
  <b></b>findmnt -o TARGET,PROPAGATION &lt;source-mount-dir&gt; to figure out
  propagation properties of source mount. If <b></b>findmnt utility is not
  available, then one can look at mount entry for source mount point in
  <b></b>/proc/self/mountinfo. Look at <b></b>optional fields and see if any
  propagaion properties are specified. <b></b>shared:X means mount is
  <b></b>shared, <b></b>master:X means mount is <b></b>slave and if nothing is
  there that means mount is <b></b>private.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
To change propagation properties of a mount point use <b></b>mount command. For
  example, if one wants to bind mount source directory <b></b>/foo one can do
  <b></b>mount --bind /foo /foo and <b></b>mount --make-private --make-shared
  /foo. This will convert /foo into a <b></b>shared mount point. Alternatively
  one can directly change propagation properties of source mount. Say <b></b>/
  is source mount for <b></b>/foo, then use <b></b>mount --make-shared / to
  convert <b></b>/ into a <b></b>shared mount.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>Note</b>: When using systemd to manage the Docker daemon's start and stop, in
  the systemd unit file there is an option to control mount propagation for the
  Docker daemon itself, called <b></b>MountFlags. The value of this setting may
  cause Docker to not see mount propagation changes made on the mount point. For
  example, if this value is <b></b>slave, you may not be able to use the
  <b></b>shared or <b></b>rshared propagation on a volume.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
To disable automatic copying of data from the container path to the volume, use
  the <b></b>nocopy flag. The <b></b>nocopy flag can be set on bind mounts and
  named volumes.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--volume-driver</b>=&quot;&quot;
<br/>
 Container's volume driver. This driver creates volumes specified either from
<br/>
 a Dockerfile's <b></b>VOLUME instruction or from the <b></b>docker run -v flag.
<br/>
 See <b>docker-volume-create(1)</b> for full details.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>--volumes-from</b>=[]
<br/>
 Mount volumes from the specified container(s)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Mounts already mounted volumes from a source container onto another
<br/>
 container. You must supply the source's container-id. To share
<br/>
 a volume, use the <b>--volumes-from</b> option when running
<br/>
 the target container. You can share volumes even if the source container
<br/>
 is not running.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
By default, Docker mounts the volumes in the same mode (read-write or
<br/>
 read-only) as it is mounted in the source container. Optionally, you
<br/>
 can change this by suffixing the container-id with either the <b></b>:ro or
<br/>
 <b></b>:rw keyword.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
If the location of the volume from the source container overlaps with
<br/>
 data residing on a target container, then the volume hides
<br/>
 that data on the target.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>-w</b>, <b>--workdir</b>=&quot;&quot;
<br/>
 Working directory inside the container
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The default working directory for running binaries within a container is the
  root directory (/). The developer can set a different default with the
  Dockerfile WORKDIR instruction. The operator can override the working
  directory by using the <b>-w</b> option.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Exit_Status"><a class="selflink" href="#Exit_Status">Exit
  Status</a></h1>
The exit code from <b></b>docker run gives information about why the container
  failed to run or why it exited. When <b></b>docker run exits with a non-zero
  code, the exit codes follow the <b></b>chroot standard, see below:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b></b><i>125</i><b></b><i> if the error is with Docker daemon
  </i><b></b><i>itself</i> <b></b><i></i>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
$ docker run --foo busybox; echo $?
# flag provided but not defined: --foo
  See 'docker run --help'.
  125
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b></b><i>126</i><b></b><i> if the </i><b></b><i>contained command</i><b></b><i>
  cannot be invoked</i>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
$ docker run busybox /etc; echo $?
# exec: &quot;/etc&quot;: permission denied
  docker: Error response from daemon: Contained command could not be invoked
  126
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b></b><i>127</i><b></b><i> if the </i><b></b><i>contained command</i><b></b><i>
  cannot be found</i>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
$ docker run busybox foo; echo $?
# exec: &quot;foo&quot;: executable file not found in $PATH
  docker: Error response from daemon: Contained command not found or does not exist
  127
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b></b><i>Exit code</i><b></b><i> of </i><b></b><i>contained
  command</i><b></b><i> otherwise</i>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
$ docker run busybox /bin/sh -c 'exit 3' 
# 3
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
<h1 class="Sh" title="Sh" id="Running_container_in_read-only_mode"><a class="selflink" href="#Running_container_in_read-only_mode">Running
  container in read-only mode</a></h1>
During container image development, containers often need to write to the image
  content. Installing packages into /usr, for example. In production,
  applications seldom need to write to the image. Container applications write
  to volumes if they need to write to file systems at all. Applications can be
  made more secure by running them in read-only mode using the --read-only
  switch. This protects the containers image from modification. Read only
  containers may still need to write temporary data. The best way to handle this
  is to mount tmpfs directories on /run and /tmp.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run --read-only --tmpfs /run --tmpfs /tmp -i -t fedora /bin/bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Exposing_log_messages_from_the_container_to_the_host's_log"><a class="selflink" href="#Exposing_log_messages_from_the_container_to_the_host's_log">Exposing
  log messages from the container to the host's log</a></h1>
If you want messages that are logged in your container to show up in the host's
  syslog/journal then you should bind mount the /dev/log directory as follows.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run -v /dev/log:/dev/log -i -t fedora /bin/bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
From inside the container you can test this by sending a message to the log.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
(bash)# logger &quot;Hello from my container&quot;
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Then exit and check the journal.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# exit
<div class="Pp"></div>
# journalctl -b | grep Hello
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
This should list the message sent to logger.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Attaching_to_one_or_more_from_STDIN,_STDOUT,_STDERR"><a class="selflink" href="#Attaching_to_one_or_more_from_STDIN,_STDOUT,_STDERR">Attaching
  to one or more from STDIN, STDOUT, STDERR</a></h1>
If you do not specify -a then Docker will attach everything
  (stdin,stdout,stderr) you'd like to connect instead, as in:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run -a stdin -a stdout -i -t fedora /bin/bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Sharing_IPC_between_containers"><a class="selflink" href="#Sharing_IPC_between_containers">Sharing
  IPC between containers</a></h1>
Using shm_server.c available here:
  &#x27E8;https://www.cs.cf.ac.uk/Dave/C/node27.html&#x27E9;
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Testing <b></b>--ipc=host mode:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Host shows a shared memory segment with 7 pids attached, happens to be from
  httpd:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
 $ sudo ipcs -m
<div class="Pp"></div>
 ------ Shared Memory Segments --------
 key        shmid      owner      perms      bytes      nattch     status      
 0x01128e25 0          root       600        1000       7                       
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Now run a regular container, and it correctly does NOT see the shared memory
  segment from the host:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
 $ docker run -it shm ipcs -m
<div class="Pp"></div>
 ------ Shared Memory Segments --------
 key        shmid      owner      perms      bytes      nattch     status      
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Run a container with the new <b></b>--ipc=host option, and it now sees the
  shared memory segment from the host httpd:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
 $ docker run -it --ipc=host shm ipcs -m
<div class="Pp"></div>
 ------ Shared Memory Segments --------
 key        shmid      owner      perms      bytes      nattch     status      
 0x01128e25 0          root       600        1000       7                   
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Testing <b></b>--ipc=container:CONTAINERID mode:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Start a container with a program to create a shared memory segment:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
 $ docker run -it shm bash
 $ sudo shm/shm_server 
 $ sudo ipcs -m
<div class="Pp"></div>
 ------ Shared Memory Segments --------
 key        shmid      owner      perms      bytes      nattch     status      
 0x0000162e 0          root       666        27         1                       
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Create a 2nd container correctly shows no shared memory segment from 1st
  container:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
 $ docker run shm ipcs -m
<div class="Pp"></div>
 ------ Shared Memory Segments --------
 key        shmid      owner      perms      bytes      nattch     status      
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Create a 3rd container using the new --ipc=container:CONTAINERID option, now it
  shows the shared memory segment from the first:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
 $ docker run -it --ipc=container:ed735b2264ac shm ipcs -m
 $ sudo ipcs -m
<div class="Pp"></div>
 ------ Shared Memory Segments --------
 key        shmid      owner      perms      bytes      nattch     status      
 0x0000162e 0          root       666        27         1
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Linking_Containers"><a class="selflink" href="#Linking_Containers">Linking
  Containers</a></h1>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>Note</b>: This section describes linking between containers on the default
  (bridge) network, also known as &quot;legacy links&quot;. Using <b></b>--link
  on user-defined networks uses the DNS-based discovery, which does not add
  entries to <b></b>/etc/hosts, and does not set environment variables for
  discovery.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
The link feature allows multiple containers to communicate with each other. For
  example, a container whose Dockerfile has exposed port 80 can be run and named
  as follows:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run --name=link-test -d -i -t fedora/httpd
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
A second container, in this case called linker, can communicate with the httpd
  container, named link-test, by running with the
  <b>--link=&lt;name&gt;:&lt;alias&gt;</b>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run -t -i --link=link-test:lt --name=linker fedora /bin/bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Now the container linker is linked to container link-test with the alias lt.
  Running the <b>env</b> command in the linker container shows environment
  variables
<br/>
 with the LT (alias) context ( <b>LT_</b>)
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# env
HOSTNAME=668231cb0978
TERM=xterm
LT_PORT_80_TCP=tcp://172.17.0.3:80
LT_PORT_80_TCP_PORT=80
LT_PORT_80_TCP_PROTO=tcp
LT_PORT=tcp://172.17.0.3:80
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD=/
LT_NAME=/linker/lt
SHLVL=1
HOME=/
LT_PORT_80_TCP_ADDR=172.17.0.3
_=/usr/bin/env
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
When linking two containers Docker will use the exposed ports of the container
  to create a secure tunnel for the parent to access.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
If a container is connected to the default bridge network and <b></b>linked with
  other containers, then the container's <b></b>/etc/hosts file is updated with
  the linked container's name.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<b>Note</b> Since Docker may live update the container's <b></b>/etc/hosts file,
  there may be situations when processes inside the container can end up reading
  an empty or incomplete <b></b>/etc/hosts file. In most cases, retrying the
  read again should fix the problem.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Mapping_Ports_for_External_Usage"><a class="selflink" href="#Mapping_Ports_for_External_Usage">Mapping
  Ports for External Usage</a></h1>
The exposed port of an application can be mapped to a host port using the
  <b>-p</b> flag. For example, a httpd port 80 can be mapped to the host port
  8080 using the following:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run -p 8080:80 -d -i -t fedora/httpd
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Creating_and_Mounting_a_Data_Volume_Container"><a class="selflink" href="#Creating_and_Mounting_a_Data_Volume_Container">Creating
  and Mounting a Data Volume Container</a></h1>
Many applications require the sharing of persistent data across several
  containers. Docker allows you to create a Data Volume Container that other
  containers can mount from. For example, create a named container that contains
  directories /var/volume1 and /tmp/volume2. The image will need to contain
  these directories so a couple of RUN mkdir instructions might be required for
  you fedora-data image:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run --name=data -v /var/volume1 -v /tmp/volume2 -i -t fedora-data true
# docker run --volumes-from=data --name=fedora-container1 -i -t fedora bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Multiple --volumes-from parameters will bring together multiple data volumes
  from multiple containers. And it's possible to mount the volumes that came
  from the DATA container in yet another container via the fedora-container1
  intermediary container, allowing to abstract the actual data source from users
  of that data:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run --volumes-from=fedora-container1 --name=fedora-container2 -i -t fedora bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Mounting_External_Volumes"><a class="selflink" href="#Mounting_External_Volumes">Mounting
  External Volumes</a></h1>
To mount a host directory as a container volume, specify the absolute path to
  the directory and the absolute path for the container directory separated by a
  colon:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run -v /var/db:/data1 -i -t fedora bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
When using SELinux, be aware that the host has no knowledge of container SELinux
  policy. Therefore, in the above example, if SELinux policy is enforced, the
  <b></b>/var/db directory is not writable to the container. A &quot;Permission
  Denied&quot; message will occur and an avc: message in the host's syslog.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
To work around this, at time of writing this man page, the following command
  needs to be run in order for the proper SELinux policy type label to be
  attached to the host directory:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# chcon -Rt svirt_sandbox_file_t /var/db
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Now, writing to the /data1 volume in the container will be allowed and the
  changes will also be reflected on the host in /var/db.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Using_alternative_security_labeling"><a class="selflink" href="#Using_alternative_security_labeling">Using
  alternative security labeling</a></h1>
You can override the default labeling scheme for each container by specifying
  the <b></b>--security-opt flag. For example, you can specify the MCS/MLS
  level, a requirement for MLS systems. Specifying the level in the following
  command allows you to share the same content between containers.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run --security-opt label=level:s0:c100,c200 -i -t fedora bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
An MLS example might be:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run --security-opt label=level:TopSecret -i -t rhel7 bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
To disable the security labeling for this container versus running with the
  <b></b>--permissive flag, use the following command:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run --security-opt label=disable -i -t fedora bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
If you want a tighter security policy on the processes within a container, you
  can specify an alternate type for the container. You could run a container
  that is only allowed to listen on Apache ports by executing the following
  command:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
# docker run --security-opt label=type:svirt_apache_t -i -t centos bash
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Note:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
You would have to write policy defining a <b></b>svirt_apache_t type.
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Setting_device_weight"><a class="selflink" href="#Setting_device_weight">Setting
  device weight</a></h1>
If you want to set <b></b>/dev/sda device weight to <b></b>200, you can specify
  the device weight by <b></b>--blkio-weight-device flag. Use the following
  command:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
# docker run -it --blkio-weight-device &quot;/dev/sda:200&quot; ubuntu
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Specify_isolation_technology_for_container_(--isolation)"><a class="selflink" href="#Specify_isolation_technology_for_container_(--isolation)">Specify
  isolation technology for container (--isolation)</a></h1>
This option is useful in situations where you are running Docker containers on
  Microsoft Windows. The <b></b>--isolation &lt;value&gt; option sets a
  container's isolation technology. On Linux, the only supported is the
  <b></b>default option which uses Linux namespaces. These two commands are
  equivalent on Linux:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
$ docker run -d busybox top
$ docker run -d --isolation default busybox top
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
On Microsoft Windows, can take any of these values:
<dl class="Bl-tag">
  <dt class="It-tag">0[step?]</dt>
  <dd class="It-tag">
    <div style="height: 1.00em;">&#x00A0;</div>
    item <b></b>default: Use the value specified by the Docker daemon's
      <b></b>--exec-opt . If the <b></b>daemon does not specify an isolation
      technology, Microsoft Windows uses <b></b>process as its default value.
      item <b></b>process: Namespace isolation only. item <b></b>hyperv: Hyper-V
      hypervisor partition-based isolation.</dd>
</dl>
<div class="Pp"></div>
In practice, when running on Microsoft Windows without a <b></b>daemon option
  set, these two commands are equivalent:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
$ docker run -d --isolation default busybox top
$ docker run -d --isolation process busybox top
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
If you have set the <b></b>--exec-opt isolation=hyperv option on the Docker
  <b></b>daemon, any of these commands also result in <b></b>hyperv isolation:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
$ docker run -d --isolation default busybox top
$ docker run -d --isolation hyperv busybox top
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="Setting_Namespaced_Kernel_Parameters_(Sysctls)"><a class="selflink" href="#Setting_Namespaced_Kernel_Parameters_(Sysctls)">Setting
  Namespaced Kernel Parameters (Sysctls)</a></h1>
The <b></b>--sysctl sets namespaced kernel parameters (sysctls) in the
  container. For example, to turn on IP forwarding in the containers network
  namespace, run this command:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
$ docker run --sysctl net.ipv4.ip_forward=1 someimage
<div class="Pp"></div>
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Note:
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
Not all sysctls are namespaced. Docker does not support changing sysctls inside
  of a container that also modify the host system. As the kernel evolves we
  expect to see more sysctls become namespaced.
<div style="height: 1.00em;">&#x00A0;</div>
<div class="Pp"></div>
See the definition of the <b></b>--sysctl option above for the current list of
  supported sysctls.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="height: 1.00em;">&#x00A0;</div>
<h1 class="Sh" title="Sh" id="HISTORY"><a class="selflink" href="#HISTORY">HISTORY</a></h1>
April 2014, Originally compiled by William Henry (whenry at redhat dot com)
  based on docker.com source material and internal work. June 2014, updated by
  Sven Dowideit &#x27E8;SvenDowideit@home.org.au&#x27E9; July 2014, updated by
  Sven Dowideit &#x27E8;SvenDowideit@home.org.au&#x27E9; November 2015, updated
  by Sally O'Malley &#x27E8;somalley@redhat.com&#x27E9;</div>
<table class="foot">
  <tr>
    <td class="foot-date"> Docker User Manuals</td>
    <td class="foot-os">Docker Community</td>
  </tr>
</table>
</body>
</html>
