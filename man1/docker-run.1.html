<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:04:53 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DOCKER(1) JUNE 2014 DOCKER(1)</p>

<p style="margin-top: 1em">NAME <br>
docker-run - Run a command in a new container</p>

<p style="margin-top: 1em">SYNOPSIS <br>
docker run [-a|--attach[=[]]] [--add-host[=[]]]
[--blkio-weight[=[BLKIO-WEIGHT]]]
[--blkio-weight-device[=[]]] [--cpu-shares[=0]]
[--cap-add[=[]]] [--cap-drop[=[]]] <br>
[--cgroup-parent[=CGROUP-PATH]] [--cidfile[=CIDFILE]]
[--cpu-period[=0]] [--cpu-quota[=0]]
[--cpuset-cpus[=CPUSET-CPUS]] [--cpuset-mems[=CPUSET-MEMS]]
[-d|--detach] <br>
[--detach-keys[=[]]] [--device[=[]]]
[--device-read-bps[=[]]] [--device-read-iops[=[]]]
[--device-write-bps[=[]]] [--device-write-iops[=[]]]
[--dns[=[]]] [--dns-opt[=[]]] <br>
[--dns-search[=[]]] [-e|--env[=[]]]
[--entrypoint[=ENTRYPOINT]] [--env-file[=[]]]
[--expose[=[]]] [--group-add[=[]]]
[-h|--hostname[=HOSTNAME]] [--help] [-i|--interactive] <br>
[--ip[=IPv4-ADDRESS]] [--ip6[=IPv6-ADDRESS]] [--ipc[=IPC]]
[--isolation[=default]] [--kernel-memory[=KERNEL-MEMORY]]
[-l|--label[=[]]] [--label-file[=[]]] [--link[=[]]] <br>
[--link-local-ip[=[]]] [--log-driver[=[]]] [--log-opt[=[]]]
[-m|--memory[=MEMORY]] [--mac-address[=MAC-ADDRESS]]
[--memory-reservation[=MEMORY-RESERVATION]] [--mem&acirc;
<br>
ory-swap[=LIMIT]] [--memory-swappiness[=MEMORY-SWAPPINESS]]
[--name[=NAME]] [--network-alias[=[]]]
[--network[=&quot;bridge&quot;]] [--oom-kill-disable]
[--oom-score-adj[=0]] [-P|--pub&acirc; <br>
lish-all] [-p|--publish[=[]]] [--pid[=[PID]]]
[--userns[=[]]] [--pids-limit[=PIDS_LIMIT]] [--privileged]
[--read-only] [--restart[=RESTART]] [--rm]
[--security-opt[=[]]] [--stor&acirc; <br>
age-opt[=[]]] [--stop-signal[=SIGNAL]] [--shm-size[=[]]]
[--sig-proxy[=true]] [--sysctl[=[]]] [-t|--tty]
[--tmpfs[=[CONTAINER-DIR[:&lt;OPTIONS&gt;]]]
[-u|--user[=USER]] [--ulimit[=[]]] <br>
[--uts[=[]]]
[-v|--volume[=[[HOST-DIR:]CONTAINER-DIR[:OPTIONS]]]]
[--volume-driver[=DRIVER]] [--volumes-from[=[]]]
[-w|--workdir[=WORKDIR]] IMAGE [COMMAND] [ARG...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Run a process in a new container. docker run starts a
process with its own file system, its own networking, and
its own isolated process tree. The IMAGE which starts the
process <br>
may define defaults related to the process that will be run
in the container, the networking to expose, and more, but
docker run gives final control to the operator or
adminis&acirc; <br>
trator who starts the container from the image. For that
reason docker run has more options than any other Docker
command.</p>

<p style="margin-top: 1em">If the IMAGE is not already
loaded then docker run will pull the IMAGE, and all image
dependencies, from the repository in the same way running
docker pull IMAGE, before it <br>
starts the container from that image.</p>

<p style="margin-top: 1em">OPTIONS <br>
-a, --attach=[] <br>
Attach to STDIN, STDOUT or STDERR.</p>

<p style="margin-top: 1em">In foreground mode (the default
when -d is not specified), docker run can start the process
in the container and attach the console to the
process&rsquo;s standard input, output, and <br>
standard error. It can even pretend to be a TTY (this is
what most commandline executables expect) and pass along
signals. The -a option can be set for each of stdin, stdout,
and <br>
stderr.</p>

<p style="margin-top: 1em">--add-host=[] <br>
Add a custom host-to-IP mapping (host:ip)</p>

<p style="margin-top: 1em">Add a line to /etc/hosts. The
format is hostname:ip. The --add-host option can be set
multiple times.</p>

<p style="margin-top: 1em">--blkio-weight=0 <br>
Block IO weight (relative weight) accepts a weight value
between 10 and 1000.</p>

<p style="margin-top: 1em">--blkio-weight-device=[] <br>
Block IO weight (relative device weight, format:
DEVICE_NAME:WEIGHT).</p>

<p style="margin-top: 1em">--cpu-shares=0 <br>
CPU shares (relative weight)</p>

<p style="margin-top: 1em">By default, all containers get
the same proportion of CPU cycles. This proportion can be
modified by changing the container&rsquo;s CPU share
weighting relative to the weighting of all <br>
other running containers.</p>

<p style="margin-top: 1em">To modify the proportion from
the default of 1024, use the --cpu-shares flag to set the
weighting to 2 or higher.</p>

<p style="margin-top: 1em">The proportion will only apply
when CPU-intensive processes are running. When tasks in one
container are idle, other containers can use the left-over
CPU time. The actual amount <br>
of CPU time will vary depending on the number of containers
running on the system.</p>

<p style="margin-top: 1em">For example, consider three
containers, one has a cpu-share of 1024 and two others have
a cpu-share setting of 512. When processes in all three
containers attempt to use 100% of <br>
CPU, the first container would receive 50% of the total CPU
time. If you add a fourth container with a cpu-share of
1024, the first container only gets 33% of the CPU. The <br>
remaining containers receive 16.5%, 16.5% and 33% of the
CPU.</p>

<p style="margin-top: 1em">On a multi-core system, the
shares of CPU time are distributed over all CPU cores. Even
if a container is limited to less than 100% of CPU time, it
can use 100% of each individ&acirc; <br>
ual CPU core.</p>

<p style="margin-top: 1em">For example, consider a system
with more than three cores. If you start one container {C0}
with -c=512 running one process, and another container {C1}
with -c=1024 running two <br>
processes, this can result in the following division of CPU
shares:</p>

<p style="margin-top: 1em">PID container CPU CPU share <br>
100 {C0} 0 100% of CPU0 <br>
101 {C1} 1 100% of CPU1 <br>
102 {C1} 2 100% of CPU2</p>

<p style="margin-top: 1em">--cap-add=[] <br>
Add Linux capabilities</p>

<p style="margin-top: 1em">--cap-drop=[] <br>
Drop Linux capabilities</p>

<p style="margin-top: 1em">--cgroup-parent=&quot;&quot;
<br>
Path to cgroups under which the cgroup for the container
will be created. If the path is not absolute, the path is
considered to be relative to the cgroups path of the init
<br>
process. Cgroups will be created if they do not already
exist.</p>

<p style="margin-top: 1em">--cidfile=&quot;&quot; <br>
Write the container ID to the file</p>

<p style="margin-top: 1em">--cpu-period=0 <br>
Limit the CPU CFS (Completely Fair Scheduler) period</p>

<p style="margin-top: 1em">Limit the container&rsquo;s CPU
usage. This flag tell the kernel to restrict the
container&rsquo;s CPU usage to the period you specify.</p>

<p style="margin-top: 1em">--cpuset-cpus=&quot;&quot; <br>
CPUs in which to allow execution (0-3, 0,1)</p>

<p style="margin-top: 1em">--cpuset-mems=&quot;&quot; <br>
Memory nodes (MEMs) in which to allow execution (0-3, 0,1).
Only effective on NUMA systems.</p>

<p style="margin-top: 1em">If you have four memory nodes on
your system (0-3), use --cpuset-mems=0,1 then processes in
your Docker container will only use memory from the first
two memory nodes.</p>

<p style="margin-top: 1em">--cpu-quota=0 <br>
Limit the CPU CFS (Completely Fair Scheduler) quota</p>

<p style="margin-top: 1em">Limit the container&rsquo;s CPU
usage. By default, containers run with the full CPU
resource. This flag tell the kernel to restrict the
container&rsquo;s CPU usage to the quota you specify.</p>

<p style="margin-top: 1em">-d, --detach=true|false <br>
Detached mode: run the container in the background and print
the new container ID. The default is false.</p>

<p style="margin-top: 1em">At any time you can run docker
ps in the other shell to view a list of the running
containers. You can reattach to a detached container with
docker attach. If you choose to run a <br>
container in the detached mode, then you cannot use the -rm
option.</p>

<p style="margin-top: 1em">When attached in the tty mode,
you can detach from the container (and leave it running)
using a configurable key sequence. The default sequence is
CTRL-p CTRL-q. You configure <br>
the key sequence using the --detach-keys option or a
configuration file. See config-json(5) for documentation on
using a configuration file.</p>

<p style="margin-top: 1em">--detach-keys=&quot;&quot; <br>
Override the key sequence for detaching a container. Format
is a single character [a-Z] or ctrl-&lt;value&gt; where
&lt;value&gt; is one of: a-z, @, ^, [, , or _.</p>

<p style="margin-top: 1em">--device=[] <br>
Add a host device to the container (e.g.
--device=/dev/sdc:/dev/xvdc:rwm)</p>

<p style="margin-top: 1em">--device-read-bps=[] <br>
Limit read rate from a device (e.g.
--device-read-bps=/dev/sda:1mb)</p>

<p style="margin-top: 1em">--device-read-iops=[] <br>
Limit read rate from a device (e.g.
--device-read-iops=/dev/sda:1000)</p>

<p style="margin-top: 1em">--device-write-bps=[] <br>
Limit write rate to a device (e.g.
--device-write-bps=/dev/sda:1mb)</p>

<p style="margin-top: 1em">--device-write-iops=[] <br>
Limit write rate to a device (e.g.
--device-write-iops=/dev/sda:1000)</p>

<p style="margin-top: 1em">--dns-search=[] <br>
Set custom DNS search domains (Use --dns-search=. if you
don&rsquo;t wish to set the search domain)</p>

<p style="margin-top: 1em">--dns-opt=[] <br>
Set custom DNS options</p>

<p style="margin-top: 1em">--dns=[] <br>
Set custom DNS servers</p>

<p style="margin-top: 1em">This option can be used to
override the DNS configuration passed to the container.
Typically this is necessary when the host DNS configuration
is invalid for the container (e.g., <br>
127.0.0.1). When this is the case the --dns flags is
necessary for every run.</p>

<p style="margin-top: 1em">-e, --env=[] <br>
Set environment variables</p>

<p style="margin-top: 1em">This option allows you to
specify arbitrary environment variables that are available
for the process that will be launched inside of the
container.</p>

<p style="margin-top: 1em">--entrypoint=&quot;&quot; <br>
Overwrite the default ENTRYPOINT of the image</p>

<p style="margin-top: 1em">This option allows you to
overwrite the default entrypoint of the image that is set in
the Dockerfile. The ENTRYPOINT of an image is similar to a
COMMAND because it specifies <br>
what executable to run when the container starts, but it is
(purposely) more difficult to override. The ENTRYPOINT gives
a container its default nature or behavior, so that when
<br>
you set an ENTRYPOINT you can run the container as if it
were that binary, complete with default options, and you can
pass in more options via the COMMAND. But, sometimes an <br>
operator may want to run something else inside the
container, so you can override the default ENTRYPOINT at
runtime by using a --entrypoint and a string to specify the
new ENTRY&acirc; <br>
POINT.</p>

<p style="margin-top: 1em">--env-file=[] <br>
Read in a line delimited file of environment variables</p>

<p style="margin-top: 1em">--expose=[] <br>
Expose a port, or a range of ports (e.g. --expose=3300-3310)
informs Docker that the container listens on the specified
network ports at runtime. Docker uses this information <br>
to interconnect containers using links and to set up port
redirection on the host system.</p>

<p style="margin-top: 1em">--group-add=[] <br>
Add additional groups to run as</p>

<p style="margin-top: 1em">-h, --hostname=&quot;&quot; <br>
Container host name</p>

<p style="margin-top: 1em">Sets the container host name
that is available inside the container.</p>

<p style="margin-top: 1em">--help <br>
Print usage statement</p>

<p style="margin-top: 1em">-i, --interactive=true|false
<br>
Keep STDIN open even if not attached. The default is
false.</p>

<p style="margin-top: 1em">When set to true, keep stdin
open even if not attached. The default is false.</p>

<p style="margin-top: 1em">--ip=&quot;&quot; <br>
Sets the container&rsquo;s interface IPv4 address (e.g.
172.23.0.9)</p>

<p style="margin-top: 1em">It can only be used in
conjunction with --net for user-defined networks</p>

<p style="margin-top: 1em">--ip6=&quot;&quot; <br>
Sets the container&rsquo;s interface IPv6 address (e.g.
2001:db8::1b99)</p>

<p style="margin-top: 1em">It can only be used in
conjunction with --net for user-defined networks</p>

<p style="margin-top: 1em">--ipc=&quot;&quot; <br>
Default is to create a private IPC namespace (POSIX SysV
IPC) for the container <br>
&rsquo;container:&lt;name|id&gt;&rsquo;: reuses another
container shared memory, semaphores and message queues <br>
&rsquo;host&rsquo;: use the host shared memory,semaphores
and message queues inside the container. Note: the host mode
gives the container full access to <br>
local shared memory and is therefore considered
insecure.</p>

<p style="margin-top: 1em">--isolation=&quot;default&quot;
<br>
Isolation specifies the type of isolation technology used by
containers. Note that the default on Windows server is
process, and the default on Windows client is hyperv. Linux
<br>
only supports default.</p>

<p style="margin-top: 1em">-l, --label=[] <br>
Set metadata on the container (e.g., --label
com.example.key=value)</p>

<p style="margin-top: 1em">--kernel-memory=&quot;&quot;
<br>
Kernel memory limit (format: &lt;number&gt;[&lt;unit&gt;],
where unit = b, k, m or g)</p>

<p style="margin-top: 1em">Constrains the kernel memory
available to a container. If a limit of 0 is specified (not
using --kernel-memory), the container&rsquo;s kernel memory
is not limited. If you specify a <br>
limit, it may be rounded up to a multiple of the operating
system&rsquo;s page size and the value can be very large,
millions of trillions.</p>

<p style="margin-top: 1em">--label-file=[] <br>
Read in a line delimited file of labels</p>

<p style="margin-top: 1em">--link=[] <br>
Add link to another container in the form of &lt;name or
id&gt;:alias or just &lt;name or id&gt; in which case the
alias will match the name</p>

<p style="margin-top: 1em">If the operator uses --link when
starting the new client container, then the client container
can access the exposed port via a private networking
interface. Docker will set some <br>
environment variables in the client container to help
indicate which interface and port to use.</p>

<p style="margin-top: 1em">--link-local-ip=[] <br>
Add one or more link-local IPv4/IPv6 addresses to the
container&rsquo;s interface</p>


<p style="margin-top: 1em">--log-driver=&quot;json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none&quot;
<br>
Logging driver for the container. Default is defined by
daemon --log-driver flag. <br>
Warning: the docker logs command works only for the
json-file and <br>
journald logging drivers.</p>

<p style="margin-top: 1em">--log-opt=[] <br>
Logging driver specific options.</p>

<p style="margin-top: 1em">-m, --memory=&quot;&quot; <br>
Memory limit (format: &lt;number&gt;[&lt;unit&gt;], where
unit = b, k, m or g)</p>

<p style="margin-top: 1em">Allows you to constrain the
memory available to a container. If the host supports swap
memory, then the -m memory setting can be larger than
physical RAM. If a limit of 0 is <br>
specified (not using -m), the container&rsquo;s memory is
not limited. The actual limit may be rounded up to a
multiple of the operating system&rsquo;s page size (the
value would be very <br>
large, that&rsquo;s millions of trillions).</p>


<p style="margin-top: 1em">--memory-reservation=&quot;&quot;
<br>
Memory soft limit (format: &lt;number&gt;[&lt;unit&gt;],
where unit = b, k, m or g)</p>

<p style="margin-top: 1em">After setting memory
reservation, when the system detects memory contention or
low memory, containers are forced to restrict their
consumption to their reservation. So you should <br>
always set the value below --memory, otherwise the hard
limit will take precedence. By default, memory reservation
will be the same as memory limit.</p>

<p style="margin-top: 1em">--memory-swap=&quot;LIMIT&quot;
<br>
A limit value equal to memory plus swap. Must be used with
the -m (--memory) flag. The swap LIMIT should always be
larger than -m (--memory) value. By default, the swap <br>
LIMIT will be set to double the value of --memory.</p>

<p style="margin-top: 1em">The format of LIMIT is
&lt;number&gt;[&lt;unit&gt;]. Unit can be b (bytes), k
(kilobytes), m (megabytes), or g (gigabytes). If you
don&rsquo;t specify a unit, b is used. Set LIMIT to -1 to
enable <br>
unlimited swap.</p>

<p style="margin-top: 1em">--mac-address=&quot;&quot; <br>
Container MAC address (e.g. 92:d0:c6:0a:29:33)</p>

<p style="margin-top: 1em">Remember that the MAC address in
an Ethernet network must be unique. The IPv6 link-local
address will be based on the device&rsquo;s MAC address
according to RFC4862.</p>

<p style="margin-top: 1em">--name=&quot;&quot; <br>
Assign a name to the container</p>

<p style="margin-top: 1em">The operator can identify a
container in three ways: <br>
UUID long identifier
(&acirc;f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778&acirc;)
<br>
UUID short identifier (&acirc;f78375b1c487&acirc;) <br>
Name (&acirc;jonah&acirc;)</p>

<p style="margin-top: 1em">The UUID identifiers come from
the Docker daemon, and if a name is not assigned to the
container with --name then the daemon will also generate a
random string name. The name is <br>
useful when defining links (see --link) (or any other place
you need to identify a container). This works for both
background and foreground Docker containers.</p>

<p style="margin-top: 1em">--net=&quot;bridge&quot; <br>
Set the Network mode for the container <br>
&rsquo;bridge&rsquo;: create a network stack on the default
Docker bridge <br>
&rsquo;none&rsquo;: no networking <br>
&rsquo;container:&lt;name|id&gt;&rsquo;: reuse another
container&rsquo;s network stack <br>
&rsquo;host&rsquo;: use the Docker host network stack. Note:
the host mode gives the container full access to local
system services such as D-bus and is there&acirc; <br>
fore considered insecure. <br>
&rsquo;&lt;network-name&gt;|&lt;network-id&gt;&rsquo;:
connect to a user-defined network</p>

<p style="margin-top: 1em">--network-alias=[] <br>
Add network-scoped alias for the container</p>

<p style="margin-top: 1em">--oom-kill-disable=true|false
<br>
Whether to disable OOM Killer for the container or not.</p>

<p style="margin-top: 1em">--oom-score-adj=&quot;&quot;
<br>
Tune the host&rsquo;s OOM preferences for containers
(accepts -1000 to 1000)</p>

<p style="margin-top: 1em">-P, --publish-all=true|false
<br>
Publish all exposed ports to random ports on the host
interfaces. The default is false.</p>

<p style="margin-top: 1em">When set to true publish all
exposed ports to the host interfaces. The default is false.
If the operator uses -P (or -p) then Docker will make the
exposed port accessible on the <br>
host and the ports will be available to any client that can
reach the host. When using -P, Docker will bind any exposed
port to a random port on the host within an ephemeral port
<br>
range defined by /proc/sys/net/ipv4/ip_local_port_range. To
find the mapping between the host ports and the exposed
ports, use docker port.</p>

<p style="margin-top: 1em">-p, --publish=[] <br>
Publish a container&rsquo;s port, or range of ports, to the
host.</p>

<p style="margin-top: 1em">Format:
ip:hostPort:containerPort | ip::containerPort |
hostPort:containerPort | containerPort Both hostPort and
containerPort can be specified as a range of ports. When
speci&acirc; <br>
fying ranges for both, the number of container ports in the
range must match the number of host ports in the range.
(e.g., docker run -p 1234-1236:1222-1224 --name thisWorks -t
<br>
busybox but not docker run -p 1230-1236:1230-1240 --name
RangeContainerPortsBiggerThanRangeHostPorts -t busybox) With
ip: docker run -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT --name
<br>
CONTAINER -t someimage Use docker port to see the actual
mapping: docker port CONTAINER $CONTAINERPORT</p>

<p style="margin-top: 1em">--pid=&quot;&quot; <br>
Set the PID mode for the container <br>
Default is to create a private PID namespace for the
container <br>
&rsquo;container:&lt;name|id&gt;&rsquo;: join another
container&rsquo;s PID namespace <br>
&rsquo;host&rsquo;: use the host&rsquo;s PID namespace for
the container. Note: the host mode gives the container full
access to local PID and is therefore consid&acirc; <br>
ered insecure.</p>

<p style="margin-top: 1em">--userns=&quot;&quot; <br>
Set the usernamespace mode for the container when
userns-remap option is enabled. <br>
host: use the host usernamespace and enable all privileged
options (e.g., pid=host or --privileged).</p>

<p style="margin-top: 1em">--pids-limit=&quot;&quot; <br>
Tune the container&rsquo;s pids limit. Set -1 to have
unlimited pids for the container.</p>

<p style="margin-top: 1em">--uts=host <br>
Set the UTS mode for the container <br>
host: use the host&rsquo;s UTS namespace inside the
container. <br>
Note: the host mode gives the container access to changing
the host&rsquo;s hostname and is therefore considered
insecure.</p>

<p style="margin-top: 1em">--privileged=true|false <br>
Give extended privileges to this container. The default is
false.</p>

<p style="margin-top: 1em">By default, Docker containers
are &acirc;unprivileged&acirc; (=false) and cannot, for
example, run a Docker daemon inside the Docker container.
This is because by default a container is not <br>
allowed to access any devices. A &acirc;privileged&acirc;
container is given access to all devices.</p>

<p style="margin-top: 1em">When the operator executes
docker run --privileged, Docker will enable access to all
devices on the host as well as set some configuration in
AppArmor to allow the container <br>
nearly all the same access to the host as processes running
outside of a container on the host.</p>

<p style="margin-top: 1em">--read-only=true|false <br>
Mount the container&rsquo;s root filesystem as read
only.</p>

<p style="margin-top: 1em">By default a container will have
its root filesystem writable allowing processes to write
files anywhere. By specifying the --read-only flag the
container will have its root <br>
filesystem mounted as read only prohibiting any writes.</p>

<p style="margin-top: 1em">--restart=&quot;no&quot; <br>
Restart policy to apply when a container exits (no,
on-failure[:max-retry], always, unless-stopped).</p>

<p style="margin-top: 1em">--rm=true|false <br>
Automatically remove the container when it exits
(incompatible with -d). The default is false.</p>

<p style="margin-top: 1em">--security-opt=[] <br>
Security Options</p>

<p style="margin-top: 1em">&quot;label=user:USER&quot; :
Set the label user for the container <br>
&quot;label=role:ROLE&quot; : Set the label role for the
container <br>
&quot;label=type:TYPE&quot; : Set the label type for the
container <br>
&quot;label=level:LEVEL&quot; : Set the label level for the
container <br>
&quot;label=disable&quot; : Turn off label confinement for
the container <br>
&quot;no-new-privileges&quot; : Disable container processes
from gaining additional privileges</p>

<p style="margin-top: 1em">&quot;seccomp=unconfined&quot; :
Turn off seccomp confinement for the container <br>
&quot;seccomp=profile.json : White listed syscalls seccomp
Json file to be used as a seccomp filter</p>

<p style="margin-top: 1em">&quot;apparmor=unconfined&quot;
: Turn off apparmor confinement for the container <br>
&quot;apparmor=your-profile&quot; : Set the apparmor
confinement profile for the container</p>

<p style="margin-top: 1em">--storage-opt=[] <br>
Storage driver options per container</p>

<p style="margin-top: 1em">$ docker run -it --storage-opt
size=120G fedora /bin/bash</p>

<p style="margin-top: 1em">This (size) will allow to set
the container rootfs size to 120G at creation time. User
cannot pass a size less than the Default BaseFS Size. <br>
This option is only available for the devicemapper, btrfs,
and zfs graph drivers.</p>

<p style="margin-top: 1em">--stop-signal=SIGTERM <br>
Signal to stop a container. Default is SIGTERM.</p>

<p style="margin-top: 1em">--shm-size=&quot;&quot; <br>
Size of /dev/shm. The format is &lt;number&gt;&lt;unit&gt;.
<br>
number must be greater than 0. Unit is optional and can be b
(bytes), k (kilobytes), m(megabytes), or g (gigabytes). <br>
If you omit the unit, the system uses bytes. If you omit the
size entirely, the system uses 64m.</p>

<p style="margin-top: 1em">--sysctl=SYSCTL <br>
Configure namespaced kernel parameters at runtime</p>

<p style="margin-top: 1em">IPC Namespace - current sysctls
allowed:</p>

<p style="margin-top: 1em">kernel.msgmax, kernel.msgmnb,
kernel.msgmni, kernel.sem, kernel.shmall, kernel.shmmax,
kernel.shmmni, kernel.shm_rmid_forced <br>
Sysctls beginning with fs.mqueue.*</p>

<p style="margin-top: 1em">If you use the --ipc=host option
these sysctls will not be allowed.</p>

<p style="margin-top: 1em">Network Namespace - current
sysctls allowed: <br>
Sysctls beginning with net.*</p>

<p style="margin-top: 1em">If you use the --net=host option
these sysctls will not be allowed.</p>

<p style="margin-top: 1em">--sig-proxy=true|false <br>
Proxy received signals to the process (non-TTY mode only).
SIGCHLD, SIGSTOP, and SIGKILL are not proxied. The default
is true.</p>


<p style="margin-top: 1em">--memory-swappiness=&quot;&quot;
<br>
Tune a container&rsquo;s memory swappiness behavior. Accepts
an integer between 0 and 100.</p>

<p style="margin-top: 1em">-t, --tty=true|false <br>
Allocate a pseudo-TTY. The default is false.</p>

<p style="margin-top: 1em">When set to true Docker can
allocate a pseudo-tty and attach to the standard input of
any container. This can be used, for example, to run a
throwaway interactive shell. The <br>
default is false.</p>

<p style="margin-top: 1em">The -t option is incompatible
with a redirection of the docker client standard input.</p>

<p style="margin-top: 1em">--tmpfs=[] Create a tmpfs
mount</p>

<p style="margin-top: 1em">Mount a temporary filesystem
(tmpfs) mount into a container, for example:</p>

<p style="margin-top: 1em">$ docker run -d --tmpfs
/tmp:rw,size=787448k,mode=1777 my_image</p>

<p style="margin-top: 1em">This command mounts a tmpfs at
/tmp within the container. The supported mount options are
the same as the Linux default mount flags. If you do not
specify any options, the sys&acirc; <br>
tems uses the following options:
rw,noexec,nosuid,nodev,size=65536k.</p>

<p style="margin-top: 1em">-u, --user=&quot;&quot; <br>
Sets the username or UID used and optionally the groupname
or GID for the specified command.</p>

<p style="margin-top: 1em">The followings examples are all
valid: <br>
--user [user | user:group | uid | uid:gid | user:gid |
uid:group ]</p>

<p style="margin-top: 1em">Without this argument the
command will be run as root in the container.</p>

<p style="margin-top: 1em">--ulimit=[] <br>
Ulimit options</p>


<p style="margin-top: 1em">-v|--volume[=[[HOST-DIR:]CONTAINER-DIR[:OPTIONS]]]
<br>
Create a bind mount. If you specify, -v
/HOST-DIR:/CONTAINER-DIR, Docker <br>
bind mounts /HOST-DIR in the host to /CONTAINER-DIR in the
Docker <br>
container. If &rsquo;HOST-DIR&rsquo; is omitted, Docker
automatically creates the new <br>
volume on the host. The OPTIONS are a comma delimited list
and can be:</p>

<p style="margin-top: 1em">0</p>

<p style="margin-top: 1em">item [rw|ro] item [z|Z] item
[[r]shared|[r]slave|[r]private] item [nocopy]</p>

<p style="margin-top: 1em">The CONTAINER-DIR must be an
absolute path such as /src/docs. The HOST-DIR can be an
absolute path or a name value. A name value must start with
an alphanumeric character, fol&acirc; <br>
lowed by a-z0-9, _ (underscore), . (period) or - (hyphen).
An absolute path starts with a / (forward slash).</p>

<p style="margin-top: 1em">If you supply a HOST-DIR that is
an absolute path, Docker bind-mounts to the path you
specify. If you supply a name, Docker creates a named volume
by that name. For example, you <br>
can specify either /foo or foo for a HOST-DIR value. If you
supply the /foo value, Docker creates a bind-mount. If you
supply the foo specification, Docker creates a named
vol&acirc; <br>
ume.</p>

<p style="margin-top: 1em">You can specify multiple -v
options to mount one or more mounts to a container. To use
these same mounts in other containers, specify the
--volumes-from option also.</p>

<p style="margin-top: 1em">You can add :ro or :rw suffix to
a volume to mount it read-only or read-write mode,
respectively. By default, the volumes are mounted
read-write. See examples.</p>

<p style="margin-top: 1em">Labeling systems like SELinux
require that proper labels are placed on volume content
mounted into a container. Without a label, the security
system might prevent the processes <br>
running inside the container from using the content. By
default, Docker does not change the labels set by the
OS.</p>

<p style="margin-top: 1em">To change a label in the
container context, you can add either of two suffixes :z or
:Z to the volume mount. These suffixes tell Docker to
relabel file objects on the shared vol&acirc; <br>
umes. The z option tells Docker that two containers share
the volume content. As a result, Docker labels the content
with a shared content label. Shared volume labels allow all
<br>
containers to read/write content. The Z option tells Docker
to label the content with a private unshared label. Only the
current container can use a private volume.</p>

<p style="margin-top: 1em">By default bind mounted volumes
are private. That means any mounts done inside container
will not be visible on host and vice-a-versa. One can change
this behavior by specifying <br>
a volume mount propagation property. Making a volume shared
mounts done under that volume inside container will be
visible on host and vice-a-versa. Making a volume slave
enables <br>
only one way mount propagation and that is mounts done on
host under that volume will be visible inside container but
not the other way around.</p>

<p style="margin-top: 1em">To control mount propagation
property of volume one can use :[r]shared, :[r]slave or
:[r]private propagation flag. Propagation property can be
specified only for bind mounted <br>
volumes and not for internal volumes or named volumes. For
mount propagation to work source mount point (mount point
where source dir is mounted on) has to have right
propagation <br>
properties. For shared volumes, source mount point has to be
shared. And for slave volumes, source mount has to be either
shared or slave.</p>

<p style="margin-top: 1em">Use df &lt;source-dir&gt; to
figure out the source mount and then use findmnt -o
TARGET,PROPAGATION &lt;source-mount-dir&gt; to figure out
propagation properties of source mount. If findmnt <br>
utility is not available, then one can look at mount entry
for source mount point in /proc/self/mountinfo. Look at
optional fields and see if any propagaion properties are
speci&acirc; <br>
fied. shared:X means mount is shared, master:X means mount
is slave and if nothing is there that means mount is
private.</p>

<p style="margin-top: 1em">To change propagation properties
of a mount point use mount command. For example, if one
wants to bind mount source directory /foo one can do mount
--bind /foo /foo and mount <br>
--make-private --make-shared /foo. This will convert /foo
into a shared mount point. Alternatively one can directly
change propagation properties of source mount. Say / is
source <br>
mount for /foo, then use mount --make-shared / to convert /
into a shared mount.</p>

<p style="margin-top: 1em">Note: When using systemd to
manage the Docker daemon&rsquo;s start and stop, in the
systemd unit file there is an option to control mount
propagation for the Docker daemon <br>
itself, called MountFlags. The value of this setting may
cause Docker to not see mount propagation changes made on
the mount point. For example, if this value is slave, <br>
you may not be able to use the shared or rshared propagation
on a volume.</p>

<p style="margin-top: 1em">To disable automatic copying of
data from the container path to the volume, use the nocopy
flag. The nocopy flag can be set on bind mounts and named
volumes.</p>

<p style="margin-top: 1em">--volume-driver=&quot;&quot;
<br>
Container&rsquo;s volume driver. This driver creates volumes
specified either from <br>
a Dockerfile&rsquo;s VOLUME instruction or from the docker
run -v flag. <br>
See docker-volume-create(1) for full details.</p>

<p style="margin-top: 1em">--volumes-from=[] <br>
Mount volumes from the specified container(s)</p>

<p style="margin-top: 1em">Mounts already mounted volumes
from a source container onto another <br>
container. You must supply the source&rsquo;s container-id.
To share <br>
a volume, use the --volumes-from option when running <br>
the target container. You can share volumes even if the
source container <br>
is not running.</p>

<p style="margin-top: 1em">By default, Docker mounts the
volumes in the same mode (read-write or <br>
read-only) as it is mounted in the source container.
Optionally, you <br>
can change this by suffixing the container-id with either
the :ro or <br>
:rw keyword.</p>

<p style="margin-top: 1em">If the location of the volume
from the source container overlaps with <br>
data residing on a target container, then the volume hides
<br>
that data on the target.</p>

<p style="margin-top: 1em">-w, --workdir=&quot;&quot; <br>
Working directory inside the container</p>

<p style="margin-top: 1em">The default working directory
for running binaries within a container is the root
directory (/). The developer can set a different default
with the Dockerfile WORKDIR instruc&acirc; <br>
tion. The operator can override the working directory by
using the -w option.</p>

<p style="margin-top: 1em">Exit Status <br>
The exit code from docker run gives information about why
the container failed to run or why it exited. When docker
run exits with a non-zero code, the exit codes follow the
<br>
chroot standard, see below:</p>

<p style="margin-top: 1em">125 if the error is with Docker
daemon itself</p>

<p style="margin-top: 1em">$ docker run --foo busybox; echo
$? <br>
# flag provided but not defined: --foo <br>
See &rsquo;docker run --help&rsquo;. <br>
125</p>

<p style="margin-top: 1em">126 if the contained command
cannot be invoked</p>

<p style="margin-top: 1em">$ docker run busybox /etc; echo
$? <br>
# exec: &quot;/etc&quot;: permission denied <br>
docker: Error response from daemon: Contained command could
not be invoked <br>
126</p>

<p style="margin-top: 1em">127 if the contained command
cannot be found</p>

<p style="margin-top: 1em">$ docker run busybox foo; echo
$? <br>
# exec: &quot;foo&quot;: executable file not found in $PATH
<br>
docker: Error response from daemon: Contained command not
found or does not exist <br>
127</p>

<p style="margin-top: 1em">Exit code of contained command
otherwise</p>

<p style="margin-top: 1em">$ docker run busybox /bin/sh -c
&rsquo;exit 3&rsquo; <br>
# 3</p>

<p style="margin-top: 1em">EXAMPLES Running container in
read-only mode <br>
During container image development, containers often need to
write to the image content. Installing packages into /usr,
for example. In production, applications seldom need to <br>
write to the image. Container applications write to volumes
if they need to write to file systems at all. Applications
can be made more secure by running them in read-only mode
<br>
using the --read-only switch. This protects the containers
image from modification. Read only containers may still need
to write temporary data. The best way to handle this is <br>
to mount tmpfs directories on /run and /tmp.</p>

<p style="margin-top: 1em"># docker run --read-only --tmpfs
/run --tmpfs /tmp -i -t fedora /bin/bash</p>

<p style="margin-top: 1em">Exposing log messages from the
container to the host&rsquo;s log <br>
If you want messages that are logged in your container to
show up in the host&rsquo;s syslog/journal then you should
bind mount the /dev/log directory as follows.</p>

<p style="margin-top: 1em"># docker run -v
/dev/log:/dev/log -i -t fedora /bin/bash</p>

<p style="margin-top: 1em">From inside the container you
can test this by sending a message to the log.</p>

<p style="margin-top: 1em">(bash)# logger &quot;Hello from
my container&quot;</p>

<p style="margin-top: 1em">Then exit and check the
journal.</p>

<p style="margin-top: 1em"># exit</p>

<p style="margin-top: 1em"># journalctl -b | grep Hello</p>

<p style="margin-top: 1em">This should list the message
sent to logger.</p>

<p style="margin-top: 1em">Attaching to one or more from
STDIN, STDOUT, STDERR <br>
If you do not specify -a then Docker will attach everything
(stdin,stdout,stderr) you&rsquo;d like to connect instead,
as in:</p>

<p style="margin-top: 1em"># docker run -a stdin -a stdout
-i -t fedora /bin/bash</p>

<p style="margin-top: 1em">Sharing IPC between containers
<br>
Using shm_server.c available here:
&acirc;&uml;https://www.cs.cf.ac.uk/Dave/C/node27.html&acirc;&copy;</p>

<p style="margin-top: 1em">Testing --ipc=host mode:</p>

<p style="margin-top: 1em">Host shows a shared memory
segment with 7 pids attached, happens to be from httpd:</p>

<p style="margin-top: 1em">$ sudo ipcs -m</p>

<p style="margin-top: 1em">------ Shared Memory Segments
-------- <br>
key shmid owner perms bytes nattch status <br>
0x01128e25 0 root 600 1000 7</p>

<p style="margin-top: 1em">Now run a regular container, and
it correctly does NOT see the shared memory segment from the
host:</p>

<p style="margin-top: 1em">$ docker run -it shm ipcs -m</p>

<p style="margin-top: 1em">------ Shared Memory Segments
-------- <br>
key shmid owner perms bytes nattch status</p>

<p style="margin-top: 1em">Run a container with the new
--ipc=host option, and it now sees the shared memory segment
from the host httpd:</p>

<p style="margin-top: 1em">$ docker run -it --ipc=host shm
ipcs -m</p>

<p style="margin-top: 1em">------ Shared Memory Segments
-------- <br>
key shmid owner perms bytes nattch status <br>
0x01128e25 0 root 600 1000 7</p>

<p style="margin-top: 1em">Testing
--ipc=container:CONTAINERID mode:</p>

<p style="margin-top: 1em">Start a container with a program
to create a shared memory segment:</p>

<p style="margin-top: 1em">$ docker run -it shm bash <br>
$ sudo shm/shm_server <br>
$ sudo ipcs -m</p>

<p style="margin-top: 1em">------ Shared Memory Segments
-------- <br>
key shmid owner perms bytes nattch status <br>
0x0000162e 0 root 666 27 1</p>

<p style="margin-top: 1em">Create a 2nd container correctly
shows no shared memory segment from 1st container:</p>

<p style="margin-top: 1em">$ docker run shm ipcs -m</p>

<p style="margin-top: 1em">------ Shared Memory Segments
-------- <br>
key shmid owner perms bytes nattch status</p>

<p style="margin-top: 1em">Create a 3rd container using the
new --ipc=container:CONTAINERID option, now it shows the
shared memory segment from the first:</p>

<p style="margin-top: 1em">$ docker run -it
--ipc=container:ed735b2264ac shm ipcs -m <br>
$ sudo ipcs -m</p>

<p style="margin-top: 1em">------ Shared Memory Segments
-------- <br>
key shmid owner perms bytes nattch status <br>
0x0000162e 0 root 666 27 1</p>

<p style="margin-top: 1em">Linking Containers <br>
Note: This section describes linking between containers on
the default (bridge) network, also known as &quot;legacy
links&quot;. Using --link on user-defined networks uses the
<br>
DNS-based discovery, which does not add entries to
/etc/hosts, and does not set environment variables for
discovery.</p>

<p style="margin-top: 1em">The link feature allows multiple
containers to communicate with each other. For example, a
container whose Dockerfile has exposed port 80 can be run
and named as follows:</p>

<p style="margin-top: 1em"># docker run --name=link-test -d
-i -t fedora/httpd</p>

<p style="margin-top: 1em">A second container, in this case
called linker, can communicate with the httpd container,
named link-test, by running with the
--link=&lt;name&gt;:&lt;alias&gt;</p>

<p style="margin-top: 1em"># docker run -t -i
--link=link-test:lt --name=linker fedora /bin/bash</p>

<p style="margin-top: 1em">Now the container linker is
linked to container link-test with the alias lt. Running the
env command in the linker container shows environment
variables <br>
with the LT (alias) context (LT_)</p>

<p style="margin-top: 1em"># env <br>
HOSTNAME=668231cb0978 <br>
TERM=xterm <br>
LT_PORT_80_TCP=tcp://172.17.0.3:80 <br>
LT_PORT_80_TCP_PORT=80 <br>
LT_PORT_80_TCP_PROTO=tcp <br>
LT_PORT=tcp://172.17.0.3:80 <br>

PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<br>
PWD=/ <br>
LT_NAME=/linker/lt <br>
SHLVL=1 <br>
HOME=/ <br>
LT_PORT_80_TCP_ADDR=172.17.0.3 <br>
_=/usr/bin/env</p>

<p style="margin-top: 1em">When linking two containers
Docker will use the exposed ports of the container to create
a secure tunnel for the parent to access.</p>

<p style="margin-top: 1em">If a container is connected to
the default bridge network and linked with other containers,
then the container&rsquo;s /etc/hosts file is updated with
the linked container&rsquo;s name.</p>

<p style="margin-top: 1em">Note Since Docker may live
update the container&rsquo;s /etc/hosts file, there may be
situations when processes inside the container can end up
reading an empty or incomplete <br>
/etc/hosts file. In most cases, retrying the read again
should fix the problem.</p>

<p style="margin-top: 1em">Mapping Ports for External Usage
<br>
The exposed port of an application can be mapped to a host
port using the -p flag. For example, a httpd port 80 can be
mapped to the host port 8080 using the following:</p>

<p style="margin-top: 1em"># docker run -p 8080:80 -d -i -t
fedora/httpd</p>

<p style="margin-top: 1em">Creating and Mounting a Data
Volume Container <br>
Many applications require the sharing of persistent data
across several containers. Docker allows you to create a
Data Volume Container that other containers can mount from.
For <br>
example, create a named container that contains directories
/var/volume1 and /tmp/volume2. The image will need to
contain these directories so a couple of RUN mkdir
instructions <br>
might be required for you fedora-data image:</p>

<p style="margin-top: 1em"># docker run --name=data -v
/var/volume1 -v /tmp/volume2 -i -t fedora-data true <br>
# docker run --volumes-from=data --name=fedora-container1 -i
-t fedora bash</p>

<p style="margin-top: 1em">Multiple --volumes-from
parameters will bring together multiple data volumes from
multiple containers. And it&rsquo;s possible to mount the
volumes that came from the DATA container in <br>
yet another container via the fedora-container1 intermediary
container, allowing to abstract the actual data source from
users of that data:</p>

<p style="margin-top: 1em"># docker run
--volumes-from=fedora-container1 --name=fedora-container2 -i
-t fedora bash</p>

<p style="margin-top: 1em">Mounting External Volumes <br>
To mount a host directory as a container volume, specify the
absolute path to the directory and the absolute path for the
container directory separated by a colon:</p>

<p style="margin-top: 1em"># docker run -v /var/db:/data1
-i -t fedora bash</p>

<p style="margin-top: 1em">When using SELinux, be aware
that the host has no knowledge of container SELinux policy.
Therefore, in the above example, if SELinux policy is
enforced, the /var/db directory is <br>
not writable to the container. A &quot;Permission
Denied&quot; message will occur and an avc: message in the
host&rsquo;s syslog.</p>

<p style="margin-top: 1em">To work around this, at time of
writing this man page, the following command needs to be run
in order for the proper SELinux policy type label to be
attached to the host direc&acirc; <br>
tory:</p>

<p style="margin-top: 1em"># chcon -Rt svirt_sandbox_file_t
/var/db</p>

<p style="margin-top: 1em">Now, writing to the /data1
volume in the container will be allowed and the changes will
also be reflected on the host in /var/db.</p>

<p style="margin-top: 1em">Using alternative security
labeling <br>
You can override the default labeling scheme for each
container by specifying the --security-opt flag. For
example, you can specify the MCS/MLS level, a requirement
for MLS sys&acirc; <br>
tems. Specifying the level in the following command allows
you to share the same content between containers.</p>

<p style="margin-top: 1em"># docker run --security-opt
label=level:s0:c100,c200 -i -t fedora bash</p>

<p style="margin-top: 1em">An MLS example might be:</p>

<p style="margin-top: 1em"># docker run --security-opt
label=level:TopSecret -i -t rhel7 bash</p>

<p style="margin-top: 1em">To disable the security labeling
for this container versus running with the --permissive
flag, use the following command:</p>

<p style="margin-top: 1em"># docker run --security-opt
label=disable -i -t fedora bash</p>

<p style="margin-top: 1em">If you want a tighter security
policy on the processes within a container, you can specify
an alternate type for the container. You could run a
container that is only allowed to <br>
listen on Apache ports by executing the following
command:</p>

<p style="margin-top: 1em"># docker run --security-opt
label=type:svirt_apache_t -i -t centos bash</p>

<p style="margin-top: 1em">Note:</p>

<p style="margin-top: 1em">You would have to write policy
defining a svirt_apache_t type.</p>

<p style="margin-top: 1em">Setting device weight <br>
If you want to set /dev/sda device weight to 200, you can
specify the device weight by --blkio-weight-device flag. Use
the following command:</p>

<p style="margin-top: 1em"># docker run -it
--blkio-weight-device &quot;/dev/sda:200&quot; ubuntu</p>

<p style="margin-top: 1em">Specify isolation technology for
container (--isolation) <br>
This option is useful in situations where you are running
Docker containers on Microsoft Windows. The --isolation
&lt;value&gt; option sets a container&rsquo;s isolation
technology. On <br>
Linux, the only supported is the default option which uses
Linux namespaces. These two commands are equivalent on
Linux:</p>

<p style="margin-top: 1em">$ docker run -d busybox top <br>
$ docker run -d --isolation default busybox top</p>

<p style="margin-top: 1em">On Microsoft Windows, can take
any of these values:</p>

<p style="margin-top: 1em">0</p>

<p style="margin-top: 1em">item default: Use the value
specified by the Docker daemon&rsquo;s --exec-opt . If the
daemon does not specify an isolation technology, Microsoft
Windows uses process as its <br>
default value. item process: Namespace isolation only. item
hyperv: Hyper-V hypervisor partition-based isolation.</p>

<p style="margin-top: 1em">In practice, when running on
Microsoft Windows without a daemon option set, these two
commands are equivalent:</p>

<p style="margin-top: 1em">$ docker run -d --isolation
default busybox top <br>
$ docker run -d --isolation process busybox top</p>

<p style="margin-top: 1em">If you have set the --exec-opt
isolation=hyperv option on the Docker daemon, any of these
commands also result in hyperv isolation:</p>

<p style="margin-top: 1em">$ docker run -d --isolation
default busybox top <br>
$ docker run -d --isolation hyperv busybox top</p>

<p style="margin-top: 1em">Setting Namespaced Kernel
Parameters (Sysctls) <br>
The --sysctl sets namespaced kernel parameters (sysctls) in
the container. For example, to turn on IP forwarding in the
containers network namespace, run this command:</p>

<p style="margin-top: 1em">$ docker run --sysctl
net.ipv4.ip_forward=1 someimage</p>

<p style="margin-top: 1em">Note:</p>

<p style="margin-top: 1em">Not all sysctls are namespaced.
Docker does not support changing sysctls inside of a
container that also modify the host system. As the kernel
evolves we expect to see more <br>
sysctls become namespaced.</p>

<p style="margin-top: 1em">See the definition of the
--sysctl option above for the current list of supported
sysctls.</p>

<p style="margin-top: 1em">HISTORY <br>
April 2014, Originally compiled by William Henry (whenry at
redhat dot com) based on docker.com source material and
internal work. June 2014, updated by Sven Dowideit
&acirc;&uml;Sven&acirc; <br>
Dowideit@home.org.au&acirc;&copy; July 2014, updated by Sven
Dowideit &acirc;&uml;SvenDowideit@home.org.au&acirc;&copy;
November 2015, updated by Sally O&rsquo;Malley
&acirc;&uml;somalley@redhat.com&acirc;&copy;</p>

<p style="margin-top: 1em">Docker Community Docker User
Manuals DOCKER(1)</p>
<hr>
</body>
</html>
