<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:26:21 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>mspdebug(1) General Commands Manual mspdebug(1)</p>

<p style="margin-top: 1em">NAME <br>
MSPDebug - debugging tool for MSP430 MCUs</p>

<p style="margin-top: 1em">SYNOPSIS <br>
mspdebug [options] driver [command ...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
MSPDebug is a command-line tool designed for debugging and
programming the MSP430 family of MCUs. It supports the
eZ430-F2013, eZ430-RF2500, Launchpad, Chronos, FET430UIF,
Good&acirc; <br>
FET, Olimex MSP430-JTAG-TINY and MSP430-JTAG-ISO programming
tools, as well as a simulation mode.</p>

<p style="margin-top: 1em">When started with appropriate
options, MSPDebug will attempt to connect to the debugging
tool specified and identify the device under test. Once
connected, the user is presented <br>
with a command prompt which can be used to reflash the
device memory, inspect memory and registers, set registers,
and control the CPU (single step, run and run to
breakpoint).</p>

<p style="margin-top: 1em">It supports a variety of file
formats, described in the section BINARY FORMATS below. It
can also be used as a remote stub for gdb(1).</p>

<p style="margin-top: 1em">On startup, MSPDebug will look
for a file called .mspdebug first in the current directory,
and then in the user&rsquo;s home directory. If either file
exists, commands will be read and <br>
executed from this file before executing any other commands
or starting the interactive reader.</p>

<p style="margin-top: 1em">Alternatively, a configuration
file can be explicitly specified with the -C option.</p>

<p style="margin-top: 1em">COMMAND-LINE OPTIONS <br>
Command-line options accepted by MSPDebug are described
below. If commands are specified on the end of the
command-line, then they are executed after connecting to the
device, <br>
and the interactive prompt is not started. Please be aware
that commands consisting of multiple words need to be
enclosed in quotation marks, otherwise they are treated as
single <br>
commands. Thus the common prog command would be used as
&quot;prog main.elf&quot;. See the section labelled COMMANDS
for more information.</p>

<p style="margin-top: 1em">-q Start in quiet mode. See the
&quot;quiet&quot; option described below.</p>

<p style="margin-top: 1em">-v voltage <br>
Set the programming voltage. The voltage should be specified
as an integer in millivolts. It defaults to 3000 (3.0
V).</p>

<p style="margin-top: 1em">-j Use JTAG instead of
Spy-Bi-Wire to communicate with the MSP430. This option
doesn&rsquo;t work with eZ430 or eZ430-RF2500 devices, which
support Spy-Bi-Wire only.</p>

<p style="margin-top: 1em">-d device <br>
Specify that the driver should connect via a tty device
rather than USB. The supported connection methods vary
depending on the driver. See the section DRIVERS below for
<br>
details.</p>

<p style="margin-top: 1em">-U bus:device <br>
Specify a particular USB device to connect to. Without this
option, the first device of the appropriate type is
opened.</p>

<p style="margin-top: 1em">-s serial <br>
Specify a particular USB device serial number to connect to.
Use this option to distinguish between multiple devices of
the same type.</p>

<p style="margin-top: 1em">-n Do not process the startup
file (~/.mspdebug).</p>

<p style="margin-top: 1em">-C file <br>
Specify an alternative configuration file (default is
~/.mspdebug). If -n is specified as well, no file will be
read.</p>

<p style="margin-top: 1em">--long-password <br>
When using the flash-bsl driver, send a 32-byte BSL password
instead of the standard 16-byte password.</p>

<p style="margin-top: 1em">--help Display a brief help
message and exit.</p>

<p style="margin-top: 1em">--fet-list <br>
Display a list of chips supported by the FET driver (the
driver used for UIF, RF2500 and Olimex devices).</p>

<p style="margin-top: 1em">--fet-force-id string <br>
When using a FET device, force the connected chip to be
recognised by MSPDebug as one of the given type during
initialization. This overrides the device ID returned by the
<br>
FET. The given string should be a chip name in long form,
for example &quot;MSP430F2274&quot;.</p>

<p style="margin-top: 1em">--fet-skip-close <br>
When using a FET device, skip the JTAG close procedure when
disconnecting. With some boards, this removes the need to
replug the debugger after use.</p>

<p style="margin-top: 1em">--usb-list <br>
List available USB devices and exit.</p>

<p style="margin-top: 1em">--force-reset <br>
When using a FET device, always send a reset during
initialization. By default, an initialization without reset
will be tried first.</p>

<p style="margin-top: 1em">--allow-fw-update <br>
When using a V3 FET device via the TI library, allow the
library to perform a firmware update if the FET firmware is
incompatible with the library.</p>

<p style="margin-top: 1em">--require-fw-update image.txt
<br>
When using a V3 FET device, or certain Olimex devices, force
a firmware update using the given firmware image. The
firmware format depends on the driver.</p>

<p style="margin-top: 1em">--version <br>
Show program version and copyright information.</p>

<p style="margin-top: 1em">--embedded <br>
Start mspdebug as an embedded subprocess. See the
documentation accompanying the source release for more
information on embedded mode.</p>

<p style="margin-top: 1em">--bsl-entry-sequence seq <br>
Specify a BSL entry sequence. Each character specifies a
modem control line transition (R: RTS on, r: RTS off, D: DTR
on, d: DTR off). A comma indicates a delay. The entry <br>
and exit sequences are separated by a colon. The default
value is dR,r,R,r,R,D:dR,DR, for the flash-bsl driver.</p>

<p style="margin-top: 1em">DRIVERS <br>
For drivers supporting both USB and tty access, USB is the
default, unless specified otherwise (see -d above).</p>

<p style="margin-top: 1em">On Linux, if USB access is used,
the kernel driver (if any) is detached from the tty device.
If further access to the tty device is needed, unloading and
re-loading of the driver <br>
(e.g. cdc-acm.ko) is required.</p>

<p style="margin-top: 1em">A driver name must be specified
on the command line for MSPDebug to connect to. Valid driver
names are listed here.</p>

<p style="margin-top: 1em">rf2500 Connect to an
eZ430-RF2500, Launchpad or Chronos device. Only USB
connection is supported.</p>

<p style="margin-top: 1em">olimex Connect to an Olimex
MSP430-JTAG-TINY device. Both USB and tty access are
supported.</p>

<p style="margin-top: 1em">olimex-v1 <br>
Connect to an Olimex MSP430-JTAG-TINY (V1) device. Both USB
and tty access are supported. This driver must be used
instead of olimex if connecting to a V1 device via a tty
<br>
interface.</p>

<p style="margin-top: 1em">olimex-iso <br>
Connect to an Olimex MSP430-JTAG-ISO device. Both USB and
tty access are supported.</p>

<p style="margin-top: 1em">olimex-iso-mk2 <br>
Connect to an Olimex MSP430-JTAG-ISO-MK2 device. Both USB
and tty access are supported.</p>

<p style="margin-top: 1em">sim Do not connect to any
hardware device, but instead start in simulation mode. A 64k
buffer is allocated to simulate the device memory.</p>

<p style="margin-top: 1em">During simulation, addresses
below 0x0200 are assumed to be IO memory. Programmed IO
writes to and from IO memory are handled by the IO
simulator, which can be configured <br>
and controlled with the simio command, described below.</p>

<p style="margin-top: 1em">This mode is intended for
testing of changes to MSPDebug, and for aiding the
disassembly of MSP430 binaries (as all binary and symbol
table formats are still usable in <br>
this mode).</p>

<p style="margin-top: 1em">uif Connect to an eZ430-F2013 or
a FET430UIF device. The device argument should be the
filename of the appropriate tty device. The TI serial
converter chips on these devices <br>
are supported by newer versions of the Linux kernel, and
should appear as /dev/ttyXX when attached.</p>

<p style="margin-top: 1em">USB connection is supported for
this driver. The USB interface chip in these devices is a
TI3410, which requires a firmware download on startup.
MSPDebug will search for a <br>
file called ti_3410.fw.ihex in the configured library
directory and the current directory. You can specify an
alternate location for the file via the MSPDEBUG_TI3410_FW
<br>
environment variable.</p>

<p style="margin-top: 1em">uif-bsl <br>
Connect to the bootloader on a FET430UIF device. These
devices contain MSP430F1612 chips. By sending a special
command sequence, you can obtain access to the bootloader
<br>
and inspect memory on the MSP430F1612 in the programming
device itself.</p>

<p style="margin-top: 1em">Currently, only memory
read/write and erase are supported. CPU control via the
bootloader is not possible.</p>

<p style="margin-top: 1em">flash-bsl <br>
Connect to the built-in bootloader in MSP430 devices with
flash bootloader memory. Devices with ROM bootloaders
require another driver. Currently, this driver must mass-
<br>
erase the device in order to gain access. Read, write, and
erase operations are supported.</p>

<p style="margin-top: 1em">USB connection is not supported
for this driver. Connection is via serial port, and
bootloader entry is accomplished via the RTS and DTR lines.
Connect RTS to the <br>
device&rsquo;s TEST pin and DTR to the device&rsquo;s RST
pin. Use an appropriate serial level-shifter to make the
connection, if necessary. If connecting to a device with
non-mul&acirc; <br>
tiplexed JTAG pins, connect RTS to the device&rsquo;s TCK
pin via an inverter.</p>

<p style="margin-top: 1em">gdbc GDB client mode. Connect to
a server which implements the GDB remote protocol and
provide an interface to it. To use this driver, specify the
remote address in host&acirc; <br>
name:port format using the -d option.</p>

<p style="margin-top: 1em">tilib Use the Texas Instruments
MSP430.DLL to access the device. The library file
(MSP430.DLL for Windows, libmsp430.so for Unix-like systems)
must be present in the dynamic <br>
loader search path.</p>

<p style="margin-top: 1em">USB connection is not supported
for this driver. This driver supports watchpoints. Note that
the -d option for this driver passes its argument straight
through to the <br>
library&rsquo;s MSP430_Initialize function. Any special
argument supported by that function is therefore accessible
via the -d option.</p>

<p style="margin-top: 1em">Automatic device discovery works
only on Linux and Windows. On other systems, the appropriate
ACM serial node must be explicitly specified.</p>

<p style="margin-top: 1em">goodfet <br>
Connect to a GoodFET device. JTAG mode must be used, and
only tty access is supported. This device can be used for
memory access (read, erase and program), but CPU control
<br>
is limited. The CPU may be halted, run and reset, but
register access and breakpoints aren&rsquo;t supported.</p>

<p style="margin-top: 1em">pif Connect to a parallel-port
JTAG controller. JTAG mode must be used, and only tty access
is supported. Currently, this driver is only supported on
Linux, FreeBSD and Drag&acirc; <br>
onFly BSD. A parallel port device (ppdev on Linux, ppi on
FreeBSD and DragonFly BSD) must be specified via the -d
option.</p>

<p style="margin-top: 1em">gpio Connect to system gpios.
JTAG mode must be used, and only tty access is supported.
Currently, this driver is only supported on Linux, FreeBSD
and DragonFly BSD. The gpios <br>
to used must defined using a string like &quot;tdi=7 tdo=8
tms=9 tck=4&quot; via the -d option. (dont forget the
quotes)</p>

<p style="margin-top: 1em">load-bsl <br>
Connect to a USB bootloader. The stub bootloader will be
used to load a fuller-featured bootloader into RAM for
execution.</p>

<p style="margin-top: 1em">ezfet This driver is for Texas
Instruments&rsquo; eZ-FET devices. It supports USB and tty
access. It does not support breakpoint control.</p>

<p style="margin-top: 1em">rom-bsl <br>
This driver is for the old-style (ROM) bootstrap loader. It
supports tty access only. Entry is attempted via the RTS/DTR
signals. The default sequence is <br>
DR,r,R,r,d,R:DR,r, but you can override this with the
--bsl-entry-sequence option.</p>

<p style="margin-top: 1em">WARNING: this driver unlocks the
BSL by performing a mass erase. There are reports of this
operation causing an erase of info A in some devices. Use at
your own risk.</p>

<p style="margin-top: 1em">COMMANDS <br>
MSPDebug can accept commands either through an interactive
prompt, or non-interactively when specified on the command
line. The supported commands are listed below.</p>

<p style="margin-top: 1em">Commands take arguments
separated by spaces. Any text string enclosed in
double-quotation marks is considered to be a single
argument, even if it contains space characters. <br>
Within a quoted string, the usual C-style backslash
substitutions can be used.</p>

<p style="margin-top: 1em">Commands can be specified by
giving the first few characters of the command name,
provided that the prefix is unambiguous. Some commands
support automatic repeat. For these com&acirc; <br>
mands, pressing enter at the reader prompt without typing
anything will cause repeat execution.</p>

<p style="margin-top: 1em">! [command [args ...]] <br>
Invoke an interactive operating system shell. If any
arguments are specified, the first one is taken as a command
to execute, with the rest of the arguments as the
argu&acirc; <br>
ments to the command.</p>

<p style="margin-top: 1em">This command is not yet
available on non-POSIX systems.</p>

<p style="margin-top: 1em">= expression <br>
Evaluate an address expression and show both its value, and
the result when the value is looked up in reverse in the
current symbol table. This result is of the form sym&acirc;
<br>
bol+offset, where symbol is the name of the nearest symbol
not past the address in question.</p>

<p style="margin-top: 1em">See the section marked ADDRESS
EXPRESSIONS for more information on the syntax of
expressions.</p>

<p style="margin-top: 1em">alias Show a list of defined
command aliases.</p>

<p style="margin-top: 1em">alias name <br>
Remove a previously defined command alias.</p>

<p style="margin-top: 1em">alias name command <br>
Define a command alias. The text command will be substituted
for name when looking up commands. The given command text
may contain a command plus arguments, if the entire <br>
text is wrapped in quotes when defining the alias. To avoid
alias substitution when interpreting commands, prefix the
command with &nbsp;(a backslash character).</p>

<p style="margin-top: 1em">blow_jtag_fuse <br>
Blow the device&rsquo;s JTAG fuse.</p>

<p style="margin-top: 1em">WARNING: this is an irreversible
operation!</p>

<p style="margin-top: 1em">break Show a list of active
breakpoints. Breakpoints can be added and removed with the
setbreak and delbreak commands. Each breakpoint is numbered
with an integer index starting <br>
at 0.</p>

<p style="margin-top: 1em">cgraph address length [address]
<br>
Construct the call graph of all functions contained or
referenced in the given range of memory. If a particular
function is specified, then details for that node of the
<br>
graph are displayed. Otherwise, a summary of all nodes is
displayed.</p>

<p style="margin-top: 1em">Information from the symbol
table is used for hinting at the possible locations of
function starts. Any symbol which does not contain a
&quot;.&quot; is considered a possible func&acirc; <br>
tion start.</p>

<p style="margin-top: 1em">Callers and callee names are
shown prefixed by a &quot;*&quot; where the transition is a
tail-call type transition.</p>

<p style="margin-top: 1em">delbreak [index] <br>
Delete one or all breakpoints. If an index is given, the
selected breakpoint is deleted. Otherwise, all breakpoints
are cleared.</p>

<p style="margin-top: 1em">dis address [length] <br>
Dissassemble a section of memory. Both arguments may be
address expressions. If no length is specified, a section of
the default length (64 bytes) is disassembled and <br>
shown.</p>

<p style="margin-top: 1em">If symbols are available, then
all addresses used as operands are translated into
symbol+offset form.</p>

<p style="margin-top: 1em">This command supports repeat
execution. If repeated, it continues to disassemble another
block of memory following that last printed.</p>

<p style="margin-top: 1em">erase [all|segment|segrange]
[address] [size] [segrange] <br>
Erase the device under test. With no arguments, all code
memory is erased (but not information or boot memory). With
the argument &quot;all&quot;, a mass erase is performed (the
<br>
results may depend on the state of the LOCKA bit in the
flash memory controller).</p>

<p style="margin-top: 1em">Specify &quot;segment&quot; and
a memory address to erase an individual flash segment.
Specify &quot;segrange&quot;, an address, size and segment
size to erase an arbitrary set of contiguous <br>
segments.</p>

<p style="margin-top: 1em">exit Exit from MSPDebug.</p>

<p style="margin-top: 1em">fill address length b0 [b1 b2
...] <br>
Fill the memory region of size length starting at address
with the pattern of bytes given (specified in hexadecimal).
The pattern will be repeated without padding as many <br>
times as necessary without exceeding the bounds of the
specified region.</p>

<p style="margin-top: 1em">gdb [port] <br>
Start a GDB remote stub, optionally specifying a TCP port to
listen on. If no port is given, the default port is
controlled by the option gdb_default_port.</p>

<p style="margin-top: 1em">MSPDebug will wait for a
connection on this port, and then act as a GDB remote stub
until GDB disconnects.</p>

<p style="margin-top: 1em">GDB&rsquo;s &quot;monitor&quot;
command can be used to issue MSPDebug commands via the GDB
interface. Supplied commands are executed non-interactively,
and the output is sent back to be <br>
displayed in GDB.</p>

<p style="margin-top: 1em">help [command] <br>
Show a brief listing of available commands. If an argument
is specified, show the syntax for the given command. The
help text shown when no argument is given is also shown <br>
when MSPDebug starts up.</p>

<p style="margin-top: 1em">hexout address length filename
<br>
Read the specified section of the device memory and save it
to an Intel HEX file. The address and length arguments may
both be address expressions.</p>

<p style="margin-top: 1em">If the specified file already
exists, then it will be overwritten. If you need to dump
memory from several disjoint memory regions, you can do this
by saving each section <br>
to a separate file. The resulting files can then be
concatenated together to form a single valid HEX file.</p>

<p style="margin-top: 1em">isearch address length [options
...] <br>
Search over the given range for an instruction which matches
the specified search criteria. The search may be narrowed by
specifying one or more of the following terms:</p>

<p style="margin-top: 1em">opcode opcode <br>
Match the specified opcode. Byte/word specifiers are not
recognised, as they are specified with other options.</p>

<p style="margin-top: 1em">byte Match only byte
operations.</p>

<p style="margin-top: 1em">word Match only word
operations.</p>

<p style="margin-top: 1em">aword Match only address-word
(20-bit) operations.</p>

<p style="margin-top: 1em">jump Match only jump
instructions (conditional and unconditional jumps, but not
instructions such as BR which load the program counter
explicitly).</p>

<p style="margin-top: 1em">single Match only single-operand
instructions.</p>

<p style="margin-top: 1em">double Match only double-operand
instructions.</p>

<p style="margin-top: 1em">noarg Match only instructions
with no arguments.</p>

<p style="margin-top: 1em">src address <br>
Match instructions with the specified value in the source
operand. The value may be given as an address expression.
Specifying this option implies matching of only <br>
double-operand instructions.</p>

<p style="margin-top: 1em">dst address <br>
Match instructions with the specified value in the
destination operand. This option implies that no-argument
instructions are not matched.</p>

<p style="margin-top: 1em">srcreg register <br>
Match instructions using the specified register in the
source operand. This option implies matching of only
double-operand instructions.</p>

<p style="margin-top: 1em">dstreg register <br>
Match instructions using the specified register in the
destination operand. This option implies that no-argument
instructions are not matched.</p>

<p style="margin-top: 1em">srcmode mode <br>
Match instructions using the specified mode in the source
operand. See below for a list of modes recognised. This
option implies matching of only double-operand <br>
instructions.</p>

<p style="margin-top: 1em">dstmode mode <br>
Match instructions using the specified mode in the
destination operand. See below for a list of modes. This
option implies that no-argument instructions are not <br>
matched.</p>

<p style="margin-top: 1em">For single-operand instructions,
the operand is considered to be the destination operand.</p>

<p style="margin-top: 1em">The seven addressing modes used
by the MSP430 are represented by single characters, and are
listed here:</p>

<p style="margin-top: 1em">R Register mode.</p>

<p style="margin-top: 1em">I Indexed mode.</p>

<p style="margin-top: 1em">S Symbolic mode.</p>

<p style="margin-top: 1em">&amp; Absolute mode.</p>

<p style="margin-top: 1em">@ Register-indirect mode.</p>

<p style="margin-top: 1em">+ Register-indirect mode with
auto-increment.</p>

<p style="margin-top: 1em"># Immediate mode.</p>

<p style="margin-top: 1em">load filename <br>
Program the device under test using the binary file
supplied. This command is like prog, but it does not load
symbols or erase the device before programming.</p>

<p style="margin-top: 1em">The CPU is reset and halted
before and after programming.</p>

<p style="margin-top: 1em">load_raw filename address <br>
Write the data contained in a raw binary file to the given
memory address.</p>

<p style="margin-top: 1em">The CPU is reset and halted
before and after programming.</p>

<p style="margin-top: 1em">md address [length] <br>
Read the specified section of device memory and display it
as a canonical-style hexdump. Both arguments may be address
expressions. If no length is specified, a section of <br>
the default length (64 bytes) is shown.</p>

<p style="margin-top: 1em">The output is split into three
columns. The first column shows the starting address for the
line. The second column lists the hexadecimal values of the
bytes. The final <br>
column shows the ASCII characters corresponding to printable
bytes, and . for non-printing characters.</p>

<p style="margin-top: 1em">This command supports repeat
execution. If repeated, it continues to print another block
of memory following that last printed.</p>

<p style="margin-top: 1em">mw address bytes ... <br>
Write a sequence of bytes at the given memory address. The
address given may be an address expression. Bytes values are
two-digit hexadecimal numbers separated by spaces.</p>

<p style="margin-top: 1em">opt [name] [value] <br>
Query, set or list option variables. MSPDebug&rsquo;s
behaviour can be configured using option variables,
described below in the section OPTIONS.</p>

<p style="margin-top: 1em">Option variables may be of three
types: boolean, numeric or text. Numeric values may be
specified as address expressions.</p>

<p style="margin-top: 1em">With no arguments, this command
displays all available option variables. With just an option
name as its argument, it displays the current value of that
option.</p>

<p style="margin-top: 1em">power info <br>
Show basic power statistics gathered over the last few
sessions. This includes total charge consumption, run time
and average current.</p>

<p style="margin-top: 1em">power clear <br>
Clear all recorded power statistics.</p>

<p style="margin-top: 1em">power all [granularity] <br>
Show sample data gathered over all sessions. An optional
granularity can be specified, in microseconds. For each time
slice, relative session time, charge consumption, <br>
current consumption and approximate code location are
shown.</p>

<p style="margin-top: 1em">power session N [granularity]
<br>
Same as power all, except that data is shown only for the
Nth session.</p>

<p style="margin-top: 1em">power export-csv N filename <br>
Export raw sample data for the Nth session to the given file
in CSV format. For each line, the columns are, in order:
relative time in microseconds, current consumption in <br>
microamps, memory address.</p>

<p style="margin-top: 1em">power profile <br>
If a symbol table is loaded, compile and correlate all
gathered power data against the symbol table. A single table
is then shown listing, per function, charge consump&acirc;
<br>
tion, run time and average current. The functions are listed
in order of charge consumption (biggest consumers
first).</p>

<p style="margin-top: 1em">prog filename <br>
Erase and reprogram the device under test using the binary
file supplied. The file format will be auto-detected and may
be any of the supported file formats.</p>

<p style="margin-top: 1em">In the case of a file containing
symbols, symbols will be automatically loaded from the file
into the symbol table (discarding any existing symbols), if
they are present.</p>

<p style="margin-top: 1em">The CPU is reset and halted
before and after programming.</p>

<p style="margin-top: 1em">read filename <br>
Read commands from the given file, line by line and process
each one. Any lines whose first non-space character is # are
ignored. If an error occurs while processing a <br>
command, the rest of the file is not processed.</p>

<p style="margin-top: 1em">regs Show the current value of
all CPU registers in the device under test.</p>

<p style="margin-top: 1em">reset Reset (and halt) the CPU
of the device under test.</p>

<p style="margin-top: 1em">run Start running the CPU. The
interactive command prompt is blocked when the CPU is
started and the prompt will not appear again until the CPU
halts. The CPU will halt if it <br>
encounters a breakpoint, or if Ctrl-C is pressed by the
user.</p>

<p style="margin-top: 1em">After the CPU halts, the current
register values are shown as well as a disassembly of the
first few instructions at the address selected by the
program counter.</p>

<p style="margin-top: 1em">save_raw address length filename
<br>
Save a region of memory to a raw binary file. The address
and length arguments may both be address expressions.</p>

<p style="margin-top: 1em">If the specified file already
exists, then it will be overwritten.</p>

<p style="margin-top: 1em">set register value <br>
Alter the value of a register. Registers are specified as
numbers from 0 through 15. Any leading non-numeric
characters are ignored (so a register may be specified as,
for <br>
example, &quot;R12&quot;). The value argument is an address
expression.</p>

<p style="margin-top: 1em">setbreak address [index] <br>
Add a new breakpoint. The breakpoint location is an address
expression. An optional index may be specified, indicating
that this new breakpoint should overwrite an exist&acirc;
<br>
ing slot. If no index is specified, then the breakpoint will
be stored in the next unused slot.</p>

<p style="margin-top: 1em">setwatch address [index] <br>
Add a new watchpoint. The watchpoint location is an address
expression, and an optional index may be specified.
Watchpoints are considered to be a type of breakpoint and
<br>
can be inspected or removed using the break and delbreak
commands. Note that not all drivers support watchpoints.</p>

<p style="margin-top: 1em">setwatch_r address [index] <br>
Add a watchpoint which is triggered only on read access.</p>

<p style="margin-top: 1em">setwatch_w address [index] <br>
Add a watchpoint which is triggered only on write
access.</p>

<p style="margin-top: 1em">simio add class name [args ...]
<br>
Add a new peripheral to the IO simulator. The class
parameter may be any of the peripheral types named in the
output of the simio classes command. The name parameter is a
<br>
unique name assigned by the user to this peripheral
instance, and is used with other commands to refer to this
instance of the peripheral.</p>

<p style="margin-top: 1em">Some peripheral classes take
arguments upon creation. These are documented in the output
to the simio help command.</p>

<p style="margin-top: 1em">simio classes <br>
List the names of the different types of peripherals which
may be added to the simulator. You can use the simio help
command to obtain more information about each periph&acirc;
<br>
eral type.</p>

<p style="margin-top: 1em">simio config name param [args
...] <br>
Configure or perform some action on a peripheral instance.
The param argument is specific to the peripheral type. A
list of valid configuration commands can be obtained by <br>
using the simio help command.</p>

<p style="margin-top: 1em">simio del name <br>
Remove a previously added peripheral instance. The name
argument should be the name of the peripheral that was
assigned with the simio add command.</p>

<p style="margin-top: 1em">simio devices <br>
List all peripheral instances currently attached to the
simulator, along with their types and interrupt status. You
can obtain more detailed information for each instance <br>
with the simio info command.</p>

<p style="margin-top: 1em">simio help class <br>
Obtain more information about a peripheral class. The
documentation given will list constructor arguments and
configuration parameters for the device type.</p>

<p style="margin-top: 1em">simio info name <br>
Display detailed status information for a particular
peripheral. The type of information displayed is specific to
each type of peripheral.</p>

<p style="margin-top: 1em">step [count] <br>
Step the CPU through one or more instructions. After
stepping, the new register values are displayed, as well as
a disassembly of the instructions at the address selected
<br>
by the program counter.</p>

<p style="margin-top: 1em">An optional count can be
specified to step multiple times. If no argument is given,
the CPU steps once. This command supports repeat
execution.</p>

<p style="margin-top: 1em">sym clear <br>
Clear the symbol table, deleting all symbols.</p>

<p style="margin-top: 1em">sym set name value <br>
Set or alter the value of a symbol. The value given may be
an address expression.</p>

<p style="margin-top: 1em">sym del name <br>
Delete the given symbol from the symbol table.</p>

<p style="margin-top: 1em">sym import filename <br>
Load symbols from the specified file and add them to the
symbol table. The file format will be auto-detected and may
be either ELF32 or a BSD-style symbol listing (like <br>
the output from nm(1)).</p>

<p style="margin-top: 1em">Symbols can be combined from
many sources, as the syms command adds to the existing
symbol table without discarding existing symbols.</p>

<p style="margin-top: 1em">sym import+ filename <br>
This command is similar to sym import, except that the
symbol table is not cleared first. By using this command,
symbols from multiple sources can be combined.</p>

<p style="margin-top: 1em">sym export filename <br>
Save all symbols currently defined to the given file. The
symbols are saved as a BSD-style symbol table. Note that
symbol types are not stored by MSPDebug, and all symbols
<br>
are saved as type t.</p>

<p style="margin-top: 1em">sym find [regex] <br>
Search for symbols. If a regular expression is given, then
all symbols matching the expression are printed. If no
expression is specified, then the entire symbol table is
<br>
listed.</p>

<p style="margin-top: 1em">sym rename regex string <br>
Rename symbols by searching for those matching the given
regular expression and substituting the given string for the
matched portion. The symbols renamed are displayed, <br>
as well as a total count of all symbols renamed.</p>

<p style="margin-top: 1em">verify filename <br>
Compare the contents of the given binary file to the chip
memory. If any differences are found, a message is printed
for the first mismatched byte.</p>

<p style="margin-top: 1em">verify_raw filename address <br>
Compare the contents of a raw binary file to the device
memory at the given address. If any differences are found, a
message is printed for the first mismatched byte.</p>

<p style="margin-top: 1em">BINARY FORMATS <br>
The following binary/symbol formats are supported by
MSPDebug:</p>

<p style="margin-top: 1em">ELF32 <br>
COFF <br>
Intel HEX (program only) <br>
BSD symbol table (symbols only) <br>
TI Text (program only) <br>
SREC (program only)</p>

<p style="margin-top: 1em">IO SIMULATOR <br>
The IO simulator subsystem consists of a database of device
classes, and a list of instances of those classes. Each
device class has a different set of constructor arguments,
<br>
configuration parameters and information which may be
displayed. This section describes the operation of the
available device classes in detail.</p>

<p style="margin-top: 1em">In the list below, each device
class is listed, followed by its constructor arguments.</p>

<p style="margin-top: 1em">gpio Digital IO port simulator.
This device simulates any of the digital ports with or
without interrupt capability. It has the following
configuration parameters:</p>

<p style="margin-top: 1em">base address <br>
Set the base address for this port. Note that for ports
without interrupt capability, the resistor enable port has a
special address which is computable from the <br>
base address.</p>

<p style="margin-top: 1em">irq vector <br>
Enable interrupt functionality for this port by specifying
an interrupt vector number.</p>

<p style="margin-top: 1em">noirq Disable interrupt
functionality for this port.</p>

<p style="margin-top: 1em">verbose <br>
Print a state change message every time the port output
changes.</p>

<p style="margin-top: 1em">quiet Don&rsquo;t print anything
when the port state changes (the default).</p>

<p style="margin-top: 1em">set pin value <br>
Set the input pin state for the given pin on this port. The
pin parameter should be an index between 0 and 7. The value
should be either zero (for a low state) or <br>
non-zero (for a high state).</p>

<p style="margin-top: 1em">hwmult This peripheral simulates
the hardware multiplier. It has no constructor or
configuration parameters, and does not provide any extended
information.</p>

<p style="margin-top: 1em">timer [size] <br>
This peripheral simulators Timer_A modules, and can be used
to simulate Timer_B modules, provided that the extended
features aren&rsquo;t required.</p>

<p style="margin-top: 1em">The constructor takes a size
argument specifying the number of capture/compare registers
in this peripheral instance. The number of such registers
may not be less than 2, <br>
or greater than 7.</p>

<p style="margin-top: 1em">The IO addresses and IRQs used
are configurable. The default IO addresses used are those
specified for Timer_A in the MSP430 hardware
documentation.</p>

<p style="margin-top: 1em">base address <br>
Alter the base IO address. By default, this is 0x0160. By
setting this to 0x0180, a Timer_B module may be
simulated.</p>

<p style="margin-top: 1em">irq0 number <br>
Set the TACCR0 interrupt vector number. By default, this is
interrupt vector 9. This interrupt is self-clearing, and
higher priority than the TACCR1/TAIFG vector.</p>

<p style="margin-top: 1em">irq1 number <br>
Set the TACCR1/TAIFG interrupt vector. By default, this is
interrupt vector 8.</p>

<p style="margin-top: 1em">iv address <br>
Alter the address of the interrupt vector register. By
default, this is 0x012E. By setting this to 0x011E, a
Timer_B module may be simulated.</p>

<p style="margin-top: 1em">set channel value <br>
When Timer_A is used in capture mode, the CCI bit in each
capture register reflects the state of the corresponding
input pin, and can&rsquo;t be altered in software. This <br>
configuration command can be used to simulate changes in
input pin state, and will trigger the corresponding
interrupts if the peripheral is so configured.</p>

<p style="margin-top: 1em">tracer [history-size] <br>
The tracer peripheral is a debugging device. It can be used
to investigate and record the IO activity of a running
program, to benchmark execution time, and to simulate <br>
interrupts.</p>

<p style="margin-top: 1em">The information displayed by the
tracer gives a running count of clock cycles from each of
the system clocks, and an instruction count. A list of the N
most recent IO <br>
events is also displayed (this is configurable via the
history-size argument of the constructor). Each IO event is
timestamped by the number of MCLK cycles that have <br>
elapsed since the last reset of the device&rsquo;s
counter.</p>

<p style="margin-top: 1em">The IO events that it records
consist of programmed IO reads and writes, interrupt
acceptance, and system resets. As well as keeping the IO
events in a rotating buffer, <br>
the tracer can be configured to display the events as they
occur.</p>

<p style="margin-top: 1em">Note that since clock cycles
don&rsquo;t advance while the CPU isn&rsquo;t running, this
peripheral can be used to calculate execution times for
blocks of code. This can be achieved <br>
by setting a breakpoint at the end of the code block,
setting the program counter to the start of the code block,
clearing the tracer and running the code. After the <br>
breakpoint is reached, the information displayed by the
tracer will contain a count of MCLK cycles elapsed during
the last run.</p>

<p style="margin-top: 1em">The configuration parameters for
this device class are:</p>

<p style="margin-top: 1em">verbose <br>
Start displaying IO events as they occur, as well as
recording them in the rotating buffer.</p>

<p style="margin-top: 1em">quiet Stop displaying IO events
as they occur, and just record them in the buffer.</p>

<p style="margin-top: 1em">trigger irq <br>
Signal an interrupt request to the CPU. This request will
remain raised until accepted by the CPU or cleared by the
user.</p>

<p style="margin-top: 1em">untrigger <br>
Clear a signalled interrupt request.</p>

<p style="margin-top: 1em">clear Reset the clock cycle and
instruction counts to 0, and clear the IO event history.</p>

<p style="margin-top: 1em">wdt This peripheral simulates
the Watchdog Timer+, which can be used in software either as
a watchdog or as an interval timer. It has no constructor
arguments.</p>

<p style="margin-top: 1em">The simulated state of the
NMI/RST# pin can be controlled through a configuration
parameter. Note that if this pin state is held low with the
pin mode selected as a reset <br>
(the default), the CPU will not run.</p>

<p style="margin-top: 1em">The extended information for
this peripheral shows all register states, including the
hidden counter register. Configuration parameters are:</p>

<p style="margin-top: 1em">nmi state <br>
Set the NMI/RST# pin state. The argument should be zero to
indicate a low state or non-zero for a high state.</p>

<p style="margin-top: 1em">irq irq <br>
Select the interrupt vector for interval timer mode. The
default is to use interrupt vector 10.</p>

<p style="margin-top: 1em">ADDRESS EXPRESSIONS <br>
Any command which accepts a memory address, length or
register value as an argument may be given an address
expression. An address expression consists of an algebraic
combination <br>
of values.</p>

<p style="margin-top: 1em">An address value may be either a
symbol name, a hex value preceded with the specifier
&quot;0x&quot;, a decimal value preceded with the specifier
&quot;0d&quot;, or a number in the default input <br>
radix (without a specifier). See the option iradix for more
information.</p>

<p style="margin-top: 1em">The operators recognised are the
usual algebraic operators: +, -, *, /, %, ( and ). Operator
precedence is the same as in C-like languages, and the -
operator may be used as a <br>
unary negation operator.</p>

<p style="margin-top: 1em">The following are all valid
examples of address expressions:</p>

<p style="margin-top: 1em">2+2 <br>
table_start + (elem_size + elem_pad)*4 <br>
main+0x3f <br>
__bss_end-__bss_start</p>

<p style="margin-top: 1em">OPTIONS <br>
MSPDebug&rsquo;s behaviour can be configured via the
following variables:</p>

<p style="margin-top: 1em">color (boolean) <br>
If true, MSPDebug will colorize debugging output.</p>

<p style="margin-top: 1em">fet_block_size (numeric) <br>
Change the size of the buffer used to transfer memory to and
from the FET. Increasing the value from the default of 64
will improve transfer speed, but may cause problems <br>
with some chips.</p>

<p style="margin-top: 1em">enable_bsl_access (boolean) <br>
If set, some drivers will allow erase/program access to
flash BSL memory. If in doubt, do not enable this.</p>

<p style="margin-top: 1em">enable_locked_flash_access
(boolean) <br>
If set, some drivers will allow erase/program access to the
info A segment. If in doubt, do not enable this. Currently,
the tilib and uif drivers are affected by this <br>
option.</p>

<p style="margin-top: 1em">enable_fuse_blow <br>
If set, some drivers will allow the JTAG security fuse to be
blown.</p>

<p style="margin-top: 1em">WARNING: this is an irreversible
operation!</p>

<p style="margin-top: 1em">If in doubt, do not enable this
option.</p>

<p style="margin-top: 1em">gdb_default_port (numeric) <br>
This option controls the default TCP port for the GDB
server, if no argument is given to the &quot;gdb&quot;
command.</p>

<p style="margin-top: 1em">gdb_loop (boolean) <br>
Automatically restart the GDB server after disconnection. If
this option is set, then the GDB server keeps running until
an error occurs, or the user interrupts with <br>
Ctrl+C.</p>

<p style="margin-top: 1em">gdbc_xfer_size (numeric) <br>
Maximum size of memory transfers for the GDB client.
Increasing this value will result in faster transfers, but
may cause problems with some servers.</p>

<p style="margin-top: 1em">iradix (numeric) <br>
Default input radix for address expressions. For address
values with no radix specifier, this value gives the input
radix, which is 10 (decimal) by default.</p>

<p style="margin-top: 1em">quiet (boolean) <br>
If set, MSPDebug will supress most of its debug-related
output. This option defaults to false, but can be set true
on start-up using the -q command-line option.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
MSPDEBUG_TI3410_FW <br>
Specifies the location of TI3410 firmware, for raw USB
access to FET430UIF or eZ430 devices. This variable should
contain the path to an Intel HEX file containing suitable
<br>
firmware for the TI3410.</p>

<p style="margin-top: 1em">FILES <br>
~/.mspdebug <br>
File containing commands to be executed on startup.</p>

<p style="margin-top: 1em">ti_3410.fw.ihex <br>
Firmware image for the TI3410 USB interface chip. This file
is only required for raw USB access to FET430UIF or eZ430
devices.</p>

<p style="margin-top: 1em">SEE ALSO <br>
nm(1), gdb(1), objcopy(1)</p>

<p style="margin-top: 1em">BUGS <br>
If you find any bugs, you should report them to the author
at dlbeer@gmail.com. It would help if you could include a
transcript of an MSPDebug session illustrating the program,
<br>
as well as any relevant binaries or other files.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (C) 2009-2013 Daniel Beer
&lt;dlbeer@gmail.com&gt;</p>

<p style="margin-top: 1em">MSPDebug is free software,
distributed under the terms of the GNU General Public
license (version 2 or later). See the file COPYING included
with the source code for more <br>
details.</p>

<p style="margin-top: 1em">Version 0.23 2 Mar 2015
mspdebug(1)</p>
<hr>
</body>
</html>
