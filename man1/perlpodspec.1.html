<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:02 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLPODSPEC(1) Perl Programmers Reference Guide
PERLPODSPEC(1)</p>

<p style="margin-top: 1em">NAME <br>
perlpodspec - Plain Old Documentation: format specification
and notes</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This document is detailed notes on the Pod markup language.
Most people will only have to read perlpod to know how to
write in Pod, but this document may answer some incidental
<br>
questions to do with parsing and rendering Pod.</p>

<p style="margin-top: 1em">In this document,
&quot;must&quot; / &quot;must not&quot;, &quot;should&quot;
/ &quot;should not&quot;, and &quot;may&quot; have their
conventional (cf. RFC 2119) meanings: &quot;X must do
Y&quot; means that if X doesn&rsquo;t do Y, it&rsquo;s <br>
against this specification, and should really be fixed.
&quot;X should do Y&quot; means that it&rsquo;s recommended,
but X may fail to do Y, if there&rsquo;s a good reason.
&quot;X may do Y&quot; is merely a <br>
note that X can do Y at will (although it is up to the
reader to detect any connotation of &quot;and I think it
would be nice if X did Y&quot; versus &quot;it
wouldn&rsquo;t really bother me if X did <br>
Y&quot;).</p>

<p style="margin-top: 1em">Notably, when I say &quot;the
parser should do Y&quot;, the parser may fail to do Y, if
the calling application explicitly requests that the parser
not do Y. I often phrase this as &quot;the <br>
parser should, by default, do Y.&quot; This doesn&rsquo;t
require the parser to provide an option for turning off
whatever feature Y is (like expanding tabs in verbatim
paragraphs), <br>
although it implicates that such an option may be
provided.</p>

<p style="margin-top: 1em">Pod Definitions <br>
Pod is embedded in files, typically Perl source files,
although you can write a file that&rsquo;s nothing but
Pod.</p>

<p style="margin-top: 1em">A line in a file consists of
zero or more non-newline characters, terminated by either a
newline or the end of the file.</p>

<p style="margin-top: 1em">A newline sequence is usually a
platform-dependent concept, but Pod parsers should
understand it to mean any of CR (ASCII 13), LF (ASCII 10),
or a CRLF (ASCII 13 followed <br>
immediately by ASCII 10), in addition to any other
system-specific meaning. The first CR/CRLF/LF sequence in
the file may be used as the basis for identifying the
newline <br>
sequence for parsing the rest of the file.</p>

<p style="margin-top: 1em">A blank line is a line
consisting entirely of zero or more spaces (ASCII 32) or
tabs (ASCII 9), and terminated by a newline or end-of-file.
A non-blank line is a line containing <br>
one or more characters other than space or tab (and
terminated by a newline or end-of-file).</p>

<p style="margin-top: 1em">(Note: Many older Pod parsers
did not accept a line consisting of spaces/tabs and then a
newline as a blank line. The only lines they considered
blank were lines consisting of no <br>
characters at all, terminated by a newline.)</p>

<p style="margin-top: 1em">Whitespace is used in this
document as a blanket term for spaces, tabs, and newline
sequences. (By itself, this term usually refers to literal
whitespace. That is, sequences of <br>
whitespace characters in Pod source, as opposed to
&quot;E&lt;32&gt;&quot;, which is a formatting code that
denotes a whitespace character.)</p>

<p style="margin-top: 1em">A Pod parser is a module meant
for parsing Pod (regardless of whether this involves calling
callbacks or building a parse tree or directly formatting
it). A Pod formatter (or <br>
Pod translator) is a module or program that converts Pod to
some other format (HTML, plaintext, TeX, PostScript, RTF). A
Pod processor might be a formatter or translator, or <br>
might be a program that does something else with the Pod
(like counting words, scanning for index points, etc.).</p>

<p style="margin-top: 1em">Pod content is contained in Pod
blocks. A Pod block starts with a line that matches &lt;m/0
<br>
of the file if there is no &quot;m/0</p>

<p style="margin-top: 1em">Within a Pod block, there are
Pod paragraphs. A Pod paragraph consists of non-blank lines
of text, separated by one or more blank lines.</p>

<p style="margin-top: 1em">For purposes of Pod processing,
there are four types of paragraphs in a Pod block:</p>

<p style="margin-top: 1em">&Acirc;&middot; A command
paragraph (also called a &quot;directive&quot;). The first
line of this paragraph must match &quot;m/0</p>

<p style="margin-top: 1em">=head1 NOTES</p>

<p style="margin-top: 1em">=item *</p>

<p style="margin-top: 1em">But they may span several
(non-blank) lines:</p>

<p style="margin-top: 1em">=for comment <br>
Hm, I wonder what it would look like if <br>
you tried to write a BNF for Pod from this.</p>

<p style="margin-top: 1em">=head3 Dr. Strangelove, or: How
I Learned to <br>
Stop Worrying and Love the Bomb</p>

<p style="margin-top: 1em">Some command paragraphs allow
formatting codes in their content (i.e., after the part that
matches &quot;m/0</p>

<p style="margin-top: 1em">=head1 Did You Remember to
C&lt;use strict;&gt;?</p>

<p style="margin-top: 1em">In other words, the Pod
processing handler for &quot;head1&quot; will apply the same
processing to &quot;Did You Remember to C&lt;use
strict;&gt;?&quot; that it would to an ordinary paragraph
(i.e., <br>
formatting codes like &quot;C&lt;...&gt;&quot;) are parsed
and presumably formatted appropriately, and whitespace in
the form of literal spaces and/or tabs is not
significant.</p>

<p style="margin-top: 1em">&Acirc;&middot; A verbatim
paragraph. The first line of this paragraph must be a
literal space or tab, and this paragraph must not be inside
a &quot;=begin identifier&quot;, ... &quot;=end
identifier&quot; <br>
sequence unless &quot;identifier&quot; begins with a colon
(&quot;:&quot;). That is, if a paragraph starts with a
literal space or tab, but is inside a &quot;=begin
identifier&quot;, ... &quot;=end <br>
identifier&quot; region, then it&rsquo;s a data paragraph,
unless &quot;identifier&quot; begins with a colon.</p>

<p style="margin-top: 1em">Whitespace is significant in
verbatim paragraphs (although, in processing, tabs are
probably expanded).</p>

<p style="margin-top: 1em">&Acirc;&middot; An ordinary
paragraph. A paragraph is an ordinary paragraph if its first
line matches neither &quot;m/0 <br>
identifier&quot;, ... &quot;=end identifier&quot; sequence
unless &quot;identifier&quot; begins with a colon
(&quot;:&quot;).</p>

<p style="margin-top: 1em">&Acirc;&middot; A data
paragraph. This is a paragraph that is inside a &quot;=begin
identifier&quot; ... &quot;=end identifier&quot; sequence
where &quot;identifier&quot; does not begin with a literal
colon (&quot;:&quot;). In <br>
some sense, a data paragraph is not part of Pod at all
(i.e., effectively it&rsquo;s &quot;out-of-band&quot;),
since it&rsquo;s not subject to most kinds of Pod parsing;
but it is specified here, <br>
since Pod parsers need to be able to call an event for it,
or store it in some form in a parse tree, or at least just
parse around it.</p>

<p style="margin-top: 1em">For example: consider the
following paragraphs:</p>

<p style="margin-top: 1em"># &lt;- that&rsquo;s the 0th
column</p>

<p style="margin-top: 1em">=head1 Foo</p>

<p style="margin-top: 1em">Stuff</p>

<p style="margin-top: 1em">$foo-&gt;bar</p>

<p style="margin-top: 1em">=cut</p>

<p style="margin-top: 1em">Here, &quot;=head1 Foo&quot; and
&quot;=cut&quot; are command paragraphs because the first
line of each matches &quot;m/0 <br>
first line starts with a literal whitespace character (and
there&rsquo;s no &quot;=begin&quot;...&quot;=end&quot;
region around).</p>

<p style="margin-top: 1em">The &quot;=begin
identifier&quot; ... &quot;=end identifier&quot; commands
stop paragraphs that they surround from being parsed as
ordinary or verbatim paragraphs, if identifier doesn&rsquo;t
begin with a <br>
colon. This is discussed in detail in the section
&quot;About Data Paragraphs and &quot;=begin/=end&quot;
Regions&quot;.</p>

<p style="margin-top: 1em">Pod Commands <br>
This section is intended to supplement and clarify the
discussion in &quot;Command Paragraph&quot; in perlpod.
These are the currently recognized Pod commands:</p>

<p style="margin-top: 1em">&quot;=head1&quot;,
&quot;=head2&quot;, &quot;=head3&quot;, &quot;=head4&quot;
<br>
This command indicates that the text in the remainder of the
paragraph is a heading. That text may contain formatting
codes. Examples:</p>

<p style="margin-top: 1em">=head1 Object Attributes</p>

<p style="margin-top: 1em">=head3 What B&lt;Not&gt; to
Do!</p>

<p style="margin-top: 1em">&quot;=pod&quot; <br>
This command indicates that this paragraph begins a Pod
block. (If we are already in the middle of a Pod block, this
command has no effect at all.) If there is any text in <br>
this command paragraph after &quot;=pod&quot;, it must be
ignored. Examples:</p>

<p style="margin-top: 1em">=pod</p>

<p style="margin-top: 1em">This is a plain Pod
paragraph.</p>

<p style="margin-top: 1em">=pod This text is ignored.</p>

<p style="margin-top: 1em">&quot;=cut&quot; <br>
This command indicates that this line is the end of this
previously started Pod block. If there is any text after
&quot;=cut&quot; on the line, it must be ignored.
Examples:</p>

<p style="margin-top: 1em">=cut</p>

<p style="margin-top: 1em">=cut The documentation ends
here.</p>

<p style="margin-top: 1em">=cut <br>
# This is the first line of program text. <br>
sub foo { # This is the second.</p>

<p style="margin-top: 1em">It is an error to try to start a
Pod block with a &quot;=cut&quot; command. In that case, the
Pod processor must halt parsing of the input file, and must
by default emit a warning.</p>

<p style="margin-top: 1em">&quot;=over&quot; <br>
This command indicates that this is the start of a
list/indent region. If there is any text following the
&quot;=over&quot;, it must consist of only a nonzero
positive numeral. The <br>
semantics of this numeral is explained in the &quot;About
=over...=back Regions&quot; section, further below.
Formatting codes are not expanded. Examples:</p>

<p style="margin-top: 1em">=over 3</p>

<p style="margin-top: 1em">=over 3.5</p>

<p style="margin-top: 1em">=over</p>

<p style="margin-top: 1em">&quot;=item&quot; <br>
This command indicates that an item in a list begins here.
Formatting codes are processed. The semantics of the
(optional) text in the remainder of this paragraph are <br>
explained in the &quot;About =over...=back Regions&quot;
section, further below. Examples:</p>

<p style="margin-top: 1em">=item</p>

<p style="margin-top: 1em">=item *</p>

<p style="margin-top: 1em">=item *</p>

<p style="margin-top: 1em">=item 14</p>

<p style="margin-top: 1em">=item 3.</p>

<p style="margin-top: 1em">=item C&lt;&lt;
$thing-&gt;stuff(I&lt;dodad&gt;) &gt;&gt;</p>

<p style="margin-top: 1em">=item For transporting us beyond
seas to be tried for pretended <br>
offenses</p>

<p style="margin-top: 1em">=item He is at this time
transporting large armies of foreign <br>
mercenaries to complete the works of death, desolation and
<br>
tyranny, already begun with circumstances of cruelty and
perfidy <br>
scarcely paralleled in the most barbarous ages, and totally
<br>
unworthy the head of a civilized nation.</p>

<p style="margin-top: 1em">&quot;=back&quot; <br>
This command indicates that this is the end of the region
begun by the most recent &quot;=over&quot; command. It
permits no text after the &quot;=back&quot; command.</p>

<p style="margin-top: 1em">&quot;=begin formatname&quot;
<br>
&quot;=begin formatname parameter&quot; <br>
This marks the following paragraphs (until the matching
&quot;=end formatname&quot;) as being for some special kind
of processing. Unless &quot;formatname&quot; begins with a
colon, the <br>
contained non-command paragraphs are data paragraphs. But if
&quot;formatname&quot; does begin with a colon, then
non-command paragraphs are ordinary paragraphs or data
paragraphs. <br>
This is discussed in detail in the section &quot;About Data
Paragraphs and &quot;=begin/=end&quot; Regions&quot;.</p>

<p style="margin-top: 1em">It is advised that formatnames
match the regexp &quot;m/0 <br>
formatter when dealing with this region. This parameter must
not be repeated in the &quot;=end&quot; paragraph.
Implementors should anticipate future expansion in the
semantics and <br>
syntax of the first parameter to
&quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</p>

<p style="margin-top: 1em">&quot;=end formatname&quot; <br>
This marks the end of the region opened by the matching
&quot;=begin formatname&quot; region. If
&quot;formatname&quot; is not the formatname of the most
recent open &quot;=begin formatname&quot; region, <br>
then this is an error, and must generate an error message.
This is discussed in detail in the section &quot;About Data
Paragraphs and &quot;=begin/=end&quot; Regions&quot;.</p>

<p style="margin-top: 1em">&quot;=for formatname
text...&quot; <br>
This is synonymous with:</p>

<p style="margin-top: 1em">=begin formatname</p>

<p style="margin-top: 1em">text...</p>

<p style="margin-top: 1em">=end formatname</p>

<p style="margin-top: 1em">That is, it creates a region
consisting of a single paragraph; that paragraph is to be
treated as a normal paragraph if &quot;formatname&quot;
begins with a &quot;:&quot;; if &quot;formatname&quot; <br>
doesn&rsquo;t begin with a colon, then &quot;text...&quot;
will constitute a data paragraph. There is no way to use
&quot;=for formatname text...&quot; to express
&quot;text...&quot; as a verbatim paragraph.</p>

<p style="margin-top: 1em">&quot;=encoding
encodingname&quot; <br>
This command, which should occur early in the document (at
least before any non-US-ASCII data!), declares that this
document is encoded in the encoding encodingname, which <br>
must be an encoding name that Encode recognizes.
(Encode&rsquo;s list of supported encodings, in
Encode::Supported, is useful here.) If the Pod parser cannot
decode the declared <br>
encoding, it should emit a warning and may abort parsing the
document altogether.</p>

<p style="margin-top: 1em">A document having more than one
&quot;=encoding&quot; line should be considered an error.
Pod processors may silently tolerate this if the not-first
&quot;=encoding&quot; lines are just <br>
duplicates of the first one (e.g., if there&rsquo;s a
&quot;=encoding utf8&quot; line, and later on another
&quot;=encoding utf8&quot; line). But Pod processors should
complain if there are <br>
contradictory &quot;=encoding&quot; lines in the same
document (e.g., if there is a &quot;=encoding utf8&quot;
early in the document and &quot;=encoding big5&quot; later).
Pod processors that recognize <br>
BOMs may also complain if they see an &quot;=encoding&quot;
line that contradicts the BOM (e.g., if a document with a
UTF-16LE BOM has an &quot;=encoding shiftjis&quot;
line).</p>

<p style="margin-top: 1em">If a Pod processor sees any
command other than the ones listed above (like
&quot;=head&quot;, or &quot;=haed1&quot;, or
&quot;=stuff&quot;, or &quot;=cuttlefish&quot;, or
&quot;=w123&quot;), that processor must by default treat
<br>
this as an error. It must not process the paragraph
beginning with that command, must by default warn of this as
an error, and may abort the parse. A Pod parser may allow a
way <br>
for particular applications to add to the above list of
known commands, and to stipulate, for each additional
command, whether formatting codes should be processed.</p>

<p style="margin-top: 1em">Future versions of this
specification may add additional commands.</p>

<p style="margin-top: 1em">Pod Formatting Codes <br>
(Note that in previous drafts of this document and of
perlpod, formatting codes were referred to as &quot;interior
sequences&quot;, and this term may still be found in the
documentation <br>
for Pod parsers, and in error messages from Pod
processors.)</p>

<p style="margin-top: 1em">There are two syntaxes for
formatting codes:</p>

<p style="margin-top: 1em">&Acirc;&middot; A formatting
code starts with a capital letter (just US-ASCII [A-Z])
followed by a &quot;&lt;&quot;, any number of characters,
and ending with the first matching &quot;&gt;&quot;.
Examples:</p>

<p style="margin-top: 1em">That&rsquo;s what I&lt;you&gt;
think!</p>

<p style="margin-top: 1em">What&rsquo;s C&lt;dump()&gt;
for?</p>

<p style="margin-top: 1em">X&lt;C&lt;chmod&gt; and
C&lt;unlink()&gt; Under Different Operating Systems&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; A formatting
code starts with a capital letter (just US-ASCII [A-Z])
followed by two or more &quot;&lt;&quot;&rsquo;s, one or
more whitespace characters, any number of characters, one or
more <br>
whitespace characters, and ending with the first matching
sequence of two or more &quot;&gt;&quot;&rsquo;s, where the
number of &quot;&gt;&quot;&rsquo;s equals the number of
&quot;&lt;&quot;&rsquo;s in the opening of this <br>
formatting code. Examples:</p>

<p style="margin-top: 1em">That&rsquo;s what I&lt;&lt; you
&gt;&gt; think!</p>

<p style="margin-top: 1em">C&lt;&lt;&lt; open(X,
&quot;&gt;&gt;thing.dat&quot;) || die $! &gt;&gt;&gt;</p>

<p style="margin-top: 1em">B&lt;&lt; $foo-&gt;bar();
&gt;&gt;</p>

<p style="margin-top: 1em">With this syntax, the whitespace
character(s) after the &quot;C&lt;&lt;&lt;&quot; and before
the &quot;&gt;&gt;&quot; (or whatever letter) are not
renderable. They do not signify whitespace, are merely part
of <br>
the formatting codes themselves. That is, these are all
synonymous:</p>

<p style="margin-top: 1em">C&lt;thing&gt; <br>
C&lt;&lt; thing &gt;&gt; <br>
C&lt;&lt; thing &gt;&gt; <br>
C&lt;&lt;&lt; thing &gt;&gt;&gt; <br>
C&lt;&lt;&lt;&lt; <br>
thing <br>
&gt;&gt;&gt;&gt;</p>

<p style="margin-top: 1em">and so on.</p>

<p style="margin-top: 1em">Finally, the
multiple-angle-bracket form does not alter the
interpretation of nested formatting codes, meaning that the
following four example lines are identical in meaning:</p>

<p style="margin-top: 1em">B&lt;example: C&lt;$a
E&lt;lt&gt;=E&lt;gt&gt; $b&gt;&gt;</p>

<p style="margin-top: 1em">B&lt;example: C&lt;&lt; $a
&lt;=&gt; $b &gt;&gt;&gt;</p>

<p style="margin-top: 1em">B&lt;example: C&lt;&lt; $a
E&lt;lt&gt;=E&lt;gt&gt; $b &gt;&gt;&gt;</p>

<p style="margin-top: 1em">B&lt;&lt;&lt; example: C&lt;&lt;
$a E&lt;lt&gt;=E&lt;gt&gt; $b &gt;&gt; &gt;&gt;&gt;</p>

<p style="margin-top: 1em">In parsing Pod, a notably tricky
part is the correct parsing of (potentially nested!)
formatting codes. Implementors should consult the code in
the &quot;parse_text&quot; routine in <br>
Pod::Parser as an example of a correct implementation.</p>

<p style="margin-top: 1em">&quot;I&lt;text&gt;&quot; --
italic text <br>
See the brief discussion in &quot;Formatting Codes&quot; in
perlpod.</p>

<p style="margin-top: 1em">&quot;B&lt;text&gt;&quot; --
bold text <br>
See the brief discussion in &quot;Formatting Codes&quot; in
perlpod.</p>

<p style="margin-top: 1em">&quot;C&lt;code&gt;&quot; --
code text <br>
See the brief discussion in &quot;Formatting Codes&quot; in
perlpod.</p>

<p style="margin-top: 1em">&quot;F&lt;filename&gt;&quot; --
style for filenames <br>
See the brief discussion in &quot;Formatting Codes&quot; in
perlpod.</p>

<p style="margin-top: 1em">&quot;X&lt;topic name&gt;&quot;
-- an index entry <br>
See the brief discussion in &quot;Formatting Codes&quot; in
perlpod.</p>

<p style="margin-top: 1em">This code is unusual in that
most formatters completely discard this code and its
content. Other formatters will render it with invisible
codes that can be used in building <br>
an index of the current document.</p>

<p style="margin-top: 1em">&quot;Z&lt;&gt;&quot; -- a null
(zero-effect) formatting code <br>
Discussed briefly in &quot;Formatting Codes&quot; in
perlpod.</p>

<p style="margin-top: 1em">This code is unusual is that it
should have no content. That is, a processor may complain if
it sees &quot;Z&lt;potatoes&gt;&quot;. Whether or not it
complains, the potatoes text should <br>
ignored.</p>

<p style="margin-top: 1em">&quot;L&lt;name&gt;&quot; -- a
hyperlink <br>
The complicated syntaxes of this code are discussed at
length in &quot;Formatting Codes&quot; in perlpod, and
implementation details are discussed below, in &quot;About
L&lt;...&gt; Codes&quot;. <br>
Parsing the contents of L&lt;content&gt; is tricky. Notably,
the content has to be checked for whether it looks like a
URL, or whether it has to be split on literal &quot;|&quot;
and/or &quot;/&quot; <br>
(in the right order!), and so on, before E&lt;...&gt; codes
are resolved.</p>

<p style="margin-top: 1em">&quot;E&lt;escape&gt;&quot; -- a
character escape <br>
See &quot;Formatting Codes&quot; in perlpod, and several
points in &quot;Notes on Implementing Pod
Processors&quot;.</p>

<p style="margin-top: 1em">&quot;S&lt;text&gt;&quot; --
text contains non-breaking spaces <br>
This formatting code is syntactically simple, but
semantically complex. What it means is that each space in
the printable content of this code signifies a non-breaking
<br>
space.</p>

<p style="margin-top: 1em">Consider:</p>

<p style="margin-top: 1em">C&lt;$x ? $y : $z&gt;</p>

<p style="margin-top: 1em">S&lt;C&lt;$x ? $y :
$z&gt;&gt;</p>

<p style="margin-top: 1em">Both signify the monospace
(c[ode] style) text consisting of &quot;$x&quot;, one space,
&quot;?&quot;, one space, &quot;:&quot;, one space,
&quot;$z&quot;. The difference is that in the latter, with
the S code, <br>
those spaces are not &quot;normal&quot; spaces, but instead
are non-breaking spaces.</p>

<p style="margin-top: 1em">If a Pod processor sees any
formatting code other than the ones listed above (as in
&quot;N&lt;...&gt;&quot;, or &quot;Q&lt;...&gt;&quot;,
etc.), that processor must by default treat this as an
error. A Pod <br>
parser may allow a way for particular applications to add to
the above list of known formatting codes; a Pod parser might
even allow a way to stipulate, for each additional <br>
command, whether it requires some form of special
processing, as L&lt;...&gt; does.</p>

<p style="margin-top: 1em">Future versions of this
specification may add additional formatting codes.</p>

<p style="margin-top: 1em">Historical note: A few older Pod
processors would not see a &quot;&gt;&quot; as closing a
&quot;C&lt;&quot; code, if the &quot;&gt;&quot; was
immediately preceded by a &quot;-&quot;. This was so that
this:</p>

<p style="margin-top: 1em">C&lt;$foo-&gt;bar&gt;</p>

<p style="margin-top: 1em">would parse as equivalent to
this:</p>


<p style="margin-top: 1em">C&lt;$foo-E&lt;gt&gt;bar&gt;</p>

<p style="margin-top: 1em">instead of as equivalent to a
&quot;C&quot; formatting code containing only
&quot;$foo-&quot;, and then a &quot;bar&gt;&quot; outside
the &quot;C&quot; formatting code. This problem has since
been solved by the addition <br>
of syntaxes like this:</p>

<p style="margin-top: 1em">C&lt;&lt; $foo-&gt;bar
&gt;&gt;</p>

<p style="margin-top: 1em">Compliant parsers must not treat
&quot;-&gt;&quot; as special.</p>

<p style="margin-top: 1em">Formatting codes absolutely
cannot span paragraphs. If a code is opened in one
paragraph, and no closing code is found by the end of that
paragraph, the Pod parser must close <br>
that formatting code, and should complain (as in
&quot;Unterminated I code in the paragraph starting at line
123: &rsquo;Time objects are not...&rsquo;&quot;). So these
two paragraphs:</p>

<p style="margin-top: 1em">I&lt;I told you not to do
this!</p>

<p style="margin-top: 1em">Don&rsquo;t make me say it
again!&gt;</p>

<p style="margin-top: 1em">...must not be parsed as two
paragraphs in italics (with the I code starting in one
paragraph and starting in another.) Instead, the first
paragraph should generate a warning, <br>
but that aside, the above code must parse as if it were:</p>

<p style="margin-top: 1em">I&lt;I told you not to do
this!&gt;</p>

<p style="margin-top: 1em">Don&rsquo;t make me say it
again!E&lt;gt&gt;</p>

<p style="margin-top: 1em">(In SGMLish jargon, all Pod
commands are like block-level elements, whereas all Pod
formatting codes are like inline-level elements.)</p>

<p style="margin-top: 1em">Notes on Implementing Pod
Processors <br>
The following is a long section of miscellaneous
requirements and suggestions to do with Pod processing.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod formatters
should tolerate lines in verbatim blocks that are of any
length, even if that means having to break them (possibly
several times, for very long lines) to avoid <br>
text running off the side of the page. Pod formatters may
warn of such line-breaking. Such warnings are particularly
appropriate for lines are over 100 characters long, <br>
which are usually not intentional.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers must
recognize all of the three well-known newline formats: CR,
LF, and CRLF. See perlport.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers
should accept input lines that are of any length.</p>

<p style="margin-top: 1em">&Acirc;&middot; Since Perl
recognizes a Unicode Byte Order Mark at the start of files
as signaling that the file is Unicode encoded as in UTF-16
(whether big-endian or little-endian) or <br>
UTF-8, Pod parsers should do the same. Otherwise, the
character encoding should be understood as being UTF-8 if
the first highbit byte sequence in the file seems valid as a
<br>
UTF-8 sequence, or otherwise as Latin-1.</p>

<p style="margin-top: 1em">Future versions of this
specification may specify how Pod can accept other
encodings. Presumably treatment of other encodings in Pod
parsing would be as in XML parsing: <br>
whatever the encoding declared by a particular Pod file,
content is to be stored in memory as Unicode characters.</p>

<p style="margin-top: 1em">&Acirc;&middot; The well known
Unicode Byte Order Marks are as follows: if the file begins
with the two literal byte values 0xFE 0xFF, this is the BOM
for big-endian UTF-16. If the file <br>
begins with the two literal byte value 0xFF 0xFE, this is
the BOM for little-endian UTF-16. If the file begins with
the three literal byte values 0xEF 0xBB 0xBF, this is the
<br>
BOM for UTF-8.</p>

<p style="margin-top: 1em">&Acirc;&middot; A naive but
sufficient heuristic for testing the first highbit
byte-sequence in a BOM-less file (whether in code or in
Pod!), to see whether that sequence is valid as UTF-8 <br>
(RFC 2279) is to check whether that the first byte in the
sequence is in the range 0xC0 - 0xFD and whether the next
byte is in the range 0x80 - 0xBF. If so, the parser may <br>
conclude that this file is in UTF-8, and all highbit
sequences in the file should be assumed to be UTF-8.
Otherwise the parser should treat the file as being in
Latin-1. In <br>
the unlikely circumstance that the first highbit sequence in
a truly non-UTF-8 file happens to appear to be UTF-8, one
can cater to our heuristic (as well as any more <br>
intelligent heuristic) by prefacing that line with a comment
line containing a highbit sequence that is clearly not valid
as UTF-8. A line consisting of simply &quot;#&quot;, an <br>
e-acute, and any non-highbit byte, is sufficient to
establish this file&rsquo;s encoding.</p>

<p style="margin-top: 1em">&Acirc;&middot; This
document&rsquo;s requirements and suggestions about
encodings do not apply to Pod processors running on
non-ASCII platforms, notably EBCDIC platforms.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod processors
must treat a &quot;=for [label] [content...]&quot; paragraph
as meaning the same thing as a &quot;=begin [label]&quot;
paragraph, content, and an &quot;=end [label]&quot;
paragraph. (The <br>
parser may conflate these two constructs, or may leave them
distinct, in the expectation that the formatter will
nevertheless treat them the same.)</p>

<p style="margin-top: 1em">&Acirc;&middot; When rendering
Pod to a format that allows comments (i.e., to nearly any
format other than plaintext), a Pod formatter must insert
comment text identifying its name and <br>
version number, and the name and version numbers of any
modules it might be using to process the Pod. Minimal
examples:</p>

<p style="margin-top: 1em">%% POD::Pod2PS v3.14159, using
POD::Parser v1.92</p>

<p style="margin-top: 1em">&lt;!-- Pod::HTML v3.14159,
using POD::Parser v1.92 --&gt;</p>

<p style="margin-top: 1em">{occomm generated by
Pod::Tree::RTF 3.14159 using Pod::Tree 1.08}</p>

<p style="margin-top: 1em">.</p>

<p style="margin-top: 1em">Formatters may also insert
additional comments, including: the release date of the Pod
formatter program, the contact address for the author(s) of
the formatter, the current <br>
time, the name of input file, the formatting options in
effect, version of Perl used, etc.</p>

<p style="margin-top: 1em">Formatters may also choose to
note errors/warnings as comments, besides or instead of
emitting them otherwise (as in messages to STDERR, or
&quot;die&quot;ing).</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers may
emit warnings or error messages (&quot;Unknown E code
E&lt;zslig&gt;!&quot;) to STDERR (whether through printing
to STDERR, or &quot;warn&quot;ing/&quot;carp&quot;ing, or
&quot;die&quot;ing/&quot;croak&quot;ing), <br>
but must allow suppressing all such STDERR output, and
instead allow an option for reporting errors/warnings in
some other way, whether by triggering a callback, or noting
<br>
errors in some attribute of the document object, or some
similarly unobtrusive mechanism -- or even by appending a
&quot;Pod Errors&quot; section to the end of the parsed form
of the <br>
document.</p>

<p style="margin-top: 1em">&Acirc;&middot; In cases of
exceptionally aberrant documents, Pod parsers may abort the
parse. Even then, using
&quot;die&quot;ing/&quot;croak&quot;ing is to be avoided;
where possible, the parser library may <br>
simply close the input file and add text like &quot;***
Formatting Aborted ***&quot; to the end of the (partial)
in-memory document.</p>

<p style="margin-top: 1em">&Acirc;&middot; In paragraphs
where formatting codes (like E&lt;...&gt;, B&lt;...&gt;) are
understood (i.e., not verbatim paragraphs, but including
ordinary paragraphs, and command paragraphs that <br>
produce renderable text, like &quot;=head1&quot;), literal
whitespace should generally be considered
&quot;insignificant&quot;, in that one literal space has the
same meaning as any (nonzero) <br>
number of literal spaces, literal newlines, and literal tabs
(as long as this produces no blank lines, since those would
terminate the paragraph). Pod parsers should compact <br>
literal whitespace in each processed paragraph, but may
provide an option for overriding this (since some processing
tasks do not require it), or may follow additional <br>
special rules (for example, specially treating
period-space-space or period-newline sequences).</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers
should not, by default, try to coerce apostrophe (&rsquo;)
and quote (&quot;) into smart quotes (little 9&rsquo;s,
66&rsquo;s, 99&rsquo;s, etc), nor try to turn backtick
(&lsquo;) into anything <br>
else but a single backtick character (distinct from an open
quote character!), nor &quot;--&quot; into anything but two
minus signs. They must never do any of those things to text
in <br>
C&lt;...&gt; formatting codes, and never ever to text in
verbatim paragraphs.</p>

<p style="margin-top: 1em">&Acirc;&middot; When rendering
Pod to a format that has two kinds of hyphens (-), one
that&rsquo;s a non-breaking hyphen, and another that&rsquo;s
a breakable hyphen (as in &quot;object-oriented&quot;, which
can <br>
be split across lines as &quot;object-&quot;, newline,
&quot;oriented&quot;), formatters are encouraged to
generally translate &quot;-&quot; to non-breaking hyphen,
but may apply heuristics to convert <br>
some of these to breaking hyphens.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod formatters
should make reasonable efforts to keep words of Perl code
from being broken across lines. For example,
&quot;Foo::Bar&quot; in some formatting systems is seen as
<br>
eligible for being broken across lines as &quot;Foo::&quot;
newline &quot;Bar&quot; or even &quot;Foo::-&quot; newline
&quot;Bar&quot;. This should be avoided where possible,
either by disabling all line-breaking <br>
in mid-word, or by wrapping particular words with internal
punctuation in &quot;don&rsquo;t break this across
lines&quot; codes (which in some formats may not be a single
code, but might be <br>
a matter of inserting non-breaking zero-width spaces between
every pair of characters in a word.)</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers
should, by default, expand tabs in verbatim paragraphs as
they are processed, before passing them to the formatter or
other processor. Parsers may also allow an <br>
option for overriding this.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers
should, by default, remove newlines from the end of ordinary
and verbatim paragraphs before passing them to the
formatter. For example, while the paragraph <br>
you&rsquo;re reading now could be considered, in Pod source,
to end with (and contain) the newline(s) that end it, it
should be processed as ending with (and containing) the
period <br>
character that ends this sentence.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers,
when reporting errors, should make some effort to report an
approximate line number (&quot;Nested E&lt;&gt;&rsquo;s in
Paragraph #52, near line 633 of Thing/Foo.pm!&quot;),
instead of <br>
merely noting the paragraph number (&quot;Nested
E&lt;&gt;&rsquo;s in Paragraph #52 of Thing/Foo.pm!&quot;).
Where this is problematic, the paragraph number should at
least be accompanied by an <br>
excerpt from the paragraph (&quot;Nested E&lt;&gt;&rsquo;s
in Paragraph #52 of Thing/Foo.pm, which begins
&rsquo;Read/write accessor for the C&lt;interest rate&gt;
attribute...&rsquo;&quot;).</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers,
when processing a series of verbatim paragraphs one after
another, should consider them to be one large verbatim
paragraph that happens to contain blank lines. <br>
I.e., these two lines, which have a blank line between
them:</p>

<p style="margin-top: 1em">use Foo;</p>

<p style="margin-top: 1em">print Foo-&gt;VERSION</p>

<p style="margin-top: 1em">should be unified into one
paragraph (&quot;use Foo;0rint Foo-&gt;VERSION&quot;) before
being passed to the formatter or other processor. Parsers
may also allow an option for <br>
overriding this.</p>

<p style="margin-top: 1em">While this might be too
cumbersome to implement in event-based Pod parsers, it is
straightforward for parsers that return parse trees.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod formatters,
where feasible, are advised to avoid splitting short
verbatim paragraphs (under twelve lines, say) across
pages.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers must
treat a line with only spaces and/or tabs on it as a
&quot;blank line&quot; such as separates paragraphs. (Some
older parsers recognized only two adjacent newlines as <br>
a &quot;blank line&quot; but would not recognize a newline,
a space, and a newline, as a blank line. This is
noncompliant behavior.)</p>

<p style="margin-top: 1em">&Acirc;&middot; Authors of Pod
formatters/processors should make every effort to avoid
writing their own Pod parser. There are already several in
CPAN, with a wide range of interface styles <br>
-- and one of them, Pod::Parser, comes with modern versions
of Perl.</p>

<p style="margin-top: 1em">&Acirc;&middot; Characters in
Pod documents may be conveyed either as literals, or by
number in E&lt;n&gt; codes, or by an equivalent mnemonic, as
in E&lt;eacute&gt; which is exactly equivalent to <br>
E&lt;233&gt;.</p>

<p style="margin-top: 1em">Characters in the range 32-126
refer to those well known US-ASCII characters (also defined
there by Unicode, with the same meaning), which all Pod
formatters must render <br>
faithfully. Characters in the ranges 0-31 and 127-159 should
not be used (neither as literals, nor as E&lt;number&gt;
codes), except for the literal byte-sequences for newline
<br>
(13, 13 10, or 10), and tab (9).</p>

<p style="margin-top: 1em">Characters in the range 160-255
refer to Latin-1 characters (also defined there by Unicode,
with the same meaning). Characters above 255 should be
understood to refer to <br>
Unicode characters.</p>

<p style="margin-top: 1em">&Acirc;&middot; Be warned that
some formatters cannot reliably render characters outside
32-126; and many are able to handle 32-126 and 160-255, but
nothing above 255.</p>

<p style="margin-top: 1em">&Acirc;&middot; Besides the
well-known &quot;E&lt;lt&gt;&quot; and
&quot;E&lt;gt&gt;&quot; codes for less-than and
greater-than, Pod parsers must understand
&quot;E&lt;sol&gt;&quot; for &quot;/&quot; (solidus, slash),
and &quot;E&lt;verbar&gt;&quot; for &quot;|&quot; <br>
(vertical bar, pipe). Pod parsers should also understand
&quot;E&lt;lchevron&gt;&quot; and
&quot;E&lt;rchevron&gt;&quot; as legacy codes for characters
171 and 187, i.e., &quot;left-pointing double angle <br>
quotation mark&quot; = &quot;left pointing guillemet&quot;
and &quot;right-pointing double angle quotation mark&quot; =
&quot;right pointing guillemet&quot;. (These look like
little &quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot;, and
they <br>
are now preferably expressed with the HTML/XHTML codes
&quot;E&lt;laquo&gt;&quot; and
&quot;E&lt;raquo&gt;&quot;.)</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers
should understand all &quot;E&lt;html&gt;&quot; codes as
defined in the entity declarations in the most recent XHTML
specification at &quot;www.W3.org&quot;. Pod parsers must
understand <br>
at least the entities that define characters in the range
160-255 (Latin-1). Pod parsers, when faced with some unknown
&quot;E&lt;identifier&gt;&quot; code, shouldn&rsquo;t simply
replace it with <br>
nullstring (by default, at least), but may pass it through
as a string consisting of the literal characters E,
less-than, identifier, greater-than. Or Pod parsers may
offer <br>
the alternative option of processing such unknown
&quot;E&lt;identifier&gt;&quot; codes by firing an event
especially for such codes, or by adding a special node-type
to the in-memory <br>
document tree. Such &quot;E&lt;identifier&gt;&quot; may have
special meaning to some processors, or some processors may
choose to add them to a special error report.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod parsers must
also support the XHTML codes &quot;E&lt;quot&gt;&quot; for
character 34 (doublequote, &quot;), &quot;E&lt;amp&gt;&quot;
for character 38 (ampersand, &amp;), and
&quot;E&lt;apos&gt;&quot; for character 39 <br>
(apostrophe, &rsquo;).</p>

<p style="margin-top: 1em">&Acirc;&middot; Note that in all
cases of &quot;E&lt;whatever&gt;&quot;, whatever (whether an
htmlname, or a number in any base) must consist only of
alphanumeric characters -- that is, whatever must watch <br>
&quot;m/1 <br>
processor; &quot; 0 1 2 3 &quot; doesn&rsquo;t look like a
number in any base, so it would presumably be looked up in
the table of HTML-like names. Since there isn&rsquo;t (and
cannot be) an <br>
HTML-like entity called &quot; 0 1 2 3 &quot;, this will be
treated as an error. However, Pod processors may treat
&quot;E&lt; 0 1 2 3 &gt;&quot; or
&quot;E&lt;e-acute&gt;&quot; as syntactically invalid,
potentially <br>
earning a different error message than the error message (or
warning, or event) generated by a merely unknown (but
theoretically valid) htmlname, as in
&quot;E&lt;qacute&gt;&quot; [sic]. <br>
However, Pod parsers are not required to make this
distinction.</p>

<p style="margin-top: 1em">&Acirc;&middot; Note that
E&lt;number&gt; must not be interpreted as simply
&quot;codepoint number in the current/native character
set&quot;. It always means only &quot;the character
represented by codepoint <br>
number in Unicode.&quot; (This is identical to the semantics
of &amp;#number; in XML.)</p>

<p style="margin-top: 1em">This will likely require many
formatters to have tables mapping from treatable Unicode
codepoints (such as the &quot; for the e-acute character) to
the escape sequences or <br>
codes necessary for conveying such sequences in the target
output format. A converter to *roff would, for example know
that &quot; (whether conveyed literally, or via a <br>
E&lt;...&gt; sequence) is to be conveyed as
&quot;e\*&rsquo;&quot;. Similarly, a program rendering Pod
in a Mac OS application window, would presumably need to
know that &quot; maps to codepoint <br>
142 in MacRoman encoding that (at time of writing) is native
for Mac OS. Such Unicode2whatever mappings are presumably
already widely available for common output formats. <br>
(Such mappings may be incomplete! Implementers are not
expected to bend over backwards in an attempt to render
Cherokee syllabics, Etruscan runes, Byzantine musical
symbols, <br>
or any of the other weird things that Unicode can encode.)
And if a Pod document uses a character not found in such a
mapping, the formatter should consider it an <br>
unrenderable character.</p>

<p style="margin-top: 1em">&Acirc;&middot; If,
surprisingly, the implementor of a Pod formatter can&rsquo;t
find a satisfactory pre-existing table mapping from Unicode
characters to escapes in the target format (e.g., a <br>
decent table of Unicode characters to *roff escapes), it
will be necessary to build such a table. If you are in this
circumstance, you should begin with the characters in <br>
the range 0x00A0 - 0x00FF, which is mostly the heavily used
accented characters. Then proceed (as patience permits and
fastidiousness compels) through the characters that <br>
the (X)HTML standards groups judged important enough to
merit mnemonics for. These are declared in the (X)HTML
specifications at the www.W3.org site. At time of writing
<br>
(September 2001), the most recent entity declaration files
are:</p>


<p style="margin-top: 1em">http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent
<br>
http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent <br>
http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</p>

<p style="margin-top: 1em">Then you can progress through
any remaining notable Unicode characters in the range
0x2000-0x204D (consult the character tables at
www.unicode.org), and whatever else strikes <br>
your fancy. For example, in xhtml-symbol.ent, there is the
entry:</p>

<p style="margin-top: 1em">&lt;!ENTITY infin
&quot;&amp;#8734;&quot;&gt; &lt;!-- infinity, U+221E ISOtech
--&gt;</p>

<p style="margin-top: 1em">While the mapping
&quot;infin&quot; to the character &quot;}&quot; will
(hopefully) have been already handled by the Pod parser, the
presence of the character in this file means that it&rsquo;s
<br>
reasonably important enough to include in a
formatter&rsquo;s table that maps from notable Unicode
characters to the codes necessary for rendering them. So for
a Unicode-to-*roff <br>
mapping, for example, this would merit the entry:</p>

<p style="margin-top: 1em">&quot;}&quot; =&gt;
&rsquo;&rsquo;,</p>

<p style="margin-top: 1em">It is eagerly hoped that in the
future, increasing numbers of formats (and formatters) will
support Unicode characters directly (as (X)HTML does with
&quot;&amp;infin;&quot;, &quot;&amp;#8734;&quot;, or <br>
&quot;&amp;#x221E;&quot;), reducing the need for
idiosyncratic mappings of Unicode-to-my_escapes.</p>

<p style="margin-top: 1em">&Acirc;&middot; It is up to
individual Pod formatter to display good judgement when
confronted with an unrenderable character (which is distinct
from an unknown E&lt;thing&gt; sequence that the <br>
parser couldn&rsquo;t resolve to anything, renderable or
not). It is good practice to map Latin letters with
diacritics (like
&quot;E&lt;eacute&gt;&quot;/&quot;E&lt;233&gt;&quot;) to the
corresponding unaccented <br>
US-ASCII letters (like a simple character 101,
&quot;e&quot;), but clearly this is often not feasible, and
an unrenderable character may be represented as
&quot;?&quot;, or the like. In <br>
attempting a sane fallback (as from E&lt;233&gt; to
&quot;e&quot;), Pod formatters may use the
%Latin1Code_to_fallback table in Pod::Escapes, or
Text::Unidecode, if available.</p>

<p style="margin-top: 1em">For example, this Pod text:</p>

<p style="margin-top: 1em">magic is enabled if you set
C&lt;$Currency&gt; to &rsquo;E&lt;euro&gt;&rsquo;.</p>

<p style="margin-top: 1em">may be rendered as: &quot;magic
is enabled if you set $Currency to &rsquo;?&rsquo;&quot; or
as &quot;magic is enabled if you set $Currency to
&rsquo;[euro]&rsquo;&quot;, or as &quot;magic is enabled if
you set $Currency to <br>
&rsquo;[x20AC]&rsquo;, etc.</p>

<p style="margin-top: 1em">A Pod formatter may also note,
in a comment or warning, a list of what unrenderable
characters were encountered.</p>

<p style="margin-top: 1em">&Acirc;&middot; E&lt;...&gt; may
freely appear in any formatting code (other than in another
E&lt;...&gt; or in an Z&lt;&gt;). That is, &quot;X&lt;The
E&lt;euro&gt;1,000,000 Solution&gt;&quot; is valid, as is
&quot;L&lt;The <br>
E&lt;euro&gt;1,000,000
Solution|Million::Euros&gt;&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; Some Pod
formatters output to formats that implement non-breaking
spaces as an individual character (which I&rsquo;ll call
&quot;NBSP&quot;), and others output to formats that
implement non- <br>
breaking spaces just as spaces wrapped in a
&quot;don&rsquo;t break this across lines&quot; code. Note
that at the level of Pod, both sorts of codes can occur: Pod
can contain a NBSP <br>
character (whether as a literal, or as a
&quot;E&lt;160&gt;&quot; or &quot;E&lt;nbsp&gt;&quot; code);
and Pod can contain &quot;S&lt;foo I&lt;bar&gt;
baz&gt;&quot; codes, where &quot;mere spaces&quot;
(character 32) in such codes are <br>
taken to represent non-breaking spaces. Pod parsers should
consider supporting the optional parsing of &quot;S&lt;foo
I&lt;bar&gt; baz&gt;&quot; as if it were
&quot;fooNBSPI&lt;bar&gt;NBSPbaz&quot;, and, going <br>
the other way, the optional parsing of groups of words
joined by NBSP&rsquo;s as if each group were in a
S&lt;...&gt; code, so that formatters may use the
representation that maps best <br>
to what the output format demands.</p>

<p style="margin-top: 1em">&Acirc;&middot; Some processors
may find that the &quot;S&lt;...&gt;&quot; code is easiest
to implement by replacing each space in the parse tree under
the content of the S, with an NBSP. But note: the <br>
replacement should apply not to spaces in all text, but only
to spaces in printable text. (This distinction may or may
not be evident in the particular tree/event model <br>
implemented by the Pod parser.) For example, consider this
unusual case:</p>

<p style="margin-top: 1em">S&lt;L&lt;/Autoloaded
Functions&gt;&gt;</p>

<p style="margin-top: 1em">This means that the space in the
middle of the visible link text must not be broken across
lines. In other words, it&rsquo;s the same as this:</p>


<p style="margin-top: 1em">L&lt;&quot;AutoloadedE&lt;160&gt;Functions&quot;/Autoloaded
Functions&gt;</p>

<p style="margin-top: 1em">However, a misapplied
space-to-NBSP replacement could (wrongly) produce something
equivalent to this:</p>


<p style="margin-top: 1em">L&lt;&quot;AutoloadedE&lt;160&gt;Functions&quot;/AutoloadedE&lt;160&gt;Functions&gt;</p>

<p style="margin-top: 1em">...which is almost definitely
not going to work as a hyperlink (assuming this formatter
outputs a format supporting hypertext).</p>

<p style="margin-top: 1em">Formatters may choose to just
not support the S format code, especially in cases where the
output format simply has no NBSP character/code and no code
for &quot;don&rsquo;t break this <br>
stuff across lines&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; Besides the NBSP
character discussed above, implementors are reminded of the
existence of the other &quot;special&quot; character in
Latin-1, the &quot;soft hyphen&quot; character, also known
as <br>
&quot;discretionary hyphen&quot;, i.e.
&quot;E&lt;173&gt;&quot; = &quot;E&lt;0xAD&gt;&quot; =
&quot;E&lt;shy&gt;&quot;). This character expresses an
optional hyphenation point. That is, it normally renders as
nothing, but may <br>
render as a &quot;-&quot; if a formatter breaks the word at
that point. Pod formatters should, as appropriate, do one of
the following: 1) render this with a code with the same <br>
meaning (e.g., &quot;&minus;&quot; in RTF), 2) pass it
through in the expectation that the formatter understands
this character as such, or 3) delete it.</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">sigE&lt;shy&gt;action <br>
manuE&lt;shy&gt;script <br>
JarkE&lt;shy&gt;ko
HieE&lt;shy&gt;taE&lt;shy&gt;nieE&lt;shy&gt;mi</p>

<p style="margin-top: 1em">These signal to a formatter that
if it is to hyphenate &quot;sigaction&quot; or
&quot;manuscript&quot;, then it should be done as
&quot;sig-[linebreak]action&quot; or
&quot;manu-[linebreak]script&quot; (and if it <br>
doesn&rsquo;t hyphenate it, then the
&quot;E&lt;shy&gt;&quot; doesn&rsquo;t show up at all). And
if it is to hyphenate &quot;Jarkko&quot; and/or
&quot;Hietaniemi&quot;, it can do so only at the points
where there is a <br>
&quot;E&lt;shy&gt;&quot; code.</p>

<p style="margin-top: 1em">In practice, it is anticipated
that this character will not be used often, but formatters
should either support it, or delete it.</p>

<p style="margin-top: 1em">&Acirc;&middot; If you think
that you want to add a new command to Pod (like, say, a
&quot;=biblio&quot; command), consider whether you could get
the same effect with a for or begin/end sequence: <br>
&quot;=for biblio ...&quot; or &quot;=begin biblio&quot; ...
&quot;=end biblio&quot;. Pod processors that don&rsquo;t
understand &quot;=for biblio&quot;, etc, will simply ignore
it, whereas they may complain loudly if <br>
they see &quot;=biblio&quot;.</p>

<p style="margin-top: 1em">&Acirc;&middot; Throughout this
document, &quot;Pod&quot; has been the preferred spelling
for the name of the documentation format. One may also use
&quot;POD&quot; or &quot;pod&quot;. For the documentation
that is <br>
(typically) in the Pod format, you may use &quot;pod&quot;,
or &quot;Pod&quot;, or &quot;POD&quot;. Understanding these
distinctions is useful; but obsessing over how to spell
them, usually is not.</p>

<p style="margin-top: 1em">About L&lt;...&gt; Codes <br>
As you can tell from a glance at perlpod, the L&lt;...&gt;
code is the most complex of the Pod formatting codes. The
points below will hopefully clarify what it means and how
<br>
processors should deal with it.</p>

<p style="margin-top: 1em">&Acirc;&middot; In parsing an
L&lt;...&gt; code, Pod parsers must distinguish at least
four attributes:</p>

<p style="margin-top: 1em">First: <br>
The link-text. If there is none, this must be undef. (E.g.,
in &quot;L&lt;Perl Functions|perlfunc&gt;&quot;, the
link-text is &quot;Perl Functions&quot;. In
&quot;L&lt;Time::HiRes&gt;&quot; and even <br>
&quot;L&lt;|Time::HiRes&gt;&quot;, there is no link text.
Note that link text may contain formatting.)</p>

<p style="margin-top: 1em">Second: <br>
The possibly inferred link-text; i.e., if there was no real
link text, then this is the text that we&rsquo;ll infer in
its place. (E.g., for &quot;L&lt;Getopt::Std&gt;&quot;, the
inferred <br>
link text is &quot;Getopt::Std&quot;.)</p>

<p style="margin-top: 1em">Third: <br>
The name or URL, or undef if none. (E.g., in &quot;L&lt;Perl
Functions|perlfunc&gt;&quot;, the name (also sometimes
called the page) is &quot;perlfunc&quot;. In
&quot;L&lt;/CAVEATS&gt;&quot;, the name is <br>
undef.)</p>

<p style="margin-top: 1em">Fourth: <br>
The section (AKA &quot;item&quot; in older perlpods), or
undef if none. E.g., in
&quot;L&lt;Getopt::Std/DESCRIPTION&gt;&quot;,
&quot;DESCRIPTION&quot; is the section. (Note that this is
not the same as a <br>
manpage section like the &quot;5&quot; in &quot;man 5
crontab&quot;. &quot;Section Foo&quot; in the Pod sense
means the part of the text that&rsquo;s introduced by the
heading or item whose text is &quot;Foo&quot;.)</p>

<p style="margin-top: 1em">Pod parsers may also note
additional attributes including:</p>

<p style="margin-top: 1em">Fifth: <br>
A flag for whether item 3 (if present) is a URL (like
&quot;http://lists.perl.org&quot; is), in which case there
should be no section attribute; a Pod name (like
&quot;perldoc&quot; and <br>
&quot;Getopt::Std&quot; are); or possibly a man page name
(like &quot;crontab(5)&quot; is).</p>

<p style="margin-top: 1em">Sixth: <br>
The raw original L&lt;...&gt; content, before text is split
on &quot;|&quot;, &quot;/&quot;, etc, and before
E&lt;...&gt; codes are expanded.</p>

<p style="margin-top: 1em">(The above were numbered only
for concise reference below. It is not a requirement that
these be passed as an actual list or array.)</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">L&lt;Foo::Bar&gt; <br>
=&gt; undef, # link text <br>
&quot;Foo::Bar&quot;, # possibly inferred link text <br>
&quot;Foo::Bar&quot;, # name <br>
undef, # section <br>
&rsquo;pod&rsquo;, # what sort of link <br>
&quot;Foo::Bar&quot; # original content</p>

<p style="margin-top: 1em">L&lt;Perlport&rsquo;s section on
NL&rsquo;s|perlport/Newlines&gt; <br>
=&gt; &quot;Perlport&rsquo;s section on NL&rsquo;s&quot;, #
link text <br>
&quot;Perlport&rsquo;s section on NL&rsquo;s&quot;, #
possibly inferred link text <br>
&quot;perlport&quot;, # name <br>
&quot;Newlines&quot;, # section <br>
&rsquo;pod&rsquo;, # what sort of link <br>
&quot;Perlport&rsquo;s section on
NL&rsquo;s|perlport/Newlines&quot; # orig. content</p>

<p style="margin-top: 1em">L&lt;perlport/Newlines&gt; <br>
=&gt; undef, # link text <br>
&rsquo;&quot;Newlines&quot; in perlport&rsquo;, # possibly
inferred link text <br>
&quot;perlport&quot;, # name <br>
&quot;Newlines&quot;, # section <br>
&rsquo;pod&rsquo;, # what sort of link <br>
&quot;perlport/Newlines&quot; # original content</p>


<p style="margin-top: 1em">L&lt;crontab(5)/&quot;DESCRIPTION&quot;&gt;
<br>
=&gt; undef, # link text <br>
&rsquo;&quot;DESCRIPTION&quot; in crontab(5)&rsquo;, #
possibly inferred link text <br>
&quot;crontab(5)&quot;, # name <br>
&quot;DESCRIPTION&quot;, # section <br>
&rsquo;man&rsquo;, # what sort of link <br>
&rsquo;crontab(5)/&quot;DESCRIPTION&quot;&rsquo; # original
content</p>

<p style="margin-top: 1em">L&lt;/Object Attributes&gt; <br>
=&gt; undef, # link text <br>
&rsquo;&quot;Object Attributes&quot;&rsquo;, # possibly
inferred link text <br>
undef, # name <br>
&quot;Object Attributes&quot;, # section <br>
&rsquo;pod&rsquo;, # what sort of link <br>
&quot;/Object Attributes&quot; # original content</p>

<p style="margin-top: 1em">L&lt;http://www.perl.org/&gt;
<br>
=&gt; undef, # link text <br>
&quot;http://www.perl.org/&quot;, # possibly inferred link
text <br>
&quot;http://www.perl.org/&quot;, # name <br>
undef, # section <br>
&rsquo;url&rsquo;, # what sort of link <br>
&quot;http://www.perl.org/&quot; # original content</p>


<p style="margin-top: 1em">L&lt;Perl.org|http://www.perl.org/&gt;
<br>
=&gt; &quot;Perl.org&quot;, # link text <br>
&quot;http://www.perl.org/&quot;, # possibly inferred link
text <br>
&quot;http://www.perl.org/&quot;, # name <br>
undef, # section <br>
&rsquo;url&rsquo;, # what sort of link <br>
&quot;Perl.org|http://www.perl.org/&quot; # original
content</p>

<p style="margin-top: 1em">Note that you can distinguish
URL-links from anything else by the fact that they match
&quot;m/1 <br>
isn&rsquo;t.</p>

<p style="margin-top: 1em">&Acirc;&middot; In case of
L&lt;...&gt; codes with no &quot;text|&quot; part in them,
older formatters have exhibited great variation in actually
displaying the link or cross reference. For example, <br>
L&lt;crontab(5)&gt; would render as &quot;the crontab(5)
manpage&quot;, or &quot;in the crontab(5) manpage&quot; or
just &quot;crontab(5)&quot;.</p>

<p style="margin-top: 1em">Pod processors must now treat
&quot;text|&quot;-less links as follows:</p>

<p style="margin-top: 1em">L&lt;name&gt; =&gt;
L&lt;name|name&gt; <br>
L&lt;/section&gt; =&gt;
L&lt;&quot;section&quot;|/section&gt; <br>
L&lt;name/section&gt; =&gt; L&lt;&quot;section&quot; in
name|name/section&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Note that
section names might contain markup. I.e., if a section
starts with:</p>

<p style="margin-top: 1em">=head2 About the C&lt;-M&gt;
Operator</p>

<p style="margin-top: 1em">or with:</p>

<p style="margin-top: 1em">=item About the C&lt;-M&gt;
Operator</p>

<p style="margin-top: 1em">then a link to it would look
like this:</p>

<p style="margin-top: 1em">L&lt;somedoc/About the
C&lt;-M&gt; Operator&gt;</p>

<p style="margin-top: 1em">Formatters may choose to ignore
the markup for purposes of resolving the link and use only
the renderable characters in the section name, as in:</p>

<p style="margin-top: 1em">&lt;h1&gt;&lt;a
name=&quot;About_the_-M_Operator&quot;&gt;About the
&lt;code&gt;-M&lt;/code&gt; <br>
Operator&lt;/h1&gt;</p>

<p style="margin-top: 1em">...</p>

<p style="margin-top: 1em">&lt;a
href=&quot;somedoc#About_the_-M_Operator&quot;&gt;About the
&lt;code&gt;-M&lt;/code&gt; <br>
Operator&quot; in somedoc&lt;/a&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Previous
versions of perlpod distinguished
&quot;L&lt;name/&quot;section&quot;&gt;&quot; links from
&quot;L&lt;name/item&gt;&quot; links (and their targets).
These have been merged syntactically and semantically in
<br>
the current specification, and section can refer either to a
&quot;=headn Heading Content&quot; command or to a
&quot;=item Item Content&quot; command. This specification
does not specify what <br>
behavior should be in the case of a given document having
several things all seeming to produce the same section
identifier (e.g., in HTML, several things all producing the
<br>
same anchorname in &lt;a
name=&quot;anchorname&quot;&gt;...&lt;/a&gt; elements).
Where Pod processors can control this behavior, they should
use the first such anchor. That is,
&quot;L&lt;Foo/Bar&gt;&quot; <br>
refers to the first &quot;Bar&quot; section in Foo.</p>

<p style="margin-top: 1em">But for some processors/formats
this cannot be easily controlled; as with the HTML example,
the behavior of multiple ambiguous &lt;a
name=&quot;anchorname&quot;&gt;...&lt;/a&gt; is most easily
<br>
just left up to browsers to decide.</p>

<p style="margin-top: 1em">&Acirc;&middot; In a
&quot;L&lt;text|...&gt;&quot; code, text may contain
formatting codes for formatting or for E&lt;...&gt; escapes,
as in:</p>


<p style="margin-top: 1em">L&lt;B&lt;ummE&lt;234&gt;stuff&gt;|...&gt;</p>

<p style="margin-top: 1em">For &quot;L&lt;...&gt;&quot;
codes without a &quot;name|&quot; part, only
&quot;E&lt;...&gt;&quot; and &quot;Z&lt;&gt;&quot; codes may
occur. That is, authors should not use
&quot;&quot;L&lt;B&lt;Foo::Bar&gt;&gt;&quot;&quot;.</p>

<p style="margin-top: 1em">Note, however, that formatting
codes and Z&lt;&gt;&rsquo;s can occur in any and all parts
of an L&lt;...&gt; (i.e., in name, section, text, and
url).</p>

<p style="margin-top: 1em">Authors must not nest
L&lt;...&gt; codes. For example, &quot;L&lt;The
L&lt;Foo::Bar&gt; man page&gt;&quot; should be treated as an
error.</p>

<p style="margin-top: 1em">&Acirc;&middot; Note that Pod
authors may use formatting codes inside the &quot;text&quot;
part of &quot;L&lt;text|name&gt;&quot; (and so on for
L&lt;text|/&quot;sec&quot;&gt;).</p>

<p style="margin-top: 1em">In other words, this is
valid:</p>

<p style="margin-top: 1em">Go read L&lt;the docs on
C&lt;$.&gt;|perlvar/&quot;$.&quot;&gt;</p>

<p style="margin-top: 1em">Some output formats that do
allow rendering &quot;L&lt;...&gt;&quot; codes as hypertext,
might not allow the link-text to be formatted; in that case,
formatters will have to just ignore that <br>
formatting.</p>

<p style="margin-top: 1em">&Acirc;&middot; At time of
writing, &quot;L&lt;name&gt;&quot; values are of two types:
either the name of a Pod page like
&quot;L&lt;Foo::Bar&gt;&quot; (which might be a real Perl
module or program in an @INC / PATH <br>
directory, or a .pod file in those places); or the name of a
Unix man page, like &quot;L&lt;crontab(5)&gt;&quot;. In
theory, &quot;L&lt;chmod&gt;&quot; in ambiguous between a
Pod page called &quot;chmod&quot;, or <br>
the Unix man page &quot;chmod&quot; (in whatever
man-section). However, the presence of a string in parens,
as in &quot;crontab(5)&quot;, is sufficient to signal that
what is being discussed is <br>
not a Pod page, and so is presumably a Unix man page. The
distinction is of no importance to many Pod processors, but
some processors that render to hypertext formats may <br>
need to distinguish them in order to know how to render a
given &quot;L&lt;foo&gt;&quot; code.</p>

<p style="margin-top: 1em">&Acirc;&middot; Previous
versions of perlpod allowed for a
&quot;L&lt;section&gt;&quot; syntax (as in &quot;L&lt;Object
Attributes&gt;&quot;), which was not easily distinguishable
from &quot;L&lt;name&gt;&quot; syntax and for <br>
&quot;L&lt;&quot;section&quot;&gt;&quot; which was only
slightly less ambiguous. This syntax is no longer in the
specification, and has been replaced by the
&quot;L&lt;/section&gt;&quot; syntax (where the slash was
<br>
formerly optional). Pod parsers should tolerate the
&quot;L&lt;&quot;section&quot;&gt;&quot; syntax, for a while
at least. The suggested heuristic for distinguishing
&quot;L&lt;section&gt;&quot; from &quot;L&lt;name&gt;&quot;
is <br>
that if it contains any whitespace, it&rsquo;s a section.
Pod processors should warn about this being deprecated
syntax.</p>

<p style="margin-top: 1em">About =over...=back Regions <br>
&quot;=over&quot;...&quot;=back&quot; regions are used for
various kinds of list-like structures. (I use the term
&quot;region&quot; here simply as a collective term for
everything from the &quot;=over&quot; to the <br>
matching &quot;=back&quot;.)</p>

<p style="margin-top: 1em">&Acirc;&middot; The non-zero
numeric indentlevel in &quot;=over indentlevel&quot; ...
&quot;=back&quot; is used for giving the formatter a clue as
to how many &quot;spaces&quot; (ems, or roughly equivalent
units) it <br>
should tab over, although many formatters will have to
convert this to an absolute measurement that may not exactly
match with the size of spaces (or M&rsquo;s) in the
document&rsquo;s <br>
base font. Other formatters may have to completely ignore
the number. The lack of any explicit indentlevel parameter
is equivalent to an indentlevel value of 4. Pod <br>
processors may complain if indentlevel is present but is not
a positive number matching &quot;m/0</p>

<p style="margin-top: 1em">&Acirc;&middot; Authors of Pod
formatters are reminded that &quot;=over&quot; ...
&quot;=back&quot; may map to several different constructs in
your output format. For example, in converting Pod to
(X)HTML, it <br>
can map to any of &lt;ul&gt;...&lt;/ul&gt;,
&lt;ol&gt;...&lt;/ol&gt;, &lt;dl&gt;...&lt;/dl&gt;, or
&lt;blockquote&gt;...&lt;/blockquote&gt;. Similarly,
&quot;=item&quot; can map to &lt;li&gt; or &lt;dt&gt;.</p>

<p style="margin-top: 1em">&Acirc;&middot; Each
&quot;=over&quot; ... &quot;=back&quot; region should be one
of the following:</p>

<p style="margin-top: 1em">&Acirc;&middot; An
&quot;=over&quot; ... &quot;=back&quot; region containing
only &quot;=item *&quot; commands, each followed by some
number of ordinary/verbatim paragraphs, other nested
&quot;=over&quot; ... &quot;=back&quot; regions, <br>
&quot;=for...&quot; paragraphs, and
&quot;=begin&quot;...&quot;=end&quot; regions.</p>

<p style="margin-top: 1em">(Pod processors must tolerate a
bare &quot;=item&quot; as if it were &quot;=item *&quot;.)
Whether &quot;*&quot; is rendered as a literal asterisk, an
&quot;o&quot;, or as some kind of real bullet character,
<br>
is left up to the Pod formatter, and may depend on the level
of nesting.</p>

<p style="margin-top: 1em">&Acirc;&middot; An
&quot;=over&quot; ... &quot;=back&quot; region containing
only &quot;m/0 <br>
paragraphs, other nested &quot;=over&quot; ...
&quot;=back&quot; regions, &quot;=for...&quot; paragraphs,
and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note
that the numbers must start at 1 in each section, and <br>
must proceed in order and without skipping numbers.</p>

<p style="margin-top: 1em">(Pod processors must tolerate
lines like &quot;=item 1&quot; as if they were &quot;=item
1.&quot;, with the period.)</p>

<p style="margin-top: 1em">&Acirc;&middot; An
&quot;=over&quot; ... &quot;=back&quot; region containing
only &quot;=item [text]&quot; commands, each one (or each
group of them) followed by some number of ordinary/verbatim
paragraphs, other <br>
nested &quot;=over&quot; ... &quot;=back&quot; regions, or
&quot;=for...&quot; paragraphs, and
&quot;=begin&quot;...&quot;=end&quot; regions.</p>

<p style="margin-top: 1em">The &quot;=item [text]&quot;
paragraph should not match &quot;m/0</p>

<p style="margin-top: 1em">&Acirc;&middot; An
&quot;=over&quot; ... &quot;=back&quot; region containing no
&quot;=item&quot; paragraphs at all, and containing only
some number of ordinary/verbatim paragraphs, and possibly
also some nested <br>
&quot;=over&quot; ... &quot;=back&quot; regions,
&quot;=for...&quot; paragraphs, and
&quot;=begin&quot;...&quot;=end&quot; regions. Such an
itemless &quot;=over&quot; ... &quot;=back&quot; region in
Pod is equivalent in meaning to a <br>
&quot;&lt;blockquote&gt;...&lt;/blockquote&gt;&quot; element
in HTML.</p>

<p style="margin-top: 1em">Note that with all the above
cases, you can determine which type of &quot;=over&quot; ...
&quot;=back&quot; you have, by examining the first
(non-&quot;=cut&quot;, non-&quot;=pod&quot;) Pod paragraph
after the <br>
&quot;=over&quot; command.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod formatters
must tolerate arbitrarily large amounts of text in the
&quot;=item text...&quot; paragraph. In practice, most such
paragraphs are short, as in:</p>

<p style="margin-top: 1em">=item For cutting off our trade
with all parts of the world</p>

<p style="margin-top: 1em">But they may be arbitrarily
long:</p>

<p style="margin-top: 1em">=item For transporting us beyond
seas to be tried for pretended <br>
offenses</p>

<p style="margin-top: 1em">=item He is at this time
transporting large armies of foreign <br>
mercenaries to complete the works of death, desolation and
<br>
tyranny, already begun with circumstances of cruelty and
perfidy <br>
scarcely paralleled in the most barbarous ages, and totally
<br>
unworthy the head of a civilized nation.</p>

<p style="margin-top: 1em">&Acirc;&middot; Pod processors
should tolerate &quot;=item *&quot; / &quot;=item
number&quot; commands with no accompanying paragraph. The
middle item is an example:</p>

<p style="margin-top: 1em">=over</p>

<p style="margin-top: 1em">=item 1</p>

<p style="margin-top: 1em">Pick up dry cleaning.</p>

<p style="margin-top: 1em">=item 2</p>

<p style="margin-top: 1em">=item 3</p>

<p style="margin-top: 1em">Stop by the store. Get Abba
Zabas, Stoli, and cheap lawn chairs.</p>

<p style="margin-top: 1em">=back</p>

<p style="margin-top: 1em">&Acirc;&middot; No
&quot;=over&quot; ... &quot;=back&quot; region can contain
headings. Processors may treat such a heading as an
error.</p>

<p style="margin-top: 1em">&Acirc;&middot; Note that an
&quot;=over&quot; ... &quot;=back&quot; region should have
some content. That is, authors should not have an empty
region like this:</p>

<p style="margin-top: 1em">=over</p>

<p style="margin-top: 1em">=back</p>

<p style="margin-top: 1em">Pod processors seeing such a
contentless &quot;=over&quot; ... &quot;=back&quot; region,
may ignore it, or may report it as an error.</p>

<p style="margin-top: 1em">&Acirc;&middot; Processors must
tolerate an &quot;=over&quot; list that goes off the end of
the document (i.e., which has no matching
&quot;=back&quot;), but they may warn about such a list.</p>

<p style="margin-top: 1em">&Acirc;&middot; Authors of Pod
formatters should note that this construct:</p>

<p style="margin-top: 1em">=item Neque</p>

<p style="margin-top: 1em">=item Porro</p>

<p style="margin-top: 1em">=item Quisquam Est</p>

<p style="margin-top: 1em">Qui dolorem ipsum quia dolor sit
amet, consectetur, adipisci <br>
velit, sed quia non numquam eius modi tempora incidunt ut
<br>
labore et dolore magnam aliquam quaerat voluptatem.</p>

<p style="margin-top: 1em">=item Ut Enim</p>

<p style="margin-top: 1em">is semantically ambiguous, in a
way that makes formatting decisions a bit difficult. On the
one hand, it could be mention of an item &quot;Neque&quot;,
mention of another item <br>
&quot;Porro&quot;, and mention of another item
&quot;Quisquam Est&quot;, with just the last one requiring
the explanatory paragraph &quot;Qui dolorem ipsum quia
dolor...&quot;; and then an item &quot;Ut Enim&quot;. <br>
In that case, you&rsquo;d want to format it like so:</p>

<p style="margin-top: 1em">Neque</p>

<p style="margin-top: 1em">Porro</p>

<p style="margin-top: 1em">Quisquam Est <br>
Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
<br>
velit, sed quia non numquam eius modi tempora incidunt ut
<br>
labore et dolore magnam aliquam quaerat voluptatem.</p>

<p style="margin-top: 1em">Ut Enim</p>

<p style="margin-top: 1em">But it could equally well be a
discussion of three (related or equivalent) items,
&quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam
Est&quot;, followed by a paragraph explaining them all, and
then <br>
a new item &quot;Ut Enim&quot;. In that case, you&rsquo;d
probably want to format it like so:</p>

<p style="margin-top: 1em">Neque <br>
Porro <br>
Quisquam Est <br>
Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
<br>
velit, sed quia non numquam eius modi tempora incidunt ut
<br>
labore et dolore magnam aliquam quaerat voluptatem.</p>

<p style="margin-top: 1em">Ut Enim</p>

<p style="margin-top: 1em">But (for the foreseeable
future), Pod does not provide any way for Pod authors to
distinguish which grouping is meant by the above
&quot;=item&quot;-cluster structure. So formatters <br>
should format it like so:</p>

<p style="margin-top: 1em">Neque</p>

<p style="margin-top: 1em">Porro</p>

<p style="margin-top: 1em">Quisquam Est</p>

<p style="margin-top: 1em">Qui dolorem ipsum quia dolor sit
amet, consectetur, adipisci <br>
velit, sed quia non numquam eius modi tempora incidunt ut
<br>
labore et dolore magnam aliquam quaerat voluptatem.</p>

<p style="margin-top: 1em">Ut Enim</p>

<p style="margin-top: 1em">That is, there should be (at
least roughly) equal spacing between items as between
paragraphs (although that spacing may well be less than the
full height of a line of text). <br>
This leaves it to the reader to use (con)textual cues to
figure out whether the &quot;Qui dolorem ipsum...&quot;
paragraph applies to the &quot;Quisquam Est&quot; item or to
all three items <br>
&quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam
Est&quot;. While not an ideal situation, this is preferable
to providing formatting cues that may be actually contrary
to the author&rsquo;s intent.</p>

<p style="margin-top: 1em">About Data Paragraphs and
&quot;=begin/=end&quot; Regions <br>
Data paragraphs are typically used for inlining non-Pod data
that is to be used (typically passed through) when rendering
the document to a specific format:</p>

<p style="margin-top: 1em">=begin rtf</p>

<p style="margin-top: 1em">ar{ardqri Printed&nbsp; <br>
=end rtf</p>

<p style="margin-top: 1em">The exact same effect could,
incidentally, be achieved with a single &quot;=for&quot;
paragraph:</p>

<p style="margin-top: 1em">=for rtf ar{ardqri Printed&nbsp;
<br>
(Although that is not formally a data paragraph, it has the
same meaning as one, and Pod parsers may parse it as
one.)</p>

<p style="margin-top: 1em">Another example of a data
paragraph:</p>

<p style="margin-top: 1em">=begin html</p>

<p style="margin-top: 1em">I like
&lt;em&gt;PIE&lt;/em&gt;!</p>

<p style="margin-top: 1em">&lt;hr&gt;Especially pecan
pie!</p>

<p style="margin-top: 1em">=end html</p>

<p style="margin-top: 1em">If these were ordinary
paragraphs, the Pod parser would try to expand the
&quot;E&lt;/em&gt;&quot; (in the first paragraph) as a
formatting code, just like &quot;E&lt;lt&gt;&quot; or
&quot;E&lt;eacute&gt;&quot;. But since <br>
this is in a &quot;=begin identifier&quot;...&quot;=end
identifier&quot; region and the identifier &quot;html&quot;
doesn&rsquo;t begin have a &quot;:&quot; prefix, the
contents of this region are stored as data paragraphs, <br>
instead of being processed as ordinary paragraphs (or if
they began with a spaces and/or tabs, as verbatim
paragraphs).</p>

<p style="margin-top: 1em">As a further example: At time of
writing, no &quot;biblio&quot; identifier is supported, but
suppose some processor were written to recognize it as a way
of (say) denoting a bibliographic <br>
reference (necessarily containing formatting codes in
ordinary paragraphs). The fact that &quot;biblio&quot;
paragraphs were meant for ordinary processing would be
indicated by prefacing <br>
each &quot;biblio&quot; identifier with a colon:</p>

<p style="margin-top: 1em">=begin :biblio</p>

<p style="margin-top: 1em">Wirth, Niklaus. 1976.
I&lt;Algorithms + Data Structures = <br>
Programs.&gt; Prentice-Hall, Englewood Cliffs, NJ.</p>

<p style="margin-top: 1em">=end :biblio</p>

<p style="margin-top: 1em">This would signal to the parser
that paragraphs in this begin...end region are subject to
normal handling as ordinary/verbatim paragraphs (while still
tagged as meant only for <br>
processors that understand the &quot;biblio&quot;
identifier). The same effect could be had with:</p>

<p style="margin-top: 1em">=for :biblio <br>
Wirth, Niklaus. 1976. I&lt;Algorithms + Data Structures =
<br>
Programs.&gt; Prentice-Hall, Englewood Cliffs, NJ.</p>

<p style="margin-top: 1em">The &quot;:&quot; on these
identifiers means simply &quot;process this stuff normally,
even though the result will be for some special
target&quot;. I suggest that parser APIs report
&quot;biblio&quot; as <br>
the target identifier, but also report that it had a
&quot;:&quot; prefix. (And similarly, with the above
&quot;html&quot;, report &quot;html&quot; as the target
identifier, and note the lack of a &quot;:&quot; <br>
prefix.)</p>

<p style="margin-top: 1em">Note that a &quot;=begin
identifier&quot;...&quot;=end identifier&quot; region where
identifier begins with a colon, can contain commands. For
example:</p>

<p style="margin-top: 1em">=begin :biblio</p>

<p style="margin-top: 1em">Wirth&rsquo;s classic is
available in several editions, including:</p>

<p style="margin-top: 1em">=for comment <br>
hm, check abebooks.com for how much used copies cost.</p>

<p style="margin-top: 1em">=over</p>

<p style="margin-top: 1em">=item</p>

<p style="margin-top: 1em">Wirth, Niklaus. 1975.
I&lt;Algorithmen und Datenstrukturen.&gt; <br>
Teubner, Stuttgart. [Yes, it&rsquo;s in German.]</p>

<p style="margin-top: 1em">=item</p>

<p style="margin-top: 1em">Wirth, Niklaus. 1976.
I&lt;Algorithms + Data Structures = <br>
Programs.&gt; Prentice-Hall, Englewood Cliffs, NJ.</p>

<p style="margin-top: 1em">=back</p>

<p style="margin-top: 1em">=end :biblio</p>

<p style="margin-top: 1em">Note, however, a &quot;=begin
identifier&quot;...&quot;=end identifier&quot; region where
identifier does not begin with a colon, should not directly
contain &quot;=head1&quot; ... &quot;=head4&quot; commands,
nor <br>
&quot;=over&quot;, nor &quot;=back&quot;, nor
&quot;=item&quot;. For example, this may be considered
invalid:</p>

<p style="margin-top: 1em">=begin somedata</p>

<p style="margin-top: 1em">This is a data paragraph.</p>

<p style="margin-top: 1em">=head1 Don&rsquo;t do this!</p>

<p style="margin-top: 1em">This is a data paragraph
too.</p>

<p style="margin-top: 1em">=end somedata</p>

<p style="margin-top: 1em">A Pod processor may signal that
the above (specifically the &quot;=head1&quot; paragraph) is
an error. Note, however, that the following should not be
treated as an error:</p>

<p style="margin-top: 1em">=begin somedata</p>

<p style="margin-top: 1em">This is a data paragraph.</p>

<p style="margin-top: 1em">=cut</p>

<p style="margin-top: 1em"># Yup, this isn&rsquo;t Pod
anymore. <br>
sub excl { (rand() &gt; .5) ? &quot;hoo!&quot; :
&quot;hah!&quot; }</p>

<p style="margin-top: 1em">=pod</p>

<p style="margin-top: 1em">This is a data paragraph
too.</p>

<p style="margin-top: 1em">=end somedata</p>

<p style="margin-top: 1em">And this too is valid:</p>

<p style="margin-top: 1em">=begin someformat</p>

<p style="margin-top: 1em">This is a data paragraph.</p>

<p style="margin-top: 1em">And this is a data
paragraph.</p>

<p style="margin-top: 1em">=begin someotherformat</p>

<p style="margin-top: 1em">This is a data paragraph
too.</p>

<p style="margin-top: 1em">And this is a data paragraph
too.</p>

<p style="margin-top: 1em">=begin :yetanotherformat</p>

<p style="margin-top: 1em">=head2 This is a command
paragraph!</p>

<p style="margin-top: 1em">This is an ordinary
paragraph!</p>

<p style="margin-top: 1em">And this is a verbatim
paragraph!</p>

<p style="margin-top: 1em">=end :yetanotherformat</p>

<p style="margin-top: 1em">=end someotherformat</p>

<p style="margin-top: 1em">Another data paragraph!</p>

<p style="margin-top: 1em">=end someformat</p>

<p style="margin-top: 1em">The contents of the above
&quot;=begin :yetanotherformat&quot; ... &quot;=end
:yetanotherformat&quot; region aren&rsquo;t data paragraphs,
because the immediately containing region&rsquo;s identifier
<br>
(&quot;:yetanotherformat&quot;) begins with a colon. In
practice, most regions that contain data paragraphs will
contain only data paragraphs; however, the above nesting is
syntactically <br>
valid as Pod, even if it is rare. However, the handlers for
some formats, like &quot;html&quot;, will accept only data
paragraphs, not nested regions; and they may complain if
they see <br>
(targeted for them) nested regions, or commands, other than
&quot;=end&quot;, &quot;=pod&quot;, and
&quot;=cut&quot;.</p>

<p style="margin-top: 1em">Also consider this valid
structure:</p>

<p style="margin-top: 1em">=begin :biblio</p>

<p style="margin-top: 1em">Wirth&rsquo;s classic is
available in several editions, including:</p>

<p style="margin-top: 1em">=over</p>

<p style="margin-top: 1em">=item</p>

<p style="margin-top: 1em">Wirth, Niklaus. 1975.
I&lt;Algorithmen und Datenstrukturen.&gt; <br>
Teubner, Stuttgart. [Yes, it&rsquo;s in German.]</p>

<p style="margin-top: 1em">=item</p>

<p style="margin-top: 1em">Wirth, Niklaus. 1976.
I&lt;Algorithms + Data Structures = <br>
Programs.&gt; Prentice-Hall, Englewood Cliffs, NJ.</p>

<p style="margin-top: 1em">=back</p>

<p style="margin-top: 1em">Buy buy buy!</p>

<p style="margin-top: 1em">=begin html</p>

<p style="margin-top: 1em">&lt;img
src=&rsquo;wirth_spokesmodeling_book.png&rsquo;&gt;</p>

<p style="margin-top: 1em">&lt;hr&gt;</p>

<p style="margin-top: 1em">=end html</p>

<p style="margin-top: 1em">Now now now!</p>

<p style="margin-top: 1em">=end :biblio</p>

<p style="margin-top: 1em">There, the &quot;=begin
html&quot;...&quot;=end html&quot; region is nested inside
the larger &quot;=begin :biblio&quot;...&quot;=end
:biblio&quot; region. Note that the content of the
&quot;=begin html&quot;...&quot;=end html&quot; <br>
region is data paragraph(s), because the immediately
containing region&rsquo;s identifier (&quot;html&quot;)
doesn&rsquo;t begin with a colon.</p>

<p style="margin-top: 1em">Pod parsers, when processing a
series of data paragraphs one after another (within a single
region), should consider them to be one large data paragraph
that happens to contain <br>
blank lines. So the content of the above &quot;=begin
html&quot;...&quot;=end html&quot; may be stored as two data
paragraphs (one consisting of &quot;&lt;img
src=&rsquo;wirth_spokesmodeling_book.png&rsquo;&gt;0 and
<br>
another consisting of &quot;&lt;hr&gt;0), but should be
stored as a single data paragraph (consisting of
&quot;&lt;img
src=&rsquo;wirth_spokesmodeling_book.png&rsquo;&gt;0hr&gt;0).</p>

<p style="margin-top: 1em">Pod processors should tolerate
empty &quot;=begin something&quot;...&quot;=end
something&quot; regions, empty &quot;=begin
:something&quot;...&quot;=end :something&quot; regions, and
contentless &quot;=for something&quot; and <br>
&quot;=for :something&quot; paragraphs. I.e., these should
be tolerated:</p>

<p style="margin-top: 1em">=for html</p>

<p style="margin-top: 1em">=begin html</p>

<p style="margin-top: 1em">=end html</p>

<p style="margin-top: 1em">=begin :biblio</p>

<p style="margin-top: 1em">=end :biblio</p>

<p style="margin-top: 1em">Incidentally, note that
there&rsquo;s no easy way to express a data paragraph
starting with something that looks like a command.
Consider:</p>

<p style="margin-top: 1em">=begin stuff</p>

<p style="margin-top: 1em">=shazbot</p>

<p style="margin-top: 1em">=end stuff</p>

<p style="margin-top: 1em">There, &quot;=shazbot&quot; will
be parsed as a Pod command &quot;shazbot&quot;, not as a
data paragraph &quot;=shazbot0. However, you can express a
data paragraph consisting of &quot;=shazbot0 using <br>
this code:</p>

<p style="margin-top: 1em">=for stuff =shazbot</p>

<p style="margin-top: 1em">The situation where this is
necessary, is presumably quite rare.</p>

<p style="margin-top: 1em">Note that =end commands must
match the currently open =begin command. That is, they must
properly nest. For example, this is valid:</p>

<p style="margin-top: 1em">=begin outer</p>

<p style="margin-top: 1em">X</p>

<p style="margin-top: 1em">=begin inner</p>

<p style="margin-top: 1em">Y</p>

<p style="margin-top: 1em">=end inner</p>

<p style="margin-top: 1em">Z</p>

<p style="margin-top: 1em">=end outer</p>

<p style="margin-top: 1em">while this is invalid:</p>

<p style="margin-top: 1em">=begin outer</p>

<p style="margin-top: 1em">X</p>

<p style="margin-top: 1em">=begin inner</p>

<p style="margin-top: 1em">Y</p>

<p style="margin-top: 1em">=end outer</p>

<p style="margin-top: 1em">Z</p>

<p style="margin-top: 1em">=end inner</p>

<p style="margin-top: 1em">This latter is improper because
when the &quot;=end outer&quot; command is seen, the
currently open region has the formatname &quot;inner&quot;,
not &quot;outer&quot;. (It just happens that
&quot;outer&quot; is the <br>
format name of a higher-up region.) This is an error.
Processors must by default report this as an error, and may
halt processing the document containing that error. A <br>
corollary of this is that regions cannot
&quot;overlap&quot;. That is, the latter block above does
not represent a region called &quot;outer&quot; which
contains X and Y, overlapping a region called <br>
&quot;inner&quot; which contains Y and Z. But because it is
invalid (as all apparently overlapping regions would be), it
doesn&rsquo;t represent that, or anything at all.</p>

<p style="margin-top: 1em">Similarly, this is invalid:</p>

<p style="margin-top: 1em">=begin thing</p>

<p style="margin-top: 1em">=end hting</p>

<p style="margin-top: 1em">This is an error because the
region is opened by &quot;thing&quot;, and the
&quot;=end&quot; tries to close &quot;hting&quot; [sic].</p>

<p style="margin-top: 1em">This is also invalid:</p>

<p style="margin-top: 1em">=begin thing</p>

<p style="margin-top: 1em">=end</p>

<p style="margin-top: 1em">This is invalid because every
&quot;=end&quot; command must have a formatname
parameter.</p>

<p style="margin-top: 1em">SEE ALSO <br>
perlpod, &quot;PODs: Embedded Documentation&quot; in
perlsyn, podchecker</p>

<p style="margin-top: 1em">AUTHOR <br>
Sean M. Burke</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLPODSPEC(1)</p>
<hr>
</body>
</html>
