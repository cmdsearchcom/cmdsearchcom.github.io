<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:24 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GAWK(1) Utility Commands GAWK(1)</p>

<p style="margin-top: 1em">NAME <br>
gawk - pattern scanning and processing language</p>

<p style="margin-top: 1em">SYNOPSIS <br>
gawk [ POSIX or GNU style options ] -f program-file [ -- ]
file ... <br>
gawk [ POSIX or GNU style options ] [ -- ] program-text file
...</p>

<p style="margin-top: 1em">pgawk [ POSIX or GNU style
options ] -f program-file [ -- ] file ... <br>
pgawk [ POSIX or GNU style options ] [ -- ] program-text
file ...</p>

<p style="margin-top: 1em">dgawk [ POSIX or GNU style
options ] -f program-file [ -- ] file ...</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Gawk is the GNU Project&rsquo;s implementation of the AWK
programming language. It conforms to the definition of the
language in the POSIX 1003.1 Standard. This version in turn
is <br>
based on the description in The AWK Programming Language, by
Aho, Kernighan, and Weinberger. Gawk provides the additional
features found in the current version of UNIX awk and a <br>
number of GNU-specific extensions.</p>

<p style="margin-top: 1em">The command line consists of
options to gawk itself, the AWK program text (if not
supplied via the -f or --file options), and values to be
made available in the ARGC and ARGV <br>
pre-defined AWK variables.</p>

<p style="margin-top: 1em">Pgawk is the profiling version
of gawk. It is identical in every way to gawk, except that
programs run more slowly, and it automatically produces an
execution profile in the <br>
file awkprof.out when done. See the --profile option,
below.</p>

<p style="margin-top: 1em">Dgawk is an awk debugger.
Instead of running the program directly, it loads the AWK
source code and then prompts for debugging commands. Unlike
gawk and pgawk, dgawk only pro&acirc; <br>
cesses AWK program source provided with the -f option. The
debugger is documented in GAWK: Effective AWK
Programming.</p>

<p style="margin-top: 1em">OPTION FORMAT <br>
Gawk options may be either traditional POSIX-style one
letter options, or GNU-style long options. POSIX options
start with a single &acirc;-&acirc;, while long options
start with &acirc;--&acirc;. <br>
Long options are provided for both GNU-specific features and
for POSIX-mandated features.</p>

<p style="margin-top: 1em">Gawk- specific options are
typically used in long-option form. Arguments to long
options are either joined with the option by an = sign, with
no intervening spaces, or they may <br>
be provided in the next command line argument. Long options
may be abbreviated, as long as the abbreviation remains
unique.</p>

<p style="margin-top: 1em">Additionally, each long option
has a corresponding short option, so that the option&rsquo;s
functionality may be used from within #! executable
scripts.</p>

<p style="margin-top: 1em">OPTIONS <br>
Gawk accepts the following options. Standard options are
listed first, followed by options for gawk extensions,
listed alphabetically by short option.</p>

<p style="margin-top: 1em">-f program-file <br>
--file program-file <br>
Read the AWK program source from the file program-file,
instead of from the first command line argument. Multiple -f
(or --file) options may be used.</p>

<p style="margin-top: 1em">-F fs <br>
--field-separator fs <br>
Use fs for the input field separator (the value of the FS
predefined variable).</p>

<p style="margin-top: 1em">-v var=val <br>
--assign var=val <br>
Assign the value val to the variable var, before execution
of the program begins. Such variable values are available to
the BEGIN block of an AWK program.</p>

<p style="margin-top: 1em">-b <br>
--characters-as-bytes <br>
Treat all input data as single-byte characters. In other
words, don&rsquo;t pay any attention to the locale
information when attempting to process strings as multibyte
charac&acirc; <br>
ters. The --posix option overrides this one.</p>

<p style="margin-top: 1em">-c <br>
--traditional <br>
Run in compatibility mode. In compatibility mode, gawk
behaves identically to UNIX awk; none of the GNU-specific
extensions are recognized. See GNU EXTENSIONS, below, <br>
for more information.</p>

<p style="margin-top: 1em">-C <br>
--copyright <br>
Print the short version of the GNU copyright information
message on the standard output and exit successfully.</p>

<p style="margin-top: 1em">-d[file] <br>
--dump-variables[=file] <br>
Print a sorted list of global variables, their types and
final values to file. If no file is provided, gawk uses a
file named awkvars.out in the current directory. <br>
Having a list of all the global variables is a good way to
look for typographical errors in your programs. You would
also use this option if you have a large program with <br>
a lot of functions, and you want to be sure that your
functions don&rsquo;t inadvertently use global variables
that you meant to be local. (This is a particularly easy
mistake <br>
to make with simple variable names like i, j, and so
on.)</p>

<p style="margin-top: 1em">-e program-text <br>
--source program-text <br>
Use program-text as AWK program source code. This option
allows the easy intermixing of library functions (used via
the -f and --file options) with source code entered on <br>
the command line. It is intended primarily for medium to
large AWK programs used in shell scripts.</p>

<p style="margin-top: 1em">-E file <br>
--exec file <br>
Similar to -f, however, this is option is the last one
processed. This should be used with #! scripts, particularly
for CGI applications, to avoid passing in options or <br>
source code (!) on the command line from a URL. This option
disables command-line variable assignments.</p>

<p style="margin-top: 1em">-g <br>
--gen-pot <br>
Scan and parse the AWK program, and generate a GNU .pot
(Portable Object Template) format file on standard output
with entries for all localizable strings in the program.
<br>
The program itself is not executed. See the GNU gettext
distribution for more information on .pot files.</p>

<p style="margin-top: 1em">-h <br>
--help Print a relatively short summary of the available
options on the standard output. (Per the GNU Coding
Standards, these options cause an immediate, successful
exit.)</p>

<p style="margin-top: 1em">-L [value] <br>
--lint[=value] <br>
Provide warnings about constructs that are dubious or
non-portable to other AWK implementations. With an optional
argument of fatal, lint warnings become fatal errors. <br>
This may be drastic, but its use will certainly encourage
the development of cleaner AWK programs. With an optional
argument of invalid, only warnings about things that <br>
are actually invalid are issued. (This is not fully
implemented yet.)</p>

<p style="margin-top: 1em">-n <br>
--non-decimal-data <br>
Recognize octal and hexadecimal values in input data. Use
this option with great caution!</p>

<p style="margin-top: 1em">-N <br>
--use-lc-numeric <br>
This forces gawk to use the locale&rsquo;s decimal point
character when parsing input data. Although the POSIX
standard requires this behavior, and gawk does so when
--posix is <br>
in effect, the default is to follow traditional behavior and
use a period as the decimal point, even in locales where the
period is not the decimal point character. This <br>
option overrides the default behavior, without the full
draconian strictness of the --posix option.</p>

<p style="margin-top: 1em">-O <br>
--optimize <br>
Enable optimizations upon the internal representation of the
program. Currently, this includes just simple
constant-folding. The gawk maintainer hopes to add
additional <br>
optimizations over time.</p>

<p style="margin-top: 1em">-p[prof_file] <br>
--profile[=prof_file] <br>
Send profiling data to prof_file. The default is
awkprof.out. When run with gawk, the profile is just a
&acirc;pretty printed&acirc; version of the program. When
run with pgawk, <br>
the profile contains execution counts of each statement in
the program in the left margin and function call counts for
each user-defined function.</p>

<p style="margin-top: 1em">-P <br>
--posix <br>
This turns on compatibility mode, with the following
additional restrictions:</p>

<p style="margin-top: 1em">&Acirc;&middot; escape sequences
are not recognized.</p>

<p style="margin-top: 1em">&Acirc;&middot; Only space and
tab act as field separators when FS is set to a single
space, newline does not.</p>

<p style="margin-top: 1em">&Acirc;&middot; You cannot
continue lines after ? and :.</p>

<p style="margin-top: 1em">&Acirc;&middot; The synonym func
for the keyword function is not recognized.</p>

<p style="margin-top: 1em">&Acirc;&middot; The operators **
and **= cannot be used in place of ^ and ^=.</p>

<p style="margin-top: 1em">-r <br>
--re-interval <br>
Enable the use of interval expressions in regular expression
matching (see Regular Expressions, below). Interval
expressions were not traditionally available in the AWK <br>
language. The POSIX standard added them, to make awk and
egrep consistent with each other. They are enabled by
default, but this option remains for use with --tradi&acirc;
<br>
tional.</p>

<p style="margin-top: 1em">-R <br>
--command file <br>
Dgawk only. Read stored debugger commands from file.</p>

<p style="margin-top: 1em">-S <br>
--sandbox <br>
Runs gawk in sandbox mode, disabling the system() function,
input redirection with getline, output redirection with
print and printf, and loading dynamic extensions. Com&acirc;
<br>
mand execution (through pipelines) is also disabled. This
effectively blocks a script from accessing local resources
(except for the files specified on the command line).</p>

<p style="margin-top: 1em">-t <br>
--lint-old <br>
Provide warnings about constructs that are not portable to
the original version of Unix awk.</p>

<p style="margin-top: 1em">-V <br>
--version <br>
Print version information for this particular copy of gawk
on the standard output. This is useful mainly for knowing if
the current copy of gawk on your system is up to <br>
date with respect to whatever the Free Software Foundation
is distributing. This is also useful when reporting bugs.
(Per the GNU Coding Standards, these options cause <br>
an immediate, successful exit.)</p>

<p style="margin-top: 1em">-- Signal the end of options.
This is useful to allow further arguments to the AWK program
itself to start with a &acirc;-&acirc;. This provides
consistency with the argument parsing <br>
convention used by most other POSIX programs.</p>

<p style="margin-top: 1em">In compatibility mode, any other
options are flagged as invalid, but are otherwise ignored.
In normal operation, as long as program text has been
supplied, unknown options are <br>
passed on to the AWK program in the ARGV array for
processing. This is particularly useful for running AWK
programs via the &acirc;#!&acirc; executable interpreter
mechanism.</p>

<p style="margin-top: 1em">AWK PROGRAM EXECUTION <br>
An AWK program consists of a sequence of pattern-action
statements and optional function definitions.</p>

<p style="margin-top: 1em">@include &quot;filename&quot;
pattern { action statements } <br>
function name(parameter list) { statements }</p>

<p style="margin-top: 1em">Gawk first reads the program
source from the program-file(s) if specified, from arguments
to --source, or from the first non-option argument on the
command line. The -f and <br>
--source options may be used multiple times on the command
line. Gawk reads the program text as if all the
program-files and command line source texts had been
concatenated <br>
together. This is useful for building libraries of AWK
functions, without having to include them in each new AWK
program that uses them. It also provides the ability to mix
<br>
library functions with command line programs.</p>

<p style="margin-top: 1em">In addition, lines beginning
with @include may be used to include other source files into
your program, making library use even easier.</p>

<p style="margin-top: 1em">The environment variable AWKPATH
specifies a search path to use when finding source files
named with the -f option. If this variable does not exist,
the default path is <br>
&quot;.:/usr/local/share/awk&quot;. (The actual directory
may vary, depending upon how gawk was built and installed.)
If a file name given to the -f option contains a
&acirc;/&acirc; character, no <br>
path search is performed.</p>

<p style="margin-top: 1em">Gawk executes AWK programs in
the following order. First, all variable assignments
specified via the -v option are performed. Next, gawk
compiles the program into an internal <br>
form. Then, gawk executes the code in the BEGIN block(s) (if
any), and then proceeds to read each file named in the ARGV
array (up to ARGV[ARGC]). If there are no files named <br>
on the command line, gawk reads the standard input.</p>

<p style="margin-top: 1em">If a filename on the command
line has the form var=val it is treated as a variable
assignment. The variable var will be assigned the value val.
(This happens after any BEGIN <br>
block(s) have been run.) Command line variable assignment is
most useful for dynamically assigning values to the
variables AWK uses to control how input is broken into
fields <br>
and records. It is also useful for controlling state if
multiple passes are needed over a single data file.</p>

<p style="margin-top: 1em">If the value of a particular
element of ARGV is empty (&quot;&quot;), gawk skips over
it.</p>

<p style="margin-top: 1em">For each input file, if a
BEGINFILE rule exists, gawk executes the associated code
before processing the contents of the file. Similarly, gawk
executes the code associated with <br>
ENDFILE after processing the file.</p>

<p style="margin-top: 1em">For each record in the input,
gawk tests to see if it matches any pattern in the AWK
program. For each pattern that the record matches, the
associated action is executed. The <br>
patterns are tested in the order they occur in the
program.</p>

<p style="margin-top: 1em">Finally, after all the input is
exhausted, gawk executes the code in the END block(s) (if
any).</p>

<p style="margin-top: 1em">Command Line Directories <br>
According to POSIX, files named on the awk command line must
be text files. The behavior is
&lsquo;&lsquo;undefined&rsquo;&rsquo; if they are not. Most
versions of awk treat a directory on the command <br>
line as a fatal error.</p>

<p style="margin-top: 1em">Starting with version 4.0 of
gawk, a directory on the command line produces a warning,
but is otherwise skipped. If either of the --posix or
--traditional options is given, then <br>
gawk reverts to treating directories on the command line as
a fatal error.</p>

<p style="margin-top: 1em">VARIABLES, RECORDS AND FIELDS
<br>
AWK variables are dynamic; they come into existence when
they are first used. Their values are either floating-point
numbers or strings, or both, depending upon how they are
<br>
used. AWK also has one dimensional arrays; arrays with
multiple dimensions may be simulated. Several pre-defined
variables are set as a program runs; these are described as
<br>
needed and summarized below.</p>

<p style="margin-top: 1em">Records <br>
Normally, records are separated by newline characters. You
can control how records are separated by assigning values to
the built-in variable RS. If RS is any single character,
<br>
that character separates records. Otherwise, RS is a regular
expression. Text in the input that matches this regular
expression separates the record. However, in compatibility
<br>
mode, only the first character of its string value is used
for separating records. If RS is set to the null string,
then records are separated by blank lines. When RS is set to
<br>
the null string, the newline character always acts as a
field separator, in addition to whatever value FS may
have.</p>

<p style="margin-top: 1em">Fields <br>
As each input record is read, gawk splits the record into
fields, using the value of the FS variable as the field
separator. If FS is a single character, fields are separated
by <br>
that character. If FS is the null string, then each
individual character becomes a separate field. Otherwise, FS
is expected to be a full regular expression. In the special
<br>
case that FS is a single space, fields are separated by runs
of spaces and/or tabs and/or newlines. (But see the section
POSIX COMPATIBILITY, below). NOTE: The value of
IGNORE&acirc; <br>
CASE (see below) also affects how fields are split when FS
is a regular expression, and how records are separated when
RS is a regular expression.</p>

<p style="margin-top: 1em">If the FIELDWIDTHS variable is
set to a space separated list of numbers, each field is
expected to have fixed width, and gawk splits up the record
using the specified widths. <br>
The value of FS is ignored. Assigning a new value to FS or
FPAT overrides the use of FIELDWIDTHS.</p>

<p style="margin-top: 1em">Similarly, if the FPAT variable
is set to a string representing a regular expression, each
field is made up of text that matches that regular
expression. In this case, the regu&acirc; <br>
lar expression describes the fields themselves, instead of
the text that separates the fields. Assigning a new value to
FS or FIELDWIDTHS overrides the use of FPAT.</p>

<p style="margin-top: 1em">Each field in the input record
may be referenced by its position, $1, $2, and so on. $0 is
the whole record. Fields need not be referenced by
constants:</p>

<p style="margin-top: 1em">n = 5 <br>
print $n</p>

<p style="margin-top: 1em">prints the fifth field in the
input record.</p>

<p style="margin-top: 1em">The variable NF is set to the
total number of fields in the input record.</p>

<p style="margin-top: 1em">References to non-existent
fields (i.e. fields after $NF) produce the null-string.
However, assigning to a non-existent field (e.g., $(NF+2) =
5) increases the value of NF, cre&acirc; <br>
ates any intervening fields with the null string as their
value, and causes the value of $0 to be recomputed, with the
fields being separated by the value of OFS. References to
<br>
negative numbered fields cause a fatal error. Decrementing
NF causes the values of fields past the new value to be
lost, and the value of $0 to be recomputed, with the fields
<br>
being separated by the value of OFS.</p>

<p style="margin-top: 1em">Assigning a value to an existing
field causes the whole record to be rebuilt when $0 is
referenced. Similarly, assigning a value to $0 causes the
record to be resplit, creating <br>
new values for the fields.</p>

<p style="margin-top: 1em">Built-in Variables <br>
Gawk&rsquo;s built-in variables are:</p>

<p style="margin-top: 1em">ARGC The number of command line
arguments (does not include options to gawk, or the program
source).</p>

<p style="margin-top: 1em">ARGIND The index in ARGV of the
current file being processed.</p>

<p style="margin-top: 1em">ARGV Array of command line
arguments. The array is indexed from 0 to ARGC - 1.
Dynamically changing the contents of ARGV can control the
files used for data.</p>

<p style="margin-top: 1em">BINMODE On non-POSIX systems,
specifies use of &acirc;binary&acirc; mode for all file I/O.
Numeric values of 1, 2, or 3, specify that input files,
output files, or all files, respec&acirc; <br>
tively, should use binary I/O. String values of
&quot;r&quot;, or &quot;w&quot; specify that input files, or
output files, respectively, should use binary I/O. String
values of &quot;rw&quot; or <br>
&quot;wr&quot; specify that all files should use binary I/O.
Any other string value is treated as &quot;rw&quot;, but
generates a warning message.</p>

<p style="margin-top: 1em">CONVFMT The conversion format
for numbers, &quot;%.6g&quot;, by default.</p>

<p style="margin-top: 1em">ENVIRON An array containing the
values of the current environment. The array is indexed by
the environment variables, each element being the value of
that variable (e.g., <br>
ENVIRON[&quot;HOME&quot;] might be /home/arnold). Changing
this array does not affect the environment seen by programs
which gawk spawns via redirection or the system()
func&acirc; <br>
tion.</p>

<p style="margin-top: 1em">ERRNO If a system error occurs
either doing a redirection for getline, during a read for
getline, or during a close(), then ERRNO will contain a
string describing the <br>
error. The value is subject to translation in non-English
locales.</p>

<p style="margin-top: 1em">FIELDWIDTHS A whitespace
separated list of field widths. When set, gawk parses the
input into fields of fixed width, instead of using the value
of the FS variable as the field <br>
separator. See Fields, above.</p>

<p style="margin-top: 1em">FILENAME The name of the current
input file. If no files are specified on the command line,
the value of FILENAME is &acirc;-&acirc;. However, FILENAME
is undefined inside the BEGIN <br>
block (unless set by getline).</p>

<p style="margin-top: 1em">FNR The input record number in
the current input file.</p>

<p style="margin-top: 1em">FPAT A regular expression
describing the contents of the fields in a record. When set,
gawk parses the input into fields, where the fields match
the regular expression, <br>
instead of using the value of the FS variable as the field
separator. See Fields, above.</p>

<p style="margin-top: 1em">FS The input field separator, a
space by default. See Fields, above.</p>

<p style="margin-top: 1em">IGNORECASE Controls the
case-sensitivity of all regular expression and string
operations. If IGNORECASE has a non-zero value, then string
comparisons and pattern matching in <br>
rules, field splitting with FS and FPAT, record separating
with RS, regular expression matching with ~ and !~, and the
gensub(), gsub(), index(), match(), patsplit(), <br>
split(), and sub() built-in functions all ignore case when
doing regular expression operations. NOTE: Array
subscripting is not affected. However, the asort() and <br>
asorti() functions are affected. <br>
Thus, if IGNORECASE is not equal to zero, /aB/ matches all
of the strings &quot;ab&quot;, &quot;aB&quot;,
&quot;Ab&quot;, and &quot;AB&quot;. As with all AWK
variables, the initial value of IGNORECASE is <br>
zero, so all regular expression and string operations are
normally case-sensitive.</p>

<p style="margin-top: 1em">LINT Provides dynamic control of
the --lint option from within an AWK program. When true,
gawk prints lint warnings. When false, it does not. When
assigned the string <br>
value &quot;fatal&quot;, lint warnings become fatal errors,
exactly like --lint=fatal. Any other true value just prints
warnings.</p>

<p style="margin-top: 1em">NF The number of fields in the
current input record.</p>

<p style="margin-top: 1em">NR The total number of input
records seen so far.</p>

<p style="margin-top: 1em">OFMT The output format for
numbers, &quot;%.6g&quot;, by default.</p>

<p style="margin-top: 1em">OFS The output field separator,
a space by default.</p>

<p style="margin-top: 1em">ORS The output record separator,
by default a newline.</p>

<p style="margin-top: 1em">PROCINFO The elements of this
array provide access to information about the running AWK
program. On some systems, there may be elements in the
array, &quot;group1&quot; through <br>
&quot;groupn&quot; for some n, which is the number of
supplementary groups that the process has. Use the in
operator to test for these elements. The following elements
are <br>
guaranteed to be available:</p>

<p style="margin-top: 1em">PROCINFO[&quot;egid&quot;] the
value of the getegid(2) system call.</p>

<p style="margin-top: 1em">PROCINFO[&quot;strftime&quot;]
<br>
The default time format string for strftime().</p>

<p style="margin-top: 1em">PROCINFO[&quot;euid&quot;] the
value of the geteuid(2) system call.</p>

<p style="margin-top: 1em">PROCINFO[&quot;FS&quot;]
&quot;FS&quot; if field splitting with FS is in effect,
&quot;FPAT&quot; if field splitting with FPAT is in effect,
or &quot;FIELDWIDTHS&quot; if field splitting with
FIELD&acirc; <br>
WIDTHS is in effect.</p>

<p style="margin-top: 1em">PROCINFO[&quot;gid&quot;] the
value of the getgid(2) system call.</p>

<p style="margin-top: 1em">PROCINFO[&quot;pgrpid&quot;] the
process group ID of the current process.</p>

<p style="margin-top: 1em">PROCINFO[&quot;pid&quot;] the
process ID of the current process.</p>

<p style="margin-top: 1em">PROCINFO[&quot;ppid&quot;] the
parent process ID of the current process.</p>

<p style="margin-top: 1em">PROCINFO[&quot;uid&quot;] the
value of the getuid(2) system call.</p>

<p style="margin-top: 1em">PROCINFO[&quot;sorted_in&quot;]
<br>
If this element exists in PROCINFO, then its value controls
the order in which array elements are traversed in for
loops. Supported values are <br>
&quot;@ind_str_asc&quot;, &quot;@ind_num_asc&quot;,
&quot;@val_type_asc&quot;, &quot;@val_str_asc&quot;,
&quot;@val_num_asc&quot;, &quot;@ind_str_desc&quot;,
&quot;@ind_num_desc&quot;, &quot;@val_type_desc&quot;, <br>
&quot;@val_str_desc&quot;, &quot;@val_num_desc&quot;, and
&quot;@unsorted&quot;. The value can also be the name of any
comparison function defined as follows:</p>

<p style="margin-top: 1em">function cmp_func(i1, v1, i2,
v2)</p>

<p style="margin-top: 1em">where i1 and i2 are the indices,
and v1 and v2 are the corresponding values of the two
elements being compared. It should return a number less
than, equal to, or <br>
greater than 0, depending on how the elements of the array
are to be ordered.</p>

<p style="margin-top: 1em">PROCINFO[&quot;version&quot;]
<br>
the version of gawk.</p>

<p style="margin-top: 1em">RS The input record separator,
by default a newline.</p>

<p style="margin-top: 1em">RT The record terminator. Gawk
sets RT to the input text that matched the character or
regular expression specified by RS.</p>

<p style="margin-top: 1em">RSTART The index of the first
character matched by match(); 0 if no match. (This implies
that character indices start at one.)</p>

<p style="margin-top: 1em">RLENGTH The length of the string
matched by match(); -1 if no match.</p>

<p style="margin-top: 1em">SUBSEP The character used to
separate multiple subscripts in array elements, by default
&quot; 34&quot;.</p>

<p style="margin-top: 1em">TEXTDOMAIN The text domain of
the AWK program; used to find the localized translations for
the program&rsquo;s strings.</p>

<p style="margin-top: 1em">Arrays <br>
Arrays are subscripted with an expression between square
brackets ([ and ]). If the expression is an expression list
(expr, expr ...) then the array subscript is a string
con&acirc; <br>
sisting of the concatenation of the (string) value of each
expression, separated by the value of the SUBSEP variable.
This facility is used to simulate multiply dimensioned <br>
arrays. For example:</p>

<p style="margin-top: 1em">i = &quot;A&quot;; j =
&quot;B&quot;; k = &quot;C&quot; <br>
x[i, j, k] = &quot;hello, world0</p>

<p style="margin-top: 1em">assigns the string &quot;hello,
world0 to the element of the array x which is indexed by the
string &quot;A 34B 34C&quot;. All arrays in AWK are
associative, i.e. indexed by string values.</p>

<p style="margin-top: 1em">The special operator in may be
used to test if an array has an index consisting of a
particular value:</p>

<p style="margin-top: 1em">if (val in array) <br>
print array[val]</p>

<p style="margin-top: 1em">If the array has multiple
subscripts, use (i, j) in array.</p>

<p style="margin-top: 1em">The in construct may also be
used in a for loop to iterate over all the elements of an
array.</p>

<p style="margin-top: 1em">An element may be deleted from
an array using the delete statement. The delete statement
may also be used to delete the entire contents of an array,
just by specifying the array <br>
name without a subscript.</p>

<p style="margin-top: 1em">gawk supports true
multidimensional arrays. It does not require that such
arrays be &lsquo;&lsquo;rectangular&rsquo;&rsquo; as in C or
C++. For example: <br>
a[1] = 5 <br>
a[2][1] = 6 <br>
a[2][2] = 7</p>

<p style="margin-top: 1em">Variable Typing And Conversion
<br>
Variables and fields may be (floating point) numbers, or
strings, or both. How the value of a variable is interpreted
depends upon its context. If used in a numeric expression,
<br>
it will be treated as a number; if used as a string it will
be treated as a string.</p>

<p style="margin-top: 1em">To force a variable to be
treated as a number, add 0 to it; to force it to be treated
as a string, concatenate it with the null string.</p>

<p style="margin-top: 1em">When a string must be converted
to a number, the conversion is accomplished using strtod(3).
A number is converted to a string by using the value of
CONVFMT as a format string <br>
for sprintf(3), with the numeric value of the variable as
the argument. However, even though all numbers in AWK are
floating-point, integral values are always converted as
inte&acirc; <br>
gers. Thus, given</p>

<p style="margin-top: 1em">CONVFMT = &quot;%2.2f&quot; <br>
a = 12 <br>
b = a &quot;&quot;</p>

<p style="margin-top: 1em">the variable b has a string
value of &quot;12&quot; and not &quot;12.00&quot;.</p>

<p style="margin-top: 1em">NOTE: When operating in POSIX
mode (such as with the --posix command line option), beware
that locale settings may interfere with the way decimal
numbers are treated: the decimal <br>
separator of the numbers you are feeding to gawk must
conform to what your locale would expect, be it a comma (,)
or a period (.).</p>

<p style="margin-top: 1em">Gawk performs comparisons as
follows: If two variables are numeric, they are compared
numerically. If one value is numeric and the other has a
string value that is a &acirc;numeric <br>
string,&acirc; then comparisons are also done numerically.
Otherwise, the numeric value is converted to a string and a
string comparison is performed. Two strings are compared, of
<br>
course, as strings.</p>

<p style="margin-top: 1em">Note that string constants, such
as &quot;57&quot;, are not numeric strings, they are string
constants. The idea of &acirc;numeric string&acirc; only
applies to fields, getline input, FILENAME, ARGV <br>
elements, ENVIRON elements and the elements of an array
created by split() or patsplit() that are numeric strings.
The basic idea is that user input, and only user input, that
<br>
looks numeric, should be treated that way.</p>

<p style="margin-top: 1em">Uninitialized variables have the
numeric value 0 and the string value &quot;&quot; (the null,
or empty, string).</p>

<p style="margin-top: 1em">Octal and Hexadecimal Constants
<br>
You may use C-style octal and hexadecimal constants in your
AWK program source code. For example, the octal value 011 is
equal to decimal 9, and the hexadecimal value 0x11 is <br>
equal to decimal 17.</p>

<p style="margin-top: 1em">String Constants <br>
String constants in AWK are sequences of characters enclosed
between double quotes (like &quot;value&quot;). Within
strings, certain escape sequences are recognized, as in C.
These are:</p>

<p style="margin-top: 1em">\ A literal backslash.</p>

<p style="margin-top: 1em">The &acirc;alert&acirc;
character; usually the ASCII BEL character.</p>

<p style="margin-top: 1em">backspace.</p>

<p style="margin-top: 1em">form-feed.</p>

<p style="margin-top: 1em">newline.</p>

<p style="margin-top: 1em">carriage return.</p>

<p style="margin-top: 1em">horizontal tab.</p>

<p style="margin-top: 1em">vertical tab.</p>

<p style="margin-top: 1em">x digits <br>
The character represented by the string of hexadecimal
digits following the As in ANSI C, all following hexadecimal
digits are considered part of the escape sequence. <br>
(This feature should tell us something about language design
by committee.) E.g., &quot;B&quot; is the ASCII ESC (escape)
character.</p>

<p style="margin-top: 1em">dd The character represented by
the 1-, 2-, or 3-digit sequence of octal digits. E.g.,
&quot; 33&quot; is the ASCII ESC (escape) character.</p>

<p style="margin-top: 1em">The escape sequences may also be
used inside constant regular expressions (e.g., /[ rmatches
whitespace characters).</p>

<p style="margin-top: 1em">In compatibility mode, the
characters represented by octal and hexadecimal escape
sequences are treated literally when used in regular
expression constants. Thus, /a52b/ is <br>
equivalent to /a/.</p>

<p style="margin-top: 1em">PATTERNS AND ACTIONS <br>
AWK is a line-oriented language. The pattern comes first,
and then the action. Action statements are enclosed in { and
}. Either the pattern may be missing, or the action may <br>
be missing, but, of course, not both. If the pattern is
missing, the action is executed for every single record of
input. A missing action is equivalent to</p>

<p style="margin-top: 1em">{ print }</p>

<p style="margin-top: 1em">which prints the entire
record.</p>

<p style="margin-top: 1em">Comments begin with the #
character, and continue until the end of the line. Blank
lines may be used to separate statements. Normally, a
statement ends with a newline, however, <br>
this is not the case for lines ending in a comma, {, ?, :,
&amp;&amp;, or ||. Lines ending in do or else also have
their statements automatically continued on the following
line. In <br>
other cases, a line can be continued by ending it with a
&acirc;&acirc;, in which case the newline is ignored.</p>

<p style="margin-top: 1em">Multiple statements may be put
on one line by separating them with a &acirc;;&acirc;. This
applies to both the statements within the action part of a
pattern-action pair (the usual case), <br>
and to the pattern-action statements themselves.</p>

<p style="margin-top: 1em">Patterns <br>
AWK patterns may be one of the following:</p>

<p style="margin-top: 1em">BEGIN <br>
END <br>
BEGINFILE <br>
ENDFILE <br>
/regular expression/ <br>
relational expression <br>
pattern &amp;&amp; pattern <br>
pattern || pattern <br>
pattern ? pattern : pattern <br>
(pattern) <br>
! pattern <br>
pattern1, pattern2</p>

<p style="margin-top: 1em">BEGIN and END are two special
kinds of patterns which are not tested against the input.
The action parts of all BEGIN patterns are merged as if all
the statements had been writ&acirc; <br>
ten in a single BEGIN block. They are executed before any of
the input is read. Similarly, all the END blocks are merged,
and executed when all the input is exhausted (or when <br>
an exit statement is executed). BEGIN and END patterns
cannot be combined with other patterns in pattern
expressions. BEGIN and END patterns cannot have missing
action parts.</p>

<p style="margin-top: 1em">BEGINFILE and ENDFILE are
additional special patterns whose bodies are executed before
reading the first record of each command line input file and
after reading the last record <br>
of each file. Inside the BEGINFILE rule, the value of ERRNO
will be the empty string if the file could be opened
successfully. Otherwise, there is some problem with the file
<br>
and the code should use nextfile to skip it. If that is not
done, gawk produces its usual fatal error for files that
cannot be opened.</p>

<p style="margin-top: 1em">For /regular expression/
patterns, the associated statement is executed for each
input record that matches the regular expression. Regular
expressions are the same as those in <br>
egrep(1), and are summarized below.</p>

<p style="margin-top: 1em">A relational expression may use
any of the operators defined below in the section on
actions. These generally test whether certain fields match
certain regular expressions.</p>

<p style="margin-top: 1em">The &amp;&amp;, ||, and !
operators are logical AND, logical OR, and logical NOT,
respectively, as in C. They do short-circuit evaluation,
also as in C, and are used for combining more <br>
primitive pattern expressions. As in most languages,
parentheses may be used to change the order of
evaluation.</p>

<p style="margin-top: 1em">The ?: operator is like the same
operator in C. If the first pattern is true then the pattern
used for testing is the second pattern, otherwise it is the
third. Only one of the <br>
second and third patterns is evaluated.</p>

<p style="margin-top: 1em">The pattern1, pattern2 form of
an expression is called a range pattern. It matches all
input records starting with a record that matches pattern1,
and continuing until a record <br>
that matches pattern2, inclusive. It does not combine with
any other sort of pattern expression.</p>

<p style="margin-top: 1em">Regular Expressions <br>
Regular expressions are the extended kind found in egrep.
They are composed of characters as follows:</p>

<p style="margin-top: 1em">c matches the non-metacharacter
c.</p>

<p style="margin-top: 1em">. matches any character
including newline.</p>

<p style="margin-top: 1em">^ matches the beginning of a
string.</p>

<p style="margin-top: 1em">$ matches the end of a
string.</p>

<p style="margin-top: 1em">[abc...] character list, matches
any of the characters abc....</p>

<p style="margin-top: 1em">[^abc...] negated character
list, matches any character except abc....</p>

<p style="margin-top: 1em">r1|r2 alternation: matches
either r1 or r2.</p>

<p style="margin-top: 1em">r1r2 concatenation: matches r1,
and then r2.</p>

<p style="margin-top: 1em">r+ matches one or more
r&rsquo;s.</p>

<p style="margin-top: 1em">r* matches zero or more
r&rsquo;s.</p>

<p style="margin-top: 1em">r? matches zero or one
r&rsquo;s.</p>

<p style="margin-top: 1em">(r) grouping: matches r.</p>

<p style="margin-top: 1em">r{n} <br>
r{n,} <br>
r{n,m} One or two numbers inside braces denote an interval
expression. If there is one number in the braces, the
preceding regular expression r is repeated n times. If <br>
there are two numbers separated by a comma, r is repeated n
to m times. If there is one number followed by a comma, then
r is repeated at least n times.</p>

<p style="margin-top: 1em">y matches the empty string at
either the beginning or the end of a word.</p>

<p style="margin-top: 1em">0 matches the empty string
within a word.</p>

<p style="margin-top: 1em">&lt; matches the empty string at
the beginning of a word.</p>

<p style="margin-top: 1em">&gt; matches the empty string at
the end of a word.</p>

<p style="margin-top: 1em">matches any whitespace
character.</p>

<p style="margin-top: 1em">matches any nonwhitespace
character.</p>

<p style="margin-top: 1em">0 matches any word-constituent
character (letter, digit, or underscore).</p>

<p style="margin-top: 1em">W matches any character that is
not word-constituent.</p>

<p style="margin-top: 1em">` matches the empty string at
the beginning of a buffer (string).</p>

<p style="margin-top: 1em">&acute; matches the empty string
at the end of a buffer.</p>

<p style="margin-top: 1em">The escape sequences that are
valid in string constants (see below) are also valid in
regular expressions.</p>

<p style="margin-top: 1em">Character classes are a feature
introduced in the POSIX standard. A character class is a
special notation for describing lists of characters that
have a specific attribute, but <br>
where the actual characters themselves can vary from country
to country and/or from character set to character set. For
example, the notion of what is an alphabetic character <br>
differs in the USA and in France.</p>

<p style="margin-top: 1em">A character class is only valid
in a regular expression inside the brackets of a character
list. Character classes consist of [:, a keyword denoting
the class, and :]. The <br>
character classes defined by the POSIX standard are:</p>

<p style="margin-top: 1em">[:alnum:] Alphanumeric
characters.</p>

<p style="margin-top: 1em">[:alpha:] Alphabetic
characters.</p>

<p style="margin-top: 1em">[:blank:] Space or tab
characters.</p>

<p style="margin-top: 1em">[:cntrl:] Control
characters.</p>

<p style="margin-top: 1em">[:digit:] Numeric
characters.</p>

<p style="margin-top: 1em">[:graph:] Characters that are
both printable and visible. (A space is printable, but not
visible, while an a is both.)</p>

<p style="margin-top: 1em">[:lower:] Lowercase alphabetic
characters.</p>

<p style="margin-top: 1em">[:print:] Printable characters
(characters that are not control characters.)</p>

<p style="margin-top: 1em">[:punct:] Punctuation characters
(characters that are not letter, digits, control characters,
or space characters).</p>

<p style="margin-top: 1em">[:space:] Space characters (such
as space, tab, and formfeed, to name a few).</p>

<p style="margin-top: 1em">[:upper:] Uppercase alphabetic
characters.</p>

<p style="margin-top: 1em">[:xdigit:] Characters that are
hexadecimal digits.</p>

<p style="margin-top: 1em">For example, before the POSIX
standard, to match alphanumeric characters, you would have
had to write /[A-Za-z0-9]/. If your character set had other
alphabetic characters in it, <br>
this would not match them, and if your character set
collated differently from ASCII, this might not even match
the ASCII alphanumeric characters. With the POSIX character
<br>
classes, you can write /[[:alnum:]]/, and this matches the
alphabetic and numeric characters in your character set, no
matter what it is.</p>

<p style="margin-top: 1em">Two additional special sequences
can appear in character lists. These apply to non-ASCII
character sets, which can have single symbols (called
collating elements) that are rep&acirc; <br>
resented with more than one character, as well as several
characters that are equivalent for collating, or sorting,
purposes. (E.g., in French, a plain &acirc;e&acirc; and a
grave-accented <br>
&acirc;&lsquo;&acirc; are equivalent.)</p>

<p style="margin-top: 1em">Collating Symbols <br>
A collating symbol is a multi-character collating element
enclosed in [. and .]. For example, if ch is a collating
element, then [[.ch.]] is a regular expression that <br>
matches this collating element, while [ch] is a regular
expression that matches either c or h.</p>

<p style="margin-top: 1em">Equivalence Classes <br>
An equivalence class is a locale-specific name for a list of
characters that are equivalent. The name is enclosed in [=
and =]. For example, the name e might be used to <br>
represent all of &acirc;e,&acirc;
&acirc;&Acirc;&acute;,&acirc; and &acirc;&lsquo;.&acirc; In
this case, [[=e=]] is a regular expression that matches any
of e, &Acirc;&acute;, or &lsquo;.</p>

<p style="margin-top: 1em">These features are very valuable
in non-English speaking locales. The library functions that
gawk uses for regular expression matching currently only
recognize POSIX character <br>
classes; they do not recognize collating symbols or
equivalence classes.</p>

<p style="margin-top: 1em">The y, 0 &gt;, , and &acute;
operators are specific to gawk; they are extensions based on
facilities in the GNU regular expression libraries.</p>

<p style="margin-top: 1em">The various command line options
control how gawk interprets characters in regular
expressions.</p>

<p style="margin-top: 1em">No options <br>
In the default case, gawk provide all the facilities of
POSIX regular expressions and the GNU regular expression
operators described above.</p>

<p style="margin-top: 1em">--posix <br>
Only POSIX regular expressions are supported, the GNU
operators are not special. (E.g., 168a literal w).</p>

<p style="margin-top: 1em">--traditional <br>
Traditional Unix awk regular expressions are matched. The
GNU operators are not special, and interval expressions are
not available. Characters described by octal and <br>
hexadecimal escape sequences are treated literally, even if
they represent regular expression metacharacters.</p>

<p style="margin-top: 1em">--re-interval <br>
Allow interval expressions in regular expressions, even if
--traditional has been provided.</p>

<p style="margin-top: 1em">Actions <br>
Action statements are enclosed in braces, { and }. Action
statements consist of the usual assignment, conditional, and
looping statements found in most languages. The opera&acirc;
<br>
tors, control statements, and input/output statements
available are patterned after those in C.</p>

<p style="margin-top: 1em">Operators <br>
The operators in AWK, in order of decreasing precedence,
are</p>

<p style="margin-top: 1em">(...) Grouping</p>

<p style="margin-top: 1em">$ Field reference.</p>

<p style="margin-top: 1em">++ -- Increment and decrement,
both prefix and postfix.</p>

<p style="margin-top: 1em">^ Exponentiation (** may also be
used, and **= for the assignment operator).</p>

<p style="margin-top: 1em">+ - ! Unary plus, unary minus,
and logical negation.</p>

<p style="margin-top: 1em">* / % Multiplication, division,
and modulus.</p>

<p style="margin-top: 1em">+ - Addition and
subtraction.</p>

<p style="margin-top: 1em">space String concatenation.</p>

<p style="margin-top: 1em">| |&amp; Piped I/O for getline,
print, and printf.</p>

<p style="margin-top: 1em">&lt; &gt; &lt;= &gt;= != == <br>
The regular relational operators.</p>

<p style="margin-top: 1em">~ !~ Regular expression match,
negated match. NOTE: Do not use a constant regular
expression (/foo/) on the left-hand side of a ~ or !~. Only
use one on the right-hand <br>
side. The expression /foo/ ~ exp has the same meaning as
(($0 ~ /foo/) ~ exp). This is usually not what was
intended.</p>

<p style="margin-top: 1em">in Array membership.</p>

<p style="margin-top: 1em">&amp;&amp; Logical AND.</p>

<p style="margin-top: 1em">|| Logical OR.</p>

<p style="margin-top: 1em">?: The C conditional expression.
This has the form expr1 ? expr2 : expr3. If expr1 is true,
the value of the expression is expr2, otherwise it is expr3.
Only one of <br>
expr2 and expr3 is evaluated.</p>

<p style="margin-top: 1em">= += -= *= /= %= ^= <br>
Assignment. Both absolute assignment (var = value) and
operator-assignment (the other forms) are supported.</p>

<p style="margin-top: 1em">Control Statements <br>
The control statements are as follows:</p>

<p style="margin-top: 1em">if (condition) statement [ else
statement ] <br>
while (condition) statement <br>
do statement while (condition) <br>
for (expr1; expr2; expr3) statement <br>
for (var in array) statement <br>
break <br>
continue <br>
delete array[index] <br>
delete array <br>
exit [ expression ] <br>
{ statements } <br>
switch (expression) { <br>
case value|regex : statement <br>
... <br>
[ default: statement ] <br>
}</p>

<p style="margin-top: 1em">I/O Statements <br>
The input/output statements are as follows:</p>

<p style="margin-top: 1em">close(file [, how]) Close file,
pipe or co-process. The optional how should only be used
when closing one end of a two-way pipe to a co-process. It
must be a string value, <br>
either &quot;to&quot; or &quot;from&quot;.</p>

<p style="margin-top: 1em">getline Set $0 from next input
record; set NF, NR, FNR.</p>

<p style="margin-top: 1em">getline &lt;file Set $0 from
next record of file; set NF.</p>

<p style="margin-top: 1em">getline var Set var from next
input record; set NR, FNR.</p>

<p style="margin-top: 1em">getline var &lt;file Set var
from next record of file.</p>

<p style="margin-top: 1em">command | getline [var] <br>
Run command piping the output either into $0 or var, as
above.</p>

<p style="margin-top: 1em">command |&amp; getline [var]
<br>
Run command as a co-process piping the output either into $0
or var, as above. Co-processes are a gawk extension.
(command can also be a socket. See the <br>
subsection Special File Names, below.)</p>

<p style="margin-top: 1em">next Stop processing the current
input record. The next input record is read and processing
starts over with the first pattern in the AWK program. If
the end <br>
of the input data is reached, the END block(s), if any, are
executed.</p>

<p style="margin-top: 1em">nextfile Stop processing the
current input file. The next input record read comes from
the next input file. FILENAME and ARGIND are updated, FNR is
reset to 1, and <br>
processing starts over with the first pattern in the AWK
program. If the end of the input data is reached, the END
block(s), if any, are executed.</p>

<p style="margin-top: 1em">print Print the current record.
The output record is terminated with the value of the ORS
variable.</p>

<p style="margin-top: 1em">print expr-list Print
expressions. Each expression is separated by the value of
the OFS variable. The output record is terminated with the
value of the ORS variable.</p>

<p style="margin-top: 1em">print expr-list &gt;file Print
expressions on file. Each expression is separated by the
value of the OFS variable. The output record is terminated
with the value of the ORS vari&acirc; <br>
able.</p>

<p style="margin-top: 1em">printf fmt, expr-list Format and
print. See The printf Statement, below.</p>

<p style="margin-top: 1em">printf fmt, expr-list &gt;file
<br>
Format and print on file.</p>

<p style="margin-top: 1em">system(cmd-line) Execute the
command cmd-line, and return the exit status. (This may not
be available on non-POSIX systems.)</p>

<p style="margin-top: 1em">fflush([file]) Flush any buffers
associated with the open output file or pipe file. If file
is missing or if it is the null string, then flush all open
output files and <br>
pipes.</p>

<p style="margin-top: 1em">Additional output redirections
are allowed for print and printf.</p>

<p style="margin-top: 1em">print ... &gt;&gt; file <br>
Appends output to the file.</p>

<p style="margin-top: 1em">print ... | command <br>
Writes on a pipe.</p>

<p style="margin-top: 1em">print ... |&amp; command <br>
Sends data to a co-process or socket. (See also the
subsection Special File Names, below.)</p>

<p style="margin-top: 1em">The getline command returns 1 on
success, 0 on end of file, and -1 on an error. Upon an
error, ERRNO contains a string describing the problem.</p>

<p style="margin-top: 1em">NOTE: Failure in opening a
two-way socket will result in a non-fatal error being
returned to the calling function. If using a pipe,
co-process, or socket to getline, or from <br>
print or printf within a loop, you must use close() to
create new instances of the command or socket. AWK does not
automatically close pipes, sockets, or co-processes when
they <br>
return EOF.</p>

<p style="margin-top: 1em">The printf Statement <br>
The AWK versions of the printf statement and sprintf()
function (see below) accept the following conversion
specification formats:</p>

<p style="margin-top: 1em">%c A single character. If the
argument used for %c is numeric, it is treated as a
character and printed. Otherwise, the argument is assumed to
be a string, and the only <br>
first character of that string is printed.</p>

<p style="margin-top: 1em">%d, %i A decimal number (the
integer part).</p>

<p style="margin-top: 1em">%e, %E A floating point number
of the form [-]d.dddddde[+-]dd. The %E format uses E instead
of e.</p>

<p style="margin-top: 1em">%f, %F A floating point number
of the form [-]ddd.dddddd. If the system library supports
it, %F is available as well. This is like %f, but uses
capital letters for special &acirc;not <br>
a number&acirc; and &acirc;infinity&acirc; values. If %F is
not available, gawk uses %f.</p>

<p style="margin-top: 1em">%g, %G Use %e or %f conversion,
whichever is shorter, with nonsignificant zeros suppressed.
The %G format uses %E instead of %e.</p>

<p style="margin-top: 1em">%o An unsigned octal number
(also an integer).</p>

<p style="margin-top: 1em">%u An unsigned decimal number
(again, an integer).</p>

<p style="margin-top: 1em">%s A character string.</p>

<p style="margin-top: 1em">%x, %X An unsigned hexadecimal
number (an integer). The %X format uses ABCDEF instead of
abcdef.</p>

<p style="margin-top: 1em">%% A single % character; no
argument is converted.</p>

<p style="margin-top: 1em">Optional, additional parameters
may lie between the % and the control letter:</p>

<p style="margin-top: 1em">count$ Use the count&rsquo;th
argument at this point in the formatting. This is called a
positional specifier and is intended primarily for use in
translated versions of format <br>
strings, not in the original text of an AWK program. It is a
gawk extension.</p>

<p style="margin-top: 1em">- The expression should be
left-justified within its field.</p>

<p style="margin-top: 1em">space For numeric conversions,
prefix positive values with a space, and negative values
with a minus sign.</p>

<p style="margin-top: 1em">+ The plus sign, used before the
width modifier (see below), says to always supply a sign for
numeric conversions, even if the data to be formatted is
positive. The + over&acirc; <br>
rides the space modifier.</p>

<p style="margin-top: 1em"># Use an &acirc;alternate
form&acirc; for certain control letters. For %o, supply a
leading zero. For %x, and %X, supply a leading 0x or 0X for
a nonzero result. For %e, %E, %f and <br>
%F, the result always contains a decimal point. For %g, and
%G, trailing zeros are not removed from the result.</p>

<p style="margin-top: 1em">0 A leading 0 (zero) acts as a
flag, that indicates output should be padded with zeroes
instead of spaces. This applies only to the numeric output
formats. This flag only <br>
has an effect when the field width is wider than the value
to be printed.</p>

<p style="margin-top: 1em">width The field should be padded
to this width. The field is normally padded with spaces. If
the 0 flag has been used, it is padded with zeroes.</p>

<p style="margin-top: 1em">.prec A number that specifies
the precision to use when printing. For the %e, %E, %f and
%F, formats, this specifies the number of digits you want
printed to the right of the <br>
decimal point. For the %g, and %G formats, it specifies the
maximum number of significant digits. For the %d, %i, %o,
%u, %x, and %X formats, it specifies the minimum <br>
number of digits to print. For %s, it specifies the maximum
number of characters from the string that should be
printed.</p>

<p style="margin-top: 1em">The dynamic width and prec
capabilities of the ANSI C printf() routines are supported.
A * in place of either the width or prec specifications
causes their values to be taken <br>
from the argument list to printf or sprintf(). To use a
positional specifier with a dynamic width or precision,
supply the count$ after the * in the format string. For
example, <br>
&quot;%3$*2$.*1$s&quot;.</p>

<p style="margin-top: 1em">Special File Names <br>
When doing I/O redirection from either print or printf into
a file, or via getline from a file, gawk recognizes certain
special filenames internally. These filenames allow <br>
access to open file descriptors inherited from gawk&rsquo;s
parent process (usually the shell). These file names may
also be used on the command line to name data files. The
file&acirc; <br>
names are:</p>

<p style="margin-top: 1em">/dev/stdin The standard
input.</p>

<p style="margin-top: 1em">/dev/stdout The standard
output.</p>

<p style="margin-top: 1em">/dev/stderr The standard error
output.</p>

<p style="margin-top: 1em">/dev/fd/n The file associated
with the open file descriptor n.</p>

<p style="margin-top: 1em">These are particularly useful
for error messages. For example:</p>

<p style="margin-top: 1em">print &quot;You blew it!&quot;
&gt; &quot;/dev/stderr&quot;</p>

<p style="margin-top: 1em">whereas you would otherwise have
to use</p>

<p style="margin-top: 1em">print &quot;You blew it!&quot; |
&quot;cat 1&gt;&amp;2&quot;</p>

<p style="margin-top: 1em">The following special filenames
may be used with the |&amp; co-process operator for creating
TCP/IP network connections:</p>

<p style="margin-top: 1em">/inet/tcp/lport/rhost/rport <br>
/inet4/tcp/lport/rhost/rport <br>
/inet6/tcp/lport/rhost/rport <br>
Files for a TCP/IP connection on local port lport to remote
host rhost on remote port rport. Use a port of 0 to have the
system pick a port. Use /inet4 to force an IPv4 <br>
connection, and /inet6 to force an IPv6 connection. Plain
/inet uses the system default (most likely IPv4).</p>

<p style="margin-top: 1em">/inet/udp/lport/rhost/rport <br>
/inet4/udp/lport/rhost/rport <br>
/inet6/udp/lport/rhost/rport <br>
Similar, but use UDP/IP instead of TCP/IP.</p>

<p style="margin-top: 1em">Numeric Functions <br>
AWK has the following built-in arithmetic functions:</p>

<p style="margin-top: 1em">atan2(y, x) Return the
arctangent of y/x in radians.</p>

<p style="margin-top: 1em">cos(expr) Return the cosine of
expr, which is in radians.</p>

<p style="margin-top: 1em">exp(expr) The exponential
function.</p>

<p style="margin-top: 1em">int(expr) Truncate to
integer.</p>

<p style="margin-top: 1em">log(expr) The natural logarithm
function.</p>

<p style="margin-top: 1em">rand() Return a random number N,
between 0 and 1, such that 0 &acirc;&curren; N &lt; 1.</p>

<p style="margin-top: 1em">sin(expr) Return the sine of
expr, which is in radians.</p>

<p style="margin-top: 1em">sqrt(expr) The square root
function.</p>

<p style="margin-top: 1em">srand([expr]) Use expr as the
new seed for the random number generator. If no expr is
provided, use the time of day. The return value is the
previous seed for the random number <br>
generator.</p>

<p style="margin-top: 1em">String Functions <br>
Gawk has the following built-in string functions:</p>

<p style="margin-top: 1em">asort(s [, d [, how] ]) Return
the number of elements in the source array s. Sort the
contents of s using gawk&rsquo;s normal rules for comparing
values, and replace the indices of <br>
the sorted values s with sequential integers starting with
1. If the optional destination array d is specified, then
first duplicate s into d, and then <br>
sort d, leaving the indices of the source array s unchanged.
The optional string how controls the direction and the
comparison mode. Valid values for how <br>
are any of the strings valid for
PROCINFO[&quot;sorted_in&quot;]. It can also be the name of
a user-defined comparison function as described in <br>
PROCINFO[&quot;sorted_in&quot;].</p>

<p style="margin-top: 1em">asorti(s [, d [, how] ]) <br>
Return the number of elements in the source array s. The
behavior is the same as that of asort(), except that the
array indices are used for sorting, not <br>
the array values. When done, the array is indexed
numerically, and the values are those of the original
indices. The original values are lost; thus pro&acirc; <br>
vide a second array if you wish to preserve the original.
The purpose of the optional string how is the same as
described in asort() above.</p>

<p style="margin-top: 1em">gensub(r, s, h [, t]) Search the
target string t for matches of the regular expression r. If
h is a string beginning with g or G, then replace all
matches of r with s. Other&acirc; <br>
wise, h is a number indicating which match of r to replace.
If t is not supplied, use $0 instead. Within the replacement
text s, the sequence 0 where <br>
n is a digit from 1 to 9, may be used to indicate just the
text that matched the n&rsquo;th parenthesized
subexpression. The sequence represents the entire <br>
matched text, as does the character &amp;. Unlike sub() and
gsub(), the modified string is returned as the result of the
function, and the original target <br>
string is not changed.</p>

<p style="margin-top: 1em">gsub(r, s [, t]) For each
substring matching the regular expression r in the string t,
substitute the string s, and return the number of
substitutions. If t is not sup&acirc; <br>
plied, use $0. An &amp; in the replacement text is replaced
with the text that was actually matched. Use to get a
literal &amp;. (This must be typed as <br>
&quot;\&amp;&quot;; see GAWK: Effective AWK Programming for
a fuller discussion of the rules for &amp;&rsquo;s and
backslashes in the replacement text of sub(), gsub(), and
gen&acirc; <br>
sub().)</p>

<p style="margin-top: 1em">index(s, t) Return the index of
the string t in the string s, or 0 if t is not present.
(This implies that character indices start at one.)</p>

<p style="margin-top: 1em">length([s]) Return the length of
the string s, or the length of $0 if s is not supplied. As a
non-standard extension, with an array argument, length()
returns the <br>
number of elements in the array.</p>

<p style="margin-top: 1em">match(s, r [, a]) Return the
position in s where the regular expression r occurs, or 0 if
r is not present, and set the values of RSTART and RLENGTH.
Note that the argu&acirc; <br>
ment order is the same as for the ~ operator: str ~ re. If
array a is provided, a is cleared and then elements 1
through n are filled with the portions <br>
of s that match the corresponding parenthesized
subexpression in r. The 0&rsquo;th element of a contains the
portion of s matched by the entire regular expres&acirc;
<br>
sion r. Subscripts a[n, &quot;start&quot;], and a[n,
&quot;length&quot;] provide the starting index in the string
and length respectively, of each matching substring.</p>

<p style="margin-top: 1em">patsplit(s, a [, r [, seps] ])
<br>
Split the string s into the array a and the separators array
seps on the regular expression r, and return the number of
fields. Element values are the <br>
portions of s that matched r. The value of seps[i] is the
separator that appeared in front of a[i+1]. If r is omitted,
FPAT is used instead. The arrays <br>
a and seps are cleared first. Splitting behaves identically
to field splitting with FPAT, described above.</p>

<p style="margin-top: 1em">split(s, a [, r [, seps] ]) <br>
Split the string s into the array a and the separators array
seps on the regular expression r, and return the number of
fields. If r is omitted, FS is <br>
used instead. The arrays a and seps are cleared first.
seps[i] is the field separator matched by r between a[i] and
a[i+1]. If r is a single space, <br>
then leading whitespace in s goes into the extra array
element seps[0] and trailing whitespace goes into the extra
array element seps[n], where n is the <br>
return value of split(s, a, r, seps). Splitting behaves
identically to field splitting, described above.</p>

<p style="margin-top: 1em">sprintf(fmt, expr-list) Prints
expr-list according to fmt, and returns the resulting
string.</p>

<p style="margin-top: 1em">strtonum(str) Examine str, and
return its numeric value. If str begins with a leading 0,
strtonum() assumes that str is an octal number. If str
begins with a leading <br>
0x or 0X, strtonum() assumes that str is a hexadecimal
number. Otherwise, decimal is assumed.</p>

<p style="margin-top: 1em">sub(r, s [, t]) Just like
gsub(), but replace only the first matching substring.</p>

<p style="margin-top: 1em">substr(s, i [, n]) Return the at
most n-character substring of s starting at i. If n is
omitted, use the rest of s.</p>

<p style="margin-top: 1em">tolower(str) Return a copy of
the string str, with all the uppercase characters in str
translated to their corresponding lowercase counterparts.
Non-alphabetic char&acirc; <br>
acters are left unchanged.</p>

<p style="margin-top: 1em">toupper(str) Return a copy of
the string str, with all the lowercase characters in str
translated to their corresponding uppercase counterparts.
Non-alphabetic char&acirc; <br>
acters are left unchanged.</p>

<p style="margin-top: 1em">Gawk is multibyte aware. This
means that index(), length(), substr() and match() all work
in terms of characters, not bytes.</p>

<p style="margin-top: 1em">Time Functions <br>
Since one of the primary uses of AWK programs is processing
log files that contain time stamp information, gawk provides
the following functions for obtaining time stamps and <br>
formatting them.</p>

<p style="margin-top: 1em">mktime(datespec) <br>
Turn datespec into a time stamp of the same form as returned
by systime(), and return the result. The datespec is a
string of the form YYYY MM DD HH MM SS[ DST]. The <br>
contents of the string are six or seven numbers representing
respectively the full year including century, the month from
1 to 12, the day of the month from 1 to 31, <br>
the hour of the day from 0 to 23, the minute from 0 to 59,
the second from 0 to 60, and an optional daylight saving
flag. The values of these numbers need not be <br>
within the ranges specified; for example, an hour of -1
means 1 hour before midnight. The origin-zero Gregorian
calendar is assumed, with year 0 preceding year 1 and <br>
year -1 preceding year 0. The time is assumed to be in the
local timezone. If the daylight saving flag is positive, the
time is assumed to be daylight saving time; if <br>
zero, the time is assumed to be standard time; and if
negative (the default), mktime() attempts to determine
whether daylight saving time is in effect for the specified
<br>
time. If datespec does not contain enough elements or if the
resulting time is out of range, mktime() returns -1.</p>

<p style="margin-top: 1em">strftime([format [, timestamp[,
utc-flag]]]) <br>
Format timestamp according to the specification in format.
If utc-flag is present and is non-zero or non-null, the
result is in UTC, otherwise the result is in local <br>
time. The timestamp should be of the same form as returned
by systime(). If timestamp is missing, the current time of
day is used. If format is missing, a default <br>
format equivalent to the output of date(1) is used. The
default format is available in
PROCINFO[&quot;strftime&quot;]. See the specification for
the strftime() function in ANSI <br>
C for the format conversions that are guaranteed to be
available.</p>

<p style="margin-top: 1em">systime() Return the current
time of day as the number of seconds since the Epoch
(1970-01-01 00:00:00 UTC on POSIX systems).</p>

<p style="margin-top: 1em">Bit Manipulations Functions <br>
Gawk supplies the following bit manipulation functions. They
work by converting double-precision floating point values to
uintmax_t integers, doing the operation, and then con&acirc;
<br>
verting the result back to floating point. The functions
are:</p>

<p style="margin-top: 1em">and(v1, v2) Return the bitwise
AND of the values provided by v1 and v2.</p>

<p style="margin-top: 1em">compl(val) Return the bitwise
complement of val.</p>

<p style="margin-top: 1em">lshift(val, count) Return the
value of val, shifted left by count bits.</p>

<p style="margin-top: 1em">or(v1, v2) Return the bitwise OR
of the values provided by v1 and v2.</p>

<p style="margin-top: 1em">rshift(val, count) Return the
value of val, shifted right by count bits.</p>

<p style="margin-top: 1em">xor(v1, v2) Return the bitwise
XOR of the values provided by v1 and v2.</p>

<p style="margin-top: 1em">Type Function <br>
The following function is for use with multidimensional
arrays.</p>

<p style="margin-top: 1em">isarray(x) <br>
Return true if x is an array, false otherwise.</p>

<p style="margin-top: 1em">Internationalization Functions
<br>
The following functions may be used from within your AWK
program for translating strings at run-time. For full
details, see GAWK: Effective AWK Programming.</p>

<p style="margin-top: 1em">bindtextdomain(directory [,
domain]) <br>
Specify the directory where gawk looks for the .mo files, in
case they will not or cannot be placed in the
&lsquo;&lsquo;standard&rsquo;&rsquo; locations (e.g., during
testing). It returns the <br>
directory where domain is &lsquo;&lsquo;bound.&rsquo;&rsquo;
<br>
The default domain is the value of TEXTDOMAIN. If directory
is the null string (&quot;&quot;), then bindtextdomain()
returns the current binding for the given domain.</p>

<p style="margin-top: 1em">dcgettext(string [, domain [,
category]]) <br>
Return the translation of string in text domain domain for
locale category category. The default value for domain is
the current value of TEXTDOMAIN. The default value <br>
for category is &quot;LC_MESSAGES&quot;. <br>
If you supply a value for category, it must be a string
equal to one of the known locale categories described in
GAWK: Effective AWK Programming. You must also supply a <br>
text domain. Use TEXTDOMAIN if you want to use the current
domain.</p>

<p style="margin-top: 1em">dcngettext(string1 , string2 ,
number [, domain [, category]]) <br>
Return the plural form used for number of the translation of
string1 and string2 in text domain domain for locale
category category. The default value for domain is the <br>
current value of TEXTDOMAIN. The default value for category
is &quot;LC_MESSAGES&quot;. <br>
If you supply a value for category, it must be a string
equal to one of the known locale categories described in
GAWK: Effective AWK Programming. You must also supply a <br>
text domain. Use TEXTDOMAIN if you want to use the current
domain.</p>

<p style="margin-top: 1em">USER-DEFINED FUNCTIONS <br>
Functions in AWK are defined as follows:</p>

<p style="margin-top: 1em">function name(parameter list) {
statements }</p>

<p style="margin-top: 1em">Functions are executed when they
are called from within expressions in either patterns or
actions. Actual parameters supplied in the function call are
used to instantiate the <br>
formal parameters declared in the function. Arrays are
passed by reference, other variables are passed by
value.</p>

<p style="margin-top: 1em">Since functions were not
originally part of the AWK language, the provision for local
variables is rather clumsy: They are declared as extra
parameters in the parameter list. <br>
The convention is to separate local variables from real
parameters by extra spaces in the parameter list. For
example:</p>

<p style="margin-top: 1em">function f(p, q, a, b) # a and b
are local <br>
{ <br>
... <br>
}</p>

<p style="margin-top: 1em">/abc/ { ... ; f(1, 2) ; ...
}</p>

<p style="margin-top: 1em">The left parenthesis in a
function call is required to immediately follow the function
name, without any intervening whitespace. This avoids a
syntactic ambiguity with the con&acirc; <br>
catenation operator. This restriction does not apply to the
built-in functions listed above.</p>

<p style="margin-top: 1em">Functions may call each other
and may be recursive. Function parameters used as local
variables are initialized to the null string and the number
zero upon function invocation.</p>

<p style="margin-top: 1em">Use return expr to return a
value from a function. The return value is undefined if no
value is provided, or if the function returns by
&acirc;falling off&acirc; the end.</p>

<p style="margin-top: 1em">As a gawk extension, functions
may be called indirectly. To do this, assign the name of the
function to be called, as a string, to a variable. Then use
the variable as if it <br>
were the name of a function, prefixed with an @ sign, like
so: <br>
function myfunc() <br>
{ <br>
print &quot;myfunc called&quot; <br>
... <br>
}</p>

<p style="margin-top: 1em">{ ... <br>
the_func = &quot;myfunc&quot; <br>
@the_func() # call through the_func to myfunc <br>
... <br>
}</p>

<p style="margin-top: 1em">If --lint has been provided,
gawk warns about calls to undefined functions at parse time,
instead of at run time. Calling an undefined function at run
time is a fatal error.</p>

<p style="margin-top: 1em">The word func may be used in
place of function.</p>

<p style="margin-top: 1em">DYNAMICALLY LOADING NEW
FUNCTIONS <br>
You can dynamically add new built-in functions to the
running gawk interpreter. The full details are beyond the
scope of this manual page; see GAWK: Effective AWK
Programming <br>
for the details.</p>

<p style="margin-top: 1em">extension(object, function) <br>
Dynamically link the shared object file named by object, and
invoke function in that object, to perform initialization.
These should both be provided as strings. Return <br>
the value returned by function.</p>

<p style="margin-top: 1em">Using this feature at the C
level is not pretty, but it is unlikely to go away.
Additional mechanisms may be added at some point.</p>

<p style="margin-top: 1em">SIGNALS <br>
pgawk accepts two signals. SIGUSR1 causes it to dump a
profile and function call stack to the profile file, which
is either awkprof.out, or whatever file was named with the
<br>
--profile option. It then continues to run. SIGHUP causes
pgawk to dump the profile and function call stack and then
exit.</p>

<p style="margin-top: 1em">INTERNATIONALIZATION <br>
String constants are sequences of characters enclosed in
double quotes. In non-English speaking environments, it is
possible to mark strings in the AWK program as requiring
<br>
translation to the local natural language. Such strings are
marked in the AWK program with a leading underscore
(&acirc;_&acirc;). For example,</p>

<p style="margin-top: 1em">gawk &rsquo;BEGIN { print
&quot;hello, world&quot; }&rsquo;</p>

<p style="margin-top: 1em">always prints hello, world.
But,</p>

<p style="margin-top: 1em">gawk &rsquo;BEGIN { print
_&quot;hello, world&quot; }&rsquo;</p>

<p style="margin-top: 1em">might print bonjour, monde in
France.</p>

<p style="margin-top: 1em">There are several steps involved
in producing and running a localizable AWK program.</p>

<p style="margin-top: 1em">1. Add a BEGIN action to assign
a value to the TEXTDOMAIN variable to set the text domain to
a name associated with your program:</p>

<p style="margin-top: 1em">BEGIN { TEXTDOMAIN =
&quot;myprog&quot; }</p>

<p style="margin-top: 1em">This allows gawk to find the .mo
file associated with your program. Without this step, gawk
uses the messages text domain, which likely does not contain
translations for your <br>
program.</p>

<p style="margin-top: 1em">2. Mark all strings that should
be translated with leading underscores.</p>

<p style="margin-top: 1em">3. If necessary, use the
dcgettext() and/or bindtextdomain() functions in your
program, as appropriate.</p>

<p style="margin-top: 1em">4. Run gawk --gen-pot -f
myprog.awk &gt; myprog.pot to generate a .po file for your
program.</p>

<p style="margin-top: 1em">5. Provide appropriate
translations, and build and install the corresponding .mo
files.</p>

<p style="margin-top: 1em">The internationalization
features are described in full detail in GAWK: Effective AWK
Programming.</p>

<p style="margin-top: 1em">POSIX COMPATIBILITY <br>
A primary goal for gawk is compatibility with the POSIX
standard, as well as with the latest version of UNIX awk. To
this end, gawk incorporates the following user visible
fea&acirc; <br>
tures which are not described in the AWK book, but are part
of the Bell Laboratories version of awk, and are in the
POSIX standard.</p>

<p style="margin-top: 1em">The book indicates that command
line variable assignment happens when awk would otherwise
open the argument as a file, which is after the BEGIN block
is executed. However, in <br>
earlier implementations, when such an assignment appeared
before any file names, the assignment would happen before
the BEGIN block was run. Applications came to depend on this
<br>
&acirc;feature.&acirc; When awk was changed to match its
documentation, the -v option for assigning variables before
program execution was added to accommodate applications that
depended <br>
upon the old behavior. (This feature was agreed upon by both
the Bell Laboratories and the GNU developers.)</p>

<p style="margin-top: 1em">When processing arguments, gawk
uses the special option &acirc;--&acirc; to signal the end
of arguments. In compatibility mode, it warns about but
otherwise ignores undefined options. In <br>
normal operation, such arguments are passed on to the AWK
program for it to process.</p>

<p style="margin-top: 1em">The AWK book does not define the
return value of srand(). The POSIX standard has it return
the seed it was using, to allow keeping track of random
number sequences. Therefore <br>
srand() in gawk also returns its current seed.</p>

<p style="margin-top: 1em">Other new features are: The use
of multiple -f options (from MKS awk); the ENVIRON array;
the , and escape sequences (done originally in gawk and fed
back into the Bell Lab&acirc; <br>
oratories version); the tolower() and toupper() built-in
functions (from the Bell Laboratories version); and the ANSI
C conversion specifications in printf (done first in the
<br>
Bell Laboratories version).</p>

<p style="margin-top: 1em">HISTORICAL FEATURES <br>
There is one feature of historical AWK implementations that
gawk supports: It is possible to call the length() built-in
function not only with no argument, but even without <br>
parentheses! Thus,</p>

<p style="margin-top: 1em">a = length # Holy Algol 60,
Batman!</p>

<p style="margin-top: 1em">is the same as either of</p>

<p style="margin-top: 1em">a = length() <br>
a = length($0)</p>

<p style="margin-top: 1em">Using this feature is poor
practice, and gawk issues a warning about its use if --lint
is specified on the command line.</p>

<p style="margin-top: 1em">GNU EXTENSIONS <br>
Gawk has a number of extensions to POSIX awk. They are
described in this section. All the extensions described here
can be disabled by invoking gawk with the --traditional or
<br>
--posix options.</p>

<p style="margin-top: 1em">The following features of gawk
are not available in POSIX awk.</p>

<p style="margin-top: 1em">&Acirc;&middot; No path search
is performed for files named via the -f option. Therefore
the AWKPATH environment variable is not special.</p>

<p style="margin-top: 1em">&Acirc;&middot; There is no
facility for doing file inclusion (gawk&rsquo;s @include
mechanism).</p>

<p style="margin-top: 1em">&Acirc;&middot; The escape
sequence. (Disabled with --posix.)</p>

<p style="margin-top: 1em">&Acirc;&middot; The ability to
continue lines after ? and :. (Disabled with --posix.)</p>

<p style="margin-top: 1em">&Acirc;&middot; Octal and
hexadecimal constants in AWK programs.</p>

<p style="margin-top: 1em">&Acirc;&middot; The ARGIND,
BINMODE, ERRNO, LINT, RT and TEXTDOMAIN variables are not
special.</p>

<p style="margin-top: 1em">&Acirc;&middot; The IGNORECASE
variable and its side-effects are not available.</p>

<p style="margin-top: 1em">&Acirc;&middot; The FIELDWIDTHS
variable and fixed-width field splitting.</p>

<p style="margin-top: 1em">&Acirc;&middot; The FPAT
variable and field splitting based on field values.</p>

<p style="margin-top: 1em">&Acirc;&middot; The PROCINFO
array is not available.</p>

<p style="margin-top: 1em">&Acirc;&middot; The use of RS as
a regular expression.</p>

<p style="margin-top: 1em">&Acirc;&middot; The special file
names available for I/O redirection are not recognized.</p>

<p style="margin-top: 1em">&Acirc;&middot; The |&amp;
operator for creating co-processes.</p>

<p style="margin-top: 1em">&Acirc;&middot; The BEGINFILE
and ENDFILE special patterns are not available.</p>

<p style="margin-top: 1em">&Acirc;&middot; The ability to
split out individual characters using the null string as the
value of FS, and as the third argument to split().</p>

<p style="margin-top: 1em">&Acirc;&middot; An optional
fourth argument to split() to receive the separator
texts.</p>

<p style="margin-top: 1em">&Acirc;&middot; The optional
second argument to the close() function.</p>

<p style="margin-top: 1em">&Acirc;&middot; The optional
third argument to the match() function.</p>

<p style="margin-top: 1em">&Acirc;&middot; The ability to
use positional specifiers with printf and sprintf().</p>

<p style="margin-top: 1em">&Acirc;&middot; The ability to
pass an array to length().</p>

<p style="margin-top: 1em">&Acirc;&middot; The use of
delete array to delete the entire contents of an array.</p>

<p style="margin-top: 1em">&Acirc;&middot; The use of
nextfile to abandon processing of the current input
file.</p>

<p style="margin-top: 1em">&Acirc;&middot; The and(),
asort(), asorti(), bindtextdomain(), compl(), dcgettext(),
dcngettext(), gensub(), lshift(), mktime(), or(),
patsplit(), rshift(), strftime(), strtonum(), systime() <br>
and xor() functions.</p>

<p style="margin-top: 1em">&Acirc;&middot; Localizable
strings.</p>

<p style="margin-top: 1em">&Acirc;&middot; Adding new
built-in functions dynamically with the extension()
function.</p>

<p style="margin-top: 1em">The AWK book does not define the
return value of the close() function. Gawk&rsquo;s close()
returns the value from fclose(3), or pclose(3), when closing
an output file or pipe, <br>
respectively. It returns the process&rsquo;s exit status
when closing an input pipe. The return value is -1 if the
named file, pipe or co-process was not opened with a
redirection.</p>

<p style="margin-top: 1em">When gawk is invoked with the
--traditional option, if the fs argument to the -F option is
&acirc;t&acirc;, then FS is set to the tab character. Note
that typing gawk -F ... simply <br>
causes the shell to quote the &acirc;t,&acirc; and does not
pass &acirc;&acirc; to the -F option. Since this is a rather
ugly special case, it is not the default behavior. This
behavior also does <br>
not occur if --posix has been specified. To really get a tab
character as the field separator, it is best to use single
quotes: gawk -F&rsquo;&rsquo; ....</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
The AWKPATH environment variable can be used to provide a
list of directories that gawk searches when looking for
files named via the -f and --file options.</p>

<p style="margin-top: 1em">For socket communication, two
special environment variables can be used to control the
number of retries (GAWK_SOCK_RETRIES), and the interval
between retries (GAWK_MSEC_SLEEP). <br>
The interval is in milliseconds. On systems that do not
support usleep(3), the value is rounded up to an integral
number of seconds.</p>

<p style="margin-top: 1em">If POSIXLY_CORRECT exists in the
environment, then gawk behaves exactly as if --posix had
been specified on the command line. If --lint has been
specified, gawk issues a warning <br>
message to this effect.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
If the exit statement is used with a value, then gawk exits
with the numeric value given to it.</p>

<p style="margin-top: 1em">Otherwise, if there were no
problems during execution, gawk exits with the value of the
C constant EXIT_SUCCESS. This is usually zero.</p>

<p style="margin-top: 1em">If an error occurs, gawk exits
with the value of the C constant EXIT_FAILURE. This is
usually one.</p>

<p style="margin-top: 1em">If gawk exits because of a fatal
error, the exit status is 2. On non-POSIX systems, this
value may be mapped to EXIT_FAILURE.</p>

<p style="margin-top: 1em">VERSION INFORMATION <br>
This man page documents gawk, version 4.0.</p>

<p style="margin-top: 1em">AUTHORS <br>
The original version of UNIX awk was designed and
implemented by Alfred Aho, Peter Weinberger, and Brian
Kernighan of Bell Laboratories. Brian Kernighan continues to
maintain <br>
and enhance it.</p>

<p style="margin-top: 1em">Paul Rubin and Jay Fenlason, of
the Free Software Foundation, wrote gawk, to be compatible
with the original version of awk distributed in Seventh
Edition UNIX. John Woods con&acirc; <br>
tributed a number of bug fixes. David Trueman, with
contributions from Arnold Robbins, made gawk compatible with
the new version of UNIX awk. Arnold Robbins is the current
<br>
maintainer.</p>

<p style="margin-top: 1em">The initial DOS port was done by
Conrad Kwok and Scott Garfinkle. Scott Deifik maintains the
port to MS-DOS using DJGPP. Eli Zaretskii maintains the port
to MS-Windows using <br>
MinGW. Pat Rankin did the port to VMS, and Michal Jaegermann
did the port to the Atari ST. The port to OS/2 was done by
Kai Uwe Rommel, with contributions and help from Darrel <br>
Hankerson. Andreas Buening now maintains the OS/2 port. The
late Fred Fish supplied support for the Amiga, and Martin
Brown provided the BeOS port. Stephen Davies provided the
<br>
original Tandem port, and Matthew Woehlke provided changes
for Tandem&rsquo;s POSIX-compliant systems. Dave Pitts
provided the port to z/OS.</p>

<p style="margin-top: 1em">See the README file in the gawk
distribution for up-to-date information about maintainers
and which ports are currently supported.</p>

<p style="margin-top: 1em">BUG REPORTS <br>
If you find a bug in gawk, please send electronic mail to
bug-gawk@gnu.org. Please include your operating system and
its revision, the version of gawk (from gawk --version),
<br>
which C compiler you used to compile it, and a test program
and data that are as small as possible for reproducing the
problem.</p>

<p style="margin-top: 1em">Before sending a bug report,
please do the following things. First, verify that you have
the latest version of gawk. Many bugs (usually subtle ones)
are fixed at each release, <br>
and if yours is out of date, the problem may already have
been solved. Second, please see if setting the environment
variable LC_ALL to LC_ALL=C causes things to behave as you
<br>
expect. If so, it&rsquo;s a locale issue, and may or may not
really be a bug. Finally, please read this man page and the
reference manual carefully to be sure that what you think is
a <br>
bug really is, instead of just a quirk in the language.</p>

<p style="margin-top: 1em">Whatever you do, do NOT post a
bug report in comp.lang.awk. While the gawk developers
occasionally read this newsgroup, posting bug reports there
is an unreliable way to report <br>
bugs. Instead, please use the electronic mail addresses
given above.</p>

<p style="margin-top: 1em">If you&rsquo;re using a
GNU/Linux or BSD-based system, you may wish to submit a bug
report to the vendor of your distribution. That&rsquo;s
fine, but please send a copy to the official <br>
email address as well, since there&rsquo;s no guarantee that
the bug report will be forwarded to the gawk maintainer.</p>

<p style="margin-top: 1em">BUGS <br>
The -F option is not necessary given the command line
variable assignment feature; it remains only for backwards
compatibility.</p>

<p style="margin-top: 1em">Syntactically invalid single
character programs tend to overflow the parse stack,
generating a rather unhelpful message. Such programs are
surprisingly difficult to diagnose in <br>
the completely general case, and the effort to do so really
is not worth it.</p>

<p style="margin-top: 1em">SEE ALSO <br>
egrep(1), getpid(2), getppid(2), getpgrp(2), getuid(2),
geteuid(2), getgid(2), getegid(2), getgroups(2),
usleep(3)</p>

<p style="margin-top: 1em">The AWK Programming Language,
Alfred V. Aho, Brian W. Kernighan, Peter J. Weinberger,
Addison-Wesley, 1988. ISBN 0-201-07981-X.</p>

<p style="margin-top: 1em">GAWK: Effective AWK Programming,
Edition 4.0, shipped with the gawk source. The current
version of this document is available online at
http://www.gnu.org/software/gawk/manual.</p>

<p style="margin-top: 1em">EXAMPLES <br>
Print and sort the login names of all users:</p>

<p style="margin-top: 1em">BEGIN { FS = &quot;:&quot; }
<br>
{ print $1 | &quot;sort&quot; }</p>

<p style="margin-top: 1em">Count lines in a file:</p>

<p style="margin-top: 1em">{ nlines++ } <br>
END { print nlines }</p>

<p style="margin-top: 1em">Precede each line by its number
in the file:</p>

<p style="margin-top: 1em">{ print FNR, $0 }</p>

<p style="margin-top: 1em">Concatenate and line number (a
variation on a theme):</p>

<p style="margin-top: 1em">{ print NR, $0 }</p>

<p style="margin-top: 1em">Run an external command for
particular lines of data:</p>

<p style="margin-top: 1em">tail -f access_log | <br>
awk &rsquo;/myhome.html/ { system(&quot;nmap &quot; $1
&quot;&gt;&gt; logdir/myhome.html&quot;) }&rsquo;</p>

<p style="margin-top: 1em">ACKNOWLEDGEMENTS <br>
Brian Kernighan of Bell Laboratories provided valuable
assistance during testing and debugging. We thank him.</p>

<p style="margin-top: 1em">COPYING PERMISSIONS <br>
Copyright &Acirc;&copy; 1989, 1991, 1992, 1993, 1994, 1995,
1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2005, 2007,
2009, 2010, 2011 Free Software Foundation, Inc.</p>

<p style="margin-top: 1em">Permission is granted to make
and distribute verbatim copies of this manual page provided
the copyright notice and this permission notice are
preserved on all copies.</p>

<p style="margin-top: 1em">Permission is granted to copy
and distribute modified versions of this manual page under
the conditions for verbatim copying, provided that the
entire resulting derived work is <br>
distributed under the terms of a permission notice identical
to this one.</p>

<p style="margin-top: 1em">Permission is granted to copy
and distribute translations of this manual page into another
language, under the above conditions for modified versions,
except that this permission <br>
notice may be stated in a translation approved by the
Foundation.</p>

<p style="margin-top: 1em">Free Software Foundation Dec 07
2012 GAWK(1)</p>
<hr>
</body>
</html>
