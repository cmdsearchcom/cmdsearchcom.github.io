<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>JPNEVULATOR(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">JPNEVULATOR(1)</td>
    <td class="head-vol">User Commands</td>
    <td class="head-rtitle">JPNEVULATOR(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
jpnevulator - Just another serial sniffer
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>jpnevulator</b> [ <i>OPTION</i>]... &lt;<i>FILE</i>&gt;
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
jpnevulator is a handy serial sniffer. You can use it to send data on a serial
  device too. You can read or write from/to one or more serial devices at the
  same time.
<div class="Pp"></div>
In write (--write) mode data to be sent on the serial device(s) is read from a
  file or stdin in base (--base) defined notation. Data is sent on the serial
  device(s) line by line.
<div class="Pp"></div>
In read (--read) mode data to be read from the serial device(s) is written to a
  file or stdout in base (--base) defined notation. Skim through the options for
  several enhancements in the output. It's even possible to pass(--pass) on the
  data between the several serial devices.
<div class="Pp"></div>
Mandatory arguments to long options are mandatory for short options too.
<div class="Pp"></div>
Generic options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-B</b>, <b>--base</b>=<i>BASE</i></dt>
  <dd class="It-tag">Specify the base unit of read/write bytes. Currently only
      2=binary and 16=hexadecimal are supported. The default base unit is
      hexadecimal.
    <div style="height: 1.00em;">&#x00A0;</div>
    Selecting hexadecimal as the base unit, the input format is FD or 0xFD. Of
      course all input is treated case-insensitive. Spaces may or may not be
      included in the input. So DEADBEEF is exactly the same as DE AD BE EF.
    <div style="height: 1.00em;">&#x00A0;</div>
    Selecting binary as the base unit, the input format is 01000010. Spaces may
      or may not be included in the input. So 01000010111 is exactely the same
      as 01000010 111. Yes, that's right! It's perfectly fine to write less than
      8 bits, excluding the leading zeros. Please understand if doing so, spaces
      are needed to separate the individual bytes in this case, but that's
      obvious. If no spaces are used, the parses reads the first 8 bits before
      it continues with the next, as shown in the example above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l</b>, <b>--alias-separator</b></dt>
  <dd class="It-tag">Use the given string as the alias separator. See --tty for
      more information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b>, <b>--file</b>=<i>NAME</i></dt>
  <dd class="It-tag">In write mode read the contents of the file given and send
      them on the serial device(s) and in read mode write the contents of the
      serial device(s) to the file given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b>, <b>--help</b></dt>
  <dd class="It-tag">Shows a brief list of options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b>, <b>--count</b>=<i>BYTES</i></dt>
  <dd class="It-tag">Exit after reading / writing the given amount of
    bytes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b>, <b>--read</b></dt>
  <dd class="It-tag">Put the program in read mode. This way you read the data
      from the given serial device(s) and write it to the file given or stdout
      if none given. See the read options section for more read specific
      options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b>, <b>--tty</b>=<i>NAME:ALIAS</i></dt>
  <dd class="It-tag">The serial device to read from or write to. Use multiple
      times to read/write from/to more than one serial device(s). For handy
      reference you can also separate an alias from the tty name with a collon
      ':'. If a collon is for some strange reason part of your device name, you
      can use the --alias-separator option to specify another separation string.
      If an alias is given it will be used as the name of the serial
    device.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b>, <b>--version</b></dt>
  <dd class="It-tag">Output the version information, a small GPL notice and
      exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b>, <b>--write</b></dt>
  <dd class="It-tag">Put the program in write mode. This way you read data from
      a given file or stdin if none given and write it to the serial device(s)
      given. See the write options section for more write specific options.</dd>
</dl>
<div class="Pp"></div>
Read options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-a</b>, <b>--ascii</b></dt>
  <dd class="It-tag">Besides the normal output of the data, also display an
      extra column with the data in the ASCII representation. Non printable
      characters are displayed as a dot '.'. The ASCII data is displayed after
      the normal data.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b</b>, <b>--byte-count</b></dt>
  <dd class="It-tag">Besides the normal output also display an extra column with
      the current index number of the byte in the output. These numbers are
      displayed in front of the normal output. When readin from multiple serial
      devices at the same time the index number will increase per serial
    device.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C</b>, <b>--control</b></dt>
  <dd class="It-tag">Monitor modem control bits (line enable, data terminal
      ready, request to send, secondary TXD, secondary RXD, clear to send,
      carrier detect, ring and data set ready) too and notify changes. Use the
      --control-poll option to specify how often to poll for the bits.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D</b>, <b>--control-poll</b>=<i>MICROSECONDS</i></dt>
  <dd class="It-tag">The control poll is the amount of microseconds to wait in
      between two checks of the modem control bits if nothing else is
    happening.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-P</b>, <b>--pass</b></dt>
  <dd class="It-tag">This one passes all the data between the serial devices.
      Handy if you want to put your serial sniffer in between the serial devices
      you want to sniff.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b>, <b>--pty</b>=<i>:ALIAS</i></dt>
  <dd class="It-tag">The pseudo-terminal device to read from. Use multiple times
      to read from more than one pseudo-terminal device(s). For handy reference
      you can also use an alias to name the pty. Make sure it starts with a
      collon ':'. Use the --alias-separator option if you for some reason don't
      like to use a collon. If an alias is given it will be used as the name of
      the pseudo-terminal device.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e</b>, <b>--timing-delta</b>=<i>MICROSECONDS</i></dt>
  <dd class="It-tag">The timing delta is the amount of microseconds between two
      bytes that the latter is considered to be part of a new package. The
      default is 100 miliseconds. Use this option in conjunction with the
      --timing-print option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g</b>, <b>--timing-print</b></dt>
  <dd class="It-tag">Print a line of timing information before every continues
      stream of bytes. When multiple serial devices are given also print the
      name or alias of the device where the data is coming from.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b>, <b>--width</b>=<i>WIDTH</i></dt>
  <dd class="It-tag">The number of bytes to display on one line. The default is
      16.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-A</b>, <b>--append</b></dt>
  <dd class="It-tag">Append to the output file instead of overwriting. The
      default is to overwrite.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S</b>, <b>--append-separator</b></dt>
  <dd class="It-tag">Use the given string as the append separator. The string is
      processed and the '\n' sequence transforms into a real newline. So far no
      other sequences do anything special. The default is a single newline
      character.</dd>
</dl>
<div class="Pp"></div>
Write options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b>, <b>--checksum</b></dt>
  <dd class="It-tag">Append a single checksum byte to the line of data written
      to the serial device(s) chosen. This checksum is a simple modulo 256
      addition of all input bytes on a line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-z</b>, <b>--crc8</b>=<i>POLY</i></dt>
  <dd class="It-tag">Append a crc8 checksum to the line of data written to the
      serial device(s) chosen. Use the optionally given poly as the polynomial.
      Specify the polynomial as hexadecimal value, as in 0x07 (the
    default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-y</b>, <b>--crc16</b>=<i>POLY</i></dt>
  <dd class="It-tag">Append a crc16 checksum to the line of data written to the
      serial device(s) chosen. Use the optionally given poly as the polynomial.
      Specify the polynomial as hexadecimal value, as in 0xA001 (the
    default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k</b>, <b>--delay-byte</b>=<i>MICROSECONDS</i></dt>
  <dd class="It-tag">This delay is an optional amount of microseconds to wait in
      between every input byte is sent on the serial device(s).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b>, <b>--delay-line</b>=<i>MICROSECONDS</i></dt>
  <dd class="It-tag">This delay is an optional amount of microseconds to wait in
      between every input line is sent on the serial device(s).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-j</b>, <b>--fuck-up</b></dt>
  <dd class="It-tag">This is the special fuck up option. When the calculation of
      a checksum is chosen (see checksum and crc* options) the checkum will be
      crippled on purpose. Carefully named after the special Jan Arie de Bruin
      'fuck up crc' button.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b>, <b>--no-send</b></dt>
  <dd class="It-tag">Do not actually send the bytes on the serial device(s).
      Rather pointless, but seemed one day long ago to be a rather handy
      feature.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b>, <b>--print</b></dt>
  <dd class="It-tag">Besided sending the data on the serial device(s) also write
      the data to stdout.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b>, <b>--size</b>=<i>SIZE</i></dt>
  <dd class="It-tag">The maximum number of bytes per line to send on the serial
      device(s). The default is 22, coming from back in the Cham2 days of the
      program.</dd>
</dl>
<h1 class="Sh" title="Sh" id="DIAGNOSTICS"><a class="selflink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
Normally, exit status is 0 if the program did run with no problem whatsoever. If
  the exit status is not equal to 0 an error message is printed on stderr which
  should help you solve the problem.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
<b>Order of bytes broke when reading several tty devices at once</b>
<div class="Pp"></div>
The display of incoming bytes can be broke if you use multiple tty devices to
  read from. At the moment I do not have a solution for this problem. Since I
  use select() to watch the several tty devices and after the select() I have to
  read() them one by one, I can not completely 100% display which bytes came
  after which on different tty devices. Take the example below:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
$ jpnevulator --ascii --timing-print --tty /dev/ttyS0 --tty /dev/ttyUSB0 --read
2006-05-30 13:23:49.461075: /dev/ttyS0
00 00 05 3B 0D 00 00 05                         ...;....
2006-05-30 13:23:49.461113: /dev/ttyUSB0
00 05 3B 0D 00 00 05 3B 0D                      ..;....;.
2006-05-30 13:23:49.473074: /dev/ttyS0
3B 0D 00 00 05 3B 0D                            ;....;.
2006-05-30 13:23:49.473105: /dev/ttyUSB0
00 12 05 06 39 00 12 05 06 39 1F 00 22 80 00 0E ....9....9..&quot;...
$
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
<div class="Pp"></div>
And now see the order in which things really got sent on the line:
<div class="Pp"></div>
<div style="margin-left: 5.00ex;">
<pre>
<div style="height: 0.50em;">&#x00A0;</div>
/dev/ttyS0:
00 00 05 3B 0D
/dev/ttyUSB0:
00 00 05 3B 0D
/dev/ttyS0:
00 00 05 3B 0D
/dev/ttyUSB0:
00 00 05 3B 0D
/dev/ttyS0:
00 00 05 3B 0D
/dev/ttyUSB0:
00 00 05 3B 0D 00 12 05 06 39 00 12 05 06 39 ...
<div style="height: 0.50em;">&#x00A0;</div>
</pre>
</div>
<div class="Pp"></div>
As you can see /dev/ttyUSB0 receives the echo of all things sent by /dev/ttyS0.
  This is exactly what happens. But since there does exist a small time between
  the select() who is happy expressing something is available and the read() who
  does get the available data, some extra data will be available. I have no idea
  on how I can use high level system call like select() and read() and be still
  able to put the bytes in the correct order. Anyone an idea?
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Written by Freddy Spierenburg.
<h1 class="Sh" title="Sh" id="REPORTING_BUGS"><a class="selflink" href="#REPORTING_BUGS">REPORTING
  BUGS</a></h1>
Report bugs to &lt;freddy@snarl.nl&gt;.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright &#x00A9; 2006-2016 Freddy Spierenburg</div>
<table class="foot">
  <tr>
    <td class="foot-date">August 2016</td>
    <td class="foot-os">jpnevulator 2.3.2</td>
  </tr>
</table>
</body>
</html>
