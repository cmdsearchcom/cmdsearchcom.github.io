<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:19:58 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>JPNEVULATOR(1) User Commands JPNEVULATOR(1)</p>

<p style="margin-top: 1em">NAME <br>
jpnevulator - Just another serial sniffer</p>

<p style="margin-top: 1em">SYNOPSIS <br>
jpnevulator [OPTION]... &lt;FILE&gt;</p>

<p style="margin-top: 1em">DESCRIPTION <br>
jpnevulator is a handy serial sniffer. You can use it to
send data on a serial device too. You can read or write
from/to one or more serial devices at the same time.</p>

<p style="margin-top: 1em">In write (--write) mode data to
be sent on the serial device(s) is read from a file or stdin
in base (--base) defined notation. Data is sent on the
serial device(s) line by line.</p>

<p style="margin-top: 1em">In read (--read) mode data to be
read from the serial device(s) is written to a file or
stdout in base (--base) defined notation. Skim through the
options for several enhance&acirc; <br>
ments in the output. It&rsquo;s even possible to
pass(--pass) on the data between the several serial
devices.</p>

<p style="margin-top: 1em">Mandatory arguments to long
options are mandatory for short options too.</p>

<p style="margin-top: 1em">Generic options:</p>

<p style="margin-top: 1em">-B, --base=BASE <br>
Specify the base unit of read/write bytes. Currently only
2=binary and 16=hexadecimal are supported. The default base
unit is hexadecimal.</p>

<p style="margin-top: 1em">Selecting hexadecimal as the
base unit, the input format is FD or 0xFD. Of course all
input is treated case-insensitive. Spaces may or may not be
included in the input. So <br>
DEADBEEF is exactly the same as DE AD BE EF.</p>

<p style="margin-top: 1em">Selecting binary as the base
unit, the input format is 01000010. Spaces may or may not be
included in the input. So 01000010111 is exactely the same
as 01000010 111. Yes, <br>
that&rsquo;s right! It&rsquo;s perfectly fine to write less
than 8 bits, excluding the leading zeros. Please understand
if doing so, spaces are needed to separate the individual
bytes <br>
in this case, but that&rsquo;s obvious. If no spaces are
used, the parses reads the first 8 bits before it continues
with the next, as shown in the example above.</p>

<p style="margin-top: 1em">-l, --alias-separator <br>
Use the given string as the alias separator. See --tty for
more information.</p>

<p style="margin-top: 1em">-f, --file=NAME <br>
In write mode read the contents of the file given and send
them on the serial device(s) and in read mode write the
contents of the serial device(s) to the file given.</p>

<p style="margin-top: 1em">-h, --help <br>
Shows a brief list of options.</p>

<p style="margin-top: 1em">-o, --count=BYTES <br>
Exit after reading / writing the given amount of bytes.</p>

<p style="margin-top: 1em">-r, --read <br>
Put the program in read mode. This way you read the data
from the given serial device(s) and write it to the file
given or stdout if none given. See the read options
sec&acirc; <br>
tion for more read specific options.</p>

<p style="margin-top: 1em">-t, --tty=NAME:ALIAS <br>
The serial device to read from or write to. Use multiple
times to read/write from/to more than one serial device(s).
For handy reference you can also separate an alias <br>
from the tty name with a collon &rsquo;:&rsquo;. If a collon
is for some strange reason part of your device name, you can
use the --alias-separator option to specify another
separa&acirc; <br>
tion string. If an alias is given it will be used as the
name of the serial device.</p>

<p style="margin-top: 1em">-v, --version <br>
Output the version information, a small GPL notice and
exit.</p>

<p style="margin-top: 1em">-w, --write <br>
Put the program in write mode. This way you read data from a
given file or stdin if none given and write it to the serial
device(s) given. See the write options section <br>
for more write specific options.</p>

<p style="margin-top: 1em">Read options:</p>

<p style="margin-top: 1em">-a, --ascii <br>
Besides the normal output of the data, also display an extra
column with the data in the ASCII representation. Non
printable characters are displayed as a dot &rsquo;.&rsquo;.
The <br>
ASCII data is displayed after the normal data.</p>

<p style="margin-top: 1em">-b, --byte-count <br>
Besides the normal output also display an extra column with
the current index number of the byte in the output. These
numbers are displayed in front of the normal output. <br>
When readin from multiple serial devices at the same time
the index number will increase per serial device.</p>

<p style="margin-top: 1em">-C, --control <br>
Monitor modem control bits (line enable, data terminal
ready, request to send, secondary TXD, secondary RXD, clear
to send, carrier detect, ring and data set ready) too <br>
and notify changes. Use the --control-poll option to specify
how often to poll for the bits.</p>

<p style="margin-top: 1em">-D, --control-poll=MICROSECONDS
<br>
The control poll is the amount of microseconds to wait in
between two checks of the modem control bits if nothing else
is happening.</p>

<p style="margin-top: 1em">-P, --pass <br>
This one passes all the data between the serial devices.
Handy if you want to put your serial sniffer in between the
serial devices you want to sniff.</p>

<p style="margin-top: 1em">-q, --pty=:ALIAS <br>
The pseudo-terminal device to read from. Use multiple times
to read from more than one pseudo-terminal device(s). For
handy reference you can also use an alias to name the <br>
pty. Make sure it starts with a collon &rsquo;:&rsquo;. Use
the --alias-separator option if you for some reason
don&rsquo;t like to use a collon. If an alias is given it
will be used as <br>
the name of the pseudo-terminal device.</p>

<p style="margin-top: 1em">-e, --timing-delta=MICROSECONDS
<br>
The timing delta is the amount of microseconds between two
bytes that the latter is considered to be part of a new
package. The default is 100 miliseconds. Use this option
<br>
in conjunction with the --timing-print option.</p>

<p style="margin-top: 1em">-g, --timing-print <br>
Print a line of timing information before every continues
stream of bytes. When multiple serial devices are given also
print the name or alias of the device where the data <br>
is coming from.</p>

<p style="margin-top: 1em">-i, --width=WIDTH <br>
The number of bytes to display on one line. The default is
16.</p>

<p style="margin-top: 1em">-A, --append <br>
Append to the output file instead of overwriting. The
default is to overwrite.</p>

<p style="margin-top: 1em">-S, --append-separator <br>
Use the given string as the append separator. The string is
processed and the &rsquo;0 sequence transforms into a real
newline. So far no other sequences do anything special. <br>
The default is a single newline character.</p>

<p style="margin-top: 1em">Write options:</p>

<p style="margin-top: 1em">-c, --checksum <br>
Append a single checksum byte to the line of data written to
the serial device(s) chosen. This checksum is a simple
modulo 256 addition of all input bytes on a line.</p>

<p style="margin-top: 1em">-z, --crc8=POLY <br>
Append a crc8 checksum to the line of data written to the
serial device(s) chosen. Use the optionally given poly as
the polynomial. Specify the polynomial as hexadecimal <br>
value, as in 0x07 (the default).</p>

<p style="margin-top: 1em">-y, --crc16=POLY <br>
Append a crc16 checksum to the line of data written to the
serial device(s) chosen. Use the optionally given poly as
the polynomial. Specify the polynomial as hexadecimal <br>
value, as in 0xA001 (the default).</p>

<p style="margin-top: 1em">-k, --delay-byte=MICROSECONDS
<br>
This delay is an optional amount of microseconds to wait in
between every input byte is sent on the serial
device(s).</p>

<p style="margin-top: 1em">-d, --delay-line=MICROSECONDS
<br>
This delay is an optional amount of microseconds to wait in
between every input line is sent on the serial
device(s).</p>

<p style="margin-top: 1em">-j, --fuck-up <br>
This is the special fuck up option. When the calculation of
a checksum is chosen (see checksum and crc* options) the
checkum will be crippled on purpose. Carefully named <br>
after the special Jan Arie de Bruin &rsquo;fuck up
crc&rsquo; button.</p>

<p style="margin-top: 1em">-n, --no-send <br>
Do not actually send the bytes on the serial device(s).
Rather pointless, but seemed one day long ago to be a rather
handy feature.</p>

<p style="margin-top: 1em">-p, --print <br>
Besided sending the data on the serial device(s) also write
the data to stdout.</p>

<p style="margin-top: 1em">-s, --size=SIZE <br>
The maximum number of bytes per line to send on the serial
device(s). The default is 22, coming from back in the Cham2
days of the program.</p>

<p style="margin-top: 1em">DIAGNOSTICS <br>
Normally, exit status is 0 if the program did run with no
problem whatsoever. If the exit status is not equal to 0 an
error message is printed on stderr which should help you
<br>
solve the problem.</p>

<p style="margin-top: 1em">BUGS <br>
Order of bytes broke when reading several tty devices at
once</p>

<p style="margin-top: 1em">The display of incoming bytes
can be broke if you use multiple tty devices to read from.
At the moment I do not have a solution for this problem.
Since I use select() to watch <br>
the several tty devices and after the select() I have to
read() them one by one, I can not completely 100% display
which bytes came after which on different tty devices. Take
the <br>
example below:</p>

<p style="margin-top: 1em">$ jpnevulator --ascii
--timing-print --tty /dev/ttyS0 --tty /dev/ttyUSB0 --read
<br>
2006-05-30 13:23:49.461075: /dev/ttyS0 <br>
00 00 05 3B 0D 00 00 05 ...;.... <br>
2006-05-30 13:23:49.461113: /dev/ttyUSB0 <br>
00 05 3B 0D 00 00 05 3B 0D ..;....;. <br>
2006-05-30 13:23:49.473074: /dev/ttyS0 <br>
3B 0D 00 00 05 3B 0D ;....;. <br>
2006-05-30 13:23:49.473105: /dev/ttyUSB0 <br>
00 12 05 06 39 00 12 05 06 39 1F 00 22 80 00 0E
....9....9..&quot;... <br>
$</p>

<p style="margin-top: 1em">And now see the order in which
things really got sent on the line:</p>

<p style="margin-top: 1em">/dev/ttyS0: <br>
00 00 05 3B 0D <br>
/dev/ttyUSB0: <br>
00 00 05 3B 0D <br>
/dev/ttyS0: <br>
00 00 05 3B 0D <br>
/dev/ttyUSB0: <br>
00 00 05 3B 0D <br>
/dev/ttyS0: <br>
00 00 05 3B 0D <br>
/dev/ttyUSB0: <br>
00 00 05 3B 0D 00 12 05 06 39 00 12 05 06 39 ...</p>

<p style="margin-top: 1em">As you can see /dev/ttyUSB0
receives the echo of all things sent by /dev/ttyS0. This is
exactly what happens. But since there does exist a small
time between the select() who is <br>
happy expressing something is available and the read() who
does get the available data, some extra data will be
available. I have no idea on how I can use high level system
call <br>
like select() and read() and be still able to put the bytes
in the correct order. Anyone an idea?</p>

<p style="margin-top: 1em">AUTHOR <br>
Written by Freddy Spierenburg.</p>

<p style="margin-top: 1em">REPORTING BUGS <br>
Report bugs to &lt;freddy@snarl.nl&gt;.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright &Acirc;&copy; 2006-2016 Freddy Spierenburg</p>

<p style="margin-top: 1em">jpnevulator 2.3.2 August 2016
JPNEVULATOR(1)</p>
<hr>
</body>
</html>
