<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:07:35 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>erl(1) User Commands erl(1)</p>

<p style="margin-top: 1em">NAME <br>
erl - The Erlang emulator.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The erl program starts an Erlang runtime system. The exact
details (for example, whether erl is a script or a program
and which other programs it calls) are system-dependent.</p>

<p style="margin-top: 1em">Windows users probably want to
use the werl program instead, which runs in its own window
with scrollbars and supports command-line editing. The erl
program on Windows provides <br>
no line editing in its shell, and on Windows 95 there is no
way to scroll back to text that has scrolled off the screen.
The erl program must be used, however, in pipelines or if
<br>
you want to redirect standard input or output.</p>

<p style="margin-top: 1em">Note: <br>
As from ERTS 5.9 (Erlang/OTP R15B) the runtime system does
by default not bind schedulers to logical processors. For
more information, see system flag +sbt.</p>

<p style="margin-top: 1em">EXPORTS <br>
erl &lt;arguments&gt;</p>

<p style="margin-top: 1em">Starts an Erlang runtime
system.</p>

<p style="margin-top: 1em">The arguments can be divided
into emulator flags, flags, and plain arguments:</p>

<p style="margin-top: 1em">* Any argument starting with
character + is interpreted as an emulator flag.</p>

<p style="margin-top: 1em">As indicated by the name,
emulator flags control the behavior of the emulator.</p>

<p style="margin-top: 1em">* Any argument starting with
character - (hyphen) is interpreted as a flag, which is to
be passed to the Erlang part of the runtime system, more
specifically to the init <br>
system process, see init(3erl).</p>

<p style="margin-top: 1em">The init process itself
interprets some of these flags, the init flags. It also
stores any remaining flags, the user flags. The latter can
be retrieved by calling <br>
init:get_argument/1.</p>

<p style="margin-top: 1em">A small number of &quot;-&quot;
flags exist, which now actually are emulator flags, see the
description below.</p>

<p style="margin-top: 1em">* Plain arguments are not
interpreted in any way. They are also stored by the init
process and can be retrieved by calling
init:get_plain_arguments/0. Plain arguments <br>
can occur before the first flag, or after a -- flag. Also,
the -extra flag causes everything that follows to become
plain arguments.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">% erl +W w -sname arnie +R 9 -s
my_init -extra +bertie <br>
(arnie@host)1&gt; init:get_argument(sname). <br>
{ok,[[&quot;arnie&quot;]]} <br>
(arnie@host)2&gt; init:get_plain_arguments(). <br>
[&quot;+bertie&quot;]</p>

<p style="margin-top: 1em">Here +W w and +R 9 are emulator
flags. -s my_init is an init flag, interpreted by init.
-sname arnie is a user flag, stored by init. It is read by
Kernel and causes the <br>
Erlang runtime system to become distributed. Finally,
everything after -extra (that is, +bertie) is considered as
plain arguments.</p>

<p style="margin-top: 1em">% erl -myflag 1 <br>
1&gt; init:get_argument(myflag). <br>
{ok,[[&quot;1&quot;]]} <br>
2&gt; init:get_plain_arguments(). <br>
[]</p>

<p style="margin-top: 1em">Here the user flag -myflag 1 is
passed to and stored by the init process. It is a
user-defined flag, presumably used by some user-defined
application.</p>

<p style="margin-top: 1em">FLAGS <br>
In the following list, init flags are marked &quot;(init
flag)&quot;. Unless otherwise specified, all other flags are
user flags, for which the values can be retrieved by calling
<br>
init:get_argument/1. Notice that the list of user flags is
not exhaustive, there can be more application-specific flags
that instead are described in the corresponding
applica&acirc; <br>
tion documentation.</p>

<p style="margin-top: 1em">-- (init flag): <br>
Everything following -- up to the next flag (-flag or +flag)
is considered plain arguments and can be retrieved using
init:get_plain_arguments/0.</p>

<p style="margin-top: 1em">-Application Par Val: <br>
Sets the application configuration parameter Par to the
value Val for the application Application; see app(5) and
application(3erl).</p>

<p style="margin-top: 1em">-args_file FileName: <br>
Command-line arguments are read from the file FileName. The
arguments read from the file replace flag &rsquo;-args_file
FileName&rsquo; on the resulting command line.</p>

<p style="margin-top: 1em">The file FileName is to be a
plain text file and can contain comments and command-line
arguments. A comment begins with a # character and continues
until the next end of line <br>
character. Backslash (\) is used as quoting character. All
command-line arguments accepted by erl are allowed, also
flag -args_file FileName. Be careful not to cause
circu&acirc; <br>
lar dependencies between files containing flag -args_file,
though.</p>

<p style="margin-top: 1em">The flag -extra is treated in
special way. Its scope ends at the end of the file.
Arguments following an -extra flag are moved on the command
line into the -extra section, <br>
that is, the end of the command line following after an
-extra flag.</p>

<p style="margin-top: 1em">-async_shell_start: <br>
The initial Erlang shell does not read user input until the
system boot procedure has been completed (Erlang/OTP 5.4 and
later). This flag disables the start synchronization <br>
feature and lets the shell start in parallel with the rest
of the system.</p>

<p style="margin-top: 1em">-boot File: <br>
Specifies the name of the boot file, File.boot, which is
used to start the system; see init(3erl). Unless File
contains an absolute path, the system searches for File.boot
in <br>
the current and $ROOT/bin directories.</p>

<p style="margin-top: 1em">Defaults to
$ROOT/bin/start.boot.</p>

<p style="margin-top: 1em">-boot_var Var Dir: <br>
If the boot script contains a path variable Var other than
$ROOT, this variable is expanded to Dir. Used when
applications are installed in another directory than
$ROOT/lib; <br>
see systools:make_script/1,2 in SASL.</p>

<p style="margin-top: 1em">-code_path_cache: <br>
Enables the code path cache of the code server; see
code(3erl).</p>

<p style="margin-top: 1em">-compile Mod1 Mod2 ...: <br>
Compiles the specified modules and then terminates (with
non-zero exit code if the compilation of some file did not
succeed). Implies -noinput.</p>

<p style="margin-top: 1em">Not recommended; use erlc
instead.</p>

<p style="margin-top: 1em">-config Config: <br>
Specifies the name of a configuration file, Config.config,
which is used to configure applications; see app(5) and
application(3erl).</p>

<p style="margin-top: 1em">-connect_all false: <br>
If this flag is present, global does not maintain a fully
connected network of distributed Erlang nodes, and then
global name registration cannot be used; see
global(3erl).</p>

<p style="margin-top: 1em">-cookie Cookie: <br>
Obsolete flag without any effect and common misspelling for
-setcookie. Use -setcookie instead.</p>

<p style="margin-top: 1em">-detached: <br>
Starts the Erlang runtime system detached from the system
console. Useful for running daemons and backgrounds
processes. Implies -noinput.</p>

<p style="margin-top: 1em">-emu_args: <br>
Useful for debugging. Prints the arguments sent to the
emulator.</p>

<p style="margin-top: 1em">-env Variable Value: <br>
Sets the host OS environment variable Variable to the value
Value for the Erlang runtime system. Example:</p>

<p style="margin-top: 1em">% erl -env DISPLAY gin:0</p>

<p style="margin-top: 1em">In this example, an Erlang
runtime system is started with environment variable DISPLAY
set to gin:0.</p>

<p style="margin-top: 1em">-epmd_module Module (init flag):
<br>
Configures the module responsible to communicate to epmd.
Defaults to erl_epmd.</p>

<p style="margin-top: 1em">-eval Expr (init flag): <br>
Makes init evaluate the expression Expr; see init(3erl).</p>

<p style="margin-top: 1em">-extra (init flag): <br>
Everything following -extra is considered plain arguments
and can be retrieved using init:get_plain_arguments/0.</p>

<p style="margin-top: 1em">-heart: <br>
Starts heartbeat monitoring of the Erlang runtime system;
see heart(3erl).</p>

<p style="margin-top: 1em">-hidden: <br>
Starts the Erlang runtime system as a hidden node, if it is
run as a distributed node. Hidden nodes always establish
hidden connections to all other nodes except for nodes in
<br>
the same global group. Hidden connections are not published
on any of the connected nodes, that is, none of the
connected nodes are part of the result from nodes/0 on the
<br>
other node. See also hidden global groups;
global_group(3erl).</p>

<p style="margin-top: 1em">-hosts Hosts: <br>
Specifies the IP addresses for the hosts on which Erlang
boot servers are running, see erl_boot_server(3erl). This
flag is mandatory if flag -loader inet is present.</p>

<p style="margin-top: 1em">The IP addresses must be
specified in the standard form (four decimal numbers
separated by periods, for example,
&quot;150.236.20.74&quot;. Hosts names are not acceptable,
but a broad&acirc; <br>
cast address (preferably limited to the local network)
is.</p>

<p style="margin-top: 1em">-id Id: <br>
Specifies the identity of the Erlang runtime system. If it
is run as a distributed node, Id must be identical to the
name supplied together with flag -sname or -name.</p>

<p style="margin-top: 1em">-init_debug: <br>
Makes init write some debug information while interpreting
the boot script.</p>

<p style="margin-top: 1em">-instr (emulator flag): <br>
Selects an instrumented Erlang runtime system (virtual
machine) to run, instead of the ordinary one. When running
an instrumented runtime system, some resource usage data can
<br>
be obtained and analyzed using the instrument module.
Functionally, it behaves exactly like an ordinary Erlang
runtime system.</p>

<p style="margin-top: 1em">-loader Loader: <br>
Specifies the method used by erl_prim_loader to load Erlang
modules into the system; see erl_prim_loader(3erl). Two
Loader methods are supported:</p>

<p style="margin-top: 1em">* efile, which means use the
local file system, this is the default.</p>

<p style="margin-top: 1em">* inet, which means use a boot
server on another machine. The flags -id, -hosts and
-setcookie must also be specified.</p>

<p style="margin-top: 1em">If Loader is something else, the
user-supplied Loader port program is started.</p>

<p style="margin-top: 1em">-make: <br>
Makes the Erlang runtime system invoke make:all() in the
current working directory and then terminate; see
make(3erl). Implies -noinput.</p>

<p style="margin-top: 1em">-man Module: <br>
Displays the manual page for the Erlang module Module. Only
supported on Unix.</p>

<p style="margin-top: 1em">-mode interactive | embedded:
<br>
Indicates if the system is to load code dynamically
(interactive), or if all code is to be loaded during system
initialization (embedded); see code(3erl). Defaults to
inter&acirc; <br>
active.</p>

<p style="margin-top: 1em">-name Name: <br>
Makes the Erlang runtime system into a distributed node.
This flag invokes all network servers necessary for a node
to become distributed; see net_kernel(3erl). It is also <br>
ensured that epmd runs on the current host before Erlang is
started; see epmd(1).and the -start_epmd option.</p>

<p style="margin-top: 1em">The node name will be Name@Host,
where Host is the fully qualified host name of the current
host. For short names, use flag -sname instead.</p>

<p style="margin-top: 1em">-noinput: <br>
Ensures that the Erlang runtime system never tries to read
any input. Implies -noshell.</p>

<p style="margin-top: 1em">-noshell: <br>
Starts an Erlang runtime system with no shell. This flag
makes it possible to have the Erlang runtime system as a
component in a series of Unix pipes.</p>

<p style="margin-top: 1em">-nostick: <br>
Disables the sticky directory facility of the Erlang code
server; see code(3erl).</p>

<p style="margin-top: 1em">-oldshell: <br>
Invokes the old Erlang shell from Erlang/OTP 3.3. The old
shell can still be used.</p>

<p style="margin-top: 1em">-pa Dir1 Dir2 ...: <br>
Adds the specified directories to the beginning of the code
path, similar to code:add_pathsa/1. Note that the order of
the given directories will be reversed in the resulting <br>
path.</p>

<p style="margin-top: 1em">As an alternative to -pa, if
several directories are to be prepended to the code path and
the directories have a common parent directory, that parent
directory can be speci&acirc; <br>
fied in environment variable ERL_LIBS; see code(3erl).</p>

<p style="margin-top: 1em">-pz Dir1 Dir2 ...: <br>
Adds the specified directories to the end of the code path,
similar to code:add_pathsz/1; see code(3erl).</p>

<p style="margin-top: 1em">-path Dir1 Dir2 ...: <br>
Replaces the path specified in the boot script; see
script(5).</p>

<p style="margin-top: 1em">-proto_dist Proto: <br>
Specifies a protocol for Erlang distribution:</p>

<p style="margin-top: 1em">inet_tcp: <br>
TCP over IPv4 (the default)</p>

<p style="margin-top: 1em">inet_tls: <br>
Distribution over TLS/SSL</p>

<p style="margin-top: 1em">inet6_tcp: <br>
TCP over IPv6</p>

<p style="margin-top: 1em">For example, to start up IPv6
distributed nodes:</p>

<p style="margin-top: 1em">% erl -name
test@ipv6node.example.com -proto_dist inet6_tcp</p>

<p style="margin-top: 1em">-remsh Node: <br>
Starts Erlang with a remote shell connected to Node.</p>

<p style="margin-top: 1em">-rsh Program: <br>
Specifies an alternative to rsh for starting a slave node on
a remote host; see slave(3erl).</p>

<p style="margin-top: 1em">-run Mod [Func [Arg1, Arg2,
...]] (init flag): <br>
Makes init call the specified function. Func defaults to
start. If no arguments are provided, the function is assumed
to be of arity 0. Otherwise it is assumed to be of arity
<br>
1, taking the list [Arg1,Arg2,...] as argument. All
arguments are passed as strings. See init(3erl).</p>

<p style="margin-top: 1em">-s Mod [Func [Arg1, Arg2, ...]]
(init flag): <br>
Makes init call the specified function. Func defaults to
start. If no arguments are provided, the function is assumed
to be of arity 0. Otherwise it is assumed to be of arity
<br>
1, taking the list [Arg1,Arg2,...] as argument. All
arguments are passed as atoms. See init(3erl).</p>

<p style="margin-top: 1em">-setcookie Cookie: <br>
Sets the magic cookie of the node to Cookie; see
erlang:set_cookie/2.</p>

<p style="margin-top: 1em">-shutdown_time Time: <br>
Specifies how long time (in milliseconds) the init process
is allowed to spend shutting down the system. If Time
milliseconds have elapsed, all processes still existing are
<br>
killed. Defaults to infinity.</p>

<p style="margin-top: 1em">-sname Name: <br>
Makes the Erlang runtime system into a distributed node,
similar to -name, but the host name portion of the node name
Name@Host will be the short name, not fully qualified.</p>

<p style="margin-top: 1em">This is sometimes the only way
to run distributed Erlang if the Domain Name System (DNS) is
not running. No communication can exist between nodes
running with flag -sname and <br>
those running with flag -name, as node names must be unique
in distributed Erlang systems.</p>

<p style="margin-top: 1em">-start_epmd true | false: <br>
Specifies whether Erlang should start epmd on startup. By
default this is true, but if you prefer to start epmd
manually, set this to false.</p>

<p style="margin-top: 1em">This only applies if Erlang is
started as a distributed node, i.e. if -name or -sname is
specified. Otherwise, epmd is not started even if
-start_epmd true is given.</p>

<p style="margin-top: 1em">Note that a distributed node
will fail to start if epmd is not running.</p>

<p style="margin-top: 1em">-smp [enable|auto|disable]: <br>
-smp enable and -smp start the Erlang runtime system with
SMP support enabled. This can fail if no runtime system with
SMP support is available. -smp auto starts the Erlang <br>
runtime system with SMP support enabled if it is available
and more than one logical processor is detected. -smp
disable starts a runtime system without SMP support.</p>

<p style="margin-top: 1em">Note: <br>
The runtime system with SMP support is not available on all
supported platforms. See also flag +S.</p>

<p style="margin-top: 1em">-version (emulator flag): <br>
Makes the emulator print its version number. The same as erl
+V.</p>

<p style="margin-top: 1em">EMULATOR FLAGS <br>
erl invokes the code for the Erlang emulator (virtual
machine), which supports the following flags:</p>

<p style="margin-top: 1em">+a size: <br>
Suggested stack size, in kilowords, for threads in the async
thread pool. Valid range is 16-8192 kilowords. The default
suggested stack size is 16 kilowords, that is, 64 <br>
kilobyte on 32-bit architectures. This small default size
has been chosen because the number of async threads can be
large. The default size is enough for drivers delivered <br>
with Erlang/OTP, but might not be large enough for other
dynamically linked-in drivers that use the driver_async()
functionality. Notice that the value passed is only a
sug&acirc; <br>
gestion, and it can even be ignored on some platforms.</p>

<p style="margin-top: 1em">+A size: <br>
Sets the number of threads in async thread pool. Valid range
is 0-1024. Defaults to 10 if thread support is
available.</p>

<p style="margin-top: 1em">+B [c | d | i]: <br>
Option c makes Ctrl-C interrupt the current shell instead of
invoking the emulator break handler. Option d (same as
specifying +B without an extra option) disables the break
<br>
handler. Option i makes the emulator ignore any break
signal.</p>

<p style="margin-top: 1em">If option c is used with
oldshell on Unix, Ctrl-C will restart the shell process
rather than interrupt it.</p>

<p style="margin-top: 1em">Notice that on Windows, this
flag is only applicable for werl, not erl (oldshell). Notice
also that Ctrl-Break is used instead of Ctrl-C on
Windows.</p>

<p style="margin-top: 1em">+c true | false: <br>
Enables or disables time correction:</p>

<p style="margin-top: 1em">true: <br>
Enables time correction. This is the default if time
correction is supported on the specific platform.</p>

<p style="margin-top: 1em">false: <br>
Disables time correction.</p>

<p style="margin-top: 1em">For backward compatibility, the
boolean value can be omitted. This is interpreted as +c
false.</p>

<p style="margin-top: 1em">+C no_time_warp |
single_time_warp | multi_time_warp: <br>
Sets time warp mode:</p>

<p style="margin-top: 1em">no_time_warp: <br>
No time warp mode (the default)</p>

<p style="margin-top: 1em">single_time_warp: <br>
Single time warp mode</p>

<p style="margin-top: 1em">multi_time_warp: <br>
Multi-time warp mode</p>

<p style="margin-top: 1em">+d: <br>
If the emulator detects an internal error (or runs out of
memory), it, by default, generates both a crash dump and a
core dump. The core dump is, however, not very useful as
<br>
the content of process heaps is destroyed by the crash dump
generation.</p>

<p style="margin-top: 1em">Option +d instructs the emulator
to produce only a core dump and no crash dump if an internal
error is detected.</p>

<p style="margin-top: 1em">Calling erlang:halt/1 with a
string argument still produces a crash dump. On Unix
systems, sending an emulator process a SIGUSR1 signal also
forces a crash dump.</p>

<p style="margin-top: 1em">+e Number: <br>
Sets the maximum number of ETS tables.</p>

<p style="margin-top: 1em">+ec: <br>
Forces option compressed on all ETS tables. Only intended
for test and evaluation.</p>

<p style="margin-top: 1em">+fnl: <br>
The virtual machine works with filenames as if they are
encoded using the ISO Latin-1 encoding, disallowing Unicode
characters with code points &gt; 255.</p>

<p style="margin-top: 1em">For more information about
Unicode filenames, see section Unicode Filenames in the
STDLIB User&rsquo;s Guide. Notice that this value also
applies to command-line parameters and <br>
environment variables (see section Unicode in Enviroment and
Parameters in the STDLIB User&rsquo;s Guide).</p>

<p style="margin-top: 1em">+fnu[{w|i|e}]: <br>
The virtual machine works with filenames as if they are
encoded using UTF-8 (or some other system-specific Unicode
encoding). This is the default on operating systems that
<br>
enforce Unicode encoding, that is, Windows and MacOS X.</p>

<p style="margin-top: 1em">The +fnu switch can be followed
by w, i, or e to control how wrongly encoded filenames are
to be reported:</p>

<p style="margin-top: 1em">* w means that a warning is sent
to the error_logger whenever a wrongly encoded filename is
&quot;skipped&quot; in directory listings. This is the
default.</p>

<p style="margin-top: 1em">* i means that those wrongly
encoded filenames are silently ignored.</p>

<p style="margin-top: 1em">* e means that the API function
returns an error whenever a wrongly encoded filename (or
directory name) is encountered.</p>

<p style="margin-top: 1em">Notice that file:read_link/1
always returns an error if the link points to an invalid
filename.</p>

<p style="margin-top: 1em">For more information about
Unicode filenames, see section Unicode Filenames in the
STDLIB User&rsquo;s Guide. Notice that this value also
applies to command-line parameters and <br>
environment variables (see section Unicode in Enviroment and
Parameters in the STDLIB User&rsquo;s Guide).</p>

<p style="margin-top: 1em">+fna[{w|i|e}]: <br>
Selection between +fnl and +fnu is done based on the current
locale settings in the OS. This means that if you have set
your terminal for UTF-8 encoding, the filesystem is <br>
expected to use the same encoding for filenames. This is
default on all operating systems, except MacOS X and
Windows.</p>

<p style="margin-top: 1em">The +fna switch can be followed
by w, i, or e. This has effect if the locale settings cause
the behavior of +fnu to be selected; see the description of
+fnu above. If the <br>
locale settings cause the behavior of +fnl to be selected,
then w, i, or e have no effect.</p>

<p style="margin-top: 1em">For more information about
Unicode filenames, see section Unicode Filenames in the
STDLIB User&rsquo;s Guide. Notice that this value also
applies to command-line parameters and <br>
environment variables (see section Unicode in Enviroment and
Parameters in the STDLIB User&rsquo;s Guide).</p>

<p style="margin-top: 1em">+hms Size: <br>
Sets the default heap size of processes to the size
Size.</p>

<p style="margin-top: 1em">+hmbs Size: <br>
Sets the default binary virtual heap size of processes to
the size Size.</p>

<p style="margin-top: 1em">+hmax Size: <br>
Sets the default maximum heap size of processes to the size
Size. Defaults to 0, which means that no maximum heap size
is used. For more information, see <br>
process_flag(max_heap_size, MaxHeapSize).</p>

<p style="margin-top: 1em">+hmaxel true|false: <br>
Sets whether to send an error logger message or not for
processes reaching the maximum heap size. Defaults to true.
For more information, see process_flag(max_heap_size,
Max&acirc; <br>
HeapSize).</p>

<p style="margin-top: 1em">+hmaxk true|false: <br>
Sets whether to kill processes reaching the maximum heap
size or not. Default to true. For more information, see
process_flag(max_heap_size, MaxHeapSize).</p>

<p style="margin-top: 1em">+hpds Size: <br>
Sets the initial process dictionary size of processes to the
size Size.</p>

<p style="margin-top: 1em">+hmqd off_heap|on_heap: <br>
Sets the default value for process flag message_queue_data.
Defaults to on_heap. If +hmqd is not passed, on_heap will be
the default. For more information, see <br>
process_flag(message_queue_data, MQD).</p>

<p style="margin-top: 1em">+K true | false: <br>
Enables or disables the kernel poll functionality if
supported by the emulator. Defaults to false (disabled). If
the emulator does not support kernel poll, and flag +K is
<br>
passed to the emulator, a warning is issued at startup.</p>

<p style="margin-top: 1em">+l: <br>
Enables autoload tracing, displaying information while
loading code.</p>

<p style="margin-top: 1em">+L: <br>
Prevents loading information about source filenames and line
numbers. This saves some memory, but exceptions do not
contain information about the filenames and line
numbers.</p>

<p style="margin-top: 1em">+MFlag Value: <br>
Memory allocator-specific flags. For more information, see
erts_alloc(3erl).</p>

<p style="margin-top: 1em">+pc Range: <br>
Sets the range of characters that the system considers
printable in heuristic detection of strings. This typically
affects the shell, debugger, and io:format functions (when
<br>
~tp is used in the format string).</p>

<p style="margin-top: 1em">Two values are supported for
Range:</p>

<p style="margin-top: 1em">latin1: <br>
The default. Only characters in the ISO Latin-1 range can be
considered printable. This means that a character with a
code point &gt; 255 is never considered printable and <br>
that lists containing such characters are displayed as lists
of integers rather than text strings by tools.</p>

<p style="margin-top: 1em">unicode: <br>
All printable Unicode characters are considered when
determining if a list of integers is to be displayed in
string syntax. This can give unexpected results if, for
exam&acirc; <br>
ple, your font does not cover all Unicode characters.</p>

<p style="margin-top: 1em">See also io:printable_range/0 in
STDLIB.</p>

<p style="margin-top: 1em">+P Number: <br>
Sets the maximum number of simultaneously existing processes
for this system if a Number is passed as value. Valid range
for Number is [1024-134217727]</p>

<p style="margin-top: 1em">NOTE: The actual maximum chosen
may be much larger than the Number passed. Currently the
runtime system often, but not always, chooses a value that
is a power of 2. This <br>
might, however, be changed in the future. The actual value
chosen can be checked by calling
erlang:system_info(process_limit).</p>

<p style="margin-top: 1em">The default value is 262144</p>

<p style="margin-top: 1em">+Q Number: <br>
Sets the maximum number of simultaneously existing ports for
this system if a Number is passed as value. Valid range for
Number is [1024-134217727]</p>

<p style="margin-top: 1em">NOTE: The actual maximum chosen
may be much larger than the actual Number passed. Currently
the runtime system often, but not always, chooses a value
that is a power of 2. <br>
This might, however, be changed in the future. The actual
value chosen can be checked by calling
erlang:system_info(port_limit).</p>

<p style="margin-top: 1em">The default value used is
normally 65536. However, if the runtime system is able to
determine maximum amount of file descriptors that it is
allowed to open and this value is <br>
larger than 65536, the chosen value will increased to a
value larger or equal to the maximum amount of file
descriptors that can be opened.</p>

<p style="margin-top: 1em">On Windows the default value is
set to 8196 because the normal OS limitations are set higher
than most machines can handle.</p>

<p style="margin-top: 1em">+R ReleaseNumber: <br>
Sets the compatibility mode.</p>

<p style="margin-top: 1em">The distribution mechanism is
not backward compatible by default. This flag sets the
emulator in compatibility mode with an earlier Erlang/OTP
release ReleaseNumber. The <br>
release number must be in the range &lt;current
release&gt;-2..&lt;current release&gt;. This limits the
emulator, making it possible for it to communicate with
Erlang nodes (as well as <br>
C- and Java nodes) running that earlier release.</p>

<p style="margin-top: 1em">Note: <br>
Ensure that all nodes (Erlang-, C-, and Java nodes) of a
distributed Erlang system is of the same Erlang/OTP release,
or from two different Erlang/OTP releases X and Y, where
<br>
all Y nodes have compatibility mode X.</p>

<p style="margin-top: 1em">+r: <br>
Forces ETS memory block to be moved on realloc.</p>

<p style="margin-top: 1em">+rg ReaderGroupsLimit: <br>
Limits the number of reader groups used by read/write locks
optimized for read operations in the Erlang runtime system.
By default the reader groups limit is 64.</p>

<p style="margin-top: 1em">When the number of schedulers is
less than or equal to the reader groups limit, each
scheduler has its own reader group. When the number of
schedulers is larger than the <br>
reader groups limit, schedulers share reader groups. Shared
reader groups degrade read lock and read unlock performance
while many reader groups degrade write lock perfor&acirc;
<br>
mance. So, the limit is a tradeoff between performance for
read operations and performance for write operations. Each
reader group consumes 64 byte in each read/write lock.</p>

<p style="margin-top: 1em">Notice that a runtime system
using shared reader groups benefits from binding schedulers
to logical processors, as the reader groups are distributed
better between sched&acirc; <br>
ulers.</p>

<p style="margin-top: 1em">+S Schedulers:SchedulerOnline:
<br>
Sets the number of scheduler threads to create and scheduler
threads to set online when SMP support has been enabled. The
maximum for both values is 1024. If the Erlang run&acirc;
<br>
time system is able to determine the number of logical
processors configured and logical processors available,
Schedulers defaults to logical processors configured, and
<br>
SchedulersOnline defaults to logical processors available;
otherwise the default values are 1. Schedulers can be
omitted if :SchedulerOnline is not and conversely. The
number <br>
of schedulers online can be changed at runtime through
erlang:system_flag(schedulers_online, SchedulersOnline).</p>

<p style="margin-top: 1em">If Schedulers or
SchedulersOnline is specified as a negative number, the
value is subtracted from the default number of logical
processors configured or logical processors <br>
available, respectively.</p>

<p style="margin-top: 1em">Specifying value 0 for
Schedulers or SchedulersOnline resets the number of
scheduler threads or scheduler threads online, respectively,
to its default value.</p>

<p style="margin-top: 1em">This option is ignored if the
emulator does not have SMP support enabled (see flag
-smp).</p>

<p style="margin-top: 1em">+SP
SchedulersPercentage:SchedulersOnlinePercentage: <br>
Similar to +S but uses percentages to set the number of
scheduler threads to create, based on logical processors
configured, and scheduler threads to set online, based on
<br>
logical processors available, when SMP support has been
enabled. Specified values must be &gt; 0. For example, +SP
50:25 sets the number of scheduler threads to 50% of the
logi&acirc; <br>
cal processors configured, and the number of scheduler
threads online to 25% of the logical processors available.
SchedulersPercentage can be omitted if
:SchedulersOnlinePer&acirc; <br>
centage is not and conversely. The number of schedulers
online can be changed at runtime through
erlang:system_flag(schedulers_online, SchedulersOnline).</p>

<p style="margin-top: 1em">This option interacts with +S
settings. For example, on a system with 8 logical cores
configured and 8 logical cores available, the combination of
the options +S 4:4 +SP <br>
50:25 (in either order) results in 2 scheduler threads (50%
of 4) and 1 scheduler thread online (25% of 4).</p>

<p style="margin-top: 1em">This option is ignored if the
emulator does not have SMP support enabled (see flag
-smp).</p>

<p style="margin-top: 1em">+SDcpu
DirtyCPUSchedulers:DirtyCPUSchedulersOnline: <br>
Sets the number of dirty CPU scheduler threads to create and
dirty CPU scheduler threads to set online when threading
support has been enabled. The maximum for both values is
<br>
1024, and each value is further limited by the settings for
normal schedulers:</p>

<p style="margin-top: 1em">* The number of dirty CPU
scheduler threads created cannot exceed the number of normal
scheduler threads created.</p>

<p style="margin-top: 1em">* The number of dirty CPU
scheduler threads online cannot exceed the number of normal
scheduler threads online.</p>

<p style="margin-top: 1em">For details, see the +S and +SP.
By default, the number of dirty CPU scheduler threads
created equals the number of normal scheduler threads
created, and the number of dirty <br>
CPU scheduler threads online equals the number of normal
scheduler threads online. DirtyCPUSchedulers can be omitted
if :DirtyCPUSchedulersOnline is not and conversely. The <br>
number of dirty CPU schedulers online can be changed at
runtime through
erlang:system_flag(dirty_cpu_schedulers_online,
DirtyCPUSchedulersOnline).</p>

<p style="margin-top: 1em">The amount of dirty CPU
schedulers is limited by the amount of normal schedulers in
order to limit the effect on processes executing on ordinary
schedulers. If the amount of <br>
dirty CPU schedulers was allowed to be unlimited, dirty CPU
bound jobs would potentially starve normal jobs.</p>

<p style="margin-top: 1em">This option is ignored if the
emulator does not have threading support enabled. This
option is experimental and is supported only if the emulator
was configured and built <br>
with support for dirty schedulers enabled (it is disabled by
default).</p>

<p style="margin-top: 1em">+SDPcpu
DirtyCPUSchedulersPercentage:DirtyCPUSchedulersOnlinePercentage:
<br>
Similar to +SDcpu but uses percentages to set the number of
dirty CPU scheduler threads to create and the number of
dirty CPU scheduler threads to set online when threading
<br>
support has been enabled. Specified values must be &gt; 0.
For example, +SDPcpu 50:25 sets the number of dirty CPU
scheduler threads to 50% of the logical processors
configured <br>
and the number of dirty CPU scheduler threads online to 25%
of the logical processors available.
DirtyCPUSchedulersPercentage can be omitted if
:DirtyCPUSchedulersOnlinePer&acirc; <br>
centage is not and conversely. The number of dirty CPU
schedulers online can be changed at runtime through
erlang:system_flag(dirty_cpu_schedulers_online,
DirtyCPUScheduler&acirc; <br>
sOnline).</p>

<p style="margin-top: 1em">This option interacts with
+SDcpu settings. For example, on a system with 8 logical
cores configured and 8 logical cores available, the
combination of the options +SDcpu 4:4 <br>
+SDPcpu 50:25 (in either order) results in 2 dirty CPU
scheduler threads (50% of 4) and 1 dirty CPU scheduler
thread online (25% of 4).</p>

<p style="margin-top: 1em">This option is ignored if the
emulator does not have threading support enabled. This
option is experimental and is supported only if the emulator
was configured and built <br>
with support for dirty schedulers enabled (it is disabled by
default).</p>

<p style="margin-top: 1em">+SDio DirtyIOSchedulers: <br>
Sets the number of dirty I/O scheduler threads to create
when threading support has been enabled. Valid range is
0-1024. By default, the number of dirty I/O scheduler
threads <br>
created is 10, same as the default number of threads in the
async thread pool.</p>

<p style="margin-top: 1em">The amount of dirty IO
schedulers is not limited by the amount of normal schedulers
like the amount of dirty CPU schedulers. This since only I/O
bound work is expected to <br>
execute on dirty I/O schedulers. If the user should schedule
CPU bound jobs on dirty I/O schedulers, these jobs might
starve ordinary jobs executing on ordinary schedulers.</p>

<p style="margin-top: 1em">This option is ignored if the
emulator does not have threading support enabled. This
option is experimental and is supported only if the emulator
was configured and built <br>
with support for dirty schedulers enabled (it is disabled by
default).</p>

<p style="margin-top: 1em">+sFlag Value: <br>
Scheduling specific flags.</p>

<p style="margin-top: 1em">+sbt BindType: <br>
Sets scheduler bind type.</p>

<p style="margin-top: 1em">Schedulers can also be bound
using flag +stbt. The only difference between these two
flags is how the following errors are handled:</p>

<p style="margin-top: 1em">* Binding of schedulers is not
supported on the specific platform.</p>

<p style="margin-top: 1em">* No available CPU topology.
That is, the runtime system was not able to detect the CPU
topology automatically, and no user-defined CPU topology was
set.</p>

<p style="margin-top: 1em">If any of these errors occur
when +sbt has been passed, the runtime system prints an
error message, and refuses to start. If any of these errors
occur when +stbt has been <br>
passed, the runtime system silently ignores the error, and
start up using unbound schedulers.</p>

<p style="margin-top: 1em">Valid BindTypes:</p>

<p style="margin-top: 1em">u: <br>
unbound - Schedulers are not bound to logical processors,
that is, the operating system decides where the scheduler
threads execute, and when to migrate them. This is the <br>
default.</p>

<p style="margin-top: 1em">ns: <br>
no_spread - Schedulers with close scheduler identifiers are
bound as close as possible in hardware.</p>

<p style="margin-top: 1em">ts: <br>
thread_spread - Thread refers to hardware threads (such as
Intel&rsquo;s hyper-threads). Schedulers with low scheduler
identifiers, are bound to the first hardware thread of <br>
each core, then schedulers with higher scheduler identifiers
are bound to the second hardware thread of each core,and so
on.</p>

<p style="margin-top: 1em">ps: <br>
processor_spread - Schedulers are spread like thread_spread,
but also over physical processor chips.</p>

<p style="margin-top: 1em">s: <br>
spread - Schedulers are spread as much as possible.</p>

<p style="margin-top: 1em">nnts: <br>
no_node_thread_spread - Like thread_spread, but if multiple
Non-Uniform Memory Access (NUMA) nodes exist, schedulers are
spread over one NUMA node at a time, that is, all <br>
logical processors of one NUMA node are bound to schedulers
in sequence.</p>

<p style="margin-top: 1em">nnps: <br>
no_node_processor_spread - Like processor_spread, but if
multiple NUMA nodes exist, schedulers are spread over one
NUMA node at a time, that is, all logical processors of <br>
one NUMA node are bound to schedulers in sequence.</p>

<p style="margin-top: 1em">tnnps: <br>
thread_no_node_processor_spread - A combination of
thread_spread, and no_node_processor_spread. Schedulers are
spread over hardware threads across NUMA nodes, but
sched&acirc; <br>
ulers are only spread over processors internally in one NUMA
node at a time.</p>

<p style="margin-top: 1em">db: <br>
default_bind - Binds schedulers the default way. Defaults to
thread_no_node_processor_spread (which can change in the
future).</p>

<p style="margin-top: 1em">Binding of schedulers is only
supported on newer Linux, Solaris, FreeBSD, and Windows
systems.</p>

<p style="margin-top: 1em">If no CPU topology is available
when flag +sbt is processed and BindType is any other type
than u, the runtime system fails to start. CPU topology can
be defined using flag <br>
+sct. Notice that flag +sct can have to be passed before
flag +sbt on the command line (if no CPU topology has been
automatically detected).</p>

<p style="margin-top: 1em">The runtime system does by
default not bind schedulers to logical processors.</p>

<p style="margin-top: 1em">Note: <br>
If the Erlang runtime system is the only operating system
process that binds threads to logical processors, this
improves the performance of the runtime system. However, if
<br>
other operating system processes (for example another Erlang
runtime system) also bind threads to logical processors,
there can be a performance penalty instead. This
perfor&acirc; <br>
mance penalty can sometimes be severe. If so, you are
advised not to bind the schedulers.</p>

<p style="margin-top: 1em">How schedulers are bound
matters. For example, in situations when there are fewer
running processes than schedulers online, the runtime system
tries to migrate processes to <br>
schedulers with low scheduler identifiers. The more the
schedulers are spread over the hardware, the more resources
are available to the runtime system in such situations.</p>

<p style="margin-top: 1em">Note: <br>
If a scheduler fails to bind, this is often silently
ignored, as it is not always possible to verify valid
logical processor identifiers. If an error is reported, it
is <br>
reported to the error_logger. If you want to verify that the
schedulers have bound as requested, call
erlang:system_info(scheduler_bindings).</p>

<p style="margin-top: 1em">+sbwt
none|very_short|short|medium|long|very_long: <br>
Sets scheduler busy wait threshold. Defaults to medium. The
threshold determines how long schedulers are to busy wait
when running out of work before going to sleep.</p>

<p style="margin-top: 1em">Note: <br>
This flag can be removed or changed at any time without
prior notice.</p>

<p style="margin-top: 1em">+scl true|false: <br>
Enables or disables scheduler compaction of load. By default
scheduler compaction of load is enabled. When enabled, load
balancing strives for a load distribution, which <br>
causes as many scheduler threads as possible to be fully
loaded (that is, not run out of work). This is accomplished
by migrating load (for example, runnable processes) <br>
into a smaller set of schedulers when schedulers frequently
run out of work. When disabled, the frequency with which
schedulers run out of work is not taken into account by <br>
the load balancing logic.</p>

<p style="margin-top: 1em">+scl false is similar to +sub
true, but +sub true also balances scheduler utilization
between schedulers.</p>

<p style="margin-top: 1em">+sct CpuTopology:</p>

<p style="margin-top: 1em">* &lt;Id&gt; = integer(); when 0
=&lt; &lt;Id&gt; =&lt; 65535</p>

<p style="margin-top: 1em">* &lt;IdRange&gt; =
&lt;Id&gt;-&lt;Id&gt;</p>

<p style="margin-top: 1em">* &lt;IdOrIdRange&gt; =
&lt;Id&gt; | &lt;IdRange&gt;</p>

<p style="margin-top: 1em">* &lt;IdList&gt; =
&lt;IdOrIdRange&gt;,&lt;IdOrIdRange&gt; |
&lt;IdOrIdRange&gt;</p>

<p style="margin-top: 1em">* &lt;LogicalIds&gt; =
L&lt;IdList&gt;</p>

<p style="margin-top: 1em">* &lt;ThreadIds&gt; =
T&lt;IdList&gt; | t&lt;IdList&gt;</p>

<p style="margin-top: 1em">* &lt;CoreIds&gt; =
C&lt;IdList&gt; | c&lt;IdList&gt;</p>

<p style="margin-top: 1em">* &lt;ProcessorIds&gt; =
P&lt;IdList&gt; | p&lt;IdList&gt;</p>

<p style="margin-top: 1em">* &lt;NodeIds&gt; =
N&lt;IdList&gt; | n&lt;IdList&gt;</p>

<p style="margin-top: 1em">* &lt;IdDefs&gt; =
&lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;ProcessorIds&gt;&lt;NodeIds&gt;
|
&lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;NodeIds&gt;&lt;ProcessorIds&gt;</p>

<p style="margin-top: 1em">* CpuTopology =
&lt;IdDefs&gt;:&lt;IdDefs&gt; | &lt;IdDefs&gt;</p>

<p style="margin-top: 1em">Sets a user-defined CPU
topology. The user-defined CPU topology overrides any
automatically detected CPU topology. The CPU topology is
used when binding schedulers to logi&acirc; <br>
cal processors.</p>

<p style="margin-top: 1em">Uppercase letters signify real
identifiers and lowercase letters signify fake identifiers
only used for description of the topology. Identifiers
passed as real identifiers <br>
can be used by the runtime system when trying to access
specific hardware; if they are incorrect the behavior is
undefined. Faked logical CPU identifiers are not accepted,
<br>
as there is no point in defining the CPU topology without
real logical CPU identifiers. Thread, core, processor, and
node identifiers can be omitted. If omitted, the thread <br>
ID defaults to t0, the core ID defaults to c0, the processor
ID defaults to p0, and the node ID is left undefined. Either
each logical processor must belong to only one <br>
NUMA node, or no logical processors must belong to any NUMA
nodes.</p>

<p style="margin-top: 1em">Both increasing and decreasing
&lt;IdRange&gt;s are allowed.</p>

<p style="margin-top: 1em">NUMA node identifiers are system
wide. That is, each NUMA node on the system must have a
unique identifier. Processor identifiers are also system
wide. Core identifiers are <br>
processor wide. Thread identifiers are core wide.</p>

<p style="margin-top: 1em">The order of the identifier
types implies the hierarchy of the CPU topology. The valid
orders are as follows:</p>

<p style="margin-top: 1em">*
&lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;ProcessorIds&gt;&lt;NodeIds&gt;,
that is, thread is part of a core that is part of a
processor, which is part of a NUMA node.</p>

<p style="margin-top: 1em">*
&lt;LogicalIds&gt;&lt;ThreadIds&gt;&lt;CoreIds&gt;&lt;NodeIds&gt;&lt;ProcessorIds&gt;,
that is, thread is part of a core that is part of a NUMA
node, which is part of a processor.</p>

<p style="margin-top: 1em">A CPU topology can consist of
both processor external, and processor internal NUMA nodes
as long as each logical processor belongs to only one NUMA
node. If &lt;ProcessorIds&gt; <br>
is omitted, its default position is before &lt;NodeIds&gt;.
That is, the default is processor external NUMA nodes.</p>

<p style="margin-top: 1em">If a list of identifiers is used
in an &lt;IdDefs&gt;:</p>

<p style="margin-top: 1em">* &lt;LogicalIds&gt; must be a
list of identifiers.</p>

<p style="margin-top: 1em">* At least one other identifier
type besides &lt;LogicalIds&gt; must also have a list of
identifiers.</p>

<p style="margin-top: 1em">* All lists of identifiers must
produce the same number of identifiers.</p>

<p style="margin-top: 1em">A simple example. A single quad
core processor can be described as follows:</p>

<p style="margin-top: 1em">% erl +sct L0-3c0-3 <br>
1&gt; erlang:system_info(cpu_topology). <br>
[{processor,[{core,{logical,0}}, <br>
{core,{logical,1}}, <br>
{core,{logical,2}}, <br>
{core,{logical,3}}]}]</p>

<p style="margin-top: 1em">A more complicated example with
two quad core processors, each processor in its own NUMA
node. The ordering of logical processors is a bit weird.
This to give a better <br>
example of identifier lists:</p>

<p style="margin-top: 1em">% erl +sct
L0-1,3-2c0-3p0N0:L7,4,6-5c0-3p1N1 <br>
1&gt; erlang:system_info(cpu_topology). <br>
[{node,[{processor,[{core,{logical,0}}, <br>
{core,{logical,1}}, <br>
{core,{logical,3}}, <br>
{core,{logical,2}}]}]}, <br>
{node,[{processor,[{core,{logical,7}}, <br>
{core,{logical,4}}, <br>
{core,{logical,6}}, <br>
{core,{logical,5}}]}]}]</p>

<p style="margin-top: 1em">As long as real identifiers are
correct, it is OK to pass a CPU topology that is not a
correct description of the CPU topology. When used with care
this can be very useful. <br>
This to trick the emulator to bind its schedulers as you
want. For example, if you want to run multiple Erlang
runtime systems on the same machine, you want to reduce the
<br>
number of schedulers used and manipulate the CPU topology so
that they bind to different logical CPUs. An example, with
two Erlang runtime systems on a quad core machine:</p>

<p style="margin-top: 1em">% erl +sct L0-3c0-3 +sbt db
+S3:2 -detached -noinput -noshell -sname one <br>
% erl +sct L3-0c0-3 +sbt db +S3:2 -detached -noinput
-noshell -sname two</p>

<p style="margin-top: 1em">In this example, each runtime
system have two schedulers each online, and all schedulers
online will run on different cores. If we change to one
scheduler online on one <br>
runtime system, and three schedulers online on the other,
all schedulers online will still run on different cores.</p>

<p style="margin-top: 1em">Notice that a faked CPU topology
that does not reflect how the real CPU topology looks like
is likely to decrease the performance of the runtime
system.</p>

<p style="margin-top: 1em">For more information, see
erlang:system_info(cpu_topology).</p>

<p style="margin-top: 1em">+secio true|false: <br>
Enables or disables eager check I/O scheduling. Defaults to
true. The default was changed from false as from ERTS 7.0.
The behavior before this flag was introduced corre&acirc;
<br>
sponds to +secio false.</p>

<p style="margin-top: 1em">The flag effects when schedulers
will check for I/O operations possible to execute, and when
such I/O operations will execute. As the parameter name
implies, schedulers are <br>
more eager to check for I/O when true is passed. This,
however, also implies that execution of outstanding I/O
operation is not prioritized to the same extent as when
false <br>
is passed.</p>


<p style="margin-top: 1em">erlang:system_info(eager_check_io)
returns the value of this parameter used when starting the
virtual machine.</p>

<p style="margin-top: 1em">+sfwi Interval: <br>
Sets scheduler-forced wakeup interval. All run queues are
scanned each Interval milliseconds. While there are sleeping
schedulers in the system, one scheduler is woken for <br>
each non-empty run queue found. Interval default to 0,
meaning this feature is disabled.</p>

<p style="margin-top: 1em">Note: <br>
This feature has been introduced as a temporary workaround
for long-executing native code, and native code that does
not bump reductions properly in OTP. When these bugs have
<br>
be fixed, this flag will be removed.</p>

<p style="margin-top: 1em">+spp Bool: <br>
Sets default scheduler hint for port parallelism. If set to
true, the virtual machine schedules port tasks when it
improves parallelism in the system. If set to false, the
<br>
virtual machine tries to perform port tasks immediately,
improving latency at the expense of parallelism. Default to
false. The default used can be inspected in runtime by <br>
calling erlang:system_info(port_parallelism). The default
can be overridden on port creation by passing option
parallelism to erlang:open_port/2.</p>

<p style="margin-top: 1em">+sss size: <br>
Suggested stack size, in kilowords, for scheduler threads.
Valid range is 4-8192 kilowords. The default stack size is
OS-dependent.</p>

<p style="margin-top: 1em">+stbt BindType: <br>
Tries to set the scheduler bind type. The same as flag +sbt
except how some errors are handled. For more information,
see +sbt.</p>

<p style="margin-top: 1em">+sub true|false: <br>
Enables or disables scheduler utilization balancing of load.
By default scheduler utilization balancing is disabled and
instead scheduler compaction of load is enabled, <br>
which strives for a load distribution that causes as many
scheduler threads as possible to be fully loaded (that is,
not run out of work). When scheduler utilization bal&acirc;
<br>
ancing is enabled, the system instead tries to balance
scheduler utilization between schedulers. That is, strive
for equal scheduler utilization on all schedulers.</p>

<p style="margin-top: 1em">+sub true is only supported on
systems where the runtime system detects and uses a
monotonically increasing high-resolution clock. On other
systems, the runtime system <br>
fails to start.</p>

<p style="margin-top: 1em">+sub true implies +scl false.
The difference between +sub true and +scl false is that +scl
false does not try to balance the scheduler utilization.</p>

<p style="margin-top: 1em">+swct
very_eager|eager|medium|lazy|very_lazy: <br>
Sets scheduler wake cleanup threshold. Defaults to medium.
Controls how eager schedulers are to be requesting wakeup
because of certain cleanup operations. When a lazy
set&acirc; <br>
ting is used, more outstanding cleanup operations can be
left undone while a scheduler is idling. When an eager
setting is used, schedulers are more frequently woken, <br>
potentially increasing CPU-utilization.</p>

<p style="margin-top: 1em">Note: <br>
This flag can be removed or changed at any time without
prior notice.</p>

<p style="margin-top: 1em">+sws default|legacy: <br>
Sets scheduler wakeup strategy. Default strategy changed in
ERTS 5.10 (Erlang/OTP R16A). This strategy was known as
proposal in Erlang/OTP R15. The legacy strategy was used
<br>
as default from R13 up to and including R15.</p>

<p style="margin-top: 1em">Note: <br>
This flag can be removed or changed at any time without
prior notice.</p>

<p style="margin-top: 1em">+swt
very_low|low|medium|high|very_high: <br>
Sets scheduler wakeup threshold. Defaults to medium. The
threshold determines when to wake up sleeping schedulers
when more work than can be handled by currently awake <br>
schedulers exists. A low threshold causes earlier wakeups,
and a high threshold causes later wakeups. Early wakeups
distribute work over multiple schedulers faster, but <br>
work does more easily bounce between schedulers.</p>

<p style="margin-top: 1em">Note: <br>
This flag can be removed or changed at any time without
prior notice.</p>

<p style="margin-top: 1em">+t size: <br>
Sets the maximum number of atoms the virtual machine can
handle. Defaults to 1,048,576.</p>

<p style="margin-top: 1em">+T Level: <br>
Enables modified timing and sets the modified timing level.
Valid range is 0-9. The timing of the runtime system is
changed. A high level usually means a greater change than
<br>
a low level. Changing the timing can be very useful for
finding timing-related bugs.</p>

<p style="margin-top: 1em">Modified timing affects the
following:</p>

<p style="margin-top: 1em">Process spawning: <br>
A process calling spawn, spawn_link, spawn_monitor, or
spawn_opt is scheduled out immediately after completing the
call. When higher modified timing levels are used, the <br>
caller also sleeps for a while after it is scheduled
out.</p>

<p style="margin-top: 1em">Context reductions: <br>
The number of reductions a process is allowed to use before
it is scheduled out is increased or reduced.</p>

<p style="margin-top: 1em">Input reductions: <br>
The number of reductions performed before checking I/O is
increased or reduced.</p>

<p style="margin-top: 1em">Note: <br>
Performance suffers when modified timing is enabled. This
flag is only intended for testing and debugging.</p>

<p style="margin-top: 1em">return_to and return_from trace
messages are lost when tracing on the spawn BIFs.</p>

<p style="margin-top: 1em">This flag can be removed or
changed at any time without prior notice.</p>

<p style="margin-top: 1em">+v: <br>
Verbose.</p>

<p style="margin-top: 1em">+V: <br>
Makes the emulator print its version number.</p>

<p style="margin-top: 1em">+W w | i | e: <br>
Sets the mapping of warning messages for error_logger.
Messages sent to the error logger using one of the warning
routines can be mapped to errors (+W e), warnings (+W w), or
<br>
information reports (+W i). Defaults to warnings. The
current mapping can be retrieved using
error_logger:warning_map/0. For more information, see
error_logger:warning_map/0 <br>
in Kernel.</p>

<p style="margin-top: 1em">+zFlag Value: <br>
Miscellaneous flags:</p>

<p style="margin-top: 1em">+zdbbl size: <br>
Sets the distribution buffer busy limit
(dist_buf_busy_limit) in kilobytes. Valid range is
1-2097151. Defaults to 1024.</p>

<p style="margin-top: 1em">A larger buffer limit allows
processes to buffer more outgoing messages over the
distribution. When the buffer limit has been reached,
sending processes will be suspended <br>
until the buffer size has shrunk. The buffer limit is per
distribution channel. A higher limit gives lower latency and
higher throughput at the expense of higher memory <br>
use.</p>

<p style="margin-top: 1em">+zdntgc time: <br>
Sets the delayed node table garbage collection time
(delayed_node_table_gc) in seconds. Valid values are either
infinity or an integer in the range 0-100000000. Defaults to
<br>
60.</p>

<p style="margin-top: 1em">Node table entries that are not
referred linger in the table for at least the amount of time
that this parameter determines. The lingering prevents
repeated deletions and <br>
insertions in the tables from occurring.</p>

<p style="margin-top: 1em">ENVIRONMENT VARIABLES <br>
ERL_CRASH_DUMP: <br>
If the emulator needs to write a crash dump, the value of
this variable is the filename of the crash dump file. If the
variable is not set, the name of the crash dump file is <br>
erl_crash.dump in the current directory.</p>

<p style="margin-top: 1em">ERL_CRASH_DUMP_NICE: <br>
Unix systems: If the emulator needs to write a crash dump,
it uses the value of this variable to set the nice value for
the process, thus lowering its priority. Valid range <br>
is 1-39 (higher values are replaced with 39). The highest
value, 39, gives the process the lowest priority.</p>

<p style="margin-top: 1em">ERL_CRASH_DUMP_SECONDS: <br>
Unix systems: This variable gives the number of seconds that
the emulator is allowed to spend writing a crash dump. When
the given number of seconds have elapsed, the emula&acirc;
<br>
tor is terminated by a SIGALRM signal.</p>

<p style="margin-top: 1em">If the variable is not set or
set to 0 seconds (ERL_CRASH_DUMP_SECONDS=0), the runtime
system does not even attempt to write the crash dump file.
It only terminates.</p>

<p style="margin-top: 1em">If the variable is set to
negative value, such as ERL_CRASH_DUMP_SECONDS=-1, the
runtime system waits indefinitely for the crash dump file to
be written.</p>

<p style="margin-top: 1em">This variable is used with
heart(3erl) if heart is running:</p>

<p style="margin-top: 1em">ERL_CRASH_DUMP_SECONDS=0: <br>
Suppresses the writing a crash dump file entirely, thus
rebooting the runtime system immediately. This is the same
as not setting the environment variable.</p>

<p style="margin-top: 1em">ERL_CRASH_DUMP_SECONDS=-1: <br>
Setting the environment variable to a negative value causes
the termination of the runtime system to wait until the
crash dump file has been completly written.</p>

<p style="margin-top: 1em">ERL_CRASH_DUMP_SECONDS=S: <br>
Waits for S seconds to complete the crash dump file and then
terminates the runtime system.</p>

<p style="margin-top: 1em">ERL_CRASH_DUMP_BYTES: <br>
This variable sets the maximum size of a crash dump file in
bytes. The crash dump will be truncated if this limit is
exceeded. If the variable is not set, no size limit is <br>
enforced by default. If the variable is set to 0, the
runtime system does not even attempt to write a crash dump
file.</p>

<p style="margin-top: 1em">Introduced in ERTS 8.1.2
(Erlang/OTP 19.2).</p>

<p style="margin-top: 1em">ERL_AFLAGS: <br>
The content of this variable is added to the beginning of
the command line for erl.</p>

<p style="margin-top: 1em">Flag -extra is treated in a
special way. Its scope ends at the end of the environment
variable content. Arguments following an -extra flag are
moved on the command line into <br>
section -extra, that is, the end of the command line
following an -extra flag.</p>

<p style="margin-top: 1em">ERL_ZFLAGS and ERL_FLAGS: <br>
The content of these variables are added to the end of the
command line for erl.</p>

<p style="margin-top: 1em">Flag -extra is treated in a
special way. Its scope ends at the end of the environment
variable content. Arguments following an -extra flag are
moved on the command line into <br>
section -extra, that is, the end of the command line
following an -extra flag.</p>

<p style="margin-top: 1em">ERL_LIBS: <br>
Contains a list of additional library directories that the
code server searches for applications and adds to the code
path; see code(3erl).</p>

<p style="margin-top: 1em">ERL_EPMD_ADDRESS: <br>
Can be set to a comma-separated list of IP addresses, in
which case the epmd daemon listens only on the specified
address(es) and on the loopback address (which is implicitly
<br>
added to the list if it has not been specified).</p>

<p style="margin-top: 1em">ERL_EPMD_PORT: <br>
Can contain the port number to use when communicating with
epmd. The default port works fine in most cases. A different
port can be specified to allow nodes of independent <br>
clusters to co-exist on the same host. All nodes in a
cluster must use the same epmd port number.</p>

<p style="margin-top: 1em">CONFIGURATION <br>
The standard Erlang/OTP system can be reconfigured to change
the default behavior on startup.</p>

<p style="margin-top: 1em">The .erlang startup file: <br>
When Erlang/OTP is started, the system searches for a file
named .erlang in the directory where Erlang/OTP is started.
If not found, the user&rsquo;s home directory is searched
for <br>
an .erlang file.</p>

<p style="margin-top: 1em">If an .erlang file is found, it
is assumed to contain valid Erlang expressions. These
expressions are evaluated as if they were input to the
shell.</p>

<p style="margin-top: 1em">A typical .erlang file contains
a set of search paths, for example:</p>

<p style="margin-top: 1em">io:format(&quot;executing user
profile in HOME/.erlang0,[]). <br>
code:add_path(&quot;/home/calvin/test/ebin&quot;). <br>
code:add_path(&quot;/home/hobbes/bigappl-1.2/ebin&quot;).
<br>
io:format(&quot;.erlang rc finished0,[]).</p>

<p style="margin-top: 1em">user_default and shell_default:
<br>
Functions in the shell that are not prefixed by a module
name are assumed to be functional objects (funs), built-in
functions (BIFs), or belong to the module user_default or
<br>
shell_default.</p>

<p style="margin-top: 1em">To include private shell
commands, define them in a module user_default and add the
following argument as the first line in the .erlang
file:</p>


<p style="margin-top: 1em">code:load_abs(&quot;..../user_default&quot;).</p>

<p style="margin-top: 1em">erl: <br>
If the contents of .erlang are changed and a private version
of user_default is defined, the Erlang/OTP environment can
be customized. More powerful changes can be made by <br>
supplying command-line arguments in the startup script erl.
For more information, see init(3erl).</p>

<p style="margin-top: 1em">SEE ALSO <br>
epmd(1), erl_prim_loader(3erl), erts_alloc(3erl),
init(3erl), application(3erl), auth(3erl), code(3erl),
erl_boot_server(3erl), heart(3erl), net_kernel(3erl),
make(3erl)</p>

<p style="margin-top: 1em">Ericsson AB erts 8.2.1
erl(1)</p>
<hr>
</body>
</html>
