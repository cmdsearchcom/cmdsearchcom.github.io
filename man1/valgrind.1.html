<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>VALGRIND(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">VALGRIND(1)</td>
    <td class="head-vol">Release 3.11.0</td>
    <td class="head-rtitle">VALGRIND(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
valgrind - a suite of tools for debugging and profiling programs
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<div class="Pp" style="margin-left: 9.00ex; text-indent: -9.00ex;"><b>valgrind</b>
  [ <i>valgrind-options</i>] [<b>your-program</b>]
  [<i>your-program-options</i>]</div>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>Valgrind</b> is a flexible program for debugging and profiling Linux
  executables. It consists of a core, which provides a synthetic CPU in
  software, and a series of debugging and profiling tools. The architecture is
  modular, so that new tools can be created easily and without disturbing the
  existing structure.
<div class="Pp"></div>
Some of the options described below work with all Valgrind tools, and some only
  work with a few or one. The section MEMCHECK OPTIONS and those below it
  describe tool-specific options.
<div class="Pp"></div>
This manual page covers only basic usage and options. For more comprehensive
  information, please see the HTML documentation on your system:
  $INSTALL/share/doc/valgrind/html/index.html, or online:
  http://www.valgrind.org/docs/manual/index.html.
<h1 class="Sh" title="Sh" id="TOOL_SELECTION_OPTIONS"><a class="selflink" href="#TOOL_SELECTION_OPTIONS">TOOL
  SELECTION OPTIONS</a></h1>
The single most important option.
<div class="Pp"></div>
<b>--tool=&lt;toolname&gt; [default: memcheck] </b>
<div style="margin-left: 4.00ex;">Run the Valgrind tool called <i>toolname</i>,
  e.g. memcheck, cachegrind, callgrind, helgrind, drd, massif, lackey, none,
  exp-sgcheck, exp-bbv, exp-dhat, etc.</div>
<h1 class="Sh" title="Sh" id="BASIC_OPTIONS"><a class="selflink" href="#BASIC_OPTIONS">BASIC
  OPTIONS</a></h1>
These options work with all tools.
<div class="Pp"></div>
<b>-h --help</b>
<div style="margin-left: 4.00ex;">Show help for all options, both for the core
  and for the selected tool. If the option is repeated it is equivalent to
  giving <b>--help-debug</b>.</div>
<div class="Pp"></div>
<b>--help-debug</b>
<div style="margin-left: 4.00ex;">Same as <b>--help</b>, but also lists
  debugging options which usually are only of use to Valgrind's
  developers.</div>
<div class="Pp"></div>
<b>--version</b>
<div style="margin-left: 4.00ex;">Show the version number of the Valgrind core.
  Tools can have their own version numbers. There is a scheme in place to ensure
  that tools only execute when the core version is one they are known to work
  with. This was done to minimise the chances of strange problems arising from
  tool-vs-core version incompatibilities.</div>
<div class="Pp"></div>
<b>-q</b>, <b>--quiet</b>
<div style="margin-left: 4.00ex;">Run silently, and only print error messages.
  Useful if you are running regression tests or have some other automated test
  machinery.</div>
<div class="Pp"></div>
<b>-v</b>, <b>--verbose</b>
<div style="margin-left: 4.00ex;">Be more verbose. Gives extra information on
  various aspects of your program, such as: the shared objects loaded, the
  suppressions used, the progress of the instrumentation and execution engines,
  and warnings about unusual behaviour. Repeating the option increases the
  verbosity level.</div>
<div class="Pp"></div>
<b>--trace-children=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, Valgrind will trace into
  sub-processes initiated via the <i>exec</i> system call. This is necessary for
  multi-process programs.
<div style="height: 1.00em;">&#x00A0;</div>
Note that Valgrind does trace into the child of a <i>fork</i> (it would be
  difficult not to, since <i>fork</i> makes an identical copy of a process), so
  this option is arguably badly named. However, most children of <i>fork</i>
  calls immediately call <i>exec</i> anyway.</div>
<div class="Pp"></div>
<b>--trace-children-skip=patt1,patt2,... </b>
<div style="margin-left: 4.00ex;">This option only has an effect when
  <b>--trace-children=yes</b> is specified. It allows for some children to be
  skipped. The option takes a comma separated list of patterns for the names of
  child executables that Valgrind should not trace into. Patterns may include
  the metacharacters ? and *, which have the usual meaning.
<div style="height: 1.00em;">&#x00A0;</div>
This can be useful for pruning uninteresting branches from a tree of processes
  being run on Valgrind. But you should be careful when using it. When Valgrind
  skips tracing into an executable, it doesn't just skip tracing that
  executable, it also skips tracing any of that executable's child processes. In
  other words, the flag doesn't merely cause tracing to stop at the specified
  executables -- it skips tracing of entire process subtrees rooted at any of
  the specified executables.</div>
<div class="Pp"></div>
<b>--trace-children-skip-by-arg=patt1,patt2,... </b>
<div style="margin-left: 4.00ex;">This is the same as
  <b>--trace-children-skip</b>, with one difference: the decision as to whether
  to trace into a child process is made by examining the arguments to the child
  process, rather than the name of its executable.</div>
<div class="Pp"></div>
<b>--child-silent-after-fork=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, Valgrind will not show any
  debugging or logging output for the child process resulting from a <i>fork</i>
  call. This can make the output less confusing (although more misleading) when
  dealing with processes that create children. It is particularly useful in
  conjunction with <i>--trace-children=</i>. Use of this option is also strongly
  recommended if you are requesting XML output ( <i>--xml=yes</i>), since
  otherwise the XML from child and parent may become mixed up, which usually
  makes it useless.</div>
<div class="Pp"></div>
<b>--vgdb=&lt;no|yes|full&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">Valgrind will provide &quot;gdbserver&quot;
  functionality when <b>--vgdb=yes</b> or <b>--vgdb=full</b> is specified. This
  allows an external GNU GDB debugger to control and debug your program when it
  runs on Valgrind. <b>--vgdb=full</b> incurs significant performance overheads,
  but provides more precise breakpoints and watchpoints. See Debugging your
  program using Valgrind's gdbserver and GDB for a detailed description.
<div style="height: 1.00em;">&#x00A0;</div>
If the embedded gdbserver is enabled but no gdb is currently being used, the
  vgdb command line utility can send &quot;monitor commands&quot; to Valgrind
  from a shell. The Valgrind core provides a set of Valgrind monitor commands. A
  tool can optionally provide tool specific monitor commands, which are
  documented in the tool specific chapter.</div>
<div class="Pp"></div>
<b>--vgdb-error=&lt;number&gt; [default: 999999999] </b>
<div style="margin-left: 4.00ex;">Use this option when the Valgrind gdbserver is
  enabled with <b>--vgdb=yes</b> or <b>--vgdb=full</b>. Tools that report errors
  will wait for &quot;number&quot; errors to be reported before freezing the
  program and waiting for you to connect with GDB. It follows that a value of
  zero will cause the gdbserver to be started before your program is executed.
  This is typically used to insert GDB breakpoints before execution, and also
  works with tools that do not report errors, such as Massif.</div>
<div class="Pp"></div>
<b>--vgdb-stop-at=&lt;set&gt; [default: none] </b>
<div style="margin-left: 4.00ex;">Use this option when the Valgrind gdbserver is
  enabled with <b>--vgdb=yes</b> or <b>--vgdb=full</b>. The Valgrind gdbserver
  will be invoked for each error after <b>--vgdb-error</b> have been reported.
  You can additionally ask the Valgrind gdbserver to be invoked for other
  events, specified in one of the following ways:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;a comma separated list of one or more
  of <b>startup exit valgrindabexit</b>.
<div style="height: 1.00em;">&#x00A0;</div>
The values <b>startup</b><b>exit</b><b>valgrindabexit</b> respectively indicate
  to invoke gdbserver before your program is executed, after the last
  instruction of your program, on Valgrind abnormal exit (e.g. internal error,
  out of memory, ...).
<div style="height: 1.00em;">&#x00A0;</div>
Note: <b>startup</b> and <b>--vgdb-error=0</b> will both cause Valgrind
  gdbserver to be invoked before your program is executed. The
  <b>--vgdb-error=0</b> will in addition cause your program to stop on all
  subsequent errors.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>all</b> to specify the complete
  set. It is equivalent to
  <b>--vgdb-stop-at=startup,exit,valgrindabexit</b>.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>none</b> for the empty set.</div>
</div>
<div class="Pp"></div>
<b>--track-fds=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, Valgrind will print out a list
  of open file descriptors on exit or on request, via the gdbserver monitor
  command <i>v.info open_fds</i>. Along with each file descriptor is printed a
  stack backtrace of where the file was opened and any details relating to the
  file descriptor such as the file name or socket details.</div>
<div class="Pp"></div>
<b>--time-stamp=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, each message is preceded with an
  indication of the elapsed wallclock time since startup, expressed as days,
  hours, minutes, seconds and milliseconds.</div>
<div class="Pp"></div>
<b>--log-fd=&lt;number&gt; [default: 2, stderr] </b>
<div style="margin-left: 4.00ex;">Specifies that Valgrind should send all of its
  messages to the specified file descriptor. The default, 2, is the standard
  error channel (stderr). Note that this may interfere with the client's own use
  of stderr, as Valgrind's output will be interleaved with any output that the
  client sends to stderr.</div>
<div class="Pp"></div>
<b>--log-file=&lt;filename&gt; </b>
<div style="margin-left: 4.00ex;">Specifies that Valgrind should send all of its
  messages to the specified file. If the file name is empty, it causes an abort.
  There are three special format specifiers that can be used in the file name.
<div style="height: 1.00em;">&#x00A0;</div>
<b>%p</b> is replaced with the current process ID. This is very useful for
  program that invoke multiple processes. WARNING: If you use
  <b>--trace-children=yes</b> and your program invokes multiple processes OR
  your program forks without calling exec afterwards, and you don't use this
  specifier (or the <b>%q</b> specifier below), the Valgrind output from all
  those processes will go into one file, possibly jumbled up, and possibly
  incomplete.
<div style="height: 1.00em;">&#x00A0;</div>
<b>%q{FOO}</b> is replaced with the contents of the environment variable
  <i>FOO</i>. If the <b>{FOO}</b> part is malformed, it causes an abort. This
  specifier is rarely needed, but very useful in certain circumstances (eg. when
  running MPI programs). The idea is that you specify a variable which will be
  set differently for each process in the job, for example BPROC_RANK or
  whatever is applicable in your MPI setup. If the named environment variable is
  not set, it causes an abort. Note that in some shells, the <b>{</b> and
  <b>}</b> characters may need to be escaped with a backslash.
<div style="height: 1.00em;">&#x00A0;</div>
<b>%%</b> is replaced with <b>%</b>.
<div style="height: 1.00em;">&#x00A0;</div>
If an <b>%</b> is followed by any other character, it causes an abort.
<div style="height: 1.00em;">&#x00A0;</div>
If the file name specifies a relative file name, it is put in the program's
  initial working directory : this is the current directory when the program
  started its execution after the fork or after the exec. If it specifies an
  absolute file name (ie. starts with '/') then it is put there.</div>
<div class="Pp"></div>
<b>--log-socket=&lt;ip-address:port-number&gt; </b>
<div style="margin-left: 4.00ex;">Specifies that Valgrind should send all of its
  messages to the specified port at the specified IP address. The port may be
  omitted, in which case port 1500 is used. If a connection cannot be made to
  the specified socket, Valgrind falls back to writing output to the standard
  error (stderr). This option is intended to be used in conjunction with the
  valgrind-listener program. For further details, see the commentary in the
  manual.</div>
<h1 class="Sh" title="Sh" id="ERROR-RELATED_OPTIONS"><a class="selflink" href="#ERROR-RELATED_OPTIONS">ERROR-RELATED
  OPTIONS</a></h1>
These options are used by all tools that can report errors, e.g. Memcheck, but
  not Cachegrind.
<div class="Pp"></div>
<b>--xml=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, the important parts of the
  output (e.g. tool error messages) will be in XML format rather than plain
  text. Furthermore, the XML output will be sent to a different output channel
  than the plain text output. Therefore, you also must use one of
  <b>--xml-fd</b>, <b>--xml-file</b> or <b>--xml-socket</b> to specify where the
  XML is to be sent.
<div style="height: 1.00em;">&#x00A0;</div>
Less important messages will still be printed in plain text, but because the XML
  output and plain text output are sent to different output channels (the
  destination of the plain text output is still controlled by <b>--log-fd</b>,
  <b>--log-file</b> and <b>--log-socket</b>) this should not cause problems.
<div style="height: 1.00em;">&#x00A0;</div>
This option is aimed at making life easier for tools that consume Valgrind's
  output as input, such as GUI front ends. Currently this option works with
  Memcheck, Helgrind, DRD and SGcheck. The output format is specified in the
  file docs/internals/xml-output-protocol4.txt in the source tree for Valgrind
  3.5.0 or later.
<div style="height: 1.00em;">&#x00A0;</div>
The recommended options for a GUI to pass, when requesting XML output, are:
  <b>--xml=yes</b> to enable XML output, <b>--xml-file</b> to send the XML
  output to a (presumably GUI-selected) file, <b>--log-file</b> to send the
  plain text output to a second GUI-selected file,
  <b>--child-silent-after-fork=yes</b>, and <b>-q</b> to restrict the plain text
  output to critical error messages created by Valgrind itself. For example,
  failure to read a specified suppressions file counts as a critical error
  message. In this way, for a successful run the text output file will be empty.
  But if it isn't empty, then it will contain important information which the
  GUI user should be made aware of.</div>
<div class="Pp"></div>
<b>--xml-fd=&lt;number&gt; [default: -1, disabled] </b>
<div style="margin-left: 4.00ex;">Specifies that Valgrind should send its XML
  output to the specified file descriptor. It must be used in conjunction with
  <b>--xml=yes</b>.</div>
<div class="Pp"></div>
<b>--xml-file=&lt;filename&gt; </b>
<div style="margin-left: 4.00ex;">Specifies that Valgrind should send its XML
  output to the specified file. It must be used in conjunction with
  <b>--xml=yes</b>. Any <b>%p</b> or <b>%q</b> sequences appearing in the
  filename are expanded in exactly the same way as they are for
  <b>--log-file</b>. See the description of <b>--log-file</b> for details.</div>
<div class="Pp"></div>
<b>--xml-socket=&lt;ip-address:port-number&gt; </b>
<div style="margin-left: 4.00ex;">Specifies that Valgrind should send its XML
  output the specified port at the specified IP address. It must be used in
  conjunction with <b>--xml=yes</b>. The form of the argument is the same as
  that used by <b>--log-socket</b>. See the description of <b>--log-socket</b>
  for further details.</div>
<div class="Pp"></div>
<b>--xml-user-comment=&lt;string&gt; </b>
<div style="margin-left: 4.00ex;">Embeds an extra user comment string at the
  start of the XML output. Only works when <b>--xml=yes</b> is specified;
  ignored otherwise.</div>
<div class="Pp"></div>
<b>--demangle=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">Enable/disable automatic demangling (decoding)
  of C++ names. Enabled by default. When enabled, Valgrind will attempt to
  translate encoded C++ names back to something approaching the original. The
  demangler handles symbols mangled by g++ versions 2.X, 3.X and 4.X.
<div style="height: 1.00em;">&#x00A0;</div>
An important fact about demangling is that function names mentioned in
  suppressions files should be in their mangled form. Valgrind does not demangle
  function names when searching for applicable suppressions, because to do
  otherwise would make suppression file contents dependent on the state of
  Valgrind's demangling machinery, and also slow down suppression
  matching.</div>
<div class="Pp"></div>
<b>--num-callers=&lt;number&gt; [default: 12] </b>
<div style="margin-left: 4.00ex;">Specifies the maximum number of entries shown
  in stack traces that identify program locations. Note that errors are commoned
  up using only the top four function locations (the place in the current
  function, and that of its three immediate callers). So this doesn't affect the
  total number of errors reported.
<div style="height: 1.00em;">&#x00A0;</div>
The maximum value for this is 500. Note that higher settings will make Valgrind
  run a bit more slowly and take a bit more memory, but can be useful when
  working with programs with deeply-nested call chains.</div>
<div class="Pp"></div>
<b>--unw-stack-scan-thresh=&lt;number&gt; [default: 0] </b>,
  <b>--unw-stack-scan-frames=&lt;number&gt; [default: 5] </b>
<div style="margin-left: 4.00ex;">Stack-scanning support is available only on
  ARM targets.
<div style="height: 1.00em;">&#x00A0;</div>
These flags enable and control stack unwinding by stack scanning. When the
  normal stack unwinding mechanisms -- usage of Dwarf CFI records, and
  frame-pointer following -- fail, stack scanning may be able to recover a stack
  trace.
<div style="height: 1.00em;">&#x00A0;</div>
Note that stack scanning is an imprecise, heuristic mechanism that may give very
  misleading results, or none at all. It should be used only in emergencies,
  when normal unwinding fails, and it is important to nevertheless have stack
  traces.
<div style="height: 1.00em;">&#x00A0;</div>
Stack scanning is a simple technique: the unwinder reads words from the stack,
  and tries to guess which of them might be return addresses, by checking to see
  if they point just after ARM or Thumb call instructions. If so, the word is
  added to the backtrace.
<div style="height: 1.00em;">&#x00A0;</div>
The main danger occurs when a function call returns, leaving its return address
  exposed, and a new function is called, but the new function does not overwrite
  the old address. The result of this is that the backtrace may contain entries
  for functions which have already returned, and so be very confusing.
<div style="height: 1.00em;">&#x00A0;</div>
A second limitation of this implementation is that it will scan only the page
  (4KB, normally) containing the starting stack pointer. If the stack frames are
  large, this may result in only a few (or not even any) being present in the
  trace. Also, if you are unlucky and have an initial stack pointer near the end
  of its containing page, the scan may miss all interesting frames.
<div style="height: 1.00em;">&#x00A0;</div>
By default stack scanning is disabled. The normal use case is to ask for it when
  a stack trace would otherwise be very short. So, to enable it, use
  --unw-stack-scan-thresh=number. This requests Valgrind to try using stack
  scanning to &quot;extend&quot; stack traces which contain fewer than number
  frames.
<div style="height: 1.00em;">&#x00A0;</div>
If stack scanning does take place, it will only generate at most the number of
  frames specified by --unw-stack-scan-frames. Typically, stack scanning
  generates so many garbage entries that this value is set to a low value (5) by
  default. In no case will a stack trace larger than the value specified by
  --num-callers be created.</div>
<div class="Pp"></div>
<b>--error-limit=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">When enabled, Valgrind stops reporting errors
  after 10,000,000 in total, or 1,000 different ones, have been seen. This is to
  stop the error tracking machinery from becoming a huge performance overhead in
  programs with many errors.</div>
<div class="Pp"></div>
<b>--error-exitcode=&lt;number&gt; [default: 0] </b>
<div style="margin-left: 4.00ex;">Specifies an alternative exit code to return
  if Valgrind reported any errors in the run. When set to the default value
  (zero), the return value from Valgrind will always be the return value of the
  process being simulated. When set to a nonzero value, that value is returned
  instead, if Valgrind detects any errors. This is useful for using Valgrind as
  part of an automated test suite, since it makes it easy to detect test cases
  for which Valgrind has reported errors, just by inspecting return codes.</div>
<div class="Pp"></div>
<b>--error-markers=&lt;begin&gt;,&lt;end&gt; [default: none]</b>
<div style="margin-left: 4.00ex;">When errors are output as plain text (i.e. XML
  not used), <b>--error-markers</b> instructs to output a line containing the
  <b>begin</b> ( <b>end</b>) string before (after) each error.
<div style="height: 1.00em;">&#x00A0;</div>
Such marker lines facilitate searching for errors and/or extracting errors in an
  output file that contain valgrind errors mixed with the program output.
<div style="height: 1.00em;">&#x00A0;</div>
Note that empty markers are accepted. So, only using a begin (or an end) marker
  is possible.</div>
<div class="Pp"></div>
<b>--sigill-diagnostics=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">Enable/disable printing of illegal instruction
  diagnostics. Enabled by default, but defaults to disabled when <b>--quiet</b>
  is given. The default can always be explicitly overridden by giving this
  option.
<div style="height: 1.00em;">&#x00A0;</div>
When enabled, a warning message will be printed, along with some diagnostics,
  whenever an instruction is encountered that Valgrind cannot decode or
  translate, before the program is given a SIGILL signal. Often an illegal
  instruction indicates a bug in the program or missing support for the
  particular instruction in Valgrind. But some programs do deliberately try to
  execute an instruction that might be missing and trap the SIGILL signal to
  detect processor features. Using this flag makes it possible to avoid the
  diagnostic output that you would otherwise get in such cases.</div>
<div class="Pp"></div>
<b>--show-below-main=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">By default, stack traces for errors do not
  show any functions that appear beneath <b>main</b> because most of the time
  it's uninteresting C library stuff and/or gobbledygook. Alternatively, if
  <b>main</b> is not present in the stack trace, stack traces will not show any
  functions below <b>main</b>-like functions such as glibc's
  <b>__libc_start_main</b>. Furthermore, if <b>main</b>-like functions are
  present in the trace, they are normalised as <b>(below main)</b>, in order to
  make the output more deterministic.
<div style="height: 1.00em;">&#x00A0;</div>
If this option is enabled, all stack trace entries will be shown and
  <b>main</b>-like functions will not be normalised.</div>
<div class="Pp"></div>
<b>--fullpath-after=&lt;string&gt; [default: don't show source paths] </b>
<div style="margin-left: 4.00ex;">By default Valgrind only shows the filenames
  in stack traces, but not full paths to source files. When using Valgrind in
  large projects where the sources reside in multiple different directories,
  this can be inconvenient. <b>--fullpath-after</b> provides a flexible solution
  to this problem. When this option is present, the path to each source file is
  shown, with the following all-important caveat: if <b>string</b> is found in
  the path, then the path up to and including <b>string</b> is omitted, else the
  path is shown unmodified. Note that <b>string</b> is not required to be a
  prefix of the path.
<div style="height: 1.00em;">&#x00A0;</div>
For example, consider a file named /home/janedoe/blah/src/foo/bar/xyzzy.c.
  Specifying <b>--fullpath-after=/home/janedoe/blah/src/</b> will cause Valgrind
  to show the name as foo/bar/xyzzy.c.
<div style="height: 1.00em;">&#x00A0;</div>
Because the string is not required to be a prefix, <b>--fullpath-after=src/</b>
  will produce the same output. This is useful when the path contains arbitrary
  machine-generated characters. For example, the path
  /my/build/dir/C32A1B47/blah/src/foo/xyzzy can be pruned to foo/xyzzy using
  <b>--fullpath-after=/blah/src/</b>.
<div style="height: 1.00em;">&#x00A0;</div>
If you simply want to see the full path, just specify an empty string:
  <b>--fullpath-after=</b>. This isn't a special case, merely a logical
  consequence of the above rules.
<div style="height: 1.00em;">&#x00A0;</div>
Finally, you can use <b>--fullpath-after</b> multiple times. Any appearance of
  it causes Valgrind to switch to producing full paths and applying the above
  filtering rule. Each produced path is compared against all the
  <b>--fullpath-after</b>-specified strings, in the order specified. The first
  string to match causes the path to be truncated as described above. If none
  match, the full path is shown. This facilitates chopping off prefixes when the
  sources are drawn from a number of unrelated directories.</div>
<div class="Pp"></div>
<b>--extra-debuginfo-path=&lt;path&gt; [default: undefined and unused] </b>
<div style="margin-left: 4.00ex;">By default Valgrind searches in several
  well-known paths for debug objects, such as /usr/lib/debug/.
<div style="height: 1.00em;">&#x00A0;</div>
However, there may be scenarios where you may wish to put debug objects at an
  arbitrary location, such as external storage when running Valgrind on a mobile
  device with limited local storage. Another example might be a situation where
  you do not have permission to install debug object packages on the system
  where you are running Valgrind.
<div style="height: 1.00em;">&#x00A0;</div>
In these scenarios, you may provide an absolute path as an extra, final place
  for Valgrind to search for debug objects by specifying
  <b>--extra-debuginfo-path=/path/to/debug/objects</b>. The given path will be
  prepended to the absolute path name of the searched-for object. For example,
  if Valgrind is looking for the debuginfo for /w/x/y/zz.so and
  <b>--extra-debuginfo-path=/a/b/c</b> is specified, it will look for a debug
  object at /a/b/c/w/x/y/zz.so.
<div style="height: 1.00em;">&#x00A0;</div>
This flag should only be specified once. If it is specified multiple times, only
  the last instance is honoured.</div>
<div class="Pp"></div>
<b>--debuginfo-server=ipaddr:port [default: undefined and unused]</b>
<div style="margin-left: 4.00ex;">This is a new, experimental, feature
  introduced in version 3.9.0.
<div style="height: 1.00em;">&#x00A0;</div>
In some scenarios it may be convenient to read debuginfo from objects stored on
  a different machine. With this flag, Valgrind will query a debuginfo server
  running on ipaddr and listening on port port, if it cannot find the debuginfo
  object in the local filesystem.
<div style="height: 1.00em;">&#x00A0;</div>
The debuginfo server must accept TCP connections on port port. The debuginfo
  server is contained in the source file auxprogs/valgrind-di-server.c. It will
  only serve from the directory it is started in. port defaults to 1500 in both
  client and server if not specified.
<div style="height: 1.00em;">&#x00A0;</div>
If Valgrind looks for the debuginfo for /w/x/y/zz.so by using the debuginfo
  server, it will strip the pathname components and merely request zz.so on the
  server. That in turn will look only in its current working directory for a
  matching debuginfo object.
<div style="height: 1.00em;">&#x00A0;</div>
The debuginfo data is transmitted in small fragments (8 KB) as requested by
  Valgrind. Each block is compressed using LZO to reduce transmission time. The
  implementation has been tuned for best performance over a single-stage 802.11g
  (WiFi) network link.
<div style="height: 1.00em;">&#x00A0;</div>
Note that checks for matching primary vs debug objects, using GNU debuglink CRC
  scheme, are performed even when using the debuginfo server. To disable such
  checking, you need to also specify --allow-mismatched-debuginfo=yes.
<div style="height: 1.00em;">&#x00A0;</div>
By default the Valgrind build system will build valgrind-di-server for the
  target platform, which is almost certainly not what you want. So far we have
  been unable to find out how to get automake/autoconf to build it for the build
  platform. If you want to use it, you will have to recompile it by hand using
  the command shown at the top of auxprogs/valgrind-di-server.c.</div>
<div class="Pp"></div>
<b>--allow-mismatched-debuginfo=no|yes [no] </b>
<div style="margin-left: 4.00ex;">When reading debuginfo from separate debuginfo
  objects, Valgrind will by default check that the main and debuginfo objects
  match, using the GNU debuglink mechanism. This guarantees that it does not
  read debuginfo from out of date debuginfo objects, and also ensures that
  Valgrind can't crash as a result of mismatches.
<div style="height: 1.00em;">&#x00A0;</div>
This check can be overridden using --allow-mismatched-debuginfo=yes. This may be
  useful when the debuginfo and main objects have not been split in the proper
  way. Be careful when using this, though: it disables all consistency checking,
  and Valgrind has been observed to crash when the main and debuginfo objects
  don't match.</div>
<div class="Pp"></div>
<b>--suppressions=&lt;filename&gt; [default: $PREFIX/lib/valgrind/default.supp]
  </b>
<div style="margin-left: 4.00ex;">Specifies an extra file from which to read
  descriptions of errors to suppress. You may use up to 100 extra suppression
  files.</div>
<div class="Pp"></div>
<b>--gen-suppressions=&lt;yes|no|all&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When set to <i>yes</i>, Valgrind will pause
  after every error shown and print the line:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
    ---- Print suppression ? --- [Return/N/n/Y/y/C/c] ----
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
Pressing <i>Ret</i>, or <i>N Ret</i> or <i>n Ret</i>, causes Valgrind continue
  execution without printing a suppression for this error.
<div style="height: 1.00em;">&#x00A0;</div>
Pressing <i>Y Ret</i> or <i>y Ret</i> causes Valgrind to write a suppression for
  this error. You can then cut and paste it into a suppression file if you don't
  want to hear about the error in the future.
<div style="height: 1.00em;">&#x00A0;</div>
When set to <i>all</i>, Valgrind will print a suppression for every reported
  error, without querying the user.
<div style="height: 1.00em;">&#x00A0;</div>
This option is particularly useful with C++ programs, as it prints out the
  suppressions with mangled names, as required.
<div style="height: 1.00em;">&#x00A0;</div>
Note that the suppressions printed are as specific as possible. You may want to
  common up similar ones, by adding wildcards to function names, and by using
  frame-level wildcards. The wildcarding facilities are powerful yet flexible,
  and with a bit of careful editing, you may be able to suppress a whole family
  of related errors with only a few suppressions.
<div style="height: 1.00em;">&#x00A0;</div>
Sometimes two different errors are suppressed by the same suppression, in which
  case Valgrind will output the suppression more than once, but you only need to
  have one copy in your suppression file (but having more than one won't cause
  problems). Also, the suppression name is given as &lt;insert a suppression
  name here&gt;; the name doesn't really matter, it's only used with the
  <b>-v</b> option which prints out all used suppression records.</div>
<div class="Pp"></div>
<b>--input-fd=&lt;number&gt; [default: 0, stdin] </b>
<div style="margin-left: 4.00ex;">When using <b>--gen-suppressions=yes</b>,
  Valgrind will stop so as to read keyboard input from you when each error
  occurs. By default it reads from the standard input (stdin), which is
  problematic for programs which close stdin. This option allows you to specify
  an alternative file descriptor from which to read input.</div>
<div class="Pp"></div>
<b>--dsymutil=no|yes [yes] </b>
<div style="margin-left: 4.00ex;">This option is only relevant when running
  Valgrind on Mac OS X.
<div style="height: 1.00em;">&#x00A0;</div>
Mac OS X uses a deferred debug information (debuginfo) linking scheme. When
  object files containing debuginfo are linked into a .dylib or an executable,
  the debuginfo is not copied into the final file. Instead, the debuginfo must
  be linked manually by running dsymutil, a system-provided utility, on the
  executable or .dylib. The resulting combined debuginfo is placed in a
  directory alongside the executable or .dylib, but with the extension .dSYM.
<div style="height: 1.00em;">&#x00A0;</div>
With <b>--dsymutil=no</b>, Valgrind will detect cases where the .dSYM directory
  is either missing, or is present but does not appear to match the associated
  executable or .dylib, most likely because it is out of date. In these cases,
  Valgrind will print a warning message but take no further action.
<div style="height: 1.00em;">&#x00A0;</div>
With <b>--dsymutil=yes</b>, Valgrind will, in such cases, automatically run
  dsymutil as necessary to bring the debuginfo up to date. For all practical
  purposes, if you always use <b>--dsymutil=yes</b>, then there is never any
  need to run dsymutil manually or as part of your applications's build system,
  since Valgrind will run it as necessary.
<div style="height: 1.00em;">&#x00A0;</div>
Valgrind will not attempt to run dsymutil on any executable or library in /usr/,
  /bin/, /sbin/, /opt/, /sw/, /System/, /Library/ or /Applications/ since
  dsymutil will always fail in such situations. It fails both because the
  debuginfo for such pre-installed system components is not available anywhere,
  and also because it would require write privileges in those directories.
<div style="height: 1.00em;">&#x00A0;</div>
Be careful when using <b>--dsymutil=yes</b>, since it will cause pre-existing
  .dSYM directories to be silently deleted and re-created. Also note that
  dsymutil is quite slow, sometimes excessively so.</div>
<div class="Pp"></div>
<b>--max-stackframe=&lt;number&gt; [default: 2000000] </b>
<div style="margin-left: 4.00ex;">The maximum size of a stack frame. If the
  stack pointer moves by more than this amount then Valgrind will assume that
  the program is switching to a different stack.
<div style="height: 1.00em;">&#x00A0;</div>
You may need to use this option if your program has large stack-allocated
  arrays. Valgrind keeps track of your program's stack pointer. If it changes by
  more than the threshold amount, Valgrind assumes your program is switching to
  a different stack, and Memcheck behaves differently than it would for a stack
  pointer change smaller than the threshold. Usually this heuristic works well.
  However, if your program allocates large structures on the stack, this
  heuristic will be fooled, and Memcheck will subsequently report large numbers
  of invalid stack accesses. This option allows you to change the threshold to a
  different value.
<div style="height: 1.00em;">&#x00A0;</div>
You should only consider use of this option if Valgrind's debug output directs
  you to do so. In that case it will tell you the new threshold you should
  specify.
<div style="height: 1.00em;">&#x00A0;</div>
In general, allocating large structures on the stack is a bad idea, because you
  can easily run out of stack space, especially on systems with limited memory
  or which expect to support large numbers of threads each with a small stack,
  and also because the error checking performed by Memcheck is more effective
  for heap-allocated data than for stack-allocated data. If you have to use this
  option, you may wish to consider rewriting your code to allocate on the heap
  rather than on the stack.</div>
<div class="Pp"></div>
<b>--main-stacksize=&lt;number&gt; [default: use current 'ulimit' value] </b>
<div style="margin-left: 4.00ex;">Specifies the size of the main thread's stack.
<div style="height: 1.00em;">&#x00A0;</div>
To simplify its memory management, Valgrind reserves all required space for the
  main thread's stack at startup. That means it needs to know the required stack
  size at startup.
<div style="height: 1.00em;">&#x00A0;</div>
By default, Valgrind uses the current &quot;ulimit&quot; value for the stack
  size, or 16 MB, whichever is lower. In many cases this gives a stack size in
  the range 8 to 16 MB, which almost never overflows for most applications.
<div style="height: 1.00em;">&#x00A0;</div>
If you need a larger total stack size, use <b>--main-stacksize</b> to specify
  it. Only set it as high as you need, since reserving far more space than you
  need (that is, hundreds of megabytes more than you need) constrains Valgrind's
  memory allocators and may reduce the total amount of memory that Valgrind can
  use. This is only really of significance on 32-bit machines.
<div style="height: 1.00em;">&#x00A0;</div>
On Linux, you may request a stack of size up to 2GB. Valgrind will stop with a
  diagnostic message if the stack cannot be allocated.
<div style="height: 1.00em;">&#x00A0;</div>
<b>--main-stacksize</b> only affects the stack size for the program's initial
  thread. It has no bearing on the size of thread stacks, as Valgrind does not
  allocate those.
<div style="height: 1.00em;">&#x00A0;</div>
You may need to use both <b>--main-stacksize</b> and <b>--max-stackframe</b>
  together. It is important to understand that <b>--main-stacksize</b> sets the
  maximum total stack size, whilst <b>--max-stackframe</b> specifies the largest
  size of any one stack frame. You will have to work out the
  <b>--main-stacksize</b> value for yourself (usually, if your applications
  segfaults). But Valgrind will tell you the needed <b>--max-stackframe</b>
  size, if necessary.
<div style="height: 1.00em;">&#x00A0;</div>
As discussed further in the description of <b>--max-stackframe</b>, a
  requirement for a large stack is a sign of potential portability problems. You
  are best advised to place all large data in heap-allocated memory.</div>
<div class="Pp"></div>
<b>--max-threads=&lt;number&gt; [default: 500] </b>
<div style="margin-left: 4.00ex;">By default, Valgrind can handle to up to 500
  threads. Occasionally, that number is too small. Use this option to provide a
  different limit. E.g. --max-threads=3000.</div>
<h1 class="Sh" title="Sh" id="MALLOC()-RELATED_OPTIONS"><a class="selflink" href="#MALLOC()-RELATED_OPTIONS">MALLOC()-RELATED
  OPTIONS</a></h1>
For tools that use their own version of malloc (e.g. Memcheck, Massif, Helgrind,
  DRD), the following options apply.
<div class="Pp"></div>
<b>--alignment=&lt;number&gt; [default: 8 or 16, depending on the platform] </b>
<div style="margin-left: 4.00ex;">By default Valgrind's <b>malloc</b>,
  <b>realloc</b>, etc, return a block whose starting address is 8-byte aligned
  or 16-byte aligned (the value depends on the platform and matches the platform
  default). This option allows you to specify a different alignment. The
  supplied value must be greater than or equal to the default, less than or
  equal to 4096, and must be a power of two.</div>
<div class="Pp"></div>
<b>--redzone-size=&lt;number&gt; [default: depends on the tool] </b>
<div style="margin-left: 4.00ex;">Valgrind's <b>malloc, realloc,</b> etc, add
  padding blocks before and after each heap block allocated by the program being
  run. Such padding blocks are called redzones. The default value for the
  redzone size depends on the tool. For example, Memcheck adds and protects a
  minimum of 16 bytes before and after each block allocated by the client. This
  allows it to detect block underruns or overruns of up to 16 bytes.
<div style="height: 1.00em;">&#x00A0;</div>
Increasing the redzone size makes it possible to detect overruns of larger
  distances, but increases the amount of memory used by Valgrind. Decreasing the
  redzone size will reduce the memory needed by Valgrind but also reduces the
  chances of detecting over/underruns, so is not recommended.</div>
<h1 class="Sh" title="Sh" id="UNCOMMON_OPTIONS"><a class="selflink" href="#UNCOMMON_OPTIONS">UNCOMMON
  OPTIONS</a></h1>
These options apply to all tools, as they affect certain obscure workings of the
  Valgrind core. Most people won't need to use them.
<div class="Pp"></div>
<b>--smc-check=&lt;none|stack|all|all-non-file&gt; [default: all-non-file for
  x86/amd64/s390x, stack for other archs] </b>
<div style="margin-left: 4.00ex;">This option controls Valgrind's detection of
  self-modifying code. If no checking is done, when a program executes some
  code, then overwrites it with new code, and executes the new code, Valgrind
  will continue to execute the translations it made for the old code. This will
  likely lead to incorrect behaviour and/or crashes.
<div style="height: 1.00em;">&#x00A0;</div>
For &quot;modern&quot; architectures -- anything that's not x86, amd64 or s390x
  -- the default is <i>stack</i>. This is because a correct program must take
  explicit action to reestablish D-I cache coherence following code
  modification. Valgrind observes and honours such actions, with the result that
  self-modifying code is transparently handled with zero extra cost.
<div style="height: 1.00em;">&#x00A0;</div>
For x86, amd64 and s390x, the program is not required to notify the hardware of
  required D-I coherence syncing. Hence the default is <i>all-non-file</i>,
  which covers the normal case of generating code into an anonymous
  (non-file-backed) mmap'd area.
<div style="height: 1.00em;">&#x00A0;</div>
The meanings of the four available settings are as follows. No detection (
  <i>none</i>), detect self-modifying code on the stack (which is used by GCC to
  implement nested functions) ( <i>stack</i>), detect self-modifying code
  everywhere ( <i>all</i>), and detect self-modifying code everywhere except in
  file-backed mappings ( <i>all-non-file</i>).
<div style="height: 1.00em;">&#x00A0;</div>
Running with <i>all</i> will slow Valgrind down noticeably. Running with
  <i>none</i> will rarely speed things up, since very little code gets
  dynamically generated in most programs. The
  <b>VALGRIND_DISCARD_TRANSLATIONS</b> client request is an alternative to
  <b>--smc-check=all</b> and <b>--smc-check=all-non-file</b> that requires more
  programmer effort but allows Valgrind to run your program faster, by telling
  it precisely when translations need to be re-made.
<div style="height: 1.00em;">&#x00A0;</div>
<b>--smc-check=all-non-file</b> provides a cheaper but more limited version of
  <b>--smc-check=all</b>. It adds checks to any translations that do not
  originate from file-backed memory mappings. Typical applications that generate
  code, for example JITs in web browsers, generate code into anonymous mmaped
  areas, whereas the &quot;fixed&quot; code of the browser always lives in
  file-backed mappings. <b>--smc-check=all-non-file</b> takes advantage of this
  observation, limiting the overhead of checking to code which is likely to be
  JIT generated.</div>
<div class="Pp"></div>
<b>--read-inline-info=&lt;yes|no&gt; [default: see below] </b>
<div style="margin-left: 4.00ex;">When enabled, Valgrind will read information
  about inlined function calls from DWARF3 debug info. This slows Valgrind
  startup and makes it use more memory (typically for each inlined piece of
  code, 6 words and space for the function name), but it results in more
  descriptive stacktraces. For the 3.10.0 release, this functionality is enabled
  by default only for Linux, Android and Solaris targets and only for the tools
  Memcheck, Helgrind and DRD. Here is an example of some stacktraces with
  <b>--read-inline-info=no</b>:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
==15380== Conditional jump or move depends on uninitialised value(s)
==15380==    at 0x80484EA: main (inlinfo.c:6)
==15380== 
==15380== Conditional jump or move depends on uninitialised value(s)
==15380==    at 0x8048550: fun_noninline (inlinfo.c:6)
==15380==    by 0x804850E: main (inlinfo.c:34)
==15380== 
==15380== Conditional jump or move depends on uninitialised value(s)
==15380==    at 0x8048520: main (inlinfo.c:6)
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
And here are the same errors with <b>--read-inline-info=yes</b>:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
==15377== Conditional jump or move depends on uninitialised value(s)
==15377==    at 0x80484EA: fun_d (inlinfo.c:6)
==15377==    by 0x80484EA: fun_c (inlinfo.c:14)
==15377==    by 0x80484EA: fun_b (inlinfo.c:20)
==15377==    by 0x80484EA: fun_a (inlinfo.c:26)
==15377==    by 0x80484EA: main (inlinfo.c:33)
==15377== 
==15377== Conditional jump or move depends on uninitialised value(s)
==15377==    at 0x8048550: fun_d (inlinfo.c:6)
==15377==    by 0x8048550: fun_noninline (inlinfo.c:41)
==15377==    by 0x804850E: main (inlinfo.c:34)
==15377== 
==15377== Conditional jump or move depends on uninitialised value(s)
==15377==    at 0x8048520: fun_d (inlinfo.c:6)
==15377==    by 0x8048520: main (inlinfo.c:35)
</pre>
</div>
</div>
<div class="Pp"></div>
<b>--read-var-info=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, Valgrind will read information
  about variable types and locations from DWARF3 debug info. This slows Valgrind
  startup significantly and makes it use significantly more memory, but for the
  tools that can take advantage of it (Memcheck, Helgrind, DRD) it can result in
  more precise error messages. For example, here are some standard errors issued
  by Memcheck:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
==15363== Uninitialised byte(s) found during client check request
==15363==    at 0x80484A9: croak (varinfo1.c:28)
==15363==    by 0x8048544: main (varinfo1.c:55)
==15363==  Address 0x80497f7 is 7 bytes inside data symbol &quot;global_i2&quot;
==15363== 
==15363== Uninitialised byte(s) found during client check request
==15363==    at 0x80484A9: croak (varinfo1.c:28)
==15363==    by 0x8048550: main (varinfo1.c:56)
==15363==  Address 0xbea0d0cc is on thread 1's stack
==15363==  in frame #1, created by main (varinfo1.c:45)
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
And here are the same errors with <b>--read-var-info=yes</b>:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
==15370== Uninitialised byte(s) found during client check request
==15370==    at 0x80484A9: croak (varinfo1.c:28)
==15370==    by 0x8048544: main (varinfo1.c:55)
==15370==  Location 0x80497f7 is 0 bytes inside global_i2[7],
==15370==  a global variable declared at varinfo1.c:41
==15370== 
==15370== Uninitialised byte(s) found during client check request
==15370==    at 0x80484A9: croak (varinfo1.c:28)
==15370==    by 0x8048550: main (varinfo1.c:56)
==15370==  Location 0xbeb4a0cc is 0 bytes inside local var &quot;local&quot;
==15370==  declared at varinfo1.c:46, in frame #1 of thread 1
</pre>
</div>
</div>
<div class="Pp"></div>
<b>--vgdb-poll=&lt;number&gt; [default: 5000] </b>
<div style="margin-left: 4.00ex;">As part of its main loop, the Valgrind
  scheduler will poll to check if some activity (such as an external command or
  some input from a gdb) has to be handled by gdbserver. This activity poll will
  be done after having run the given number of basic blocks (or slightly more
  than the given number of basic blocks). This poll is quite cheap so the
  default value is set relatively low. You might further decrease this value if
  vgdb cannot use ptrace system call to interrupt Valgrind if all threads are
  (most of the time) blocked in a system call.</div>
<div class="Pp"></div>
<b>--vgdb-shadow-registers=no|yes [default: no] </b>
<div style="margin-left: 4.00ex;">When activated, gdbserver will expose the
  Valgrind shadow registers to GDB. With this, the value of the Valgrind shadow
  registers can be examined or changed using GDB. Exposing shadow registers only
  works with GDB version 7.1 or later.</div>
<div class="Pp"></div>
<b>--vgdb-prefix=&lt;prefix&gt; [default: /tmp/vgdb-pipe] </b>
<div style="margin-left: 4.00ex;">To communicate with gdb/vgdb, the Valgrind
  gdbserver creates 3 files (2 named FIFOs and a mmap shared memory file). The
  prefix option controls the directory and prefix for the creation of these
  files.</div>
<div class="Pp"></div>
<b>--run-libc-freeres=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">This option is only relevant when running
  Valgrind on Linux.
<div style="height: 1.00em;">&#x00A0;</div>
The GNU C library ( <b>libc.so</b>), which is used by all programs, may allocate
  memory for its own uses. Usually it doesn't bother to free that memory when
  the program ends&#x2014;there would be no point, since the Linux kernel
  reclaims all process resources when a process exits anyway, so it would just
  slow things down.
<div style="height: 1.00em;">&#x00A0;</div>
The glibc authors realised that this behaviour causes leak checkers, such as
  Valgrind, to falsely report leaks in glibc, when a leak check is done at exit.
  In order to avoid this, they provided a routine called <b>__libc_freeres</b>
  specifically to make glibc release all memory it has allocated. Memcheck
  therefore tries to run <b>__libc_freeres</b> at exit.
<div style="height: 1.00em;">&#x00A0;</div>
Unfortunately, in some very old versions of glibc, <b>__libc_freeres</b> is
  sufficiently buggy to cause segmentation faults. This was particularly
  noticeable on Red Hat 7.1. So this option is provided in order to inhibit the
  run of <b>__libc_freeres</b>. If your program seems to run fine on Valgrind,
  but segfaults at exit, you may find that <b>--run-libc-freeres=no</b> fixes
  that, although at the cost of possibly falsely reporting space leaks in
  libc.so.</div>
<div class="Pp"></div>
<b>--sim-hints=hint1,hint2,... </b>
<div style="margin-left: 4.00ex;">Pass miscellaneous hints to Valgrind which
  slightly modify the simulated behaviour in nonstandard or dangerous ways,
  possibly to help the simulation of strange features. By default no hints are
  enabled. Use with caution! Currently known hints are:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>lax-ioctls: </b> Be very lax about
  ioctl handling; the only assumption is that the size is correct. Doesn't
  require the full buffer to be initialised when writing. Without this, using
  some device drivers with a large number of strange ioctl commands becomes very
  tiresome.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>fuse-compatible: </b> Enable
  special handling for certain system calls that may block in a FUSE
  file-system. This may be necessary when running Valgrind on a multi-threaded
  program that uses one thread to manage a FUSE file-system and another thread
  to access that file-system.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>enable-outer: </b> Enable some
  special magic needed when the program being run is itself Valgrind.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>no-inner-prefix: </b> Disable
  printing a prefix <b>&gt;</b> in front of each stdout or stderr output line in
  an inner Valgrind being run by an outer Valgrind. This is useful when running
  Valgrind regression tests in an outer/inner setup. Note that the prefix
  <b>&gt;</b> will always be printed in front of the inner debug logging
  lines.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>no-nptl-pthread-stackcache: </b>
  This hint is only relevant when running Valgrind on Linux.
<div style="height: 1.00em;">&#x00A0;</div>
The GNU glibc pthread library ( <b>libpthread.so</b>), which is used by pthread
  programs, maintains a cache of pthread stacks. When a pthread terminates, the
  memory used for the pthread stack and some thread local storage related data
  structure are not always directly released. This memory is kept in a cache (up
  to a certain size), and is re-used if a new thread is started.
<div style="height: 1.00em;">&#x00A0;</div>
This cache causes the helgrind tool to report some false positive race condition
  errors on this cached memory, as helgrind does not understand the internal
  glibc cache synchronisation primitives. So, when using helgrind, disabling the
  cache helps to avoid false positive race conditions, in particular when using
  thread local storage variables (e.g. variables using the <b>__thread</b>
  qualifier).
<div style="height: 1.00em;">&#x00A0;</div>
When using the memcheck tool, disabling the cache ensures the memory used by
  glibc to handle __thread variables is directly released when a thread
  terminates.
<div style="height: 1.00em;">&#x00A0;</div>
Note: Valgrind disables the cache using some internal knowledge of the glibc
  stack cache implementation and by examining the debug information of the
  pthread library. This technique is thus somewhat fragile and might not work
  for all glibc versions. This has been succesfully tested with various glibc
  versions (e.g. 2.11, 2.16, 2.18) on various platforms.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>lax-doors: </b> (Solaris only) Be
  very lax about door syscall handling over unrecognised door file descriptors.
  Does not require that full buffer is initialised when writing. Without this,
  programs using libdoor(3LIB) functionality with completely proprietary
  semantics may report large number of false positives.</div>
</div>
<div class="Pp"></div>
<b>--fair-sched=&lt;no|yes|try&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">The <b>--fair-sched</b> option controls the
  locking mechanism used by Valgrind to serialise thread execution. The locking
  mechanism controls the way the threads are scheduled, and different settings
  give different trade-offs between fairness and performance. For more details
  about the Valgrind thread serialisation scheme and its impact on performance
  and thread scheduling, see Scheduling and Multi-Thread Performance.
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;The value <b>--fair-sched=yes</b>
  activates a fair scheduler. In short, if multiple threads are ready to run,
  the threads will be scheduled in a round robin fashion. This mechanism is not
  available on all platforms or Linux versions. If not available, using
  <b>--fair-sched=yes</b> will cause Valgrind to terminate with an error.
<div style="height: 1.00em;">&#x00A0;</div>
You may find this setting improves overall responsiveness if you are running an
  interactive multithreaded program, for example a web browser, on
  Valgrind.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;The value <b>--fair-sched=try</b>
  activates fair scheduling if available on the platform. Otherwise, it will
  automatically fall back to <b>--fair-sched=no</b>.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;The value <b>--fair-sched=no</b>
  activates a scheduler which does not guarantee fairness between threads ready
  to run, but which in general gives the highest performance.</div>
</div>
<div class="Pp"></div>
<b>--kernel-variant=variant1,variant2,...</b>
<div style="margin-left: 4.00ex;">Handle system calls and ioctls arising from
  minor variants of the default kernel for this platform. This is useful for
  running on hacked kernels or with kernel modules which support nonstandard
  ioctls, for example. Use with caution. If you don't understand what this
  option does then you almost certainly don't need it. Currently known variants
  are:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>bproc</b>: support the
  <b>sys_broc</b> system call on x86. This is for running on BProc, which is a
  minor variant of standard Linux which is sometimes used for building
  clusters.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>android-no-hw-tls</b>: some
  versions of the Android emulator for ARM do not provide a hardware TLS
  (thread-local state) register, and Valgrind crashes at startup. Use this
  variant to select software support for TLS.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>android-gpu-sgx5xx</b>: use this to
  support handling of proprietary ioctls for the PowerVR SGX 5XX series of GPUs
  on Android devices. Failure to select this does not cause stability problems,
  but may cause Memcheck to report false errors after the program performs
  GPU-specific ioctls.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>android-gpu-adreno3xx</b>:
  similarly, use this to support handling of proprietary ioctls for the Qualcomm
  Adreno 3XX series of GPUs on Android devices.</div>
</div>
<div class="Pp"></div>
<b>--merge-recursive-frames=&lt;number&gt; [default: 0] </b>
<div style="margin-left: 4.00ex;">Some recursive algorithms, for example
  balanced binary tree implementations, create many different stack traces, each
  containing cycles of calls. A cycle is defined as two identical program
  counter values separated by zero or more other program counter values.
  Valgrind may then use a lot of memory to store all these stack traces. This is
  a poor use of memory considering that such stack traces contain repeated
  uninteresting recursive calls instead of more interesting information such as
  the function that has initiated the recursive call.
<div style="height: 1.00em;">&#x00A0;</div>
The option <b>--merge-recursive-frames=&lt;number&gt;</b> instructs Valgrind to
  detect and merge recursive call cycles having a size of up to
  <b>&lt;number&gt;</b> frames. When such a cycle is detected, Valgrind records
  the cycle in the stack trace as a unique program counter.
<div style="height: 1.00em;">&#x00A0;</div>
The value 0 (the default) causes no recursive call merging. A value of 1 will
  cause stack traces of simple recursive algorithms (for example, a factorial
  implementation) to be collapsed. A value of 2 will usually be needed to
  collapse stack traces produced by recursive algorithms such as binary trees,
  quick sort, etc. Higher values might be needed for more complex recursive
  algorithms.
<div style="height: 1.00em;">&#x00A0;</div>
Note: recursive calls are detected by analysis of program counter values. They
  are not detected by looking at function names.</div>
<div class="Pp"></div>
<b>--num-transtab-sectors=&lt;number&gt; [default: 6 for Android platforms, 16
  for all others] </b>
<div style="margin-left: 4.00ex;">Valgrind translates and instruments your
  program's machine code in small fragments (basic blocks). The translations are
  stored in a translation cache that is divided into a number of sections
  (sectors). If the cache is full, the sector containing the oldest translations
  is emptied and reused. If these old translations are needed again, Valgrind
  must re-translate and re-instrument the corresponding machine code, which is
  expensive. If the &quot;executed instructions&quot; working set of a program
  is big, increasing the number of sectors may improve performance by reducing
  the number of re-translations needed. Sectors are allocated on demand. Once
  allocated, a sector can never be freed, and occupies considerable space,
  depending on the tool and the value of <b>--avg-transtab-entry-size</b> (about
  40 MB per sector for Memcheck). Use the option <b>--stats=yes</b> to obtain
  precise information about the memory used by a sector and the allocation and
  recycling of sectors.</div>
<div class="Pp"></div>
<b>--avg-transtab-entry-size=&lt;number&gt; [default: 0, meaning use tool
  provided default] </b>
<div style="margin-left: 4.00ex;">Average size of translated basic block. This
  average size is used to dimension the size of a sector. Each tool provides a
  default value to be used. If this default value is too small, the translation
  sectors will become full too quickly. If this default value is too big, a
  significant part of the translation sector memory will be unused. Note that
  the average size of a basic block translation depends on the tool, and might
  depend on tool options. For example, the memcheck option
  <b>--track-origins=yes</b> increases the size of the basic block translations.
  Use <b>--avg-transtab-entry-size</b> to tune the size of the sectors, either
  to gain memory or to avoid too many retranslations.</div>
<div class="Pp"></div>
<b>--aspace-minaddr=&lt;address&gt; [default: depends on the platform] </b>
<div style="margin-left: 4.00ex;">To avoid potential conflicts with some system
  libraries, Valgrind does not use the address space below
  <b>--aspace-minaddr</b> value, keeping it reserved in case a library
  specifically requests memory in this region. So, some &quot;pessimistic&quot;
  value is guessed by Valgrind depending on the platform. On linux, by default,
  Valgrind avoids using the first 64MB even if typically there is no conflict in
  this complete zone. You can use the option <b>--aspace-minaddr</b> to have
  your memory hungry application benefitting from more of this lower memory. On
  the other hand, if you encounter a conflict, increasing aspace-minaddr value
  might solve it. Conflicts will typically manifest themselves with mmap
  failures in the low range of the address space. The provided address must be
  page aligned and must be equal or bigger to 0x1000 (4KB). To find the default
  value on your platform, do something such as valgrind -d -d date 2&gt;&amp;1 |
  grep -i minaddr. Values lower than 0x10000 (64KB) are known to create problems
  on some distributions.</div>
<div class="Pp"></div>
<b>--valgrind-stacksize=&lt;number&gt; [default: 1MB] </b>
<div style="margin-left: 4.00ex;">For each thread, Valgrind needs its own
  'private' stack. The default size for these stacks is largely dimensioned, and
  so should be sufficient in most cases. In case the size is too small, Valgrind
  will segfault. Before segfaulting, a warning might be produced by Valgrind
  when approaching the limit.
<div style="height: 1.00em;">&#x00A0;</div>
Use the option <b>--valgrind-stacksize</b> if such an (unlikely) warning is
  produced, or Valgrind dies due to a segmentation violation. Such segmentation
  violations have been seen when demangling huge C++ symbols.
<div style="height: 1.00em;">&#x00A0;</div>
If your application uses many threads and needs a lot of memory, you can gain
  some memory by reducing the size of these Valgrind stacks using the option
  <b>--valgrind-stacksize</b>.</div>
<div class="Pp"></div>
<b>--show-emwarns=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, Valgrind will emit warnings
  about its CPU emulation in certain cases. These are usually not
  interesting.</div>
<div class="Pp"></div>
<b>--require-text-symbol=:sonamepatt:fnnamepatt</b>
<div style="margin-left: 4.00ex;">When a shared object whose soname matches
  <i>sonamepatt</i> is loaded into the process, examine all the text symbols it
  exports. If none of those match <i>fnnamepatt</i>, print an error message and
  abandon the run. This makes it possible to ensure that the run does not
  continue unless a given shared object contains a particular function name.
<div style="height: 1.00em;">&#x00A0;</div>
Both <i>sonamepatt</i> and <i>fnnamepatt</i> can be written using the usual
  <i>?</i> and <i>*</i> wildcards. For example:
  <i>&quot;:*libc.so*:foo?bar&quot;</i>. You may use characters other than a
  colon to separate the two patterns. It is only important that the first
  character and the separator character are the same. For example, the above
  example could also be written <i>&quot;Q*libc.so*Qfoo?bar&quot;</i>. Multiple
  <i> --require-text-symbol</i> flags are allowed, in which case shared objects
  that are loaded into the process will be checked against all of them.
<div style="height: 1.00em;">&#x00A0;</div>
The purpose of this is to support reliable usage of marked-up libraries. For
  example, suppose we have a version of GCC's <i>libgomp.so</i> which has been
  marked up with annotations to support Helgrind. It is only too easy and
  confusing to load the wrong, un-annotated <i>libgomp.so</i> into the
  application. So the idea is: add a text symbol in the marked-up library, for
  example <i>annotated_for_helgrind_3_6</i>, and then give the flag
  <i>--require-text-symbol=:*libgomp*so*:annotated_for_helgrind_3_6</i> so that
  when <i>libgomp.so</i> is loaded, Valgrind scans its symbol table, and if the
  symbol isn't present the run is aborted, rather than continuing silently with
  the un-marked-up library. Note that you should put the entire flag in quotes
  to stop shells expanding up the <i>*</i> and <i>?</i> wildcards.</div>
<div class="Pp"></div>
<b>--soname-synonyms=syn1=pattern1,syn2=pattern2,...</b>
<div style="margin-left: 4.00ex;">When a shared library is loaded, Valgrind
  checks for functions in the library that must be replaced or wrapped. For
  example, Memcheck replaces all malloc related functions (malloc, free, calloc,
  ...) with its own versions. Such replacements are done by default only in
  shared libraries whose soname matches a predefined soname pattern (e.g.
  <i>libc.so*</i> on linux). By default, no replacement is done for a statically
  linked library or for alternative libraries such as tcmalloc. In some cases,
  the replacements allow <b>--soname-synonyms</b> to specify one additional
  synonym pattern, giving flexibility in the replacement.
<div style="height: 1.00em;">&#x00A0;</div>
Currently, this flexibility is only allowed for the malloc related functions,
  using the synonym <i>somalloc</i>. This synonym is usable for all tools doing
  standard replacement of malloc related functions (e.g. memcheck, massif, drd,
  helgrind, exp-dhat, exp-sgcheck).
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;Alternate malloc library: to replace
  the malloc related functions in an alternate library with soname
  <i>mymalloclib.so</i>, give the option
  <b>--soname-synonyms=somalloc=mymalloclib.so</b>. A pattern can be used to
  match multiple libraries sonames. For example,
  <b>--soname-synonyms=somalloc=*tcmalloc*</b> will match the soname of all
  variants of the tcmalloc library (native, debug, profiled, ... tcmalloc
  variants).
<div style="height: 1.00em;">&#x00A0;</div>
Note: the soname of a elf shared library can be retrieved using the readelf
  utility.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;Replacements in a statically linked
  library are done by using the <i>NONE</i> pattern. For example, if you link
  with <i>libtcmalloc.a</i>, memcheck will properly work when you give the
  option <b>--soname-synonyms=somalloc=NONE</b>. Note that a NONE pattern will
  match the main executable and any shared library having no soname.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;To run a &quot;default&quot; Firefox
  build for Linux, in which JEMalloc is linked in to the main executable, use
  <b>--soname-synonyms=somalloc=NONE</b>.</div>
</div>
<h1 class="Sh" title="Sh" id="DEBUGGING_VALGRIND_OPTIONS"><a class="selflink" href="#DEBUGGING_VALGRIND_OPTIONS">DEBUGGING
  VALGRIND OPTIONS</a></h1>
There are also some options for debugging Valgrind itself. You shouldn't need to
  use them in the normal run of things. If you wish to see the list, use the
  <b>--help-debug</b> option.
<h1 class="Sh" title="Sh" id="MEMCHECK_OPTIONS"><a class="selflink" href="#MEMCHECK_OPTIONS">MEMCHECK
  OPTIONS</a></h1>
<b>--leak-check=&lt;no|summary|yes|full&gt; [default: summary] </b>
<div style="margin-left: 4.00ex;">When enabled, search for memory leaks when the
  client program finishes. If set to <i>summary</i>, it says how many leaks
  occurred. If set to <i>full</i> or <i>yes</i>, each individual leak will be
  shown in detail and/or counted as an error, as specified by the options
  <b>--show-leak-kinds</b> and <b>--errors-for-leak-kinds</b>.</div>
<div class="Pp"></div>
<b>--leak-resolution=&lt;low|med|high&gt; [default: high] </b>
<div style="margin-left: 4.00ex;">When doing leak checking, determines how
  willing Memcheck is to consider different backtraces to be the same for the
  purposes of merging multiple leaks into a single leak report. When set to
  <i>low</i>, only the first two entries need match. When <i>med</i>, four
  entries have to match. When <i>high</i>, all entries need to match.
<div style="height: 1.00em;">&#x00A0;</div>
For hardcore leak debugging, you probably want to use
  <b>--leak-resolution=high</b> together with <b>--num-callers=40</b> or some
  such large number.
<div style="height: 1.00em;">&#x00A0;</div>
Note that the <b>--leak-resolution</b> setting does not affect Memcheck's
  ability to find leaks. It only changes how the results are presented.</div>
<div class="Pp"></div>
<b>--show-leak-kinds=&lt;set&gt; [default: definite,possible] </b>
<div style="margin-left: 4.00ex;">Specifies the leak kinds to show in a
  <i>full</i> leak search, in one of the following ways:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;a comma separated list of one or more
  of <b>definite indirect possible reachable</b>.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>all</b> to specify the complete set
  (all leak kinds). It is equivalent to
  <b>--show-leak-kinds=definite,indirect,possible,reachable</b>.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>none</b> for the empty set.</div>
</div>
<div class="Pp"></div>
<b>--errors-for-leak-kinds=&lt;set&gt; [default: definite,possible] </b>
<div style="margin-left: 4.00ex;">Specifies the leak kinds to count as errors in
  a <i>full</i> leak search. The <b>&lt;set&gt;</b> is specified similarly to
  <b>--show-leak-kinds</b></div>
<div class="Pp"></div>
<b>--leak-check-heuristics=&lt;set&gt; [default: all] </b>
<div style="margin-left: 4.00ex;">Specifies the set of leak check heuristics to
  be used during leak searches. The heuristics control which interior pointers
  to a block cause it to be considered as reachable. The heuristic set is
  specified in one of the following ways:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;a comma separated list of one or more
  of <b>stdstring length64 newarray multipleinheritance</b>.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>all</b> to activate the complete
  set of heuristics. It is equivalent to
  <b>--leak-check-heuristics=stdstring,length64,newarray,multipleinheritance</b>.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>none</b> for the empty set.</div>
<div class="Pp"></div>
Note that these heuristics are dependent on the layout of the objects produced
  by the C++ compiler. They have been tested with some gcc versions (e.g. 4.4
  and 4.7). They might not work properly with other C++ compilers.</div>
<div class="Pp"></div>
<b>--show-reachable=&lt;yes|no&gt; </b>, <b>--show-possibly-lost=&lt;yes|no&gt;
  </b>
<div style="margin-left: 4.00ex;">These options provide an alternative way to
  specify the leak kinds to show:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>--show-reachable=no
  --show-possibly-lost=yes</b> is equivalent to
  <b>--show-leak-kinds=definite,possible</b>.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>--show-reachable=no
  --show-possibly-lost=no</b> is equivalent to
  <b>--show-leak-kinds=definite</b>.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;<b>--show-reachable=yes</b> is
  equivalent to <b>--show-leak-kinds=all</b>.</div>
<div class="Pp"></div>
Note that <b>--show-possibly-lost=no</b> has no effect if
  <b>--show-reachable=yes</b> is specified.</div>
<div class="Pp"></div>
<b>--undef-value-errors=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">Controls whether Memcheck reports uses of
  undefined value errors. Set this to <i>no</i> if you don't want to see
  undefined value errors. It also has the side effect of speeding up Memcheck
  somewhat.</div>
<div class="Pp"></div>
<b>--track-origins=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">Controls whether Memcheck tracks the origin of
  uninitialised values. By default, it does not, which means that although it
  can tell you that an uninitialised value is being used in a dangerous way, it
  cannot tell you where the uninitialised value came from. This often makes it
  difficult to track down the root problem.
<div style="height: 1.00em;">&#x00A0;</div>
When set to <i>yes</i>, Memcheck keeps track of the origins of all uninitialised
  values. Then, when an uninitialised value error is reported, Memcheck will try
  to show the origin of the value. An origin can be one of the following four
  places: a heap block, a stack allocation, a client request, or miscellaneous
  other sources (eg, a call to <i>brk</i>).
<div style="height: 1.00em;">&#x00A0;</div>
For uninitialised values originating from a heap block, Memcheck shows where the
  block was allocated. For uninitialised values originating from a stack
  allocation, Memcheck can tell you which function allocated the value, but no
  more than that -- typically it shows you the source location of the opening
  brace of the function. So you should carefully check that all of the
  function's local variables are initialised properly.
<div style="height: 1.00em;">&#x00A0;</div>
Performance overhead: origin tracking is expensive. It halves Memcheck's speed
  and increases memory use by a minimum of 100MB, and possibly more.
  Nevertheless it can drastically reduce the effort required to identify the
  root cause of uninitialised value errors, and so is often a programmer
  productivity win, despite running more slowly.
<div style="height: 1.00em;">&#x00A0;</div>
Accuracy: Memcheck tracks origins quite accurately. To avoid very large space
  and time overheads, some approximations are made. It is possible, although
  unlikely, that Memcheck will report an incorrect origin, or not be able to
  identify any origin.
<div style="height: 1.00em;">&#x00A0;</div>
Note that the combination <b>--track-origins=yes</b> and
  <b>--undef-value-errors=no</b> is nonsensical. Memcheck checks for and rejects
  this combination at startup.</div>
<div class="Pp"></div>
<b>--partial-loads-ok=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">Controls how Memcheck handles 32-, 64-, 128-
  and 256-bit naturally aligned loads from addresses for which some bytes are
  addressable and others are not. When <i>yes</i>, such loads do not produce an
  address error. Instead, loaded bytes originating from illegal addresses are
  marked as uninitialised, and those corresponding to legal addresses are
  handled in the normal way.
<div style="height: 1.00em;">&#x00A0;</div>
When <i>no</i>, loads from partially invalid addresses are treated the same as
  loads from completely invalid addresses: an illegal-address error is issued,
  and the resulting bytes are marked as initialised.
<div style="height: 1.00em;">&#x00A0;</div>
Note that code that behaves in this way is in violation of the ISO C/C++
  standards, and should be considered broken. If at all possible, such code
  should be fixed.</div>
<div class="Pp"></div>
<b>--expensive-definedness-checks=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">Controls whether Memcheck should employ more
  precise but also more expensive (time consuming) algorithms when checking the
  definedness of a value. The default setting is not to do that and it is
  usually sufficient. However, for highly optimised code valgrind may sometimes
  incorrectly complain. Invoking valgrind with
  <b>--expensive-definedness-checks=yes</b> helps but comes at a performance
  cost. Runtime degradation of 25% have been observed but the extra cost depends
  a lot on the application at hand.</div>
<div class="Pp"></div>
<b>--keep-stacktraces=alloc|free|alloc-and-free|alloc-then-free|none [default:
  alloc-and-free] </b>
<div style="margin-left: 4.00ex;">Controls which stack trace(s) to keep for
  malloc'd and/or free'd blocks.
<div style="height: 1.00em;">&#x00A0;</div>
With <i>alloc-then-free</i>, a stack trace is recorded at allocation time, and
  is associated with the block. When the block is freed, a second stack trace is
  recorded, and this replaces the allocation stack trace. As a result, any
  &quot;use after free&quot; errors relating to this block can only show a stack
  trace for where the block was freed.
<div style="height: 1.00em;">&#x00A0;</div>
With <i>alloc-and-free</i>, both allocation and the deallocation stack traces
  for the block are stored. Hence a &quot;use after free&quot; error will show
  both, which may make the error easier to diagnose. Compared to
  <i>alloc-then-free</i>, this setting slightly increases Valgrind's memory use
  as the block contains two references instead of one.
<div style="height: 1.00em;">&#x00A0;</div>
With <i>alloc</i>, only the allocation stack trace is recorded (and reported).
  With <i>free</i>, only the deallocation stack trace is recorded (and
  reported). These values somewhat decrease Valgrind's memory and cpu usage.
  They can be useful depending on the error types you are searching for and the
  level of detail you need to analyse them. For example, if you are only
  interested in memory leak errors, it is sufficient to record the allocation
  stack traces.
<div style="height: 1.00em;">&#x00A0;</div>
With <i>none</i>, no stack traces are recorded for malloc and free operations.
  If your program allocates a lot of blocks and/or allocates/frees from many
  different stack traces, this can significantly decrease cpu and/or memory
  required. Of course, few details will be reported for errors related to heap
  blocks.
<div style="height: 1.00em;">&#x00A0;</div>
Note that once a stack trace is recorded, Valgrind keeps the stack trace in
  memory even if it is not referenced by any block. Some programs (for example,
  recursive algorithms) can generate a huge number of stack traces. If Valgrind
  uses too much memory in such circumstances, you can reduce the memory required
  with the options <i>--keep-stacktraces</i> and/or by using a smaller value for
  the option <i>--num-callers</i>.</div>
<div class="Pp"></div>
<b>--freelist-vol=&lt;number&gt; [default: 20000000] </b>
<div style="margin-left: 4.00ex;">When the client program releases memory using
  <b>free</b> (in C) or delete (C++), that memory is not immediately made
  available for re-allocation. Instead, it is marked inaccessible and placed in
  a queue of freed blocks. The purpose is to defer as long as possible the point
  at which freed-up memory comes back into circulation. This increases the
  chance that Memcheck will be able to detect invalid accesses to blocks for
  some significant period of time after they have been freed.
<div style="height: 1.00em;">&#x00A0;</div>
This option specifies the maximum total size, in bytes, of the blocks in the
  queue. The default value is twenty million bytes. Increasing this increases
  the total amount of memory used by Memcheck but may detect invalid uses of
  freed blocks which would otherwise go undetected.</div>
<div class="Pp"></div>
<b>--freelist-big-blocks=&lt;number&gt; [default: 1000000] </b>
<div style="margin-left: 4.00ex;">When making blocks from the queue of freed
  blocks available for re-allocation, Memcheck will in priority re-circulate the
  blocks with a size greater or equal to <b>--freelist-big-blocks</b>. This
  ensures that freeing big blocks (in particular freeing blocks bigger than
  <b>--freelist-vol</b>) does not immediately lead to a re-circulation of all
  (or a lot of) the small blocks in the free list. In other words, this option
  increases the likelihood to discover dangling pointers for the
  &quot;small&quot; blocks, even when big blocks are freed.
<div style="height: 1.00em;">&#x00A0;</div>
Setting a value of 0 means that all the blocks are re-circulated in a FIFO
  order.</div>
<div class="Pp"></div>
<b>--workaround-gcc296-bugs=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, assume that reads and writes
  some small distance below the stack pointer are due to bugs in GCC 2.96, and
  does not report them. The &quot;small distance&quot; is 256 bytes by default.
  Note that GCC 2.96 is the default compiler on some ancient Linux distributions
  (RedHat 7.X) and so you may need to use this option. Do not use it if you do
  not have to, as it can cause real errors to be overlooked. A better
  alternative is to use a more recent GCC in which this bug is fixed.
<div style="height: 1.00em;">&#x00A0;</div>
You may also need to use this option when working with GCC 3.X or 4.X on 32-bit
  PowerPC Linux. This is because GCC generates code which occasionally accesses
  below the stack pointer, particularly for floating-point to/from integer
  conversions. This is in violation of the 32-bit PowerPC ELF specification,
  which makes no provision for locations below the stack pointer to be
  accessible.</div>
<div class="Pp"></div>
<b>--show-mismatched-frees=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">When enabled, Memcheck checks that heap blocks
  are deallocated using a function that matches the allocating function. That
  is, it expects <i>free</i> to be used to deallocate blocks allocated by
  <i>malloc</i>, <i>delete</i> for blocks allocated by <i>new</i>, and
  <i>delete[]</i> for blocks allocated by <i>new[]</i>. If a mismatch is
  detected, an error is reported. This is in general important because in some
  environments, freeing with a non-matching function can cause crashes.
<div style="height: 1.00em;">&#x00A0;</div>
There is however a scenario where such mismatches cannot be avoided. That is
  when the user provides implementations of <i>new</i>/<i>new[]</i> that call
  <i>malloc</i> and of <i>delete</i>/<i>delete[]</i> that call <i>free</i>, and
  these functions are asymmetrically inlined. For example, imagine that
  <i>delete[]</i> is inlined but <i>new[]</i> is not. The result is that
  Memcheck &quot;sees&quot; all <i>delete[]</i> calls as direct calls to
  <i>free</i>, even when the program source contains no mismatched calls.
<div style="height: 1.00em;">&#x00A0;</div>
This causes a lot of confusing and irrelevant error reports.
  <i>--show-mismatched-frees=no</i> disables these checks. It is not generally
  advisable to disable them, though, because you may miss real errors as a
  result.</div>
<div class="Pp"></div>
<b>--ignore-ranges=0xPP-0xQQ[,0xRR-0xSS] </b>
<div style="margin-left: 4.00ex;">Any ranges listed in this option (and multiple
  ranges can be specified, separated by commas) will be ignored by Memcheck's
  addressability checking.</div>
<div class="Pp"></div>
<b>--malloc-fill=&lt;hexnumber&gt; </b>
<div style="margin-left: 4.00ex;">Fills blocks allocated by malloc, new, etc,
  but not by calloc, with the specified byte. This can be useful when trying to
  shake out obscure memory corruption problems. The allocated area is still
  regarded by Memcheck as undefined -- this option only affects its contents.
  Note that <b>--malloc-fill</b> does not affect a block of memory when it is
  used as argument to client requests VALGRIND_MEMPOOL_ALLOC or
  VALGRIND_MALLOCLIKE_BLOCK.</div>
<div class="Pp"></div>
<b>--free-fill=&lt;hexnumber&gt; </b>
<div style="margin-left: 4.00ex;">Fills blocks freed by free, delete, etc, with
  the specified byte value. This can be useful when trying to shake out obscure
  memory corruption problems. The freed area is still regarded by Memcheck as
  not valid for access -- this option only affects its contents. Note that
  <b>--free-fill</b> does not affect a block of memory when it is used as
  argument to client requests VALGRIND_MEMPOOL_FREE or
  VALGRIND_FREELIKE_BLOCK.</div>
<h1 class="Sh" title="Sh" id="CACHEGRIND_OPTIONS"><a class="selflink" href="#CACHEGRIND_OPTIONS">CACHEGRIND
  OPTIONS</a></h1>
<b>--I1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt; </b>
<div style="margin-left: 4.00ex;">Specify the size, associativity and line size
  of the level 1 instruction cache.</div>
<div class="Pp"></div>
<b>--D1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt; </b>
<div style="margin-left: 4.00ex;">Specify the size, associativity and line size
  of the level 1 data cache.</div>
<div class="Pp"></div>
<b>--LL=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt; </b>
<div style="margin-left: 4.00ex;">Specify the size, associativity and line size
  of the last-level cache.</div>
<div class="Pp"></div>
<b>--cache-sim=no|yes [yes] </b>
<div style="margin-left: 4.00ex;">Enables or disables collection of cache access
  and miss counts.</div>
<div class="Pp"></div>
<b>--branch-sim=no|yes [no] </b>
<div style="margin-left: 4.00ex;">Enables or disables collection of branch
  instruction and misprediction counts. By default this is disabled as it slows
  Cachegrind down by approximately 25%. Note that you cannot specify
  <b>--cache-sim=no</b> and <b>--branch-sim=no</b> together, as that would leave
  Cachegrind with no information to collect.</div>
<div class="Pp"></div>
<b>--cachegrind-out-file=&lt;file&gt; </b>
<div style="margin-left: 4.00ex;">Write the profile data to file rather than to
  the default output file, cachegrind.out.&lt;pid&gt;. The <b>%p</b> and
  <b>%q</b> format specifiers can be used to embed the process ID and/or the
  contents of an environment variable in the name, as is the case for the core
  option <b>--log-file</b>.</div>
<h1 class="Sh" title="Sh" id="CALLGRIND_OPTIONS"><a class="selflink" href="#CALLGRIND_OPTIONS">CALLGRIND
  OPTIONS</a></h1>
<b>--callgrind-out-file=&lt;file&gt; </b>
<div style="margin-left: 4.00ex;">Write the profile data to file rather than to
  the default output file, callgrind.out.&lt;pid&gt;. The <b>%p</b> and
  <b>%q</b> format specifiers can be used to embed the process ID and/or the
  contents of an environment variable in the name, as is the case for the core
  option <b>--log-file</b>. When multiple dumps are made, the file name is
  modified further; see below.</div>
<div class="Pp"></div>
<b>--dump-line=&lt;no|yes&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">This specifies that event counting should be
  performed at source line granularity. This allows source annotation for
  sources which are compiled with debug information ( <b>-g</b>).</div>
<div class="Pp"></div>
<b>--dump-instr=&lt;no|yes&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">This specifies that event counting should be
  performed at per-instruction granularity. This allows for assembly code
  annotation. Currently the results can only be displayed by KCachegrind.</div>
<div class="Pp"></div>
<b>--compress-strings=&lt;no|yes&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">This option influences the output format of
  the profile data. It specifies whether strings (file and function names)
  should be identified by numbers. This shrinks the file, but makes it more
  difficult for humans to read (which is not recommended in any case).</div>
<div class="Pp"></div>
<b>--compress-pos=&lt;no|yes&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">This option influences the output format of
  the profile data. It specifies whether numerical positions are always
  specified as absolute values or are allowed to be relative to previous
  numbers. This shrinks the file size.</div>
<div class="Pp"></div>
<b>--combine-dumps=&lt;no|yes&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, when multiple profile data parts
  are to be generated these parts are appended to the same output file. Not
  recommended.</div>
<div class="Pp"></div>
<b>--dump-every-bb=&lt;count&gt; [default: 0, never] </b>
<div style="margin-left: 4.00ex;">Dump profile data every <b>count</b> basic
  blocks. Whether a dump is needed is only checked when Valgrind's internal
  scheduler is run. Therefore, the minimum setting useful is about 100000. The
  count is a 64-bit value to make long dump periods possible.</div>
<div class="Pp"></div>
<b>--dump-before=&lt;function&gt; </b>
<div style="margin-left: 4.00ex;">Dump when entering <b>function</b>.</div>
<div class="Pp"></div>
<b>--zero-before=&lt;function&gt; </b>
<div style="margin-left: 4.00ex;">Zero all costs when entering
  <b>function</b>.</div>
<div class="Pp"></div>
<b>--dump-after=&lt;function&gt; </b>
<div style="margin-left: 4.00ex;">Dump when leaving <b>function</b>.</div>
<div class="Pp"></div>
<b>--instr-atstart=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">Specify if you want Callgrind to start
  simulation and profiling from the beginning of the program. When set to no,
  Callgrind will not be able to collect any information, including calls, but it
  will have at most a slowdown of around 4, which is the minimum Valgrind
  overhead. Instrumentation can be interactively enabled via callgrind_control
  -i on.
<div style="height: 1.00em;">&#x00A0;</div>
Note that the resulting call graph will most probably not contain <b>main</b>,
  but will contain all the functions executed after instrumentation was enabled.
  Instrumentation can also programatically enabled/disabled. See the Callgrind
  include file callgrind.h for the macro you have to use in your source code.
<div style="height: 1.00em;">&#x00A0;</div>
For cache simulation, results will be less accurate when switching on
  instrumentation later in the program run, as the simulator starts with an
  empty cache at that moment. Switch on event collection later to cope with this
  error.</div>
<div class="Pp"></div>
<b>--collect-atstart=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">Specify whether event collection is enabled at
  beginning of the profile run.
<div style="height: 1.00em;">&#x00A0;</div>
To only look at parts of your program, you have two possibilities:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;"> 1.Zero event counters before entering the
  program part you want to profile, and dump the event counters to a file after
  leaving that program part.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;"> 2.Switch on/off collection state as needed to
  only see event counters happening while inside of the program part you want to
  profile.</div>
<div style="height: 1.00em;">&#x00A0;</div>
The second option can be used if the program part you want to profile is called
  many times. Option 1, i.e. creating a lot of dumps is not practical here.
<div style="height: 1.00em;">&#x00A0;</div>
Collection state can be toggled at entry and exit of a given function with the
  option <b>--toggle-collect</b>. If you use this option, collection state
  should be disabled at the beginning. Note that the specification of
  <b>--toggle-collect</b> implicitly sets <b>--collect-state=no</b>.
<div style="height: 1.00em;">&#x00A0;</div>
Collection state can be toggled also by inserting the client request
  CALLGRIND_TOGGLE_COLLECT ; at the needed code positions.</div>
<div class="Pp"></div>
<b>--toggle-collect=&lt;function&gt; </b>
<div style="margin-left: 4.00ex;">Toggle collection on entry/exit of
  <b>function</b>.</div>
<div class="Pp"></div>
<b>--collect-jumps=&lt;no|yes&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">This specifies whether information for
  (conditional) jumps should be collected. As above, callgrind_annotate
  currently is not able to show you the data. You have to use KCachegrind to get
  jump arrows in the annotated code.</div>
<div class="Pp"></div>
<b>--collect-systime=&lt;no|yes&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">This specifies whether information for system
  call times should be collected.</div>
<div class="Pp"></div>
<b>--collect-bus=&lt;no|yes&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">This specifies whether the number of global
  bus events executed should be collected. The event type &quot;Ge&quot; is used
  for these events.</div>
<div class="Pp"></div>
<b>--cache-sim=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">Specify if you want to do full cache
  simulation. By default, only instruction read accesses will be counted
  (&quot;Ir&quot;). With cache simulation, further event counters are enabled:
  Cache misses on instruction reads (&quot;I1mr&quot;/&quot;ILmr&quot;), data
  read accesses (&quot;Dr&quot;) and related cache misses
  (&quot;D1mr&quot;/&quot;DLmr&quot;), data write accesses (&quot;Dw&quot;) and
  related cache misses (&quot;D1mw&quot;/&quot;DLmw&quot;). For more
  information, see Cachegrind: a cache and branch-prediction profiler.</div>
<div class="Pp"></div>
<b>--branch-sim=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">Specify if you want to do branch prediction
  simulation. Further event counters are enabled: Number of executed conditional
  branches and related predictor misses (&quot;Bc&quot;/&quot;Bcm&quot;),
  executed indirect jumps and related misses of the jump address predictor
  (&quot;Bi&quot;/&quot;Bim&quot;).</div>
<h1 class="Sh" title="Sh" id="HELGRIND_OPTIONS"><a class="selflink" href="#HELGRIND_OPTIONS">HELGRIND
  OPTIONS</a></h1>
<b>--free-is-write=no|yes [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled (not the default), Helgrind
  treats freeing of heap memory as if the memory was written immediately before
  the free. This exposes races where memory is referenced by one thread, and
  freed by another, but there is no observable synchronisation event to ensure
  that the reference happens before the free.
<div style="height: 1.00em;">&#x00A0;</div>
This functionality is new in Valgrind 3.7.0, and is regarded as experimental. It
  is not enabled by default because its interaction with custom memory
  allocators is not well understood at present. User feedback is welcomed.</div>
<div class="Pp"></div>
<b>--track-lockorders=no|yes [default: yes] </b>
<div style="margin-left: 4.00ex;">When enabled (the default), Helgrind performs
  lock order consistency checking. For some buggy programs, the large number of
  lock order errors reported can become annoying, particularly if you're only
  interested in race errors. You may therefore find it helpful to disable lock
  order checking.</div>
<div class="Pp"></div>
<b>--history-level=none|approx|full [default: full] </b>
<div style="margin-left: 4.00ex;"><b>--history-level=full</b> (the default)
  causes Helgrind collects enough information about &quot;old&quot; accesses
  that it can produce two stack traces in a race report -- both the stack trace
  for the current access, and the trace for the older, conflicting access. To
  limit memory usage, &quot;old&quot; accesses stack traces are limited to a
  maximum of 8 entries, even if <b>--num-callers</b> value is bigger.
<div style="height: 1.00em;">&#x00A0;</div>
Collecting such information is expensive in both speed and memory, particularly
  for programs that do many inter-thread synchronisation events (locks, unlocks,
  etc). Without such information, it is more difficult to track down the root
  causes of races. Nonetheless, you may not need it in situations where you just
  want to check for the presence or absence of races, for example, when doing
  regression testing of a previously race-free program.
<div style="height: 1.00em;">&#x00A0;</div>
<b>--history-level=none</b> is the opposite extreme. It causes Helgrind not to
  collect any information about previous accesses. This can be dramatically
  faster than <b>--history-level=full</b>.
<div style="height: 1.00em;">&#x00A0;</div>
<b>--history-level=approx</b> provides a compromise between these two extremes.
  It causes Helgrind to show a full trace for the later access, and approximate
  information regarding the earlier access. This approximate information
  consists of two stacks, and the earlier access is guaranteed to have occurred
  somewhere between program points denoted by the two stacks. This is not as
  useful as showing the exact stack for the previous access (as
  <b>--history-level=full</b> does), but it is better than nothing, and it is
  almost as fast as <b>--history-level=none</b>.</div>
<div class="Pp"></div>
<b>--conflict-cache-size=N [default: 1000000] </b>
<div style="margin-left: 4.00ex;">This flag only has any effect at
  <b>--history-level=full</b>.
<div style="height: 1.00em;">&#x00A0;</div>
Information about &quot;old&quot; conflicting accesses is stored in a cache of
  limited size, with LRU-style management. This is necessary because it isn't
  practical to store a stack trace for every single memory access made by the
  program. Historical information on not recently accessed locations is
  periodically discarded, to free up space in the cache.
<div style="height: 1.00em;">&#x00A0;</div>
This option controls the size of the cache, in terms of the number of different
  memory addresses for which conflicting access information is stored. If you
  find that Helgrind is showing race errors with only one stack instead of the
  expected two stacks, try increasing this value.
<div style="height: 1.00em;">&#x00A0;</div>
The minimum value is 10,000 and the maximum is 30,000,000 (thirty times the
  default value). Increasing the value by 1 increases Helgrind's memory
  requirement by very roughly 100 bytes, so the maximum value will easily eat up
  three extra gigabytes or so of memory.</div>
<div class="Pp"></div>
<b>--check-stack-refs=no|yes [default: yes] </b>
<div style="margin-left: 4.00ex;">By default Helgrind checks all data memory
  accesses made by your program. This flag enables you to skip checking for
  accesses to thread stacks (local variables). This can improve performance, but
  comes at the cost of missing races on stack-allocated data.</div>
<div class="Pp"></div>
<b>--ignore-thread-creation=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Controls whether all activities during thread
  creation should be ignored. By default enabled only on Solaris. Solaris
  provides higher throughput, parallelism and scalability than other operating
  systems, at the cost of more fine-grained locking activity. This means for
  example that when a thread is created under glibc, just one big lock is used
  for all thread setup. Solaris libc uses several fine-grained locks and the
  creator thread resumes its activities as soon as possible, leaving for example
  stack and TLS setup sequence to the created thread. This situation confuses
  Helgrind as it assumes there is some false ordering in place between creator
  and created thread; and therefore many types of race conditions in the
  application would not be reported. To prevent such false ordering, this
  command line option is set to yes by default on Solaris. All activity (loads,
  stores, client requests) is therefore ignored during:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;pthread_create() call in the creator
  thread</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;thread creation phase (stack and TLS
  setup) in the created thread</div>
<div style="height: 1.00em;">&#x00A0;</div>
Also new memory allocated during thread creation is untracked, that is race
  reporting is suppressed there. DRD does the same thing implicitly. This is
  necessary because Solaris libc caches many objects and reuses them for
  different threads and that confuses Helgrind.</div>
<h1 class="Sh" title="Sh" id="DRD_OPTIONS"><a class="selflink" href="#DRD_OPTIONS">DRD
  OPTIONS</a></h1>
<b>--check-stack-var=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Controls whether DRD detects data races on
  stack variables. Verifying stack variables is disabled by default because most
  programs do not share stack variables over threads.</div>
<div class="Pp"></div>
<b>--exclusive-threshold=&lt;n&gt; [default: off]</b>
<div style="margin-left: 4.00ex;">Print an error message if any mutex or writer
  lock has been held longer than the time specified in milliseconds. This option
  enables the detection of lock contention.</div>
<div class="Pp"></div>
<b>--join-list-vol=&lt;n&gt; [default: 10]</b>
<div style="margin-left: 4.00ex;">Data races that occur between a statement at
  the end of one thread and another thread can be missed if memory access
  information is discarded immediately after a thread has been joined. This
  option allows to specify for how many joined threads memory access information
  should be retained.</div>
<div class="Pp"></div>
<b> --first-race-only=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">Whether to report only the first data race
  that has been detected on a memory location or all data races that have been
  detected on a memory location.</div>
<div class="Pp"></div>
<b> --free-is-write=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">Whether to report races between accessing
  memory and freeing memory. Enabling this option may cause DRD to run slightly
  slower. Notes:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;Don't enable this option when using
  custom memory allocators that use the VG_USERREQ__MALLOCLIKE_BLOCK and
  VG_USERREQ__FREELIKE_BLOCK because that would result in false positives.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;Don't enable this option when using
  reference-counted objects because that will result in false positives, even
  when that code has been annotated properly with ANNOTATE_HAPPENS_BEFORE and
  ANNOTATE_HAPPENS_AFTER. See e.g. the output of the following command for an
  example: valgrind --tool=drd --free-is-write=yes
  drd/tests/annotate_smart_pointer.</div>
</div>
<div class="Pp"></div>
<b> --report-signal-unlocked=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">Whether to report calls to
  <b>pthread_cond_signal</b> and <b>pthread_cond_broadcast</b> where the mutex
  associated with the signal through <b>pthread_cond_wait</b> or
  <b>pthread_cond_timed_wait</b>is not locked at the time the signal is sent.
  Sending a signal without holding a lock on the associated mutex is a common
  programming error which can cause subtle race conditions and unpredictable
  behavior. There exist some uncommon synchronization patterns however where it
  is safe to send a signal without holding a lock on the associated mutex.</div>
<div class="Pp"></div>
<b>--segment-merging=&lt;yes|no&gt; [default: yes]</b>
<div style="margin-left: 4.00ex;">Controls segment merging. Segment merging is
  an algorithm to limit memory usage of the data race detection algorithm.
  Disabling segment merging may improve the accuracy of the so-called 'other
  segments' displayed in race reports but can also trigger an out of memory
  error.</div>
<div class="Pp"></div>
<b>--segment-merging-interval=&lt;n&gt; [default: 10]</b>
<div style="margin-left: 4.00ex;">Perform segment merging only after the
  specified number of new segments have been created. This is an advanced
  configuration option that allows to choose whether to minimize DRD's memory
  usage by choosing a low value or to let DRD run faster by choosing a slightly
  higher value. The optimal value for this parameter depends on the program
  being analyzed. The default value works well for most programs.</div>
<div class="Pp"></div>
<b>--shared-threshold=&lt;n&gt; [default: off]</b>
<div style="margin-left: 4.00ex;">Print an error message if a reader lock has
  been held longer than the specified time (in milliseconds). This option
  enables the detection of lock contention.</div>
<div class="Pp"></div>
<b>--show-confl-seg=&lt;yes|no&gt; [default: yes]</b>
<div style="margin-left: 4.00ex;">Show conflicting segments in race reports.
  Since this information can help to find the cause of a data race, this option
  is enabled by default. Disabling this option makes the output of DRD more
  compact.</div>
<div class="Pp"></div>
<b>--show-stack-usage=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Print stack usage at thread exit time. When a
  program creates a large number of threads it becomes important to limit the
  amount of virtual memory allocated for thread stacks. This option makes it
  possible to observe how much stack memory has been used by each thread of the
  client program. Note: the DRD tool itself allocates some temporary data on the
  client thread stack. The space necessary for this temporary data must be
  allocated by the client program when it allocates stack memory, but is not
  included in stack usage reported by DRD.</div>
<div class="Pp"></div>
<b>--ignore-thread-creation=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Controls whether all activities during thread
  creation should be ignored. By default enabled only on Solaris. Solaris
  provides higher throughput, parallelism and scalability than other operating
  systems, at the cost of more fine-grained locking activity. This means for
  example that when a thread is created under glibc, just one big lock is used
  for all thread setup. Solaris libc uses several fine-grained locks and the
  creator thread resumes its activities as soon as possible, leaving for example
  stack and TLS setup sequence to the created thread. This situation confuses
  DRD as it assumes there is some false ordering in place between creator and
  created thread; and therefore many types of race conditions in the application
  would not be reported. To prevent such false ordering, this command line
  option is set to yes by default on Solaris. All activity (loads, stores,
  client requests) is therefore ignored during:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;pthread_create() call in the creator
  thread</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">&#x2022;thread creation phase (stack and TLS
  setup) in the created thread</div>
</div>
<div class="Pp"></div>
<b>--trace-addr=&lt;address&gt; [default: none]</b>
<div style="margin-left: 4.00ex;">Trace all load and store activity for the
  specified address. This option may be specified more than once.</div>
<div class="Pp"></div>
<b>--ptrace-addr=&lt;address&gt; [default: none]</b>
<div style="margin-left: 4.00ex;">Trace all load and store activity for the
  specified address and keep doing that even after the memory at that address
  has been freed and reallocated.</div>
<div class="Pp"></div>
<b>--trace-alloc=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Trace all memory allocations and
  deallocations. May produce a huge amount of output.</div>
<div class="Pp"></div>
<b>--trace-barrier=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Trace all barrier activity.</div>
<div class="Pp"></div>
<b>--trace-cond=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Trace all condition variable activity.</div>
<div class="Pp"></div>
<b>--trace-fork-join=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Trace all thread creation and all thread
  termination events.</div>
<div class="Pp"></div>
<b>--trace-hb=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Trace execution of the
  ANNOTATE_HAPPENS_BEFORE(), ANNOTATE_HAPPENS_AFTER() and
  ANNOTATE_HAPPENS_DONE() client requests.</div>
<div class="Pp"></div>
<b>--trace-mutex=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Trace all mutex activity.</div>
<div class="Pp"></div>
<b>--trace-rwlock=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Trace all reader-writer lock activity.</div>
<div class="Pp"></div>
<b>--trace-semaphore=&lt;yes|no&gt; [default: no]</b>
<div style="margin-left: 4.00ex;">Trace all semaphore activity.</div>
<h1 class="Sh" title="Sh" id="MASSIF_OPTIONS"><a class="selflink" href="#MASSIF_OPTIONS">MASSIF
  OPTIONS</a></h1>
<b>--heap=&lt;yes|no&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">Specifies whether heap profiling should be
  done.</div>
<div class="Pp"></div>
<b>--heap-admin=&lt;size&gt; [default: 8] </b>
<div style="margin-left: 4.00ex;">If heap profiling is enabled, gives the number
  of administrative bytes per block to use. This should be an estimate of the
  average, since it may vary. For example, the allocator used by glibc on Linux
  requires somewhere between 4 to 15 bytes per block, depending on various
  factors. That allocator also requires admin space for freed blocks, but Massif
  cannot account for this.</div>
<div class="Pp"></div>
<b>--stacks=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">Specifies whether stack profiling should be
  done. This option slows Massif down greatly, and so is off by default. Note
  that Massif assumes that the main stack has size zero at start-up. This is not
  true, but doing otherwise accurately is difficult. Furthermore, starting at
  zero better indicates the size of the part of the main stack that a user
  program actually has control over.</div>
<div class="Pp"></div>
<b>--pages-as-heap=&lt;yes|no&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">Tells Massif to profile memory at the page
  level rather than at the malloc'd block level. See above for details.</div>
<div class="Pp"></div>
<b>--depth=&lt;number&gt; [default: 30] </b>
<div style="margin-left: 4.00ex;">Maximum depth of the allocation trees recorded
  for detailed snapshots. Increasing it will make Massif run somewhat more
  slowly, use more memory, and produce bigger output files.</div>
<div class="Pp"></div>
<b>--alloc-fn=&lt;name&gt; </b>
<div style="margin-left: 4.00ex;">Functions specified with this option will be
  treated as though they were a heap allocation function such as <b>malloc</b>.
  This is useful for functions that are wrappers to <b>malloc</b> or <b>new</b>,
  which can fill up the allocation trees with uninteresting information. This
  option can be specified multiple times on the command line, to name multiple
  functions.
<div style="height: 1.00em;">&#x00A0;</div>
Note that the named function will only be treated this way if it is the top
  entry in a stack trace, or just below another function treated this way. For
  example, if you have a function <b>malloc1</b> that wraps <b>malloc</b>, and
  <b>malloc2</b> that wraps <b>malloc1</b>, just specifying
  <b>--alloc-fn=malloc2</b> will have no effect. You need to specify
  <b>--alloc-fn=malloc1</b> as well. This is a little inconvenient, but the
  reason is that checking for allocation functions is slow, and it saves a lot
  of time if Massif can stop looking through the stack trace entries as soon as
  it finds one that doesn't match rather than having to continue through all the
  entries.
<div style="height: 1.00em;">&#x00A0;</div>
Note that C++ names are demangled. Note also that overloaded C++ names must be
  written in full. Single quotes may be necessary to prevent the shell from
  breaking them up. For example:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;">
<pre>
--alloc-fn='operator new(unsigned, std::nothrow_t const&amp;)'
</pre>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
</div>
<div class="Pp"></div>
<b>--ignore-fn=&lt;name&gt; </b>
<div style="margin-left: 4.00ex;">Any direct heap allocation (i.e. a call to
  <b>malloc</b>, <b>new</b>, etc, or a call to a function named by an
  <b>--alloc-fn</b> option) that occurs in a function specified by this option
  will be ignored. This is mostly useful for testing purposes. This option can
  be specified multiple times on the command line, to name multiple functions.
<div style="height: 1.00em;">&#x00A0;</div>
Any <b>realloc</b> of an ignored block will also be ignored, even if the
  <b>realloc</b> call does not occur in an ignored function. This avoids the
  possibility of negative heap sizes if ignored blocks are shrunk with
  <b>realloc</b>.
<div style="height: 1.00em;">&#x00A0;</div>
The rules for writing C++ function names are the same as for <b>--alloc-fn</b>
  above.</div>
<div class="Pp"></div>
<b>--threshold=&lt;m.n&gt; [default: 1.0] </b>
<div style="margin-left: 4.00ex;">The significance threshold for heap
  allocations, as a percentage of total memory size. Allocation tree entries
  that account for less than this will be aggregated. Note that this should be
  specified in tandem with ms_print's option of the same name.</div>
<div class="Pp"></div>
<b>--peak-inaccuracy=&lt;m.n&gt; [default: 1.0] </b>
<div style="margin-left: 4.00ex;">Massif does not necessarily record the actual
  global memory allocation peak; by default it records a peak only when the
  global memory allocation size exceeds the previous peak by at least 1.0%. This
  is because there can be many local allocation peaks along the way, and doing a
  detailed snapshot for every one would be expensive and wasteful, as all but
  one of them will be later discarded. This inaccuracy can be changed (even to
  0.0%) via this option, but Massif will run drastically slower as the number
  approaches zero.</div>
<div class="Pp"></div>
<b>--time-unit=&lt;i|ms|B&gt; [default: i] </b>
<div style="margin-left: 4.00ex;">The time unit used for the profiling. There
  are three possibilities: instructions executed (i), which is good for most
  cases; real (wallclock) time (ms, i.e. milliseconds), which is sometimes
  useful; and bytes allocated/deallocated on the heap and/or stack (B), which is
  useful for very short-run programs, and for testing purposes, because it is
  the most reproducible across different machines.</div>
<div class="Pp"></div>
<b>--detailed-freq=&lt;n&gt; [default: 10] </b>
<div style="margin-left: 4.00ex;">Frequency of detailed snapshots. With
  <b>--detailed-freq=1</b>, every snapshot is detailed.</div>
<div class="Pp"></div>
<b>--max-snapshots=&lt;n&gt; [default: 100] </b>
<div style="margin-left: 4.00ex;">The maximum number of snapshots recorded. If
  set to N, for all programs except very short-running ones, the final number of
  snapshots will be between N/2 and N.</div>
<div class="Pp"></div>
<b>--massif-out-file=&lt;file&gt; [default: massif.out.%p] </b>
<div style="margin-left: 4.00ex;">Write the profile data to file rather than to
  the default output file, massif.out.&lt;pid&gt;. The <b>%p</b> and <b>%q</b>
  format specifiers can be used to embed the process ID and/or the contents of
  an environment variable in the name, as is the case for the core option
  <b>--log-file</b>.</div>
<h1 class="Sh" title="Sh" id="SGCHECK_OPTIONS"><a class="selflink" href="#SGCHECK_OPTIONS">SGCHECK
  OPTIONS</a></h1>
There are no SGCheck-specific command-line options at present.
<h1 class="Sh" title="Sh" id="BBV_OPTIONS"><a class="selflink" href="#BBV_OPTIONS">BBV
  OPTIONS</a></h1>
<b>--bb-out-file=&lt;name&gt; [default: bb.out.%p] </b>
<div style="margin-left: 4.00ex;">This option selects the name of the basic
  block vector file. The <b>%p</b> and <b>%q</b> format specifiers can be used
  to embed the process ID and/or the contents of an environment variable in the
  name, as is the case for the core option <b>--log-file</b>.</div>
<div class="Pp"></div>
<b>--pc-out-file=&lt;name&gt; [default: pc.out.%p] </b>
<div style="margin-left: 4.00ex;">This option selects the name of the PC file.
  This file holds program counter addresses and function name info for the
  various basic blocks. This can be used in conjunction with the basic block
  vector file to fast-forward via function names instead of just instruction
  counts. The <b>%p</b> and <b>%q</b> format specifiers can be used to embed the
  process ID and/or the contents of an environment variable in the name, as is
  the case for the core option <b>--log-file</b>.</div>
<div class="Pp"></div>
<b>--interval-size=&lt;number&gt; [default: 100000000] </b>
<div style="margin-left: 4.00ex;">This option selects the size of the interval
  to use. The default is 100 million instructions, which is a commonly used
  value. Other sizes can be used; smaller intervals can help programs with
  finer-grained phases. However smaller interval size can lead to accuracy
  issues due to warm-up effects (When fast-forwarding the various architectural
  features will be un-initialized, and it will take some number of instructions
  before they &quot;warm up&quot; to the state a full simulation would be at
  without the fast-forwarding. Large interval sizes tend to mitigate
  this.)</div>
<div class="Pp"></div>
<b>--instr-count-only [default: no] </b>
<div style="margin-left: 4.00ex;">This option tells the tool to only display
  instruction count totals, and to not generate the actual basic block vector
  file. This is useful for debugging, and for gathering instruction count info
  without generating the large basic block vector files.</div>
<h1 class="Sh" title="Sh" id="LACKEY_OPTIONS"><a class="selflink" href="#LACKEY_OPTIONS">LACKEY
  OPTIONS</a></h1>
<b>--basic-counts=&lt;no|yes&gt; [default: yes] </b>
<div style="margin-left: 4.00ex;">When enabled, Lackey prints the following
  statistics and information about the execution of the client program:
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;"> 1.The number of calls to the function
  specified by the <b>--fnname</b> option (the default is main). If the program
  has had its symbols stripped, the count will always be zero.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;"> 2.The number of conditional branches
  encountered and the number and proportion of those taken.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;"> 3.The number of superblocks entered and
  completed by the program. Note that due to optimisations done by the JIT, this
  is not at all an accurate value.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;"> 4.The number of guest (x86, amd64, ppc, etc.)
  instructions and IR statements executed. IR is Valgrind's RISC-like
  intermediate representation via which all instrumentation is done.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;"> 5.Ratios between some of these counts.</div>
<div style="height: 1.00em;">&#x00A0;</div>
<div style="margin-left: 4.00ex;"> 6.The exit code of the client program.</div>
</div>
<div class="Pp"></div>
<b>--detailed-counts=&lt;no|yes&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, Lackey prints a table containing
  counts of loads, stores and ALU operations, differentiated by their IR types.
  The IR types are identified by their IR name (&quot;I1&quot;, &quot;I8&quot;,
  ... &quot;I128&quot;, &quot;F32&quot;, &quot;F64&quot;, and
  &quot;V128&quot;).</div>
<div class="Pp"></div>
<b>--trace-mem=&lt;no|yes&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, Lackey prints the size and
  address of almost every memory access made by the program. See the comments at
  the top of the file lackey/lk_main.c for details about the output format, how
  it works, and inaccuracies in the address trace. Note that this option
  produces immense amounts of output.</div>
<div class="Pp"></div>
<b>--trace-superblocks=&lt;no|yes&gt; [default: no] </b>
<div style="margin-left: 4.00ex;">When enabled, Lackey prints out the address of
  every superblock (a single entry, multiple exit, linear chunk of code)
  executed by the program. This is primarily of interest to Valgrind developers.
  See the comments at the top of the file lackey/lk_main.c for details about the
  output format. Note that this option produces large amounts of output.</div>
<div class="Pp"></div>
<b>--fnname=&lt;name&gt; [default: main] </b>
<div style="margin-left: 4.00ex;">Changes the function for which calls are
  counted when <b>--basic-counts=yes</b> is specified.</div>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
cg_annotate(1), callgrind_annotate(1), callgrind_control(1), ms_print(1),
  $INSTALL/share/doc/valgrind/html/index.html or
  http://www.valgrind.org/docs/manual/index.html, <b>Debugging your program
  using Valgrind's gdbserver and GDB</b>[1] <b>vgdb</b>[2], <b>Valgrind monitor
  commands</b>[3], <b>The Commentary</b>[4], <b>Scheduling and Multi-Thread
  Performance</b>[5], <b>Cachegrind: a cache and branch-prediction
  profiler</b>[6].
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
See the AUTHORS file in the valgrind distribution for a comprehensive list of
  authors.
<div class="Pp"></div>
This manpage was written by Andres Roldan &lt;aroldan@debian.org&gt; and the
  Valgrind developers.
<h1 class="Sh" title="Sh" id="NOTES"><a class="selflink" href="#NOTES">NOTES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"> 1.</dt>
  <dd class="It-tag">Debugging your program using Valgrind's gdbserver and
    GDB</dd>
</dl>
<div style="margin-left: 4.00ex;">http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.gdbserver</div>
<dl class="Bl-tag">
  <dt class="It-tag"> 2.</dt>
  <dd class="It-tag">vgdb</dd>
</dl>
<div style="margin-left: 4.00ex;">http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.vgdb</div>
<dl class="Bl-tag">
  <dt class="It-tag"> 3.</dt>
  <dd class="It-tag">Valgrind monitor commands</dd>
</dl>
<div style="margin-left: 4.00ex;">http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.valgrind-monitor-commands</div>
<dl class="Bl-tag">
  <dt class="It-tag"> 4.</dt>
  <dd class="It-tag">The Commentary</dd>
</dl>
<div style="margin-left: 4.00ex;">http://www.valgrind.org/docs/manual/manual-core.html#manual-core.comment</div>
<dl class="Bl-tag">
  <dt class="It-tag"> 5.</dt>
  <dd class="It-tag">Scheduling and Multi-Thread Performance</dd>
</dl>
<div style="margin-left: 4.00ex;">http://www.valgrind.org/docs/manual/manual-core.html#manual-core.pthreads_perf_sched</div>
<dl class="Bl-tag">
  <dt class="It-tag"> 6.</dt>
  <dd class="It-tag">Cachegrind: a cache and branch-prediction profiler</dd>
</dl>
<div style="margin-left: 4.00ex;">http://www.valgrind.org/docs/manual/cg-manual.html</div>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">09/23/2015</td>
    <td class="foot-os">Release 3.11.0</td>
  </tr>
</table>
</body>
</html>
