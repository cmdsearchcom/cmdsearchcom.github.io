<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:37:33 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>BASH(1) General Commands Manual BASH(1)</p>

<p style="margin-top: 1em">NAME <br>
bash - GNU Bourne-Again SHell</p>

<p style="margin-top: 1em">SYNOPSIS <br>
bash [options] [file]</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Bash is Copyright (C) 1989-2011 by the Free Software
Foundation, Inc.</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Bash is an sh-compatible command language interpreter that
executes commands read from the standard input or from a
file. Bash also incorporates useful features from the Korn
<br>
and C shells (ksh and csh).</p>

<p style="margin-top: 1em">Bash is intended to be a
conformant implementation of the Shell and Utilities portion
of the IEEE POSIX specification (IEEE Standard 1003.1). Bash
can be configured to be POSIX- <br>
conformant by default.</p>

<p style="margin-top: 1em">OPTIONS <br>
All of the single-character shell options documented in the
description of the set builtin command can be used as
options when the shell is invoked. In addition, bash
inter&acirc; <br>
prets the following options when it is invoked:</p>

<p style="margin-top: 1em">-c string If the -c option is
present, then commands are read from string. If there are
arguments after the string, they are assigned to the
positional parameters, starting with <br>
$0. <br>
-i If the -i option is present, the shell is interactive.
<br>
-l Make bash act as if it had been invoked as a login shell
(see INVOCATION below). <br>
-r If the -r option is present, the shell becomes restricted
(see RESTRICTED SHELL below). <br>
-s If the -s option is present, or if no arguments remain
after option processing, then commands are read from the
standard input. This option allows the positional <br>
parameters to be set when invoking an interactive shell.
<br>
-D A list of all double-quoted strings preceded by $ is
printed on the standard output. These are the strings that
are subject to language translation when the current <br>
locale is not C or POSIX. This implies the -n option; no
commands will be executed. <br>
[-+]O [shopt_option] <br>
shopt_option is one of the shell options accepted by the
shopt builtin (see SHELL BUILTIN COMMANDS below). If
shopt_option is present, -O sets the value of that <br>
option; +O unsets it. If shopt_option is not supplied, the
names and values of the shell options accepted by shopt are
printed on the standard output. If the invoca&acirc; <br>
tion option is +O, the output is displayed in a format that
may be reused as input. <br>
-- A -- signals the end of options and disables further
option processing. Any arguments after the -- are treated as
filenames and arguments. An argument of - is equiva&acirc;
<br>
lent to --.</p>

<p style="margin-top: 1em">Bash also interprets a number of
multi-character options. These options must appear on the
command line before the single-character options to be
recognized.</p>

<p style="margin-top: 1em">--debugger <br>
Arrange for the debugger profile to be executed before the
shell starts. Turns on extended debugging mode (see the
description of the extdebug option to the shopt builtin <br>
below). <br>
--dump-po-strings <br>
Equivalent to -D, but the output is in the GNU gettext po
(portable object) file format. <br>
--dump-strings <br>
Equivalent to -D. <br>
--help Display a usage message on standard output and exit
successfully. <br>
--init-file file <br>
--rcfile file <br>
Execute commands from file instead of the standard personal
initialization file ~/.bashrc if the shell is interactive
(see INVOCATION below).</p>

<p style="margin-top: 1em">--login <br>
Equivalent to -l.</p>

<p style="margin-top: 1em">--noediting <br>
Do not use the GNU readline library to read command lines
when the shell is interactive.</p>

<p style="margin-top: 1em">--noprofile <br>
Do not read either the system-wide startup file /etc/profile
or any of the personal initialization files ~/.bash_profile,
~/.bash_login, or ~/.profile. By default, bash <br>
reads these files when it is invoked as a login shell (see
INVOCATION below).</p>

<p style="margin-top: 1em">--norc Do not read and execute
the personal initialization file ~/.bashrc if the shell is
interactive. This option is on by default if the shell is
invoked as sh.</p>

<p style="margin-top: 1em">--posix <br>
Change the behavior of bash where the default operation
differs from the POSIX standard to match the standard (posix
mode).</p>

<p style="margin-top: 1em">--restricted <br>
The shell becomes restricted (see RESTRICTED SHELL
below).</p>

<p style="margin-top: 1em">--rpm-requires <br>
Produce the list of files that are required for the shell
script to run. This implies &rsquo;-n&rsquo; and is subject
to the same limitations as compile time error checking
checking; <br>
Command substitutions, Conditional expressions and eval
builtin are not parsed so some dependencies may be
missed.</p>

<p style="margin-top: 1em">--verbose <br>
Equivalent to -v.</p>

<p style="margin-top: 1em">--version <br>
Show version information for this instance of bash on the
standard output and exit successfully.</p>

<p style="margin-top: 1em">ARGUMENTS <br>
If arguments remain after option processing, and neither the
-c nor the -s option has been supplied, the first argument
is assumed to be the name of a file containing shell
com&acirc; <br>
mands. If bash is invoked in this fashion, $0 is set to the
name of the file, and the positional parameters are set to
the remaining arguments. Bash reads and executes commands
<br>
from this file, then exits. Bash&rsquo;s exit status is the
exit status of the last command executed in the script. If
no commands are executed, the exit status is 0. An attempt
is <br>
first made to open the file in the current directory, and,
if no file is found, then the shell searches the directories
in PATH for the script.</p>

<p style="margin-top: 1em">INVOCATION <br>
A login shell is one whose first character of argument zero
is a -, or one started with the --login option.</p>

<p style="margin-top: 1em">An interactive shell is one
started without non-option arguments and without the -c
option whose standard input and error are both connected to
terminals (as determined by <br>
isatty(3)), or one started with the -i option. PS1 is set
and $- includes i if bash is interactive, allowing a shell
script or a startup file to test this state.</p>

<p style="margin-top: 1em">The following paragraphs
describe how bash executes its startup files. If any of the
files exist but cannot be read, bash reports an error.
Tildes are expanded in file names as <br>
described below under Tilde Expansion in the EXPANSION
section.</p>

<p style="margin-top: 1em">When bash is invoked as an
interactive login shell, or as a non-interactive shell with
the --login option, it first reads and executes commands
from the file /etc/profile, if <br>
that file exists. After reading that file, it looks for
~/.bash_profile, ~/.bash_login, and ~/.profile, in that
order, and reads and executes commands from the first one
that <br>
exists and is readable. The --noprofile option may be used
when the shell is started to inhibit this behavior.</p>

<p style="margin-top: 1em">When a login shell exits, bash
reads and executes commands from the files ~/.bash_logout
and /etc/bash.bash_logout, if the files exists.</p>

<p style="margin-top: 1em">When an interactive shell that
is not a login shell is started, bash reads and executes
commands from ~/.bashrc, if that file exists. This may be
inhibited by using the --norc <br>
option. The --rcfile file option will force bash to read and
execute commands from file instead of ~/.bashrc.</p>

<p style="margin-top: 1em">When bash is started
non-interactively, to run a shell script, for example, it
looks for the variable BASH_ENV in the environment, expands
its value if it appears there, and uses <br>
the expanded value as the name of a file to read and
execute. Bash behaves as if the following command were
executed: <br>
if [ -n &quot;$BASH_ENV&quot; ]; then .
&quot;$BASH_ENV&quot;; fi <br>
but the value of the PATH variable is not used to search for
the file name.</p>

<p style="margin-top: 1em">If bash is invoked with the name
sh, it tries to mimic the startup behavior of historical
versions of sh as closely as possible, while conforming to
the POSIX standard as well. <br>
When invoked as an interactive login shell, or a
non-interactive shell with the --login option, it first
attempts to read and execute commands from /etc/profile and
~/.profile, <br>
in that order. The --noprofile option may be used to inhibit
this behavior. When invoked as an interactive shell with the
name sh, bash looks for the variable ENV, expands its <br>
value if it is defined, and uses the expanded value as the
name of a file to read and execute. Since a shell invoked as
sh does not attempt to read and execute commands from any
<br>
other startup files, the --rcfile option has no effect. A
non-interactive shell invoked with the name sh does not
attempt to read any other startup files. When invoked as sh,
<br>
bash enters posix mode after the startup files are read.</p>

<p style="margin-top: 1em">When bash is started in posix
mode, as with the --posix command line option, it follows
the POSIX standard for startup files. In this mode,
interactive shells expand the ENV <br>
variable and commands are read and executed from the file
whose name is the expanded value. No other startup files are
read.</p>

<p style="margin-top: 1em">Bash attempts to determine when
it is being run with its standard input connected to a
network connection, as when executed by the remote shell
daemon, usually rshd, or the <br>
secure shell daemon sshd. If bash determines it is being run
in this fashion, it reads and executes commands from
~/.bashrc, if that file exists and is readable. It will not
do <br>
this if invoked as sh. The --norc option may be used to
inhibit this behavior, and the --rcfile option may be used
to force another file to be read, but rshd does not
generally <br>
invoke the shell with those options or allow them to be
specified.</p>

<p style="margin-top: 1em">If the shell is started with the
effective user (group) id not equal to the real user (group)
id, and the -p option is not supplied, no startup files are
read, shell functions <br>
are not inherited from the environment, the SHELLOPTS,
BASHOPTS, CDPATH, and GLOBIGNORE variables, if they appear
in the environment, are ignored, and the effective user id
is <br>
set to the real user id. If the -p option is supplied at
invocation, the startup behavior is the same, but the
effective user id is not reset.</p>

<p style="margin-top: 1em">DEFINITIONS <br>
The following definitions are used throughout the rest of
this document. <br>
blank A space or tab. <br>
word A sequence of characters considered as a single unit by
the shell. Also known as a token. <br>
name A word consisting only of alphanumeric characters and
underscores, and beginning with an alphabetic character or
an underscore. Also referred to as an identifier. <br>
metacharacter <br>
A character that, when unquoted, separates words. One of the
following: <br>
| &amp; ; ( ) &lt; &gt; space tab <br>
control operator <br>
A token that performs a control function. It is one of the
following symbols: <br>
|| &amp; &amp;&amp; ; ;; ( ) | |&amp; &lt;newline&gt;</p>

<p style="margin-top: 1em">RESERVED WORDS <br>
Reserved words are words that have a special meaning to the
shell. The following words are recognized as reserved when
unquoted and either the first word of a simple command <br>
(see SHELL GRAMMAR below) or the third word of a case or for
command:</p>

<p style="margin-top: 1em">! case do done elif else esac fi
for function if in select then until while { } time [[
]]</p>

<p style="margin-top: 1em">SHELL GRAMMAR <br>
Simple Commands <br>
A simple command is a sequence of optional variable
assignments followed by blank-separated words and
redirections, and terminated by a control operator. The
first word speci&acirc; <br>
fies the command to be executed, and is passed as argument
zero. The remaining words are passed as arguments to the
invoked command.</p>

<p style="margin-top: 1em">The return value of a simple
command is its exit status, or 128+n if the command is
terminated by signal n.</p>

<p style="margin-top: 1em">Pipelines <br>
A pipeline is a sequence of one or more commands separated
by one of the control operators | or |&amp;. The format for
a pipeline is:</p>

<p style="margin-top: 1em">[time [-p]] [ ! ] command [
[|&acirc;&ordf;|&amp;] command2 ... ]</p>

<p style="margin-top: 1em">The standard output of command
is connected via a pipe to the standard input of command2.
This connection is performed before any redirections
specified by the command (see RE&acirc; <br>
DIRECTION below). If |&amp; is used, the standard error of
command is connected to command2&rsquo;s standard input
through the pipe; it is shorthand for 2&gt;&amp;1 |. This
implicit redirection <br>
of the standard error is performed after any redirections
specified by the command.</p>

<p style="margin-top: 1em">The return status of a pipeline
is the exit status of the last command, unless the pipefail
option is enabled. If pipefail is enabled, the
pipeline&rsquo;s return status is the value <br>
of the last (rightmost) command to exit with a non-zero
status, or zero if all commands exit successfully. If the
reserved word ! precedes a pipeline, the exit status of that
<br>
pipeline is the logical negation of the exit status as
described above. The shell waits for all commands in the
pipeline to terminate before returning a value.</p>

<p style="margin-top: 1em">If the time reserved word
precedes a pipeline, the elapsed as well as user and system
time consumed by its execution are reported when the
pipeline terminates. The -p option <br>
changes the output format to that specified by POSIX. When
the shell is in posix mode, it does not recognize time as a
reserved word if the next token begins with a
&lsquo;-&rsquo;. The <br>
TIMEFORMAT variable may be set to a format string that
specifies how the timing information should be displayed;
see the description of TIMEFORMAT under Shell Variables
below.</p>

<p style="margin-top: 1em">When the shell is in posix mode,
time may be followed by a newline. In this case, the shell
displays the total user and system time consumed by the
shell and its children. The <br>
TIMEFORMAT variable may be used to specify the format of the
time information.</p>

<p style="margin-top: 1em">Each command in a pipeline is
executed as a separate process (i.e., in a subshell).</p>

<p style="margin-top: 1em">Lists <br>
A list is a sequence of one or more pipelines separated by
one of the operators ;, &amp;, &amp;&amp;, or ||, and
optionally terminated by one of ;, &amp;, or
&lt;newline&gt;.</p>

<p style="margin-top: 1em">Of these list operators,
&amp;&amp; and || have equal precedence, followed by ; and
&amp;, which have equal precedence.</p>

<p style="margin-top: 1em">A sequence of one or more
newlines may appear in a list instead of a semicolon to
delimit commands.</p>

<p style="margin-top: 1em">If a command is terminated by
the control operator &amp;, the shell executes the command
in the background in a subshell. The shell does not wait for
the command to finish, and the <br>
return status is 0. Commands separated by a ; are executed
sequentially; the shell waits for each command to terminate
in turn. The return status is the exit status of the last
<br>
command executed.</p>

<p style="margin-top: 1em">AND and OR lists are sequences
of one of more pipelines separated by the &amp;&amp; and ||
control operators, respectively. AND and OR lists are
executed with left associativity. An <br>
AND list has the form</p>

<p style="margin-top: 1em">command1 &amp;&amp; command2</p>

<p style="margin-top: 1em">command2 is executed if, and
only if, command1 returns an exit status of zero.</p>

<p style="margin-top: 1em">An OR list has the form</p>

<p style="margin-top: 1em">command1 || command2</p>

<p style="margin-top: 1em">command2 is executed if and only
if command1 returns a non-zero exit status. The return
status of AND and OR lists is the exit status of the last
command executed in the list.</p>

<p style="margin-top: 1em">Compound Commands <br>
A compound command is one of the following:</p>

<p style="margin-top: 1em">(list) list is executed in a
subshell environment (see COMMAND EXECUTION ENVIRONMENT
below). Variable assignments and builtin commands that
affect the shell&rsquo;s environment do not <br>
remain in effect after the command completes. The return
status is the exit status of list.</p>

<p style="margin-top: 1em">{ list; } <br>
list is simply executed in the current shell environment.
list must be terminated with a newline or semicolon. This is
known as a group command. The return status is <br>
the exit status of list. Note that unlike the metacharacters
( and ), { and } are reserved words and must occur where a
reserved word is permitted to be recognized. <br>
Since they do not cause a word break, they must be separated
from list by whitespace or another shell metacharacter.</p>

<p style="margin-top: 1em">((expression)) <br>
The expression is evaluated according to the rules described
below under ARITHMETIC EVALUATION. If the value of the
expression is non-zero, the return status is 0; other&acirc;
<br>
wise the return status is 1. This is exactly equivalent to
let &quot;expression&quot;.</p>

<p style="margin-top: 1em">[[ expression ]] <br>
Return a status of 0 or 1 depending on the evaluation of the
conditional expression expression. Expressions are composed
of the primaries described below under CONDI&acirc; <br>
TIONAL EXPRESSIONS. Word splitting and pathname expansion
are not performed on the words between the [[ and ]]; tilde
expansion, parameter and variable expansion, arith&acirc;
<br>
metic expansion, command substitution, process substitution,
and quote removal are performed. Conditional operators such
as -f must be unquoted to be recognized as pri&acirc; <br>
maries.</p>

<p style="margin-top: 1em">When used with [[, the &lt; and
&gt; operators sort lexicographically using the current
locale.</p>

<p style="margin-top: 1em">When the == and != operators are
used, the string to the right of the operator is considered
a pattern and matched according to the rules described below
under Pattern <br>
Matching. If the shell option nocasematch is enabled, the
match is performed without regard to the case of alphabetic
characters. The return value is 0 if the string <br>
matches (==) or does not match (!=) the pattern, and 1
otherwise. Any part of the pattern may be quoted to force it
to be matched as a string.</p>

<p style="margin-top: 1em">An additional binary operator,
=~, is available, with the same precedence as == and !=.
When it is used, the string to the right of the operator is
considered an extended <br>
regular expression and matched accordingly (as in regex(3)).
The return value is 0 if the string matches the pattern, and
1 otherwise. If the regular expression is syn&acirc; <br>
tactically incorrect, the conditional expression&rsquo;s
return value is 2. If the shell option nocasematch is
enabled, the match is performed without regard to the case
of <br>
alphabetic characters. Any part of the pattern may be quoted
to force it to be matched as a string. Substrings matched by
parenthesized subexpressions within the regular <br>
expression are saved in the array variable BASH_REMATCH. The
element of BASH_REMATCH with index 0 is the portion of the
string matching the entire regular expression. <br>
The element of BASH_REMATCH with index n is the portion of
the string matching the nth parenthesized subexpression.</p>

<p style="margin-top: 1em">Expressions may be combined
using the following operators, listed in decreasing order of
precedence:</p>

<p style="margin-top: 1em">( expression ) <br>
Returns the value of expression. This may be used to
override the normal precedence of operators. <br>
! expression <br>
True if expression is false. <br>
expression1 &amp;&amp; expression2 <br>
True if both expression1 and expression2 are true. <br>
expression1 || expression2 <br>
True if either expression1 or expression2 is true.</p>

<p style="margin-top: 1em">The &amp;&amp; and || operators
do not evaluate expression2 if the value of expression1 is
sufficient to determine the return value of the entire
conditional expression.</p>

<p style="margin-top: 1em">for name [ [ in [ word ... ] ] ;
] do list ; done <br>
The list of words following in is expanded, generating a
list of items. The variable name is set to each element of
this list in turn, and list is executed each time. If <br>
the in word is omitted, the for command executes list once
for each positional parameter that is set (see PARAMETERS
below). The return status is the exit status of the <br>
last command that executes. If the expansion of the items
following in results in an empty list, no commands are
executed, and the return status is 0.</p>

<p style="margin-top: 1em">for (( expr1 ; expr2 ; expr3 ))
; do list ; done <br>
First, the arithmetic expression expr1 is evaluated
according to the rules described below under ARITHMETIC
EVALUATION. The arithmetic expression expr2 is then
evaluated <br>
repeatedly until it evaluates to zero. Each time expr2
evaluates to a non-zero value, list is executed and the
arithmetic expression expr3 is evaluated. If any
expres&acirc; <br>
sion is omitted, it behaves as if it evaluates to 1. The
return value is the exit status of the last command in list
that is executed, or false if any of the expressions <br>
is invalid.</p>

<p style="margin-top: 1em">select name [ in word ] ; do
list ; done <br>
The list of words following in is expanded, generating a
list of items. The set of expanded words is printed on the
standard error, each preceded by a number. If the in <br>
word is omitted, the positional parameters are printed (see
PARAMETERS below). The PS3 prompt is then displayed and a
line read from the standard input. If the line con&acirc;
<br>
sists of a number corresponding to one of the displayed
words, then the value of name is set to that word. If the
line is empty, the words and prompt are displayed again.
<br>
If EOF is read, the command completes. Any other value read
causes name to be set to null. The line read is saved in the
variable REPLY. The list is executed after each <br>
selection until a break command is executed. The exit status
of select is the exit status of the last command executed in
list, or zero if no commands were executed.</p>

<p style="margin-top: 1em">case word in [ [(] pattern [ |
pattern ] ... ) list ;; ] ... esac <br>
A case command first expands word, and tries to match it
against each pattern in turn, using the same matching rules
as for pathname expansion (see Pathname Expansion <br>
below). The word is expanded using tilde expansion,
parameter and variable expansion, arithmetic substitution,
command substitution, process substitution and quote <br>
removal. Each pattern examined is expanded using tilde
expansion, parameter and variable expansion, arithmetic
substitution, command substitution, and process
substitu&acirc; <br>
tion. If the shell option nocasematch is enabled, the match
is performed without regard to the case of alphabetic
characters. When a match is found, the corresponding <br>
list is executed. If the ;; operator is used, no subsequent
matches are attempted after the first pattern match. Using
;&amp; in place of ;; causes execution to continue <br>
with the list associated with the next set of patterns.
Using ;;&amp; in place of ;; causes the shell to test the
next pattern list in the statement, if any, and execute any
<br>
associated list on a successful match. The exit status is
zero if no pattern matches. Otherwise, it is the exit status
of the last command executed in list.</p>

<p style="margin-top: 1em">if list; then list; [ elif list;
then list; ] ... [ else list; ] fi <br>
The if list is executed. If its exit status is zero, the
then list is executed. Otherwise, each elif list is executed
in turn, and if its exit status is zero, the corre&acirc;
<br>
sponding then list is executed and the command completes.
Otherwise, the else list is executed, if present. The exit
status is the exit status of the last command exe&acirc;
<br>
cuted, or zero if no condition tested true.</p>

<p style="margin-top: 1em">while list-1; do list-2; done
<br>
until list-1; do list-2; done <br>
The while command continuously executes the list list-2 as
long as the last command in the list list-1 returns an exit
status of zero. The until command is identical to <br>
the while command, except that the test is negated; list-2
is executed as long as the last command in list-1 returns a
non-zero exit status. The exit status of the while <br>
and until commands is the exit status of the last command
executed in list-2, or zero if none was executed.</p>

<p style="margin-top: 1em">Coprocesses <br>
A coprocess is a shell command preceded by the coproc
reserved word. A coprocess is executed asynchronously in a
subshell, as if the command had been terminated with the
&amp; con&acirc; <br>
trol operator, with a two-way pipe established between the
executing shell and the coprocess.</p>

<p style="margin-top: 1em">The format for a coprocess
is:</p>

<p style="margin-top: 1em">coproc [NAME] command
[redirections]</p>

<p style="margin-top: 1em">This creates a coprocess named
NAME. If NAME is not supplied, the default name is COPROC.
NAME must not be supplied if command is a simple command
(see above); otherwise, it is <br>
interpreted as the first word of the simple command. When
the coproc is executed, the shell creates an array variable
(see Arrays below) named NAME in the context of the
execut&acirc; <br>
ing shell. The standard output of command is connected via a
pipe to a file descriptor in the executing shell, and that
file descriptor is assigned to NAME[0]. The standard <br>
input of command is connected via a pipe to a file
descriptor in the executing shell, and that file descriptor
is assigned to NAME[1]. This pipe is established before any
redi&acirc; <br>
rections specified by the command (see REDIRECTION below).
The file descriptors can be utilized as arguments to shell
commands and redirections using standard word expansions.
<br>
The process ID of the shell spawned to execute the coprocess
is available as the value of the variable NAME_PID. The wait
builtin command may be used to wait for the coprocess <br>
to terminate.</p>

<p style="margin-top: 1em">The return status of a coprocess
is the exit status of command.</p>

<p style="margin-top: 1em">Shell Function Definitions <br>
A shell function is an object that is called like a simple
command and executes a compound command with a new set of
positional parameters. Shell functions are declared as
fol&acirc; <br>
lows:</p>

<p style="margin-top: 1em">name () compound-command
[redirection] <br>
function name [()] compound-command [redirection] <br>
This defines a function named name. The reserved word
function is optional. If the function reserved word is
supplied, the parentheses are optional. The body of the <br>
function is the compound command compound-command (see
Compound Commands above). That command is usually a list of
commands between { and }, but may be any command listed <br>
under Compound Commands above. compound-command is executed
whenever name is specified as the name of a simple command.
Any redirections (see REDIRECTION below) speci&acirc; <br>
fied when a function is defined are performed when the
function is executed. The exit status of a function
definition is zero unless a syntax error occurs or a
readonly <br>
function with the same name already exists. When executed,
the exit status of a function is the exit status of the last
command executed in the body. (See FUNCTIONS <br>
below.)</p>

<p style="margin-top: 1em">COMMENTS <br>
In a non-interactive shell, or an interactive shell in which
the interactive_comments option to the shopt builtin is
enabled (see SHELL BUILTIN COMMANDS below), a word beginning
<br>
with # causes that word and all remaining characters on that
line to be ignored. An interactive shell without the
interactive_comments option enabled does not allow comments.
<br>
The interactive_comments option is on by default in
interactive shells.</p>

<p style="margin-top: 1em">QUOTING <br>
Quoting is used to remove the special meaning of certain
characters or words to the shell. Quoting can be used to
disable special treatment for special characters, to prevent
<br>
reserved words from being recognized as such, and to prevent
parameter expansion.</p>

<p style="margin-top: 1em">Each of the metacharacters
listed above under DEFINITIONS has special meaning to the
shell and must be quoted if it is to represent itself.</p>

<p style="margin-top: 1em">When the command history
expansion facilities are being used (see HISTORY EXPANSION
below), the history expansion character, usually !, must be
quoted to prevent history expan&acirc; <br>
sion.</p>

<p style="margin-top: 1em">There are three quoting
mechanisms: the escape character, single quotes, and double
quotes.</p>

<p style="margin-top: 1em">A non-quoted backslash ( is the
escape character. It preserves the literal value of the next
character that follows, with the exception of
&lt;newline&gt;. If a &lt;newline&gt; pair <br>
appears, and the backslash is not itself quoted, the
&lt;newline&gt; is treated as a line continuation (that is,
it is removed from the input stream and effectively
ignored).</p>

<p style="margin-top: 1em">Enclosing characters in single
quotes preserves the literal value of each character within
the quotes. A single quote may not occur between single
quotes, even when preceded by <br>
a backslash.</p>

<p style="margin-top: 1em">Enclosing characters in double
quotes preserves the literal value of all characters within
the quotes, with the exception of $, &lsquo;, and, when
history expansion is enabled, !. <br>
The characters $ and &lsquo; retain their special meaning
within double quotes. The backslash retains its special
meaning only when followed by one of the following
characters: $, &lsquo;, <br>
&quot;, or &lt;newline&gt;. A double quote may be quoted
within double quotes by preceding it with a backslash. If
enabled, history expansion will be performed unless an !
appearing <br>
in double quotes is escaped using a backslash. The backslash
preceding the ! is not removed.</p>

<p style="margin-top: 1em">The special parameters * and @
have special meaning when in double quotes (see PARAMETERS
below).</p>

<p style="margin-top: 1em">Words of the form
$&rsquo;string&rsquo; are treated specially. The word
expands to string, with backslash-escaped characters
replaced as specified by the ANSI C standard. Backslash
escape <br>
sequences, if present, are decoded as follows: <br>
alert (bell) <br>
backspace <br>
\ &nbsp; <br>
an escape character <br>
form feed <br>
new line <br>
carriage return <br>
horizontal tab <br>
vertical tab <br>
\ backslash <br>
&acute; single quote</p>

<p style="margin-top: 1em">0n the eight-bit character whose
value is the octal value nnn (one to three digits) <br>
the eight-bit character whose value is the hexadecimal value
HH (one or two hex digits) <br>
HHHH the Unicode (ISO/IEC 10646) character whose value is
the hexadecimal value HHHH (one to four hex digits) <br>
UHHHHHHHH <br>
the Unicode (ISO/IEC 10646) character whose value is the
hexadecimal value HHHHHHHH (one to eight hex digits) <br>
The expanded result is single-quoted, as if the dollar sign
had not been present.</p>

<p style="margin-top: 1em">A double-quoted string preceded
by a dollar sign ($&quot;string&quot;) will cause the string
to be translated according to the current locale. If the
current locale is C or POSIX, the <br>
dollar sign is ignored. If the string is translated and
replaced, the replacement is double-quoted.</p>

<p style="margin-top: 1em">PARAMETERS <br>
A parameter is an entity that stores values. It can be a
name, a number, or one of the special characters listed
below under Special Parameters. A variable is a parameter
<br>
denoted by a name. A variable has a value and zero or more
attributes. Attributes are assigned using the declare
builtin command (see declare below in SHELL BUILTIN
COMMANDS).</p>

<p style="margin-top: 1em">A parameter is set if it has
been assigned a value. The null string is a valid value.
Once a variable is set, it may be unset only by using the
unset builtin command (see SHELL <br>
BUILTIN COMMANDS below).</p>

<p style="margin-top: 1em">A variable may be assigned to by
a statement of the form</p>

<p style="margin-top: 1em">name=[value]</p>

<p style="margin-top: 1em">If value is not given, the
variable is assigned the null string. All values undergo
tilde expansion, parameter and variable expansion, command
substitution, arithmetic expan&acirc; <br>
sion, and quote removal (see EXPANSION below). If the
variable has its integer attribute set, then value is
evaluated as an arithmetic expression even if the $((...))
expansion <br>
is not used (see Arithmetic Expansion below). Word splitting
is not performed, with the exception of &quot;$@&quot; as
explained below under Special Parameters. Pathname expansion
is not <br>
performed. Assignment statements may also appear as
arguments to the alias, declare, typeset, export, readonly,
and local builtin commands.</p>

<p style="margin-top: 1em">In the context where an
assignment statement is assigning a value to a shell
variable or array index, the += operator can be used to
append to or add to the variable&rsquo;s previous <br>
value. When += is applied to a variable for which the
integer attribute has been set, value is evaluated as an
arithmetic expression and added to the variable&rsquo;s
current value, <br>
which is also evaluated. When += is applied to an array
variable using compound assignment (see Arrays below), the
variable&rsquo;s value is not unset (as it is when using =),
and new <br>
values are appended to the array beginning at one greater
than the array&rsquo;s maximum index (for indexed arrays) or
added as additional key-value pairs in an associative array.
<br>
When applied to a string-valued variable, value is expanded
and appended to the variable&rsquo;s value.</p>

<p style="margin-top: 1em">Positional Parameters <br>
A positional parameter is a parameter denoted by one or more
digits, other than the single digit 0. Positional parameters
are assigned from the shell&rsquo;s arguments when it is
<br>
invoked, and may be reassigned using the set builtin
command. Positional parameters may not be assigned to with
assignment statements. The positional parameters are
temporarily <br>
replaced when a shell function is executed (see FUNCTIONS
below).</p>

<p style="margin-top: 1em">When a positional parameter
consisting of more than a single digit is expanded, it must
be enclosed in braces (see EXPANSION below).</p>

<p style="margin-top: 1em">Special Parameters <br>
The shell treats several parameters specially. These
parameters may only be referenced; assignment to them is not
allowed. <br>
* Expands to the positional parameters, starting from one.
When the expansion occurs within double quotes, it expands
to a single word with the value of each parameter sep&acirc;
<br>
arated by the first character of the IFS special variable.
That is, &quot;$*&quot; is equivalent to
&quot;$1c$2c...&quot;, where c is the first character of the
value of the IFS variable. <br>
If IFS is unset, the parameters are separated by spaces. If
IFS is null, the parameters are joined without intervening
separators. <br>
@ Expands to the positional parameters, starting from one.
When the expansion occurs within double quotes, each
parameter expands to a separate word. That is,
&quot;$@&quot; is <br>
equivalent to &quot;$1&quot; &quot;$2&quot; ... If the
double-quoted expansion occurs within a word, the expansion
of the first parameter is joined with the beginning part of
the original <br>
word, and the expansion of the last parameter is joined with
the last part of the original word. When there are no
positional parameters, &quot;$@&quot; and $@ expand to
nothing <br>
(i.e., they are removed). <br>
# Expands to the number of positional parameters in decimal.
<br>
? Expands to the exit status of the most recently executed
foreground pipeline. <br>
- Expands to the current option flags as specified upon
invocation, by the set builtin command, or those set by the
shell itself (such as the -i option). <br>
$ Expands to the process ID of the shell. In a () subshell,
it expands to the process ID of the current shell, not the
subshell. <br>
! Expands to the process ID of the most recently executed
background (asynchronous) command. <br>
0 Expands to the name of the shell or shell script. This is
set at shell initialization. If bash is invoked with a file
of commands, $0 is set to the name of that file. <br>
If bash is started with the -c option, then $0 is set to the
first argument after the string to be executed, if one is
present. Otherwise, it is set to the file name used <br>
to invoke bash, as given by argument zero. <br>
_ At shell startup, set to the absolute pathname used to
invoke the shell or shell script being executed as passed in
the environment or argument list. Subsequently, <br>
expands to the last argument to the previous command, after
expansion. Also set to the full pathname used to invoke each
command executed and placed in the environment <br>
exported to that command. When checking mail, this parameter
holds the name of the mail file currently being checked.</p>

<p style="margin-top: 1em">Shell Variables <br>
The following variables are set by the shell:</p>

<p style="margin-top: 1em">BASH Expands to the full file
name used to invoke this instance of bash. <br>
BASHOPTS <br>
A colon-separated list of enabled shell options. Each word
in the list is a valid argument for the -s option to the
shopt builtin command (see SHELL BUILTIN COMMANDS <br>
below). The options appearing in BASHOPTS are those reported
as on by shopt. If this variable is in the environment when
bash starts up, each shell option in the list <br>
will be enabled before reading any startup files. This
variable is read-only. <br>
BASHPID <br>
Expands to the process ID of the current bash process. This
differs from $$ under certain circumstances, such as
subshells that do not require bash to be re-initialized.
<br>
BASH_ALIASES <br>
An associative array variable whose members correspond to
the internal list of aliases as maintained by the alias
builtin. Elements added to this array appear in the <br>
alias list; unsetting array elements cause aliases to be
removed from the alias list. <br>
BASH_ARGC <br>
An array variable whose values are the number of parameters
in each frame of the current bash execution call stack. The
number of parameters to the current subroutine <br>
(shell function or script executed with . or source) is at
the top of the stack. When a subroutine is executed, the
number of parameters passed is pushed onto BASH_ARGC. <br>
The shell sets BASH_ARGC only when in extended debugging
mode (see the description of the extdebug option to the
shopt builtin below) <br>
BASH_ARGV <br>
An array variable containing all of the parameters in the
current bash execution call stack. The final parameter of
the last subroutine call is at the top of the stack; <br>
the first parameter of the initial call is at the bottom.
When a subroutine is executed, the parameters supplied are
pushed onto BASH_ARGV. The shell sets BASH_ARGV only <br>
when in extended debugging mode (see the description of the
extdebug option to the shopt builtin below) <br>
BASH_CMDS <br>
An associative array variable whose members correspond to
the internal hash table of commands as maintained by the
hash builtin. Elements added to this array appear in <br>
the hash table; unsetting array elements cause commands to
be removed from the hash table. <br>
BASH_COMMAND <br>
The command currently being executed or about to be
executed, unless the shell is executing a command as the
result of a trap, in which case it is the command executing
at <br>
the time of the trap. <br>
BASH_EXECUTION_STRING <br>
The command argument to the -c invocation option. <br>
BASH_LINENO <br>
An array variable whose members are the line numbers in
source files where each corresponding member of FUNCNAME was
invoked. ${BASH_LINENO[$i]} is the line number in the <br>
source file (${BASH_SOURCE[$i+1]}) where ${FUNCNAME[$i]} was
called (or ${BASH_LINENO[$i-1]} if referenced within another
shell function). Use LINENO to obtain the cur&acirc; <br>
rent line number. <br>
BASH_REMATCH <br>
An array variable whose members are assigned by the =~
binary operator to the [[ conditional command. The element
with index 0 is the portion of the string matching the <br>
entire regular expression. The element with index n is the
portion of the string matching the nth parenthesized
subexpression. This variable is read-only. <br>
BASH_SOURCE <br>
An array variable whose members are the source filenames
where the corresponding shell function names in the FUNCNAME
array variable are defined. The shell function <br>
${FUNCNAME[$i]} is defined in the file ${BASH_SOURCE[$i]}
and called from ${BASH_SOURCE[$i+1]}. <br>
BASH_SUBSHELL <br>
Incremented by one each time a subshell or subshell
environment is spawned. The initial value is 0. <br>
BASH_VERSINFO <br>
A readonly array variable whose members hold version
information for this instance of bash. The values assigned
to the array members are as follows: <br>
BASH_VERSINFO[0] The major version number (the release).
<br>
BASH_VERSINFO[1] The minor version number (the version).
<br>
BASH_VERSINFO[2] The patch level. <br>
BASH_VERSINFO[3] The build version. <br>
BASH_VERSINFO[4] The release status (e.g., beta1). <br>
BASH_VERSINFO[5] The value of MACHTYPE. <br>
BASH_VERSION <br>
Expands to a string describing the version of this instance
of bash. <br>
COMP_CWORD <br>
An index into ${COMP_WORDS} of the word containing the
current cursor position. This variable is available only in
shell functions invoked by the programmable completion <br>
facilities (see Programmable Completion below). <br>
COMP_KEY <br>
The key (or final key of a key sequence) used to invoke the
current completion function. <br>
COMP_LINE <br>
The current command line. This variable is available only in
shell functions and external commands invoked by the
programmable completion facilities (see Programmable <br>
Completion below). <br>
COMP_POINT <br>
The index of the current cursor position relative to the
beginning of the current command. If the current cursor
position is at the end of the current command, the value
<br>
of this variable is equal to ${#COMP_LINE}. This variable is
available only in shell functions and external commands
invoked by the programmable completion facilities <br>
(see Programmable Completion below). <br>
COMP_TYPE <br>
Set to an integer value corresponding to the type of
completion attempted that caused a completion function to be
called: TAB, for normal completion, ?, for listing
com&acirc; <br>
pletions after successive tabs, !, for listing alternatives
on partial word completion, @, to list completions if the
word is not unmodified, or %, for menu completion. <br>
This variable is available only in shell functions and
external commands invoked by the programmable completion
facilities (see Programmable Completion below). <br>
COMP_WORDBREAKS <br>
The set of characters that the readline library treats as
word separators when performing word completion. If
COMP_WORDBREAKS is unset, it loses its special properties,
<br>
even if it is subsequently reset. <br>
COMP_WORDS <br>
An array variable (see Arrays below) consisting of the
individual words in the current command line. The line is
split into words as readline would split it, using <br>
COMP_WORDBREAKS as described above. This variable is
available only in shell functions invoked by the
programmable completion facilities (see Programmable
Completion <br>
below). <br>
COPROC An array variable (see Arrays below) created to hold
the file descriptors for output from and input to an unnamed
coprocess (see Coprocesses above). <br>
DIRSTACK <br>
An array variable (see Arrays below) containing the current
contents of the directory stack. Directories appear in the
stack in the order they are displayed by the dirs <br>
builtin. Assigning to members of this array variable may be
used to modify directories already in the stack, but the
pushd and popd builtins must be used to add and <br>
remove directories. Assignment to this variable will not
change the current directory. If DIRSTACK is unset, it loses
its special properties, even if it is subsequently <br>
reset. <br>
EUID Expands to the effective user ID of the current user,
initialized at shell startup. This variable is readonly.
<br>
FUNCNAME <br>
An array variable containing the names of all shell
functions currently in the execution call stack. The element
with index 0 is the name of any currently-executing shell
<br>
function. The bottom-most element (the one with the highest
index) is &quot;main&quot;. This variable exists only when a
shell function is executing. Assignments to FUNCNAME have
<br>
no effect and return an error status. If FUNCNAME is unset,
it loses its special properties, even if it is subsequently
reset.</p>

<p style="margin-top: 1em">This variable can be used with
BASH_LINENO and BASH_SOURCE. Each element of FUNCNAME has
corresponding elements in BASH_LINENO and BASH_SOURCE to
describe the call stack. <br>
For instance, ${FUNCNAME[$i]} was called from the file
${BASH_SOURCE[$i+1]} at line number ${BASH_LINENO[$i]}. The
caller builtin displays the current call stack using <br>
this information. <br>
GROUPS An array variable containing the list of groups of
which the current user is a member. Assignments to GROUPS
have no effect and return an error status. If GROUPS is <br>
unset, it loses its special properties, even if it is
subsequently reset. <br>
HISTCMD <br>
The history number, or index in the history list, of the
current command. If HISTCMD is unset, it loses its special
properties, even if it is subsequently reset. <br>
HOSTNAME <br>
Automatically set to the name of the current host. <br>
HOSTTYPE <br>
Automatically set to a string that uniquely describes the
type of machine on which bash is executing. The default is
system-dependent. <br>
LINENO Each time this parameter is referenced, the shell
substitutes a decimal number representing the current
sequential line number (starting with 1) within a script or
func&acirc; <br>
tion. When not in a script or function, the value
substituted is not guaranteed to be meaningful. If LINENO is
unset, it loses its special properties, even if it is
sub&acirc; <br>
sequently reset. <br>
MACHTYPE <br>
Automatically set to a string that fully describes the
system type on which bash is executing, in the standard GNU
cpu-company-system format. The default is
system-depen&acirc; <br>
dent. <br>
MAPFILE <br>
An array variable (see Arrays below) created to hold the
text read by the mapfile builtin when no variable name is
supplied. <br>
OLDPWD The previous working directory as set by the cd
command. <br>
OPTARG The value of the last option argument processed by
the getopts builtin command (see SHELL BUILTIN COMMANDS
below). <br>
OPTIND The index of the next argument to be processed by the
getopts builtin command (see SHELL BUILTIN COMMANDS below).
<br>
OSTYPE Automatically set to a string that describes the
operating system on which bash is executing. The default is
system-dependent. <br>
PIPESTATUS <br>
An array variable (see Arrays below) containing a list of
exit status values from the processes in the
most-recently-executed foreground pipeline (which may
contain only a <br>
single command). <br>
PPID The process ID of the shell&rsquo;s parent. This
variable is readonly. <br>
PWD The current working directory as set by the cd command.
<br>
RANDOM Each time this parameter is referenced, a random
integer between 0 and 32767 is generated. The sequence of
random numbers may be initialized by assigning a value to
RAN&acirc; <br>
DOM. If RANDOM is unset, it loses its special properties,
even if it is subsequently reset. <br>
READLINE_LINE <br>
The contents of the readline line buffer, for use with
&quot;bind -x&quot; (see SHELL BUILTIN COMMANDS below). <br>
READLINE_POINT <br>
The position of the insertion point in the readline line
buffer, for use with &quot;bind -x&quot; (see SHELL BUILTIN
COMMANDS below). <br>
REPLY Set to the line of input read by the read builtin
command when no arguments are supplied. <br>
SECONDS <br>
Each time this parameter is referenced, the number of
seconds since shell invocation is returned. If a value is
assigned to SECONDS, the value returned upon subsequent <br>
references is the number of seconds since the assignment
plus the value assigned. If SECONDS is unset, it loses its
special properties, even if it is subsequently reset. <br>
SHELLOPTS <br>
A colon-separated list of enabled shell options. Each word
in the list is a valid argument for the -o option to the set
builtin command (see SHELL BUILTIN COMMANDS <br>
below). The options appearing in SHELLOPTS are those
reported as on by set -o. If this variable is in the
environment when bash starts up, each shell option in the
list <br>
will be enabled before reading any startup files. This
variable is read-only. <br>
SHLVL Incremented by one each time an instance of bash is
started. <br>
UID Expands to the user ID of the current user, initialized
at shell startup. This variable is readonly.</p>

<p style="margin-top: 1em">The following variables are used
by the shell. In some cases, bash assigns a default value to
a variable; these cases are noted below.</p>

<p style="margin-top: 1em">BASH_ENV <br>
If this parameter is set when bash is executing a shell
script, its value is interpreted as a filename containing
commands to initialize the shell, as in ~/.bashrc. The <br>
value of BASH_ENV is subjected to parameter expansion,
command substitution, and arithmetic expansion before being
interpreted as a file name. PATH is not used to search <br>
for the resultant file name. <br>
BASH_XTRACEFD <br>
If set to an integer corresponding to a valid file
descriptor, bash will write the trace output generated when
set -x is enabled to that file descriptor. The file <br>
descriptor is closed when BASH_XTRACEFD is unset or assigned
a new value. Unsetting BASH_XTRACEFD or assigning it the
empty string causes the trace output to be sent to <br>
the standard error. Note that setting BASH_XTRACEFD to 2
(the standard error file descriptor) and then unsetting it
will result in the standard error being closed. <br>
CDPATH The search path for the cd command. This is a
colon-separated list of directories in which the shell looks
for destination directories specified by the cd command. A
<br>
sample value is &quot;.:~:/usr&quot;. <br>
COLUMNS <br>
Used by the select compound command to determine the
terminal width when printing selection lists. Automatically
set upon receipt of a SIGWINCH. <br>
COMPREPLY <br>
An array variable from which bash reads the possible
completions generated by a shell function invoked by the
programmable completion facility (see Programmable
Completion <br>
below). <br>
EMACS If bash finds this variable in the environment when
the shell starts with value &quot;t&quot;, it assumes that
the shell is running in an Emacs shell buffer and disables
line edit&acirc; <br>
ing. <br>
ENV Similar to BASH_ENV; used when the shell is invoked in
POSIX mode. <br>
FCEDIT The default editor for the fc builtin command. <br>
FIGNORE <br>
A colon-separated list of suffixes to ignore when performing
filename completion (see READLINE below). A filename whose
suffix matches one of the entries in FIGNORE is <br>
excluded from the list of matched filenames. A sample value
is &quot;.o:~&quot;. <br>
FUNCNEST <br>
If set to a numeric value greater than 0, defines a maximum
function nesting level. Function invocations that exceed
this nesting level will cause the current command to <br>
abort. <br>
GLOBIGNORE <br>
A colon-separated list of patterns defining the set of
filenames to be ignored by pathname expansion. If a filename
matched by a pathname expansion pattern also matches <br>
one of the patterns in GLOBIGNORE, it is removed from the
list of matches. <br>
HISTCONTROL <br>
A colon-separated list of values controlling how commands
are saved on the history list. If the list of values
includes ignorespace, lines which begin with a space
char&acirc; <br>
acter are not saved in the history list. A value of
ignoredups causes lines matching the previous history entry
to not be saved. A value of ignoreboth is shorthand for <br>
ignorespace and ignoredups. A value of erasedups causes all
previous lines matching the current line to be removed from
the history list before that line is saved. Any <br>
value not in the above list is ignored. If HISTCONTROL is
unset, or does not include a valid value, all lines read by
the shell parser are saved on the history list, sub&acirc;
<br>
ject to the value of HISTIGNORE. The second and subsequent
lines of a multi-line compound command are not tested, and
are added to the history regardless of the value of <br>
HISTCONTROL. <br>
HISTFILE <br>
The name of the file in which command history is saved (see
HISTORY below). The default value is ~/.bash_history. If
unset, the command history is not saved when an <br>
interactive shell exits. <br>
HISTFILESIZE <br>
The maximum number of lines contained in the history file.
When this variable is assigned a value, the history file is
truncated, if necessary, by removing the oldest <br>
entries, to contain no more than that number of lines. The
default value is 500. The history file is also truncated to
this size after writing it when an interactive <br>
shell exits. <br>
HISTIGNORE <br>
A colon-separated list of patterns used to decide which
command lines should be saved on the history list. Each
pattern is anchored at the beginning of the line and must
<br>
match the complete line (no implicit &lsquo;*&rsquo; is
appended). Each pattern is tested against the line after the
checks specified by HISTCONTROL are applied. In addition to
the <br>
normal shell pattern matching characters,
&lsquo;&amp;&rsquo; matches the previous history line.
&lsquo;&amp;&rsquo; may be escaped using a backslash; the
backslash is removed before attempting a match. <br>
The second and subsequent lines of a multi-line compound
command are not tested, and are added to the history
regardless of the value of HISTIGNORE. <br>
HISTSIZE <br>
The number of commands to remember in the command history
(see HISTORY below). The default value is 500. <br>
HISTTIMEFORMAT <br>
If this variable is set and not null, its value is used as a
format string for strftime(3) to print the time stamp
associated with each history entry displayed by the
his&acirc; <br>
tory builtin. If this variable is set, time stamps are
written to the history file so they may be preserved across
shell sessions. This uses the history comment charac&acirc;
<br>
ter to distinguish timestamps from other history lines. <br>
HOME The home directory of the current user; the default
argument for the cd builtin command. The value of this
variable is also used when performing tilde expansion. <br>
HOSTFILE <br>
Contains the name of a file in the same format as /etc/hosts
that should be read when the shell needs to complete a
hostname. The list of possible hostname completions <br>
may be changed while the shell is running; the next time
hostname completion is attempted after the value is changed,
bash adds the contents of the new file to the exist&acirc;
<br>
ing list. If HOSTFILE is set, but has no value, or does not
name a readable file, bash attempts to read /etc/hosts to
obtain the list of possible hostname completions. <br>
When HOSTFILE is unset, the hostname list is cleared. <br>
IFS The Internal Field Separator that is used for word
splitting after expansion and to split lines into words with
the read builtin command. The default value is <br>

&lsquo;&lsquo;&lt;space&gt;&lt;tab&gt;&lt;newline&gt;&rsquo;&rsquo;.
<br>
IGNOREEOF <br>
Controls the action of an interactive shell on receipt of an
EOF character as the sole input. If set, the value is the
number of consecutive EOF characters which must be <br>
typed as the first characters on an input line before bash
exits. If the variable exists but does not have a numeric
value, or has no value, the default value is 10. If <br>
it does not exist, EOF signifies the end of input to the
shell. <br>
INPUTRC <br>
The filename for the readline startup file, overriding the
default of ~/.inputrc (see READLINE below). <br>
LANG Used to determine the locale category for any category
not specifically selected with a variable starting with LC_.
<br>
LC_ALL This variable overrides the value of LANG and any
other LC_ variable specifying a locale category. <br>
LC_COLLATE <br>
This variable determines the collation order used when
sorting the results of pathname expansion, and determines
the behavior of range expressions, equivalence classes, <br>
and collating sequences within pathname expansion and
pattern matching. <br>
LC_CTYPE <br>
This variable determines the interpretation of characters
and the behavior of character classes within pathname
expansion and pattern matching. <br>
LC_MESSAGES <br>
This variable determines the locale used to translate
double-quoted strings preceded by a $. <br>
LC_NUMERIC <br>
This variable determines the locale category used for number
formatting. <br>
LINES Used by the select compound command to determine the
column length for printing selection lists. Automatically
set upon receipt of a SIGWINCH. <br>
MAIL If this parameter is set to a file or directory name
and the MAILPATH variable is not set, bash informs the user
of the arrival of mail in the specified file or Maildir-
<br>
format directory. <br>
MAILCHECK <br>
Specifies how often (in seconds) bash checks for mail. The
default is 60 seconds. When it is time to check for mail,
the shell does so before displaying the primary <br>
prompt. If this variable is unset, or set to a value that is
not a number greater than or equal to zero, the shell
disables mail checking. <br>
MAILPATH <br>
A colon-separated list of file names to be checked for mail.
The message to be printed when mail arrives in a particular
file may be specified by separating the file name <br>
from the message with a &lsquo;?&rsquo;. When used in the
text of the message, $_ expands to the name of the current
mailfile. Example: <br>
MAILPATH=&rsquo;/var/mail/bfox?&quot;You have
mail&quot;:~/shell-mail?&quot;$_ has mail!&quot;&rsquo; <br>
Bash supplies a default value for this variable, but the
location of the user mail files that it uses is system
dependent (e.g., /var/mail/$USER). <br>
OPTERR If set to the value 1, bash displays error messages
generated by the getopts builtin command (see SHELL BUILTIN
COMMANDS below). OPTERR is initialized to 1 each time the
<br>
shell is invoked or a shell script is executed. <br>
PATH The search path for commands. It is a colon-separated
list of directories in which the shell looks for commands
(see COMMAND EXECUTION below). A zero-length (null) <br>
directory name in the value of PATH indicates the current
directory. A null directory name may appear as two adjacent
colons, or as an initial or trailing colon. The <br>
default path is system-dependent, and is set by the
administrator who installs bash. A common value is
&lsquo;&lsquo;/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin&rsquo;&rsquo;.
<br>
POSIXLY_CORRECT <br>
If this variable is in the environment when bash starts, the
shell enters posix mode before reading the startup files, as
if the --posix invocation option had been sup&acirc; <br>
plied. If it is set while the shell is running, bash enables
posix mode, as if the command set -o posix had been
executed. <br>
PROMPT_COMMAND <br>
If set, the value is executed as a command prior to issuing
each primary prompt. <br>
PROMPT_DIRTRIM <br>
If set to a number greater than zero, the value is used as
the number of trailing directory components to retain when
expanding the 72W prompt string escapes (see <br>
PROMPTING below). Characters removed are replaced with an
ellipsis. <br>
PS1 The value of this parameter is expanded (see PROMPTING
below) and used as the primary prompt string. The default
value is &lsquo;&lsquo; <br>
PS2 The value of this parameter is expanded as with PS1 and
used as the secondary prompt string. The default is
&lsquo;&lsquo;&gt; &rsquo;&rsquo;. <br>
PS3 The value of this parameter is used as the prompt for
the select command (see SHELL GRAMMAR above). <br>
PS4 The value of this parameter is expanded as with PS1 and
the value is printed before each command bash displays
during an execution trace. The first character of PS4 is
<br>
replicated multiple times, as necessary, to indicate
multiple levels of indirection. The default is
&lsquo;&lsquo;+ &rsquo;&rsquo;. <br>
SHELL The full pathname to the shell is kept in this
environment variable. If it is not set when the shell
starts, bash assigns to it the full pathname of the current
user&rsquo;s <br>
login shell. <br>
TIMEFORMAT <br>
The value of this parameter is used as a format string
specifying how the timing information for pipelines prefixed
with the time reserved word should be displayed. The % <br>
character introduces an escape sequence that is expanded to
a time value or other information. The escape sequences and
their meanings are as follows; the braces denote <br>
optional portions. <br>
%% A literal %. <br>
%[p][l]R The elapsed time in seconds. <br>
%[p][l]U The number of CPU seconds spent in user mode. <br>
%[p][l]S The number of CPU seconds spent in system mode.
<br>
%P The CPU percentage, computed as (%U + %S) / %R.</p>

<p style="margin-top: 1em">The optional p is a digit
specifying the precision, the number of fractional digits
after a decimal point. A value of 0 causes no decimal point
or fraction to be output. <br>
At most three places after the decimal point may be
specified; values of p greater than 3 are changed to 3. If p
is not specified, the value 3 is used.</p>

<p style="margin-top: 1em">The optional l specifies a
longer format, including minutes, of the form MMmSS.FFs. The
value of p determines whether or not the fraction is
included.</p>

<p style="margin-top: 1em">If this variable is not set,
bash acts as if it had the value
$&rsquo;0eal%3lR0ser%3lU0ys%3lS&rsquo;. If the value is
null, no timing information is displayed. A trailing <br>
newline is added when the format string is displayed. <br>
TMOUT If set to a value greater than zero, TMOUT is treated
as the default timeout for the read builtin. The select
command terminates if input does not arrive after TMOUT
sec&acirc; <br>
onds when input is coming from a terminal. In an interactive
shell, the value is interpreted as the number of seconds to
wait for input after issuing the primary prompt. <br>
Bash terminates after waiting for that number of seconds if
input does not arrive. <br>
TMPDIR If set, bash uses its value as the name of a
directory in which bash creates temporary files for the
shell&rsquo;s use. <br>
auto_resume <br>
This variable controls how the shell interacts with the user
and job control. If this variable is set, single word simple
commands without redirections are treated as <br>
candidates for resumption of an existing stopped job. There
is no ambiguity allowed; if there is more than one job
beginning with the string typed, the job most recently <br>
accessed is selected. The name of a stopped job, in this
context, is the command line used to start it. If set to the
value exact, the string supplied must match the <br>
name of a stopped job exactly; if set to substring, the
string supplied needs to match a substring of the name of a
stopped job. The substring value provides functional&acirc;
<br>
ity analogous to the %? job identifier (see JOB CONTROL
below). If set to any other value, the supplied string must
be a prefix of a stopped job&rsquo;s name; this provides
<br>
functionality analogous to the %string job identifier. <br>
histchars <br>
The two or three characters which control history expansion
and tokenization (see HISTORY EXPANSION below). The first
character is the history expansion character, the <br>
character which signals the start of a history expansion,
normally &lsquo;!&rsquo;. The second character is the quick
substitution character, which is used as shorthand for
re-run&acirc; <br>
ning the previous command entered, substituting one string
for another in the command. The default is &lsquo;^&rsquo;.
The optional third character is the character which
indicates <br>
that the remainder of the line is a comment when found as
the first character of a word, normally &lsquo;#&rsquo;. The
history comment character causes history substitution to be
<br>
skipped for the remaining words on the line. It does not
necessarily cause the shell parser to treat the rest of the
line as a comment.</p>

<p style="margin-top: 1em">Arrays <br>
Bash provides one-dimensional indexed and associative array
variables. Any variable may be used as an indexed array; the
declare builtin will explicitly declare an array. There <br>
is no maximum limit on the size of an array, nor any
requirement that members be indexed or assigned
contiguously. Indexed arrays are referenced using integers
(including arith&acirc; <br>
metic expressions) and are zero-based; associative arrays
are referenced using arbitrary strings.</p>

<p style="margin-top: 1em">An indexed array is created
automatically if any variable is assigned to using the
syntax name[subscript]=value. The subscript is treated as an
arithmetic expression that must <br>
evaluate to a number. If subscript evaluates to a number
less than zero, it is used as an offset from one greater
than the array&rsquo;s maximum index (so a subcript of -1
refers to <br>
the last element of the array). To explicitly declare an
indexed array, use declare -a name (see SHELL BUILTIN
COMMANDS below). declare -a name[subscript] is also
accepted; the <br>
subscript is ignored.</p>

<p style="margin-top: 1em">Associative arrays are created
using declare -A name.</p>

<p style="margin-top: 1em">Attributes may be specified for
an array variable using the declare and readonly builtins.
Each attribute applies to all members of an array.</p>

<p style="margin-top: 1em">Arrays are assigned to using
compound assignments of the form name=(value1 ... valuen),
where each value is of the form [subscript]=string. Indexed
array assignments do not <br>
require the bracket and subscript. When assigning to indexed
arrays, if the optional brackets and subscript are supplied,
that index is assigned to; otherwise the index of the <br>
element assigned is the last index assigned to by the
statement plus one. Indexing starts at zero.</p>

<p style="margin-top: 1em">When assigning to an associative
array, the subscript is required.</p>

<p style="margin-top: 1em">This syntax is also accepted by
the declare builtin. Individual array elements may be
assigned to using the name[subscript]=value syntax
introduced above.</p>

<p style="margin-top: 1em">Any element of an array may be
referenced using ${name[subscript]}. The braces are required
to avoid conflicts with pathname expansion. If subscript is
@ or *, the word expands <br>
to all members of name. These subscripts differ only when
the word appears within double quotes. If the word is
double-quoted, ${name[*]} expands to a single word with the
<br>
value of each array member separated by the first character
of the IFS special variable, and ${name[@]} expands each
element of name to a separate word. When there are no array
<br>
members, ${name[@]} expands to nothing. If the double-quoted
expansion occurs within a word, the expansion of the first
parameter is joined with the beginning part of the
origi&acirc; <br>
nal word, and the expansion of the last parameter is joined
with the last part of the original word. This is analogous
to the expansion of the special parameters * and @ (see <br>
Special Parameters above). ${#name[subscript]} expands to
the length of ${name[subscript]}. If subscript is * or @,
the expansion is the number of elements in the array.
Ref&acirc; <br>
erencing an array variable without a subscript is equivalent
to referencing the array with a subscript of 0.</p>

<p style="margin-top: 1em">An array variable is considered
set if a subscript has been assigned a value. The null
string is a valid value.</p>

<p style="margin-top: 1em">The unset builtin is used to
destroy arrays. unset name[subscript] destroys the array
element at index subscript. Care must be taken to avoid
unwanted side effects caused by <br>
pathname expansion. unset name, where name is an array, or
unset name[subscript], where subscript is * or @, removes
the entire array.</p>

<p style="margin-top: 1em">The declare, local, and readonly
builtins each accept a -a option to specify an indexed array
and a -A option to specify an associative array. If both
options are supplied, -A <br>
takes precedence. The read builtin accepts a -a option to
assign a list of words read from the standard input to an
array. The set and declare builtins display array values in
<br>
a way that allows them to be reused as assignments.</p>

<p style="margin-top: 1em">EXPANSION <br>
Expansion is performed on the command line after it has been
split into words. There are seven kinds of expansion
performed: brace expansion, tilde expansion, parameter and
<br>
variable expansion, command substitution, arithmetic
expansion, word splitting, and pathname expansion.</p>

<p style="margin-top: 1em">The order of expansions is:
brace expansion, tilde expansion, parameter, variable and
arithmetic expansion and command substitution (done in a
left-to-right fashion), word split&acirc; <br>
ting, and pathname expansion.</p>

<p style="margin-top: 1em">On systems that can support it,
there is an additional expansion available: process
substitution.</p>

<p style="margin-top: 1em">Only brace expansion, word
splitting, and pathname expansion can change the number of
words of the expansion; other expansions expand a single
word to a single word. The only <br>
exceptions to this are the expansions of &quot;$@&quot; and
&quot;${name[@]}&quot; as explained above (see
PARAMETERS).</p>

<p style="margin-top: 1em">Brace Expansion <br>
Brace expansion is a mechanism by which arbitrary strings
may be generated. This mechanism is similar to pathname
expansion, but the filenames generated need not exist.
Pat&acirc; <br>
terns to be brace expanded take the form of an optional
preamble, followed by either a series of comma-separated
strings or a sequence expression between a pair of braces,
fol&acirc; <br>
lowed by an optional postscript. The preamble is prefixed to
each string contained within the braces, and the postscript
is then appended to each resulting string, expanding <br>
left to right.</p>

<p style="margin-top: 1em">Brace expansions may be nested.
The results of each expanded string are not sorted; left to
right order is preserved. For example, a{d,c,b}e expands
into &lsquo;ade ace abe&rsquo;.</p>

<p style="margin-top: 1em">A sequence expression takes the
form {x..y[..incr]}, where x and y are either integers or
single characters, and incr, an optional increment, is an
integer. When integers are <br>
supplied, the expression expands to each number between x
and y, inclusive. Supplied integers may be prefixed with 0
to force each term to have the same width. When either x or
<br>
y begins with a zero, the shell attempts to force all
generated terms to contain the same number of digits,
zero-padding where necessary. When characters are supplied,
the <br>
expression expands to each character lexicographically
between x and y, inclusive. Note that both x and y must be
of the same type. When the increment is supplied, it is used
<br>
as the difference between each term. The default increment
is 1 or -1 as appropriate.</p>

<p style="margin-top: 1em">Brace expansion is performed
before any other expansions, and any characters special to
other expansions are preserved in the result. It is strictly
textual. Bash does not <br>
apply any syntactic interpretation to the context of the
expansion or the text between the braces.</p>

<p style="margin-top: 1em">A correctly-formed brace
expansion must contain unquoted opening and closing braces,
and at least one unquoted comma or a valid sequence
expression. Any incorrectly formed brace <br>
expansion is left unchanged. A { or , may be quoted with a
backslash to prevent its being considered part of a brace
expression. To avoid conflicts with parameter expansion,
<br>
the string ${ is not considered eligible for brace
expansion.</p>

<p style="margin-top: 1em">This construct is typically used
as shorthand when the common prefix of the strings to be
generated is longer than in the above example:</p>

<p style="margin-top: 1em">mkdir
/usr/local/src/bash/{old,new,dist,bugs} <br>
or <br>
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}</p>

<p style="margin-top: 1em">Brace expansion introduces a
slight incompatibility with historical versions of sh. sh
does not treat opening or closing braces specially when they
appear as part of a word, and <br>
preserves them in the output. Bash removes braces from words
as a consequence of brace expansion. For example, a word
entered to sh as file{1,2} appears identically in the
out&acirc; <br>
put. The same word is output as file1 file2 after expansion
by bash. If strict compatibility with sh is desired, start
bash with the +B option or disable brace expansion with <br>
the +B option to the set command (see SHELL BUILTIN COMMANDS
below).</p>

<p style="margin-top: 1em">Tilde Expansion <br>
If a word begins with an unquoted tilde character
(&lsquo;~&rsquo;), all of the characters preceding the first
unquoted slash (or all characters, if there is no unquoted
slash) are consid&acirc; <br>
ered a tilde-prefix. If none of the characters in the
tilde-prefix are quoted, the characters in the tilde-prefix
following the tilde are treated as a possible login name. If
<br>
this login name is the null string, the tilde is replaced
with the value of the shell parameter HOME. If HOME is
unset, the home directory of the user executing the shell is
<br>
substituted instead. Otherwise, the tilde-prefix is replaced
with the home directory associated with the specified login
name.</p>

<p style="margin-top: 1em">If the tilde-prefix is a
&lsquo;~+&rsquo;, the value of the shell variable PWD
replaces the tilde-prefix. If the tilde-prefix is a
&lsquo;~-&rsquo;, the value of the shell variable OLDPWD, if
it is <br>
set, is substituted. If the characters following the tilde
in the tilde-prefix consist of a number N, optionally
prefixed by a &lsquo;+&rsquo; or a &lsquo;-&rsquo;, the
tilde-prefix is replaced with <br>
the corresponding element from the directory stack, as it
would be displayed by the dirs builtin invoked with the
tilde-prefix as an argument. If the characters following the
<br>
tilde in the tilde-prefix consist of a number without a
leading &lsquo;+&rsquo; or &lsquo;-&rsquo;, &lsquo;+&rsquo;
is assumed.</p>

<p style="margin-top: 1em">If the login name is invalid, or
the tilde expansion fails, the word is unchanged.</p>

<p style="margin-top: 1em">Each variable assignment is
checked for unquoted tilde-prefixes immediately following a
: or the first =. In these cases, tilde expansion is also
performed. Consequently, one <br>
may use file names with tildes in assignments to PATH,
MAILPATH, and CDPATH, and the shell assigns the expanded
value.</p>

<p style="margin-top: 1em">Parameter Expansion <br>
The &lsquo;$&rsquo; character introduces parameter
expansion, command substitution, or arithmetic expansion.
The parameter name or symbol to be expanded may be enclosed
in braces, which are <br>
optional but serve to protect the variable to be expanded
from characters immediately following it which could be
interpreted as part of the name.</p>

<p style="margin-top: 1em">When braces are used, the
matching ending brace is the first &lsquo;}&rsquo; not
escaped by a backslash or within a quoted string, and not
within an embedded arithmetic expansion, command <br>
substitution, or parameter expansion.</p>

<p style="margin-top: 1em">${parameter} <br>
The value of parameter is substituted. The braces are
required when parameter is a positional parameter with more
than one digit, or when parameter is followed by a
char&acirc; <br>
acter which is not to be interpreted as part of its
name.</p>

<p style="margin-top: 1em">If the first character of
parameter is an exclamation point (!), a level of variable
indirection is introduced. Bash uses the value of the
variable formed from the rest of <br>
parameter as the name of the variable; this variable is then
expanded and that value is used in the rest of the
substitution, rather than the value of parameter itself.
This is <br>
known as indirect expansion. The exceptions to this are the
expansions of ${!prefix*} and ${!name[@]} described below.
The exclamation point must immediately follow the left <br>
brace in order to introduce indirection.</p>

<p style="margin-top: 1em">In each of the cases below, word
is subject to tilde expansion, parameter expansion, command
substitution, and arithmetic expansion.</p>

<p style="margin-top: 1em">When not performing substring
expansion, using the forms documented below, bash tests for
a parameter that is unset or null. Omitting the colon
results in a test only for a <br>
parameter that is unset.</p>

<p style="margin-top: 1em">${parameter:-word} <br>
Use Default Values. If parameter is unset or null, the
expansion of word is substituted. Otherwise, the value of
parameter is substituted. <br>
${parameter:=word} <br>
Assign Default Values. If parameter is unset or null, the
expansion of word is assigned to parameter. The value of
parameter is then substituted. Positional parameters <br>
and special parameters may not be assigned to in this way.
<br>
${parameter:?word} <br>
Display Error if Null or Unset. If parameter is null or
unset, the expansion of word (or a message to that effect if
word is not present) is written to the standard error <br>
and the shell, if it is not interactive, exits. Otherwise,
the value of parameter is substituted. <br>
${parameter:+word} <br>
Use Alternate Value. If parameter is null or unset, nothing
is substituted, otherwise the expansion of word is
substituted. <br>
${parameter:offset} <br>
${parameter:offset:length} <br>
Substring Expansion. Expands to up to length characters of
parameter starting at the character specified by offset. If
length is omitted, expands to the substring of <br>
parameter starting at the character specified by offset.
length and offset are arithmetic expressions (see ARITHMETIC
EVALUATION below). If offset evaluates to a number <br>
less than zero, the value is used as an offset from the end
of the value of parameter. If length evaluates to a number
less than zero, and parameter is not @ and not an <br>
indexed or associative array, it is interpreted as an offset
from the end of the value of parameter rather than a number
of characters, and the expansion is the characters <br>
between the two offsets. If parameter is @, the result is
length positional parameters beginning at offset. If
parameter is an indexed array name subscripted by @ or *,
<br>
the result is the length members of the array beginning with
${parameter[offset]}. A negative offset is taken relative to
one greater than the maximum index of the speci&acirc; <br>
fied array. Substring expansion applied to an associative
array produces undefined results. Note that a negative
offset must be separated from the colon by at least one <br>
space to avoid being confused with the :- expansion.
Substring indexing is zero-based unless the positional
parameters are used, in which case the indexing starts at 1
by <br>
default. If offset is 0, and the positional parameters are
used, $0 is prefixed to the list.</p>

<p style="margin-top: 1em">${!prefix*} <br>
${!prefix@} <br>
Names matching prefix. Expands to the names of variables
whose names begin with prefix, separated by the first
character of the IFS special variable. When @ is used and
<br>
the expansion appears within double quotes, each variable
name expands to a separate word.</p>

<p style="margin-top: 1em">${!name[@]} <br>
${!name[*]} <br>
List of array keys. If name is an array variable, expands to
the list of array indices (keys) assigned in name. If name
is not an array, expands to 0 if name is set and <br>
null otherwise. When @ is used and the expansion appears
within double quotes, each key expands to a separate
word.</p>

<p style="margin-top: 1em">${#parameter} <br>
Parameter length. The length in characters of the value of
parameter is substituted. If parameter is * or @, the value
substituted is the number of positional parame&acirc; <br>
ters. If parameter is an array name subscripted by * or @,
the value substituted is the number of elements in the
array.</p>

<p style="margin-top: 1em">${parameter#word} <br>
${parameter##word} <br>
Remove matching prefix pattern. The word is expanded to
produce a pattern just as in pathname expansion. If the
pattern matches the beginning of the value of parameter,
<br>
then the result of the expansion is the expanded value of
parameter with the shortest matching pattern (the
&lsquo;&lsquo;#&rsquo;&rsquo; case) or the longest matching
pattern (the &lsquo;&lsquo;##&rsquo;&rsquo; case) <br>
deleted. If parameter is @ or *, the pattern removal
operation is applied to each positional parameter in turn,
and the expansion is the resultant list. If parameter is
<br>
an array variable subscripted with @ or *, the pattern
removal operation is applied to each member of the array in
turn, and the expansion is the resultant list.</p>

<p style="margin-top: 1em">${parameter%word} <br>
${parameter%%word} <br>
Remove matching suffix pattern. The word is expanded to
produce a pattern just as in pathname expansion. If the
pattern matches a trailing portion of the expanded value
<br>
of parameter, then the result of the expansion is the
expanded value of parameter with the shortest matching
pattern (the &lsquo;&lsquo;%&rsquo;&rsquo; case) or the
longest matching pattern (the <br>
&lsquo;&lsquo;%%&rsquo;&rsquo; case) deleted. If parameter
is @ or *, the pattern removal operation is applied to each
positional parameter in turn, and the expansion is the
resultant list. If <br>
parameter is an array variable subscripted with @ or *, the
pattern removal operation is applied to each member of the
array in turn, and the expansion is the resultant <br>
list.</p>

<p style="margin-top: 1em">${parameter/pattern/string} <br>
Pattern substitution. The pattern is expanded to produce a
pattern just as in pathname expansion. Parameter is expanded
and the longest match of pattern against its <br>
value is replaced with string. If pattern begins with /, all
matches of pattern are replaced with string. Normally only
the first match is replaced. If pattern begins <br>
with #, it must match at the beginning of the expanded value
of parameter. If pattern begins with %, it must match at the
end of the expanded value of parameter. If <br>
string is null, matches of pattern are deleted and the /
following pattern may be omitted. If parameter is @ or *,
the substitution operation is applied to each posi&acirc;
<br>
tional parameter in turn, and the expansion is the resultant
list. If parameter is an array variable subscripted with @
or *, the substitution operation is applied to <br>
each member of the array in turn, and the expansion is the
resultant list.</p>

<p style="margin-top: 1em">${parameter^pattern} <br>
${parameter^^pattern} <br>
${parameter,pattern} <br>
${parameter,,pattern} <br>
Case modification. This expansion modifies the case of
alphabetic characters in parameter. The pattern is expanded
to produce a pattern just as in pathname expansion. <br>
The ^ operator converts lowercase letters matching pattern
to uppercase; the , operator converts matching uppercase
letters to lowercase. The ^^ and ,, expansions convert <br>
each matched character in the expanded value; the ^ and ,
expansions match and convert only the first character in the
expanded value. If pattern is omitted, it is <br>
treated like a ?, which matches every character. If
parameter is @ or *, the case modification operation is
applied to each positional parameter in turn, and the
expan&acirc; <br>
sion is the resultant list. If parameter is an array
variable subscripted with @ or *, the case modification
operation is applied to each member of the array in turn,
and <br>
the expansion is the resultant list.</p>

<p style="margin-top: 1em">Command Substitution <br>
Command substitution allows the output of a command to
replace the command name. There are two forms:</p>

<p style="margin-top: 1em">$(command) <br>
or <br>
&lsquo;command&lsquo;</p>

<p style="margin-top: 1em">Bash performs the expansion by
executing command and replacing the command substitution
with the standard output of the command, with any trailing
newlines deleted. Embedded <br>
newlines are not deleted, but they may be removed during
word splitting. The command substitution $(cat file) can be
replaced by the equivalent but faster $(&lt; file).</p>

<p style="margin-top: 1em">When the old-style backquote
form of substitution is used, backslash retains its literal
meaning except when followed by $, &lsquo;, or . The first
backquote not preceded by a back&acirc; <br>
slash terminates the command substitution. When using the
$(command) form, all characters between the parentheses make
up the command; none are treated specially.</p>

<p style="margin-top: 1em">Command substitutions may be
nested. To nest when using the backquoted form, escape the
inner backquotes with backslashes.</p>

<p style="margin-top: 1em">If the substitution appears
within double quotes, word splitting and pathname expansion
are not performed on the results.</p>

<p style="margin-top: 1em">Arithmetic Expansion <br>
Arithmetic expansion allows the evaluation of an arithmetic
expression and the substitution of the result. The format
for arithmetic expansion is:</p>

<p style="margin-top: 1em">$((expression))</p>

<p style="margin-top: 1em">The expression is treated as if
it were within double quotes, but a double quote inside the
parentheses is not treated specially. All tokens in the
expression undergo parameter <br>
expansion, string expansion, command substitution, and quote
removal. Arithmetic expansions may be nested.</p>

<p style="margin-top: 1em">The evaluation is performed
according to the rules listed below under ARITHMETIC
EVALUATION. If expression is invalid, bash prints a message
indicating failure and no substitu&acirc; <br>
tion occurs.</p>

<p style="margin-top: 1em">Process Substitution <br>
Process substitution is supported on systems that support
named pipes (FIFOs) or the /dev/fd method of naming open
files. It takes the form of &lt;(list) or &gt;(list). The
process <br>
list is run with its input or output connected to a FIFO or
some file in /dev/fd. The name of this file is passed as an
argument to the current command as the result of the <br>
expansion. If the &gt;(list) form is used, writing to the
file will provide input for list. If the &lt;(list) form is
used, the file passed as an argument should be read to
obtain <br>
the output of list.</p>

<p style="margin-top: 1em">When available, process
substitution is performed simultaneously with parameter and
variable expansion, command substitution, and arithmetic
expansion.</p>

<p style="margin-top: 1em">Word Splitting <br>
The shell scans the results of parameter expansion, command
substitution, and arithmetic expansion that did not occur
within double quotes for word splitting.</p>

<p style="margin-top: 1em">The shell treats each character
of IFS as a delimiter, and splits the results of the other
expansions into words on these characters. If IFS is unset,
or its value is exactly <br>
&lt;space&gt;&lt;tab&gt;&lt;newline&gt;, the default, then
sequences of &lt;space&gt;, &lt;tab&gt;, and &lt;newline&gt;
at the beginning and end of the results of the previous
expansions are ignored, and any <br>
sequence of IFS characters not at the beginning or end
serves to delimit words. If IFS has a value other than the
default, then sequences of the whitespace characters space
and <br>
tab are ignored at the beginning and end of the word, as
long as the whitespace character is in the value of IFS (an
IFS whitespace character). Any character in IFS that is not
<br>
IFS whitespace, along with any adjacent IFS whitespace
characters, delimits a field. A sequence of IFS whitespace
characters is also treated as a delimiter. If the value of
IFS <br>
is null, no word splitting occurs.</p>

<p style="margin-top: 1em">Explicit null arguments
(&quot;&quot; or &rsquo;&rsquo;) are retained. Unquoted
implicit null arguments, resulting from the expansion of
parameters that have no values, are removed. If a parameter
<br>
with no value is expanded within double quotes, a null
argument results and is retained.</p>

<p style="margin-top: 1em">Note that if no expansion
occurs, no splitting is performed.</p>

<p style="margin-top: 1em">Pathname Expansion <br>
After word splitting, unless the -f option has been set,
bash scans each word for the characters *, ?, and [. If one
of these characters appears, then the word is regarded as a
<br>
pattern, and replaced with an alphabetically sorted list of
file names matching the pattern. If no matching file names
are found, and the shell option nullglob is not enabled,
<br>
the word is left unchanged. If the nullglob option is set,
and no matches are found, the word is removed. If the
failglob shell option is set, and no matches are found, an
<br>
error message is printed and the command is not executed. If
the shell option nocaseglob is enabled, the match is
performed without regard to the case of alphabetic
characters. <br>
When a pattern is used for pathname expansion, the character
&lsquo;&lsquo;.&rsquo;&rsquo; at the start of a name or
immediately following a slash must be matched explicitly,
unless the shell option <br>
dotglob is set. When matching a pathname, the slash
character must always be matched explicitly. In other cases,
the &lsquo;&lsquo;.&rsquo;&rsquo; character is not treated
specially. See the <br>
description of shopt below under SHELL BUILTIN COMMANDS for
a description of the nocaseglob, nullglob, failglob, and
dotglob shell options.</p>

<p style="margin-top: 1em">The GLOBIGNORE shell variable
may be used to restrict the set of file names matching a
pattern. If GLOBIGNORE is set, each matching file name that
also matches one of the pat&acirc; <br>
terns in GLOBIGNORE is removed from the list of matches. The
file names &lsquo;&lsquo;.&rsquo;&rsquo; and
&lsquo;&lsquo;..&rsquo;&rsquo; are always ignored when
GLOBIGNORE is set and not null. However, setting GLOBIGNORE
<br>
to a non-null value has the effect of enabling the dotglob
shell option, so all other file names beginning with a
&lsquo;&lsquo;.&rsquo;&rsquo; will match. To get the old
behavior of ignoring file <br>
names beginning with a &lsquo;&lsquo;.&rsquo;&rsquo;, make
&lsquo;&lsquo;.*&rsquo;&rsquo; one of the patterns in
GLOBIGNORE. The dotglob option is disabled when GLOBIGNORE
is unset.</p>

<p style="margin-top: 1em">Pattern Matching</p>

<p style="margin-top: 1em">Any character that appears in a
pattern, other than the special pattern characters described
below, matches itself. The NUL character may not occur in a
pattern. A backslash <br>
escapes the following character; the escaping backslash is
discarded when matching. The special pattern characters must
be quoted if they are to be matched literally.</p>

<p style="margin-top: 1em">The special pattern characters
have the following meanings:</p>

<p style="margin-top: 1em">* Matches any string, including
the null string. When the globstar shell option is enabled,
and * is used in a pathname expansion context, two adjacent
*s used as a <br>
single pattern will match all files and zero or more
directories and subdirectories. If followed by a /, two
adjacent *s will match only directories and subdirec&acirc;
<br>
tories. <br>
? Matches any single character. <br>
[...] Matches any one of the enclosed characters. A pair of
characters separated by a hyphen denotes a range expression;
any character that sorts between those two char&acirc; <br>
acters, inclusive, using the current locale&rsquo;s
collating sequence and character set, is matched. If the
first character following the [ is a ! or a ^ then any <br>
character not enclosed is matched. The sorting order of
characters in range expressions is determined by the current
locale and the value of the LC_COLLATE shell <br>
variable, if set. A - may be matched by including it as the
first or last character in the set. A ] may be matched by
including it as the first character in the <br>
set.</p>

<p style="margin-top: 1em">Within [ and ], character
classes can be specified using the syntax [:class:], where
class is one of the following classes defined in the POSIX
standard: <br>
alnum alpha ascii blank cntrl digit graph lower print punct
space upper word xdigit <br>
A character class matches any character belonging to that
class. The word character class matches letters, digits, and
the character _.</p>

<p style="margin-top: 1em">Within [ and ], an equivalence
class can be specified using the syntax [=c=], which matches
all characters with the same collation weight (as defined by
the current <br>
locale) as the character c.</p>

<p style="margin-top: 1em">Within [ and ], the syntax
[.symbol.] matches the collating symbol symbol.</p>

<p style="margin-top: 1em">Several extended pattern
matching operators are recognized. In the following
description, a pattern-list is a list of one or more
patterns separated by a |. Composite patterns <br>
may be formed using one or more of the following
sub-patterns:</p>

<p style="margin-top: 1em">?(pattern-list) <br>
Matches zero or one occurrence of the given patterns <br>
*(pattern-list) <br>
Matches zero or more occurrences of the given patterns <br>
+(pattern-list) <br>
Matches one or more occurrences of the given patterns <br>
@(pattern-list) <br>
Matches one of the given patterns</p>

<p style="margin-top: 1em">If the extglob shell option is
enabled using the shopt builtin, following pattern matching
operator is recognized as well:</p>

<p style="margin-top: 1em">!(pattern-list) <br>
Matches anything except one of the given patterns</p>

<p style="margin-top: 1em">Quote Removal <br>
After the preceding expansions, all unquoted occurrences of
the characters &rsquo;, and &quot; that did not result from
one of the above expansions are removed.</p>

<p style="margin-top: 1em">REDIRECTION <br>
Before a command is executed, its input and output may be
redirected using a special notation interpreted by the
shell. Redirection may also be used to open and close files
for <br>
the current shell execution environment. The following
redirection operators may precede or appear anywhere within
a simple command or may follow a command. Redirections are
<br>
processed in the order they appear, from left to right.</p>

<p style="margin-top: 1em">Each redirection that may be
preceded by a file descriptor number may instead be preceded
by a word of the form {varname}. In this case, for each
redirection operator except &gt;&amp;- <br>
and &lt;&amp;-, the shell will allocate a file descriptor
greater than 10 and assign it to varname. If &gt;&amp;- or
&lt;&amp;- is preceded by {varname}, the value of varname
defines the file <br>
descriptor to close.</p>

<p style="margin-top: 1em">In the following descriptions,
if the file descriptor number is omitted, and the first
character of the redirection operator is &lt;, the
redirection refers to the standard input <br>
(file descriptor 0). If the first character of the
redirection operator is &gt;, the redirection refers to the
standard output (file descriptor 1).</p>

<p style="margin-top: 1em">The word following the
redirection operator in the following descriptions, unless
otherwise noted, is subjected to brace expansion, tilde
expansion, parameter expansion, command <br>
substitution, arithmetic expansion, quote removal, pathname
expansion, and word splitting. If it expands to more than
one word, bash reports an error.</p>

<p style="margin-top: 1em">Note that the order of
redirections is significant. For example, the command</p>

<p style="margin-top: 1em">ls &gt; dirlist 2&gt;&amp;1</p>

<p style="margin-top: 1em">directs both standard output and
standard error to the file dirlist, while the command</p>

<p style="margin-top: 1em">ls 2&gt;&amp;1 &gt; dirlist</p>

<p style="margin-top: 1em">directs only the standard output
to file dirlist, because the standard error was duplicated
from the standard output before the standard output was
redirected to dirlist.</p>

<p style="margin-top: 1em">Bash handles several filenames
specially when they are used in redirections, as described
in the following table:</p>

<p style="margin-top: 1em">/dev/fd/fd <br>
If fd is a valid integer, file descriptor fd is duplicated.
<br>
/dev/stdin <br>
File descriptor 0 is duplicated. <br>
/dev/stdout <br>
File descriptor 1 is duplicated. <br>
/dev/stderr <br>
File descriptor 2 is duplicated. <br>
/dev/tcp/host/port <br>
If host is a valid hostname or Internet address, and port is
an integer port number or service name, bash attempts to
open a TCP connection to the corresponding <br>
socket. <br>
/dev/udp/host/port <br>
If host is a valid hostname or Internet address, and port is
an integer port number or service name, bash attempts to
open a UDP connection to the corresponding <br>
socket.</p>

<p style="margin-top: 1em">A failure to open or create a
file causes the redirection to fail.</p>

<p style="margin-top: 1em">Redirections using file
descriptors greater than 9 should be used with care, as they
may conflict with file descriptors the shell uses
internally.</p>

<p style="margin-top: 1em">Redirecting Input <br>
Redirection of input causes the file whose name results from
the expansion of word to be opened for reading on file
descriptor n, or the standard input (file descriptor 0) if n
<br>
is not specified.</p>

<p style="margin-top: 1em">The general format for
redirecting input is:</p>

<p style="margin-top: 1em">[n]&lt;word</p>

<p style="margin-top: 1em">Redirecting Output <br>
Redirection of output causes the file whose name results
from the expansion of word to be opened for writing on file
descriptor n, or the standard output (file descriptor 1) if
n <br>
is not specified. If the file does not exist it is created;
if it does exist it is truncated to zero size.</p>

<p style="margin-top: 1em">The general format for
redirecting output is:</p>

<p style="margin-top: 1em">[n]&gt;word</p>

<p style="margin-top: 1em">If the redirection operator is
&gt;, and the noclobber option to the set builtin has been
enabled, the redirection will fail if the file whose name
results from the expansion of <br>
word exists and is a regular file. If the redirection
operator is &gt;|, or the redirection operator is &gt; and
the noclobber option to the set builtin command is not
enabled, the <br>
redirection is attempted even if the file named by word
exists.</p>

<p style="margin-top: 1em">Appending Redirected Output <br>
Redirection of output in this fashion causes the file whose
name results from the expansion of word to be opened for
appending on file descriptor n, or the standard output (file
<br>
descriptor 1) if n is not specified. If the file does not
exist it is created.</p>

<p style="margin-top: 1em">The general format for appending
output is:</p>

<p style="margin-top: 1em">[n]&gt;&gt;word</p>

<p style="margin-top: 1em">Redirecting Standard Output and
Standard Error <br>
This construct allows both the standard output (file
descriptor 1) and the standard error output (file descriptor
2) to be redirected to the file whose name is the expansion
of <br>
word.</p>

<p style="margin-top: 1em">There are two formats for
redirecting standard output and standard error:</p>

<p style="margin-top: 1em">&amp;&gt;word <br>
and <br>
&gt;&amp;word</p>

<p style="margin-top: 1em">Of the two forms, the first is
preferred. This is semantically equivalent to</p>

<p style="margin-top: 1em">&gt;word 2&gt;&amp;1</p>

<p style="margin-top: 1em">Appending Standard Output and
Standard Error <br>
This construct allows both the standard output (file
descriptor 1) and the standard error output (file descriptor
2) to be appended to the file whose name is the expansion of
<br>
word.</p>

<p style="margin-top: 1em">The format for appending
standard output and standard error is:</p>

<p style="margin-top: 1em">&amp;&gt;&gt;word</p>

<p style="margin-top: 1em">This is semantically equivalent
to</p>

<p style="margin-top: 1em">&gt;&gt;word 2&gt;&amp;1</p>

<p style="margin-top: 1em">Here Documents <br>
This type of redirection instructs the shell to read input
from the current source until a line containing only
delimiter (with no trailing blanks) is seen. All of the
lines <br>
read up to that point are then used as the standard input
for a command.</p>

<p style="margin-top: 1em">The format of here-documents
is:</p>

<p style="margin-top: 1em">&lt;&lt;[-]word <br>
here-document <br>
delimiter</p>

<p style="margin-top: 1em">No parameter expansion, command
substitution, arithmetic expansion, or pathname expansion is
performed on word. If any characters in word are quoted, the
delimiter is the result <br>
of quote removal on word, and the lines in the here-document
are not expanded. If word is unquoted, all lines of the
here-document are subjected to parameter expansion, command
<br>
substitution, and arithmetic expansion. In the latter case,
the character sequence &lt;newline&gt; is ignored, and
&nbsp;must be used to quote the characters $, and
&lsquo;.</p>

<p style="margin-top: 1em">If the redirection operator is
&lt;&lt;-, then all leading tab characters are stripped from
input lines and the line containing delimiter. This allows
here-documents within shell <br>
scripts to be indented in a natural fashion.</p>

<p style="margin-top: 1em">Here Strings <br>
A variant of here documents, the format is:</p>

<p style="margin-top: 1em">&lt;&lt;&lt;word</p>

<p style="margin-top: 1em">The word is expanded and
supplied to the command on its standard input.</p>

<p style="margin-top: 1em">Duplicating File Descriptors
<br>
The redirection operator</p>

<p style="margin-top: 1em">[n]&lt;&amp;word</p>

<p style="margin-top: 1em">is used to duplicate input file
descriptors. If word expands to one or more digits, the file
descriptor denoted by n is made to be a copy of that file
descriptor. If the digits <br>
in word do not specify a file descriptor open for input, a
redirection error occurs. If word evaluates to -, file
descriptor n is closed. If n is not specified, the standard
<br>
input (file descriptor 0) is used.</p>

<p style="margin-top: 1em">The operator</p>

<p style="margin-top: 1em">[n]&gt;&amp;word</p>

<p style="margin-top: 1em">is used similarly to duplicate
output file descriptors. If n is not specified, the standard
output (file descriptor 1) is used. If the digits in word do
not specify a file <br>
descriptor open for output, a redirection error occurs. As a
special case, if n is omitted, and word does not expand to
one or more digits, the standard output and standard <br>
error are redirected as described previously.</p>

<p style="margin-top: 1em">Moving File Descriptors <br>
The redirection operator</p>

<p style="margin-top: 1em">[n]&lt;&amp;digit-</p>

<p style="margin-top: 1em">moves the file descriptor digit
to file descriptor n, or the standard input (file descriptor
0) if n is not specified. digit is closed after being
duplicated to n.</p>

<p style="margin-top: 1em">Similarly, the redirection
operator</p>

<p style="margin-top: 1em">[n]&gt;&amp;digit-</p>

<p style="margin-top: 1em">moves the file descriptor digit
to file descriptor n, or the standard output (file
descriptor 1) if n is not specified.</p>

<p style="margin-top: 1em">Opening File Descriptors for
Reading and Writing <br>
The redirection operator</p>

<p style="margin-top: 1em">[n]&lt;&gt;word</p>

<p style="margin-top: 1em">causes the file whose name is
the expansion of word to be opened for both reading and
writing on file descriptor n, or on file descriptor 0 if n
is not specified. If the file <br>
does not exist, it is created.</p>

<p style="margin-top: 1em">ALIASES <br>
Aliases allow a string to be substituted for a word when it
is used as the first word of a simple command. The shell
maintains a list of aliases that may be set and unset with
<br>
the alias and unalias builtin commands (see SHELL BUILTIN
COMMANDS below). The first word of each simple command, if
unquoted, is checked to see if it has an alias. If so, that
<br>
word is replaced by the text of the alias. The characters /,
$, &lsquo;, and = and any of the shell metacharacters or
quoting characters listed above may not appear in an alias
name. <br>
The replacement text may contain any valid shell input,
including shell metacharacters. The first word of the
replacement text is tested for aliases, but a word that is
identi&acirc; <br>
cal to an alias being expanded is not expanded a second
time. This means that one may alias ls to ls -F, for
instance, and bash does not try to recursively expand the
replace&acirc; <br>
ment text. If the last character of the alias value is a
blank, then the next command word following the alias is
also checked for alias expansion.</p>

<p style="margin-top: 1em">Aliases are created and listed
with the alias command, and removed with the unalias
command.</p>

<p style="margin-top: 1em">There is no mechanism for using
arguments in the replacement text. If arguments are needed,
a shell function should be used (see FUNCTIONS below).</p>

<p style="margin-top: 1em">Aliases are not expanded when
the shell is not interactive, unless the expand_aliases
shell option is set using shopt (see the description of
shopt under SHELL BUILTIN COMMANDS <br>
below).</p>

<p style="margin-top: 1em">The rules concerning the
definition and use of aliases are somewhat confusing. Bash
always reads at least one complete line of input before
executing any of the commands on that <br>
line. Aliases are expanded when a command is read, not when
it is executed. Therefore, an alias definition appearing on
the same line as another command does not take effect <br>
until the next line of input is read. The commands following
the alias definition on that line are not affected by the
new alias. This behavior is also an issue when functions
<br>
are executed. Aliases are expanded when a function
definition is read, not when the function is executed,
because a function definition is itself a compound command.
As a con&acirc; <br>
sequence, aliases defined in a function are not available
until after that function is executed. To be safe, always
put alias definitions on a separate line, and do not use
<br>
alias in compound commands.</p>

<p style="margin-top: 1em">For almost every purpose,
aliases are superseded by shell functions.</p>

<p style="margin-top: 1em">FUNCTIONS <br>
A shell function, defined as described above under SHELL
GRAMMAR, stores a series of commands for later execution.
When the name of a shell function is used as a simple
command <br>
name, the list of commands associated with that function
name is executed. Functions are executed in the context of
the current shell; no new process is created to interpret
<br>
them (contrast this with the execution of a shell script).
When a function is executed, the arguments to the function
become the positional parameters during its execution. The
<br>
special parameter # is updated to reflect the change.
Special parameter 0 is unchanged. The first element of the
FUNCNAME variable is set to the name of the function while
the <br>
function is executing.</p>

<p style="margin-top: 1em">All other aspects of the shell
execution environment are identical between a function and
its caller with these exceptions: the DEBUG and RETURN traps
(see the description of <br>
the trap builtin under SHELL BUILTIN COMMANDS below) are not
inherited unless the function has been given the trace
attribute (see the description of the declare builtin below)
<br>
or the -o functrace shell option has been enabled with the
set builtin (in which case all functions inherit the DEBUG
and RETURN traps), and the ERR trap is not inherited unless
<br>
the -o errtrace shell option has been enabled.</p>

<p style="margin-top: 1em">Variables local to the function
may be declared with the local builtin command. Ordinarily,
variables and their values are shared between the function
and its caller.</p>

<p style="margin-top: 1em">The FUNCNEST variable, if set to
a numeric value greater than 0, defines a maximum function
nesting level. Function invocations that exceed the limit
cause the entire command to <br>
abort.</p>

<p style="margin-top: 1em">If the builtin command return is
executed in a function, the function completes and execution
resumes with the next command after the function call. Any
command associated with <br>
the RETURN trap is executed before execution resumes. When a
function completes, the values of the positional parameters
and the special parameter # are restored to the values <br>
they had prior to the function&rsquo;s execution.</p>

<p style="margin-top: 1em">Function names and definitions
may be listed with the -f option to the declare or typeset
builtin commands. The -F option to declare or typeset will
list the function names only <br>
(and optionally the source file and line number, if the
extdebug shell option is enabled). Functions may be exported
so that subshells automatically have them defined with the
<br>
-f option to the export builtin. A function definition may
be deleted using the -f option to the unset builtin. Note
that shell functions and variables with the same name may
<br>
result in multiple identically-named entries in the
environment passed to the shell&rsquo;s children. Care
should be taken in cases where this may cause a problem.</p>

<p style="margin-top: 1em">Functions may be recursive. The
FUNCNEST variable may be used to limit the depth of the
function call stack and restrict the number of function
invocations. By default, no <br>
limit is imposed on the number of recursive calls.</p>

<p style="margin-top: 1em">ARITHMETIC EVALUATION <br>
The shell allows arithmetic expressions to be evaluated,
under certain circumstances (see the let and declare builtin
commands and Arithmetic Expansion). Evaluation is done in
<br>
fixed-width integers with no check for overflow, though
division by 0 is trapped and flagged as an error. The
operators and their precedence, associativity, and values
are the <br>
same as in the C language. The following list of operators
is grouped into levels of equal-precedence operators. The
levels are listed in order of decreasing precedence.</p>

<p style="margin-top: 1em">id++ id-- <br>
variable post-increment and post-decrement <br>
++id --id <br>
variable pre-increment and pre-decrement <br>
- + unary minus and plus <br>
! ~ logical and bitwise negation <br>
** exponentiation <br>
* / % multiplication, division, remainder <br>
+ - addition, subtraction <br>
&lt;&lt; &gt;&gt; left and right bitwise shifts <br>
&lt;= &gt;= &lt; &gt; <br>
comparison <br>
== != equality and inequality <br>
&amp; bitwise AND <br>
^ bitwise exclusive OR <br>
| bitwise OR <br>
&amp;&amp; logical AND <br>
|| logical OR <br>
expr?expr:expr <br>
conditional operator <br>
= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |= <br>
assignment <br>
expr1 , expr2 <br>
comma</p>

<p style="margin-top: 1em">Shell variables are allowed as
operands; parameter expansion is performed before the
expression is evaluated. Within an expression, shell
variables may also be referenced by <br>
name without using the parameter expansion syntax. A shell
variable that is null or unset evaluates to 0 when
referenced by name without using the parameter expansion
syntax. <br>
The value of a variable is evaluated as an arithmetic
expression when it is referenced, or when a variable which
has been given the integer attribute using declare -i is
assigned <br>
a value. A null value evaluates to 0. A shell variable need
not have its integer attribute turned on to be used in an
expression.</p>

<p style="margin-top: 1em">Constants with a leading 0 are
interpreted as octal numbers. A leading 0x or 0X denotes
hexadecimal. Otherwise, numbers take the form [base#]n,
where the optional base is a <br>
decimal number between 2 and 64 representing the arithmetic
base, and n is a number in that base. If base# is omitted,
then base 10 is used. The digits greater than 9 are
rep&acirc; <br>
resented by the lowercase letters, the uppercase letters, @,
and _, in that order. If base is less than or equal to 36,
lowercase and uppercase letters may be used
interchange&acirc; <br>
ably to represent numbers between 10 and 35.</p>

<p style="margin-top: 1em">Operators are evaluated in order
of precedence. Sub-expressions in parentheses are evaluated
first and may override the precedence rules above.</p>

<p style="margin-top: 1em">CONDITIONAL EXPRESSIONS <br>
Conditional expressions are used by the [[ compound command
and the test and [ builtin commands to test file attributes
and perform string and arithmetic comparisons. Expres&acirc;
<br>
sions are formed from the following unary or binary
primaries. If any file argument to one of the primaries is
of the form /dev/fd/n, then file descriptor n is checked. If
the <br>
file argument to one of the primaries is one of /dev/stdin,
/dev/stdout, or /dev/stderr, file descriptor 0, 1, or 2,
respectively, is checked.</p>

<p style="margin-top: 1em">Unless otherwise specified,
primaries that operate on files follow symbolic links and
operate on the target of the link, rather than the link
itself.</p>

<p style="margin-top: 1em">When used with [[, the &lt; and
&gt; operators sort lexicographically using the current
locale. The test command sorts using ASCII ordering.</p>

<p style="margin-top: 1em">-a file <br>
True if file exists. <br>
-b file <br>
True if file exists and is a block special file. <br>
-c file <br>
True if file exists and is a character special file. <br>
-d file <br>
True if file exists and is a directory. <br>
-e file <br>
True if file exists. <br>
-f file <br>
True if file exists and is a regular file. <br>
-g file <br>
True if file exists and is set-group-id. <br>
-h file <br>
True if file exists and is a symbolic link. <br>
-k file <br>
True if file exists and its
&lsquo;&lsquo;sticky&rsquo;&rsquo; bit is set. <br>
-p file <br>
True if file exists and is a named pipe (FIFO). <br>
-r file <br>
True if file exists and is readable. <br>
-s file <br>
True if file exists and has a size greater than zero. <br>
-t fd True if file descriptor fd is open and refers to a
terminal. <br>
-u file <br>
True if file exists and its set-user-id bit is set. <br>
-w file <br>
True if file exists and is writable. <br>
-x file <br>
True if file exists and is executable. <br>
-G file <br>
True if file exists and is owned by the effective group id.
<br>
-L file <br>
True if file exists and is a symbolic link. <br>
-N file <br>
True if file exists and has been modified since it was last
read. <br>
-O file <br>
True if file exists and is owned by the effective user id.
<br>
-S file <br>
True if file exists and is a socket. <br>
file1 -ef file2 <br>
True if file1 and file2 refer to the same device and inode
numbers. <br>
file1 -nt file2 <br>
True if file1 is newer (according to modification date) than
file2, or if file1 exists and file2 does not. <br>
file1 -ot file2 <br>
True if file1 is older than file2, or if file2 exists and
file1 does not. <br>
-o optname <br>
True if the shell option optname is enabled. See the list of
options under the description of the -o option to the set
builtin below. <br>
-v varname <br>
True if the shell variable varname is set (has been assigned
a value). <br>
-z string <br>
True if the length of string is zero. <br>
string <br>
-n string <br>
True if the length of string is non-zero.</p>

<p style="margin-top: 1em">string1 == string2 <br>
string1 = string2 <br>
True if the strings are equal. = should be used with the
test command for POSIX conformance.</p>

<p style="margin-top: 1em">string1 != string2 <br>
True if the strings are not equal.</p>

<p style="margin-top: 1em">string1 &lt; string2 <br>
True if string1 sorts before string2 lexicographically.</p>

<p style="margin-top: 1em">string1 &gt; string2 <br>
True if string1 sorts after string2 lexicographically.</p>

<p style="margin-top: 1em">arg1 OP arg2 <br>
OP is one of -eq, -ne, -lt, -le, -gt, or -ge. These
arithmetic binary operators return true if arg1 is equal to,
not equal to, less than, less than or equal to, greater <br>
than, or greater than or equal to arg2, respectively. Arg1
and arg2 may be positive or negative integers.</p>

<p style="margin-top: 1em">SIMPLE COMMAND EXPANSION <br>
When a simple command is executed, the shell performs the
following expansions, assignments, and redirections, from
left to right.</p>

<p style="margin-top: 1em">1. The words that the parser has
marked as variable assignments (those preceding the command
name) and redirections are saved for later processing.</p>

<p style="margin-top: 1em">2. The words that are not
variable assignments or redirections are expanded. If any
words remain after expansion, the first word is taken to be
the name of the command and <br>
the remaining words are the arguments.</p>

<p style="margin-top: 1em">3. Redirections are performed as
described above under REDIRECTION.</p>

<p style="margin-top: 1em">4. The text after the = in each
variable assignment undergoes tilde expansion, parameter
expansion, command substitution, arithmetic expansion, and
quote removal before being <br>
assigned to the variable.</p>

<p style="margin-top: 1em">If no command name results, the
variable assignments affect the current shell environment.
Otherwise, the variables are added to the environment of the
executed command and do <br>
not affect the current shell environment. If any of the
assignments attempts to assign a value to a readonly
variable, an error occurs, and the command exits with a
non-zero <br>
status.</p>

<p style="margin-top: 1em">If no command name results,
redirections are performed, but do not affect the current
shell environment. A redirection error causes the command to
exit with a non-zero status.</p>

<p style="margin-top: 1em">If there is a command name left
after expansion, execution proceeds as described below.
Otherwise, the command exits. If one of the expansions
contained a command substitution, <br>
the exit status of the command is the exit status of the
last command substitution performed. If there were no
command substitutions, the command exits with a status of
zero.</p>

<p style="margin-top: 1em">COMMAND EXECUTION <br>
After a command has been split into words, if it results in
a simple command and an optional list of arguments, the
following actions are taken.</p>

<p style="margin-top: 1em">If the command name contains no
slashes, the shell attempts to locate it. If there exists a
shell function by that name, that function is invoked as
described above in FUNC&acirc; <br>
TIONS. If the name does not match a function, the shell
searches for it in the list of shell builtins. If a match is
found, that builtin is invoked.</p>

<p style="margin-top: 1em">If the name is neither a shell
function nor a builtin, and contains no slashes, bash
searches each element of the PATH for a directory containing
an executable file by that name. <br>
Bash uses a hash table to remember the full pathnames of
executable files (see hash under SHELL BUILTIN COMMANDS
below). A full search of the directories in PATH is
performed <br>
only if the command is not found in the hash table. If the
search is unsuccessful, the shell searches for a defined
shell function named command_not_found_handle. If that
func&acirc; <br>
tion exists, it is invoked with the original command and the
original command&rsquo;s arguments as its arguments, and the
function&rsquo;s exit status becomes the exit status of the
shell. <br>
If that function is not defined, the shell prints an error
message and returns an exit status of 127.</p>

<p style="margin-top: 1em">If the search is successful, or
if the command name contains one or more slashes, the shell
executes the named program in a separate execution
environment. Argument 0 is set to <br>
the name given, and the remaining arguments to the command
are set to the arguments given, if any.</p>

<p style="margin-top: 1em">If this execution fails because
the file is not in executable format, and the file is not a
directory, it is assumed to be a shell script, a file
containing shell commands. A <br>
subshell is spawned to execute it. This subshell
reinitializes itself, so that the effect is as if a new
shell had been invoked to handle the script, with the
exception that the <br>
locations of commands remembered by the parent (see hash
below under SHELL BUILTIN COMMANDS) are retained by the
child.</p>

<p style="margin-top: 1em">If the program is a file
beginning with #!, the remainder of the first line specifies
an interpreter for the program. The shell executes the
specified interpreter on operating <br>
systems that do not handle this executable format
themselves. The arguments to the interpreter consist of a
single optional argument following the interpreter name on
the first <br>
line of the program, followed by the name of the program,
followed by the command arguments, if any.</p>

<p style="margin-top: 1em">COMMAND EXECUTION ENVIRONMENT
<br>
The shell has an execution environment, which consists of
the following:</p>

<p style="margin-top: 1em">&Acirc;&middot; open files
inherited by the shell at invocation, as modified by
redirections supplied to the exec builtin</p>

<p style="margin-top: 1em">&Acirc;&middot; the current
working directory as set by cd, pushd, or popd, or inherited
by the shell at invocation</p>

<p style="margin-top: 1em">&Acirc;&middot; the file
creation mode mask as set by umask or inherited from the
shell&rsquo;s parent</p>

<p style="margin-top: 1em">&Acirc;&middot; current traps
set by trap</p>

<p style="margin-top: 1em">&Acirc;&middot; shell parameters
that are set by variable assignment or with set or inherited
from the shell&rsquo;s parent in the environment</p>

<p style="margin-top: 1em">&Acirc;&middot; shell functions
defined during execution or inherited from the shell&rsquo;s
parent in the environment</p>

<p style="margin-top: 1em">&Acirc;&middot; options enabled
at invocation (either by default or with command-line
arguments) or by set</p>

<p style="margin-top: 1em">&Acirc;&middot; options enabled
by shopt</p>

<p style="margin-top: 1em">&Acirc;&middot; shell aliases
defined with alias</p>

<p style="margin-top: 1em">&Acirc;&middot; various process
IDs, including those of background jobs, the value of $$,
and the value of PPID</p>

<p style="margin-top: 1em">When a simple command other than
a builtin or shell function is to be executed, it is invoked
in a separate execution environment that consists of the
following. Unless other&acirc; <br>
wise noted, the values are inherited from the shell.</p>

<p style="margin-top: 1em">&Acirc;&middot; the
shell&rsquo;s open files, plus any modifications and
additions specified by redirections to the command</p>

<p style="margin-top: 1em">&Acirc;&middot; the current
working directory</p>

<p style="margin-top: 1em">&Acirc;&middot; the file
creation mode mask</p>

<p style="margin-top: 1em">&Acirc;&middot; shell variables
and functions marked for export, along with variables
exported for the command, passed in the environment</p>

<p style="margin-top: 1em">&Acirc;&middot; traps caught by
the shell are reset to the values inherited from the
shell&rsquo;s parent, and traps ignored by the shell are
ignored</p>

<p style="margin-top: 1em">A command invoked in this
separate environment cannot affect the shell&rsquo;s
execution environment.</p>

<p style="margin-top: 1em">Command substitution, commands
grouped with parentheses, and asynchronous commands are
invoked in a subshell environment that is a duplicate of the
shell environment, except that <br>
traps caught by the shell are reset to the values that the
shell inherited from its parent at invocation. Builtin
commands that are invoked as part of a pipeline are also
exe&acirc; <br>
cuted in a subshell environment. Changes made to the
subshell environment cannot affect the shell&rsquo;s
execution environment.</p>

<p style="margin-top: 1em">Subshells spawned to execute
command substitutions inherit the value of the -e option
from the parent shell. When not in posix mode, bash clears
the -e option in such subshells.</p>

<p style="margin-top: 1em">If a command is followed by a
&amp; and job control is not active, the default standard
input for the command is the empty file /dev/null.
Otherwise, the invoked command inherits <br>
the file descriptors of the calling shell as modified by
redirections.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
When a program is invoked it is given an array of strings
called the environment. This is a list of name-value pairs,
of the form name=value.</p>

<p style="margin-top: 1em">The shell provides several ways
to manipulate the environment. On invocation, the shell
scans its own environment and creates a parameter for each
name found, automatically <br>
marking it for export to child processes. Executed commands
inherit the environment. The export and declare -x commands
allow parameters and functions to be added to and <br>
deleted from the environment. If the value of a parameter in
the environment is modified, the new value becomes part of
the environment, replacing the old. The environment <br>
inherited by any executed command consists of the
shell&rsquo;s initial environment, whose values may be
modified in the shell, less any pairs removed by the unset
command, plus any <br>
additions via the export and declare -x commands.</p>

<p style="margin-top: 1em">The environment for any simple
command or function may be augmented temporarily by
prefixing it with parameter assignments, as described above
in PARAMETERS. These assignment <br>
statements affect only the environment seen by that
command.</p>

<p style="margin-top: 1em">If the -k option is set (see the
set builtin command below), then all parameter assignments
are placed in the environment for a command, not just those
that precede the command <br>
name.</p>

<p style="margin-top: 1em">When bash invokes an external
command, the variable _ is set to the full file name of the
command and passed to that command in its environment.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
The exit status of an executed command is the value returned
by the waitpid system call or equivalent function. Exit
statuses fall between 0 and 255, though, as explained below,
<br>
the shell may use values above 125 specially. Exit statuses
from shell builtins and compound commands are also limited
to this range. Under certain circumstances, the shell will
<br>
use special values to indicate specific failure modes.</p>

<p style="margin-top: 1em">For the shell&rsquo;s purposes,
a command which exits with a zero exit status has succeeded.
An exit status of zero indicates success. A non-zero exit
status indicates failure. When <br>
a command terminates on a fatal signal N, bash uses the
value of 128+N as the exit status.</p>

<p style="margin-top: 1em">If a command is not found, the
child process created to execute it returns a status of 127.
If a command is found but is not executable, the return
status is 126.</p>

<p style="margin-top: 1em">If a command fails because of an
error during expansion or redirection, the exit status is
greater than zero.</p>

<p style="margin-top: 1em">Shell builtin commands return a
status of 0 (true) if successful, and non-zero (false) if an
error occurs while they execute. All builtins return an exit
status of 2 to indicate <br>
incorrect usage.</p>

<p style="margin-top: 1em">Bash itself returns the exit
status of the last command executed, unless a syntax error
occurs, in which case it exits with a non-zero value. See
also the exit builtin command <br>
below.</p>

<p style="margin-top: 1em">SIGNALS <br>
When bash is interactive, in the absence of any traps, it
ignores SIGTERM (so that kill 0 does not kill an interactive
shell), and SIGINT is caught and handled (so that the wait
<br>
builtin is interruptible). In all cases, bash ignores
SIGQUIT. If job control is in effect, bash ignores SIGTTIN,
SIGTTOU, and SIGTSTP.</p>

<p style="margin-top: 1em">Non-builtin commands run by bash
have signal handlers set to the values inherited by the
shell from its parent. When job control is not in effect,
asynchronous commands ignore <br>
SIGINT and SIGQUIT in addition to these inherited handlers.
Commands run as a result of command substitution ignore the
keyboard-generated job control signals SIGTTIN, SIGTTOU,
<br>
and SIGTSTP.</p>

<p style="margin-top: 1em">The shell exits by default upon
receipt of a SIGHUP. Before exiting, an interactive shell
resends the SIGHUP to all jobs, running or stopped. Stopped
jobs are sent SIGCONT to <br>
ensure that they receive the SIGHUP. To prevent the shell
from sending the signal to a particular job, it should be
removed from the jobs table with the disown builtin (see
<br>
SHELL BUILTIN COMMANDS below) or marked to not receive
SIGHUP using disown -h.</p>

<p style="margin-top: 1em">If the huponexit shell option
has been set with shopt, bash sends a SIGHUP to all jobs
when an interactive login shell exits.</p>

<p style="margin-top: 1em">If bash is waiting for a command
to complete and receives a signal for which a trap has been
set, the trap will not be executed until the command
completes. When bash is waiting <br>
for an asynchronous command via the wait builtin, the
reception of a signal for which a trap has been set will
cause the wait builtin to return immediately with an exit
status <br>
greater than 128, immediately after which the trap is
executed.</p>

<p style="margin-top: 1em">JOB CONTROL <br>
Job control refers to the ability to selectively stop
(suspend) the execution of processes and continue (resume)
their execution at a later point. A user typically employs
this <br>
facility via an interactive interface supplied jointly by
the operating system kernel&rsquo;s terminal driver and
bash.</p>

<p style="margin-top: 1em">The shell associates a job with
each pipeline. It keeps a table of currently executing jobs,
which may be listed with the jobs command. When bash starts
a job asynchronously <br>
(in the background), it prints a line that looks like:</p>

<p style="margin-top: 1em">[1] 25647</p>

<p style="margin-top: 1em">indicating that this job is job
number 1 and that the process ID of the last process in the
pipeline associated with this job is 25647. All of the
processes in a single pipeline <br>
are members of the same job. Bash uses the job abstraction
as the basis for job control.</p>

<p style="margin-top: 1em">To facilitate the implementation
of the user interface to job control, the operating system
maintains the notion of a current terminal process group ID.
Members of this process <br>
group (processes whose process group ID is equal to the
current terminal process group ID) receive
keyboard-generated signals such as SIGINT. These processes
are said to be in <br>
the foreground. Background processes are those whose process
group ID differs from the terminal&rsquo;s; such processes
are immune to keyboard-generated signals. Only foreground
pro&acirc; <br>
cesses are allowed to read from or, if the user so specifies
with stty tostop, write to the terminal. Background
processes which attempt to read from (write to when stty
tostop <br>
is in effect) the terminal are sent a SIGTTIN (SIGTTOU)
signal by the kernel&rsquo;s terminal driver, which, unless
caught, suspends the process.</p>

<p style="margin-top: 1em">If the operating system on which
bash is running supports job control, bash contains
facilities to use it. Typing the suspend character
(typically ^Z, Control-Z) while a process <br>
is running causes that process to be stopped and returns
control to bash. Typing the delayed suspend character
(typically ^Y, Control-Y) causes the process to be stopped
when it <br>
attempts to read input from the terminal, and control to be
returned to bash. The user may then manipulate the state of
this job, using the bg command to continue it in the <br>
background, the fg command to continue it in the foreground,
or the kill command to kill it. A ^Z takes effect
immediately, and has the additional side effect of causing
pending <br>
output and typeahead to be discarded.</p>

<p style="margin-top: 1em">There are a number of ways to
refer to a job in the shell. The character % introduces a
job specification (jobspec). Job number n may be referred to
as %n. A job may also be <br>
referred to using a prefix of the name used to start it, or
using a substring that appears in its command line. For
example, %ce refers to a stopped ce job. If a prefix matches
<br>
more than one job, bash reports an error. Using %?ce, on the
other hand, refers to any job containing the string ce in
its command line. If the substring matches more than one
<br>
job, bash reports an error. The symbols %% and %+ refer to
the shell&rsquo;s notion of the current job, which is the
last job stopped while it was in the foreground or started
in the <br>
background. The previous job may be referenced using %-. If
there is only a single job, %+ and %- can both be used to
refer to that job. In output pertaining to jobs (e.g., <br>
the output of the jobs command), the current job is always
flagged with a +, and the previous job with a -. A single %
(with no accompanying job specification) also refers to <br>
the current job.</p>

<p style="margin-top: 1em">Simply naming a job can be used
to bring it into the foreground: %1 is a synonym for
&lsquo;&lsquo;fg %1&rsquo;&rsquo;, bringing job 1 from the
background into the foreground. Similarly, &lsquo;&lsquo;%1
&amp;&rsquo;&rsquo; <br>
resumes job 1 in the background, equivalent to
&lsquo;&lsquo;bg %1&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">The shell learns immediately
whenever a job changes state. Normally, bash waits until it
is about to print a prompt before reporting changes in a
job&rsquo;s status so as to not <br>
interrupt any other output. If the -b option to the set
builtin command is enabled, bash reports such changes
immediately. Any trap on SIGCHLD is executed for each child
that <br>
exits.</p>

<p style="margin-top: 1em">If an attempt to exit bash is
made while jobs are stopped (or, if the checkjobs shell
option has been enabled using the shopt builtin, running),
the shell prints a warning mes&acirc; <br>
sage, and, if the checkjobs option is enabled, lists the
jobs and their statuses. The jobs command may then be used
to inspect their status. If a second attempt to exit is made
<br>
without an intervening command, the shell does not print
another warning, and any stopped jobs are terminated.</p>

<p style="margin-top: 1em">PROMPTING <br>
When executing interactively, bash displays the primary
prompt PS1 when it is ready to read a command, and the
secondary prompt PS2 when it needs more input to complete a
com&acirc; <br>
mand. Bash allows these prompt strings to be customized by
inserting a number of backslash-escaped special characters
that are decoded as follows: <br>
an ASCII bell character (07) <br>
the date in &quot;Weekday Month Date&quot; format (e.g.,
&quot;Tue May 26&quot;) <br>
the format is passed to strftime(3) and the result is
inserted into the prompt string; an empty format results in
a locale-specific time representation. The braces <br>
are required <br>
\ an ASCII escape character (033) <br>
the hostname up to the first &lsquo;.&rsquo; <br>
the hostname <br>
j the number of jobs currently managed by the shell <br>
the basename of the shell&rsquo;s terminal device name <br>
newline <br>
carriage return <br>
the name of the shell, the basename of $0 (the portion
following the final slash) <br>
the current time in 24-hour HH:MM:SS format <br>
T the current time in 12-hour HH:MM:SS format <br>
@ the current time in 12-hour am/pm format <br>
0 the current time in 24-hour HH:MM format <br>
the username of the current user <br>
the version of bash (e.g., 2.00) <br>
the release of bash, version + patch level (e.g., 2.00.0)
<br>
0 the current working directory, with $HOME abbreviated with
a tilde (uses the value of the PROMPT_DIRTRIM variable) <br>
W the basename of the current working directory, with $HOME
abbreviated with a tilde <br>
the history number of this command <br>
if the effective UID is 0, a #, otherwise a $ <br>
0n the character corresponding to the octal number nnn <br>
\ a backslash <br>
begin a sequence of non-printing characters, which could be
used to embed a terminal control sequence into the prompt
<br>
] end a sequence of non-printing characters</p>

<p style="margin-top: 1em">The command number and the
history number are usually different: the history number of
a command is its position in the history list, which may
include commands restored from the <br>
history file (see HISTORY below), while the command number
is the position in the sequence of commands executed during
the current shell session. After the string is decoded, it
<br>
is expanded via parameter expansion, command substitution,
arithmetic expansion, and quote removal, subject to the
value of the promptvars shell option (see the description of
<br>
the shopt command under SHELL BUILTIN COMMANDS below).</p>

<p style="margin-top: 1em">READLINE <br>
This is the library that handles reading input when using an
interactive shell, unless the --noediting option is given at
shell invocation. Line editing is also used when using <br>
the -e option to the read builtin. By default, the line
editing commands are similar to those of Emacs. A vi-style
line editing interface is also available. Line editing can
<br>
be enabled at any time using the -o emacs or -o vi options
to the set builtin (see SHELL BUILTIN COMMANDS below). To
turn off line editing after the shell is running, use the +o
<br>
emacs or +o vi options to the set builtin.</p>

<p style="margin-top: 1em">Readline Notation <br>
In this section, the Emacs-style notation is used to denote
keystrokes. Control keys are denoted by C-key, e.g., C-n
means Control-N. Similarly, meta keys are denoted by M-key,
<br>
so M-x means Meta-X. (On keyboards without a meta key, M-x
means ESC x, i.e., press the Escape key then the x key. This
makes ESC the meta prefix. The combination M-C-x means <br>
ESC-Control-x, or press the Escape key then hold the Control
key while pressing the x key.)</p>

<p style="margin-top: 1em">Readline commands may be given
numeric arguments, which normally act as a repeat count.
Sometimes, however, it is the sign of the argument that is
significant. Passing a nega&acirc; <br>
tive argument to a command that acts in the forward
direction (e.g., kill-line) causes that command to act in a
backward direction. Commands whose behavior with arguments
devi&acirc; <br>
ates from this are noted below.</p>

<p style="margin-top: 1em">When a command is described as
killing text, the text deleted is saved for possible future
retrieval (yanking). The killed text is saved in a kill
ring. Consecutive kills cause <br>
the text to be accumulated into one unit, which can be
yanked all at once. Commands which do not kill text separate
the chunks of text on the kill ring.</p>

<p style="margin-top: 1em">Readline Initialization <br>
Readline is customized by putting commands in an
initialization file (the inputrc file). The name of this
file is taken from the value of the INPUTRC variable. If
that variable <br>
is unset, the default is ~/.inputrc. When a program which
uses the readline library starts up, the initialization file
is read, and the key bindings and variables are set. <br>
There are only a few basic constructs allowed in the
readline initialization file. Blank lines are ignored. Lines
beginning with a # are comments. Lines beginning with a $
<br>
indicate conditional constructs. Other lines denote key
bindings and variable settings.</p>

<p style="margin-top: 1em">The default key-bindings may be
changed with an inputrc file. Other programs that use this
library may add their own commands and bindings.</p>

<p style="margin-top: 1em">For example, placing</p>

<p style="margin-top: 1em">M-Control-u: universal-argument
<br>
or <br>
C-Meta-u: universal-argument <br>
into the inputrc would make M-C-u execute the readline
command universal-argument.</p>

<p style="margin-top: 1em">The following symbolic character
names are recognized: RUBOUT, DEL, ESC, LFD, NEWLINE, RET,
RETURN, SPC, SPACE, and TAB.</p>

<p style="margin-top: 1em">In addition to command names,
readline allows keys to be bound to a string that is
inserted when the key is pressed (a macro).</p>

<p style="margin-top: 1em">Readline Key Bindings <br>
The syntax for controlling key bindings in the inputrc file
is simple. All that is required is the name of the command
or the text of a macro and a key sequence to which it <br>
should be bound. The name may be specified in one of two
ways: as a symbolic key name, possibly with Meta- or
Control- prefixes, or as a key sequence.</p>

<p style="margin-top: 1em">When using the form
keyname:function-name or macro, keyname is the name of a key
spelled out in English. For example:</p>

<p style="margin-top: 1em">Control-u: universal-argument
<br>
Meta-Rubout: backward-kill-word <br>
Control-o: &quot;&gt; output&quot;</p>

<p style="margin-top: 1em">In the above example, C-u is
bound to the function universal-argument, M-DEL is bound to
the function backward-kill-word, and C-o is bound to run the
macro expressed on the right <br>
hand side (that is, to insert the text &lsquo;&lsquo;&gt;
output&rsquo;&rsquo; into the line).</p>

<p style="margin-top: 1em">In the second form,
&quot;keyseq&quot;:function-name or macro, keyseq differs
from keyname above in that strings denoting an entire key
sequence may be specified by placing the sequence <br>
within double quotes. Some GNU Emacs style key escapes can
be used, as in the following example, but the symbolic
character names are not recognized.</p>

<p style="margin-top: 1em">&quot;universal-argument <br>
&quot;read-init-file <br>
&quot;\[11~&quot;: &quot;Function Key 1&quot;</p>

<p style="margin-top: 1em">In this example, C-u is again
bound to the function universal-argument. C-x C-r is bound
to the function re-read-init-file, and ESC [ 1 1 ~ is bound
to insert the text &lsquo;&lsquo;Func&acirc; <br>
tion Key 1&rsquo;&rsquo;.</p>

<p style="margin-top: 1em">The full set of GNU Emacs style
escape sequences is <br>
control prefix <br>
meta prefix <br>
\ an escape character <br>
\ backslash</p>

<p style="margin-top: 1em">&acute; literal &rsquo;</p>

<p style="margin-top: 1em">In addition to the GNU Emacs
style escape sequences, a second set of backslash escapes is
available: <br>
alert (bell) <br>
backspace <br>
delete <br>
form feed <br>
newline <br>
carriage return <br>
horizontal tab <br>
vertical tab <br>
0n the eight-bit character whose value is the octal value
nnn (one to three digits) <br>
the eight-bit character whose value is the hexadecimal value
HH (one or two hex digits)</p>

<p style="margin-top: 1em">When entering the text of a
macro, single or double quotes must be used to indicate a
macro definition. Unquoted text is assumed to be a function
name. In the macro body, the <br>
backslash escapes described above are expanded. Backslash
will quote any other character in the macro text, including
&quot; and &rsquo;.</p>

<p style="margin-top: 1em">Bash allows the current readline
key bindings to be displayed or modified with the bind
builtin command. The editing mode may be switched during
interactive use by using the -o <br>
option to the set builtin command (see SHELL BUILTIN
COMMANDS below).</p>

<p style="margin-top: 1em">Readline Variables <br>
Readline has variables that can be used to further customize
its behavior. A variable may be set in the inputrc file with
a statement of the form</p>

<p style="margin-top: 1em">set variable-name value</p>

<p style="margin-top: 1em">Except where noted, readline
variables can take the values On or Off (without regard to
case). Unrecognized variable names are ignored. When a
variable value is read, empty or <br>
null values, &quot;on&quot; (case-insensitive), and
&quot;1&quot; are equivalent to On. All other values are
equivalent to Off. The variables and their default values
are:</p>

<p style="margin-top: 1em">bell-style (audible) <br>
Controls what happens when readline wants to ring the
terminal bell. If set to none, readline never rings the
bell. If set to visible, readline uses a visible bell if
<br>
one is available. If set to audible, readline attempts to
ring the terminal&rsquo;s bell. <br>
bind-tty-special-chars (On) <br>
If set to On, readline attempts to bind the control
characters treated specially by the kernel&rsquo;s terminal
driver to their readline equivalents. <br>
comment-begin (&lsquo;&lsquo;#&rsquo;&rsquo;) <br>
The string that is inserted when the readline insert-comment
command is executed. This command is bound to M-# in emacs
mode and to # in vi command mode. <br>
completion-ignore-case (Off) <br>
If set to On, readline performs filename matching and
completion in a case-insensitive fashion. <br>
completion-prefix-display-length (0) <br>
The length in characters of the common prefix of a list of
possible completions that is displayed without modification.
When set to a value greater than zero, common pre&acirc;
<br>
fixes longer than this value are replaced with an ellipsis
when displaying possible completions. <br>
completion-query-items (100) <br>
This determines when the user is queried about viewing the
number of possible completions generated by the
possible-completions command. It may be set to any integer
<br>
value greater than or equal to zero. If the number of
possible completions is greater than or equal to the value
of this variable, the user is asked whether or not he <br>
wishes to view them; otherwise they are simply listed on the
terminal. <br>
convert-meta (On) <br>
If set to On, readline will convert characters with the
eighth bit set to an ASCII key sequence by stripping the
eighth bit and prefixing an escape character (in effect,
<br>
using escape as the meta prefix). <br>
disable-completion (Off) <br>
If set to On, readline will inhibit word completion.
Completion characters will be inserted into the line as if
they had been mapped to self-insert. <br>
editing-mode (emacs) <br>
Controls whether readline begins with a set of key bindings
similar to Emacs or vi. editing-mode can be set to either
emacs or vi. <br>
echo-control-characters (On) <br>
When set to On, on operating systems that indicate they
support it, readline echoes a character corresponding to a
signal generated from the keyboard. <br>
enable-keypad (Off) <br>
When set to On, readline will try to enable the application
keypad when it is called. Some systems need this to enable
the arrow keys. <br>
enable-meta-key (On) <br>
When set to On, readline will try to enable any meta
modifier key the terminal claims to support when it is
called. On many terminals, the meta key is used to send
eight- <br>
bit characters. <br>
expand-tilde (Off) <br>
If set to On, tilde expansion is performed when readline
attempts word completion. <br>
history-preserve-point (Off) <br>
If set to On, the history code attempts to place point at
the same location on each history line retrieved with
previous-history or next-history. <br>
history-size (0) <br>
Set the maximum number of history entries saved in the
history list. If set to zero, the number of entries in the
history list is not limited. <br>
horizontal-scroll-mode (Off) <br>
When set to On, makes readline use a single line for
display, scrolling the input horizontally on a single screen
line when it becomes longer than the screen width rather
<br>
than wrapping to a new line. <br>
input-meta (Off) <br>
If set to On, readline will enable eight-bit input (that is,
it will not strip the high bit from the characters it
reads), regardless of what the terminal claims it can <br>
support. The name meta-flag is a synonym for this variable.
<br>
isearch-terminators (&lsquo;&lsquo;C-[C-J&rsquo;&rsquo;)
<br>
The string of characters that should terminate an
incremental search without subsequently executing the
character as a command. If this variable has not been given
a <br>
value, the characters ESC and C-J will terminate an
incremental search. <br>
keymap (emacs) <br>
Set the current readline keymap. The set of valid keymap
names is emacs, emacs-standard, emacs-meta, emacs-ctlx, vi,
vi-command, and vi-insert. vi is equivalent to <br>
vi-command; emacs is equivalent to emacs-standard. The
default value is emacs; the value of editing-mode also
affects the default keymap. <br>
mark-directories (On) <br>
If set to On, completed directory names have a slash
appended. <br>
mark-modified-lines (Off) <br>
If set to On, history lines that have been modified are
displayed with a preceding asterisk (*). <br>
mark-symlinked-directories (Off) <br>
If set to On, completed names which are symbolic links to
directories have a slash appended (subject to the value of
mark-directories). <br>
match-hidden-files (On) <br>
This variable, when set to On, causes readline to match
files whose names begin with a &lsquo;.&rsquo; (hidden
files) when performing filename completion. If set to Off,
the leading <br>
&lsquo;.&rsquo; must be supplied by the user in the filename
to be completed. <br>
menu-complete-display-prefix (Off) <br>
If set to On, menu completion displays the common prefix of
the list of possible completions (which may be empty) before
cycling through the list. <br>
output-meta (Off) <br>
If set to On, readline will display characters with the
eighth bit set directly rather than as a meta-prefixed
escape sequence. <br>
page-completions (On) <br>
If set to On, readline uses an internal more-like pager to
display a screenful of possible completions at a time. <br>
print-completions-horizontally (Off) <br>
If set to On, readline will display completions with matches
sorted horizontally in alphabetical order, rather than down
the screen. <br>
revert-all-at-newline (Off) <br>
If set to On, readline will undo all changes to history
lines before returning when accept-line is executed. By
default, history lines may be modified and retain
individ&acirc; <br>
ual undo lists across calls to readline. <br>
show-all-if-ambiguous (Off) <br>
This alters the default behavior of the completion
functions. If set to On, words which have more than one
possible completion cause the matches to be listed
immediately <br>
instead of ringing the bell. <br>
show-all-if-unmodified (Off) <br>
This alters the default behavior of the completion functions
in a fashion similar to show-all-if-ambiguous. If set to On,
words which have more than one possible comple&acirc; <br>
tion without any possible partial completion (the possible
completions don&rsquo;t share a common prefix) cause the
matches to be listed immediately instead of ringing the
bell. <br>
skip-completed-text (Off) <br>
If set to On, this alters the default completion behavior
when inserting a single match into the line. It&rsquo;s only
active when performing completion in the middle of a <br>
word. If enabled, readline does not insert characters from
the completion that match characters after point in the word
being completed, so portions of the word following <br>
the cursor are not duplicated. <br>
visible-stats (Off) <br>
If set to On, a character denoting a file&rsquo;s type as
reported by stat(2) is appended to the filename when listing
possible completions.</p>

<p style="margin-top: 1em">Readline Conditional Constructs
<br>
Readline implements a facility similar in spirit to the
conditional compilation features of the C preprocessor which
allows key bindings and variable settings to be performed as
<br>
the result of tests. There are four parser directives
used.</p>

<p style="margin-top: 1em">$if The $if construct allows
bindings to be made based on the editing mode, the terminal
being used, or the application using readline. The text of
the test extends to the <br>
end of the line; no characters are required to isolate
it.</p>

<p style="margin-top: 1em">mode The mode= form of the $if
directive is used to test whether readline is in emacs or vi
mode. This may be used in conjunction with the set keymap
command, for <br>
instance, to set bindings in the emacs-standard and
emacs-ctlx keymaps only if readline is starting out in emacs
mode.</p>

<p style="margin-top: 1em">term The term= form may be used
to include terminal-specific key bindings, perhaps to bind
the key sequences output by the terminal&rsquo;s function
keys. The word on the <br>
right side of the = is tested against the both full name of
the terminal and the portion of the terminal name before the
first -. This allows sun to match both sun <br>
and sun-cmd, for instance.</p>

<p style="margin-top: 1em">application <br>
The application construct is used to include
application-specific settings. Each program using the
readline library sets the application name, and an
initializa&acirc; <br>
tion file can test for a particular value. This could be
used to bind key sequences to functions useful for a
specific program. For instance, the following com&acirc;
<br>
mand adds a key sequence that quotes the current or previous
word in bash:</p>

<p style="margin-top: 1em">$if Bash <br>
# Quote the current or previous word <br>
&quot;&quot;\b <br>
$endif</p>

<p style="margin-top: 1em">$endif This command, as seen in
the previous example, terminates an $if command.</p>

<p style="margin-top: 1em">$else Commands in this branch of
the $if directive are executed if the test fails.</p>

<p style="margin-top: 1em">$include <br>
This directive takes a single filename as an argument and
reads commands and bindings from that file. For example, the
following directive would read /etc/inputrc:</p>

<p style="margin-top: 1em">$include /etc/inputrc</p>

<p style="margin-top: 1em">Searching <br>
Readline provides commands for searching through the command
history (see HISTORY below) for lines containing a specified
string. There are two search modes: incremental and <br>
non-incremental.</p>

<p style="margin-top: 1em">Incremental searches begin
before the user has finished typing the search string. As
each character of the search string is typed, readline
displays the next entry from the his&acirc; <br>
tory matching the string typed so far. An incremental search
requires only as many characters as needed to find the
desired history entry. The characters present in the value
<br>
of the isearch-terminators variable are used to terminate an
incremental search. If that variable has not been assigned a
value the Escape and Control-J characters will termi&acirc;
<br>
nate an incremental search. Control-G will abort an
incremental search and restore the original line. When the
search is terminated, the history entry containing the
search <br>
string becomes the current line.</p>

<p style="margin-top: 1em">To find other matching entries
in the history list, type Control-S or Control-R as
appropriate. This will search backward or forward in the
history for the next entry matching <br>
the search string typed so far. Any other key sequence bound
to a readline command will terminate the search and execute
that command. For instance, a newline will terminate <br>
the search and accept the line, thereby executing the
command from the history list.</p>

<p style="margin-top: 1em">Readline remembers the last
incremental search string. If two Control-Rs are typed
without any intervening characters defining a new search
string, any remembered search string <br>
is used.</p>

<p style="margin-top: 1em">Non-incremental searches read
the entire search string before starting to search for
matching history lines. The search string may be typed by
the user or be part of the con&acirc; <br>
tents of the current line.</p>

<p style="margin-top: 1em">Readline Command Names <br>
The following is a list of the names of the commands and the
default key sequences to which they are bound. Command names
without an accompanying key sequence are unbound by <br>
default. In the following descriptions, point refers to the
current cursor position, and mark refers to a cursor
position saved by the set-mark command. The text between the
<br>
point and mark is referred to as the region.</p>

<p style="margin-top: 1em">Commands for Moving <br>
beginning-of-line (C-a) <br>
Move to the start of the current line. <br>
end-of-line (C-e) <br>
Move to the end of the line. <br>
forward-char (C-f) <br>
Move forward a character. <br>
backward-char (C-b) <br>
Move back a character. <br>
forward-word (M-f) <br>
Move forward to the end of the next word. Words are composed
of alphanumeric characters (letters and digits). <br>
backward-word (M-b) <br>
Move back to the start of the current or previous word.
Words are composed of alphanumeric characters (letters and
digits). <br>
shell-forward-word <br>
Move forward to the end of the next word. Words are
delimited by non-quoted shell metacharacters. <br>
shell-backward-word <br>
Move back to the start of the current or previous word.
Words are delimited by non-quoted shell metacharacters. <br>
clear-screen (C-l) <br>
Clear the screen leaving the current line at the top of the
screen. With an argument, refresh the current line without
clearing the screen. <br>
redraw-current-line <br>
Refresh the current line.</p>

<p style="margin-top: 1em">Commands for Manipulating the
History <br>
accept-line (Newline, Return) <br>
Accept the line regardless of where the cursor is. If this
line is non-empty, add it to the history list according to
the state of the HISTCONTROL variable. If the line <br>
is a modified history line, then restore the history line to
its original state. <br>
previous-history (C-p) <br>
Fetch the previous command from the history list, moving
back in the list. <br>
next-history (C-n) <br>
Fetch the next command from the history list, moving forward
in the list. <br>
beginning-of-history (M-&lt;) <br>
Move to the first line in the history. <br>
end-of-history (M-&gt;) <br>
Move to the end of the input history, i.e., the line
currently being entered. <br>
reverse-search-history (C-r) <br>
Search backward starting at the current line and moving
&lsquo;up&rsquo; through the history as necessary. This is
an incremental search. <br>
forward-search-history (C-s) <br>
Search forward starting at the current line and moving
&lsquo;down&rsquo; through the history as necessary. This is
an incremental search. <br>
non-incremental-reverse-search-history (M-p) <br>
Search backward through the history starting at the current
line using a non-incremental search for a string supplied by
the user. <br>
non-incremental-forward-search-history (M-n) <br>
Search forward through the history using a non-incremental
search for a string supplied by the user. <br>
history-search-forward <br>
Search forward through the history for the string of
characters between the start of the current line and the
point. This is a non-incremental search. <br>
history-search-backward <br>
Search backward through the history for the string of
characters between the start of the current line and the
point. This is a non-incremental search. <br>
yank-nth-arg (M-C-y) <br>
Insert the first argument to the previous command (usually
the second word on the previous line) at point. With an
argument n, insert the nth word from the previous com&acirc;
<br>
mand (the words in the previous command begin with word 0).
A negative argument inserts the nth word from the end of the
previous command. Once the argument n is com&acirc; <br>
puted, the argument is extracted as if the &quot;!n&quot;
history expansion had been specified. <br>
yank-last-arg (M-., M-_) <br>
Insert the last argument to the previous command (the last
word of the previous history entry). With a numeric
argument, behave exactly like yank-nth-arg. Successive <br>
calls to yank-last-arg move back through the history list,
inserting the last word (or the word specified by the
argument to the first call) of each line in turn. Any <br>
numeric argument supplied to these successive calls
determines the direction to move through the history. A
negative argument switches the direction through the history
<br>
(back or forward). The history expansion facilities are used
to extract the last argument, as if the &quot;!$&quot;
history expansion had been specified. <br>
shell-expand-line (M-C-e) <br>
Expand the line as the shell does. This performs alias and
history expansion as well as all of the shell word
expansions. See HISTORY EXPANSION below for a description
<br>
of history expansion. <br>
history-expand-line (M-^) <br>
Perform history expansion on the current line. See HISTORY
EXPANSION below for a description of history expansion. <br>
magic-space <br>
Perform history expansion on the current line and insert a
space. See HISTORY EXPANSION below for a description of
history expansion. <br>
alias-expand-line <br>
Perform alias expansion on the current line. See ALIASES
above for a description of alias expansion. <br>
history-and-alias-expand-line <br>
Perform history and alias expansion on the current line.
<br>
insert-last-argument (M-., M-_) <br>
A synonym for yank-last-arg. <br>
operate-and-get-next (C-o) <br>
Accept the current line for execution and fetch the next
line relative to the current line from the history for
editing. Any argument is ignored. <br>
edit-and-execute-command (C-xC-e) <br>
Invoke an editor on the current command line, and execute
the result as shell commands. Bash attempts to invoke
$VISUAL, $EDITOR, and emacs as the editor, in that
order.</p>

<p style="margin-top: 1em">Commands for Changing Text <br>
delete-char (C-d) <br>
Delete the character at point. If point is at the beginning
of the line, there are no characters in the line, and the
last character typed was not bound to delete-char, <br>
then return EOF. <br>
backward-delete-char (Rubout) <br>
Delete the character behind the cursor. When given a numeric
argument, save the deleted text on the kill ring. <br>
forward-backward-delete-char <br>
Delete the character under the cursor, unless the cursor is
at the end of the line, in which case the character behind
the cursor is deleted. <br>
quoted-insert (C-q, C-v) <br>
Add the next character typed to the line verbatim. This is
how to insert characters like C-q, for example. <br>
tab-insert (C-v TAB) <br>
Insert a tab character. <br>
self-insert (a, b, A, 1, !, ...) <br>
Insert the character typed. <br>
transpose-chars (C-t) <br>
Drag the character before point forward over the character
at point, moving point forward as well. If point is at the
end of the line, then this transposes the two char&acirc;
<br>
acters before point. Negative arguments have no effect. <br>
transpose-words (M-t) <br>
Drag the word before point past the word after point, moving
point over that word as well. If point is at the end of the
line, this transposes the last two words on the <br>
line. <br>
upcase-word (M-u) <br>
Uppercase the current (or following) word. With a negative
argument, uppercase the previous word, but do not move
point. <br>
downcase-word (M-l) <br>
Lowercase the current (or following) word. With a negative
argument, lowercase the previous word, but do not move
point. <br>
capitalize-word (M-c) <br>
Capitalize the current (or following) word. With a negative
argument, capitalize the previous word, but do not move
point. <br>
overwrite-mode <br>
Toggle overwrite mode. With an explicit positive numeric
argument, switches to overwrite mode. With an explicit
non-positive numeric argument, switches to insert mode. <br>
This command affects only emacs mode; vi mode does overwrite
differently. Each call to readline() starts in insert mode.
In overwrite mode, characters bound to <br>
self-insert replace the text at point rather than pushing
the text to the right. Characters bound to
backward-delete-char replace the character before point with
a space. <br>
By default, this command is unbound.</p>

<p style="margin-top: 1em">Killing and Yanking <br>
kill-line (C-k) <br>
Kill the text from point to the end of the line. <br>
backward-kill-line (C-x Rubout) <br>
Kill backward to the beginning of the line. <br>
unix-line-discard (C-u) <br>
Kill backward from point to the beginning of the line. The
killed text is saved on the kill-ring. <br>
kill-whole-line <br>
Kill all characters on the current line, no matter where
point is. <br>
kill-word (M-d) <br>
Kill from point to the end of the current word, or if
between words, to the end of the next word. Word boundaries
are the same as those used by forward-word. <br>
backward-kill-word (M-Rubout) <br>
Kill the word behind point. Word boundaries are the same as
those used by backward-word. <br>
shell-kill-word (M-d) <br>
Kill from point to the end of the current word, or if
between words, to the end of the next word. Word boundaries
are the same as those used by shell-forward-word. <br>
shell-backward-kill-word (M-Rubout) <br>
Kill the word behind point. Word boundaries are the same as
those used by shell-backward-word. <br>
unix-word-rubout (C-w) <br>
Kill the word behind point, using white space as a word
boundary. The killed text is saved on the kill-ring. <br>
unix-filename-rubout <br>
Kill the word behind point, using white space and the slash
character as the word boundaries. The killed text is saved
on the kill-ring. <br>
delete-horizontal-space (M- <br>
Delete all spaces and tabs around point. <br>
kill-region <br>
Kill the text in the current region. <br>
copy-region-as-kill <br>
Copy the text in the region to the kill buffer. <br>
copy-backward-word <br>
Copy the word before point to the kill buffer. The word
boundaries are the same as backward-word. <br>
copy-forward-word <br>
Copy the word following point to the kill buffer. The word
boundaries are the same as forward-word. <br>
yank (C-y) <br>
Yank the top of the kill ring into the buffer at point. <br>
yank-pop (M-y) <br>
Rotate the kill ring, and yank the new top. Only works
following yank or yank-pop.</p>

<p style="margin-top: 1em">Numeric Arguments <br>
digit-argument (M-0, M-1, ..., M--) <br>
Add this digit to the argument already accumulating, or
start a new argument. M-- starts a negative argument. <br>
universal-argument <br>
This is another way to specify an argument. If this command
is followed by one or more digits, optionally with a leading
minus sign, those digits define the argument. If <br>
the command is followed by digits, executing
universal-argument again ends the numeric argument, but is
otherwise ignored. As a special case, if this command is
immedi&acirc; <br>
ately followed by a character that is neither a digit or
minus sign, the argument count for the next command is
multiplied by four. The argument count is initially one,
<br>
so executing this function the first time makes the argument
count four, a second time makes the argument count sixteen,
and so on.</p>

<p style="margin-top: 1em">Completing <br>
complete (TAB) <br>
Attempt to perform completion on the text before point. Bash
attempts completion treating the text as a variable (if the
text begins with $), username (if the text begins <br>
with ~), hostname (if the text begins with @), or command
(including aliases and functions) in turn. If none of these
produces a match, filename completion is attempted. <br>
possible-completions (M-?) <br>
List the possible completions of the text before point. <br>
insert-completions (M-*) <br>
Insert all completions of the text before point that would
have been generated by possible-completions. <br>
menu-complete <br>
Similar to complete, but replaces the word to be completed
with a single match from the list of possible completions.
Repeated execution of menu-complete steps through <br>
the list of possible completions, inserting each match in
turn. At the end of the list of completions, the bell is
rung (subject to the setting of bell-style) and the <br>
original text is restored. An argument of n moves n
positions forward in the list of matches; a negative
argument may be used to move backward through the list. This
<br>
command is intended to be bound to TAB, but is unbound by
default. <br>
menu-complete-backward <br>
Identical to menu-complete, but moves backward through the
list of possible completions, as if menu-complete had been
given a negative argument. This command is unbound <br>
by default. <br>
delete-char-or-list <br>
Deletes the character under the cursor if not at the
beginning or end of the line (like delete-char). If at the
end of the line, behaves identically to
possible-comple&acirc; <br>
tions. This command is unbound by default. <br>
complete-filename (M-/) <br>
Attempt filename completion on the text before point. <br>
possible-filename-completions (C-x /) <br>
List the possible completions of the text before point,
treating it as a filename. <br>
complete-username (M-~) <br>
Attempt completion on the text before point, treating it as
a username. <br>
possible-username-completions (C-x ~) <br>
List the possible completions of the text before point,
treating it as a username. <br>
complete-variable (M-$) <br>
Attempt completion on the text before point, treating it as
a shell variable. <br>
possible-variable-completions (C-x $) <br>
List the possible completions of the text before point,
treating it as a shell variable. <br>
complete-hostname (M-@) <br>
Attempt completion on the text before point, treating it as
a hostname. <br>
possible-hostname-completions (C-x @) <br>
List the possible completions of the text before point,
treating it as a hostname. <br>
complete-command (M-!) <br>
Attempt completion on the text before point, treating it as
a command name. Command completion attempts to match the
text against aliases, reserved words, shell func&acirc; <br>
tions, shell builtins, and finally executable filenames, in
that order. <br>
possible-command-completions (C-x !) <br>
List the possible completions of the text before point,
treating it as a command name. <br>
dynamic-complete-history (M-TAB) <br>
Attempt completion on the text before point, comparing the
text against lines from the history list for possible
completion matches. <br>
dabbrev-expand <br>
Attempt menu completion on the text before point, comparing
the text against lines from the history list for possible
completion matches. <br>
complete-into-braces (M-{) <br>
Perform filename completion and insert the list of possible
completions enclosed within braces so the list is available
to the shell (see Brace Expansion above).</p>

<p style="margin-top: 1em">Keyboard Macros <br>
start-kbd-macro (C-x () <br>
Begin saving the characters typed into the current keyboard
macro. <br>
end-kbd-macro (C-x )) <br>
Stop saving the characters typed into the current keyboard
macro and store the definition. <br>
call-last-kbd-macro (C-x e) <br>
Re-execute the last keyboard macro defined, by making the
characters in the macro appear as if typed at the
keyboard.</p>

<p style="margin-top: 1em">Miscellaneous <br>
re-read-init-file (C-x C-r) <br>
Read in the contents of the inputrc file, and incorporate
any bindings or variable assignments found there. <br>
abort (C-g) <br>
Abort the current editing command and ring the
terminal&rsquo;s bell (subject to the setting of
bell-style). <br>
do-uppercase-version (M-a, M-b, M-x, ...) <br>
If the metafied character x is lowercase, run the command
that is bound to the corresponding uppercase character. <br>
prefix-meta (ESC) <br>
Metafy the next character typed. ESC f is equivalent to
Meta-f. <br>
undo (C-_, C-x C-u) <br>
Incremental undo, separately remembered for each line. <br>
revert-line (M-r) <br>
Undo all changes made to this line. This is like executing
the undo command enough times to return the line to its
initial state. <br>
tilde-expand (M-&amp;) <br>
Perform tilde expansion on the current word. <br>
set-mark (C-@, M-&lt;space&gt;) <br>
Set the mark to the point. If a numeric argument is
supplied, the mark is set to that position. <br>
exchange-point-and-mark (C-x C-x) <br>
Swap the point with the mark. The current cursor position is
set to the saved position, and the old cursor position is
saved as the mark. <br>
character-search (C-]) <br>
A character is read and point is moved to the next
occurrence of that character. A negative count searches for
previous occurrences. <br>
character-search-backward (M-C-]) <br>
A character is read and point is moved to the previous
occurrence of that character. A negative count searches for
subsequent occurrences. <br>
skip-csi-sequence <br>
Read enough characters to consume a multi-key sequence such
as those defined for keys like Home and End. Such sequences
begin with a Control Sequence Indicator (CSI), <br>
usually ESC-[. If this sequence is bound to &quot; stray
characters into the editing buffer. This is unbound by
default, but usually bound to ESC-[. <br>
insert-comment (M-#) <br>
Without a numeric argument, the value of the readline
comment-begin variable is inserted at the beginning of the
current line. If a numeric argument is supplied, this <br>
command acts as a toggle: if the characters at the beginning
of the line do not match the value of comment-begin, the
value is inserted, otherwise the characters in com&acirc;
<br>
ment-begin are deleted from the beginning of the line. In
either case, the line is accepted as if a newline had been
typed. The default value of comment-begin causes <br>
this command to make the current line a shell comment. If a
numeric argument causes the comment character to be removed,
the line will be executed by the shell. <br>
glob-complete-word (M-g) <br>
The word before point is treated as a pattern for pathname
expansion, with an asterisk implicitly appended. This
pattern is used to generate a list of matching file names
<br>
for possible completions. <br>
glob-expand-word (C-x *) <br>
The word before point is treated as a pattern for pathname
expansion, and the list of matching file names is inserted,
replacing the word. If a numeric argument is sup&acirc; <br>
plied, an asterisk is appended before pathname expansion.
<br>
glob-list-expansions (C-x g) <br>
The list of expansions that would have been generated by
glob-expand-word is displayed, and the line is redrawn. If a
numeric argument is supplied, an asterisk is <br>
appended before pathname expansion. <br>
dump-functions <br>
Print all of the functions and their key bindings to the
readline output stream. If a numeric argument is supplied,
the output is formatted in such a way that it can be <br>
made part of an inputrc file. <br>
dump-variables <br>
Print all of the settable readline variables and their
values to the readline output stream. If a numeric argument
is supplied, the output is formatted in such a way that <br>
it can be made part of an inputrc file. <br>
dump-macros <br>
Print all of the readline key sequences bound to macros and
the strings they output. If a numeric argument is supplied,
the output is formatted in such a way that it can <br>
be made part of an inputrc file. <br>
display-shell-version (C-x C-v) <br>
Display version information about the current instance of
bash.</p>

<p style="margin-top: 1em">Programmable Completion <br>
When word completion is attempted for an argument to a
command for which a completion specification (a compspec)
has been defined using the complete builtin (see SHELL
BUILTIN <br>
COMMANDS below), the programmable completion facilities are
invoked.</p>

<p style="margin-top: 1em">First, the command name is
identified. If the command word is the empty string
(completion attempted at the beginning of an empty line),
any compspec defined with the -E option <br>
to complete is used. If a compspec has been defined for that
command, the compspec is used to generate the list of
possible completions for the word. If the command word is a
<br>
full pathname, a compspec for the full pathname is searched
for first. If no compspec is found for the full pathname, an
attempt is made to find a compspec for the portion
fol&acirc; <br>
lowing the final slash. If those searches do not result in a
compspec, any compspec defined with the -D option to
complete is used as the default.</p>

<p style="margin-top: 1em">Once a compspec has been found,
it is used to generate the list of matching words. If a
compspec is not found, the default bash completion as
described above under Completing is <br>
performed.</p>

<p style="margin-top: 1em">First, the actions specified by
the compspec are used. Only matches which are prefixed by
the word being completed are returned. When the -f or -d
option is used for filename <br>
or directory name completion, the shell variable FIGNORE is
used to filter the matches.</p>

<p style="margin-top: 1em">Any completions specified by a
pathname expansion pattern to the -G option are generated
next. The words generated by the pattern need not match the
word being completed. The <br>
GLOBIGNORE shell variable is not used to filter the matches,
but the FIGNORE variable is used.</p>

<p style="margin-top: 1em">Next, the string specified as
the argument to the -W option is considered. The string is
first split using the characters in the IFS special variable
as delimiters. Shell quot&acirc; <br>
ing is honored. Each word is then expanded using brace
expansion, tilde expansion, parameter and variable
expansion, command substitution, and arithmetic expansion,
as described <br>
above under EXPANSION. The results are split using the rules
described above under Word Splitting. The results of the
expansion are prefix-matched against the word being
com&acirc; <br>
pleted, and the matching words become the possible
completions.</p>

<p style="margin-top: 1em">After these matches have been
generated, any shell function or command specified with the
-F and -C options is invoked. When the command or function
is invoked, the COMP_LINE, <br>
COMP_POINT, COMP_KEY, and COMP_TYPE variables are assigned
values as described above under Shell Variables. If a shell
function is being invoked, the COMP_WORDS and COMP_CWORD
<br>
variables are also set. When the function or command is
invoked, the first argument is the name of the command whose
arguments are being completed, the second argument is the
<br>
word being completed, and the third argument is the word
preceding the word being completed on the current command
line. No filtering of the generated completions against the
<br>
word being completed is performed; the function or command
has complete freedom in generating the matches.</p>

<p style="margin-top: 1em">Any function specified with -F
is invoked first. The function may use any of the shell
facilities, including the compgen builtin described below,
to generate the matches. It <br>
must put the possible completions in the COMPREPLY array
variable.</p>

<p style="margin-top: 1em">Next, any command specified with
the -C option is invoked in an environment equivalent to
command substitution. It should print a list of completions,
one per line, to the stan&acirc; <br>
dard output. Backslash may be used to escape a newline, if
necessary.</p>

<p style="margin-top: 1em">After all of the possible
completions are generated, any filter specified with the -X
option is applied to the list. The filter is a pattern as
used for pathname expansion; a &amp; <br>
in the pattern is replaced with the text of the word being
completed. A literal &amp; may be escaped with a backslash;
the backslash is removed before attempting a match. Any
com&acirc; <br>
pletion that matches the pattern will be removed from the
list. A leading ! negates the pattern; in this case any
completion not matching the pattern will be removed.</p>

<p style="margin-top: 1em">Finally, any prefix and suffix
specified with the -P and -S options are added to each
member of the completion list, and the result is returned to
the readline completion code as <br>
the list of possible completions.</p>

<p style="margin-top: 1em">If the previously-applied
actions do not generate any matches, and the -o dirnames
option was supplied to complete when the compspec was
defined, directory name completion is <br>
attempted.</p>

<p style="margin-top: 1em">If the -o plusdirs option was
supplied to complete when the compspec was defined,
directory name completion is attempted and any matches are
added to the results of the other <br>
actions.</p>

<p style="margin-top: 1em">By default, if a compspec is
found, whatever it generates is returned to the completion
code as the full set of possible completions. The default
bash completions are not <br>
attempted, and the readline default of filename completion
is disabled. If the -o bashdefault option was supplied to
complete when the compspec was defined, the bash default
<br>
completions are attempted if the compspec generates no
matches. If the -o default option was supplied to complete
when the compspec was defined, readline&rsquo;s default
completion <br>
will be performed if the compspec (and, if attempted, the
default bash completions) generate no matches.</p>

<p style="margin-top: 1em">When a compspec indicates that
directory name completion is desired, the programmable
completion functions force readline to append a slash to
completed names which are symbolic <br>
links to directories, subject to the value of the
mark-directories readline variable, regardless of the
setting of the mark-symlinked-directories readline
variable.</p>

<p style="margin-top: 1em">There is some support for
dynamically modifying completions. This is most useful when
used in combination with a default completion specified with
complete -D. It&rsquo;s possible <br>
for shell functions executed as completion handlers to
indicate that completion should be retried by returning an
exit status of 124. If a shell function returns 124, and
<br>
changes the compspec associated with the command on which
completion is being attempted (supplied as the first
argument when the function is executed), programmable
completion <br>
restarts from the beginning, with an attempt to find a new
compspec for that command. This allows a set of completions
to be built dynamically as completion is attempted, rather
<br>
than being loaded all at once.</p>

<p style="margin-top: 1em">For instance, assuming that
there is a library of compspecs, each kept in a file
corresponding to the name of the command, the following
default completion function would load <br>
completions dynamically:</p>

<p style="margin-top: 1em">_completion_loader() <br>
{ <br>
. &quot;/etc/bash_completion.d/$1.sh&quot; &gt;/dev/null
2&gt;&amp;1 &amp;&amp; return 124 <br>
} <br>
complete -D -F _completion_loader</p>

<p style="margin-top: 1em">HISTORY <br>
When the -o history option to the set builtin is enabled,
the shell provides access to the command history, the list
of commands previously typed. The value of the HISTSIZE <br>
variable is used as the number of commands to save in a
history list. The text of the last HISTSIZE commands
(default 500) is saved. The shell stores each command in the
his&acirc; <br>
tory list prior to parameter and variable expansion (see
EXPANSION above) but after history expansion is performed,
subject to the values of the shell variables HISTIGNORE and
<br>
HISTCONTROL.</p>

<p style="margin-top: 1em">On startup, the history is
initialized from the file named by the variable HISTFILE
(default ~/.bash_history). The file named by the value of
HISTFILE is truncated, if neces&acirc; <br>
sary, to contain no more than the number of lines specified
by the value of HISTFILESIZE. When the history file is read,
lines beginning with the history comment character
fol&acirc; <br>
lowed immediately by a digit are interpreted as timestamps
for the preceding history line. These timestamps are
optionally displayed depending on the value of the
HISTTIMEFORMAT <br>
variable. When an interactive shell exits, the last
$HISTSIZE lines are copied from the history list to
$HISTFILE. If the histappend shell option is enabled (see
the descrip&acirc; <br>
tion of shopt under SHELL BUILTIN COMMANDS below), the lines
are appended to the history file, otherwise the history file
is overwritten. If HISTFILE is unset, or if the history <br>
file is unwritable, the history is not saved. If the
HISTTIMEFORMAT variable is set, time stamps are written to
the history file, marked with the history comment character,
so <br>
they may be preserved across shell sessions. This uses the
history comment character to distinguish timestamps from
other history lines. After saving the history, the history
<br>
file is truncated to contain no more than HISTFILESIZE
lines. If HISTFILESIZE is not set, no truncation is
performed.</p>

<p style="margin-top: 1em">The builtin command fc (see
SHELL BUILTIN COMMANDS below) may be used to list or edit
and re-execute a portion of the history list. The history
builtin may be used to display or <br>
modify the history list and manipulate the history file.
When using command-line editing, search commands are
available in each editing mode that provide access to the
history <br>
list.</p>

<p style="margin-top: 1em">The shell allows control over
which commands are saved on the history list. The
HISTCONTROL and HISTIGNORE variables may be set to cause the
shell to save only a subset of the <br>
commands entered. The cmdhist shell option, if enabled,
causes the shell to attempt to save each line of a
multi-line command in the same history entry, adding
semicolons where <br>
necessary to preserve syntactic correctness. The lithist
shell option causes the shell to save the command with
embedded newlines instead of semicolons. See the description
of <br>
the shopt builtin below under SHELL BUILTIN COMMANDS for
information on setting and unsetting shell options.</p>

<p style="margin-top: 1em">HISTORY EXPANSION <br>
The shell supports a history expansion feature that is
similar to the history expansion in csh. This section
describes what syntax features are available. This feature
is <br>
enabled by default for interactive shells, and can be
disabled using the +H option to the set builtin command (see
SHELL BUILTIN COMMANDS below). Non-interactive shells do not
<br>
perform history expansion by default.</p>

<p style="margin-top: 1em">History expansions introduce
words from the history list into the input stream, making it
easy to repeat commands, insert the arguments to a previous
command into the current <br>
input line, or fix errors in previous commands quickly.</p>

<p style="margin-top: 1em">History expansion is performed
immediately after a complete line is read, before the shell
breaks it into words. It takes place in two parts. The first
is to determine which <br>
line from the history list to use during substitution. The
second is to select portions of that line for inclusion into
the current one. The line selected from the history is <br>
the event, and the portions of that line that are acted upon
are words. Various modifiers are available to manipulate the
selected words. The line is broken into words in the <br>
same fashion as when reading input, so that several
metacharacter-separated words surrounded by quotes are
considered one word. History expansions are introduced by
the appear&acirc; <br>
ance of the history expansion character, which is ! by
default. Only backslash ( and single quotes can quote the
history expansion character.</p>

<p style="margin-top: 1em">Several characters inhibit
history expansion if found immediately following the history
expansion character, even if it is unquoted: space, tab,
newline, carriage return, and =. <br>
If the extglob shell option is enabled, ( will also inhibit
expansion.</p>

<p style="margin-top: 1em">Several shell options settable
with the shopt builtin may be used to tailor the behavior of
history expansion. If the histverify shell option is enabled
(see the description of <br>
the shopt builtin below), and readline is being used,
history substitutions are not immediately passed to the
shell parser. Instead, the expanded line is reloaded into
the read&acirc; <br>
line editing buffer for further modification. If readline is
being used, and the histreedit shell option is enabled, a
failed history substitution will be reloaded into the <br>
readline editing buffer for correction. The -p option to the
history builtin command may be used to see what a history
expansion will do before using it. The -s option to the <br>
history builtin may be used to add commands to the end of
the history list without actually executing them, so that
they are available for subsequent recall.</p>

<p style="margin-top: 1em">The shell allows control of the
various characters used by the history expansion mechanism
(see the description of histchars above under Shell
Variables). The shell uses the <br>
history comment character to mark history timestamps when
writing the history file.</p>

<p style="margin-top: 1em">Event Designators <br>
An event designator is a reference to a command line entry
in the history list. Unless the reference is absolute,
events are relative to the current position in the history
<br>
list.</p>

<p style="margin-top: 1em">! Start a history substitution,
except when followed by a blank, newline, carriage return, =
or ( (when the extglob shell option is enabled using the
shopt builtin). <br>
!n Refer to command line n. <br>
!-n Refer to the current command minus n. <br>
!! Refer to the previous command. This is a synonym for
&lsquo;!-1&rsquo;. <br>
!string <br>
Refer to the most recent command preceding the current
position in the history list starting with string. <br>
!?string[?] <br>
Refer to the most recent command preceding the current
postition in the history list containing string. The
trailing ? may be omitted if string is followed immediately
by <br>
a newline. <br>
^string1^string2^ <br>
Quick substitution. Repeat the previous command, replacing
string1 with string2. Equivalent to
&lsquo;&lsquo;!!:s/string1/string2/&rsquo;&rsquo; (see
Modifiers below). <br>
!# The entire command line typed so far.</p>

<p style="margin-top: 1em">Word Designators <br>
Word designators are used to select desired words from the
event. A : separates the event specification from the word
designator. It may be omitted if the word designator <br>
begins with a ^, $, *, -, or %. Words are numbered from the
beginning of the line, with the first word being denoted by
0 (zero). Words are inserted into the current line
sepa&acirc; <br>
rated by single spaces.</p>

<p style="margin-top: 1em">0 (zero) <br>
The zeroth word. For the shell, this is the command word.
<br>
n The nth word. <br>
^ The first argument. That is, word 1. <br>
$ The last argument. <br>
% The word matched by the most recent &lsquo;?string?&rsquo;
search. <br>
x-y A range of words; &lsquo;-y&rsquo; abbreviates
&lsquo;0-y&rsquo;. <br>
* All of the words but the zeroth. This is a synonym for
&lsquo;1-$&rsquo;. It is not an error to use * if there is
just one word in the event; the empty string is returned in
that <br>
case. <br>
x* Abbreviates x-$. <br>
x- Abbreviates x-$ like x*, but omits the last word.</p>

<p style="margin-top: 1em">If a word designator is supplied
without an event specification, the previous command is used
as the event.</p>

<p style="margin-top: 1em">Modifiers <br>
After the optional word designator, there may appear a
sequence of one or more of the following modifiers, each
preceded by a &lsquo;:&rsquo;.</p>

<p style="margin-top: 1em">h Remove a trailing file name
component, leaving only the head. <br>
t Remove all leading file name components, leaving the tail.
<br>
r Remove a trailing suffix of the form .xxx, leaving the
basename. <br>
e Remove all but the trailing suffix. <br>
p Print the new command but do not execute it. <br>
q Quote the substituted words, escaping further
substitutions. <br>
x Quote the substituted words as with q, but break into
words at blanks and newlines. <br>
s/old/new/ <br>
Substitute new for the first occurrence of old in the event
line. Any delimiter can be used in place of /. The final
delimiter is optional if it is the last character of <br>
the event line. The delimiter may be quoted in old and new
with a single backslash. If &amp; appears in new, it is
replaced by old. A single backslash will quote the &amp;. If
<br>
old is null, it is set to the last old substituted, or, if
no previous history substitutions took place, the last
string in a !?string[?] search. <br>
&amp; Repeat the previous substitution. <br>
g Cause changes to be applied over the entire event line.
This is used in conjunction with &lsquo;:s&rsquo; (e.g.,
&lsquo;:gs/old/new/&rsquo;) or &lsquo;:&amp;&rsquo;. If used
with &lsquo;:s&rsquo;, any delimiter can be <br>
used in place of /, and the final delimiter is optional if
it is the last character of the event line. An a may be used
as a synonym for g. <br>
G Apply the following &lsquo;s&rsquo; modifier once to each
word in the event line.</p>

<p style="margin-top: 1em">SHELL BUILTIN COMMANDS <br>
Unless otherwise noted, each builtin command documented in
this section as accepting options preceded by - accepts --
to signify the end of the options. The :, true, false, and
<br>
test builtins do not accept options and do not treat --
specially. The exit, logout, break, continue, let, and shift
builtins accept and process arguments beginning with -
with&acirc; <br>
out requiring --. Other builtins that accept arguments but
are not specified as accepting options interpret arguments
beginning with - as invalid options and require -- to
pre&acirc; <br>
vent this interpretation. <br>
: [arguments] <br>
No effect; the command does nothing beyond expanding
arguments and performing any specified redirections. A zero
exit code is returned.</p>

<p style="margin-top: 1em">. filename [arguments] <br>
source filename [arguments] <br>
Read and execute commands from filename in the current shell
environment and return the exit status of the last command
executed from filename. If filename does not con&acirc; <br>
tain a slash, file names in PATH are used to find the
directory containing filename. The file searched for in PATH
need not be executable. When bash is not in posix <br>
mode, the current directory is searched if no file is found
in PATH. If the sourcepath option to the shopt builtin
command is turned off, the PATH is not searched. If <br>
any arguments are supplied, they become the positional
parameters when filename is executed. Otherwise the
positional parameters are unchanged. The return status is
the <br>
status of the last command exited within the script (0 if no
commands are executed), and false if filename is not found
or cannot be read.</p>

<p style="margin-top: 1em">alias [-p] [name[=value] ...]
<br>
Alias with no arguments or with the -p option prints the
list of aliases in the form alias name=value on standard
output. When arguments are supplied, an alias is defined
<br>
for each name whose value is given. A trailing space in
value causes the next word to be checked for alias
substitution when the alias is expanded. For each name in
the <br>
argument list for which no value is supplied, the name and
value of the alias is printed. Alias returns true unless a
name is given for which no alias has been defined.</p>

<p style="margin-top: 1em">bg [jobspec ...] <br>
Resume each suspended job jobspec in the background, as if
it had been started with &amp;. If jobspec is not present,
the shell&rsquo;s notion of the current job is used. bg
job&acirc; <br>
spec returns 0 unless run when job control is disabled or,
when run with job control enabled, any specified jobspec was
not found or was started without job control.</p>

<p style="margin-top: 1em">bind [-m keymap] [-lpsvPSV] <br>
bind [-m keymap] [-q function] [-u function] [-r keyseq]
<br>
bind [-m keymap] -f filename <br>
bind [-m keymap] -x keyseq:shell-command <br>
bind [-m keymap] keyseq:function-name <br>
bind readline-command <br>
Display current readline key and function bindings, bind a
key sequence to a readline function or macro, or set a
readline variable. Each non-option argument is a command
<br>
as it would appear in .inputrc, but each binding or command
must be passed as a separate argument; e.g.,
&rsquo;&quot;read-init-file&rsquo;. Options, if supplied,
have the <br>
following meanings: <br>
-m keymap <br>
Use keymap as the keymap to be affected by the subsequent
bindings. Acceptable keymap names are emacs, emacs-standard,
emacs-meta, emacs-ctlx, vi, vi-move, vi-com&acirc; <br>
mand, and vi-insert. vi is equivalent to vi-command; emacs
is equivalent to emacs-standard. <br>
-l List the names of all readline functions. <br>
-p Display readline function names and bindings in such a
way that they can be re-read. <br>
-P List current readline function names and bindings. <br>
-s Display readline key sequences bound to macros and the
strings they output in such a way that they can be re-read.
<br>
-S Display readline key sequences bound to macros and the
strings they output. <br>
-v Display readline variable names and values in such a way
that they can be re-read. <br>
-V List current readline variable names and values. <br>
-f filename <br>
Read key bindings from filename. <br>
-q function <br>
Query about which keys invoke the named function. <br>
-u function <br>
Unbind all keys bound to the named function. <br>
-r keyseq <br>
Remove any current binding for keyseq. <br>
-x keyseq:shell-command <br>
Cause shell-command to be executed whenever keyseq is
entered. When shell-command is executed, the shell sets the
READLINE_LINE variable to the contents of the <br>
readline line buffer and the READLINE_POINT variable to the
current location of the insertion point. If the executed
command changes the value of READLINE_LINE or <br>
READLINE_POINT, those new values will be reflected in the
editing state.</p>

<p style="margin-top: 1em">The return value is 0 unless an
unrecognized option is given or an error occurred.</p>

<p style="margin-top: 1em">break [n] <br>
Exit from within a for, while, until, or select loop. If n
is specified, break n levels. n must be &acirc;&yen; 1. If n
is greater than the number of enclosing loops, all
enclos&acirc; <br>
ing loops are exited. The return value is non-zero when n is
&acirc;&curren; 0; Otherwise, break returns 0 value.</p>

<p style="margin-top: 1em">builtin shell-builtin
[arguments] <br>
Execute the specified shell builtin, passing it arguments,
and return its exit status. This is useful when defining a
function whose name is the same as a shell builtin, <br>
retaining the functionality of the builtin within the
function. The cd builtin is commonly redefined this way. The
return status is false if shell-builtin is not a shell <br>
builtin command.</p>

<p style="margin-top: 1em">caller [expr] <br>
Returns the context of any active subroutine call (a shell
function or a script executed with the . or source
builtins). Without expr, caller displays the line number and
<br>
source filename of the current subroutine call. If a
non-negative integer is supplied as expr, caller displays
the line number, subroutine name, and source file
corre&acirc; <br>
sponding to that position in the current execution call
stack. This extra information may be used, for example, to
print a stack trace. The current frame is frame 0. <br>
The return value is 0 unless the shell is not executing a
subroutine call or expr does not correspond to a valid
position in the call stack.</p>

<p style="margin-top: 1em">cd [-L|[-P [-e]]] [dir] <br>
Change the current directory to dir. The variable HOME is
the default dir. The variable CDPATH defines the search path
for the directory containing dir. Alternative <br>
directory names in CDPATH are separated by a colon (:). A
null directory name in CDPATH is the same as the current
directory, i.e., &lsquo;&lsquo;.&rsquo;&rsquo;. If dir
begins with a slash <br>
(/), then CDPATH is not used. The -P option says to use the
physical directory structure instead of following symbolic
links (see also the -P option to the set builtin <br>
command); the -L option forces symbolic links to be
followed. If the -e option is supplied with -P, and the
current working directory cannot be successfully determined
<br>
after a successful directory change, cd will return an
unsuccessful status. An argument of - is equivalent to
$OLDPWD. If a non-empty directory name from CDPATH is used,
<br>
or if - is the first argument, and the directory change is
successful, the absolute pathname of the new working
directory is written to the standard output. The return <br>
value is true if the directory was successfully changed;
false otherwise.</p>

<p style="margin-top: 1em">command [-pVv] command [arg ...]
<br>
Run command with args suppressing the normal shell function
lookup. Only builtin commands or commands found in the PATH
are executed. If the -p option is given, the <br>
search for command is performed using a default value for
PATH that is guaranteed to find all of the standard
utilities. If either the -V or -v option is supplied, a <br>
description of command is printed. The -v option causes a
single word indicating the command or file name used to
invoke command to be displayed; the -V option produces a
<br>
more verbose description. If the -V or -v option is
supplied, the exit status is 0 if command was found, and 1
if not. If neither option is supplied and an error <br>
occurred or command cannot be found, the exit status is 127.
Otherwise, the exit status of the command builtin is the
exit status of command.</p>

<p style="margin-top: 1em">compgen [option] [word] <br>
Generate possible completion matches for word according to
the options, which may be any option accepted by the
complete builtin with the exception of -p and -r, and write
<br>
the matches to the standard output. When using the -F or -C
options, the various shell variables set by the programmable
completion facilities, while available, will not <br>
have useful values.</p>

<p style="margin-top: 1em">The matches will be generated in
the same way as if the programmable completion code had
generated them directly from a completion specification with
the same flags. If <br>
word is specified, only those completions matching word will
be displayed.</p>

<p style="margin-top: 1em">The return value is true unless
an invalid option is supplied, or no matches were
generated.</p>

<p style="margin-top: 1em">complete [-abcdefgjksuv] [-o
comp-option] [-DE] [-A action] [-G globpat] [-W wordlist]
[-F function] [-C command] <br>
[-X filterpat] [-P prefix] [-S suffix] name [name ...] <br>
complete -pr [-DE] [name ...] <br>
Specify how arguments to each name should be completed. If
the -p option is supplied, or if no options are supplied,
existing completion specifications are printed in a <br>
way that allows them to be reused as input. The -r option
removes a completion specification for each name, or, if no
names are supplied, all completion specifications. <br>
The -D option indicates that the remaining options and
actions should apply to the
&lsquo;&lsquo;default&rsquo;&rsquo; command completion; that
is, completion attempted on a command for which no <br>
completion has previously been defined. The -E option
indicates that the remaining options and actions should
apply to &lsquo;&lsquo;empty&rsquo;&rsquo; command
completion; that is, completion <br>
attempted on a blank line.</p>

<p style="margin-top: 1em">The process of applying these
completion specifications when word completion is attempted
is described above under Programmable Completion.</p>

<p style="margin-top: 1em">Other options, if specified,
have the following meanings. The arguments to the -G, -W,
and -X options (and, if necessary, the -P and -S options)
should be quoted to pro&acirc; <br>
tect them from expansion before the complete builtin is
invoked. <br>
-o comp-option <br>
The comp-option controls several aspects of the
compspec&rsquo;s behavior beyond the simple generation of
completions. comp-option may be one of: <br>
bashdefault <br>
Perform the rest of the default bash completions if the
compspec generates no matches. <br>
default Use readline&rsquo;s default filename completion if
the compspec generates no matches. <br>
dirnames <br>
Perform directory name completion if the compspec generates
no matches. <br>
filenames <br>
Tell readline that the compspec generates filenames, so it
can perform any filename-specific processing (like adding a
slash to directory names, quoting <br>
special characters, or suppressing trailing spaces).
Intended to be used with shell functions. <br>
nospace Tell readline not to append a space (the default) to
words completed at the end of the line. <br>
plusdirs <br>
After any matches defined by the compspec are generated,
directory name completion is attempted and any matches are
added to the results of the other <br>
actions. <br>
-A action <br>
The action may be one of the following to generate a list of
possible completions: <br>
alias Alias names. May also be specified as -a. <br>
arrayvar <br>
Array variable names. <br>
binding Readline key binding names. <br>
builtin Names of shell builtin commands. May also be
specified as -b. <br>
command Command names. May also be specified as -c. <br>
directory <br>
Directory names. May also be specified as -d. <br>
disabled <br>
Names of disabled shell builtins. <br>
enabled Names of enabled shell builtins. <br>
export Names of exported shell variables. May also be
specified as -e. <br>
file File names. May also be specified as -f. <br>
function <br>
Names of shell functions. <br>
group Group names. May also be specified as -g. <br>
helptopic <br>
Help topics as accepted by the help builtin. <br>
hostname <br>
Hostnames, as taken from the file specified by the HOSTFILE
shell variable. <br>
job Job names, if job control is active. May also be
specified as -j. <br>
keyword Shell reserved words. May also be specified as -k.
<br>
running Names of running jobs, if job control is active.
<br>
service Service names. May also be specified as -s. <br>
setopt Valid arguments for the -o option to the set builtin.
<br>
shopt Shell option names as accepted by the shopt builtin.
<br>
signal Signal names. <br>
stopped Names of stopped jobs, if job control is active.
<br>
user User names. May also be specified as -u. <br>
variable <br>
Names of all shell variables. May also be specified as -v.
<br>
-C command <br>
command is executed in a subshell environment, and its
output is used as the possible completions. <br>
-F function <br>
The shell function function is executed in the current shell
environment. When it finishes, the possible completions are
retrieved from the value of the COMPREPLY <br>
array variable. <br>
-G globpat <br>
The pathname expansion pattern globpat is expanded to
generate the possible completions. <br>
-P prefix <br>
prefix is added at the beginning of each possible completion
after all other options have been applied. <br>
-S suffix <br>
suffix is appended to each possible completion after all
other options have been applied. <br>
-W wordlist <br>
The wordlist is split using the characters in the IFS
special variable as delimiters, and each resultant word is
expanded. The possible completions are the mem&acirc; <br>
bers of the resultant list which match the word being
completed. <br>
-X filterpat <br>
filterpat is a pattern as used for pathname expansion. It is
applied to the list of possible completions generated by the
preceding options and arguments, and <br>
each completion matching filterpat is removed from the list.
A leading ! in filterpat negates the pattern; in this case,
any completion not matching filterpat is <br>
removed.</p>

<p style="margin-top: 1em">The return value is true unless
an invalid option is supplied, an option other than -p or -r
is supplied without a name argument, an attempt is made to
remove a completion <br>
specification for a name for which no specification exists,
or an error occurs adding a completion specification.</p>

<p style="margin-top: 1em">compopt [-o option] [-DE] [+o
option] [name] <br>
Modify completion options for each name according to the
options, or for the currently-executing completion if no
names are supplied. If no options are given, display the
<br>
completion options for each name or the current completion.
The possible values of option are those valid for the
complete builtin described above. The -D option indi&acirc;
<br>
cates that the remaining options should apply to the
&lsquo;&lsquo;default&rsquo;&rsquo; command completion; that
is, completion attempted on a command for which no
completion has previously been <br>
defined. The -E option indicates that the remaining options
should apply to &lsquo;&lsquo;empty&rsquo;&rsquo; command
completion; that is, completion attempted on a blank
line.</p>

<p style="margin-top: 1em">The return value is true unless
an invalid option is supplied, an attempt is made to modify
the options for a name for which no completion specification
exists, or an out&acirc; <br>
put error occurs.</p>

<p style="margin-top: 1em">continue [n] <br>
Resume the next iteration of the enclosing for, while,
until, or select loop. If n is specified, resume at the nth
enclosing loop. n must be &acirc;&yen; 1. If n is greater
than <br>
the number of enclosing loops, the last enclosing loop (the
&lsquo;&lsquo;top-level&rsquo;&rsquo; loop) is resumed. When
continue is executed inside of loop, the return value is
non-zero when n <br>
is &acirc;&curren; 0; Otherwise, continue returns 0 value.
When continue is executed outside of loop, the return value
is 0.</p>

<p style="margin-top: 1em">declare [-aAfFgilrtux] [-p]
[name[=value] ...] <br>
typeset [-aAfFgilrtux] [-p] [name[=value] ...] <br>
Declare variables and/or give them attributes. If no names
are given then display the values of variables. The -p
option will display the attributes and values of each <br>
name. When -p is used with name arguments, additional
options are ignored. When -p is supplied without name
arguments, it will display the attributes and values of all
<br>
variables having the attributes specified by the additional
options. If no other options are supplied with -p, declare
will display the attributes and values of all shell <br>
variables. The -f option will restrict the display to shell
functions. The -F option inhibits the display of function
definitions; only the function name and attributes <br>
are printed. If the extdebug shell option is enabled using
shopt, the source file name and line number where the
function is defined are displayed as well. The -F option
<br>
implies -f. The -g option forces variables to be created or
modified at the global scope, even when declare is executed
in a shell function. It is ignored in all other <br>
cases. The following options can be used to restrict output
to variables with the specified attribute or to give
variables attributes: <br>
-a Each name is an indexed array variable (see Arrays
above). <br>
-A Each name is an associative array variable (see Arrays
above). <br>
-f Use function names only. <br>
-i The variable is treated as an integer; arithmetic
evaluation (see ARITHMETIC EVALUATION above) is performed
when the variable is assigned a value. <br>
-l When the variable is assigned a value, all upper-case
characters are converted to lower-case. The upper-case
attribute is disabled. <br>
-r Make names readonly. These names cannot then be assigned
values by subsequent assignment statements or unset. <br>
-t Give each name the trace attribute. Traced functions
inherit the DEBUG and RETURN traps from the calling shell.
The trace attribute has no special meaning for <br>
variables. <br>
-u When the variable is assigned a value, all lower-case
characters are converted to upper-case. The lower-case
attribute is disabled. <br>
-x Mark names for export to subsequent commands via the
environment.</p>

<p style="margin-top: 1em">Using &lsquo;+&rsquo; instead of
&lsquo;-&rsquo; turns off the attribute instead, with the
exceptions that +a may not be used to destroy an array
variable and +r will not remove the readonly <br>
attribute. When used in a function, makes each name local,
as with the local command, unless the -g option is supplied,
If a variable name is followed by =value, the <br>
value of the variable is set to value. The return value is 0
unless an invalid option is encountered, an attempt is made
to define a function using &lsquo;&lsquo;-f
foo=bar&rsquo;&rsquo;, an <br>
attempt is made to assign a value to a readonly variable, an
attempt is made to assign a value to an array variable
without using the compound assignment syntax (see <br>
Arrays above), one of the names is not a valid shell
variable name, an attempt is made to turn off readonly
status for a readonly variable, an attempt is made to turn
off <br>
array status for an array variable, or an attempt is made to
display a non-existent function with -f.</p>

<p style="margin-top: 1em">dirs [+n] [-n] [-clpv] <br>
Without options, displays the list of currently remembered
directories. The default display is on a single line with
directory names separated by spaces. Directories are <br>
added to the list with the pushd command; the popd command
removes entries from the list. <br>
+n Displays the nth entry counting from the left of the list
shown by dirs when invoked without options, starting with
zero. <br>
-n Displays the nth entry counting from the right of the
list shown by dirs when invoked without options, starting
with zero. <br>
-c Clears the directory stack by deleting all of the
entries. <br>
-l Produces a longer listing; the default listing format
uses a tilde to denote the home directory. <br>
-p Print the directory stack with one entry per line. <br>
-v Print the directory stack with one entry per line,
prefixing each entry with its index in the stack.</p>

<p style="margin-top: 1em">The return value is 0 unless an
invalid option is supplied or n indexes beyond the end of
the directory stack.</p>

<p style="margin-top: 1em">disown [-ar] [-h] [jobspec ...]
<br>
Without options, each jobspec is removed from the table of
active jobs. If jobspec is not present, and neither -a nor
-r is supplied, the shell&rsquo;s notion of the current <br>
job is used. If the -h option is given, each jobspec is not
removed from the table, but is marked so that SIGHUP is not
sent to the job if the shell receives a SIGHUP. <br>
If no jobspec is present, and neither the -a nor the -r
option is supplied, the current job is used. If no jobspec
is supplied, the -a option means to remove or mark all <br>
jobs; the -r option without a jobspec argument restricts
operation to running jobs. The return value is 0 unless a
jobspec does not specify a valid job.</p>

<p style="margin-top: 1em">echo [-neE] [arg ...] <br>
Output the args, separated by spaces, followed by a newline.
The return status is always 0. If -n is specified, the
trailing newline is suppressed. If the -e option is <br>
given, interpretation of the following backslash-escaped
characters is enabled. The -E option disables the
interpretation of these escape characters, even on systems
<br>
where they are interpreted by default. The xpg_echo shell
option may be used to dynamically determine whether or not
echo expands these escape characters by default. <br>
echo does not interpret -- to mean the end of options. echo
interprets the following escape sequences: <br>
alert (bell) <br>
backspace <br>
\ &nbsp; <br>
an escape character <br>
form feed <br>
new line <br>
carriage return <br>
horizontal tab <br>
vertical tab <br>
\ backslash <br>
nnn the eight-bit character whose value is the octal value
nnn (zero to three octal digits) <br>
the eight-bit character whose value is the hexadecimal value
HH (one or two hex digits) <br>
HHHH the Unicode (ISO/IEC 10646) character whose value is
the hexadecimal value HHHH (one to four hex digits) <br>
UHHHHHHHH <br>
the Unicode (ISO/IEC 10646) character whose value is the
hexadecimal value HHHHHHHH (one to eight hex digits)</p>

<p style="margin-top: 1em">enable [-a] [-dnps] [-f
filename] [name ...] <br>
Enable and disable builtin shell commands. Disabling a
builtin allows a disk command which has the same name as a
shell builtin to be executed without specifying a full <br>
pathname, even though the shell normally searches for
builtins before disk commands. If -n is used, each name is
disabled; otherwise, names are enabled. For example, to <br>
use the test binary found via the PATH instead of the shell
builtin version, run &lsquo;&lsquo;enable -n
test&rsquo;&rsquo;. The -f option means to load the new
builtin command name from shared <br>
object filename, on systems that support dynamic loading.
The -d option will delete a builtin previously loaded with
-f. If no name arguments are given, or if the -p <br>
option is supplied, a list of shell builtins is printed.
With no other option arguments, the list consists of all
enabled shell builtins. If -n is supplied, only dis&acirc;
<br>
abled builtins are printed. If -a is supplied, the list
printed includes all builtins, with an indication of whether
or not each is enabled. If -s is supplied, the out&acirc;
<br>
put is restricted to the POSIX special builtins. The return
value is 0 unless a name is not a shell builtin or there is
an error loading a new builtin from a shared <br>
object.</p>

<p style="margin-top: 1em">eval [arg ...] <br>
The args are read and concatenated together into a single
command. This command is then read and executed by the
shell, and its exit status is returned as the value of <br>
eval. If there are no args, or only null arguments, eval
returns 0.</p>

<p style="margin-top: 1em">exec [-cl] [-a name] [command
[arguments]] <br>
If command is specified, it replaces the shell. No new
process is created. The arguments become the arguments to
command. If the -l option is supplied, the shell places <br>
a dash at the beginning of the zeroth argument passed to
command. This is what login(1) does. The -c option causes
command to be executed with an empty environment. If <br>
-a is supplied, the shell passes name as the zeroth argument
to the executed command. If command cannot be executed for
some reason, a non-interactive shell exits, unless <br>
the shell option execfail is enabled, in which case it
returns failure. An interactive shell returns failure if the
file cannot be executed. If command is not specified, <br>
any redirections take effect in the current shell, and the
return status is 0. If there is a redirection error, the
return status is 1.</p>

<p style="margin-top: 1em">exit [n] <br>
Cause the shell to exit with a status of n. If n is omitted,
the exit status is that of the last command executed. A trap
on EXIT is executed before the shell termi&acirc; <br>
nates.</p>

<p style="margin-top: 1em">export [-fn] [name[=word]] ...
<br>
export -p <br>
The supplied names are marked for automatic export to the
environment of subsequently executed commands. If the -f
option is given, the names refer to functions. If no <br>
names are given, or if the -p option is supplied, a list of
all names that are exported in this shell is printed. The -n
option causes the export property to be removed <br>
from each name. If a variable name is followed by =word, the
value of the variable is set to word. export returns an exit
status of 0 unless an invalid option is encoun&acirc; <br>
tered, one of the names is not a valid shell variable name,
or -f is supplied with a name that is not a function.</p>

<p style="margin-top: 1em">fc [-e ename] [-lnr] [first]
[last] <br>
fc -s [pat=rep] [cmd] <br>
Fix Command. In the first form, a range of commands from
first to last is selected from the history list. First and
last may be specified as a string (to locate the last <br>
command beginning with that string) or as a number (an index
into the history list, where a negative number is used as an
offset from the current command number). If last <br>
is not specified it is set to the current command for
listing (so that &lsquo;&lsquo;fc -l -10&rsquo;&rsquo;
prints the last 10 commands) and to first otherwise. If
first is not specified it is <br>
set to the previous command for editing and -16 for
listing.</p>

<p style="margin-top: 1em">The -n option suppresses the
command numbers when listing. The -r option reverses the
order of the commands. If the -l option is given, the
commands are listed on stan&acirc; <br>
dard output. Otherwise, the editor given by ename is invoked
on a file containing those commands. If ename is not given,
the value of the FCEDIT variable is used, and <br>
the value of EDITOR if FCEDIT is not set. If neither
variable is set, vi is used. When editing is complete, the
edited commands are echoed and executed.</p>

<p style="margin-top: 1em">In the second form, command is
re-executed after each instance of pat is replaced by rep. A
useful alias to use with this is &lsquo;&lsquo;r=&quot;fc
-s&quot;&rsquo;&rsquo;, so that typing &lsquo;&lsquo;r
cc&rsquo;&rsquo; runs <br>
the last command beginning with
&lsquo;&lsquo;cc&rsquo;&rsquo; and typing
&lsquo;&lsquo;r&rsquo;&rsquo; re-executes the last
command.</p>

<p style="margin-top: 1em">If the first form is used, the
return value is 0 unless an invalid option is encountered or
first or last specify history lines out of range. If the -e
option is sup&acirc; <br>
plied, the return value is the value of the last command
executed or failure if an error occurs with the temporary
file of commands. If the second form is used, the <br>
return status is that of the command re-executed, unless cmd
does not specify a valid history line, in which case fc
returns failure.</p>

<p style="margin-top: 1em">fg [jobspec] <br>
Resume jobspec in the foreground, and make it the current
job. If jobspec is not present, the shell&rsquo;s notion of
the current job is used. The return value is that of the
<br>
command placed into the foreground, or failure if run when
job control is disabled or, when run with job control
enabled, if jobspec does not specify a valid job or
job&acirc; <br>
spec specifies a job that was started without job
control.</p>

<p style="margin-top: 1em">getopts optstring name [args]
<br>
getopts is used by shell procedures to parse positional
parameters. optstring contains the option characters to be
recognized; if a character is followed by a colon, the <br>
option is expected to have an argument, which should be
separated from it by white space. The colon and question
mark characters may not be used as option characters. <br>
Each time it is invoked, getopts places the next option in
the shell variable name, initializing name if it does not
exist, and the index of the next argument to be pro&acirc;
<br>
cessed into the variable OPTIND. OPTIND is initialized to 1
each time the shell or a shell script is invoked. When an
option requires an argument, getopts places that <br>
argument into the variable OPTARG. The shell does not reset
OPTIND automatically; it must be manually reset between
multiple calls to getopts within the same shell invo&acirc;
<br>
cation if a new set of parameters is to be used.</p>

<p style="margin-top: 1em">When the end of options is
encountered, getopts exits with a return value greater than
zero. OPTIND is set to the index of the first non-option
argument, and name is set <br>
to ?.</p>

<p style="margin-top: 1em">getopts normally parses the
positional parameters, but if more arguments are given in
args, getopts parses those instead.</p>

<p style="margin-top: 1em">getopts can report errors in two
ways. If the first character of optstring is a colon, silent
error reporting is used. In normal operation diagnostic
messages are <br>
printed when invalid options or missing option arguments are
encountered. If the variable OPTERR is set to 0, no error
messages will be displayed, even if the first char&acirc;
<br>
acter of optstring is not a colon.</p>

<p style="margin-top: 1em">If an invalid option is seen,
getopts places ? into name and, if not silent, prints an
error message and unsets OPTARG. If getopts is silent, the
option character found <br>
is placed in OPTARG and no diagnostic message is
printed.</p>

<p style="margin-top: 1em">If a required argument is not
found, and getopts is not silent, a question mark (?) is
placed in name, OPTARG is unset, and a diagnostic message is
printed. If getopts is <br>
silent, then a colon (:) is placed in name and OPTARG is set
to the option character found.</p>

<p style="margin-top: 1em">getopts returns true if an
option, specified or unspecified, is found. It returns false
if the end of options is encountered or an error occurs.</p>

<p style="margin-top: 1em">hash [-lr] [-p filename] [-dt]
[name] <br>
Each time hash is invoked, the full pathname of the command
name is determined by searching the directories in $PATH and
remembered. Any previously-remembered pathname is <br>
discarded. If the -p option is supplied, no path search is
performed, and filename is used as the full file name of the
command. The -r option causes the shell to forget <br>
all remembered locations. The -d option causes the shell to
forget the remembered location of each name. If the -t
option is supplied, the full pathname to which each <br>
name corresponds is printed. If multiple name arguments are
supplied with -t, the name is printed before the hashed full
pathname. The -l option causes output to be dis&acirc; <br>
played in a format that may be reused as input. If no
arguments are given, or if only -l is supplied, information
about remembered commands is printed. The return status <br>
is true unless a name is not found or an invalid option is
supplied.</p>

<p style="margin-top: 1em">help [-dms] [pattern] <br>
Display helpful information about builtin commands. If
pattern is specified, help gives detailed help on all
commands matching pattern; otherwise help for all the <br>
builtins and shell control structures is printed. <br>
-d Display a short description of each pattern <br>
-m Display the description of each pattern in a manpage-like
format <br>
-s Display only a short usage synopsis for each pattern</p>

<p style="margin-top: 1em">The return status is 0 unless no
command matches pattern.</p>

<p style="margin-top: 1em">history [n] <br>
history -c <br>
history -d offset <br>
history -anrw [filename] <br>
history -p arg [arg ...] <br>
history -s arg [arg ...] <br>
With no options, display the command history list with line
numbers. Lines listed with a * have been modified. An
argument of n lists only the last n lines. If the <br>
shell variable HISTTIMEFORMAT is set and not null, it is
used as a format string for strftime(3) to display the time
stamp associated with each displayed history entry. <br>
No intervening blank is printed between the formatted time
stamp and the history line. If filename is supplied, it is
used as the name of the history file; if not, the <br>
value of HISTFILE is used. Options, if supplied, have the
following meanings: <br>
-c Clear the history list by deleting all the entries. <br>
-d offset <br>
Delete the history entry at position offset. <br>
-a Append the &lsquo;&lsquo;new&rsquo;&rsquo; history lines
(history lines entered since the beginning of the current
bash session) to the history file. <br>
-n Read the history lines not already read from the history
file into the current history list. These are lines appended
to the history file since the beginning of <br>
the current bash session. <br>
-r Read the contents of the history file and use them as the
current history. <br>
-w Write the current history to the history file,
overwriting the history file&rsquo;s contents. <br>
-p Perform history substitution on the following args and
display the result on the standard output. Does not store
the results in the history list. Each arg must be <br>
quoted to disable normal history expansion. <br>
-s Store the args in the history list as a single entry. The
last command in the history list is removed before the args
are added.</p>

<p style="margin-top: 1em">If the HISTTIMEFORMAT variable
is set, the time stamp information associated with each
history entry is written to the history file, marked with
the history comment char&acirc; <br>
acter. When the history file is read, lines beginning with
the history comment character followed immediately by a
digit are interpreted as timestamps for the previous <br>
history line. The return value is 0 unless an invalid option
is encountered, an error occurs while reading or writing the
history file, an invalid offset is supplied as <br>
an argument to -d, or the history expansion supplied as an
argument to -p fails.</p>

<p style="margin-top: 1em">jobs [-lnprs] [ jobspec ... ]
<br>
jobs -x command [ args ... ] <br>
The first form lists the active jobs. The options have the
following meanings: <br>
-l List process IDs in addition to the normal information.
<br>
-n Display information only about jobs that have changed
status since the user was last notified of their status.
<br>
-p List only the process ID of the job&rsquo;s process group
leader. <br>
-r Restrict output to running jobs. <br>
-s Restrict output to stopped jobs.</p>

<p style="margin-top: 1em">If jobspec is given, output is
restricted to information about that job. The return status
is 0 unless an invalid option is encountered or an invalid
jobspec is supplied.</p>

<p style="margin-top: 1em">If the -x option is supplied,
jobs replaces any jobspec found in command or args with the
corresponding process group ID, and executes command passing
it args, returning <br>
its exit status.</p>

<p style="margin-top: 1em">kill [-s sigspec | -n signum |
-sigspec] [pid | jobspec] ... <br>
kill -l [sigspec | exit_status] <br>
Send the signal named by sigspec or signum to the processes
named by pid or jobspec. sigspec is either a
case-insensitive signal name such as SIGKILL (with or
without the <br>
SIG prefix) or a signal number; signum is a signal number.
If sigspec is not present, then SIGTERM is assumed. An
argument of -l lists the signal names. If any argu&acirc;
<br>
ments are supplied when -l is given, the names of the
signals corresponding to the arguments are listed, and the
return status is 0. The exit_status argument to -l is a <br>
number specifying either a signal number or the exit status
of a process terminated by a signal. kill returns true if at
least one signal was successfully sent, or false <br>
if an error occurs or an invalid option is encountered.</p>

<p style="margin-top: 1em">let arg [arg ...] <br>
Each arg is an arithmetic expression to be evaluated (see
ARITHMETIC EVALUATION above). If the last arg evaluates to
0, let returns 1; 0 is returned otherwise.</p>

<p style="margin-top: 1em">local [option] [name[=value]
...] <br>
For each argument, a local variable named name is created,
and assigned value. The option can be any of the options
accepted by declare. When local is used within a <br>
function, it causes the variable name to have a visible
scope restricted to that function and its children. With no
operands, local writes a list of local variables to <br>
the standard output. It is an error to use local when not
within a function. The return status is 0 unless local is
used outside a function, an invalid name is supplied, <br>
or name is a readonly variable.</p>

<p style="margin-top: 1em">logout Exit a login shell.</p>

<p style="margin-top: 1em">mapfile [-n count] [-O origin]
[-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]
<br>
readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C
callback] [-c quantum] [array] <br>
Read lines from the standard input into the indexed array
variable array, or from file descriptor fd if the -u option
is supplied. The variable MAPFILE is the default <br>
array. Options, if supplied, have the following meanings:
<br>
-n Copy at most count lines. If count is 0, all lines are
copied. <br>
-O Begin assigning to array at index origin. The default
index is 0. <br>
-s Discard the first count lines read. <br>
-t Remove a trailing newline from each line read. <br>
-u Read lines from file descriptor fd instead of the
standard input. <br>
-C Evaluate callback each time quantum lines are read. The
-c option specifies quantum. <br>
-c Specify the number of lines read between each call to
callback.</p>

<p style="margin-top: 1em">If -C is specified without -c,
the default quantum is 5000. When callback is evaluated, it
is supplied the index of the next array element to be
assigned and the line to <br>
be assigned to that element as additional arguments.
callback is evaluated after the line is read but before the
array element is assigned.</p>

<p style="margin-top: 1em">If not supplied with an explicit
origin, mapfile will clear array before assigning to it.</p>

<p style="margin-top: 1em">mapfile returns successfully
unless an invalid option or option argument is supplied,
array is invalid or unassignable, or if array is not an
indexed array.</p>

<p style="margin-top: 1em">popd [-n] [+n] [-n] <br>
Removes entries from the directory stack. With no arguments,
removes the top directory from the stack, and performs a cd
to the new top directory. Arguments, if sup&acirc; <br>
plied, have the following meanings: <br>
-n Suppresses the normal change of directory when removing
directories from the stack, so that only the stack is
manipulated. <br>
+n Removes the nth entry counting from the left of the list
shown by dirs, starting with zero. For example:
&lsquo;&lsquo;popd +0&rsquo;&rsquo; removes the first
directory, &lsquo;&lsquo;popd +1&rsquo;&rsquo; the <br>
second. <br>
-n Removes the nth entry counting from the right of the list
shown by dirs, starting with zero. For example:
&lsquo;&lsquo;popd -0&rsquo;&rsquo; removes the last
directory, &lsquo;&lsquo;popd -1&rsquo;&rsquo; the <br>
next to last.</p>

<p style="margin-top: 1em">If the popd command is
successful, a dirs is performed as well, and the return
status is 0. popd returns false if an invalid option is
encountered, the directory stack is <br>
empty, a non-existent directory stack entry is specified, or
the directory change fails.</p>

<p style="margin-top: 1em">printf [-v var] format
[arguments] <br>
Write the formatted arguments to the standard output under
the control of the format. The -v option causes the output
to be assigned to the variable var rather than being <br>
printed to the standard output.</p>

<p style="margin-top: 1em">The format is a character string
which contains three types of objects: plain characters,
which are simply copied to standard output, character escape
sequences, which are <br>
converted and copied to the standard output, and format
specifications, each of which causes printing of the next
successive argument. In addition to the standard <br>
printf(1) format specifications, printf interprets the
following extensions: <br>
%b causes printf to expand backslash escape sequences in the
corresponding argument (except that and octal escapes
beginning with may contain up to four digits). <br>
%q causes printf to output the corresponding argument in a
format that can be reused as shell input. <br>
%(datefmt)T <br>
causes printf to output the date-time string resulting from
using datefmt as a format string for strftime(3). The
corresponding argument is an integer representing <br>
the number of seconds since the epoch. Two special argument
values may be used: -1 represents the current time, and -2
represents the time the shell was invoked.</p>

<p style="margin-top: 1em">Arguments to non-string format
specifiers are treated as C constants, except that a leading
plus or minus sign is allowed, and if the leading character
is a single or dou&acirc; <br>
ble quote, the value is the ASCII value of the following
character.</p>

<p style="margin-top: 1em">The format is reused as
necessary to consume all of the arguments. If the format
requires more arguments than are supplied, the extra format
specifications behave as if a <br>
zero value or null string, as appropriate, had been
supplied. The return value is zero on success, non-zero on
failure.</p>

<p style="margin-top: 1em">pushd [-n] [+n] [-n] <br>
pushd [-n] [dir] <br>
Adds a directory to the top of the directory stack, or
rotates the stack, making the new top of the stack the
current working directory. With no arguments, exchanges the
<br>
top two directories and returns 0, unless the directory
stack is empty. Arguments, if supplied, have the following
meanings: <br>
-n Suppresses the normal change of directory when adding
directories to the stack, so that only the stack is
manipulated. <br>
+n Rotates the stack so that the nth directory (counting
from the left of the list shown by dirs, starting with zero)
is at the top. <br>
-n Rotates the stack so that the nth directory (counting
from the right of the list shown by dirs, starting with
zero) is at the top. <br>
dir Adds dir to the directory stack at the top, making it
the new current working directory.</p>

<p style="margin-top: 1em">If the pushd command is
successful, a dirs is performed as well. If the first form
is used, pushd returns 0 unless the cd to dir fails. With
the second form, pushd <br>
returns 0 unless the directory stack is empty, a
non-existent directory stack element is specified, or the
directory change to the specified new current directory
fails.</p>

<p style="margin-top: 1em">pwd [-LP] <br>
Print the absolute pathname of the current working
directory. The pathname printed contains no symbolic links
if the -P option is supplied or the -o physical option to
<br>
the set builtin command is enabled. If the -L option is
used, the pathname printed may contain symbolic links. The
return status is 0 unless an error occurs while read&acirc;
<br>
ing the name of the current directory or an invalid option
is supplied.</p>

<p style="margin-top: 1em">read [-ers] [-a aname] [-d
delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t
timeout] [-u fd] [name ...] <br>
One line is read from the standard input, or from the file
descriptor fd supplied as an argument to the -u option, and
the first word is assigned to the first name, the <br>
second word to the second name, and so on, with leftover
words and their intervening separators assigned to the last
name. If there are fewer words read from the input <br>
stream than names, the remaining names are assigned empty
values. The characters in IFS are used to split the line
into words. The backslash character ( may be used to <br>
remove any special meaning for the next character read and
for line continuation. Options, if supplied, have the
following meanings: <br>
-a aname <br>
The words are assigned to sequential indices of the array
variable aname, starting at 0. aname is unset before any new
values are assigned. Other name arguments <br>
are ignored. <br>
-d delim <br>
The first character of delim is used to terminate the input
line, rather than newline. <br>
-e If the standard input is coming from a terminal, readline
(see READLINE above) is used to obtain the line. Readline
uses the current (or default, if line editing <br>
was not previously active) editing settings. <br>
-i text <br>
If readline is being used to read the line, text is placed
into the editing buffer before editing begins. <br>
-n nchars <br>
read returns after reading nchars characters rather than
waiting for a complete line of input, but honor a delimiter
if fewer than nchars characters are read before <br>
the delimiter. <br>
-N nchars <br>
read returns after reading exactly nchars characters rather
than waiting for a complete line of input, unless EOF is
encountered or read times out. Delimiter char&acirc; <br>
acters encountered in the input are not treated specially
and do not cause read to return until nchars characters are
read. <br>
-p prompt <br>
Display prompt on standard error, without a trailing
newline, before attempting to read any input. The prompt is
displayed only if input is coming from a terminal. <br>
-r Backslash does not act as an escape character. The
backslash is considered to be part of the line. In
particular, a backslash-newline pair may not be used as a
<br>
line continuation. <br>
-s Silent mode. If input is coming from a terminal,
characters are not echoed. <br>
-t timeout <br>
Cause read to time out and return failure if a complete line
of input is not read within timeout seconds. timeout may be
a decimal number with a fractional portion <br>
following the decimal point. This option is only effective
if read is reading input from a terminal, pipe, or other
special file; it has no effect when reading <br>
from regular files. If timeout is 0, read returns success if
input is available on the specified file descriptor, failure
otherwise. The exit status is greater <br>
than 128 if the timeout is exceeded. <br>
-u fd Read input from file descriptor fd.</p>

<p style="margin-top: 1em">If no names are supplied, the
line read is assigned to the variable REPLY. The return code
is zero, unless end-of-file is encountered, read times out
(in which case the <br>
return code is greater than 128), or an invalid file
descriptor is supplied as the argument to -u.</p>

<p style="margin-top: 1em">readonly [-aAf] [-p]
[name[=word] ...] <br>
The given names are marked readonly; the values of these
names may not be changed by subsequent assignment. If the -f
option is supplied, the functions corresponding to <br>
the names are so marked. The -a option restricts the
variables to indexed arrays; the -A option restricts the
variables to associative arrays. If both options are
sup&acirc; <br>
plied, -A takes precedence. If no name arguments are given,
or if the -p option is supplied, a list of all readonly
names is printed. The other options may be used to <br>
restrict the output to a subset of the set of readonly
names. The -p option causes output to be displayed in a
format that may be reused as input. If a variable name is
<br>
followed by =word, the value of the variable is set to word.
The return status is 0 unless an invalid option is
encountered, one of the names is not a valid shell
vari&acirc; <br>
able name, or -f is supplied with a name that is not a
function.</p>

<p style="margin-top: 1em">return [n] <br>
Causes a function to exit with the return value specified by
n. If n is omitted, the return status is that of the last
command executed in the function body. If used <br>
outside a function, but during execution of a script by the
. (source) command, it causes the shell to stop executing
that script and return either n or the exit status <br>
of the last command executed within the script as the exit
status of the script. If used outside a function and not
during execution of a script by ., the return status <br>
is false. Any command associated with the RETURN trap is
executed before execution resumes after the function or
script.</p>

<p style="margin-top: 1em">set [--abefhkmnptuvxBCEHPT] [-o
option-name] [arg ...] <br>
set [+abefhkmnptuvxBCEHPT] [+o option-name] [arg ...] <br>
Without options, the name and value of each shell variable
are displayed in a format that can be reused as input for
setting or resetting the currently-set variables. <br>
Read-only variables cannot be reset. In posix mode, only
shell variables are listed. The output is sorted according
to the current locale. When options are specified, <br>
they set or unset shell attributes. Any arguments remaining
after option processing are treated as values for the
positional parameters and are assigned, in order, to $1,
<br>
$2, ... $n. Options, if specified, have the following
meanings: <br>
-a Automatically mark variables and functions which are
modified or created for export to the environment of
subsequent commands. <br>
-b Report the status of terminated background jobs
immediately, rather than before the next primary prompt.
This is effective only when job control is enabled. <br>
-e Exit immediately if a pipeline (which may consist of a
single simple command), a subshell command enclosed in
parentheses, or one of the commands executed as part <br>
of a command list enclosed by braces (see SHELL GRAMMAR
above) exits with a non-zero status. The shell does not exit
if the command that fails is part of the com&acirc; <br>
mand list immediately following a while or until keyword,
part of the test following the if or elif reserved words,
part of any command executed in a &amp;&amp; or || list <br>
except the command following the final &amp;&amp; or ||, any
command in a pipeline but the last, or if the
command&rsquo;s return value is being inverted with !. A
trap on ERR, <br>
if set, is executed before the shell exits. This option
applies to the shell environment and each subshell
environment separately (see COMMAND EXECUTION ENVIRON&acirc;
<br>
MENT above), and may cause subshells to exit before
executing all the commands in the subshell. <br>
-f Disable pathname expansion. <br>
-h Remember the location of commands as they are looked up
for execution. This is enabled by default. <br>
-k All arguments in the form of assignment statements are
placed in the environment for a command, not just those that
precede the command name. <br>
-m Monitor mode. Job control is enabled. This option is on
by default for interactive shells on systems that support it
(see JOB CONTROL above). Background pro&acirc; <br>
cesses run in a separate process group and a line containing
their exit status is printed upon their completion. <br>
-n Read commands but do not execute them. This may be used
to check a shell script for syntax errors. This is ignored
by interactive shells. <br>
-o option-name <br>
The option-name can be one of the following: <br>
allexport <br>
Same as -a. <br>
braceexpand <br>
Same as -B. <br>
emacs Use an emacs-style command line editing interface.
This is enabled by default when the shell is interactive,
unless the shell is started with the <br>
--noediting option. This also affects the editing interface
used for read -e. <br>
errexit Same as -e. <br>
errtrace <br>
Same as -E. <br>
functrace <br>
Same as -T. <br>
hashall Same as -h. <br>
histexpand <br>
Same as -H. <br>
history Enable command history, as described above under
HISTORY. This option is on by default in interactive shells.
<br>
ignoreeof <br>
The effect is as if the shell command
&lsquo;&lsquo;IGNOREEOF=10&rsquo;&rsquo; had been executed
(see Shell Variables above). <br>
keyword Same as -k. <br>
monitor Same as -m. <br>
noclobber <br>
Same as -C. <br>
noexec Same as -n. <br>
noglob Same as -f. <br>
nolog Currently ignored. <br>
notify Same as -b. <br>
nounset Same as -u. <br>
onecmd Same as -t. <br>
physical <br>
Same as -P. <br>
pipefail <br>
If set, the return value of a pipeline is the value of the
last (rightmost) command to exit with a non-zero status, or
zero if all commands in the pipeline <br>
exit successfully. This option is disabled by default. <br>
posix Change the behavior of bash where the default
operation differs from the POSIX standard to match the
standard (posix mode). <br>
privileged <br>
Same as -p. <br>
verbose Same as -v. <br>
vi Use a vi-style command line editing interface. This also
affects the editing interface used for read -e. <br>
xtrace Same as -x. <br>
If -o is supplied with no option-name, the values of the
current options are printed. If +o is supplied with no
option-name, a series of set commands to recreate <br>
the current option settings is displayed on the standard
output. <br>
-p Turn on privileged mode. In this mode, the $ENV and
$BASH_ENV files are not processed, shell functions are not
inherited from the environment, and the SHELLOPTS, <br>
BASHOPTS, CDPATH, and GLOBIGNORE variables, if they appear
in the environment, are ignored. If the shell is started
with the effective user (group) id not equal <br>
to the real user (group) id, and the -p option is not
supplied, these actions are taken and the effective user id
is set to the real user id. If the -p option is <br>
supplied at startup, the effective user id is not reset.
Turning this option off causes the effective user and group
ids to be set to the real user and group ids. <br>
-t Exit after reading and executing one command. <br>
-u Treat unset variables and parameters other than the
special parameters &quot;@&quot; and &quot;*&quot; as an
error when performing parameter expansion. If expansion is
attempted on <br>
an unset variable or parameter, the shell prints an error
message, and, if not interactive, exits with a non-zero
status. <br>
-v Print shell input lines as they are read. <br>
-x After expanding each simple command, for command, case
command, select command, or arithmetic for command, display
the expanded value of PS4, followed by the com&acirc; <br>
mand and its expanded arguments or associated word list.
<br>
-B The shell performs brace expansion (see Brace Expansion
above). This is on by default. <br>
-C If set, bash does not overwrite an existing file with the
&gt;, &gt;&amp;, and &lt;&gt; redirection operators. This
may be overridden when creating output files by using the
re&acirc; <br>
direction operator &gt;| instead of &gt;. <br>
-E If set, any trap on ERR is inherited by shell functions,
command substitutions, and commands executed in a subshell
environment. The ERR trap is normally not <br>
inherited in such cases. <br>
-H Enable ! style history substitution. This option is on by
default when the shell is interactive. <br>
-P If set, the shell does not follow symbolic links when
executing commands such as cd that change the current
working directory. It uses the physical directory <br>
structure instead. By default, bash follows the logical
chain of directories when performing commands which change
the current directory. <br>
-T If set, any traps on DEBUG and RETURN are inherited by
shell functions, command substitutions, and commands
executed in a subshell environment. The DEBUG and <br>
RETURN traps are normally not inherited in such cases. <br>
-- If no arguments follow this option, then the positional
parameters are unset. Otherwise, the positional parameters
are set to the args, even if some of them begin <br>
with a -. <br>
- Signal the end of options, cause all remaining args to be
assigned to the positional parameters. The -x and -v options
are turned off. If there are no args, the <br>
positional parameters remain unchanged.</p>

<p style="margin-top: 1em">The options are off by default
unless otherwise noted. Using + rather than - causes these
options to be turned off. The options can also be specified
as arguments to an <br>
invocation of the shell. The current set of options may be
found in $-. The return status is always true unless an
invalid option is encountered.</p>

<p style="margin-top: 1em">shift [n] <br>
The positional parameters from n+1 ... are renamed to $1
.... Parameters represented by the numbers $# down to $#-n+1
are unset. n must be a non-negative number less <br>
than or equal to $#. If n is 0, no parameters are changed.
If n is not given, it is assumed to be 1. If n is greater
than $#, the positional parameters are not changed. <br>
The return status is greater than zero if n is greater than
$# or less than zero; otherwise 0.</p>

<p style="margin-top: 1em">shopt [-pqsu] [-o] [optname ...]
<br>
Toggle the values of variables controlling optional shell
behavior. With no options, or with the -p option, a list of
all settable options is displayed, with an indica&acirc;
<br>
tion of whether or not each is set. The -p option causes
output to be displayed in a form that may be reused as
input. Other options have the following meanings: <br>
-s Enable (set) each optname. <br>
-u Disable (unset) each optname. <br>
-q Suppresses normal output (quiet mode); the return status
indicates whether the optname is set or unset. If multiple
optname arguments are given with -q, the return <br>
status is zero if all optnames are enabled; non-zero
otherwise. <br>
-o Restricts the values of optname to be those defined for
the -o option to the set builtin.</p>

<p style="margin-top: 1em">If either -s or -u is used with
no optname arguments, the display is limited to those
options which are set or unset, respectively. Unless
otherwise noted, the shopt <br>
options are disabled (unset) by default.</p>

<p style="margin-top: 1em">The return status when listing
options is zero if all optnames are enabled, non-zero
otherwise. When setting or unsetting options, the return
status is zero unless an <br>
optname is not a valid shell option.</p>

<p style="margin-top: 1em">The list of shopt options
is:</p>

<p style="margin-top: 1em">autocd If set, a command name
that is the name of a directory is executed as if it were
the argument to the cd command. This option is only used by
interactive shells. <br>
cdable_vars <br>
If set, an argument to the cd builtin command that is not a
directory is assumed to be the name of a variable whose
value is the directory to change to. <br>
cdspell If set, minor errors in the spelling of a directory
component in a cd command will be corrected. The errors
checked for are transposed characters, a missing char&acirc;
<br>
acter, and one character too many. If a correction is found,
the corrected file name is printed, and the command
proceeds. This option is only used by interac&acirc; <br>
tive shells. <br>
checkhash <br>
If set, bash checks that a command found in the hash table
exists before trying to execute it. If a hashed command no
longer exists, a normal path search is per&acirc; <br>
formed. <br>
checkjobs <br>
If set, bash lists the status of any stopped and running
jobs before exiting an interactive shell. If any jobs are
running, this causes the exit to be deferred <br>
until a second exit is attempted without an intervening
command (see JOB CONTROL above). The shell always postpones
exiting if any jobs are stopped. <br>
checkwinsize <br>
If set, bash checks the window size after each command and,
if necessary, updates the values of LINES and COLUMNS. <br>
cmdhist If set, bash attempts to save all lines of a
multiple-line command in the same history entry. This allows
easy re-editing of multi-line commands. <br>
compat31 <br>
If set, bash changes its behavior to that of version 3.1
with respect to quoted arguments to the [[ conditional
command&rsquo;s =~ operator. <br>
compat32 <br>
If set, bash changes its behavior to that of version 3.2
with respect to locale-specific string comparison when using
the [[ conditional command&rsquo;s &lt; and &gt;
opera&acirc; <br>
tors. Bash versions prior to bash-4.1 use ASCII collation
and strcmp(3); bash-4.1 and later use the current
locale&rsquo;s collation sequence and strcoll(3). <br>
compat40 <br>
If set, bash changes its behavior to that of version 4.0
with respect to locale-specific string comparison when using
the [[ conditional command&rsquo;s &lt; and &gt;
opera&acirc; <br>
tors (see previous item) and the effect of interrupting a
command list. <br>
compat41 <br>
If set, bash, when in posix mode, treats a single quote in a
double-quoted parameter expansion as a special character.
The single quotes must match (an even num&acirc; <br>
ber) and the characters between the single quotes are
considered quoted. This is the behavior of posix mode
through version 4.1. The default bash behavior <br>
remains as in previous versions. <br>
direxpand <br>
If set, bash replaces directory names with the results of
word expansion when performing filename completion. This
changes the contents of the readline editing <br>
buffer. If not set, bash attempts to preserve what the user
typed. <br>
dirspell <br>
If set, bash attempts spelling correction on directory names
during word completion if the directory name initially
supplied does not exist. <br>
dotglob If set, bash includes filenames beginning with a
&lsquo;.&rsquo; in the results of pathname expansion. <br>
execfail <br>
If set, a non-interactive shell will not exit if it cannot
execute the file specified as an argument to the exec
builtin command. An interactive shell does not <br>
exit if exec fails. <br>
expand_aliases <br>
If set, aliases are expanded as described above under
ALIASES. This option is enabled by default for interactive
shells. <br>
extdebug <br>
If set, behavior intended for use by debuggers is enabled:
<br>
1. The -F option to the declare builtin displays the source
file name and line number corresponding to each function
name supplied as an argument. <br>
2. If the command run by the DEBUG trap returns a non-zero
value, the next command is skipped and not executed. <br>
3. If the command run by the DEBUG trap returns a value of
2, and the shell is executing in a subroutine (a shell
function or a shell script executed by the . <br>
or source builtins), a call to return is simulated. <br>
4. BASH_ARGC and BASH_ARGV are updated as described in their
descriptions above. <br>
5. Function tracing is enabled: command substitution, shell
functions, and subshells invoked with ( command ) inherit
the DEBUG and RETURN traps. <br>
6. Error tracing is enabled: command substitution, shell
functions, and subshells invoked with ( command ) inherit
the ERR trap. <br>
extglob If set, the extended pattern matching features
described above under Pathname Expansion are enabled. <br>
extquote <br>
If set, $&rsquo;string&rsquo; and $&quot;string&quot;
quoting is performed within ${parameter} expansions enclosed
in double quotes. This option is enabled by default. <br>
failglob <br>
If set, patterns which fail to match filenames during
pathname expansion result in an expansion error. <br>
force_fignore <br>
If set, the suffixes specified by the FIGNORE shell variable
cause words to be ignored when performing word completion
even if the ignored words are the only pos&acirc; <br>
sible completions. See SHELL VARIABLES above for a
description of FIGNORE. This option is enabled by default.
<br>
globstar <br>
If set, the pattern ** used in a pathname expansion context
will match all files and zero or more directories and
subdirectories. If the pattern is followed by a <br>
/, only directories and subdirectories match. <br>
gnu_errfmt <br>
If set, shell error messages are written in the standard GNU
error message format. <br>
histappend <br>
If set, the history list is appended to the file named by
the value of the HISTFILE variable when the shell exits,
rather than overwriting the file. <br>
histreedit <br>
If set, and readline is being used, a user is given the
opportunity to re-edit a failed history substitution. <br>
histverify <br>
If set, and readline is being used, the results of history
substitution are not immediately passed to the shell parser.
Instead, the resulting line is loaded into <br>
the readline editing buffer, allowing further modification.
<br>
hostcomplete <br>
If set, and readline is being used, bash will attempt to
perform hostname completion when a word containing a @ is
being completed (see Completing under READLINE <br>
above). This is enabled by default. <br>
huponexit <br>
If set, bash will send SIGHUP to all jobs when an
interactive login shell exits. <br>
interactive_comments <br>
If set, allow a word beginning with # to cause that word and
all remaining characters on that line to be ignored in an
interactive shell (see COMMENTS above). <br>
This option is enabled by default. <br>
lastpipe <br>
If set, and job control is not active, the shell runs the
last command of a pipeline not executed in the background in
the current shell environment. <br>
lithist If set, and the cmdhist option is enabled,
multi-line commands are saved to the history with embedded
newlines rather than using semicolon separators where
possi&acirc; <br>
ble. <br>
login_shell <br>
The shell sets this option if it is started as a login shell
(see INVOCATION above). The value may not be changed. <br>
mailwarn <br>
If set, and a file that bash is checking for mail has been
accessed since the last time it was checked, the message
&lsquo;&lsquo;The mail in mailfile has been
read&rsquo;&rsquo; is dis&acirc; <br>
played. <br>
no_empty_cmd_completion <br>
If set, and readline is being used, bash will not attempt to
search the PATH for possible completions when completion is
attempted on an empty line. <br>
nocaseglob <br>
If set, bash matches filenames in a case-insensitive fashion
when performing pathname expansion (see Pathname Expansion
above). <br>
nocasematch <br>
If set, bash matches patterns in a case-insensitive fashion
when performing matching while executing case or [[
conditional commands. <br>
nullglob <br>
If set, bash allows patterns which match no files (see
Pathname Expansion above) to expand to a null string, rather
than themselves. <br>
progcomp <br>
If set, the programmable completion facilities (see
Programmable Completion above) are enabled. This option is
enabled by default. <br>
promptvars <br>
If set, prompt strings undergo parameter expansion, command
substitution, arithmetic expansion, and quote removal after
being expanded as described in PROMPTING <br>
above. This option is enabled by default. <br>
restricted_shell <br>
The shell sets this option if it is started in restricted
mode (see RESTRICTED SHELL below). The value may not be
changed. This is not reset when the startup <br>
files are executed, allowing the startup files to discover
whether or not a shell is restricted. <br>
shift_verbose <br>
If set, the shift builtin prints an error message when the
shift count exceeds the number of positional parameters.
<br>
sourcepath <br>
If set, the source (.) builtin uses the value of PATH to
find the directory containing the file supplied as an
argument. This option is enabled by default. <br>
xpg_echo <br>
If set, the echo builtin expands backslash-escape sequences
by default.</p>

<p style="margin-top: 1em">suspend [-f] <br>
Suspend the execution of this shell until it receives a
SIGCONT signal. When the suspended shell is a background
process, it can be restarted by the fg command. For more
<br>
information, read the JOB CONTROL section. The suspend
command can not suspend the login shell. However, when -f
option is specified, suspend command can suspend even <br>
login shell. The return status is 0 unless the shell is a
login shell and -f is not supplied, or if job control is not
enabled.</p>

<p style="margin-top: 1em">test expr <br>
[ expr ] <br>
Return a status of 0 or 1 depending on the evaluation of the
conditional expression expr. Each operator and operand must
be a separate argument. Expressions are composed <br>
of the primaries described above under CONDITIONAL
EXPRESSIONS. test does not accept any options, nor does it
accept and ignore an argument of -- as signifying the end of
<br>
options.</p>

<p style="margin-top: 1em">Expressions may be combined
using the following operators, listed in decreasing order of
precedence. The evaluation depends on the number of
arguments; see below. Opera&acirc; <br>
tor precedence is used when there are five or more
arguments. <br>
! expr True if expr is false. <br>
( expr ) <br>
Returns the value of expr. This may be used to override the
normal precedence of operators. <br>
expr1 -a expr2 <br>
True if both expr1 and expr2 are true. <br>
expr1 -o expr2 <br>
True if either expr1 or expr2 is true.</p>

<p style="margin-top: 1em">test and [ evaluate conditional
expressions using a set of rules based on the number of
arguments.</p>

<p style="margin-top: 1em">0 arguments <br>
The expression is false. <br>
1 argument <br>
The expression is true if and only if the argument is not
null. <br>
2 arguments <br>
If the first argument is !, the expression is true if and
only if the second argument is null. If the first argument
is one of the unary conditional operators <br>
listed above under CONDITIONAL EXPRESSIONS, the expression
is true if the unary test is true. If the first argument is
not a valid unary conditional operator, the <br>
expression is false. <br>
3 arguments <br>
The following conditions are applied in the order listed. If
the second argument is one of the binary conditional
operators listed above under CONDITIONAL EXPRES&acirc; <br>
SIONS, the result of the expression is the result of the
binary test using the first and third arguments as operands.
The -a and -o operators are considered binary <br>
operators when there are three arguments. If the first
argument is !, the value is the negation of the two-argument
test using the second and third arguments. If <br>
the first argument is exactly ( and the third argument is
exactly ), the result is the one-argument test of the second
argument. Otherwise, the expression is <br>
false. <br>
4 arguments <br>
If the first argument is !, the result is the negation of
the three-argument expression composed of the remaining
arguments. Otherwise, the expression is parsed <br>
and evaluated according to precedence using the rules listed
above. <br>
5 or more arguments <br>
The expression is parsed and evaluated according to
precedence using the rules listed above.</p>

<p style="margin-top: 1em">When used with test or [, the
&lt; and &gt; operators sort lexicographically using ASCII
ordering.</p>

<p style="margin-top: 1em">times Print the accumulated user
and system times for the shell and for processes run from
the shell. The return status is 0.</p>

<p style="margin-top: 1em">trap [-lp] [[arg] sigspec ...]
<br>
The command arg is to be read and executed when the shell
receives signal(s) sigspec. If arg is absent (and there is a
single sigspec) or -, each specified signal is <br>
reset to its original disposition (the value it had upon
entrance to the shell). If arg is the null string the signal
specified by each sigspec is ignored by the shell <br>
and by the commands it invokes. If arg is not present and -p
has been supplied, then the trap commands associated with
each sigspec are displayed. If no arguments are <br>
supplied or if only -p is given, trap prints the list of
commands associated with each signal. The -l option causes
the shell to print a list of signal names and their <br>
corresponding numbers. Each sigspec is either a signal name
defined in &lt;signal.h&gt;, or a signal number. Signal
names are case insensitive and the SIG prefix is
optional.</p>

<p style="margin-top: 1em">If a sigspec is EXIT (0) the
command arg is executed on exit from the shell. If a sigspec
is DEBUG, the command arg is executed before every simple
command, for command, <br>
case command, select command, every arithmetic for command,
and before the first command executes in a shell function
(see SHELL GRAMMAR above). Refer to the description <br>
of the extdebug option to the shopt builtin for details of
its effect on the DEBUG trap. If a sigspec is RETURN, the
command arg is executed each time a shell function or <br>
a script executed with the . or source builtins finishes
executing.</p>

<p style="margin-top: 1em">If a sigspec is ERR, the command
arg is executed whenever a simple command has a non-zero
exit status, subject to the following conditions. The ERR
trap is not executed <br>
if the failed command is part of the command list
immediately following a while or until keyword, part of the
test in an if statement, part of a command executed in a
&amp;&amp; <br>
or || list, or if the command&rsquo;s return value is being
inverted via !. These are the same conditions obeyed by the
errexit option.</p>

<p style="margin-top: 1em">Signals ignored upon entry to
the shell cannot be trapped, reset or listed. Trapped
signals that are not being ignored are reset to their
original values in a subshell or <br>
subshell environment when one is created. The return status
is false if any sigspec is invalid; otherwise trap returns
true.</p>

<p style="margin-top: 1em">type [-aftpP] name [name ...]
<br>
With no options, indicate how each name would be interpreted
if used as a command name. If the -t option is used, type
prints a string which is one of alias, keyword, <br>
function, builtin, or file if name is an alias, shell
reserved word, function, builtin, or disk file,
respectively. If the name is not found, then nothing is
printed, and <br>
an exit status of false is returned. If the -p option is
used, type either returns the name of the disk file that
would be executed if name were specified as a command <br>
name, or nothing if &lsquo;&lsquo;type -t name&rsquo;&rsquo;
would not return file. The -P option forces a PATH search
for each name, even if &lsquo;&lsquo;type -t
name&rsquo;&rsquo; would not return file. If a com&acirc;
<br>
mand is hashed, -p and -P print the hashed value, not
necessarily the file that appears first in PATH. If the -a
option is used, type prints all of the places that
con&acirc; <br>
tain an executable named name. This includes aliases and
functions, if and only if the -p option is not also used.
The table of hashed commands is not consulted when <br>
using -a. The -f option suppresses shell function lookup, as
with the command builtin. type returns true if all of the
arguments are found, false if any are not found.</p>

<p style="margin-top: 1em">ulimit [-HSTabcdefilmnpqrstuvx
[limit]] <br>
Provides control over the resources available to the shell
and to processes started by it, on systems that allow such
control. The -H and -S options specify that the hard <br>
or soft limit is set for the given resource. A hard limit
cannot be increased by a non-root user once it is set; a
soft limit may be increased up to the value of the hard <br>
limit. If neither -H nor -S is specified, both the soft and
hard limits are set. The value of limit can be a number in
the unit specified for the resource or one of the <br>
special values hard, soft, or unlimited, which stand for the
current hard limit, the current soft limit, and no limit,
respectively. If limit is omitted, the current <br>
value of the soft limit of the resource is printed, unless
the -H option is given. When more than one resource is
specified, the limit name and unit are printed before <br>
the value. Other options are interpreted as follows: <br>
-a All current limits are reported <br>
-b The maximum socket buffer size <br>
-c The maximum size of core files created <br>
-d The maximum size of a process&rsquo;s data segment <br>
-e The maximum scheduling priority (&quot;nice&quot;) <br>
-f The maximum size of files written by the shell and its
children <br>
-i The maximum number of pending signals <br>
-l The maximum size that may be locked into memory <br>
-m The maximum resident set size (many systems do not honor
this limit) <br>
-n The maximum number of open file descriptors (most systems
do not allow this value to be set) <br>
-p The pipe size in 512-byte blocks (this may not be set)
<br>
-q The maximum number of bytes in POSIX message queues <br>
-r The maximum real-time scheduling priority <br>
-s The maximum stack size <br>
-t The maximum amount of cpu time in seconds <br>
-u The maximum number of processes available to a single
user <br>
-v The maximum amount of virtual memory available to the
shell and, on some systems, to its children <br>
-x The maximum number of file locks <br>
-T The maximum number of threads</p>

<p style="margin-top: 1em">If limit is given, it is the new
value of the specified resource (the -a option is display
only). If no option is given, then -f is assumed. Values are
in 1024-byte <br>
increments, except for -t, which is in seconds, -p, which is
in units of 512-byte blocks, and -T, -b, -n, and -u, which
are unscaled values. The return status is 0 unless <br>
an invalid option or argument is supplied, or an error
occurs while setting a new limit. In POSIX Mode 512-byte
blocks are used for the &lsquo;-c&rsquo; and
&lsquo;-f&rsquo; options.</p>

<p style="margin-top: 1em">umask [-p] [-S] [mode] <br>
The user file-creation mask is set to mode. If mode begins
with a digit, it is interpreted as an octal number;
otherwise it is interpreted as a symbolic mode mask similar
<br>
to that accepted by chmod(1). If mode is omitted, the
current value of the mask is printed. The -S option causes
the mask to be printed in symbolic form; the default <br>
output is an octal number. If the -p option is supplied, and
mode is omitted, the output is in a form that may be reused
as input. The return status is 0 if the mode was <br>
successfully changed or if no mode argument was supplied,
and false otherwise.</p>

<p style="margin-top: 1em">unalias [-a] [name ...] <br>
Remove each name from the list of defined aliases. If -a is
supplied, all alias definitions are removed. The return
value is true unless a supplied name is not a defined <br>
alias.</p>

<p style="margin-top: 1em">unset [-fv] [name ...] <br>
For each name, remove the corresponding variable or
function. If no options are supplied, or the -v option is
given, each name refers to a shell variable. Read-only <br>
variables may not be unset. If -f is specified, each name
refers to a shell function, and the function definition is
removed. Each unset variable or function is removed <br>
from the environment passed to subsequent commands. If any
of COMP_WORDBREAKS, RANDOM, SECONDS, LINENO, HISTCMD,
FUNCNAME, GROUPS, or DIRSTACK are unset, they lose their
<br>
special properties, even if they are subsequently reset. The
exit status is true unless a name is readonly.</p>

<p style="margin-top: 1em">wait [n ...] <br>
Wait for each specified process and return its termination
status. Each n may be a process ID or a job specification;
if a job spec is given, all processes in that job&rsquo;s
<br>
pipeline are waited for. If n is not given, all currently
active child processes are waited for, and the return status
is zero. If n specifies a non-existent process or <br>
job, the return status is 127. Otherwise, the return status
is the exit status of the last process or job waited
for.</p>

<p style="margin-top: 1em">RESTRICTED SHELL <br>
If bash is started with the name rbash, or the -r option is
supplied at invocation, the shell becomes restricted. A
restricted shell is used to set up an environment more
con&acirc; <br>
trolled than the standard shell. It behaves identically to
bash with the exception that the following are disallowed or
not performed:</p>

<p style="margin-top: 1em">&Acirc;&middot; changing
directories with cd</p>

<p style="margin-top: 1em">&Acirc;&middot; setting or
unsetting the values of SHELL, PATH, ENV, or BASH_ENV</p>

<p style="margin-top: 1em">&Acirc;&middot; specifying
command names containing /</p>

<p style="margin-top: 1em">&Acirc;&middot; specifying a
file name containing a / as an argument to the . builtin
command</p>

<p style="margin-top: 1em">&Acirc;&middot; specifying a
filename containing a slash as an argument to the -p option
to the hash builtin command</p>

<p style="margin-top: 1em">&Acirc;&middot; importing
function definitions from the shell environment at
startup</p>

<p style="margin-top: 1em">&Acirc;&middot; parsing the
value of SHELLOPTS from the shell environment at startup</p>

<p style="margin-top: 1em">&Acirc;&middot; redirecting
output using the &gt;, &gt;|, &lt;&gt;, &gt;&amp;,
&amp;&gt;, and &gt;&gt; redirection operators</p>

<p style="margin-top: 1em">&Acirc;&middot; using the exec
builtin command to replace the shell with another
command</p>

<p style="margin-top: 1em">&Acirc;&middot; adding or
deleting builtin commands with the -f and -d options to the
enable builtin command</p>

<p style="margin-top: 1em">&Acirc;&middot; using the enable
builtin command to enable disabled shell builtins</p>

<p style="margin-top: 1em">&Acirc;&middot; specifying the
-p option to the command builtin command</p>

<p style="margin-top: 1em">&Acirc;&middot; turning off
restricted mode with set +r or set +o restricted.</p>

<p style="margin-top: 1em">These restrictions are enforced
after any startup files are read.</p>

<p style="margin-top: 1em">When a command that is found to
be a shell script is executed (see COMMAND EXECUTION above),
rbash turns off any restrictions in the shell spawned to
execute the script.</p>

<p style="margin-top: 1em">SEE ALSO <br>
Bash Reference Manual, Brian Fox and Chet Ramey <br>
The Gnu Readline Library, Brian Fox and Chet Ramey <br>
The Gnu History Library, Brian Fox and Chet Ramey <br>
Portable Operating System Interface (POSIX) Part 2: Shell
and Utilities, IEEE <br>
sh(1), ksh(1), csh(1) <br>
emacs(1), vi(1) <br>
readline(3)</p>

<p style="margin-top: 1em">FILES <br>
/bin/bash <br>
The bash executable <br>
/etc/profile <br>
The systemwide initialization file, executed for login
shells <br>
/etc/bash.bash_logout <br>
The systemwide login shell cleanup file, executed when a
login shell exits <br>
~/.bash_profile <br>
The personal initialization file, executed for login shells
<br>
~/.bashrc <br>
The individual per-interactive-shell startup file <br>
~/.bash_logout <br>
The individual login shell cleanup file, executed when a
login shell exits <br>
~/.inputrc <br>
Individual readline initialization file</p>

<p style="margin-top: 1em">AUTHORS <br>
Brian Fox, Free Software Foundation <br>
bfox@gnu.org</p>

<p style="margin-top: 1em">Chet Ramey, Case Western Reserve
University <br>
chet.ramey@case.edu</p>

<p style="margin-top: 1em">BUG REPORTS <br>
If you find a bug in bash, you should report it. But first,
you should make sure that it really is a bug, and that it
appears in the latest version of bash. The latest version
<br>
is always available from
ftp://ftp.gnu.org/pub/gnu/bash/.</p>

<p style="margin-top: 1em">Once you have determined that a
bug actually exists, use the bashbug command (from the
source package) to submit a bug report. If you have a fix,
you are encouraged to mail that <br>
as well! Suggestions and &lsquo;philosophical&rsquo; bug
reports may be mailed to bug-bash@gnu.org or posted to the
Usenet newsgroup gnu.bash.bug.</p>

<p style="margin-top: 1em">ALL bug reports should
include:</p>

<p style="margin-top: 1em">The version number of bash <br>
The hardware and operating system <br>
The compiler used to compile <br>
A description of the bug behaviour <br>
A short script or &lsquo;recipe&rsquo; which exercises the
bug</p>

<p style="margin-top: 1em">Comments and bug reports
concerning this manual page should be directed to
chet.ramey@case.edu.</p>

<p style="margin-top: 1em">BUGS <br>
It&rsquo;s too big and too slow.</p>

<p style="margin-top: 1em">There are some subtle
differences between bash and traditional versions of sh,
mostly because of the POSIX specification.</p>

<p style="margin-top: 1em">Aliases are confusing in some
uses.</p>

<p style="margin-top: 1em">Shell builtin commands and
functions are not stoppable/restartable.</p>

<p style="margin-top: 1em">Compound commands and command
sequences of the form &lsquo;a ; b ; c&rsquo; are not
handled gracefully when process suspension is attempted.
When a process is stopped, the shell immediately <br>
executes the next command in the sequence. It suffices to
place the sequence of commands between parentheses to force
it into a subshell, which may be stopped as a unit.</p>

<p style="margin-top: 1em">Array variables may not (yet) be
exported.</p>

<p style="margin-top: 1em">There may be only one active
coprocess at a time.</p>

<p style="margin-top: 1em">GNU Bash-4.2 2010 December 28
BASH(1)</p>
<hr>
</body>
</html>
