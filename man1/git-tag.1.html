<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:13:42 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GIT-TAG(1) Git Manual GIT-TAG(1)</p>

<p style="margin-top: 1em">NAME <br>
git-tag - Create, list, delete or verify a tag object signed
with GPG</p>

<p style="margin-top: 1em">SYNOPSIS <br>
git tag [-a | -s | -u &lt;key-id&gt;] [-f] [-m &lt;msg&gt; |
-F &lt;file&gt;] <br>
&lt;tagname&gt; [&lt;commit&gt; | &lt;object&gt;] <br>
git tag -d &lt;tagname&gt;... <br>
git tag [-n[&lt;num&gt;]] -l [--contains &lt;commit&gt;]
[--points-at &lt;object&gt;] <br>
[--column[=&lt;options&gt;] | --no-column]
[&lt;pattern&gt;...] <br>
[&lt;pattern&gt;...] <br>
git tag -v &lt;tagname&gt;...</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Add a tag reference in refs/tags/, unless -d/-l/-v is given
to delete, list or verify tags.</p>

<p style="margin-top: 1em">Unless -f is given, the named
tag must not yet exist.</p>

<p style="margin-top: 1em">If one of -a, -s, or -u
&lt;key-id&gt; is passed, the command creates a tag object,
and requires a tag message. Unless -m &lt;msg&gt; or -F
&lt;file&gt; is given, an editor is started for the user
<br>
to type in the tag message.</p>

<p style="margin-top: 1em">If -m &lt;msg&gt; or -F
&lt;file&gt; is given and -a, -s, and -u &lt;key-id&gt; are
absent, -a is implied.</p>

<p style="margin-top: 1em">Otherwise just a tag reference
for the SHA-1 object name of the commit object is created
(i.e. a lightweight tag).</p>

<p style="margin-top: 1em">A GnuPG signed tag object will
be created when -s or -u &lt;key-id&gt; is used. When -u
&lt;key-id&gt; is not used, the committer identity for the
current user is used to find the GnuPG key <br>
for signing. The configuration variable gpg.program is used
to specify custom GnuPG binary.</p>

<p style="margin-top: 1em">OPTIONS <br>
-a, --annotate <br>
Make an unsigned, annotated tag object</p>

<p style="margin-top: 1em">-s, --sign <br>
Make a GPG-signed tag, using the default e-mail
address&acirc;s key.</p>

<p style="margin-top: 1em">-u &lt;key-id&gt;,
--local-user=&lt;key-id&gt; <br>
Make a GPG-signed tag, using the given key.</p>

<p style="margin-top: 1em">-f, --force <br>
Replace an existing tag with the given name (instead of
failing)</p>

<p style="margin-top: 1em">-d, --delete <br>
Delete existing tags with the given names.</p>

<p style="margin-top: 1em">-v, --verify <br>
Verify the gpg signature of the given tag names.</p>

<p style="margin-top: 1em">-n&lt;num&gt; <br>
&lt;num&gt; specifies how many lines from the annotation, if
any, are printed when using -l. The default is not to print
any annotation lines. If no number is given to -n, only the
<br>
first line is printed. If the tag is not annotated, the
commit message is displayed instead.</p>

<p style="margin-top: 1em">-l &lt;pattern&gt;, --list
&lt;pattern&gt; <br>
List tags with names that match the given pattern (or all if
no pattern is given). Running &quot;git tag&quot; without
arguments also lists all tags. The pattern is a shell
wildcard <br>
(i.e., matched using fnmatch(3)). Multiple patterns may be
given; if any of them matches, the tag is shown.</p>

<p style="margin-top: 1em">--column[=&lt;options&gt;],
--no-column <br>
Display tag listing in columns. See configuration variable
column.tag for option syntax.--column and --no-column
without options are equivalent to always and never <br>
respectively.</p>

<p style="margin-top: 1em">This option is only applicable
when listing tags without annotation lines.</p>

<p style="margin-top: 1em">--contains &lt;commit&gt; <br>
Only list tags which contain the specified commit.</p>

<p style="margin-top: 1em">--points-at &lt;object&gt; <br>
Only list tags of the given object.</p>

<p style="margin-top: 1em">-m &lt;msg&gt;,
--message=&lt;msg&gt; <br>
Use the given tag message (instead of prompting). If
multiple -m options are given, their values are concatenated
as separate paragraphs. Implies -a if none of -a, -s, or -u
<br>
&lt;key-id&gt; is given.</p>

<p style="margin-top: 1em">-F &lt;file&gt;,
--file=&lt;file&gt; <br>
Take the tag message from the given file. Use - to read the
message from the standard input. Implies -a if none of -a,
-s, or -u &lt;key-id&gt; is given.</p>

<p style="margin-top: 1em">--cleanup=&lt;mode&gt; <br>
This option sets how the tag message is cleaned up. The
&lt;mode&gt; can be one of verbatim, whitespace and strip.
The strip mode is default. The verbatim mode does not change
<br>
message at all, whitespace removes just leading/trailing
whitespace lines and strip removes both whitespace and
commentary.</p>

<p style="margin-top: 1em">&lt;tagname&gt; <br>
The name of the tag to create, delete, or describe. The new
tag name must pass all checks defined by
git-check-ref-format(1). Some of these checks may restrict
the characters <br>
allowed in a tag name.</p>

<p style="margin-top: 1em">&lt;commit&gt;, &lt;object&gt;
<br>
The object that the new tag will refer to, usually a commit.
Defaults to HEAD.</p>

<p style="margin-top: 1em">CONFIGURATION <br>
By default, git tag in sign-with-default mode (-s) will use
your committer identity (of the form &quot;Your Name
&lt;your@email.address&gt;&quot;) to find a key. If you want
to use a different <br>
default key, you can specify it in the repository
configuration as follows:</p>

<p style="margin-top: 1em">[user] <br>
signingkey = &lt;gpg-key-id&gt;</p>

<p style="margin-top: 1em">DISCUSSION <br>
On Re-tagging <br>
What should you do when you tag a wrong commit and you would
want to re-tag?</p>

<p style="margin-top: 1em">If you never pushed anything
out, just re-tag it. Use &quot;-f&quot; to replace the old
one. And you&acirc;re done.</p>

<p style="margin-top: 1em">But if you have pushed things
out (or others could just read your repository directly),
then others will have already seen the old tag. In that case
you can do one of two things:</p>

<p style="margin-top: 1em">1. The sane thing. Just admit
you screwed up, and use a different name. Others have
already seen one tag-name, and if you keep the same name,
you may be in the situation that <br>
two people both have &quot;version X&quot;, but they
actually have different &quot;X&quot;&rsquo;s. So just call
it &quot;X.1&quot; and be done with it.</p>

<p style="margin-top: 1em">2. The insane thing. You really
want to call the new version &quot;X&quot; too, even though
others have already seen the old one. So just use git tag -f
again, as if you hadn&acirc;t already <br>
published the old one.</p>

<p style="margin-top: 1em">However, Git does not (and it
should not) change tags behind users back. So if somebody
already got the old tag, doing a git pull on your tree
shouldn&acirc;t just make them overwrite <br>
the old one.</p>

<p style="margin-top: 1em">If somebody got a release tag
from you, you cannot just change the tag for them by
updating your own one. This is a big security issue, in that
people MUST be able to trust their <br>
tag-names. If you really want to do the insane thing, you
need to just fess up to it, and tell people that you messed
up. You can do that by making a very public announcement
<br>
saying:</p>

<p style="margin-top: 1em">Ok, I messed up, and I pushed
out an earlier version tagged as X. I <br>
then fixed something, and retagged the *fixed* tree as X
again.</p>

<p style="margin-top: 1em">If you got the wrong tag, and
want the new one, please delete <br>
the old one and fetch the new one by doing:</p>

<p style="margin-top: 1em">git tag -d X <br>
git fetch origin tag X</p>

<p style="margin-top: 1em">to get my updated tag.</p>

<p style="margin-top: 1em">You can test which tag you have
by doing</p>

<p style="margin-top: 1em">git rev-parse X</p>

<p style="margin-top: 1em">which should return
0123456789abcdef.. if you have the new version.</p>

<p style="margin-top: 1em">Sorry for the inconvenience.</p>

<p style="margin-top: 1em">Does this seem a bit
complicated? It should be. There is no way that it would be
correct to just &quot;fix&quot; it automatically. People
need to know that their tags might have been <br>
changed.</p>

<p style="margin-top: 1em">On Automatic following <br>
If you are following somebody else&acirc;s tree, you are
most likely using remote-tracking branches
(refs/heads/origin in traditional layout, or
refs/remotes/origin/master in the <br>
separate-remote layout). You usually want the tags from the
other end.</p>

<p style="margin-top: 1em">On the other hand, if you are
fetching because you would want a one-shot merge from
somebody else, you typically do not want to get tags from
there. This happens more often for <br>
people near the toplevel but not limited to them. Mere
mortals when pulling from each other do not necessarily want
to automatically get private anchor point tags from the
other <br>
person.</p>

<p style="margin-top: 1em">Often, &quot;please pull&quot;
messages on the mailing list just provide two pieces of
information: a repo URL and a branch name; this is designed
to be easily cut&amp;pasted at the end of a <br>
git fetch command line:</p>

<p style="margin-top: 1em">Linus, please pull from</p>

<p style="margin-top: 1em">git://git..../proj.git
master</p>

<p style="margin-top: 1em">to get the following
updates...</p>

<p style="margin-top: 1em">becomes:</p>

<p style="margin-top: 1em">$ git pull
git://git..../proj.git master</p>

<p style="margin-top: 1em">In such a case, you do not want
to automatically follow the other person&acirc;s tags.</p>

<p style="margin-top: 1em">One important aspect of Git is
its distributed nature, which largely means there is no
inherent &quot;upstream&quot; or &quot;downstream&quot; in
the system. On the face of it, the above example <br>
might seem to indicate that the tag namespace is owned by
the upper echelon of people and that tags only flow
downwards, but that is not the case. It only shows that the
usage <br>
pattern determines who are interested in whose tags.</p>

<p style="margin-top: 1em">A one-shot pull is a sign that a
commit history is now crossing the boundary between one
circle of people (e.g. &quot;people who are primarily
interested in the networking part of the <br>
kernel&quot;) who may have their own set of tags (e.g.
&quot;this is the third release candidate from the
networking group to be proposed for general consumption with
2.6.21 release&quot;) to <br>
another circle of people (e.g. &quot;people who integrate
various subsystem improvements&quot;). The latter are
usually not interested in the detailed tags used internally
in the former <br>
group (that is what &quot;internal&quot; means). That is why
it is desirable not to follow tags automatically in this
case.</p>

<p style="margin-top: 1em">It may well be that among
networking people, they may want to exchange the tags
internal to their group, but in that workflow they are most
likely tracking each other&acirc;s progress <br>
by having remote-tracking branches. Again, the heuristic to
automatically follow such tags is a good thing.</p>

<p style="margin-top: 1em">On Backdating Tags <br>
If you have imported some changes from another VCS and would
like to add tags for major releases of your work, it is
useful to be able to specify the date to embed inside of the
<br>
tag object; such data in the tag object affects, for
example, the ordering of tags in the gitweb interface.</p>

<p style="margin-top: 1em">To set the date used in future
tag objects, set the environment variable GIT_COMMITTER_DATE
(see the later discussion of possible values; the most
common form is &quot;YYYY-MM-DD <br>
HH:MM&quot;).</p>

<p style="margin-top: 1em">For example:</p>

<p style="margin-top: 1em">$
GIT_COMMITTER_DATE=&quot;2006-10-02 10:31&quot; git tag -s
v1.0.1</p>

<p style="margin-top: 1em">DATE FORMATS <br>
The GIT_AUTHOR_DATE, GIT_COMMITTER_DATE environment
variables support the following date formats:</p>

<p style="margin-top: 1em">Git internal format <br>
It is &lt;unix timestamp&gt; &lt;timezone offset&gt;, where
&lt;unix timestamp&gt; is the number of seconds since the
UNIX epoch. &lt;timezone offset&gt; is a positive or
negative offset from UTC. <br>
For example CET (which is 2 hours ahead UTC) is +0200.</p>

<p style="margin-top: 1em">RFC 2822 <br>
The standard email format as described by RFC 2822, for
example Thu, 07 Apr 2005 22:13:13 +0200.</p>

<p style="margin-top: 1em">ISO 8601 <br>
Time and date specified by the ISO 8601 standard, for
example 2005-04-07T22:13:13. The parser accepts a space
instead of the T character as well.</p>

<p style="margin-top: 1em">Note <br>
In addition, the date part is accepted in the following
formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.</p>

<p style="margin-top: 1em">SEE ALSO <br>
git-check-ref-format(1).</p>

<p style="margin-top: 1em">GIT <br>
Part of the git(1) suite</p>

<p style="margin-top: 1em">Git 1.8.3.1 03/23/2016
GIT-TAG(1)</p>
<hr>
</body>
</html>
