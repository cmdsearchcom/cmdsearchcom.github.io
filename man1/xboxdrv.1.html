<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>xboxdrv (1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">xboxdrv (1)</td>
    <td class="head-vol">User Commands</td>
    <td class="head-rtitle">xboxdrv (1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
xboxdrv - A Xbox/Xbox360 gamepad driver that works in userspace
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<br/>
<b>xboxdrv</b>
<br/>
[OPTION]... [--] [COMMAND] [ARGUMENTS]
<br/>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>xboxdrv</b> is a driver for Xbox and Xbox360 gamepads. It works by reading
  the raw data from the controller with the userspace library libusb and then
  passes the interpreted data to the kernel via uinput. This allows
  <b>xboxdrv</b> to provide regular joystick and event devices, which makes it
  compatible with all Linux software.
<div class="Pp"></div>
Aside from the pure driver, <b>xboxdrv</b> also includes a rich set of
  configuration options that allow you to tweak the abilities of the virtual
  input devices that xboxdrv will create. This includes basic button and axis
  remapping, as well as more complicated things like mouse and keyboard
  emulation, auto-fire and throttle control emulation.
<div class="Pp"></div>
It is also possible for <b>xboxdrv</b> to read input data directly from an event
  device, this allows the use of the configurability of <b>xboxdrv</b> on
  regular PC joysticks, keyboards and mice and thus lets <b>xboxdrv</b> serve a
  similar purpose as <b>joy2key</b>. See the option <b>--evdev</b> below for
  more information.
<div class="Pp"></div>
When a <b>COMMAND</b> is provided xboxdrv will launch that application and be
  running till that application exits. This is a convenience function to make it
  easier to use xboxdrv in wrapper scripts. See the section [Writing Start-Up
  Scripts for Games] for more information.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<h2 class="Ss" title="Ss" id="GENERAL_OPTIONS"><a class="selflink" href="#GENERAL_OPTIONS">GENERAL
  OPTIONS</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b>, <b>--help</b></dt>
  <dd class="It-tag">Display help text and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-V, --version</dt>
  <dd class="It-tag">Print the version number and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b>, <b>--verbose</b></dt>
  <dd class="It-tag">Print verbose messages.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--debug</b></dt>
  <dd class="It-tag">Print even more verbose messages then
    <b>--verbose</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b>, <b>--silent</b></dt>
  <dd class="It-tag">Do not display controller events on the terminal. For
      regular use this option should always be used as output data to the
      terminal can eat up quite a bit of CPU.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--quiet</b></dt>
  <dd class="It-tag">Do not display startup text and suppress most other
    output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--priority</b> <i>PRIORITY</i></dt>
  <dd class="It-tag">Possible values for <i>PRIORITY</i> are &quot;normal&quot;
      and &quot;realtime&quot;. Realtime scheduling gives the xboxdrv process
      higher priority and thus allows it to function properly even when the
      machine is under load.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that realtime priority requires running xboxdrv as root, when running
      xboxdrv as user there is no way to increase the priority.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is deprecated, use <b>chrt</b>(1) instead to achive the same
      effect.</dd>
</dl>
<h2 class="Ss" title="Ss" id="LIST_OPTIONS"><a class="selflink" href="#LIST_OPTIONS">LIST
  OPTIONS</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help-led</b></dt>
  <dd class="It-tag">List possible values for the led.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help-devices</b></dt>
  <dd class="It-tag">List supported devices.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--list-supported-devices</b></dt>
  <dd class="It-tag">List supported devices (used by xboxdrv-daemon.py).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--list-supported-devices-xpad</b></dt>
  <dd class="It-tag">List supported devices in <i>xpad.c</i> style.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help-abs</b></dt>
  <dd class="It-tag">List all allowed EV_ABS symbols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help-rel</b></dt>
  <dd class="It-tag">List all allowed EV_REL symbols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help-key</b></dt>
  <dd class="It-tag">List all allowed EV_KEY symbols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help-x11keysym</b></dt>
  <dd class="It-tag">List all allowed X11 Keysym symbols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help-axis</b></dt>
  <dd class="It-tag">List all allowed XboxAxis symbols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help-button</b></dt>
  <dd class="It-tag">List all allowed XboxButton symbols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--help-all</b></dt>
  <dd class="It-tag">List all symbols that can be used in <b>--ui-buttonmap</b>,
      <b>--ui-axismap</b>, <b>--buttonmap</b> and <b>--axismap</b>. This option
      is the same as <b>--help-abs</b>, <b>--help-rel</b>, <b>--help-key</b>,
      <b>--help-x11keysym</b>, <b>--help-axis</b> and <b>--help-button</b>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="CONFIG_FILE_OPTIONS"><a class="selflink" href="#CONFIG_FILE_OPTIONS">CONFIG
  FILE OPTIONS</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b>, <b>--config</b> <i>FILE</i></dt>
  <dd class="It-tag">Reads configuration information from <i>FILE</i>.
      Configurations from file are handling as if they would be command line
      options at the position of <b>--config</b> <i>FILE</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The syntax of <i>FILE</i> is the familiar INI syntax used for many
      configuration files. Regular key/value pairs must go into the [xboxdrv]
      section. '#' and ';' can be used for comments. Key names have for most
      part the same name as command line options. Command line options that take
      a list of input mappings (--ui-buttonmap, --ui-axismap, --evdev-absmap,
      ...) can be split of into their own section for better readability.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>examples/</i> directory contains some example configuration files.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
[xboxdrv]
silent=true
deadzone=6000
dpad-as-button=true
trigger-as-button=true
<div class="Pp"></div>
[ui-axismap]
x2=REL_X:10
y2=REL_Y:-10
x1=KEY_A:KEY_D
y1=KEY_W:KEY_S
<div class="Pp"></div>
[ui-buttonmap]
a=KEY_LEFTSHIFT
b=BTN_C
x=BTN_EXTRA
y=KEY_C
<div class="Pp"></div>
[ui-buttonmap]
lb=BTN_RIGHT
rb=KEY_SPACE
<div class="Pp"></div>
[ui-buttonmap]
lt=KEY_Z
rt=BTN_LEFT
<div class="Pp"></div>
[ui-buttonmap]
dl=KEY_4
dr=KEY_2
du=REL_WHEEL:-1:150
dd=REL_WHEEL:1:150
<div class="Pp"></div>
[ui-buttonmap]
back=KEY_TAB
start=KEY_ESC
<div class="Pp"></div>
# EOF #
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--alt-config</b> <i>FILE</i></dt>
  <dd class="It-tag">A shortcut for writing <b>--next-config</b> <b>--config</b>
      <i>FILE</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    To load multiple configuration options use:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv --config first.ini --alt-config second.ini --alt-config third.ini
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b>, <b>--option</b> <i>NAME=VALUE</i></dt>
  <dd class="It-tag">Set an option as if it would come from a config file from
      the command line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--write-config</b> <i>FILE</i></dt>
  <dd class="It-tag">Write an example configuration file to <i>FILE</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="DAEMON_OPTIONS"><a class="selflink" href="#DAEMON_OPTIONS">DAEMON
  OPTIONS</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D</b>, <b>--daemon</b></dt>
  <dd class="It-tag">Run xboxdrv as daemon. If this option is given xboxdrv will
      listen to udev for USB connection events and launch driver threads for
      newly connected controllers.
    <div style="height: 1.00em;">&#x00A0;</div>
    Configuration options can still be supplied as usual. Note however that
      xboxdrv when run as daemon will not create new uinput devices on demand,
      instead it will only create devices once at startup for the given
      configurations and then assign new controllers to these configurations.
      While this means xboxdrv can't support an unlimited number of controllers,
      it also means that xboxdrv can allow hot plugging even for applications
      that don't support it themselves, as applications will only see the
      permanent device files, not the controller that xboxdrv will change around
      under the hood.
    <div style="height: 1.00em;">&#x00A0;</div>
    An example configuration that supports three controller would look like
      this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv --daemon \
    # config options for the first controller
  --next-controller \
    # config options for the second controller
  --next-controller
    # config options for the third controller
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The <b>--match</b> option can be used to limit the controller slots to only
      those controllers that match the given RULE and thus be used to assign
      configurations only to specific controllers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--detach</b></dt>
  <dd class="It-tag">Detaches xboxdrv from the current shell, only valid if
      <b>--daemon</b> is given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--pid-file</b> <i>FILE</i></dt>
  <dd class="It-tag">Write the xboxdrv daemon process id to FILE.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dbus</b> <i>BUS</i></dt>
  <dd class="It-tag">Set which bus type xboxdrv should connect to. Allowed
      values for BUS are session, system, disabled and auto. The default is
      auto, which will detect the appropriate bus type depending on if xboxdrv
      is run as root (system or as user (session). Running with disabled will
      disable D-Bus support completely.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--on-connect</b> <i>EXE</i></dt>
  <dd class="It-tag">Launches <i>EXE</i> when a controller gets connected. As
      arguments &quot; <i>BUSDEV</i>:<i>DEVNUM</i>&quot;, &quot;
      <i>idVendor</i>: <i>idProduct</i>&quot;, &quot; <i>NAME</i> are
    provided.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--on-disconnect</b> <i>EXE</i></dt>
  <dd class="It-tag">Launches <i>EXE</i> when a controller gets disconnected. As
      arguments &quot; <i>BUSDEV</i>:<i>DEVNUM</i>&quot;, &quot;
      <i>idVendor</i>: <i>idProduct</i>&quot;, &quot; <i>NAME</i> are
    provided.</dd>
</dl>
<h2 class="Ss" title="Ss" id="DEVICE_OPTIONS"><a class="selflink" href="#DEVICE_OPTIONS">DEVICE
  OPTIONS</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L</b>, <b>--list-controller</b></dt>
  <dd class="It-tag">List available controllers on the system.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b>, <b>--id</b> <i>N</i></dt>
  <dd class="It-tag">Use controller with id N (default: 0), use
      <b>--list-controller</b> to obtain a list of available controller.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b>, <b>--wid</b> <i>N</i></dt>
  <dd class="It-tag">Use wireless controller with wid N (default: 0).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--device-by-path</b> <i>BUS:DEV</i></dt>
  <dd class="It-tag">Use the controller at BUS:DEV, do not do any automatic
      scanning. Useful for cases when a controller isn't known by xboxdrv, but
      supports one of the given protocols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--device-by-id</b> <i>VENDOR:PRODUCT</i></dt>
  <dd class="It-tag">Use device that matches VENDOR:PRODUCT (as returned by
      <b>lsusb</b>). Useful for cases when a controller isn't known by xboxdrv,
      but supports one of the given protocols.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--type</b> <i>TYPE</i></dt>
  <dd class="It-tag">Ignore autodetection and enforce the controller type.
      Possible values for <i>TYPE</i>:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">xbox</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">xbox-mat</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">xbox360</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">xbox360-wireless</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">xbox360-guitar</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">firestorm</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">firestorm-vsb</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">saitek-p2500</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">generic-usb</dd>
</dl>
</div>
<div style="height: 1.00em;">&#x00A0;</div>
The <b>generic-usb</b> type is a special type that will work with any USB
  controller, it will however not interpret the input it gets, but just dump it
  to the console for development purposes. See <b>--generic-usb-spec</b> for
  further information.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b>, <b>--detach-kernel-driver</b></dt>
  <dd class="It-tag">Detaches the kernel driver that is currently associated
      with the given device. This is useful when you have the xpad module loaded
      and want to use xboxdrv without unloading it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--generic-usb-spec</b> <i>NAME=VALUE,...</i></dt>
  <dd class="It-tag">Allows to specify from which endpoint <b>generic-usb</b>
      will read. The spec as the form of <i>NAME=VALUE,...</i>. Allowed values
      are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">vid=HEX</dt>
  <dd class="It-tag">The vendor id of the controller to which this spec
    applies</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">pid=HEX</dt>
  <dd class="It-tag">The product id of the controller to which this spec
    applies</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">if=NUM</dt>
  <dd class="It-tag">The interface from which GenericUSBController should be
      read</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">ep=NUM</dt>
  <dd class="It-tag">The endpoint from which GenericUSBController should be
    read</dd>
</dl>
</div>
<h2 class="Ss" title="Ss" id="EVDEV_OPTION"><a class="selflink" href="#EVDEV_OPTION">EVDEV
  OPTION</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--evdev</b> <i>DEVICE</i></dt>
  <dd class="It-tag">Allows you to read input data from a regular event device.
      This allows you to use <b>xboxdrv</b> on regular PC joysticks. The data
      that is read from the event device is converted internally into a XboxMsg
      object and then passed through the same configuration pipeline as it would
      be for a regular Xbox360 controller. This allows you to make use of all
      the regular configurability, but limits you to the number of axis and
      buttons that an Xbox360 controller provides.
    <div style="height: 1.00em;">&#x00A0;</div>
    As a regular PC joystick will most likely already create a
      <i>/dev/input/jsX</i> device by itself, you might need to get rid of that
      so that a game will properly detect the joystick device created by
      <b>xboxdrv</b>. The easiest way to accomplish that is to simply delete the
      old joystick and rename the device that <b>xboxdrv</b> created to
      <i>/dev/input/js0</i>. When you use udev, this operation should be
      harmless and automatically reverse itself when you remove the controller
      and plug it back in or when you reboot the computer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--evdev-debug</b></dt>
  <dd class="It-tag">The evdev event handler will print all received events to
      stdout, this makes it easy to see which events a given controller
    sends.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--evdev-no-grab</b></dt>
  <dd class="It-tag">By default the evdev driver will grab the device, thus
      making it impossible for other applications to receive events from that
      device. This is done to avoid confusing applications, as otherwise an app
      would receive every event twice, once from the original device and once
      from the virtual xboxdrv one. In some cases this behaviour is undesired,
      such when mapping only an otherwise unhandled subset of keys of an device,
      i.e. mapping the multimedia keys on a keyboard, so this option turns the
      grab off.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--evdev-absmap</b> <i>ABSMAP,...</i></dt>
  <dd class="It-tag">
    <pre>
ABSMAP = EVDEV_ABS [ &quot;+&quot;, &quot;-&quot; ] &quot;=&quot; XBOXAXIS ;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Sets how evdev events are mapped to Xbox axis events. An example
      configuration would look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
--evdev-absmap ABS_X=x1,ABS_Y=y1,ABS_RZ=x2,ABS_THROTTLE=y2,ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>xboxdrv</b> will output on startup a full list of event names that the
      given event device supports and that can be used in place of
      <i>EVDEV_ABS</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    It is also possible to map half-axis with a command like:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
--evdev-absmap ABS_Y+=LT,ABS_Y-=RT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This will map the upward movement of the Y axis to the left trigger and the
      downward movement to the right trigger.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--evdev-keymap</b> <i>KEYMAP</i></dt>
  <dd class="It-tag">Sets how evdev events are mapped to Xbox controller events.
      An example configuration would look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
--evdev-keymap BTN_TRIGGER=a,BTN_THUMB=b,BTN_THUMB2=x
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>xboxdrv</b> will output on start a full list of event names that the
      given event device supports.</dd>
</dl>
<h2 class="Ss" title="Ss" id="STATUS_OPTIONS"><a class="selflink" href="#STATUS_OPTIONS">STATUS
  OPTIONS</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l</b>, <b>--led</b> <i>NUM</i></dt>
  <dd class="It-tag">Set LED status. Possible values for <i>NUM</i> are:
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>LED Status Codes</b>
    <table class="tbl">
      <colgroup>
        <col style="width: 3.00ex;"/>
        <col style="width: 29.00ex;"/>
      </colgroup>
      <tr>
        <td>Num</td>
        <td>Behavior</td>
      </tr>
      <tr>
        <td>0</td>
        <td>off</td>
      </tr>
      <tr>
        <td>1</td>
        <td>all blinking</td>
      </tr>
      <tr>
        <td>2</td>
        <td>1/top-left blink, then on</td>
      </tr>
      <tr>
        <td>3</td>
        <td>2/top-right blink, then on</td>
      </tr>
      <tr>
        <td>4</td>
        <td>3/bottom-left blink, then on</td>
      </tr>
      <tr>
        <td>5</td>
        <td>4/bottom-right blink, then on</td>
      </tr>
      <tr>
        <td>6</td>
        <td>1/top-left on</td>
      </tr>
      <tr>
        <td>7</td>
        <td>2/top-right on</td>
      </tr>
      <tr>
        <td>8</td>
        <td>3/bottom-left on</td>
      </tr>
      <tr>
        <td>9</td>
        <td>4/bottom-right on</td>
      </tr>
      <tr>
        <td>10</td>
        <td>rotate</td>
      </tr>
      <tr>
        <td>11</td>
        <td>blink</td>
      </tr>
      <tr>
        <td>12</td>
        <td>blink slower</td>
      </tr>
      <tr>
        <td>13</td>
        <td>rotate with two lights</td>
      </tr>
      <tr>
        <td>14</td>
        <td>blink</td>
      </tr>
      <tr>
        <td>15</td>
        <td>blink once</td>
      </tr>
    </table>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--rumble-gain</b> <i>AMOUNT</i></dt>
  <dd class="It-tag">You can change the rumble strength via:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --rumble-gain 50%
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Values larger then 100% are possible as well and will amplify small rumble
      commands, rumble commands already at the maximum will stay unchanged.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-q</b>, <b>--quit</b></dt>
  <dd class="It-tag">Exit xboxdrv after setting LED or rumble values.</dd>
</dl>
<h2 class="Ss" title="Ss" id="CHATPAD_OPTIONS_(EXPERIMENTAL)"><a class="selflink" href="#CHATPAD_OPTIONS_(EXPERIMENTAL)">CHATPAD
  OPTIONS (EXPERIMENTAL)</a></h2>
Chatpad support is still experimental. Basic keyboard usage will work, there is
  however currently no support for customization or the green and orange key
  modifiers.
<div class="Pp"></div>
Starting xboxdrv multiple times in a row with the <b>--chatpad</b> option can
  crash the controller. Unplugging it and plugging it back in should reset it.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--chatpad</b></dt>
  <dd class="It-tag">Enables the support for the Xbox360 Chatpad. WARNING: This
      is preliminary code, it will crash your gamepad when xboxdrv is started
      multiple times and won't provide proper keymapping for any of the umlauts
      and special characters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--chatpad-no-init</b></dt>
  <dd class="It-tag">This will start chatpad support with out sending the init
      sequence, thus potentially avoiding crashing the controller if xboxdrv is
      started multiple times.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--chatpad-debug</b></dt>
  <dd class="It-tag">Output raw chatpad data to the stdout for debugging
      purpose.</dd>
</dl>
<h2 class="Ss" title="Ss" id="HEADSET_OPTIONS_(EXPERIMENTAL,_XBOX360_USB_ONLY)"><a class="selflink" href="#HEADSET_OPTIONS_(EXPERIMENTAL,_XBOX360_USB_ONLY)">HEADSET
  OPTIONS (EXPERIMENTAL, XBOX360 USB ONLY)</a></h2>
Xboxdrv does not support the headset, the options below are for developers only
  and will dump raw headset data, not .wav files.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--headset</b></dt>
  <dd class="It-tag">Enable headset support and dump incoming data to
    stdout.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--headset-dump</b> <i>FILE</i></dt>
  <dd class="It-tag">Enable headset support and dump incoming data to FILE.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--headset-play</b> <i>FILE</i></dt>
  <dd class="It-tag">Enable headset support and send FILE to the headset for
      playback.</dd>
</dl>
<h2 class="Ss" title="Ss" id="FORCE_FEEDBACK"><a class="selflink" href="#FORCE_FEEDBACK">FORCE
  FEEDBACK</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--force-feedback</b></dt>
  <dd class="It-tag">Enables the standard kernel force feedback interface. It is
      disabled by default as it causes trouble with some applications running in
      Wine.
    <div style="height: 1.00em;">&#x00A0;</div>
    Since the Xbox360 controller supports just rumble not full force feedback,
      xboxdrv tries to emulate other effects. This emulation hasn't been tested
      much and might not always work as expected. Bug reports and test cases are
      welcome.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that you must close the application that is using force feedback always
      before you close the xboxdrv driver, else you might end up with a hanging
      non-interruptable xboxdrv process that will require a reboot to get rid
      of.
    <div style="height: 1.00em;">&#x00A0;</div>
    When using xboxdrv in daemon mode with multiple controller slots you have to
      enable force feedback for each slot separately.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ff-device</b> <i>DEVICEID</i></dt>
  <dd class="It-tag">Select to which virtual device the force-feedback callbacks
      will be connected to, it defaults to joystick. Other allowed values are
      mouse, keyboard and any integer number. See <b>--ui-buttonmap</b> for
      further information on how device-ids work.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-R</b>, <b>--test-rumble</b></dt>
  <dd class="It-tag">Pressing LT will move the left rumble motor and pressing RT
      will move the right one. Rumble motor strength depends on how hard you
      press. This is useful for testing the rumble motors.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-r</b>, <b>--rumble</b> <i>L,R</i></dt>
  <dd class="It-tag">Set the speed for both rumble motors. Values from 0 to 255
      are accepted, the default is 0,0.</dd>
</dl>
<h2 class="Ss" title="Ss" id="CONTROLLER_SLOT_OPTIONS"><a class="selflink" href="#CONTROLLER_SLOT_OPTIONS">CONTROLLER
  SLOT OPTIONS</a></h2>
Controller slots are used when running xboxdrv in daemon mode. Each slot
  represents a complete controller configuration. If you want to use multiple
  controller in daemon mode you have to supply multiple controller slots.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--controller-slot</b> <i>N</i></dt>
  <dd class="It-tag">Switches to the controller slot with the number N,
      numbering starts at zero.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--next-controller</b></dt>
  <dd class="It-tag">Switches to the next controller slot.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--match</b> <i>RULE,...</i></dt>
  <dd class="It-tag">Limits a controller slot to devices that match any one of
      the given rules. Possible match rules are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">usbid=<i>VENDOR</i>:<i>PRODUCT</i></dt>
  <dd class="It-tag">Match controllers that have the given USB vendor and
      product ids.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">vendor=<i>VENDOR</i></dt>
  <dd class="It-tag">Match controllers that have the given USB idVendor.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">product=<i>PRODUCT</i></dt>
  <dd class="It-tag">Match controllers that have the given USB idProduct.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">property=<i>PROPERTY</i>:<i>VALUE</i></dt>
  <dd class="It-tag">Match against an arbitrary udev property, with name
      <i>PROPERTY</i> and value <i>VALUE</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">usbpath=<i>BUS</i>:<i>DEV</i></dt>
  <dd class="It-tag">Match against the USB path given by <i>BUS</i> and
      <i>DEV</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">usbserial=<i>SERIAL</i></dt>
  <dd class="It-tag">Match against the USB iSerial number.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--match-group</b> <i>RULE,...</i></dt>
  <dd class="It-tag">Limits a controller slot to devices that match all of the
      given rules. Possible match rules are the same as for <b>--match</b>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="CONFIG_SLOT_OPTIONS"><a class="selflink" href="#CONFIG_SLOT_OPTIONS">CONFIG
  SLOT OPTIONS</a></h2>
You can use multiple configurations, called config slots, with your controller.
  You switch between those multiple configurations by pressing the Guide button
  by default, but you can also set another button via the option
  <b>--toggle</b>.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--config-slot</b> <i>NUM</i></dt>
  <dd class="It-tag">Select the config slot <i>NUM</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--next-config</b></dt>
  <dd class="It-tag">Allows the creation of an alternative uinput configuration
      to which one can toggle at runtime by pressing the ui-toggle button
      (defaults to guide).
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv \
    --mouse \
  --next-config 
    --ui-axismap X1=ABS_X,Y1=ABS_Y \
    --ui-buttonmap A=JS_0,B=JS_1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The above configuration would install mouse emulation as first configuration
      and a simple joystick emulation as second configuration. Allowing toggling
      between mouse emulation and joystick handling by pressing the guide
      button.
    <div style="height: 1.00em;">&#x00A0;</div>
    Not that <b>--next-config</b> is currently limited to only configurations
      done with <b>--ui-buttonmap</b> and <b>--ui-axismap</b>, autofire,
      throttle emulation, deadzones and all other things can currently not be
      switched at runtime.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--toggle</b> <i>XBOXBTN</i></dt>
  <dd class="It-tag">Sets the button that will be used to toggle between
      different different configurations. A value of 'void' will disable the
      toggle button. If no toggle button is specified, the guide button will be
      used to toggle between configurations.</dd>
</dl>
<h2 class="Ss" title="Ss" id="CONFIGURATION_OPTIONS"><a class="selflink" href="#CONFIGURATION_OPTIONS">CONFIGURATION
  OPTIONS</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--modifier </b><i>MOD</i></dt>
  <dd class="It-tag">Add a modifier to the modifier stack, see [Modifier] for a
      full list of possible modifier.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--timeout </b><i>MSEC</i></dt>
  <dd class="It-tag">Specify the number of miliseconds that xboxdrv will wait
      for events from the controller before moving on and processing things like
      auto-fire or relative-axis. Default value is 10, smaller values will give
      you a higher resolution auto fire and relative event movement, but will
      waste some more CPU.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b, --buttonmap BUTTON=BUTTON,...</b></dt>
  <dd class="It-tag">Button remapping is available via the <b>--buttonmap</b>
      option. If you want to swap button A and B start with:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --buttonmap A=B,B=A
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you want all face buttons send out A button events:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --buttonmap B=A,X=A,Y=A
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Possible button names are (aliases are in parenthesis):
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>Button Names</b>
    <table class="tbl">
      <colgroup>
        <col style="width: 37.00ex;"/>
        <col style="width: 64.00ex;"/>
      </colgroup>
      <tr>
        <td>Name</td>
        <td>Description</td>
      </tr>
      <tr>
        <td>start, back</td>
        <td>start, back buttons</td>
      </tr>
      <tr>
        <td>guide</td>
        <td>big X-button in the middle (Xbox360 only)</td>
      </tr>
      <tr>
        <td>a(1), b(2), x(3), y(4)</td>
        <td>face buttons</td>
      </tr>
      <tr>
        <td>black, white</td>
        <td>black, white buttons (Xbox1 only, mapped to lb, rb on Xbox360)</td>
      </tr>
      <tr>
        <td>lb(5), rb(6)</td>
        <td>shoulder buttons (Xbox360 only, mapped to black, white on
          Xbox1)</td>
      </tr>
      <tr>
        <td>lt(7), rt(8)</td>
        <td>analog trigger (needs --trigger-as-button option)</td>
      </tr>
      <tr>
        <td>tl, tr</td>
        <td>pressing the left or right analog stick</td>
      </tr>
      <tr>
        <td>du(up), dd(down), dl(left), dr(right)</td>
        <td>dpad directions (needs --dpad-as-button option)</td>
      </tr>
      <tr>
        <td>green, red, yellow, blue, orange</td>
        <td>guitar buttons</td>
      </tr>
    </table>
    <div style="height: 1.00em;">&#x00A0;</div>
    Just like with <b>--ui-buttonmap</b> you can add button filter to each
      button.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--axismap</b> <i>AXIS=MAPPING,...</i></dt>
  <dd class="It-tag">Axis remapping is available via --axismap and works the
      same as button mapping. In addition you can supply a sign to indicate that
      an axis should be inverted. So if you want to invert the y1 axis start
      with:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --axismap -Y1=Y1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you want to swap the left and right stick start with:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --axismap X2=X1,Y2=Y1,X1=X2,Y1=Y2
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Possible axis names are: x1, y1, x2, y2, lt, rt
    <div style="height: 1.00em;">&#x00A0;</div>
    Swaping lt or rt with x1, y1, x2, y2 will not work properly, since their
      range is different.
    <div style="height: 1.00em;">&#x00A0;</div>
    Just like with <b>--ui-axismap</b> you can add axis filter to each
    axis.</dd>
</dl>
<h2 class="Ss" title="Ss" id="MODIFIER_PRESET_CONFIGURATION_OPTIONS"><a class="selflink" href="#MODIFIER_PRESET_CONFIGURATION_OPTIONS">MODIFIER
  PRESET CONFIGURATION OPTIONS</a></h2>
The options in this sections are sortcuts for <b>--modifier</b> options. Unlike
  <b>--modifier</b> they are not order depended, but have a predefined order
  that is used no matter the order in which the options are given.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--autofire BUTTON=FREQUENCY,...</b></dt>
  <dd class="It-tag">Autofire mapping allows you to let a button automatically
      fire with a given frequency in miliseconds:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --autofire A=250
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Combining <b>--autofire</b> with button map allows you to have one button
      act as autofire while another one, emitting the same signal, acts
      normally.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --autofire B=250 --buttonmap B=A
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--axis-sensitivty </b><i>AXIS=SENSITIVITY</i>,...</dt>
  <dd class="It-tag">The sensitive of an axis can be adjusted via
      --axis-sensitivty:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --axis-sensitivty X1=-1.0,Y1=-1.0
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    A value of 0 gives you the default linear sensitivity, values larger then 0
      will give you higher sensitivity, while values smaller then 0 will give
      you lower sensitivity. Sensitivity values in the range of [-1, 1] will
      generally give good results, everything beyond that won't be of much
      practical use.
    <div style="height: 1.00em;">&#x00A0;</div>
    Sensitivity works by applying:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
t = 2 ** sensitivity;
pos = (1.0f - (1.0f - pos) ** t) ** (1 / t);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    To the value of the axis, this means that both the minimum value and the
      maximum value of the axis will always stay the same, just the response
      inbetween changes.
    <div style="height: 1.00em;">&#x00A0;</div>
    For a complete freeform way to change the axis response see the <b>Response
      Curve Filter</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--calibration </b><i>CALIBRATIONSPEC</i></dt>
  <dd class="It-tag">If your gamepad for some reason can't reach the maximum
      value or isn't centered properly you can fix that via the calibration
      options:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --calibration X2=-32768:0:32767
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    X2 is the axis name and the three values that follow are min, center and
      max. Simply insert the values that jstest reports when your axis is in the
      respective positions.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also use the calibration option if you want to make your joystick
      more sensitive. A setting of:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv --calibration AXIS=MIN:CENTER:MAX,...
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Will cause the joystick device report maximum position when your stick is
      only moved half the way.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--deadzone </b><i>NUM</i></dt>
  <dd class="It-tag">The deadzone is the area at which the sticks do not report
      any events. The default is zero, which gives the best sensitifity but
      might also cause trouble in some games in that the character or camera
      might move without moving the stick. To fix this one has to set the value
      to something higher:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --deadzone 4000
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    A value of 4000 works quite well for most games.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also give the deadzone in percentage:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --deadzone 15%
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--deadzone-trigger </b><i>NUM</i></dt>
  <dd class="It-tag">The left and right trigger have a separate deadzone value
      which can be specified with:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --deadzone-trigger 15%  
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dpad-rotation</b> <i>DEGREE</i></dt>
  <dd class="It-tag">Allows you to rotate the dpad. <i>DEGREE</i> must be a
      multiple of 45. This can be useful in isometric games where the playfield
      itself is rotated, thus a:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv --dpad-rotation 45
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Will give you controls that are relative to your character instead of your
      viewpoint.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--four-way-restrictor</b></dt>
  <dd class="It-tag">The <b>--four-way-restrictor</b> option allows to limit the
      movement on both analogsticks to only four directions (up, down, left,
      right), the diagonals (up/left, up/right, down/left, down/right) are
      filtered out from the output. This option is useful for games such as
      Tetris, that don't need diagonals and where you don't want to accidently
      trigger the down-move while trying to do a left/right move.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--relative-axis AXIS=NUM,...</b></dt>
  <dd class="It-tag">The function <b>--relative-axis</b> allows you to change
      the behaviour of an axis so that your movement of it moves its value up or
      down instead of applying it directly. This allows you to simulate throttle
      control for flightsim games.
    <div style="height: 1.00em;">&#x00A0;</div>
    Since the axis might be upside down, you might want to use the
      <b>--axismap</b> function to reverse it.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --relative-axis y2=64000 --axismap -y2=y2
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--square-axis</b></dt>
  <dd class="It-tag">The Xbox360 gamepad, as most other current day gamepads,
      features a circular movement range, which restricts the movement so that
      the distance to the center never gets beyond 1. This means that when you
      have the controller at the top/left the value reported is (0.7, 0.7) (i.e.
      length 1, angle 45) instead of (1,1). This behaviour is different then
      most classic PC joysticks, which had a square range and would report (1,1)
      when hold in the top/left corner.
    <div style="height: 1.00em;">&#x00A0;</div>
    Some old games (i.e. mostly DOS stuff) require a square movement range and
      will not function properly with the Xbox360 gamepad. Via the
      <b>--square-axis</b> option you can work around this issue and diagonals
      will be reported as (1,1).</dd>
</dl>
<h2 class="Ss" title="Ss" id="UINPUT_PRESET_CONFIGURATION_OPTIONS"><a class="selflink" href="#UINPUT_PRESET_CONFIGURATION_OPTIONS">UINPUT
  PRESET CONFIGURATION OPTIONS</a></h2>
The following options are simple shortcuts for common configurations that can be
  accomplished manually by using <b>--ui-buttonmap</b> and <b>--ui-axismap</b>.
<dl class="Bl-tag">
  <dt class="It-tag"><b>--trigger-as-button</b></dt>
  <dd class="It-tag">LT and RT send button instead of axis events</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--trigger-as-zaxis</b></dt>
  <dd class="It-tag">Combine LT and RT to form a zaxis instead</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dpad-as-button</b></dt>
  <dd class="It-tag">The DPad sends button instead of axis events.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--dpad-only</b></dt>
  <dd class="It-tag">Both sticks are ignored, only the DPad sends out axis
      events. Useful for games that might get confused by additional analog
      axis. Combining this option with <b>--trigger-as-button</b> is recommend
      in most situations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--guitar</b></dt>
  <dd class="It-tag">Sets a predefined button and axis mapping for use with
      guitar controllers. This mainly gets rid of a few unnecessary buttons and
      axis not used by a guitar controller.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m, --mouse</b></dt>
  <dd class="It-tag">Lets the controller act as a mouse. It is indendical to:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv \
  --dpad-as-button
  --deadzone 4000
  --trigger-as-zaxis
  --axismap &quot;-y2=y2,-trigger=trigger&quot;
  --ui-axismap &quot;x1=REL_X:15:20,y1=REL_Y:15:20,y2=REL_WHEEL:5:100,x2=REL_HWHEEL:5:100,trigger=REL_WHEEL:5:100&quot;
  --ui-buttonmap &quot;a=BTN_LEFT,b=BTN_RIGHT,x=BTN_MIDDLE,y=KEY_ENTER,rb=KEY_PAGEDOWN,lb=KEY_PAGEUP,&quot;
  --ui-buttonmap &quot;dl=KEY_LEFT,dr=KEY_RIGHT,du=KEY_UP,dd=KEY_DOWN,&quot;
  --ui-buttonmap &quot;start=KEY_FORWARD,back=KEY_BACK,guide=KEY_ESC,tl=void,tr=void&quot;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can customize it by the usual means, just make sure that <b>--mouse</b>
      comes before your customization options on the command line.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that if you have your mouse buttons switched you must adjust the above
      to match your mouse configuration or the button events will come out
      wrong.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mimic-xpad</b></dt>
  <dd class="It-tag">Causes xboxdrv to use the same axis and button names as the
      xpad kernel driver for wired Xbox360 controller</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--mimic-xpad-wireless</b></dt>
  <dd class="It-tag">Causes xboxdrv to use the same axis and button names as the
      xpad kernel driver for wired Xbox360 controller</dd>
</dl>
<h2 class="Ss" title="Ss" id="UINPUT_CONFIGURATION_OPTIONS"><a class="selflink" href="#UINPUT_CONFIGURATION_OPTIONS">UINPUT
  CONFIGURATION OPTIONS</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-uinput</b></dt>
  <dd class="It-tag">Do not to start UInput, instead simply read events from the
      controller, useful for debugging.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-extra-devices</b></dt>
  <dd class="It-tag">By default xboxdrv will allocate multiple uinput devices
      and sort events to each of them. Thus mouse related events like BTN_LEFT
      or REL_X will go to a virtual mouse device, while ABS_X events would go to
      a virtual joystick device and KEY_ESC would go to a virtual keyboard
      device.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option disables that automatism and all events will go to the same
      virtual device.
    <div style="height: 1.00em;">&#x00A0;</div>
    Manual assignment to a specific device (i.e. KEY_ESC@keyboard,
      BTN_A@joystick, ...) is still possible.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--no-extra-events</b></dt>
  <dd class="It-tag">By default xboxdrv will allocate multiple uinput devices
      and sort events to each of them. Thus mouse related events like BTN_LEFT
      or REL_X will go to a virtual mouse device, while ABS_X events would go to
      a virtual joystick device and KEY_ESC would go to a virtual keyboard
      device.
    <div style="height: 1.00em;">&#x00A0;</div>
    To make sure sure that a mouse, keyboard or joystick device is properly
      detected by Xorg, the kernel or libraries such SDL xboxdrv will insert
      extra dummy events. For example a mouse device needs REL_X and REL_Y
      events to be detected as such, but a configuration that only wants to
      emulate the mouse buttons won't provide those, thus xboxdrv will add them
      automatically. The <b>--no-extra-events</b> option will switch this
      behaviour off.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--device-name NAME</b></dt>
  <dd class="It-tag">Changes the descriptive name the device will have. This
      options acts the same as --device-names
      <i>CURRENTSLOT</i>.auto=<i>NAME</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--device-names TYPE.SLOT=NAME,...</b></dt>
  <dd class="It-tag">Changes the descriptive name the device will have.
      <i>TYPE</i> is one of mouse, keyboard, joystick, auto or a number.
      <i>SLOT</i> is a slot number or auto. The auto name acts as wild card and
      matches everything.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--device-usbid VENDOR:PRODUCT:VERSION:BUS</b></dt>
  <dd class="It-tag">Changes the vendor, product, version and bus id that the
      device will have. The last two arguments are optional. This options acts
      the same as --device-usbids
      <i>CURRENTSLOT</i>.auto=<i>VENDOR:PRODUCT:VERSION:BUS</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--device-usbids
    TYPE.SLOT=VENDOR:PRODUCT:VERSION:BUS,...</b></dt>
  <dd class="It-tag">Changes the vendor, product, version and bus id the device
      will have. <i>TYPE</i> is one of mouse, keyboard, joystick, auto or a
      number. <i>SLOT</i> is a slot number or auto. The auto name acts as wild
      card and matches everything.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ui-clear</b></dt>
  <dd class="It-tag">Removes all uinput mappings and will leave the driver in a
      blank state and only map those things you added yourself. If you only want
      to get rid of individual buttons you can use the 'void' event.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ui-buttonmap</b> <i>UIBUTTONSPEC,...</i></dt>
  <dd class="It-tag">
    <pre>
UIBUTTONSPEC = XBOXBUTTON [ &quot;+&quot; XBOXBUTTON ] [ &quot;^&quot; FILTER ] ... &quot;=&quot; ( RELSPEC | BTNSPEC | EXECSPEC ) ;
RELSPEC      = [ DEVICEID &quot;-&quot; ] &quot;REL_&quot; [ &quot;:&quot; [ VALUE ] [ &quot;:&quot; REPEAT ] ] ;
BTNSPEC      = [ DEVICEID &quot;-&quot; ] ( ( &quot;BTN_&quot; NAME ) | ( &quot;KEY_&quot; NAME ) ) { &quot;+&quot; BTNSPEC } ;
EXECSPEC     = PROGRAM { &quot;:&quot; ARGUMENT } ;
XBOXBUTTON   = &quot;a&quot; | &quot;b&quot; | &quot;x&quot; | &quot;y&quot; | &quot;lb&quot; | &quot;rb&quot; | &quot;lt&quot; | &quot;rt&quot; | 
               &quot;tl&quot; | &quot;tr&quot; | &quot;start&quot; | &quot;select&quot; | &quot;back&quot; | &quot;guide&quot; | &quot;black&quot; | &quot;white&quot; ;
FILTER       = &quot;toggle&quot; | &quot;invert&quot; | &quot;autofire&quot; [ &quot;:&quot; RATE ] [ &quot;:&quot; DELAY ] | log [ &quot;:&quot; STRING ] ;
NAME         = STRING ;
VALUE        = NUMBER ;
REPEAT       = NUMBER ;
DEVICEID     = NUMBER ;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Allows you to change the event code that is send to the kernel for buttons.
      The usage is similar to the normal button mapping, except that the right
      hand side is an event name from <i>/usr/include/linux/input.h</i>. You can
      use all <b>KEY_</b> or <b>BTN_</b> codes for <b>--ui-buttonmap</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    If the right hand side is left empty all the supplied filters will be added
      to the already existing button binding instead of a new one.
    <div style="height: 1.00em;">&#x00A0;</div>
    Aside from the named keys, you can also give the input code directly as
      number via the syntax <b>KEY_#</b><i>NUM</i><b></b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Instead of the low level <b>KEY_</b> names, which represent keycodes, you
      can also use the higher level X11 keysyms <b>XK_</b>, the keysyms have the
      advantage that they map directly to the key you expect, while a
      <b>KEY_</b> name gets mangled by the X11 keymap and will often not report
      what you expect in case you use a keymap that is different then your
      keyboard (i.e. dvorak on a qwerty keyboard).
    <div style="height: 1.00em;">&#x00A0;</div>
    A full list of valid X11 keysyms can be optained with
      <b>--help-x11keysym</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    For joystick buttons there is in addition to the <b>BTN_JOYSTICK</b>,
      <b>BTN_X</b>, etc. macros the special name <b>JS_$NUM</b>, which sets the
      given button to the $NUMS joystick button, i.e.:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --ui-clear --ui-buttonmap A=JS_0,B=JS_1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that this will only work if no other joystick button ids are in the
      way.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also map a button to a <b>REL_</b> event. In that case you can
      supply additional paramaters in the form of:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --ui-buttonmap X=REL_???:VALUE:REPEAT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>VALUE</i> gives the value of the event (default: 10)
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>REPEAT</i> gives the number of milisecond to pass before the event is
      fired again (default: 5)
    <div style="height: 1.00em;">&#x00A0;</div>
    The special 'void' event allows you to clear any existing bindings for a
      given button, which can be useful in cases when a game only supports a
      limited number of buttons.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also prepend a device_id to the UIBUTTONSPEC which allows you to
      create multiple uinput devices. By default 'auto' is assumed as device_id
      which automatically try to do the right thing, sending keyboard events to
      a keyboard device and mouse events to a mouse device. Other possible
      values are 'mouse' and 'keyboard'. A device_id of '0' refers to the first
      joystick device, values larger then 0 to the second, third, etc.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the 'mouse' and 'keyboard' device_id names do not give you a mouse
      or keyboard device, these are just symbolic names for the devices into
      which xboxdrv will sort events that look like a mouse or keyboard event.
      The final determination of which device gets handled as what will be done
      by the Kernel or Xorg depending on what events a device provides.
    <div style="height: 1.00em;">&#x00A0;</div>
    An example configuration making use of device_id would look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv -s \
  --ui-clear \
  --ui-buttonmap A=JS_0@0,B=JS_1@0 --ui-axismap X2=ABS_X@0,Y2=ABS_Y@0
  --ui-buttonmap X=JS_0@0,Y=1-JS_1@0 --ui-axismap X2=ABS_X@1,Y2=ABS_Y@1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    In this example the left stick creates a joystick device and the right stick
      creates a separate joystick device.
    <div style="height: 1.00em;">&#x00A0;</div>
    When using multiple controller slots you can additionally append the slot id
      and thus assign events across controller slot boundaries. The syntax for
      that is:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
BTN_A@{deviceid}.{slotid}
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Instead of giving just a single button, it is also possible to give two
      buttons to <b>--ui-buttonmap</b> to allow shifting:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv -s \
  --ui-clear \
  --ui-buttonmap A=JS_0,B=JS_1,LB+A=JS_2,LB+B=JS_3
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    In this example LB acts as shift button, if A is pressed without LB it will
      send out a JS_0 event, but if LB is pressed it will send a JS_2 event
      instead. This allows you to multiply the number of available buttons on
      the controller.
    <div style="height: 1.00em;">&#x00A0;</div>
    See the section KEYBOARD EMULATION below on how to resolve issues with Xorg
      not detecting the virtual keyboard that xboxdrv creates.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also apply filters to button events:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv -s \
  --ui-buttonmap A^toggle=JS_0
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    For documentation on the filters you can apply to events see [Button
      Filter].</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>--ui-axismap</b> <i>UIAXISSPEC,...</i></dt>
  <dd class="It-tag">
    <pre>
UIAXISSPEC = [ XBOXBTN &quot;+&quot; ] XBOXAXIS { &quot;^&quot; FILTER }  &quot;=&quot; ( RELSPEC | RELREP | KEYSPEC | ABSSPEC ) ;
KEYSPEC    = [ &quot;key:&quot; ] &quot;KEY_&quot; NAME &quot;:&quot; &quot;KEY_&quot; NAME &quot;:&quot; THRESHOLD ;
RELSPEC    = [ &quot;rel:&quot; ] &quot;REL_&quot; NAME &quot;:&quot; VALUE &quot;:&quot; REPEAT ;
RELREP     = &quot;rel-repeat:&quot; &quot;REL_&quot; NAME &quot;:&quot; VALUE &quot;:&quot; REPEAT ;
ABSSPEC    = [ &quot;abs:&quot; ] &quot;ABS_&quot; NAME ;
FILTER     = ( &quot;calibration&quot; | &quot;cal&quot; ) &quot;:&quot; MIN &quot;:&quot; CENTER &quot;:&quot; MAX |
             ( &quot;sensitifity&quot; | &quot;sen&quot; ) &quot;:&quot; SENSITIFITY |
             ( &quot;deadzone&quot; | &quot;dead&quot; ) &quot;:&quot; MIN &quot;:&quot; MAX &quot;:&quot; SMOOTH |
             ( &quot;relative&quot; | &quot;rel&quot; ) &quot;:&quot; SPEED  |
             ( &quot;responsecurve&quot; | &quot;response&quot; | &quot;resp&quot; ) { &quot;:&quot; VALUE }
XBOXBTN    = &quot;a&quot; | &quot;b&quot; | &quot;x&quot; | &quot;y&quot; | &quot;start&quot; | &quot;back&quot; | &quot;guide&quot; | &quot;lb&quot; | &quot;rb&quot; | ...
XBOXAXIS   = &quot;x1&quot; | &quot;y1&quot; | &quot;x2&quot; | &quot;y2&quot; | &quot;z&quot; | &quot;lt&quot; | &quot;rt&quot; | &quot;dpad_x&quot; | &quot;dpad_y&quot; ;
VALUE      = NUMBER ;
REPEAT     = NUMBER ;
THRESHOLD  = NUMBER ;
NAME       = STRING ;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Similar to <b>--ui-buttonmap</b> this option allows you to change the event
      code that is send to the kernel for axes. The events that are available
      are the same as for <b>--ui-buttonmap</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --ui-axismap X1=REL_???:VALUE:REPEAT
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>VALUE</i> gives the maximum value of the event, the actual value that
      gets send is <i>VALUE</i> * axis_state. (default: 10)
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>REPEAT</i> gives the number of milisecond to pass before the event is
      fired again (default: 5).
    <div style="height: 1.00em;">&#x00A0;</div>
    The value of -1 has a special meaning, it will result in the REL event being
      fired as soon as possible (i.e. every <i>timeout</i> miliseconds). This is
      the recomment way for handling mouse emulation, as it will keep REL events
      syncronized and thus avoid jaggies in the movement, that will result from
      manually specifying a timeout.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --ui-axismap X1=KEY_UP:KEY_DOWN:THRESHOLD
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>KEY_UP</i> gives the keycode to be send when the axis is moved up
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>KEY_DOWN</i> gives the keycode to be send when the axis is moved down
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>THRESHOLD</i> gives the threshold that triggers the sending of an event
    <div style="height: 1.00em;">&#x00A0;</div>
    Just like <b>--ui-buttonmap</b>, you can also use shift keys in place of the
      XBOXAXIS:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --ui-axismap X1=ABS_X,LB+X1=ABS_RX
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This allows you to send ABS_X events normally and ABS_RX events when the LB
      button is held down.
    <div style="height: 1.00em;">&#x00A0;</div>
    For information on how to use axis filters, see [Axis Filter].</dd>
</dl>
<h1 class="Sh" title="Sh" id="INPUT_EVENT_HANDLER"><a class="selflink" href="#INPUT_EVENT_HANDLER">INPUT
  EVENT HANDLER</a></h1>
Input event handler decide what comes out of the virtual input devices that
  xboxdrv creates. They for example decide that when button A is pressed on a
  gamepad, that a virtual keyboard will emit a press of the space key.
<div class="Pp"></div>
Furthermore input event handler can also perform some basic transformation of
  the input signals, thus a joystick can be used to send WASD keys.
<h2 class="Ss" title="Ss" id="BUTTON_EVENT_HANDLER"><a class="selflink" href="#BUTTON_EVENT_HANDLER">BUTTON
  EVENT HANDLER</a></h2>
A button event handler decides what happens when a button is pressed, it needs
  to be specified with the <b>--ui-buttonmap</b> option. The example below shows
  the simplest use case:
<div class="Pp"></div>
<pre>
$ xboxdrv --ui-buttonmap A=key:KEY_A
</pre>
<div class="Pp"></div>
Here <b>key</b> is the name of the button event handler, while <b>KEY_A</b> is
  an argument for the event handler. What kind of arguments an event handler
  allows depends on the event handler.
<div class="Pp"></div>
There is also a shorthand form of specifing event handlers by just writing:
<div class="Pp"></div>
<pre>
$ xboxdrv --ui-buttonmap A=KEY_A
</pre>
<div class="Pp"></div>
Here no handler is specified explicitly, if that is the case, the appropriate
  handler will be guessed based on the event type. EV_KEY events will be handled
  by the <b>key</b> handler, EV_REL by the <b>rel</b> handler and EV_ABS by the
  <b>abs</b> handler.
<dl class="Bl-tag">
  <dt class="It-tag"><b>key</b>:<i>KEY_EVENT</i>,
    <b>key</b>:<i>KEY_EVENT</i>:<i>KEY_EVENT</i>:<i>HOLD_THRESHOLD_MSEC</i></dt>
  <dd class="It-tag">The <b>key</b> handler is the most basic one, it maps a
      button directly to a virtual key or another button.
    <div style="height: 1.00em;">&#x00A0;</div>
    If additional arguments are supplied the button will be able to send out two
      different events. The first event specified will be send when the button
      is clicked normally, while the second event will be send in case the
      button is hold down for the time specified in <i>HOLD_THRESHOLD_MSEC</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    An example for the hold button would look like:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv \
  --ui-buttonmap A=JS_0:JS_1:500
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This will send JS_0 events when the button is pressed and switch to JS_1
      events when the button was hold for 500 miliseconds.
    <div style="height: 1.00em;">&#x00A0;</div>
    The hold button feature is useful to effectly double the number of available
      buttons, thus the dpad can for example be used to send out eight different
      button events instead of just four, which is enough to handle weapons in
      most FPS games.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>abs</b></dt>
  <dd class="It-tag">not yet implemented</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rel</b>:<i>REL_EVENT</i>:<i>VALUE</i>:<i>REPEAT</i></dt>
  <dd class="It-tag">The rel handler will send out a REL event whenever the
      button is pressed. <i>VALUE</i> gives the value of the event that will be
      send, while <i>REPEAT</i> gives the number of miliseconds till the event
      will be send again.
    <div style="height: 1.00em;">&#x00A0;</div>
    A typical use for REL events is emulation of the scroll wheel of a mouse, an
      example configuration would be:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv \
  --ui-buttonmap Y=rel:REL_WHEEL:1:500,A=rel:REL_WHEEL:-1:500
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Here Y will scroll up and A will scroll down.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cycle-key</b>:<i>KEY_EVENT</i>:...</dt>
  <dd class="It-tag">The cycle-key handler will switch the <i>KEY_EVENT</i> that
      gets send with each button press. This is useful in situations where a
      range of buttons should be mapped to a single key. For example a FPS might
      have weapons mapped from 1 to 6, but only a single key on the gamepad is
      free, thus one could write:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv \
  --ui-buttonmap A=cycle-key:KEY_1:KEY_2:KEY_3:KEY_4:KEY_5:KEY_6
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cycle-key-named:</b><i>NAME</i><b>:</b><i>KEY_EVENT</i><b>:...</b></dt>
  <dd class="It-tag">The <b>cycle-key-named</b> handler works exactly like the
      <b>cycle-key</b> handler, except that a name has to be supplied for the
      cycle sequence. The name of the sequence is used by <b>cycle-key-ref</b>
      to access the sequence and reuse it for another button.
    <div style="height: 1.00em;">&#x00A0;</div>
    In this simple example A is used to toggle through all weapon keys forward,
      while B is used to toggle the keys backwards:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv \
  --ui-buttonmap A=cycle-key-named:weapons:KEY_1:KEY_2:KEY_3:KEY_4,B=cycle-key-ref:weapons
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cycle-key-ref</b>:<i>NAME</i>:<i>DIRECTION</i>,
    <b>sequence-key-ref</b>: <i>NAME</i>:<i>DIRECTION</i></dt>
  <dd class="It-tag">The <b>cycle-key-ref</b> handler will access and reuse the
      named cycle keysequence given by <i>NAME</i>. If <i>DIRECTION</i> can
      either be 'forward' or 'backward', if no direction is supplied it will
      default to 'backward'.
    <div style="height: 1.00em;">&#x00A0;</div>
    See <b>cycle-key-named</b> for a full example.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sequence-key-named:</b><i>NAME</i><b>:</b><i>KEY_EVENT</i><b>:...</b></dt>
  <dd class="It-tag">The <b>sequence-key-named</b> works exactly the same as the
      <b>cycle-key-named</b>, with the only difference being that the
      <b>sequence-key-named</b> will not wrap around when reaching the beginning
      or end of the sequence.
    <div style="height: 1.00em;">&#x00A0;</div>
    This behaviour is useful in flight simulations or other games where
      thrusters might be controllered by numeric keys and it wouldn't make much
      sense to jump from zero to full thrust in one go.
    <div style="height: 1.00em;">&#x00A0;</div>
    To move backwards through the sequence another key must be bound to
      <b>sequence-key-ref</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>exec</b></dt>
  <dd class="It-tag">The exec button handler allows to launch an application
      when the button was pressed. An example would look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv \
  --ui-buttonmap A=exec:/home/juser/local/bin/screenshot.sh
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Possible uses for the button are the ability to do screenshots or perform
      other tasks that are outside the main application you are using xboxdrv
      with.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>macro</b></dt>
  <dd class="It-tag">A button can be bound to a macro via:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv \
  --ui-buttonmap A=macro:/home/juser/.xboxdrv/somefile.macro
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>.macro</i> file has the form of:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
send KEY_LEFTSHIFT 1
wait 500
send KEY_LEFTSHIFT 0
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    All abs, rel and key events can be send from a macro file.</dd>
</dl>
<h2 class="Ss" title="Ss" id="AXIS_EVENT_HANDLER"><a class="selflink" href="#AXIS_EVENT_HANDLER">AXIS
  EVENT HANDLER</a></h2>
Axis event handler decide what happens when an axis is moved. Like button event
  handler they come in different forms and like button event handler they
  provide a shortcut form. EV_KEY events will be handled by the <b>key</b>
  handler, EV_REL by the <b>rel</b> handler and EV_ABS by the <b>abs</b>
  handler.
<dl class="Bl-tag">
  <dt class="It-tag"><b>abs</b>:<i>ABS_EVENT</i></dt>
  <dd class="It-tag">The <b>abs</b> handler is the simplest of them all, it will
      simply send out the value it gets as input as the given <i>ABS_EVENT</i>
      event to the kernel. Thus a basic configuration to make the left stick
      behave as joystick would look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv \
  --ui-axismap X1=abs:ABS_X,Y1=abs:ABS_Y
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>key</b>:<i>KEY_UP</i>:<i>KEY_DOWN</i>:<i>THRESHOLD</i></dt>
  <dd class="It-tag"><i>KEY_UP</i> gives the keycode to be send when the axis is
      moved up
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>KEY_DOWN</i> gives the keycode to be send when the axis is moved down
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>THRESHOLD</i> gives the threshold that triggers the sending of an event
    <div style="height: 1.00em;">&#x00A0;</div>
    Just like <b>--ui-buttonmap</b>, you can also use shift keys in place of the
      XBOXAXIS:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
$ xboxdrv --ui-axismap X1=ABS_X,LB+X1=ABS_RX
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This allows you to send ABS_X events normally and ABS_RX events when the LB
      button is held down.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rel</b>:<i>REL_EVENT</i>:<i>VALUE</i>:<i>REPEAT</i></dt>
  <dd class="It-tag"><i>VALUE</i> gives the maximum value of the event, the
      actual value that gets send is <i>VALUE</i> * axis_state. (default: 10)
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>REPEAT</i> gives the number of milisecond to pass before the event is
      fired again (default: 5).
    <div style="height: 1.00em;">&#x00A0;</div>
    The value of -1 has a special meaning, it will result in the REL event being
      fired as soon as possible (i.e. every <i>timeout</i> miliseconds). This is
      the recomment way for handling mouse emulation, as it will keep REL events
      syncronized and thus avoid jaggies in the movement, that will result from
      manually specifying a timeout.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <b>rel</b> handler is mainly useful for mouse pointer emulation, if you
      want to emulate a mouse scroll wheel use the <b>rel-repeat</b> handler
      instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rel-repeat</b>:<i>REL_EVENT</i>:<i>VALUE</i>:<i>REPEAT</i></dt>
  <dd class="It-tag">The <b>rel-repeat</b> handler is similar to the <b>rel</b>
      handler, but optimized for emulating the scroll wheel of a mouse.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>VALUE</i> isn't scaled to how far the axis has moved, instead it is
      constant, instead the time given in <i>REPEAT</i> is scaled according to
      the axis movement. Thus the further the stick is moved, the more events
      will be send.
    <div style="height: 1.00em;">&#x00A0;</div>
    The need for both <b>rel-repeat</b> and <b>rel</b> arises from the fact that
      Xorg converts scroll wheel movement to button presses before they are
      handed to an application, thus an application never properly sees the
      changes in <i>VALUE</i>, by scaling <i>REPEAT</i> instead that problem is
      worked around.</dd>
</dl>
<h1 class="Sh" title="Sh" id="INPUT_FILTER"><a class="selflink" href="#INPUT_FILTER">INPUT
  FILTER</a></h1>
Input filter allow to manipulate the events that come from the controller. They
  can be used on <b>--buttonmap</b>, <b>--axismap</b>, <b>--ui-buttonmap</b> and
  <b>--ui-axismap</b>. The difference between the two is that the
  <b>--ui-...</b> versions applies to the uinput events, while the other version
  applies to Xbox360 controller events.
<h2 class="Ss" title="Ss" id="BUTTON_FILTER"><a class="selflink" href="#BUTTON_FILTER">BUTTON
  FILTER</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tog</b>, <b>toggle</b></dt>
  <dd class="It-tag">The toggle filter will turn the button into a toggle
      button, clicking the button will set it to pressed state and pressing it
      again will unpress it. Useful for games where you might want to
      permanently run or duck without holding the button pressed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>inv</b>, <b>invert</b></dt>
  <dd class="It-tag">The invert filter will keep the button in pressed state
      when it is not pressed and in unpressed state when it is pressed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>auto</b>, <b>autofire</b>:<i>RATE</i>:<i>DELAY</i></dt>
  <dd class="It-tag">The autofire filter allows to repeatatly send button press
      events when the button is held down. It takes two optional parameters:
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>RATE</i> is the number of miliseconds between button press events.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>DELAY</i> the amount of miliseconds till the autofire will start, before
      that delay the button will act as normal.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>click-press</b></dt>
  <dd class="It-tag">The <b>click-press</b> filter will transmit a single button
      click when the button is pressed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>click-release</b></dt>
  <dd class="It-tag">The <b>click-release</b> filter will transmit a single
      button click when the button is released.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>click-both</b></dt>
  <dd class="It-tag">The <b>click-both</b> filter will transmit a single button
      click when the button is pressed and another one when it is released.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>const</b>:<i>VALUE</i></dt>
  <dd class="It-tag">The const filter will ignore the input signal and send a
      constant value to the output. This can be used for example in combination
      with multiple configurations to signal a game or another application which
      configuration is currently active.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>delay</b>:<i>TIME</i></dt>
  <dd class="It-tag">A button has to be held down for TIME miliseconds before it
      will emit an event, press events shorter then that will be ignored.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log</b>:<i>STRING</i></dt>
  <dd class="It-tag">The log filter will output everything to stdout that goes
      through it to, this is useful for debugging the filter. A <i>STRING</i>
      can be provided as parameter that will be outputed before the event.</dd>
</dl>
<h2 class="Ss" title="Ss" id="AXIS_FILTER"><a class="selflink" href="#AXIS_FILTER">AXIS
  FILTER</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cal</b>,
    <b>calibration</b>:<i>MIN</i>:<i>CENTER</i>:<i>MAX</i></dt>
  <dd class="It-tag">See <b>--calibration</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sen</b>, <b>sensitivity</b>:<i>SENSITIVITY</i></dt>
  <dd class="It-tag">See <b>--axis-sensitivity</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dead</b>, <b>deadzone</b>:<i>VALUE</i>,
    <b>deadzone</b>:<i>MIN</i>:<i>CENTER</i>:<i>MAX</i></dt>
  <dd class="It-tag">Deadzone filter applies a deadzone to the current axis. If
      only <i>MIN</i> is provided, the parameter will be interpreted as
      <i>-MIN:MIN:1</i>. If the argument is 1, smooth filtering will be applied
      so that the end of the deadzone is 0. Setting the argument to 0 will apply
      a simple cut-off filter, where all events smaller then the threshold are
      ignored.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rel</b>, <b>relative</b>:<i>SPEED</i></dt>
  <dd class="It-tag">See <b>--relative-axis</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>resp</b>, <b>response</b>:<i>VALUES</i>:...</dt>
  <dd class="It-tag">The response curve filter allows you to completely change
      the way an axis reacts. The filter takes a list of <i>VALUES</i> that are
      then linearly interpolated and spread across the full range of the axis.
      An example would look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
xboxdrv \
 --ui-axismap x1^resp:-32768:-4000:0:4000:32767
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Here the X1 axis is manipulated so that it will have a lower sensitivity in
      the center and a higher one on the outside.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>const</b>:<i>VALUE</i></dt>
  <dd class="It-tag">The const filter will ignore the input signal and send a
      constant value to the output. This can be used for example in combination
      with multiple configurations to signal a game or another application which
      configuration is currently active.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>log</b>:<i>STRING</i></dt>
  <dd class="It-tag">The log filter will output everything to stdout that goes
      through it to, this is useful for debugging the filter. A <i>STRING</i>
      can be provided as parameter that will be outputed before the event.</dd>
</dl>
<h2 class="Ss" title="Ss" id="MODIFIER"><a class="selflink" href="#MODIFIER">MODIFIER</a></h2>
While button and axis filter only apply to a single axis or button at a time,
  modifiers apply to the complete controller at once and can thus be used to
  perform modifications that require input from multiple axis or buttons. Most
  of the modifiers explained below replicate functionality provided by regular
  options, but allow more fine tuning, such as limiting the effects to a single
  analog stick instead of just applyig it to all. Note that modifiers are
  applied one after the other, so order is important.
<dl class="Bl-tag">
  <dt class="It-tag"><b>dpad-rotate</b>=<i>DEGREE</i></dt>
  <dd class="It-tag">See <b>--dpad-rotation</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dpad-restrictor</b>=<i>RESTRICTON</i></dt>
  <dd class="It-tag">Restricts the dpad movement, values for <i>RESTRICTON</i>
      can be:
    <div style="height: 1.00em;">&#x00A0;</div>
    x-axis: only allow movement in the X axis
    <div style="height: 1.00em;">&#x00A0;</div>
    y-axis: only allow movement in the Y axis
    <div style="height: 1.00em;">&#x00A0;</div>
    fourway: allow movement in X and Y axis, but filter out diagonals</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>4wayrest</b>,
    <b>four-way-restrictor</b>=<i>XAXIS</i>:<i>YAXIS</i></dt>
  <dd class="It-tag">See <b>--four-way-restrictor</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>square</b>,
    <b>square-axis</b>=<i>XAXIS</i>:<i>YAXIS</i></dt>
  <dd class="It-tag">See <b>--square-axis</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rotate</b>=<i>XAXIS</i>:<i>YAXIS</i>:<i>DEGREE</i>:<i>MIRROR</i></dt>
  <dd class="It-tag">Rotates the stick given by <i>XAXIS</i> and <i>YAXIS</i> by
      <i>DEGREE</i> and optionally <i>MIRRORS</i> it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>stat</b>, <b>statistic</b></dt>
  <dd class="It-tag">The statistic modifier doesn't actually modify anything,
      instead it collects statistics on the controller, such as how many times a
      button has been pressed. The results of the collections will be displayed
      on shutdown of xboxdrv.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the stat modifier is part of the modifier stack, thus to get
      correct results you must make sure that it comes first in the stack when
      it should work on real events and not be confused by auto-fire or similar
      modifications.</dd>
</dl>
<h1 class="Sh" title="Sh" id="RUNNING_XBOXDRV"><a class="selflink" href="#RUNNING_XBOXDRV">RUNNING
  XBOXDRV</a></h1>
<h2 class="Ss" title="Ss" id="USING_A_SINGLE_CONTROLLER"><a class="selflink" href="#USING_A_SINGLE_CONTROLLER">USING
  A SINGLE CONTROLLER</a></h2>
Plug in your Xbox360 gamepad and then unload the xpad driver via:
<div class="Pp"></div>
<pre>
$ rmmod xpad
</pre>
<div class="Pp"></div>
If you want to permanently unload it add the following line to
  <i>/etc/modprobe.d/blacklist.conf</i>:
<div class="Pp"></div>
<pre>
blacklist xpad
</pre>
<div class="Pp"></div>
Next you have to load the uinput kernel module which allows userspace programms
  to create virtual input devices and the joydev module handles the
  <i>/dev/input/jsX</i> devices:
<div class="Pp"></div>
<pre>
$ modprobe uinput
$ modprobe joydev
</pre>
<div class="Pp"></div>
You also have to make sure that you have access rights to /dev/input/uinput,
  either add yourself to the appropriate group, adjust the permissions or run
  xboxdrv as root.
<div class="Pp"></div>
Once ensured that xpad is out of the way and everything is in place start the
  userspace driver with:
<div class="Pp"></div>
<pre>
$ xboxdrv
</pre>
<div class="Pp"></div>
Or in case you don't have the neccesary rights (being in group root should often
  be enough) start the driver as root via:
<div class="Pp"></div>
<pre>
$ sudo xboxdrv
</pre>
<div class="Pp"></div>
This will create /dev/input/js0 and allow you to access the gamepad from any
  game. To exit the driver press Ctrl-c.
<div class="Pp"></div>
By default xboxdrv will echo all controller events to the console, this makes it
  easy to see if things are properly working, but will eat a lot of CPU, thus it
  is strongly recomment to disabled that output with the <b>--silent</b> option.
<div class="Pp"></div>
The trigger buttons are handled by xboxdrv normally as axis, giving you analog
  feedback, while this reproduces the Xbox360 controller the most accurately, it
  will confuse many and only be useful in a few, racing games mainly. So in the
  majority of cases it is recomment to change the triggers to regular buttons
  via:
<div class="Pp"></div>
<pre>
$ xboxdrv --trigger-as-button
</pre>
<h2 class="Ss" title="Ss" id="USING_MULTIPLE_CONTROLLER"><a class="selflink" href="#USING_MULTIPLE_CONTROLLER">USING
  MULTIPLE CONTROLLER</a></h2>
If you want to use multiple wired controllers you need to start multiple
  instances of the xboxdrv driver and append the -i argument to select the
  appropriate controller like this:
<div class="Pp"></div>
<pre>
$ xboxdrv -i 1
</pre>
<div class="Pp"></div>
If you have multiple wireless controller you need to start multiple instances of
  the xboxdrv driver and append the <b>--wid</b> option like this:
<div class="Pp"></div>
<pre>
$ xboxdrv --wid 1
</pre>
<div class="Pp"></div>
You have to sync the wireless controller as usual.
<div class="Pp"></div>
To see a list of all the controllers that xboxdrv detects being connected to
  your system use:
<div class="Pp"></div>
<pre>
$ xboxdrv --list-controller
</pre>
<h2 class="Ss" title="Ss" id="HOTPLUGGING_AND_XBOXDRV_DAEMON"><a class="selflink" href="#HOTPLUGGING_AND_XBOXDRV_DAEMON">HOTPLUGGING
  AND XBOXDRV DAEMON</a></h2>
To allow hotplugging of gamepads xboxdrv has to be run in daemon mode. This is
  accomplished with the <b>--daemon</b> option:
<div class="Pp"></div>
<pre>
$ xboxdrv --daemon
</pre>
<div class="Pp"></div>
When launched in daemon mode xboxdrv will listen to udev events and thus be
  notified whenever a new USB device gets plugged into the computer. It will
  then match that device against its list of supported devices and launch a
  separate thread to handle that gamepad.
<div class="Pp"></div>
Note that xboxdrv will not allow an arbitrary large number of controllers to be
  used in that mode, it can only handle as many controllers as you have
  allocated controller slots at startup. New slots can be allocated with
  <b>--next-controller</b> and by default one slot is always allocated, thus to
  support three controller you would run it with:
<div class="Pp"></div>
<pre>
$ xboxdrv --daemon --next-controller --next-controller
</pre>
<div class="Pp"></div>
Each controller slot can be configured individually and you can limit which
  gamepad gets assigned to which slot with the <b>--match</b> option.
<div class="Pp"></div>
Note that xboxdrv will create the virtual uinput devices on startup, not when a
  gamepad gets plugged in, this allows to plug in gamepads even after a game or
  an application like XBMC has already been launched and still have it all
  function properly.
<div class="Pp"></div>
In daemon mode xboxdrv can be detached from the current shell via
  <b>--detach</b>, to get a handle on it to kill it you can write its pid via
  the <b>--pid-file</b>:
<div class="Pp"></div>
<pre>
$ sudo xboxdrv --daemon --detach --pid-file /var/run/xboxdrv.pid
</pre>
<h1 class="Sh" title="Sh" id="XBOXDRV_DAEMON_DBUS_INTERFACE"><a class="selflink" href="#XBOXDRV_DAEMON_DBUS_INTERFACE">XBOXDRV
  DAEMON DBUS INTERFACE</a></h1>
When Xboxdrv is run as daemon it will export some API functions via D-Bus, thus
  allowing to make configuration changes at runtime. The D-Bus interface can be
  accessed either by the numerous language bindings provided or via the generic
  command line tool <b>dbus-send</b> or by the more userfriendly
  <b>xboxdrvctl</b> tool. Examples below are given for the raw <b>dbus-send</b>.
<div class="Pp"></div>
Introspection is provided via the usual means:
<div class="Pp"></div>
<pre>
dbus-send --session --type=method_call --print-reply \
  --dest=org.seul.Xboxdrv /org/seul/Xboxdrv org.freedesktop.DBus.Introspectable.Introspect
<div class="Pp"></div>
dbus-send --session --type=method_call --print-reply \
  --dest=org.seul.Xboxdrv /org/seul/Xboxdrv/ControllerSlots/0 org.freedesktop.DBus.Introspectable.Introspect
<div class="Pp"></div>
dbus-send --session --type=method_call --print-reply \
  --dest=org.seul.Xboxdrv /org/seul/Xboxdrv/Daemon org.freedesktop.DBus.Introspectable.Introspect
</pre>
<div class="Pp"></div>
Status information on available slots, configuration and active controllers can
  be obtained via:
<div class="Pp"></div>
<pre>
dbus-send \
  --session --type=method_call --print-reply \
  --dest=org.seul.Xboxdrv /org/seul/Xboxdrv/Daemon  org.seul.Xboxdrv.Daemon.Status
</pre>
<div class="Pp"></div>
Setting the LED on controller 0 can be done via:
<div class="Pp"></div>
<pre>
dbus-send --session --type=method_call  --print-reply \
  --dest=org.seul.Xboxdrv  /org/seul/Xboxdrv/ControllerSlots/0  org.seul.Xboxdrv.Controller.SetLed int32:4
</pre>
<div class="Pp"></div>
Setting the rumble motors on controller 0 can be done via:
<div class="Pp"></div>
<pre>
dbus-send --session --type=method_call  --print-reply \
  --dest=org.seul.Xboxdrv  /org/seul/Xboxdrv/ControllerSlots/0  org.seul.Xboxdrv.Controller.SetRumble int32:255 int32:255
</pre>
<div class="Pp"></div>
Setting a specific controller slot configuration, just as <b>--toggle BTN</b>
  allows, can be done with:
<div class="Pp"></div>
<pre>
dbus-send --session --type=method_call  --print-reply \
  --dest=org.seul.Xboxdrv  /org/seul/Xboxdrv/ControllerSlots/0  org.seul.Xboxdrv.Controller.SetConfig int32:2
</pre>
<h1 class="Sh" title="Sh" id="TESTING"><a class="selflink" href="#TESTING">TESTING</a></h1>
Knowing how to test a xboxdrv configuration is absolutely crucial in
  understanding what is wrong in a given setup. Testing the configuration in a
  game is most often not helpful, since you won't see the true cause beyond
  endless layers of abstraction between you and the actual events. Luckily there
  are a few tools you can use to test, all of these are command line based and
  it is recomment that you get familar with them when you want to do any more
  complex configuration.
<h2 class="Ss" title="Ss" id="EVTEST"><a class="selflink" href="#EVTEST">EVTEST</a></h2>
evtest lets you read raw input events from <i>/dev/input/eventX</i>. The event
  devices are the very core of all event handling, things like the joystick
  devices are derived from the event device, so if you want to fix some issue on
  the joystick device, you have to fix the event device.
<div class="Pp"></div>
evtest is available in the tools/ directory or as part of your distribution in
  the package <i>evtest</i>. your distribution.
<h2 class="Ss" title="Ss" id="JSTEST"><a class="selflink" href="#JSTEST">JSTEST</a></h2>
jstest lets you read the output out of a joystick event device (/dev/input/js0).
<div class="Pp"></div>
jstest is available in the tools/ directory or as part of your distribution
  <i>joystick</i>.
<h2 class="Ss" title="Ss" id="SDL-JSTEST"><a class="selflink" href="#SDL-JSTEST">SDL-JSTEST</a></h2>
sdl-jstest lets you see events as games using SDL see them. This is very
  important when you want to set and test the SDL_LINUX_JOYSTICK environment
  variables.
<div class="Pp"></div>
It is currently available via:
<div class="Pp"></div>
<pre>
$ svn co svn://svn.berlios.de/windstille/trunk/sdl-jstest
</pre>
<div class="Pp"></div>
Or from the same Ubuntu PPA that also contains xboxdrv in the package
  <i>sdl-jstest</i>.
<h2 class="Ss" title="Ss" id="XEV"><a class="selflink" href="#XEV">XEV</a></h2>
xev lets you see the events that Xorg sees. Note however that you might not see
  all events, since some will be grapped by your Window manager before they
  reach xev, this is normal.
<div class="Pp"></div>
xev is part of every Linux distribution, on Ubuntu its available via:
<div class="Pp"></div>
<pre>
$ apt-get install x11-utils
</pre>
<h2 class="Ss" title="Ss" id="JSCALC_AND_JSCALIBRATOR"><a class="selflink" href="#JSCALC_AND_JSCALIBRATOR">JSCALC
  AND JSCALIBRATOR</a></h2>
Both of these tools lets you calibrate your gamepad, however with pretty much
  all current gamepads this is no longer needed and actually harmful as it might
  overwrite a perfectly good working configuration with a broken one (unplugging
  the gamepad or a reboot will fix that). So avoid them unless you clearly
  understand the issues of using them.
<div class="Pp"></div>
If your gamepad produces incorrect data and you do want to calibrate it you
  might want to check out the option <b>--calibration</b>, which lets you tweak
  the way xboxdrv interprets your gamepad data.
<h2 class="Ss" title="Ss" id="MOUSE"><a class="selflink" href="#MOUSE">MOUSE</a></h2>
No tools for testing the output on /dev/input/mouseX are known.
<h2 class="Ss" title="Ss" id="NOTE"><a class="selflink" href="#NOTE">NOTE</a></h2>
If the tools provide no output at all, this might not be due to a wrong
  configuration, but due to Xorg grabbing your event device and locking it, see
  Xorg section for possible fixes.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
The configurations below are just a few random examples, further examples can be
  found in the <i>examples/</i> directory of the xboxdrv source tree or in
  <i>/usr/share/doc/xboxdrv/examples/</i>.
<h2 class="Ss" title="Ss" id="TURNING_TRIGGERS_INTO_BUTTONS"><a class="selflink" href="#TURNING_TRIGGERS_INTO_BUTTONS">TURNING
  TRIGGERS INTO BUTTONS</a></h2>
By default xboxdrv will handle the trigger as analog axis, not buttons, while
  this is beneficial for racing games, it will confuse many other games, thus
  xboxdrv provides an easy way to change the handling into buttons via the
  <b>--trigger-as-button</b> option:
<div class="Pp"></div>
<pre>
$ xboxdrv --trigger-as-button
</pre>
<h2 class="Ss" title="Ss" id="CONFIGURE_A_DEADZONE"><a class="selflink" href="#CONFIGURE_A_DEADZONE">CONFIGURE
  A DEADZONE</a></h2>
Many gamepads don't center exactly at zero, but at random values around it. This
  'noise' can confuse some games and is thus be best filtered out, this can be
  accomplished with:
<div class="Pp"></div>
<pre>
$ xboxdrv --deadzone 25%
</pre>
<div class="Pp"></div>
The percentance is the amount of noise that will get filtered out, you can also
  give raw device values if you leave out the % sign. If you want to have a
  deadzone only on a specific axis you have to use axis filter:
<div class="Pp"></div>
<pre>
$ xboxdrv --buttonmap X1^deadzone:15000
</pre>
<h2 class="Ss" title="Ss" id="KEYBOARD_EMULATION"><a class="selflink" href="#KEYBOARD_EMULATION">KEYBOARD
  EMULATION</a></h2>
The following configuration will cause xboxdrv to emulate a keyboard, which can
  be useful for games that are played with keyboard, like Flash games or games
  that don't support a joystick. Since different games use different keyboard
  keys you might have to adjust the keybindings to fit the game:
<div class="Pp"></div>
<pre>
$ xboxdrv \
  --ui-clear \
  --ui-buttonmap a=XK_a,b=XK_b,x=XK_x,y=XK_y \
  --ui-buttonmap dl=XK_Left,dr=XK_Right,du=XK_Up,dd=XK_Down
</pre>
<h2 class="Ss" title="Ss" id="FIGHTING_GAMES:"><a class="selflink" href="#FIGHTING_GAMES:">FIGHTING
  GAMES:</a></h2>
In this configuration the left and right trigger get turned into digital
  buttons. All axis except the dpad are ignored. RB and RT are mapped to act as
  if buttons 1,2 and 3 are pressed simultaniously which is useful for some
  special attacks. Instead of using the native button names, the 1,2,3,...
  aliases are used, which makes things a little easier to read:
<div class="Pp"></div>
<pre>
$ xboxdrv \
  --dpad-only \
  --trigger-as-button \
  --buttonmap lb=1,x=2,y=3,lt=4,a=5,b=6 \
  --buttonmap rb=1,rb=2,rb=3 \
  --buttonmap rt=4,rt=5,rt=6
</pre>
<h2 class="Ss" title="Ss" id="CH_FLIGHTSTICK_EMULATION_IN_DOSBOX:"><a class="selflink" href="#CH_FLIGHTSTICK_EMULATION_IN_DOSBOX:">CH
  FLIGHTSTICK EMULATION IN DOSBOX:</a></h2>
In <i>dosbox.conf</i> set:
<div class="Pp"></div>
<pre>
[joystick]
joysticktype = ch
</pre>
<div class="Pp"></div>
Start xboxdrv with:
<div class="Pp"></div>
<pre>
$ xboxdrv -s \
  --trigger-as-zaxis --square-axis \
  --relative-axis y2=64000 --axismap -y2=x2,x2=y2
</pre>
<div class="Pp"></div>
Your right analog stick will act as trottle control, the trigger as rudder.
  Using <b>--modifier</b> to install a four-way restrictor might also be worth a
  consideration to not accidently touch the throttle when the rudder is moved.
<h2 class="Ss" title="Ss" id="USING_MOUSE_EMULATION_AND_JOYSTICK_AT_THE_SAME_TIME"><a class="selflink" href="#USING_MOUSE_EMULATION_AND_JOYSTICK_AT_THE_SAME_TIME">USING
  MOUSE EMULATION AND JOYSTICK AT THE SAME TIME</a></h2>
To use mouse emulation and joystick at the same time you have to register two
  configuration with xboxdrv, this works via:
<div class="Pp"></div>
<pre>
$ xboxdrv --next-config --mouse
</pre>
<div class="Pp"></div>
The <b>--next-config</b> option will open up a second configuration and all
  configuration options on the right side of it will go there, while everything
  on the left side of it will go into the first configuration. Toggling between
  the configurations works with the guide button, you can have as many
  configuratios as you want.
<h2 class="Ss" title="Ss" id="MAPPING_EVERY_BUTTON_MULTIPLE"><a class="selflink" href="#MAPPING_EVERY_BUTTON_MULTIPLE">MAPPING
  EVERY BUTTON MULTIPLE</a></h2>
Some games might require more buttons then your gamepad has, in those situation
  it can be useful to map a button twice by using shifted buttons:
<div class="Pp"></div>
<pre>
$ xboxdrv \
  --ui-clear \
  --ui-axismap X1=ABS_X,Y1=ABS_Y \
  --ui-buttonmap a=JS_0,b=JS_1,x=JS_2,y=JS_3 \
  --ui-buttonmap lb+a=JS_4,lb+b=JS_5,lb+x=JS_6,lb+y=JS_7 \
  --ui-buttonmap rb+a=JS_8,rb+b=JS_9,rb+x=JS_10,rb+y=JS_11
.fi
</pre>
<div class="Pp"></div>
<pre>
Here all face buttons are get mapped three times, once when
pressed normally, once when pressed while LB is held down and
once when RB is held down, thus given you for the six buttons
12 virtual ones.
</pre>
<h2 class="Ss" title="Ss" id="SAUERBRATEN"><a class="selflink" href="#SAUERBRATEN">SAUERBRATEN</a></h2>
First analogstick gets mapped te cursor keys, second analogstick gets mapped to
  mouse. Note: This is just an incomplete example, not a perfectly playable
  configuration, you have to do tweaking yourself.
<div class="Pp"></div>
<pre>
$ xboxdrv \
  --ui-axismap x2=REL_X:10,y2=REL_Y:-10,x1=KEY_LEFT:KEY_RIGHT,y1=KEY_UP:KEY_DOWN \
  --ui-buttonmap a=BTN_RIGHT,b=BTN_LEFT,x=BTN_EXTRA \
  --ui-buttonmap rb=KEY_5,lb=KEY_6,lt=BTN_LEFT,rt=BTN_RIGHT \
  --ui-buttonmap y=KEY_ENTER,dl=KEY_4,dr=KEY_2,du=KEY_1,dd=KEY_3,back=KEY_TAB,start=KEY_ESC \
  -s --deadzone 6000  --dpad-as-button --trigger-as-button
</pre>
<h2 class="Ss" title="Ss" id="WARSOW"><a class="selflink" href="#WARSOW">WARSOW</a></h2>
Note: This is just an incomplete example, not a perfectly playable
  configuration, you have to do tweaking yourself.
<div class="Pp"></div>
<pre>
$ xboxdrv \
  --ui-axismap x2=REL_X:10,y2=REL_Y:-10,x1=KEY_A:KEY_D,y1=KEY_W:KEY_S \
  --ui-buttonmap a=KEY_LEFTSHIFT,b=BTN_C,x=BTN_EXTRA,y=KEY_C \
  --ui-buttonmap lb=BTN_RIGHT,rb=KEY_SPACE \
  --ui-buttonmap lt=KEY_Z,rt=BTN_LEFT \
  --ui-buttonmap dl=KEY_4,dr=KEY_2,du=REL_WHEEL:-1:150,dd=REL_WHEEL:1:150 \
  --ui-buttonmap back=KEY_TAB,start=KEY_ESC \
  -s --deadzone 6000 --dpad-as-button --trigger-as-button
</pre>
<h1 class="Sh" title="Sh" id="WRITING_START-UP_SCRIPTS_FOR_GAMES"><a class="selflink" href="#WRITING_START-UP_SCRIPTS_FOR_GAMES">WRITING
  START-UP SCRIPTS FOR GAMES</a></h1>
When you want full game specific configurability and automatic launching of
  xboxdrv, it is easiest to write little startup scripts for your games that
  will launch xboxdrv, launch your game and then when the game is finished tear
  down xboxdrv:
<div class="Pp"></div>
<pre>
#!/bin/sh
<div class="Pp"></div>
exec xboxdrv \
  --trigger-as-button -s \
  -- \
  your_favorite_game
<div class="Pp"></div>
# EOF #
</pre>
<div class="Pp"></div>
Here <i>your_favorite_game</i> is the executable of your game and is passed to
  xboxdrv as last argument. This will cause xboxdrv to start the game and keep
  running as long as the game is running, when the game is done, xboxdrv will
  quit automatically.
<div class="Pp"></div>
If you want to pass parameters to the game you have to add a <b>--</b>
  separator, as otherwise your options to the game would be eaten up by xboxdrv.
<h1 class="Sh" title="Sh" id="SDL_NOTES"><a class="selflink" href="#SDL_NOTES">SDL
  NOTES</a></h1>
To let SDL know which axis act as a hat and which act as normal axis you have to
  set an environment variable:
<div class="Pp"></div>
<pre>
$ SDL_LINUX_JOYSTICK=&quot;'Xbox Gamepad (userspace driver)' 6 1 0&quot;
$ export SDL_LINUX_JOYSTICK
</pre>
<div class="Pp"></div>
You might also need in addition use this (depends on the way SDL was compiled):
<div class="Pp"></div>
<pre>
$ SDL_JOYSTICK_DEVICE=&quot;/dev/input/js0&quot;
$ export SDL_JOYSTICK_DEVICE
</pre>
<div class="Pp"></div>
This will let the DPad act as Hat in SDL based application. For many games the
  driver will work without this, but especially in Dosbox this variable is very
  important.
<div class="Pp"></div>
If you use options in xboxdrv that change the number of axis you have to adjust
  the variable accordingly, see:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&#x27E8;ftp://ptah.lnf.kth.se/pub/misc/sdl-env-vars&#x27E9;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">SDL_LINUX_JOYSTICK</dt>
  <dd class="It-tag">Special joystick configuration string for linux. The format
      is <b>&quot;name numaxes numhats numballs&quot;</b> where name is the name
      string of the joystick (possibly in single quotes), and the rest are the
      number of axes, hats and balls respectively.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">SDL_JOYSTICK_DEVICE</dt>
  <dd class="It-tag">Joystick device to use in the linux joystick driver, in
      addition to the usual: <i>/dev/js*</i>, <i>/dev/input/event*</i>,
      <i>/dev/input/js*</i></dd>
</dl>
<h1 class="Sh" title="Sh" id="TROUBLESHOOTING"><a class="selflink" href="#TROUBLESHOOTING">TROUBLESHOOTING</a></h1>
<h2 class="Ss" title="Ss" id="&quot;NO_XBOX_OR_XBOX360_CONTROLLER_FOUND&quot;"><a class="selflink" href="#&quot;NO_XBOX_OR_XBOX360_CONTROLLER_FOUND&quot;">&quot;NO
  XBOX OR XBOX360 CONTROLLER FOUND&quot;</a></h2>
This means that either your controller isn't plugged in or is not recognized by
  the driver. To fix this you need to know the idVendor and the idProduct
  numbers, which you can find out via:
<div class="Pp"></div>
<pre>
$ lsusb -v
</pre>
<div class="Pp"></div>
Once done you can try to add them to this array in <i>src/xpad_device.cpp</i>:
<div class="Pp"></div>
<pre>
XPadDevice xpad_devices[] = { ... }
</pre>
<div class="Pp"></div>
If you have success with that, send a patch to &lt;grumbel@gmail.com&gt;, if
  not, contact me too, I might be able to provide additional help.
<div class="Pp"></div>
As an alternative you can also use the --device and --type option to enforce a
  USB device as well as a controller type an bypass any auto detection.
<h2 class="Ss" title="Ss" id="&quot;UNKNOWN_DATA:_BYTES:_3_DATA:_...&quot;"><a class="selflink" href="#&quot;UNKNOWN_DATA:_BYTES:_3_DATA:_...&quot;">&quot;UNKNOWN
  DATA: BYTES: 3 DATA: ...&quot;</a></h2>
This means that your controller is sending data that isn't understood by the
  driver. If your controller still works, you can just ignore it, the Xbox360
  controller seems to send out useless data every now and then. If your
  controller does not work and you get plenty of those lines when you move the
  sticks or press buttons it means that your controller talks an un-understood
  protocol and some reverse enginiering is required. Contact
  &lt;grumbel@gmail.com&gt; and include the output of:
<div class="Pp"></div>
<pre>
$ lsusb -v
</pre>
<div class="Pp"></div>
Along with all the &quot;Unknown data&quot; lines you get.
<h2 class="Ss" title="Ss" id="&quot;ERROR:_NO_STUITABLE_UINPUT_DEVICE_FOUND&quot;"><a class="selflink" href="#&quot;ERROR:_NO_STUITABLE_UINPUT_DEVICE_FOUND&quot;">&quot;ERROR:
  NO STUITABLE UINPUT DEVICE FOUND&quot;</a></h2>
Make sure that uinput and joydev kernel modules are loaded. Make sure that you
  have a /dev/input/uinput, /dev/uinput or /dev/misc/uinput and permissions to
  access it.
<div class="Pp"></div>
Before reporting this as a bug make sure you have tested if the driver itself
  works with:
<div class="Pp"></div>
<pre>
$ xboxdrv --no-uinput -v
</pre>
<h2 class="Ss" title="Ss" id="THE_WIRELESS_CONTROLLER_DOESN'T_WORK"><a class="selflink" href="#THE_WIRELESS_CONTROLLER_DOESN'T_WORK">THE
  WIRELESS CONTROLLER DOESN'T WORK</a></h2>
You have to sync the controller befor it can be used, restart of the driver
  isn't needed and the driver should let you now when it recieves a connection
  after you sync the controller.
<h2 class="Ss" title="Ss" id="KEYBOARD_EMULATION"><a class="selflink" href="#KEYBOARD_EMULATION">KEYBOARD
  EMULATION</a></h2>
When you try to let xboxdrv send a keyboard events via <b>--ui-buttonmap</b> or
  <b>--ui-axismap</b> Xorg must register the device as keyboard device to work
  properly. This seems to work automatically when you bind more then two
  keyboard keys, if you bind less you need to create the file
  <i>/etc/hal/fdi/preprobe/xboxdrv.fdi</i> containing:
<div class="Pp"></div>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;deviceinfo version=&quot;0.2&quot;&gt;
  &lt;device&gt;
    &lt;match key=&quot;input.product&quot; string=&quot;Xbox Gamepad (userspace driver) - Keyboard Emulation&quot;&gt;
      &lt;addset key=&quot;info.capabilities&quot; type=&quot;strlist&quot;&gt;input.keys&lt;/addset&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;
</pre>
<div class="Pp"></div>
This will tell HAL and later Xorg that xboxdrv acts as keyboard.
<h2 class="Ss" title="Ss" id="WACOM_ISSUES"><a class="selflink" href="#WACOM_ISSUES">WACOM
  ISSUES</a></h2>
In some older kernels a Wacom graphic tablet creates a joystick device, so
  xboxdrv or any other real joysticks ends up as <i>/dev/input/js1</i> instead
  of <i>/dev/input/js0</i>. In many games this causes the joystick to not
  function any more.
<div class="Pp"></div>
A temporary workaround for this is to simply delete the joystick device js0 and
  replace it with a symbolic link js1 via:
<div class="Pp"></div>
<pre>
$ sudo ln -sf /dev/input/js1 /dev/input/js0
</pre>
<div class="Pp"></div>
This workaround will only last till the next reboot, since the device names are
  dynamically created, but for the time being there doesn't seem to any other
  way to easily work around this issue.
<div class="Pp"></div>
In newer kernels this issue is fixed.
<h2 class="Ss" title="Ss" id="UINPUT_ISSUES"><a class="selflink" href="#UINPUT_ISSUES">UINPUT
  ISSUES</a></h2>
On Ubuntu 9.04 the permissions of the uinput device have changed to 0640,
  meaning only root has access to the device. To change this back so that users
  in the group root have access the device and in turn can run xboxdrv without
  sudo you have to create a file called
  <i>/etc/udev/rules.d/55-permissions-uinput.rules</i> with the content:
<div class="Pp"></div>
<pre>
KERNEL==&quot;uinput&quot;, MODE=&quot;0660&quot;, GROUP=&quot;root&quot;
</pre>
<h2 class="Ss" title="Ss" id="WINE_ISSUES"><a class="selflink" href="#WINE_ISSUES">WINE
  ISSUES</a></h2>
When using the Xbox360 gamepad in Wine it is not specially handled as Xbox360
  gamepad, but as generic DirectInput gamepad. This means games will not display
  the proper button labels, but just numbers (i.e. 'Btn1' instead of 'A' for
  example). Aside from that it should work fine.
<div class="Pp"></div>
XInput support (the Microsoft DirectInput replacment, not the Xorg xinput) is as
  of January 2011 not implemented in Wine, so games that require XInput and
  don't have an DirectInput fallback will not work with a Xbox360 controller,
  unofficial patches however do exist.
<h1 class="Sh" title="Sh" id="XORG_ISSUES"><a class="selflink" href="#XORG_ISSUES">XORG
  ISSUES</a></h1>
If you start xboxdrv and instead of having a fully working joystick, you end up
  controlling the mouse that might be due to recent changes in Xorg and its
  device hotplug handling. There are four workarounds, the one that involves
  editing <i>/etc/hal/fdi/policy/preferences.fdi</i> is the recommont one.
<h2 class="Ss" title="Ss" id="TEMPORARY_WORKAROUND_USING_HAL-DEVICE"><a class="selflink" href="#TEMPORARY_WORKAROUND_USING_HAL-DEVICE">TEMPORARY
  WORKAROUND USING HAL-DEVICE</a></h2>
Get the device id from hal:
<div class="Pp"></div>
<pre>
$ hal-find-by-property --key 'info.product' --string 'Xbox Gamepad (userspace driver)'
</pre>
<div class="Pp"></div>
Then remove the device from hal with:
<div class="Pp"></div>
<pre>
$ hal-device -r $DEVICEID
</pre>
<h2 class="Ss" title="Ss" id="TEMPORARY_WORKAROUND_USING_XINPUT"><a class="selflink" href="#TEMPORARY_WORKAROUND_USING_XINPUT">TEMPORARY
  WORKAROUND USING XINPUT</a></h2>
Second workaround works with xinput:
<div class="Pp"></div>
<pre>
$ xinput list
$ xinput set-int-prop $DEVICEID 'Device Enabled' 32 0
</pre>
<h2 class="Ss" title="Ss" id="PERMANENT_WORKAROUND_USING_.FDI_FILES"><a class="selflink" href="#PERMANENT_WORKAROUND_USING_.FDI_FILES">PERMANENT
  WORKAROUND USING .FDI FILES</a></h2>
The former two workarounds are just temporary and have to be redone after each
  start of xboxdrv, the last workaround is a permanent one:
<div class="Pp"></div>
You have to edit:
<div class="Pp"></div>
<i>/etc/hal/fdi/policy/preferences.fdi</i>
<div class="Pp"></div>
And insert the following lines:
<div class="Pp"></div>
<pre>
&lt;match key=&quot;input.product&quot; string=&quot;Xbox Gamepad (userspace driver)&quot;&gt;
  &lt;remove key=&quot;input.x11_driver&quot; /&gt;
&lt;/match&gt;
</pre>
<h2 class="Ss" title="Ss" id="PERMANENT_WORKAROUND_BY_DISABLING_DEVICE_AUTO_DETECTION"><a class="selflink" href="#PERMANENT_WORKAROUND_BY_DISABLING_DEVICE_AUTO_DETECTION">PERMANENT
  WORKAROUND BY DISABLING DEVICE AUTO DETECTION</a></h2>
A fourth workaround involved disabling the autodetection of Xorg completly, you
  can do that by adding the following lines to <i>/etc/X11/xorg.conf</i>:
<div class="Pp"></div>
<pre>
Section &quot;ServerFlags&quot;
  Option &quot;AutoAddDevices&quot; &quot;False&quot;
EndSection
</pre>
<div class="Pp"></div>
Note that without auto detection you will have to manually configure all your
  mice and keyboards or your Xorg Server won't start up properly. So unless you
  are already familiar with editing Xorg you better avoid this workaround.
  Workaround 3) has basically the same effect, except that auto detection only
  gets disabled for the single device it is causing problems.
<h1 class="Sh" title="Sh" id="FORCE_FEEDBACK_PROGRAMMING"><a class="selflink" href="#FORCE_FEEDBACK_PROGRAMMING">FORCE
  FEEDBACK PROGRAMMING</a></h1>
For documentation on the FF interface see:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">&#x27E8;http://github.com/github/linux-2.6/blob/f3b8436ad9a8ad36b3c9fa1fe030c7f38e5d3d0b/Documentation/input/ff.txt&#x27E9;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag"><i>/usr/include/linux/input.h</i></dd>
</dl>
<div class="Pp"></div>
Additional, non Linux related, force feedback related information can be found
  at:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">
    <br/>
    
      &#x27E8;http://www.immersion.com/developer/downloads/ImmFundamentals/HTML/&#x27E9;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">
    <br/>
    
      &#x27E8;http://msdn.microsoft.com/en-us/library/bb219655(VS.85).aspx&#x27E9;</dd>
</dl>
<div class="Pp"></div>
<b>fftest</b> is an application you can use to test the force feedback
  interface.
<div class="Pp"></div>
Force feedback is disabed by default since it causes trouble in certain
  application. &quot;Tomb Raider: Legend&quot; for example when run in Wine
  crashes at startup when rumble is enabled, while it works perfectly normal
  when rumble is disabled.
<h1 class="Sh" title="Sh" id="BUGS"><a class="selflink" href="#BUGS">BUGS</a></h1>
<h2 class="Ss" title="Ss" id="X11_KEYSYM_ISSUES"><a class="selflink" href="#X11_KEYSYM_ISSUES">X11
  KEYSYM ISSUES</a></h2>
X11 keysyms might not work correctly in <b>--ui-buttonmap a=XK_Foobar</b> when
  Foobar is mapped to multiple keycodes in the keymap.
<div class="Pp"></div>
Workaround: Use <b>KEY_</b> instead or cleanup your keymap
<div class="Pp"></div>
Newer versions of Xorg will also do perform some auto configuration that might
  lead to your keymap being switched whenever a new keyboard is detected, in
  cases of custom Xmodmaps this might confuse xboxdrv and make the XK_ style
  names unusable. No workaround for that is known right now.
<h2 class="Ss" title="Ss" id="NON-INTERRUPTABLE_PROCESSES_DUE_TO_FORCE_FEEDBACK"><a class="selflink" href="#NON-INTERRUPTABLE_PROCESSES_DUE_TO_FORCE_FEEDBACK">NON-INTERRUPTABLE
  PROCESSES DUE TO FORCE FEEDBACK</a></h2>
Force feedback support is brittle, if you Ctrl-c the driver in the wrong moment
  you will end up with a dead uninterruptable process and basically have to
  reboot. This looks like it might be a kernel issue and not a xboxdrv one.
<div class="Pp"></div>
Workaround: Kill the app that uses xboxdrv before xboxdrv itself.
<h2 class="Ss" title="Ss" id="QUESTIONS,_BUG_REPORTS_AND_FEATURE_REQUESTS"><a class="selflink" href="#QUESTIONS,_BUG_REPORTS_AND_FEATURE_REQUESTS">QUESTIONS,
  BUG REPORTS AND FEATURE REQUESTS</a></h2>
Bug reports and feature request can be report to the xboxdrv issue tracker at:
<div class="Pp"></div>
<br/>
 &#x27E8;https://github.com/Grumbel/xboxdrv/issues/new&#x27E9;
<div class="Pp"></div>
General questions and requests for configuration help should be directed to the
  xboxdrv mailing list at:
<div class="Pp"></div>
<br/>
 &#x27E8;http://groups.google.com/group/xboxdrv&#x27E9;
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright &#x00A9; 2010-2011 Ingo Ruhnke &lt;grumbel@gmail.com&gt; License
  GPLv3+: GNU GPL version 3 or later
<br/>
 &#x27E8;http://gnu.org/licenses/gpl.html&#x27E9; . This is free software: you
  are free to change and redistribute it. There is NO WARRANTY, to the extent
  permitted by law.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>xboxdrvctl</b>(1), <b>evtest</b>(1), <b>jstest</b>(1), <b>jstest-gtk</b>(1),
  <b>xev</b>(1), <b>fftest</b>(1), <b>lsusb</b>(1)</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011-07-20</td>
    <td class="foot-os">0.8.3</td>
  </tr>
</table>
</body>
</html>
