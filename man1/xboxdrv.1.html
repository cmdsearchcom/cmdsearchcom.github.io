<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:43:54 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>xboxdrv (1) User Commands xboxdrv (1)</p>

<p style="margin-top: 1em">NAME <br>
xboxdrv - A Xbox/Xbox360 gamepad driver that works in
userspace</p>

<p style="margin-top: 1em">SYNOPSIS <br>
xboxdrv [OPTION]... [--] [COMMAND] [ARGUMENTS]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
xboxdrv is a driver for Xbox and Xbox360 gamepads. It works
by reading the raw data from the controller with the
userspace library libusb and then passes the interpreted
data to <br>
the kernel via uinput. This allows xboxdrv to provide
regular joystick and event devices, which makes it
compatible with all Linux software.</p>

<p style="margin-top: 1em">Aside from the pure driver,
xboxdrv also includes a rich set of configuration options
that allow you to tweak the abilities of the virtual input
devices that xboxdrv will create. <br>
This includes basic button and axis remapping, as well as
more complicated things like mouse and keyboard emulation,
auto-fire and throttle control emulation.</p>

<p style="margin-top: 1em">It is also possible for xboxdrv
to read input data directly from an event device, this
allows the use of the configurability of xboxdrv on regular
PC joysticks, keyboards and <br>
mice and thus lets xboxdrv serve a similar purpose as
joy2key. See the option --evdev below for more
information.</p>

<p style="margin-top: 1em">When a COMMAND is provided
xboxdrv will launch that application and be running till
that application exits. This is a convenience function to
make it easier to use xboxdrv in <br>
wrapper scripts. See the section [Writing Start-Up Scripts
for Games] for more information.</p>

<p style="margin-top: 1em">OPTIONS <br>
GENERAL OPTIONS <br>
-h, --help <br>
Display help text and exit.</p>

<p style="margin-top: 1em">-V, --version <br>
Print the version number and exit.</p>

<p style="margin-top: 1em">-v, --verbose <br>
Print verbose messages.</p>

<p style="margin-top: 1em">--debug <br>
Print even more verbose messages then --verbose.</p>

<p style="margin-top: 1em">-s, --silent <br>
Do not display controller events on the terminal. For
regular use this option should always be used as output data
to the terminal can eat up quite a bit of CPU.</p>

<p style="margin-top: 1em">--quiet <br>
Do not display startup text and suppress most other
output.</p>

<p style="margin-top: 1em">--priority PRIORITY <br>
Possible values for PRIORITY are &quot;normal&quot; and
&quot;realtime&quot;. Realtime scheduling gives the xboxdrv
process higher priority and thus allows it to function
properly even when <br>
the machine is under load.</p>

<p style="margin-top: 1em">Note that realtime priority
requires running xboxdrv as root, when running xboxdrv as
user there is no way to increase the priority.</p>

<p style="margin-top: 1em">This option is deprecated, use
chrt(1) instead to achive the same effect.</p>

<p style="margin-top: 1em">LIST OPTIONS <br>
--help-led <br>
List possible values for the led.</p>

<p style="margin-top: 1em">--help-devices <br>
List supported devices.</p>

<p style="margin-top: 1em">--list-supported-devices <br>
List supported devices (used by xboxdrv-daemon.py).</p>

<p style="margin-top: 1em">--list-supported-devices-xpad
<br>
List supported devices in xpad.c style.</p>

<p style="margin-top: 1em">--help-abs <br>
List all allowed EV_ABS symbols.</p>

<p style="margin-top: 1em">--help-rel <br>
List all allowed EV_REL symbols.</p>

<p style="margin-top: 1em">--help-key <br>
List all allowed EV_KEY symbols.</p>

<p style="margin-top: 1em">--help-x11keysym <br>
List all allowed X11 Keysym symbols.</p>

<p style="margin-top: 1em">--help-axis <br>
List all allowed XboxAxis symbols.</p>

<p style="margin-top: 1em">--help-button <br>
List all allowed XboxButton symbols.</p>

<p style="margin-top: 1em">--help-all <br>
List all symbols that can be used in --ui-buttonmap,
--ui-axismap, --buttonmap and --axismap. This option is the
same as --help-abs, --help-rel, --help-key, <br>
--help-x11keysym, --help-axis and --help-button.</p>

<p style="margin-top: 1em">CONFIG FILE OPTIONS <br>
-c, --config FILE <br>
Reads configuration information from FILE. Configurations
from file are handling as if they would be command line
options at the position of --config FILE.</p>

<p style="margin-top: 1em">The syntax of FILE is the
familiar INI syntax used for many configuration files.
Regular key/value pairs must go into the [xboxdrv] section.
&rsquo;#&rsquo; and &rsquo;;&rsquo; can be used for <br>
comments. Key names have for most part the same name as
command line options. Command line options that take a list
of input mappings (--ui-buttonmap, --ui-axismap, <br>
--evdev-absmap, ...) can be split of into their own section
for better readability.</p>

<p style="margin-top: 1em">The examples/ directory contains
some example configuration files.</p>

<p style="margin-top: 1em">[xboxdrv] <br>
silent=true <br>
deadzone=6000 <br>
dpad-as-button=true <br>
trigger-as-button=true</p>

<p style="margin-top: 1em">[ui-axismap] <br>
x2=REL_X:10 <br>
y2=REL_Y:-10 <br>
x1=KEY_A:KEY_D <br>
y1=KEY_W:KEY_S</p>

<p style="margin-top: 1em">[ui-buttonmap] <br>
a=KEY_LEFTSHIFT <br>
b=BTN_C <br>
x=BTN_EXTRA <br>
y=KEY_C</p>

<p style="margin-top: 1em">[ui-buttonmap] <br>
lb=BTN_RIGHT <br>
rb=KEY_SPACE</p>

<p style="margin-top: 1em">[ui-buttonmap] <br>
lt=KEY_Z <br>
rt=BTN_LEFT</p>

<p style="margin-top: 1em">[ui-buttonmap] <br>
dl=KEY_4 <br>
dr=KEY_2 <br>
du=REL_WHEEL:-1:150 <br>
dd=REL_WHEEL:1:150</p>

<p style="margin-top: 1em">[ui-buttonmap] <br>
back=KEY_TAB <br>
start=KEY_ESC</p>

<p style="margin-top: 1em"># EOF #</p>

<p style="margin-top: 1em">--alt-config FILE <br>
A shortcut for writing --next-config --config FILE.</p>

<p style="margin-top: 1em">To load multiple configuration
options use:</p>

<p style="margin-top: 1em">xboxdrv --config first.ini
--alt-config second.ini --alt-config third.ini</p>

<p style="margin-top: 1em">-o, --option NAME=VALUE <br>
Set an option as if it would come from a config file from
the command line.</p>

<p style="margin-top: 1em">--write-config FILE <br>
Write an example configuration file to FILE.</p>

<p style="margin-top: 1em">DAEMON OPTIONS <br>
-D, --daemon <br>
Run xboxdrv as daemon. If this option is given xboxdrv will
listen to udev for USB connection events and launch driver
threads for newly connected controllers.</p>

<p style="margin-top: 1em">Configuration options can still
be supplied as usual. Note however that xboxdrv when run as
daemon will not create new uinput devices on demand, instead
it will only cre&acirc; <br>
ate devices once at startup for the given configurations and
then assign new controllers to these configurations. While
this means xboxdrv can&rsquo;t support an unlimited
num&acirc; <br>
ber of controllers, it also means that xboxdrv can allow hot
plugging even for applications that don&rsquo;t support it
themselves, as applications will only see the permanent <br>
device files, not the controller that xboxdrv will change
around under the hood.</p>

<p style="margin-top: 1em">An example configuration that
supports three controller would look like this:</p>

<p style="margin-top: 1em">xboxdrv --daemon # config
options for the first controller <br>
--next-controller # config options for the second controller
<br>
--next-controller <br>
# config options for the third controller</p>

<p style="margin-top: 1em">The --match option can be used
to limit the controller slots to only those controllers that
match the given RULE and thus be used to assign
configurations only to specific <br>
controllers.</p>

<p style="margin-top: 1em">--detach <br>
Detaches xboxdrv from the current shell, only valid if
--daemon is given.</p>

<p style="margin-top: 1em">--pid-file FILE <br>
Write the xboxdrv daemon process id to FILE.</p>

<p style="margin-top: 1em">--dbus BUS <br>
Set which bus type xboxdrv should connect to. Allowed values
for BUS are session, system, disabled and auto. The default
is auto, which will detect the appropriate bus <br>
type depending on if xboxdrv is run as root (system or as
user (session). Running with disabled will disable D-Bus
support completely.</p>

<p style="margin-top: 1em">--on-connect EXE <br>
Launches EXE when a controller gets connected. As arguments
&quot;BUSDEV:DEVNUM&quot;, &quot;idVendor:idProduct&quot;,
&quot;NAME are provided.</p>

<p style="margin-top: 1em">--on-disconnect EXE <br>
Launches EXE when a controller gets disconnected. As
arguments &quot;BUSDEV:DEVNUM&quot;,
&quot;idVendor:idProduct&quot;, &quot;NAME are provided.</p>

<p style="margin-top: 1em">DEVICE OPTIONS <br>
-L, --list-controller <br>
List available controllers on the system.</p>

<p style="margin-top: 1em">-i, --id N <br>
Use controller with id N (default: 0), use --list-controller
to obtain a list of available controller.</p>

<p style="margin-top: 1em">-w, --wid N <br>
Use wireless controller with wid N (default: 0).</p>

<p style="margin-top: 1em">--device-by-path BUS:DEV <br>
Use the controller at BUS:DEV, do not do any automatic
scanning. Useful for cases when a controller isn&rsquo;t
known by xboxdrv, but supports one of the given
protocols.</p>

<p style="margin-top: 1em">--device-by-id VENDOR:PRODUCT
<br>
Use device that matches VENDOR:PRODUCT (as returned by
lsusb). Useful for cases when a controller isn&rsquo;t known
by xboxdrv, but supports one of the given protocols.</p>

<p style="margin-top: 1em">--type TYPE <br>
Ignore autodetection and enforce the controller type.
Possible values for TYPE:</p>

<p style="margin-top: 1em">&Acirc;&middot; xbox</p>

<p style="margin-top: 1em">&Acirc;&middot; xbox-mat</p>

<p style="margin-top: 1em">&Acirc;&middot; xbox360</p>

<p style="margin-top: 1em">&Acirc;&middot;
xbox360-wireless</p>

<p style="margin-top: 1em">&Acirc;&middot;
xbox360-guitar</p>

<p style="margin-top: 1em">&Acirc;&middot; firestorm</p>

<p style="margin-top: 1em">&Acirc;&middot;
firestorm-vsb</p>

<p style="margin-top: 1em">&Acirc;&middot; saitek-p2500</p>

<p style="margin-top: 1em">&Acirc;&middot; generic-usb</p>

<p style="margin-top: 1em">The generic-usb type is a
special type that will work with any USB controller, it will
however not interpret the input it gets, but just dump it to
the console for development <br>
purposes. See --generic-usb-spec for further
information.</p>

<p style="margin-top: 1em">-d, --detach-kernel-driver <br>
Detaches the kernel driver that is currently associated with
the given device. This is useful when you have the xpad
module loaded and want to use xboxdrv without unload&acirc;
<br>
ing it.</p>

<p style="margin-top: 1em">--generic-usb-spec
NAME=VALUE,... <br>
Allows to specify from which endpoint generic-usb will read.
The spec as the form of NAME=VALUE,.... Allowed values
are:</p>

<p style="margin-top: 1em">vid=HEX <br>
The vendor id of the controller to which this spec
applies</p>

<p style="margin-top: 1em">pid=HEX <br>
The product id of the controller to which this spec
applies</p>

<p style="margin-top: 1em">if=NUM The interface from which
GenericUSBController should be read</p>

<p style="margin-top: 1em">ep=NUM The endpoint from which
GenericUSBController should be read</p>

<p style="margin-top: 1em">EVDEV OPTION <br>
--evdev DEVICE <br>
Allows you to read input data from a regular event device.
This allows you to use xboxdrv on regular PC joysticks. The
data that is read from the event device is converted <br>
internally into a XboxMsg object and then passed through the
same configuration pipeline as it would be for a regular
Xbox360 controller. This allows you to make use of <br>
all the regular configurability, but limits you to the
number of axis and buttons that an Xbox360 controller
provides.</p>

<p style="margin-top: 1em">As a regular PC joystick will
most likely already create a /dev/input/jsX device by
itself, you might need to get rid of that so that a game
will properly detect the joy&acirc; <br>
stick device created by xboxdrv. The easiest way to
accomplish that is to simply delete the old joystick and
rename the device that xboxdrv created to /dev/input/js0.
When <br>
you use udev, this operation should be harmless and
automatically reverse itself when you remove the controller
and plug it back in or when you reboot the computer.</p>

<p style="margin-top: 1em">--evdev-debug <br>
The evdev event handler will print all received events to
stdout, this makes it easy to see which events a given
controller sends.</p>

<p style="margin-top: 1em">--evdev-no-grab <br>
By default the evdev driver will grab the device, thus
making it impossible for other applications to receive
events from that device. This is done to avoid confusing
ap&acirc; <br>
plications, as otherwise an app would receive every event
twice, once from the original device and once from the
virtual xboxdrv one. In some cases this behaviour is
unde&acirc; <br>
sired, such when mapping only an otherwise unhandled subset
of keys of an device, i.e. mapping the multimedia keys on a
keyboard, so this option turns the grab off.</p>

<p style="margin-top: 1em">--evdev-absmap ABSMAP,... <br>
ABSMAP = EVDEV_ABS [ &quot;+&quot;, &quot;-&quot; ]
&quot;=&quot; XBOXAXIS ;</p>

<p style="margin-top: 1em">Sets how evdev events are mapped
to Xbox axis events. An example configuration would look
like this:</p>

<p style="margin-top: 1em">--evdev-absmap
ABS_X=x1,ABS_Y=y1,ABS_RZ=x2,ABS_THROTTLE=y2,ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y</p>

<p style="margin-top: 1em">xboxdrv will output on startup a
full list of event names that the given event device
supports and that can be used in place of EVDEV_ABS.</p>

<p style="margin-top: 1em">It is also possible to map
half-axis with a command like:</p>

<p style="margin-top: 1em">--evdev-absmap
ABS_Y+=LT,ABS_Y-=RT</p>

<p style="margin-top: 1em">This will map the upward
movement of the Y axis to the left trigger and the downward
movement to the right trigger.</p>

<p style="margin-top: 1em">--evdev-keymap KEYMAP <br>
Sets how evdev events are mapped to Xbox controller events.
An example configuration would look like this:</p>

<p style="margin-top: 1em">--evdev-keymap
BTN_TRIGGER=a,BTN_THUMB=b,BTN_THUMB2=x</p>

<p style="margin-top: 1em">xboxdrv will output on start a
full list of event names that the given event device
supports.</p>

<p style="margin-top: 1em">STATUS OPTIONS <br>
-l, --led NUM <br>
Set LED status. Possible values for NUM are:</p>

<p style="margin-top: 1em">LED Status Codes</p>

<p style="margin-top: 1em">Num Behavior <br>
0 off <br>
1 all blinking <br>
2 1/top-left blink, then on <br>
3 2/top-right blink, then on <br>
4 3/bottom-left blink, then on <br>
5 4/bottom-right blink, then on <br>
6 1/top-left on <br>
7 2/top-right on <br>
8 3/bottom-left on <br>
9 4/bottom-right on <br>
10 rotate <br>
11 blink <br>
12 blink slower <br>
13 rotate with two lights <br>
14 blink <br>
15 blink once</p>

<p style="margin-top: 1em">--rumble-gain AMOUNT <br>
You can change the rumble strength via:</p>

<p style="margin-top: 1em">$ xboxdrv --rumble-gain 50%</p>

<p style="margin-top: 1em">Values larger then 100% are
possible as well and will amplify small rumble commands,
rumble commands already at the maximum will stay
unchanged.</p>

<p style="margin-top: 1em">-q, --quit <br>
Exit xboxdrv after setting LED or rumble values.</p>

<p style="margin-top: 1em">CHATPAD OPTIONS (EXPERIMENTAL)
<br>
Chatpad support is still experimental. Basic keyboard usage
will work, there is however currently no support for
customization or the green and orange key modifiers.</p>

<p style="margin-top: 1em">Starting xboxdrv multiple times
in a row with the --chatpad option can crash the controller.
Unplugging it and plugging it back in should reset it.</p>

<p style="margin-top: 1em">--chatpad <br>
Enables the support for the Xbox360 Chatpad. WARNING: This
is preliminary code, it will crash your gamepad when xboxdrv
is started multiple times and won&rsquo;t provide proper
<br>
keymapping for any of the umlauts and special
characters.</p>

<p style="margin-top: 1em">--chatpad-no-init <br>
This will start chatpad support with out sending the init
sequence, thus potentially avoiding crashing the controller
if xboxdrv is started multiple times.</p>

<p style="margin-top: 1em">--chatpad-debug <br>
Output raw chatpad data to the stdout for debugging
purpose.</p>

<p style="margin-top: 1em">HEADSET OPTIONS (EXPERIMENTAL,
XBOX360 USB ONLY) <br>
Xboxdrv does not support the headset, the options below are
for developers only and will dump raw headset data, not .wav
files.</p>

<p style="margin-top: 1em">--headset <br>
Enable headset support and dump incoming data to stdout.</p>

<p style="margin-top: 1em">--headset-dump FILE <br>
Enable headset support and dump incoming data to FILE.</p>

<p style="margin-top: 1em">--headset-play FILE <br>
Enable headset support and send FILE to the headset for
playback.</p>

<p style="margin-top: 1em">FORCE FEEDBACK <br>
--force-feedback <br>
Enables the standard kernel force feedback interface. It is
disabled by default as it causes trouble with some
applications running in Wine.</p>

<p style="margin-top: 1em">Since the Xbox360 controller
supports just rumble not full force feedback, xboxdrv tries
to emulate other effects. This emulation hasn&rsquo;t been
tested much and might not al&acirc; <br>
ways work as expected. Bug reports and test cases are
welcome.</p>

<p style="margin-top: 1em">Note that you must close the
application that is using force feedback always before you
close the xboxdrv driver, else you might end up with a
hanging non-interruptable <br>
xboxdrv process that will require a reboot to get rid
of.</p>

<p style="margin-top: 1em">When using xboxdrv in daemon
mode with multiple controller slots you have to enable force
feedback for each slot separately.</p>

<p style="margin-top: 1em">--ff-device DEVICEID <br>
Select to which virtual device the force-feedback callbacks
will be connected to, it defaults to joystick. Other allowed
values are mouse, keyboard and any integer number. <br>
See --ui-buttonmap for further information on how device-ids
work.</p>

<p style="margin-top: 1em">-R, --test-rumble <br>
Pressing LT will move the left rumble motor and pressing RT
will move the right one. Rumble motor strength depends on
how hard you press. This is useful for testing the <br>
rumble motors.</p>

<p style="margin-top: 1em">-r, --rumble L,R <br>
Set the speed for both rumble motors. Values from 0 to 255
are accepted, the default is 0,0.</p>

<p style="margin-top: 1em">CONTROLLER SLOT OPTIONS <br>
Controller slots are used when running xboxdrv in daemon
mode. Each slot represents a complete controller
configuration. If you want to use multiple controller in
daemon mode <br>
you have to supply multiple controller slots.</p>

<p style="margin-top: 1em">--controller-slot N <br>
Switches to the controller slot with the number N, numbering
starts at zero.</p>

<p style="margin-top: 1em">--next-controller <br>
Switches to the next controller slot.</p>

<p style="margin-top: 1em">--match RULE,... <br>
Limits a controller slot to devices that match any one of
the given rules. Possible match rules are:</p>

<p style="margin-top: 1em">usbid=VENDOR:PRODUCT <br>
Match controllers that have the given USB vendor and product
ids.</p>

<p style="margin-top: 1em">vendor=VENDOR <br>
Match controllers that have the given USB idVendor.</p>

<p style="margin-top: 1em">product=PRODUCT <br>
Match controllers that have the given USB idProduct.</p>

<p style="margin-top: 1em">property=PROPERTY:VALUE <br>
Match against an arbitrary udev property, with name PROPERTY
and value VALUE.</p>

<p style="margin-top: 1em">usbpath=BUS:DEV <br>
Match against the USB path given by BUS and DEV.</p>

<p style="margin-top: 1em">usbserial=SERIAL <br>
Match against the USB iSerial number.</p>

<p style="margin-top: 1em">--match-group RULE,... <br>
Limits a controller slot to devices that match all of the
given rules. Possible match rules are the same as for
--match.</p>

<p style="margin-top: 1em">CONFIG SLOT OPTIONS <br>
You can use multiple configurations, called config slots,
with your controller. You switch between those multiple
configurations by pressing the Guide button by default, but
you <br>
can also set another button via the option --toggle.</p>

<p style="margin-top: 1em">--config-slot NUM <br>
Select the config slot NUM.</p>

<p style="margin-top: 1em">--next-config <br>
Allows the creation of an alternative uinput configuration
to which one can toggle at runtime by pressing the ui-toggle
button (defaults to guide).</p>

<p style="margin-top: 1em">$ xboxdrv --mouse --next-config
<br>
--ui-axismap X1=ABS_X,Y1=ABS_Y --ui-buttonmap
A=JS_0,B=JS_1</p>

<p style="margin-top: 1em">The above configuration would
install mouse emulation as first configuration and a simple
joystick emulation as second configuration. Allowing
toggling between mouse emu&acirc; <br>
lation and joystick handling by pressing the guide
button.</p>

<p style="margin-top: 1em">Not that --next-config is
currently limited to only configurations done with
--ui-buttonmap and --ui-axismap, autofire, throttle
emulation, deadzones and all other things <br>
can currently not be switched at runtime.</p>

<p style="margin-top: 1em">--toggle XBOXBTN <br>
Sets the button that will be used to toggle between
different different configurations. A value of
&rsquo;void&rsquo; will disable the toggle button. If no
toggle button is specified, <br>
the guide button will be used to toggle between
configurations.</p>

<p style="margin-top: 1em">CONFIGURATION OPTIONS <br>
--modifier MOD <br>
Add a modifier to the modifier stack, see [Modifier] for a
full list of possible modifier.</p>

<p style="margin-top: 1em">--timeout MSEC <br>
Specify the number of miliseconds that xboxdrv will wait for
events from the controller before moving on and processing
things like auto-fire or relative-axis. Default <br>
value is 10, smaller values will give you a higher
resolution auto fire and relative event movement, but will
waste some more CPU.</p>

<p style="margin-top: 1em">-b, --buttonmap
BUTTON=BUTTON,... <br>
Button remapping is available via the --buttonmap option. If
you want to swap button A and B start with:</p>

<p style="margin-top: 1em">$ xboxdrv --buttonmap
A=B,B=A</p>

<p style="margin-top: 1em">If you want all face buttons
send out A button events:</p>

<p style="margin-top: 1em">$ xboxdrv --buttonmap
B=A,X=A,Y=A</p>

<p style="margin-top: 1em">Possible button names are
(aliases are in parenthesis):</p>

<p style="margin-top: 1em">Button Names</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc;Name &acirc; Description &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;start, back &acirc; start, back buttons &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;guide &acirc; big X-button in the middle (Xbox360
only) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;a(1), b(2), x(3), y(4) &acirc; face buttons &acirc;
<br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;black, white &acirc; black, white buttons (Xbox1
only, mapped to lb, rb on Xbox360) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;lb(5), rb(6) &acirc; shoulder buttons (Xbox360 only,
mapped to black, white on &acirc; <br>
&acirc; &acirc; Xbox1) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;lt(7), rt(8) &acirc; analog trigger (needs
--trigger-as-button option) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;tl, tr &acirc; pressing the left or right analog
stick &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;du(up), dd(down), dl(left), dr(right) &acirc; dpad
directions (needs --dpad-as-button option) &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;green, red, yellow, blue, orange &acirc; guitar
buttons &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
Just like with --ui-buttonmap you can add button filter to
each button.</p>

<p style="margin-top: 1em">--axismap AXIS=MAPPING,... <br>
Axis remapping is available via --axismap and works the same
as button mapping. In addition you can supply a sign to
indicate that an axis should be inverted. So if you <br>
want to invert the y1 axis start with:</p>

<p style="margin-top: 1em">$ xboxdrv --axismap -Y1=Y1</p>

<p style="margin-top: 1em">If you want to swap the left and
right stick start with:</p>

<p style="margin-top: 1em">$ xboxdrv --axismap
X2=X1,Y2=Y1,X1=X2,Y1=Y2</p>

<p style="margin-top: 1em">Possible axis names are: x1, y1,
x2, y2, lt, rt</p>

<p style="margin-top: 1em">Swaping lt or rt with x1, y1,
x2, y2 will not work properly, since their range is
different.</p>

<p style="margin-top: 1em">Just like with --ui-axismap you
can add axis filter to each axis.</p>

<p style="margin-top: 1em">MODIFIER PRESET CONFIGURATION
OPTIONS <br>
The options in this sections are sortcuts for --modifier
options. Unlike --modifier they are not order depended, but
have a predefined order that is used no matter the order in
<br>
which the options are given.</p>

<p style="margin-top: 1em">--autofire BUTTON=FREQUENCY,...
<br>
Autofire mapping allows you to let a button automatically
fire with a given frequency in miliseconds:</p>

<p style="margin-top: 1em">$ xboxdrv --autofire A=250</p>

<p style="margin-top: 1em">Combining --autofire with button
map allows you to have one button act as autofire while
another one, emitting the same signal, acts normally.</p>

<p style="margin-top: 1em">$ xboxdrv --autofire B=250
--buttonmap B=A</p>

<p style="margin-top: 1em">--axis-sensitivty
AXIS=SENSITIVITY,... <br>
The sensitive of an axis can be adjusted via
--axis-sensitivty:</p>

<p style="margin-top: 1em">$ xboxdrv --axis-sensitivty
X1=-1.0,Y1=-1.0</p>

<p style="margin-top: 1em">A value of 0 gives you the
default linear sensitivity, values larger then 0 will give
you higher sensitivity, while values smaller then 0 will
give you lower sensitivity. <br>
Sensitivity values in the range of [-1, 1] will generally
give good results, everything beyond that won&rsquo;t be of
much practical use.</p>

<p style="margin-top: 1em">Sensitivity works by
applying:</p>

<p style="margin-top: 1em">t = 2 ** sensitivity; <br>
pos = (1.0f - (1.0f - pos) ** t) ** (1 / t);</p>

<p style="margin-top: 1em">To the value of the axis, this
means that both the minimum value and the maximum value of
the axis will always stay the same, just the response
inbetween changes.</p>

<p style="margin-top: 1em">For a complete freeform way to
change the axis response see the Response Curve Filter.</p>

<p style="margin-top: 1em">--calibration CALIBRATIONSPEC
<br>
If your gamepad for some reason can&rsquo;t reach the
maximum value or isn&rsquo;t centered properly you can fix
that via the calibration options:</p>

<p style="margin-top: 1em">$ xboxdrv --calibration
X2=-32768:0:32767</p>

<p style="margin-top: 1em">X2 is the axis name and the
three values that follow are min, center and max. Simply
insert the values that jstest reports when your axis is in
the respective positions.</p>

<p style="margin-top: 1em">You can also use the calibration
option if you want to make your joystick more sensitive. A
setting of:</p>

<p style="margin-top: 1em">xboxdrv --calibration
AXIS=MIN:CENTER:MAX,...</p>

<p style="margin-top: 1em">Will cause the joystick device
report maximum position when your stick is only moved half
the way.</p>

<p style="margin-top: 1em">--deadzone NUM <br>
The deadzone is the area at which the sticks do not report
any events. The default is zero, which gives the best
sensitifity but might also cause trouble in some games in
<br>
that the character or camera might move without moving the
stick. To fix this one has to set the value to something
higher:</p>

<p style="margin-top: 1em">$ xboxdrv --deadzone 4000</p>

<p style="margin-top: 1em">A value of 4000 works quite well
for most games.</p>

<p style="margin-top: 1em">You can also give the deadzone
in percentage:</p>

<p style="margin-top: 1em">$ xboxdrv --deadzone 15%</p>

<p style="margin-top: 1em">--deadzone-trigger NUM <br>
The left and right trigger have a separate deadzone value
which can be specified with:</p>

<p style="margin-top: 1em">$ xboxdrv --deadzone-trigger
15%</p>

<p style="margin-top: 1em">--dpad-rotation DEGREE <br>
Allows you to rotate the dpad. DEGREE must be a multiple of
45. This can be useful in isometric games where the
playfield itself is rotated, thus a:</p>

<p style="margin-top: 1em">xboxdrv --dpad-rotation 45</p>

<p style="margin-top: 1em">Will give you controls that are
relative to your character instead of your viewpoint.</p>

<p style="margin-top: 1em">--four-way-restrictor <br>
The --four-way-restrictor option allows to limit the
movement on both analogsticks to only four directions (up,
down, left, right), the diagonals (up/left, up/right, <br>
down/left, down/right) are filtered out from the output.
This option is useful for games such as Tetris, that
don&rsquo;t need diagonals and where you don&rsquo;t want to
accidently <br>
trigger the down-move while trying to do a left/right
move.</p>

<p style="margin-top: 1em">--relative-axis AXIS=NUM,...
<br>
The function --relative-axis allows you to change the
behaviour of an axis so that your movement of it moves its
value up or down instead of applying it directly. This
al&acirc; <br>
lows you to simulate throttle control for flightsim
games.</p>

<p style="margin-top: 1em">Since the axis might be upside
down, you might want to use the --axismap function to
reverse it.</p>

<p style="margin-top: 1em">$ xboxdrv --relative-axis
y2=64000 --axismap -y2=y2</p>

<p style="margin-top: 1em">--square-axis <br>
The Xbox360 gamepad, as most other current day gamepads,
features a circular movement range, which restricts the
movement so that the distance to the center never gets
be&acirc; <br>
yond 1. This means that when you have the controller at the
top/left the value reported is (0.7, 0.7) (i.e. length 1,
angle 45) instead of (1,1). This behaviour is differ&acirc;
<br>
ent then most classic PC joysticks, which had a square range
and would report (1,1) when hold in the top/left corner.</p>

<p style="margin-top: 1em">Some old games (i.e. mostly DOS
stuff) require a square movement range and will not function
properly with the Xbox360 gamepad. Via the --square-axis
option you can work <br>
around this issue and diagonals will be reported as
(1,1).</p>

<p style="margin-top: 1em">UINPUT PRESET CONFIGURATION
OPTIONS <br>
The following options are simple shortcuts for common
configurations that can be accomplished manually by using
--ui-buttonmap and --ui-axismap.</p>

<p style="margin-top: 1em">--trigger-as-button <br>
LT and RT send button instead of axis events</p>

<p style="margin-top: 1em">--trigger-as-zaxis <br>
Combine LT and RT to form a zaxis instead</p>

<p style="margin-top: 1em">--dpad-as-button <br>
The DPad sends button instead of axis events.</p>

<p style="margin-top: 1em">--dpad-only <br>
Both sticks are ignored, only the DPad sends out axis
events. Useful for games that might get confused by
additional analog axis. Combining this option with
--trig&acirc; <br>
ger-as-button is recommend in most situations.</p>

<p style="margin-top: 1em">--guitar <br>
Sets a predefined button and axis mapping for use with
guitar controllers. This mainly gets rid of a few
unnecessary buttons and axis not used by a guitar
controller.</p>

<p style="margin-top: 1em">-m, --mouse <br>
Lets the controller act as a mouse. It is indendical to:</p>

<p style="margin-top: 1em">$ xboxdrv --dpad-as-button <br>
--deadzone 4000 <br>
--trigger-as-zaxis <br>
--axismap &quot;-y2=y2,-trigger=trigger&quot; <br>
--ui-axismap
&quot;x1=REL_X:15:20,y1=REL_Y:15:20,y2=REL_WHEEL:5:100,x2=REL_HWHEEL:5:100,trigger=REL_WHEEL:5:100&quot;
<br>
--ui-buttonmap
&quot;a=BTN_LEFT,b=BTN_RIGHT,x=BTN_MIDDLE,y=KEY_ENTER,rb=KEY_PAGEDOWN,lb=KEY_PAGEUP,&quot;
<br>
--ui-buttonmap
&quot;dl=KEY_LEFT,dr=KEY_RIGHT,du=KEY_UP,dd=KEY_DOWN,&quot;
<br>
--ui-buttonmap
&quot;start=KEY_FORWARD,back=KEY_BACK,guide=KEY_ESC,tl=void,tr=void&quot;</p>

<p style="margin-top: 1em">You can customize it by the
usual means, just make sure that --mouse comes before your
customization options on the command line.</p>

<p style="margin-top: 1em">Note that if you have your mouse
buttons switched you must adjust the above to match your
mouse configuration or the button events will come out
wrong.</p>

<p style="margin-top: 1em">--mimic-xpad <br>
Causes xboxdrv to use the same axis and button names as the
xpad kernel driver for wired Xbox360 controller</p>

<p style="margin-top: 1em">--mimic-xpad-wireless <br>
Causes xboxdrv to use the same axis and button names as the
xpad kernel driver for wired Xbox360 controller</p>

<p style="margin-top: 1em">UINPUT CONFIGURATION OPTIONS
<br>
--no-uinput <br>
Do not to start UInput, instead simply read events from the
controller, useful for debugging.</p>

<p style="margin-top: 1em">--no-extra-devices <br>
By default xboxdrv will allocate multiple uinput devices and
sort events to each of them. Thus mouse related events like
BTN_LEFT or REL_X will go to a virtual mouse de&acirc; <br>
vice, while ABS_X events would go to a virtual joystick
device and KEY_ESC would go to a virtual keyboard
device.</p>

<p style="margin-top: 1em">This option disables that
automatism and all events will go to the same virtual
device.</p>

<p style="margin-top: 1em">Manual assignment to a specific
device (i.e. KEY_ESC@keyboard, BTN_A@joystick, ...) is still
possible.</p>

<p style="margin-top: 1em">--no-extra-events <br>
By default xboxdrv will allocate multiple uinput devices and
sort events to each of them. Thus mouse related events like
BTN_LEFT or REL_X will go to a virtual mouse de&acirc; <br>
vice, while ABS_X events would go to a virtual joystick
device and KEY_ESC would go to a virtual keyboard
device.</p>

<p style="margin-top: 1em">To make sure sure that a mouse,
keyboard or joystick device is properly detected by Xorg,
the kernel or libraries such SDL xboxdrv will insert extra
dummy events. For ex&acirc; <br>
ample a mouse device needs REL_X and REL_Y events to be
detected as such, but a configuration that only wants to
emulate the mouse buttons won&rsquo;t provide those, thus
xbox&acirc; <br>
drv will add them automatically. The --no-extra-events
option will switch this behaviour off.</p>

<p style="margin-top: 1em">--device-name NAME <br>
Changes the descriptive name the device will have. This
options acts the same as --device-names
CURRENTSLOT.auto=NAME</p>

<p style="margin-top: 1em">--device-names
TYPE.SLOT=NAME,... <br>
Changes the descriptive name the device will have. TYPE is
one of mouse, keyboard, joystick, auto or a number. SLOT is
a slot number or auto. The auto name acts as wild <br>
card and matches everything.</p>

<p style="margin-top: 1em">--device-usbid
VENDOR:PRODUCT:VERSION:BUS <br>
Changes the vendor, product, version and bus id that the
device will have. The last two arguments are optional. This
options acts the same as --device-usbids CUR&acirc; <br>
RENTSLOT.auto=VENDOR:PRODUCT:VERSION:BUS</p>

<p style="margin-top: 1em">--device-usbids
TYPE.SLOT=VENDOR:PRODUCT:VERSION:BUS,... <br>
Changes the vendor, product, version and bus id the device
will have. TYPE is one of mouse, keyboard, joystick, auto or
a number. SLOT is a slot number or auto. The auto <br>
name acts as wild card and matches everything.</p>

<p style="margin-top: 1em">--ui-clear <br>
Removes all uinput mappings and will leave the driver in a
blank state and only map those things you added yourself. If
you only want to get rid of individual buttons you <br>
can use the &rsquo;void&rsquo; event.</p>

<p style="margin-top: 1em">--ui-buttonmap UIBUTTONSPEC,...
<br>
UIBUTTONSPEC = XBOXBUTTON [ &quot;+&quot; XBOXBUTTON ] [
&quot;^&quot; FILTER ] ... &quot;=&quot; ( RELSPEC | BTNSPEC
| EXECSPEC ) ; <br>
RELSPEC = [ DEVICEID &quot;-&quot; ] &quot;REL_&quot; [
&quot;:&quot; [ VALUE ] [ &quot;:&quot; REPEAT ] ] ; <br>
BTNSPEC = [ DEVICEID &quot;-&quot; ] ( ( &quot;BTN_&quot;
NAME ) | ( &quot;KEY_&quot; NAME ) ) { &quot;+&quot; BTNSPEC
} ; <br>
EXECSPEC = PROGRAM { &quot;:&quot; ARGUMENT } ; <br>
XBOXBUTTON = &quot;a&quot; | &quot;b&quot; | &quot;x&quot; |
&quot;y&quot; | &quot;lb&quot; | &quot;rb&quot; |
&quot;lt&quot; | &quot;rt&quot; | <br>
&quot;tl&quot; | &quot;tr&quot; | &quot;start&quot; |
&quot;select&quot; | &quot;back&quot; | &quot;guide&quot; |
&quot;black&quot; | &quot;white&quot; ; <br>
FILTER = &quot;toggle&quot; | &quot;invert&quot; |
&quot;autofire&quot; [ &quot;:&quot; RATE ] [ &quot;:&quot;
DELAY ] | log [ &quot;:&quot; STRING ] ; <br>
NAME = STRING ; <br>
VALUE = NUMBER ; <br>
REPEAT = NUMBER ; <br>
DEVICEID = NUMBER ;</p>

<p style="margin-top: 1em">Allows you to change the event
code that is send to the kernel for buttons. The usage is
similar to the normal button mapping, except that the right
hand side is an event <br>
name from /usr/include/linux/input.h. You can use all KEY_
or BTN_ codes for --ui-buttonmap.</p>

<p style="margin-top: 1em">If the right hand side is left
empty all the supplied filters will be added to the already
existing button binding instead of a new one.</p>

<p style="margin-top: 1em">Aside from the named keys, you
can also give the input code directly as number via the
syntax KEY_#NUM.</p>

<p style="margin-top: 1em">Instead of the low level KEY_
names, which represent keycodes, you can also use the higher
level X11 keysyms XK_, the keysyms have the advantage that
they map directly to <br>
the key you expect, while a KEY_ name gets mangled by the
X11 keymap and will often not report what you expect in case
you use a keymap that is different then your key&acirc; <br>
board (i.e. dvorak on a qwerty keyboard).</p>

<p style="margin-top: 1em">A full list of valid X11 keysyms
can be optained with --help-x11keysym.</p>

<p style="margin-top: 1em">For joystick buttons there is in
addition to the BTN_JOYSTICK, BTN_X, etc. macros the special
name JS_$NUM, which sets the given button to the $NUMS
joystick button, i.e.:</p>

<p style="margin-top: 1em">$ xboxdrv --ui-clear
--ui-buttonmap A=JS_0,B=JS_1</p>

<p style="margin-top: 1em">Note that this will only work if
no other joystick button ids are in the way.</p>

<p style="margin-top: 1em">You can also map a button to a
REL_ event. In that case you can supply additional
paramaters in the form of:</p>

<p style="margin-top: 1em">$ xboxdrv --ui-buttonmap
X=REL_???:VALUE:REPEAT</p>

<p style="margin-top: 1em">VALUE gives the value of the
event (default: 10)</p>

<p style="margin-top: 1em">REPEAT gives the number of
milisecond to pass before the event is fired again (default:
5)</p>

<p style="margin-top: 1em">The special &rsquo;void&rsquo;
event allows you to clear any existing bindings for a given
button, which can be useful in cases when a game only
supports a limited number of buttons.</p>

<p style="margin-top: 1em">You can also prepend a device_id
to the UIBUTTONSPEC which allows you to create multiple
uinput devices. By default &rsquo;auto&rsquo; is assumed as
device_id which automatically try <br>
to do the right thing, sending keyboard events to a keyboard
device and mouse events to a mouse device. Other possible
values are &rsquo;mouse&rsquo; and &rsquo;keyboard&rsquo;. A
device_id of <br>
&rsquo;0&rsquo; refers to the first joystick device, values
larger then 0 to the second, third, etc.</p>

<p style="margin-top: 1em">Note that the
&rsquo;mouse&rsquo; and &rsquo;keyboard&rsquo; device_id
names do not give you a mouse or keyboard device, these are
just symbolic names for the devices into which xboxdrv will
sort <br>
events that look like a mouse or keyboard event. The final
determination of which device gets handled as what will be
done by the Kernel or Xorg depending on what events a <br>
device provides.</p>

<p style="margin-top: 1em">An example configuration making
use of device_id would look like this:</p>

<p style="margin-top: 1em">xboxdrv -s --ui-clear
--ui-buttonmap A=JS_0@0,B=JS_1@0 --ui-axismap
X2=ABS_X@0,Y2=ABS_Y@0 <br>
--ui-buttonmap X=JS_0@0,Y=1-JS_1@0 --ui-axismap
X2=ABS_X@1,Y2=ABS_Y@1</p>

<p style="margin-top: 1em">In this example the left stick
creates a joystick device and the right stick creates a
separate joystick device.</p>

<p style="margin-top: 1em">When using multiple controller
slots you can additionally append the slot id and thus
assign events across controller slot boundaries. The syntax
for that is:</p>

<p style="margin-top: 1em">BTN_A@{deviceid}.{slotid}</p>

<p style="margin-top: 1em">Instead of giving just a single
button, it is also possible to give two buttons to
--ui-buttonmap to allow shifting:</p>

<p style="margin-top: 1em">xboxdrv -s --ui-clear
--ui-buttonmap A=JS_0,B=JS_1,LB+A=JS_2,LB+B=JS_3</p>

<p style="margin-top: 1em">In this example LB acts as shift
button, if A is pressed without LB it will send out a JS_0
event, but if LB is pressed it will send a JS_2 event
instead. This allows you <br>
to multiply the number of available buttons on the
controller.</p>

<p style="margin-top: 1em">See the section KEYBOARD
EMULATION below on how to resolve issues with Xorg not
detecting the virtual keyboard that xboxdrv creates.</p>

<p style="margin-top: 1em">You can also apply filters to
button events:</p>

<p style="margin-top: 1em">xboxdrv -s --ui-buttonmap
A^toggle=JS_0</p>

<p style="margin-top: 1em">For documentation on the filters
you can apply to events see [Button Filter].</p>

<p style="margin-top: 1em">--ui-axismap UIAXISSPEC,... <br>
UIAXISSPEC = [ XBOXBTN &quot;+&quot; ] XBOXAXIS {
&quot;^&quot; FILTER } &quot;=&quot; ( RELSPEC | RELREP |
KEYSPEC | ABSSPEC ) ; <br>
KEYSPEC = [ &quot;key:&quot; ] &quot;KEY_&quot; NAME
&quot;:&quot; &quot;KEY_&quot; NAME &quot;:&quot; THRESHOLD
; <br>
RELSPEC = [ &quot;rel:&quot; ] &quot;REL_&quot; NAME
&quot;:&quot; VALUE &quot;:&quot; REPEAT ; <br>
RELREP = &quot;rel-repeat:&quot; &quot;REL_&quot; NAME
&quot;:&quot; VALUE &quot;:&quot; REPEAT ; <br>
ABSSPEC = [ &quot;abs:&quot; ] &quot;ABS_&quot; NAME ; <br>
FILTER = ( &quot;calibration&quot; | &quot;cal&quot; )
&quot;:&quot; MIN &quot;:&quot; CENTER &quot;:&quot; MAX |
<br>
( &quot;sensitifity&quot; | &quot;sen&quot; ) &quot;:&quot;
SENSITIFITY | <br>
( &quot;deadzone&quot; | &quot;dead&quot; ) &quot;:&quot;
MIN &quot;:&quot; MAX &quot;:&quot; SMOOTH | <br>
( &quot;relative&quot; | &quot;rel&quot; ) &quot;:&quot;
SPEED | <br>
( &quot;responsecurve&quot; | &quot;response&quot; |
&quot;resp&quot; ) { &quot;:&quot; VALUE } <br>
XBOXBTN = &quot;a&quot; | &quot;b&quot; | &quot;x&quot; |
&quot;y&quot; | &quot;start&quot; | &quot;back&quot; |
&quot;guide&quot; | &quot;lb&quot; | &quot;rb&quot; | ...
<br>
XBOXAXIS = &quot;x1&quot; | &quot;y1&quot; | &quot;x2&quot;
| &quot;y2&quot; | &quot;z&quot; | &quot;lt&quot; |
&quot;rt&quot; | &quot;dpad_x&quot; | &quot;dpad_y&quot; ;
<br>
VALUE = NUMBER ; <br>
REPEAT = NUMBER ; <br>
THRESHOLD = NUMBER ; <br>
NAME = STRING ;</p>

<p style="margin-top: 1em">Similar to --ui-buttonmap this
option allows you to change the event code that is send to
the kernel for axes. The events that are available are the
same as for --ui-but&acirc; <br>
tonmap.</p>

<p style="margin-top: 1em">$ xboxdrv --ui-axismap
X1=REL_???:VALUE:REPEAT</p>

<p style="margin-top: 1em">VALUE gives the maximum value of
the event, the actual value that gets send is VALUE *
axis_state. (default: 10)</p>

<p style="margin-top: 1em">REPEAT gives the number of
milisecond to pass before the event is fired again (default:
5).</p>

<p style="margin-top: 1em">The value of -1 has a special
meaning, it will result in the REL event being fired as soon
as possible (i.e. every timeout miliseconds). This is the
recomment way for <br>
handling mouse emulation, as it will keep REL events
syncronized and thus avoid jaggies in the movement, that
will result from manually specifying a timeout.</p>

<p style="margin-top: 1em">$ xboxdrv --ui-axismap
X1=KEY_UP:KEY_DOWN:THRESHOLD</p>

<p style="margin-top: 1em">KEY_UP gives the keycode to be
send when the axis is moved up</p>

<p style="margin-top: 1em">KEY_DOWN gives the keycode to be
send when the axis is moved down</p>

<p style="margin-top: 1em">THRESHOLD gives the threshold
that triggers the sending of an event</p>

<p style="margin-top: 1em">Just like --ui-buttonmap, you
can also use shift keys in place of the XBOXAXIS:</p>

<p style="margin-top: 1em">$ xboxdrv --ui-axismap
X1=ABS_X,LB+X1=ABS_RX</p>

<p style="margin-top: 1em">This allows you to send ABS_X
events normally and ABS_RX events when the LB button is held
down.</p>

<p style="margin-top: 1em">For information on how to use
axis filters, see [Axis Filter].</p>

<p style="margin-top: 1em">INPUT EVENT HANDLER <br>
Input event handler decide what comes out of the virtual
input devices that xboxdrv creates. They for example decide
that when button A is pressed on a gamepad, that a virtual
<br>
keyboard will emit a press of the space key.</p>

<p style="margin-top: 1em">Furthermore input event handler
can also perform some basic transformation of the input
signals, thus a joystick can be used to send WASD keys.</p>

<p style="margin-top: 1em">BUTTON EVENT HANDLER <br>
A button event handler decides what happens when a button is
pressed, it needs to be specified with the --ui-buttonmap
option. The example below shows the simplest use case:</p>

<p style="margin-top: 1em">$ xboxdrv --ui-buttonmap
A=key:KEY_A</p>

<p style="margin-top: 1em">Here key is the name of the
button event handler, while KEY_A is an argument for the
event handler. What kind of arguments an event handler
allows depends on the event handler.</p>

<p style="margin-top: 1em">There is also a shorthand form
of specifing event handlers by just writing:</p>

<p style="margin-top: 1em">$ xboxdrv --ui-buttonmap
A=KEY_A</p>

<p style="margin-top: 1em">Here no handler is specified
explicitly, if that is the case, the appropriate handler
will be guessed based on the event type. EV_KEY events will
be handled by the key handler, <br>
EV_REL by the rel handler and EV_ABS by the abs handler.</p>

<p style="margin-top: 1em">key:KEY_EVENT,
key:KEY_EVENT:KEY_EVENT:HOLD_THRESHOLD_MSEC <br>
The key handler is the most basic one, it maps a button
directly to a virtual key or another button.</p>

<p style="margin-top: 1em">If additional arguments are
supplied the button will be able to send out two different
events. The first event specified will be send when the
button is clicked normally, <br>
while the second event will be send in case the button is
hold down for the time specified in HOLD_THRESHOLD_MSEC.</p>

<p style="margin-top: 1em">An example for the hold button
would look like:</p>

<p style="margin-top: 1em">xboxdrv --ui-buttonmap
A=JS_0:JS_1:500</p>

<p style="margin-top: 1em">This will send JS_0 events when
the button is pressed and switch to JS_1 events when the
button was hold for 500 miliseconds.</p>

<p style="margin-top: 1em">The hold button feature is
useful to effectly double the number of available buttons,
thus the dpad can for example be used to send out eight
different button events in&acirc; <br>
stead of just four, which is enough to handle weapons in
most FPS games.</p>

<p style="margin-top: 1em">abs not yet implemented</p>

<p style="margin-top: 1em">rel:REL_EVENT:VALUE:REPEAT <br>
The rel handler will send out a REL event whenever the
button is pressed. VALUE gives the value of the event that
will be send, while REPEAT gives the number of
milisec&acirc; <br>
onds till the event will be send again.</p>

<p style="margin-top: 1em">A typical use for REL events is
emulation of the scroll wheel of a mouse, an example
configuration would be:</p>

<p style="margin-top: 1em">xboxdrv --ui-buttonmap
Y=rel:REL_WHEEL:1:500,A=rel:REL_WHEEL:-1:500</p>

<p style="margin-top: 1em">Here Y will scroll up and A will
scroll down.</p>

<p style="margin-top: 1em">cycle-key:KEY_EVENT:... <br>
The cycle-key handler will switch the KEY_EVENT that gets
send with each button press. This is useful in situations
where a range of buttons should be mapped to a single <br>
key. For example a FPS might have weapons mapped from 1 to
6, but only a single key on the gamepad is free, thus one
could write:</p>

<p style="margin-top: 1em">xboxdrv --ui-buttonmap
A=cycle-key:KEY_1:KEY_2:KEY_3:KEY_4:KEY_5:KEY_6</p>


<p style="margin-top: 1em">cycle-key-named:NAME:KEY_EVENT:...
<br>
The cycle-key-named handler works exactly like the cycle-key
handler, except that a name has to be supplied for the cycle
sequence. The name of the sequence is used by cy&acirc; <br>
cle-key-ref to access the sequence and reuse it for another
button.</p>

<p style="margin-top: 1em">In this simple example A is used
to toggle through all weapon keys forward, while B is used
to toggle the keys backwards:</p>

<p style="margin-top: 1em">xboxdrv --ui-buttonmap
A=cycle-key-named:weapons:KEY_1:KEY_2:KEY_3:KEY_4,B=cycle-key-ref:weapons</p>

<p style="margin-top: 1em">cycle-key-ref:NAME:DIRECTION,
sequence-key-ref:NAME:DIRECTION <br>
The cycle-key-ref handler will access and reuse the named
cycle keysequence given by NAME. If DIRECTION can either be
&rsquo;forward&rsquo; or &rsquo;backward&rsquo;, if no
direction is supplied <br>
it will default to &rsquo;backward&rsquo;.</p>

<p style="margin-top: 1em">See cycle-key-named for a full
example.</p>


<p style="margin-top: 1em">sequence-key-named:NAME:KEY_EVENT:...
<br>
The sequence-key-named works exactly the same as the
cycle-key-named, with the only difference being that the
sequence-key-named will not wrap around when reaching the
be&acirc; <br>
ginning or end of the sequence.</p>

<p style="margin-top: 1em">This behaviour is useful in
flight simulations or other games where thrusters might be
controllered by numeric keys and it wouldn&rsquo;t make much
sense to jump from zero to <br>
full thrust in one go.</p>

<p style="margin-top: 1em">To move backwards through the
sequence another key must be bound to sequence-key-ref.</p>

<p style="margin-top: 1em">exec The exec button handler
allows to launch an application when the button was pressed.
An example would look like this:</p>

<p style="margin-top: 1em">xboxdrv --ui-buttonmap
A=exec:/home/juser/local/bin/screenshot.sh</p>

<p style="margin-top: 1em">Possible uses for the button are
the ability to do screenshots or perform other tasks that
are outside the main application you are using xboxdrv
with.</p>

<p style="margin-top: 1em">macro A button can be bound to a
macro via:</p>

<p style="margin-top: 1em">xboxdrv --ui-buttonmap
A=macro:/home/juser/.xboxdrv/somefile.macro</p>

<p style="margin-top: 1em">The .macro file has the form
of:</p>

<p style="margin-top: 1em">send KEY_LEFTSHIFT 1 <br>
wait 500 <br>
send KEY_LEFTSHIFT 0</p>

<p style="margin-top: 1em">All abs, rel and key events can
be send from a macro file.</p>

<p style="margin-top: 1em">AXIS EVENT HANDLER <br>
Axis event handler decide what happens when an axis is
moved. Like button event handler they come in different
forms and like button event handler they provide a shortcut
form. <br>
EV_KEY events will be handled by the key handler, EV_REL by
the rel handler and EV_ABS by the abs handler.</p>

<p style="margin-top: 1em">abs:ABS_EVENT <br>
The abs handler is the simplest of them all, it will simply
send out the value it gets as input as the given ABS_EVENT
event to the kernel. Thus a basic configuration to <br>
make the left stick behave as joystick would look like
this:</p>

<p style="margin-top: 1em">xboxdrv --ui-axismap
X1=abs:ABS_X,Y1=abs:ABS_Y</p>

<p style="margin-top: 1em">key:KEY_UP:KEY_DOWN:THRESHOLD
<br>
KEY_UP gives the keycode to be send when the axis is moved
up</p>

<p style="margin-top: 1em">KEY_DOWN gives the keycode to be
send when the axis is moved down</p>

<p style="margin-top: 1em">THRESHOLD gives the threshold
that triggers the sending of an event</p>

<p style="margin-top: 1em">Just like --ui-buttonmap, you
can also use shift keys in place of the XBOXAXIS:</p>

<p style="margin-top: 1em">$ xboxdrv --ui-axismap
X1=ABS_X,LB+X1=ABS_RX</p>

<p style="margin-top: 1em">This allows you to send ABS_X
events normally and ABS_RX events when the LB button is held
down.</p>

<p style="margin-top: 1em">rel:REL_EVENT:VALUE:REPEAT <br>
VALUE gives the maximum value of the event, the actual value
that gets send is VALUE * axis_state. (default: 10)</p>

<p style="margin-top: 1em">REPEAT gives the number of
milisecond to pass before the event is fired again (default:
5).</p>

<p style="margin-top: 1em">The value of -1 has a special
meaning, it will result in the REL event being fired as soon
as possible (i.e. every timeout miliseconds). This is the
recomment way for <br>
handling mouse emulation, as it will keep REL events
syncronized and thus avoid jaggies in the movement, that
will result from manually specifying a timeout.</p>

<p style="margin-top: 1em">The rel handler is mainly useful
for mouse pointer emulation, if you want to emulate a mouse
scroll wheel use the rel-repeat handler instead.</p>


<p style="margin-top: 1em">rel-repeat:REL_EVENT:VALUE:REPEAT
<br>
The rel-repeat handler is similar to the rel handler, but
optimized for emulating the scroll wheel of a mouse.</p>

<p style="margin-top: 1em">VALUE isn&rsquo;t scaled to how
far the axis has moved, instead it is constant, instead the
time given in REPEAT is scaled according to the axis
movement. Thus the further the <br>
stick is moved, the more events will be send.</p>

<p style="margin-top: 1em">The need for both rel-repeat and
rel arises from the fact that Xorg converts scroll wheel
movement to button presses before they are handed to an
application, thus an ap&acirc; <br>
plication never properly sees the changes in VALUE, by
scaling REPEAT instead that problem is worked around.</p>

<p style="margin-top: 1em">INPUT FILTER <br>
Input filter allow to manipulate the events that come from
the controller. They can be used on --buttonmap, --axismap,
--ui-buttonmap and --ui-axismap. The difference between the
<br>
two is that the --ui-... versions applies to the uinput
events, while the other version applies to Xbox360
controller events.</p>

<p style="margin-top: 1em">BUTTON FILTER <br>
tog, toggle <br>
The toggle filter will turn the button into a toggle button,
clicking the button will set it to pressed state and
pressing it again will unpress it. Useful for games where
<br>
you might want to permanently run or duck without holding
the button pressed.</p>

<p style="margin-top: 1em">inv, invert <br>
The invert filter will keep the button in pressed state when
it is not pressed and in unpressed state when it is
pressed.</p>

<p style="margin-top: 1em">auto, autofire:RATE:DELAY <br>
The autofire filter allows to repeatatly send button press
events when the button is held down. It takes two optional
parameters:</p>

<p style="margin-top: 1em">RATE is the number of
miliseconds between button press events.</p>

<p style="margin-top: 1em">DELAY the amount of miliseconds
till the autofire will start, before that delay the button
will act as normal.</p>

<p style="margin-top: 1em">click-press <br>
The click-press filter will transmit a single button click
when the button is pressed.</p>

<p style="margin-top: 1em">click-release <br>
The click-release filter will transmit a single button click
when the button is released.</p>

<p style="margin-top: 1em">click-both <br>
The click-both filter will transmit a single button click
when the button is pressed and another one when it is
released.</p>

<p style="margin-top: 1em">const:VALUE <br>
The const filter will ignore the input signal and send a
constant value to the output. This can be used for example
in combination with multiple configurations to signal a <br>
game or another application which configuration is currently
active.</p>

<p style="margin-top: 1em">delay:TIME <br>
A button has to be held down for TIME miliseconds before it
will emit an event, press events shorter then that will be
ignored.</p>

<p style="margin-top: 1em">log:STRING <br>
The log filter will output everything to stdout that goes
through it to, this is useful for debugging the filter. A
STRING can be provided as parameter that will be out&acirc;
<br>
puted before the event.</p>

<p style="margin-top: 1em">AXIS FILTER <br>
cal, calibration:MIN:CENTER:MAX <br>
See --calibration.</p>

<p style="margin-top: 1em">sen, sensitivity:SENSITIVITY
<br>
See --axis-sensitivity.</p>

<p style="margin-top: 1em">dead, deadzone:VALUE,
deadzone:MIN:CENTER:MAX <br>
Deadzone filter applies a deadzone to the current axis. If
only MIN is provided, the parameter will be interpreted as
-MIN:MIN:1. If the argument is 1, smooth filtering <br>
will be applied so that the end of the deadzone is 0.
Setting the argument to 0 will apply a simple cut-off
filter, where all events smaller then the threshold are
ig&acirc; <br>
nored.</p>

<p style="margin-top: 1em">rel, relative:SPEED <br>
See --relative-axis.</p>

<p style="margin-top: 1em">resp, response:VALUES:... <br>
The response curve filter allows you to completely change
the way an axis reacts. The filter takes a list of VALUES
that are then linearly interpolated and spread across <br>
the full range of the axis. An example would look like
this:</p>

<p style="margin-top: 1em">xboxdrv --ui-axismap
x1^resp:-32768:-4000:0:4000:32767</p>

<p style="margin-top: 1em">Here the X1 axis is manipulated
so that it will have a lower sensitivity in the center and a
higher one on the outside.</p>

<p style="margin-top: 1em">const:VALUE <br>
The const filter will ignore the input signal and send a
constant value to the output. This can be used for example
in combination with multiple configurations to signal a <br>
game or another application which configuration is currently
active.</p>

<p style="margin-top: 1em">log:STRING <br>
The log filter will output everything to stdout that goes
through it to, this is useful for debugging the filter. A
STRING can be provided as parameter that will be out&acirc;
<br>
puted before the event.</p>

<p style="margin-top: 1em">MODIFIER <br>
While button and axis filter only apply to a single axis or
button at a time, modifiers apply to the complete controller
at once and can thus be used to perform modifications <br>
that require input from multiple axis or buttons. Most of
the modifiers explained below replicate functionality
provided by regular options, but allow more fine tuning,
such as <br>
limiting the effects to a single analog stick instead of
just applyig it to all. Note that modifiers are applied one
after the other, so order is important.</p>

<p style="margin-top: 1em">dpad-rotate=DEGREE <br>
See --dpad-rotation.</p>

<p style="margin-top: 1em">dpad-restrictor=RESTRICTON <br>
Restricts the dpad movement, values for RESTRICTON can
be:</p>

<p style="margin-top: 1em">x-axis: only allow movement in
the X axis</p>

<p style="margin-top: 1em">y-axis: only allow movement in
the Y axis</p>

<p style="margin-top: 1em">fourway: allow movement in X and
Y axis, but filter out diagonals</p>

<p style="margin-top: 1em">4wayrest,
four-way-restrictor=XAXIS:YAXIS <br>
See --four-way-restrictor.</p>

<p style="margin-top: 1em">square, square-axis=XAXIS:YAXIS
<br>
See --square-axis.</p>


<p style="margin-top: 1em">rotate=XAXIS:YAXIS:DEGREE:MIRROR
<br>
Rotates the stick given by XAXIS and YAXIS by DEGREE and
optionally MIRRORS it.</p>

<p style="margin-top: 1em">stat, statistic <br>
The statistic modifier doesn&rsquo;t actually modify
anything, instead it collects statistics on the controller,
such as how many times a button has been pressed. The
results of <br>
the collections will be displayed on shutdown of
xboxdrv.</p>

<p style="margin-top: 1em">Note that the stat modifier is
part of the modifier stack, thus to get correct results you
must make sure that it comes first in the stack when it
should work on real <br>
events and not be confused by auto-fire or similar
modifications.</p>

<p style="margin-top: 1em">RUNNING XBOXDRV <br>
USING A SINGLE CONTROLLER <br>
Plug in your Xbox360 gamepad and then unload the xpad driver
via:</p>

<p style="margin-top: 1em">$ rmmod xpad</p>

<p style="margin-top: 1em">If you want to permanently
unload it add the following line to
/etc/modprobe.d/blacklist.conf:</p>

<p style="margin-top: 1em">blacklist xpad</p>

<p style="margin-top: 1em">Next you have to load the uinput
kernel module which allows userspace programms to create
virtual input devices and the joydev module handles the
/dev/input/jsX devices:</p>

<p style="margin-top: 1em">$ modprobe uinput <br>
$ modprobe joydev</p>

<p style="margin-top: 1em">You also have to make sure that
you have access rights to /dev/input/uinput, either add
yourself to the appropriate group, adjust the permissions or
run xboxdrv as root.</p>

<p style="margin-top: 1em">Once ensured that xpad is out of
the way and everything is in place start the userspace
driver with:</p>

<p style="margin-top: 1em">$ xboxdrv</p>

<p style="margin-top: 1em">Or in case you don&rsquo;t have
the neccesary rights (being in group root should often be
enough) start the driver as root via:</p>

<p style="margin-top: 1em">$ sudo xboxdrv</p>

<p style="margin-top: 1em">This will create /dev/input/js0
and allow you to access the gamepad from any game. To exit
the driver press Ctrl-c.</p>

<p style="margin-top: 1em">By default xboxdrv will echo all
controller events to the console, this makes it easy to see
if things are properly working, but will eat a lot of CPU,
thus it is strongly recom&acirc; <br>
ment to disabled that output with the --silent option.</p>

<p style="margin-top: 1em">The trigger buttons are handled
by xboxdrv normally as axis, giving you analog feedback,
while this reproduces the Xbox360 controller the most
accurately, it will confuse many <br>
and only be useful in a few, racing games mainly. So in the
majority of cases it is recomment to change the triggers to
regular buttons via:</p>

<p style="margin-top: 1em">$ xboxdrv
--trigger-as-button</p>

<p style="margin-top: 1em">USING MULTIPLE CONTROLLER <br>
If you want to use multiple wired controllers you need to
start multiple instances of the xboxdrv driver and append
the -i argument to select the appropriate controller like
<br>
this:</p>

<p style="margin-top: 1em">$ xboxdrv -i 1</p>

<p style="margin-top: 1em">If you have multiple wireless
controller you need to start multiple instances of the
xboxdrv driver and append the --wid option like this:</p>

<p style="margin-top: 1em">$ xboxdrv --wid 1</p>

<p style="margin-top: 1em">You have to sync the wireless
controller as usual.</p>

<p style="margin-top: 1em">To see a list of all the
controllers that xboxdrv detects being connected to your
system use:</p>

<p style="margin-top: 1em">$ xboxdrv --list-controller</p>

<p style="margin-top: 1em">HOTPLUGGING AND XBOXDRV DAEMON
<br>
To allow hotplugging of gamepads xboxdrv has to be run in
daemon mode. This is accomplished with the --daemon
option:</p>

<p style="margin-top: 1em">$ xboxdrv --daemon</p>

<p style="margin-top: 1em">When launched in daemon mode
xboxdrv will listen to udev events and thus be notified
whenever a new USB device gets plugged into the computer. It
will then match that device <br>
against its list of supported devices and launch a separate
thread to handle that gamepad.</p>

<p style="margin-top: 1em">Note that xboxdrv will not allow
an arbitrary large number of controllers to be used in that
mode, it can only handle as many controllers as you have
allocated controller slots <br>
at startup. New slots can be allocated with
--next-controller and by default one slot is always
allocated, thus to support three controller you would run it
with:</p>

<p style="margin-top: 1em">$ xboxdrv --daemon
--next-controller --next-controller</p>

<p style="margin-top: 1em">Each controller slot can be
configured individually and you can limit which gamepad gets
assigned to which slot with the --match option.</p>

<p style="margin-top: 1em">Note that xboxdrv will create
the virtual uinput devices on startup, not when a gamepad
gets plugged in, this allows to plug in gamepads even after
a game or an application like <br>
XBMC has already been launched and still have it all
function properly.</p>

<p style="margin-top: 1em">In daemon mode xboxdrv can be
detached from the current shell via --detach, to get a
handle on it to kill it you can write its pid via the
--pid-file:</p>

<p style="margin-top: 1em">$ sudo xboxdrv --daemon --detach
--pid-file /var/run/xboxdrv.pid</p>

<p style="margin-top: 1em">XBOXDRV DAEMON DBUS INTERFACE
<br>
When Xboxdrv is run as daemon it will export some API
functions via D-Bus, thus allowing to make configuration
changes at runtime. The D-Bus interface can be accessed
either by <br>
the numerous language bindings provided or via the generic
command line tool dbus-send or by the more userfriendly
xboxdrvctl tool. Examples below are given for the raw dbus-
<br>
send.</p>

<p style="margin-top: 1em">Introspection is provided via
the usual means:</p>

<p style="margin-top: 1em">dbus-send --session
--type=method_call --print-reply --dest=org.seul.Xboxdrv
/org/seul/Xboxdrv
org.freedesktop.DBus.Introspectable.Introspect</p>

<p style="margin-top: 1em">dbus-send --session
--type=method_call --print-reply --dest=org.seul.Xboxdrv
/org/seul/Xboxdrv/ControllerSlots/0
org.freedesktop.DBus.Introspectable.Introspect</p>

<p style="margin-top: 1em">dbus-send --session
--type=method_call --print-reply --dest=org.seul.Xboxdrv
/org/seul/Xboxdrv/Daemon
org.freedesktop.DBus.Introspectable.Introspect</p>

<p style="margin-top: 1em">Status information on available
slots, configuration and active controllers can be obtained
via:</p>

<p style="margin-top: 1em">dbus-send --session
--type=method_call --print-reply --dest=org.seul.Xboxdrv
/org/seul/Xboxdrv/Daemon org.seul.Xboxdrv.Daemon.Status</p>

<p style="margin-top: 1em">Setting the LED on controller 0
can be done via:</p>

<p style="margin-top: 1em">dbus-send --session
--type=method_call --print-reply --dest=org.seul.Xboxdrv
/org/seul/Xboxdrv/ControllerSlots/0
org.seul.Xboxdrv.Controller.SetLed int32:4</p>

<p style="margin-top: 1em">Setting the rumble motors on
controller 0 can be done via:</p>

<p style="margin-top: 1em">dbus-send --session
--type=method_call --print-reply --dest=org.seul.Xboxdrv
/org/seul/Xboxdrv/ControllerSlots/0
org.seul.Xboxdrv.Controller.SetRumble int32:255
int32:255</p>

<p style="margin-top: 1em">Setting a specific controller
slot configuration, just as --toggle BTN allows, can be done
with:</p>

<p style="margin-top: 1em">dbus-send --session
--type=method_call --print-reply --dest=org.seul.Xboxdrv
/org/seul/Xboxdrv/ControllerSlots/0
org.seul.Xboxdrv.Controller.SetConfig int32:2</p>

<p style="margin-top: 1em">TESTING <br>
Knowing how to test a xboxdrv configuration is absolutely
crucial in understanding what is wrong in a given setup.
Testing the configuration in a game is most often not
helpful, <br>
since you won&rsquo;t see the true cause beyond endless
layers of abstraction between you and the actual events.
Luckily there are a few tools you can use to test, all of
these are <br>
command line based and it is recomment that you get familar
with them when you want to do any more complex
configuration.</p>

<p style="margin-top: 1em">EVTEST <br>
evtest lets you read raw input events from
/dev/input/eventX. The event devices are the very core of
all event handling, things like the joystick devices are
derived from the <br>
event device, so if you want to fix some issue on the
joystick device, you have to fix the event device.</p>

<p style="margin-top: 1em">evtest is available in the
tools/ directory or as part of your distribution in the
package evtest. your distribution.</p>

<p style="margin-top: 1em">JSTEST <br>
jstest lets you read the output out of a joystick event
device (/dev/input/js0).</p>

<p style="margin-top: 1em">jstest is available in the
tools/ directory or as part of your distribution
joystick.</p>

<p style="margin-top: 1em">SDL-JSTEST <br>
sdl-jstest lets you see events as games using SDL see them.
This is very important when you want to set and test the
SDL_LINUX_JOYSTICK environment variables.</p>

<p style="margin-top: 1em">It is currently available
via:</p>

<p style="margin-top: 1em">$ svn co
svn://svn.berlios.de/windstille/trunk/sdl-jstest</p>

<p style="margin-top: 1em">Or from the same Ubuntu PPA that
also contains xboxdrv in the package sdl-jstest.</p>

<p style="margin-top: 1em">XEV <br>
xev lets you see the events that Xorg sees. Note however
that you might not see all events, since some will be
grapped by your Window manager before they reach xev, this
is nor&acirc; <br>
mal.</p>

<p style="margin-top: 1em">xev is part of every Linux
distribution, on Ubuntu its available via:</p>

<p style="margin-top: 1em">$ apt-get install x11-utils</p>

<p style="margin-top: 1em">JSCALC AND JSCALIBRATOR <br>
Both of these tools lets you calibrate your gamepad, however
with pretty much all current gamepads this is no longer
needed and actually harmful as it might overwrite a
perfectly <br>
good working configuration with a broken one (unplugging the
gamepad or a reboot will fix that). So avoid them unless you
clearly understand the issues of using them.</p>

<p style="margin-top: 1em">If your gamepad produces
incorrect data and you do want to calibrate it you might
want to check out the option --calibration, which lets you
tweak the way xboxdrv interprets your <br>
gamepad data.</p>

<p style="margin-top: 1em">MOUSE <br>
No tools for testing the output on /dev/input/mouseX are
known.</p>

<p style="margin-top: 1em">NOTE <br>
If the tools provide no output at all, this might not be due
to a wrong configuration, but due to Xorg grabbing your
event device and locking it, see Xorg section for possible
<br>
fixes.</p>

<p style="margin-top: 1em">EXAMPLES <br>
The configurations below are just a few random examples,
further examples can be found in the examples/ directory of
the xboxdrv source tree or in
/usr/share/doc/xboxdrv/exam&acirc; <br>
ples/.</p>

<p style="margin-top: 1em">TURNING TRIGGERS INTO BUTTONS
<br>
By default xboxdrv will handle the trigger as analog axis,
not buttons, while this is beneficial for racing games, it
will confuse many other games, thus xboxdrv provides an easy
<br>
way to change the handling into buttons via the
--trigger-as-button option:</p>

<p style="margin-top: 1em">$ xboxdrv
--trigger-as-button</p>

<p style="margin-top: 1em">CONFIGURE A DEADZONE <br>
Many gamepads don&rsquo;t center exactly at zero, but at
random values around it. This &rsquo;noise&rsquo; can
confuse some games and is thus be best filtered out, this
can be accomplished with:</p>

<p style="margin-top: 1em">$ xboxdrv --deadzone 25%</p>

<p style="margin-top: 1em">The percentance is the amount of
noise that will get filtered out, you can also give raw
device values if you leave out the % sign. If you want to
have a deadzone only on a spe&acirc; <br>
cific axis you have to use axis filter:</p>

<p style="margin-top: 1em">$ xboxdrv --buttonmap
X1^deadzone:15000</p>

<p style="margin-top: 1em">KEYBOARD EMULATION <br>
The following configuration will cause xboxdrv to emulate a
keyboard, which can be useful for games that are played with
keyboard, like Flash games or games that don&rsquo;t support
a <br>
joystick. Since different games use different keyboard keys
you might have to adjust the keybindings to fit the
game:</p>

<p style="margin-top: 1em">$ xboxdrv --ui-clear
--ui-buttonmap a=XK_a,b=XK_b,x=XK_x,y=XK_y --ui-buttonmap
dl=XK_Left,dr=XK_Right,du=XK_Up,dd=XK_Down</p>

<p style="margin-top: 1em">FIGHTING GAMES: <br>
In this configuration the left and right trigger get turned
into digital buttons. All axis except the dpad are ignored.
RB and RT are mapped to act as if buttons 1,2 and 3 are <br>
pressed simultaniously which is useful for some special
attacks. Instead of using the native button names, the
1,2,3,... aliases are used, which makes things a little
easier to <br>
read:</p>

<p style="margin-top: 1em">$ xboxdrv --dpad-only
--trigger-as-button --buttonmap lb=1,x=2,y=3,lt=4,a=5,b=6
--buttonmap rb=1,rb=2,rb=3 --buttonmap rt=4,rt=5,rt=6</p>

<p style="margin-top: 1em">CH FLIGHTSTICK EMULATION IN
DOSBOX: <br>
In dosbox.conf set:</p>

<p style="margin-top: 1em">[joystick] <br>
joysticktype = ch</p>

<p style="margin-top: 1em">Start xboxdrv with:</p>

<p style="margin-top: 1em">$ xboxdrv -s --trigger-as-zaxis
--square-axis --relative-axis y2=64000 --axismap
-y2=x2,x2=y2</p>

<p style="margin-top: 1em">Your right analog stick will act
as trottle control, the trigger as rudder. Using --modifier
to install a four-way restrictor might also be worth a
consideration to not accident&acirc; <br>
ly touch the throttle when the rudder is moved.</p>

<p style="margin-top: 1em">USING MOUSE EMULATION AND
JOYSTICK AT THE SAME TIME <br>
To use mouse emulation and joystick at the same time you
have to register two configuration with xboxdrv, this works
via:</p>

<p style="margin-top: 1em">$ xboxdrv --next-config
--mouse</p>

<p style="margin-top: 1em">The --next-config option will
open up a second configuration and all configuration options
on the right side of it will go there, while everything on
the left side of it will go <br>
into the first configuration. Toggling between the
configurations works with the guide button, you can have as
many configuratios as you want.</p>

<p style="margin-top: 1em">MAPPING EVERY BUTTON MULTIPLE
<br>
Some games might require more buttons then your gamepad has,
in those situation it can be useful to map a button twice by
using shifted buttons:</p>

<p style="margin-top: 1em">$ xboxdrv --ui-clear
--ui-axismap X1=ABS_X,Y1=ABS_Y --ui-buttonmap
a=JS_0,b=JS_1,x=JS_2,y=JS_3 --ui-buttonmap
lb+a=JS_4,lb+b=JS_5,lb+x=JS_6,lb+y=JS_7 --ui-buttonmap
rb+a=JS_8,rb+b=JS_9,rb+x=JS_10,rb+y=JS_11 <br>
.fi</p>

<p style="margin-top: 1em">Here all face buttons are get
mapped three times, once when <br>
pressed normally, once when pressed while LB is held down
and <br>
once when RB is held down, thus given you for the six
buttons <br>
12 virtual ones.</p>

<p style="margin-top: 1em">SAUERBRATEN <br>
First analogstick gets mapped te cursor keys, second
analogstick gets mapped to mouse. Note: This is just an
incomplete example, not a perfectly playable configuration,
you have <br>
to do tweaking yourself.</p>

<p style="margin-top: 1em">$ xboxdrv --ui-axismap
x2=REL_X:10,y2=REL_Y:-10,x1=KEY_LEFT:KEY_RIGHT,y1=KEY_UP:KEY_DOWN
--ui-buttonmap a=BTN_RIGHT,b=BTN_LEFT,x=BTN_EXTRA
--ui-buttonmap rb=KEY_5,lb=KEY_6,lt=BTN_LEFT,rt=BTN_RIGHT
--ui-buttonmap
y=KEY_ENTER,dl=KEY_4,dr=KEY_2,du=KEY_1,dd=KEY_3,back=KEY_TAB,start=KEY_ESC
-s --deadzone 6000 --dpad-as-button --trigger-as-button</p>

<p style="margin-top: 1em">WARSOW <br>
Note: This is just an incomplete example, not a perfectly
playable configuration, you have to do tweaking
yourself.</p>

<p style="margin-top: 1em">$ xboxdrv --ui-axismap
x2=REL_X:10,y2=REL_Y:-10,x1=KEY_A:KEY_D,y1=KEY_W:KEY_S
--ui-buttonmap a=KEY_LEFTSHIFT,b=BTN_C,x=BTN_EXTRA,y=KEY_C
--ui-buttonmap lb=BTN_RIGHT,rb=KEY_SPACE --ui-buttonmap
lt=KEY_Z,rt=BTN_LEFT --ui-buttonmap
dl=KEY_4,dr=KEY_2,du=REL_WHEEL:-1:150,dd=REL_WHEEL:1:150
--ui-buttonmap back=KEY_TAB,start=KEY_ESC -s --deadzone 6000
--dpad-as-button --trigger-as-button</p>

<p style="margin-top: 1em">WRITING START-UP SCRIPTS FOR
GAMES <br>
When you want full game specific configurability and
automatic launching of xboxdrv, it is easiest to write
little startup scripts for your games that will launch
xboxdrv, launch <br>
your game and then when the game is finished tear down
xboxdrv:</p>

<p style="margin-top: 1em">#!/bin/sh</p>

<p style="margin-top: 1em">exec xboxdrv --trigger-as-button
-s -- your_favorite_game</p>

<p style="margin-top: 1em"># EOF #</p>

<p style="margin-top: 1em">Here your_favorite_game is the
executable of your game and is passed to xboxdrv as last
argument. This will cause xboxdrv to start the game and keep
running as long as the game <br>
is running, when the game is done, xboxdrv will quit
automatically.</p>

<p style="margin-top: 1em">If you want to pass parameters
to the game you have to add a -- separator, as otherwise
your options to the game would be eaten up by xboxdrv.</p>

<p style="margin-top: 1em">SDL NOTES <br>
To let SDL know which axis act as a hat and which act as
normal axis you have to set an environment variable:</p>

<p style="margin-top: 1em">$
SDL_LINUX_JOYSTICK=&quot;&rsquo;Xbox Gamepad (userspace
driver)&rsquo; 6 1 0&quot; <br>
$ export SDL_LINUX_JOYSTICK</p>

<p style="margin-top: 1em">You might also need in addition
use this (depends on the way SDL was compiled):</p>

<p style="margin-top: 1em">$
SDL_JOYSTICK_DEVICE=&quot;/dev/input/js0&quot; <br>
$ export SDL_JOYSTICK_DEVICE</p>

<p style="margin-top: 1em">This will let the DPad act as
Hat in SDL based application. For many games the driver will
work without this, but especially in Dosbox this variable is
very important.</p>

<p style="margin-top: 1em">If you use options in xboxdrv
that change the number of axis you have to adjust the
variable accordingly, see:</p>

<p style="margin-top: 1em">&Acirc;&middot;
&acirc;&uml;ftp://ptah.lnf.kth.se/pub/misc/sdl-env-vars&acirc;&copy;</p>

<p style="margin-top: 1em">SDL_LINUX_JOYSTICK <br>
Special joystick configuration string for linux. The format
is &quot;name numaxes numhats numballs&quot; where name is
the name string of the joystick (possibly in single quotes),
and <br>
the rest are the number of axes, hats and balls
respectively.</p>

<p style="margin-top: 1em">SDL_JOYSTICK_DEVICE <br>
Joystick device to use in the linux joystick driver, in
addition to the usual: /dev/js*, /dev/input/event*,
/dev/input/js*</p>

<p style="margin-top: 1em">TROUBLESHOOTING <br>
&quot;NO XBOX OR XBOX360 CONTROLLER FOUND&quot; <br>
This means that either your controller isn&rsquo;t plugged
in or is not recognized by the driver. To fix this you need
to know the idVendor and the idProduct numbers, which you
can <br>
find out via:</p>

<p style="margin-top: 1em">$ lsusb -v</p>

<p style="margin-top: 1em">Once done you can try to add
them to this array in src/xpad_device.cpp:</p>

<p style="margin-top: 1em">XPadDevice xpad_devices[] = {
... }</p>

<p style="margin-top: 1em">If you have success with that,
send a patch to &lt;grumbel@gmail.com&gt;, if not, contact
me too, I might be able to provide additional help.</p>

<p style="margin-top: 1em">As an alternative you can also
use the --device and --type option to enforce a USB device
as well as a controller type an bypass any auto
detection.</p>

<p style="margin-top: 1em">&quot;UNKNOWN DATA: BYTES: 3
DATA: ...&quot; <br>
This means that your controller is sending data that
isn&rsquo;t understood by the driver. If your controller
still works, you can just ignore it, the Xbox360 controller
seems to send <br>
out useless data every now and then. If your controller does
not work and you get plenty of those lines when you move the
sticks or press buttons it means that your controller <br>
talks an un-understood protocol and some reverse enginiering
is required. Contact &lt;grumbel@gmail.com&gt; and include
the output of:</p>

<p style="margin-top: 1em">$ lsusb -v</p>

<p style="margin-top: 1em">Along with all the &quot;Unknown
data&quot; lines you get.</p>

<p style="margin-top: 1em">&quot;ERROR: NO STUITABLE UINPUT
DEVICE FOUND&quot; <br>
Make sure that uinput and joydev kernel modules are loaded.
Make sure that you have a /dev/input/uinput, /dev/uinput or
/dev/misc/uinput and permissions to access it.</p>

<p style="margin-top: 1em">Before reporting this as a bug
make sure you have tested if the driver itself works
with:</p>

<p style="margin-top: 1em">$ xboxdrv --no-uinput -v</p>

<p style="margin-top: 1em">THE WIRELESS CONTROLLER
DOESN&rsquo;T WORK <br>
You have to sync the controller befor it can be used,
restart of the driver isn&rsquo;t needed and the driver
should let you now when it recieves a connection after you
sync the con&acirc; <br>
troller.</p>

<p style="margin-top: 1em">KEYBOARD EMULATION <br>
When you try to let xboxdrv send a keyboard events via
--ui-buttonmap or --ui-axismap Xorg must register the device
as keyboard device to work properly. This seems to work
auto&acirc; <br>
matically when you bind more then two keyboard keys, if you
bind less you need to create the file
/etc/hal/fdi/preprobe/xboxdrv.fdi containing:</p>

<p style="margin-top: 1em">&lt;?xml version=&quot;1.0&quot;
encoding=&quot;UTF-8&quot;?&gt; <br>
&lt;deviceinfo version=&quot;0.2&quot;&gt; <br>
&lt;device&gt; <br>
&lt;match key=&quot;input.product&quot; string=&quot;Xbox
Gamepad (userspace driver) - Keyboard Emulation&quot;&gt;
<br>
&lt;addset key=&quot;info.capabilities&quot;
type=&quot;strlist&quot;&gt;input.keys&lt;/addset&gt; <br>
&lt;/match&gt; <br>
&lt;/device&gt; <br>
&lt;/deviceinfo&gt;</p>

<p style="margin-top: 1em">This will tell HAL and later
Xorg that xboxdrv acts as keyboard.</p>

<p style="margin-top: 1em">WACOM ISSUES <br>
In some older kernels a Wacom graphic tablet creates a
joystick device, so xboxdrv or any other real joysticks ends
up as /dev/input/js1 instead of /dev/input/js0. In many
games <br>
this causes the joystick to not function any more.</p>

<p style="margin-top: 1em">A temporary workaround for this
is to simply delete the joystick device js0 and replace it
with a symbolic link js1 via:</p>

<p style="margin-top: 1em">$ sudo ln -sf /dev/input/js1
/dev/input/js0</p>

<p style="margin-top: 1em">This workaround will only last
till the next reboot, since the device names are dynamically
created, but for the time being there doesn&rsquo;t seem to
any other way to easily work <br>
around this issue.</p>

<p style="margin-top: 1em">In newer kernels this issue is
fixed.</p>

<p style="margin-top: 1em">UINPUT ISSUES <br>
On Ubuntu 9.04 the permissions of the uinput device have
changed to 0640, meaning only root has access to the device.
To change this back so that users in the group root have
<br>
access the device and in turn can run xboxdrv without sudo
you have to create a file called
/etc/udev/rules.d/55-permissions-uinput.rules with the
content:</p>

<p style="margin-top: 1em">KERNEL==&quot;uinput&quot;,
MODE=&quot;0660&quot;, GROUP=&quot;root&quot;</p>

<p style="margin-top: 1em">WINE ISSUES <br>
When using the Xbox360 gamepad in Wine it is not specially
handled as Xbox360 gamepad, but as generic DirectInput
gamepad. This means games will not display the proper button
<br>
labels, but just numbers (i.e. &rsquo;Btn1&rsquo; instead of
&rsquo;A&rsquo; for example). Aside from that it should work
fine.</p>

<p style="margin-top: 1em">XInput support (the Microsoft
DirectInput replacment, not the Xorg xinput) is as of
January 2011 not implemented in Wine, so games that require
XInput and don&rsquo;t have an DirectIn&acirc; <br>
put fallback will not work with a Xbox360 controller,
unofficial patches however do exist.</p>

<p style="margin-top: 1em">XORG ISSUES <br>
If you start xboxdrv and instead of having a fully working
joystick, you end up controlling the mouse that might be due
to recent changes in Xorg and its device hotplug handling.
<br>
There are four workarounds, the one that involves editing
/etc/hal/fdi/policy/preferences.fdi is the recommont
one.</p>

<p style="margin-top: 1em">TEMPORARY WORKAROUND USING
HAL-DEVICE <br>
Get the device id from hal:</p>

<p style="margin-top: 1em">$ hal-find-by-property --key
&rsquo;info.product&rsquo; --string &rsquo;Xbox Gamepad
(userspace driver)&rsquo;</p>

<p style="margin-top: 1em">Then remove the device from hal
with:</p>

<p style="margin-top: 1em">$ hal-device -r $DEVICEID</p>

<p style="margin-top: 1em">TEMPORARY WORKAROUND USING
XINPUT <br>
Second workaround works with xinput:</p>

<p style="margin-top: 1em">$ xinput list <br>
$ xinput set-int-prop $DEVICEID &rsquo;Device Enabled&rsquo;
32 0</p>

<p style="margin-top: 1em">PERMANENT WORKAROUND USING .FDI
FILES <br>
The former two workarounds are just temporary and have to be
redone after each start of xboxdrv, the last workaround is a
permanent one:</p>

<p style="margin-top: 1em">You have to edit:</p>


<p style="margin-top: 1em">/etc/hal/fdi/policy/preferences.fdi</p>

<p style="margin-top: 1em">And insert the following
lines:</p>

<p style="margin-top: 1em">&lt;match
key=&quot;input.product&quot; string=&quot;Xbox Gamepad
(userspace driver)&quot;&gt; <br>
&lt;remove key=&quot;input.x11_driver&quot; /&gt; <br>
&lt;/match&gt;</p>

<p style="margin-top: 1em">PERMANENT WORKAROUND BY
DISABLING DEVICE AUTO DETECTION <br>
A fourth workaround involved disabling the autodetection of
Xorg completly, you can do that by adding the following
lines to /etc/X11/xorg.conf:</p>

<p style="margin-top: 1em">Section &quot;ServerFlags&quot;
<br>
Option &quot;AutoAddDevices&quot; &quot;False&quot; <br>
EndSection</p>

<p style="margin-top: 1em">Note that without auto detection
you will have to manually configure all your mice and
keyboards or your Xorg Server won&rsquo;t start up properly.
So unless you are already familiar <br>
with editing Xorg you better avoid this workaround.
Workaround 3) has basically the same effect, except that
auto detection only gets disabled for the single device it
is causing <br>
problems.</p>

<p style="margin-top: 1em">FORCE FEEDBACK PROGRAMMING <br>
For documentation on the FF interface see:</p>

<p style="margin-top: 1em">&Acirc;&middot;
&acirc;&uml;http://github.com/github/linux-2.6/blob/f3b8436ad9a8ad36b3c9fa1fe030c7f38e5d3d0b/Documentation/input/ff.txt&acirc;&copy;</p>

<p style="margin-top: 1em">&Acirc;&middot;
/usr/include/linux/input.h</p>

<p style="margin-top: 1em">Additional, non Linux related,
force feedback related information can be found at:</p>

<p style="margin-top: 1em">&Acirc;&middot;
&acirc;&uml;http://www.immersion.com/developer/downloads/ImmFundamentals/HTML/&acirc;&copy;</p>

<p style="margin-top: 1em">&Acirc;&middot;
&acirc;&uml;http://msdn.microsoft.com/en-us/library/bb219655(VS.85).aspx&acirc;&copy;</p>

<p style="margin-top: 1em">fftest is an application you can
use to test the force feedback interface.</p>

<p style="margin-top: 1em">Force feedback is disabed by
default since it causes trouble in certain application.
&quot;Tomb Raider: Legend&quot; for example when run in Wine
crashes at startup when rumble is enabled, <br>
while it works perfectly normal when rumble is disabled.</p>

<p style="margin-top: 1em">BUGS <br>
X11 KEYSYM ISSUES <br>
X11 keysyms might not work correctly in --ui-buttonmap
a=XK_Foobar when Foobar is mapped to multiple keycodes in
the keymap.</p>

<p style="margin-top: 1em">Workaround: Use KEY_ instead or
cleanup your keymap</p>

<p style="margin-top: 1em">Newer versions of Xorg will also
do perform some auto configuration that might lead to your
keymap being switched whenever a new keyboard is detected,
in cases of custom Xmodmaps <br>
this might confuse xboxdrv and make the XK_ style names
unusable. No workaround for that is known right now.</p>

<p style="margin-top: 1em">NON-INTERRUPTABLE PROCESSES DUE
TO FORCE FEEDBACK <br>
Force feedback support is brittle, if you Ctrl-c the driver
in the wrong moment you will end up with a dead
uninterruptable process and basically have to reboot. This
looks like <br>
it might be a kernel issue and not a xboxdrv one.</p>

<p style="margin-top: 1em">Workaround: Kill the app that
uses xboxdrv before xboxdrv itself.</p>

<p style="margin-top: 1em">QUESTIONS, BUG REPORTS AND
FEATURE REQUESTS <br>
Bug reports and feature request can be report to the xboxdrv
issue tracker at:</p>


<p style="margin-top: 1em">&acirc;&uml;https://github.com/Grumbel/xboxdrv/issues/new&acirc;&copy;</p>

<p style="margin-top: 1em">General questions and requests
for configuration help should be directed to the xboxdrv
mailing list at:</p>


<p style="margin-top: 1em">&acirc;&uml;http://groups.google.com/group/xboxdrv&acirc;&copy;</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright &Acirc;&copy; 2010-2011 Ingo Ruhnke
&lt;grumbel@gmail.com&gt; License GPLv3+: GNU GPL version 3
or later
&acirc;&uml;http://gnu.org/licenses/gpl.html&acirc;&copy; .
This is free software: you are free to <br>
change and redistribute it. There is NO WARRANTY, to the
extent permitted by law.</p>

<p style="margin-top: 1em">SEE ALSO <br>
xboxdrvctl(1), evtest(1), jstest(1), jstest-gtk(1), xev(1),
fftest(1), lsusb(1)</p>

<p style="margin-top: 1em">0.8.3 2011-07-20 xboxdrv (1)</p>
<hr>
</body>
</html>
