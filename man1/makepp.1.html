<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>MAKEPP(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MAKEPP(1)</td>
    <td class="head-vol">Makepp</td>
    <td class="head-rtitle">MAKEPP(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
makepp -- Compatible but improved replacement for make
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>makepp</b> [&#x00A0;-e&#x00A0;] [&#x00A0;-C&#x00A0;<i>dir</i>&#x00A0;]
  [&#x00A0;-f&#x00A0; <i>makefile</i>]
  [&#x00A0;-F&#x00A0;<i>makefile_or_dir</i>&#x00A0;]
<br/>
 [&#x00A0;-j&#x00A0; <i>n</i>] [&#x00A0;-k&#x00A0;]
  [&#x00A0;-m&#x00A0;<i>method</i>&#x00A0;]
  [&#x00A0;--noremake-makefiles&#x00A0;]
<br/>
 [&#x00A0;--nowarn&#x00A0;] [&#x00A0;-q&#x00A0;] [&#x00A0;-R&#x00A0; <i>dir</i>]
  [&#x00A0;--traditional-recursive-make&#x00A0;]
<br/>
 [&#x00A0;-v&#x00A0;] [&#x00A0;--version&#x00A0;] [&#x00A0;
  <i>VAR=value</i>&#x00A0;...&#x00A0;] [&#x00A0;
  <i>target</i>&#x00A0;...&#x00A0;]
<div class="Pp"></div>
<b>mpp</b> [-options] [&#x00A0;<i>VAR=value</i>&#x00A0;...&#x00A0;]
  [&#x00A0;<i>target</i>&#x00A0;...&#x00A0;]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Makepp, a build program which has a number of features that allow for reliable
  builds and simpler build files, is a drop-in replacement for GNU make. It
  supports almost all of the syntax that GNU make supports, and can be used with
  makefiles produced by utilities such as automake. It is called makepp (or
  <b>make++</b>) because it was designed with special support for C++, which has
  since been extended to other languages like Swig or embedded SQL. Also its
  relationship to <b>make</b> is analogous to C++'s relationship to C: it is
  almost 100% backward compatible but adds a number of new features and much
  better ways to write makefiles.
<div class="Pp"></div>
Makepp passes an extensive test-suite, and is used in several big projects. If
  you have any issues with the latest CVS version, holler, and we'll try to fix
  it quickly. Makepp runs with any version of Perl since 5.8.
<div class="Pp"></div>
The following manual pages contain further information on how to use makepp:
<dl class="Bl-tag">
  <dt class="It-tag">Tutorial</dt>
  <dd class="It-tag">How to write a makefile. This is mostly intended for
      someone with little or no experience using any implementation of
    make.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Compilation Tutorial</dt>
  <dd class="It-tag">What the Unix compilation commands do.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Release Notes</dt>
  <dd class="It-tag">What changed with each release.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Incompatibilities</dt>
  <dd class="It-tag">What works differently between GNU make and makepp.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Speedup</dt>
  <dd class="It-tag">Various tips for making makepp go much faster.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Perl Performance</dt>
  <dd class="It-tag">Various tips for making Perl programming (within your
      makefiles and elsewhere) go faster.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Cookbook</dt>
  <dd class="It-tag">Quick answers to &quot;How do I ...?&quot; or &quot;What's
      the best way to ...?&quot;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">FAQ</dt>
  <dd class="It-tag">Quick answers to questions people have stumbled upon.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Build Algorithm</dt>
  <dd class="It-tag">How makepp's build algorithm differs in fundamental ways
      from traditional make.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Build Cache</dt>
  <dd class="It-tag">A build cache is a directory that stores the results of
      prior builds in case they are needed again in the same directory, or in a
      separate build in a different directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Build Check Methods</dt>
  <dd class="It-tag">How makepp decides when to build.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Builtin Commands</dt>
  <dd class="It-tag">Powerful, efficient commands available everwhere makepp 2.0
      or newer is.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Builtin Rules</dt>
  <dd class="It-tag">For very simple programs, you may not need a makefile at
      all! These are the builtin rules that makepp knows about.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Compatibility</dt>
  <dd class="It-tag">Where and and with what version of Perl makepp works.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Extending</dt>
  <dd class="It-tag">How you can add functions to makepp by writing your own
      Perl code.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Functions</dt>
  <dd class="It-tag">Functions for text manipulation and various other
    purposes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Repositories</dt>
  <dd class="It-tag">Repositories are a technique that simplifies both variant
      builds and keeping a central set of sources.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Rules</dt>
  <dd class="It-tag">Specifying rules to build files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Sandboxes</dt>
  <dd class="It-tag">Using sandboxes to partition the build.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Scanning</dt>
  <dd class="It-tag">How makepp scans for dependencies like include files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Signatures</dt>
  <dd class="It-tag">How makepp decides when files have changed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Statements</dt>
  <dd class="It-tag">Additional directives to control makepp.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Variables</dt>
  <dd class="It-tag">Using variables to simplify rules.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makepp, mpp</dt>
  <dd class="It-tag">Command line syntax of the main utility.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makeppclean, mppc</dt>
  <dd class="It-tag">An efficient stand-alone cleanup script to remove files
      generated by makepp.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makeppgraph, mppg</dt>
  <dd class="It-tag">A stand-alone utility to graphically analyze dependencies
      and the reasons for a rebuild.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makeppinfo, mppi</dt>
  <dd class="It-tag">A stand-alone utility to readably dump the build info
      makepp remembers about each file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makepplog, mppl</dt>
  <dd class="It-tag">A stand-alone utility to analyze dependencies and the
      reasons for a rebuild.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">makeppreplay, mppr</dt>
  <dd class="It-tag">A stand-alone utility to repeat things makepp has done, but
      much faster.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Index</dt>
  <dd class="It-tag">All keywords, functions and operators in makepp.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Features"><a class="selflink" href="#Features">Features</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">Automatic scanning for include files</dt>
  <dd class="It-tag">Makepp scans automatically for include files. This obviates
      the need for tools like makedepend. Makepp's scanner works even if the
      included files don't exist yet but have to be built. (This is true no
      matter where on the include path they come from, unlike programs that
      depend on gcc's &quot;-MM&#x00A0;-MG&quot; option.) Makepp has a flexible
      system for doing this which is based on scanning the build command; you
      can adapt it for other languages or build commands by writing a Perl
      subroutine.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Better system for hierarchical builds</dt>
  <dd class="It-tag">Makepp has a better system for handling builds involving
      multiple directories and multiple makefiles. The traditional technique is
      to have make invoke itself recursively in each directory. Depending on how
      complicated the interdependencies are, several recursive passes are
      sometimes needed. This makes the makefiles very complicated if they
      guarantee a correct build. The real problem is that unless dependencies
      are trivial (e.g., just one library file), it is almost impossible to
      express accurately dependencies of targets in one makefile in terms of
      targets from the other makefile. Unix make isn't smart enough to realize
      that a target in one makefile depends on a file that is a target in a
      lower-level makefile; it can't take build commands from the lower-level
      makefile while it is trying to build the target in the upper-level
      makefile. So the usual solution is to build everything that can be built
      with the lower-level makefiles, hoping that that's adequate to build
      everything that's needed for the upper-level makefile.
    <div style="height: 1.00em;">&#x00A0;</div>
    Makepp loads all the needed makefiles in at once, so it has no problem
      dealing with situations where a file from one makefile depends on a file
      produced by a different makefile. Makepp cd's automatically to the
      directory containing the makefile before executing a command from a
      makefile, so each makefile may be written independently without knowledge
      of the top-level build directory. But if access to the root of your build
      tree is important (e.g. because that's where your include directory
      resides), you can name the makefile in that directory specially. Then
      makepp gives you the path to that directory in a variable.
    <div style="height: 1.00em;">&#x00A0;</div>
    Makepp also can figure out where all the makefiles for the entire project
      are without being told, if each makefile is in the same directory as the
      files it is supposed to produce. This can also simplify makefiles a great
      deal.
    <div style="height: 1.00em;">&#x00A0;</div>
    For more details on building with multiple directories, see &quot;Tips for
      multiple directories&quot; in makepp_cookbook.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Reliable wildcards</dt>
  <dd class="It-tag">Makefiles can use wildcards reliably, because wild cards
      match either files that exist, <i>or</i> files that do not yet exist but
      makepp knows how to build. So even for a program with dozens of modules,
      your entire makefile could simply read something like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    CXX = g++
    CXXFLAGS = -g
 
    %.o : %.c
        $(CXX) $(CXXFLAGS) -c $(input) -o $(output)
 
    my_program: *.o
        $(CXX) $(inputs) -o $(output)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and this will work even if none of the &quot;.o&quot; files have been built
      yet.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Reliable builds: remembers build command</dt>
  <dd class="It-tag">Makepp keeps track of the build commands, so that if
      compilation options change, files are automatically rebuilt. This is
      important to guarantee correct builds. (This idea was taken from Bob
      Sidebothem's &quot;cons&quot; utility, which was described in the Perl
      Journal in 1998 and is available from CPAN.)
    <div style="height: 1.00em;">&#x00A0;</div>
    To illustrate why this is important, consider the following structure
      definition:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    class ABC {
      int x;
    #ifndef SPECIAL_OPTION
      int y;
    #endif
      int z;
    };
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Now suppose you decide to turn on the &quot;SPECIAL_OPTION&quot; option by
      adding &quot;-DSPECIAL_OPTION&quot; to the command line. A recompilation
      of everything is needed, but a traditional Unix make will not detect this,
      and will only recompile source files which have actually changed. As a
      result, some of your modules will be compiled with -DSPECIAL_OPTION, and
      others won't. After a very frustrating debugging session, you will
      discover that all that needs to be done is to rebuild everything. Then you
      will curse make and hopefully switch to an improved implementation of it,
      like makepp. At least, that's what I did.
    <div style="height: 1.00em;">&#x00A0;</div>
    As another example, suppose that you are working on a project which is
      pretty well debugged, so it's usually compiled with &quot;-O2&quot;. Now
      you run into a bug which you need to look at in the debugger. Code
      compiled with optimization is difficult to examine in the debugger, so you
      want to recompile your code so that you can look at it. If your makefile
      is set up to store the compiler options in the usual variables, you can
      just do this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    makepp CFLAGS=-g CXXFLAGS=-g
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and makepp will know that the command line has changed for all the modules.
      Then when you've found your bug, just type
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    makepp
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and it will be recompiled with optimization. You don't need to type
      &quot;make clean&quot; when you change build options.
    <div style="height: 1.00em;">&#x00A0;</div>
    Some makefiles (e.g., those for the Linux kernel) go to incredible lengths
      to force recompilation when the compile command changes. With makepp, it's
      taken care of automatically--you don't have to do anything.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Reliable builds: exact matching of signature</dt>
  <dd class="It-tag">By default, makepp doesn't merely ensure that all targets
      are newer than all dependencies; if you replace a dependency with an older
      file, makepp knows that it has to rebuild the target, simply because the
      input file has changed. This is another important feature to guarantee
      correct builds which was taken from the &quot;cons&quot; utility.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Smart signature calculations</dt>
  <dd class="It-tag">Some modifications to source files do not actually require
      a rebuild. For example, if you just change a comment line, or if you
      reindent some code, there is no particular reason to force a compilation.
      For C/C++ compilation, makepp determines whether a file needs
      recompilation by computing a cryptographic checksum of the file's
      contents, ignoring comments and whitespace, instead of looking at the file
      time.
    <div style="height: 1.00em;">&#x00A0;</div>
    This is particularly useful if you have include files that are generated by
      files that change, and yet the generated include files themselves seldom
      change. Suppose you have a complicated yacc grammar in your program, with
      a build rule like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    y.tab.c y.tab.h: parser.y
        yacc -d parser.y
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Ordinarily, every time you make even a tiny change to &quot;parser.y&quot;,
      every file that depends on &quot;y.tab.h&quot; must be rebuilt since the
      file time of &quot;y.tab.h&quot; has changed. However, most changes to
      &quot;parser.y&quot; won't actually change the contents of
      &quot;y.tab.h&quot; (except possibly a comment), so all that recompilation
      is unnecessary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Repositories</dt>
  <dd class="It-tag">Makepp can automatically incorporate files from a different
      directory tree (the &quot;repository&quot;) into the current build tree as
      needed. (This idea was also taken from the &quot;cons&quot; program.) This
      has several interesting uses:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">Variant builds</dt>
  <dd class="It-tag">Suppose you have been compiling your program with
      optimization on and debugging off. Now a bug crops up and you have to
      recompile everything with debugging enabled. Once you find the bug,
      however, you're going to turn debugging off and optimization back on, and
      with most make programs you would have to recompile all the sources again,
      even the ones that did not change. The procedure would look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    % makepp CFLAGS=-O2                 # Compile everything.
    # oops, bug discovered here
    % makepp CFLAGS=-g                  # Recompiles everything again.
    gdb my_program
    # ... find the bug
    % makepp CFLAGS=-O2                 # Recompiles everything a third time.
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    With makepp, you can simply cd to an empty directory, and specify your
      original directory as a repository. This will create new object files in
      the empty directory, while leaving your old object files intact. Now you
      can find the bug in the directory compiled with debug, fix it in your
      original sources, and then go back to your original directory. Now only
      the few files that you changed actually need to be recompiled.
    <div style="height: 1.00em;">&#x00A0;</div>
    The entire procedure would look like this:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    % makepp CFLAGS=-O2                 # Compile everything.
    # oops, bug discovered here
    % mkdir debugging
    % cd debugging
    % makepp -R .. CFLAGS=-g            # Compile with debugging enabled, but
                                        # put objects in debugging subdir.
    % gdb my_program
    # ... find the bug
    % cd ..                             # Back to original directory.
    % makepp CFLAGS=-O2                 # Recompiles only those files
                                        # that you changed.
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    This can be a tremendous savings in time if there are many modules.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Development team with common sources</dt>
  <dd class="It-tag">Suppose you have a team of developers working on a standard
      set of sources. Each developer is making independent changes, but doesn't
      need to have a copy of the whole source tree. Using makepp's repositories,
      you can have each developer have copies only of the files he has changed.
      Makepp will automatically and temporarily create symbolic links for the
      other files that have not been changed to the corresponding files in the
      repository. It can even do this for object files which exist in the
      repository and do not need to be recompiled in the developer's individual
      directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Guarantee correct rules</dt>
  <dd class="It-tag">If your rules do somthing which you didn't tell makepp
      about, the repository mechanism will not know to fetch those things. So
      something that builds normally but fails from a repository tells you to
      fix your rules.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag">Automatic inference of needed &quot;.o&quot; files</dt>
  <dd class="It-tag">Makepp can often infer exactly which objects are actually
      necessary without being explicitly told. If you use this feature, then if
      one of your source file includes &quot;xx.h&quot;, and there is a file
      called &quot;xx.o&quot; that makepp knows how to make, then makepp adds
      &quot;xx.o&quot; to the link command line. I don't use non-shared
      libraries now in many places where I used to, because makepp can
      automatically pick out the modules I need.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Correct handling of aliases for directories</dt>
  <dd class="It-tag">Makepp won't be confused by soft links to a directory or by
      different relative filenames that refer to the same file. All directory
      paths to a file are recognized, including <i>foo</i>, <i>./foo</i>,
      <i>../src/foo</i>, <i>/auto_mnt/somedisk/bob/src/foo</i>, and
      <i>/users/bob/src/foo</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Filenames with special characters</dt>
  <dd class="It-tag">Makepp can support filenames with colons or spaces or other
      special characters that cause trouble for the traditional make. Just
      surround the filename with quotes. (See &quot;Special characters&quot; in
      makepp_rules for details.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Extensible textual substutition functions</dt>
  <dd class="It-tag">Makepp can use arbitrary Perl subroutines for textual
      substitution in the makefile. If you know Perl, you are not constrained at
      all by the set of makepp's builtin textual manipulation functions.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also simply write Perl code in your makefile. You can manipulate
      Make variables with the full power of the entire Perl language. See
      makepp_variables for details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Logging of build decisions</dt>
  <dd class="It-tag">By default, makepp makes a log-file viewable with
      makepplog, mppl that contains a description of every file that it tried to
      build, what rule was used to build it, what it depended on, and (if the
      file was rebuilt) why. This can be extremely useful for debugging a
      makefile--if you're wondering why makepp decided to rebuild a file, or why
      it didn't, you can just look in the log file where it explains the
      decisions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Improved support for parallel builds</dt>
  <dd class="It-tag">Makepp supports parallel compilations, but (unlike other
      make implementations) it won't mix output from separate processes which
      are running simultaneously.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">Synonyms for cryptic variables</dt>
  <dd class="It-tag">Makepp supports easier-to-remember synonyms for the cryptic
      make variables $@, $^, and $&lt;. See makepp_variables for details.</dd>
</dl>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-11-28</td>
    <td class="foot-os">perl v5.24.1</td>
  </tr>
</table>
</body>
</html>
