<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>mpqc(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">mpqc(1)</td>
    <td class="head-vol">MPQC</td>
    <td class="head-rtitle">mpqc(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
mpqc - The Massively Parallel Quantum Chemistry program (MPQC) computes the
  properties of molecules from first principles.
<div class="Pp"></div>
This documentation is divided into the following chapters:
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MPQC Overview</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Running MPQC</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MPQC Input</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Validating MPQC</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Running Psi 3 from MPQC</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>CCA Components</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MPQC License</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MPQC Warranty</b></dd>
</dl>
<h1 class="Sh" title="Sh" id="MPQC_Overview"><a class="selflink" href="#MPQC_Overview">MPQC
  Overview</a></h1>
The Massively Parallel Quantum Chemistry program (MPQC) computes the properties
  of molecules, <i>ab initio</i>, on a wide variety of computer architectures.
<div class="Pp"></div>
MPQC can compute closed shell and general restricted open-shell Hartree-Fock
  energies and gradients, second order open-shell perturbation theory (OPT2[2])
  and Z-averaged perturbation theory (ZAPT2) energies, and second order closed
  shell Moeller-Plesset perturbation theory energies and gradients. It also
  includes methods for optimizing molecules in either Cartesian or internal
  coordinates.
<div class="Pp"></div>
MPQC is designed using object-oriented programming techniques and implemented in
  the C++ programming language.
<h1 class="Sh" title="Sh" id="Running_MPQC"><a class="selflink" href="#Running_MPQC">Running
  MPQC</a></h1>
This chapter explains how to run MPQC in a variety of environments.
<div class="Pp"></div>
The first two sections give general information on running MPQC:
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Command Line Options</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Environmental Variables</b></dd>
</dl>
<div class="Pp"></div>
The final sections given specific information on running MPQC in different
  environments:
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Shared Memory Multiprocessor with SysV IPC</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Shared Memory Multiprocessor with POSIX Threads</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Shared or Distributed Memory Multiprocessor with
    MPI</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Special Notes for MP2 Gradients</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Special Notes for MP2-R12 energies</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Special Notes for CCA Components</b></dd>
</dl>
<h2 class="Ss" title="Ss" id="Command_Line_Options"><a class="selflink" href="#Command_Line_Options">Command
  Line Options</a></h2>
MPQC can be given options followed by an optional input file name. If the input
  file name is not given, it will default to 'mpqc.in'. The following command
  line options are recognized:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-o<b></b></dt>
  <dd class="It-tag">Gives the name of the output file. The default is the
      console.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-i<b></b></dt>
  <dd class="It-tag">Convert a simple input file to an object oriented input
      file and write the result to the ouput. No calculations are done.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-messagegrp<b></b></dt>
  <dd class="It-tag">A ParsedKeyVal specification of a MessageGrp object. The
      default depends on how MPQC was compiled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-memorygrp<b></b></dt>
  <dd class="It-tag">A ParsedKeyVal specification of a MemoryGrp object. The
      default depends on how MPQC was compiled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-threadgrp<b></b></dt>
  <dd class="It-tag">A ParsedKeyVal specification of a ThreadGrp object. The
      default depends on how MPQC was compiled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-integral<b></b></dt>
  <dd class="It-tag">A ParsedKeyVal specification of an Integral object. The
      default is IntegralV3. Note that some MolecularEnergy specializations
      require specific choices of Integral specializations and may not work with
      IntegralV3.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-l<b></b></dt>
  <dd class="It-tag">Sets a limit on the number of basis functions. The default
      is zero, which means an unlimited number of basis functions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-W<b></b></dt>
  <dd class="It-tag">Sets the working directory. The default is the current
      directory.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-c<b></b></dt>
  <dd class="It-tag">Check the input and exit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-v<b></b></dt>
  <dd class="It-tag">Print the version number.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-w<b></b></dt>
  <dd class="It-tag">Print the warranty information (there is no warranty).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-d<b></b></dt>
  <dd class="It-tag">If a debugger object was given in the input, start the
      debugger running as soon as MPQC is started.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-h<b></b></dt>
  <dd class="It-tag">Print a list of options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-f<b></b></dt>
  <dd class="It-tag">The name of an object-oriented input file. The default is
      mpqc.in. This cannot be used if another input file is specified. This
      option is deprecated, as both input file formats can be read by given the
      input file name on the command line without any option flags.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-cca-path<b></b></dt>
  <dd class="It-tag">A colon-separated list of directories in which CCA
      component libraries may be found.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>-cca-load<b></b></dt>
  <dd class="It-tag">A colon-separated list of sidl class names for CCA
      components which will be instantiated from the libraries found in the path
      given by -cca-path</dd>
</dl>
<div class="Pp"></div>
Some MPI environments do not pass the command line to slave programs, but supply
  it when MPI_Init is called. To make MPQC call MPI_Init with the correct
  arguments as early as possible use the configure option
  --enable-always-use-mpi.
<h2 class="Ss" title="Ss" id="Environmental_Variables"><a class="selflink" href="#Environmental_Variables">Environmental
  Variables</a></h2>
MPQC looks at five environmental variables to set up communication, find library
  files, and specify the default Integral object. Machine specific libraries and
  utilities to run programs in parallel might look at other environment
  variables as well. The five that apply on all platforms are:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>SCLIBDIR<b></b></dt>
  <dd class="It-tag">The name of the library directory. See the GaussianBasisSet
      documentation and look below for more information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>MESSAGEGRP<b></b></dt>
  <dd class="It-tag">A ParsedKeyVal specification of a MessageGrp object. The
      default depends on how MPQC was compiled. See the MessageGrp class
      documentation for more information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>MEMORYGRP<b></b></dt>
  <dd class="It-tag">A ParsedKeyVal specification of a MemoryGrp object. The
      default depends on how MPQC was compiled and the MessageGrp in use.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>THREADGRP<b></b></dt>
  <dd class="It-tag">A ParsedKeyVal specification of a ThreadGrp object. The
      default depends on how MPQC was compiled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>INTEGRAL<b></b></dt>
  <dd class="It-tag">A ParsedKeyVal specification of an Integral object. The
      default is IntegralV3. Note that some MolecularEnergy specializations
      require specific choices of Integral specializations and may not work with
      IntegralV3.</dd>
</dl>
<div class="Pp"></div>
By default, MPQC tries to find library files first in the lib subdirectory of
  the installation directory and then the source code directory. If the library
  files cannot be found, MPQC must be notified of the new location with the
  environmental variable SCLIBDIR.
<div class="Pp"></div>
For example, if you need to run MPQC on a machine that doesn't have the source
  code distribution in the same place as it was located on the machine on which
  MPQC is compiled you must do something like the following on the machine with
  the source code:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
cd mpqc/lib
tar cvf ../sclib.tar basis atominfo.kv
</pre>
<div class="Pp"></div>
Then transfer sclib.tar to the machine on which you want to run MPQC and do
  something like
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
mkdir ~/sclib
cd ~/sclib
tar xvf ../sclib.tar
setenv SCLIBDIR ~/sclib
</pre>
<div class="Pp"></div>
The setenv command is specific to the C-shell. You will need to do what is
  appropriate for your shell.
<div class="Pp"></div>
The other three keywords specify objects. This is done by giving a mini
  ParsedKeyVal input in a string. The object is anonymous, that is, no keyword
  is associated with it. Here is an example:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
setenv MESSAGEGRP '&lt;ShmMessageGrp&gt;:(n = 4)'
</pre>
<h2 class="Ss" title="Ss" id="Shared_Memory_Multiprocessor_with_SysV_IPC"><a class="selflink" href="#Shared_Memory_Multiprocessor_with_SysV_IPC">Shared
  Memory Multiprocessor with SysV IPC</a></h2>
By default, MPQC will run on only one CPU. To specify more, you can give a
  ShmMessageGrp object on the command line. The following would run MPQC in four
  processes:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
mpqc -messagegrp '&lt;ShmMessageGrp&gt;:(n = 4)' input_file
</pre>
<div class="Pp"></div>
Alternately, the ShmMessageGrp object can be given as an environmental variable:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
setenv MESSAGEGRP '&lt;ShmMessageGrp&gt;:(n = 4)'
mpqc input_file
</pre>
<div class="Pp"></div>
If MPQC should unexpectedly die, shared memory segments and semaphores will be
  left on the machine. These should be promptly cleaned up or other jobs may be
  prevented from running successfully. To see if you have any of these resources
  allocated, use the ipcs command. The output will look something like:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
IPC status from /dev/kmem as of Wed Mar 13 14:42:18 1996
T     ID     KEY        MODE       OWNER    GROUP
Message Queues:
Shared Memory:
m 288800 0x00000000 --rw-------  cljanss     user
Semaphores:
s    390 0x00000000 --ra-------  cljanss     user
s    391 0x00000000 --ra-------  cljanss     user
</pre>
<div class="Pp"></div>
To remove the IPC resources used by cljanss in the above example on IRIX, type:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
ipcrm -m 288800
ipcrm -s 390
ipcrm -s 391
</pre>
<div class="Pp"></div>
And on Linux, type:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
ipcrm shm 288800
ipcrm sem 390
ipcrm sem 391
</pre>
<h2 class="Ss" title="Ss" id="Shared_Memory_Multiprocessor_with_POSIX_Threads"><a class="selflink" href="#Shared_Memory_Multiprocessor_with_POSIX_Threads">Shared
  Memory Multiprocessor with POSIX Threads</a></h2>
By default, MPQC will run with only one thread. To specify more, you can give a
  PthreadThreadGrp object on the command line. MPQC is not parallelized to as
  large an extent with threads as it is with the more conventional distributed
  memory model, so you might not get the best performance using this technique.
  On the other the memory overhead is lower and no interprocess communication is
  needed.
<div class="Pp"></div>
The following would run MPQC in four threads:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
mpqc -threadgrp '&lt;PthreadThreadGrp&gt;:(num_threads = 4)' input_file
</pre>
<div class="Pp"></div>
Alternately, the PthreadThreadGrp object can be given as an environmental
  variable:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
setenv THREADGRP '&lt;PthreadThreadGrp&gt;:(num_threads = 4)'
mpqc input_file
</pre>
<h2 class="Ss" title="Ss" id="Shared_or_Distributed_Memory_Multiprocessor_with_MPI"><a class="selflink" href="#Shared_or_Distributed_Memory_Multiprocessor_with_MPI">Shared
  or Distributed Memory Multiprocessor with MPI</a></h2>
A MPIMessageGrp object is used to run using MPI. The number of nodes used is
  determined by the MPI run-time and is not specified as input data to
  MPIMessageGrp.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
mpqc -messagegrp '&lt;MPIMessageGrp&gt;:()' input_file
</pre>
<div class="Pp"></div>
Alternately, the MPIMessageGrp object can be given as an environmental variable:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
setenv MESSAGEGRP '&lt;MPIMessageGrp&gt;:()'
mpqc input_file
</pre>
<div class="Pp"></div>
Usually, a special command is needed to start MPI jobs; typically it is named
  mpirun.
<h2 class="Ss" title="Ss" id="Special_Notes_for_MP2_Gradients"><a class="selflink" href="#Special_Notes_for_MP2_Gradients">Special
  Notes for MP2 Gradients</a></h2>
The MP2 gradient algorithm uses MemoryGrp object to access distributed shared
  memory. The MTMPIMemoryGrp class is the most efficient and reliable
  implementation of MemoryGrp. It requires a multi-thread aware MPI
  implementation, which is still not common. To run MP2 gradients on a machine
  with POSIX threads and an multi-thread aware MPI, use:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
mpqc -messagegrp '&lt;MPIMessageGrp&gt;:()' \
     -threadgrp '&lt;PthreadThreadGrp&gt;:()' \
     -memorygrp '&lt;MTMPIMemoryGrp&gt;:()' \
     input_file
</pre>
<div class="Pp"></div>
or
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
setenv MESSAGEGRP '&lt;MPIMessageGrp&gt;:()'
setenv THREADGRP '&lt;PthreadThreadGrp&gt;:()'
setenv MEMORYGRP '&lt;MTMPIMemoryGrp&gt;:()'
mpqc input_file
</pre>
<h2 class="Ss" title="Ss" id="Special_Notes_for_MP2-R12_energies"><a class="selflink" href="#Special_Notes_for_MP2-R12_energies">Special
  Notes for MP2-R12 energies</a></h2>
<b>Distributed Memory</b>
<div class="Pp"></div>
The MP2-R12 energy algorithm is similar to the MP2 energy algorithm that uses
  MemoryGrp object to access distributed memory. Hence the MTMPIMemoryGrp is the
  recommended implementation of MemoryGrp for such computations (see <b>Special
  Notes for MP2 Gradients</b>).
<div class="Pp"></div>
<b>Disk I/O</b>
<div class="Pp"></div>
In contrast to the MP2 energy and gradient algorithms, the MP2-R12 energy
  algorithm may have to use disk to store transformed MO integrals if a single
  pass through the AO integrals is not possible due to insufficient memory. The
  best option in such case is to increase the total amount of memory available
  to the computation by either increasing the number of tasks or the amount of
  memory per task or both.
<div class="Pp"></div>
When increasing memory further is not possible, the user has to specify which
  type of disk I/O should be used for the MP2-R12 energy algorithm. It is done
  through the r12ints keyword in input for the MBPT2_R12 object. The default
  choice is to use POSIX I/O on the node on which task 0 resides. This kind of
  disk I/O is guaranteed to work on all parallel machines, provided there's
  enough disk space on the node. However, this is hardly most efficient on
  machines with some sort of parallel I/O available. On machines which have an
  efficient implementation of MPI-IO the r12ints should be set instead to
  mpi-mem. This will force the MBPT2_R12 object to use MPI-IO for disk I/O. It
  is user's responsibility to make sure that the MO integrals file resides on an
  MPI-IO-compatible file system. Hence the r12ints_file keyword, which specifies
  the name of the MO integrals file, should be set to a location which is
  guaranteed to work properly with MPI-IO. For example, on IBM SP and other IBM
  machines which have General Parallel File System (GPFS), the user should set
  r12ints = mpi-mem and r12ints_file to a file on a GPFS file system.
<div class="Pp"></div>
<b>Integral object</b>
<div>&#x00A0;</div>
<div class="Pp"></div>
At the moment, MBPT2_R12 objects require specific specialization of Integral,
  IntegralCints. Thus in order to compute MP2-R12 energies, your version of MPQC
  needs to be compiled with support for IntegralCints. A free, open-source
  library called libint is a prerequisite for IntegralCints. In order to use
  IntegralCints as the default Integral object, add -integral
  '&lt;IntegralCints&gt;:()' to the command line, or set environmental variable
  INTEGRAL to '&lt;IntegralCints&gt;:()'.
<h2 class="Ss" title="Ss" id="Special_Notes_for_CCA_Components"><a class="selflink" href="#Special_Notes_for_CCA_Components">Special
  Notes for CCA Components</a></h2>
<b>Common Component Architecture (CCA)</b>
<div class="Pp"></div>
Portions of MPQC functionality are being packaged into CCA components. For
  general overviews of CCA technology and framework usage, please see
  www.cca-forum.org (the tutorial in particular) and the cca-chem-apps
  documentation. MPQC components may be utilized directly within the ccaffeine
  framework, while some components may be instantiated and used within MPQC
  itself, making use of an embedded CCA framework.
<div class="Pp"></div>
<b>CCA Runtime Environment</b>
<div class="Pp"></div>
For MPQC runs utilizing embedded components, the runtime environment for the CCA
  framework must be specified. The colon-separated path used to locate component
  libraries must be specified either using the -cca-path command-line option or
  using the cca_path key within the mpqc section of a keyval input. The
  colon-separated list of component sidl class names which will be referenced
  within the input must be specified using either the -cca-load command-line
  option or using the cca_load key within the mpqc section of a keyval input. If
  defaults for the cca-path and cca-load options are desired, do_cca must be set
  to yes in the keyval input.
<h1 class="Sh" title="Sh" id="MPQC_Input"><a class="selflink" href="#MPQC_Input">MPQC
  Input</a></h1>
MPQC supports two input formats. The primary input is an object oriented format
  which gives users access to all of MPQC's options. The second format allows
  access to a subset of MPQC's capabilities, but is more intuitive and easier to
  learn. New users are advised to start with the simplified format. MPQC can be
  used to convert the simplified format to the full object-oriented format with
  the -i option.
<div class="Pp"></div>
Each of these input formats is described in the following two chapters:
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Simple Input</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Object-Oriented Input</b></dd>
</dl>
<h1 class="Sh" title="Sh" id="Simple_Input"><a class="selflink" href="#Simple_Input">Simple
  Input</a></h1>
The simple input format consists of keywords followed by a ':' followed by a
  value. The keywords are case sensitive. The values might be modified by
  options found in parenthesis. For example, the following input performs an
  optimization of water using density functional theory with the B3LYP
  exchange-correlation functional:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% B3LYP optimization of water
optimize: yes
method: KS (xc = B3LYP)
basis: 3-21G*
molecule: (angstrom)
    O    0.172   0.000   0.000
    H    0.745   0.000   0.754
    H    0.745   0.000  -0.754
</pre>
<div class="Pp"></div>
Comments begin with a % and continue to the end of the line. Basis set names
  containing special characters, such as a space or parentheses, must be quoted
  inside a pair of double quotes. The accepted keywords are:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>molecule<b></b></dt>
  <dd class="It-tag">Gives the atoms types and coordinates. The following
      options can be used</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>bohr<b></b></dt>
  <dd class="It-tag">The coordinates are given in Bohr.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>angstrom<b></b></dt>
  <dd class="It-tag">The coordinates are given in Angstroms (the default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>charge<b></b></dt>
  <dd class="It-tag">This option can be given after an 'element x y z'
      quadruple. This will override the charge on the atom. For example, (charge
      = 0) can be given for the ghost atoms in a counterpoise correction
      calculation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>multiplicity<b></b></dt>
  <dd class="It-tag">Gives the multiplicity of the molecule. The default is
    1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>optimize<b></b></dt>
  <dd class="It-tag">If yes, then an optimization will be performed. The default
      is no. The following options can be given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>cartesian<b></b></dt>
  <dd class="It-tag">Use Cartesian coordinates.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>internal<b></b></dt>
  <dd class="It-tag">Use internal coordinates.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>redundant<b></b></dt>
  <dd class="It-tag">Use redundant internal coordinates.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>gradient<b></b></dt>
  <dd class="It-tag">If yes, then a gradient calculation will be performed. The
      default is no.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>frequencies<b></b></dt>
  <dd class="It-tag">If yes, then the frequencies will be obtained. The default
      is no.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>charge<b></b></dt>
  <dd class="It-tag">Specificies the charge on the molecule. The default is
    0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>method<b></b></dt>
  <dd class="It-tag">Specifices the method. There is no default and the possible
      values are:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>HF<b></b></dt>
  <dd class="It-tag">Hartree-Fock. Unrestricted HF is used if multiplicity &gt;
      1</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>RHF<b></b></dt>
  <dd class="It-tag">Restricted Hartree-Fock.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>UHF<b></b></dt>
  <dd class="It-tag">Unrestricted Hartree-Fock.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>KS<b></b></dt>
  <dd class="It-tag">Kohn-Sham. Unrestricted KS is used if multiplicity &gt;
    1</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>RKS<b></b></dt>
  <dd class="It-tag">Restricted Kohn-Sham.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>UKS<b></b></dt>
  <dd class="It-tag">Unrestricted Kohn-Sham.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>MP2<b></b></dt>
  <dd class="It-tag">Second order Moeller-Plesset perturbation theory. Only
      available for multiplicity = 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>MP2-R12/A<b></b></dt>
  <dd class="It-tag">The A version of MP2-R12. Only available for multiplicity =
      1. An auxiliary basis may be specified. No gradient, optimization, or
      frequencies are possible.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>MP2-R12/A'<b></b></dt>
  <dd class="It-tag">The A' version of MP2-R12. Only available for multiplicity
      = 1. An auxiliary basis may be specified. No gradient, optimization, or
      frequencies are possible.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>ZAPT2<b></b></dt>
  <dd class="It-tag">Z-averaged perturbation theory. Only available for
      multiplicity &gt; 1. No gradient, optimization, or frequencies are
      possible.</dd>
</dl>
<div class="Pp"></div>
The following options are valid with the KS, RKS, and UKS methods:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>grid<b></b></dt>
  <dd class="It-tag">Specifies the grid to be used for numerical integrations.
      The following values can be given:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>xcoarse<b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>coarse<b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>medium<b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>fine<b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>xfine<b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>ultrafine<b></b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>xc<b></b></dt>
  <dd class="It-tag">Specifies the exchange-correlation functional. There is no
      default. See the table in the StdDenFunctional class documentation for the
      possible values.</dd>
</dl>
<div class="Pp"></div>
The following options are valid with the MP2-R12/A and MP2-R12/A' methods. These
  options are mutually exclusive:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>abs<b></b></dt>
  <dd class="It-tag">Use the standard Auxiliary Basis Set method.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>abs+<b></b></dt>
  <dd class="It-tag">Use the standard Auxiliary Basis Set method, but use the
      union of the orbital and the given auxiliary basis as the actual auxiliary
      basis set used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>cabs<b></b></dt>
  <dd class="It-tag">Use the Complementary Auxiliary Basis Set method.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>cabs+<b></b></dt>
  <dd class="It-tag">Use the Complementary Auxiliary Basis Set method, but use
      the union of the orbital and the given auxiliary basis as the actual
      auxiliary basis set used.</dd>
</dl>
<div class="Pp"></div>
The following options are valid with the MP2-R12/A' method:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>ebc<b></b></dt>
  <dd class="It-tag">Assume the Extended Brillion Condition to hold. This is the
      default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>gbc<b></b></dt>
  <dd class="It-tag">Assume the Generalized Brillion Condition to hold. This is
      the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>!ebc<b></b></dt>
  <dd class="It-tag">Do not assume the Extended Brillion Condition to hold.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>!gbc<b></b></dt>
  <dd class="It-tag">Do not assume the Generalized Brillion Condition to
    hold.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>basis<b></b></dt>
  <dd class="It-tag">Specifies the basis set. There is no default. See the table
      in the GaussianBasisSet class documentation for the available basis
    sets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>auxbasis<b></b></dt>
  <dd class="It-tag">Specifies the auxiliary basis set for MP2-R12 methods.
      There is no default. See the table in the GaussianBasisSet class
      documentation for the available basis sets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>restart<b></b></dt>
  <dd class="It-tag">Set to yes to restart an optimization. The default is
    no.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>checkpoint<b></b></dt>
  <dd class="It-tag">Set to no to not save checkpoint files during an
      optimization. The default is yes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>symmetry<b></b></dt>
  <dd class="It-tag">Specifices the Schoenflies symbol of the point group of the
      molecule. The default is auto, which will cause to program to find the
      highest order Abelian subgroup of the molecule.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>docc<b></b></dt>
  <dd class="It-tag">Gives the number of doubly occupied orbitals in each each
      irreducible representation in a parenthesized list. The symmetry must be
      specified and not be auto. The method must be restricted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>socc<b></b></dt>
  <dd class="It-tag">Gives the number of single occupied orbitals in each each
      irreducible representation in a parenthesized list. The symmetry must be
      specified and not be auto. The method must be restricted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>alpha<b></b></dt>
  <dd class="It-tag">Gives the number of alpha occupied orbitals in each each
      irreducible representation in a parenthesized list. The symmetry must be
      specified and not be auto. The method must be unrestricted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>beta<b></b></dt>
  <dd class="It-tag">Gives the number of beta occupied orbitals in each each
      irreducible representation in a parenthesized list. The symmetry must be
      specified and not be auto. The method must be unrestricted.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>frozen_docc<b></b></dt>
  <dd class="It-tag">Gives the number of frozen core orbitals. Can be either a
      single integer or a parenthesized list giving the frozen core orbitals in
      each irreducible representation. In the latter case the symmetry must be
      given and not be auto.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>frozen_uocc<b></b></dt>
  <dd class="It-tag">Gives the number of frozen virtual orbitals. Can be either
      a single integer or a parenthesized list giving the frozen virtual
      orbitals in each irreducible representation. In the latter case the
      symmetry must be given and not be auto.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>memory<b></b></dt>
  <dd class="It-tag">Gives a hint for the amount of memory in bytes that can be
      used. This is typically a lower bound, more memory will be used in
      practice and the exact amount cannot be precisely controlled. The format
      is a fixed or floating point number optionally followed (without spaces)
      by one of the following suffixes: KB, MB, GB, KIB, MIB, or GIB.</dd>
</dl>
<h1 class="Sh" title="Sh" id="Object-Oriented_Input"><a class="selflink" href="#Object-Oriented_Input">Object-Oriented
  Input</a></h1>
MPQC is an object-oriented program that directly allows the user to specify
  objects that MPQC then manipulates to obtain energies, properties, etc. This
  makes the input very flexible, but very complex. However, most calculations
  should be quite similar to the one of the examples given later in this
  chapter. The best way to get started is to use one of the example input files
  and modify it to meet your needs.
<div class="Pp"></div>
The object-oriented input format is described in the following sections:
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Overview of the Object-Oriented Input</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>A Walk-Through of an Object-Oriented Input File</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Sample Object-Oriented Input Files</b></dd>
</dl>
<h2 class="Ss" title="Ss" id="Overview_of_the_Object-Oriented_Input"><a class="selflink" href="#Overview_of_the_Object-Oriented_Input">Overview
  of the Object-Oriented Input</a></h2>
MPQC starts off by creating a ParsedKeyVal object that parses the input file
  specified on the command line. The format of the input file is documented in
  the KeyVal documentation. It is basically a free format input that associates
  keywords and logical groupings of keywords with values. The values can be
  scalars, arrays, or objects.
<div class="Pp"></div>
The keywords recognized by MPQC begin with the mpqc prefix. That is, they must
  be nested between an mpqc:( and a ). Alternately, each keyword can be
  individually prefixed by mpqc:. The primary keywords are given below. Some of
  the keywords specify objects, in which case the object will require more
  ParsedKeyVal input. These objects are created from the input by using their
  ParsedKeyVal constructors. These constructors are documented with the source
  code documentation for the class.
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>mole<b></b></dt>
  <dd class="It-tag">This is the most important keyword for MPQC. It specifies
      the MolecularEnergy object. This is an object that knows how to compute
      the energy of a molecule. The specializations of MolecularEnergy that are
      most commonly used are CLKS, HSOSKS, UKS, CLHF, HSOSHF, UHF, and
    MBPT2.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>opt<b></b></dt>
  <dd class="It-tag">This keyword must be specified for optimizations. It
      specifies an Optimize object. Usually, QNewtonOpt is best for finding
      minima and EFCOpt is best for transition states.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>freq<b></b></dt>
  <dd class="It-tag">This keyword must be specified to compute frequencies. It
      specifies a MolecularFrequencies object.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>thread<b></b></dt>
  <dd class="It-tag">This specifies an object of type ThreadGrp that can be used
      to advantage on shared-memory multiprocessor machines for certain types of
      calculations. This keyword can be overridden by giving the ThreadGrp in
      the environment or command line. See the section on running MPQC for more
      information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>integrals<b></b></dt>
  <dd class="It-tag">This specifies an object of type Integral that will be used
      as the default integral evaluator. If MP2-R12 is used, then this should be
      set to use IntegralCints with a line like integrals&lt;IntegralCints&gt;:
      ().</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>checkpoint<b> </b></dt>
  <dd class="It-tag">The value of this keyword is boolean.</dd>
</dl>
<div class="Pp"></div>
<pre>
    &lt;ul&gt;
<div class="Pp"></div>
    &lt;li&gt;&lt;tt&gt;true&lt;/tt&gt; and optimization is to be performed &lt;br&gt;
<div class="Pp"></div>
    &lt;tt&gt;opt&lt;/tt&gt; object will be checkpointed after each iteration.
    The checkpoint file suffix is &quot;.ckpt&quot;.
<div class="Pp"></div>
    &lt;li&gt;&lt;tt&gt;true&lt;/tt&gt; and optimization is not performed &lt;br&gt;
<div class="Pp"></div>
    &lt;tt&gt;mole&lt;/tt&gt; object will be checkpointed at intermediate points.
    The manner in which
    &lt;tt&gt;mole&lt;/tt&gt; will be checkpointed depends on its particular type.
    The checkpoint file suffix is usually &quot;.wfn&quot;, however
    in general it will depend on the particular specialization of
    &lt;tt&gt;MolecularEnergy&lt;/tt&gt;.
<div class="Pp"></div>
    &lt;/ul&gt;
<div class="Pp"></div>
    The default is to not checkpoint.
    &lt;/dd&gt;
<div class="Pp"></div>
</pre>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>checkpoint_freq<b></b></dt>
  <dd class="It-tag">This specifies how often to checkpoint certain
      MolecularEnergy specializations which compute iteratively. Currently, mole
      objects of SCF type can use this keyword. The default is 1, which means to
      checkpoint after every iteration.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>savestate<b></b></dt>
  <dd class="It-tag">The value of this keyword is boolean. If true, then the
      states of the Optimize and MolecularEnergy objects will be saved after the
      calculation completes. The output file suffixes are '.ckpt' and '.wfn',
      respectively. The default is to save state.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>restart<b></b></dt>
  <dd class="It-tag">The value of this keyword is boolean. If true, mpqc will
      attempt to restart the calculation. If the checkpoint file is not found,
      the calculation will continue as if the value were false. The default is
      true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>restart_file<b></b></dt>
  <dd class="It-tag">This gives the name of a file from which restart
      information is read. If the file name ends with '.wfn' then MPQC will try
      to restore a MolecularEnergy object from it and query for the opt object
      in the input file. If the file name ends with '.ckpt' MPQC will try to
      restore an Optimize object from this file. The default file name is formed
      by appending '.ckpt' to the input file name with the extension
    removed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>do_energy<b></b></dt>
  <dd class="It-tag">The value of this keyword is boolean. If true a single
      point energy calculation will be done for the MolecularEnergy object given
      with the mole keyword. The default is true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>do_gradient<b></b></dt>
  <dd class="It-tag">The value of this keyword is boolean. If true a single
      point gradient calculation will be done for the MolecularEnergy object
      given with the mole keyword. The default is false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>do_cca<b></b></dt>
  <dd class="It-tag">The value of this keywork is boolean. If true the cca
      embedded framework will be initialized. The default is false.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>cca_path<b></b></dt>
  <dd class="It-tag">The value of this keyword is a string that provides a
      colon-separated list of directories in which CCA component libraries may
      be found.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>cca_load<b></b></dt>
  <dd class="It-tag">The value of this keyword is a string that provides a
      colon-separated list of sidl class names for CCA components which will be
      instantiated from the libraries found in the path given by cca_path.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>optimize<b></b></dt>
  <dd class="It-tag">The value of this keyword is boolean. If true and the opt
      keyword was set to a valid value, then an optimization will be performed.
      The default is true.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>write_pdb<b></b></dt>
  <dd class="It-tag">The value of this keyword is boolean. If true a PDB file
      with the molecular coordinates will be written.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>filename<b></b></dt>
  <dd class="It-tag">The value of this keyword is a string that gives a name
      from which checkpoint and other filenames are constructed. The default is
      the basename of the input file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>print_timings<b></b></dt>
  <dd class="It-tag">If this is true, timing information is printed at the end
      of the run. The default is true.</dd>
</dl>
<div class="Pp"></div>
There are also some utility keywords that tell mpqc some technical details about
  how to do the calculation:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>debug<b></b></dt>
  <dd class="It-tag">This optional keyword gives a Debugger object which can be
      used to help find the problem if MPQC encounters a catastrophic
    error.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>matrixkit<b></b></dt>
  <dd class="It-tag">This optional keyword gives a SCMatrixKit specialization
      which is used to produce matrices of the desired type. The default is a
      ReplSCMatrixKit which replicates matrices on all of the nodes. Other
      choices are not thoroughly tested.</dd>
</dl>
<h2 class="Ss" title="Ss" id="A_Walk-Through_of_an_Object-Oriented_Input_File"><a class="selflink" href="#A_Walk-Through_of_an_Object-Oriented_Input_File">A
  Walk-Through of an Object-Oriented Input File</a></h2>
This example input does a Hartree-Fock calculation on water. Following is the
  entire input, followed by a breakdown with descriptions.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% This input does a Hartree-Fock calculation on water.
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
  )
)
</pre>
<div class="Pp"></div>
We start with a descriptive comment. Comments begin with a %. Everything from
  the % to the end of the line is ignored.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% This input does a Hartree-Fock calculation on water.
</pre>
<div class="Pp"></div>
Now lets set up a Molecule object. The name of the object comes first, it is
  molecule. Then, in angle brackets, comes the type of the molecule, which is
  the class Molecule. The keyword and class name are followed by a : and then
  several pieces of input grouped between a pair of matching parentheses. These
  parentheses contain the information that will be given to Molecule KeyVal
  constructor.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
molecule&lt;Molecule&gt;: (
</pre>
<div class="Pp"></div>
The point group of the molecule is needed. This is done by assigning symmetry to
  a case insensitive Schoenflies symbol that is used to initialize a PointGroup
  object. An Abelian point group should be used.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
  symmetry = C2V
</pre>
<div class="Pp"></div>
The default unit for the Cartesian coordinates is Bohr. You can specify other
  units by assigned unit to a string that will be used to initialize a Units
  object.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
  unit = angstrom
</pre>
<div class="Pp"></div>
Finally, the atoms and coordinates are given. This can be given in the shorthand
  table syntax shown below. The headings of the table are the keywords between
  the first pair of brackets. These are followed by an = and another pair of
  brackets that contain the data. The first datum is assigned to the first
  element of the array that corresponds to the first heading, atom. The second
  datum is assigned to the first element of the array associated with the second
  heading, geometry, and so on. Here the second datum is actually a vector: the
  x, y and z coordinates of the first atom.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
  { atoms                       geometry                   } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
</pre>
<div class="Pp"></div>
Next, a basis set object is given.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
</pre>
<div class="Pp"></div>
Now we will give the main body of input. All the subsequent keywords will be
  grouped in the mpqc section of the input (that is, each keyword will be
  prefixed with mpqc:).
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
mpqc: (
</pre>
<div class="Pp"></div>
Next we give the mole keyword which provides a specialization of the
  MolecularEnergy class. In this case we will do a closed-shell Hartree-Fock
  calculation. That is done with an object of type CLHF. The keywords that CLHF
  accepts are given with the documentation for the CLHF class, usually in the
  description of the const RefKeyVal&amp; constructor for the class. Also with
  the CLHF documentation is a list of parent classes. Each of the parent classes
  may also have input. This input is included with the rest of the input for the
  child class.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
  mole&lt;CLHF&gt;: (
</pre>
<div class="Pp"></div>
The next line specifies the molecule to be used. There are two things to note,
  first that this is actually a reference to complete molecule specification
  elsewhere in the input file. The $ indicates that this is a reference and the
  keyword following the $ is the actual location of the molecule. The : in front
  of the keyword means that the keyword is not relative to the current location
  in the input, but rather relative to the root of the tree of keywords. Thus,
  this line grabs the molecule that was specified above. The molecule object
  could have been placed here, but frequently it is necessary that several
  objects refer to the exact same object and this can only be done using
  references.
<div class="Pp"></div>
The second point is that if you look at the documentation for CLHF, you will see
  that it doesn't read molecule keyword. However, if you follow its parent
  classes up to MolecularEnergy, you'll find that molecule is indeed read.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
    molecule = $:molecule
</pre>
<div class="Pp"></div>
Just as we gave molecule, specify the basis set with the basis keyword as
  follows:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
    basis = $:basis
</pre>
<div class="Pp"></div>
Now we close off the parentheses we opened above and we are finished.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Sample_Object-Oriented_Input_Files"><a class="selflink" href="#Sample_Object-Oriented_Input_Files">Sample
  Object-Oriented Input Files</a></h2>
The easiest way to get started with mpqc is to start with one of sample inputs
  that most nearly matches your problem. The src/bin/mpqc/samples contains all
  of the sample inputs below:
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Hartree-Fock Energy</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MP2 Energy</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MP2-R12 energy</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Hartree-Fock Optimization</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Optimization with a Computed Guess Hessian</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Optimization Using Newton's Method</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Hartree-Fock Frequencies</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Giving Coordinates and a Guess Hessian</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Optimization with a Hydrogen Bond</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Fixed Coordinate Optimization</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Transition State Optimization</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Transition State Optimization with a Computed Guess
      Hessian</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Hartree-Fock energy with intermediate
    checkpointing</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MP2-R12 energy with intermediate checkpointing</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>HF gradient computed from a previously computed HF wave
      funtion</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MP2 Energy computed using precomputed Hartree-Fock wave
      function</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>CLHF energy using a CCA integrals component</b></dd>
</dl>
<h2 class="Ss" title="Ss" id="Hartree-Fock_Energy"><a class="selflink" href="#Hartree-Fock_Energy">Hartree-Fock
  Energy</a></h2>
The following input will compute the Hartree-Fock energy of water.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
)
</pre>
<h2 class="Ss" title="Ss" id="MP2_Energy"><a class="selflink" href="#MP2_Energy">MP2
  Energy</a></h2>
The following input will compute the MP2 energy of water.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;MBPT2&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    % reference wavefunction
    reference&lt;CLHF&gt;: (
      molecule = $:molecule
      basis = $:basis
      memory = 16000000
    )
  )
)
</pre>
<h2 class="Ss" title="Ss" id="MP2-R12_energy"><a class="selflink" href="#MP2-R12_energy">MP2-R12
  energy</a></h2>
The following will compute the MP2-R12 energy of water in standard approximation
  A' (MP2-R12/A').
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'cc-pVDZ'
  molecule = $:molecule
)
% auxiliary basis set specification
abasis&lt;GaussianBasisSet&gt;: (
  name = 'aug-cc-pVDZ'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;MBPT2_R12&gt;: (
    molecule = $:molecule
    basis = $:basis
    aux_basis = $:abasis
    stdapprox = 'A''
    nfzc = 1
    memory = 16000000
    integrals&lt;IntegralCints&gt;:()
    % reference wavefunction
    reference&lt;CLHF&gt;: (
      molecule = $:molecule
      basis = $:basis
      memory = 16000000
      integrals&lt;IntegralCints&gt;:()
    )
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Hartree-Fock_Optimization"><a class="selflink" href="#Hartree-Fock_Optimization">Hartree-Fock
  Optimization</a></h2>
The following input will optimize the geometry of water using the quasi-Newton
  method.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = '6-31G*'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
  )
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Optimization_with_a_Computed_Guess_Hessian"><a class="selflink" href="#Optimization_with_a_Computed_Guess_Hessian">Optimization
  with a Computed Guess Hessian</a></h2>
The following input will optimize the geometry of water using the quasi-Newton
  method. The guess Hessian will be computed at a lower level of theory.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = '6-31G*'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
  )
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
    guess_hessian&lt;FinDispMolecularHessian&gt;: (
      molecule = $:molecule
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
      energy&lt;CLHF&gt;: (
        molecule = $:molecule
        memory = 16000000
        basis&lt;GaussianBasisSet&gt;: (
          name = '3-21G'
          molecule = $:molecule
        )
      )
    )
  )
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Optimization_Using_Newton's_Method"><a class="selflink" href="#Optimization_Using_Newton's_Method">Optimization
  Using Newton's Method</a></h2>
The following input will optimize the geometry of water using the Newton's
  method. The Hessian will be computed at each step in the optimization.
  However, Hessian recomputation is usually not worth the cost; try using the
  computed Hessian as a guess Hessian for a quasi-Newton method before resorting
  to a Newton optimization.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% Emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = c2v
  unit = angstrom
  { atoms geometry } = {
     O     [     0.00000000     0.00000000     0.36937294 ]
     H     [     0.78397590     0.00000000    -0.18468647 ]
     H     [    -0.78397590     0.00000000    -0.18468647 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = '3-21G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  restart = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
  )
  do_energy = no
  do_gradient = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    coor = $..:coor
    guess_wavefunction&lt;CLHF&gt;: (
      molecule = $:molecule
      total_charge = 0
      basis&lt;GaussianBasisSet&gt;: (
        molecule = $:molecule
        name = 'STO-3G'
      )
      memory = 16000000
    )
    hessian&lt;FinDispMolecularHessian&gt;: (
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
    )
  )
  optimize = yes
  % optimizer object for the molecular geometry
  opt&lt;NewtonOpt&gt;: (
    print_hessian = yes
    max_iterations = 20
    function = $..:mole
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Hartree-Fock_Frequencies"><a class="selflink" href="#Hartree-Fock_Frequencies">Hartree-Fock
  Frequencies</a></h2>
The following input will compute Hartree-Fock frequencies by finite
  displacements. A thermodynamic analysis will also be performed. If
  optimization input is also provided, then the optimization will be run first,
  then the frequencies.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C1
  { atoms geometry } = {
    O     [  0.0000000000    0.0000000000    0.8072934188 ]
    H     [  1.4325589285    0.0000000000   -0.3941980761 ]
    H     [ -1.4325589285    0.0000000000   -0.3941980761 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
% vibrational frequency input
  freq&lt;MolecularFrequencies&gt;: (
    molecule = $:molecule
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Giving_Coordinates_and_a_Guess_Hessian"><a class="selflink" href="#Giving_Coordinates_and_a_Guess_Hessian">Giving
  Coordinates and a Guess Hessian</a></h2>
The following example shows several features that are really independent. The
  variable coordinates are explicitly given, rather than generated
  automatically. This is especially useful when a guess Hessian is to be
  provided, as it is here. This Hessian, as given by the user, is not complete
  and the QNewtonOpt object will fill in the missing values using a guess the
  Hessian provided by the MolecularEnergy object. Also, fixed coordinates are
  given in this sample input.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C1
  { atoms geometry } = {
      H    [ 0.088    2.006    1.438 ]
      O    [ 0.123    3.193    0.000 ]
      H    [ 0.088    2.006   -1.438 ]
      O    [ 4.502    5.955   -0.000 ]
      H    [ 2.917    4.963   -0.000 ]
      H    [ 3.812    7.691   -0.000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
      extra_bonds = [ 2 5 ]
    )
    % use these instead of generated coordinates
    variable&lt;SetIntCoor&gt;: [
      &lt;StreSimpleCo&gt;:( atoms = [ 2 5 ] )
      &lt;BendSimpleCo&gt;:( atoms = [ 2 5 4 ] )
      &lt;OutSimpleCo&gt;: ( atoms = [ 5 2 1 3 ] )
      &lt;SumIntCoor&gt;: (
        coor: [
          &lt;StreSimpleCo&gt;:( atoms = [ 1 2 ] )
          &lt;StreSimpleCo&gt;:( atoms = [ 2 3 ] )
          ]
        coef = [ 1.0 1.0 ]
        )
      &lt;SumIntCoor&gt;: (
        coor: [
          &lt;StreSimpleCo&gt;:( atoms = [ 4 5 ] )
          &lt;StreSimpleCo&gt;:( atoms = [ 4 6 ] )
          ]
        coef = [ 1.0 1.0 ]
        )
      &lt;BendSimpleCo&gt;:( atoms = [ 1 2 3 ] )
      &lt;BendSimpleCo&gt;:( atoms = [ 5 4 6 ] )
    ]
    % these are fixed by symmetry anyway,
    fixed&lt;SetIntCoor&gt;: [
      &lt;SumIntCoor&gt;: (
        coor: [
          &lt;StreSimpleCo&gt;:( atoms = [ 1 2 ] )
          &lt;StreSimpleCo&gt;:( atoms = [ 2 3 ] )
          ]
        coef = [ 1.0 -1.0 ]
        )
      &lt;SumIntCoor&gt;: (
        coor: [
          &lt;StreSimpleCo&gt;:( atoms = [ 4 5 ] )
          &lt;StreSimpleCo&gt;:( atoms = [ 4 6 ] )
          ]
        coef = [ 1.0 -1.0 ]
        )
      &lt;TorsSimpleCo&gt;:( atoms = [ 2 5 4 6] )
      &lt;OutSimpleCo&gt;:( atoms = [ 3 2 6 4 ] )
      &lt;OutSimpleCo&gt;:( atoms = [ 1 2 6 4 ] )
    ]
  )
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
    % give a partial guess hessian in internal coordinates
    % the missing elements will be filled in automatically
    hessian = [
        [  0.0109261670 ]
        [ -0.0004214845    0.0102746106  ]
        [ -0.0008600592    0.0030051330    0.0043149957 ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
     ]
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Optimization_with_a_Hydrogen_Bond"><a class="selflink" href="#Optimization_with_a_Hydrogen_Bond">Optimization
  with a Hydrogen Bond</a></h2>
The automatic internal coordinate generator will fail if it cannot find enough
  redundant internal coordinates. In this case, the internal coordinate
  generator must be explicitly created in the input and given extra connectivity
  information, as is shown below.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C1
  { atoms geometry } = {
      H    [ 0.088    2.006    1.438 ]
      O    [ 0.123    3.193    0.000 ]
      H    [ 0.088    2.006   -1.438 ]
      O    [ 4.502    5.955   -0.000 ]
      H    [ 2.917    4.963   -0.000 ]
      H    [ 3.812    7.691   -0.000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    % give an internal coordinate generator that knows about the
    % hydrogen bond between atoms 2 and 5
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
      extra_bonds = [ 2 5 ]
    )
  )
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Fixed_Coordinate_Optimization"><a class="selflink" href="#Fixed_Coordinate_Optimization">Fixed
  Coordinate Optimization</a></h2>
This example shows how to selectively fix internal coordinates in an
  optimization. Any number of linearly independent coordinates can be given.
  These coordinates must remain linearly independent throughout the
  optimization, a condition that might not hold since the coordinates can be
  nonlinear.
<div class="Pp"></div>
By default, the initial fixed coordinates' values are taken from the cartesian
  geometry given by the Molecule object; however, the molecule will be displaced
  to the internal coordinate values given with the fixed internal coordinates if
  have_fixed_values keyword is set to true, as shown in this example. In this
  case, the initial cartesian geometry should be reasonably close to the desired
  initial geometry and all of the variable coordinates will be frozen to their
  original values during the initial displacement.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.04 -0.69 -1.59 ]
    H [  3.04 -0.69  1.59 ]
    N [  2.09 -0.48 -0.00 ]
    C [ -0.58 -0.15  0.00 ]
    H [ -1.17  1.82  0.00 ]
    H [ -1.41 -1.04 -1.64 ]
    H [ -1.41 -1.04  1.64 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = '3-21G*'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
    have_fixed_values = yes
    fixed&lt;SetIntCoor&gt;: [
      &lt;OutSimpleCo&gt;: ( value = -0.1
                       label = 'N-inversion'
                       atoms = [4 3 2 1] )
      ]
  )
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    max_iterations = 20
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Transition_State_Optimization"><a class="selflink" href="#Transition_State_Optimization">Transition
  State Optimization</a></h2>
This example shows a transition state optimization of the N-inversion in
  $thrm{CH}_3thrm{NH}_2$ using mode following. The initial geometry was obtained
  by doing a few fixed coordinate optimizations along the inversion coordinate.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.045436 -0.697438 -1.596748 ]
    H [  3.045436 -0.697438  1.596748 ]
    N [  2.098157 -0.482779 -0.000000 ]
    C [ -0.582616 -0.151798  0.000000 ]
    H [ -1.171620  1.822306  0.000000 ]
    H [ -1.417337 -1.042238 -1.647529 ]
    H [ -1.417337 -1.042238  1.647529 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = '3-21G*'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
    followed&lt;OutSimpleCo&gt; = [ 'N-inversion' 4 3 2 1 ]
  )  
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt&lt;EFCOpt&gt;: (
    transition_state = yes
    mode_following = yes
    max_iterations = 20
    function = $..:mole
    update&lt;PowellUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Transition_State_Optimization_with_a_Computed_Guess_Hessian"><a class="selflink" href="#Transition_State_Optimization_with_a_Computed_Guess_Hessian">Transition
  State Optimization with a Computed Guess Hessian</a></h2>
This example shows a transition state optimization of the N-inversion in
  $thrm{CH}_3thrm{NH}_2$ using mode following. The initial geometry was obtained
  by doing a few fixed coordinate optimizations along the inversion coordinate.
  An approximate guess Hessian will be computed, which makes the optimiziation
  converge much faster in this case.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.045436 -0.697438 -1.596748 ]
    H [  3.045436 -0.697438  1.596748 ]
    N [  2.098157 -0.482779 -0.000000 ]
    C [ -0.582616 -0.151798  0.000000 ]
    H [ -1.171620  1.822306  0.000000 ]
    H [ -1.417337 -1.042238 -1.647529 ]
    H [ -1.417337 -1.042238  1.647529 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = '3-21G*'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
    followed&lt;OutSimpleCo&gt; = [ 'N-inversion' 4 3 2 1 ]
  )  
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
    guess_hessian&lt;FinDispMolecularHessian&gt;: (
      molecule = $:molecule
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
      energy&lt;CLHF&gt;: (
        molecule = $:molecule
        memory = 16000000
        basis&lt;GaussianBasisSet&gt;: (
          name = '3-21G'
          molecule = $:molecule
        )
      )
    )
  )
  % optimizer object for the molecular geometry
  opt&lt;EFCOpt&gt;: (
    transition_state = yes
    mode_following = yes
    max_iterations = 20
    function = $..:mole
    update&lt;PowellUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
</pre>
<h2 class="Ss" title="Ss" id="Hartree-Fock_energy_with_intermediate_checkpointing"><a class="selflink" href="#Hartree-Fock_energy_with_intermediate_checkpointing">Hartree-Fock
  energy with intermediate checkpointing</a></h2>
The following two sections demonstrate how MPQC can be used to save the mole
  object periodically. This input will compute the Hartree-Fock energy of water
  while saving the mole object every 3 iterations.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = yes
  filename = 'h2o-rhf-STO3G'
  checkpoint_freq = 3
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
)
</pre>
<div class="Pp"></div>
The mole object will be saved to files named
  'h2o-rhf-STO3G.wfn.&lt;iter#&gt;.tmp' where &lt;iter#&gt; is the SCF iteration
  number (3, 6, etc.). Only the most recent file is kept, files from previous
  iterations are removed automatically. Keyword filename here is used to set the
  default file name prefix.
<h2 class="Ss" title="Ss" id="MP2-R12_energy_with_intermediate_checkpointing"><a class="selflink" href="#MP2-R12_energy_with_intermediate_checkpointing">MP2-R12
  energy with intermediate checkpointing</a></h2>
The following input will compute the MP2-R12 energy of water in standard
  approximation A' (MP2-R12/A') while saving the mole object at intermediate
  checkpoints.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'cc-pVDZ'
  molecule = $:molecule
)
% auxiliary basis set specification
abasis&lt;GaussianBasisSet&gt;: (
  name = 'aug-cc-pVDZ'
  molecule = $:molecule
)
mpqc: (
  checkpoint = yes
  filename = 'h2o-mp2r12ap-vdz-avdz'
  savestate = no
  % method for computing the molecule's energy
  mole&lt;MBPT2_R12&gt;: (
    molecule = $:molecule
    basis = $:basis
    aux_basis = $:abasis
    stdapprox = 'A''
    nfzc = 1
    memory = 16000000
    integrals&lt;IntegralCints&gt;:()
    % reference wavefunction
    reference&lt;CLHF&gt;: (
      molecule = $:molecule
      basis = $:basis
      memory = 16000000
      integrals&lt;IntegralCints&gt;:()
    )
  )
)
</pre>
<div class="Pp"></div>
The mole object will be saved to a file named h2o-mp2r12ap-vdz-avdz.wfn&quot;.
  Keyword filename here is used to set the default file name prefix. Objects of
  the MBPT2_R12 type are checkpointed after the HF procedure, after the first
  integrals (SBS) transformation, and after the optional second (ABS)
  transformation.
<h2 class="Ss" title="Ss" id="HF_gradient_computed_from_a_previously_computed_HF_wave_funtion"><a class="selflink" href="#HF_gradient_computed_from_a_previously_computed_HF_wave_funtion">HF
  gradient computed from a previously computed HF wave funtion</a></h2>
The following will illustrate how to reuse previously computed MolecularEnergy
  objects in subsequent computations. The first input computes Hartree-Fock
  energy for water and saves the mole object to file h2o-rhf-sto3g.wfn.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = yes
  filename = 'h2o-rhf-sto3g'
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
)
</pre>
<div class="Pp"></div>
The second input reuses the mole object from the previous run to compute the
  gradient of the Hartree-Fock energy.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
mpqc: (
  checkpoint = no
  savestate = no
  restart = yes
  restart_file = 'h2o-rhf-sto3g.wfn'
  do_gradient = yes
)
</pre>
<h2 class="Ss" title="Ss" id="MP2_Energy_computed_using_precomputed_Hartree-Fock_wave_function"><a class="selflink" href="#MP2_Energy_computed_using_precomputed_Hartree-Fock_wave_function">MP2
  Energy computed using precomputed Hartree-Fock wave function</a></h2>
The following input will compute the MP2 energy of water using a saved
  Hartree-Fock wave function obtained using the first input from <b>HF gradient
  computed from a previously computed HF wave funtion</b>.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
% wave function file object specification
wfnfile&lt;BcastStateInBin&gt;:file = 'h2o-rhf-sto3g.wfn'
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;MBPT2&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    % reference wavefunction
    reference&lt;SavableStateProxy&gt;: (
      statein = $:wfnfile
      object = 'CLHF'
    )
  )
)
</pre>
<div class="Pp"></div>
Note that now object reference is of type SavableStateProxy, rather than CLHF.
  SavableStateProxy is a special object type that can be converted at runtime
  into the desired type (in this case, CLHF, as indicated by object).
<h2 class="Ss" title="Ss" id="CLHF_energy_using_a_CCA_integrals_component"><a class="selflink" href="#CLHF_energy_using_a_CCA_integrals_component">CLHF
  energy using a CCA integrals component</a></h2>
The following input will compute the CLHF energy of water using a CCA integrals
  component via the IntegralCCA adaptor class.
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  % path to component libraries
  cca_path = /usr/local/lib/cca
  % sidl class names of components which will be instantiated
  cca_load = MPQC.IntegralEvaluatorFactory
  do_cca = yes
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;CLHF&gt;: (
    molecule = $:molecule
    basis = $:basis
    % cca integrals adaptor class
    integrals&lt;IntegralCCA&gt;: (
      molecule = $:molecule
      % integral buffer type
      integral_buffer = opaque
      % integral package
      integral_package = intv3
      % factory component sidl class name
      evaluator_factory = MPQC.IntegralEvaluatorFactory
    )
  )
)
</pre>
<h1 class="Sh" title="Sh" id="Validating_MPQC"><a class="selflink" href="#Validating_MPQC">Validating
  MPQC</a></h1>
After you compile MPQC, you should run the validation suite. You should also run
  the validation suite if you upgrade your operating system software, since this
  could change shared libraries that are linking with MPQC and could affect the
  results. Note that the reference validation suite has not been verified
  relative to an independent code, except for a few spot checks. If you find
  that MPQC doesn't produce the same answer as another quantum chemistry program
  that you trust, then please promptly notify us and send all the details.
<div class="Pp"></div>
The top-level Makefile has several targets that can be used to check an MPQC
  build. MPQC must be built before one of these targets is used:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>check<b></b></dt>
  <dd class="It-tag">The same as check0 below. This is only available from the
      top-level directory and src/bin/mpqc/validate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>check0<b></b></dt>
  <dd class="It-tag">Run the smallest MPQC verification suite. It tests basic
      functionality. This is only available from the top-level directory and
      src/bin/mpqc/validate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>check1<b></b></dt>
  <dd class="It-tag">Run the intermediate MPQC verification suite. It runs most
      of the tests, only leaving out very expensive runs. This is only available
      from the top-level directory and src/bin/mpqc/validate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>check2<b></b></dt>
  <dd class="It-tag">Run the complete MPQC verification suite. Depending on the
      compilation and runtime environment, tests that are not expected to work
      will be omitted. This is only available from the top-level directory and
      src/bin/mpqc/validate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>check_clean<b></b></dt>
  <dd class="It-tag">Remove MPQC verification suite output files. This is only
      available from the top-level directory and src/bin/mpqc/validate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>testbuild<b></b></dt>
  <dd class="It-tag">Verify that a variety of small test programs compile. If
      static libraries are used, this will require a substantial amount of disk
      space.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>testrun<b></b></dt>
  <dd class="It-tag">Run a variety of small test programs. This will build them
      if necessary.</dd>
</dl>
<div class="Pp"></div>
The check targets will run mpqc with the mpqcrun (see <b>mpqcrun</b>) command.
  You can give arguments to mpqcrun by setting the MPQCRUN_ARGS variable on the
  make command line.
<div class="Pp"></div>
The verification suite is in src/bin/mpqc/validate. After running it, the output
  files can be found in src/bin/mpqc/validate/run. The check targets will
  compare outputs that your build produced to the reference files in
  src/bin/mpqc/validate/ref. The input files can be found with the reference
  files. For each comparison, first the status (ok, missing, or failed) for each
  file is printed. If both statuses are ok then an E: is printed followed by the
  number of digits to which the energies agree. If they agree to all digits 99
  is printed. If a gradient was computed, then Grad: is printed followed by the
  number of digits to which the gradients in least agreement agree. Other
  properties checked in this way include frequencies, diagnostics, and
  populations.
<div class="Pp"></div>
If two numbers do not agree to the expected accuracy, then an asterisk, *, is
  printed after the number of digits in agreement.
<div class="Pp"></div>
Finally, you can do a detailed comparison of the contents of the ref and run
  subdirectories by typing make diff.
<div class="Pp"></div>
The input files in the verification suite are divided into several categories:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>h2o<b></b></dt>
  <dd class="It-tag">These are simple tests that exercise many of MPQC's
      features.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>h2omp2<b></b></dt>
  <dd class="It-tag">Tests that further exercise MP2.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>h2ofrq<b></b></dt>
  <dd class="It-tag">Tests of H2 O frequencies with a variety of methods.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>mbpt<b></b></dt>
  <dd class="It-tag">These tests exercise MP2 as well as the open-shell
      perturbation theory methods. The various available algorithms are tested
      as well.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>ckpt<b></b></dt>
  <dd class="It-tag">Tests the checkpoint and restart capabilities.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>symm1<b></b></dt>
  <dd class="It-tag">Tests of point group symmetry.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>symm2<b></b></dt>
  <dd class="It-tag">More point group symmetry tests. These use basis sets with
      higher angular momentum than #symm1#.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>symm3<b></b></dt>
  <dd class="It-tag">Tests automatic point group determination.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>basis1<b></b></dt>
  <dd class="It-tag">A variety of basis sets are tested for first row atoms
      along with hydrogen and helium.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>basis2<b></b></dt>
  <dd class="It-tag">Basis sets test for second row atoms.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>methods<b></b></dt>
  <dd class="It-tag">Basic tests of several of MPQC's methods.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>clscf<b></b></dt>
  <dd class="It-tag">More tests of methods based on CLSCF.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>hsosscf<b></b></dt>
  <dd class="It-tag">More tests of methods based on HSOSSCF.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>uscf<b></b></dt>
  <dd class="It-tag">More tests of methods based on UnrestrictedSCF.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>dft<b></b></dt>
  <dd class="It-tag">More tests of the CLKS method.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>mp2r12<b></b></dt>
  <dd class="It-tag">More tests of MP2-R12.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>ccaintv3<b></b></dt>
  <dd class="It-tag">Tests of embedded CCA integrals components using
    intv3.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>ccacints<b></b></dt>
  <dd class="It-tag">Tests of embedded CCA integrals components using
    cints.</dd>
</dl>
<h1 class="Sh" title="Sh" id="Running_Psi_3_from_MPQC"><a class="selflink" href="#Running_Psi_3_from_MPQC">Running
  Psi 3 from MPQC</a></h1>
Psi 3 is a suite of <i>ab initio</i> codes related to the original Psi package
  started in Prof. Fritz Schaefer's group at UC Berkeley. Current version of
  MPQC works with stable versions of Psi 3 starting with 3.2.0. From now on we
  will refer to Psi 3 as simply Psi. Psi is written primarily in C and executes
  in serial mode only. The interface between Psi and MPQC is intended mainly for
  Psi users who wish to exploit MPQC's geometry optimization and frequency
  analyses capabilities with Psi energies and gradients.
<div class="Pp"></div>
The following sections explain how to use Psi from MPQC:
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>How the MPQC-Psi interface works</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Environmental Variables</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Preparing an input file</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>Psi Execution Environment</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>PsiWavefunction specializations</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>More examples</b></dd>
</dl>
<h2 class="Ss" title="Ss" id="How_the_MPQC-Psi_interface_works"><a class="selflink" href="#How_the_MPQC-Psi_interface_works">How
  the MPQC-Psi interface works</a></h2>
The current version of the interface is rather slim. It is only possible to
  import energies and gradients computed with Psi into MPQC, i.e. wave functions
  cannot be imported. All MPQC-Psi interaction happens via text files and system
  calls. MPQC generates input file for Psi, calls appropriate Psi modules, and
  then parses the output files for energies and gradients.
<h2 class="Ss" title="Ss" id="Environmental_Variables"><a class="selflink" href="#Environmental_Variables">Environmental
  Variables</a></h2>
Several environmental variables are used to control MPQC-Psi interaction:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>PSIBIN<b></b></dt>
  <dd class="It-tag">By default, MPQC will try to find Psi binaries under
      /usr/local/psi/bin. Use PSIBIN environmental variable to point to the
      right location.</dd>
</dl>
<div class="Pp"></div>
The rest of the Psi environment is job specific and specified in the input file.
<h2 class="Ss" title="Ss" id="Preparing_an_input_file"><a class="selflink" href="#Preparing_an_input_file">Preparing
  an input file</a></h2>
As noted above, MPQC parses the input file, and as such the input file has to be
  in the MPQC OO input format. All features of usual MPQC input files are there
  (mpqc section, mole MolecularEnergy object, etc.). In addition the following
  rules apply:
<div style="height: 1.00em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">instead of using MPQC Wavefunction objects (CLHF, MBPT2,
      etc.), the Psi specific Wavefunction types (i.e. specializations of
      PsiWavefunction) have to be used. Presently the following specializations
      are supported: PsiCLHF, PsiHSOSHF, PsiUHF, PsiCCSD, PsiCCSD_T . The first
      three are directly analogous to MPQC Wavefunction types CLHF, HSOSHF, and
      UHF. The latter two do not have MPQC analogs yet. See appropriate class
      documentation on how to specify them properly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">each Psi-specific Wavefunction object has to have a member
      object psienv of type PsiExEnv. PsiExEnv contains job specific
      information, such as the directory in which Psi input, output, and
      checkpoint files will be kept, filename prefix, scratch directories, etc.
      It makes sense to define one such object and simply refer to it from all
      PsiWavefunction objects. See PsiExEnv class documentation for more
    info.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Psi_Execution_Environment"><a class="selflink" href="#Psi_Execution_Environment">Psi
  Execution Environment</a></h2>
Each PsiWavefunction-derived class has to have a member object called psienv of
  type PsiExEnv. The following keywords are used by its KeyVal constructor:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>cwd<b></b></dt>
  <dd class="It-tag">The directory where to keep Psi input, checkpoint, stdout,
      stderr, and other files. Default is /tmp.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>fileprefix<b></b></dt>
  <dd class="It-tag">The file prefix to use for Psi checkpoint, scratch, and
      some ASCII files. Equivalent to keyword name in Psi psi:files:default
      section. Defaults to psi.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>stdout<b></b></dt>
  <dd class="It-tag">The file into which to redirect standard output of Psi
      modules. Defaults to psi.stdout.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>stderr<b></b></dt>
  <dd class="It-tag">The file into which to redirect standard error of Psi
      modules. Defaults to psi.stderr.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>nscratch<b></b></dt>
  <dd class="It-tag">The number of locations over which to stripe Psi binary
      files. Equivalent to keyword nvolume in Psi psi:files:default section.
      Default is 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>scratch<b></b></dt>
  <dd class="It-tag">The locations over which to stripe Psi binary files.
      Equivalent to keyword volume <i>x</i><i> in Psi </i>psi:files:default<i>
      section. There's no default.</i></dd>
</dl>
<div class="Pp"></div>
Here's an example:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
  psienv&lt;PsiExEnv&gt;: (
    cwd = ./
    fileprefix = psi.test
    nscratch = 2
    scratch = [ '/scratch1/' '/scratch2/' ]
  )
</pre>
<h2 class="Ss" title="Ss" id="PsiWavefunction_specializations"><a class="selflink" href="#PsiWavefunction_specializations">PsiWavefunction
  specializations</a></h2>
Class PsiWavefunction is derived from class Wavefunction, hence its KeyVal
  constructor uses all keywords that Wavefunction's KeyVal constructor uses
  (basis, molecule, etc.). In addition, PsiWavefunction's KeyVal constructor
  looks for the following keywords in the input file:
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>psienv<b></b></dt>
  <dd class="It-tag">The PsiExEnv object that provides job specific Psi
      environment. There's no default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>docc<b></b></dt>
  <dd class="It-tag">An optional array of integers that specifies the number of
      doubly-occupied orbitals in each irrep.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>socc<b></b></dt>
  <dd class="It-tag">An optional array of integers that specifies the number of
      singly-occupied orbitals in each irrep.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>frozen_docc<b></b></dt>
  <dd class="It-tag">An optional array of integers that specifies the number of
      doubly-occupied orbitals in each irrep frozen in correlated
    computations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>frozen_uocc<b></b></dt>
  <dd class="It-tag">An optional array of integers that specifies the number of
      unoccupied orbitals in each irrep frozen in correlated computations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>total_charge<b></b></dt>
  <dd class="It-tag">The total charge of the system. This keyword is queried
      only if neither docc nor socc are given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>multiplicity<b></b></dt>
  <dd class="It-tag">The spin multiplicity of the system (2*M_S+1). This keyword
      is queried only if neither docc nor socc are given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b></b>memory<b></b></dt>
  <dd class="It-tag">The number of bytes of memory Psi modules associated with
      this PsiWavefunction are allowed to use. Default is 2000000 (2 million
      bytes, approximately 2 MB).</dd>
</dl>
<div class="Pp"></div>
Note that keywords docc, socc, frozen_docc, frozen_uocc, total_charge, and
  multiplicity are used by appropriate specializations of PsiWavefunctions, i.e.
  PsiCLHF only checks for docc, etc.
<div class="Pp"></div>
PsiWavefunction specializations PsiCCSD and PsiCCSD_T also look for keyword
  reference which specifies the reference wave function (an object of type
  PsiSCF). All classes for correlated Psi wave functions will require such an
  object.
<div class="Pp"></div>
Here are a few examples of PsiWavefunctions:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
  %
  % ROHF DZ on F atom
  %
  mole&lt;PsiHSOSHF&gt;: (
    docc = [ 2 0 0 0 0 1 1 0 ] socc = [ 0 0 0 0 0 0 0 1]
    memory = 10000000
</pre>
<div class="Pp"></div>
<pre>
    % Psi Environment data
    psienv&lt;PsiExEnv&gt;: (
      cwd = ./
      fileprefix = f.dz.test
      stdout = f.dz.test.stdout
      stderr = f.dz.test.stderr
      nscratch = 1
      scratch = [ '/scratch/mpqc/' ]
    )
</pre>
<div class="Pp"></div>
<pre>
    % MolecularEnergy input
    molecule&lt;Molecule&gt;: (
        {atoms geometry} = {
          F  [   0.0  0.0   0.0 ]
         }
      )
</pre>
<div class="Pp"></div>
<pre>
    % Basis input
    basis&lt;GaussianBasisSet&gt;: (
        molecule = $..:molecule
        name = 'DZ (Dunning)'
      )
</pre>
<div class="Pp"></div>
<pre>
  )
</pre>
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
  %
  % RHF CCSD/cc-pVDZ on water
  %
  mole&lt;PsiCCSD&gt;: (
    frozen_docc = [1 0 0 0]
    memory = 40000000
</pre>
<div class="Pp"></div>
<pre>
    % Psi Environment data
    psienv&lt;PsiExEnv&gt;: (
      cwd = ./
      fileprefix = h2o.ccpvdz.ccsd.test
      nscratch = 1
      scratch = [ '/tmp/' ]
    )
</pre>
<div class="Pp"></div>
<pre>
    % MolecularEnergy input
    molecule&lt;Molecule&gt;: (
        {atoms geometry} = {
          H  [  -1.5  0.0  -0.3 ]
          H  [   1.5  0.0  -0.3 ]
          O  [   0.0  0.0   1.0 ]
         }
      )
</pre>
<div class="Pp"></div>
<pre>
    % Basis input
    basis&lt;GaussianBasisSet&gt;: (
        molecule = $..:molecule
        name = 'cc-pVDZ'
      )
</pre>
<div class="Pp"></div>
<pre>
    reference&lt;PsiCLHF&gt;: (
      psienv = $..:psienv
      molecule = $..:molecule
      basis = $..:basis
      total_charge = 0
      multiplicity = 1
    )
  )
</pre>
<h2 class="Ss" title="Ss" id="More_examples"><a class="selflink" href="#More_examples">More
  examples</a></h2>
This section contains some examples of complete inputs that specify an MPQC/Psi
  computations.
<div class="Pp"></div>
Here's an optimization + subsequent frequency analysis on water molecule at the
  RHF CCSD 6-311G** level:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
% Emacs should use -*- KeyVal -*- mode
% this file was automatically generated
% label: water test series
% molecule specification
molecule&lt;Molecule&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
     O     [     0.000000000000     0.000000000000     0.369372944000 ]
     H     [     0.783975899000     0.000000000000    -0.184686472000 ]
     H     [    -0.783975899000     0.000000000000    -0.184686472000 ]
  }
)
% basis set specification
basis&lt;GaussianBasisSet&gt;: (
  name = '6-311G**'
  molecule = $:molecule
)
% Psi environment specification
psienv&lt;PsiExEnv&gt;: (
      cwd = ./
      fileprefix = mpqcpsi
      stdout = mpqcpsi.stdout
      stderr = mpqcpsi.stderr
      nscratch = 1
      scratch = [ '/scratch/evaleev/' ]
)
</pre>
<div class="Pp"></div>
<pre>
mpqc: (
  checkpoint = no
  savestate = no
  restart = no
  coor&lt;SymmMolecularCoor&gt;: (
    molecule = $:molecule
    generator&lt;IntCoorGen&gt;: (
      molecule = $:molecule
    )
  )
  % molecular coordinates for optimization  do_energy = yes
  do_gradient = no
  % method for computing the molecule's energy
  mole&lt;PsiCCSD&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    psienv = $:psienv
    memory = 32000000
    reference&lt;PsiCLHF&gt;: (
      psienv = $:psienv
      molecule = $:molecule
      total_charge = 0
      multiplicity = 1
      basis = $:basis
      memory = 32000000
    )
    hessian&lt;FinDispMolecularHessian&gt;: (
      point_group&lt;PointGroup&gt;: symmetry = C2V
      checkpoint = no
      restart = no
    )
  )
  optimize = yes
  % optimizer object for the molecular geometry
  opt&lt;QNewtonOpt&gt;: (
    max_iterations = 20
    function = $..:mole
    update&lt;BFGSUpdate&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
% vibrational frequency input
  freq&lt;MolecularFrequencies&gt;: (
    point_group&lt;PointGroup&gt;: symmetry = C2V
    molecule = $:molecule
  )
)
</pre>
<h1 class="Sh" title="Sh" id="CCA_Components"><a class="selflink" href="#CCA_Components">CCA
  Components</a></h1>
Common Component Architecture (CCA) component wrappers, conforming to interfaces
  developed for the CCA Chemistry Component Toolkit, have been created to
  encapsulate some MPQC functionality. The following components are provided by
  MPQC:
<div class="Pp"></div>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MPQC.Chemistry_QC_ModelFactory</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MPQC.ChemistryOpt_CoordinateModel</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>MPQC.IntegralEvaluatorFactory</b></dd>
</dl>
<h2 class="Ss" title="Ss" id="MPQC.Chemistry_QC_ModelFactory"><a class="selflink" href="#MPQC.Chemistry_QC_ModelFactory">MPQC.Chemistry_QC_ModelFactory</a></h2>
This is an implementation of the Chemistry.QC.ModelFactory interface. This
  factory produces model objects (implementing the Chemistry.QC.Model interface)
  based on the MPQC package. The MPQC model allows calculation of molecular
  energies and energy derivatives using a variety of methods.
<h2 class="Ss" title="Ss" id="Provides_Ports"><a class="selflink" href="#Provides_Ports">Provides
  Ports</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">Chemistry.QC.ModelFactory <i>ModelFactory</i></dd>
</dl>
<h2 class="Ss" title="Ss" id="Uses_Ports"><a class="selflink" href="#Uses_Ports">Uses
  Ports</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">Chemistry.QC.MoleculeFactory <i>MoleculeFactory</i>
      (required)</dd>
</dl>
<h2 class="Ss" title="Ss" id="Parameters"><a class="selflink" href="#Parameters">Parameters</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>theory</b> The method for determining the electronic
      structure. Defaults to HF.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> o</dt>
  <dd class="It-tag"><i>HF</i> Hartree-Fock method.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> o</dt>
  <dd class="It-tag"><i>B3LYP</i> Density Functional Theory (DFT) with B3LYP
      functional.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> o</dt>
  <dd class="It-tag">Use keyval input for other options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>basis</b> The atomic orbital basis set. Defaults to
      <i>STO-3G</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> o</dt>
  <dd class="It-tag">Any basis set defined in the MPQC package.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> o</dt>
  <dd class="It-tag">Use keyval input for mixed basis sets.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>molecule_filename</b> Path to the molecule file (see
      cca-chem-generic documentation for format). No default -- required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>keyval_filename</b> Path to the keyval input file (see
      below). No default -- optional.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Keyval_Input"><a class="selflink" href="#Keyval_Input">Keyval
  Input</a></h2>
The <b>theory</b> and <b>basis</b> parameters allow very basic calculations to
  be performed. More complex calculations will require the use of a keyval input
  file. The keyval file format is the same as that used to run MPQC stand-alone,
  and any valid MPQC options may be used. The molecular energy object must be
  named model. The user-supplied keyval cannot contain a molecule section; the
  molecule section will be automatically inserted by the ModelFactory using the
  required <b>molecule_filename</b>. This molecule section should be referred to
  as $:molecule.
<div class="Pp"></div>
Example keyval input:
<div class="Pp"></div>
<pre>
<div class="Pp"></div>
  model&lt;CLHF&gt;:(
    molecule=$:molecule
    basis&lt;GaussianBasisSet&gt;:(
      name = '6-31G'
      molecule = $:molecule
    )
  )
</pre>
<h2 class="Ss" title="Ss" id="MPQC.ChemistryOpt_CoordinateModel"><a class="selflink" href="#MPQC.ChemistryOpt_CoordinateModel">MPQC.ChemistryOpt_CoordinateModel</a></h2>
This is an implementation of the ChemistryOpt.CoordinateModel interface based on
  the MPQC package. It supports molecular structure optimization in cartesian,
  symmetrized internal, and redundant internal coordinates. Hessian
  approximation is supported.
<h2 class="Ss" title="Ss" id="Provides_Ports"><a class="selflink" href="#Provides_Ports">Provides
  Ports</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">ChemistryOpt.CoordinateModel <i>CoordinateModel</i></dd>
</dl>
<h2 class="Ss" title="Ss" id="Uses_Ports"><a class="selflink" href="#Uses_Ports">Uses
  Ports</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">Chemistry.QC.ModelFactory <i>ModelFactory</i>
    (required)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">Chemistry.QC.ModelFactory <i>BackupModelFactory</i>
      (optional)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">Chemistry.MoleculeViewer <i>MoleculeViewer</i>
    (optional)</dd>
</dl>
<div class="Pp"></div>
A backup model factory may be supplied. If an error is detected in the primary
  model, then a model obtained from the backup factory will be used. The
  molecule viewer is currently only used to communicate with the python viewer,
  in which case component instantiation and connection is handled automatically.
<h2 class="Ss" title="Ss" id="Parameters"><a class="selflink" href="#Parameters">Parameters</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>grad_rms</b> RMS gradient convergence criteria. Defaults
      to 0.00030.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>grad_max</b> Max gradient convergence criteria. Defaults
      to 0.00045.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>disp_rms</b> RMS displacement convergence criteria.
      Defaults to 0.00120.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>disp_max</b> Max displacement convergence criteria.
      Defaults to 0.00180.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>coordinate_type</b> Optimization coordinate type.
      Defaults to <i>symmetrized</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> o</dt>
  <dd class="It-tag"><i>cartesian</i> Cartesian coordinates.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> o</dt>
  <dd class="It-tag"><i>symmetrized</i> Symmetrized internal coordinates.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"> o</dt>
  <dd class="It-tag"><i>redundant</i> Redundant internal coordinates.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>multiple_guess_h</b> Compute new guess Hessian at each
      call to guess_hessian_solve() ( <i>true</i>) or use guess from first
      iteration only ( <i>false</i>). Only meaningful in conjunction with
      solvers supporting use of dense guess Hessians with limited-memory
      methods. Defaults to <i>true</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>use_current_geom</b> If <b>multiple_guess_h</b> is
      <i>true</i>, either use the current geometry ( <i>true</i>) or the
      geometry at which the earliest correction pair used by the solver was
      determined ( <i>false</i>) when computing the guess Hessian. Defaults to
      <i>false</i>.</dd>
</dl>
<h2 class="Ss" title="Ss" id="MPQC.IntegralEvaluatorFactory"><a class="selflink" href="#MPQC.IntegralEvaluatorFactory">MPQC.IntegralEvaluatorFactory</a></h2>
This is an implementation of the
  Chemistry.QC.GaussianBasis.IntegralEvaluatorFactory interface. This factory
  produces molecular integral evaluator objects based on the MPQC package. This
  code is experimental and does not currently support derivative integrals.
<h2 class="Ss" title="Ss" id="Provides_Ports"><a class="selflink" href="#Provides_Ports">Provides
  Ports</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag">Chemistry.QC.GaussianBasis.IntegralEvaluatorFactory
      <i>IntegralEvaluatorFactory</i></dd>
</dl>
<h2 class="Ss" title="Ss" id="Parameters"><a class="selflink" href="#Parameters">Parameters</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>package</b> Integral package, either intv3 or cints.
      Defaults to intv3.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">o</dt>
  <dd class="It-tag"><b>integral_buffer</b> Integral buffer type, either opaque
      or array. The opaque option uses pointers and is therefore higher
      performance. The array option may be used by components implemented in
      languages which are not pointer-aware.</dd>
</dl>
<h1 class="Sh" title="Sh" id="MPQC_License"><a class="selflink" href="#MPQC_License">MPQC
  License</a></h1>
MPQC is open-source software; you can redistribute it and/or modify it under the
  terms of the GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any later
  version.
<h1 class="Sh" title="Sh" id="MPQC_Warranty"><a class="selflink" href="#MPQC_Warranty">MPQC
  Warranty</a></h1>
MPQC is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE. See the GNU General Public License for more
  details.</div>
<table class="foot">
  <tr>
    <td class="foot-date">Mon May 15 2017</td>
    <td class="foot-os">Version 2.3.1</td>
  </tr>
</table>
</body>
</html>
