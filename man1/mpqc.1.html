<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:26:10 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>mpqc(1) MPQC mpqc(1)</p>

<p style="margin-top: 1em">NAME <br>
mpqc - The Massively Parallel Quantum Chemistry program
(MPQC) computes the properties of molecules from first
principles.</p>

<p style="margin-top: 1em">This documentation is divided
into the following chapters:</p>

<p style="margin-top: 1em">o MPQC Overview <br>
o Running MPQC <br>
o MPQC Input <br>
o Validating MPQC <br>
o Running Psi 3 from MPQC <br>
o CCA Components <br>
o MPQC License <br>
o MPQC Warranty MPQC Overview <br>
The Massively Parallel Quantum Chemistry program (MPQC)
computes the properties of molecules, ab initio, on a wide
variety of computer architectures. <br>
MPQC can compute closed shell and general restricted
open-shell Hartree-Fock energies and gradients, second order
open-shell perturbation theory (OPT2[2]) and Z-averaged <br>
perturbation theory (ZAPT2) energies, and second order
closed shell Moeller-Plesset perturbation theory energies
and gradients. It also includes methods for optimizing
molecules <br>
in either Cartesian or internal coordinates. <br>
MPQC is designed using object-oriented programming
techniques and implemented in the C++ programming language.
Running MPQC <br>
This chapter explains how to run MPQC in a variety of
environments. <br>
The first two sections give general information on running
MPQC: <br>
o Command Line Options <br>
o Environmental Variables <br>
The final sections given specific information on running
MPQC in different environments: <br>
o Shared Memory Multiprocessor with SysV IPC <br>
o Shared Memory Multiprocessor with POSIX Threads <br>
o Shared or Distributed Memory Multiprocessor with MPI <br>
o Special Notes for MP2 Gradients <br>
o Special Notes for MP2-R12 energies <br>
o Special Notes for CCA Components <br>
Command Line Options <br>
MPQC can be given options followed by an optional input file
name. If the input file name is not given, it will default
to &rsquo;mpqc.in&rsquo;. The following command line options
are <br>
recognized: <br>
-o Gives the name of the output file. The default is the
console. <br>
-i Convert a simple input file to an object oriented input
file and write the result to the ouput. No calculations are
done. <br>
-messagegrp <br>
A ParsedKeyVal specification of a MessageGrp object. The
default depends on how MPQC was compiled. <br>
-memorygrp <br>
A ParsedKeyVal specification of a MemoryGrp object. The
default depends on how MPQC was compiled. <br>
-threadgrp <br>
A ParsedKeyVal specification of a ThreadGrp object. The
default depends on how MPQC was compiled. <br>
-integral <br>
A ParsedKeyVal specification of an Integral object. The
default is IntegralV3. Note that some MolecularEnergy
specializations require specific choices of Integral <br>
specializations and may not work with IntegralV3. <br>
-l Sets a limit on the number of basis functions. The
default is zero, which means an unlimited number of basis
functions. <br>
-W Sets the working directory. The default is the current
directory. <br>
-c Check the input and exit. <br>
-v Print the version number. <br>
-w Print the warranty information (there is no warranty).
<br>
-d If a debugger object was given in the input, start the
debugger running as soon as MPQC is started. <br>
-h Print a list of options. <br>
-f The name of an object-oriented input file. The default is
mpqc.in. This cannot be used if another input file is
specified. This option is deprecated, as both input file
<br>
formats can be read by given the input file name on the
command line without any option flags. <br>
-cca-path <br>
A colon-separated list of directories in which CCA component
libraries may be found. <br>
-cca-load <br>
A colon-separated list of sidl class names for CCA
components which will be instantiated from the libraries
found in the path given by -cca-path <br>
Some MPI environments do not pass the command line to slave
programs, but supply it when MPI_Init is called. To make
MPQC call MPI_Init with the correct arguments as early as
<br>
possible use the configure option --enable-always-use-mpi.
<br>
Environmental Variables <br>
MPQC looks at five environmental variables to set up
communication, find library files, and specify the default
Integral object. Machine specific libraries and utilities to
run <br>
programs in parallel might look at other environment
variables as well. The five that apply on all platforms are:
<br>
SCLIBDIR <br>
The name of the library directory. See the GaussianBasisSet
documentation and look below for more information. <br>
MESSAGEGRP <br>
A ParsedKeyVal specification of a MessageGrp object. The
default depends on how MPQC was compiled. See the MessageGrp
class documentation for more information. <br>
MEMORYGRP <br>
A ParsedKeyVal specification of a MemoryGrp object. The
default depends on how MPQC was compiled and the MessageGrp
in use. <br>
THREADGRP <br>
A ParsedKeyVal specification of a ThreadGrp object. The
default depends on how MPQC was compiled. <br>
INTEGRAL <br>
A ParsedKeyVal specification of an Integral object. The
default is IntegralV3. Note that some MolecularEnergy
specializations require specific choices of Integral <br>
specializations and may not work with IntegralV3. <br>
By default, MPQC tries to find library files first in the
lib subdirectory of the installation directory and then the
source code directory. If the library files cannot be found,
<br>
MPQC must be notified of the new location with the
environmental variable SCLIBDIR. <br>
For example, if you need to run MPQC on a machine that
doesn&rsquo;t have the source code distribution in the same
place as it was located on the machine on which MPQC is
compiled you <br>
must do something like the following on the machine with the
source code: <br>
cd mpqc/lib <br>
tar cvf ../sclib.tar basis atominfo.kv <br>
Then transfer sclib.tar to the machine on which you want to
run MPQC and do something like <br>
mkdir ~/sclib <br>
cd ~/sclib <br>
tar xvf ../sclib.tar <br>
setenv SCLIBDIR ~/sclib <br>
The setenv command is specific to the C-shell. You will need
to do what is appropriate for your shell. <br>
The other three keywords specify objects. This is done by
giving a mini ParsedKeyVal input in a string. The object is
anonymous, that is, no keyword is associated with it. Here
<br>
is an example: <br>
setenv MESSAGEGRP &rsquo;&lt;ShmMessageGrp&gt;:(n =
4)&rsquo; <br>
Shared Memory Multiprocessor with SysV IPC <br>
By default, MPQC will run on only one CPU. To specify more,
you can give a ShmMessageGrp object on the command line. The
following would run MPQC in four processes: <br>
mpqc -messagegrp &rsquo;&lt;ShmMessageGrp&gt;:(n = 4)&rsquo;
input_file <br>
Alternately, the ShmMessageGrp object can be given as an
environmental variable: <br>
setenv MESSAGEGRP &rsquo;&lt;ShmMessageGrp&gt;:(n =
4)&rsquo; <br>
mpqc input_file <br>
If MPQC should unexpectedly die, shared memory segments and
semaphores will be left on the machine. These should be
promptly cleaned up or other jobs may be prevented from <br>
running successfully. To see if you have any of these
resources allocated, use the ipcs command. The output will
look something like: <br>
IPC status from /dev/kmem as of Wed Mar 13 14:42:18 1996
<br>
T ID KEY MODE OWNER GROUP <br>
Message Queues: <br>
Shared Memory: <br>
m 288800 0x00000000 --rw------- cljanss user <br>
Semaphores: <br>
s 390 0x00000000 --ra------- cljanss user <br>
s 391 0x00000000 --ra------- cljanss user <br>
To remove the IPC resources used by cljanss in the above
example on IRIX, type: <br>
ipcrm -m 288800 <br>
ipcrm -s 390 <br>
ipcrm -s 391 <br>
And on Linux, type: <br>
ipcrm shm 288800 <br>
ipcrm sem 390 <br>
ipcrm sem 391 <br>
Shared Memory Multiprocessor with POSIX Threads <br>
By default, MPQC will run with only one thread. To specify
more, you can give a PthreadThreadGrp object on the command
line. MPQC is not parallelized to as large an extent with
<br>
threads as it is with the more conventional distributed
memory model, so you might not get the best performance
using this technique. On the other the memory overhead is
lower <br>
and no interprocess communication is needed. <br>
The following would run MPQC in four threads: <br>
mpqc -threadgrp &rsquo;&lt;PthreadThreadGrp&gt;:(num_threads
= 4)&rsquo; input_file <br>
Alternately, the PthreadThreadGrp object can be given as an
environmental variable: <br>
setenv THREADGRP
&rsquo;&lt;PthreadThreadGrp&gt;:(num_threads = 4)&rsquo;
<br>
mpqc input_file <br>
Shared or Distributed Memory Multiprocessor with MPI <br>
A MPIMessageGrp object is used to run using MPI. The number
of nodes used is determined by the MPI run-time and is not
specified as input data to MPIMessageGrp. <br>
mpqc -messagegrp &rsquo;&lt;MPIMessageGrp&gt;:()&rsquo;
input_file <br>
Alternately, the MPIMessageGrp object can be given as an
environmental variable: <br>
setenv MESSAGEGRP &rsquo;&lt;MPIMessageGrp&gt;:()&rsquo;
<br>
mpqc input_file <br>
Usually, a special command is needed to start MPI jobs;
typically it is named mpirun. <br>
Special Notes for MP2 Gradients <br>
The MP2 gradient algorithm uses MemoryGrp object to access
distributed shared memory. The MTMPIMemoryGrp class is the
most efficient and reliable implementation of MemoryGrp. It
<br>
requires a multi-thread aware MPI implementation, which is
still not common. To run MP2 gradients on a machine with
POSIX threads and an multi-thread aware MPI, use: <br>
mpqc -messagegrp &rsquo;&lt;MPIMessageGrp&gt;:()&rsquo;
-threadgrp &rsquo;&lt;PthreadThreadGrp&gt;:()&rsquo;
-memorygrp &rsquo;&lt;MTMPIMemoryGrp&gt;:()&rsquo;
input_file <br>
or <br>
setenv MESSAGEGRP &rsquo;&lt;MPIMessageGrp&gt;:()&rsquo;
<br>
setenv THREADGRP &rsquo;&lt;PthreadThreadGrp&gt;:()&rsquo;
<br>
setenv MEMORYGRP &rsquo;&lt;MTMPIMemoryGrp&gt;:()&rsquo;
<br>
mpqc input_file <br>
Special Notes for MP2-R12 energies <br>
Distributed Memory <br>
The MP2-R12 energy algorithm is similar to the MP2 energy
algorithm that uses MemoryGrp object to access distributed
memory. Hence the MTMPIMemoryGrp is the recommended <br>
implementation of MemoryGrp for such computations (see
Special Notes for MP2 Gradients). <br>
Disk I/O <br>
In contrast to the MP2 energy and gradient algorithms, the
MP2-R12 energy algorithm may have to use disk to store
transformed MO integrals if a single pass through the AO
<br>
integrals is not possible due to insufficient memory. The
best option in such case is to increase the total amount of
memory available to the computation by either increasing the
<br>
number of tasks or the amount of memory per task or both.
<br>
When increasing memory further is not possible, the user has
to specify which type of disk I/O should be used for the
MP2-R12 energy algorithm. It is done through the r12ints
<br>
keyword in input for the MBPT2_R12 object. The default
choice is to use POSIX I/O on the node on which task 0
resides. This kind of disk I/O is guaranteed to work on all
parallel <br>
machines, provided there&rsquo;s enough disk space on the
node. However, this is hardly most efficient on machines
with some sort of parallel I/O available. On machines which
have an <br>
efficient implementation of MPI-IO the r12ints should be set
instead to mpi-mem. This will force the MBPT2_R12 object to
use MPI-IO for disk I/O. It is user&rsquo;s responsibility
to <br>
make sure that the MO integrals file resides on an
MPI-IO-compatible file system. Hence the r12ints_file
keyword, which specifies the name of the MO integrals file,
should be set <br>
to a location which is guaranteed to work properly with
MPI-IO. For example, on IBM SP and other IBM machines which
have General Parallel File System (GPFS), the user should
set <br>
r12ints = mpi-mem and r12ints_file to a file on a GPFS file
system. <br>
Integral object <br>
At the moment, MBPT2_R12 objects require specific
specialization of Integral, IntegralCints. Thus in order to
compute MP2-R12 energies, your version of MPQC needs to be
compiled <br>
with support for IntegralCints. A free, open-source library
called libint is a prerequisite for IntegralCints. In order
to use IntegralCints as the default Integral object, add
<br>
-integral &rsquo;&lt;IntegralCints&gt;:()&rsquo; to the
command line, or set environmental variable INTEGRAL to
&rsquo;&lt;IntegralCints&gt;:()&rsquo;. <br>
Special Notes for CCA Components <br>
Common Component Architecture (CCA) <br>
Portions of MPQC functionality are being packaged into CCA
components. For general overviews of CCA technology and
framework usage, please see www.cca-forum.org (the tutorial
in <br>
particular) and the cca-chem-apps documentation. MPQC
components may be utilized directly within the ccaffeine
framework, while some components may be instantiated and
used <br>
within MPQC itself, making use of an embedded CCA framework.
<br>
CCA Runtime Environment <br>
For MPQC runs utilizing embedded components, the runtime
environment for the CCA framework must be specified. The
colon-separated path used to locate component libraries must
be <br>
specified either using the -cca-path command-line option or
using the cca_path key within the mpqc section of a keyval
input. The colon-separated list of component sidl class <br>
names which will be referenced within the input must be
specified using either the -cca-load command-line option or
using the cca_load key within the mpqc section of a keyval
<br>
input. If defaults for the cca-path and cca-load options are
desired, do_cca must be set to yes in the keyval input. MPQC
Input <br>
MPQC supports two input formats. The primary input is an
object oriented format which gives users access to all of
MPQC&rsquo;s options. The second format allows access to a
subset of <br>
MPQC&rsquo;s capabilities, but is more intuitive and easier
to learn. New users are advised to start with the simplified
format. MPQC can be used to convert the simplified format to
<br>
the full object-oriented format with the -i option. <br>
Each of these input formats is described in the following
two chapters: <br>
o Simple Input <br>
o Object-Oriented Input Simple Input <br>
The simple input format consists of keywords followed by a
&rsquo;:&rsquo; followed by a value. The keywords are case
sensitive. The values might be modified by options found in
parenthesis. <br>
For example, the following input performs an optimization of
water using density functional theory with the B3LYP
exchange-correlation functional: <br>
% B3LYP optimization of water <br>
optimize: yes <br>
method: KS (xc = B3LYP) <br>
basis: 3-21G* <br>
molecule: (angstrom) <br>
O 0.172 0.000 0.000 <br>
H 0.745 0.000 0.754 <br>
H 0.745 0.000 -0.754 <br>
Comments begin with a % and continue to the end of the line.
Basis set names containing special characters, such as a
space or parentheses, must be quoted inside a pair of double
<br>
quotes. The accepted keywords are: <br>
molecule <br>
Gives the atoms types and coordinates. The following options
can be used <br>
bohr <br>
The coordinates are given in Bohr. <br>
angstrom <br>
The coordinates are given in Angstroms (the default). <br>
charge <br>
This option can be given after an &rsquo;element x y
z&rsquo; quadruple. This will override the charge on the
atom. For example, (charge = 0) can be given for the ghost
atoms in a <br>
counterpoise correction calculation. <br>
multiplicity <br>
Gives the multiplicity of the molecule. The default is 1.
<br>
optimize <br>
If yes, then an optimization will be performed. The default
is no. The following options can be given. <br>
cartesian <br>
Use Cartesian coordinates. <br>
internal <br>
Use internal coordinates. <br>
redundant <br>
Use redundant internal coordinates. <br>
gradient <br>
If yes, then a gradient calculation will be performed. The
default is no. <br>
frequencies <br>
If yes, then the frequencies will be obtained. The default
is no. <br>
charge <br>
Specificies the charge on the molecule. The default is 0.
<br>
method <br>
Specifices the method. There is no default and the possible
values are: <br>
HF Hartree-Fock. Unrestricted HF is used if multiplicity
&gt; 1 <br>
RHF <br>
Restricted Hartree-Fock. <br>
UHF <br>
Unrestricted Hartree-Fock. <br>
KS Kohn-Sham. Unrestricted KS is used if multiplicity &gt; 1
<br>
RKS <br>
Restricted Kohn-Sham. <br>
UKS <br>
Unrestricted Kohn-Sham. <br>
MP2 <br>
Second order Moeller-Plesset perturbation theory. Only
available for multiplicity = 1. <br>
MP2-R12/A <br>
The A version of MP2-R12. Only available for multiplicity =
1. An auxiliary basis may be specified. No gradient,
optimization, or frequencies are possible. <br>
MP2-R12/A&rsquo; <br>
The A&rsquo; version of MP2-R12. Only available for
multiplicity = 1. An auxiliary basis may be specified. No
gradient, optimization, or frequencies are possible. <br>
ZAPT2 <br>
Z-averaged perturbation theory. Only available for
multiplicity &gt; 1. No gradient, optimization, or
frequencies are possible. <br>
The following options are valid with the KS, RKS, and UKS
methods: <br>
grid <br>
Specifies the grid to be used for numerical integrations.
The following values can be given: <br>
xcoarse <br>
coarse <br>
medium <br>
fine <br>
xfine <br>
ultrafine <br>
xc Specifies the exchange-correlation functional. There is
no default. See the table in the StdDenFunctional class
documentation for the possible values. <br>
The following options are valid with the MP2-R12/A and
MP2-R12/A&rsquo; methods. These options are mutually
exclusive: <br>
abs <br>
Use the standard Auxiliary Basis Set method. <br>
abs+ <br>
Use the standard Auxiliary Basis Set method, but use the
union of the orbital and the given auxiliary basis as the
actual auxiliary basis set used. <br>
cabs <br>
Use the Complementary Auxiliary Basis Set method. <br>
cabs+ <br>
Use the Complementary Auxiliary Basis Set method, but use
the union of the orbital and the given auxiliary basis as
the actual auxiliary basis set used. <br>
The following options are valid with the MP2-R12/A&rsquo;
method: <br>
ebc <br>
Assume the Extended Brillion Condition to hold. This is the
default. <br>
gbc <br>
Assume the Generalized Brillion Condition to hold. This is
the default. <br>
!ebc <br>
Do not assume the Extended Brillion Condition to hold. <br>
!gbc <br>
Do not assume the Generalized Brillion Condition to hold.
<br>
basis <br>
Specifies the basis set. There is no default. See the table
in the GaussianBasisSet class documentation for the
available basis sets. <br>
auxbasis <br>
Specifies the auxiliary basis set for MP2-R12 methods. There
is no default. See the table in the GaussianBasisSet class
documentation for the available basis sets. <br>
restart <br>
Set to yes to restart an optimization. The default is no.
<br>
checkpoint <br>
Set to no to not save checkpoint files during an
optimization. The default is yes. <br>
symmetry <br>
Specifices the Schoenflies symbol of the point group of the
molecule. The default is auto, which will cause to program
to find the highest order Abelian subgroup of the <br>
molecule. <br>
docc <br>
Gives the number of doubly occupied orbitals in each each
irreducible representation in a parenthesized list. The
symmetry must be specified and not be auto. The method must
<br>
be restricted. <br>
socc <br>
Gives the number of single occupied orbitals in each each
irreducible representation in a parenthesized list. The
symmetry must be specified and not be auto. The method must
<br>
be restricted. <br>
alpha <br>
Gives the number of alpha occupied orbitals in each each
irreducible representation in a parenthesized list. The
symmetry must be specified and not be auto. The method must
<br>
be unrestricted. <br>
beta <br>
Gives the number of beta occupied orbitals in each each
irreducible representation in a parenthesized list. The
symmetry must be specified and not be auto. The method must
be <br>
unrestricted. <br>
frozen_docc <br>
Gives the number of frozen core orbitals. Can be either a
single integer or a parenthesized list giving the frozen
core orbitals in each irreducible representation. In the
<br>
latter case the symmetry must be given and not be auto. <br>
frozen_uocc <br>
Gives the number of frozen virtual orbitals. Can be either a
single integer or a parenthesized list giving the frozen
virtual orbitals in each irreducible representation. In <br>
the latter case the symmetry must be given and not be auto.
<br>
memory <br>
Gives a hint for the amount of memory in bytes that can be
used. This is typically a lower bound, more memory will be
used in practice and the exact amount cannot be <br>
precisely controlled. The format is a fixed or floating
point number optionally followed (without spaces) by one of
the following suffixes: KB, MB, GB, KIB, MIB, or GIB.
Object-Oriented Input <br>
MPQC is an object-oriented program that directly allows the
user to specify objects that MPQC then manipulates to obtain
energies, properties, etc. This makes the input very <br>
flexible, but very complex. However, most calculations
should be quite similar to the one of the examples given
later in this chapter. The best way to get started is to use
one <br>
of the example input files and modify it to meet your needs.
<br>
The object-oriented input format is described in the
following sections: <br>
o Overview of the Object-Oriented Input <br>
o A Walk-Through of an Object-Oriented Input File <br>
o Sample Object-Oriented Input Files <br>
Overview of the Object-Oriented Input <br>
MPQC starts off by creating a ParsedKeyVal object that
parses the input file specified on the command line. The
format of the input file is documented in the KeyVal <br>
documentation. It is basically a free format input that
associates keywords and logical groupings of keywords with
values. The values can be scalars, arrays, or objects. <br>
The keywords recognized by MPQC begin with the mpqc prefix.
That is, they must be nested between an mpqc:( and a ).
Alternately, each keyword can be individually prefixed by
<br>
mpqc:. The primary keywords are given below. Some of the
keywords specify objects, in which case the object will
require more ParsedKeyVal input. These objects are created
from <br>
the input by using their ParsedKeyVal constructors. These
constructors are documented with the source code
documentation for the class. <br>
mole <br>
This is the most important keyword for MPQC. It specifies
the MolecularEnergy object. This is an object that knows how
to compute the energy of a molecule. The <br>
specializations of MolecularEnergy that are most commonly
used are CLKS, HSOSKS, UKS, CLHF, HSOSHF, UHF, and MBPT2.
<br>
opt <br>
This keyword must be specified for optimizations. It
specifies an Optimize object. Usually, QNewtonOpt is best
for finding minima and EFCOpt is best for transition states.
<br>
freq <br>
This keyword must be specified to compute frequencies. It
specifies a MolecularFrequencies object. <br>
thread <br>
This specifies an object of type ThreadGrp that can be used
to advantage on shared-memory multiprocessor machines for
certain types of calculations. This keyword can be <br>
overridden by giving the ThreadGrp in the environment or
command line. See the section on running MPQC for more
information. <br>
integrals <br>
This specifies an object of type Integral that will be used
as the default integral evaluator. If MP2-R12 is used, then
this should be set to use IntegralCints with a line <br>
like integrals&lt;IntegralCints&gt;: (). <br>
checkpoint <br>
The value of this keyword is boolean. <br>
&lt;ul&gt;</p>


<p style="margin-top: 1em">&lt;li&gt;&lt;tt&gt;true&lt;/tt&gt;
and optimization is to be performed &lt;br&gt;</p>

<p style="margin-top: 1em">&lt;tt&gt;opt&lt;/tt&gt; object
will be checkpointed after each iteration. <br>
The checkpoint file suffix is &quot;.ckpt&quot;.</p>


<p style="margin-top: 1em">&lt;li&gt;&lt;tt&gt;true&lt;/tt&gt;
and optimization is not performed &lt;br&gt;</p>

<p style="margin-top: 1em">&lt;tt&gt;mole&lt;/tt&gt; object
will be checkpointed at intermediate points. <br>
The manner in which <br>
&lt;tt&gt;mole&lt;/tt&gt; will be checkpointed depends on
its particular type. <br>
The checkpoint file suffix is usually &quot;.wfn&quot;,
however <br>
in general it will depend on the particular specialization
of <br>
&lt;tt&gt;MolecularEnergy&lt;/tt&gt;.</p>

<p style="margin-top: 1em">&lt;/ul&gt;</p>

<p style="margin-top: 1em">The default is to not
checkpoint. <br>
&lt;/dd&gt;</p>

<p style="margin-top: 1em">checkpoint_freq <br>
This specifies how often to checkpoint certain
MolecularEnergy specializations which compute iteratively.
Currently, mole objects of SCF type can use this keyword.
The <br>
default is 1, which means to checkpoint after every
iteration. <br>
savestate <br>
The value of this keyword is boolean. If true, then the
states of the Optimize and MolecularEnergy objects will be
saved after the calculation completes. The output file <br>
suffixes are &rsquo;.ckpt&rsquo; and &rsquo;.wfn&rsquo;,
respectively. The default is to save state. <br>
restart <br>
The value of this keyword is boolean. If true, mpqc will
attempt to restart the calculation. If the checkpoint file
is not found, the calculation will continue as if the <br>
value were false. The default is true. <br>
restart_file <br>
This gives the name of a file from which restart information
is read. If the file name ends with &rsquo;.wfn&rsquo; then
MPQC will try to restore a MolecularEnergy object from it
and <br>
query for the opt object in the input file. If the file name
ends with &rsquo;.ckpt&rsquo; MPQC will try to restore an
Optimize object from this file. The default file name is
formed by <br>
appending &rsquo;.ckpt&rsquo; to the input file name with
the extension removed. <br>
do_energy <br>
The value of this keyword is boolean. If true a single point
energy calculation will be done for the MolecularEnergy
object given with the mole keyword. The default is true.
<br>
do_gradient <br>
The value of this keyword is boolean. If true a single point
gradient calculation will be done for the MolecularEnergy
object given with the mole keyword. The default is <br>
false. <br>
do_cca <br>
The value of this keywork is boolean. If true the cca
embedded framework will be initialized. The default is
false. <br>
cca_path <br>
The value of this keyword is a string that provides a
colon-separated list of directories in which CCA component
libraries may be found. <br>
cca_load <br>
The value of this keyword is a string that provides a
colon-separated list of sidl class names for CCA components
which will be instantiated from the libraries found in the
<br>
path given by cca_path. <br>
optimize <br>
The value of this keyword is boolean. If true and the opt
keyword was set to a valid value, then an optimization will
be performed. The default is true. <br>
write_pdb <br>
The value of this keyword is boolean. If true a PDB file
with the molecular coordinates will be written. <br>
filename <br>
The value of this keyword is a string that gives a name from
which checkpoint and other filenames are constructed. The
default is the basename of the input file. <br>
print_timings <br>
If this is true, timing information is printed at the end of
the run. The default is true. <br>
There are also some utility keywords that tell mpqc some
technical details about how to do the calculation: <br>
debug <br>
This optional keyword gives a Debugger object which can be
used to help find the problem if MPQC encounters a
catastrophic error. <br>
matrixkit <br>
This optional keyword gives a SCMatrixKit specialization
which is used to produce matrices of the desired type. The
default is a ReplSCMatrixKit which replicates matrices on
<br>
all of the nodes. Other choices are not thoroughly tested.
<br>
A Walk-Through of an Object-Oriented Input File <br>
This example input does a Hartree-Fock calculation on water.
Following is the entire input, followed by a breakdown with
descriptions. <br>
% This input does a Hartree-Fock calculation on water. <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
) <br>
) <br>
We start with a descriptive comment. Comments begin with a
%. Everything from the % to the end of the line is ignored.
<br>
% This input does a Hartree-Fock calculation on water. <br>
Now lets set up a Molecule object. The name of the object
comes first, it is molecule. Then, in angle brackets, comes
the type of the molecule, which is the class Molecule. The
<br>
keyword and class name are followed by a : and then several
pieces of input grouped between a pair of matching
parentheses. These parentheses contain the information that
will be <br>
given to Molecule KeyVal constructor. <br>
molecule&lt;Molecule&gt;: ( <br>
The point group of the molecule is needed. This is done by
assigning symmetry to a case insensitive Schoenflies symbol
that is used to initialize a PointGroup object. An Abelian
<br>
point group should be used. <br>
symmetry = C2V <br>
The default unit for the Cartesian coordinates is Bohr. You
can specify other units by assigned unit to a string that
will be used to initialize a Units object. <br>
unit = angstrom <br>
Finally, the atoms and coordinates are given. This can be
given in the shorthand table syntax shown below. The
headings of the table are the keywords between the first
pair of <br>
brackets. These are followed by an = and another pair of
brackets that contain the data. The first datum is assigned
to the first element of the array that corresponds to the
<br>
first heading, atom. The second datum is assigned to the
first element of the array associated with the second
heading, geometry, and so on. Here the second datum is
actually a <br>
vector: the x, y and z coordinates of the first atom. <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
Next, a basis set object is given. <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
Now we will give the main body of input. All the subsequent
keywords will be grouped in the mpqc section of the input
(that is, each keyword will be prefixed with mpqc:). <br>
mpqc: ( <br>
Next we give the mole keyword which provides a
specialization of the MolecularEnergy class. In this case we
will do a closed-shell Hartree-Fock calculation. That is
done with an <br>
object of type CLHF. The keywords that CLHF accepts are
given with the documentation for the CLHF class, usually in
the description of the const RefKeyVal&amp; constructor for
the <br>
class. Also with the CLHF documentation is a list of parent
classes. Each of the parent classes may also have input.
This input is included with the rest of the input for the
<br>
child class. <br>
mole&lt;CLHF&gt;: ( <br>
The next line specifies the molecule to be used. There are
two things to note, first that this is actually a reference
to complete molecule specification elsewhere in the input
<br>
file. The $ indicates that this is a reference and the
keyword following the $ is the actual location of the
molecule. The : in front of the keyword means that the
keyword is not <br>
relative to the current location in the input, but rather
relative to the root of the tree of keywords. Thus, this
line grabs the molecule that was specified above. The
molecule <br>
object could have been placed here, but frequently it is
necessary that several objects refer to the exact same
object and this can only be done using references. <br>
The second point is that if you look at the documentation
for CLHF, you will see that it doesn&rsquo;t read molecule
keyword. However, if you follow its parent classes up to
<br>
MolecularEnergy, you&rsquo;ll find that molecule is indeed
read. <br>
molecule = $:molecule <br>
Just as we gave molecule, specify the basis set with the
basis keyword as follows: <br>
basis = $:basis <br>
Now we close off the parentheses we opened above and we are
finished. <br>
) <br>
) <br>
Sample Object-Oriented Input Files <br>
The easiest way to get started with mpqc is to start with
one of sample inputs that most nearly matches your problem.
The src/bin/mpqc/samples contains all of the sample inputs
<br>
below: <br>
o Hartree-Fock Energy <br>
o MP2 Energy <br>
o MP2-R12 energy <br>
o Hartree-Fock Optimization <br>
o Optimization with a Computed Guess Hessian <br>
o Optimization Using Newton&rsquo;s Method <br>
o Hartree-Fock Frequencies <br>
o Giving Coordinates and a Guess Hessian <br>
o Optimization with a Hydrogen Bond <br>
o Fixed Coordinate Optimization <br>
o Transition State Optimization <br>
o Transition State Optimization with a Computed Guess
Hessian <br>
o Hartree-Fock energy with intermediate checkpointing <br>
o MP2-R12 energy with intermediate checkpointing <br>
o HF gradient computed from a previously computed HF wave
funtion <br>
o MP2 Energy computed using precomputed Hartree-Fock wave
function <br>
o CLHF energy using a CCA integrals component <br>
Hartree-Fock Energy <br>
The following input will compute the Hartree-Fock energy of
water. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
memory = 16000000 <br>
) <br>
) <br>
MP2 Energy <br>
The following input will compute the MP2 energy of water.
<br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;MBPT2&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
memory = 16000000 <br>
% reference wavefunction <br>
reference&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
memory = 16000000 <br>
) <br>
) <br>
) <br>
MP2-R12 energy <br>
The following will compute the MP2-R12 energy of water in
standard approximation A&rsquo; (MP2-R12/A&rsquo;). <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;cc-pVDZ&rsquo; <br>
molecule = $:molecule <br>
) <br>
% auxiliary basis set specification <br>
abasis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;aug-cc-pVDZ&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;MBPT2_R12&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
aux_basis = $:abasis <br>
stdapprox = &rsquo;A&rsquo;&rsquo; <br>
nfzc = 1 <br>
memory = 16000000 <br>
integrals&lt;IntegralCints&gt;:() <br>
% reference wavefunction <br>
reference&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
memory = 16000000 <br>
integrals&lt;IntegralCints&gt;:() <br>
) <br>
) <br>
) <br>
Hartree-Fock Optimization <br>
The following input will optimize the geometry of water
using the quasi-Newton method. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;6-31G*&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% molecular coordinates for optimization <br>
coor&lt;SymmMolecularCoor&gt;: ( <br>
molecule = $:molecule <br>
generator&lt;IntCoorGen&gt;: ( <br>
molecule = $:molecule <br>
) <br>
) <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
coor = $..:coor <br>
memory = 16000000 <br>
) <br>
% optimizer object for the molecular geometry <br>
opt&lt;QNewtonOpt&gt;: ( <br>
function = $..:mole <br>
update&lt;BFGSUpdate&gt;: () <br>
convergence&lt;MolEnergyConvergence&gt;: ( <br>
cartesian = yes <br>
energy = $..:..:mole <br>
) <br>
) <br>
) <br>
Optimization with a Computed Guess Hessian <br>
The following input will optimize the geometry of water
using the quasi-Newton method. The guess Hessian will be
computed at a lower level of theory. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;6-31G*&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% molecular coordinates for optimization <br>
coor&lt;SymmMolecularCoor&gt;: ( <br>
molecule = $:molecule <br>
generator&lt;IntCoorGen&gt;: ( <br>
molecule = $:molecule <br>
) <br>
) <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
coor = $..:coor <br>
memory = 16000000 <br>
guess_hessian&lt;FinDispMolecularHessian&gt;: ( <br>
molecule = $:molecule <br>
only_totally_symmetric = yes <br>
eliminate_cubic_terms = no <br>
checkpoint = no <br>
energy&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
memory = 16000000 <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;3-21G&rsquo; <br>
molecule = $:molecule <br>
) <br>
) <br>
) <br>
) <br>
% optimizer object for the molecular geometry <br>
opt&lt;QNewtonOpt&gt;: ( <br>
function = $..:mole <br>
update&lt;BFGSUpdate&gt;: () <br>
convergence&lt;MolEnergyConvergence&gt;: ( <br>
cartesian = yes <br>
energy = $..:..:mole <br>
) <br>
) <br>
) <br>
Optimization Using Newton&rsquo;s Method <br>
The following input will optimize the geometry of water
using the Newton&rsquo;s method. The Hessian will be
computed at each step in the optimization. However, Hessian
recomputation <br>
is usually not worth the cost; try using the computed
Hessian as a guess Hessian for a quasi-Newton method before
resorting to a Newton optimization. <br>
% Emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = c2v <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.36937294 ] <br>
H [ 0.78397590 0.00000000 -0.18468647 ] <br>
H [ -0.78397590 0.00000000 -0.18468647 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;3-21G&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
restart = no <br>
% molecular coordinates for optimization <br>
coor&lt;SymmMolecularCoor&gt;: ( <br>
molecule = $:molecule <br>
generator&lt;IntCoorGen&gt;: ( <br>
molecule = $:molecule <br>
) <br>
) <br>
do_energy = no <br>
do_gradient = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
memory = 16000000 <br>
coor = $..:coor <br>
guess_wavefunction&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
total_charge = 0 <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
molecule = $:molecule <br>
name = &rsquo;STO-3G&rsquo; <br>
) <br>
memory = 16000000 <br>
) <br>
hessian&lt;FinDispMolecularHessian&gt;: ( <br>
only_totally_symmetric = yes <br>
eliminate_cubic_terms = no <br>
checkpoint = no <br>
) <br>
) <br>
optimize = yes <br>
% optimizer object for the molecular geometry <br>
opt&lt;NewtonOpt&gt;: ( <br>
print_hessian = yes <br>
max_iterations = 20 <br>
function = $..:mole <br>
convergence&lt;MolEnergyConvergence&gt;: ( <br>
cartesian = yes <br>
energy = $..:..:mole <br>
) <br>
) <br>
) <br>
Hartree-Fock Frequencies <br>
The following input will compute Hartree-Fock frequencies by
finite displacements. A thermodynamic analysis will also be
performed. If optimization input is also provided, then <br>
the optimization will be run first, then the frequencies.
<br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C1 <br>
{ atoms geometry } = { <br>
O [ 0.0000000000 0.0000000000 0.8072934188 ] <br>
H [ 1.4325589285 0.0000000000 -0.3941980761 ] <br>
H [ -1.4325589285 0.0000000000 -0.3941980761 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
memory = 16000000 <br>
) <br>
% vibrational frequency input <br>
freq&lt;MolecularFrequencies&gt;: ( <br>
molecule = $:molecule <br>
) <br>
) <br>
Giving Coordinates and a Guess Hessian <br>
The following example shows several features that are really
independent. The variable coordinates are explicitly given,
rather than generated automatically. This is especially <br>
useful when a guess Hessian is to be provided, as it is
here. This Hessian, as given by the user, is not complete
and the QNewtonOpt object will fill in the missing values
using <br>
a guess the Hessian provided by the MolecularEnergy object.
Also, fixed coordinates are given in this sample input. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C1 <br>
{ atoms geometry } = { <br>
H [ 0.088 2.006 1.438 ] <br>
O [ 0.123 3.193 0.000 ] <br>
H [ 0.088 2.006 -1.438 ] <br>
O [ 4.502 5.955 -0.000 ] <br>
H [ 2.917 4.963 -0.000 ] <br>
H [ 3.812 7.691 -0.000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
coor = $..:coor <br>
memory = 16000000 <br>
) <br>
% molecular coordinates for optimization <br>
coor&lt;SymmMolecularCoor&gt;: ( <br>
molecule = $:molecule <br>
generator&lt;IntCoorGen&gt;: ( <br>
molecule = $:molecule <br>
extra_bonds = [ 2 5 ] <br>
) <br>
% use these instead of generated coordinates <br>
variable&lt;SetIntCoor&gt;: [ <br>
&lt;StreSimpleCo&gt;:( atoms = [ 2 5 ] ) <br>
&lt;BendSimpleCo&gt;:( atoms = [ 2 5 4 ] ) <br>
&lt;OutSimpleCo&gt;: ( atoms = [ 5 2 1 3 ] ) <br>
&lt;SumIntCoor&gt;: ( <br>
coor: [ <br>
&lt;StreSimpleCo&gt;:( atoms = [ 1 2 ] ) <br>
&lt;StreSimpleCo&gt;:( atoms = [ 2 3 ] ) <br>
] <br>
coef = [ 1.0 1.0 ] <br>
) <br>
&lt;SumIntCoor&gt;: ( <br>
coor: [ <br>
&lt;StreSimpleCo&gt;:( atoms = [ 4 5 ] ) <br>
&lt;StreSimpleCo&gt;:( atoms = [ 4 6 ] ) <br>
] <br>
coef = [ 1.0 1.0 ] <br>
) <br>
&lt;BendSimpleCo&gt;:( atoms = [ 1 2 3 ] ) <br>
&lt;BendSimpleCo&gt;:( atoms = [ 5 4 6 ] ) <br>
] <br>
% these are fixed by symmetry anyway, <br>
fixed&lt;SetIntCoor&gt;: [ <br>
&lt;SumIntCoor&gt;: ( <br>
coor: [ <br>
&lt;StreSimpleCo&gt;:( atoms = [ 1 2 ] ) <br>
&lt;StreSimpleCo&gt;:( atoms = [ 2 3 ] ) <br>
] <br>
coef = [ 1.0 -1.0 ] <br>
) <br>
&lt;SumIntCoor&gt;: ( <br>
coor: [ <br>
&lt;StreSimpleCo&gt;:( atoms = [ 4 5 ] ) <br>
&lt;StreSimpleCo&gt;:( atoms = [ 4 6 ] ) <br>
] <br>
coef = [ 1.0 -1.0 ] <br>
) <br>
&lt;TorsSimpleCo&gt;:( atoms = [ 2 5 4 6] ) <br>
&lt;OutSimpleCo&gt;:( atoms = [ 3 2 6 4 ] ) <br>
&lt;OutSimpleCo&gt;:( atoms = [ 1 2 6 4 ] ) <br>
] <br>
) <br>
% optimizer object for the molecular geometry <br>
opt&lt;QNewtonOpt&gt;: ( <br>
function = $..:mole <br>
update&lt;BFGSUpdate&gt;: () <br>
convergence&lt;MolEnergyConvergence&gt;: ( <br>
cartesian = yes <br>
energy = $..:..:mole <br>
) <br>
% give a partial guess hessian in internal coordinates <br>
% the missing elements will be filled in automatically <br>
hessian = [ <br>
[ 0.0109261670 ] <br>
[ -0.0004214845 0.0102746106 ] <br>
[ -0.0008600592 0.0030051330 0.0043149957 ] <br>
[ 0.0 0.0 0.0 ] <br>
[ 0.0 0.0 0.0 ] <br>
[ 0.0 0.0 0.0 ] <br>
[ 0.0 0.0 0.0 ] <br>
] <br>
) <br>
) <br>
Optimization with a Hydrogen Bond <br>
The automatic internal coordinate generator will fail if it
cannot find enough redundant internal coordinates. In this
case, the internal coordinate generator must be explicitly
<br>
created in the input and given extra connectivity
information, as is shown below. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C1 <br>
{ atoms geometry } = { <br>
H [ 0.088 2.006 1.438 ] <br>
O [ 0.123 3.193 0.000 ] <br>
H [ 0.088 2.006 -1.438 ] <br>
O [ 4.502 5.955 -0.000 ] <br>
H [ 2.917 4.963 -0.000 ] <br>
H [ 3.812 7.691 -0.000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
coor = $..:coor <br>
memory = 16000000 <br>
) <br>
% molecular coordinates for optimization <br>
coor&lt;SymmMolecularCoor&gt;: ( <br>
molecule = $:molecule <br>
% give an internal coordinate generator that knows about the
<br>
% hydrogen bond between atoms 2 and 5 <br>
generator&lt;IntCoorGen&gt;: ( <br>
molecule = $:molecule <br>
extra_bonds = [ 2 5 ] <br>
) <br>
) <br>
% optimizer object for the molecular geometry <br>
opt&lt;QNewtonOpt&gt;: ( <br>
function = $..:mole <br>
update&lt;BFGSUpdate&gt;: () <br>
convergence&lt;MolEnergyConvergence&gt;: ( <br>
cartesian = yes <br>
energy = $..:..:mole <br>
) <br>
) <br>
) <br>
Fixed Coordinate Optimization <br>
This example shows how to selectively fix internal
coordinates in an optimization. Any number of linearly
independent coordinates can be given. These coordinates must
remain <br>
linearly independent throughout the optimization, a
condition that might not hold since the coordinates can be
nonlinear. <br>
By default, the initial fixed coordinates&rsquo; values are
taken from the cartesian geometry given by the Molecule
object; however, the molecule will be displaced to the
internal <br>
coordinate values given with the fixed internal coordinates
if have_fixed_values keyword is set to true, as shown in
this example. In this case, the initial cartesian geometry
<br>
should be reasonably close to the desired initial geometry
and all of the variable coordinates will be frozen to their
original values during the initial displacement. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = CS <br>
{ atoms geometry } = { <br>
H [ 3.04 -0.69 -1.59 ] <br>
H [ 3.04 -0.69 1.59 ] <br>
N [ 2.09 -0.48 -0.00 ] <br>
C [ -0.58 -0.15 0.00 ] <br>
H [ -1.17 1.82 0.00 ] <br>
H [ -1.41 -1.04 -1.64 ] <br>
H [ -1.41 -1.04 1.64 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;3-21G*&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% molecular coordinates for optimization <br>
coor&lt;SymmMolecularCoor&gt;: ( <br>
molecule = $:molecule <br>
generator&lt;IntCoorGen&gt;: ( <br>
molecule = $:molecule <br>
) <br>
have_fixed_values = yes <br>
fixed&lt;SetIntCoor&gt;: [ <br>
&lt;OutSimpleCo&gt;: ( value = -0.1 <br>
label = &rsquo;N-inversion&rsquo; <br>
atoms = [4 3 2 1] ) <br>
] <br>
) <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
coor = $..:coor <br>
memory = 16000000 <br>
) <br>
% optimizer object for the molecular geometry <br>
opt&lt;QNewtonOpt&gt;: ( <br>
max_iterations = 20 <br>
function = $..:mole <br>
update&lt;BFGSUpdate&gt;: () <br>
convergence&lt;MolEnergyConvergence&gt;: ( <br>
cartesian = yes <br>
energy = $..:..:mole <br>
) <br>
) <br>
) <br>
Transition State Optimization <br>
This example shows a transition state optimization of the
N-inversion in $thrm{CH}_3thrm{NH}_2$ using mode following.
The initial geometry was obtained by doing a few fixed <br>
coordinate optimizations along the inversion coordinate.
<br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = CS <br>
{ atoms geometry } = { <br>
H [ 3.045436 -0.697438 -1.596748 ] <br>
H [ 3.045436 -0.697438 1.596748 ] <br>
N [ 2.098157 -0.482779 -0.000000 ] <br>
C [ -0.582616 -0.151798 0.000000 ] <br>
H [ -1.171620 1.822306 0.000000 ] <br>
H [ -1.417337 -1.042238 -1.647529 ] <br>
H [ -1.417337 -1.042238 1.647529 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;3-21G*&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% molecular coordinates for optimization <br>
coor&lt;SymmMolecularCoor&gt;: ( <br>
molecule = $:molecule <br>
generator&lt;IntCoorGen&gt;: ( <br>
molecule = $:molecule <br>
) <br>
followed&lt;OutSimpleCo&gt; = [ &rsquo;N-inversion&rsquo; 4
3 2 1 ] <br>
) <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
coor = $..:coor <br>
memory = 16000000 <br>
) <br>
% optimizer object for the molecular geometry <br>
opt&lt;EFCOpt&gt;: ( <br>
transition_state = yes <br>
mode_following = yes <br>
max_iterations = 20 <br>
function = $..:mole <br>
update&lt;PowellUpdate&gt;: () <br>
convergence&lt;MolEnergyConvergence&gt;: ( <br>
cartesian = yes <br>
energy = $..:..:mole <br>
) <br>
) <br>
) <br>
Transition State Optimization with a Computed Guess Hessian
<br>
This example shows a transition state optimization of the
N-inversion in $thrm{CH}_3thrm{NH}_2$ using mode following.
The initial geometry was obtained by doing a few fixed <br>
coordinate optimizations along the inversion coordinate. An
approximate guess Hessian will be computed, which makes the
optimiziation converge much faster in this case. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = CS <br>
{ atoms geometry } = { <br>
H [ 3.045436 -0.697438 -1.596748 ] <br>
H [ 3.045436 -0.697438 1.596748 ] <br>
N [ 2.098157 -0.482779 -0.000000 ] <br>
C [ -0.582616 -0.151798 0.000000 ] <br>
H [ -1.171620 1.822306 0.000000 ] <br>
H [ -1.417337 -1.042238 -1.647529 ] <br>
H [ -1.417337 -1.042238 1.647529 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;3-21G*&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% molecular coordinates for optimization <br>
coor&lt;SymmMolecularCoor&gt;: ( <br>
molecule = $:molecule <br>
generator&lt;IntCoorGen&gt;: ( <br>
molecule = $:molecule <br>
) <br>
followed&lt;OutSimpleCo&gt; = [ &rsquo;N-inversion&rsquo; 4
3 2 1 ] <br>
) <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
coor = $..:coor <br>
memory = 16000000 <br>
guess_hessian&lt;FinDispMolecularHessian&gt;: ( <br>
molecule = $:molecule <br>
only_totally_symmetric = yes <br>
eliminate_cubic_terms = no <br>
checkpoint = no <br>
energy&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
memory = 16000000 <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;3-21G&rsquo; <br>
molecule = $:molecule <br>
) <br>
) <br>
) <br>
) <br>
% optimizer object for the molecular geometry <br>
opt&lt;EFCOpt&gt;: ( <br>
transition_state = yes <br>
mode_following = yes <br>
max_iterations = 20 <br>
function = $..:mole <br>
update&lt;PowellUpdate&gt;: () <br>
convergence&lt;MolEnergyConvergence&gt;: ( <br>
cartesian = yes <br>
energy = $..:..:mole <br>
) <br>
) <br>
) <br>
Hartree-Fock energy with intermediate checkpointing <br>
The following two sections demonstrate how MPQC can be used
to save the mole object periodically. This input will
compute the Hartree-Fock energy of water while saving the
mole <br>
object every 3 iterations. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = yes <br>
filename = &rsquo;h2o-rhf-STO3G&rsquo; <br>
checkpoint_freq = 3 <br>
savestate = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
memory = 16000000 <br>
) <br>
) <br>
The mole object will be saved to files named
&rsquo;h2o-rhf-STO3G.wfn.&lt;iter#&gt;.tmp&rsquo; where
&lt;iter#&gt; is the SCF iteration number (3, 6, etc.). Only
the most recent file is kept, files from <br>
previous iterations are removed automatically. Keyword
filename here is used to set the default file name prefix.
<br>
MP2-R12 energy with intermediate checkpointing <br>
The following input will compute the MP2-R12 energy of water
in standard approximation A&rsquo; (MP2-R12/A&rsquo;) while
saving the mole object at intermediate checkpoints. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;cc-pVDZ&rsquo; <br>
molecule = $:molecule <br>
) <br>
% auxiliary basis set specification <br>
abasis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;aug-cc-pVDZ&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = yes <br>
filename = &rsquo;h2o-mp2r12ap-vdz-avdz&rsquo; <br>
savestate = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;MBPT2_R12&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
aux_basis = $:abasis <br>
stdapprox = &rsquo;A&rsquo;&rsquo; <br>
nfzc = 1 <br>
memory = 16000000 <br>
integrals&lt;IntegralCints&gt;:() <br>
% reference wavefunction <br>
reference&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
memory = 16000000 <br>
integrals&lt;IntegralCints&gt;:() <br>
) <br>
) <br>
) <br>
The mole object will be saved to a file named
h2o-mp2r12ap-vdz-avdz.wfn&quot;. Keyword filename here is
used to set the default file name prefix. Objects of the
MBPT2_R12 type are <br>
checkpointed after the HF procedure, after the first
integrals (SBS) transformation, and after the optional
second (ABS) transformation. <br>
HF gradient computed from a previously computed HF wave
funtion <br>
The following will illustrate how to reuse previously
computed MolecularEnergy objects in subsequent computations.
The first input computes Hartree-Fock energy for water and
<br>
saves the mole object to file h2o-rhf-sto3g.wfn. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = yes <br>
filename = &rsquo;h2o-rhf-sto3g&rsquo; <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
memory = 16000000 <br>
) <br>
) <br>
The second input reuses the mole object from the previous
run to compute the gradient of the Hartree-Fock energy. <br>
% emacs should use -*- KeyVal -*- mode <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
restart = yes <br>
restart_file = &rsquo;h2o-rhf-sto3g.wfn&rsquo; <br>
do_gradient = yes <br>
) <br>
MP2 Energy computed using precomputed Hartree-Fock wave
function <br>
The following input will compute the MP2 energy of water
using a saved Hartree-Fock wave function obtained using the
first input from HF gradient computed from a previously <br>
computed HF wave funtion. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
% wave function file object specification <br>
wfnfile&lt;BcastStateInBin&gt;:file =
&rsquo;h2o-rhf-sto3g.wfn&rsquo; <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;MBPT2&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
memory = 16000000 <br>
% reference wavefunction <br>
reference&lt;SavableStateProxy&gt;: ( <br>
statein = $:wfnfile <br>
object = &rsquo;CLHF&rsquo; <br>
) <br>
) <br>
) <br>
Note that now object reference is of type SavableStateProxy,
rather than CLHF. SavableStateProxy is a special object type
that can be converted at runtime into the desired type <br>
(in this case, CLHF, as indicated by object). <br>
CLHF energy using a CCA integrals component <br>
The following input will compute the CLHF energy of water
using a CCA integrals component via the IntegralCCA adaptor
class. <br>
% emacs should use -*- KeyVal -*- mode <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.00000000 0.00000000 0.37000000 ] <br>
H [ 0.78000000 0.00000000 -0.18000000 ] <br>
H [ -0.78000000 0.00000000 -0.18000000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;STO-3G&rsquo; <br>
molecule = $:molecule <br>
) <br>
mpqc: ( <br>
% path to component libraries <br>
cca_path = /usr/local/lib/cca <br>
% sidl class names of components which will be instantiated
<br>
cca_load = MPQC.IntegralEvaluatorFactory <br>
do_cca = yes <br>
checkpoint = no <br>
savestate = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;CLHF&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
% cca integrals adaptor class <br>
integrals&lt;IntegralCCA&gt;: ( <br>
molecule = $:molecule <br>
% integral buffer type <br>
integral_buffer = opaque <br>
% integral package <br>
integral_package = intv3 <br>
% factory component sidl class name <br>
evaluator_factory = MPQC.IntegralEvaluatorFactory <br>
) <br>
) <br>
) Validating MPQC <br>
After you compile MPQC, you should run the validation suite.
You should also run the validation suite if you upgrade your
operating system software, since this could change <br>
shared libraries that are linking with MPQC and could affect
the results. Note that the reference validation suite has
not been verified relative to an independent code, except
<br>
for a few spot checks. If you find that MPQC doesn&rsquo;t
produce the same answer as another quantum chemistry program
that you trust, then please promptly notify us and send all
the <br>
details. <br>
The top-level Makefile has several targets that can be used
to check an MPQC build. MPQC must be built before one of
these targets is used: <br>
check <br>
The same as check0 below. This is only available from the
top-level directory and src/bin/mpqc/validate. <br>
check0 <br>
Run the smallest MPQC verification suite. It tests basic
functionality. This is only available from the top-level
directory and src/bin/mpqc/validate. <br>
check1 <br>
Run the intermediate MPQC verification suite. It runs most
of the tests, only leaving out very expensive runs. This is
only available from the top-level directory and <br>
src/bin/mpqc/validate. <br>
check2 <br>
Run the complete MPQC verification suite. Depending on the
compilation and runtime environment, tests that are not
expected to work will be omitted. This is only available
<br>
from the top-level directory and src/bin/mpqc/validate. <br>
check_clean <br>
Remove MPQC verification suite output files. This is only
available from the top-level directory and
src/bin/mpqc/validate. <br>
testbuild <br>
Verify that a variety of small test programs compile. If
static libraries are used, this will require a substantial
amount of disk space. <br>
testrun <br>
Run a variety of small test programs. This will build them
if necessary. <br>
The check targets will run mpqc with the mpqcrun (see
mpqcrun) command. You can give arguments to mpqcrun by
setting the MPQCRUN_ARGS variable on the make command line.
<br>
The verification suite is in src/bin/mpqc/validate. After
running it, the output files can be found in
src/bin/mpqc/validate/run. The check targets will compare
outputs that your <br>
build produced to the reference files in
src/bin/mpqc/validate/ref. The input files can be found with
the reference files. For each comparison, first the status
(ok, missing, or <br>
failed) for each file is printed. If both statuses are ok
then an E: is printed followed by the number of digits to
which the energies agree. If they agree to all digits 99 is
<br>
printed. If a gradient was computed, then Grad: is printed
followed by the number of digits to which the gradients in
least agreement agree. Other properties checked in this way
<br>
include frequencies, diagnostics, and populations. <br>
If two numbers do not agree to the expected accuracy, then
an asterisk, *, is printed after the number of digits in
agreement. <br>
Finally, you can do a detailed comparison of the contents of
the ref and run subdirectories by typing make diff. <br>
The input files in the verification suite are divided into
several categories: <br>
h2o <br>
These are simple tests that exercise many of MPQC&rsquo;s
features. <br>
h2omp2 <br>
Tests that further exercise MP2. <br>
h2ofrq <br>
Tests of H2 O frequencies with a variety of methods. <br>
mbpt <br>
These tests exercise MP2 as well as the open-shell
perturbation theory methods. The various available
algorithms are tested as well. <br>
ckpt <br>
Tests the checkpoint and restart capabilities. <br>
symm1 <br>
Tests of point group symmetry. <br>
symm2 <br>
More point group symmetry tests. These use basis sets with
higher angular momentum than #symm1#. <br>
symm3 <br>
Tests automatic point group determination. <br>
basis1 <br>
A variety of basis sets are tested for first row atoms along
with hydrogen and helium. <br>
basis2 <br>
Basis sets test for second row atoms. <br>
methods <br>
Basic tests of several of MPQC&rsquo;s methods. <br>
clscf <br>
More tests of methods based on CLSCF. <br>
hsosscf <br>
More tests of methods based on HSOSSCF. <br>
uscf <br>
More tests of methods based on UnrestrictedSCF. <br>
dft <br>
More tests of the CLKS method. <br>
mp2r12 <br>
More tests of MP2-R12. <br>
ccaintv3 <br>
Tests of embedded CCA integrals components using intv3. <br>
ccacints <br>
Tests of embedded CCA integrals components using cints.
Running Psi 3 from MPQC <br>
Psi 3 is a suite of ab initio codes related to the original
Psi package started in Prof. Fritz Schaefer&rsquo;s group at
UC Berkeley. Current version of MPQC works with stable
versions <br>
of Psi 3 starting with 3.2.0. From now on we will refer to
Psi 3 as simply Psi. Psi is written primarily in C and
executes in serial mode only. The interface between Psi and
MPQC <br>
is intended mainly for Psi users who wish to exploit
MPQC&rsquo;s geometry optimization and frequency analyses
capabilities with Psi energies and gradients. <br>
The following sections explain how to use Psi from MPQC:
<br>
o How the MPQC-Psi interface works <br>
o Environmental Variables <br>
o Preparing an input file <br>
o Psi Execution Environment <br>
o PsiWavefunction specializations <br>
o More examples <br>
How the MPQC-Psi interface works <br>
The current version of the interface is rather slim. It is
only possible to import energies and gradients computed with
Psi into MPQC, i.e. wave functions cannot be imported. All
<br>
MPQC-Psi interaction happens via text files and system
calls. MPQC generates input file for Psi, calls appropriate
Psi modules, and then parses the output files for energies
and <br>
gradients. <br>
Environmental Variables <br>
Several environmental variables are used to control MPQC-Psi
interaction: <br>
PSIBIN <br>
By default, MPQC will try to find Psi binaries under
/usr/local/psi/bin. Use PSIBIN environmental variable to
point to the right location. <br>
The rest of the Psi environment is job specific and
specified in the input file. <br>
Preparing an input file <br>
As noted above, MPQC parses the input file, and as such the
input file has to be in the MPQC OO input format. All
features of usual MPQC input files are there (mpqc section,
mole <br>
MolecularEnergy object, etc.). In addition the following
rules apply:</p>

<p style="margin-top: 1em">o instead of using MPQC
Wavefunction objects (CLHF, MBPT2, etc.), the Psi specific
Wavefunction types (i.e. specializations of PsiWavefunction)
have to be used. Presently the <br>
following specializations are supported: PsiCLHF, PsiHSOSHF,
PsiUHF, PsiCCSD, PsiCCSD_T . The first three are directly
analogous to MPQC Wavefunction types CLHF, HSOSHF, and <br>
UHF. The latter two do not have MPQC analogs yet. See
appropriate class documentation on how to specify them
properly. <br>
o each Psi-specific Wavefunction object has to have a member
object psienv of type PsiExEnv. PsiExEnv contains job
specific information, such as the directory in which Psi
input, <br>
output, and checkpoint files will be kept, filename prefix,
scratch directories, etc. It makes sense to define one such
object and simply refer to it from all PsiWavefunction <br>
objects. See PsiExEnv class documentation for more info.
<br>
Psi Execution Environment <br>
Each PsiWavefunction-derived class has to have a member
object called psienv of type PsiExEnv. The following
keywords are used by its KeyVal constructor: <br>
cwd <br>
The directory where to keep Psi input, checkpoint, stdout,
stderr, and other files. Default is /tmp. <br>
fileprefix <br>
The file prefix to use for Psi checkpoint, scratch, and some
ASCII files. Equivalent to keyword name in Psi
psi:files:default section. Defaults to psi. <br>
stdout <br>
The file into which to redirect standard output of Psi
modules. Defaults to psi.stdout. <br>
stderr <br>
The file into which to redirect standard error of Psi
modules. Defaults to psi.stderr. <br>
nscratch <br>
The number of locations over which to stripe Psi binary
files. Equivalent to keyword nvolume in Psi
psi:files:default section. Default is 1. <br>
scratch <br>
The locations over which to stripe Psi binary files.
Equivalent to keyword volumex in Psi psi:files:default
section. There&rsquo;s no default. <br>
Here&rsquo;s an example: <br>
psienv&lt;PsiExEnv&gt;: ( <br>
cwd = ./ <br>
fileprefix = psi.test <br>
nscratch = 2 <br>
scratch = [ &rsquo;/scratch1/&rsquo;
&rsquo;/scratch2/&rsquo; ] <br>
) <br>
PsiWavefunction specializations <br>
Class PsiWavefunction is derived from class Wavefunction,
hence its KeyVal constructor uses all keywords that
Wavefunction&rsquo;s KeyVal constructor uses (basis,
molecule, etc.). In <br>
addition, PsiWavefunction&rsquo;s KeyVal constructor looks
for the following keywords in the input file: <br>
psienv <br>
The PsiExEnv object that provides job specific Psi
environment. There&rsquo;s no default. <br>
docc <br>
An optional array of integers that specifies the number of
doubly-occupied orbitals in each irrep. <br>
socc <br>
An optional array of integers that specifies the number of
singly-occupied orbitals in each irrep. <br>
frozen_docc <br>
An optional array of integers that specifies the number of
doubly-occupied orbitals in each irrep frozen in correlated
computations. <br>
frozen_uocc <br>
An optional array of integers that specifies the number of
unoccupied orbitals in each irrep frozen in correlated
computations. <br>
total_charge <br>
The total charge of the system. This keyword is queried only
if neither docc nor socc are given. <br>
multiplicity <br>
The spin multiplicity of the system (2*M_S+1). This keyword
is queried only if neither docc nor socc are given. <br>
memory <br>
The number of bytes of memory Psi modules associated with
this PsiWavefunction are allowed to use. Default is 2000000
(2 million bytes, approximately 2 MB). <br>
Note that keywords docc, socc, frozen_docc, frozen_uocc,
total_charge, and multiplicity are used by appropriate
specializations of PsiWavefunctions, i.e. PsiCLHF only
checks for <br>
docc, etc. <br>
PsiWavefunction specializations PsiCCSD and PsiCCSD_T also
look for keyword reference which specifies the reference
wave function (an object of type PsiSCF). All classes for
<br>
correlated Psi wave functions will require such an object.
<br>
Here are a few examples of PsiWavefunctions: <br>
% <br>
% ROHF DZ on F atom <br>
% <br>
mole&lt;PsiHSOSHF&gt;: ( <br>
docc = [ 2 0 0 0 0 1 1 0 ] socc = [ 0 0 0 0 0 0 0 1] <br>
memory = 10000000 <br>
% Psi Environment data <br>
psienv&lt;PsiExEnv&gt;: ( <br>
cwd = ./ <br>
fileprefix = f.dz.test <br>
stdout = f.dz.test.stdout <br>
stderr = f.dz.test.stderr <br>
nscratch = 1 <br>
scratch = [ &rsquo;/scratch/mpqc/&rsquo; ] <br>
) <br>
% MolecularEnergy input <br>
molecule&lt;Molecule&gt;: ( <br>
{atoms geometry} = { <br>
F [ 0.0 0.0 0.0 ] <br>
} <br>
) <br>
% Basis input <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
molecule = $..:molecule <br>
name = &rsquo;DZ (Dunning)&rsquo; <br>
) <br>
) <br>
% <br>
% RHF CCSD/cc-pVDZ on water <br>
% <br>
mole&lt;PsiCCSD&gt;: ( <br>
frozen_docc = [1 0 0 0] <br>
memory = 40000000 <br>
% Psi Environment data <br>
psienv&lt;PsiExEnv&gt;: ( <br>
cwd = ./ <br>
fileprefix = h2o.ccpvdz.ccsd.test <br>
nscratch = 1 <br>
scratch = [ &rsquo;/tmp/&rsquo; ] <br>
) <br>
% MolecularEnergy input <br>
molecule&lt;Molecule&gt;: ( <br>
{atoms geometry} = { <br>
H [ -1.5 0.0 -0.3 ] <br>
H [ 1.5 0.0 -0.3 ] <br>
O [ 0.0 0.0 1.0 ] <br>
} <br>
) <br>
% Basis input <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
molecule = $..:molecule <br>
name = &rsquo;cc-pVDZ&rsquo; <br>
) <br>
reference&lt;PsiCLHF&gt;: ( <br>
psienv = $..:psienv <br>
molecule = $..:molecule <br>
basis = $..:basis <br>
total_charge = 0 <br>
multiplicity = 1 <br>
) <br>
) <br>
More examples <br>
This section contains some examples of complete inputs that
specify an MPQC/Psi computations. <br>
Here&rsquo;s an optimization + subsequent frequency analysis
on water molecule at the RHF CCSD 6-311G** level: <br>
% Emacs should use -*- KeyVal -*- mode <br>
% this file was automatically generated <br>
% label: water test series <br>
% molecule specification <br>
molecule&lt;Molecule&gt;: ( <br>
symmetry = C2V <br>
unit = angstrom <br>
{ atoms geometry } = { <br>
O [ 0.000000000000 0.000000000000 0.369372944000 ] <br>
H [ 0.783975899000 0.000000000000 -0.184686472000 ] <br>
H [ -0.783975899000 0.000000000000 -0.184686472000 ] <br>
} <br>
) <br>
% basis set specification <br>
basis&lt;GaussianBasisSet&gt;: ( <br>
name = &rsquo;6-311G**&rsquo; <br>
molecule = $:molecule <br>
) <br>
% Psi environment specification <br>
psienv&lt;PsiExEnv&gt;: ( <br>
cwd = ./ <br>
fileprefix = mpqcpsi <br>
stdout = mpqcpsi.stdout <br>
stderr = mpqcpsi.stderr <br>
nscratch = 1 <br>
scratch = [ &rsquo;/scratch/evaleev/&rsquo; ] <br>
) <br>
mpqc: ( <br>
checkpoint = no <br>
savestate = no <br>
restart = no <br>
coor&lt;SymmMolecularCoor&gt;: ( <br>
molecule = $:molecule <br>
generator&lt;IntCoorGen&gt;: ( <br>
molecule = $:molecule <br>
) <br>
) <br>
% molecular coordinates for optimization do_energy = yes
<br>
do_gradient = no <br>
% method for computing the molecule&rsquo;s energy <br>
mole&lt;PsiCCSD&gt;: ( <br>
molecule = $:molecule <br>
basis = $:basis <br>
coor = $..:coor <br>
psienv = $:psienv <br>
memory = 32000000 <br>
reference&lt;PsiCLHF&gt;: ( <br>
psienv = $:psienv <br>
molecule = $:molecule <br>
total_charge = 0 <br>
multiplicity = 1 <br>
basis = $:basis <br>
memory = 32000000 <br>
) <br>
hessian&lt;FinDispMolecularHessian&gt;: ( <br>
point_group&lt;PointGroup&gt;: symmetry = C2V <br>
checkpoint = no <br>
restart = no <br>
) <br>
) <br>
optimize = yes <br>
% optimizer object for the molecular geometry <br>
opt&lt;QNewtonOpt&gt;: ( <br>
max_iterations = 20 <br>
function = $..:mole <br>
update&lt;BFGSUpdate&gt;: () <br>
convergence&lt;MolEnergyConvergence&gt;: ( <br>
cartesian = yes <br>
energy = $..:..:mole <br>
) <br>
) <br>
% vibrational frequency input <br>
freq&lt;MolecularFrequencies&gt;: ( <br>
point_group&lt;PointGroup&gt;: symmetry = C2V <br>
molecule = $:molecule <br>
) <br>
) CCA Components <br>
Common Component Architecture (CCA) component wrappers,
conforming to interfaces developed for the CCA Chemistry
Component Toolkit, have been created to encapsulate some
MPQC <br>
functionality. The following components are provided by
MPQC: <br>
o MPQC.Chemistry_QC_ModelFactory <br>
o MPQC.ChemistryOpt_CoordinateModel <br>
o MPQC.IntegralEvaluatorFactory <br>
MPQC.Chemistry_QC_ModelFactory <br>
This is an implementation of the Chemistry.QC.ModelFactory
interface. This factory produces model objects (implementing
the Chemistry.QC.Model interface) based on the MPQC <br>
package. The MPQC model allows calculation of molecular
energies and energy derivatives using a variety of methods.
<br>
Provides Ports <br>
o Chemistry.QC.ModelFactory ModelFactory <br>
Uses Ports <br>
o Chemistry.QC.MoleculeFactory MoleculeFactory (required)
<br>
Parameters <br>
o theory The method for determining the electronic
structure. Defaults to HF.</p>

<p style="margin-top: 1em">o HF Hartree-Fock method. <br>
o B3LYP Density Functional Theory (DFT) with B3LYP
functional. <br>
o Use keyval input for other options. <br>
o basis The atomic orbital basis set. Defaults to
STO-3G.</p>

<p style="margin-top: 1em">o Any basis set defined in the
MPQC package. <br>
o Use keyval input for mixed basis sets. <br>
o molecule_filename Path to the molecule file (see
cca-chem-generic documentation for format). No default --
required. <br>
o keyval_filename Path to the keyval input file (see below).
No default -- optional. <br>
Keyval Input <br>
The theory and basis parameters allow very basic
calculations to be performed. More complex calculations will
require the use of a keyval input file. The keyval file
format is <br>
the same as that used to run MPQC stand-alone, and any valid
MPQC options may be used. The molecular energy object must
be named model. The user-supplied keyval cannot contain a
<br>
molecule section; the molecule section will be automatically
inserted by the ModelFactory using the required
molecule_filename. This molecule section should be referred
to as <br>
$:molecule. <br>
Example keyval input: <br>
model&lt;CLHF&gt;:( <br>
molecule=$:molecule <br>
basis&lt;GaussianBasisSet&gt;:( <br>
name = &rsquo;6-31G&rsquo; <br>
molecule = $:molecule <br>
) <br>
) <br>
MPQC.ChemistryOpt_CoordinateModel <br>
This is an implementation of the
ChemistryOpt.CoordinateModel interface based on the MPQC
package. It supports molecular structure optimization in
cartesian, symmetrized <br>
internal, and redundant internal coordinates. Hessian
approximation is supported. <br>
Provides Ports <br>
o ChemistryOpt.CoordinateModel CoordinateModel <br>
Uses Ports <br>
o Chemistry.QC.ModelFactory ModelFactory (required) <br>
o Chemistry.QC.ModelFactory BackupModelFactory (optional)
<br>
o Chemistry.MoleculeViewer MoleculeViewer (optional) <br>
A backup model factory may be supplied. If an error is
detected in the primary model, then a model obtained from
the backup factory will be used. The molecule viewer is
currently <br>
only used to communicate with the python viewer, in which
case component instantiation and connection is handled
automatically. <br>
Parameters <br>
o grad_rms RMS gradient convergence criteria. Defaults to
0.00030. <br>
o grad_max Max gradient convergence criteria. Defaults to
0.00045. <br>
o disp_rms RMS displacement convergence criteria. Defaults
to 0.00120. <br>
o disp_max Max displacement convergence criteria. Defaults
to 0.00180. <br>
o coordinate_type Optimization coordinate type. Defaults to
symmetrized.</p>

<p style="margin-top: 1em">o cartesian Cartesian
coordinates. <br>
o symmetrized Symmetrized internal coordinates. <br>
o redundant Redundant internal coordinates. <br>
o multiple_guess_h Compute new guess Hessian at each call to
guess_hessian_solve() (true) or use guess from first
iteration only (false). Only meaningful in conjunction with
<br>
solvers supporting use of dense guess Hessians with
limited-memory methods. Defaults to true. <br>
o use_current_geom If multiple_guess_h is true, either use
the current geometry (true) or the geometry at which the
earliest correction pair used by the solver was determined
<br>
(false) when computing the guess Hessian. Defaults to false.
<br>
MPQC.IntegralEvaluatorFactory <br>
This is an implementation of the
Chemistry.QC.GaussianBasis.IntegralEvaluatorFactory
interface. This factory produces molecular integral
evaluator objects based on the MPQC <br>
package. This code is experimental and does not currently
support derivative integrals. <br>
Provides Ports <br>
o Chemistry.QC.GaussianBasis.IntegralEvaluatorFactory
IntegralEvaluatorFactory <br>
Parameters <br>
o package Integral package, either intv3 or cints. Defaults
to intv3. <br>
o integral_buffer Integral buffer type, either opaque or
array. The opaque option uses pointers and is therefore
higher performance. The array option may be used by
components <br>
implemented in languages which are not pointer-aware. MPQC
License <br>
MPQC is open-source software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either <br>
version 2 of the License, or (at your option) any later
version. MPQC Warranty <br>
MPQC is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
<br>
the GNU General Public License for more details. Version
2.3.1 Mon May 15 2017 mpqc(1)</p>
<hr>
</body>
</html>
