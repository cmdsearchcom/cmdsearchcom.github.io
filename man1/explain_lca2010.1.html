<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>explain_lca2010(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">explain_lca2010(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">explain_lca2010(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
explain_lca2010 - No medium found: when it's time to stop trying to read
  <i>strerror</i>(3)'s mind.
<h1 class="Sh" title="Sh" id="MOTIVATION"><a class="selflink" href="#MOTIVATION">MOTIVATION</a></h1>
The idea for libexplain occurred to me back in the early 1980s. Whenever a
  system call returns an error, the kernel knows exactly what went wrong... and
  compresses this into less that 8 bits of <i>errno</i>. User space has access
  to the same data as the kernel, it should be possible for user space to figure
  out exactly what happened to provoke the error return, and use this to write
  good error messages.
<div class="Pp"></div>
Could it be that simple?
<h2 class="Ss" title="Ss" id="Error_messages_as_finesse"><a class="selflink" href="#Error_messages_as_finesse">Error
  messages as finesse</a></h2>
Good error messages are often those &#x201C;one percent&#x201D; tasks that get
  dropped when schedule pressure squeezes your project. However, a good error
  message can make a huge, disproportionate improvement to the user experience,
  when the user wanders into scarey unknown territory not usually encountered.
  This is no easy task.
<div class="Pp"></div>
As a larval programmer, the author didn't see the problem with (completely
  accurate) error messages like this one:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
floating exception (core dumped)
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
until the alternative non&#x2010;programmer interpretation was pointed out. But
  that isn't the only thing wrong with Unix error messages. How often do you see
  error messages like:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
$  <b>./stupid</b>
can't open file
$
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
There are two options for a developer at this point:
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">you can run a debugger, such as <i>gdb</i>(1), or</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">you can use <i>strace</i>(1) or <i>truss</i>(1) to look
      inside.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Remember that your users may not even have access to these
      tools, let alone the ability to use them. (It's a very long time since
      <i>Unix beginner</i> meant &#x201C;has only written <i>one</i> device
      driver&#x201D;.)</dd>
</dl>
<div class="Pp"></div>
In this example, however, using <i>strace</i>(1) reveals
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
$  <b>strace -e trace=open ./stupid</b>
open(&quot;some/file&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
can't open file
$
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
This is considerably more information than the error message provides.
  Typically, the stupid source code looks like this
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
int fd = open(&quot; <i>some/thing</i>&quot;, O_RDONLY);
if (fd &lt; 0)
{
    fprintf(stderr, &quot;can't open file\n&quot;);
    exit(1);
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The user isn't told <i>which</i> file, and also fails to tell the user
  <i>which</i> error. Was the file even there? Was there a permissions problem?
  It does tell you it was trying to open a file, but that was probably by
  accident.
<div class="Pp"></div>
Grab your clue stick and go beat the larval programmer with it. Tell him about
  <i>perror</i>(3). The next time you use the program you see a different error
  message:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
$  <b>./stupid</b>
open: No such file or directory
$
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
Progress, but not what we expected. How can the user fix the problem if the
  error message doesn't tell him what the problem was? Looking at the source, we
  see
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
int fd = open(&quot; <i>some/thing</i>&quot;, O_RDONLY);
if (fd &lt; 0)
{
    perror(&quot;open&quot;);
    exit(1);
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
Time for another run with the clue stick. This time, the error message takes one
  step forward and one step back:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
$  <b>./stupid</b>
<i>some/thing</i>: No such file or directory
$
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
Now we know the file it was trying to open, but are no longer informed that it
  was <i>open</i>(2) that failed. In this case it is probably not significant,
  but it can be significant for other system calls. It could have been
  <i>creat</i>(2) instead, an operation implying that different permissions are
  necessary.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
const char *filename = &quot; <i>some/thing</i>&quot;;
int fd = open(filename, O_RDONLY);
if (fd &lt; 0)
{
    perror(filename);
    exit(1);
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The above example code is unfortunately typical of non&#x2010;larval programmers
  as well. Time to tell our padawan learner about the <i>strerror</i>(3) system
  call.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
$  <b>./stupid</b>
open  <i>some/thing</i>: No such file or directory
$
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
This maximizes the information that can be presented to the user. The code looks
  like this:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
const char *filename = &quot; <i>some/thing</i>&quot;;
int fd = open(filename, O_RDONLY);
if (fd &lt; 0)
{
    fprintf(stderr, &quot;open %s: %s\n&quot;, filename, strerror(errno));
    exit(1);
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
Now we have the system call, the filename, and the error string. This contains
  all the information that <i>strace</i>(1) printed. That's as good as it gets.
<div class="Pp"></div>
Or is it?
<h2 class="Ss" title="Ss" id="Limitations_of_perror_and_strerror"><a class="selflink" href="#Limitations_of_perror_and_strerror">Limitations
  of perror and strerror</a></h2>
The problem the author saw, back in the 1980s, was that the error message is
  incomplete. Does &#x201C;no such file or directory&#x201D; refer to the
  &#x201C; <i>some</i>&#x201D; directory, or to the &#x201C;<i>thing</i>&#x201D;
  file in the &#x201C; <i>some</i>&#x201D; directory?
<div class="Pp"></div>
A quick look at the man page for <i>strerror</i>(3) is telling:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">strerror - return string describing error
  number</div>
<div style="height: 0.30em;">&#x00A0;</div>
Note well: it is describing the error <i>number</i>, not the error.
<div class="Pp"></div>
On the other hand, the kernel <i>knows</i> what the error was. There was a
  specific point in the kernel code, caused by a specific condition, where the
  kernel code branched and said &#x201C;no&#x201D;. Could a user&#x2010;space
  program figure out the specific condition and write a better error message?
<div class="Pp"></div>
However, the problem goes deeper. What if the problem occurs during the
  <i>read</i>(2) system call, rather than the <i>open</i>(2) call? It is simple
  for the error message associated with <i>open</i>(2) to include the file name,
  it's right there. But to be able to include a file name in the error
  associated with the <i>read</i>(2) system call, you have to pass the file name
  all the way down the call stack, as well as the file descriptor.
<div class="Pp"></div>
And here is the bit that grates: the kernel already knows what file name the
  file descriptor is associated with. Why should a programmer have to pass
  redundant data all the way down the call stack just to improve an error
  message that may never be issued? In reality, many programmers don't bother,
  and the resulting error messages are the worse for it.
<div class="Pp"></div>
But that was the 1980s, on a PDP11, with limited resources and no shared
  libraries. Back then, no flavor of Unix included /proc even in rudimentary
  form, and the <i>lsof</i>(1) program was over a decade away. So the idea was
  shelved as impractical.
<h2 class="Ss" title="Ss" id="Level_Infinity_Support"><a class="selflink" href="#Level_Infinity_Support">Level
  Infinity Support</a></h2>
Imagine that you are level infinity support. Your job description says that you
  never <i>ever</i> have to talk to users. Why, then, is there still a constant
  stream of people wanting you, the local Unix guru, to decipher yet another
  error message?
<div class="Pp"></div>
Strangely, 25 years later, despite a simple permissions system, implemented with
  complete consistency, most Unix users still have no idea how to decode
  &#x201C;No such file or directory&#x201D;, or any of the other cryptic error
  messages they see every day. Or, at least, cryptic to them.
<div class="Pp"></div>
Wouldn't it be nice if first level tech support didn't need error messages
  deciphered? Wouldn't it be nice to have error messages that users could
  understand without calling tech support?
<div class="Pp"></div>
These days /proc on Linux is more than able to provide the information necessary
  to decode the vast majority of error messages, and point the user to the
  proximate cause of their problem. On systems with a limited /proc
  implementation, the <i>lsof</i>(1) command can fill in many of the gaps.
<div class="Pp"></div>
In 2008, the stream of translation requests happened to the author way too
  often. It was time to re&#x2010;examine that 25 year old idea, and libexplain
  is the result.
<h1 class="Sh" title="Sh" id="USING_THE_LIBRARY"><a class="selflink" href="#USING_THE_LIBRARY">USING
  THE LIBRARY</a></h1>
The interface to the library tries to be consistent, where possible. Let's start
  with an example using <i>strerror</i>(3):
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
if (rename(old_path, new_path) &lt; 0)
{
    fprintf(stderr, &quot;rename %s %s: %s\n&quot;, old_path, new_path,
        strerror(errno));
    exit(1);
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The idea behind libexplain is to provide a <i>strerror</i>(3) equivalent for
  <b>each</b> system call, tailored specifically to that system call, so that it
  can provide a more detailed error message, containing much of the information
  you see under the &#x201C;ERRORS&#x201D; heading of section 2 and 3 <i>man</i>
  pages, supplemented with information about actual conditions, actual argument
  values, and system limits.
<h2 class="Ss" title="Ss" id="The_Simple_Case"><a class="selflink" href="#The_Simple_Case">The
  Simple Case</a></h2>
The <i>strerror</i>(3) replacement:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
if (rename(old_path, new_path) &lt; 0)
{
    fprintf(stderr, &quot;%s\n&quot;, explain_rename(old_path, new_path));
    exit(1);
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="The_Errno_Case"><a class="selflink" href="#The_Errno_Case">The
  Errno Case</a></h2>
It is also possible to pass an explicit <i>errno</i>(3) value, if you must first
  do some processing that would disturb <i>errno</i>, such as error recovery:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
if (rename(old_path, new_path &lt; 0))
{
    int old_errno = errno;
    ... <i>code that disturbs errno</i>...
    fprintf(stderr, &quot;%s\n&quot;, explain_errno_rename(old_errno,
        old_path, new_path));
    exit(1);
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="The_Multi&#x2010;thread_Cases"><a class="selflink" href="#The_Multi&#x2010;thread_Cases">The
  Multi&#x2010;thread Cases</a></h2>
Some applications are multi&#x2010;threaded, and thus are unable to share
  libexplain's internal buffer. You can supply your own buffer using
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
if (unlink(pathname))
{
    char message[3000];
    explain_message_unlink(message, sizeof(message), pathname);
    error_dialog(message);
    return -1;
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
And for completeness, both <i>errno</i>(3) and thread&#x2010;safe:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
ssize_t nbytes = read(fd, data, sizeof(data));
if (nbytes &lt; 0)
{
    char message[3000];
    int old_errno = errno;
    ... <i>error recovery</i>...
    explain_message_errno_read(message, sizeof(message),
        old_errno, fd, data, sizeof(data));
    error_dialog(message);
    return -1;
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<div class="Pp"></div>
These are replacements for <i>strerror_r</i>(3), on systems that have it.
<h2 class="Ss" title="Ss" id="Interface_Sugar"><a class="selflink" href="#Interface_Sugar">Interface
  Sugar</a></h2>
A set of functions added as convenience functions, to woo programmers to use the
  libexplain library, turn out to be the author's most commonly used libexplain
  functions in command line programs:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
int fd = explain_creat_or_die(filename, 0666);
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
This function attempts to create a new file. If it can't, it prints an error
  message and exits with EXIT_FAILURE. If there is no error, it returns the new
  file descriptor.
<div class="Pp"></div>
A related function:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
int fd = explain_creat_on_error(filename, 0666);
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
will print the error message on failure, but also returns the original error
  result, and <i>errno</i>(3) is unmolested, as well.
<h2 class="Ss" title="Ss" id="All_the_other_system_calls"><a class="selflink" href="#All_the_other_system_calls">All
  the other system calls</a></h2>
In general, every system call has its own include file
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
#include &lt;libexplain/ <i>name</i>.h&gt;
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
that defines function prototypes for six functions:
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">explain_<i>name</i>,</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">explain_errno_<i>name</i>,</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">explain_message_<i>name</i>,</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">explain_message_errno_<i>name</i>,</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">explain_<i>name</i>_or_die and</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">explain_<i>name</i>_on_error.</dd>
</dl>
<div class="Pp"></div>
Every function prototype has Doxygen documentation, and this documentation <i>is
  not</i> stripped when the include files are installed.
<div class="Pp"></div>
The <i>wait</i>(2) system call (and friends) have some extra variants that also
  interpret failure to be an exit status that isn't EXIT_SUCCESS. This applies
  to <i>system</i>(3) and <i>pclose</i>(3) as well.
<div class="Pp"></div>
Coverage includes 221 system calls and 547 ioctl requests. There are many more
  system calls yet to implement. System calls that never return, such as
  <i>exit</i>(2), are not present in the library, and will never be. The
  <i>exec</i> family of system calls <i>are</i> supported, because they return
  when there is an error.
<h2 class="Ss" title="Ss" id="Cat"><a class="selflink" href="#Cat">Cat</a></h2>
This is what a hypothetical &#x201C;cat&#x201D; program could look like, with
  full error reporting, using libexplain.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
#include &lt;libexplain/libexplain.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
There is one include for libexplain, plus the usual suspects. (If you wish to
  reduce the preprocessor load, you can use the specific &lt;libexplain/
  <i>name</i>.h&gt; includes.)
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
static void
process(FILE *fp)
{
    for (;;)
    {
        char buffer[4096];
        size_t n = explain_fread_or_die(buffer, 1, sizeof(buffer), fp);
        if (!n)
            break;
        explain_fwrite_or_die(buffer, 1, n, stdout);
    }
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The <i>process</i> function copies a file stream to the standard output. Should
  an error occur for either reading or writing, it is reported (and the pathname
  will be included in the error) and the command exits with EXIT_FAILURE. We
  don't even worry about tracking the pathnames, or passing them down the call
  stack.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
int
main(int argc, char **argv)
{
    for (;;)
    {
        int c = getopt(argc, argv, &quot;o:&quot;);
        if (c == EOF)
            break;
        switch (c)
        {
        case 'o':
            explain_freopen_or_die(optarg, &quot;w&quot;, stdout);
            break;
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The fun part of this code is that libexplain can report errors <i>including the
  pathname</i> even if you <b>don't</b> explicitly re&#x2010;open stdout as is
  done here. We don't even worry about tracking the file name.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
        default:
            fprintf(stderr, &quot;Usage: %ss [ -o &lt;filename&gt; ] &lt;filename&gt;...\n&quot;,
                argv[0]);
            return EXIT_FAILURE;
        }
    }
    if (optind == argc)
        process(stdin);
    else
    {
        while (optind &lt; argc)
        {
            FILE *fp = explain_fopen_or_die(argv[optind]++, &quot;r&quot;);
            process(fp);
            explain_fclose_or_die(fp);
        }
    }
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The standard output will be closed implicitly, but too late for an error report
  to be issued, so we do that here, just in case the buffered I/O hasn't written
  anything yet, and there is an ENOSPC error or something.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
    explain_fflush_or_die(stdout);
    return EXIT_SUCCESS;
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
That's all. Full error reporting, clear code.
<h2 class="Ss" title="Ss" id="Rusty's_Scale_of_Interface_Goodness"><a class="selflink" href="#Rusty's_Scale_of_Interface_Goodness">Rusty's
  Scale of Interface Goodness</a></h2>
For those of you not familiar with it, Rusty Russel's &#x201C;How Do I Make This
  Hard to Misuse?&#x201D; page is a must&#x2010;read for API designers.
<div>&#x00A0;</div>
http://ozlabs.org/~rusty/index.cgi/tech/2008&#x2010;03&#x2010;30.html
<div class="Pp"></div>
<i>10. It's impossible to get wrong.</i>
<div class="Pp"></div>
Goals need to be set high, ambitiously high, lest you accomplish them and think
  you are finished when you are not.
<div class="Pp"></div>
The libexplain library detects bogus pointers and many other bogus system call
  parameters, and generally tries to avoid segfaults in even the most trying
  circumstances.
<div class="Pp"></div>
The libexplain library is designed to be thread safe. More real&#x2010;world use
  will likely reveal places this can be improved.
<div class="Pp"></div>
The biggest problem is with the actual function names themselves. Because C does
  not have name&#x2010;spaces, the libexplain library always uses an explain_
  name prefix. This is the traditional way of creating a
  pseudo&#x2010;name&#x2010;space in order to avoid symbol conflicts. However,
  it results in some unnatural&#x2010;sounding names.
<div class="Pp"></div>
<i>9. The compiler or linker won't let you get it wrong.</i>
<div class="Pp"></div>
A common mistake is to use explain_open where explain_open_or_die was intended.
  Fortunately, the compiler will often issue a type error at this point (
  <i>e.g.</i> can't assign const char * rvalue to an int lvalue).
<div class="Pp"></div>
<i>8. The compiler will warn if you get it wrong.</i>
<div class="Pp"></div>
If explain_rename is used when explain_rename_or_die was intended, this can
  cause other problems. GCC has a useful warn_unused_result function attribute,
  and the libexplain library attaches it to all the explain_ <i>name</i>
  function calls to produce a warning when you make this mistake. Combine this
  with <i>gcc -Werror</i> to promote this to level 9 goodness.
<div class="Pp"></div>
<i>7. The obvious use is (probably) the correct one.</i>
<div class="Pp"></div>
The function names have been chosen to convey their meaning, but this is not
  always successful. While explain_ <i>name</i>_or_die and explain_
  <i>name</i>_on_error are fairly descriptive, the less&#x2010;used thread safe
  variants are harder to decode. The function prototypes help the compiler
  towards understanding, and the Doxygen comments in the header files help the
  user towards understanding.
<div class="Pp"></div>
<i>6. The name tells you how to use it.</i>
<div class="Pp"></div>
It is particularly important to read explain_ <i>name</i>_or_die as
  &#x201C;explain ( <i>name</i> or die)&#x201D;. Using a consistent explain_
  name&#x2010;space prefix has some unfortunate side&#x2010;effects in the
  obviousness department, as well.
<div class="Pp"></div>
The order of words in the names also indicate the order of the arguments. The
  argument lists always <i>end</i> with the same arguments as passed to the
  system call; <i>all of them</i>. If _errno_ appears in the name, its argument
  always precedes the system call arguments. If _message_ appears in the name,
  its two arguments always come first.
<div class="Pp"></div>
<i>5. Do it right or it will break at runtime.</i>
<div class="Pp"></div>
The libexplain library detects bogus pointers and many other bogus system call
  parameters, and generally tries to avoid segfaults in even the most trying
  circumstances. It should never break at runtime, but more real&#x2010;world
  use will no doubt improve this.
<div class="Pp"></div>
Some error messages are aimed at developers and maintainers rather than end
  users, as this can assist with bug resolution. Not so much &#x201C;break at
  runtime&#x201D; as &#x201C;be informative at runtime&#x201D; (after the system
  call barfs).
<div class="Pp"></div>
<i>4. Follow common convention and you'll get it right.</i>
<div class="Pp"></div>
Because C does not have name&#x2010;spaces, the libexplain library always uses
  an explain_ name prefix. This is the traditional way of creating a
  pseudo&#x2010;name&#x2010;space in order to avoid symbol conflicts.
<div class="Pp"></div>
The trailing arguments of all the libexplain call are identical to the system
  call they are describing. This is intended to provide a consistent convention
  in common with the system calls themselves.
<div class="Pp"></div>
<i>3. Read the documentation and you'll get it right.</i>
<div class="Pp"></div>
The libexplain library aims to have complete Doxygen documentation for each and
  every public API call (and internally as well).
<h1 class="Sh" title="Sh" id="MESSAGE_CONTENT"><a class="selflink" href="#MESSAGE_CONTENT">MESSAGE
  CONTENT</a></h1>
Working on libexplain is a bit like looking at the underside of your car when it
  is up on the hoist at the mechanic's. There's some ugly stuff under there,
  plus mud and crud, and users rarely see it. A good error message needs to be
  informative, even for a user who has been fortunate enough not to have to look
  at the under&#x2010;side very often, and also informative for the mechanic
  listening to the user's description over the phone. This is no easy task.
<div class="Pp"></div>
Revisiting our first example, the code would like this if it uses libexplain:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
int fd = explain_open_or_die(&quot;some/thing&quot;, O_RDONLY, 0);
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
will fail with an error message like this
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;some/file&quot;, flags = O_RDONLY) failed, No such file or
  directory (2, ENOENT) because there is no &quot;some&quot; directory in the
  current directory
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
This breaks down into three pieces
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
<i>system&#x2010;call</i> failed, <i>system&#x2010;error</i> because
<i>explanation</i>
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="Before_Because"><a class="selflink" href="#Before_Because">Before
  Because</a></h2>
It is possible to see the part of the message before &#x201C;because&#x201D; as
  overly technical to non&#x2010;technical users, mostly as a result of
  accurately printing the system call itself at the beginning of the error
  message. And it looks like <i>strace</i>(1) output, for bonus geek points.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;some/file&quot;, flags = O_RDONLY) failed, No such file or
  directory (2, ENOENT)
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
This part of the error message is essential to the developer when he is writing
  the code, and equally important to the maintainer who has to read bug reports
  and fix bugs in the code. It says exactly what failed.
<div class="Pp"></div>
If this text is not presented to the user then the user cannot
  copy&#x2010;and&#x2010;paste it into a bug report, and if it isn't in the bug
  report the maintainer can't know what actually went wrong.
<div class="Pp"></div>
Frequently tech staff will use <i>strace</i>(1) or <i>truss</i>(1) to get this
  exact information, but this avenue is not open when reading bug reports. The
  bug reporter's system is far far away, and, by now, in a far different state.
  Thus, this information needs to be in the bug report, which means it must be
  in the error message.
<div class="Pp"></div>
The system call representation also gives context to the rest of the message. If
  need arises, the offending system call argument may be referred to by name in
  the explanation after &#x201C;because&#x201D;. In addition, all strings are
  fully quoted and escaped C strings, so embedded newlines and
  non&#x2010;printing characters will not cause the user's terminal to go
  haywire.
<div class="Pp"></div>
The <i>system&#x2010;error</i> is what comes out of <i>strerror</i>(2), plus the
  error symbol. Impatient and expert sysadmins could stop reading at this point,
  but the author's experience to date is that reading further is rewarding. (If
  it isn't rewarding, it's probably an area of libexplain that can be improved.
  Code contributions are welcome, of course.)
<h2 class="Ss" title="Ss" id="After_Because"><a class="selflink" href="#After_Because">After
  Because</a></h2>
This is the portion of the error message aimed at non&#x2010;technical users. It
  looks beyond the simple system call arguments, and looks for something more
  specific.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
there is no &quot;some&quot; directory in the current directory
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
This portion attempts to explain the proximal cause of the error in plain
  language, and it is here that internationalization is essential.
<div class="Pp"></div>
In general, the policy is to include as much information as possible, so that
  the user doesn't need to go looking for it (and doesn't leave it out of the
  bug report).
<h2 class="Ss" title="Ss" id="Internationalization"><a class="selflink" href="#Internationalization">Internationalization</a></h2>
Most of the error messages in the libexplain library have been
  internationalized. There are no localizations as yet, so if you want the
  explanations in your native language, please contribute.
<div class="Pp"></div>
The &#x201C;most of&#x201D; qualifier, above, relates to the fact that the
  proof&#x2010;of&#x2010;concept implementation did not include
  internationalization support. The code base is being revised progressively,
  usually as a result of refactoring messages so that each error message string
  appears in the code exactly once.
<div class="Pp"></div>
Provision has been made for languages that need to assemble the portions of
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
<i>system&#x2010;call</i> failed, <i>system&#x2010;error</i> because <i>explanation</i>
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
in different orders for correct grammar in localized error messages.
<h2 class="Ss" title="Ss" id="Postmortem"><a class="selflink" href="#Postmortem">Postmortem</a></h2>
There are times when a program has yet to use libexplain, and you can't use
  <i>strace</i>(1) either. There is an <i>explain</i>(1) command included with
  libexplain that can be used to decipher error messages, if the state of the
  underlying system hasn't changed too much.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
$  <b>explain rename foo /tmp/bar/baz -e ENOENT</b>
</pre>
rename(oldpath = &quot;foo&quot;, newpath = &quot;/tmp/bar/baz&quot;) failed, No
  such file or directory (2, ENOENT) because there is no &quot;bar&quot;
  directory in the newpath &quot;/tmp&quot; directory
<pre>
$
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
Note how the path ambiguity is resolved by using the system call argument name.
  Of course, you have to know the error and the system call for
  <i>explain</i>(1) to be useful. As an aside, this is one of the ways used by
  the libexplain automatic test suite to verify that libexplain is working.
<h2 class="Ss" title="Ss" id="Philosophy"><a class="selflink" href="#Philosophy">Philosophy</a></h2>
&#x201C;Tell me everything, including stuff I didn't know to look for.&#x201D;
<div class="Pp"></div>
The library is implemented in such a way that when statically linked, only the
  code you actually use will be linked. This is achieved by having one function
  per source file, whenever feasible.
<div class="Pp"></div>
When it is possible to supply more information, libexplain will do so. The less
  the user has to track down for themselves, the better. This means that UIDs
  are accompanied by the user name, GIDs are accompanied by the group name, PIDs
  are accompanied by the process name, file descriptors and streams are
  accompanied by the pathname, <i>etc</i>.
<div class="Pp"></div>
When resolving paths, if a path component does not exist, libexplain will look
  for similar names, in order to suggest alternatives for typographical errors.
<div class="Pp"></div>
The libexplain library tries to use as little heap as possible, and usually
  none. This is to avoid perturbing the process state, as far as possible,
  although sometimes it is unavoidable.
<div class="Pp"></div>
The libexplain library attempts to be thread safe, by avoiding global variables,
  keeping state on the stack as much as possible. There is a single common
  message buffer, and the functions that use it are documented as not being
  thread safe.
<div class="Pp"></div>
The libexplain library does not disturb a process's signal handlers. This makes
  determining whether a pointer would segfault a challenge, but not impossible.
<div class="Pp"></div>
When information is available via a system call as well as available through a
  /proc entry, the system call is preferred. This is to avoid disturbing the
  process's state. There are also times when no file descriptors are available.
<div class="Pp"></div>
The libexplain library is compiled with large file support. There is no
  large/small schizophrenia. Where this affects the argument types in the API,
  and error will be issued if the necessary large file defines are absent.
<div class="Pp"></div>
FIXME: Work is needed to make sure that file system quotas are handled in the
  code. This applies to some <i>getrlimit</i>(2) boundaries, as well.
<div class="Pp"></div>
There are cases when relatives paths are uninformative. For example: system
  daemons, servers and background processes. In these cases, absolute paths are
  used in the error explanations.
<h1 class="Sh" title="Sh" id="PATH_RESOLUTION"><a class="selflink" href="#PATH_RESOLUTION">PATH
  RESOLUTION</a></h1>
Short version: see <i>path_resolution</i>(7).
<div class="Pp"></div>
Long version: Most users have never heard of <i>path_resolution</i>(7), and many
  advanced users have never read it. Here is an annotated version:
<h2 class="Ss" title="Ss" id="Step_1:_Start_of_the_resolution_process"><a class="selflink" href="#Step_1:_Start_of_the_resolution_process">Step
  1: Start of the resolution process</a></h2>
If the pathname starts with the slash (&#x201C;/&#x201D;) character, the
  starting lookup directory is the root directory of the calling process.
<div class="Pp"></div>
If the pathname does not start with the slash(&#x201C;/&#x201D;) character, the
  starting lookup directory of the resolution process is the current working
  directory of the process.
<h2 class="Ss" title="Ss" id="Step_2:_Walk_along_the_path"><a class="selflink" href="#Step_2:_Walk_along_the_path">Step
  2: Walk along the path</a></h2>
Set the current lookup directory to the starting lookup directory. Now, for each
  non&#x2010;final component of the pathname, where a component is a substring
  delimited by slash (&#x201C;/&#x201D;) characters, this component is looked up
  in the current lookup directory.
<div class="Pp"></div>
If the process does not have search permission on the current lookup directory,
  an EACCES error is returned (&quot;Permission denied&quot;).
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;/home/archives/.ssh/private_key&quot;, flags = O_RDONLY)
  failed, Permission denied (13, EACCES) because the process does not have
  search permission to the pathname &quot;/home/archives/.ssh&quot; directory,
  the process effective GID 1000 &quot;pmiller&quot; does not match the
  directory owner 1001 &quot;archives&quot; so the owner permission mode
  &quot;rwx&quot; is ignored, the others permission mode is &quot;---&quot;, and
  the process is not privileged (does not have the DAC_READ_SEARCH capability)
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<div class="Pp"></div>
If the component is not found, an ENOENT error is returned (&quot;No such file
  or directory&quot;).
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
unlink(pathname = &quot;/home/microsoft/rubbish&quot;) failed, No such file or
  directory (2, ENOENT) because there is no &quot;microsoft&quot; directory in
  the pathname &quot;/home&quot; directory
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<div class="Pp"></div>
There is also some support for users when they mis&#x2010;type pathnames, making
  suggestions when ENOENT is returned:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;/user/include/fcntl.h&quot;, flags = O_RDONLY) failed, No
  such file or directory (2, ENOENT) because there is no &quot;user&quot;
  directory in the pathname &quot;/&quot; directory, did you mean the
  &quot;usr&quot; directory instead?
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<div class="Pp"></div>
If the component is found, but is neither a directory nor a symbolic link, an
  ENOTDIR error is returned (&quot;Not a directory&quot;).
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;/home/pmiller/.netrc/lca&quot;, flags = O_RDONLY) failed,
  Not a directory (20, ENOTDIR) because the &quot;.netrc&quot; regular file in
  the pathname &quot;/home/pmiller&quot; directory is being used as a directory
  when it is not
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<div class="Pp"></div>
If the component is found and is a directory, we set the current lookup
  directory to that directory, and go to the next component.
<div class="Pp"></div>
If the component is found and is a symbolic link (symlink), we first resolve
  this symbolic link (with the current lookup directory as starting lookup
  directory). Upon error, that error is returned. If the result is not a
  directory, an ENOTDIR error is returned.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
unlink(pathname = &quot;/tmp/dangling/rubbish&quot;) failed, No such file or
  directory (2, ENOENT) because the &quot;dangling&quot; symbolic link in the
  pathname &quot;/tmp&quot; directory refers to &quot;nowhere&quot; that does
  not exist
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
If the resolution of the symlink is successful and returns a directory, we set
  the current lookup directory to that directory, and go to the next component.
  Note that the resolution process here involves recursion. In order to protect
  the kernel against stack overflow, and also to protect against denial of
  service, there are limits on the maximum recursion depth, and on the maximum
  number of symbolic links followed. An ELOOP error is returned when the maximum
  is exceeded (&quot;Too many levels of symbolic links&quot;).
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;/tmp/dangling&quot;, flags = O_RDONLY) failed, Too many
  levels of symbolic links (40, ELOOP) because a symbolic link loop was
  encountered in pathname, starting at &quot;/tmp/dangling&quot;
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
It is also possible to get an ELOOP or EMLINK error if there are too many
  symlinks, but no loop was detected.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;/tmp/rabbit&#x2010;hole&quot;, flags = O_RDONLY) failed,
  Too many levels of symbolic links (40, ELOOP) because too many symbolic links
  were encountered in pathname (8)
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
Notice how the actual limit is also printed.
<h2 class="Ss" title="Ss" id="Step_3:_Find_the_final_entry"><a class="selflink" href="#Step_3:_Find_the_final_entry">Step
  3: Find the final entry</a></h2>
The lookup of the final component of the pathname goes just like that of all
  other components, as described in the previous step, with two differences:
<dl class="Bl-tag">
  <dt class="It-tag">(i)</dt>
  <dd class="It-tag">The final component need not be a directory (at least as
      far as the path resolution process is concerned. It may have to be a
      directory, or a non&#x2010;directory, because of the requirements of the
      specific system call).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">(ii)</dt>
  <dd class="It-tag">It is not necessarily an error if the final component is
      not found; maybe we are just creating it. The details on the treatment of
      the final entry are described in the manual pages of the specific system
      calls.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">(iii)</dt>
  <dd class="It-tag">It is also possible to have a problem with the last
      component if it is a symbolic link and it should not be followed. For
      example, using the <i>open</i>(2) O_NOFOLLOW flag:
    <div style="height: 0.30em;">&#x00A0;</div>
  </dd>
</dl>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;a&#x2010;symlink&quot;, flags = O_RDONLY | O_NOFOLLOW)
  failed, Too many levels of symbolic links (ELOOP) because O_NOFOLLOW was
  specified but pathname refers to a symbolic link
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag">(iv)</dt>
  <dd class="It-tag">It is common for users to make mistakes when typing
      pathnames. The libexplain library attempts to make suggestions when ENOENT
      is returned, for example:
    <div style="height: 0.30em;">&#x00A0;</div>
  </dd>
</dl>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;/usr/include/filecontrl.h&quot;, flags = O_RDONLY) failed,
  No such file or directory (2, ENOENT) because there is no
  &quot;filecontrl.h&quot; regular file in the pathname &quot;/usr/include&quot;
  directory, did you mean the &quot;fcntl.h&quot; regular file instead?
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag">(v)</dt>
  <dd class="It-tag">It is also possible that the final component is required to
      be something other than a regular file:
    <div style="height: 0.30em;">&#x00A0;</div>
  </dd>
</dl>
<div style="margin-left: 5.00ex;">
<br/>
readlink(pathname = &quot;just&#x2010;a&#x2010;file&quot;, data = 0x7F930A50,
  data_size = 4097) failed, Invalid argument (22, EINVAL) because pathname is a
  regular file, not a symbolic link
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag">(vi)</dt>
  <dd class="It-tag">FIXME: handling of the &quot;t&quot; bit.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Limits"><a class="selflink" href="#Limits">Limits</a></h2>
There are a number of limits with regards to pathnames and filenames.
<dl class="Bl-tag">
  <dt class="It-tag">Pathname length limit</dt>
  <dd class="It-tag">There is a maximum length for pathnames. If the pathname
      (or some intermediate pathname obtained while resolving symbolic links) is
      too long, an ENAMETOOLONG error is returned (&quot;File name too
      long&quot;). Notice how the system limit is included in the error message.
    <div style="height: 0.30em;">&#x00A0;</div>
  </dd>
</dl>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot; <i>very...long</i>&quot;, flags = O_RDONLY) failed, File
  name too long (36, ENAMETOOLONG) because pathname exceeds the system maximum
  path length (4096)
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag">Filename length limit</dt>
  <dd class="It-tag">Some Unix variants have a limit on the number of bytes in
      each path component. Some of them deal with this silently, and some give
      ENAMETOOLONG; the libexplain library uses <i>pathconf</i>(3) _PC_NO_TRUNC
      to tell which. If this error happens, the libexplain library will state
      the limit in the error message, the limit is obtained from
      <i>pathconf</i>(3) _PC_NAME_MAX. Notice how the system limit is included
      in the error message.
    <div style="height: 0.30em;">&#x00A0;</div>
  </dd>
</dl>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot; <i>system7/only-had-14-characters</i>&quot;, flags =
  O_RDONLY) failed, File name too long (36, ENAMETOOLONG) because
  &quot;only-had-14-characters&quot; component is longer than the system limit
  (14)
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<dl class="Bl-tag">
  <dt class="It-tag">Empty pathname</dt>
  <dd class="It-tag">In the original Unix, the empty pathname referred to the
      current directory. Nowadays POSIX decrees that an empty pathname must not
      be resolved successfully.
    <div style="height: 0.30em;">&#x00A0;</div>
  </dd>
</dl>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;&quot;, flags = O_RDONLY) failed, No such file or
  directory (2, ENOENT) because POSIX decrees that an empty pathname must not be
  resolved successfully
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<h2 class="Ss" title="Ss" id="Permissions"><a class="selflink" href="#Permissions">Permissions</a></h2>
The permission bits of a file consist of three groups of three bits. The first
  group of three is used when the effective user ID of the calling process
  equals the owner ID of the file. The second group of three is used when the
  group ID of the file either equals the effective group ID of the calling
  process, or is one of the supplementary group IDs of the calling process. When
  neither holds, the third group is used.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;/etc/passwd&quot;, flags = O_WRONLY) failed, Permission
  denied (13, EACCES) because the process does not have write permission to the
  &quot;passwd&quot; regular file in the pathname &quot;/etc&quot; directory,
  the process effective UID 1000 &quot;pmiller&quot; does not match the regular
  file owner 0 &quot;root&quot; so the owner permission mode &quot;rw-&quot; is
  ignored, the others permission mode is &quot;r--&quot;, and the process is not
  privileged (does not have the DAC_OVERRIDE capability)
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
Some considerable space is given to this explanation, as most users do not know
  that this is how the permissions system works. In particular: the owner, group
  and other permissions are exclusive, they are not &#x201C;OR&#x201D;ed
  together.
<h1 class="Sh" title="Sh" id="STRANGE_AND_INTERESTING_SYSTEM_CALLS"><a class="selflink" href="#STRANGE_AND_INTERESTING_SYSTEM_CALLS">STRANGE
  AND INTERESTING SYSTEM CALLS</a></h1>
The process of writing a specific error handler for each system call often
  reveals interesting quirks and boundary conditions, or obscure <i>errno</i>(3)
  values.
<h2 class="Ss" title="Ss" id="ENOMEDIUM,_No_medium_found"><a class="selflink" href="#ENOMEDIUM,_No_medium_found">ENOMEDIUM,
  No medium found</a></h2>
The act of copying a CD was the source of the title for this paper.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
$  <b>dd if=/dev/cdrom of=fubar.iso</b>
dd: opening &#x201C;/dev/cdrom&#x201D;: No medium found
$
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The author wondered why his computer was telling him there is no such thing as a
  psychic medium. Quite apart from the fact that huge numbers of native English
  speakers are not even aware that &#x201C;media&#x201D; is a plural, let alone
  that &#x201C;medium&#x201D; is its singular, the string returned by
  <i>strerror</i>(3) for ENOMEDIUM is so terse as to be almost completely free
  of content.
<div class="Pp"></div>
When <i>open</i>(2) returns ENOMEDIUM it would be nice if the libexplain library
  could expand a little on this, based on the type of drive it is. For example:
<br/>
... because there is no disk in the floppy drive
<div>&#x00A0;</div>
... because there is no disc in the CD&#x2010;ROM drive
<div>&#x00A0;</div>
... because there is no tape in the tape drive
<div>&#x00A0;</div>
... because there is no memory stick in the card reader
<div class="Pp"></div>
And so it came to pass...
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;/dev/cdrom&quot;, flags = O_RDONLY) failed, No medium
  found (123, ENOMEDIUM) because there does not appear to be a disc in the
  CD&#x2010;ROM drive
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The trick, that the author was previously unaware of, was to open the device
  using the O_NONBLOCK flag, which will allow you to open a drive with no medium
  in it. You then issue device specific <i>ioctl</i>(2) requests until you
  figure out what the heck it is. (Not sure if this is POSIX, but it also seems
  to work that way in BSD and Solaris, according to the <i>wodim</i>(1)
  sources.)
<div class="Pp"></div>
Note also the differing uses of &#x201C;disk&#x201D; and &#x201C;disc&#x201D; in
  context. The CD standard originated in France, but everything else has a
  &#x201C;k&#x201D;.
<h2 class="Ss" title="Ss" id="EFAULT,_Bad_address"><a class="selflink" href="#EFAULT,_Bad_address">EFAULT,
  Bad address</a></h2>
Any system call that takes a pointer argument can return EFAULT. The libexplain
  library can figure out which argument is at fault, and it does it without
  disturbing the process (or thread) signal handling.
<div class="Pp"></div>
When available, the <i>mincore</i>(2) system call is used, to ask if the memory
  region is valid. It can return three results: mapped but not in physical
  memory, mapped and in physical memory, and not mapped. When testing the
  validity of a pointer, the first two are &#x201C;yes&#x201D; and the last one
  is &#x201C;no&#x201D;.
<div class="Pp"></div>
Checking C strings are more difficult, because instead of a pointer and a size,
  we only have a pointer. To determine the size we would have to find the NUL,
  and that could segfault, catch&#x2010;22.
<div class="Pp"></div>
To work around this, the libexplain library uses the <i>lstat</i>(2) sysem call
  (with a known good second argument) to test C strings for validity. A failure
  return &amp;&amp; errno == EFAULT is a &#x201C;no&#x201D;, and anythng else is
  a &#x201C;yes&#x201D;. This, of course limits strings to PATH_MAX characters,
  but that usually isn't a problem for the libexplain library, because that is
  almost always the longest strings it cares about.
<h2 class="Ss" title="Ss" id="EMFILE,_Too_many_open_files"><a class="selflink" href="#EMFILE,_Too_many_open_files">EMFILE,
  Too many open files</a></h2>
This error occurs when a process already has the maximum number of file
  descriptors open. If the actual limit is to be printed, and the libexplain
  library tries to, you can't open a file in /proc to read what it is.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
open_max = sysconf(_SC_OPEN_MAX);
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
This one wan't so difficult, there is a <i>sysconf</i>(3) way of obtaining the
  limit.
<h2 class="Ss" title="Ss" id="ENFILE,_Too_many_open_files_in_system"><a class="selflink" href="#ENFILE,_Too_many_open_files_in_system">ENFILE,
  Too many open files in system</a></h2>
This error occurs when the system limit on the total number of open files has
  been reached. In this case there is no handy <i>sysconf</i>(3) way of obtain
  the limit.
<div class="Pp"></div>
Digging deeper, one may discover that on Linux there is a /proc entry we could
  read to obtain this value. Catch&#x2010;22: we are out of file descriptors, so
  we can't open a file to read the limit.
<div class="Pp"></div>
On Linux there is a system call to obtain it, but it has no [e]glibc wrapper
  function, so you have to all it very carefully:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
long
explain_maxfile(void)
{
#ifdef __linux__
    struct __sysctl_args args;
    int32_t maxfile;
    size_t maxfile_size = sizeof(maxfile);
    int name[] = { CTL_FS, FS_MAXFILE };
    memset(&amp;args, 0, sizeof(struct __sysctl_args));
    args.name = name;
    args.nlen = 2;
    args.oldval = &amp;maxfile;
    args.oldlenp = &amp;maxfile_size;
    if (syscall(SYS__sysctl, &amp;args) &gt;= 0)
        return maxfile;
#endif
    return -1;
}
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
This permits the limit to be included in the error message, when available.
<h2 class="Ss" title="Ss" id="EINVAL_&#x201C;Invalid_argument&#x201D;_vs_ENOSYS_&#x201C;Function_not_implemented&#x201D;"><a class="selflink" href="#EINVAL_&#x201C;Invalid_argument&#x201D;_vs_ENOSYS_&#x201C;Function_not_implemented&#x201D;">EINVAL
  &#x201C;Invalid argument&#x201D; <i>vs</i> ENOSYS &#x201C;Function not
  implemented&#x201D;</a></h2>
Unsupported actions (such as <i>symlink</i>(2) on a FAT file system) are not
  reported consistently from one system call to the next. It is possible to have
  either EINVAL or ENOSYS returned.
<div class="Pp"></div>
As a result, attention must be paid to these error cases to get them right,
  particularly as the EINVAL could also be referring to problems with one or
  more system call arguments.
<h2 class="Ss" title="Ss" id="Note_that_errno(3)_is_not_always_set"><a class="selflink" href="#Note_that_errno(3)_is_not_always_set">Note
  that <b><i>errno</i></b>(3) is not always set</a></h2>
There are times when it is necessary to read the [e]glibc sources to determine
  how and when errors are returned for some system calls.
<dl class="Bl-tag">
  <dt class="It-tag"><i>feof</i>(3), <i>fileno</i>(3)</dt>
  <dd class="It-tag">It is often assumed that these functions cannot return an
      error. This is only true if the <i>stream</i> argument is valid, however
      they are capable of detecting an invalid pointer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>fpathconf</i>(3), <i>pathconf</i>(3)</dt>
  <dd class="It-tag">The return value of <i>fpathconf</i>(2) and
      <i>pathconf</i>(2) could legitimately be -1, so it is necessary to see if
      <i>errno</i>(3) has been explicitly set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ioctl</i>(2)</dt>
  <dd class="It-tag">The return value of <i>ioctl</i>(2) could legitimately be
      -1, so it is necessary to see if <i>errno</i>(3) has been explicitly
    set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>readdir</i>(3)</dt>
  <dd class="It-tag">The return value of <i>readdir</i>(3) is NULL for both
      errors and end&#x2010;of&#x2010;file. It is necessary to see if
      <i>errno</i>(3) has been explicitly set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>setbuf</i>(3), <i>setbuffer</i>(3),
    <i>setlinebuf</i>(3), <i>setvbuf</i>(3)</dt>
  <dd class="It-tag">All but the last of these functions return void. And
      <i>setvbuf</i>(3) is only documented as returning
      &#x201C;non&#x2010;zero&#x201D; on error. It is necessary to see if
      <i>errno</i>(3) has been explicitly set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>strtod</i>(3), <i>strtol</i>(3), <i>strtold</i>(3),
    <i>strtoll</i>(3), <i>strtoul</i>(3), <i>strtoull</i>(3)</dt>
  <dd class="It-tag">These functions return 0 on error, but that is also a
      legitimate return value. It is necessary to see if <i>errno</i>(3) has
      been explicitly set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>ungetc</i>(3)</dt>
  <dd class="It-tag">While only a single character of backup is mandated by the
      ANSI C standard, it turns out that [e]glibc permits more... but that means
      it can fail with ENOMEM. It can also fail with EBADF if <i>fp</i> is
      bogus. Most difficult of all, if you pass EOF an error return occurs, but
      errno is not set.</dd>
</dl>
<div class="Pp"></div>
The libexplain library detects all of these errors correctly, even in cases
  where the error values are poorly documented, if at all.
<h2 class="Ss" title="Ss" id="ENOSPC,_No_space_left_on_device"><a class="selflink" href="#ENOSPC,_No_space_left_on_device">ENOSPC,
  No space left on device</a></h2>
When this error refers to a file on a file system, the libexplain library prints
  the mount point of the file system with the problem. This can make the source
  of the error much clearer.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
write(fildes = 1 &quot;example&quot;, data = 0xbfff2340, data_size = 5) failed,
  No space left on device (28, ENOSPC) because the file system containing fildes
  (&quot;/home&quot;) has no more space for data
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
As more special device support is added, error messages are expected to include
  the device name and actual size of the device.
<h2 class="Ss" title="Ss" id="EROFS,_Read&#x2010;only_file_system"><a class="selflink" href="#EROFS,_Read&#x2010;only_file_system">EROFS,
  Read&#x2010;only file system</a></h2>
When this error refers to a file on a file system, the libexplain library prints
  the mount point of the file system with the problem. This can make the source
  of the error much clearer.
<div class="Pp"></div>
As more special device support is added, error messages are expected to include
  the device name and type.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
open(pathname = &quot;/dev/fd0&quot;, O_RDWR, 0666) failed, Read&#x2010;only
  file system (30, EROFS) because the floppy disk has the write protect tab set
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<div class="Pp"></div>
...because a CD&#x2010;ROM is not writable
<div>&#x00A0;</div>
...because the memory card has the write protect tab set
<div>&#x00A0;</div>
...because the &#x00BD; inch magnetic tape does not have a write ring
<h2 class="Ss" title="Ss" id="rename"><a class="selflink" href="#rename">rename</a></h2>
The <i>rename</i>(2) system call is used to change the location or name of a
  file, moving it between directories if required. If the destination pathname
  already exists it will be atomically replaced, so that there is no point at
  which another process attempting to access it will find it missing.
<div class="Pp"></div>
There are limitations, however: you can only rename a directory on top of
  another directory if the destination directory is not empty.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
rename(oldpath = &quot;foo&quot;, newpath = &quot;bar&quot;) failed, Directory
  not empty (39, ENOTEMPTY) because newpath is not an empty directory; that is,
  it contains entries other than &quot;.&quot; and &quot;..&quot;
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
You can't rename a directory on top of a non&#x2010;directory, either.
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
rename(oldpath = &quot;foo&quot;, newpath = &quot;bar&quot;) failed, Not a
  directory (20, ENOTDIR) because oldpath is a directory, but newpath is a
  regular file, not a directory
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
Nor is the reverse allowed
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
rename(oldpath = &quot;foo&quot;, newpath = &quot;bar&quot;) failed, Is a
  directory (21, EISDIR) because newpath is a directory, but oldpath is a
  regular file, not a directory
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
<div class="Pp"></div>
This, of course, makes the libexplain library's job more complicated, because
  the <i>unlink</i>(2) or <i>rmdir</i>(2) system call is called implicitly by
  <i>rename</i>(2), and so all of the <i>unlink</i>(2) or <i>rmdir</i>(2) errors
  must be detected and handled, as well.
<h2 class="Ss" title="Ss" id="dup2"><a class="selflink" href="#dup2">dup2</a></h2>
The <i>dup2</i>(2) system call is used to create a second file descriptor that
  references the same object as the first file descriptor. Typically this is
  used to implement shell input and output redirection.
<div class="Pp"></div>
The fun thing is that, just as <i>rename</i>(2) can atomically rename a file on
  top of an existing file and remove the old file, <i>dup2</i>(2) can do this
  onto an already&#x2010;open file descriptor.
<div class="Pp"></div>
Once again, this makes the libexplain library's job more complicated, because
  the <i>close</i>(2) system call is called implicitly by <i>dup2</i>(2), and so
  all of <i>close</i>(2)'s errors must be detected and handled, as well.
<h1 class="Sh" title="Sh" id="ADVENTURES_IN_IOCTL_SUPPORT"><a class="selflink" href="#ADVENTURES_IN_IOCTL_SUPPORT">ADVENTURES
  IN IOCTL SUPPORT</a></h1>
The <i>ioctl</i>(2) system call provides device driver authors with a way to
  communicate with user&#x2010;space that doesn't fit within the existing kernel
  API. See <i>ioctl_list</i>(2).
<h2 class="Ss" title="Ss" id="Decoding_Request_Numbers"><a class="selflink" href="#Decoding_Request_Numbers">Decoding
  Request Numbers</a></h2>
From a cursory look at the <i>ioctl</i>(2) interface, there would appear to be a
  large but finite number of possible <i>ioctl</i>(2) requests. Each different
  <i>ioctl</i>(2) request is effectively another system call, but without any
  type&#x2010;safety at all - the compiler can't help a programmer get these
  right. This was probably the motivation behind <i>tcflush</i>(3) and friends.
<div class="Pp"></div>
The initial impression is that you could decode <i>ioctl</i>(2) requests using a
  huge switch statement. This turns out to be infeasible because one very
  rapidly discovers that it is impossible to include all of the necessary system
  headers defining the various <i>ioctl</i>(2) requests, because they have a
  hard time playing nicely with each other.
<div class="Pp"></div>
A deeper look reveals that there is a range of &#x201C;private&#x201D; request
  numbers, and device driver authors are encouraged to use them. This means that
  there is a far larger possible set of requests, with ambiguous request
  numbers, than are immediately apparent. Also, there are some historical
  ambiguities as well.
<div class="Pp"></div>
We already knew that the switch was impractical, but now we know that to select
  the appropriate request name and explanation we must consider not only the
  request number but also the file descriptor.
<div class="Pp"></div>
The implementation of <i>ioctl</i>(2) support within the libexplain library is
  to have a table of pointers to <i>ioctl</i>(2) request descriptors. Each of
  these descriptors includes an optional pointer to a disambiguation function.
<div class="Pp"></div>
Each request is actually implemented in a separate source file, so that the
  necessary include files are relieved of the obligation to play nicely with
  others.
<h2 class="Ss" title="Ss" id="Representation"><a class="selflink" href="#Representation">Representation</a></h2>
The philosophy behind the libexplain library is to provide as much information
  as possible, including an accurate representation of the system call. In the
  case of <i>ioctl</i>(2) this means printing the correct request number (by
  name) and also a correct (or at least useful) representation of the third
  argument.
<div class="Pp"></div>
The <i>ioctl</i>(2) prototype looks like this:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
int ioctl(int fildes, int request, ...);
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
which should have your type&#x2010;safety alarms going off. Internal to
  [e]glibc, this is turned into a variety of forms:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
int __ioctl(int fildes, int request, long arg);
int __ioctl(int fildes, int request, void *arg);
</pre>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
and the Linux kernel syscall interface expects
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
asmlinkage long sys_ioctl(unsigned int fildes, unsigned int request, unsigned
  long arg);
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The extreme variability of the third argument is a challenge, when the
  libexplain library tries to print a representation of that third argument.
  However, once the request number has been disambiguated, each entry in the the
  libexplain library's ioctl table has a custom print_data function (OO done
  manually).
<h2 class="Ss" title="Ss" id="Explanations"><a class="selflink" href="#Explanations">Explanations</a></h2>
There are fewer problems determining the explanation to be used. Once the
  request number has been disambiguated, each entry in the libexplain library's
  ioctl table has a custom print_explanation function (again, OO done manually).
<div class="Pp"></div>
Unlike section 2 and section 3 system calls, most <i>ioctl</i>(2) requests have
  no errors documented. This means, to give good error descriptions, it is
  necessary to read kernel sources to discover
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">what <i>errno</i>(3) values may be returned, and</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">the cause of each error.</dd>
</dl>
<div class="Pp"></div>
Because of the OO nature of function call dispatching withing the kernel, you
  need to read <i>all</i> sources implementing that <i>ioctl</i>(2) request, not
  just the generic implementation. It is to be expected that different kernels
  will have different error numbers and subtly different error causes.
<h2 class="Ss" title="Ss" id="EINVAL_vs_ENOTTY"><a class="selflink" href="#EINVAL_vs_ENOTTY">EINVAL
  <i>vs</i> ENOTTY</a></h2>
The situation is even worse for <i>ioctl</i>(2) requests than for system calls,
  with EINVAL and ENOTTY both being used to indicate that an <i>ioctl</i>(2)
  request is inappropriate in that context, and occasionally ENOSYS, ENOTSUP and
  EOPNOTSUPP (meant to be used for sockets) as well. There are comments in the
  Linux kernel sources that seem to indicate a progressive cleanup is in
  progress. For extra chaos, BSD adds ENOIOCTL to the confusion.
<div class="Pp"></div>
As a result, attention must be paid to these error cases to get them right,
  particularly as the EINVAL could also be referring to problems with one or
  more system call arguments.
<h2 class="Ss" title="Ss" id="intptr_t"><a class="selflink" href="#intptr_t">intptr_t</a></h2>
The C99 standard defines an integer type that is guaranteed to be able to hold
  any pointer without representation loss.
<div class="Pp"></div>
The above function syscall prototype would be better written
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
long sys_ioctl(unsigned int fildes, unsigned int request, intptr_t arg);
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The problem is the cognitive dissonance induced by device&#x2010;specific or
  file&#x2010;system&#x2010;specific <i>ioctl</i>(2) implementations, such as:
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<br/>
long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
The majority of <i>ioctl</i>(2) requests actually have an int *arg third
  argument. But having it declared long leads to code treating this as long
  *arg. This is harmless on 32&#x2010;bits (sizeof(long) == sizeof(int)) but
  nasty on 64&#x2010;bits (sizeof(long) != sizeof(int)). Depending on the
  endian&#x2010;ness, you do or don't get the value you expect, but you
  <i>always</i> get a memory scribble or stack scribble as well.
<div class="Pp"></div>
Writing all of these as
<div style="height: 0.30em;">&#x00A0;</div>
<div style="margin-left: 5.00ex;">
<pre>
int ioctl(int fildes, int request, ...);
int __ioctl(int fildes, int request, intptr_t arg);
</pre>
long sys_ioctl(unsigned int fildes, unsigned int request, intptr_t arg);
<div>&#x00A0;</div>
long vfs_ioctl(struct file *filp, unsigned int cmd, intptr_t arg);
<br/>
</div>
<div style="height: 0.30em;">&#x00A0;</div>
emphasizes that the integer is only an integer to represent a quantity that is
  almost always an unrelated pointer type.
<h1 class="Sh" title="Sh" id="CONCLUSION"><a class="selflink" href="#CONCLUSION">CONCLUSION</a></h1>
Use libexplain, your users will like it.
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
libexplain version 1.4
<div>&#x00A0;</div>
Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014 Peter Miller
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Written by Peter Miller &lt;pmiller@opensource.org.au&gt;</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
