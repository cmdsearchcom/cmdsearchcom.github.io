<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:05 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLREREF(1) Perl Programmers Reference Guide
PERLREREF(1)</p>

<p style="margin-top: 1em">NAME <br>
perlreref - Perl Regular Expressions Reference</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This is a quick reference to Perl&rsquo;s regular
expressions. For full information see perlre and perlop, as
well as the &quot;SEE ALSO&quot; section in this
document.</p>

<p style="margin-top: 1em">OPERATORS <br>
&quot;=~&quot; determines to which variable the regex is
applied. In its absence, $_ is used.</p>

<p style="margin-top: 1em">$var =~ /foo/;</p>

<p style="margin-top: 1em">&quot;!~&quot; determines to
which variable the regex is applied, and negates the result
of the match; it returns false if the match succeeds, and
true if it fails.</p>

<p style="margin-top: 1em">$var !~ /foo/;</p>


<p style="margin-top: 1em">&quot;m/pattern/msixpogcdual&quot;
searches a string for a pattern match, applying the given
options.</p>

<p style="margin-top: 1em">m Multiline mode - ^ and $ match
internal lines <br>
s match as a Single line - . matches <br>
i case-Insensitive <br>
x eXtended legibility - free whitespace and comments <br>
p Preserve a copy of the matched string - <br>
${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined. <br>
o compile pattern Once <br>
g Global - all occurrences <br>
c don&rsquo;t reset pos on failed matches when using /g <br>
a restrict , :posix:] to match ASCII only <br>
aa (two a&rsquo;s) also /i matches exclude ASCII/non-ASCII
<br>
l match according to current locale <br>
u match according to Unicode rules <br>
d match according to native rules unless something indicates
<br>
Unicode</p>

<p style="margin-top: 1em">If &rsquo;pattern&rsquo; is an
empty string, the last successfully matched regex is used.
Delimiters other than &rsquo;/&rsquo; may be used for both
this operator and the following ones. The leading
&quot;m&quot; <br>
can be omitted if the delimiter is &rsquo;/&rsquo;.</p>


<p style="margin-top: 1em">&quot;qr/pattern/msixpodual&quot;
lets you store a regex in a variable, or pass one around.
Modifiers as for &quot;m//&quot;, and are stored within the
regex.</p>


<p style="margin-top: 1em">&quot;s/pattern/replacement/msixpogcedual&quot;
substitutes matches of &rsquo;pattern&rsquo; with
&rsquo;replacement&rsquo;. Modifiers as for &quot;m//&quot;,
with two additions:</p>

<p style="margin-top: 1em">e Evaluate
&rsquo;replacement&rsquo; as an expression <br>
r Return substitution and leave the original string
untouched.</p>

<p style="margin-top: 1em">&rsquo;e&rsquo; may be specified
multiple times. &rsquo;replacement&rsquo; is interpreted as
a double quoted string unless a single-quote
(&quot;&rsquo;&quot;) is the delimiter.</p>

<p style="margin-top: 1em">&quot;?pattern?&quot; is like
&quot;m/pattern/&quot; but matches only once. No alternate
delimiters can be used. Must be reset with reset().</p>

<p style="margin-top: 1em">SYNTAX &nbsp; <br>
Escapes the character immediately following it <br>
. Matches any single character except a newline (unless /s
is <br>
used) <br>
^ Matches at the beginning of the string (or line, if /m is
used) <br>
$ Matches at the end of the string (or line, if /m is used)
<br>
* Matches the preceding element 0 or more times <br>
+ Matches the preceding element 1 or more times <br>
? Matches the preceding element 0 or 1 times <br>
{...} Specifies a range of occurrences for the element
preceding it <br>
[...] Matches any one of the characters contained within the
brackets <br>
(...) Groups subexpressions for capturing to $1, $2... <br>
(?:...) Groups subexpressions without capturing (cluster)
<br>
| Matches either the subexpression preceding or following it
<br>
or 1}, ... Matches the text from the Nth group <br>
1, 2, 3 ... Matches the text from the Nth group <br>
1 or -1}, 2 ... Matches the text from the Nth previous group
<br>
name} Named backreference <br>
name&gt; Named backreference <br>
name&rsquo; Named backreference <br>
(?P=name) Named backreference (python syntax)</p>

<p style="margin-top: 1em">ESCAPE SEQUENCES <br>
These work as in normal strings.</p>

<p style="margin-top: 1em">Alarm (beep) <br>
\ Escape <br>
Formfeed <br>
Newline <br>
Carriage return <br>
Tab <br>
37 Char whose ordinal is the 3 octal digits, max 777 d <br>
f Char whose ordinal is the 2 hex digits, max <br>
} Char whose ordinal is the hex number, unrestricted <br>
ame} A named Unicode character or character sequence <br>
+263D} A Unicode character by hex ordinal</p>

<p style="margin-top: 1em">Lowercase next character <br>
Titlecase next character <br>
Lowercase until U Uppercase until Foldcase until Q Disable
pattern metacharacters until &nbsp; End modification</p>

<p style="margin-top: 1em">For Titlecase, see
&quot;Titlecase&quot;.</p>

<p style="margin-top: 1em">This one works differently from
normal strings:</p>

<p style="margin-top: 1em">An assertion, not backspace,
except in a character class</p>

<p style="margin-top: 1em">CHARACTER CLASSES <br>
[amy] Match &rsquo;a&rsquo;, &rsquo;m&rsquo; or
&rsquo;y&rsquo; <br>
[f-j] Dash specifies &quot;range&quot; <br>
[f-j-] Dash escaped or at start or end means
&rsquo;dash&rsquo; <br>
[^f-j] Caret indicates &quot;match any character _except_
these&quot;</p>

<p style="margin-top: 1em">The following sequences (except
&quot; work within or without a character class. The first
six are locale aware, all are Unicode aware. See perllocale
and perlunicode for <br>
details.</p>

<p style="margin-top: 1em">A digit <br>
A nondigit <br>
0 A word character <br>
W A non-word character <br>
A whitespace character <br>
A non-whitespace character <br>
An horizontal whitespace <br>
A non horizontal whitespace <br>
A non newline (when not followed by &rsquo;{NAME}&rsquo;;
experimental; <br>
not valid in a character class; equivalent to [^0;
it&rsquo;s <br>
like &rsquo;.&rsquo; without /s modifier) <br>
A vertical whitespace <br>
A non vertical whitespace <br>
A generic newline (?&gt;A)</p>

<p style="margin-top: 1em">Match a byte (with Unicode,
&rsquo;.&rsquo; matches a character) <br>
P Match P-named (Unicode) property <br>
{...} Match Unicode property with name longer than 1
character <br>
PP Match non-P <br>
P{...} Match lack of Unicode property with name longer than
1 char <br>
Match Unicode extended grapheme cluster</p>

<p style="margin-top: 1em">POSIX character classes and
their Unicode and Perl equivalents:</p>

<p style="margin-top: 1em">ASCII- Full- <br>
POSIX range range backslash <br>
[[:...:]] {...} {...} sequence Description</p>


<p style="margin-top: 1em">-----------------------------------------------------------------------
<br>
alnum PosixAlnum XPosixAlnum Alpha plus Digit <br>
alpha PosixAlpha XPosixAlpha Alphabetic characters <br>
ascii ASCII Any ASCII character <br>
blank PosixBlank XPosixBlank Horizontal whitespace; <br>
full-range also <br>
written as <br>
{HorizSpace} (GNU <br>
extension) <br>
cntrl PosixCntrl XPosixCntrl Control characters <br>
digit PosixDigit XPosixDigit Decimal digits <br>
graph PosixGraph XPosixGraph Alnum plus Punct <br>
lower PosixLower XPosixLower Lowercase characters <br>
print PosixPrint XPosixPrint Graph plus Print, but <br>
not any Cntrls <br>
punct PosixPunct XPosixPunct Punctuation and Symbols <br>
in ASCII-range; just <br>
punct outside it <br>
space PosixSpace XPosixSpace [] <br>
PerlSpace XPerlSpace Perl&rsquo;s whitespace def&rsquo;n
<br>
upper PosixUpper XPosixUpper Uppercase characters <br>
word PosixWord XPosixWord 0 Alnum + Unicode marks + <br>
connectors, like &rsquo;_&rsquo; <br>
(Perl extension) <br>
xdigit ASCII_Hex_Digit XPosixDigit Hexadecimal digit, <br>
ASCII-range is <br>
[0-9A-Fa-f]</p>

<p style="margin-top: 1em">Also, various synonyms like
&quot;{Alpha}&quot; for &quot;{XPosixAlpha}&quot;; all
listed in &quot;Properties accessible through {} and
P{}&quot; in perluniprops</p>

<p style="margin-top: 1em">Within a character class:</p>

<p style="margin-top: 1em">POSIX traditional Unicode <br>
[:digit:] {Digit} <br>
[:^digit:] P{Digit}</p>

<p style="margin-top: 1em">ANCHORS <br>
All are zero-width assertions.</p>

<p style="margin-top: 1em">^ Match string start (or line,
if /m is used) <br>
$ Match string end (or line, if /m is used) or before
newline M a t <br>
word boundary (between 72W) c h <br>
0Match except at word boundary (between 7248W and W) <br>
1string start (regardless of /m) Match <br>
string end (before optional newline) <br>
Match absolute string end <br>
G Match where previous m//g left off <br>
K Keep the stuff left of the K, don&rsquo;t include it in
$&amp;</p>

<p style="margin-top: 1em">QUANTIFIERS <br>
Quantifiers are greedy by default and match the longest
leftmost.</p>

<p style="margin-top: 1em">Maximal Minimal Possessive
Allowed range <br>
------- ------- ---------- ------------- <br>
{n,m} {n,m}? {n,m}+ Must occur at least n times <br>
but no more than m times <br>
{n,} {n,}? {n,}+ Must occur at least n times <br>
{n} {n}? {n}+ Must occur exactly n times <br>
* *? *+ 0 or more times (same as {0,}) <br>
+ +? ++ 1 or more times (same as {1,}) <br>
? ?? ?+ 0 or 1 time (same as {0,1})</p>

<p style="margin-top: 1em">The possessive forms (new in
Perl 5.10) prevent backtracking: what gets matched by a
pattern with a possessive quantifier will not be backtracked
into, even if that causes the <br>
whole match to fail.</p>

<p style="margin-top: 1em">There is no quantifier
&quot;{,n}&quot;. That&rsquo;s interpreted as a literal
string.</p>

<p style="margin-top: 1em">EXTENDED CONSTRUCTS <br>
(?#text) A comment <br>
(?:...) Groups subexpressions without capturing (cluster)
<br>
(?pimsx-imsx:...) Enable/disable option (as per m//
modifiers) <br>
(?=...) Zero-width positive lookahead assertion <br>
(?!...) Zero-width negative lookahead assertion <br>
(?&lt;=...) Zero-width positive lookbehind assertion <br>
(?&lt;!...) Zero-width negative lookbehind assertion <br>
(?&gt;...) Grab what we can, prohibit backtracking <br>
(?|...) Branch reset <br>
(?&lt;name&gt;...) Named capture <br>
(?&rsquo;name&rsquo;...) Named capture <br>
(?P&lt;name&gt;...) Named capture (python syntax) <br>
(?{ code }) Embedded code, return value becomes $^R <br>
(??{ code }) Dynamic regex, return value used as regex <br>
(?N) Recurse into subpattern number N <br>
(?-N), (?+N) Recurse into Nth previous/next subpattern <br>
(?R), (?0) Recurse at the beginning of the whole pattern
<br>
(?&amp;name) Recurse into a named subpattern <br>
(?P&gt;name) Recurse into a named subpattern (python syntax)
<br>
(?(cond)yes|no) <br>
(?(cond)yes) Conditional expression, where &quot;cond&quot;
can be: <br>
(?=pat) look-ahead <br>
(?!pat) negative look-ahead <br>
(?&lt;=pat) look-behind <br>
(?&lt;!pat) negative look-behind <br>
(N) subpattern N has matched something <br>
(&lt;name&gt;) named subpattern has matched something <br>
(&rsquo;name&rsquo;) named subpattern has matched something
<br>
(?{code}) code condition <br>
(R) true if recursing <br>
(RN) true if recursing into Nth subpattern <br>
(R&amp;name) true if recursing into named subpattern <br>
(DEFINE) always false, no no-pattern allowed</p>

<p style="margin-top: 1em">VARIABLES <br>
$_ Default variable for operators to use</p>

<p style="margin-top: 1em">$&lsquo; Everything prior to
matched string <br>
$&amp; Entire matched string <br>
$&rsquo; Everything after to matched string</p>

<p style="margin-top: 1em">${^PREMATCH} Everything prior to
matched string <br>
${^MATCH} Entire matched string <br>
${^POSTMATCH} Everything after to matched string</p>

<p style="margin-top: 1em">The use of &quot;$&lsquo;&quot;,
$&amp; or &quot;$&rsquo;&quot; will slow down all regex use
within your program. Consult perlvar for &quot;@-&quot; to
see equivalent expressions that won&rsquo;t cause slow down.
See also <br>
Devel::SawAmpersand. Starting with Perl 5.10, you can also
use the equivalent variables &quot;${^PREMATCH}&quot;,
&quot;${^MATCH}&quot; and &quot;${^POSTMATCH}&quot;, but for
them to be defined, you have to <br>
specify the &quot;/p&quot; (preserve) modifier on your
regular expression.</p>

<p style="margin-top: 1em">$1, $2 ... hold the Xth captured
expr <br>
$+ Last parenthesized pattern match <br>
$^N Holds the most recently closed capture <br>
$^R Holds the result of the last (?{...}) expr <br>
@- Offsets of starts of groups. $-[0] holds start of whole
match <br>
@+ Offsets of ends of groups. $+[0] holds end of whole match
<br>
%+ Named capture groups <br>
%- Named capture groups, as array refs</p>

<p style="margin-top: 1em">Captured groups are numbered
according to their opening paren.</p>

<p style="margin-top: 1em">FUNCTIONS <br>
lc Lowercase a string <br>
lcfirst Lowercase first char of a string <br>
uc Uppercase a string <br>
ucfirst Titlecase first char of a string <br>
fc Foldcase a string</p>

<p style="margin-top: 1em">pos Return or set current match
position <br>
quotemeta Quote metacharacters <br>
reset Reset ?pattern? status <br>
study Analyze string for optimizing matching</p>

<p style="margin-top: 1em">split Use a regex to split a
string into parts</p>

<p style="margin-top: 1em">The first five of these are like
the escape sequences &quot; &quot; &quot;U&quot;,
&quot;&quot;, and &quot;. For Titlecase, see
&quot;Titlecase&quot;; For Foldcase, see
&quot;Foldcase&quot;.</p>

<p style="margin-top: 1em">TERMINOLOGY <br>
Titlecase</p>

<p style="margin-top: 1em">Unicode concept which most often
is equal to uppercase, but for certain characters like the
German &quot;sharp s&quot; there is a difference.</p>

<p style="margin-top: 1em">Foldcase</p>

<p style="margin-top: 1em">Unicode form that is useful when
comparing strings regardless of case, as certain characters
have compex one-to-many case mappings. Primarily a variant
of lowercase.</p>

<p style="margin-top: 1em">AUTHOR <br>
Iain Truskett. Updated by the Perl 5 Porters.</p>

<p style="margin-top: 1em">This document may be distributed
under the same terms as Perl itself.</p>

<p style="margin-top: 1em">SEE ALSO <br>
&Acirc;&middot; perlretut for a tutorial on regular
expressions.</p>

<p style="margin-top: 1em">&Acirc;&middot; perlrequick for
a rapid tutorial.</p>

<p style="margin-top: 1em">&Acirc;&middot; perlre for more
details.</p>

<p style="margin-top: 1em">&Acirc;&middot; perlvar for
details on the variables.</p>

<p style="margin-top: 1em">&Acirc;&middot; perlop for
details on the operators.</p>

<p style="margin-top: 1em">&Acirc;&middot; perlfunc for
details on the functions.</p>

<p style="margin-top: 1em">&Acirc;&middot; perlfaq6 for
FAQs on regular expressions.</p>

<p style="margin-top: 1em">&Acirc;&middot; perlrebackslash
for a reference on backslash sequences.</p>

<p style="margin-top: 1em">&Acirc;&middot; perlrecharclass
for a reference on character classes.</p>

<p style="margin-top: 1em">&Acirc;&middot; The re module to
alter behaviour and aid debugging.</p>

<p style="margin-top: 1em">&Acirc;&middot; &quot;Debugging
Regular Expressions&quot; in perldebug</p>

<p style="margin-top: 1em">&Acirc;&middot; perluniintro,
perlunicode, charnames and perllocale for details on regexes
and internationalisation.</p>

<p style="margin-top: 1em">&Acirc;&middot; Mastering
Regular Expressions by Jeffrey Friedl
(http://oreilly.com/catalog/9780596528126/) for a thorough
grounding and reference on the topic.</p>

<p style="margin-top: 1em">THANKS <br>
David P.C. Wollmann, Richard Soderberg, Sean M. Burke, Tom
Christiansen, Jim Cromie, and Jeffrey Goff for useful
advice.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLREREF(1)</p>
<hr>
</body>
</html>
