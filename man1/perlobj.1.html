<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:59 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLOBJ(1) Perl Programmers Reference Guide
PERLOBJ(1)</p>

<p style="margin-top: 1em">NAME <br>
perlobj - Perl object reference</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This document provides a reference for Perl&rsquo;s object
orientation features. If you&rsquo;re looking for an
introduction to object-oriented programming in Perl, please
see perlootut.</p>

<p style="margin-top: 1em">In order to understand Perl
objects, you first need to understand references in Perl.
See perlref for details.</p>

<p style="margin-top: 1em">This document describes all of
Perl&rsquo;s object-oriented (OO) features from the ground
up. If you&rsquo;re just looking to write some
object-oriented code of your own, you are probably <br>
better served by using one of the object systems from CPAN
described in perlootut.</p>

<p style="margin-top: 1em">If you&rsquo;re looking to write
your own object system, or you need to maintain code which
implements objects from scratch then this document will help
you understand exactly how Perl <br>
does object orientation.</p>

<p style="margin-top: 1em">There are a few basic principles
which define object oriented Perl:</p>

<p style="margin-top: 1em">1. An object is simply a data
structure that knows to which class it belongs.</p>

<p style="margin-top: 1em">2. A class is simply a package.
A class provides methods that expect to operate on
objects.</p>

<p style="margin-top: 1em">3. A method is simply a
subroutine that expects a reference to an object (or a
package name, for class methods) as the first argument.</p>

<p style="margin-top: 1em">Let&rsquo;s look at each of
these principles in depth.</p>

<p style="margin-top: 1em">An Object is Simply a Data
Structure <br>
Unlike many other languages which support object
orientation, Perl does not provide any special syntax for
constructing an object. Objects are merely Perl data
structures <br>
(hashes, arrays, scalars, filehandles, etc.) that have been
explicitly associated with a particular class.</p>

<p style="margin-top: 1em">That explicit association is
created by the built-in &quot;bless&quot; function, which is
typically used within the constructor subroutine of the
class.</p>

<p style="margin-top: 1em">Here is a simple
constructor:</p>

<p style="margin-top: 1em">package File;</p>

<p style="margin-top: 1em">sub new { <br>
my $class = shift;</p>

<p style="margin-top: 1em">return bless {}, $class; <br>
}</p>

<p style="margin-top: 1em">The name &quot;new&quot;
isn&rsquo;t special. We could name our constructor something
else:</p>

<p style="margin-top: 1em">package File;</p>

<p style="margin-top: 1em">sub load { <br>
my $class = shift;</p>

<p style="margin-top: 1em">return bless {}, $class; <br>
}</p>

<p style="margin-top: 1em">The modern convention for OO
modules is to always use &quot;new&quot; as the name for the
constructor, but there is no requirement to do so. Any
subroutine that blesses a data structure <br>
into a class is a valid constructor in Perl.</p>

<p style="margin-top: 1em">In the previous examples, the
&quot;{}&quot; code creates a reference to an empty
anonymous hash. The &quot;bless&quot; function then takes
that reference and associates the hash with the class in
<br>
$class. In the simplest case, the $class variable will end
up containing the string &quot;File&quot;.</p>

<p style="margin-top: 1em">We can also use a variable to
store a reference to the data structure that is being
blessed as our object:</p>

<p style="margin-top: 1em">sub new { <br>
my $class = shift;</p>

<p style="margin-top: 1em">my $self = {}; <br>
bless $self, $class;</p>

<p style="margin-top: 1em">return $self; <br>
}</p>

<p style="margin-top: 1em">Once we&rsquo;ve blessed the
hash referred to by $self we can start calling methods on
it. This is useful if you want to put object initialization
in its own separate method:</p>

<p style="margin-top: 1em">sub new { <br>
my $class = shift;</p>

<p style="margin-top: 1em">my $self = {}; <br>
bless $self, $class;</p>

<p style="margin-top: 1em">$self-&gt;_initialize();</p>

<p style="margin-top: 1em">return $self; <br>
}</p>

<p style="margin-top: 1em">Since the object is also a hash,
you can treat it as one, using it to store data associated
with the object. Typically, code inside the class can treat
the hash as an accessible <br>
data structure, while code outside the class should always
treat the object as opaque. This is called encapsulation.
Encapsulation means that the user of an object does not have
<br>
to know how it is implemented. The user simply calls
documented methods on the object.</p>

<p style="margin-top: 1em">Note, however, that (unlike most
other OO languages) Perl does not ensure or enforce
encapsulation in any way. If you want objects to actually be
opaque you need to arrange for <br>
that yourself. This can be done in a varierty of ways,
including using &quot;Inside-Out objects&quot; or modules
from CPAN.</p>

<p style="margin-top: 1em">Objects Are Blessed; Variables
Are Not</p>

<p style="margin-top: 1em">When we bless something, we are
not blessing the variable which contains a reference to that
thing, nor are we blessing the reference that the variable
stores; we are blessing <br>
the thing that the variable refers to (sometimes known as
the referent). This is best demonstrated with this code:</p>

<p style="margin-top: 1em">use Scalar::Util
&rsquo;blessed&rsquo;;</p>

<p style="margin-top: 1em">my $foo = {}; <br>
my $bar = $foo;</p>

<p style="margin-top: 1em">bless $foo, &rsquo;Class&rsquo;;
<br>
print blessed( $bar ); # prints &quot;Class&quot;</p>

<p style="margin-top: 1em">$bar = &quot;some other
value&quot;; <br>
print blessed( $bar ); # prints undef</p>

<p style="margin-top: 1em">When we call &quot;bless&quot;
on a variable, we are actually blessing the underlying data
structure that the variable refers to. We are not blessing
the reference itself, nor the variable <br>
that contains that reference. That&rsquo;s why the second
call to &quot;blessed( $bar )&quot; returns false. At that
point $bar is no longer storing a reference to an
object.</p>

<p style="margin-top: 1em">You will sometimes see older
books or documentation mention &quot;blessing a
reference&quot; or describe an object as a &quot;blessed
reference&quot;, but this is incorrect. It isn&rsquo;t the
reference <br>
that is blessed as an object; it&rsquo;s the thing the
reference refers to (i.e. the referent).</p>

<p style="margin-top: 1em">A Class is Simply a Package <br>
Perl does not provide any special syntax for class
definitions. A package is simply a namespace containing
variables and subroutines. The only difference is that in a
class, the <br>
subroutines may expect a reference to an object or the name
of a class as the first argument. This is purely a matter of
convention, so a class may contain both methods and <br>
subroutines which don&rsquo;t operate on an object or
class.</p>

<p style="margin-top: 1em">Each package contains a special
array called @ISA. The @ISA array contains a list of that
class&rsquo;s parent classes, if any. This array is examined
when Perl does method resolution, <br>
which we will cover later.</p>

<p style="margin-top: 1em">It is possible to manually set
@ISA, and you may see this in older Perl code. Much older
code also uses the base pragma. For new code, we recommend
that you use the parent pragma <br>
to declare your parents. This pragma will take care of
setting @ISA. It will also load the parent classes and make
sure that the package doesn&rsquo;t inherit from itself.</p>

<p style="margin-top: 1em">However the parent classes are
set, the package&rsquo;s @ISA variable will contain a list
of those parents. This is simply a list of scalars, each of
which is a string that corresponds <br>
to a package name.</p>

<p style="margin-top: 1em">All classes inherit from the
UNIVERSAL class implicitly. The UNIVERSAL class is
implemented by the Perl core, and provides several default
methods, such as &quot;isa()&quot;, &quot;can()&quot;, and
<br>
&quot;VERSION()&quot;. The &quot;UNIVERSAL&quot; class will
never appear in a package&rsquo;s @ISA variable.</p>

<p style="margin-top: 1em">Perl only provides method
inheritance as a built-in feature. Attribute inheritance is
left up the class to implement. See the &quot;Writing
Accessors&quot; section for details.</p>

<p style="margin-top: 1em">A Method is Simply a Subroutine
<br>
Perl does not provide any special syntax for defining a
method. A method is simply a regular subroutine, and is
declared with &quot;sub&quot;. What makes a method special
is that it <br>
expects to receive either an object or a class name as its
first argument.</p>

<p style="margin-top: 1em">Perl does provide special syntax
for method invocation, the &quot;-&gt;&quot; operator. We
will cover this in more detail later.</p>

<p style="margin-top: 1em">Most methods you write will
expect to operate on objects:</p>

<p style="margin-top: 1em">sub save { <br>
my $self = shift;</p>

<p style="margin-top: 1em">open my $fh, &rsquo;&gt;&rsquo;,
$self-&gt;path() or die $!; <br>
print {$fh} $self-&gt;data() or die $!; <br>
close $fh or die $!; <br>
}</p>

<p style="margin-top: 1em">Method Invocation <br>
Calling a method on an object is written as
&quot;$object-&gt;method&quot;.</p>

<p style="margin-top: 1em">The left hand side of the method
invocation (or arrow) operator is the object (or class
name), and the right hand side is the method name.</p>

<p style="margin-top: 1em">my $pod = File-&gt;new(
&rsquo;perlobj.pod&rsquo;, $data ); <br>
$pod-&gt;save();</p>

<p style="margin-top: 1em">The &quot;-&gt;&quot; syntax is
also used when dereferencing a reference. It looks like the
same operator, but these are two different operations.</p>

<p style="margin-top: 1em">When you call a method, the
thing on the left side of the arrow is passed as the first
argument to the method. That means when we call
&quot;Critter-&gt;new()&quot;, the &quot;new()&quot; method
<br>
receives the string &quot;Critter&quot; as its first
argument. When we call &quot;$fred-&gt;speak()&quot;, the
$fred variable is passed as the first argument to
&quot;speak()&quot;.</p>

<p style="margin-top: 1em">Just as with any Perl
subroutine, all of the arguments passed in @_ are aliases to
the original argument. This includes the object itself. If
you assign directly to $_[0] you <br>
will change the contents of the variable that holds the
reference to the object. We recommend that you don&rsquo;t
do this unless you know exactly what you&rsquo;re doing.</p>

<p style="margin-top: 1em">Perl knows what package the
method is in by looking at the left side of the arrow. If
the left hand side is a package name, it looks for the
method in that package. If the left <br>
hand side is an object, then Perl looks for the method in
the package that the object has been blessed into.</p>

<p style="margin-top: 1em">If the left hand side is neither
a package name nor an object, then the method call will
cause an error, but see the section on &quot;Method Call
Variations&quot; for more nuances.</p>

<p style="margin-top: 1em">Inheritance <br>
We already talked about the special @ISA array and the
parent pragma.</p>

<p style="margin-top: 1em">When a class inherits from
another class, any methods defined in the parent class are
available to the child class. If you attempt to call a
method on an object that isn&rsquo;t <br>
defined in its own class, Perl will also look for that
method in any parent classes it may have.</p>

<p style="margin-top: 1em">package File::MP3; <br>
use parent &rsquo;File&rsquo;; # sets @File::MP3::ISA =
(&rsquo;File&rsquo;);</p>

<p style="margin-top: 1em">my $mp3 = File::MP3-&gt;new(
&rsquo;Andvari.mp3&rsquo;, $data ); <br>
$mp3-&gt;save();</p>

<p style="margin-top: 1em">Since we didn&rsquo;t define a
&quot;save()&quot; method in the &quot;File::MP3&quot;
class, Perl will look at the &quot;File::MP3&quot;
class&rsquo;s parent classes to find the &quot;save()&quot;
method. If Perl cannot find a <br>
&quot;save()&quot; method anywhere in the inheritance
hierarchy, it will die.</p>

<p style="margin-top: 1em">In this case, it finds a
&quot;save()&quot; method in the &quot;File&quot; class.
Note that the object passed to &quot;save()&quot; in this
case is still a &quot;File::MP3&quot; object, even though
the method is found <br>
in the &quot;File&quot; class.</p>

<p style="margin-top: 1em">We can override a parent&rsquo;s
method in a child class. When we do so, we can still call
the parent class&rsquo;s method with the &quot;SUPER&quot;
pseudo-class.</p>

<p style="margin-top: 1em">sub save { <br>
my $self = shift;</p>

<p style="margin-top: 1em">say &rsquo;Prepare to
rock&rsquo;; <br>
$self-&gt;SUPER::save(); <br>
}</p>

<p style="margin-top: 1em">The &quot;SUPER&quot; modifier
can only be used for method calls. You can&rsquo;t use it
for regular subroutine calls or class methods:</p>

<p style="margin-top: 1em">SUPER::save($thing); # FAIL:
looks for save() sub in package SUPER</p>

<p style="margin-top: 1em">SUPER-&gt;save($thing); # FAIL:
looks for save() method in class <br>
# SUPER</p>

<p style="margin-top: 1em">$thing-&gt;SUPER::save(); #
Okay: looks for save() method in parent <br>
# classes</p>

<p style="margin-top: 1em">How SUPER is Resolved</p>

<p style="margin-top: 1em">The &quot;SUPER&quot;
pseudo-class is resolved from the package where the call is
made. It is not resolved based on the object&rsquo;s class.
This is important, because it lets methods at <br>
different levels within a deep inheritance hierarchy each
correctly call their respective parent methods.</p>

<p style="margin-top: 1em">package A;</p>

<p style="margin-top: 1em">sub new { <br>
return bless {}, shift; <br>
}</p>

<p style="margin-top: 1em">sub speak { <br>
my $self = shift;</p>

<p style="margin-top: 1em">$self-&gt;SUPER::speak();</p>

<p style="margin-top: 1em">say &rsquo;A&rsquo;; <br>
}</p>

<p style="margin-top: 1em">package B;</p>

<p style="margin-top: 1em">use parent &rsquo;A&rsquo;;</p>

<p style="margin-top: 1em">sub speak { <br>
my $self = shift;</p>

<p style="margin-top: 1em">$self-&gt;SUPER::speak();</p>

<p style="margin-top: 1em">say &rsquo;B&rsquo;; <br>
}</p>

<p style="margin-top: 1em">package C;</p>

<p style="margin-top: 1em">use parent &rsquo;B&rsquo;;</p>

<p style="margin-top: 1em">sub speak { <br>
my $self = shift;</p>

<p style="margin-top: 1em">$self-&gt;SUPER::speak();</p>

<p style="margin-top: 1em">say &rsquo;C&rsquo;; <br>
}</p>

<p style="margin-top: 1em">my $c = C-&gt;new(); <br>
$c-&gt;speak();</p>

<p style="margin-top: 1em">In this example, we will get the
following output:</p>

<p style="margin-top: 1em">A <br>
B <br>
C</p>

<p style="margin-top: 1em">This demonstrates how
&quot;SUPER&quot; is resolved. Even though the object is
blessed into the &quot;C&quot; class, the
&quot;speak()&quot; method in the &quot;B&quot; class can
still call &quot;SUPER::speak()&quot; and expect <br>
it to correctly look in the parent class of &quot;B&quot;
(i.e the class the method call is in), not in the parent
class of &quot;C&quot; (i.e. the class the object belongs
to).</p>

<p style="margin-top: 1em">There are rare cases where this
package-based resolution can be a problem. If you copy a
subroutine from one package to another, &quot;SUPER&quot;
resolution will be done based on the <br>
original package.</p>

<p style="margin-top: 1em">Multiple Inheritance</p>

<p style="margin-top: 1em">Multiple inheritance often
indicates a design problem, but Perl always gives you enough
rope to hang yourself with if you ask for it.</p>

<p style="margin-top: 1em">To declare multiple parents, you
simply need to pass multiple class names to &quot;use
parent&quot;:</p>

<p style="margin-top: 1em">package MultiChild;</p>

<p style="margin-top: 1em">use parent
&rsquo;Parent1&rsquo;, &rsquo;Parent2&rsquo;;</p>

<p style="margin-top: 1em">Method Resolution Order</p>

<p style="margin-top: 1em">Method resolution order only
matters in the case of multiple inheritance. In the case of
single inheritance, Perl simply looks up the inheritance
chain to find a method:</p>

<p style="margin-top: 1em">Grandparent <br>
| <br>
Parent <br>
| <br>
Child</p>

<p style="margin-top: 1em">If we call a method on a
&quot;Child&quot; object and that method is not defined in
the &quot;Child&quot; class, Perl will look for that method
in the &quot;Parent&quot; class and then, if necessary, in
the <br>
&quot;Grandparent&quot; class.</p>

<p style="margin-top: 1em">If Perl cannot find the method
in any of these classes, it will die with an error
message.</p>

<p style="margin-top: 1em">When a class has multiple
parents, the method lookup order becomes more
complicated.</p>

<p style="margin-top: 1em">By default, Perl does a
depth-first left-to-right search for a method. That means it
starts with the first parent in the @ISA array, and then
searches all of its parents, <br>
grandparents, etc. If it fails to find the method, it then
goes to the next parent in the original class&rsquo;s @ISA
array and searches from there.</p>

<p style="margin-top: 1em">SharedGreatGrandParent <br>
/ PaternalGrandparent MaternalGrandparent &nbsp; <br>
/ <br>
Father Mother &nbsp; <br>
/ <br>
Child</p>

<p style="margin-top: 1em">So given the diagram above, Perl
will search &quot;Child&quot;, &quot;Father&quot;,
&quot;PaternalGrandparent&quot;,
&quot;SharedGreatGrandParent&quot;, &quot;Mother&quot;, and
finally &quot;MaternalGrandparent&quot;. This may be a <br>
problem because now we&rsquo;re looking in
&quot;SharedGreatGrandParent&quot; before we&rsquo;ve
checked all its derived classes (i.e. before we tried
&quot;Mother&quot; and &quot;MaternalGrandparent&quot;).</p>

<p style="margin-top: 1em">It is possible to ask for a
different method resolution order with the mro pragma.</p>

<p style="margin-top: 1em">package Child;</p>

<p style="margin-top: 1em">use mro &rsquo;c3&rsquo;; <br>
use parent &rsquo;Father&rsquo;, &rsquo;Mother&rsquo;;</p>

<p style="margin-top: 1em">This pragma lets you switch to
the &quot;C3&quot; resolution order. In simple terms,
&quot;C3&quot; order ensures that shared parent classes are
never searched before child classes, so Perl will now <br>
search: &quot;Child&quot;, &quot;Father&quot;,
&quot;PaternalGrandparent&quot;, &quot;Mother&quot;
&quot;MaternalGrandparent&quot;, and finally
&quot;SharedGreatGrandParent&quot;. Note however that this
is not &quot;breadth-first&quot; searching: <br>
All the &quot;Father&quot; ancestors (except the common
ancestor) are searched before any of the &quot;Mother&quot;
ancestors are considered.</p>

<p style="margin-top: 1em">The C3 order also lets you call
methods in sibling classes with the &quot;next&quot;
pseudo-class. See the mro documentation for more details on
this feature.</p>

<p style="margin-top: 1em">Method Resolution Caching</p>

<p style="margin-top: 1em">When Perl searches for a method,
it caches the lookup so that future calls to the method do
not need to search for it again. Changing a class&rsquo;s
parent class or adding subroutines <br>
to a class will invalidate the cache for that class.</p>

<p style="margin-top: 1em">The mro pragma provides some
functions for manipulating the method cache directly.</p>

<p style="margin-top: 1em">Writing Constructors <br>
As we mentioned earlier, Perl provides no special
constructor syntax. This means that a class must implement
its own constructor. A constructor is simply a class method
that <br>
returns a reference to a new object.</p>

<p style="margin-top: 1em">The constructor can also accept
additional parameters that define the object. Let&rsquo;s
write a real constructor for the &quot;File&quot; class we
used earlier:</p>

<p style="margin-top: 1em">package File;</p>

<p style="margin-top: 1em">sub new { <br>
my $class = shift; <br>
my ( $path, $data ) = @_;</p>

<p style="margin-top: 1em">my $self = bless { <br>
path =&gt; $path, <br>
data =&gt; $data, <br>
}, $class;</p>

<p style="margin-top: 1em">return $self; <br>
}</p>

<p style="margin-top: 1em">As you can see, we&rsquo;ve
stored the path and file data in the object itself.
Remember, under the hood, this object is still just a hash.
Later, we&rsquo;ll write accessors to manipulate <br>
this data.</p>

<p style="margin-top: 1em">For our File::MP3 class, we can
check to make sure that the path we&rsquo;re given ends with
&quot;.mp3&quot;:</p>

<p style="margin-top: 1em">package File::MP3;</p>

<p style="margin-top: 1em">sub new { <br>
my $class = shift; <br>
my ( $path, $data ) = @_;</p>

<p style="margin-top: 1em">die &quot;You cannot create a
File::MP3 without an mp3 extension0 <br>
unless $path =~ /.mp3;</p>

<p style="margin-top: 1em">return
$class-&gt;SUPER::new(@_); <br>
}</p>

<p style="margin-top: 1em">This constructor lets its parent
class do the actual object construction.</p>

<p style="margin-top: 1em">Attributes <br>
An attribute is a piece of data belonging to a particular
object. Unlike most object-oriented languages, Perl provides
no special syntax or support for declaring and <br>
manipulating attributes.</p>

<p style="margin-top: 1em">Attributes are often stored in
the object itself. For example, if the object is an
anonymous hash, we can store the attribute values in the
hash using the attribute name as the <br>
key.</p>

<p style="margin-top: 1em">While it&rsquo;s possible to
refer directly to these hash keys outside of the class,
it&rsquo;s considered a best practice to wrap all access to
the attribute with accessor methods.</p>

<p style="margin-top: 1em">This has several advantages.
Accessors make it easier to change the implementation of an
object later while still preserving the original API.</p>

<p style="margin-top: 1em">An accessor lets you add
additional code around attribute access. For example, you
could apply a default to an attribute that wasn&rsquo;t set
in the constructor, or you could validate <br>
that a new value for the attribute is acceptable.</p>

<p style="margin-top: 1em">Finally, using accessors makes
inheritance much simpler. Subclasses can use the accessors
rather than having to know how a parent class is implemented
internally.</p>

<p style="margin-top: 1em">Writing Accessors</p>

<p style="margin-top: 1em">As with constructors, Perl
provides no special accessor declaration syntax, so classes
must provide explicitly written accessor methods. There are
two common types of accessors, <br>
read-only and read-write.</p>

<p style="margin-top: 1em">A simple read-only accessor
simply gets the value of a single attribute:</p>

<p style="margin-top: 1em">sub path { <br>
my $self = shift;</p>

<p style="margin-top: 1em">return $self-&gt;{path}; <br>
}</p>

<p style="margin-top: 1em">A read-write accessor will allow
the caller to set the value as well as get it:</p>

<p style="margin-top: 1em">sub path { <br>
my $self = shift;</p>

<p style="margin-top: 1em">if (@_) { <br>
$self-&gt;{path} = shift; <br>
}</p>

<p style="margin-top: 1em">return $self-&gt;{path}; <br>
}</p>

<p style="margin-top: 1em">An Aside About Smarter and Safer
Code <br>
Our constructor and accessors are not very smart. They
don&rsquo;t check that a $path is defined, nor do they check
that a $path is a valid filesystem path.</p>

<p style="margin-top: 1em">Doing these checks by hand can
quickly become tedious. Writing a bunch of accessors by hand
is also incredibly tedious. There are a lot of modules on
CPAN that can help you write <br>
safer and more concise code, including the modules we
recommend in perlootut.</p>

<p style="margin-top: 1em">Method Call Variations <br>
Perl supports several other ways to call methods besides the
&quot;$object-&gt;method()&quot; usage we&rsquo;ve seen so
far.</p>

<p style="margin-top: 1em">Method Names as Strings</p>

<p style="margin-top: 1em">Perl lets you use a scalar
variable containing a string as a method name:</p>

<p style="margin-top: 1em">my $file = File-&gt;new( $path,
$data );</p>

<p style="margin-top: 1em">my $method = &rsquo;save&rsquo;;
<br>
$file-&gt;$method();</p>

<p style="margin-top: 1em">This works exactly like calling
&quot;$file-&gt;save()&quot;. This can be very useful for
writing dynamic code. For example, it allows you to pass a
method name to be called as a parameter to <br>
another method.</p>

<p style="margin-top: 1em">Class Names as Strings</p>

<p style="margin-top: 1em">Perl also lets you use a scalar
containing a string as a class name:</p>

<p style="margin-top: 1em">my $class =
&rsquo;File&rsquo;;</p>

<p style="margin-top: 1em">my $file = $class-&gt;new(
$path, $data );</p>

<p style="margin-top: 1em">Again, this allows for very
dynamic code.</p>

<p style="margin-top: 1em">Subroutine References as
Methods</p>

<p style="margin-top: 1em">You can also use a subroutine
reference as a method:</p>

<p style="margin-top: 1em">my $sub = sub { <br>
my $self = shift;</p>

<p style="margin-top: 1em">$self-&gt;save(); <br>
};</p>

<p style="margin-top: 1em">$file-&gt;$sub();</p>

<p style="margin-top: 1em">This is exactly equivalent to
writing &quot;$sub-&gt;($file)&quot;. You may see this idiom
in the wild combined with a call to &quot;can&quot;:</p>

<p style="margin-top: 1em">if ( my $meth =
$object-&gt;can(&rsquo;foo&rsquo;) ) { <br>
$object-&gt;$meth(); <br>
}</p>

<p style="margin-top: 1em">Deferencing Method Call</p>

<p style="margin-top: 1em">Perl also lets you use a
dereferenced scalar reference in a method call. That&rsquo;s
a mouthful, so let&rsquo;s look at some code:</p>

<p style="margin-top: 1em">$file-&gt;${ &acute;save&rsquo;
}; <br>
$file-&gt;${ returns_scalar_ref() }; <br>
$file-&gt;${ returns_scalar() ) }; <br>
$file-&gt;${ returns_sub_ref() };</p>

<p style="margin-top: 1em">This works if the dereference
produces a string or a subroutine reference.</p>

<p style="margin-top: 1em">Method Calls on Filehandles</p>

<p style="margin-top: 1em">Under the hood, Perl filehandles
are instances of the &quot;IO::Handle&quot; or
&quot;IO::File&quot; class. Once you have an open
filehandle, you can call methods on it. Additionally, you
can call <br>
methods on the &quot;STDIN&quot;, &quot;STDOUT&quot;, and
&quot;STDERR&quot; filehandles.</p>

<p style="margin-top: 1em">open my $fh, &rsquo;&gt;&rsquo;,
&rsquo;path/to/file&rsquo;; <br>
$fh-&gt;autoflush(); <br>
$fh-&gt;print(&rsquo;content&rsquo;);</p>

<p style="margin-top: 1em">STDOUT-&gt;autoflush();</p>

<p style="margin-top: 1em">Invoking Class Methods <br>
Because Perl allows you to use barewords for package names
and subroutine names, it sometimes interprets a
bareword&rsquo;s meaning incorrectly. For example, the
construct <br>
&quot;Class-&gt;new()&quot; can be interpreted as either
&quot;&rsquo;Class&rsquo;-&gt;new()&quot; or
&quot;Class()-&gt;new()&quot;. In English, that second
interpretation reads as &quot;call a subroutine named
Class(), then call <br>
new() as a method on the return value of Class()&quot;. If
there is a subroutine named &quot;Class()&quot; in the
current namespace, Perl will always interpret
&quot;Class-&gt;new()&quot; as the second <br>
alternative: a call to &quot;new()&quot; on the object
returned by a call to &quot;Class()&quot;</p>

<p style="margin-top: 1em">You can force Perl to use the
first interpretation (i.e. as a method call on the class
named &quot;Class&quot;) in two ways. First, you can append
a &quot;::&quot; to the class name:</p>

<p style="margin-top: 1em">Class::-&gt;new()</p>

<p style="margin-top: 1em">Perl will always interpret this
as a method call.</p>

<p style="margin-top: 1em">Alternatively, you can quote the
class name:</p>


<p style="margin-top: 1em">&rsquo;Class&rsquo;-&gt;new()</p>

<p style="margin-top: 1em">Of course, if the class name is
in a scalar Perl will do the right thing as well:</p>

<p style="margin-top: 1em">my $class = &rsquo;Class&rsquo;;
<br>
$class-&gt;new();</p>

<p style="margin-top: 1em">Indirect Object Syntax</p>

<p style="margin-top: 1em">Outside of the file handle case,
use of this syntax is discouraged, as it can confuse the
Perl interpreter. See below for more details.</p>

<p style="margin-top: 1em">Perl suports another method
invocation syntax called &quot;indirect object&quot;
notation. This syntax is called &quot;indirect&quot; because
the method comes before the object it is being invoked <br>
on.</p>

<p style="margin-top: 1em">This syntax can be used with any
class or object method:</p>

<p style="margin-top: 1em">my $file = new File $path,
$data; <br>
save $file;</p>

<p style="margin-top: 1em">We recommend that you avoid this
syntax, for several reasons.</p>

<p style="margin-top: 1em">First, it can be confusing to
read. In the above example, it&rsquo;s not clear if
&quot;save&quot; is a method provided by the
&quot;File&quot; class or simply a subroutine that expects a
file object as <br>
its first argument.</p>

<p style="margin-top: 1em">When used with class methods,
the problem is even worse. Because Perl allows subroutine
names to be written as barewords, Perl has to guess whether
the bareword after the method <br>
is a class name or subroutine name. In other words, Perl can
resolve the syntax as either &quot;File-&gt;new( $path,
$data )&quot; or &quot;new( File( $path, $data )
)&quot;.</p>

<p style="margin-top: 1em">To parse this code, Perl uses a
heuristic based on what package names it has seen, what
subroutines exist in the current package, what barewords it
has previously seen, and other <br>
input. Needless to say, heuristics can produce very
surprising results!</p>

<p style="margin-top: 1em">Older documentation (and some
CPAN modules) encouraged this syntax, particularly for
constructors, so you may still find it in the wild. However,
we encourage you to avoid using <br>
it in new code.</p>

<p style="margin-top: 1em">You can force Perl to interpret
the bareword as a class name by appending &quot;::&quot; to
it, like we saw earlier:</p>

<p style="margin-top: 1em">my $file = new File:: $path,
$data;</p>

<p style="margin-top: 1em">&quot;bless&quot;,
&quot;blessed&quot;, and &quot;ref&quot; <br>
As we saw earlier, an object is simply a data structure that
has been blessed into a class via the &quot;bless&quot;
function. The &quot;bless&quot; function can take either one
or two arguments:</p>

<p style="margin-top: 1em">my $object = bless {}, $class;
<br>
my $object = bless {};</p>

<p style="margin-top: 1em">In the first form, the anonymous
hash is being blessed into the class in $class. In the
second form, the anonymous hash is blessed into the current
package.</p>

<p style="margin-top: 1em">The second form is strongly
discouraged, because it breaks the ability of a subclass to
reuse the parent&rsquo;s constructor, but you may still run
across it in existing code.</p>

<p style="margin-top: 1em">If you want to know whether a
particular scalar refers to an object, you can use the
&quot;blessed&quot; function exported by Scalar::Util, which
is shipped with the Perl core.</p>

<p style="margin-top: 1em">use Scalar::Util
&rsquo;blessed&rsquo;;</p>

<p style="margin-top: 1em">if ( defined blessed($thing) ) {
... }</p>

<p style="margin-top: 1em">If $thing refers to an object,
then this function returns the name of the package the
object has been blessed into. If $thing doesn&rsquo;t
contain a reference to a blessed object, the <br>
&quot;blessed&quot; function returns &quot;undef&quot;.</p>

<p style="margin-top: 1em">Note that
&quot;blessed($thing)&quot; will also return false if $thing
has been blessed into a class named &quot;0&quot;. This is a
possible, but quite pathological. Don&rsquo;t create a class
named &quot;0&quot; <br>
unless you know what you&rsquo;re doing.</p>

<p style="margin-top: 1em">Similarly, Perl&rsquo;s built-in
&quot;ref&quot; function treats a reference to a blessed
object specially. If you call &quot;ref($thing)&quot; and
$thing holds a reference to an object, it will return <br>
the name of the class that the object has been blessed
into.</p>

<p style="margin-top: 1em">If you simply want to check that
a variable contains an object reference, we recommend that
you use &quot;defined blessed($object)&quot;, since
&quot;ref&quot; returns true values for all <br>
references, not just objects.</p>

<p style="margin-top: 1em">The UNIVERSAL Class <br>
All classes automatically inherit from the UNIVERSAL class,
which is built-in to the Perl core. This class provides a
number of methods, all of which can be called on either a
<br>
class or an object. You can also choose to override some of
these methods in your class. If you do so, we recommend that
you follow the built-in semantics described below.</p>

<p style="margin-top: 1em">isa($class) <br>
The &quot;isa&quot; method returns true if the object is a
member of the class in $class, or a member of a subclass of
$class.</p>

<p style="margin-top: 1em">If you override this method, it
should never throw an exception.</p>

<p style="margin-top: 1em">DOES($role) <br>
The &quot;DOES&quot; method returns true if its object
claims to perform the role $role. By default, this is
equivalent to &quot;isa&quot;. This method is provided for
use by object system <br>
extensions that implement roles, like &quot;Moose&quot; and
&quot;Role::Tiny&quot;.</p>

<p style="margin-top: 1em">You can also override
&quot;DOES&quot; directly in your own classes. If you
override this method, it should never throw an
exception.</p>

<p style="margin-top: 1em">can($method) <br>
The &quot;can&quot; method checks to see if the class or
object it was called on has a method named $method. This
checks for the method in the class and all of its parents.
If the <br>
method exists, then a reference to the subroutine is
returned. If it does not then &quot;undef&quot; is
returned.</p>

<p style="margin-top: 1em">If your class responds to method
calls via &quot;AUTOLOAD&quot;, you may want to overload
&quot;can&quot; to return a subroutine reference for methods
which your &quot;AUTOLOAD&quot; method handles.</p>

<p style="margin-top: 1em">If you override this method, it
should never throw an exception.</p>

<p style="margin-top: 1em">VERSION($need) <br>
The &quot;VERSION&quot; method returns the version number of
the class (package).</p>

<p style="margin-top: 1em">If the $need argument is given
then it will check that the current version (as defined by
the $VERSION variable in the package) is greater than or
equal to $need; it will die <br>
if this is not the case. This method is called automatically
by the &quot;VERSION&quot; form of &quot;use&quot;.</p>

<p style="margin-top: 1em">use Package 1.2 qw(some imported
subs); <br>
# implies: <br>
Package-&gt;VERSION(1.2);</p>

<p style="margin-top: 1em">We recommend that you use this
method to access another package&rsquo;s version, rather
than looking directly at $Package::VERSION. The package you
are looking at could have <br>
overridden the &quot;VERSION&quot; method.</p>

<p style="margin-top: 1em">We also recommend using this
method to check whether a module has a sufficient version.
The internal implementation uses the version module to make
sure that different types <br>
of version numbers are compared correctly.</p>

<p style="margin-top: 1em">AUTOLOAD <br>
If you call a method that doesn&rsquo;t exist in a class,
Perl will throw an error. However, if that class or any of
its parent classes defines an &quot;AUTOLOAD&quot; method,
that &quot;AUTOLOAD&quot; <br>
method is called instead.</p>

<p style="margin-top: 1em">&quot;AUTOLOAD&quot; is called
as a regular method, and the caller will not know the
difference. Whatever value your &quot;AUTOLOAD&quot; method
returns is returned to the caller.</p>

<p style="margin-top: 1em">The fully qualified method name
that was called is available in the $AUTOLOAD package global
for your class. Since this is a global, if you want to refer
to do it without a <br>
package name prefix under &quot;strict
&rsquo;vars&rsquo;&quot;, you need to declare it.</p>

<p style="margin-top: 1em"># XXX - this is a terrible way
to implement accessors, but it makes <br>
# for a simple example. <br>
our $AUTOLOAD; <br>
sub AUTOLOAD { <br>
my $self = shift;</p>

<p style="margin-top: 1em"># Remove qualifier from original
method name... <br>
my $called = $AUTOLOAD =~ s/.*:://r;</p>

<p style="margin-top: 1em"># Is there an attribute of that
name? <br>
die &quot;No such attribute: $called&quot; <br>
unless exists $self-&gt;{$called};</p>

<p style="margin-top: 1em"># If so, return it... <br>
return $self-&gt;{$called}; <br>
}</p>

<p style="margin-top: 1em">sub DESTROY { } # see below</p>

<p style="margin-top: 1em">Without the &quot;our
$AUTOLOAD&quot; declaration, this code will not compile
under the strict pragma.</p>

<p style="margin-top: 1em">As the comment says, this is not
a good way to implement accessors. It&rsquo;s slow and too
clever by far. However, you may see this as a way to provide
accessors in older Perl code. <br>
See perlootut for recommendations on OO coding in Perl.</p>

<p style="margin-top: 1em">If your class does have an
&quot;AUTOLOAD&quot; method, we strongly recommend that you
override &quot;can&quot; in your class as well. Your
overridden &quot;can&quot; method should return a subroutine
<br>
reference for any method that your &quot;AUTOLOAD&quot;
responds to.</p>

<p style="margin-top: 1em">Destructors <br>
When the last reference to an object goes away, the object
is destroyed. If you only have one reference to an object
stored in a lexical scalar, the object is destroyed when
that <br>
scalar goes out of scope. If you store the object in a
package global, that object may not go out of scope until
the program exits.</p>

<p style="margin-top: 1em">If you want to do something when
the object is destroyed, you can define a
&quot;DESTROY&quot; method in your class. This method will
always be called by Perl at the appropriate time, <br>
unless the method is empty.</p>

<p style="margin-top: 1em">This is called just like any
other method, with the object as the first argument. It does
not receive any additional arguments. However, the $_[0]
variable will be read-only in <br>
the destructor, so you cannot assign a value to it.</p>

<p style="margin-top: 1em">If your &quot;DESTROY&quot;
method throws an error, this error will be ignored. It will
not be sent to &quot;STDERR&quot; and it will not cause the
program to die. However, if your destructor is <br>
running inside an &quot;eval {}&quot; block, then the error
will change the value of $@.</p>

<p style="margin-top: 1em">Because &quot;DESTROY&quot;
methods can be called at any time, you should localize any
global variables you might update in your
&quot;DESTROY&quot;. In particular, if you use &quot;eval
{}&quot; you should <br>
localize $@, and if you use &quot;system&quot; or backticks,
you should localize $?.</p>

<p style="margin-top: 1em">If you define an
&quot;AUTOLOAD&quot; in your class, then Perl will call your
&quot;AUTOLOAD&quot; to handle the &quot;DESTROY&quot;
method. You can prevent this by defining an empty
&quot;DESTROY&quot;, like we did in <br>
the autoloading example. You can also check the value of
$AUTOLOAD and return without doing anything when called to
handle &quot;DESTROY&quot;.</p>

<p style="margin-top: 1em">Global Destruction</p>

<p style="margin-top: 1em">The order in which objects are
destroyed during the global destruction before the program
exits is unpredictable. This means that any objects
contained by your object may already <br>
have been destroyed. You should check that a contained
object is defined before calling a method on it:</p>

<p style="margin-top: 1em">sub DESTROY { <br>
my $self = shift;</p>

<p style="margin-top: 1em">$self-&gt;{handle}-&gt;close()
if $self-&gt;{handle}; <br>
}</p>

<p style="margin-top: 1em">You can use the
&quot;${^GLOBAL_PHASE}&quot; variable to detect if you are
currently in the global destruction phase:</p>

<p style="margin-top: 1em">sub DESTROY { <br>
my $self = shift;</p>

<p style="margin-top: 1em">return if ${^GLOBAL_PHASE} eq
&rsquo;DESTRUCT&rsquo;;</p>

<p style="margin-top: 1em">$self-&gt;{handle}-&gt;close();
<br>
}</p>

<p style="margin-top: 1em">Note that this variable was
added in Perl 5.14.0. If you want to detect the global
destruction phase on older versions of Perl, you can use the
&quot;Devel::GlobalDestruction&quot; module <br>
on CPAN.</p>

<p style="margin-top: 1em">If your &quot;DESTROY&quot;
method issues a warning during global destruction, the Perl
interpreter will append the string &quot; during global
destruction&quot; the warning.</p>

<p style="margin-top: 1em">During global destruction, Perl
will always garbage collect objects before unblessed
references. See &quot;PERL_DESTRUCT_LEVEL&quot; in
perlhacktips for more information about global <br>
destruction.</p>

<p style="margin-top: 1em">Non-Hash Objects <br>
All the examples so far have shown objects based on a
blessed hash. However, it&rsquo;s possible to bless any type
of data structure or referent, including scalars, globs, and
<br>
subroutines. You may see this sort of thing when looking at
code in the wild.</p>

<p style="margin-top: 1em">Here&rsquo;s an example of a
module as a blessed scalar:</p>

<p style="margin-top: 1em">package Time;</p>

<p style="margin-top: 1em">use strict; <br>
use warnings;</p>

<p style="margin-top: 1em">sub new { <br>
my $class = shift;</p>

<p style="margin-top: 1em">my $time = time; <br>
return bless ime, $class; <br>
}</p>

<p style="margin-top: 1em">sub epoch { <br>
my $self = shift; <br>
return ${ $self }; <br>
}</p>

<p style="margin-top: 1em">my $time = Time-&gt;new(); <br>
print $time-&gt;epoch();</p>

<p style="margin-top: 1em">Inside-Out objects <br>
In the past, the Perl community experimented with a
technique called &quot;inside-out objects&quot;. An
inside-out object stores its data outside of the
object&rsquo;s reference, indexed on a <br>
unique property of the object, such as its memory address,
rather than in the object itself. This has the advantage of
enforcing the encapsulation of object attributes, since <br>
their data is not stored in the object itself.</p>

<p style="margin-top: 1em">This technique was popular for a
while (and was recommended in Damian Conway&rsquo;s Perl
Best Practices), but never achieved universal adoption. The
Object::InsideOut module on CPAN <br>
provides a comprehensive implementation of this technique,
and you may see it or other inside-out modules in the
wild.</p>

<p style="margin-top: 1em">Here is a simple example of the
technique, using the Hash::Util::FieldHash core module. This
module was added to the core to support inside-out object
implementations.</p>

<p style="margin-top: 1em">package Time;</p>

<p style="margin-top: 1em">use strict; <br>
use warnings;</p>

<p style="margin-top: 1em">use Hash::Util::FieldHash
&rsquo;fieldhash&rsquo;;</p>

<p style="margin-top: 1em">fieldhash my %time_for;</p>

<p style="margin-top: 1em">sub new { <br>
my $class = shift;</p>

<p style="margin-top: 1em">my $self = bless my $object ),
$class;</p>

<p style="margin-top: 1em">$time_for{$self} = time;</p>

<p style="margin-top: 1em">return $self; <br>
}</p>

<p style="margin-top: 1em">sub epoch { <br>
my $self = shift;</p>

<p style="margin-top: 1em">return $time_for{$self}; <br>
}</p>

<p style="margin-top: 1em">my $time = Time-&gt;new; <br>
print $time-&gt;epoch;</p>

<p style="margin-top: 1em">Pseudo-hashes <br>
The pseudo-hash feature was an experimental feature
introduced in earlier versions of Perl and removed in
5.10.0. A pseudo-hash is an array reference which can be
accessed using <br>
named keys like a hash. You may run in to some code in the
wild which uses it. See the fields pragma for more
information.</p>

<p style="margin-top: 1em">SEE ALSO <br>
A kinder, gentler tutorial on object-oriented programming in
Perl can be found in perlootut. You should also check out
perlmodlib for some style guides on constructing both <br>
modules and classes.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLOBJ(1)</p>
<hr>
</body>
</html>
