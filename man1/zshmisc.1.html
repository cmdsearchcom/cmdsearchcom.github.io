<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:45:00 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>ZSHMISC(1) General Commands Manual ZSHMISC(1)</p>

<p style="margin-top: 1em">NAME <br>
zshmisc - everything and then some</p>

<p style="margin-top: 1em">SIMPLE COMMANDS &amp; PIPELINES
<br>
A simple command is a sequence of optional parameter
assignments followed by blank-separated words, with optional
redirections interspersed. The first word is the command to
be <br>
executed, and the remaining words, if any, are arguments to
the command. If a command name is given, the parameter
assignments modify the environment of the command when it is
<br>
executed. The value of a simple command is its exit status,
or 128 plus the signal number if terminated by a signal. For
example,</p>

<p style="margin-top: 1em">echo foo</p>

<p style="margin-top: 1em">is a simple command with
arguments.</p>

<p style="margin-top: 1em">A pipeline is either a simple
command, or a sequence of two or more simple commands where
each command is separated from the next by &lsquo;|&rsquo;
or &lsquo;|&amp;&rsquo;. Where commands are separated by
<br>
&lsquo;|&rsquo;, the standard output of the first command is
connected to the standard input of the next.
&lsquo;|&amp;&rsquo; is shorthand for &lsquo;2&gt;&amp;1
|&rsquo;, which connects both the standard output and the
<br>
standard error of the command to the standard input of the
next. The value of a pipeline is the value of the last
command, unless the pipeline is preceded by &lsquo;!&rsquo;
in which case <br>
the value is the logical inverse of the value of the last
command. For example,</p>

<p style="margin-top: 1em">echo foo | sed
&rsquo;s/foo/bar/&rsquo;</p>

<p style="margin-top: 1em">is a pipeline, where the output
(&lsquo;foo&rsquo; plus a newline) of the first command will
be passed to the input of the second.</p>

<p style="margin-top: 1em">If a pipeline is preceded by
&lsquo;coproc&rsquo;, it is executed as a coprocess; a
two-way pipe is established between it and the parent shell.
The shell can read from or write to the <br>
coprocess by means of the &lsquo;&gt;&amp;p&rsquo; and
&lsquo;&lt;&amp;p&rsquo; redirection operators or with
&lsquo;print -p&rsquo; and &lsquo;read -p&rsquo;. A pipeline
cannot be preceded by both &lsquo;coproc&rsquo; and
&lsquo;!&rsquo;. If job control is <br>
active, the coprocess can be treated in other than input and
output as an ordinary background job.</p>

<p style="margin-top: 1em">A sublist is either a single
pipeline, or a sequence of two or more pipelines separated
by &lsquo;&amp;&amp;&rsquo; or &lsquo;||&rsquo;. If two
pipelines are separated by &lsquo;&amp;&amp;&rsquo;, the
second pipeline is executed <br>
only if the first succeeds (returns a zero status). If two
pipelines are separated by &lsquo;||&rsquo;, the second is
executed only if the first fails (returns a nonzero status).
Both <br>
operators have equal precedence and are left associative.
The value of the sublist is the value of the last pipeline
executed. For example,</p>

<p style="margin-top: 1em">dmesg | grep panic &amp;&amp;
print yes</p>

<p style="margin-top: 1em">is a sublist consisting of two
pipelines, the second just a simple command which will be
executed if and only if the grep command returns a zero
status. If it does not, the <br>
value of the sublist is that return status, else it is the
status returned by the print (almost certainly zero).</p>

<p style="margin-top: 1em">A list is a sequence of zero or
more sublists, in which each sublist is terminated by
&lsquo;;&rsquo;, &lsquo;&amp;&rsquo;, &lsquo;&amp;|&rsquo;,
&lsquo;&amp;!&rsquo;, or a newline. This terminator may
optionally be omitted from the last <br>
sublist in the list when the list appears as a complex
command inside &lsquo;(...)&rsquo; or &lsquo;{...}&rsquo;.
When a sublist is terminated by &lsquo;;&rsquo; or newline,
the shell waits for it to finish before <br>
executing the next sublist. If a sublist is terminated by a
&lsquo;&amp;&rsquo;, &lsquo;&amp;|&rsquo;, or
&lsquo;&amp;!&rsquo;, the shell executes the last pipeline
in it in the background, and does not wait for it to finish
<br>
(note the difference from other shells which execute the
whole sublist in the background). A backgrounded pipeline
returns a status of zero.</p>

<p style="margin-top: 1em">More generally, a list can be
seen as a set of any shell commands whatsoever, including
the complex commands below; this is implied wherever the
word &lsquo;list&rsquo; appears in later <br>
descriptions. For example, the commands in a shell function
form a special sort of list.</p>

<p style="margin-top: 1em">PRECOMMAND MODIFIERS <br>
A simple command may be preceded by a precommand modifier,
which will alter how the command is interpreted. These
modifiers are shell builtin commands with the exception of
<br>
nocorrect which is a reserved word.</p>

<p style="margin-top: 1em">- The command is executed with a
&lsquo;-&rsquo; prepended to its argv[0] string.</p>

<p style="margin-top: 1em">builtin <br>
The command word is taken to be the name of a builtin
command, rather than a shell function or external
command.</p>

<p style="margin-top: 1em">command [ -pvV ] <br>
The command word is taken to be the name of an external
command, rather than a shell function or builtin. If the
POSIX_BUILTINS option is set, builtins will also be
exe&acirc; <br>
cuted but certain special properties of them are suppressed.
The -p flag causes a default path to be searched instead of
that in $path. With the -v flag, command is simi&acirc; <br>
lar to whence and with -V, it is equivalent to whence
-v.</p>

<p style="margin-top: 1em">exec [ -cl ] [ -a argv0 ] <br>
The following command together with any arguments is run in
place of the current process, rather than as a sub-process.
The shell does not fork and is replaced. The <br>
shell does not invoke TRAPEXIT, nor does it source zlogout
files. The options are provided for compatibility with other
shells.</p>

<p style="margin-top: 1em">The -c option clears the
environment.</p>

<p style="margin-top: 1em">The -l option is equivalent to
the - precommand modifier, to treat the replacement command
as a login shell; the command is executed with a - prepended
to its argv[0] <br>
string. This flag has no effect if used together with the -a
option.</p>

<p style="margin-top: 1em">The -a option is used to specify
explicitly the argv[0] string (the name of the command as
seen by the process itself) to be used by the replacement
command and is <br>
directly equivalent to setting a value for the ARGV0
environment variable.</p>

<p style="margin-top: 1em">nocorrect <br>
Spelling correction is not done on any of the words. This
must appear before any other precommand modifier, as it is
interpreted immediately, before any parsing is done. <br>
It has no effect in non-interactive shells.</p>

<p style="margin-top: 1em">noglob Filename generation
(globbing) is not performed on any of the words.</p>

<p style="margin-top: 1em">COMPLEX COMMANDS <br>
A complex command in zsh is one of the following:</p>

<p style="margin-top: 1em">if list then list [ elif list
then list ] ... [ else list ] fi <br>
The if list is executed, and if it returns a zero exit
status, the then list is executed. Otherwise, the elif list
is executed and if its status is zero, the then list is <br>
executed. If each elif list returns nonzero status, the else
list is executed.</p>

<p style="margin-top: 1em">for name ... [ in word ... ]
term do list done <br>
where term is at least one newline or ;. Expand the list of
words, and set the parameter name to each of them in turn,
executing list each time. If the in word is omit&acirc; <br>
ted, use the positional parameters instead of the words.</p>

<p style="margin-top: 1em">More than one parameter name can
appear before the list of words. If N names are given, then
on each execution of the loop the next N words are assigned
to the corre&acirc; <br>
sponding parameters. If there are more names than remaining
words, the remaining parameters are each set to the empty
string. Execution of the loop ends when there is no <br>
remaining word to assign to the first name. It is only
possible for in to appear as the first name in the list,
else it will be treated as marking the end of the list.</p>

<p style="margin-top: 1em">for (( [expr1] ; [expr2] ;
[expr3] )) do list done <br>
The arithmetic expression expr1 is evaluated first (see the
section &lsquo;Arithmetic Evaluation&rsquo;). The arithmetic
expression expr2 is repeatedly evaluated until it evaluates
<br>
to zero and when non-zero, list is executed and the
arithmetic expression expr3 evaluated. If any expression is
omitted, then it behaves as if it evaluated to 1.</p>

<p style="margin-top: 1em">while list do list done <br>
Execute the do list as long as the while list returns a zero
exit status.</p>

<p style="margin-top: 1em">until list do list done <br>
Execute the do list as long as until list returns a nonzero
exit status.</p>

<p style="margin-top: 1em">repeat word do list done <br>
word is expanded and treated as an arithmetic expression,
which must evaluate to a number n. list is then executed n
times.</p>

<p style="margin-top: 1em">The repeat syntax is disabled by
default when the shell starts in a mode emulating another
shell. It can be enabled with the command &lsquo;enable -r
repeat&rsquo;</p>

<p style="margin-top: 1em">case word in [ [(] pattern [ |
pattern ] ... ) list (;;|;&amp;|;|) ] ... esac <br>
Execute the list associated with the first pattern that
matches word, if any. The form of the patterns is the same
as that used for filename generation. See the section <br>
&lsquo;Filename Generation&rsquo;.</p>

<p style="margin-top: 1em">If the list that is executed is
terminated with ;&amp; rather than ;;, the following list is
also executed. The rule for the terminator of the following
list ;;, ;&amp; or ;| is <br>
applied unless the esac is reached.</p>

<p style="margin-top: 1em">If the list that is executed is
terminated with ;| the shell continues to scan the patterns
looking for the next match, executing the corresponding
list, and applying the <br>
rule for the corresponding terminator ;;, ;&amp; or ;|. Note
that word is not re-expanded; all applicable patterns are
tested with the same word.</p>

<p style="margin-top: 1em">select name [ in word ... term ]
do list done <br>
where term is one or more newline or ; to terminate the
words. Print the set of words, each preceded by a number. If
the in word is omitted, use the positional parame&acirc;
<br>
ters. The PROMPT3 prompt is printed and a line is read from
the line editor if the shell is interactive and that is
active, or else standard input. If this line consists <br>
of the number of one of the listed words, then the parameter
name is set to the word corresponding to this number. If
this line is empty, the selection list is printed <br>
again. Otherwise, the value of the parameter name is set to
null. The contents of the line read from standard input is
saved in the parameter REPLY. list is executed <br>
for each selection until a break or end-of-file is
encountered.</p>

<p style="margin-top: 1em">( list ) <br>
Execute list in a subshell. Traps set by the trap builtin
are reset to their default values while executing list.</p>

<p style="margin-top: 1em">{ list } <br>
Execute list.</p>

<p style="margin-top: 1em">{ try-list } always {
always-list } <br>
First execute try-list. Regardless of errors, or break,
continue, or return commands encountered within try-list,
execute always-list. Execution then continues from the <br>
result of the execution of try-list; in other words, any
error, or break, continue, or return command is treated in
the normal way, as if always-list were not present. <br>
The two chunks of code are referred to as the &lsquo;try
block&rsquo; and the &lsquo;always block&rsquo;.</p>

<p style="margin-top: 1em">Optional newlines or semicolons
may appear after the always; note, however, that they may
not appear between the preceding closing brace and the
always.</p>

<p style="margin-top: 1em">An &lsquo;error&rsquo; in this
context is a condition such as a syntax error which causes
the shell to abort execution of the current function,
script, or list. Syntax errors encoun&acirc; <br>
tered while the shell is parsing the code do not cause the
always-list to be executed. For example, an erroneously
constructed if block in try-list would cause the shell <br>
to abort during parsing, so that always-list would not be
executed, while an erroneous substitution such as ${*foo*}
would cause a run-time error, after which always-list <br>
would be executed.</p>

<p style="margin-top: 1em">An error condition can be tested
and reset with the special integer variable TRY_BLOCK_ERROR.
Outside an always-list the value is irrelevant, but it is
initialised to -1. <br>
Inside always-list, the value is 1 if an error occurred in
the try-list, else 0. If TRY_BLOCK_ERROR is set to 0 during
the always-list, the error condition caused by the <br>
try-list is reset, and shell execution continues normally
after the end of always-list. Altering the value during the
try-list is not useful (unless this forms part of an <br>
enclosing always block).</p>

<p style="margin-top: 1em">Regardless of TRY_BLOCK_ERROR,
after the end of always-list the normal shell status $? is
the value returned from always-list. This will be non-zero
if there was an <br>
error, even if TRY_BLOCK_ERROR was set to zero.</p>

<p style="margin-top: 1em">The following executes the given
code, ignoring any errors it causes. This is an alternative
to the usual convention of protecting code by executing it
in a subshell.</p>

<p style="margin-top: 1em">{ <br>
# code which may cause an error <br>
} always { <br>
# This code is executed regardless of the error. <br>
(( TRY_BLOCK_ERROR = 0 )) <br>
} <br>
# The error condition has been reset.</p>

<p style="margin-top: 1em">An exit command (or a return
command executed at the outermost function level of a
script) encountered in try-list does not cause the execution
of always-list. Instead, <br>
the shell exits immediately after any EXIT trap has been
executed.</p>

<p style="margin-top: 1em">function word ... [ () ] [ term
] { list } <br>
word ... () [ term ] { list } <br>
word ... () [ term ] command <br>
where term is one or more newline or ;. Define a function
which is referenced by any one of word. Normally, only one
word is provided; multiple words are usually only <br>
useful for setting traps. The body of the function is the
list between the { and }. See the section
&lsquo;Functions&rsquo;.</p>

<p style="margin-top: 1em">If the option SH_GLOB is set for
compatibility with other shells, then whitespace may appear
between between the left and right parentheses when there is
a single word; <br>
otherwise, the parentheses will be treated as forming a
globbing pattern in that case.</p>

<p style="margin-top: 1em">time [ pipeline ] <br>
The pipeline is executed, and timing statistics are reported
on the standard error in the form specified by the TIMEFMT
parameter. If pipeline is omitted, print statis&acirc; <br>
tics about the shell process and its children.</p>

<p style="margin-top: 1em">[[ exp ]] <br>
Evaluates the conditional expression exp and return a zero
exit status if it is true. See the section
&lsquo;Conditional Expressions&rsquo; for a description of
exp.</p>

<p style="margin-top: 1em">ALTERNATE FORMS FOR COMPLEX
COMMANDS <br>
Many of zsh&rsquo;s complex commands have alternate forms.
These are non-standard and are likely not to be obvious even
to seasoned shell programmers; they should not be used
anywhere <br>
that portability of shell code is a concern.</p>

<p style="margin-top: 1em">The short versions below only
work if sublist is of the form &lsquo;{ list }&rsquo; or if
the SHORT_LOOPS option is set. For the if, while and until
commands, in both these cases the test <br>
part of the loop must also be suitably delimited, such as by
&lsquo;[[ ... ]]&rsquo; or &lsquo;(( ... ))&rsquo;, else the
end of the test will not be recognized. For the for, repeat,
case and select <br>
commands no such special form for the arguments is
necessary, but the other condition (the special form of
sublist or use of the SHORT_LOOPS option) still applies.</p>

<p style="margin-top: 1em">if list { list } [ elif list {
list } ] ... [ else { list } ] <br>
An alternate form of if. The rules mean that</p>

<p style="margin-top: 1em">if [[ -o ignorebraces ]] { <br>
print yes <br>
}</p>

<p style="margin-top: 1em">works, but</p>

<p style="margin-top: 1em">if true { # Does not work! <br>
print yes <br>
}</p>

<p style="margin-top: 1em">does not, since the test is not
suitably delimited.</p>

<p style="margin-top: 1em">if list sublist <br>
A short form of the alternate &lsquo;if&rsquo;. The same
limitations on the form of list apply as for the previous
form.</p>

<p style="margin-top: 1em">for name ... ( word ... )
sublist <br>
A short form of for.</p>

<p style="margin-top: 1em">for name ... [ in word ... ]
term sublist <br>
where term is at least one newline or ;. Another short form
of for.</p>

<p style="margin-top: 1em">for (( [expr1] ; [expr2] ;
[expr3] )) sublist <br>
A short form of the arithmetic for command.</p>

<p style="margin-top: 1em">foreach name ... ( word ... )
list end <br>
Another form of for.</p>

<p style="margin-top: 1em">while list { list } <br>
An alternative form of while. Note the limitations on the
form of list mentioned above.</p>

<p style="margin-top: 1em">until list { list } <br>
An alternative form of until. Note the limitations on the
form of list mentioned above.</p>

<p style="margin-top: 1em">repeat word sublist <br>
This is a short form of repeat.</p>

<p style="margin-top: 1em">case word { [ [(] pattern [ |
pattern ] ... ) list (;;|;&amp;|;|) ] ... } <br>
An alternative form of case.</p>

<p style="margin-top: 1em">select name [ in word term ]
sublist <br>
where term is at least one newline or ;. A short form of
select.</p>

<p style="margin-top: 1em">RESERVED WORDS <br>
The following words are recognized as reserved words when
used as the first word of a command unless quoted or
disabled using disable -r:</p>

<p style="margin-top: 1em">do done esac then elif else fi
for case if while function repeat time until select coproc
nocorrect foreach end ! [[ { }</p>

<p style="margin-top: 1em">Additionally, &lsquo;}&rsquo; is
recognized in any position if neither the IGNORE_BRACES
option nor the IGNORE_CLOSE_BRACES option is set.</p>

<p style="margin-top: 1em">ERRORS <br>
Certain errors are treated as fatal by the shell: in an
interactive shell, they cause control to return to the
command line, and in a non-interactive shell they cause the
shell <br>
to be aborted. In older versions of zsh, a non-interactive
shell running a script would not abort completely, but would
resume execution at the next command to be read from the
<br>
script, skipping the remainder of any functions or shell
constructs such as loops or conditions; this somewhat
illogical behaviour can be recovered by setting the option
CON&acirc; <br>
TINUE_ON_ERROR.</p>

<p style="margin-top: 1em">Fatal errors found in
non-interactive shells include: <br>
Failure to parse shell options passed when invoking the
shell <br>
Failure to change options with the set builtin <br>
Parse errors of all sorts, including failures to parse <br>
mathematical expressions <br>
Failures to set or modify variable behaviour with typeset,
<br>
local, declare, export, integer, float <br>
Execution of incorrectly positioned loop control structures
<br>
(continue, break) <br>
Attempts to use regular expression with no regular
expression <br>
module available <br>
Disallowed operations when the RESTRICTED options is set
<br>
Failure to create a pipe needed for a pipeline <br>
Failure to create a multio <br>
Failure to autoload a module needed for a declared shell
feature <br>
Errors creating command or process substitutions <br>
Syntax errors in glob qualifiers <br>
File generation errors where not caught by the option
BAD_PATTERN <br>
All bad patterns used for matching within case statements
<br>
File generation failures where not caused by NO_MATCH or
<br>
All file generation errors where the pattern was used to
create a <br>
multio <br>
Memory errors where detected by the shell <br>
Invalid subscripts to shell variables <br>
Attempts to assign read-only variables <br>
Logical errors with variables such as assignment to the
wrong type <br>
Use of invalid variable names <br>
Errors in variable substitution syntax <br>
Failure to convert characters in $&rsquo;...&rsquo;
expressions <br>
similar options</p>

<p style="margin-top: 1em">If the POSIX_BUILTINS option is
set, more errors associated with shell builtin commands are
treated as fatal, as specified by the POSIX standard.</p>

<p style="margin-top: 1em">COMMENTS <br>
In non-interactive shells, or in interactive shells with the
INTERACTIVE_COMMENTS option set, a word beginning with the
third character of the histchars parameter (&lsquo;#&rsquo;
by <br>
default) causes that word and all the following characters
up to a newline to be ignored.</p>

<p style="margin-top: 1em">ALIASING <br>
Every token in the shell input is checked to see if there is
an alias defined for it. If so, it is replaced by the text
of the alias if it is in command position (if it could be
<br>
the first word of a simple command), or if the alias is
global. If the text ends with a space, the next word in the
shell input is treated as though it were in command position
<br>
for purposes of alias expansion. An alias is defined using
the alias builtin; global aliases may be defined using the
-g option to that builtin.</p>

<p style="margin-top: 1em">Alias expansion is done on the
shell input before any other expansion except history
expansion. Therefore, if an alias is defined for the word
foo, alias expansion may be <br>
avoided by quoting part of the word, e.g. o. Any form of
quoting works, although there is nothing to prevent an alias
being defined for the quoted form such as o as well. <br>
For use with completion, which would remove an initial
backslash followed by a character that isn&rsquo;t special,
it may be more convenient to quote the word by starting with
a single <br>
quote, i.e. &rsquo;foo; completion will automatically add
the trailing single quote.</p>

<p style="margin-top: 1em">There is a commonly encountered
problem with aliases illustrated by the following code:</p>

<p style="margin-top: 1em">alias echobar=&rsquo;echo
bar&rsquo;; echobar</p>

<p style="margin-top: 1em">This prints a message that the
command echobar could not be found. This happens because
aliases are expanded when the code is read in; the entire
line is read in one go, so that <br>
when echobar is executed it is too late to expand the newly
defined alias. This is often a problem in shell scripts,
functions, and code executed with &lsquo;source&rsquo; or
&lsquo;.&rsquo;. Conse&acirc; <br>
quently, use of functions rather than aliases is recommended
in non-interactive code.</p>

<p style="margin-top: 1em">Note also the unhelpful
interaction of aliases and function definitions:</p>

<p style="margin-top: 1em">alias func=&rsquo;noglob
func&rsquo; <br>
func() { <br>
echo Do something with $* <br>
}</p>

<p style="margin-top: 1em">Because aliases are expanded in
function definitions, this causes the following command to
be executed:</p>

<p style="margin-top: 1em">noglob func() { <br>
echo Do something with $* <br>
}</p>

<p style="margin-top: 1em">which defines noglob as well as
func as functions with the body given. To avoid this, either
quote the name func or use the alternative function
definition form &lsquo;function func&rsquo;. <br>
Ensuring the alias is defined after the function works but
is problematic if the code fragment might be
re-executed.</p>

<p style="margin-top: 1em">QUOTING <br>
A character may be quoted (that is, made to stand for
itself) by preceding it with a &lsquo;&acute;.
&lsquo;&acute; followed by a newline is ignored.</p>

<p style="margin-top: 1em">A string enclosed between
&lsquo;$&rsquo;&rsquo; and &lsquo;&rsquo;&rsquo; is
processed the same way as the string arguments of the print
builtin, and the resulting string is considered to be
entirely quoted. A <br>
literal &lsquo;&rsquo;&rsquo; character can be included in
the string by using the &lsquo;&acute;&rsquo; escape.</p>

<p style="margin-top: 1em">All characters enclosed between
a pair of single quotes (&rsquo;&rsquo;) that is not
preceded by a &lsquo;$&rsquo; are quoted. A single quote
cannot appear within single quotes unless the option <br>
RC_QUOTES is set, in which case a pair of single quotes are
turned into a single quote. For example,</p>

<p style="margin-top: 1em">print
&rsquo;&rsquo;&rsquo;&rsquo;</p>

<p style="margin-top: 1em">outputs nothing apart from a
newline if RC_QUOTES is not set, but one single quote if it
is set.</p>

<p style="margin-top: 1em">Inside double quotes
(&quot;&quot;), parameter and command substitution occur,
and &lsquo;&acute; quotes the characters &lsquo;&acute;,
&lsquo;&lsquo;&rsquo;, &lsquo;&quot;&rsquo;, and
&lsquo;$&rsquo;.</p>

<p style="margin-top: 1em">REDIRECTION <br>
If a command is followed by &amp; and job control is not
active, then the default standard input for the command is
the empty file /dev/null. Otherwise, the environment for the
exe&acirc; <br>
cution of a command contains the file descriptors of the
invoking shell as modified by input/output
specifications.</p>

<p style="margin-top: 1em">The following may appear
anywhere in a simple command or may precede or follow a
complex command. Expansion occurs before word or digit is
used except as noted below. If the <br>
result of substitution on word produces more than one
filename, redirection occurs for each separate filename in
turn.</p>

<p style="margin-top: 1em">&lt; word Open file word for
reading as standard input.</p>

<p style="margin-top: 1em">&lt;&gt; word <br>
Open file word for reading and writing as standard input. If
the file does not exist then it is created.</p>

<p style="margin-top: 1em">&gt; word Open file word for
writing as standard output. If the file does not exist then
it is created. If the file exists, and the CLOBBER option is
unset, this causes an error; <br>
otherwise, it is truncated to zero length.</p>

<p style="margin-top: 1em">&gt;| word <br>
&gt;! word <br>
Same as &gt;, except that the file is truncated to zero
length if it exists, even if CLOBBER is unset.</p>

<p style="margin-top: 1em">&gt;&gt; word <br>
Open file word for writing in append mode as standard
output. If the file does not exist, and the CLOBBER option
is unset, this causes an error; otherwise, the file is <br>
created.</p>

<p style="margin-top: 1em">&gt;&gt;| word <br>
&gt;&gt;! word <br>
Same as &gt;&gt;, except that the file is created if it does
not exist, even if CLOBBER is unset.</p>

<p style="margin-top: 1em">&lt;&lt;[-] word <br>
The shell input is read up to a line that is the same as
word, or to an end-of-file. No parameter expansion, command
substitution or filename generation is performed on <br>
word. The resulting document, called a here-document,
becomes the standard input.</p>

<p style="margin-top: 1em">If any character of word is
quoted with single or double quotes or a &lsquo;&acute;, no
interpretation is placed upon the characters of the
document. Otherwise, parameter and com&acirc; <br>
mand substitution occurs, &lsquo;&acute; followed by a
newline is removed, and &lsquo;&acute; must be used to quote
the characters &lsquo;&acute;, &lsquo;$&rsquo;,
&lsquo;&lsquo;&rsquo; and the first character of word.</p>

<p style="margin-top: 1em">Note that word itself does not
undergo shell expansion. Backquotes in word do not have
their usual effect; instead they behave similarly to double
quotes, except that the <br>
backquotes themselves are passed through unchanged. (This
information is given for completeness and it is not
recommended that backquotes be used.) Quotes in the form
<br>
$&rsquo;...&rsquo; have their standard effect of expanding
backslashed references to special characters.</p>

<p style="margin-top: 1em">If &lt;&lt;- is used, then all
leading tabs are stripped from word and from the
document.</p>

<p style="margin-top: 1em">&lt;&lt;&lt; word <br>
Perform shell expansion on word and pass the result to
standard input. This is known as a here-string. Compare the
use of word in here-documents above, where word does <br>
not undergo shell expansion.</p>

<p style="margin-top: 1em">&lt;&amp; number <br>
&gt;&amp; number <br>
The standard input/output is duplicated from file descriptor
number (see dup2(2)).</p>

<p style="margin-top: 1em">&lt;&amp; - <br>
&gt;&amp; - Close the standard input/output.</p>

<p style="margin-top: 1em">&lt;&amp; p <br>
&gt;&amp; p The input/output from/to the coprocess is moved
to the standard input/output.</p>

<p style="margin-top: 1em">&gt;&amp; word <br>
&amp;&gt; word <br>
(Except where &lsquo;&gt;&amp; word&rsquo; matches one of
the above syntaxes; &lsquo;&amp;&gt;&rsquo; can always be
used to avoid this ambiguity.) Redirects both standard
output and standard error (file <br>
descriptor 2) in the manner of &lsquo;&gt; word&rsquo;. Note
that this does not have the same effect as &lsquo;&gt; word
2&gt;&amp;1&rsquo; in the presence of multios (see the
section below).</p>

<p style="margin-top: 1em">&gt;&amp;| word <br>
&gt;&amp;! word <br>
&amp;&gt;| word <br>
&amp;&gt;! word <br>
Redirects both standard output and standard error (file
descriptor 2) in the manner of &lsquo;&gt;| word&rsquo;.</p>

<p style="margin-top: 1em">&gt;&gt;&amp; word <br>
&amp;&gt;&gt; word <br>
Redirects both standard output and standard error (file
descriptor 2) in the manner of &lsquo;&gt;&gt;
word&rsquo;.</p>

<p style="margin-top: 1em">&gt;&gt;&amp;| word <br>
&gt;&gt;&amp;! word <br>
&amp;&gt;&gt;| word <br>
&amp;&gt;&gt;! word <br>
Redirects both standard output and standard error (file
descriptor 2) in the manner of &lsquo;&gt;&gt;|
word&rsquo;.</p>

<p style="margin-top: 1em">If one of the above is preceded
by a digit, then the file descriptor referred to is that
specified by the digit instead of the default 0 or 1. The
order in which redirections <br>
are specified is significant. The shell evaluates each
redirection in terms of the (file descriptor, file)
association at the time of evaluation. For example:</p>

<p style="margin-top: 1em">... 1&gt;fname 2&gt;&amp;1</p>

<p style="margin-top: 1em">first associates file descriptor
1 with file fname. It then associates file descriptor 2 with
the file associated with file descriptor 1 (that is, fname).
If the order of redi&acirc; <br>
rections were reversed, file descriptor 2 would be
associated with the terminal (assuming file descriptor 1 had
been) and then file descriptor 1 would be associated with
file <br>
fname.</p>

<p style="margin-top: 1em">The &lsquo;|&amp;&rsquo; command
separator described in Simple Commands &amp; Pipelines in
zshmisc(1) is a shorthand for &lsquo;2&gt;&amp;1
|&rsquo;.</p>

<p style="margin-top: 1em">The various forms of process
substitution, &lsquo;&lt;(list)&rsquo;, and
&lsquo;=(list())&rsquo; for input and
&lsquo;&gt;(list)&rsquo; for output, are often used together
with redirection. For example, if word in an <br>
output redirection is of the form &lsquo;&gt;(list)&rsquo;
then the output is piped to the command represented by list.
See Process Substitution in zshexpn(1).</p>

<p style="margin-top: 1em">OPENING FILE DESCRIPTORS USING
PARAMETERS <br>
When the shell is parsing arguments to a command, and the
shell option IGNORE_BRACES is not set, a different form of
redirection is allowed: instead of a digit before the
opera&acirc; <br>
tor there is a valid shell identifier enclosed in braces.
The shell will open a new file descriptor that is guaranteed
to be at least 10 and set the parameter named by the
iden&acirc; <br>
tifier to the file descriptor opened. No whitespace is
allowed between the closing brace and the redirection
character. For example:</p>

<p style="margin-top: 1em">... {myfd}&gt;&amp;1</p>

<p style="margin-top: 1em">This opens a new file descriptor
that is a duplicate of file descriptor 1 and sets the
parameter myfd to the number of the file descriptor, which
will be at least 10. The new <br>
file descriptor can be written to using the syntax
&gt;&amp;$myfd.</p>

<p style="margin-top: 1em">The syntax {varid}&gt;&amp;-,
for example {myfd}&gt;&amp;-, may be used to close a file
descriptor opened in this fashion. Note that the parameter
given by varid must previously be set to a <br>
file descriptor in this case.</p>

<p style="margin-top: 1em">It is an error to open or close
a file descriptor in this fashion when the parameter is
readonly. However, it is not an error to read or write a
file descriptor using &lt;&amp;$param <br>
or &gt;&amp;$param if param is readonly.</p>

<p style="margin-top: 1em">If the option CLOBBER is unset,
it is an error to open a file descriptor using a parameter
that is already set to an open file descriptor previously
allocated by this mechanism. <br>
Unsetting the parameter before using it for allocating a
file descriptor avoids the error.</p>

<p style="margin-top: 1em">Note that this mechanism merely
allocates or closes a file descriptor; it does not perform
any redirections from or to it. It is usually convenient to
allocate a file descriptor <br>
prior to use as an argument to exec. The syntax does not in
any case work when used around complex commands such as
parenthesised subshells or loops, where the opening brace is
<br>
interpreted as part of a command list to be executed in the
current shell.</p>

<p style="margin-top: 1em">The following shows a typical
sequence of allocation, use, and closing of a file
descriptor:</p>

<p style="margin-top: 1em">integer myfd <br>
exec {myfd}&gt;~/logs/mylogfile.txt <br>
print This is a log message. &gt;&amp;$myfd <br>
exec {myfd}&gt;&amp;-</p>

<p style="margin-top: 1em">Note that the expansion of the
variable in the expression &gt;&amp;$myfd occurs at the
point the redirection is opened. This is after the expansion
of command arguments and after any <br>
redirections to the left on the command line have been
processed.</p>

<p style="margin-top: 1em">MULTIOS <br>
If the user tries to open a file descriptor for writing more
than once, the shell opens the file descriptor as a pipe to
a process that copies its input to all the specified
out&acirc; <br>
puts, similar to tee, provided the MULTIOS option is set, as
it is by default. Thus:</p>

<p style="margin-top: 1em">date &gt;foo &gt;bar</p>

<p style="margin-top: 1em">writes the date to two files,
named &lsquo;foo&rsquo; and &lsquo;bar&rsquo;. Note that a
pipe is an implicit redirection; thus</p>

<p style="margin-top: 1em">date &gt;foo | cat</p>

<p style="margin-top: 1em">writes the date to the file
&lsquo;foo&rsquo;, and also pipes it to cat.</p>

<p style="margin-top: 1em">If the MULTIOS option is set,
the word after a redirection operator is also subjected to
filename generation (globbing). Thus</p>

<p style="margin-top: 1em">: &gt; *</p>

<p style="margin-top: 1em">will truncate all files in the
current directory, assuming there&rsquo;s at least one.
(Without the MULTIOS option, it would create an empty file
called &lsquo;*&rsquo;.) Similarly, you can do</p>

<p style="margin-top: 1em">echo exit 0 &gt;&gt; *.sh</p>

<p style="margin-top: 1em">If the user tries to open a file
descriptor for reading more than once, the shell opens the
file descriptor as a pipe to a process that copies all the
specified inputs to its <br>
output in the order specified, similar to cat, provided the
MULTIOS option is set. Thus</p>

<p style="margin-top: 1em">sort &lt;foo &lt;fubar</p>

<p style="margin-top: 1em">or even</p>

<p style="margin-top: 1em">sort &lt;f{oo,ubar}</p>

<p style="margin-top: 1em">is equivalent to &lsquo;cat foo
fubar | sort&rsquo;.</p>

<p style="margin-top: 1em">Expansion of the redirection
argument occurs at the point the redirection is opened, at
the point described above for the expansion of the variable
in &gt;&amp;$myfd.</p>

<p style="margin-top: 1em">Note that a pipe is an implicit
redirection; thus</p>

<p style="margin-top: 1em">cat bar | sort &lt;foo</p>

<p style="margin-top: 1em">is equivalent to &lsquo;cat bar
foo | sort&rsquo; (note the order of the inputs).</p>

<p style="margin-top: 1em">If the MULTIOS option is unset,
each redirection replaces the previous redirection for that
file descriptor. However, all files redirected to are
actually opened, so</p>

<p style="margin-top: 1em">echo foo &gt; bar &gt; baz</p>

<p style="margin-top: 1em">when MULTIOS is unset will
truncate bar, and write &lsquo;foo&rsquo; into baz.</p>

<p style="margin-top: 1em">There is a problem when an
output multio is attached to an external program. A simple
example shows this:</p>

<p style="margin-top: 1em">cat file &gt;file1 &gt;file2
<br>
cat file1 file2</p>

<p style="margin-top: 1em">Here, it is possible that the
second &lsquo;cat&rsquo; will not display the full contents
of file1 and file2 (i.e. the original contents of file
repeated twice).</p>

<p style="margin-top: 1em">The reason for this is that the
multios are spawned after the cat process is forked from the
parent shell, so the parent shell does not wait for the
multios to finish writing <br>
data. This means the command as shown can exit before file1
and file2 are completely written. As a workaround, it is
possible to run the cat process as part of a job in the <br>
current shell:</p>

<p style="margin-top: 1em">{ cat file } &gt;file
&gt;file2</p>

<p style="margin-top: 1em">Here, the {...} job will pause
to wait for both files to be written.</p>

<p style="margin-top: 1em">REDIRECTIONS WITH NO COMMAND
<br>
When a simple command consists of one or more redirection
operators and zero or more parameter assignments, but no
command name, zsh can behave in several ways.</p>

<p style="margin-top: 1em">If the parameter NULLCMD is not
set or the option CSH_NULLCMD is set, an error is caused.
This is the csh behavior and CSH_NULLCMD is set by default
when emulating csh.</p>

<p style="margin-top: 1em">If the option SH_NULLCMD is set,
the builtin &lsquo;:&rsquo; is inserted as a command with
the given redirections. This is the default when emulating
sh or ksh.</p>

<p style="margin-top: 1em">Otherwise, if the parameter
NULLCMD is set, its value will be used as a command with the
given redirections. If both NULLCMD and READNULLCMD are set,
then the value of the lat&acirc; <br>
ter will be used instead of that of the former when the
redirection is an input. The default for NULLCMD is
&lsquo;cat&rsquo; and for READNULLCMD is &lsquo;more&rsquo;.
Thus</p>

<p style="margin-top: 1em">&lt; file</p>

<p style="margin-top: 1em">shows the contents of file on
standard output, with paging if that is a terminal. NULLCMD
and READNULLCMD may refer to shell functions.</p>

<p style="margin-top: 1em">COMMAND EXECUTION <br>
If a command name contains no slashes, the shell attempts to
locate it. If there exists a shell function by that name,
the function is invoked as described in the section
&lsquo;Func&acirc; <br>
tions&rsquo;. If there exists a shell builtin by that name,
the builtin is invoked.</p>

<p style="margin-top: 1em">Otherwise, the shell searches
each element of $path for a directory containing an
executable file by that name. If the search is unsuccessful,
the shell prints an error message <br>
and returns a nonzero exit status.</p>

<p style="margin-top: 1em">If execution fails because the
file is not in executable format, and the file is not a
directory, it is assumed to be a shell script. /bin/sh is
spawned to execute it. If the <br>
program is a file beginning with &lsquo;#!&rsquo;, the
remainder of the first line specifies an interpreter for the
program. The shell will execute the specified interpreter on
operating <br>
systems that do not handle this executable format in the
kernel.</p>

<p style="margin-top: 1em">If no external command is found
but a function command_not_found_handler exists the shell
executes this function with all command line arguments. The
function should return sta&acirc; <br>
tus zero if it successfully handled the command, or non-zero
status if it failed. In the latter case the standard
handling is applied: &lsquo;command not found&rsquo; is
printed to standard <br>
error and the shell exits with status 127. Note that the
handler is executed in a subshell forked to execute an
external command, hence changes to directories, shell
parameters, <br>
etc. have no effect on the main shell.</p>

<p style="margin-top: 1em">FUNCTIONS <br>
Shell functions are defined with the function reserved word
or the special syntax &lsquo;funcname ()&rsquo;. Shell
functions are read in and stored internally. Alias names are
resolved <br>
when the function is read. Functions are executed like
commands with the arguments passed as positional parameters.
(See the section &lsquo;Command Execution&rsquo;.)</p>

<p style="margin-top: 1em">Functions execute in the same
process as the caller and share all files and present
working directory with the caller. A trap on EXIT set inside
a function is executed after the <br>
function completes in the environment of the caller.</p>

<p style="margin-top: 1em">The return builtin is used to
return from function calls.</p>

<p style="margin-top: 1em">Function identifiers can be
listed with the functions builtin. Functions can be
undefined with the unfunction builtin.</p>

<p style="margin-top: 1em">AUTOLOADING FUNCTIONS <br>
A function can be marked as undefined using the autoload
builtin (or &lsquo;functions -u&rsquo; or &lsquo;typeset
-fu&rsquo;). Such a function has no body. When the function
is first executed, the <br>
shell searches for its definition using the elements of the
fpath variable. Thus to define functions for autoloading, a
typical sequence is:</p>

<p style="margin-top: 1em">fpath=(~/myfuncs $fpath) <br>
autoload myfunc1 myfunc2 ...</p>

<p style="margin-top: 1em">The usual alias expansion during
reading will be suppressed if the autoload builtin or its
equivalent is given the option -U. This is recommended for
the use of functions sup&acirc; <br>
plied with the zsh distribution. Note that for functions
precompiled with the zcompile builtin command the flag -U
must be provided when the .zwc file is created, as the
corre&acirc; <br>
sponding information is compiled into the latter.</p>

<p style="margin-top: 1em">For each element in fpath, the
shell looks for three possible files, the newest of which is
used to load the definition for the function:</p>

<p style="margin-top: 1em">element.zwc <br>
A file created with the zcompile builtin command, which is
expected to contain the definitions for all functions in the
directory named element. The file is treated in <br>
the same manner as a directory containing files for
functions and is searched for the definition of the
function. If the definition is not found, the search for a
defi&acirc; <br>
nition proceeds with the other two possibilities described
below.</p>

<p style="margin-top: 1em">If element already includes a
.zwc extension (i.e. the extension was explicitly given by
the user), element is searched for the definition of the
function without compar&acirc; <br>
ing its age to that of other files; in fact, there does not
need to be any directory named element without the suffix.
Thus including an element such as <br>
&lsquo;/usr/local/funcs.zwc&rsquo; in fpath will speed up
the search for functions, with the disadvantage that
functions included must be explicitly recompiled by hand
before the <br>
shell notices any changes.</p>

<p style="margin-top: 1em">element/function.zwc <br>
A file created with zcompile, which is expected to contain
the definition for function. It may include other function
definitions as well, but those are neither loaded <br>
nor executed; a file found in this way is searched only for
the definition of function.</p>

<p style="margin-top: 1em">element/function <br>
A file of zsh command text, taken to be the definition for
function.</p>

<p style="margin-top: 1em">In summary, the order of
searching is, first, in the parents of directories in fpath
for the newer of either a compiled directory or a directory
in fpath; second, if more than <br>
one of these contains a definition for the function that is
sought, the leftmost in the fpath is chosen; and third,
within a directory, the newer of either a compiled function
or <br>
an ordinary function definition is used.</p>

<p style="margin-top: 1em">If the KSH_AUTOLOAD option is
set, or the file contains only a simple definition of the
function, the file&rsquo;s contents will be executed. This
will normally define the function in <br>
question, but may also perform initialization, which is
executed in the context of the function execution, and may
therefore define local parameters. It is an error if the
func&acirc; <br>
tion is not defined by loading the file.</p>

<p style="margin-top: 1em">Otherwise, the function body
(with no surrounding &lsquo;funcname() {...}&rsquo;) is
taken to be the complete contents of the file. This form
allows the file to be used directly as an exe&acirc; <br>
cutable shell script. If processing of the file results in
the function being re-defined, the function itself is not
re-executed. To force the shell to perform initialization
<br>
and then call the function defined, the file should contain
initialization code (which will be executed then discarded)
in addition to a complete function definition (which will
<br>
be retained for subsequent calls to the function), and a
call to the shell function, including any arguments, at the
end.</p>

<p style="margin-top: 1em">For example, suppose the
autoload file func contains</p>

<p style="margin-top: 1em">func() { print This is func; }
<br>
print func is initialized</p>

<p style="margin-top: 1em">then &lsquo;func; func&rsquo;
with KSH_AUTOLOAD set will produce both messages on the
first call, but only the message &lsquo;This is func&rsquo;
on the second and subsequent calls. Without <br>
KSH_AUTOLOAD set, it will produce the initialization message
on the first call, and the other message on the second and
subsequent calls.</p>

<p style="margin-top: 1em">It is also possible to create a
function that is not marked as autoloaded, but which loads
its own definition by searching fpath, by using
&lsquo;autoload -X&rsquo; within a shell function. <br>
For example, the following are equivalent:</p>

<p style="margin-top: 1em">myfunc() { <br>
autoload -X <br>
} <br>
myfunc args...</p>

<p style="margin-top: 1em">and</p>

<p style="margin-top: 1em">unfunction myfunc # if myfunc
was defined <br>
autoload myfunc <br>
myfunc args...</p>

<p style="margin-top: 1em">In fact, the functions command
outputs &lsquo;builtin autoload -X&rsquo; as the body of an
autoloaded function. This is done so that</p>

<p style="margin-top: 1em">eval
&quot;$(functions)&quot;</p>

<p style="margin-top: 1em">produces a reasonable result. A
true autoloaded function can be identified by the presence
of the comment &lsquo;# undefined&rsquo; in the body,
because all comments are discarded from <br>
defined functions.</p>

<p style="margin-top: 1em">To load the definition of an
autoloaded function myfunc without executing myfunc,
use:</p>

<p style="margin-top: 1em">autoload +X myfunc</p>

<p style="margin-top: 1em">ANONYMOUS FUNCTIONS <br>
If no name is given for a function, it is
&lsquo;anonymous&rsquo; and is handled specially. Either
form of function definition may be used: a &lsquo;()&rsquo;
with no preceding name, or a &lsquo;function&rsquo; <br>
with an immediately following open brace. The function is
executed immediately at the point of definition and is not
stored for future use. The function name is set to <br>
&lsquo;(anon)&rsquo;.</p>

<p style="margin-top: 1em">Arguments to the function may be
specified as words following the closing brace defining the
function, hence if there are none no arguments (other than
$0) are set. This is a <br>
difference from the way other functions are parsed: normal
function definitions may be followed by certain keywords
such as &lsquo;else&rsquo; or &lsquo;fi&rsquo;, which will
be treated as arguments to <br>
anonymous functions, so that a newline or semicolon is
needed to force keyword interpretation.</p>

<p style="margin-top: 1em">Note also that the argument list
of any enclosing script or function is hidden (as would be
the case for any other function called at this point).</p>

<p style="margin-top: 1em">Redirections may be applied to
the anonymous function in the same manner as to a
current-shell structure enclosed in braces. The main use of
anonymous functions is to provide a <br>
scope for local variables. This is particularly convenient
in start-up files as these do not provide their own local
variable scope.</p>

<p style="margin-top: 1em">For example,</p>

<p style="margin-top: 1em">variable=outside <br>
function { <br>
local variable=inside <br>
print &quot;I am $variable with arguments $*&quot; <br>
} this and that <br>
print &quot;I am $variable&quot;</p>

<p style="margin-top: 1em">outputs the following:</p>

<p style="margin-top: 1em">I am inside with arguments this
and that <br>
I am outside</p>

<p style="margin-top: 1em">Note that function definitions
with arguments that expand to nothing, for example
&lsquo;name=; function $name { ... }&rsquo;, are not treated
as anonymous functions. Instead, they are <br>
treated as normal function definitions where the definition
is silently discarded.</p>

<p style="margin-top: 1em">SPECIAL FUNCTIONS <br>
Certain functions, if defined, have special meaning to the
shell.</p>

<p style="margin-top: 1em">Hook Functions <br>
For the functions below, it is possible to define an array
that has the same name as the function with
&lsquo;_functions&rsquo; appended. Any element in such an
array is taken as the name <br>
of a function to execute; it is executed in the same context
and with the same arguments as the basic function. For
example, if $chpwd_functions is an array containing the
val&acirc; <br>
ues &lsquo;mychpwd&rsquo;,
&lsquo;chpwd_save_dirstack&rsquo;, then the shell attempts
to execute the functions &lsquo;chpwd&rsquo;,
&lsquo;mychpwd&rsquo; and &lsquo;chpwd_save_dirstack&rsquo;,
in that order. Any function that does not <br>
exist is silently ignored. A function found by this
mechanism is referred to elsewhere as a &lsquo;hook
function&rsquo;. An error in any function causes subsequent
functions not to be run. <br>
Note further that an error in a precmd hook causes an
immediately following periodic function not to run (though
it may run at the next opportunity).</p>

<p style="margin-top: 1em">chpwd Executed whenever the
current working directory is changed.</p>

<p style="margin-top: 1em">periodic <br>
If the parameter PERIOD is set, this function is executed
every $PERIOD seconds, just before a prompt. Note that if
multiple functions are defined using the array peri&acirc;
<br>
odic_functions only one period is applied to the complete
set of functions, and the scheduled time is not reset if the
list of functions is altered. Hence the set of <br>
functions is always called together.</p>

<p style="margin-top: 1em">precmd Executed before each
prompt. Note that precommand functions are not re-executed
simply because the command line is redrawn, as happens, for
example, when a notification <br>
about an exiting job is displayed.</p>

<p style="margin-top: 1em">preexec <br>
Executed just after a command has been read and is about to
be executed. If the history mechanism is active (and the
line was not discarded from the history buffer), the <br>
string that the user typed is passed as the first argument,
otherwise it is an empty string. The actual command that
will be executed (including expanded aliases) is <br>
passed in two different forms: the second argument is a
single-line, size-limited version of the command (with
things like function bodies elided); the third argument
con&acirc; <br>
tains the full text that is being executed.</p>

<p style="margin-top: 1em">zshaddhistory <br>
Executed when a history line has been read interactively,
but before it is executed. The sole argument is the complete
history line (so that any terminating newline will <br>
still be present).</p>

<p style="margin-top: 1em">If any of the hook functions
return a non-zero value the history line will not be saved,
although it lingers in the history until the next line is
executed allow you to <br>
reuse or edit it immediately.</p>

<p style="margin-top: 1em">A hook function may call
&lsquo;fc -p ...&rsquo; to switch the history context so
that the history is saved in a different file from the that
in the global HISTFILE parameter. This <br>
is handled specially: the history context is automatically
restored after the processing of the history line is
finished.</p>

<p style="margin-top: 1em">The following example function
first adds the history line to the normal history with the
newline stripped, which is usually the correct behaviour.
Then it switches the <br>
history context so that the line will be written to a
history file in the current directory.</p>

<p style="margin-top: 1em">zshaddhistory() { <br>
print -sr -- ${1%%$&rsquo;0} <br>
fc -p .zsh_local_history <br>
}</p>

<p style="margin-top: 1em">zshexit <br>
Executed at the point where the main shell is about to exit
normally. This is not called by exiting subshells, nor when
the exec precommand modifier is used before an <br>
external command. Also, unlike TRAPEXIT, it is not called
when functions exit.</p>

<p style="margin-top: 1em">Trap Functions <br>
The functions below are treated specially but do not have
corresponding hook arrays.</p>

<p style="margin-top: 1em">TRAPNAL <br>
If defined and non-null, this function will be executed
whenever the shell catches a signal SIGNAL, where NAL is a
signal name as specified for the kill builtin. The
sig&acirc; <br>
nal number will be passed as the first parameter to the
function.</p>

<p style="margin-top: 1em">If a function of this form is
defined and null, the shell and processes spawned by it will
ignore SIGNAL.</p>

<p style="margin-top: 1em">The return status from the
function is handled specially. If it is zero, the signal is
assumed to have been handled, and execution continues
normally. Otherwise, the <br>
shell will behave as interrupted except that the return
status of the trap is retained.</p>

<p style="margin-top: 1em">Programs terminated by uncaught
signals typically return the status 128 plus the signal
number. Hence the following causes the handler for SIGINT to
print a message, then <br>
mimic the usual effect of the signal.</p>

<p style="margin-top: 1em">TRAPINT() { <br>
print &quot;Caught SIGINT, aborting.&quot; <br>
return $(( 128 + $1 )) <br>
}</p>

<p style="margin-top: 1em">The functions TRAPZERR,
TRAPDEBUG and TRAPEXIT are never executed inside other
traps.</p>

<p style="margin-top: 1em">TRAPDEBUG <br>
If the option DEBUG_BEFORE_CMD is set (as it is by default),
executed before each command; otherwise executed after each
command. See the description of the trap builtin <br>
in zshbuiltins(1) for details of additional features
provided in debug traps.</p>

<p style="margin-top: 1em">TRAPEXIT <br>
Executed when the shell exits, or when the current function
exits if defined inside a function. The value of $? at the
start of execution is the exit status of the shell <br>
or the return status of the function exiting.</p>

<p style="margin-top: 1em">TRAPZERR <br>
Executed whenever a command has a non-zero exit status.
However, the function is not executed if the command
occurred in a sublist followed by &lsquo;&amp;&amp;&rsquo;
or &lsquo;||&rsquo;; only the <br>
final command in a sublist of this type causes the trap to
be executed. The function TRAPERR acts the same as TRAPZERR
on systems where there is no SIGERR (this is the <br>
usual case).</p>

<p style="margin-top: 1em">The functions beginning
&lsquo;TRAP&rsquo; may alternatively be defined with the
trap builtin: this may be preferable for some uses. Setting
a trap with one form removes any trap of the <br>
other form for the same signal; removing a trap in either
form removes all traps for the same signal. The forms</p>

<p style="margin-top: 1em">TRAPNAL() { <br>
# code <br>
}</p>

<p style="margin-top: 1em">(&rsquo;function traps&rsquo;)
and</p>

<p style="margin-top: 1em">trap &rsquo; <br>
# code <br>
&rsquo; NAL</p>

<p style="margin-top: 1em">(&rsquo;list traps&rsquo;) are
equivalent in most ways, the exceptions being the
following:</p>

<p style="margin-top: 1em">&Acirc;&middot; Function traps
have all the properties of normal functions, appearing in
the list of functions and being called with their own
function context rather than the context <br>
where the trap was triggered.</p>

<p style="margin-top: 1em">&Acirc;&middot; The return
status from function traps is special, whereas a return from
a list trap causes the surrounding context to return with
the given status.</p>

<p style="margin-top: 1em">&Acirc;&middot; Function traps
are not reset within subshells, in accordance with zsh
behaviour; list traps are reset, in accordance with POSIX
behaviour.</p>

<p style="margin-top: 1em">JOBS <br>
If the MONITOR option is set, an interactive shell
associates a job with each pipeline. It keeps a table of
current jobs, printed by the jobs command, and assigns them
small <br>
integer numbers. When a job is started asynchronously with
&lsquo;&amp;&rsquo;, the shell prints a line to standard
error which looks like:</p>

<p style="margin-top: 1em">[1] 1234</p>

<p style="margin-top: 1em">indicating that the job which
was started asynchronously was job number 1 and had one
(top-level) process, whose process ID was 1234.</p>

<p style="margin-top: 1em">If a job is started with
&lsquo;&amp;|&rsquo; or &lsquo;&amp;!&rsquo;, then that job
is immediately disowned. After startup, it does not have a
place in the job table, and is not subject to the job
control <br>
features described here.</p>

<p style="margin-top: 1em">If you are running a job and
wish to do something else you may hit the key ^Z (control-Z)
which sends a TSTP signal to the current job: this key may
be redefined by the susp <br>
option of the external stty command. The shell will then
normally indicate that the job has been
&lsquo;suspended&rsquo;, and print another prompt. You can
then manipulate the state of <br>
this job, putting it in the background with the bg command,
or run some other commands and then eventually bring the job
back into the foreground with the foreground command fg.
<br>
A ^Z takes effect immediately and is like an interrupt in
that pending output and unread input are discarded when it
is typed.</p>

<p style="margin-top: 1em">A job being run in the
background will suspend if it tries to read from the
terminal.</p>

<p style="margin-top: 1em">Note that if the job running in
the foreground is a shell function, then suspending it will
have the effect of causing the shell to fork. This is
necessary to separate the func&acirc; <br>
tion&rsquo;s state from that of the parent shell performing
the job control, so that the latter can return to the
command line prompt. As a result, even if fg is used to
continue the <br>
job the function will no longer be part of the parent shell,
and any variables set by the function will not be visible in
the parent shell. Thus the behaviour is different from <br>
the case where the function was never suspended. Zsh is
different from many other shells in this regard.</p>

<p style="margin-top: 1em">The same behaviour is found when
the shell is executing code as the right hand side of a
pipeline or any complex shell construct such as if, for,
etc., in order that the entire <br>
block of code can be managed as a single job. Background
jobs are normally allowed to produce output, but this can be
disabled by giving the command &lsquo;stty tostop&rsquo;. If
you set <br>
this tty option, then background jobs will suspend when they
try to produce output like they do when they try to read
input.</p>

<p style="margin-top: 1em">When a command is suspended and
continued later with the fg or wait builtins, zsh restores
tty modes that were in effect when it was suspended. This
(intentionally) does not <br>
apply if the command is continued via &lsquo;kill
-CONT&rsquo;, nor when it is continued with bg.</p>

<p style="margin-top: 1em">There are several ways to refer
to jobs in the shell. A job can be referred to by the
process ID of any process of the job or by one of the
following:</p>

<p style="margin-top: 1em">%number <br>
The job with the given number. <br>
%string <br>
Any job whose command line begins with string. <br>
%?string <br>
Any job whose command line contains string. <br>
%% Current job. <br>
%+ Equivalent to &lsquo;%%&rsquo;. <br>
%- Previous job.</p>

<p style="margin-top: 1em">The shell learns immediately
whenever a process changes state. It normally informs you
whenever a job becomes blocked so that no further progress
is possible. If the NOTIFY <br>
option is not set, it waits until just before it prints a
prompt before it informs you. All such notifications are
sent directly to the terminal, not to the standard output or
<br>
standard error.</p>

<p style="margin-top: 1em">When the monitor mode is on,
each background job that completes triggers any trap set for
CHLD.</p>

<p style="margin-top: 1em">When you try to leave the shell
while jobs are running or suspended, you will be warned that
&lsquo;You have suspended (running) jobs&rsquo;. You may use
the jobs command to see what they <br>
are. If you do this or immediately try to exit again, the
shell will not warn you a second time; the suspended jobs
will be terminated, and the running jobs will be sent a <br>
SIGHUP signal, if the HUP option is set.</p>

<p style="margin-top: 1em">To avoid having the shell
terminate the running jobs, either use the nohup command
(see nohup(1)) or the disown builtin.</p>

<p style="margin-top: 1em">SIGNALS <br>
The INT and QUIT signals for an invoked command are ignored
if the command is followed by &lsquo;&amp;&rsquo; and the
MONITOR option is not active. The shell itself always
ignores the QUIT sig&acirc; <br>
nal. Otherwise, signals have the values inherited by the
shell from its parent (but see the TRAPNAL special functions
in the section &lsquo;Functions&rsquo;).</p>

<p style="margin-top: 1em">ARITHMETIC EVALUATION <br>
The shell can perform integer and floating point arithmetic,
either using the builtin let, or via a substitution of the
form $((...)). For integers, the shell is usually com&acirc;
<br>
piled to use 8-byte precision where this is available,
otherwise precision is 4 bytes. This can be tested, for
example, by giving the command &lsquo;print - $((
12345678901 ))&rsquo;; if <br>
the number appears unchanged, the precision is at least 8
bytes. Floating point arithmetic always uses the
&lsquo;double&rsquo; type with whatever corresponding
precision is provided by the <br>
compiler and the library.</p>

<p style="margin-top: 1em">The let builtin command takes
arithmetic expressions as arguments; each is evaluated
separately. Since many of the arithmetic operators, as well
as spaces, require quoting, an <br>
alternative form is provided: for any command which begins
with a &lsquo;((&rsquo;, all the characters until a matching
&lsquo;))&rsquo; are treated as a quoted expression and
arithmetic expansion per&acirc; <br>
formed as for an argument of let. More precisely,
&lsquo;((...))&rsquo; is equivalent to &lsquo;let
&quot;...&quot;&rsquo;. The return status is 0 if the
arithmetic value of the expression is non-zero, 1 if it <br>
is zero, and 2 if an error occurred.</p>

<p style="margin-top: 1em">For example, the following
statement</p>

<p style="margin-top: 1em">(( val = 2 + 1 ))</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">let &quot;val = 2 + 1&quot;</p>

<p style="margin-top: 1em">both assigning the value 3 to
the shell variable val and returning a zero status.</p>

<p style="margin-top: 1em">Integers can be in bases other
than 10. A leading &lsquo;0x&rsquo; or &lsquo;0X&rsquo;
denotes hexadecimal. Integers may also be of the form
&lsquo;base#n&rsquo;, where base is a decimal number between
two and <br>
thirty-six representing the arithmetic base and n is a
number in that base (for example, &lsquo;16#ff&rsquo; is 255
in hexadecimal). The base# may also be omitted, in which
case base 10 is <br>
used. For backwards compatibility the form
&lsquo;[base]n&rsquo; is also accepted.</p>

<p style="margin-top: 1em">An integer expression or a base
given in the form &lsquo;base#n&rsquo; may contain
underscores (&lsquo;_&rsquo;) after the leading digit for
visual guidance; these are ignored in computation. Examples
<br>
are 1_000_000 or 0xffff_ffff which are equivalent to 1000000
and 0xffffffff respectively.</p>

<p style="margin-top: 1em">It is also possible to specify a
base to be used for output in the form
&lsquo;[#base]&rsquo;, for example &lsquo;[#16]&rsquo;. This
is used when outputting arithmetical substitutions or when
assigning <br>
to scalar parameters, but an explicitly defined integer or
floating point parameter will not be affected. If an integer
variable is implicitly defined by an arithmetic
expres&acirc; <br>
sion, any base specified in this way will be set as the
variable&rsquo;s output arithmetic base as if the option
&lsquo;-i base&rsquo; to the typeset builtin had been used.
The expression has no <br>
precedence and if it occurs more than once in a mathematical
expression, the last encountered is used. For clarity it is
recommended that it appear at the beginning of an <br>
expression. As an example:</p>

<p style="margin-top: 1em">typeset -i 16 y <br>
print $(( [#8] x = 32, y = 32 )) <br>
print $x $y</p>

<p style="margin-top: 1em">outputs first
&lsquo;8#40&rsquo;, the rightmost value in the given output
base, and then &lsquo;8#40 16#20&rsquo;, because y has been
explicitly declared to have output base 16, while x
(assuming it <br>
does not already exist) is implicitly typed by the
arithmetic evaluation, where it acquires the output base
8.</p>

<p style="margin-top: 1em">If the C_BASES option is set,
hexadecimal numbers in the standard C format, for example
0xFF instead of the usual &lsquo;16#FF&rsquo;. If the option
OCTAL_ZEROES is also set (it is not by <br>
default), octal numbers will be treated similarly and hence
appear as &lsquo;077&rsquo; instead of &lsquo;8#77&rsquo;.
This option has no effect on the output of bases other than
hexadecimal and octal, <br>
and these formats are always understood on input.</p>

<p style="margin-top: 1em">When an output base is specified
using the &lsquo;[#base]&rsquo; syntax, an appropriate base
prefix will be output if necessary, so that the value output
is valid syntax for input. If the # <br>
is doubled, for example &lsquo;[##16]&rsquo;, then no base
prefix is output.</p>

<p style="margin-top: 1em">Floating point constants are
recognized by the presence of a decimal point or an
exponent. The decimal point may be the first character of
the constant, but the exponent charac&acirc; <br>
ter e or E may not, as it will be taken for a parameter
name. All numeric parts (before and after the decimal point
and in the exponent) may contain underscores after the
lead&acirc; <br>
ing digit for visual guidance; these are ignored in
computation.</p>

<p style="margin-top: 1em">An arithmetic expression uses
nearly the same syntax and associativity of expressions as
in C.</p>

<p style="margin-top: 1em">In the native mode of operation,
the following operators are supported (listed in decreasing
order of precedence):</p>

<p style="margin-top: 1em">+ - ! ~ ++ -- <br>
unary plus/minus, logical NOT, complement,
{pre,post}{in,de}crement <br>
&lt;&lt; &gt;&gt; bitwise shift left, right <br>
&amp; bitwise AND <br>
^ bitwise XOR <br>
| bitwise OR <br>
** exponentiation <br>
* / % multiplication, division, modulus (remainder) <br>
+ - addition, subtraction <br>
&lt; &gt; &lt;= &gt;= <br>
comparison <br>
== != equality and inequality <br>
&amp;&amp; logical AND <br>
|| ^^ logical OR, XOR <br>
? : ternary operator <br>
= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=
&amp;&amp;= ||= ^^= **= <br>
assignment <br>
, comma operator</p>

<p style="margin-top: 1em">The operators
&lsquo;&amp;&amp;&rsquo;, &lsquo;||&rsquo;,
&lsquo;&amp;&amp;=&rsquo;, and &lsquo;||=&rsquo; are
short-circuiting, and only one of the latter two expressions
in a ternary operator is evaluated. Note the precedence of
the bit&acirc; <br>
wise AND, OR, and XOR operators.</p>

<p style="margin-top: 1em">With the option C_PRECEDENCES
the precedences (but no other properties) of the operators
are altered to be the same as those in most other languages
that support the relevant <br>
operators:</p>

<p style="margin-top: 1em">+ - ! ~ ++ -- <br>
unary plus/minus, logical NOT, complement,
{pre,post}{in,de}crement <br>
** exponentiation <br>
* / % multiplication, division, modulus (remainder) <br>
+ - addition, subtraction <br>
&lt;&lt; &gt;&gt; bitwise shift left, right <br>
&lt; &gt; &lt;= &gt;= <br>
comparison <br>
== != equality and inequality <br>
&amp; bitwise AND <br>
^ bitwise XOR <br>
| bitwise OR <br>
&amp;&amp; logical AND <br>
^^ logical XOR <br>
|| logical OR <br>
? : ternary operator <br>
= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=
&amp;&amp;= ||= ^^= **= <br>
assignment <br>
, comma operator</p>

<p style="margin-top: 1em">Note the precedence of
exponentiation in both cases is below that of unary
operators, hence &lsquo;-3**2&rsquo; evaluates as
&lsquo;9&rsquo;, not -9. Use parentheses where necessary:
&lsquo;-(3**2)&rsquo;. This <br>
is for compatibility with other shells.</p>

<p style="margin-top: 1em">Mathematical functions can be
called with the syntax &lsquo;func(args)&rsquo;, where the
function decides if the args is used as a string or a
comma-separated list of arithmetic expressions. <br>
The shell currently defines no mathematical functions by
default, but the module zsh/mathfunc may be loaded with the
zmodload builtin to provide standard floating point
mathemat&acirc; <br>
ical functions.</p>

<p style="margin-top: 1em">An expression of the form
&lsquo;##x&rsquo; where x is any character sequence such as
&lsquo;a&rsquo;, &lsquo;^A&rsquo;, or &lsquo;gives the value
of this character and an expression of the form
&lsquo;#foo&rsquo; gives the <br>
value of the first character of the contents of the
parameter foo. Character values are according to the
character set used in the current locale; for multibyte
character han&acirc; <br>
dling the option MULTIBYTE must be set. Note that this form
is different from &lsquo;$#foo&rsquo;, a standard parameter
substitution which gives the length of the parameter foo.
&lsquo;#&acute; is <br>
accepted instead of &lsquo;##&rsquo;, but its use is
deprecated.</p>

<p style="margin-top: 1em">Named parameters and subscripted
arrays can be referenced by name within an arithmetic
expression without using the parameter expansion syntax. For
example,</p>

<p style="margin-top: 1em">((val2 = val1 * 2))</p>

<p style="margin-top: 1em">assigns twice the value of $val1
to the parameter named val2.</p>

<p style="margin-top: 1em">An internal integer
representation of a named parameter can be specified with
the integer builtin. Arithmetic evaluation is performed on
the value of each assignment to a named <br>
parameter declared integer in this manner. Assigning a
floating point number to an integer results in rounding down
to the next integer.</p>

<p style="margin-top: 1em">Likewise, floating point numbers
can be declared with the float builtin; there are two types,
differing only in their output format, as described for the
typeset builtin. The <br>
output format can be bypassed by using arithmetic
substitution instead of the parameter substitution, i.e.
&lsquo;${float}&rsquo; uses the defined format, but
&lsquo;$((float))&rsquo; uses a generic <br>
floating point format.</p>

<p style="margin-top: 1em">Promotion of integer to floating
point values is performed where necessary. In addition, if
any operator which requires an integer (&lsquo;~&rsquo;,
&lsquo;&amp;&rsquo;, &lsquo;|&rsquo;, &lsquo;^&rsquo;,
&lsquo;%&rsquo;, &lsquo;&lt;&lt;&rsquo;,
&lsquo;&gt;&gt;&rsquo; and their <br>
equivalents with assignment) is given a floating point
argument, it will be silently rounded down to the next
integer.</p>

<p style="margin-top: 1em">Scalar variables can hold
integer or floating point values at different times; there
is no memory of the numeric type in this case.</p>

<p style="margin-top: 1em">If a variable is first assigned
in a numeric context without previously being declared, it
will be implicitly typed as integer or float and retain that
type either until the type <br>
is explicitly changed or until the end of the scope. This
can have unforeseen consequences. For example, in the
loop</p>

<p style="margin-top: 1em">for (( f = 0; f &lt; 1; f += 0.1
)); do <br>
# use $f <br>
done</p>

<p style="margin-top: 1em">if f has not already been
declared, the first assignment will cause it to be created
as an integer, and consequently the operation &lsquo;f +=
0.1&rsquo; will always cause the result to be <br>
truncated to zero, so that the loop will fail. A simple fix
would be to turn the initialization into &lsquo;f =
0.0&rsquo;. It is therefore best to declare numeric
variables with explicit <br>
types.</p>

<p style="margin-top: 1em">CONDITIONAL EXPRESSIONS <br>
A conditional expression is used with the [[ compound
command to test attributes of files and to compare strings.
Each expression can be constructed from one or more of the
fol&acirc; <br>
lowing unary or binary expressions:</p>

<p style="margin-top: 1em">-a file <br>
true if file exists.</p>

<p style="margin-top: 1em">-b file <br>
true if file exists and is a block special file.</p>

<p style="margin-top: 1em">-c file <br>
true if file exists and is a character special file.</p>

<p style="margin-top: 1em">-d file <br>
true if file exists and is a directory.</p>

<p style="margin-top: 1em">-e file <br>
true if file exists.</p>

<p style="margin-top: 1em">-f file <br>
true if file exists and is a regular file.</p>

<p style="margin-top: 1em">-g file <br>
true if file exists and has its setgid bit set.</p>

<p style="margin-top: 1em">-h file <br>
true if file exists and is a symbolic link.</p>

<p style="margin-top: 1em">-k file <br>
true if file exists and has its sticky bit set.</p>

<p style="margin-top: 1em">-n string <br>
true if length of string is non-zero.</p>

<p style="margin-top: 1em">-o option <br>
true if option named option is on. option may be a single
character, in which case it is a single letter option name.
(See the section &lsquo;Specifying Options&rsquo;.)</p>

<p style="margin-top: 1em">-p file <br>
true if file exists and is a FIFO special file (named
pipe).</p>

<p style="margin-top: 1em">-r file <br>
true if file exists and is readable by current process.</p>

<p style="margin-top: 1em">-s file <br>
true if file exists and has size greater than zero.</p>

<p style="margin-top: 1em">-t fd true if file descriptor
number fd is open and associated with a terminal device.
(note: fd is not optional)</p>

<p style="margin-top: 1em">-u file <br>
true if file exists and has its setuid bit set.</p>

<p style="margin-top: 1em">-w file <br>
true if file exists and is writable by current process.</p>

<p style="margin-top: 1em">-x file <br>
true if file exists and is executable by current process. If
file exists and is a directory, then the current process has
permission to search in the directory.</p>

<p style="margin-top: 1em">-z string <br>
true if length of string is zero.</p>

<p style="margin-top: 1em">-L file <br>
true if file exists and is a symbolic link.</p>

<p style="margin-top: 1em">-O file <br>
true if file exists and is owned by the effective user ID of
this process.</p>

<p style="margin-top: 1em">-G file <br>
true if file exists and its group matches the effective
group ID of this process.</p>

<p style="margin-top: 1em">-S file <br>
true if file exists and is a socket.</p>

<p style="margin-top: 1em">-N file <br>
true if file exists and its access time is not newer than
its modification time.</p>

<p style="margin-top: 1em">file1 -nt file2 <br>
true if file1 exists and is newer than file2.</p>

<p style="margin-top: 1em">file1 -ot file2 <br>
true if file1 exists and is older than file2.</p>

<p style="margin-top: 1em">file1 -ef file2 <br>
true if file1 and file2 exist and refer to the same
file.</p>

<p style="margin-top: 1em">string = pattern <br>
string == pattern <br>
true if string matches pattern. The &lsquo;==&rsquo; form is
the preferred one. The &lsquo;=&rsquo; form is for backward
compatibility and should be considered obsolete.</p>

<p style="margin-top: 1em">string != pattern <br>
true if string does not match pattern.</p>

<p style="margin-top: 1em">string =~ regexp <br>
true if string matches the regular expression regexp. If the
option RE_MATCH_PCRE is set regexp is tested as a PCRE
regular expression using the zsh/pcre module, else it <br>
is tested as a POSIX extended regular expression using the
zsh/regex module. Upon successful match, some variables will
be updated; no variables are changed if the match&acirc;
<br>
ing fails.</p>

<p style="margin-top: 1em">If the option BASH_REMATCH is
not set the scalar parameter MATCH is set to the substring
that matched the pattern and the integer parameters MBEGIN
and MEND to the index <br>
of the start and end, respectively, of the match in string,
such that if string is contained in variable var the
expression &lsquo;${var[$MBEGIN,$MEND]}&rsquo; is identical
to <br>
&lsquo;$MATCH&rsquo;. The setting of the option KSH_ARRAYS
is respected. Likewise, the array match is set to the
substrings that matched parenthesised subexpressions and the
arrays <br>
mbegin and mend to the indices of the start and end
positions, respectively, of the substrings within string.
The arrays are not set if there were no parenthesised
subex&acirc; <br>
presssions. For example, if the string &lsquo;a short
string&rsquo; is matched against the regular expression
&lsquo;s(...)t&rsquo;, then (assuming the option KSH_ARRAYS
is not set) MATCH, MBE&acirc; <br>
GIN and MEND are &lsquo;short&rsquo;, 3 and 7, respectively,
while match, mbegin and mend are single entry arrays
containing the strings &lsquo;hor&rsquo;, &lsquo;4&rsquo;
and &lsquo;6, respectively.</p>

<p style="margin-top: 1em">If the option BASH_REMATCH is
set the array BASH_REMATCH is set to the substring that
matched the pattern followed by the substrings that matched
parenthesised subexpres&acirc; <br>
sions within the pattern.</p>

<p style="margin-top: 1em">string1 &lt; string2 <br>
true if string1 comes before string2 based on ASCII value of
their characters.</p>

<p style="margin-top: 1em">string1 &gt; string2 <br>
true if string1 comes after string2 based on ASCII value of
their characters.</p>

<p style="margin-top: 1em">exp1 -eq exp2 <br>
true if exp1 is numerically equal to exp2. Note that for
purely numeric comparisons use of the ((...)) builtin
described in the section &lsquo;ARITHMETIC EVALUATION&rsquo;
is more <br>
convenient than conditional expressions.</p>

<p style="margin-top: 1em">exp1 -ne exp2 <br>
true if exp1 is numerically not equal to exp2.</p>

<p style="margin-top: 1em">exp1 -lt exp2 <br>
true if exp1 is numerically less than exp2.</p>

<p style="margin-top: 1em">exp1 -gt exp2 <br>
true if exp1 is numerically greater than exp2.</p>

<p style="margin-top: 1em">exp1 -le exp2 <br>
true if exp1 is numerically less than or equal to exp2.</p>

<p style="margin-top: 1em">exp1 -ge exp2 <br>
true if exp1 is numerically greater than or equal to
exp2.</p>

<p style="margin-top: 1em">( exp ) <br>
true if exp is true.</p>

<p style="margin-top: 1em">! exp true if exp is false.</p>

<p style="margin-top: 1em">exp1 &amp;&amp; exp2 <br>
true if exp1 and exp2 are both true.</p>

<p style="margin-top: 1em">exp1 || exp2 <br>
true if either exp1 or exp2 is true.</p>

<p style="margin-top: 1em">Normal shell expansion is
performed on the file, string and pattern arguments, but the
result of each expansion is constrained to be a single word,
similar to the effect of dou&acirc; <br>
ble quotes. Filename generation is not performed on any form
of argument to conditions. However, pattern metacharacters
are active for the pattern arguments; the patterns are <br>
the same as those used for filename generation, see
zshexpn(1), but there is no special behaviour of
&lsquo;/&rsquo; nor initial dots, and no glob qualifiers are
allowed.</p>

<p style="margin-top: 1em">In each of the above
expressions, if file is of the form &lsquo;/dev/fd/n&rsquo;,
where n is an integer, then the test applied to the open
file whose descriptor number is n, even if the <br>
underlying system does not support the /dev/fd
directory.</p>

<p style="margin-top: 1em">In the forms which do numeric
comparison, the expressions exp undergo arithmetic expansion
as if they were enclosed in $((...)).</p>

<p style="margin-top: 1em">For example, the following:</p>

<p style="margin-top: 1em">[[ ( -f foo || -f bar )
&amp;&amp; $report = y* ]] &amp;&amp; print File exists.</p>

<p style="margin-top: 1em">tests if either file foo or file
bar exists, and if so, if the value of the parameter report
begins with &lsquo;y&rsquo;; if the complete condition is
true, the message &lsquo;File exists.&rsquo; is <br>
printed.</p>

<p style="margin-top: 1em">EXPANSION OF PROMPT SEQUENCES
<br>
Prompt sequences undergo a special form of expansion. This
type of expansion is also available using the -P option to
the print builtin.</p>

<p style="margin-top: 1em">If the PROMPT_SUBST option is
set, the prompt string is first subjected to parameter
expansion, command substitution and arithmetic expansion.
See zshexpn(1).</p>

<p style="margin-top: 1em">Certain escape sequences may be
recognised in the prompt string.</p>

<p style="margin-top: 1em">If the PROMPT_BANG option is
set, a &lsquo;!&rsquo; in the prompt is replaced by the
current history event number. A literal &lsquo;!&rsquo; may
then be represented as &lsquo;!!&rsquo;.</p>

<p style="margin-top: 1em">If the PROMPT_PERCENT option is
set, certain escape sequences that start with
&lsquo;%&rsquo; are expanded. Many escapes are followed by a
single character, although some of these take an <br>
optional integer argument that should appear between the
&lsquo;%&rsquo; and the next character of the sequence. More
complicated escape sequences are available to provide
conditional <br>
expansion.</p>

<p style="margin-top: 1em">SIMPLE PROMPT ESCAPES <br>
Special characters <br>
%% A &lsquo;%&rsquo;.</p>

<p style="margin-top: 1em">%) A &lsquo;)&rsquo;.</p>

<p style="margin-top: 1em">Login information <br>
%l The line (tty) the user is logged in on, without
&lsquo;/dev/&rsquo; prefix. If the name starts with
&lsquo;/dev/tty&rsquo;, that prefix is stripped.</p>

<p style="margin-top: 1em">%M The full machine
hostname.</p>

<p style="margin-top: 1em">%m The hostname up to the first
&lsquo;.&rsquo;. An integer may follow the &lsquo;%&rsquo;
to specify how many components of the hostname are desired.
With a negative integer, trailing components <br>
of the hostname are shown.</p>

<p style="margin-top: 1em">%n $USERNAME.</p>

<p style="margin-top: 1em">%y The line (tty) the user is
logged in on, without &lsquo;/dev/&rsquo; prefix. This does
not treat &lsquo;/dev/tty&rsquo; names specially.</p>

<p style="margin-top: 1em">Shell state <br>
%# A &lsquo;#&rsquo; if the shell is running with
privileges, a &lsquo;%&rsquo; if not. Equivalent to
&lsquo;%(!.#.%%)&rsquo;. The definition of
&lsquo;privileged&rsquo;, for these purposes, is that either
the effective <br>
user ID is zero, or, if POSIX.1e capabilities are supported,
that at least one capability is raised in either the
Effective or Inheritable capability vectors.</p>

<p style="margin-top: 1em">%? The return status of the last
command executed just before the prompt.</p>

<p style="margin-top: 1em">%_ The status of the parser,
i.e. the shell constructs (like &lsquo;if&rsquo; and
&lsquo;for&rsquo;) that have been started on the command
line. If given an integer number that many strings will be
<br>
printed; zero or negative or no integer means print as many
as there are. This is most useful in prompts PS2 for
continuation lines and PS4 for debugging with the XTRACE
<br>
option; in the latter case it will also work
non-interactively.</p>

<p style="margin-top: 1em">%d <br>
/ Current working directory. If an integer follows the
&lsquo;%&rsquo;, it specifies a number of trailing
components of the current working directory to show; zero
means the whole <br>
path. A negative integer specifies leading components, i.e.
%-1d specifies the first component.</p>

<p style="margin-top: 1em">%~ As %d and %/, but if the
current working directory has a named directory as its
prefix, that part is replaced by a &lsquo;~&rsquo; followed
by the name of the directory. If it starts <br>
with $HOME, that part is replaced by a &lsquo;~&rsquo;.</p>

<p style="margin-top: 1em">%h <br>
%! Current history event number.</p>

<p style="margin-top: 1em">%i The line number currently
being executed in the script, sourced file, or shell
function given by %N. This is most useful for debugging as
part of $PS4.</p>

<p style="margin-top: 1em">%I The line number currently
being executed in the file %x. This is similar to %i, but
the line number is always a line number in the file where
the code was defined, even <br>
if the code is a shell function.</p>

<p style="margin-top: 1em">%j The number of jobs.</p>

<p style="margin-top: 1em">%L The current value of
$SHLVL.</p>

<p style="margin-top: 1em">%N The name of the script,
sourced file, or shell function that zsh is currently
executing, whichever was started most recently. If there is
none, this is equivalent to the <br>
parameter $0. An integer may follow the &lsquo;%&rsquo; to
specify a number of trailing path components to show; zero
means the full path. A negative integer specifies leading
com&acirc; <br>
ponents.</p>

<p style="margin-top: 1em">%x The name of the file
containing the source code currently being executed. This
behaves as %N except that function and eval command names
are not shown, instead the file <br>
where they were defined.</p>

<p style="margin-top: 1em">%c <br>
%. <br>
%C Trailing component of the current working directory. An
integer may follow the &lsquo;%&rsquo; to get more than one
component. Unless &lsquo;%C&rsquo; is used, tilde
contraction is performed <br>
first. These are deprecated as %c and %C are equivalent to
%1~ and %1/, respectively, while explicit positive integers
have the same effect as for the latter two <br>
sequences.</p>

<p style="margin-top: 1em">Date and time <br>
%D The date in yy-mm-dd format.</p>

<p style="margin-top: 1em">%T Current time of day, in
24-hour format.</p>

<p style="margin-top: 1em">%t <br>
%@ Current time of day, in 12-hour, am/pm format.</p>

<p style="margin-top: 1em">%* Current time of day in
24-hour format, with seconds.</p>

<p style="margin-top: 1em">%w The date in day-dd
format.</p>

<p style="margin-top: 1em">%W The date in mm/dd/yy
format.</p>

<p style="margin-top: 1em">%D{string} <br>
string is formatted using the strftime function. See
strftime(3) for more details. Various zsh extensions provide
numbers with no leading zero or space if the number is <br>
a single digit:</p>

<p style="margin-top: 1em">%f a day of the month <br>
%K the hour of the day on the 24-hour clock <br>
%L the hour of the day on the 12-hour clock</p>

<p style="margin-top: 1em">The GNU extension that a
&lsquo;-&rsquo; between the % and the format character
causes a leading zero or space to be stripped is handled
directly by the shell for the format charac&acirc; <br>
ters d, f, H, k, l, m, M, S and y; any other format
characters are provided to strftime() with any leading
&lsquo;-&rsquo;, present, so the handling is system
dependent. Further GNU <br>
extensions are not supported at present.</p>

<p style="margin-top: 1em">Visual effects <br>
%B (%b) <br>
Start (stop) boldface mode.</p>

<p style="margin-top: 1em">%E Clear to end of line.</p>

<p style="margin-top: 1em">%U (%u) <br>
Start (stop) underline mode.</p>

<p style="margin-top: 1em">%S (%s) <br>
Start (stop) standout mode.</p>

<p style="margin-top: 1em">%F (%f) <br>
Start (stop) using a different foreground colour, if
supported by the terminal. The colour may be specified two
ways: either as a numeric argument, as normal, or by a <br>
sequence in braces following the %F, for example %F{red}. In
the latter case the values allowed are as described for the
fg zle_highlight attribute; see Character High&acirc; <br>
lighting in zshzle(1). This means that numeric colours are
allowed in the second format also.</p>

<p style="margin-top: 1em">%K (%k) <br>
Start (stop) using a different bacKground colour. The syntax
is identical to that for %F and %f.</p>

<p style="margin-top: 1em">%{...%} <br>
Include a string as a literal escape sequence. The string
within the braces should not change the cursor position.
Brace pairs can nest.</p>

<p style="margin-top: 1em">A positive numeric argument
between the % and the { is treated as described for %G
below.</p>

<p style="margin-top: 1em">%G Within a %{...%} sequence,
include a &lsquo;glitch&rsquo;: that is, assume that a
single character width will be output. This is useful when
outputting characters that otherwise can&acirc; <br>
not be correctly handled by the shell, such as the alternate
character set on some terminals. The characters in question
can be included within a %{...%} sequence <br>
together with the appropriate number of %G sequences to
indicate the correct width. An integer between the
&lsquo;%&rsquo; and &lsquo;G&rsquo; indicates a character
width other than one. Hence <br>
%{seq%2G%} outputs seq and assumes it takes up the width of
two standard characters.</p>

<p style="margin-top: 1em">Multiple uses of %G accumulate
in the obvious fashion; the position of the %G is
unimportant. Negative integers are not handled.</p>

<p style="margin-top: 1em">Note that when prompt truncation
is in use it is advisable to divide up output into single
characters within each %{...%} group so that the correct
truncation point can be <br>
found.</p>

<p style="margin-top: 1em">CONDITIONAL SUBSTRINGS IN
PROMPTS <br>
%v The value of the first element of the psvar array
parameter. Following the &lsquo;%&rsquo; with an integer
gives that element of the array. Negative integers count
from the end of <br>
the array.</p>

<p style="margin-top: 1em">%(x.true-text.false-text) <br>
Specifies a ternary expression. The character following the
x is arbitrary; the same character is used to separate the
text for the &lsquo;true&rsquo; result from that for the
<br>
&lsquo;false&rsquo; result. This separator may not appear in
the true-text, except as part of a %-escape sequence. A
&lsquo;)&rsquo; may appear in the false-text as
&lsquo;%)&rsquo;. true-text and <br>
false-text may both contain arbitrarily-nested escape
sequences, including further ternary expressions.</p>

<p style="margin-top: 1em">The left parenthesis may be
preceded or followed by a positive integer n, which defaults
to zero. A negative integer will be multiplied by -1. The
test character x may <br>
be any of the following:</p>

<p style="margin-top: 1em">! True if the shell is running
with privileges. <br>
# True if the effective uid of the current process is n.
<br>
? True if the exit status of the last command was n. <br>
_ True if at least n shell constructs were started. <br>
C <br>
/ True if the current absolute path has at least n elements
relative to the root directory, hence / is counted as 0
elements. <br>
c <br>
. <br>
~ True if the current path, with prefix replacement, has at
least n elements relative to the root directory, hence / is
counted as 0 elements. <br>
D True if the month is equal to n (January = 0). <br>
d True if the day of the month is equal to n. <br>
g True if the effective gid of the current process is n.
<br>
j True if the number of jobs is at least n. <br>
L True if the SHLVL parameter is at least n. <br>
l True if at least n characters have already been printed on
the current line. <br>
S True if the SECONDS parameter is at least n. <br>
T True if the time in hours is equal to n. <br>
t True if the time in minutes is equal to n. <br>
v True if the array psvar has at least n elements. <br>
V True if element n of the array psvar is set and non-empty.
<br>
w True if the day of the week is equal to n (Sunday =
0).</p>

<p style="margin-top: 1em">%&lt;string&lt; <br>
%&gt;string&gt; <br>
%[xstring] <br>
Specifies truncation behaviour for the remainder of the
prompt string. The third, deprecated, form is equivalent to
&lsquo;%xstringx&rsquo;, i.e. x may be &lsquo;&lt;&rsquo; or
&lsquo;&gt;&rsquo;. The numeric <br>
argument, which in the third form may appear immediately
after the &lsquo;[&rsquo;, specifies the maximum permitted
length of the various strings that can be displayed in the
prompt. <br>
The string will be displayed in place of the truncated
portion of any string; note this does not undergo prompt
expansion.</p>

<p style="margin-top: 1em">The forms with
&lsquo;&lt;&rsquo; truncate at the left of the string, and
the forms with &lsquo;&gt;&rsquo; truncate at the right of
the string. For example, if the current directory is
&lsquo;/home/pike&rsquo;, <br>
the prompt &lsquo;%8&lt;..&lt;%/&rsquo; will expand to
&lsquo;..e/pike&rsquo;. In this string, the terminating
character (&lsquo;&lt;&rsquo;, &lsquo;&gt;&rsquo; or
&lsquo;]&rsquo;), or in fact any character, may be quoted by
a preceding &lsquo;&acute;; <br>
note when using print -P, however, that this must be doubled
as the string is also subject to standard print processing,
in addition to any backslashes removed by a double <br>
quoted string: the worst case is therefore &lsquo;print -P
&quot;%&lt;\\&lt;&lt;...&quot;&rsquo;.</p>

<p style="margin-top: 1em">If the string is longer than the
specified truncation length, it will appear in full,
completely replacing the truncated string.</p>

<p style="margin-top: 1em">The part of the prompt string to
be truncated runs to the end of the string, or to the end of
the next enclosing group of the &lsquo;%(&rsquo; construct,
or to the next truncation <br>
encountered at the same grouping level (i.e. truncations
inside a &lsquo;%(&rsquo; are separate), which ever comes
first. In particular, a truncation with argument zero (e.g.
&lsquo;%&lt;&lt;&rsquo;) <br>
marks the end of the range of the string to be truncated
while turning off truncation from there on. For example, the
prompt &rsquo;%10&lt;...&lt;%~%&lt;&lt;%# &rsquo; will print
a truncated rep&acirc; <br>
resentation of the current directory, followed by a
&lsquo;%&rsquo; or &lsquo;#&rsquo;, followed by a space.
Without the &lsquo;%&lt;&lt;&rsquo;, those two characters
would be included in the string to be trun&acirc; <br>
cated.</p>

<p style="margin-top: 1em">zsh 5.0.2 December 21, 2012
ZSHMISC(1)</p>
<hr>
</body>
</html>
