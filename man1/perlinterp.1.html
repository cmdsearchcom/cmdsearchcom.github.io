<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:30:56 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLINTERP(1) Perl Programmers Reference Guide
PERLINTERP(1)</p>

<p style="margin-top: 1em">NAME <br>
perlinterp - An overview of the Perl interpreter</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This document provides an overview of how the Perl
interpreter works at the level of C code, along with
pointers to the relevant C source code files.</p>

<p style="margin-top: 1em">ELEMENTS OF THE INTERPRETER <br>
The work of the interpreter has two main stages: compiling
the code into the internal representation, or bytecode, and
then executing it. &quot;Compiled code&quot; in perlguts
explains <br>
exactly how the compilation stage happens.</p>

<p style="margin-top: 1em">Here is a short breakdown of
perl&rsquo;s operation:</p>

<p style="margin-top: 1em">Startup <br>
The action begins in perlmain.c. (or miniperlmain.c for
miniperl) This is very high-level code, enough to fit on a
single screen, and it resembles the code found in perlembed;
<br>
most of the real action takes place in perl.c</p>

<p style="margin-top: 1em">perlmain.c is generated by
&quot;ExtUtils::Miniperl&quot; from miniperlmain.c at make
time, so you should make perl to follow this along.</p>

<p style="margin-top: 1em">First, perlmain.c allocates some
memory and constructs a Perl interpreter, along these
lines:</p>

<p style="margin-top: 1em">1
PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env); <br>
2 <br>
3 if (!PL_do_undump) { <br>
4 my_perl = perl_alloc(); <br>
5 if (!my_perl) <br>
6 exit(1); <br>
7 perl_construct(my_perl); <br>
8 PL_perl_destruct_level = 0; <br>
9 }</p>

<p style="margin-top: 1em">Line 1 is a macro, and its
definition is dependent on your operating system. Line 3
references &quot;PL_do_undump&quot;, a global variable - all
global variables in Perl start with &quot;PL_&quot;. <br>
This tells you whether the current running program was
created with the &quot;-u&quot; flag to perl and then
undump, which means it&rsquo;s going to be false in any sane
context.</p>

<p style="margin-top: 1em">Line 4 calls a function in
perl.c to allocate memory for a Perl interpreter. It&rsquo;s
quite a simple function, and the guts of it looks like
this:</p>

<p style="margin-top: 1em">my_perl =
(PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));</p>

<p style="margin-top: 1em">Here you see an example of
Perl&rsquo;s system abstraction, which we&rsquo;ll see
later: &quot;PerlMem_malloc&quot; is either your
system&rsquo;s &quot;malloc&quot;, or Perl&rsquo;s own
&quot;malloc&quot; as defined in malloc.c if <br>
you selected that option at configure time.</p>

<p style="margin-top: 1em">Next, in line 7, we construct
the interpreter using perl_construct, also in perl.c; this
sets up all the special variables that Perl needs, the
stacks, and so on.</p>

<p style="margin-top: 1em">Now we pass Perl the command
line options, and tell it to go:</p>

<p style="margin-top: 1em">exitstatus = perl_parse(my_perl,
xs_init, argc, argv, (char **)NULL); <br>
if (!exitstatus) <br>
perl_run(my_perl);</p>

<p style="margin-top: 1em">exitstatus =
perl_destruct(my_perl);</p>

<p style="margin-top: 1em">perl_free(my_perl);</p>

<p style="margin-top: 1em">&quot;perl_parse&quot; is
actually a wrapper around &quot;S_parse_body&quot;, as
defined in perl.c, which processes the command line options,
sets up any statically linked XS modules, opens the <br>
program and calls &quot;yyparse&quot; to parse it.</p>

<p style="margin-top: 1em">Parsing <br>
The aim of this stage is to take the Perl source, and turn
it into an op tree. We&rsquo;ll see what one of those looks
like later. Strictly speaking, there&rsquo;s three things
going on <br>
here.</p>

<p style="margin-top: 1em">&quot;yyparse&quot;, the parser,
lives in perly.c, although you&rsquo;re better off reading
the original YACC input in perly.y. (Yes, Virginia, there is
a YACC grammar for Perl!) The job of the <br>
parser is to take your code and &quot;understand&quot; it,
splitting it into sentences, deciding which operands go with
which operators and so on.</p>

<p style="margin-top: 1em">The parser is nobly assisted by
the lexer, which chunks up your input into tokens, and
decides what type of thing each token is: a variable name,
an operator, a bareword, a <br>
subroutine, a core function, and so on. The main point of
entry to the lexer is &quot;yylex&quot;, and that and its
associated routines can be found in toke.c. Perl isn&rsquo;t
much like other <br>
computer languages; it&rsquo;s highly context sensitive at
times, it can be tricky to work out what sort of token
something is, or where a token ends. As such, there&rsquo;s
a lot of <br>
interplay between the tokeniser and the parser, which can
get pretty frightening if you&rsquo;re not used to it.</p>

<p style="margin-top: 1em">As the parser understands a Perl
program, it builds up a tree of operations for the
interpreter to perform during execution. The routines which
construct and link together the <br>
various operations are to be found in op.c, and will be
examined later.</p>

<p style="margin-top: 1em">Optimization <br>
Now the parsing stage is complete, and the finished tree
represents the operations that the Perl interpreter needs to
perform to execute our program. Next, Perl does a dry run
<br>
over the tree looking for optimisations: constant
expressions such as &quot;3 + 4&quot; will be computed now,
and the optimizer will also see if any multiple operations
can be replaced <br>
with a single one. For instance, to fetch the variable $foo,
instead of grabbing the glob *foo and looking at the scalar
component, the optimizer fiddles the op tree to use a <br>
function which directly looks up the scalar in question. The
main optimizer is &quot;peep&quot; in op.c, and many ops
have their own optimizing functions.</p>

<p style="margin-top: 1em">Running <br>
Now we&rsquo;re finally ready to go: we have compiled Perl
byte code, and all that&rsquo;s left to do is run it. The
actual execution is done by the &quot;runops_standard&quot;
function in run.c; more <br>
specifically, it&rsquo;s done by these three innocent
looking lines:</p>

<p style="margin-top: 1em">while ((PL_op =
PL_op-&gt;op_ppaddr(aTHX))) { <br>
PERL_ASYNC_CHECK(); <br>
}</p>

<p style="margin-top: 1em">You may be more comfortable with
the Perl version of that:</p>

<p style="margin-top: 1em">PERL_ASYNC_CHECK() while
$Perl::op = &amp;{$Perl::op-&gt;{function}};</p>

<p style="margin-top: 1em">Well, maybe not. Anyway, each op
contains a function pointer, which stipulates the function
which will actually carry out the operation. This function
will return the next op in <br>
the sequence - this allows for things like &quot;if&quot;
which choose the next op dynamically at run time. The
&quot;PERL_ASYNC_CHECK&quot; makes sure that things like
signals interrupt execution <br>
if required.</p>

<p style="margin-top: 1em">The actual functions called are
known as PP code, and they&rsquo;re spread between four
files: pp_hot.c contains the &quot;hot&quot; code, which is
most often used and highly optimized, pp_sys.c <br>
contains all the system-specific functions, pp_ctl.c
contains the functions which implement control structures
(&quot;if&quot;, &quot;while&quot; and the like) and pp.c
contains everything else. <br>
These are, if you like, the C code for Perl&rsquo;s built-in
functions and operators.</p>

<p style="margin-top: 1em">Note that each &quot;pp_&quot;
function is expected to return a pointer to the next op.
Calls to perl subs (and eval blocks) are handled within the
same runops loop, and do not consume <br>
extra space on the C stack. For example,
&quot;pp_entersub&quot; and &quot;pp_entertry&quot; just
push a &quot;CxSUB&quot; or &quot;CxEVAL&quot; block struct
onto the context stack which contain the address of the op
<br>
following the sub call or eval. They then return the first
op of that sub or eval block, and so execution continues of
that sub or block. Later, a &quot;pp_leavesub&quot; or
&quot;pp_leavetry&quot; <br>
op pops the &quot;CxSUB&quot; or &quot;CxEVAL&quot;,
retrieves the return op from it, and returns it.</p>

<p style="margin-top: 1em">Exception handing <br>
Perl&rsquo;s exception handing (i.e. &quot;die&quot; etc.)
is built on top of the low-level
&quot;setjmp()&quot;/&quot;longjmp()&quot; C-library
functions. These basically provide a way to capture the
current PC <br>
and SP registers and later restore them; i.e. a
&quot;longjmp()&quot; continues at the point in code where a
previous &quot;setjmp()&quot; was done, with anything
further up on the C stack being <br>
lost. This is why code should always save values using
&quot;SAVE_FOO&quot; rather than in auto variables.</p>

<p style="margin-top: 1em">The perl core wraps
&quot;setjmp()&quot; etc in the macros
&quot;JMPENV_PUSH&quot; and &quot;JMPENV_JUMP&quot;. The
basic rule of perl exceptions is that &quot;exit&quot;, and
&quot;die&quot; (in the absence of &quot;eval&quot;) perform
a <br>
JMPENV_JUMP(2), while &quot;die&quot; within
&quot;eval&quot; does a JMPENV_JUMP(3).</p>

<p style="margin-top: 1em">At entry points to perl, such as
&quot;perl_parse()&quot;, &quot;perl_run()&quot; and
&quot;call_sv(cv, G_EVAL)&quot; each does a
&quot;JMPENV_PUSH&quot;, then enter a runops loop or
whatever, and handle possible <br>
exception returns. For a 2 return, final cleanup is
performed, such as popping stacks and calling
&quot;CHECK&quot; or &quot;END&quot; blocks. Amongst other
things, this is how scope cleanup still <br>
occurs during an &quot;exit&quot;.</p>

<p style="margin-top: 1em">If a &quot;die&quot; can find a
&quot;CxEVAL&quot; block on the context stack, then the
stack is popped to that level and the return op in that
block is assigned to &quot;PL_restartop&quot;; then a <br>
JMPENV_JUMP(3) is performed. This normally passes control
back to the guard. In the case of &quot;perl_run&quot; and
&quot;call_sv&quot;, a non-null &quot;PL_restartop&quot;
triggers re-entry to the runops <br>
loop. The is the normal way that &quot;die&quot; or
&quot;croak&quot; is handled within an &quot;eval&quot;.</p>

<p style="margin-top: 1em">Sometimes ops are executed
within an inner runops loop, such as tie, sort or overload
code. In this case, something like</p>

<p style="margin-top: 1em">sub FETCH { eval { die } }</p>

<p style="margin-top: 1em">would cause a longjmp right back
to the guard in &quot;perl_run&quot;, popping both runops
loops, which is clearly incorrect. One way to avoid this is
for the tie code to do a <br>
&quot;JMPENV_PUSH&quot; before executing &quot;FETCH&quot;
in the inner runops loop, but for efficiency reasons, perl
in fact just sets a flag, using &quot;CATCH_SET(TRUE)&quot;.
The &quot;pp_require&quot;, <br>
&quot;pp_entereval&quot; and &quot;pp_entertry&quot; ops
check this flag, and if true, they call &quot;docatch&quot;,
which does a &quot;JMPENV_PUSH&quot; and starts a new runops
level to execute the code, rather than <br>
doing it on the current loop.</p>

<p style="margin-top: 1em">As a further optimisation, on
exit from the eval block in the &quot;FETCH&quot;, execution
of the code following the block is still carried on in the
inner loop. When an exception is <br>
raised, &quot;docatch&quot; compares the &quot;JMPENV&quot;
level of the &quot;CxEVAL&quot; with &quot;PL_top_env&quot;
and if they differ, just re-throws the exception. In this
way any inner loops get popped.</p>

<p style="margin-top: 1em">Here&rsquo;s an example.</p>

<p style="margin-top: 1em">1: eval { tie @a,
&rsquo;A&rsquo; }; <br>
2: sub A::TIEARRAY { <br>
3: eval { die }; <br>
4: die; <br>
5: }</p>

<p style="margin-top: 1em">To run this code,
&quot;perl_run&quot; is called, which does a
&quot;JMPENV_PUSH&quot; then enters a runops loop. This loop
executes the eval and tie ops on line 1, with the eval
pushing a &quot;CxEVAL&quot; <br>
onto the context stack.</p>

<p style="margin-top: 1em">The &quot;pp_tie&quot; does a
&quot;CATCH_SET(TRUE)&quot;, then starts a second runops
loop to execute the body of &quot;TIEARRAY&quot;. When it
executes the entertry op on line 3, &quot;CATCH_GET&quot; is
true, so <br>
&quot;pp_entertry&quot; calls &quot;docatch&quot; which does
a &quot;JMPENV_PUSH&quot; and starts a third runops loop,
which then executes the die op. At this point the C call
stack looks like this:</p>

<p style="margin-top: 1em">Perl_pp_die <br>
Perl_runops # third loop <br>
S_docatch_body <br>
S_docatch <br>
Perl_pp_entertry <br>
Perl_runops # second loop <br>
S_call_body <br>
Perl_call_sv <br>
Perl_pp_tie <br>
Perl_runops # first loop <br>
S_run_body <br>
perl_run <br>
main</p>

<p style="margin-top: 1em">and the context and data stacks,
as shown by &quot;-Dstv&quot;, look like:</p>

<p style="margin-top: 1em">STACK 0: MAIN <br>
CX 0: BLOCK =&gt; <br>
CX 1: EVAL =&gt; AV() PV(&quot;A&quot; ) <br>
retop=leave <br>
STACK 1: MAGIC <br>
CX 0: SUB =&gt; <br>
retop=(null) <br>
CX 1: EVAL =&gt; * <br>
retop=nextstate</p>

<p style="margin-top: 1em">The die pops the first
&quot;CxEVAL&quot; off the context stack, sets
&quot;PL_restartop&quot; from it, does a JMPENV_JUMP(3), and
control returns to the top &quot;docatch&quot;. This then
starts another <br>
third-level runops level, which executes the nextstate,
pushmark and die ops on line 4. At the point that the second
&quot;pp_die&quot; is called, the C call stack looks exactly
like that <br>
above, even though we are no longer within an inner eval;
this is because of the optimization mentioned earlier.
However, the context stack now looks like this, ie with the
top <br>
CxEVAL popped:</p>

<p style="margin-top: 1em">STACK 0: MAIN <br>
CX 0: BLOCK =&gt; <br>
CX 1: EVAL =&gt; AV() PV(&quot;A&quot; ) <br>
retop=leave <br>
STACK 1: MAGIC <br>
CX 0: SUB =&gt; <br>
retop=(null)</p>

<p style="margin-top: 1em">The die on line 4 pops the
context stack back down to the CxEVAL, leaving it as:</p>

<p style="margin-top: 1em">STACK 0: MAIN <br>
CX 0: BLOCK =&gt;</p>

<p style="margin-top: 1em">As usual,
&quot;PL_restartop&quot; is extracted from the
&quot;CxEVAL&quot;, and a JMPENV_JUMP(3) done, which pops
the C stack back to the docatch:</p>

<p style="margin-top: 1em">S_docatch <br>
Perl_pp_entertry <br>
Perl_runops # second loop <br>
S_call_body <br>
Perl_call_sv <br>
Perl_pp_tie <br>
Perl_runops # first loop <br>
S_run_body <br>
perl_run <br>
main</p>

<p style="margin-top: 1em">In this case, because the
&quot;JMPENV&quot; level recorded in the &quot;CxEVAL&quot;
differs from the current one, &quot;docatch&quot; just does
a JMPENV_JUMP(3) and the C stack unwinds to:</p>

<p style="margin-top: 1em">perl_run <br>
main</p>

<p style="margin-top: 1em">Because &quot;PL_restartop&quot;
is non-null, &quot;run_body&quot; starts a new runops loop
and execution continues.</p>

<p style="margin-top: 1em">INTERNAL VARIABLE TYPES <br>
You should by now have had a look at perlguts, which tells
you about Perl&rsquo;s internal variable types: SVs, HVs,
AVs and the rest. If not, do that now.</p>

<p style="margin-top: 1em">These variables are used not
only to represent Perl-space variables, but also any
constants in the code, as well as some structures completely
internal to Perl. The symbol table, <br>
for instance, is an ordinary Perl hash. Your code is
represented by an SV as it&rsquo;s read into the parser; any
program files you call are opened via ordinary Perl
filehandles, and <br>
so on.</p>

<p style="margin-top: 1em">The core Devel::Peek module lets
us examine SVs from a Perl program. Let&rsquo;s see, for
instance, how Perl treats the constant
&quot;hello&quot;.</p>

<p style="margin-top: 1em">% perl -MDevel::Peek -e
&rsquo;Dump(&quot;hello&quot;)&rsquo; <br>
1 SV = PV(0xa041450) at 0xa04ecbc <br>
2 REFCNT = 1 <br>
3 FLAGS = (POK,READONLY,pPOK) <br>
4 PV = 0xa0484e0 &quot;hello&quot; <br>
5 CUR = 5 <br>
6 LEN = 6</p>

<p style="margin-top: 1em">Reading &quot;Devel::Peek&quot;
output takes a bit of practise, so let&rsquo;s go through it
line by line.</p>

<p style="margin-top: 1em">Line 1 tells us we&rsquo;re
looking at an SV which lives at 0xa04ecbc in memory. SVs
themselves are very simple structures, but they contain a
pointer to a more complex structure. In <br>
this case, it&rsquo;s a PV, a structure which holds a string
value, at location 0xa041450. Line 2 is the reference count;
there are no other references to this data, so it&rsquo;s
1.</p>

<p style="margin-top: 1em">Line 3 are the flags for this SV
- it&rsquo;s OK to use it as a PV, it&rsquo;s a read-only SV
(because it&rsquo;s a constant) and the data is a PV
internally. Next we&rsquo;ve got the contents of the <br>
string, starting at location 0xa0484e0.</p>

<p style="margin-top: 1em">Line 5 gives us the current
length of the string - note that this does not include the
null terminator. Line 6 is not the length of the string, but
the length of the currently <br>
allocated buffer; as the string grows, Perl automatically
extends the available storage via a routine called
&quot;SvGROW&quot;.</p>

<p style="margin-top: 1em">You can get at any of these
quantities from C very easily; just add &quot;Sv&quot; to
the name of the field shown in the snippet, and you&rsquo;ve
got a macro which will return the value: <br>
&quot;SvCUR(sv)&quot; returns the current length of the
string, &quot;SvREFCOUNT(sv)&quot; returns the reference
count, &quot;SvPV(sv, len)&quot; returns the string itself
with its length, and so on. More <br>
macros to manipulate these properties can be found in
perlguts.</p>

<p style="margin-top: 1em">Let&rsquo;s take an example of
manipulating a PV, from &quot;sv_catpvn&quot;, in sv.c</p>

<p style="margin-top: 1em">1 void <br>
2 Perl_sv_catpvn(pTHX_ register SV *sv, register const char
*ptr, register STRLEN len) <br>
3 { <br>
4 STRLEN tlen; <br>
5 char *junk;</p>

<p style="margin-top: 1em">6 junk = SvPV_force(sv, tlen);
<br>
7 SvGROW(sv, tlen + len + 1); <br>
8 if (ptr == junk) <br>
9 ptr = SvPVX(sv); <br>
10 Move(ptr,SvPVX(sv)+tlen,len,char); <br>
11 SvCUR(sv) += len; <br>
12 *SvEND(sv) = &rsquo; &rsquo;; <br>
13 (void)SvPOK_only_UTF8(sv); /* validate pointer */ <br>
14 SvTAINT(sv); <br>
15 }</p>

<p style="margin-top: 1em">This is a function which adds a
string, &quot;ptr&quot;, of length &quot;len&quot; onto the
end of the PV stored in &quot;sv&quot;. The first thing we
do in line 6 is make sure that the SV has a valid PV, by
<br>
calling the &quot;SvPV_force&quot; macro to force a PV. As a
side effect, &quot;tlen&quot; gets set to the current value
of the PV, and the PV itself is returned to
&quot;junk&quot;.</p>

<p style="margin-top: 1em">In line 7, we make sure that the
SV will have enough room to accommodate the old string, the
new string and the null terminator. If &quot;LEN&quot;
isn&rsquo;t big enough, &quot;SvGROW&quot; will <br>
reallocate space for us.</p>

<p style="margin-top: 1em">Now, if &quot;junk&quot; is the
same as the string we&rsquo;re trying to add, we can grab
the string directly from the SV; &quot;SvPVX&quot; is the
address of the PV in the SV.</p>

<p style="margin-top: 1em">Line 10 does the actual
catenation: the &quot;Move&quot; macro moves a chunk of
memory around: we move the string &quot;ptr&quot; to the end
of the PV - that&rsquo;s the start of the PV plus its
current <br>
length. We&rsquo;re moving &quot;len&quot; bytes of type
&quot;char&quot;. After doing so, we need to tell Perl
we&rsquo;ve extended the string, by altering &quot;CUR&quot;
to reflect the new length. &quot;SvEND&quot; is a macro <br>
which gives us the end of the string, so that needs to be a
&quot; &quot;.</p>

<p style="margin-top: 1em">Line 13 manipulates the flags;
since we&rsquo;ve changed the PV, any IV or NV values will
no longer be valid: if we have &quot;$a=10;
$a.=&quot;6&quot;;&quot; we don&rsquo;t want to use the old
IV of 10. <br>
&quot;SvPOK_only_utf8&quot; is a special UTF-8-aware version
of &quot;SvPOK_only&quot;, a macro which turns off the IOK
and NOK flags and turns on POK. The final
&quot;SvTAINT&quot; is a macro which launders <br>
tainted data if taint mode is turned on.</p>

<p style="margin-top: 1em">AVs and HVs are more
complicated, but SVs are by far the most common variable
type being thrown around. Having seen something of how we
manipulate these, let&rsquo;s go on and look at <br>
how the op tree is constructed.</p>

<p style="margin-top: 1em">OP TREES <br>
First, what is the op tree, anyway? The op tree is the
parsed representation of your program, as we saw in our
section on parsing, and it&rsquo;s the sequence of
operations that Perl <br>
goes through to execute your program, as we saw in
&quot;Running&quot;.</p>

<p style="margin-top: 1em">An op is a fundamental operation
that Perl can perform: all the built-in functions and
operators are ops, and there are a series of ops which deal
with concepts the interpreter <br>
needs internally - entering and leaving a block, ending a
statement, fetching a variable, and so on.</p>

<p style="margin-top: 1em">The op tree is connected in two
ways: you can imagine that there are two &quot;routes&quot;
through it, two orders in which you can traverse the tree.
First, parse order reflects how the <br>
parser understood the code, and secondly, execution order
tells perl what order to perform the operations in.</p>

<p style="margin-top: 1em">The easiest way to examine the
op tree is to stop Perl after it has finished parsing, and
get it to dump out the tree. This is exactly what the
compiler backends B::Terse, <br>
B::Concise and B::Debug do.</p>

<p style="margin-top: 1em">Let&rsquo;s have a look at how
Perl sees &quot;$a = $b + $c&quot;:</p>

<p style="margin-top: 1em">% perl -MO=Terse -e
&rsquo;$a=$b+$c&rsquo; <br>
1 LISTOP (0x8179888) leave <br>
2 OP (0x81798b0) enter <br>
3 COP (0x8179850) nextstate <br>
4 BINOP (0x8179828) sassign <br>
5 BINOP (0x8179800) add [1] <br>
6 UNOP (0x81796e0) null [15] <br>
7 SVOP (0x80fafe0) gvsv GV (0x80fa4cc) *b <br>
8 UNOP (0x81797e0) null [15] <br>
9 SVOP (0x8179700) gvsv GV (0x80efeb0) *c <br>
10 UNOP (0x816b4f0) null [15] <br>
11 SVOP (0x816dcf0) gvsv GV (0x80fa460) *a</p>

<p style="margin-top: 1em">Let&rsquo;s start in the middle,
at line 4. This is a BINOP, a binary operator, which is at
location 0x8179828. The specific operator in question is
&quot;sassign&quot; - scalar assignment - and <br>
you can find the code which implements it in the function
&quot;pp_sassign&quot; in pp_hot.c. As a binary operator, it
has two children: the add operator, providing the result of
&quot;$b+$c&quot;, <br>
is uppermost on line 5, and the left hand side is on line
10.</p>

<p style="margin-top: 1em">Line 10 is the null op: this
does exactly nothing. What is that doing there? If you see
the null op, it&rsquo;s a sign that something has been
optimized away after parsing. As we <br>
mentioned in &quot;Optimization&quot;, the optimization
stage sometimes converts two operations into one, for
example when fetching a scalar variable. When this happens,
instead of <br>
rewriting the op tree and cleaning up the dangling pointers,
it&rsquo;s easier just to replace the redundant operation
with the null op. Originally, the tree would have looked
like <br>
this:</p>

<p style="margin-top: 1em">10 SVOP (0x816b4f0) rv2sv [15]
<br>
11 SVOP (0x816dcf0) gv GV (0x80fa460) *a</p>

<p style="margin-top: 1em">That is, fetch the &quot;a&quot;
entry from the main symbol table, and then look at the
scalar component of it: &quot;gvsv&quot;
(&quot;pp_gvsv&quot; into pp_hot.c) happens to do both these
things.</p>

<p style="margin-top: 1em">The right hand side, starting at
line 5 is similar to what we&rsquo;ve just seen: we have the
&quot;add&quot; op (&quot;pp_add&quot; also in pp_hot.c) add
together two &quot;gvsv&quot;s.</p>

<p style="margin-top: 1em">Now, what&rsquo;s this
about?</p>

<p style="margin-top: 1em">1 LISTOP (0x8179888) leave <br>
2 OP (0x81798b0) enter <br>
3 COP (0x8179850) nextstate</p>

<p style="margin-top: 1em">&quot;enter&quot; and
&quot;leave&quot; are scoping ops, and their job is to
perform any housekeeping every time you enter and leave a
block: lexical variables are tidied up, unreferenced
variables <br>
are destroyed, and so on. Every program will have those
first three lines: &quot;leave&quot; is a list, and its
children are all the statements in the block. Statements are
delimited by <br>
&quot;nextstate&quot;, so a block is a collection of
&quot;nextstate&quot; ops, with the ops to be performed for
each statement being the children of &quot;nextstate&quot;.
&quot;enter&quot; is a single op which <br>
functions as a marker.</p>

<p style="margin-top: 1em">That&rsquo;s how Perl parsed the
program, from top to bottom:</p>

<p style="margin-top: 1em">Program <br>
| <br>
Statement <br>
| <br>
= <br>
/ / $a + <br>
/ $b $c</p>

<p style="margin-top: 1em">However, it&rsquo;s impossible
to perform the operations in this order: you have to find
the values of $b and $c before you add them together, for
instance. So, the other thread that <br>
runs through the op tree is the execution order: each op has
a field &quot;op_next&quot; which points to the next op to
be run, so following these pointers tells us how perl
executes the <br>
code. We can traverse the tree in this order using the
&quot;exec&quot; option to &quot;B::Terse&quot;:</p>

<p style="margin-top: 1em">% perl -MO=Terse,exec -e
&rsquo;$a=$b+$c&rsquo; <br>
1 OP (0x8179928) enter <br>
2 COP (0x81798c8) nextstate <br>
3 SVOP (0x81796c8) gvsv GV (0x80fa4d4) *b <br>
4 SVOP (0x8179798) gvsv GV (0x80efeb0) *c <br>
5 BINOP (0x8179878) add [1] <br>
6 SVOP (0x816dd38) gvsv GV (0x80fa468) *a <br>
7 BINOP (0x81798a0) sassign <br>
8 LISTOP (0x8179900) leave</p>

<p style="margin-top: 1em">This probably makes more sense
for a human: enter a block, start a statement. Get the
values of $b and $c, and add them together. Find $a, and
assign one to the other. Then <br>
leave.</p>

<p style="margin-top: 1em">The way Perl builds up these op
trees in the parsing process can be unravelled by examining
perly.y, the YACC grammar. Let&rsquo;s take the piece we
need to construct the tree for &quot;$a <br>
= $b + $c&quot;</p>

<p style="margin-top: 1em">1 term : term ASSIGNOP term <br>
2 { $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); } <br>
3 | term ADDOP term <br>
4 { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }</p>

<p style="margin-top: 1em">If you&rsquo;re not used to
reading BNF grammars, this is how it works: You&rsquo;re fed
certain things by the tokeniser, which generally end up in
upper case. Here, &quot;ADDOP&quot;, is provided <br>
when the tokeniser sees &quot;+&quot; in your code.
&quot;ASSIGNOP&quot; is provided when &quot;=&quot; is used
for assigning. These are &quot;terminal symbols&quot;,
because you can&rsquo;t get any simpler than them.</p>

<p style="margin-top: 1em">The grammar, lines one and three
of the snippet above, tells you how to build up more complex
forms. These complex forms, &quot;non-terminal symbols&quot;
are generally placed in lower <br>
case. &quot;term&quot; here is a non-terminal symbol,
representing a single expression.</p>

<p style="margin-top: 1em">The grammar gives you the
following rule: you can make the thing on the left of the
colon if you see all the things on the right in sequence.
This is called a &quot;reduction&quot;, and <br>
the aim of parsing is to completely reduce the input. There
are several different ways you can perform a reduction,
separated by vertical bars: so, &quot;term&quot; followed by
&quot;=&quot; <br>
followed by &quot;term&quot; makes a &quot;term&quot;, and
&quot;term&quot; followed by &quot;+&quot; followed by
&quot;term&quot; can also make a &quot;term&quot;.</p>

<p style="margin-top: 1em">So, if you see two terms with an
&quot;=&quot; or &quot;+&quot;, between them, you can turn
them into a single expression. When you do this, you execute
the code in the block on the next line: if <br>
you see &quot;=&quot;, you&rsquo;ll do the code in line 2.
If you see &quot;+&quot;, you&rsquo;ll do the code in line
4. It&rsquo;s this code which contributes to the op
tree.</p>

<p style="margin-top: 1em">| term ADDOP term <br>
{ $$ = newBINOP($2, 0, scalar($1), scalar($3)); }</p>

<p style="margin-top: 1em">What this does is creates a new
binary op, and feeds it a number of variables. The variables
refer to the tokens: $1 is the first token in the input, $2
the second, and so on - <br>
think regular expression backreferences. $$ is the op
returned from this reduction. So, we call
&quot;newBINOP&quot; to create a new binary operator. The
first parameter to &quot;newBINOP&quot;, a <br>
function in op.c, is the op type. It&rsquo;s an addition
operator, so we want the type to be &quot;ADDOP&quot;. We
could specify this directly, but it&rsquo;s right there as
the second token in the <br>
input, so we use $2. The second parameter is the op&rsquo;s
flags: 0 means &quot;nothing special&quot;. Then the things
to add: the left and right hand side of our expression, in
scalar context.</p>

<p style="margin-top: 1em">STACKS <br>
When perl executes something like &quot;addop&quot;, how
does it pass on its results to the next op? The answer is,
through the use of stacks. Perl has a number of stacks to
store things <br>
it&rsquo;s currently working on, and we&rsquo;ll look at the
three most important ones here.</p>

<p style="margin-top: 1em">Argument stack <br>
Arguments are passed to PP code and returned from PP code
using the argument stack, &quot;ST&quot;. The typical way to
handle arguments is to pop them off the stack, deal with
them how you <br>
wish, and then push the result back onto the stack. This is
how, for instance, the cosine operator works:</p>

<p style="margin-top: 1em">NV value; <br>
value = POPn; <br>
value = Perl_cos(value); <br>
XPUSHn(value);</p>

<p style="margin-top: 1em">We&rsquo;ll see a more tricky
example of this when we consider Perl&rsquo;s macros below.
&quot;POPn&quot; gives you the NV (floating point value) of
the top SV on the stack: the $x in &quot;cos($x)&quot;. Then
<br>
we compute the cosine, and push the result back as an NV.
The &quot;X&quot; in &quot;XPUSHn&quot; means that the stack
should be extended if necessary - it can&rsquo;t be
necessary here, because we know <br>
there&rsquo;s room for one more item on the stack, since
we&rsquo;ve just removed one! The &quot;XPUSH*&quot; macros
at least guarantee safety.</p>

<p style="margin-top: 1em">Alternatively, you can fiddle
with the stack directly: &quot;SP&quot; gives you the first
element in your portion of the stack, and &quot;TOP*&quot;
gives you the top SV/IV/NV/etc. on the stack. So, <br>
for instance, to do unary negation of an integer:</p>

<p style="margin-top: 1em">SETi(-TOPi);</p>

<p style="margin-top: 1em">Just set the integer value of
the top stack entry to its negation.</p>

<p style="margin-top: 1em">Argument stack manipulation in
the core is exactly the same as it is in XSUBs - see
perlxstut, perlxs and perlguts for a longer description of
the macros used in stack <br>
manipulation.</p>

<p style="margin-top: 1em">Mark stack <br>
I say &quot;your portion of the stack&quot; above because PP
code doesn&rsquo;t necessarily get the whole stack to
itself: if your function calls another function,
you&rsquo;ll only want to expose the <br>
arguments aimed for the called function, and not
(necessarily) let it get at your own data. The way we do
this is to have a &quot;virtual&quot; bottom-of-stack,
exposed to each function. <br>
The mark stack keeps bookmarks to locations in the argument
stack usable by each function. For instance, when dealing
with a tied variable, (internally, something with
&quot;P&quot; magic) <br>
Perl has to call methods for accesses to the tied variables.
However, we need to separate the arguments exposed to the
method to the argument exposed to the original function -
<br>
the store or fetch or whatever it may be. Here&rsquo;s
roughly how the tied &quot;push&quot; is implemented; see
&quot;av_push&quot; in av.c:</p>

<p style="margin-top: 1em">1 PUSHMARK(SP); <br>
2 EXTEND(SP,2); <br>
3 PUSHs(SvTIED_obj((SV*)av, mg)); <br>
4 PUSHs(val); <br>
5 PUTBACK; <br>
6 ENTER; <br>
7 call_method(&quot;PUSH&quot;, G_SCALAR|G_DISCARD); <br>
8 LEAVE;</p>

<p style="margin-top: 1em">Let&rsquo;s examine the whole
implementation, for practice:</p>

<p style="margin-top: 1em">1 PUSHMARK(SP);</p>

<p style="margin-top: 1em">Push the current state of the
stack pointer onto the mark stack. This is so that when
we&rsquo;ve finished adding items to the argument stack,
Perl knows how many things we&rsquo;ve added <br>
recently.</p>

<p style="margin-top: 1em">2 EXTEND(SP,2); <br>
3 PUSHs(SvTIED_obj((SV*)av, mg)); <br>
4 PUSHs(val);</p>

<p style="margin-top: 1em">We&rsquo;re going to add two
more items onto the argument stack: when you have a tied
array, the &quot;PUSH&quot; subroutine receives the object
and the value to be pushed, and that&rsquo;s exactly <br>
what we have here - the tied object, retrieved with
&quot;SvTIED_obj&quot;, and the value, the SV
&quot;val&quot;.</p>

<p style="margin-top: 1em">5 PUTBACK;</p>

<p style="margin-top: 1em">Next we tell Perl to update the
global stack pointer from our internal variable:
&quot;dSP&quot; only gave us a local copy, not a reference
to the global.</p>

<p style="margin-top: 1em">6 ENTER; <br>
7 call_method(&quot;PUSH&quot;, G_SCALAR|G_DISCARD); <br>
8 LEAVE;</p>

<p style="margin-top: 1em">&quot;ENTER&quot; and
&quot;LEAVE&quot; localise a block of code - they make sure
that all variables are tidied up, everything that has been
localised gets its previous value returned, and so on. <br>
Think of them as the &quot;{&quot; and &quot;}&quot; of a
Perl block.</p>

<p style="margin-top: 1em">To actually do the magic method
call, we have to call a subroutine in Perl space:
&quot;call_method&quot; takes care of that, and it&rsquo;s
described in perlcall. We call the &quot;PUSH&quot; method
in <br>
scalar context, and we&rsquo;re going to discard its return
value. The call_method() function removes the top element of
the mark stack, so there is nothing for the caller to clean
up.</p>

<p style="margin-top: 1em">Save stack <br>
C doesn&rsquo;t have a concept of local scope, so perl
provides one. We&rsquo;ve seen that &quot;ENTER&quot; and
&quot;LEAVE&quot; are used as scoping braces; the save stack
implements the C equivalent of, for <br>
example:</p>

<p style="margin-top: 1em">{ <br>
local $foo = 42; <br>
... <br>
}</p>

<p style="margin-top: 1em">See &quot;Localizing
changes&quot; in perlguts for how to use the save stack.</p>

<p style="margin-top: 1em">MILLIONS OF MACROS <br>
One thing you&rsquo;ll notice about the Perl source is that
it&rsquo;s full of macros. Some have called the pervasive
use of macros the hardest thing to understand, others find
it adds to <br>
clarity. Let&rsquo;s take an example, the code which
implements the addition operator:</p>

<p style="margin-top: 1em">1 PP(pp_add) <br>
2 { <br>
3 dSP; dATARGET; tryAMAGICbin(add,opASSIGN); <br>
4 { <br>
5 dPOPTOPnnrl_ul; <br>
6 SETn( left + right ); <br>
7 RETURN; <br>
8 } <br>
9 }</p>

<p style="margin-top: 1em">Every line here (apart from the
braces, of course) contains a macro. The first line sets up
the function declaration as Perl expects for PP code; line 3
sets up variable <br>
declarations for the argument stack and the target, the
return value of the operation. Finally, it tries to see if
the addition operation is overloaded; if so, the appropriate
<br>
subroutine is called.</p>

<p style="margin-top: 1em">Line 5 is another variable
declaration - all variable declarations start with
&quot;d&quot; - which pops from the top of the argument
stack two NVs (hence &quot;nn&quot;) and puts them into the
<br>
variables &quot;right&quot; and &quot;left&quot;, hence the
&quot;rl&quot;. These are the two operands to the addition
operator. Next, we call &quot;SETn&quot; to set the NV of
the return value to the result of adding <br>
the two values. This done, we return - the
&quot;RETURN&quot; macro makes sure that our return value is
properly handled, and we pass the next operator to run back
to the main run loop.</p>

<p style="margin-top: 1em">Most of these macros are
explained in perlapi, and some of the more important ones
are explained in perlxs as well. Pay special attention to
&quot;Background and <br>
PERL_IMPLICIT_CONTEXT&quot; in perlguts for information on
the &quot;[pad]THX_?&quot; macros.</p>

<p style="margin-top: 1em">FURTHER READING <br>
For more information on the Perl internals, please see the
documents listed at &quot;Internals and C Language
Interface&quot; in perl.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLINTERP(1)</p>
<hr>
</body>
</html>
