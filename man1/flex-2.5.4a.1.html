<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>FLEX(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">FLEX(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">FLEX(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
flex - fast lexical analyzer generator
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>flex</b> <b>[-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix
  -Sskeleton]</b> <b>[--help --version]</b> <i>[filename ...]</i>
<h1 class="Sh" title="Sh" id="OVERVIEW"><a class="selflink" href="#OVERVIEW">OVERVIEW</a></h1>
This manual describes <i>flex,</i> a tool for generating programs that perform
  pattern-matching on text. The manual includes both tutorial and reference
  sections:
<pre>
<div class="Pp"></div>
    Description
        a brief overview of the tool
<div class="Pp"></div>
    Some Simple Examples
<div class="Pp"></div>
    Format Of The Input File
<div class="Pp"></div>
    Patterns
        the extended regular expressions used by flex
<div class="Pp"></div>
    How The Input Is Matched
        the rules for determining what has been matched
<div class="Pp"></div>
    Actions
        how to specify what to do when a pattern is matched
<div class="Pp"></div>
    The Generated Scanner
        details regarding the scanner that flex produces;
        how to control the input source
<div class="Pp"></div>
    Start Conditions
        introducing context into your scanners, and
        managing &quot;mini-scanners&quot;
<div class="Pp"></div>
    Multiple Input Buffers
        how to manipulate multiple input sources; how to
        scan from strings instead of files
<div class="Pp"></div>
    End-of-file Rules
        special rules for matching the end of the input
<div class="Pp"></div>
    Miscellaneous Macros
        a summary of macros available to the actions
<div class="Pp"></div>
    Values Available To The User
        a summary of values available to the actions
<div class="Pp"></div>
    Interfacing With Yacc
        connecting flex scanners together with yacc parsers
<div class="Pp"></div>
    Options
        flex command-line options, and the &quot;%option&quot;
        directive
<div class="Pp"></div>
    Performance Considerations
        how to make your scanner go as fast as possible
<div class="Pp"></div>
    Generating C++ Scanners
        the (experimental) facility for generating C++
        scanner classes
<div class="Pp"></div>
    Incompatibilities With Lex And POSIX
        how flex differs from AT&amp;T lex and the POSIX lex
        standard
<div class="Pp"></div>
    Diagnostics
        those error messages produced by flex (or scanners
        it generates) whose meanings might not be apparent
<div class="Pp"></div>
    Files
        files used by flex
<div class="Pp"></div>
    Deficiencies / Bugs
        known problems with flex
<div class="Pp"></div>
    See Also
        other documentation, related tools
<div class="Pp"></div>
    Author
        includes contact information
<div class="Pp"></div>
</pre>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>flex</i> is a tool for generating <i>scanners:</i> programs which recognized
  lexical patterns in text. <i>flex</i> reads the given input files, or its
  standard input if no file names are given, for a description of a scanner to
  generate. The description is in the form of pairs of regular expressions and C
  code, called <i>rules. flex</i> generates as output a C source file,
  <b>lex.yy.c,</b> which defines a routine <b>yylex().</b> This file is compiled
  and linked with the <b>-lfl</b> library to produce an executable. When the
  executable is run, it analyzes its input for occurrences of the regular
  expressions. Whenever it finds one, it executes the corresponding C code.
<h1 class="Sh" title="Sh" id="SOME_SIMPLE_EXAMPLES"><a class="selflink" href="#SOME_SIMPLE_EXAMPLES">SOME
  SIMPLE EXAMPLES</a></h1>
First some simple examples to get the flavor of how one uses <i>flex.</i> The
  following <i>flex</i> input specifies a scanner which whenever it encounters
  the string &quot;username&quot; will replace it with the user's login name:
<pre>
<div class="Pp"></div>
    %%
    username    printf( &quot;%s&quot;, getlogin() );
<div class="Pp"></div>
</pre>
By default, any text not matched by a <i>flex</i> scanner is copied to the
  output, so the net effect of this scanner is to copy its input file to its
  output with each occurrence of &quot;username&quot; expanded. In this input,
  there is just one rule. &quot;username&quot; is the <i>pattern</i> and the
  &quot;printf&quot; is the <i>action.</i> The &quot;%%&quot; marks the
  beginning of the rules.
<div class="Pp"></div>
Here's another simple example:
<pre>
<div class="Pp"></div>
            int num_lines = 0, num_chars = 0;
<div class="Pp"></div>
    %%
    \n      ++num_lines; ++num_chars;
    .       ++num_chars;
<div class="Pp"></div>
    %%
    main()
            {
            yylex();
            printf( &quot;# of lines = %d, # of chars = %d\n&quot;,
                    num_lines, num_chars );
            }
<div class="Pp"></div>
</pre>
This scanner counts the number of characters and the number of lines in its
  input (it produces no output other than the final report on the counts). The
  first line declares two globals, &quot;num_lines&quot; and
  &quot;num_chars&quot;, which are accessible both inside <b>yylex()</b> and in
  the <b>main()</b> routine declared after the second &quot;%%&quot;. There are
  two rules, one which matches a newline (&quot;\n&quot;) and increments both
  the line count and the character count, and one which matches any character
  other than a newline (indicated by the &quot;.&quot; regular expression).
<div class="Pp"></div>
A somewhat more complicated example:
<pre>
<div class="Pp"></div>
    /* scanner for a toy Pascal-like language */
<div class="Pp"></div>
    %{
    /* need this for the call to atof() below */
    #include &lt;math.h&gt;
    %}
<div class="Pp"></div>
    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*
<div class="Pp"></div>
    %%
<div class="Pp"></div>
    {DIGIT}+    {
                printf( &quot;An integer: %s (%d)\n&quot;, yytext,
                        atoi( yytext ) );
                }
<div class="Pp"></div>
    {DIGIT}+&quot;.&quot;{DIGIT}*        {
                printf( &quot;A float: %s (%g)\n&quot;, yytext,
                        atof( yytext ) );
                }
<div class="Pp"></div>
    if|then|begin|end|procedure|function        {
                printf( &quot;A keyword: %s\n&quot;, yytext );
                }
<div class="Pp"></div>
    {ID}        printf( &quot;An identifier: %s\n&quot;, yytext );
<div class="Pp"></div>
    &quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;   printf( &quot;An operator: %s\n&quot;, yytext );
<div class="Pp"></div>
    &quot;{&quot;[^}\n]*&quot;}&quot;     /* eat up one-line comments */
<div class="Pp"></div>
    [ \t\n]+          /* eat up whitespace */
<div class="Pp"></div>
    .           printf( &quot;Unrecognized character: %s\n&quot;, yytext );
<div class="Pp"></div>
    %%
<div class="Pp"></div>
    main( argc, argv )
    int argc;
    char **argv;
        {
        ++argv, --argc;  /* skip over program name */
        if ( argc &gt; 0 )
                yyin = fopen( argv[0], &quot;r&quot; );
        else
                yyin = stdin;
        
        yylex();
        }
<div class="Pp"></div>
</pre>
This is the beginnings of a simple scanner for a language like Pascal. It
  identifies different types of <i>tokens</i> and reports on what it has seen.
<div class="Pp"></div>
The details of this example will be explained in the following sections.
<h1 class="Sh" title="Sh" id="FORMAT_OF_THE_INPUT_FILE"><a class="selflink" href="#FORMAT_OF_THE_INPUT_FILE">FORMAT
  OF THE INPUT FILE</a></h1>
The <i>flex</i> input file consists of three sections, separated by a line with
  just <b>%%</b> in it:
<pre>
<div class="Pp"></div>
    definitions
    %%
    rules
    %%
    user code
<div class="Pp"></div>
</pre>
The <i>definitions</i> section contains declarations of simple <i>name</i>
  definitions to simplify the scanner specification, and declarations of
  <i>start conditions,</i> which are explained in a later section.
<div class="Pp"></div>
Name definitions have the form:
<pre>
<div class="Pp"></div>
    name definition
<div class="Pp"></div>
</pre>
The &quot;name&quot; is a word beginning with a letter or an underscore ('_')
  followed by zero or more letters, digits, '_', or '-' (dash). The definition
  is taken to begin at the first non-white-space character following the name
  and continuing to the end of the line. The definition can subsequently be
  referred to using &quot;{name}&quot;, which will expand to
  &quot;(definition)&quot;. For example,
<pre>
<div class="Pp"></div>
    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*
<div class="Pp"></div>
</pre>
defines &quot;DIGIT&quot; to be a regular expression which matches a single
  digit, and &quot;ID&quot; to be a regular expression which matches a letter
  followed by zero-or-more letters-or-digits. A subsequent reference to
<pre>
<div class="Pp"></div>
    {DIGIT}+&quot;.&quot;{DIGIT}*
<div class="Pp"></div>
</pre>
is identical to
<pre>
<div class="Pp"></div>
    ([0-9])+&quot;.&quot;([0-9])*
<div class="Pp"></div>
</pre>
and matches one-or-more digits followed by a '.' followed by zero-or-more
  digits.
<div class="Pp"></div>
The <i>rules</i> section of the <i>flex</i> input contains a series of rules of
  the form:
<pre>
<div class="Pp"></div>
    pattern   action
<div class="Pp"></div>
</pre>
where the pattern must be unindented and the action must begin on the same line.
<div class="Pp"></div>
See below for a further description of patterns and actions.
<div class="Pp"></div>
Finally, the user code section is simply copied to <b>lex.yy.c</b> verbatim. It
  is used for companion routines which call or are called by the scanner. The
  presence of this section is optional; if it is missing, the second <b>%%</b>
  in the input file may be skipped, too.
<div class="Pp"></div>
In the definitions and rules sections, any <i>indented</i> text or text enclosed
  in <b>%{</b> and <b>%}</b> is copied verbatim to the output (with the %{}'s
  removed). The %{}'s must appear unindented on lines by themselves.
<div class="Pp"></div>
In the rules section, any indented or %{} text appearing before the first rule
  may be used to declare variables which are local to the scanning routine and
  (after the declarations) code which is to be executed whenever the scanning
  routine is entered. Other indented or %{} text in the rule section is still
  copied to the output, but its meaning is not well-defined and it may well
  cause compile-time errors (this feature is present for <i>POSIX</i>
  compliance; see below for other such features).
<div class="Pp"></div>
In the definitions section (but not in the rules section), an unindented comment
  (i.e., a line beginning with &quot;/*&quot;) is also copied verbatim to the
  output up to the next &quot;*/&quot;.
<h1 class="Sh" title="Sh" id="PATTERNS"><a class="selflink" href="#PATTERNS">PATTERNS</a></h1>
The patterns in the input are written using an extended set of regular
  expressions. These are:
<pre>
<div class="Pp"></div>
    x          match the character 'x'
    .          any character (byte) except newline
    [xyz]      a &quot;character class&quot;; in this case, the pattern
                 matches either an 'x', a 'y', or a 'z'
    [abj-oZ]   a &quot;character class&quot; with a range in it; matches
                 an 'a', a 'b', any letter from 'j' through 'o',
                 or a 'Z'
    [^A-Z]     a &quot;negated character class&quot;, i.e., any character
                 but those in the class.  In this case, any
                 character EXCEPT an uppercase letter.
    [^A-Z\n]   any character EXCEPT an uppercase letter or
                 a newline
    r*         zero or more r's, where r is any regular expression
    r+         one or more r's
    r?         zero or one r's (that is, &quot;an optional r&quot;)
    r{2,5}     anywhere from two to five r's
    r{2,}      two or more r's
    r{4}       exactly 4 r's
    {name}     the expansion of the &quot;name&quot; definition
               (see above)
    &quot;[xyz]\&quot;foo&quot;
               the literal string: [xyz]&quot;foo
    \X         if X is an 'a', 'b', 'f', 'n', 'r', 't', or 'v',
                 then the ANSI-C interpretation of \x.
                 Otherwise, a literal 'X' (used to escape
                 operators such as '*')
    \0         a NUL character (ASCII code 0)
    \123       the character with octal value 123
    \x2a       the character with hexadecimal value 2a
    (r)        match an r; parentheses are used to override
                 precedence (see below)
<div class="Pp"></div>
<div class="Pp"></div>
    rs         the regular expression r followed by the
                 regular expression s; called &quot;concatenation&quot;
<div class="Pp"></div>
<div class="Pp"></div>
    r|s        either an r or an s
<div class="Pp"></div>
<div class="Pp"></div>
    r/s        an r but only if it is followed by an s.  The
                 text matched by s is included when determining
                 whether this rule is the &quot;longest match&quot;,
                 but is then returned to the input before
                 the action is executed.  So the action only
                 sees the text matched by r.  This type
                 of pattern is called trailing context&quot;.
                 (There are some combinations of r/s that flex
                 cannot match correctly; see notes in the
                 Deficiencies / Bugs section below regarding
                 &quot;dangerous trailing context&quot;.)
    ^r         an r, but only at the beginning of a line (i.e.,
                 which just starting to scan, or right after a
                 newline has been scanned).
    r$         an r, but only at the end of a line (i.e., just
                 before a newline).  Equivalent to &quot;r/\n&quot;.
<div class="Pp"></div>
               Note that flex's notion of &quot;newline&quot; is exactly
               whatever the C compiler used to compile flex
               interprets '\n' as; in particular, on some DOS
               systems you must either filter out \r's in the
               input yourself, or explicitly use r/\r\n for &quot;r$&quot;.
<div class="Pp"></div>
<div class="Pp"></div>
    &lt;s&gt;r       an r, but only in start condition s (see
                 below for discussion of start conditions)
    &lt;s1,s2,s3&gt;r
               same, but in any of start conditions s1,
                 s2, or s3
    &lt;*&gt;r       an r in any start condition, even an exclusive one.
<div class="Pp"></div>
<div class="Pp"></div>
    &lt;&lt;EOF&gt;&gt;    an end-of-file
    &lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt;
               an end-of-file when in start condition s1 or s2
<div class="Pp"></div>
</pre>
Note that inside of a character class, all regular expression operators lose
  their special meaning except escape ('\') and the character class operators,
  '-', ']', and, at the beginning of the class, '^'.
<div class="Pp"></div>
The regular expressions listed above are grouped according to precedence, from
  highest precedence at the top to lowest at the bottom. Those grouped together
  have equal precedence. For example,
<pre>
<div class="Pp"></div>
    foo|bar*
<div class="Pp"></div>
</pre>
is the same as
<pre>
<div class="Pp"></div>
    (foo)|(ba(r*))
<div class="Pp"></div>
</pre>
since the '*' operator has higher precedence than concatenation, and
  concatenation higher than alternation ('|'). This pattern therefore matches
  <i>either</i> the string &quot;foo&quot; <i>or</i> the string &quot;ba&quot;
  followed by zero-or-more r's. To match &quot;foo&quot; or zero-or-more
  &quot;bar&quot;'s, use:
<pre>
<div class="Pp"></div>
    foo|(bar)*
<div class="Pp"></div>
</pre>
and to match zero-or-more &quot;foo&quot;'s-or-&quot;bar&quot;'s:
<pre>
<div class="Pp"></div>
    (foo|bar)*
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
In addition to characters and ranges of characters, character classes can also
  contain character class <i>expressions.</i> These are expressions enclosed
  inside <b>[:</b> and <b>:]</b> delimiters (which themselves must appear
  between the '[' and ']' of the character class; other elements may occur
  inside the character class, too). The valid expressions are:
<pre>
<div class="Pp"></div>
    [:alnum:] [:alpha:] [:blank:]
    [:cntrl:] [:digit:] [:graph:]
    [:lower:] [:print:] [:punct:]
    [:space:] [:upper:] [:xdigit:]
<div class="Pp"></div>
</pre>
These expressions all designate a set of characters equivalent to the
  corresponding standard C <b>isXXX</b> function. For example, <b>[:alnum:]</b>
  designates those characters for which <b>isalnum()</b> returns true - i.e.,
  any alphabetic or numeric. Some systems don't provide <b>isblank(),</b> so
  flex defines <b>[:blank:]</b> as a blank or a tab.
<div class="Pp"></div>
For example, the following character classes are all equivalent:
<pre>
<div class="Pp"></div>
    [[:alnum:]]
    [[:alpha:][:digit:]
    [[:alpha:]0-9]
    [a-zA-Z0-9]
<div class="Pp"></div>
</pre>
If your scanner is case-insensitive (the <b>-i</b> flag), then <b>[:upper:]</b>
  and <b>[:lower:]</b> are equivalent to <b>[:alpha:].</b>
<div class="Pp"></div>
Some notes on patterns:
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">A negated character class such as the example
      &quot;[^A-Z]&quot; above <i>will match a newline</i> unless &quot;\n&quot;
      (or an equivalent escape sequence) is one of the characters explicitly
      present in the negated character class (e.g., &quot;[^A-Z\n]&quot;). This
      is unlike how many other regular expression tools treat negated character
      classes, but unfortunately the inconsistency is historically entrenched.
      Matching newlines means that a pattern like [^&quot;]* can match the
      entire input unless there's another quote in the input.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">A rule can have at most one instance of trailing context
      (the '/' operator or the '$' operator). The start condition, '^', and
      &quot;&lt;&lt;EOF&gt;&gt;&quot; patterns can only occur at the beginning
      of a pattern, and, as well as with '/' and '$', cannot be grouped inside
      parentheses. A '^' which does not occur at the beginning of a rule or a
      '$' which does not occur at the end of a rule loses its special properties
      and is treated as a normal character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The following are illegal:
    <pre>
<div class="Pp"></div>
    foo/bar$
    &lt;sc1&gt;foo&lt;sc2&gt;bar
<div class="Pp"></div>
    </pre>
    Note that the first of these, can be written &quot;foo/bar\n&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The following will result in '$' or '^' being treated as a
      normal character:
    <pre>
<div class="Pp"></div>
    foo|(bar$)
    foo|^bar
<div class="Pp"></div>
    </pre>
    If what's wanted is a &quot;foo&quot; or a bar-followed-by-a-newline, the
      following could be used (the special '|' action is explained below):
    <pre>
<div class="Pp"></div>
    foo      |
    bar$     /* action goes here */
<div class="Pp"></div>
    </pre>
    A similar trick will work for matching a foo or a
      bar-at-the-beginning-of-a-line.</dd>
</dl>
<h1 class="Sh" title="Sh" id="HOW_THE_INPUT_IS_MATCHED"><a class="selflink" href="#HOW_THE_INPUT_IS_MATCHED">HOW
  THE INPUT IS MATCHED</a></h1>
When the generated scanner is run, it analyzes its input looking for strings
  which match any of its patterns. If it finds more than one match, it takes the
  one matching the most text (for trailing context rules, this includes the
  length of the trailing part, even though it will then be returned to the
  input). If it finds two or more matches of the same length, the rule listed
  first in the <i>flex</i> input file is chosen.
<div class="Pp"></div>
Once the match is determined, the text corresponding to the match (called the
  <i>token)</i> is made available in the global character pointer <b>yytext,</b>
  and its length in the global integer <b>yyleng.</b> The <i>action</i>
  corresponding to the matched pattern is then executed (a more detailed
  description of actions follows), and then the remaining input is scanned for
  another match.
<div class="Pp"></div>
If no match is found, then the <i>default rule</i> is executed: the next
  character in the input is considered matched and copied to the standard
  output. Thus, the simplest legal <i>flex</i> input is:
<pre>
<div class="Pp"></div>
    %%
<div class="Pp"></div>
</pre>
which generates a scanner that simply copies its input (one character at a time)
  to its output.
<div class="Pp"></div>
Note that <b>yytext</b> can be defined in two different ways: either as a
  character <i>pointer</i> or as a character <i>array.</i> You can control which
  definition <i>flex</i> uses by including one of the special directives
  <b>%pointer</b> or <b>%array</b> in the first (definitions) section of your
  flex input. The default is <b>%pointer,</b> unless you use the <b>-l</b> lex
  compatibility option, in which case <b>yytext</b> will be an array. The
  advantage of using <b>%pointer</b> is substantially faster scanning and no
  buffer overflow when matching very large tokens (unless you run out of dynamic
  memory). The disadvantage is that you are restricted in how your actions can
  modify <b>yytext</b> (see the next section), and calls to the <b>unput()</b>
  function destroys the present contents of <b>yytext,</b> which can be a
  considerable porting headache when moving between different <i>lex</i>
  versions.
<div class="Pp"></div>
The advantage of <b>%array</b> is that you can then modify <b>yytext</b> to your
  heart's content, and calls to <b>unput()</b> do not destroy <b>yytext</b> (see
  below). Furthermore, existing <i>lex</i> programs sometimes access
  <b>yytext</b> externally using declarations of the form:
<pre>
    extern char yytext[];
</pre>
This definition is erroneous when used with <b>%pointer,</b> but correct for
  <b>%array.</b>
<div class="Pp"></div>
<b>%array</b> defines <b>yytext</b> to be an array of <b>YYLMAX</b> characters,
  which defaults to a fairly large value. You can change the size by simply
  #define'ing <b>YYLMAX</b> to a different value in the first section of your
  <i>flex</i> input. As mentioned above, with <b>%pointer</b> yytext grows
  dynamically to accommodate large tokens. While this means your <b>%pointer</b>
  scanner can accommodate very large tokens (such as matching entire blocks of
  comments), bear in mind that each time the scanner must resize <b>yytext</b>
  it also must rescan the entire token from the beginning, so matching such
  tokens can prove slow. <b>yytext</b> presently does <i>not</i> dynamically
  grow if a call to <b>unput()</b> results in too much text being pushed back;
  instead, a run-time error results.
<div class="Pp"></div>
Also note that you cannot use <b>%array</b> with C++ scanner classes (the
  <b>c++</b> option; see below).
<h1 class="Sh" title="Sh" id="ACTIONS"><a class="selflink" href="#ACTIONS">ACTIONS</a></h1>
Each pattern in a rule has a corresponding action, which can be any arbitrary C
  statement. The pattern ends at the first non-escaped whitespace character; the
  remainder of the line is its action. If the action is empty, then when the
  pattern is matched the input token is simply discarded. For example, here is
  the specification for a program which deletes all occurrences of &quot;zap
  me&quot; from its input:
<pre>
<div class="Pp"></div>
    %%
    &quot;zap me&quot;
<div class="Pp"></div>
</pre>
(It will copy all other characters in the input to the output since they will be
  matched by the default rule.)
<div class="Pp"></div>
Here is a program which compresses multiple blanks and tabs down to a single
  blank, and throws away whitespace found at the end of a line:
<pre>
<div class="Pp"></div>
    %%
    [ \t]+        putchar( ' ' );
    [ \t]+$       /* ignore this token */
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
If the action contains a '{', then the action spans till the balancing '}' is
  found, and the action may cross multiple lines. <i>flex</i> knows about C
  strings and comments and won't be fooled by braces found within them, but also
  allows actions to begin with <b>%{</b> and will consider the action to be all
  the text up to the next <b>%}</b> (regardless of ordinary braces inside the
  action).
<div class="Pp"></div>
An action consisting solely of a vertical bar ('|') means &quot;same as the
  action for the next rule.&quot; See below for an illustration.
<div class="Pp"></div>
Actions can include arbitrary C code, including <b>return</b> statements to
  return a value to whatever routine called <b>yylex().</b> Each time
  <b>yylex()</b> is called it continues processing tokens from where it last
  left off until it either reaches the end of the file or executes a return.
<div class="Pp"></div>
Actions are free to modify <b>yytext</b> except for lengthening it (adding
  characters to its end--these will overwrite later characters in the input
  stream). This however does not apply when using <b>%array</b> (see above); in
  that case, <b>yytext</b> may be freely modified in any way.
<div class="Pp"></div>
Actions are free to modify <b>yyleng</b> except they should not do so if the
  action also includes use of <b>yymore()</b> (see below).
<div class="Pp"></div>
There are a number of special directives which can be included within an action:
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>ECHO</b> copies yytext to the scanner's output.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>BEGIN</b> followed by the name of a start condition
      places the scanner in the corresponding start condition (see below).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>REJECT</b> directs the scanner to proceed on to the
      &quot;second best&quot; rule which matched the input (or a prefix of the
      input). The rule is chosen as described above in &quot;How the Input is
      Matched&quot;, and <b>yytext</b> and <b>yyleng</b> set up appropriately.
      It may either be one which matched as much text as the originally chosen
      rule but came later in the <i>flex</i> input file, or one which matched
      less text. For example, the following will both count the words in the
      input and call the routine special() whenever &quot;frob&quot; is seen:
    <pre>
<div class="Pp"></div>
            int word_count = 0;
    %%
<div class="Pp"></div>
    frob        special(); REJECT;
    [^ \t\n]+   ++word_count;
<div class="Pp"></div>
    </pre>
    Without the <b>REJECT,</b> any &quot;frob&quot;'s in the input would not be
      counted as words, since the scanner normally executes only one action per
      token. Multiple <b>REJECT's</b> are allowed, each one finding the next
      best choice to the currently active rule. For example, when the following
      scanner scans the token &quot;abcd&quot;, it will write
      &quot;abcdabcaba&quot; to the output:
    <pre>
<div class="Pp"></div>
    %%
    a        |
    ab       |
    abc      |
    abcd     ECHO; REJECT;
    .|\n     /* eat up any unmatched character */
<div class="Pp"></div>
    </pre>
    (The first three rules share the fourth's action since they use the special
      '|' action.) <b>REJECT</b> is a particularly expensive feature in terms of
      scanner performance; if it is used in <i>any</i> of the scanner's actions
      it will slow down <i>all</i> of the scanner's matching. Furthermore,
      <b>REJECT</b> cannot be used with the <i>-Cf</i> or <i>-CF</i> options
      (see below).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note also that unlike the other special actions,
      <b>REJECT</b> is a <i>branch;</i> code immediately following it in the
      action will <i>not</i> be executed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>yymore()</b> tells the scanner that the next time it
      matches a rule, the corresponding token should be <i>appended</i> onto the
      current value of <b>yytext</b> rather than replacing it. For example,
      given the input &quot;mega-kludge&quot; the following will write
      &quot;mega-mega-kludge&quot; to the output:
    <pre>
<div class="Pp"></div>
    %%
    mega-    ECHO; yymore();
    kludge   ECHO;
<div class="Pp"></div>
    </pre>
    First &quot;mega-&quot; is matched and echoed to the output. Then
      &quot;kludge&quot; is matched, but the previous &quot;mega-&quot; is still
      hanging around at the beginning of <b>yytext</b> so the <b>ECHO</b> for
      the &quot;kludge&quot; rule will actually write
    &quot;mega-kludge&quot;.</dd>
</dl>
<div class="Pp"></div>
Two notes regarding use of <b>yymore().</b> First, <b>yymore()</b> depends on
  the value of <i>yyleng</i> correctly reflecting the size of the current token,
  so you must not modify <i>yyleng</i> if you are using <b>yymore().</b> Second,
  the presence of <b>yymore()</b> in the scanner's action entails a minor
  performance penalty in the scanner's matching speed.
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>yyless(n)</b> returns all but the first <i>n</i>
      characters of the current token back to the input stream, where they will
      be rescanned when the scanner looks for the next match. <b>yytext</b> and
      <b>yyleng</b> are adjusted appropriately (e.g., <b>yyleng</b> will now be
      equal to <i>n</i> ). For example, on the input &quot;foobar&quot; the
      following will write out &quot;foobarbar&quot;:
    <pre>
<div class="Pp"></div>
    %%
    foobar    ECHO; yyless(3);
    [a-z]+    ECHO;
<div class="Pp"></div>
    </pre>
    An argument of 0 to <b>yyless</b> will cause the entire current input string
      to be scanned again. Unless you've changed how the scanner will
      subsequently process its input (using <b>BEGIN,</b> for example), this
      will result in an endless loop.</dd>
</dl>
<div class="Pp"></div>
Note that <b>yyless</b> is a macro and can only be used in the flex input file,
  not from other source files.
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>unput(c)</b> puts the character <i>c</i> back onto the
      input stream. It will be the next character scanned. The following action
      will take the current token and cause it to be rescanned enclosed in
      parentheses.
    <pre>
<div class="Pp"></div>
    {
    int i;
    /* Copy yytext because unput() trashes yytext */
    char *yycopy = strdup( yytext );
    unput( ')' );
    for ( i = yyleng - 1; i &gt;= 0; --i )
        unput( yycopy[i] );
    unput( '(' );
    free( yycopy );
    }
<div class="Pp"></div>
    </pre>
    Note that since each <b>unput()</b> puts the given character back at the
      <i>beginning</i> of the input stream, pushing back strings must be done
      back-to-front.</dd>
</dl>
<div class="Pp"></div>
An important potential problem when using <b>unput()</b> is that if you are
  using <b>%pointer</b> (the default), a call to <b>unput()</b> <i>destroys</i>
  the contents of <i>yytext,</i> starting with its rightmost character and
  devouring one character to the left with each call. If you need the value of
  yytext preserved after a call to <b>unput()</b> (as in the above example), you
  must either first copy it elsewhere, or build your scanner using <b>%array</b>
  instead (see How The Input Is Matched).
<div class="Pp"></div>
Finally, note that you cannot put back <b>EOF</b> to attempt to mark the input
  stream with an end-of-file.
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>input()</b> reads the next character from the input
      stream. For example, the following is one way to eat up C comments:
    <pre>
<div class="Pp"></div>
    %%
    &quot;/*&quot;        {
                register int c;
<div class="Pp"></div>
                for ( ; ; )
                    {
                    while ( (c = input()) != '*' &amp;&amp;
                            c != EOF )
                        ;    /* eat up text of comment */
<div class="Pp"></div>
                    if ( c == '*' )
                        {
                        while ( (c = input()) == '*' )
                            ;
                        if ( c == '/' )
                            break;    /* found the end */
                        }
<div class="Pp"></div>
                    if ( c == EOF )
                        {
                        error( &quot;EOF in comment&quot; );
                        break;
                        }
                    }
                }
<div class="Pp"></div>
    </pre>
    (Note that if the scanner is compiled using <b>C++,</b> then <b>input()</b>
      is instead referred to as <b>yyinput(),</b> in order to avoid a name clash
      with the <b>C++</b> stream by the name of <i>input.)</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>YY_FLUSH_BUFFER</b> flushes the scanner's internal
      buffer so that the next time the scanner attempts to match a token, it
      will first refill the buffer using <b>YY_INPUT</b> (see The Generated
      Scanner, below). This action is a special case of the more general
      <b>yy_flush_buffer()</b> function, described below in the section Multiple
      Input Buffers.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>yyterminate()</b> can be used in lieu of a return
      statement in an action. It terminates the scanner and returns a 0 to the
      scanner's caller, indicating &quot;all done&quot;. By default,
      <b>yyterminate()</b> is also called when an end-of-file is encountered. It
      is a macro and may be redefined.</dd>
</dl>
<h1 class="Sh" title="Sh" id="THE_GENERATED_SCANNER"><a class="selflink" href="#THE_GENERATED_SCANNER">THE
  GENERATED SCANNER</a></h1>
The output of <i>flex</i> is the file <b>lex.yy.c,</b> which contains the
  scanning routine <b>yylex(),</b> a number of tables used by it for matching
  tokens, and a number of auxiliary routines and macros. By default,
  <b>yylex()</b> is declared as follows:
<pre>
<div class="Pp"></div>
    int yylex()
        {
        ... various definitions and the actions in here ...
        }
<div class="Pp"></div>
</pre>
(If your environment supports function prototypes, then it will be &quot;int
  yylex( void )&quot;.) This definition may be changed by defining the
  &quot;YY_DECL&quot; macro. For example, you could use:
<pre>
<div class="Pp"></div>
    #define YY_DECL float lexscan( a, b ) float a, b;
<div class="Pp"></div>
</pre>
to give the scanning routine the name <i>lexscan,</i> returning a float, and
  taking two floats as arguments. Note that if you give arguments to the
  scanning routine using a K&amp;R-style/non-prototyped function declaration,
  you must terminate the definition with a semi-colon (;).
<div class="Pp"></div>
Whenever <b>yylex()</b> is called, it scans tokens from the global input file
  <i>yyin</i> (which defaults to stdin). It continues until it either reaches an
  end-of-file (at which point it returns the value 0) or one of its actions
  executes a <i>return</i> statement.
<div class="Pp"></div>
If the scanner reaches an end-of-file, subsequent calls are undefined unless
  either <i>yyin</i> is pointed at a new input file (in which case scanning
  continues from that file), or <b>yyrestart()</b> is called. <b>yyrestart()</b>
  takes one argument, a <b>FILE *</b> pointer (which can be nil, if you've set
  up <b>YY_INPUT</b> to scan from a source other than <i>yyin),</i> and
  initializes <i>yyin</i> for scanning from that file. Essentially there is no
  difference between just assigning <i>yyin</i> to a new input file or using
  <b>yyrestart()</b> to do so; the latter is available for compatibility with
  previous versions of <i>flex,</i> and because it can be used to switch input
  files in the middle of scanning. It can also be used to throw away the current
  input buffer, by calling it with an argument of <i>yyin;</i> but better is to
  use <b>YY_FLUSH_BUFFER</b> (see above). Note that <b>yyrestart()</b> does
  <i>not</i> reset the start condition to <b>INITIAL</b> (see Start Conditions,
  below).
<div class="Pp"></div>
If <b>yylex()</b> stops scanning due to executing a <i>return</i> statement in
  one of the actions, the scanner may then be called again and it will resume
  scanning where it left off.
<div class="Pp"></div>
By default (and for purposes of efficiency), the scanner uses block-reads rather
  than simple <i>getc()</i> calls to read characters from <i>yyin.</i> The
  nature of how it gets its input can be controlled by defining the
  <b>YY_INPUT</b> macro. YY_INPUT's calling sequence is
  &quot;YY_INPUT(buf,result,max_size)&quot;. Its action is to place up to
  <i>max_size</i> characters in the character array <i>buf</i> and return in the
  integer variable <i>result</i> either the number of characters read or the
  constant YY_NULL (0 on Unix systems) to indicate EOF. The default YY_INPUT
  reads from the global file-pointer &quot;yyin&quot;.
<div class="Pp"></div>
A sample definition of YY_INPUT (in the definitions section of the input file):
<pre>
<div class="Pp"></div>
    %{
    #define YY_INPUT(buf,result,max_size) \
        { \
        int c = getchar(); \
        result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
        }
    %}
<div class="Pp"></div>
</pre>
This definition will change the input processing to occur one character at a
  time.
<div class="Pp"></div>
When the scanner receives an end-of-file indication from YY_INPUT, it then
  checks the <b>yywrap()</b> function. If <b>yywrap()</b> returns false (zero),
  then it is assumed that the function has gone ahead and set up <i>yyin</i> to
  point to another input file, and scanning continues. If it returns true
  (non-zero), then the scanner terminates, returning 0 to its caller. Note that
  in either case, the start condition remains unchanged; it does <i>not</i>
  revert to <b>INITIAL.</b>
<div class="Pp"></div>
If you do not supply your own version of <b>yywrap(),</b> then you must either
  use <b>%option noyywrap</b> (in which case the scanner behaves as though
  <b>yywrap()</b> returned 1), or you must link with <b>-lfl</b> to obtain the
  default version of the routine, which always returns 1.
<div class="Pp"></div>
Three routines are available for scanning from in-memory buffers rather than
  files: <b>yy_scan_string(), yy_scan_bytes(),</b> and <b>yy_scan_buffer().</b>
  See the discussion of them below in the section Multiple Input Buffers.
<div class="Pp"></div>
The scanner writes its <b>ECHO</b> output to the <i>yyout</i> global (default,
  stdout), which may be redefined by the user simply by assigning it to some
  other <b>FILE</b> pointer.
<h1 class="Sh" title="Sh" id="START_CONDITIONS"><a class="selflink" href="#START_CONDITIONS">START
  CONDITIONS</a></h1>
<i>flex</i> provides a mechanism for conditionally activating rules. Any rule
  whose pattern is prefixed with &quot;&lt;sc&gt;&quot; will only be active when
  the scanner is in the start condition named &quot;sc&quot;. For example,
<pre>
<div class="Pp"></div>
    &lt;STRING&gt;[^&quot;]*        { /* eat up the string body ... */
                ...
                }
<div class="Pp"></div>
</pre>
will be active only when the scanner is in the &quot;STRING&quot; start
  condition, and
<pre>
<div class="Pp"></div>
    &lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an escape ... */
                ...
                }
<div class="Pp"></div>
</pre>
will be active only when the current start condition is either
  &quot;INITIAL&quot;, &quot;STRING&quot;, or &quot;QUOTE&quot;.
<div class="Pp"></div>
Start conditions are declared in the definitions (first) section of the input
  using unindented lines beginning with either <b>%s</b> or <b>%x</b> followed
  by a list of names. The former declares <i>inclusive</i> start conditions, the
  latter <i>exclusive</i> start conditions. A start condition is activated using
  the <b>BEGIN</b> action. Until the next <b>BEGIN</b> action is executed, rules
  with the given start condition will be active and rules with other start
  conditions will be inactive. If the start condition is <i>inclusive,</i> then
  rules with no start conditions at all will also be active. If it is
  <i>exclusive,</i> then <i>only</i> rules qualified with the start condition
  will be active. A set of rules contingent on the same exclusive start
  condition describe a scanner which is independent of any of the other rules in
  the <i>flex</i> input. Because of this, exclusive start conditions make it
  easy to specify &quot;mini-scanners&quot; which scan portions of the input
  that are syntactically different from the rest (e.g., comments).
<div class="Pp"></div>
If the distinction between inclusive and exclusive start conditions is still a
  little vague, here's a simple example illustrating the connection between the
  two. The set of rules:
<pre>
<div class="Pp"></div>
    %s example
    %%
<div class="Pp"></div>
    &lt;example&gt;foo   do_something();
<div class="Pp"></div>
    bar            something_else();
<div class="Pp"></div>
</pre>
is equivalent to
<pre>
<div class="Pp"></div>
    %x example
    %%
<div class="Pp"></div>
    &lt;example&gt;foo   do_something();
<div class="Pp"></div>
    &lt;INITIAL,example&gt;bar    something_else();
<div class="Pp"></div>
</pre>
Without the <b>&lt;INITIAL,example&gt;</b> qualifier, the <i>bar</i> pattern in
  the second example wouldn't be active (i.e., couldn't match) when in start
  condition <b>example.</b> If we just used <b>&lt;example&gt;</b> to qualify
  <i>bar,</i> though, then it would only be active in <b>example</b> and not in
  <b>INITIAL,</b> while in the first example it's active in both, because in the
  first example the <b>example</b> startion condition is an <i>inclusive</i>
  <b>(%s)</b> start condition.
<div class="Pp"></div>
Also note that the special start-condition specifier <b>&lt;*&gt;</b> matches
  every start condition. Thus, the above example could also have been written;
<pre>
<div class="Pp"></div>
    %x example
    %%
<div class="Pp"></div>
    &lt;example&gt;foo   do_something();
<div class="Pp"></div>
    &lt;*&gt;bar    something_else();
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
The default rule (to <b>ECHO</b> any unmatched character) remains active in
  start conditions. It is equivalent to:
<pre>
<div class="Pp"></div>
    &lt;*&gt;.|\n     ECHO;
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
<b>BEGIN(0)</b> returns to the original state where only the rules with no start
  conditions are active. This state can also be referred to as the
  start-condition &quot;INITIAL&quot;, so <b>BEGIN(INITIAL)</b> is equivalent to
  <b>BEGIN(0).</b> (The parentheses around the start condition name are not
  required but are considered good style.)
<div class="Pp"></div>
<b>BEGIN</b> actions can also be given as indented code at the beginning of the
  rules section. For example, the following will cause the scanner to enter the
  &quot;SPECIAL&quot; start condition whenever <b>yylex()</b> is called and the
  global variable <i>enter_special</i> is true:
<pre>
<div class="Pp"></div>
            int enter_special;
<div class="Pp"></div>
    %x SPECIAL
    %%
            if ( enter_special )
                BEGIN(SPECIAL);
<div class="Pp"></div>
    &lt;SPECIAL&gt;blahblahblah
    ...more rules follow...
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
To illustrate the uses of start conditions, here is a scanner which provides two
  different interpretations of a string like &quot;123.456&quot;. By default it
  will treat it as three tokens, the integer &quot;123&quot;, a dot ('.'), and
  the integer &quot;456&quot;. But if the string is preceded earlier in the line
  by the string &quot;expect-floats&quot; it will treat it as a single token,
  the floating-point number 123.456:
<pre>
<div class="Pp"></div>
    %{
    #include &lt;math.h&gt;
    %}
    %s expect
<div class="Pp"></div>
    %%
    expect-floats        BEGIN(expect);
<div class="Pp"></div>
    &lt;expect&gt;[0-9]+&quot;.&quot;[0-9]+      {
                printf( &quot;found a float, = %f\n&quot;,
                        atof( yytext ) );
                }
    &lt;expect&gt;\n           {
                /* that's the end of the line, so
                 * we need another &quot;expect-number&quot;
                 * before we'll recognize any more
                 * numbers
                 */
                BEGIN(INITIAL);
                }
<div class="Pp"></div>
    [0-9]+      {
                printf( &quot;found an integer, = %d\n&quot;,
                        atoi( yytext ) );
                }
<div class="Pp"></div>
    &quot;.&quot;         printf( &quot;found a dot\n&quot; );
<div class="Pp"></div>
</pre>
Here is a scanner which recognizes (and discards) C comments while maintaining a
  count of the current input line.
<pre>
<div class="Pp"></div>
    %x comment
    %%
            int line_num = 1;
<div class="Pp"></div>
    &quot;/*&quot;         BEGIN(comment);
<div class="Pp"></div>
    &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
    &lt;comment&gt;&quot;*&quot;+[^*/\n]*   /* eat up '*'s not followed by '/'s */
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(INITIAL);
<div class="Pp"></div>
</pre>
This scanner goes to a bit of trouble to match as much text as possible with
  each rule. In general, when attempting to write a high-speed scanner try to
  match as much possible in each rule, as it's a big win.
<div class="Pp"></div>
Note that start-conditions names are really integer values and can be stored as
  such. Thus, the above could be extended in the following fashion:
<pre>
<div class="Pp"></div>
    %x comment foo
    %%
            int line_num = 1;
            int comment_caller;
<div class="Pp"></div>
    &quot;/*&quot;         {
                 comment_caller = INITIAL;
                 BEGIN(comment);
                 }
<div class="Pp"></div>
    ...
<div class="Pp"></div>
    &lt;foo&gt;&quot;/*&quot;    {
                 comment_caller = foo;
                 BEGIN(comment);
                 }
<div class="Pp"></div>
    &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
    &lt;comment&gt;&quot;*&quot;+[^*/\n]*   /* eat up '*'s not followed by '/'s */
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(comment_caller);
<div class="Pp"></div>
</pre>
Furthermore, you can access the current start condition using the integer-valued
  <b>YY_START</b> macro. For example, the above assignments to
  <i>comment_caller</i> could instead be written
<pre>
<div class="Pp"></div>
    comment_caller = YY_START;
<div class="Pp"></div>
</pre>
Flex provides <b>YYSTATE</b> as an alias for <b>YY_START</b> (since that is
  what's used by AT&amp;T <i>lex).</i>
<div class="Pp"></div>
Note that start conditions do not have their own name-space; %s's and %x's
  declare names in the same fashion as #define's.
<div class="Pp"></div>
Finally, here's an example of how to match C-style quoted strings using
  exclusive start conditions, including expanded escape sequences (but not
  including checking for a string that's too long):
<pre>
<div class="Pp"></div>
    %x str
<div class="Pp"></div>
    %%
            char string_buf[MAX_STR_CONST];
            char *string_buf_ptr;
<div class="Pp"></div>
<div class="Pp"></div>
    \&quot;      string_buf_ptr = string_buf; BEGIN(str);
<div class="Pp"></div>
    &lt;str&gt;\&quot;        { /* saw closing quote - all done */
            BEGIN(INITIAL);
            *string_buf_ptr = '\0';
            /* return string constant token type and
             * value to parser
             */
            }
<div class="Pp"></div>
    &lt;str&gt;\n        {
            /* error - unterminated string constant */
            /* generate error message */
            }
<div class="Pp"></div>
    &lt;str&gt;\\[0-7]{1,3} {
            /* octal escape sequence */
            int result;
<div class="Pp"></div>
            (void) sscanf( yytext + 1, &quot;%o&quot;, &amp;result );
<div class="Pp"></div>
            if ( result &gt; 0xff )
                    /* error, constant is out-of-bounds */
<div class="Pp"></div>
            *string_buf_ptr++ = result;
            }
<div class="Pp"></div>
    &lt;str&gt;\\[0-9]+ {
            /* generate error - bad escape sequence; something
             * like '\48' or '\0777777'
             */
            }
<div class="Pp"></div>
    &lt;str&gt;\\n  *string_buf_ptr++ = '\n';
    &lt;str&gt;\\t  *string_buf_ptr++ = '\t';
    &lt;str&gt;\\r  *string_buf_ptr++ = '\r';
    &lt;str&gt;\\b  *string_buf_ptr++ = '\b';
    &lt;str&gt;\\f  *string_buf_ptr++ = '\f';
<div class="Pp"></div>
    &lt;str&gt;\\(.|\n)  *string_buf_ptr++ = yytext[1];
<div class="Pp"></div>
    &lt;str&gt;[^\\\n\&quot;]+        {
            char *yptr = yytext;
<div class="Pp"></div>
            while ( *yptr )
                    *string_buf_ptr++ = *yptr++;
            }
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
Often, such as in some of the examples above, you wind up writing a whole bunch
  of rules all preceded by the same start condition(s). Flex makes this a little
  easier and cleaner by introducing a notion of start condition <i>scope.</i> A
  start condition scope is begun with:
<pre>
<div class="Pp"></div>
    &lt;SCs&gt;{
<div class="Pp"></div>
</pre>
where <i>SCs</i> is a list of one or more start conditions. Inside the start
  condition scope, every rule automatically has the prefix <i>&lt;SCs&gt;</i>
  applied to it, until a <i>'}'</i> which matches the initial <i>'{'.</i> So,
  for example,
<pre>
<div class="Pp"></div>
    &lt;ESC&gt;{
        &quot;\\n&quot;   return '\n';
        &quot;\\r&quot;   return '\r';
        &quot;\\f&quot;   return '\f';
        &quot;\\0&quot;   return '\0';
    }
<div class="Pp"></div>
</pre>
is equivalent to:
<pre>
<div class="Pp"></div>
    &lt;ESC&gt;&quot;\\n&quot;  return '\n';
    &lt;ESC&gt;&quot;\\r&quot;  return '\r';
    &lt;ESC&gt;&quot;\\f&quot;  return '\f';
    &lt;ESC&gt;&quot;\\0&quot;  return '\0';
<div class="Pp"></div>
</pre>
Start condition scopes may be nested.
<div class="Pp"></div>
Three routines are available for manipulating stacks of start conditions:
<dl class="Bl-tag">
  <dt class="It-tag"><b>void yy_push_state(int new_state)</b></dt>
  <dd class="It-tag">pushes the current start condition onto the top of the
      start condition stack and switches to <i>new_state</i> as though you had
      used <b>BEGIN new_state</b> (recall that start condition names are also
      integers).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>void yy_pop_state()</b></dt>
  <dd class="It-tag">pops the top of the stack and switches to it via
      <b>BEGIN.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>int yy_top_state()</b></dt>
  <dd class="It-tag">returns the top of the stack without altering the stack's
      contents.</dd>
</dl>
<div class="Pp"></div>
The start condition stack grows dynamically and so has no built-in size
  limitation. If memory is exhausted, program execution aborts.
<div class="Pp"></div>
To use start condition stacks, your scanner must include a <b>%option stack</b>
  directive (see Options below).
<h1 class="Sh" title="Sh" id="MULTIPLE_INPUT_BUFFERS"><a class="selflink" href="#MULTIPLE_INPUT_BUFFERS">MULTIPLE
  INPUT BUFFERS</a></h1>
Some scanners (such as those which support &quot;include&quot; files) require
  reading from several input streams. As <i>flex</i> scanners do a large amount
  of buffering, one cannot control where the next input will be read from by
  simply writing a <b>YY_INPUT</b> which is sensitive to the scanning context.
  <b>YY_INPUT</b> is only called when the scanner reaches the end of its buffer,
  which may be a long time after scanning a statement such as an
  &quot;include&quot; which requires switching the input source.
<div class="Pp"></div>
To negotiate these sorts of problems, <i>flex</i> provides a mechanism for
  creating and switching between multiple input buffers. An input buffer is
  created by using:
<pre>
<div class="Pp"></div>
    YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
<div class="Pp"></div>
</pre>
which takes a <i>FILE</i> pointer and a size and creates a buffer associated
  with the given file and large enough to hold <i>size</i> characters (when in
  doubt, use <b>YY_BUF_SIZE</b> for the size). It returns a
  <b>YY_BUFFER_STATE</b> handle, which may then be passed to other routines (see
  below). The <b>YY_BUFFER_STATE</b> type is a pointer to an opaque <b>struct
  yy_buffer_state</b> structure, so you may safely initialize YY_BUFFER_STATE
  variables to <b>((YY_BUFFER_STATE) 0)</b> if you wish, and also refer to the
  opaque structure in order to correctly declare input buffers in source files
  other than that of your scanner. Note that the <i>FILE</i> pointer in the call
  to <b>yy_create_buffer</b> is only used as the value of <i>yyin</i> seen by
  <b>YY_INPUT;</b> if you redefine <b>YY_INPUT</b> so it no longer uses
  <i>yyin,</i> then you can safely pass a nil <i>FILE</i> pointer to
  <b>yy_create_buffer.</b> You select a particular buffer to scan from using:
<pre>
<div class="Pp"></div>
    void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
<div class="Pp"></div>
</pre>
switches the scanner's input buffer so subsequent tokens will come from
  <i>new_buffer.</i> Note that <b>yy_switch_to_buffer()</b> may be used by
  yywrap() to set things up for continued scanning, instead of opening a new
  file and pointing <i>yyin</i> at it. Note also that switching input sources
  via either <b>yy_switch_to_buffer()</b> or <b>yywrap()</b> does <i>not</i>
  change the start condition.
<pre>
<div class="Pp"></div>
    void yy_delete_buffer( YY_BUFFER_STATE buffer )
<div class="Pp"></div>
</pre>
is used to reclaim the storage associated with a buffer. ( <b>buffer</b> can be
  nil, in which case the routine does nothing.) You can also clear the current
  contents of a buffer using:
<pre>
<div class="Pp"></div>
    void yy_flush_buffer( YY_BUFFER_STATE buffer )
<div class="Pp"></div>
</pre>
This function discards the buffer's contents, so the next time the scanner
  attempts to match a token from the buffer, it will first fill the buffer anew
  using <b>YY_INPUT.</b>
<div class="Pp"></div>
<b>yy_new_buffer()</b> is an alias for <b>yy_create_buffer(),</b> provided for
  compatibility with the C++ use of <i>new</i> and <i>delete</i> for creating
  and destroying dynamic objects.
<div class="Pp"></div>
Finally, the <b>YY_CURRENT_BUFFER</b> macro returns a <b>YY_BUFFER_STATE</b>
  handle to the current buffer.
<div class="Pp"></div>
Here is an example of using these features for writing a scanner which expands
  include files (the <b>&lt;&lt;EOF&gt;&gt;</b> feature is discussed below):
<pre>
<div class="Pp"></div>
    /* the &quot;incl&quot; state is used for picking up the name
     * of an include file
     */
    %x incl
<div class="Pp"></div>
    %{
    #define MAX_INCLUDE_DEPTH 10
    YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
    int include_stack_ptr = 0;
    %}
<div class="Pp"></div>
    %%
    include             BEGIN(incl);
<div class="Pp"></div>
    [a-z]+              ECHO;
    [^a-z\n]*\n?        ECHO;
<div class="Pp"></div>
    &lt;incl&gt;[ \t]*      /* eat the whitespace */
    &lt;incl&gt;[^ \t\n]+   { /* got the include file name */
            if ( include_stack_ptr &gt;= MAX_INCLUDE_DEPTH )
                {
                fprintf( stderr, &quot;Includes nested too deeply&quot; );
                exit( 1 );
                }
<div class="Pp"></div>
            include_stack[include_stack_ptr++] =
                YY_CURRENT_BUFFER;
<div class="Pp"></div>
            yyin = fopen( yytext, &quot;r&quot; );
<div class="Pp"></div>
            if ( ! yyin )
                error( ... );
<div class="Pp"></div>
            yy_switch_to_buffer(
                yy_create_buffer( yyin, YY_BUF_SIZE ) );
<div class="Pp"></div>
            BEGIN(INITIAL);
            }
<div class="Pp"></div>
    &lt;&lt;EOF&gt;&gt; {
            if ( --include_stack_ptr &lt; 0 )
                {
                yyterminate();
                }
<div class="Pp"></div>
            else
                {
                yy_delete_buffer( YY_CURRENT_BUFFER );
                yy_switch_to_buffer(
                     include_stack[include_stack_ptr] );
                }
            }
<div class="Pp"></div>
</pre>
Three routines are available for setting up input buffers for scanning in-memory
  strings instead of files. All of them create a new input buffer for scanning
  the string, and return a corresponding <b>YY_BUFFER_STATE</b> handle (which
  you should delete with <b>yy_delete_buffer()</b> when done with it). They also
  switch to the new buffer using <b>yy_switch_to_buffer(),</b> so the next call
  to <b>yylex()</b> will start scanning the string.
<dl class="Bl-tag">
  <dt class="It-tag"><b>yy_scan_string(const char *str)</b></dt>
  <dd class="It-tag">scans a NUL-terminated string.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>yy_scan_bytes(const char *bytes, int len)</b></dt>
  <dd class="It-tag">scans <i>len</i> bytes (including possibly NUL's) starting
      at location <i>bytes.</i></dd>
</dl>
<div class="Pp"></div>
Note that both of these functions create and scan a <i>copy</i> of the string or
  bytes. (This may be desirable, since <b>yylex()</b> modifies the contents of
  the buffer it is scanning.) You can avoid the copy by using:
<dl class="Bl-tag">
  <dt class="It-tag"><b>yy_scan_buffer(char *base, yy_size_t size)</b></dt>
  <dd class="It-tag">which scans in place the buffer starting at <i>base,</i>
      consisting of <i>size</i> bytes, the last two bytes of which <i>must</i>
      be <b>YY_END_OF_BUFFER_CHAR</b> (ASCII NUL). These last two bytes are not
      scanned; thus, scanning consists of <b>base[0]</b> through
      <b>base[size-2],</b> inclusive.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If you fail to set up <i>base</i> in this manner (i.e.,
      forget the final two <b>YY_END_OF_BUFFER_CHAR</b> bytes), then
      <b>yy_scan_buffer()</b> returns a nil pointer instead of creating a new
      input buffer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The type <b>yy_size_t</b> is an integral type to which you
      can cast an integer expression reflecting the size of the buffer.</dd>
</dl>
<h1 class="Sh" title="Sh" id="END-OF-FILE_RULES"><a class="selflink" href="#END-OF-FILE_RULES">END-OF-FILE
  RULES</a></h1>
The special rule &quot;&lt;&lt;EOF&gt;&gt;&quot; indicates actions which are to
  be taken when an end-of-file is encountered and yywrap() returns non-zero
  (i.e., indicates no further files to process). The action must finish by doing
  one of four things:
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">assigning <i>yyin</i> to a new input file (in previous
      versions of flex, after doing the assignment you had to call the special
      action <b>YY_NEW_FILE;</b> this is no longer necessary);</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">executing a <i>return</i> statement;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">executing the special <b>yyterminate()</b> action;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">or, switching to a new buffer using
      <b>yy_switch_to_buffer()</b> as shown in the example above.</dd>
</dl>
<div class="Pp"></div>
&lt;&lt;EOF&gt;&gt; rules may not be used with other patterns; they may only be
  qualified with a list of start conditions. If an unqualified
  &lt;&lt;EOF&gt;&gt; rule is given, it applies to <i>all</i> start conditions
  which do not already have &lt;&lt;EOF&gt;&gt; actions. To specify an
  &lt;&lt;EOF&gt;&gt; rule for only the initial start condition, use
<pre>
<div class="Pp"></div>
    &lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
These rules are useful for catching things like unclosed comments. An example:
<pre>
<div class="Pp"></div>
    %x quote
    %%
<div class="Pp"></div>
    ...other rules for dealing with quotes...
<div class="Pp"></div>
    &lt;quote&gt;&lt;&lt;EOF&gt;&gt;   {
             error( &quot;unterminated quote&quot; );
             yyterminate();
             }
    &lt;&lt;EOF&gt;&gt;  {
             if ( *++filelist )
                 yyin = fopen( *filelist, &quot;r&quot; );
             else
                yyterminate();
             }
<div class="Pp"></div>
</pre>
<h1 class="Sh" title="Sh" id="MISCELLANEOUS_MACROS"><a class="selflink" href="#MISCELLANEOUS_MACROS">MISCELLANEOUS
  MACROS</a></h1>
The macro <b>YY_USER_ACTION</b> can be defined to provide an action which is
  always executed prior to the matched rule's action. For example, it could be
  #define'd to call a routine to convert yytext to lower-case. When
  <b>YY_USER_ACTION</b> is invoked, the variable <i>yy_act</i> gives the number
  of the matched rule (rules are numbered starting with 1). Suppose you want to
  profile how often each of your rules is matched. The following would do the
  trick:
<pre>
<div class="Pp"></div>
    #define YY_USER_ACTION ++ctr[yy_act]
<div class="Pp"></div>
</pre>
where <i>ctr</i> is an array to hold the counts for the different rules. Note
  that the macro <b>YY_NUM_RULES</b> gives the total number of rules (including
  the default rule, even if you use <b>-s),</b> so a correct declaration for
  <i>ctr</i> is:
<pre>
<div class="Pp"></div>
    int ctr[YY_NUM_RULES];
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
The macro <b>YY_USER_INIT</b> may be defined to provide an action which is
  always executed before the first scan (and before the scanner's internal
  initializations are done). For example, it could be used to call a routine to
  read in a data table or open a logging file.
<div class="Pp"></div>
The macro <b>yy_set_interactive(is_interactive)</b> can be used to control
  whether the current buffer is considered <i>interactive.</i> An interactive
  buffer is processed more slowly, but must be used when the scanner's input
  source is indeed interactive to avoid problems due to waiting to fill buffers
  (see the discussion of the <b>-I</b> flag below). A non-zero value in the
  macro invocation marks the buffer as interactive, a zero value as
  non-interactive. Note that use of this macro overrides <b>%option
  always-interactive</b> or <b>%option never-interactive</b> (see Options
  below). <b>yy_set_interactive()</b> must be invoked prior to beginning to scan
  the buffer that is (or is not) to be considered interactive.
<div class="Pp"></div>
The macro <b>yy_set_bol(at_bol)</b> can be used to control whether the current
  buffer's scanning context for the next token match is done as though at the
  beginning of a line. A non-zero macro argument makes rules anchored with
<div class="Pp"></div>
The macro <b>YY_AT_BOL()</b> returns true if the next token scanned from the
  current buffer will have '^' rules active, false otherwise.
<div class="Pp"></div>
In the generated scanner, the actions are all gathered in one large switch
  statement and separated using <b>YY_BREAK,</b> which may be redefined. By
  default, it is simply a &quot;break&quot;, to separate each rule's action from
  the following rule's. Redefining <b>YY_BREAK</b> allows, for example, C++
  users to #define YY_BREAK to do nothing (while being very careful that every
  rule ends with a &quot;break&quot; or a &quot;return&quot;!) to avoid
  suffering from unreachable statement warnings where because a rule's action
  ends with &quot;return&quot;, the <b>YY_BREAK</b> is inaccessible.
<h1 class="Sh" title="Sh" id="VALUES_AVAILABLE_TO_THE_USER"><a class="selflink" href="#VALUES_AVAILABLE_TO_THE_USER">VALUES
  AVAILABLE TO THE USER</a></h1>
This section summarizes the various values available to the user in the rule
  actions.
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>char *yytext</b> holds the text of the current token. It
      may be modified but not lengthened (you cannot append characters to the
      end).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">If the special directive <b>%array</b> appears in the first
      section of the scanner description, then <b>yytext</b> is instead declared
      <b>char yytext[YYLMAX],</b> where <b>YYLMAX</b> is a macro definition that
      you can redefine in the first section if you don't like the default value
      (generally 8KB). Using <b>%array</b> results in somewhat slower scanners,
      but the value of <b>yytext</b> becomes immune to calls to <i>input()</i>
      and <i>unput(),</i> which potentially destroy its value when <b>yytext</b>
      is a character pointer. The opposite of <b>%array</b> is <b>%pointer,</b>
      which is the default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">You cannot use <b>%array</b> when generating C++ scanner
      classes (the <b>-+</b> flag).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>int yyleng</b> holds the length of the current
    token.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>FILE *yyin</b> is the file which by default <i>flex</i>
      reads from. It may be redefined but doing so only makes sense before
      scanning begins or after an EOF has been encountered. Changing it in the
      midst of scanning will have unexpected results since <i>flex</i> buffers
      its input; use <b>yyrestart()</b> instead. Once scanning terminates
      because an end-of-file has been seen, you can assign <i>yyin</i> at the
      new input file and then call the scanner again to continue scanning.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>void yyrestart( FILE *new_file )</b> may be called to
      point <i>yyin</i> at the new input file. The switch-over to the new file
      is immediate (any previously buffered-up input is lost). Note that calling
      <b>yyrestart()</b> with <i>yyin</i> as an argument thus throws away the
      current input buffer and continues scanning the same input file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>FILE *yyout</b> is the file to which <b>ECHO</b> actions
      are done. It can be reassigned by the user.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>YY_CURRENT_BUFFER</b> returns a <b>YY_BUFFER_STATE</b>
      handle to the current buffer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>YY_START</b> returns an integer value corresponding to
      the current start condition. You can subsequently use this value with
      <b>BEGIN</b> to return to that start condition.</dd>
</dl>
<h1 class="Sh" title="Sh" id="INTERFACING_WITH_YACC"><a class="selflink" href="#INTERFACING_WITH_YACC">INTERFACING
  WITH YACC</a></h1>
One of the main uses of <i>flex</i> is as a companion to the <i>yacc</i>
  parser-generator. <i>yacc</i> parsers expect to call a routine named
  <b>yylex()</b> to find the next input token. The routine is supposed to return
  the type of the next token as well as putting any associated value in the
  global <b>yylval.</b> To use <i>flex</i> with <i>yacc,</i> one specifies the
  <b>-d</b> option to <i>yacc</i> to instruct it to generate the file
  <b>y.tab.h</b> containing definitions of all the <b>%tokens</b> appearing in
  the <i>yacc</i> input. This file is then included in the <i>flex</i> scanner.
  For example, if one of the tokens is &quot;TOK_NUMBER&quot;, part of the
  scanner might look like:
<pre>
<div class="Pp"></div>
    %{
    #include &quot;y.tab.h&quot;
    %}
<div class="Pp"></div>
    %%
<div class="Pp"></div>
    [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;
<div class="Pp"></div>
</pre>
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<i>flex</i> has the following options:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-b</b></dt>
  <dd class="It-tag">Generate backing-up information to <i>lex.backup.</i> This
      is a list of scanner states which require backing up and the input
      characters on which they do so. By adding rules one can remove backing-up
      states. If <i>all</i> backing-up states are eliminated and <b>-Cf</b> or
      <b>-CF</b> is used, the generated scanner will run faster (see the
      <b>-p</b> flag). Only users who wish to squeeze every last cycle out of
      their scanners need worry about this option. (See the section on
      Performance Considerations below.)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-c</b></dt>
  <dd class="It-tag">is a do-nothing, deprecated option included for POSIX
      compliance.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b></dt>
  <dd class="It-tag">makes the generated scanner run in <i>debug</i> mode.
      Whenever a pattern is recognized and the global <b>yy_flex_debug</b> is
      non-zero (which is the default), the scanner will write to <i>stderr</i> a
      line of the form:
    <pre>
<div class="Pp"></div>
    --accepting rule at line 53 (&quot;the matched text&quot;)
<div class="Pp"></div>
    </pre>
    The line number refers to the location of the rule in the file defining the
      scanner (i.e., the file that was fed to flex). Messages are also generated
      when the scanner backs up, accepts the default rule, reaches the end of
      its input buffer (or encounters a NUL; at this point, the two look the
      same as far as the scanner's concerned), or reaches an end-of-file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b></dt>
  <dd class="It-tag">specifies <i>fast scanner.</i> No table compression is done
      and stdio is bypassed. The result is large but fast. This option is
      equivalent to <b>-Cfr</b> (see below).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b></dt>
  <dd class="It-tag">generates a &quot;help&quot; summary of <i>flex's</i>
      options to <i>stdout</i> and then exits. <b>-?</b> and <b>--help</b> are
      synonyms for <b>-h.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b></dt>
  <dd class="It-tag">instructs <i>flex</i> to generate a <i>case-insensitive</i>
      scanner. The case of letters given in the <i>flex</i> input patterns will
      be ignored, and tokens in the input will be matched regardless of case.
      The matched text given in <i>yytext</i> will have the preserved case
      (i.e., it will not be folded).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-l</b></dt>
  <dd class="It-tag">turns on maximum compatibility with the original AT&amp;T
      <i>lex</i> implementation. Note that this does not mean <i>full</i>
      compatibility. Use of this option costs a considerable amount of
      performance, and it cannot be used with the <b>-+, -f, -F, -Cf,</b> or
      <b>-CF</b> options. For details on the compatibilities it provides, see
      the section &quot;Incompatibilities With Lex And POSIX&quot; below. This
      option also results in the name <b>YY_FLEX_LEX_COMPAT</b> being #define'd
      in the generated scanner.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-n</b></dt>
  <dd class="It-tag">is another do-nothing, deprecated option included only for
      POSIX compliance.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-p</b></dt>
  <dd class="It-tag">generates a performance report to stderr. The report
      consists of comments regarding features of the <i>flex</i> input file
      which will cause a serious loss of performance in the resulting scanner.
      If you give the flag twice, you will also get comments regarding features
      that lead to minor performance losses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note that the use of <b>REJECT,</b> <b>%option
      yylineno,</b> and variable trailing context (see the Deficiencies / Bugs
      section below) entails a substantial performance penalty; use of
      <i>yymore(),</i> the <b>^</b> operator, and the <b>-I</b> flag entail
      minor performance penalties.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b></dt>
  <dd class="It-tag">causes the <i>default rule</i> (that unmatched scanner
      input is echoed to <i>stdout)</i> to be suppressed. If the scanner
      encounters input that does not match any of its rules, it aborts with an
      error. This option is useful for finding holes in a scanner's rule
    set.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-t</b></dt>
  <dd class="It-tag">instructs <i>flex</i> to write the scanner it generates to
      standard output instead of <b>lex.yy.c.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-v</b></dt>
  <dd class="It-tag">specifies that <i>flex</i> should write to <i>stderr</i> a
      summary of statistics regarding the scanner it generates. Most of the
      statistics are meaningless to the casual <i>flex</i> user, but the first
      line identifies the version of <i>flex</i> (same as reported by
      <b>-V),</b> and the next line the flags used when generating the scanner,
      including those that are on by default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-w</b></dt>
  <dd class="It-tag">suppresses warning messages.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-B</b></dt>
  <dd class="It-tag">instructs <i>flex</i> to generate a <i>batch</i> scanner,
      the opposite of <i>interactive</i> scanners generated by <b>-I</b> (see
      below). In general, you use <b>-B</b> when you are <i>certain</i> that
      your scanner will never be used interactively, and you want to squeeze a
      <i>little</i> more performance out of it. If your goal is instead to
      squeeze out a <i>lot</i> more performance, you should be using the
      <b>-Cf</b> or <b>-CF</b> options (discussed below), which turn on
      <b>-B</b> automatically anyway.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-F</b></dt>
  <dd class="It-tag">specifies that the fast scanner table representation should
      be used (and stdio bypassed). This representation is about as fast as the
      full table representation <b>(-f),</b> and for some sets of patterns will
      be considerably smaller (and for others, larger). In general, if the
      pattern set contains both &quot;keywords&quot; and a catch-all,
      &quot;identifier&quot; rule, such as in the set:
    <pre>
<div class="Pp"></div>
    &quot;case&quot;    return TOK_CASE;
    &quot;switch&quot;  return TOK_SWITCH;
    ...
    &quot;default&quot; return TOK_DEFAULT;
    [a-z]+    return TOK_ID;
<div class="Pp"></div>
    </pre>
    then you're better off using the full table representation. If only the
      &quot;identifier&quot; rule is present and you then use a hash table or
      some such to detect the keywords, you're better off using <b>-F.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This option is equivalent to <b>-CFr</b> (see below). It
      cannot be used with <b>-+.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-I</b></dt>
  <dd class="It-tag">instructs <i>flex</i> to generate an <i>interactive</i>
      scanner. An interactive scanner is one that only looks ahead to decide
      what token has been matched if it absolutely must. It turns out that
      always looking one extra character ahead, even if the scanner has already
      seen enough text to disambiguate the current token, is a bit faster than
      only looking ahead when necessary. But scanners that always look ahead
      give dreadful interactive performance; for example, when a user types a
      newline, it is not recognized as a newline token until they enter
      <i>another</i> token, which often means typing in another whole line.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><i>Flex</i> scanners default to <i>interactive</i> unless
      you use the <b>-Cf</b> or <b>-CF</b> table-compression options (see
      below). That's because if you're looking for high-performance you should
      be using one of these options, so if you didn't, <i>flex</i> assumes you'd
      rather trade off a bit of run-time performance for intuitive interactive
      behavior. Note also that you <i>cannot</i> use <b>-I</b> in conjunction
      with <b>-Cf</b> or <b>-CF.</b> Thus, this option is not really needed; it
      is on by default for all those cases in which it is allowed.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">You can force a scanner to <i>not</i> be interactive by
      using <b>-B</b> (see above).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L</b></dt>
  <dd class="It-tag">instructs <i>flex</i> not to generate <b>#line</b>
      directives. Without this option, <i>flex</i> peppers the generated scanner
      with #line directives so error messages in the actions will be correctly
      located with respect to either the original <i>flex</i> input file (if the
      errors are due to code in the input file), or <b>lex.yy.c</b> (if the
      errors are <i>flex's</i> fault -- you should report these sorts of errors
      to the email address given below).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-T</b></dt>
  <dd class="It-tag">makes <i>flex</i> run in <i>trace</i> mode. It will
      generate a lot of messages to <i>stderr</i> concerning the form of the
      input and the resultant non-deterministic and deterministic finite
      automata. This option is mostly for use in maintaining <i>flex.</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b></dt>
  <dd class="It-tag">prints the version number to <i>stdout</i> and exits.
      <b>--version</b> is a synonym for <b>-V.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-7</b></dt>
  <dd class="It-tag">instructs <i>flex</i> to generate a 7-bit scanner, i.e.,
      one which can only recognized 7-bit characters in its input. The advantage
      of using <b>-7</b> is that the scanner's tables can be up to half the size
      of those generated using the <b>-8</b> option (see below). The
      disadvantage is that such scanners often hang or crash if their input
      contains an 8-bit character.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note, however, that unless you generate your scanner using
      the <b>-Cf</b> or <b>-CF</b> table compression options, use of <b>-7</b>
      will save only a small amount of table space, and make your scanner
      considerably less portable. <i>Flex's</i> default behavior is to generate
      an 8-bit scanner unless you use the <b>-Cf</b> or <b>-CF,</b> in which
      case <i>flex</i> defaults to generating 7-bit scanners unless your site
      was always configured to generate 8-bit scanners (as will often be the
      case with non-USA sites). You can tell whether flex generated a 7-bit or
      an 8-bit scanner by inspecting the flag summary in the <b>-v</b> output as
      described above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note that if you use <b>-Cfe</b> or <b>-CFe</b> (those
      table compression options, but also using equivalence classes as discussed
      see below), flex still defaults to generating an 8-bit scanner, since
      usually with these compression options full 8-bit tables are not much more
      expensive than 7-bit tables.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-8</b></dt>
  <dd class="It-tag">instructs <i>flex</i> to generate an 8-bit scanner, i.e.,
      one which can recognize 8-bit characters. This flag is only needed for
      scanners generated using <b>-Cf</b> or <b>-CF,</b> as otherwise flex
      defaults to generating an 8-bit scanner anyway.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">See the discussion of <b>-7</b> above for flex's default
      behavior and the tradeoffs between 7-bit and 8-bit scanners.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-+</b></dt>
  <dd class="It-tag">specifies that you want flex to generate a C++ scanner
      class. See the section on Generating C++ Scanners below for details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C[aefFmr]</b></dt>
  <dd class="It-tag">controls the degree of table compression and, more
      generally, trade-offs between small scanners and fast scanners.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>-Ca</b> (&quot;align&quot;) instructs flex to trade off
      larger tables in the generated scanner for faster performance because the
      elements of the tables are better aligned for memory access and
      computation. On some RISC architectures, fetching and manipulating
      longwords is more efficient than with smaller-sized units such as
      shortwords. This option can double the size of the tables used by your
      scanner.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>-Ce</b> directs <i>flex</i> to construct <i>equivalence
      classes,</i> i.e., sets of characters which have identical lexical
      properties (for example, if the only appearance of digits in the
      <i>flex</i> input is in the character class &quot;[0-9]&quot; then the
      digits '0', '1', ..., '9' will all be put in the same equivalence class).
      Equivalence classes usually give dramatic reductions in the final
      table/object file sizes (typically a factor of 2-5) and are pretty cheap
      performance-wise (one array look-up per character scanned).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>-Cf</b> specifies that the <i>full</i> scanner tables
      should be generated - <i>flex</i> should not compress the tables by taking
      advantages of similar transition functions for different states.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>-CF</b> specifies that the alternate fast scanner
      representation (described above under the <b>-F</b> flag) should be used.
      This option cannot be used with <b>-+.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>-Cm</b> directs <i>flex</i> to construct
      <i>meta-equivalence classes,</i> which are sets of equivalence classes (or
      characters, if equivalence classes are not being used) that are commonly
      used together. Meta-equivalence classes are often a big win when using
      compressed tables, but they have a moderate performance impact (one or two
      &quot;if&quot; tests and one array look-up per character scanned).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>-Cr</b> causes the generated scanner to <i>bypass</i>
      use of the standard I/O library (stdio) for input. Instead of calling
      <b>fread()</b> or <b>getc(),</b> the scanner will use the <b>read()</b>
      system call, resulting in a performance gain which varies from system to
      system, but in general is probably negligible unless you are also using
      <b>-Cf</b> or <b>-CF.</b> Using <b>-Cr</b> can cause strange behavior if,
      for example, you read from <i>yyin</i> using stdio prior to calling the
      scanner (because the scanner will miss whatever text your previous reads
      left in the stdio input buffer).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>-Cr</b> has no effect if you define <b>YY_INPUT</b> (see
      The Generated Scanner above).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">A lone <b>-C</b> specifies that the scanner tables should
      be compressed but neither equivalence classes nor meta-equivalence classes
      should be used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The options <b>-Cf</b> or <b>-CF</b> and <b>-Cm</b> do not
      make sense together - there is no opportunity for meta-equivalence classes
      if the table is not being compressed. Otherwise the options may be freely
      mixed, and are cumulative.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The default setting is <b>-Cem,</b> which specifies that
      <i>flex</i> should generate equivalence classes and meta-equivalence
      classes. This setting provides the highest degree of table compression.
      You can trade off faster-executing scanners at the cost of larger tables
      with the following generally being true:
    <pre>
<div class="Pp"></div>
    slowest &amp; smallest
          -Cem
          -Cm
          -Ce
          -C
          -C{f,F}e
          -C{f,F}
          -C{f,F}a
    fastest &amp; largest
<div class="Pp"></div>
    </pre>
    Note that scanners with the smallest tables are usually generated and
      compiled the quickest, so during development you will usually want to use
      the default, maximal compression.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>-Cfe</b> is often a good compromise between speed and
      size for production scanners.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ooutput</b></dt>
  <dd class="It-tag">directs flex to write the scanner to the file <b>output</b>
      instead of <b>lex.yy.c.</b> If you combine <b>-o</b> with the <b>-t</b>
      option, then the scanner is written to <i>stdout</i> but its <b>#line</b>
      directives (see the <b>-L</b> option above) refer to the file
      <b>output.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Pprefix</b></dt>
  <dd class="It-tag">changes the default <i>yy</i> prefix used by <i>flex</i>
      for all globally-visible variable and function names to instead be
      <i>prefix.</i> For example, <b>-Pfoo</b> changes the name of <b>yytext</b>
      to <b>footext.</b> It also changes the name of the default output file
      from <b>lex.yy.c</b> to <b>lex.foo.c.</b> Here are all of the names
      affected:
    <pre>
<div class="Pp"></div>
    yy_create_buffer
    yy_delete_buffer
    yy_flex_debug
    yy_init_buffer
    yy_flush_buffer
    yy_load_buffer_state
    yy_switch_to_buffer
    yyin
    yyleng
    yylex
    yylineno
    yyout
    yyrestart
    yytext
    yywrap
<div class="Pp"></div>
    </pre>
    (If you are using a C++ scanner, then only <b>yywrap</b> and
      <b>yyFlexLexer</b> are affected.) Within your scanner itself, you can
      still refer to the global variables and functions using either version of
      their name; but externally, they have the modified name.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">This option lets you easily link together multiple
      <i>flex</i> programs into the same executable. Note, though, that using
      this option also renames <b>yywrap(),</b> so you now <i>must</i> either
      provide your own (appropriately-named) version of the routine for your
      scanner, or use <b>%option noyywrap,</b> as linking with <b>-lfl</b> no
      longer provides one for you by default.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Sskeleton_file</b></dt>
  <dd class="It-tag">overrides the default skeleton file from which <i>flex</i>
      constructs its scanners. You'll never need this option unless you are
      doing <i>flex</i> maintenance or development.</dd>
</dl>
<div class="Pp"></div>
<i>flex</i> also provides a mechanism for controlling options within the scanner
  specification itself, rather than from the flex command-line. This is done by
  including <b>%option</b> directives in the first section of the scanner
  specification. You can specify multiple options with a single <b>%option</b>
  directive, and multiple directives in the first section of your flex input
  file.
<div class="Pp"></div>
Most options are given simply as names, optionally preceded by the word
  &quot;no&quot; (with no intervening whitespace) to negate their meaning. A
  number are equivalent to flex flags or their negation:
<pre>
<div class="Pp"></div>
    7bit            -7 option
    8bit            -8 option
    align           -Ca option
    backup          -b option
    batch           -B option
    c++             -+ option
<div class="Pp"></div>
    caseful or
    case-sensitive  opposite of -i (default)
<div class="Pp"></div>
    case-insensitive or
    caseless        -i option
<div class="Pp"></div>
    debug           -d option
    default         opposite of -s option
    ecs             -Ce option
    fast            -F option
    full            -f option
    interactive     -I option
    lex-compat      -l option
    meta-ecs        -Cm option
    perf-report     -p option
    read            -Cr option
    stdout          -t option
    verbose         -v option
    warn            opposite of -w option
                    (use &quot;%option nowarn&quot; for -w)
<div class="Pp"></div>
    array           equivalent to &quot;%array&quot;
    pointer         equivalent to &quot;%pointer&quot; (default)
<div class="Pp"></div>
</pre>
Some <b>%option's</b> provide features otherwise not available:
<dl class="Bl-tag">
  <dt class="It-tag"><b>always-interactive</b></dt>
  <dd class="It-tag">instructs flex to generate a scanner which always considers
      its input &quot;interactive&quot;. Normally, on each new input file the
      scanner calls <b>isatty()</b> in an attempt to determine whether the
      scanner's input source is interactive and thus should be read a character
      at a time. When this option is used, however, then no such call is
    made.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>main</b></dt>
  <dd class="It-tag">directs flex to provide a default <b>main()</b> program for
      the scanner, which simply calls <b>yylex().</b> This option implies
      <b>noyywrap</b> (see below).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>never-interactive</b></dt>
  <dd class="It-tag">instructs flex to generate a scanner which never considers
      its input &quot;interactive&quot; (again, no call made to
      <b>isatty()).</b> This is the opposite of <b>always-interactive.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>stack</b></dt>
  <dd class="It-tag">enables the use of start condition stacks (see Start
      Conditions above).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>stdinit</b></dt>
  <dd class="It-tag">if set (i.e., <b>%option stdinit)</b> initializes
      <i>yyin</i> and <i>yyout</i> to <i>stdin</i> and <i>stdout,</i> instead of
      the default of <i>nil.</i> Some existing <i>lex</i> programs depend on
      this behavior, even though it is not compliant with ANSI C, which does not
      require <i>stdin</i> and <i>stdout</i> to be compile-time constant.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>yylineno</b></dt>
  <dd class="It-tag">directs <i>flex</i> to generate a scanner that maintains
      the number of the current line read from its input in the global variable
      <b>yylineno.</b> This option is implied by <b>%option lex-compat.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>yywrap</b></dt>
  <dd class="It-tag">if unset (i.e., <b>%option noyywrap),</b> makes the scanner
      not call <b>yywrap()</b> upon an end-of-file, but simply assume that there
      are no more files to scan (until the user points <i>yyin</i> at a new file
      and calls <b>yylex()</b> again).</dd>
</dl>
<div class="Pp"></div>
<i>flex</i> scans your rule actions to determine whether you use the
  <b>REJECT</b> or <b>yymore()</b> features. The <b>reject</b> and <b>yymore</b>
  options are available to override its decision as to whether you use the
  options, either by setting them (e.g., <b>%option reject)</b> to indicate the
  feature is indeed used, or unsetting them to indicate it actually is not used
  (e.g., <b>%option noyymore).</b>
<div class="Pp"></div>
Three options take string-delimited values, offset with '=':
<pre>
<div class="Pp"></div>
    %option outfile=&quot;ABC&quot;
<div class="Pp"></div>
</pre>
is equivalent to <b>-oABC,</b> and
<pre>
<div class="Pp"></div>
    %option prefix=&quot;XYZ&quot;
<div class="Pp"></div>
</pre>
is equivalent to <b>-PXYZ.</b> Finally,
<pre>
<div class="Pp"></div>
    %option yyclass=&quot;foo&quot;
<div class="Pp"></div>
</pre>
only applies when generating a C++ scanner ( <b>-+</b> option). It informs
  <i>flex</i> that you have derived <b>foo</b> as a subclass of
  <b>yyFlexLexer,</b> so <i>flex</i> will place your actions in the member
  function <b>foo::yylex()</b> instead of <b>yyFlexLexer::yylex().</b> It also
  generates a <b>yyFlexLexer::yylex()</b> member function that emits a run-time
  error (by invoking <b>yyFlexLexer::LexerError())</b> if called. See Generating
  C++ Scanners, below, for additional information.
<div class="Pp"></div>
A number of options are available for lint purists who want to suppress the
  appearance of unneeded routines in the generated scanner. Each of the
  following, if unset (e.g., <b>%option nounput</b> ), results in the
  corresponding routine not appearing in the generated scanner:
<pre>
<div class="Pp"></div>
    input, unput
    yy_push_state, yy_pop_state, yy_top_state
    yy_scan_buffer, yy_scan_bytes, yy_scan_string
<div class="Pp"></div>
</pre>
(though <b>yy_push_state()</b> and friends won't appear anyway unless you use
  <b>%option stack).</b>
<h1 class="Sh" title="Sh" id="PERFORMANCE_CONSIDERATIONS"><a class="selflink" href="#PERFORMANCE_CONSIDERATIONS">PERFORMANCE
  CONSIDERATIONS</a></h1>
The main design goal of <i>flex</i> is that it generate high-performance
  scanners. It has been optimized for dealing well with large sets of rules.
  Aside from the effects on scanner speed of the table compression <b>-C</b>
  options outlined above, there are a number of options/actions which degrade
  performance. These are, from most expensive to least:
<pre>
<div class="Pp"></div>
    REJECT
    %option yylineno
    arbitrary trailing context
<div class="Pp"></div>
    pattern sets that require backing up
    %array
    %option interactive
    %option always-interactive
<div class="Pp"></div>
    '^' beginning-of-line operator
    yymore()
<div class="Pp"></div>
</pre>
with the first three all being quite expensive and the last two being quite
  cheap. Note also that <b>unput()</b> is implemented as a routine call that
  potentially does quite a bit of work, while <b>yyless()</b> is a quite-cheap
  macro; so if just putting back some excess text you scanned, use
  <b>yyless().</b>
<div class="Pp"></div>
<b>REJECT</b> should be avoided at all costs when performance is important. It
  is a particularly expensive option.
<div class="Pp"></div>
Getting rid of backing up is messy and often may be an enormous amount of work
  for a complicated scanner. In principal, one begins by using the <b>-b</b>
  flag to generate a <i>lex.backup</i> file. For example, on the input
<pre>
<div class="Pp"></div>
    %%
    foo        return TOK_KEYWORD;
    foobar     return TOK_KEYWORD;
<div class="Pp"></div>
</pre>
the file looks like:
<pre>
<div class="Pp"></div>
    State #6 is non-accepting -
     associated rule line numbers:
           2       3
     out-transitions: [ o ]
     jam-transitions: EOF [ \001-n  p-\177 ]
<div class="Pp"></div>
    State #8 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ a ]
     jam-transitions: EOF [ \001-`  b-\177 ]
<div class="Pp"></div>
    State #9 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ r ]
     jam-transitions: EOF [ \001-q  s-\177 ]
<div class="Pp"></div>
    Compressed tables always back up.
<div class="Pp"></div>
</pre>
The first few lines tell us that there's a scanner state in which it can make a
  transition on an 'o' but not on any other character, and that in that state
  the currently scanned text does not match any rule. The state occurs when
  trying to match the rules found at lines 2 and 3 in the input file. If the
  scanner is in that state and then reads something other than an 'o', it will
  have to back up to find a rule which is matched. With a bit of headscratching
  one can see that this must be the state it's in when it has seen
  &quot;fo&quot;. When this has happened, if anything other than another 'o' is
  seen, the scanner will have to back up to simply match the 'f' (by the default
  rule).
<div class="Pp"></div>
The comment regarding State #8 indicates there's a problem when &quot;foob&quot;
  has been scanned. Indeed, on any character other than an 'a', the scanner will
  have to back up to accept &quot;foo&quot;. Similarly, the comment for State #9
  concerns when &quot;fooba&quot; has been scanned and an 'r' does not follow.
<div class="Pp"></div>
The final comment reminds us that there's no point going to all the trouble of
  removing backing up from the rules unless we're using <b>-Cf</b> or
  <b>-CF,</b> since there's no performance gain doing so with compressed
  scanners.
<div class="Pp"></div>
The way to remove the backing up is to add &quot;error&quot; rules:
<pre>
<div class="Pp"></div>
    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;
<div class="Pp"></div>
    fooba       |
    foob        |
    fo          {
                /* false alarm, not really a keyword */
                return TOK_ID;
                }
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
Eliminating backing up among a list of keywords can also be done using a
  &quot;catch-all&quot; rule:
<pre>
<div class="Pp"></div>
    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;
<div class="Pp"></div>
    [a-z]+      return TOK_ID;
<div class="Pp"></div>
</pre>
This is usually the best solution when appropriate.
<div class="Pp"></div>
Backing up messages tend to cascade. With a complicated set of rules it's not
  uncommon to get hundreds of messages. If one can decipher them, though, it
  often only takes a dozen or so rules to eliminate the backing up (though it's
  easy to make a mistake and have an error rule accidentally match a valid
  token. A possible future <i>flex</i> feature will be to automatically add
  rules to eliminate backing up).
<div class="Pp"></div>
It's important to keep in mind that you gain the benefits of eliminating backing
  up only if you eliminate <i>every</i> instance of backing up. Leaving just one
  means you gain nothing.
<div class="Pp"></div>
<i>Variable</i> trailing context (where both the leading and trailing parts do
  not have a fixed length) entails almost the same performance loss as
  <b>REJECT</b> (i.e., substantial). So when possible a rule like:
<pre>
<div class="Pp"></div>
    %%
    mouse|rat/(cat|dog)   run();
<div class="Pp"></div>
</pre>
is better written:
<pre>
<div class="Pp"></div>
    %%
    mouse/cat|dog         run();
    rat/cat|dog           run();
<div class="Pp"></div>
</pre>
or as
<pre>
<div class="Pp"></div>
    %%
    mouse|rat/cat         run();
    mouse|rat/dog         run();
<div class="Pp"></div>
</pre>
Note that here the special '|' action does <i>not</i> provide any savings, and
  can even make things worse (see Deficiencies / Bugs below).
<div class="Pp"></div>
Another area where the user can increase a scanner's performance (and one that's
  easier to implement) arises from the fact that the longer the tokens matched,
  the faster the scanner will run. This is because with long tokens the
  processing of most input characters takes place in the (short) inner scanning
  loop, and does not often have to go through the additional work of setting up
  the scanning environment (e.g., <b>yytext)</b> for the action. Recall the
  scanner for C comments:
<pre>
<div class="Pp"></div>
    %x comment
    %%
            int line_num = 1;
<div class="Pp"></div>
    &quot;/*&quot;         BEGIN(comment);
<div class="Pp"></div>
    &lt;comment&gt;[^*\n]*
    &lt;comment&gt;&quot;*&quot;+[^*/\n]*
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(INITIAL);
<div class="Pp"></div>
</pre>
This could be sped up by writing it as:
<pre>
<div class="Pp"></div>
    %x comment
    %%
            int line_num = 1;
<div class="Pp"></div>
    &quot;/*&quot;         BEGIN(comment);
<div class="Pp"></div>
    &lt;comment&gt;[^*\n]*
    &lt;comment&gt;[^*\n]*\n      ++line_num;
    &lt;comment&gt;&quot;*&quot;+[^*/\n]*
    &lt;comment&gt;&quot;*&quot;+[^*/\n]*\n ++line_num;
    &lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(INITIAL);
<div class="Pp"></div>
</pre>
Now instead of each newline requiring the processing of another action,
  recognizing the newlines is &quot;distributed&quot; over the other rules to
  keep the matched text as long as possible. Note that <i>adding</i> rules does
  <i>not</i> slow down the scanner! The speed of the scanner is independent of
  the number of rules or (modulo the considerations given at the beginning of
  this section) how complicated the rules are with regard to operators such as
  '*' and '|'.
<div class="Pp"></div>
A final example in speeding up a scanner: suppose you want to scan through a
  file containing identifiers and keywords, one per line and with no other
  extraneous characters, and recognize all the keywords. A natural first
  approach is:
<pre>
<div class="Pp"></div>
    %%
    asm      |
    auto     |
    break    |
    ... etc ...
    volatile |
    while    /* it's a keyword */
<div class="Pp"></div>
    .|\n     /* it's not a keyword */
<div class="Pp"></div>
</pre>
To eliminate the back-tracking, introduce a catch-all rule:
<pre>
<div class="Pp"></div>
    %%
    asm      |
    auto     |
    break    |
    ... etc ...
    volatile |
    while    /* it's a keyword */
<div class="Pp"></div>
    [a-z]+   |
    .|\n     /* it's not a keyword */
<div class="Pp"></div>
</pre>
Now, if it's guaranteed that there's exactly one word per line, then we can
  reduce the total number of matches by a half by merging in the recognition of
  newlines with that of the other tokens:
<pre>
<div class="Pp"></div>
    %%
    asm\n    |
    auto\n   |
    break\n  |
    ... etc ...
    volatile\n |
    while\n  /* it's a keyword */
<div class="Pp"></div>
    [a-z]+\n |
    .|\n     /* it's not a keyword */
<div class="Pp"></div>
</pre>
One has to be careful here, as we have now reintroduced backing up into the
  scanner. In particular, while <i>we</i> know that there will never be any
  characters in the input stream other than letters or newlines, <i>flex</i>
  can't figure this out, and it will plan for possibly needing to back up when
  it has scanned a token like &quot;auto&quot; and then the next character is
  something other than a newline or a letter. Previously it would then just
  match the &quot;auto&quot; rule and be done, but now it has no
  &quot;auto&quot; rule, only a &quot;auto\n&quot; rule. To eliminate the
  possibility of backing up, we could either duplicate all rules but without
  final newlines, or, since we never expect to encounter such an input and
  therefore don't how it's classified, we can introduce one more catch-all rule,
  this one which doesn't include a newline:
<pre>
<div class="Pp"></div>
    %%
    asm\n    |
    auto\n   |
    break\n  |
    ... etc ...
    volatile\n |
    while\n  /* it's a keyword */
<div class="Pp"></div>
    [a-z]+\n |
    [a-z]+   |
    .|\n     /* it's not a keyword */
<div class="Pp"></div>
</pre>
Compiled with <b>-Cf,</b> this is about as fast as one can get a <i>flex</i>
  scanner to go for this particular problem.
<div class="Pp"></div>
A final note: <i>flex</i> is slow when matching NUL's, particularly when a token
  contains multiple NUL's. It's best to write rules which match <i>short</i>
  amounts of text if it's anticipated that the text will often include NUL's.
<div class="Pp"></div>
Another final note regarding performance: as mentioned above in the section How
  the Input is Matched, dynamically resizing <b>yytext</b> to accommodate huge
  tokens is a slow process because it presently requires that the (huge) token
  be rescanned from the beginning. Thus if performance is vital, you should
  attempt to match &quot;large&quot; quantities of text but not &quot;huge&quot;
  quantities, where the cutoff between the two is at about 8K characters/token.
<h1 class="Sh" title="Sh" id="GENERATING_C++_SCANNERS"><a class="selflink" href="#GENERATING_C++_SCANNERS">GENERATING
  C++ SCANNERS</a></h1>
<i>flex</i> provides two different ways to generate scanners for use with C++.
  The first way is to simply compile a scanner generated by <i>flex</i> using a
  C++ compiler instead of a C compiler. You should not encounter any
  compilations errors (please report any you find to the email address given in
  the Author section below). You can then use C++ code in your rule actions
  instead of C code. Note that the default input source for your scanner remains
  <i>yyin,</i> and default echoing is still done to <i>yyout.</i> Both of these
  remain <i>FILE *</i> variables and not C++ <i>streams.</i>
<div class="Pp"></div>
You can also use <i>flex</i> to generate a C++ scanner class, using the
  <b>-+</b> option (or, equivalently, <b>%option c++),</b> which is
  automatically specified if the name of the flex executable ends in a '+', such
  as <i>flex++.</i> When using this option, flex defaults to generating the
  scanner to the file <b>lex.yy.cc</b> instead of <b>lex.yy.c.</b> The generated
  scanner includes the header file <i>FlexLexer.h,</i> which defines the
  interface to two C++ classes.
<div class="Pp"></div>
The first class, <b>FlexLexer,</b> provides an abstract base class defining the
  general scanner class interface. It provides the following member functions:
<dl class="Bl-tag">
  <dt class="It-tag"><b>const char* YYText()</b></dt>
  <dd class="It-tag">returns the text of the most recently matched token, the
      equivalent of <b>yytext.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>int YYLeng()</b></dt>
  <dd class="It-tag">returns the length of the most recently matched token, the
      equivalent of <b>yyleng.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>int lineno() const</b></dt>
  <dd class="It-tag">returns the current input line number (see <b>%option
      yylineno),</b> or <b>1</b> if <b>%option yylineno</b> was not used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>void set_debug( int flag )</b></dt>
  <dd class="It-tag">sets the debugging flag for the scanner, equivalent to
      assigning to <b>yy_flex_debug</b> (see the Options section above). Note
      that you must build the scanner using <b>%option debug</b> to include
      debugging information in it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>int debug() const</b></dt>
  <dd class="It-tag">returns the current setting of the debugging flag.</dd>
</dl>
<div class="Pp"></div>
Also provided are member functions equivalent to <b>yy_switch_to_buffer(),</b>
  <b>yy_create_buffer()</b> (though the first argument is an <b>istream*</b>
  object pointer and not a <b>FILE*),</b> <b>yy_flush_buffer(),</b>
  <b>yy_delete_buffer(),</b> and <b>yyrestart()</b> (again, the first argument
  is a <b>istream*</b> object pointer).
<div class="Pp"></div>
The second class defined in <i>FlexLexer.h</i> is <b>yyFlexLexer,</b> which is
  derived from <b>FlexLexer.</b> It defines the following additional member
  functions:
<dl class="Bl-tag">
  <dt class="It-tag"><b>yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout =
    0 )</b></dt>
  <dd class="It-tag">constructs a <b>yyFlexLexer</b> object using the given
      streams for input and output. If not specified, the streams default to
      <b>cin</b> and <b>cout,</b> respectively.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>virtual int yylex()</b></dt>
  <dd class="It-tag">performs the same role is <b>yylex()</b> does for ordinary
      flex scanners: it scans the input stream, consuming tokens, until a rule's
      action returns a value. If you derive a subclass <b>S</b> from
      <b>yyFlexLexer</b> and want to access the member functions and variables
      of <b>S</b> inside <b>yylex(),</b> then you need to use <b>%option
      yyclass=&quot;S&quot;</b> to inform <i>flex</i> that you will be using
      that subclass instead of <b>yyFlexLexer.</b> In this case, rather than
      generating <b>yyFlexLexer::yylex(),</b> <i>flex</i> generates
      <b>S::yylex()</b> (and also generates a dummy <b>yyFlexLexer::yylex()</b>
      that calls <b>yyFlexLexer::LexerError()</b> if called).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>virtual void switch_streams(istream* new_in =
    0,</b></dt>
  <dd class="It-tag"><b>ostream* new_out = 0)</b> reassigns <b>yyin</b> to
      <b>new_in</b> (if non-nil) and <b>yyout</b> to <b>new_out</b> (ditto),
      deleting the previous input buffer if <b>yyin</b> is reassigned.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>int yylex( istream* new_in, ostream* new_out = 0
    )</b></dt>
  <dd class="It-tag">first switches the input streams via <b>switch_streams(
      new_in, new_out )</b> and then returns the value of <b>yylex().</b></dd>
</dl>
<div class="Pp"></div>
In addition, <b>yyFlexLexer</b> defines the following protected virtual
  functions which you can redefine in derived classes to tailor the scanner:
<dl class="Bl-tag">
  <dt class="It-tag"><b>virtual int LexerInput( char* buf, int max_size
    )</b></dt>
  <dd class="It-tag">reads up to <b>max_size</b> characters into <b>buf</b> and
      returns the number of characters read. To indicate end-of-input, return 0
      characters. Note that &quot;interactive&quot; scanners (see the <b>-B</b>
      and <b>-I</b> flags) define the macro <b>YY_INTERACTIVE.</b> If you
      redefine <b>LexerInput()</b> and need to take different actions depending
      on whether or not the scanner might be scanning an interactive input
      source, you can test for the presence of this name via <b>#ifdef.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>virtual void LexerOutput( const char* buf, int size
    )</b></dt>
  <dd class="It-tag">writes out <b>size</b> characters from the buffer
      <b>buf,</b> which, while NUL-terminated, may also contain
      &quot;internal&quot; NUL's if the scanner's rules can match text with
      NUL's in them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>virtual void LexerError( const char* msg )</b></dt>
  <dd class="It-tag">reports a fatal error message. The default version of this
      function writes the message to the stream <b>cerr</b> and exits.</dd>
</dl>
<div class="Pp"></div>
Note that a <b>yyFlexLexer</b> object contains its <i>entire</i> scanning state.
  Thus you can use such objects to create reentrant scanners. You can
  instantiate multiple instances of the same <b>yyFlexLexer</b> class, and you
  can also combine multiple C++ scanner classes together in the same program
  using the <b>-P</b> option discussed above.
<div class="Pp"></div>
Finally, note that the <b>%array</b> feature is not available to C++ scanner
  classes; you must use <b>%pointer</b> (the default).
<div class="Pp"></div>
Here is an example of a simple C++ scanner:
<pre>
<div class="Pp"></div>
        // An example of using the flex C++ scanner class.
<div class="Pp"></div>
    %{
    int mylineno = 0;
    %}
<div class="Pp"></div>
    string  \&quot;[^\n&quot;]+\&quot;
<div class="Pp"></div>
    ws      [ \t]+
<div class="Pp"></div>
    alpha   [A-Za-z]
    dig     [0-9]
    name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
    num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
    num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
    number  {num1}|{num2}
<div class="Pp"></div>
    %%
<div class="Pp"></div>
    {ws}    /* skip blanks and tabs */
<div class="Pp"></div>
    &quot;/*&quot;    {
            int c;
<div class="Pp"></div>
            while((c = yyinput()) != 0)
                {
                if(c == '\n')
                    ++mylineno;
<div class="Pp"></div>
                else if(c == '*')
                    {
                    if((c = yyinput()) == '/')
                        break;
                    else
                        unput(c);
                    }
                }
            }
<div class="Pp"></div>
    {number}  cout &lt;&lt; &quot;number &quot; &lt;&lt; YYText() &lt;&lt; '\n';
<div class="Pp"></div>
    \n        mylineno++;
<div class="Pp"></div>
    {name}    cout &lt;&lt; &quot;name &quot; &lt;&lt; YYText() &lt;&lt; '\n';
<div class="Pp"></div>
    {string}  cout &lt;&lt; &quot;string &quot; &lt;&lt; YYText() &lt;&lt; '\n';
<div class="Pp"></div>
    %%
<div class="Pp"></div>
    int main( int /* argc */, char** /* argv */ )
        {
        FlexLexer* lexer = new yyFlexLexer;
        while(lexer-&gt;yylex() != 0)
            ;
        return 0;
        }
</pre>
If you want to create multiple (different) lexer classes, you use the <b>-P</b>
  flag (or the <b>prefix=</b> option) to rename each <b>yyFlexLexer</b> to some
  other <b>xxFlexLexer.</b> You then can include <b>&lt;FlexLexer.h&gt;</b> in
  your other sources once per lexer class, first renaming <b>yyFlexLexer</b> as
  follows:
<pre>
<div class="Pp"></div>
    #undef yyFlexLexer
    #define yyFlexLexer xxFlexLexer
    #include &lt;FlexLexer.h&gt;
<div class="Pp"></div>
    #undef yyFlexLexer
    #define yyFlexLexer zzFlexLexer
    #include &lt;FlexLexer.h&gt;
<div class="Pp"></div>
</pre>
if, for example, you used <b>%option prefix=&quot;xx&quot;</b> for one of your
  scanners and <b>%option prefix=&quot;zz&quot;</b> for the other.
<div class="Pp"></div>
IMPORTANT: the present form of the scanning class is <i>experimental</i> and may
  change considerably between major releases.
<h1 class="Sh" title="Sh" id="INCOMPATIBILITIES_WITH_LEX_AND_POSIX"><a class="selflink" href="#INCOMPATIBILITIES_WITH_LEX_AND_POSIX">INCOMPATIBILITIES
  WITH LEX AND POSIX</a></h1>
<i>flex</i> is a rewrite of the AT&amp;T Unix <i>lex</i> tool (the two
  implementations do not share any code, though), with some extensions and
  incompatibilities, both of which are of concern to those who wish to write
  scanners acceptable to either implementation. Flex is fully compliant with the
  POSIX <i>lex</i> specification, except that when using <b>%pointer</b> (the
  default), a call to <b>unput()</b> destroys the contents of <b>yytext,</b>
  which is counter to the POSIX specification.
<div class="Pp"></div>
In this section we discuss all of the known areas of incompatibility between
  flex, AT&amp;T lex, and the POSIX specification.
<div class="Pp"></div>
<i>flex's</i> <b>-l</b> option turns on maximum compatibility with the original
  AT&amp;T <i>lex</i> implementation, at the cost of a major loss in the
  generated scanner's performance. We note below which incompatibilities can be
  overcome using the <b>-l</b> option.
<div class="Pp"></div>
<i>flex</i> is fully compatible with <i>lex</i> with the following exceptions:
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">The undocumented <i>lex</i> scanner internal variable
      <b>yylineno</b> is not supported unless <b>-l</b> or <b>%option
      yylineno</b> is used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>yylineno</b> should be maintained on a per-buffer basis,
      rather than a per-scanner (single global variable) basis.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>yylineno</b> is not part of the POSIX
    specification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">The <b>input()</b> routine is not redefinable, though it
      may be called to read characters following whatever has been matched by a
      rule. If <b>input()</b> encounters an end-of-file the normal
      <b>yywrap()</b> processing is done. A ``real'' end-of-file is returned by
      <b>input()</b> as <i>EOF.</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Input is instead controlled by defining the <b>YY_INPUT</b>
      macro.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The <i>flex</i> restriction that <b>input()</b> cannot be
      redefined is in accordance with the POSIX specification, which simply does
      not specify any way of controlling the scanner's input other than by
      making an initial assignment to <i>yyin.</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">The <b>unput()</b> routine is not redefinable. This
      restriction is in accordance with POSIX.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><i>flex</i> scanners are not as reentrant as <i>lex</i>
      scanners. In particular, if you have an interactive scanner and an
      interrupt handler which long-jumps out of the scanner, and the scanner is
      subsequently called again, you may get the following message:
    <pre>
<div class="Pp"></div>
    fatal flex scanner internal error--end of buffer missed
<div class="Pp"></div>
    </pre>
    To reenter the scanner, first use
    <pre>
<div class="Pp"></div>
    yyrestart( yyin );
<div class="Pp"></div>
    </pre>
    Note that this call will throw away any buffered input; usually this isn't a
      problem with an interactive scanner.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Also note that flex C++ scanner classes <i>are</i>
      reentrant, so if using C++ is an option for you, you should use them
      instead. See &quot;Generating C++ Scanners&quot; above for details.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><b>output()</b> is not supported. Output from the
      <b>ECHO</b> macro is done to the file-pointer <i>yyout</i> (default
      <i>stdout).</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag"><b>output()</b> is not part of the POSIX
    specification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag"><i>lex</i> does not support exclusive start conditions
      (%x), though they are in the POSIX specification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">When definitions are expanded, <i>flex</i> encloses them in
      parentheses. With lex, the following:
    <pre>
<div class="Pp"></div>
    NAME    [A-Z][A-Z0-9]*
    %%
    foo{NAME}?      printf( &quot;Found it\n&quot; );
    %%
<div class="Pp"></div>
    </pre>
    will not match the string &quot;foo&quot; because when the macro is expanded
      the rule is equivalent to &quot;foo[A-Z][A-Z0-9]*?&quot; and the
      precedence is such that the '?' is associated with &quot;[A-Z0-9]*&quot;.
      With <i>flex,</i> the rule will be expanded to
      &quot;foo([A-Z][A-Z0-9]*)?&quot; and so the string &quot;foo&quot; will
      match.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Note that if the definition begins with <b>^</b> or ends
      with <b>$</b> then it is <i>not</i> expanded with parentheses, to allow
      these operators to appear in definitions without losing their special
      meanings. But the <b>&lt;s&gt;, /,</b> and <b>&lt;&lt;EOF&gt;&gt;</b>
      operators cannot be used in a <i>flex</i> definition.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">Using <b>-l</b> results in the <i>lex</i> behavior of no
      parentheses around the definition.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"></dt>
  <dd class="It-tag">The POSIX specification is that the definition be enclosed
      in parentheses.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Some implementations of <i>lex</i> allow a rule's action to
      begin on a separate line, if the rule's pattern has trailing whitespace:
    <pre>
<div class="Pp"></div>
    %%
    foo|bar&lt;space here&gt;
      { foobar_action(); }
<div class="Pp"></div>
    </pre>
    <i>flex</i> does not support this feature.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">The <i>lex</i> <b>%r</b> (generate a Ratfor scanner) option
      is not supported. It is not part of the POSIX specification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">After a call to <b>unput(),</b> <i>yytext</i> is undefined
      until the next token is matched, unless the scanner was built using
      <b>%array.</b> This is not the case with <i>lex</i> or the POSIX
      specification. The <b>-l</b> option does away with this
    incompatibility.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">The precedence of the <b>{}</b> (numeric range) operator is
      different. <i>lex</i> interprets &quot;abc{1,3}&quot; as &quot;match one,
      two, or three occurrences of 'abc'&quot;, whereas <i>flex</i> interprets
      it as &quot;match 'ab' followed by one, two, or three occurrences of
      'c'&quot;. The latter is in agreement with the POSIX specification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">The precedence of the <b>^</b> operator is different.
      <i>lex</i> interprets &quot;^foo|bar&quot; as &quot;match either 'foo' at
      the beginning of a line, or 'bar' anywhere&quot;, whereas <i>flex</i>
      interprets it as &quot;match either 'foo' or 'bar' if they come at the
      beginning of a line&quot;. The latter is in agreement with the POSIX
      specification.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">The special table-size declarations such as <b>%a</b>
      supported by <i>lex</i> are not required by <i>flex</i> scanners;
      <i>flex</i> ignores them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">The name FLEX_SCANNER is #define'd so scanners may be
      written for use with either <i>flex</i> or <i>lex.</i> Scanners also
      include <b>YY_FLEX_MAJOR_VERSION</b> and <b>YY_FLEX_MINOR_VERSION</b>
      indicating which version of <i>flex</i> generated the scanner (for
      example, for the 2.5 release, these defines would be 2 and 5
      respectively).</dd>
</dl>
<div class="Pp"></div>
The following <i>flex</i> features are not included in <i>lex</i> or the POSIX
  specification:
<pre>
<div class="Pp"></div>
    C++ scanners
    %option
    start condition scopes
    start condition stacks
    interactive/non-interactive scanners
    yy_scan_string() and friends
    yyterminate()
    yy_set_interactive()
    yy_set_bol()
    YY_AT_BOL()
    &lt;&lt;EOF&gt;&gt;
    &lt;*&gt;
    YY_DECL
    YY_START
    YY_USER_ACTION
    YY_USER_INIT
    #line directives
    %{}'s around actions
    multiple actions on a line
<div class="Pp"></div>
</pre>
plus almost all of the flex flags. The last feature in the list refers to the
  fact that with <i>flex</i> you can put multiple actions on the same line,
  separated with semi-colons, while with <i>lex,</i> the following
<pre>
<div class="Pp"></div>
    foo    handle_foo(); ++num_foos_seen;
<div class="Pp"></div>
</pre>
is (rather surprisingly) truncated to
<pre>
<div class="Pp"></div>
    foo    handle_foo();
<div class="Pp"></div>
</pre>
<i>flex</i> does not truncate the action. Actions that are not enclosed in
  braces are simply terminated at the end of the line.
<h1 class="Sh" title="Sh" id="DIAGNOSTICS"><a class="selflink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<i>warning, rule cannot be matched</i> indicates that the given rule cannot be
  matched because it follows other rules that will always match the same text as
  it. For example, in the following &quot;foo&quot; cannot be matched because it
  comes after an identifier &quot;catch-all&quot; rule:
<pre>
<div class="Pp"></div>
    [a-z]+    got_identifier();
    foo       got_foo();
<div class="Pp"></div>
</pre>
Using <b>REJECT</b> in a scanner suppresses this warning.
<div class="Pp"></div>
<i>warning,</i> <b>-s</b> <i>option given but default rule can be matched</i>
  means that it is possible (perhaps only in a particular start condition) that
  the default rule (match any single character) is the only one that will match
  a particular input. Since <b>-s</b> was given, presumably this is not
  intended.
<div class="Pp"></div>
<i>reject_used_but_not_detected undefined</i> or <i>yymore_used_but_not_detected
  undefined -</i> These errors can occur at compile time. They indicate that the
  scanner uses <b>REJECT</b> or <b>yymore()</b> but that <i>flex</i> failed to
  notice the fact, meaning that <i>flex</i> scanned the first two sections
  looking for occurrences of these actions and failed to find any, but somehow
  you snuck some in (via a #include file, for example). Use <b>%option
  reject</b> or <b>%option yymore</b> to indicate to flex that you really do use
  these features.
<div class="Pp"></div>
<i>flex scanner jammed -</i> a scanner compiled with <b>-s</b> has encountered
  an input string which wasn't matched by any of its rules. This error can also
  occur due to internal problems.
<div class="Pp"></div>
<i>token too large, exceeds YYLMAX -</i> your scanner uses <b>%array</b> and one
  of its rules matched a string longer than the <b>YYLMAX</b> constant (8K bytes
  by default). You can increase the value by #define'ing <b>YYLMAX</b> in the
  definitions section of your <i>flex</i> input.
<div class="Pp"></div>
<i>scanner requires -8 flag to</i> <i>use the character 'x' -</i> Your scanner
  specification includes recognizing the 8-bit character <i>'x'</i> and you did
  not specify the -8 flag, and your scanner defaulted to 7-bit because you used
  the <b>-Cf</b> or <b>-CF</b> table compression options. See the discussion of
  the <b>-7</b> flag for details.
<div class="Pp"></div>
<i>flex scanner push-back overflow -</i> you used <b>unput()</b> to push back so
  much text that the scanner's buffer could not hold both the pushed-back text
  and the current token in <b>yytext.</b> Ideally the scanner should dynamically
  resize the buffer in this case, but at present it does not.
<div class="Pp"></div>
<i>input buffer overflow, can't enlarge buffer because scanner uses REJECT -</i>
  the scanner was working on matching an extremely large token and needed to
  expand the input buffer. This doesn't work with scanners that use
  <b>REJECT.</b>
<div class="Pp"></div>
<i>fatal flex scanner internal error--end of buffer missed -</i> This can occur
  in an scanner which is reentered after a long-jump has jumped out (or over)
  the scanner's activation frame. Before reentering the scanner, use:
<pre>
<div class="Pp"></div>
    yyrestart( yyin );
<div class="Pp"></div>
</pre>
or, as noted above, switch to using the C++ scanner class.
<div class="Pp"></div>
<i>too many start conditions in &lt;&gt; construct! -</i> you listed more start
  conditions in a &lt;&gt; construct than exist (so you must have listed at
  least one of them twice).
<h1 class="Sh" title="Sh" id="FILES"><a class="selflink" href="#FILES">FILES</a></h1>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-lfl</b></dt>
  <dd class="It-tag">library with which scanners must be linked.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>lex.yy.c</i></dt>
  <dd class="It-tag">generated scanner (called <i>lexyy.c</i> on some
    systems).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>lex.yy.cc</i></dt>
  <dd class="It-tag">generated C++ scanner class, when using <b>-+.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>&lt;FlexLexer.h&gt;</i></dt>
  <dd class="It-tag">header file defining the C++ scanner base class,
      <b>FlexLexer,</b> and its derived class, <b>yyFlexLexer.</b></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>flex.skl</i></dt>
  <dd class="It-tag">skeleton scanner. This file is only used when building
      flex, not when flex executes.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>lex.backup</i></dt>
  <dd class="It-tag">backing-up information for <b>-b</b> flag (called
      <i>lex.bck</i> on some systems).</dd>
</dl>
<h1 class="Sh" title="Sh" id="DEFICIENCIES_/_BUGS"><a class="selflink" href="#DEFICIENCIES_/_BUGS">DEFICIENCIES
  / BUGS</a></h1>
Some trailing context patterns cannot be properly matched and generate warning
  messages (&quot;dangerous trailing context&quot;). These are patterns where
  the ending of the first part of the rule matches the beginning of the second
  part, such as &quot;zx*/xy*&quot;, where the 'x*' matches the 'x' at the
  beginning of the trailing context. (Note that the POSIX draft states that the
  text matched by such patterns is undefined.)
<div class="Pp"></div>
For some trailing context rules, parts which are actually fixed-length are not
  recognized as such, leading to the abovementioned performance loss. In
  particular, parts using '|' or {n} (such as &quot;foo{3}&quot;) are always
  considered variable-length.
<div class="Pp"></div>
Combining trailing context with the special '|' action can result in
  <i>fixed</i> trailing context being turned into the more expensive
  <i>variable</i> trailing context. For example, in the following:
<pre>
<div class="Pp"></div>
    %%
    abc      |
    xyz/def
<div class="Pp"></div>
</pre>
<div class="Pp"></div>
Use of <b>unput()</b> invalidates yytext and yyleng, unless the <b>%array</b>
  directive or the <b>-l</b> option has been used.
<div class="Pp"></div>
Pattern-matching of NUL's is substantially slower than matching other
  characters.
<div class="Pp"></div>
Dynamic resizing of the input buffer is slow, as it entails rescanning all the
  text matched so far by the current (generally huge) token.
<div class="Pp"></div>
Due to both buffering of input and read-ahead, you cannot intermix calls to
  &lt;stdio.h&gt; routines, such as, for example, <b>getchar(),</b> with
  <i>flex</i> rules and expect it to work. Call <b>input()</b> instead.
<div class="Pp"></div>
The total table entries listed by the <b>-v</b> flag excludes the number of
  table entries needed to determine what rule has been matched. The number of
  entries is equal to the number of DFA states if the scanner does not use
  <b>REJECT,</b> and somewhat greater than the number of states if it does.
<div class="Pp"></div>
<b>REJECT</b> cannot be used with the <b>-f</b> or <b>-F</b> options.
<div class="Pp"></div>
The <i>flex</i> internal algorithms need documentation.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
lex(1), yacc(1), sed(1), awk(1).
<div class="Pp"></div>
John Levine, Tony Mason, and Doug Brown, <i>Lex &amp; Yacc,</i> O'Reilly and
  Associates. Be sure to get the 2nd edition.
<div class="Pp"></div>
M. E. Lesk and E. Schmidt, <i>LEX - Lexical Analyzer Generator</i>
<div class="Pp"></div>
Alfred Aho, Ravi Sethi and Jeffrey Ullman, <i>Compilers: Principles, Techniques
  and Tools,</i> Addison-Wesley (1986). Describes the pattern-matching
  techniques used by <i>flex</i> (deterministic finite automata).
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Vern Paxson, with the help of many ideas and much inspiration from Van Jacobson.
  Original version by Jef Poskanzer. The fast table representation is a partial
  implementation of a design done by Van Jacobson. The implementation was done
  by Kevin Gong and Vern Paxson.
<div class="Pp"></div>
Thanks to the many <i>flex</i> beta-testers, feedbackers, and contributors,
  especially Francois Pinard, Casey Leedom, Robert Abramovitz, Stan Adermann,
  Terry Allen, David Barker-Plummer, John Basrai, Neal Becker, Nelson H.F.
  Beebe, benson@odi.com, Karl Berry, Peter A. Bigot, Simon Blanchard, Keith
  Bostic, Frederic Brehm, Ian Brockbank, Kin Cho, Nick Christopher, Brian
  Clapper, J.T. Conklin, Jason Coughlin, Bill Cox, Nick Cropper, Dave Curtis,
  Scott David Daniels, Chris G. Demetriou, Theo Deraadt, Mike Donahue, Chuck
  Doucette, Tom Epperly, Leo Eskin, Chris Faylor, Chris Flatters, Jon Forrest,
  Jeffrey Friedl, Joe Gayda, Kaveh R. Ghazi, Wolfgang Glunz, Eric Goldman,
  Christopher M. Gould, Ulrich Grepel, Peer Griebel, Jan Hajic, Charles
  Hemphill, NORO Hideo, Jarkko Hietaniemi, Scott Hofmann, Jeff Honig, Dana
  Hudes, Eric Hughes, John Interrante, Ceriel Jacobs, Michal Jaegermann, Sakari
  Jalovaara, Jeffrey R. Jones, Henry Juengst, Klaus Kaempf, Jonathan I. Kamens,
  Terrence O Kane, Amir Katz, ken@ken.hilco.com, Kevin B. Kenny, Steve Kirsch,
  Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg Lee, Rohan Lenard, Craig
  Leres, John Levine, Steve Liddle, David Loffredo, Mike Long, Mohamed el Lozy,
  Brian Madsen, Malte, Joe Marshall, Bengt Martensson, Chris Metcalf, Luke
  Mewburn, Jim Meyering, R. Alexander Milowski, Erik Naggum, G.T. Nicol, Landon
  Noll, James Nordby, Marc Nozell, Richard Ohnemus, Karsten Pahnke, Sven Panne,
  Roland Pesch, Walter Pelissero, Gaumond Pierre, Esmond Pitt, Jef Poskanzer,
  Joe Rahmeh, Jarmo Raiha, Frederic Raimbault, Pat Rankin, Rick Richardson,
  Kevin Rodgers, Kai Uwe Rommel, Jim Roskind, Alberto Santini, Andreas Scherer,
  Darrell Schiebel, Raf Schietekat, Doug Schmidt, Philippe Schnoebelen, Andreas
  Schwab, Larry Schwimmer, Alex Siegel, Eckehard Stolz, Jan-Erik Strvmquist,
  Mike Stump, Paul Stuart, Dave Tallman, Ian Lance Taylor, Chris Thewalt,
  Richard M. Timoney, Jodi Tsai, Paul Tuinenga, Gary Weik, Frank Whaley, Gerhard
  Wilhelms, Kent Williams, Ken Yap, Ron Zellar, Nathan Zelle, David Zuhn, and
  those whose names have slipped my marginal mail-archiving skills but whose
  contributions are appreciated all the same.
<div class="Pp"></div>
Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore, Craig Leres,
  John Levine, Bob Mulcahy, G.T. Nicol, Francois Pinard, Rich Salz, and Richard
  Stallman for help with various distribution headaches.
<div class="Pp"></div>
Thanks to Esmond Pitt and Earle Horton for 8-bit character support; to Benson
  Margulies and Fred Burke for C++ support; to Kent Williams and Tom Epperly for
  C++ class support; to Ove Ewerlid for support of NUL's; and to Eric Hughes for
  support of multiple buffers.
<div class="Pp"></div>
This work was primarily done when I was with the Real Time Systems Group at the
  Lawrence Berkeley Laboratory in Berkeley, CA. Many thanks to all there for the
  support I received.
<div class="Pp"></div>
Send comments to vern@ee.lbl.gov.</div>
<table class="foot">
  <tr>
    <td class="foot-date">April 1995</td>
    <td class="foot-os">Version 2.5</td>
  </tr>
</table>
</body>
</html>
