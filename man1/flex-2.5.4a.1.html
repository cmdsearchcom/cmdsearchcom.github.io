<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:10:17 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>FLEX(1) General Commands Manual FLEX(1)</p>

<p style="margin-top: 1em">NAME <br>
flex - fast lexical analyzer generator</p>

<p style="margin-top: 1em">SYNOPSIS <br>
flex [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix
-Sskeleton] [--help --version] [filename ...]</p>

<p style="margin-top: 1em">OVERVIEW <br>
This manual describes flex, a tool for generating programs
that perform pattern-matching on text. The manual includes
both tutorial and reference sections:</p>

<p style="margin-top: 1em">Description <br>
a brief overview of the tool</p>

<p style="margin-top: 1em">Some Simple Examples</p>

<p style="margin-top: 1em">Format Of The Input File</p>

<p style="margin-top: 1em">Patterns <br>
the extended regular expressions used by flex</p>

<p style="margin-top: 1em">How The Input Is Matched <br>
the rules for determining what has been matched</p>

<p style="margin-top: 1em">Actions <br>
how to specify what to do when a pattern is matched</p>

<p style="margin-top: 1em">The Generated Scanner <br>
details regarding the scanner that flex produces; <br>
how to control the input source</p>

<p style="margin-top: 1em">Start Conditions <br>
introducing context into your scanners, and <br>
managing &quot;mini-scanners&quot;</p>

<p style="margin-top: 1em">Multiple Input Buffers <br>
how to manipulate multiple input sources; how to <br>
scan from strings instead of files</p>

<p style="margin-top: 1em">End-of-file Rules <br>
special rules for matching the end of the input</p>

<p style="margin-top: 1em">Miscellaneous Macros <br>
a summary of macros available to the actions</p>

<p style="margin-top: 1em">Values Available To The User
<br>
a summary of values available to the actions</p>

<p style="margin-top: 1em">Interfacing With Yacc <br>
connecting flex scanners together with yacc parsers</p>

<p style="margin-top: 1em">Options <br>
flex command-line options, and the &quot;%option&quot; <br>
directive</p>

<p style="margin-top: 1em">Performance Considerations <br>
how to make your scanner go as fast as possible</p>

<p style="margin-top: 1em">Generating C++ Scanners <br>
the (experimental) facility for generating C++ <br>
scanner classes</p>

<p style="margin-top: 1em">Incompatibilities With Lex And
POSIX <br>
how flex differs from AT&amp;T lex and the POSIX lex <br>
standard</p>

<p style="margin-top: 1em">Diagnostics <br>
those error messages produced by flex (or scanners <br>
it generates) whose meanings might not be apparent</p>

<p style="margin-top: 1em">Files <br>
files used by flex</p>

<p style="margin-top: 1em">Deficiencies / Bugs <br>
known problems with flex</p>

<p style="margin-top: 1em">See Also <br>
other documentation, related tools</p>

<p style="margin-top: 1em">Author <br>
includes contact information</p>

<p style="margin-top: 1em">DESCRIPTION <br>
flex is a tool for generating scanners: programs which
recognized lexical patterns in text. flex reads the given
input files, or its standard input if no file names are
given, <br>
for a description of a scanner to generate. The description
is in the form of pairs of regular expressions and C code,
called rules. flex generates as output a C source file, <br>
lex.yy.c, which defines a routine yylex(). This file is
compiled and linked with the -lfl library to produce an
executable. When the executable is run, it analyzes its
input <br>
for occurrences of the regular expressions. Whenever it
finds one, it executes the corresponding C code.</p>

<p style="margin-top: 1em">SOME SIMPLE EXAMPLES <br>
First some simple examples to get the flavor of how one uses
flex. The following flex input specifies a scanner which
whenever it encounters the string &quot;username&quot; will
replace <br>
it with the user&rsquo;s login name:</p>

<p style="margin-top: 1em">%% <br>
username printf( &quot;%s&quot;, getlogin() );</p>

<p style="margin-top: 1em">By default, any text not matched
by a flex scanner is copied to the output, so the net effect
of this scanner is to copy its input file to its output with
each occurrence of <br>
&quot;username&quot; expanded. In this input, there is just
one rule. &quot;username&quot; is the pattern and the
&quot;printf&quot; is the action. The &quot;%%&quot; marks
the beginning of the rules.</p>

<p style="margin-top: 1em">Here&rsquo;s another simple
example:</p>

<p style="margin-top: 1em">int num_lines = 0, num_chars =
0;</p>

<p style="margin-top: 1em">%% <br>
++num_lines; ++num_chars; <br>
. ++num_chars;</p>

<p style="margin-top: 1em">%% <br>
main() <br>
{ <br>
yylex(); <br>
printf( &quot;# of lines = %d, # of chars = %d0, <br>
num_lines, num_chars ); <br>
}</p>

<p style="margin-top: 1em">This scanner counts the number
of characters and the number of lines in its input (it
produces no output other than the final report on the
counts). The first line declares two <br>
globals, &quot;num_lines&quot; and &quot;num_chars&quot;,
which are accessible both inside yylex() and in the main()
routine declared after the second &quot;%%&quot;. There are
two rules, one which matches a <br>
newline (&quot;0) and increments both the line count and the
character count, and one which matches any character other
than a newline (indicated by the &quot;.&quot; regular
expression).</p>

<p style="margin-top: 1em">A somewhat more complicated
example:</p>

<p style="margin-top: 1em">/* scanner for a toy Pascal-like
language */</p>

<p style="margin-top: 1em">%{ <br>
/* need this for the call to atof() below */ <br>
#include &lt;math.h&gt; <br>
%}</p>

<p style="margin-top: 1em">DIGIT [0-9] <br>
ID [a-z][a-z0-9]*</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">{DIGIT}+ { <br>
printf( &quot;An integer: %s (%d)0, yytext, <br>
atoi( yytext ) ); <br>
}</p>

<p style="margin-top: 1em">{DIGIT}+&quot;.&quot;{DIGIT}* {
<br>
printf( &quot;A float: %s (%g)0, yytext, <br>
atof( yytext ) ); <br>
}</p>


<p style="margin-top: 1em">if|then|begin|end|procedure|function
{ <br>
printf( &quot;A keyword: %s0, yytext ); <br>
}</p>

<p style="margin-top: 1em">{ID} printf( &quot;An
identifier: %s0, yytext );</p>


<p style="margin-top: 1em">&quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;
printf( &quot;An operator: %s0, yytext );</p>

<p style="margin-top: 1em">&quot;{&quot;[^}0*&quot;}&quot;
/* eat up one-line comments */</p>

<p style="margin-top: 1em">[ 0+ /* eat up whitespace */</p>

<p style="margin-top: 1em">. printf( &quot;Unrecognized
character: %s0, yytext );</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">main( argc, argv ) <br>
int argc; <br>
char **argv; <br>
{ <br>
++argv, --argc; /* skip over program name */ <br>
if ( argc &gt; 0 ) <br>
yyin = fopen( argv[0], &quot;r&quot; ); <br>
else <br>
yyin = stdin;</p>

<p style="margin-top: 1em">yylex(); <br>
}</p>

<p style="margin-top: 1em">This is the beginnings of a
simple scanner for a language like Pascal. It identifies
different types of tokens and reports on what it has
seen.</p>

<p style="margin-top: 1em">The details of this example will
be explained in the following sections.</p>

<p style="margin-top: 1em">FORMAT OF THE INPUT FILE <br>
The flex input file consists of three sections, separated by
a line with just %% in it:</p>

<p style="margin-top: 1em">definitions <br>
%% <br>
rules <br>
%% <br>
user code</p>

<p style="margin-top: 1em">The definitions section contains
declarations of simple name definitions to simplify the
scanner specification, and declarations of start conditions,
which are explained in a <br>
later section.</p>

<p style="margin-top: 1em">Name definitions have the
form:</p>

<p style="margin-top: 1em">name definition</p>

<p style="margin-top: 1em">The &quot;name&quot; is a word
beginning with a letter or an underscore (&rsquo;_&rsquo;)
followed by zero or more letters, digits, &rsquo;_&rsquo;,
or &rsquo;-&rsquo; (dash). The definition is taken to begin
at the first <br>
non-white-space character following the name and continuing
to the end of the line. The definition can subsequently be
referred to using &quot;{name}&quot;, which will expand to
&quot;(defini&acirc; <br>
tion)&quot;. For example,</p>

<p style="margin-top: 1em">DIGIT [0-9] <br>
ID [a-z][a-z0-9]*</p>

<p style="margin-top: 1em">defines &quot;DIGIT&quot; to be
a regular expression which matches a single digit, and
&quot;ID&quot; to be a regular expression which matches a
letter followed by zero-or-more letters-or-digits. A <br>
subsequent reference to</p>


<p style="margin-top: 1em">{DIGIT}+&quot;.&quot;{DIGIT}*</p>

<p style="margin-top: 1em">is identical to</p>


<p style="margin-top: 1em">([0-9])+&quot;.&quot;([0-9])*</p>

<p style="margin-top: 1em">and matches one-or-more digits
followed by a &rsquo;.&rsquo; followed by zero-or-more
digits.</p>

<p style="margin-top: 1em">The rules section of the flex
input contains a series of rules of the form:</p>

<p style="margin-top: 1em">pattern action</p>

<p style="margin-top: 1em">where the pattern must be
unindented and the action must begin on the same line.</p>

<p style="margin-top: 1em">See below for a further
description of patterns and actions.</p>

<p style="margin-top: 1em">Finally, the user code section
is simply copied to lex.yy.c verbatim. It is used for
companion routines which call or are called by the scanner.
The presence of this section is <br>
optional; if it is missing, the second %% in the input file
may be skipped, too.</p>

<p style="margin-top: 1em">In the definitions and rules
sections, any indented text or text enclosed in %{ and %} is
copied verbatim to the output (with the %{}&rsquo;s
removed). The %{}&rsquo;s must appear unin&acirc; <br>
dented on lines by themselves.</p>

<p style="margin-top: 1em">In the rules section, any
indented or %{} text appearing before the first rule may be
used to declare variables which are local to the scanning
routine and (after the declara&acirc; <br>
tions) code which is to be executed whenever the scanning
routine is entered. Other indented or %{} text in the rule
section is still copied to the output, but its meaning is
<br>
not well-defined and it may well cause compile-time errors
(this feature is present for POSIX compliance; see below for
other such features).</p>

<p style="margin-top: 1em">In the definitions section (but
not in the rules section), an unindented comment (i.e., a
line beginning with &quot;/*&quot;) is also copied verbatim
to the output up to the next &quot;*/&quot;.</p>

<p style="margin-top: 1em">PATTERNS <br>
The patterns in the input are written using an extended set
of regular expressions. These are:</p>

<p style="margin-top: 1em">x match the character
&rsquo;x&rsquo; <br>
. any character (byte) except newline <br>
[xyz] a &quot;character class&quot;; in this case, the
pattern <br>
matches either an &rsquo;x&rsquo;, a &rsquo;y&rsquo;, or a
&rsquo;z&rsquo; <br>
[abj-oZ] a &quot;character class&quot; with a range in it;
matches <br>
an &rsquo;a&rsquo;, a &rsquo;b&rsquo;, any letter from
&rsquo;j&rsquo; through &rsquo;o&rsquo;, <br>
or a &rsquo;Z&rsquo; <br>
[^A-Z] a &quot;negated character class&quot;, i.e., any
character <br>
but those in the class. In this case, any <br>
character EXCEPT an uppercase letter. <br>
[^A-Z0 any character EXCEPT an uppercase letter or <br>
a newline <br>
r* zero or more r&rsquo;s, where r is any regular expression
<br>
r+ one or more r&rsquo;s <br>
r? zero or one r&rsquo;s (that is, &quot;an optional
r&quot;) <br>
r{2,5} anywhere from two to five r&rsquo;s <br>
r{2,} two or more r&rsquo;s <br>
r{4} exactly 4 r&rsquo;s <br>
{name} the expansion of the &quot;name&quot; definition <br>
(see above) <br>
&quot;[xyz] <br>
the literal string: [xyz]&quot;foo <br>
if X is an &rsquo;a&rsquo;, &rsquo;b&rsquo;,
&rsquo;f&rsquo;, &rsquo;n&rsquo;, &rsquo;r&rsquo;,
&rsquo;t&rsquo;, or &rsquo;v&rsquo;, <br>
then the ANSI-C interpretation of <br>
Otherwise, a literal &rsquo;X&rsquo; (used to escape <br>
operators such as &rsquo;*&rsquo;) <br>
a NUL character (ASCII code 0) <br>
123 the character with octal value 123 <br>
a the character with hexadecimal value 2a <br>
(r) match an r; parentheses are used to override <br>
precedence (see below)</p>

<p style="margin-top: 1em">rs the regular expression r
followed by the <br>
regular expression s; called &quot;concatenation&quot;</p>

<p style="margin-top: 1em">r|s either an r or an s</p>

<p style="margin-top: 1em">r/s an r but only if it is
followed by an s. The <br>
text matched by s is included when determining <br>
whether this rule is the &quot;longest match&quot;, <br>
but is then returned to the input before <br>
the action is executed. So the action only <br>
sees the text matched by r. This type <br>
of pattern is called trailing context&quot;. <br>
(There are some combinations of r/s that flex <br>
cannot match correctly; see notes in the <br>
Deficiencies / Bugs section below regarding <br>
&quot;dangerous trailing context&quot;.) <br>
^r an r, but only at the beginning of a line (i.e., <br>
which just starting to scan, or right after a <br>
newline has been scanned). <br>
r$ an r, but only at the end of a line (i.e., just <br>
before a newline). Equivalent to &quot;r/0.</p>

<p style="margin-top: 1em">Note that flex&rsquo;s notion of
&quot;newline&quot; is exactly <br>
whatever the C compiler used to compile flex <br>
interprets &rsquo;0 as; in particular, on some DOS &rsquo;s
in <br>
systems you must either filter out the for <br>
input yourself, or explicitly use r/ &quot;r$&quot;.</p>

<p style="margin-top: 1em">&lt;s&gt;r an r, but only in
start condition s (see <br>
below for discussion of start conditions) <br>
&lt;s1,s2,s3&gt;r <br>
same, but in any of start conditions s1, <br>
s2, or s3 <br>
&lt;*&gt;r an r in any start condition, even an exclusive
one.</p>

<p style="margin-top: 1em">&lt;&lt;EOF&gt;&gt; an
end-of-file <br>
&lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt; <br>
an end-of-file when in start condition s1 or s2</p>

<p style="margin-top: 1em">Note that inside of a character
class, all regular expression operators lose their special
meaning except escape (&rsquo;&acute;) and the character
class operators, &rsquo;-&rsquo;, &rsquo;]&rsquo;, and, at
the <br>
beginning of the class, &rsquo;^&rsquo;.</p>

<p style="margin-top: 1em">The regular expressions listed
above are grouped according to precedence, from highest
precedence at the top to lowest at the bottom. Those grouped
together have equal prece&acirc; <br>
dence. For example,</p>

<p style="margin-top: 1em">foo|bar*</p>

<p style="margin-top: 1em">is the same as</p>

<p style="margin-top: 1em">(foo)|(ba(r*))</p>

<p style="margin-top: 1em">since the &rsquo;*&rsquo;
operator has higher precedence than concatenation, and
concatenation higher than alternation (&rsquo;|&rsquo;).
This pattern therefore matches either the string
&quot;foo&quot; or the <br>
string &quot;ba&quot; followed by zero-or-more r&rsquo;s. To
match &quot;foo&quot; or zero-or-more
&quot;bar&quot;&rsquo;s, use:</p>

<p style="margin-top: 1em">foo|(bar)*</p>

<p style="margin-top: 1em">and to match zero-or-more
&quot;foo&quot;&rsquo;s-or-&quot;bar&quot;&rsquo;s:</p>

<p style="margin-top: 1em">(foo|bar)*</p>

<p style="margin-top: 1em">In addition to characters and
ranges of characters, character classes can also contain
character class expressions. These are expressions enclosed
inside [: and :] delimiters <br>
(which themselves must appear between the &rsquo;[&rsquo;
and &rsquo;]&rsquo; of the character class; other elements
may occur inside the character class, too). The valid
expressions are:</p>

<p style="margin-top: 1em">[:alnum:] [:alpha:] [:blank:]
<br>
[:cntrl:] [:digit:] [:graph:] <br>
[:lower:] [:print:] [:punct:] <br>
[:space:] [:upper:] [:xdigit:]</p>

<p style="margin-top: 1em">These expressions all designate
a set of characters equivalent to the corresponding standard
C isXXX function. For example, [:alnum:] designates those
characters for which isal&acirc; <br>
num() returns true - i.e., any alphabetic or numeric. Some
systems don&rsquo;t provide isblank(), so flex defines
[:blank:] as a blank or a tab.</p>

<p style="margin-top: 1em">For example, the following
character classes are all equivalent:</p>

<p style="margin-top: 1em">[[:alnum:]] <br>
[[:alpha:][:digit:] <br>
[[:alpha:]0-9] <br>
[a-zA-Z0-9]</p>

<p style="margin-top: 1em">If your scanner is
case-insensitive (the -i flag), then [:upper:] and [:lower:]
are equivalent to [:alpha:].</p>

<p style="margin-top: 1em">Some notes on patterns:</p>

<p style="margin-top: 1em">- A negated character class such
as the example &quot;[^A-Z]&quot; above will match a newline
unless &quot;0 (or an equivalent escape sequence) is one of
the characters explicitly <br>
present in the negated character class (e.g.,
&quot;[^A-Z0&quot;). This is unlike how many other regular
expression tools treat negated character classes, but
unfortunately the <br>
inconsistency is historically entrenched. Matching newlines
means that a pattern like [^&quot;]* can match the entire
input unless there&rsquo;s another quote in the input.</p>

<p style="margin-top: 1em">- A rule can have at most one
instance of trailing context (the &rsquo;/&rsquo; operator
or the &rsquo;$&rsquo; operator). The start condition,
&rsquo;^&rsquo;, and &quot;&lt;&lt;EOF&gt;&gt;&quot;
patterns can only occur at the <br>
beginning of a pattern, and, as well as with &rsquo;/&rsquo;
and &rsquo;$&rsquo;, cannot be grouped inside parentheses. A
&rsquo;^&rsquo; which does not occur at the beginning of a
rule or a &rsquo;$&rsquo; which does <br>
not occur at the end of a rule loses its special properties
and is treated as a normal character.</p>

<p style="margin-top: 1em">The following are illegal:</p>

<p style="margin-top: 1em">foo/bar$ <br>
&lt;sc1&gt;foo&lt;sc2&gt;bar</p>

<p style="margin-top: 1em">Note that the first of these,
can be written &quot;foo/bar0.</p>

<p style="margin-top: 1em">The following will result in
&rsquo;$&rsquo; or &rsquo;^&rsquo; being treated as a normal
character:</p>

<p style="margin-top: 1em">foo|(bar$) <br>
foo|^bar</p>

<p style="margin-top: 1em">If what&rsquo;s wanted is a
&quot;foo&quot; or a bar-followed-by-a-newline, the
following could be used (the special &rsquo;|&rsquo; action
is explained below):</p>

<p style="margin-top: 1em">foo | <br>
bar$ /* action goes here */</p>

<p style="margin-top: 1em">A similar trick will work for
matching a foo or a bar-at-the-beginning-of-a-line.</p>

<p style="margin-top: 1em">HOW THE INPUT IS MATCHED <br>
When the generated scanner is run, it analyzes its input
looking for strings which match any of its patterns. If it
finds more than one match, it takes the one matching the
most <br>
text (for trailing context rules, this includes the length
of the trailing part, even though it will then be returned
to the input). If it finds two or more matches of the same
<br>
length, the rule listed first in the flex input file is
chosen.</p>

<p style="margin-top: 1em">Once the match is determined,
the text corresponding to the match (called the token) is
made available in the global character pointer yytext, and
its length in the global inte&acirc; <br>
ger yyleng. The action corresponding to the matched pattern
is then executed (a more detailed description of actions
follows), and then the remaining input is scanned for <br>
another match.</p>

<p style="margin-top: 1em">If no match is found, then the
default rule is executed: the next character in the input is
considered matched and copied to the standard output. Thus,
the simplest legal flex <br>
input is:</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">which generates a scanner that
simply copies its input (one character at a time) to its
output.</p>

<p style="margin-top: 1em">Note that yytext can be defined
in two different ways: either as a character pointer or as a
character array. You can control which definition flex uses
by including one of the <br>
special directives %pointer or %array in the first
(definitions) section of your flex input. The default is
%pointer, unless you use the -l lex compatibility option, in
which <br>
case yytext will be an array. The advantage of using
%pointer is substantially faster scanning and no buffer
overflow when matching very large tokens (unless you run out
of <br>
dynamic memory). The disadvantage is that you are restricted
in how your actions can modify yytext (see the next
section), and calls to the unput() function destroys the
present <br>
contents of yytext, which can be a considerable porting
headache when moving between different lex versions.</p>

<p style="margin-top: 1em">The advantage of %array is that
you can then modify yytext to your heart&rsquo;s content,
and calls to unput() do not destroy yytext (see below).
Furthermore, existing lex programs <br>
sometimes access yytext externally using declarations of the
form: <br>
extern char yytext[]; <br>
This definition is erroneous when used with %pointer, but
correct for %array.</p>

<p style="margin-top: 1em">%array defines yytext to be an
array of YYLMAX characters, which defaults to a fairly large
value. You can change the size by simply #define&rsquo;ing
YYLMAX to a different value in <br>
the first section of your flex input. As mentioned above,
with %pointer yytext grows dynamically to accommodate large
tokens. While this means your %pointer scanner can
accom&acirc; <br>
modate very large tokens (such as matching entire blocks of
comments), bear in mind that each time the scanner must
resize yytext it also must rescan the entire token from the
<br>
beginning, so matching such tokens can prove slow. yytext
presently does not dynamically grow if a call to unput()
results in too much text being pushed back; instead, a run-
<br>
time error results.</p>

<p style="margin-top: 1em">Also note that you cannot use
%array with C++ scanner classes (the c++ option; see
below).</p>

<p style="margin-top: 1em">ACTIONS <br>
Each pattern in a rule has a corresponding action, which can
be any arbitrary C statement. The pattern ends at the first
non-escaped whitespace character; the remainder of the <br>
line is its action. If the action is empty, then when the
pattern is matched the input token is simply discarded. For
example, here is the specification for a program which <br>
deletes all occurrences of &quot;zap me&quot; from its
input:</p>

<p style="margin-top: 1em">%% <br>
&quot;zap me&quot;</p>

<p style="margin-top: 1em">(It will copy all other
characters in the input to the output since they will be
matched by the default rule.)</p>

<p style="margin-top: 1em">Here is a program which
compresses multiple blanks and tabs down to a single blank,
and throws away whitespace found at the end of a line:</p>

<p style="margin-top: 1em">%% <br>
[ ]+ putchar( &rsquo; &rsquo; ); <br>
[ ]+$ /* ignore this token */</p>

<p style="margin-top: 1em">If the action contains a
&rsquo;{&rsquo;, then the action spans till the balancing
&rsquo;}&rsquo; is found, and the action may cross multiple
lines. flex knows about C strings and comments and
won&rsquo;t <br>
be fooled by braces found within them, but also allows
actions to begin with %{ and will consider the action to be
all the text up to the next %} (regardless of ordinary
braces <br>
inside the action).</p>

<p style="margin-top: 1em">An action consisting solely of a
vertical bar (&rsquo;|&rsquo;) means &quot;same as the
action for the next rule.&quot; See below for an
illustration.</p>

<p style="margin-top: 1em">Actions can include arbitrary C
code, including return statements to return a value to
whatever routine called yylex(). Each time yylex() is called
it continues processing <br>
tokens from where it last left off until it either reaches
the end of the file or executes a return.</p>

<p style="margin-top: 1em">Actions are free to modify
yytext except for lengthening it (adding characters to its
end--these will overwrite later characters in the input
stream). This however does not <br>
apply when using %array (see above); in that case, yytext
may be freely modified in any way.</p>

<p style="margin-top: 1em">Actions are free to modify
yyleng except they should not do so if the action also
includes use of yymore() (see below).</p>

<p style="margin-top: 1em">There are a number of special
directives which can be included within an action:</p>

<p style="margin-top: 1em">- ECHO copies yytext to the
scanner&rsquo;s output.</p>

<p style="margin-top: 1em">- BEGIN followed by the name of
a start condition places the scanner in the corresponding
start condition (see below).</p>

<p style="margin-top: 1em">- REJECT directs the scanner to
proceed on to the &quot;second best&quot; rule which matched
the input (or a prefix of the input). The rule is chosen as
described above in &quot;How the <br>
Input is Matched&quot;, and yytext and yyleng set up
appropriately. It may either be one which matched as much
text as the originally chosen rule but came later in the
flex <br>
input file, or one which matched less text. For example, the
following will both count the words in the input and call
the routine special() whenever &quot;frob&quot; is seen:</p>

<p style="margin-top: 1em">int word_count = 0; <br>
%%</p>

<p style="margin-top: 1em">frob special(); REJECT; <br>
[^ 0+ ++word_count;</p>

<p style="margin-top: 1em">Without the REJECT, any
&quot;frob&quot;&rsquo;s in the input would not be counted
as words, since the scanner normally executes only one
action per token. Multiple REJECT&rsquo;s are allowed, <br>
each one finding the next best choice to the currently
active rule. For example, when the following scanner scans
the token &quot;abcd&quot;, it will write
&quot;abcdabcaba&quot; to the out&acirc; <br>
put:</p>

<p style="margin-top: 1em">%% <br>
a | <br>
ab | <br>
abc | <br>
abcd ECHO; REJECT; <br>
.| /* eat up any unmatched character */</p>

<p style="margin-top: 1em">(The first three rules share the
fourth&rsquo;s action since they use the special
&rsquo;|&rsquo; action.) REJECT is a particularly expensive
feature in terms of scanner performance; if it <br>
is used in any of the scanner&rsquo;s actions it will slow
down all of the scanner&rsquo;s matching. Furthermore,
REJECT cannot be used with the -Cf or -CF options (see
below).</p>

<p style="margin-top: 1em">Note also that unlike the other
special actions, REJECT is a branch; code immediately
following it in the action will not be executed.</p>

<p style="margin-top: 1em">- yymore() tells the scanner
that the next time it matches a rule, the corresponding
token should be appended onto the current value of yytext
rather than replacing it. For <br>
example, given the input &quot;mega-kludge&quot; the
following will write &quot;mega-mega-kludge&quot; to the
output:</p>

<p style="margin-top: 1em">%% <br>
mega- ECHO; yymore(); <br>
kludge ECHO;</p>

<p style="margin-top: 1em">First &quot;mega-&quot; is
matched and echoed to the output. Then &quot;kludge&quot; is
matched, but the previous &quot;mega-&quot; is still hanging
around at the beginning of yytext so the ECHO for <br>
the &quot;kludge&quot; rule will actually write
&quot;mega-kludge&quot;.</p>

<p style="margin-top: 1em">Two notes regarding use of
yymore(). First, yymore() depends on the value of yyleng
correctly reflecting the size of the current token, so you
must not modify yyleng if you are <br>
using yymore(). Second, the presence of yymore() in the
scanner&rsquo;s action entails a minor performance penalty
in the scanner&rsquo;s matching speed.</p>

<p style="margin-top: 1em">- yyless(n) returns all but the
first n characters of the current token back to the input
stream, where they will be rescanned when the scanner looks
for the next match. <br>
yytext and yyleng are adjusted appropriately (e.g., yyleng
will now be equal to n ). For example, on the input
&quot;foobar&quot; the following will write out
&quot;foobarbar&quot;:</p>

<p style="margin-top: 1em">%% <br>
foobar ECHO; yyless(3); <br>
[a-z]+ ECHO;</p>

<p style="margin-top: 1em">An argument of 0 to yyless will
cause the entire current input string to be scanned again.
Unless you&rsquo;ve changed how the scanner will
subsequently process its input <br>
(using BEGIN, for example), this will result in an endless
loop.</p>

<p style="margin-top: 1em">Note that yyless is a macro and
can only be used in the flex input file, not from other
source files.</p>

<p style="margin-top: 1em">- unput(c) puts the character c
back onto the input stream. It will be the next character
scanned. The following action will take the current token
and cause it to be res&acirc; <br>
canned enclosed in parentheses.</p>

<p style="margin-top: 1em">{ <br>
int i; <br>
/* Copy yytext because unput() trashes yytext */ <br>
char *yycopy = strdup( yytext ); <br>
unput( &rsquo;)&rsquo; ); <br>
for ( i = yyleng - 1; i &gt;= 0; --i ) <br>
unput( yycopy[i] ); <br>
unput( &rsquo;(&rsquo; ); <br>
free( yycopy ); <br>
}</p>

<p style="margin-top: 1em">Note that since each unput()
puts the given character back at the beginning of the input
stream, pushing back strings must be done back-to-front.</p>

<p style="margin-top: 1em">An important potential problem
when using unput() is that if you are using %pointer (the
default), a call to unput() destroys the contents of yytext,
starting with its rightmost <br>
character and devouring one character to the left with each
call. If you need the value of yytext preserved after a call
to unput() (as in the above example), you must either <br>
first copy it elsewhere, or build your scanner using %array
instead (see How The Input Is Matched).</p>

<p style="margin-top: 1em">Finally, note that you cannot
put back EOF to attempt to mark the input stream with an
end-of-file.</p>

<p style="margin-top: 1em">- input() reads the next
character from the input stream. For example, the following
is one way to eat up C comments:</p>

<p style="margin-top: 1em">%% <br>
&quot;/*&quot; { <br>
register int c;</p>

<p style="margin-top: 1em">for ( ; ; ) <br>
{ <br>
while ( (c = input()) != &rsquo;*&rsquo; &amp;&amp; <br>
c != EOF ) <br>
; /* eat up text of comment */</p>

<p style="margin-top: 1em">if ( c == &rsquo;*&rsquo; ) <br>
{ <br>
while ( (c = input()) == &rsquo;*&rsquo; ) <br>
; <br>
if ( c == &rsquo;/&rsquo; ) <br>
break; /* found the end */ <br>
}</p>

<p style="margin-top: 1em">if ( c == EOF ) <br>
{ <br>
error( &quot;EOF in comment&quot; ); <br>
break; <br>
} <br>
} <br>
}</p>

<p style="margin-top: 1em">(Note that if the scanner is
compiled using C++, then input() is instead referred to as
yyinput(), in order to avoid a name clash with the C++
stream by the name of <br>
input.)</p>

<p style="margin-top: 1em">- YY_FLUSH_BUFFER flushes the
scanner&rsquo;s internal buffer so that the next time the
scanner attempts to match a token, it will first refill the
buffer using YY_INPUT (see The <br>
Generated Scanner, below). This action is a special case of
the more general yy_flush_buffer() function, described below
in the section Multiple Input Buffers.</p>

<p style="margin-top: 1em">- yyterminate() can be used in
lieu of a return statement in an action. It terminates the
scanner and returns a 0 to the scanner&rsquo;s caller,
indicating &quot;all done&quot;. By <br>
default, yyterminate() is also called when an end-of-file is
encountered. It is a macro and may be redefined.</p>

<p style="margin-top: 1em">THE GENERATED SCANNER <br>
The output of flex is the file lex.yy.c, which contains the
scanning routine yylex(), a number of tables used by it for
matching tokens, and a number of auxiliary routines and <br>
macros. By default, yylex() is declared as follows:</p>

<p style="margin-top: 1em">int yylex() <br>
{ <br>
... various definitions and the actions in here ... <br>
}</p>

<p style="margin-top: 1em">(If your environment supports
function prototypes, then it will be &quot;int yylex( void
)&quot;.) This definition may be changed by defining the
&quot;YY_DECL&quot; macro. For example, you could <br>
use:</p>

<p style="margin-top: 1em">#define YY_DECL float lexscan(
a, b ) float a, b;</p>

<p style="margin-top: 1em">to give the scanning routine the
name lexscan, returning a float, and taking two floats as
arguments. Note that if you give arguments to the scanning
routine using a K&amp;R- <br>
style/non-prototyped function declaration, you must
terminate the definition with a semi-colon (;).</p>

<p style="margin-top: 1em">Whenever yylex() is called, it
scans tokens from the global input file yyin (which defaults
to stdin). It continues until it either reaches an
end-of-file (at which point it <br>
returns the value 0) or one of its actions executes a return
statement.</p>

<p style="margin-top: 1em">If the scanner reaches an
end-of-file, subsequent calls are undefined unless either
yyin is pointed at a new input file (in which case scanning
continues from that file), or <br>
yyrestart() is called. yyrestart() takes one argument, a
FILE * pointer (which can be nil, if you&rsquo;ve set up
YY_INPUT to scan from a source other than yyin), and
initializes yyin <br>
for scanning from that file. Essentially there is no
difference between just assigning yyin to a new input file
or using yyrestart() to do so; the latter is available for
com&acirc; <br>
patibility with previous versions of flex, and because it
can be used to switch input files in the middle of scanning.
It can also be used to throw away the current input
buf&acirc; <br>
fer, by calling it with an argument of yyin; but better is
to use YY_FLUSH_BUFFER (see above). Note that yyrestart()
does not reset the start condition to INITIAL (see Start
<br>
Conditions, below).</p>

<p style="margin-top: 1em">If yylex() stops scanning due to
executing a return statement in one of the actions, the
scanner may then be called again and it will resume scanning
where it left off.</p>

<p style="margin-top: 1em">By default (and for purposes of
efficiency), the scanner uses block-reads rather than simple
getc() calls to read characters from yyin. The nature of how
it gets its input can <br>
be controlled by defining the YY_INPUT macro.
YY_INPUT&rsquo;s calling sequence is
&quot;YY_INPUT(buf,result,max_size)&quot;. Its action is to
place up to max_size characters in the character <br>
array buf and return in the integer variable result either
the number of characters read or the constant YY_NULL (0 on
Unix systems) to indicate EOF. The default YY_INPUT reads
<br>
from the global file-pointer &quot;yyin&quot;.</p>

<p style="margin-top: 1em">A sample definition of YY_INPUT
(in the definitions section of the input file):</p>

<p style="margin-top: 1em">%{ <br>
#define YY_INPUT(buf,result,max_size) { int c = getchar();
result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); } <br>
%}</p>

<p style="margin-top: 1em">This definition will change the
input processing to occur one character at a time.</p>

<p style="margin-top: 1em">When the scanner receives an
end-of-file indication from YY_INPUT, it then checks the
yywrap() function. If yywrap() returns false (zero), then it
is assumed that the function <br>
has gone ahead and set up yyin to point to another input
file, and scanning continues. If it returns true (non-zero),
then the scanner terminates, returning 0 to its caller. <br>
Note that in either case, the start condition remains
unchanged; it does not revert to INITIAL.</p>

<p style="margin-top: 1em">If you do not supply your own
version of yywrap(), then you must either use %option
noyywrap (in which case the scanner behaves as though
yywrap() returned 1), or you must link <br>
with -lfl to obtain the default version of the routine,
which always returns 1.</p>

<p style="margin-top: 1em">Three routines are available for
scanning from in-memory buffers rather than files:
yy_scan_string(), yy_scan_bytes(), and yy_scan_buffer(). See
the discussion of them below in <br>
the section Multiple Input Buffers.</p>

<p style="margin-top: 1em">The scanner writes its ECHO
output to the yyout global (default, stdout), which may be
redefined by the user simply by assigning it to some other
FILE pointer.</p>

<p style="margin-top: 1em">START CONDITIONS <br>
flex provides a mechanism for conditionally activating
rules. Any rule whose pattern is prefixed with
&quot;&lt;sc&gt;&quot; will only be active when the scanner
is in the start condition named <br>
&quot;sc&quot;. For example,</p>

<p style="margin-top: 1em">&lt;STRING&gt;[^&quot;]* { /*
eat up the string body ... */ <br>
... <br>
}</p>

<p style="margin-top: 1em">will be active only when the
scanner is in the &quot;STRING&quot; start condition,
and</p>

<p style="margin-top: 1em">&lt;INITIAL,STRING,QUOTE&gt;. {
/* handle an escape ... */ <br>
... <br>
}</p>

<p style="margin-top: 1em">will be active only when the
current start condition is either &quot;INITIAL&quot;,
&quot;STRING&quot;, or &quot;QUOTE&quot;.</p>

<p style="margin-top: 1em">Start conditions are declared in
the definitions (first) section of the input using
unindented lines beginning with either %s or %x followed by
a list of names. The former <br>
declares inclusive start conditions, the latter exclusive
start conditions. A start condition is activated using the
BEGIN action. Until the next BEGIN action is executed, <br>
rules with the given start condition will be active and
rules with other start conditions will be inactive. If the
start condition is inclusive, then rules with no start
condi&acirc; <br>
tions at all will also be active. If it is exclusive, then
only rules qualified with the start condition will be
active. A set of rules contingent on the same exclusive
start <br>
condition describe a scanner which is independent of any of
the other rules in the flex input. Because of this,
exclusive start conditions make it easy to specify
&quot;mini-scan&acirc; <br>
ners&quot; which scan portions of the input that are
syntactically different from the rest (e.g., comments).</p>

<p style="margin-top: 1em">If the distinction between
inclusive and exclusive start conditions is still a little
vague, here&rsquo;s a simple example illustrating the
connection between the two. The set of <br>
rules:</p>

<p style="margin-top: 1em">%s example <br>
%%</p>

<p style="margin-top: 1em">&lt;example&gt;foo
do_something();</p>

<p style="margin-top: 1em">bar something_else();</p>

<p style="margin-top: 1em">is equivalent to</p>

<p style="margin-top: 1em">%x example <br>
%%</p>

<p style="margin-top: 1em">&lt;example&gt;foo
do_something();</p>

<p style="margin-top: 1em">&lt;INITIAL,example&gt;bar
something_else();</p>

<p style="margin-top: 1em">Without the
&lt;INITIAL,example&gt; qualifier, the bar pattern in the
second example wouldn&rsquo;t be active (i.e.,
couldn&rsquo;t match) when in start condition example. If we
just used &lt;exam&acirc; <br>
ple&gt; to qualify bar, though, then it would only be active
in example and not in INITIAL, while in the first example
it&rsquo;s active in both, because in the first example the
example <br>
startion condition is an inclusive (%s) start condition.</p>

<p style="margin-top: 1em">Also note that the special
start-condition specifier &lt;*&gt; matches every start
condition. Thus, the above example could also have been
written;</p>

<p style="margin-top: 1em">%x example <br>
%%</p>

<p style="margin-top: 1em">&lt;example&gt;foo
do_something();</p>

<p style="margin-top: 1em">&lt;*&gt;bar
something_else();</p>

<p style="margin-top: 1em">The default rule (to ECHO any
unmatched character) remains active in start conditions. It
is equivalent to:</p>

<p style="margin-top: 1em">&lt;*&gt;.| ECHO;</p>

<p style="margin-top: 1em">BEGIN(0) returns to the original
state where only the rules with no start conditions are
active. This state can also be referred to as the
start-condition &quot;INITIAL&quot;, so <br>
BEGIN(INITIAL) is equivalent to BEGIN(0). (The parentheses
around the start condition name are not required but are
considered good style.)</p>

<p style="margin-top: 1em">BEGIN actions can also be given
as indented code at the beginning of the rules section. For
example, the following will cause the scanner to enter the
&quot;SPECIAL&quot; start condition <br>
whenever yylex() is called and the global variable
enter_special is true:</p>

<p style="margin-top: 1em">int enter_special;</p>

<p style="margin-top: 1em">%x SPECIAL <br>
%% <br>
if ( enter_special ) <br>
BEGIN(SPECIAL);</p>

<p style="margin-top: 1em">&lt;SPECIAL&gt;blahblahblah <br>
...more rules follow...</p>

<p style="margin-top: 1em">To illustrate the uses of start
conditions, here is a scanner which provides two different
interpretations of a string like &quot;123.456&quot;. By
default it will treat it as three <br>
tokens, the integer &quot;123&quot;, a dot
(&rsquo;.&rsquo;), and the integer &quot;456&quot;. But if
the string is preceded earlier in the line by the string
&quot;expect-floats&quot; it will treat it as a single <br>
token, the floating-point number 123.456:</p>

<p style="margin-top: 1em">%{ <br>
#include &lt;math.h&gt; <br>
%} <br>
%s expect</p>

<p style="margin-top: 1em">%% <br>
expect-floats BEGIN(expect);</p>


<p style="margin-top: 1em">&lt;expect&gt;[0-9]+&quot;.&quot;[0-9]+
{ <br>
printf( &quot;found a float, = %f0, <br>
atof( yytext ) ); <br>
} <br>
&lt;expect&gt; { <br>
/* that&rsquo;s the end of the line, so <br>
* we need another &quot;expect-number&quot; <br>
* before we&rsquo;ll recognize any more <br>
* numbers <br>
*/ <br>
BEGIN(INITIAL); <br>
}</p>

<p style="margin-top: 1em">[0-9]+ { <br>
printf( &quot;found an integer, = %d0, <br>
atoi( yytext ) ); <br>
}</p>

<p style="margin-top: 1em">&quot;.&quot; printf(
&quot;found a dot0 );</p>

<p style="margin-top: 1em">Here is a scanner which
recognizes (and discards) C comments while maintaining a
count of the current input line.</p>

<p style="margin-top: 1em">%x comment <br>
%% <br>
int line_num = 1;</p>

<p style="margin-top: 1em">&quot;/*&quot;
BEGIN(comment);</p>

<p style="margin-top: 1em">&lt;comment&gt;[^*0* /* eat
anything that&rsquo;s not a &rsquo;*&rsquo; */ <br>
&lt;comment&gt;&quot;*&quot;+[^*/0* /* eat up
&rsquo;*&rsquo;s not followed by &rsquo;/&rsquo;s */ <br>
&lt;comment&gt; ++line_num; <br>
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;
BEGIN(INITIAL);</p>

<p style="margin-top: 1em">This scanner goes to a bit of
trouble to match as much text as possible with each rule. In
general, when attempting to write a high-speed scanner try
to match as much possible <br>
in each rule, as it&rsquo;s a big win.</p>

<p style="margin-top: 1em">Note that start-conditions names
are really integer values and can be stored as such. Thus,
the above could be extended in the following fashion:</p>

<p style="margin-top: 1em">%x comment foo <br>
%% <br>
int line_num = 1; <br>
int comment_caller;</p>

<p style="margin-top: 1em">&quot;/*&quot; { <br>
comment_caller = INITIAL; <br>
BEGIN(comment); <br>
}</p>

<p style="margin-top: 1em">...</p>

<p style="margin-top: 1em">&lt;foo&gt;&quot;/*&quot; { <br>
comment_caller = foo; <br>
BEGIN(comment); <br>
}</p>

<p style="margin-top: 1em">&lt;comment&gt;[^*0* /* eat
anything that&rsquo;s not a &rsquo;*&rsquo; */ <br>
&lt;comment&gt;&quot;*&quot;+[^*/0* /* eat up
&rsquo;*&rsquo;s not followed by &rsquo;/&rsquo;s */ <br>
&lt;comment&gt; ++line_num; <br>
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;
BEGIN(comment_caller);</p>

<p style="margin-top: 1em">Furthermore, you can access the
current start condition using the integer-valued YY_START
macro. For example, the above assignments to comment_caller
could instead be written</p>

<p style="margin-top: 1em">comment_caller = YY_START;</p>

<p style="margin-top: 1em">Flex provides YYSTATE as an
alias for YY_START (since that is what&rsquo;s used by
AT&amp;T lex).</p>

<p style="margin-top: 1em">Note that start conditions do
not have their own name-space; %s&rsquo;s and %x&rsquo;s
declare names in the same fashion as #define&rsquo;s.</p>

<p style="margin-top: 1em">Finally, here&rsquo;s an example
of how to match C-style quoted strings using exclusive start
conditions, including expanded escape sequences (but not
including checking for a string <br>
that&rsquo;s too long):</p>

<p style="margin-top: 1em">%x str</p>

<p style="margin-top: 1em">%% <br>
char string_buf[MAX_STR_CONST]; <br>
char *string_buf_ptr;</p>

<p style="margin-top: 1em">&lt;str&gt; <br>
BEGIN(INITIAL); <br>
*string_buf_ptr = &rsquo; &rsquo;; <br>
/* return string constant token type and <br>
* value to parser <br>
*/ <br>
}</p>

<p style="margin-top: 1em">&lt;str&gt; { <br>
/* error - unterminated string constant */ <br>
/* generate error message */ <br>
}</p>

<p style="margin-top: 1em">&lt;str&gt;\[0-7]{1,3} { <br>
/* octal escape sequence */ <br>
int result;</p>

<p style="margin-top: 1em">(void) sscanf( yytext + 1,
&quot;%o&quot;, &amp;result );</p>

<p style="margin-top: 1em">if ( result &gt; 0xff ) <br>
/* error, constant is out-of-bounds */</p>

<p style="margin-top: 1em">*string_buf_ptr++ = result; <br>
}</p>

<p style="margin-top: 1em">&lt;str&gt;\[0-9]+ { <br>
/* generate error - bad escape sequence; something <br>
* like &rsquo;48&rsquo; or &rsquo; 777777&rsquo; <br>
*/ <br>
}</p>

<p style="margin-top: 1em">&lt;str&gt;\n *string_buf_ptr++
= &rsquo;0; <br>
&lt;str&gt;\t *string_buf_ptr++ = &rsquo;&rsquo;;&rsquo;;
<br>
&lt;str&gt;\r *string_buf_ptr++ = &rsquo; <br>
&lt;str&gt;\b *string_buf_ptr++ = &rsquo;; <br>
&lt;str&gt;\f *string_buf_ptr++ = &rsquo;;</p>

<p style="margin-top: 1em">&lt;str&gt;\(.|0
*string_buf_ptr++ = yytext[1];</p>

<p style="margin-top: 1em">&lt;str&gt;[^\ <br>
char *yptr = yytext;</p>

<p style="margin-top: 1em">while ( *yptr ) <br>
*string_buf_ptr++ = *yptr++; <br>
}</p>

<p style="margin-top: 1em">Often, such as in some of the
examples above, you wind up writing a whole bunch of rules
all preceded by the same start condition(s). Flex makes this
a little easier and cleaner <br>
by introducing a notion of start condition scope. A start
condition scope is begun with:</p>

<p style="margin-top: 1em">&lt;SCs&gt;{</p>

<p style="margin-top: 1em">where SCs is a list of one or
more start conditions. Inside the start condition scope,
every rule automatically has the prefix &lt;SCs&gt; applied
to it, until a &rsquo;}&rsquo; which matches the <br>
initial &rsquo;{&rsquo;. So, for example,</p>

<p style="margin-top: 1em">&lt;ESC&gt;{ <br>
&quot;\n&quot; return &rsquo;0;&rsquo;; <br>
&quot;\r&quot; return &rsquo; <br>
&quot;\f&quot; return &rsquo;; <br>
&quot;\0&quot; return &rsquo; &rsquo;; <br>
}</p>

<p style="margin-top: 1em">is equivalent to:</p>

<p style="margin-top: 1em">&lt;ESC&gt;&quot;\n&quot; return
&rsquo;0;&rsquo;; <br>
&lt;ESC&gt;&quot;\r&quot; return &rsquo; <br>
&lt;ESC&gt;&quot;\f&quot; return &rsquo;; <br>
&lt;ESC&gt;&quot;\0&quot; return &rsquo; &rsquo;;</p>

<p style="margin-top: 1em">Start condition scopes may be
nested.</p>

<p style="margin-top: 1em">Three routines are available for
manipulating stacks of start conditions:</p>

<p style="margin-top: 1em">void yy_push_state(int
new_state) <br>
pushes the current start condition onto the top of the start
condition stack and switches to new_state as though you had
used BEGIN new_state (recall that start condition <br>
names are also integers).</p>

<p style="margin-top: 1em">void yy_pop_state() <br>
pops the top of the stack and switches to it via BEGIN.</p>

<p style="margin-top: 1em">int yy_top_state() <br>
returns the top of the stack without altering the
stack&rsquo;s contents.</p>

<p style="margin-top: 1em">The start condition stack grows
dynamically and so has no built-in size limitation. If
memory is exhausted, program execution aborts.</p>

<p style="margin-top: 1em">To use start condition stacks,
your scanner must include a %option stack directive (see
Options below).</p>

<p style="margin-top: 1em">MULTIPLE INPUT BUFFERS <br>
Some scanners (such as those which support
&quot;include&quot; files) require reading from several
input streams. As flex scanners do a large amount of
buffering, one cannot control where <br>
the next input will be read from by simply writing a
YY_INPUT which is sensitive to the scanning context.
YY_INPUT is only called when the scanner reaches the end of
its buffer, <br>
which may be a long time after scanning a statement such as
an &quot;include&quot; which requires switching the input
source.</p>

<p style="margin-top: 1em">To negotiate these sorts of
problems, flex provides a mechanism for creating and
switching between multiple input buffers. An input buffer is
created by using:</p>

<p style="margin-top: 1em">YY_BUFFER_STATE
yy_create_buffer( FILE *file, int size )</p>

<p style="margin-top: 1em">which takes a FILE pointer and a
size and creates a buffer associated with the given file and
large enough to hold size characters (when in doubt, use
YY_BUF_SIZE for the size). <br>
It returns a YY_BUFFER_STATE handle, which may then be
passed to other routines (see below). The YY_BUFFER_STATE
type is a pointer to an opaque struct yy_buffer_state
structure, <br>
so you may safely initialize YY_BUFFER_STATE variables to
((YY_BUFFER_STATE) 0) if you wish, and also refer to the
opaque structure in order to correctly declare input buffers
in <br>
source files other than that of your scanner. Note that the
FILE pointer in the call to yy_create_buffer is only used as
the value of yyin seen by YY_INPUT; if you redefine <br>
YY_INPUT so it no longer uses yyin, then you can safely pass
a nil FILE pointer to yy_create_buffer. You select a
particular buffer to scan from using:</p>

<p style="margin-top: 1em">void yy_switch_to_buffer(
YY_BUFFER_STATE new_buffer )</p>

<p style="margin-top: 1em">switches the scanner&rsquo;s
input buffer so subsequent tokens will come from new_buffer.
Note that yy_switch_to_buffer() may be used by yywrap() to
set things up for continued scan&acirc; <br>
ning, instead of opening a new file and pointing yyin at it.
Note also that switching input sources via either
yy_switch_to_buffer() or yywrap() does not change the start
condi&acirc; <br>
tion.</p>

<p style="margin-top: 1em">void yy_delete_buffer(
YY_BUFFER_STATE buffer )</p>

<p style="margin-top: 1em">is used to reclaim the storage
associated with a buffer. ( buffer can be nil, in which case
the routine does nothing.) You can also clear the current
contents of a buffer <br>
using:</p>

<p style="margin-top: 1em">void yy_flush_buffer(
YY_BUFFER_STATE buffer )</p>

<p style="margin-top: 1em">This function discards the
buffer&rsquo;s contents, so the next time the scanner
attempts to match a token from the buffer, it will first
fill the buffer anew using YY_INPUT.</p>

<p style="margin-top: 1em">yy_new_buffer() is an alias for
yy_create_buffer(), provided for compatibility with the C++
use of new and delete for creating and destroying dynamic
objects.</p>

<p style="margin-top: 1em">Finally, the YY_CURRENT_BUFFER
macro returns a YY_BUFFER_STATE handle to the current
buffer.</p>

<p style="margin-top: 1em">Here is an example of using
these features for writing a scanner which expands include
files (the &lt;&lt;EOF&gt;&gt; feature is discussed
below):</p>

<p style="margin-top: 1em">/* the &quot;incl&quot; state is
used for picking up the name <br>
* of an include file <br>
*/ <br>
%x incl</p>

<p style="margin-top: 1em">%{ <br>
#define MAX_INCLUDE_DEPTH 10 <br>
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH]; <br>
int include_stack_ptr = 0; <br>
%}</p>

<p style="margin-top: 1em">%% <br>
include BEGIN(incl);</p>

<p style="margin-top: 1em">[a-z]+ ECHO; <br>
[^a-z0*0 ECHO;</p>

<p style="margin-top: 1em">&lt;incl&gt;[ ]* /* eat the
whitespace */ <br>
&lt;incl&gt;[^ 0+ { /* got the include file name */ <br>
if ( include_stack_ptr &gt;= MAX_INCLUDE_DEPTH ) <br>
{ <br>
fprintf( stderr, &quot;Includes nested too deeply&quot; );
<br>
exit( 1 ); <br>
}</p>


<p style="margin-top: 1em">include_stack[include_stack_ptr++]
= <br>
YY_CURRENT_BUFFER;</p>

<p style="margin-top: 1em">yyin = fopen( yytext,
&quot;r&quot; );</p>

<p style="margin-top: 1em">if ( ! yyin ) <br>
error( ... );</p>

<p style="margin-top: 1em">yy_switch_to_buffer( <br>
yy_create_buffer( yyin, YY_BUF_SIZE ) );</p>

<p style="margin-top: 1em">BEGIN(INITIAL); <br>
}</p>

<p style="margin-top: 1em">&lt;&lt;EOF&gt;&gt; { <br>
if ( --include_stack_ptr &lt; 0 ) <br>
{ <br>
yyterminate(); <br>
}</p>

<p style="margin-top: 1em">else <br>
{ <br>
yy_delete_buffer( YY_CURRENT_BUFFER ); <br>
yy_switch_to_buffer( <br>
include_stack[include_stack_ptr] ); <br>
} <br>
}</p>

<p style="margin-top: 1em">Three routines are available for
setting up input buffers for scanning in-memory strings
instead of files. All of them create a new input buffer for
scanning the string, and <br>
return a corresponding YY_BUFFER_STATE handle (which you
should delete with yy_delete_buffer() when done with it).
They also switch to the new buffer using
yy_switch_to_buf&acirc; <br>
fer(), so the next call to yylex() will start scanning the
string.</p>

<p style="margin-top: 1em">yy_scan_string(const char *str)
<br>
scans a NUL-terminated string.</p>

<p style="margin-top: 1em">yy_scan_bytes(const char *bytes,
int len) <br>
scans len bytes (including possibly NUL&rsquo;s) starting at
location bytes.</p>

<p style="margin-top: 1em">Note that both of these
functions create and scan a copy of the string or bytes.
(This may be desirable, since yylex() modifies the contents
of the buffer it is scanning.) You <br>
can avoid the copy by using:</p>

<p style="margin-top: 1em">yy_scan_buffer(char *base,
yy_size_t size) <br>
which scans in place the buffer starting at base, consisting
of size bytes, the last two bytes of which must be
YY_END_OF_BUFFER_CHAR (ASCII NUL). These last two bytes <br>
are not scanned; thus, scanning consists of base[0] through
base[size-2], inclusive.</p>

<p style="margin-top: 1em">If you fail to set up base in
this manner (i.e., forget the final two
YY_END_OF_BUFFER_CHAR bytes), then yy_scan_buffer() returns
a nil pointer instead of creating a new <br>
input buffer.</p>

<p style="margin-top: 1em">The type yy_size_t is an
integral type to which you can cast an integer expression
reflecting the size of the buffer.</p>

<p style="margin-top: 1em">END-OF-FILE RULES <br>
The special rule &quot;&lt;&lt;EOF&gt;&gt;&quot; indicates
actions which are to be taken when an end-of-file is
encountered and yywrap() returns non-zero (i.e., indicates
no further files to process). <br>
The action must finish by doing one of four things:</p>

<p style="margin-top: 1em">- assigning yyin to a new input
file (in previous versions of flex, after doing the
assignment you had to call the special action YY_NEW_FILE;
this is no longer necessary);</p>

<p style="margin-top: 1em">- executing a return
statement;</p>

<p style="margin-top: 1em">- executing the special
yyterminate() action;</p>

<p style="margin-top: 1em">- or, switching to a new buffer
using yy_switch_to_buffer() as shown in the example
above.</p>

<p style="margin-top: 1em">&lt;&lt;EOF&gt;&gt; rules may
not be used with other patterns; they may only be qualified
with a list of start conditions. If an unqualified
&lt;&lt;EOF&gt;&gt; rule is given, it applies to all start
<br>
conditions which do not already have &lt;&lt;EOF&gt;&gt;
actions. To specify an &lt;&lt;EOF&gt;&gt; rule for only the
initial start condition, use</p>


<p style="margin-top: 1em">&lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;</p>

<p style="margin-top: 1em">These rules are useful for
catching things like unclosed comments. An example:</p>

<p style="margin-top: 1em">%x quote <br>
%%</p>

<p style="margin-top: 1em">...other rules for dealing with
quotes...</p>


<p style="margin-top: 1em">&lt;quote&gt;&lt;&lt;EOF&gt;&gt;
{ <br>
error( &quot;unterminated quote&quot; ); <br>
yyterminate(); <br>
} <br>
&lt;&lt;EOF&gt;&gt; { <br>
if ( *++filelist ) <br>
yyin = fopen( *filelist, &quot;r&quot; ); <br>
else <br>
yyterminate(); <br>
}</p>

<p style="margin-top: 1em">MISCELLANEOUS MACROS <br>
The macro YY_USER_ACTION can be defined to provide an action
which is always executed prior to the matched rule&rsquo;s
action. For example, it could be #define&rsquo;d to call a
routine to <br>
convert yytext to lower-case. When YY_USER_ACTION is
invoked, the variable yy_act gives the number of the matched
rule (rules are numbered starting with 1). Suppose you want
to <br>
profile how often each of your rules is matched. The
following would do the trick:</p>

<p style="margin-top: 1em">#define YY_USER_ACTION
++ctr[yy_act]</p>

<p style="margin-top: 1em">where ctr is an array to hold
the counts for the different rules. Note that the macro
YY_NUM_RULES gives the total number of rules (including the
default rule, even if you use <br>
-s), so a correct declaration for ctr is:</p>

<p style="margin-top: 1em">int ctr[YY_NUM_RULES];</p>

<p style="margin-top: 1em">The macro YY_USER_INIT may be
defined to provide an action which is always executed before
the first scan (and before the scanner&rsquo;s internal
initializations are done). For exam&acirc; <br>
ple, it could be used to call a routine to read in a data
table or open a logging file.</p>

<p style="margin-top: 1em">The macro
yy_set_interactive(is_interactive) can be used to control
whether the current buffer is considered interactive. An
interactive buffer is processed more slowly, but <br>
must be used when the scanner&rsquo;s input source is indeed
interactive to avoid problems due to waiting to fill buffers
(see the discussion of the -I flag below). A non-zero value
<br>
in the macro invocation marks the buffer as interactive, a
zero value as non-interactive. Note that use of this macro
overrides %option always-interactive or %option never- <br>
interactive (see Options below). yy_set_interactive() must
be invoked prior to beginning to scan the buffer that is (or
is not) to be considered interactive.</p>

<p style="margin-top: 1em">The macro yy_set_bol(at_bol) can
be used to control whether the current buffer&rsquo;s
scanning context for the next token match is done as though
at the beginning of a line. A non- <br>
zero macro argument makes rules anchored with</p>

<p style="margin-top: 1em">The macro YY_AT_BOL() returns
true if the next token scanned from the current buffer will
have &rsquo;^&rsquo; rules active, false otherwise.</p>

<p style="margin-top: 1em">In the generated scanner, the
actions are all gathered in one large switch statement and
separated using YY_BREAK, which may be redefined. By
default, it is simply a &quot;break&quot;, to <br>
separate each rule&rsquo;s action from the following
rule&rsquo;s. Redefining YY_BREAK allows, for example, C++
users to #define YY_BREAK to do nothing (while being very
careful that every <br>
rule ends with a &quot;break&quot; or a &quot;return&quot;!)
to avoid suffering from unreachable statement warnings where
because a rule&rsquo;s action ends with &quot;return&quot;,
the YY_BREAK is inaccessible.</p>

<p style="margin-top: 1em">VALUES AVAILABLE TO THE USER
<br>
This section summarizes the various values available to the
user in the rule actions.</p>

<p style="margin-top: 1em">- char *yytext holds the text of
the current token. It may be modified but not lengthened
(you cannot append characters to the end).</p>

<p style="margin-top: 1em">If the special directive %array
appears in the first section of the scanner description,
then yytext is instead declared char yytext[YYLMAX], where
YYLMAX is a macro defi&acirc; <br>
nition that you can redefine in the first section if you
don&rsquo;t like the default value (generally 8KB). Using
%array results in somewhat slower scanners, but the value of
<br>
yytext becomes immune to calls to input() and unput(), which
potentially destroy its value when yytext is a character
pointer. The opposite of %array is %pointer, which <br>
is the default.</p>

<p style="margin-top: 1em">You cannot use %array when
generating C++ scanner classes (the -+ flag).</p>

<p style="margin-top: 1em">- int yyleng holds the length of
the current token.</p>

<p style="margin-top: 1em">- FILE *yyin is the file which
by default flex reads from. It may be redefined but doing so
only makes sense before scanning begins or after an EOF has
been encountered. <br>
Changing it in the midst of scanning will have unexpected
results since flex buffers its input; use yyrestart()
instead. Once scanning terminates because an end-of-file
<br>
has been seen, you can assign yyin at the new input file and
then call the scanner again to continue scanning.</p>

<p style="margin-top: 1em">- void yyrestart( FILE *new_file
) may be called to point yyin at the new input file. The
switch-over to the new file is immediate (any previously
buffered-up input is <br>
lost). Note that calling yyrestart() with yyin as an
argument thus throws away the current input buffer and
continues scanning the same input file.</p>

<p style="margin-top: 1em">- FILE *yyout is the file to
which ECHO actions are done. It can be reassigned by the
user.</p>

<p style="margin-top: 1em">- YY_CURRENT_BUFFER returns a
YY_BUFFER_STATE handle to the current buffer.</p>

<p style="margin-top: 1em">- YY_START returns an integer
value corresponding to the current start condition. You can
subsequently use this value with BEGIN to return to that
start condition.</p>

<p style="margin-top: 1em">INTERFACING WITH YACC <br>
One of the main uses of flex is as a companion to the yacc
parser-generator. yacc parsers expect to call a routine
named yylex() to find the next input token. The routine is
<br>
supposed to return the type of the next token as well as
putting any associated value in the global yylval. To use
flex with yacc, one specifies the -d option to yacc to <br>
instruct it to generate the file y.tab.h containing
definitions of all the %tokens appearing in the yacc input.
This file is then included in the flex scanner. For example,
if <br>
one of the tokens is &quot;TOK_NUMBER&quot;, part of the
scanner might look like:</p>

<p style="margin-top: 1em">%{ <br>
#include &quot;y.tab.h&quot; <br>
%}</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">[0-9]+ yylval = atoi( yytext );
return TOK_NUMBER;</p>

<p style="margin-top: 1em">OPTIONS <br>
flex has the following options:</p>

<p style="margin-top: 1em">-b Generate backing-up
information to lex.backup. This is a list of scanner states
which require backing up and the input characters on which
they do so. By adding rules <br>
one can remove backing-up states. If all backing-up states
are eliminated and -Cf or -CF is used, the generated scanner
will run faster (see the -p flag). Only users who <br>
wish to squeeze every last cycle out of their scanners need
worry about this option. (See the section on Performance
Considerations below.)</p>

<p style="margin-top: 1em">-c is a do-nothing, deprecated
option included for POSIX compliance.</p>

<p style="margin-top: 1em">-d makes the generated scanner
run in debug mode. Whenever a pattern is recognized and the
global yy_flex_debug is non-zero (which is the default), the
scanner will write to <br>
stderr a line of the form:</p>

<p style="margin-top: 1em">--accepting rule at line 53
(&quot;the matched text&quot;)</p>

<p style="margin-top: 1em">The line number refers to the
location of the rule in the file defining the scanner (i.e.,
the file that was fed to flex). Messages are also generated
when the scanner <br>
backs up, accepts the default rule, reaches the end of its
input buffer (or encounters a NUL; at this point, the two
look the same as far as the scanner&rsquo;s concerned), or
<br>
reaches an end-of-file.</p>

<p style="margin-top: 1em">-f specifies fast scanner. No
table compression is done and stdio is bypassed. The result
is large but fast. This option is equivalent to -Cfr (see
below).</p>

<p style="margin-top: 1em">-h generates a &quot;help&quot;
summary of flex&rsquo;s options to stdout and then exits. -?
and --help are synonyms for -h.</p>

<p style="margin-top: 1em">-i instructs flex to generate a
case-insensitive scanner. The case of letters given in the
flex input patterns will be ignored, and tokens in the input
will be matched <br>
regardless of case. The matched text given in yytext will
have the preserved case (i.e., it will not be folded).</p>

<p style="margin-top: 1em">-l turns on maximum
compatibility with the original AT&amp;T lex implementation.
Note that this does not mean full compatibility. Use of this
option costs a considerable amount <br>
of performance, and it cannot be used with the -+, -f, -F,
-Cf, or -CF options. For details on the compatibilities it
provides, see the section &quot;Incompatibilities With <br>
Lex And POSIX&quot; below. This option also results in the
name YY_FLEX_LEX_COMPAT being #define&rsquo;d in the
generated scanner.</p>

<p style="margin-top: 1em">-n is another do-nothing,
deprecated option included only for POSIX compliance.</p>

<p style="margin-top: 1em">-p generates a performance
report to stderr. The report consists of comments regarding
features of the flex input file which will cause a serious
loss of performance in the <br>
resulting scanner. If you give the flag twice, you will also
get comments regarding features that lead to minor
performance losses.</p>

<p style="margin-top: 1em">Note that the use of REJECT,
%option yylineno, and variable trailing context (see the
Deficiencies / Bugs section below) entails a substantial
performance penalty; use of <br>
yymore(), the ^ operator, and the -I flag entail minor
performance penalties.</p>

<p style="margin-top: 1em">-s causes the default rule (that
unmatched scanner input is echoed to stdout) to be
suppressed. If the scanner encounters input that does not
match any of its rules, it <br>
aborts with an error. This option is useful for finding
holes in a scanner&rsquo;s rule set.</p>

<p style="margin-top: 1em">-t instructs flex to write the
scanner it generates to standard output instead of
lex.yy.c.</p>

<p style="margin-top: 1em">-v specifies that flex should
write to stderr a summary of statistics regarding the
scanner it generates. Most of the statistics are meaningless
to the casual flex user, but <br>
the first line identifies the version of flex (same as
reported by -V), and the next line the flags used when
generating the scanner, including those that are on by <br>
default.</p>

<p style="margin-top: 1em">-w suppresses warning
messages.</p>

<p style="margin-top: 1em">-B instructs flex to generate a
batch scanner, the opposite of interactive scanners
generated by -I (see below). In general, you use -B when you
are certain that your scan&acirc; <br>
ner will never be used interactively, and you want to
squeeze a little more performance out of it. If your goal is
instead to squeeze out a lot more performance, you <br>
should be using the -Cf or -CF options (discussed below),
which turn on -B automatically anyway.</p>

<p style="margin-top: 1em">-F specifies that the fast
scanner table representation should be used (and stdio
bypassed). This representation is about as fast as the full
table representation (-f), and <br>
for some sets of patterns will be considerably smaller (and
for others, larger). In general, if the pattern set contains
both &quot;keywords&quot; and a catch-all,
&quot;identifier&quot; <br>
rule, such as in the set:</p>

<p style="margin-top: 1em">&quot;case&quot; return
TOK_CASE; <br>
&quot;switch&quot; return TOK_SWITCH; <br>
... <br>
&quot;default&quot; return TOK_DEFAULT; <br>
[a-z]+ return TOK_ID;</p>

<p style="margin-top: 1em">then you&rsquo;re better off
using the full table representation. If only the
&quot;identifier&quot; rule is present and you then use a
hash table or some such to detect the keywords, <br>
you&rsquo;re better off using -F.</p>

<p style="margin-top: 1em">This option is equivalent to
-CFr (see below). It cannot be used with -+.</p>

<p style="margin-top: 1em">-I instructs flex to generate an
interactive scanner. An interactive scanner is one that only
looks ahead to decide what token has been matched if it
absolutely must. It <br>
turns out that always looking one extra character ahead,
even if the scanner has already seen enough text to
disambiguate the current token, is a bit faster than only
<br>
looking ahead when necessary. But scanners that always look
ahead give dreadful interactive performance; for example,
when a user types a newline, it is not recognized as <br>
a newline token until they enter another token, which often
means typing in another whole line.</p>

<p style="margin-top: 1em">Flex scanners default to
interactive unless you use the -Cf or -CF table-compression
options (see below). That&rsquo;s because if you&rsquo;re
looking for high-performance you should <br>
be using one of these options, so if you didn&rsquo;t, flex
assumes you&rsquo;d rather trade off a bit of run-time
performance for intuitive interactive behavior. Note also
that you <br>
cannot use -I in conjunction with -Cf or -CF. Thus, this
option is not really needed; it is on by default for all
those cases in which it is allowed.</p>

<p style="margin-top: 1em">You can force a scanner to not
be interactive by using -B (see above).</p>

<p style="margin-top: 1em">-L instructs flex not to
generate #line directives. Without this option, flex peppers
the generated scanner with #line directives so error
messages in the actions will be <br>
correctly located with respect to either the original flex
input file (if the errors are due to code in the input
file), or lex.yy.c (if the errors are flex&rsquo;s fault --
you <br>
should report these sorts of errors to the email address
given below).</p>

<p style="margin-top: 1em">-T makes flex run in trace mode.
It will generate a lot of messages to stderr concerning the
form of the input and the resultant non-deterministic and
deterministic finite <br>
automata. This option is mostly for use in maintaining
flex.</p>

<p style="margin-top: 1em">-V prints the version number to
stdout and exits. --version is a synonym for -V.</p>

<p style="margin-top: 1em">-7 instructs flex to generate a
7-bit scanner, i.e., one which can only recognized 7-bit
characters in its input. The advantage of using -7 is that
the scanner&rsquo;s tables can <br>
be up to half the size of those generated using the -8
option (see below). The disadvantage is that such scanners
often hang or crash if their input contains an 8-bit <br>
character.</p>

<p style="margin-top: 1em">Note, however, that unless you
generate your scanner using the -Cf or -CF table compression
options, use of -7 will save only a small amount of table
space, and make your <br>
scanner considerably less portable. Flex&rsquo;s default
behavior is to generate an 8-bit scanner unless you use the
-Cf or -CF, in which case flex defaults to generating 7-bit
<br>
scanners unless your site was always configured to generate
8-bit scanners (as will often be the case with non-USA
sites). You can tell whether flex generated a 7-bit or <br>
an 8-bit scanner by inspecting the flag summary in the -v
output as described above.</p>

<p style="margin-top: 1em">Note that if you use -Cfe or
-CFe (those table compression options, but also using
equivalence classes as discussed see below), flex still
defaults to generating an 8-bit <br>
scanner, since usually with these compression options full
8-bit tables are not much more expensive than 7-bit
tables.</p>

<p style="margin-top: 1em">-8 instructs flex to generate an
8-bit scanner, i.e., one which can recognize 8-bit
characters. This flag is only needed for scanners generated
using -Cf or -CF, as other&acirc; <br>
wise flex defaults to generating an 8-bit scanner
anyway.</p>

<p style="margin-top: 1em">See the discussion of -7 above
for flex&rsquo;s default behavior and the tradeoffs between
7-bit and 8-bit scanners.</p>

<p style="margin-top: 1em">-+ specifies that you want flex
to generate a C++ scanner class. See the section on
Generating C++ Scanners below for details.</p>

<p style="margin-top: 1em">-C[aefFmr] <br>
controls the degree of table compression and, more
generally, trade-offs between small scanners and fast
scanners.</p>

<p style="margin-top: 1em">-Ca (&quot;align&quot;)
instructs flex to trade off larger tables in the generated
scanner for faster performance because the elements of the
tables are better aligned for memory <br>
access and computation. On some RISC architectures, fetching
and manipulating longwords is more efficient than with
smaller-sized units such as shortwords. This option <br>
can double the size of the tables used by your scanner.</p>

<p style="margin-top: 1em">-Ce directs flex to construct
equivalence classes, i.e., sets of characters which have
identical lexical properties (for example, if the only
appearance of digits in the <br>
flex input is in the character class &quot;[0-9]&quot; then
the digits &rsquo;0&rsquo;, &rsquo;1&rsquo;, ...,
&rsquo;9&rsquo; will all be put in the same equivalence
class). Equivalence classes usually give dramatic <br>
reductions in the final table/object file sizes (typically a
factor of 2-5) and are pretty cheap performance-wise (one
array look-up per character scanned).</p>

<p style="margin-top: 1em">-Cf specifies that the full
scanner tables should be generated - flex should not
compress the tables by taking advantages of similar
transition functions for different <br>
states.</p>

<p style="margin-top: 1em">-CF specifies that the alternate
fast scanner representation (described above under the -F
flag) should be used. This option cannot be used with
-+.</p>

<p style="margin-top: 1em">-Cm directs flex to construct
meta-equivalence classes, which are sets of equivalence
classes (or characters, if equivalence classes are not being
used) that are commonly <br>
used together. Meta-equivalence classes are often a big win
when using compressed tables, but they have a moderate
performance impact (one or two &quot;if&quot; tests and one
array <br>
look-up per character scanned).</p>

<p style="margin-top: 1em">-Cr causes the generated scanner
to bypass use of the standard I/O library (stdio) for input.
Instead of calling fread() or getc(), the scanner will use
the read() system <br>
call, resulting in a performance gain which varies from
system to system, but in general is probably negligible
unless you are also using -Cf or -CF. Using -Cr can cause
<br>
strange behavior if, for example, you read from yyin using
stdio prior to calling the scanner (because the scanner will
miss whatever text your previous reads left in the <br>
stdio input buffer).</p>

<p style="margin-top: 1em">-Cr has no effect if you define
YY_INPUT (see The Generated Scanner above).</p>

<p style="margin-top: 1em">A lone -C specifies that the
scanner tables should be compressed but neither equivalence
classes nor meta-equivalence classes should be used.</p>

<p style="margin-top: 1em">The options -Cf or -CF and -Cm
do not make sense together - there is no opportunity for
meta-equivalence classes if the table is not being
compressed. Otherwise the <br>
options may be freely mixed, and are cumulative.</p>

<p style="margin-top: 1em">The default setting is -Cem,
which specifies that flex should generate equivalence
classes and meta-equivalence classes. This setting provides
the highest degree of table <br>
compression. You can trade off faster-executing scanners at
the cost of larger tables with the following generally being
true:</p>

<p style="margin-top: 1em">slowest &amp; smallest <br>
-Cem <br>
-Cm <br>
-Ce <br>
-C <br>
-C{f,F}e <br>
-C{f,F} <br>
-C{f,F}a <br>
fastest &amp; largest</p>

<p style="margin-top: 1em">Note that scanners with the
smallest tables are usually generated and compiled the
quickest, so during development you will usually want to use
the default, maximal com&acirc; <br>
pression.</p>

<p style="margin-top: 1em">-Cfe is often a good compromise
between speed and size for production scanners.</p>

<p style="margin-top: 1em">-ooutput <br>
directs flex to write the scanner to the file output instead
of lex.yy.c. If you combine -o with the -t option, then the
scanner is written to stdout but its #line direc&acirc; <br>
tives (see the -L option above) refer to the file
output.</p>

<p style="margin-top: 1em">-Pprefix <br>
changes the default yy prefix used by flex for all
globally-visible variable and function names to instead be
prefix. For example, -Pfoo changes the name of yytext to
<br>
footext. It also changes the name of the default output file
from lex.yy.c to lex.foo.c. Here are all of the names
affected:</p>

<p style="margin-top: 1em">yy_create_buffer <br>
yy_delete_buffer <br>
yy_flex_debug <br>
yy_init_buffer <br>
yy_flush_buffer <br>
yy_load_buffer_state <br>
yy_switch_to_buffer <br>
yyin <br>
yyleng <br>
yylex <br>
yylineno <br>
yyout <br>
yyrestart <br>
yytext <br>
yywrap</p>

<p style="margin-top: 1em">(If you are using a C++ scanner,
then only yywrap and yyFlexLexer are affected.) Within your
scanner itself, you can still refer to the global variables
and functions <br>
using either version of their name; but externally, they
have the modified name.</p>

<p style="margin-top: 1em">This option lets you easily link
together multiple flex programs into the same executable.
Note, though, that using this option also renames yywrap(),
so you now must <br>
either provide your own (appropriately-named) version of the
routine for your scanner, or use %option noyywrap, as
linking with -lfl no longer provides one for you by <br>
default.</p>

<p style="margin-top: 1em">-Sskeleton_file <br>
overrides the default skeleton file from which flex
constructs its scanners. You&rsquo;ll never need this option
unless you are doing flex maintenance or development.</p>

<p style="margin-top: 1em">flex also provides a mechanism
for controlling options within the scanner specification
itself, rather than from the flex command-line. This is done
by including %option direc&acirc; <br>
tives in the first section of the scanner specification. You
can specify multiple options with a single %option
directive, and multiple directives in the first section of
your <br>
flex input file.</p>

<p style="margin-top: 1em">Most options are given simply as
names, optionally preceded by the word &quot;no&quot; (with
no intervening whitespace) to negate their meaning. A number
are equivalent to flex flags or <br>
their negation:</p>

<p style="margin-top: 1em">7bit -7 option <br>
8bit -8 option <br>
align -Ca option <br>
backup -b option <br>
batch -B option <br>
c++ -+ option</p>

<p style="margin-top: 1em">caseful or <br>
case-sensitive opposite of -i (default)</p>

<p style="margin-top: 1em">case-insensitive or <br>
caseless -i option</p>

<p style="margin-top: 1em">debug -d option <br>
default opposite of -s option <br>
ecs -Ce option <br>
fast -F option <br>
full -f option <br>
interactive -I option <br>
lex-compat -l option <br>
meta-ecs -Cm option <br>
perf-report -p option <br>
read -Cr option <br>
stdout -t option <br>
verbose -v option <br>
warn opposite of -w option <br>
(use &quot;%option nowarn&quot; for -w)</p>

<p style="margin-top: 1em">array equivalent to
&quot;%array&quot; <br>
pointer equivalent to &quot;%pointer&quot; (default)</p>

<p style="margin-top: 1em">Some %option&rsquo;s provide
features otherwise not available:</p>

<p style="margin-top: 1em">always-interactive <br>
instructs flex to generate a scanner which always considers
its input &quot;interactive&quot;. Normally, on each new
input file the scanner calls isatty() in an attempt to
deter&acirc; <br>
mine whether the scanner&rsquo;s input source is interactive
and thus should be read a character at a time. When this
option is used, however, then no such call is made.</p>

<p style="margin-top: 1em">main directs flex to provide a
default main() program for the scanner, which simply calls
yylex(). This option implies noyywrap (see below).</p>

<p style="margin-top: 1em">never-interactive <br>
instructs flex to generate a scanner which never considers
its input &quot;interactive&quot; (again, no call made to
isatty()). This is the opposite of always-interactive.</p>

<p style="margin-top: 1em">stack enables the use of start
condition stacks (see Start Conditions above).</p>

<p style="margin-top: 1em">stdinit <br>
if set (i.e., %option stdinit) initializes yyin and yyout to
stdin and stdout, instead of the default of nil. Some
existing lex programs depend on this behavior, even <br>
though it is not compliant with ANSI C, which does not
require stdin and stdout to be compile-time constant.</p>

<p style="margin-top: 1em">yylineno <br>
directs flex to generate a scanner that maintains the number
of the current line read from its input in the global
variable yylineno. This option is implied by %option <br>
lex-compat.</p>

<p style="margin-top: 1em">yywrap if unset (i.e., %option
noyywrap), makes the scanner not call yywrap() upon an
end-of-file, but simply assume that there are no more files
to scan (until the user points <br>
yyin at a new file and calls yylex() again).</p>

<p style="margin-top: 1em">flex scans your rule actions to
determine whether you use the REJECT or yymore() features.
The reject and yymore options are available to override its
decision as to whether you <br>
use the options, either by setting them (e.g., %option
reject) to indicate the feature is indeed used, or unsetting
them to indicate it actually is not used (e.g., %option
noyy&acirc; <br>
more).</p>

<p style="margin-top: 1em">Three options take
string-delimited values, offset with &rsquo;=&rsquo;:</p>

<p style="margin-top: 1em">%option
outfile=&quot;ABC&quot;</p>

<p style="margin-top: 1em">is equivalent to -oABC, and</p>

<p style="margin-top: 1em">%option
prefix=&quot;XYZ&quot;</p>

<p style="margin-top: 1em">is equivalent to -PXYZ.
Finally,</p>

<p style="margin-top: 1em">%option
yyclass=&quot;foo&quot;</p>

<p style="margin-top: 1em">only applies when generating a
C++ scanner ( -+ option). It informs flex that you have
derived foo as a subclass of yyFlexLexer, so flex will place
your actions in the member <br>
function foo::yylex() instead of yyFlexLexer::yylex(). It
also generates a yyFlexLexer::yylex() member function that
emits a run-time error (by invoking
yyFlexLexer::Lexer&acirc; <br>
Error()) if called. See Generating C++ Scanners, below, for
additional information.</p>

<p style="margin-top: 1em">A number of options are
available for lint purists who want to suppress the
appearance of unneeded routines in the generated scanner.
Each of the following, if unset (e.g., <br>
%option nounput ), results in the corresponding routine not
appearing in the generated scanner:</p>

<p style="margin-top: 1em">input, unput <br>
yy_push_state, yy_pop_state, yy_top_state <br>
yy_scan_buffer, yy_scan_bytes, yy_scan_string</p>

<p style="margin-top: 1em">(though yy_push_state() and
friends won&rsquo;t appear anyway unless you use %option
stack).</p>

<p style="margin-top: 1em">PERFORMANCE CONSIDERATIONS <br>
The main design goal of flex is that it generate
high-performance scanners. It has been optimized for dealing
well with large sets of rules. Aside from the effects on
scanner <br>
speed of the table compression -C options outlined above,
there are a number of options/actions which degrade
performance. These are, from most expensive to least:</p>

<p style="margin-top: 1em">REJECT <br>
%option yylineno <br>
arbitrary trailing context</p>

<p style="margin-top: 1em">pattern sets that require
backing up <br>
%array <br>
%option interactive <br>
%option always-interactive</p>

<p style="margin-top: 1em">&rsquo;^&rsquo;
beginning-of-line operator <br>
yymore()</p>

<p style="margin-top: 1em">with the first three all being
quite expensive and the last two being quite cheap. Note
also that unput() is implemented as a routine call that
potentially does quite a bit of <br>
work, while yyless() is a quite-cheap macro; so if just
putting back some excess text you scanned, use yyless().</p>

<p style="margin-top: 1em">REJECT should be avoided at all
costs when performance is important. It is a particularly
expensive option.</p>

<p style="margin-top: 1em">Getting rid of backing up is
messy and often may be an enormous amount of work for a
complicated scanner. In principal, one begins by using the
-b flag to generate a lex.backup <br>
file. For example, on the input</p>

<p style="margin-top: 1em">%% <br>
foo return TOK_KEYWORD; <br>
foobar return TOK_KEYWORD;</p>

<p style="margin-top: 1em">the file looks like:</p>

<p style="margin-top: 1em">State #6 is non-accepting - <br>
associated rule line numbers: <br>
2 3 <br>
out-transitions: [ o ] <br>
jam-transitions: EOF [ 01-n p-177 ]</p>

<p style="margin-top: 1em">State #8 is non-accepting - <br>
associated rule line numbers: <br>
3 <br>
out-transitions: [ a ] <br>
jam-transitions: EOF [ 01-&lsquo; b-177 ]</p>

<p style="margin-top: 1em">State #9 is non-accepting - <br>
associated rule line numbers: <br>
3 <br>
out-transitions: [ r ] <br>
jam-transitions: EOF [ 01-q s-177 ]</p>

<p style="margin-top: 1em">Compressed tables always back
up.</p>

<p style="margin-top: 1em">The first few lines tell us that
there&rsquo;s a scanner state in which it can make a
transition on an &rsquo;o&rsquo; but not on any other
character, and that in that state the currently scanned <br>
text does not match any rule. The state occurs when trying
to match the rules found at lines 2 and 3 in the input file.
If the scanner is in that state and then reads something
<br>
other than an &rsquo;o&rsquo;, it will have to back up to
find a rule which is matched. With a bit of headscratching
one can see that this must be the state it&rsquo;s in when
it has seen &quot;fo&quot;. <br>
When this has happened, if anything other than another
&rsquo;o&rsquo; is seen, the scanner will have to back up to
simply match the &rsquo;f&rsquo; (by the default rule).</p>

<p style="margin-top: 1em">The comment regarding State #8
indicates there&rsquo;s a problem when &quot;foob&quot; has
been scanned. Indeed, on any character other than an
&rsquo;a&rsquo;, the scanner will have to back up to accept
<br>
&quot;foo&quot;. Similarly, the comment for State #9
concerns when &quot;fooba&quot; has been scanned and an
&rsquo;r&rsquo; does not follow.</p>

<p style="margin-top: 1em">The final comment reminds us
that there&rsquo;s no point going to all the trouble of
removing backing up from the rules unless we&rsquo;re using
-Cf or -CF, since there&rsquo;s no performance gain <br>
doing so with compressed scanners.</p>

<p style="margin-top: 1em">The way to remove the backing up
is to add &quot;error&quot; rules:</p>

<p style="margin-top: 1em">%% <br>
foo return TOK_KEYWORD; <br>
foobar return TOK_KEYWORD;</p>

<p style="margin-top: 1em">fooba | <br>
foob | <br>
fo { <br>
/* false alarm, not really a keyword */ <br>
return TOK_ID; <br>
}</p>

<p style="margin-top: 1em">Eliminating backing up among a
list of keywords can also be done using a
&quot;catch-all&quot; rule:</p>

<p style="margin-top: 1em">%% <br>
foo return TOK_KEYWORD; <br>
foobar return TOK_KEYWORD;</p>

<p style="margin-top: 1em">[a-z]+ return TOK_ID;</p>

<p style="margin-top: 1em">This is usually the best
solution when appropriate.</p>

<p style="margin-top: 1em">Backing up messages tend to
cascade. With a complicated set of rules it&rsquo;s not
uncommon to get hundreds of messages. If one can decipher
them, though, it often only takes a <br>
dozen or so rules to eliminate the backing up (though
it&rsquo;s easy to make a mistake and have an error rule
accidentally match a valid token. A possible future flex
feature will be <br>
to automatically add rules to eliminate backing up).</p>

<p style="margin-top: 1em">It&rsquo;s important to keep in
mind that you gain the benefits of eliminating backing up
only if you eliminate every instance of backing up. Leaving
just one means you gain nothing.</p>

<p style="margin-top: 1em">Variable trailing context (where
both the leading and trailing parts do not have a fixed
length) entails almost the same performance loss as REJECT
(i.e., substantial). So when <br>
possible a rule like:</p>

<p style="margin-top: 1em">%% <br>
mouse|rat/(cat|dog) run();</p>

<p style="margin-top: 1em">is better written:</p>

<p style="margin-top: 1em">%% <br>
mouse/cat|dog run(); <br>
rat/cat|dog run();</p>

<p style="margin-top: 1em">or as</p>

<p style="margin-top: 1em">%% <br>
mouse|rat/cat run(); <br>
mouse|rat/dog run();</p>

<p style="margin-top: 1em">Note that here the special
&rsquo;|&rsquo; action does not provide any savings, and can
even make things worse (see Deficiencies / Bugs below).</p>

<p style="margin-top: 1em">Another area where the user can
increase a scanner&rsquo;s performance (and one that&rsquo;s
easier to implement) arises from the fact that the longer
the tokens matched, the faster the <br>
scanner will run. This is because with long tokens the
processing of most input characters takes place in the
(short) inner scanning loop, and does not often have to go
through <br>
the additional work of setting up the scanning environment
(e.g., yytext) for the action. Recall the scanner for C
comments:</p>

<p style="margin-top: 1em">%x comment <br>
%% <br>
int line_num = 1;</p>

<p style="margin-top: 1em">&quot;/*&quot;
BEGIN(comment);</p>

<p style="margin-top: 1em">&lt;comment&gt;[^*0* <br>
&lt;comment&gt;&quot;*&quot;+[^*/0* <br>
&lt;comment&gt; ++line_num; <br>
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;
BEGIN(INITIAL);</p>

<p style="margin-top: 1em">This could be sped up by writing
it as:</p>

<p style="margin-top: 1em">%x comment <br>
%% <br>
int line_num = 1;</p>

<p style="margin-top: 1em">&quot;/*&quot;
BEGIN(comment);</p>

<p style="margin-top: 1em">&lt;comment&gt;[^*0* <br>
&lt;comment&gt;[^*0* ++line_num; <br>
&lt;comment&gt;&quot;*&quot;+[^*/0* <br>
&lt;comment&gt;&quot;*&quot;+[^*/0*++line_num; <br>
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;
BEGIN(INITIAL);</p>

<p style="margin-top: 1em">Now instead of each newline
requiring the processing of another action, recognizing the
newlines is &quot;distributed&quot; over the other rules to
keep the matched text as long as possi&acirc; <br>
ble. Note that adding rules does not slow down the scanner!
The speed of the scanner is independent of the number of
rules or (modulo the considerations given at the beginning
<br>
of this section) how complicated the rules are with regard
to operators such as &rsquo;*&rsquo; and
&rsquo;|&rsquo;.</p>

<p style="margin-top: 1em">A final example in speeding up a
scanner: suppose you want to scan through a file containing
identifiers and keywords, one per line and with no other
extraneous characters, and <br>
recognize all the keywords. A natural first approach is:</p>

<p style="margin-top: 1em">%% <br>
asm | <br>
auto | <br>
break | <br>
... etc ... <br>
volatile | <br>
while /* it&rsquo;s a keyword */</p>

<p style="margin-top: 1em">.| /* it&rsquo;s not a keyword
*/</p>

<p style="margin-top: 1em">To eliminate the back-tracking,
introduce a catch-all rule:</p>

<p style="margin-top: 1em">%% <br>
asm | <br>
auto | <br>
break | <br>
... etc ... <br>
volatile | <br>
while /* it&rsquo;s a keyword */</p>

<p style="margin-top: 1em">[a-z]+ | <br>
.| /* it&rsquo;s not a keyword */</p>

<p style="margin-top: 1em">Now, if it&rsquo;s guaranteed
that there&rsquo;s exactly one word per line, then we can
reduce the total number of matches by a half by merging in
the recognition of newlines with that of <br>
the other tokens:</p>

<p style="margin-top: 1em">%% <br>
asm | <br>
auto | <br>
break | <br>
... etc ... <br>
volatile| <br>
while /* it&rsquo;s a keyword */</p>

<p style="margin-top: 1em">[a-z]+| <br>
.| /* it&rsquo;s not a keyword */</p>

<p style="margin-top: 1em">One has to be careful here, as
we have now reintroduced backing up into the scanner. In
particular, while we know that there will never be any
characters in the input stream <br>
other than letters or newlines, flex can&rsquo;t figure this
out, and it will plan for possibly needing to back up when
it has scanned a token like &quot;auto&quot; and then the
next character <br>
is something other than a newline or a letter. Previously it
would then just match the &quot;auto&quot; rule and be done,
but now it has no &quot;auto&quot; rule, only a &quot;auto0
rule. To elimi&acirc; <br>
nate the possibility of backing up, we could either
duplicate all rules but without final newlines, or, since we
never expect to encounter such an input and therefore
don&rsquo;t how <br>
it&rsquo;s classified, we can introduce one more catch-all
rule, this one which doesn&rsquo;t include a newline:</p>

<p style="margin-top: 1em">%% <br>
asm | <br>
auto | <br>
break | <br>
... etc ... <br>
volatile| <br>
while /* it&rsquo;s a keyword */</p>

<p style="margin-top: 1em">[a-z]+| <br>
[a-z]+ | <br>
.| /* it&rsquo;s not a keyword */</p>

<p style="margin-top: 1em">Compiled with -Cf, this is about
as fast as one can get a flex scanner to go for this
particular problem.</p>

<p style="margin-top: 1em">A final note: flex is slow when
matching NUL&rsquo;s, particularly when a token contains
multiple NUL&rsquo;s. It&rsquo;s best to write rules which
match short amounts of text if it&rsquo;s anticipated <br>
that the text will often include NUL&rsquo;s.</p>

<p style="margin-top: 1em">Another final note regarding
performance: as mentioned above in the section How the Input
is Matched, dynamically resizing yytext to accommodate huge
tokens is a slow process <br>
because it presently requires that the (huge) token be
rescanned from the beginning. Thus if performance is vital,
you should attempt to match &quot;large&quot; quantities of
text but not <br>
&quot;huge&quot; quantities, where the cutoff between the
two is at about 8K characters/token.</p>

<p style="margin-top: 1em">GENERATING C++ SCANNERS <br>
flex provides two different ways to generate scanners for
use with C++. The first way is to simply compile a scanner
generated by flex using a C++ compiler instead of a C
com&acirc; <br>
piler. You should not encounter any compilations errors
(please report any you find to the email address given in
the Author section below). You can then use C++ code in your
<br>
rule actions instead of C code. Note that the default input
source for your scanner remains yyin, and default echoing is
still done to yyout. Both of these remain FILE * vari&acirc;
<br>
ables and not C++ streams.</p>

<p style="margin-top: 1em">You can also use flex to
generate a C++ scanner class, using the -+ option (or,
equivalently, %option c++), which is automatically specified
if the name of the flex executable <br>
ends in a &rsquo;+&rsquo;, such as flex++. When using this
option, flex defaults to generating the scanner to the file
lex.yy.cc instead of lex.yy.c. The generated scanner
includes the <br>
header file FlexLexer.h, which defines the interface to two
C++ classes.</p>

<p style="margin-top: 1em">The first class, FlexLexer,
provides an abstract base class defining the general scanner
class interface. It provides the following member
functions:</p>

<p style="margin-top: 1em">const char* YYText() <br>
returns the text of the most recently matched token, the
equivalent of yytext.</p>

<p style="margin-top: 1em">int YYLeng() <br>
returns the length of the most recently matched token, the
equivalent of yyleng.</p>

<p style="margin-top: 1em">int lineno() const <br>
returns the current input line number (see %option
yylineno), or 1 if %option yylineno was not used.</p>

<p style="margin-top: 1em">void set_debug( int flag ) <br>
sets the debugging flag for the scanner, equivalent to
assigning to yy_flex_debug (see the Options section above).
Note that you must build the scanner using %option <br>
debug to include debugging information in it.</p>

<p style="margin-top: 1em">int debug() const <br>
returns the current setting of the debugging flag.</p>

<p style="margin-top: 1em">Also provided are member
functions equivalent to yy_switch_to_buffer(),
yy_create_buffer() (though the first argument is an istream*
object pointer and not a FILE*), <br>
yy_flush_buffer(), yy_delete_buffer(), and yyrestart()
(again, the first argument is a istream* object
pointer).</p>

<p style="margin-top: 1em">The second class defined in
FlexLexer.h is yyFlexLexer, which is derived from FlexLexer.
It defines the following additional member functions:</p>

<p style="margin-top: 1em">yyFlexLexer( istream* arg_yyin =
0, ostream* arg_yyout = 0 ) <br>
constructs a yyFlexLexer object using the given streams for
input and output. If not specified, the streams default to
cin and cout, respectively.</p>

<p style="margin-top: 1em">virtual int yylex() <br>
performs the same role is yylex() does for ordinary flex
scanners: it scans the input stream, consuming tokens, until
a rule&rsquo;s action returns a value. If you derive a <br>
subclass S from yyFlexLexer and want to access the member
functions and variables of S inside yylex(), then you need
to use %option yyclass=&quot;S&quot; to inform flex that you
<br>
will be using that subclass instead of yyFlexLexer. In this
case, rather than generating yyFlexLexer::yylex(), flex
generates S::yylex() (and also generates a dummy <br>
yyFlexLexer::yylex() that calls yyFlexLexer::LexerError() if
called).</p>

<p style="margin-top: 1em">virtual void
switch_streams(istream* new_in = 0, <br>
ostream* new_out = 0) reassigns yyin to new_in (if non-nil)
and yyout to new_out (ditto), deleting the previous input
buffer if yyin is reassigned.</p>

<p style="margin-top: 1em">int yylex( istream* new_in,
ostream* new_out = 0 ) <br>
first switches the input streams via switch_streams( new_in,
new_out ) and then returns the value of yylex().</p>

<p style="margin-top: 1em">In addition, yyFlexLexer defines
the following protected virtual functions which you can
redefine in derived classes to tailor the scanner:</p>

<p style="margin-top: 1em">virtual int LexerInput( char*
buf, int max_size ) <br>
reads up to max_size characters into buf and returns the
number of characters read. To indicate end-of-input, return
0 characters. Note that &quot;interactive&quot; scanners
(see <br>
the -B and -I flags) define the macro YY_INTERACTIVE. If you
redefine LexerInput() and need to take different actions
depending on whether or not the scanner might be <br>
scanning an interactive input source, you can test for the
presence of this name via #ifdef.</p>

<p style="margin-top: 1em">virtual void LexerOutput( const
char* buf, int size ) <br>
writes out size characters from the buffer buf, which, while
NUL-terminated, may also contain &quot;internal&quot;
NUL&rsquo;s if the scanner&rsquo;s rules can match text with
NUL&rsquo;s in them.</p>

<p style="margin-top: 1em">virtual void LexerError( const
char* msg ) <br>
reports a fatal error message. The default version of this
function writes the message to the stream cerr and
exits.</p>

<p style="margin-top: 1em">Note that a yyFlexLexer object
contains its entire scanning state. Thus you can use such
objects to create reentrant scanners. You can instantiate
multiple instances of the <br>
same yyFlexLexer class, and you can also combine multiple
C++ scanner classes together in the same program using the
-P option discussed above.</p>

<p style="margin-top: 1em">Finally, note that the %array
feature is not available to C++ scanner classes; you must
use %pointer (the default).</p>

<p style="margin-top: 1em">Here is an example of a simple
C++ scanner:</p>

<p style="margin-top: 1em">// An example of using the flex
C++ scanner class.</p>

<p style="margin-top: 1em">%{ <br>
int mylineno = 0; <br>
%}</p>

<p style="margin-top: 1em">string</p>

<p style="margin-top: 1em">ws [ ]+</p>

<p style="margin-top: 1em">alpha [A-Za-z] <br>
dig [0-9] <br>
name ({alpha}|{dig}|({alpha}|{dig}|[_.&minus;/$])* <br>
num1 [-+]?{dig}+.?([eE][-+]?{dig}+)? <br>
num2 [-+]?{dig}*.{dig}+([eE][-+]?{dig}+)? <br>
number {num1}|{num2}</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">{ws} /* skip blanks and tabs
*/</p>

<p style="margin-top: 1em">&quot;/*&quot; { <br>
int c;</p>

<p style="margin-top: 1em">while((c = yyinput()) != 0) <br>
{ <br>
if(c == &rsquo;0) <br>
++mylineno;</p>

<p style="margin-top: 1em">else if(c == &rsquo;*&rsquo;)
<br>
{ <br>
if((c = yyinput()) == &rsquo;/&rsquo;) <br>
break; <br>
else <br>
unput(c); <br>
} <br>
} <br>
}</p>

<p style="margin-top: 1em">{number} cout &lt;&lt;
&quot;number &quot; &lt;&lt; YYText() &lt;&lt; &rsquo;0;</p>

<p style="margin-top: 1em">mylineno++;</p>

<p style="margin-top: 1em">{name} cout &lt;&lt; &quot;name
&quot; &lt;&lt; YYText() &lt;&lt; &rsquo;0;</p>

<p style="margin-top: 1em">{string} cout &lt;&lt;
&quot;string &quot; &lt;&lt; YYText() &lt;&lt; &rsquo;0;</p>

<p style="margin-top: 1em">%%</p>

<p style="margin-top: 1em">int main( int /* argc */, char**
/* argv */ ) <br>
{ <br>
FlexLexer* lexer = new yyFlexLexer; <br>
while(lexer-&gt;yylex() != 0) <br>
; <br>
return 0; <br>
} <br>
If you want to create multiple (different) lexer classes,
you use the -P flag (or the prefix= option) to rename each
yyFlexLexer to some other xxFlexLexer. You then can include
<br>
&lt;FlexLexer.h&gt; in your other sources once per lexer
class, first renaming yyFlexLexer as follows:</p>

<p style="margin-top: 1em">#undef yyFlexLexer <br>
#define yyFlexLexer xxFlexLexer <br>
#include &lt;FlexLexer.h&gt;</p>

<p style="margin-top: 1em">#undef yyFlexLexer <br>
#define yyFlexLexer zzFlexLexer <br>
#include &lt;FlexLexer.h&gt;</p>

<p style="margin-top: 1em">if, for example, you used
%option prefix=&quot;xx&quot; for one of your scanners and
%option prefix=&quot;zz&quot; for the other.</p>

<p style="margin-top: 1em">IMPORTANT: the present form of
the scanning class is experimental and may change
considerably between major releases.</p>

<p style="margin-top: 1em">INCOMPATIBILITIES WITH LEX AND
POSIX <br>
flex is a rewrite of the AT&amp;T Unix lex tool (the two
implementations do not share any code, though), with some
extensions and incompatibilities, both of which are of
concern to <br>
those who wish to write scanners acceptable to either
implementation. Flex is fully compliant with the POSIX lex
specification, except that when using %pointer (the
default), a <br>
call to unput() destroys the contents of yytext, which is
counter to the POSIX specification.</p>

<p style="margin-top: 1em">In this section we discuss all
of the known areas of incompatibility between flex, AT&amp;T
lex, and the POSIX specification.</p>

<p style="margin-top: 1em">flex&rsquo;s -l option turns on
maximum compatibility with the original AT&amp;T lex
implementation, at the cost of a major loss in the generated
scanner&rsquo;s performance. We note below <br>
which incompatibilities can be overcome using the -l
option.</p>

<p style="margin-top: 1em">flex is fully compatible with
lex with the following exceptions:</p>

<p style="margin-top: 1em">- The undocumented lex scanner
internal variable yylineno is not supported unless -l or
%option yylineno is used.</p>

<p style="margin-top: 1em">yylineno should be maintained on
a per-buffer basis, rather than a per-scanner (single global
variable) basis.</p>

<p style="margin-top: 1em">yylineno is not part of the
POSIX specification.</p>

<p style="margin-top: 1em">- The input() routine is not
redefinable, though it may be called to read characters
following whatever has been matched by a rule. If input()
encounters an end-of-file the <br>
normal yywrap() processing is done. A
&lsquo;&lsquo;real&rsquo;&rsquo; end-of-file is returned by
input() as EOF.</p>

<p style="margin-top: 1em">Input is instead controlled by
defining the YY_INPUT macro.</p>

<p style="margin-top: 1em">The flex restriction that
input() cannot be redefined is in accordance with the POSIX
specification, which simply does not specify any way of
controlling the scanner&rsquo;s <br>
input other than by making an initial assignment to
yyin.</p>

<p style="margin-top: 1em">- The unput() routine is not
redefinable. This restriction is in accordance with
POSIX.</p>

<p style="margin-top: 1em">- flex scanners are not as
reentrant as lex scanners. In particular, if you have an
interactive scanner and an interrupt handler which
long-jumps out of the scanner, and <br>
the scanner is subsequently called again, you may get the
following message:</p>

<p style="margin-top: 1em">fatal flex scanner internal
error--end of buffer missed</p>

<p style="margin-top: 1em">To reenter the scanner, first
use</p>

<p style="margin-top: 1em">yyrestart( yyin );</p>

<p style="margin-top: 1em">Note that this call will throw
away any buffered input; usually this isn&rsquo;t a problem
with an interactive scanner.</p>

<p style="margin-top: 1em">Also note that flex C++ scanner
classes are reentrant, so if using C++ is an option for you,
you should use them instead. See &quot;Generating C++
Scanners&quot; above for details.</p>

<p style="margin-top: 1em">- output() is not supported.
Output from the ECHO macro is done to the file-pointer yyout
(default stdout).</p>

<p style="margin-top: 1em">output() is not part of the
POSIX specification.</p>

<p style="margin-top: 1em">- lex does not support exclusive
start conditions (%x), though they are in the POSIX
specification.</p>

<p style="margin-top: 1em">- When definitions are expanded,
flex encloses them in parentheses. With lex, the
following:</p>

<p style="margin-top: 1em">NAME [A-Z][A-Z0-9]* <br>
%% <br>
foo{NAME}? printf( &quot;Found it0 ); <br>
%%</p>

<p style="margin-top: 1em">will not match the string
&quot;foo&quot; because when the macro is expanded the rule
is equivalent to &quot;foo[A-Z][A-Z0-9]*?&quot; and the
precedence is such that the &rsquo;?&rsquo; is associated
<br>
with &quot;[A-Z0-9]*&quot;. With flex, the rule will be
expanded to &quot;foo([A-Z][A-Z0-9]*)?&quot; and so the
string &quot;foo&quot; will match.</p>

<p style="margin-top: 1em">Note that if the definition
begins with ^ or ends with $ then it is not expanded with
parentheses, to allow these operators to appear in
definitions without losing their <br>
special meanings. But the &lt;s&gt;, /, and
&lt;&lt;EOF&gt;&gt; operators cannot be used in a flex
definition.</p>

<p style="margin-top: 1em">Using -l results in the lex
behavior of no parentheses around the definition.</p>

<p style="margin-top: 1em">The POSIX specification is that
the definition be enclosed in parentheses.</p>

<p style="margin-top: 1em">- Some implementations of lex
allow a rule&rsquo;s action to begin on a separate line, if
the rule&rsquo;s pattern has trailing whitespace:</p>

<p style="margin-top: 1em">%% <br>
foo|bar&lt;space here&gt; <br>
{ foobar_action(); }</p>

<p style="margin-top: 1em">flex does not support this
feature.</p>

<p style="margin-top: 1em">- The lex %r (generate a Ratfor
scanner) option is not supported. It is not part of the
POSIX specification.</p>

<p style="margin-top: 1em">- After a call to unput(),
yytext is undefined until the next token is matched, unless
the scanner was built using %array. This is not the case
with lex or the POSIX speci&acirc; <br>
fication. The -l option does away with this
incompatibility.</p>

<p style="margin-top: 1em">- The precedence of the {}
(numeric range) operator is different. lex interprets
&quot;abc{1,3}&quot; as &quot;match one, two, or three
occurrences of &rsquo;abc&rsquo;&quot;, whereas flex
interprets it <br>
as &quot;match &rsquo;ab&rsquo; followed by one, two, or
three occurrences of &rsquo;c&rsquo;&quot;. The latter is in
agreement with the POSIX specification.</p>

<p style="margin-top: 1em">- The precedence of the ^
operator is different. lex interprets &quot;^foo|bar&quot;
as &quot;match either &rsquo;foo&rsquo; at the beginning of
a line, or &rsquo;bar&rsquo; anywhere&quot;, whereas flex
interprets it <br>
as &quot;match either &rsquo;foo&rsquo; or &rsquo;bar&rsquo;
if they come at the beginning of a line&quot;. The latter is
in agreement with the POSIX specification.</p>

<p style="margin-top: 1em">- The special table-size
declarations such as %a supported by lex are not required by
flex scanners; flex ignores them.</p>

<p style="margin-top: 1em">- The name FLEX_SCANNER is
#define&rsquo;d so scanners may be written for use with
either flex or lex. Scanners also include
YY_FLEX_MAJOR_VERSION and YY_FLEX_MINOR_VERSION indi&acirc;
<br>
cating which version of flex generated the scanner (for
example, for the 2.5 release, these defines would be 2 and 5
respectively).</p>

<p style="margin-top: 1em">The following flex features are
not included in lex or the POSIX specification:</p>

<p style="margin-top: 1em">C++ scanners <br>
%option <br>
start condition scopes <br>
start condition stacks <br>
interactive/non-interactive scanners <br>
yy_scan_string() and friends <br>
yyterminate() <br>
yy_set_interactive() <br>
yy_set_bol() <br>
YY_AT_BOL() <br>
&lt;&lt;EOF&gt;&gt; <br>
&lt;*&gt; <br>
YY_DECL <br>
YY_START <br>
YY_USER_ACTION <br>
YY_USER_INIT <br>
#line directives <br>
%{}&rsquo;s around actions <br>
multiple actions on a line</p>

<p style="margin-top: 1em">plus almost all of the flex
flags. The last feature in the list refers to the fact that
with flex you can put multiple actions on the same line,
separated with semi-colons, <br>
while with lex, the following</p>

<p style="margin-top: 1em">foo handle_foo();
++num_foos_seen;</p>

<p style="margin-top: 1em">is (rather surprisingly)
truncated to</p>

<p style="margin-top: 1em">foo handle_foo();</p>

<p style="margin-top: 1em">flex does not truncate the
action. Actions that are not enclosed in braces are simply
terminated at the end of the line.</p>

<p style="margin-top: 1em">DIAGNOSTICS <br>
warning, rule cannot be matched indicates that the given
rule cannot be matched because it follows other rules that
will always match the same text as it. For example, in the
<br>
following &quot;foo&quot; cannot be matched because it comes
after an identifier &quot;catch-all&quot; rule:</p>

<p style="margin-top: 1em">[a-z]+ got_identifier(); <br>
foo got_foo();</p>

<p style="margin-top: 1em">Using REJECT in a scanner
suppresses this warning.</p>

<p style="margin-top: 1em">warning, -s option given but
default rule can be matched means that it is possible
(perhaps only in a particular start condition) that the
default rule (match any single charac&acirc; <br>
ter) is the only one that will match a particular input.
Since -s was given, presumably this is not intended.</p>

<p style="margin-top: 1em">reject_used_but_not_detected
undefined or yymore_used_but_not_detected undefined - These
errors can occur at compile time. They indicate that the
scanner uses REJECT or yymore() <br>
but that flex failed to notice the fact, meaning that flex
scanned the first two sections looking for occurrences of
these actions and failed to find any, but somehow you snuck
<br>
some in (via a #include file, for example). Use %option
reject or %option yymore to indicate to flex that you really
do use these features.</p>

<p style="margin-top: 1em">flex scanner jammed - a scanner
compiled with -s has encountered an input string which
wasn&rsquo;t matched by any of its rules. This error can
also occur due to internal problems.</p>

<p style="margin-top: 1em">token too large, exceeds YYLMAX
- your scanner uses %array and one of its rules matched a
string longer than the YYLMAX constant (8K bytes by
default). You can increase the <br>
value by #define&rsquo;ing YYLMAX in the definitions section
of your flex input.</p>

<p style="margin-top: 1em">scanner requires -8 flag to use
the character &rsquo;x&rsquo; - Your scanner specification
includes recognizing the 8-bit character &rsquo;x&rsquo; and
you did not specify the -8 flag, and your scanner <br>
defaulted to 7-bit because you used the -Cf or -CF table
compression options. See the discussion of the -7 flag for
details.</p>

<p style="margin-top: 1em">flex scanner push-back overflow
- you used unput() to push back so much text that the
scanner&rsquo;s buffer could not hold both the pushed-back
text and the current token in yytext. <br>
Ideally the scanner should dynamically resize the buffer in
this case, but at present it does not.</p>

<p style="margin-top: 1em">input buffer overflow,
can&rsquo;t enlarge buffer because scanner uses REJECT - the
scanner was working on matching an extremely large token and
needed to expand the input buffer. <br>
This doesn&rsquo;t work with scanners that use REJECT.</p>

<p style="margin-top: 1em">fatal flex scanner internal
error--end of buffer missed - This can occur in an scanner
which is reentered after a long-jump has jumped out (or
over) the scanner&rsquo;s activation <br>
frame. Before reentering the scanner, use:</p>

<p style="margin-top: 1em">yyrestart( yyin );</p>

<p style="margin-top: 1em">or, as noted above, switch to
using the C++ scanner class.</p>

<p style="margin-top: 1em">too many start conditions in
&lt;&gt; construct! - you listed more start conditions in a
&lt;&gt; construct than exist (so you must have listed at
least one of them twice).</p>

<p style="margin-top: 1em">FILES <br>
-lfl library with which scanners must be linked.</p>

<p style="margin-top: 1em">lex.yy.c <br>
generated scanner (called lexyy.c on some systems).</p>

<p style="margin-top: 1em">lex.yy.cc <br>
generated C++ scanner class, when using -+.</p>

<p style="margin-top: 1em">&lt;FlexLexer.h&gt; <br>
header file defining the C++ scanner base class, FlexLexer,
and its derived class, yyFlexLexer.</p>

<p style="margin-top: 1em">flex.skl <br>
skeleton scanner. This file is only used when building flex,
not when flex executes.</p>

<p style="margin-top: 1em">lex.backup <br>
backing-up information for -b flag (called lex.bck on some
systems).</p>

<p style="margin-top: 1em">DEFICIENCIES / BUGS <br>
Some trailing context patterns cannot be properly matched
and generate warning messages (&quot;dangerous trailing
context&quot;). These are patterns where the ending of the
first part of <br>
the rule matches the beginning of the second part, such as
&quot;zx*/xy*&quot;, where the &rsquo;x*&rsquo; matches the
&rsquo;x&rsquo; at the beginning of the trailing context.
(Note that the POSIX draft states <br>
that the text matched by such patterns is undefined.)</p>

<p style="margin-top: 1em">For some trailing context rules,
parts which are actually fixed-length are not recognized as
such, leading to the abovementioned performance loss. In
particular, parts using &rsquo;|&rsquo; <br>
or {n} (such as &quot;foo{3}&quot;) are always considered
variable-length.</p>

<p style="margin-top: 1em">Combining trailing context with
the special &rsquo;|&rsquo; action can result in fixed
trailing context being turned into the more expensive
variable trailing context. For example, in the <br>
following:</p>

<p style="margin-top: 1em">%% <br>
abc | <br>
xyz/def</p>

<p style="margin-top: 1em">Use of unput() invalidates
yytext and yyleng, unless the %array directive or the -l
option has been used.</p>

<p style="margin-top: 1em">Pattern-matching of NUL&rsquo;s
is substantially slower than matching other characters.</p>

<p style="margin-top: 1em">Dynamic resizing of the input
buffer is slow, as it entails rescanning all the text
matched so far by the current (generally huge) token.</p>

<p style="margin-top: 1em">Due to both buffering of input
and read-ahead, you cannot intermix calls to &lt;stdio.h&gt;
routines, such as, for example, getchar(), with flex rules
and expect it to work. Call <br>
input() instead.</p>

<p style="margin-top: 1em">The total table entries listed
by the -v flag excludes the number of table entries needed
to determine what rule has been matched. The number of
entries is equal to the number <br>
of DFA states if the scanner does not use REJECT, and
somewhat greater than the number of states if it does.</p>

<p style="margin-top: 1em">REJECT cannot be used with the
-f or -F options.</p>

<p style="margin-top: 1em">The flex internal algorithms
need documentation.</p>

<p style="margin-top: 1em">SEE ALSO <br>
lex(1), yacc(1), sed(1), awk(1).</p>

<p style="margin-top: 1em">John Levine, Tony Mason, and
Doug Brown, Lex &amp; Yacc, O&rsquo;Reilly and Associates.
Be sure to get the 2nd edition.</p>

<p style="margin-top: 1em">M. E. Lesk and E. Schmidt, LEX -
Lexical Analyzer Generator</p>

<p style="margin-top: 1em">Alfred Aho, Ravi Sethi and
Jeffrey Ullman, Compilers: Principles, Techniques and Tools,
Addison-Wesley (1986). Describes the pattern-matching
techniques used by flex (determin&acirc; <br>
istic finite automata).</p>

<p style="margin-top: 1em">AUTHOR <br>
Vern Paxson, with the help of many ideas and much
inspiration from Van Jacobson. Original version by Jef
Poskanzer. The fast table representation is a partial
implementation of <br>
a design done by Van Jacobson. The implementation was done
by Kevin Gong and Vern Paxson.</p>

<p style="margin-top: 1em">Thanks to the many flex
beta-testers, feedbackers, and contributors, especially
Francois Pinard, Casey Leedom, Robert Abramovitz, Stan
Adermann, Terry Allen, David Barker-Plum&acirc; <br>
mer, John Basrai, Neal Becker, Nelson H.F. Beebe,
benson@odi.com, Karl Berry, Peter A. Bigot, Simon Blanchard,
Keith Bostic, Frederic Brehm, Ian Brockbank, Kin Cho, Nick
Christo&acirc; <br>
pher, Brian Clapper, J.T. Conklin, Jason Coughlin, Bill Cox,
Nick Cropper, Dave Curtis, Scott David Daniels, Chris G.
Demetriou, Theo Deraadt, Mike Donahue, Chuck Doucette, Tom
<br>
Epperly, Leo Eskin, Chris Faylor, Chris Flatters, Jon
Forrest, Jeffrey Friedl, Joe Gayda, Kaveh R. Ghazi, Wolfgang
Glunz, Eric Goldman, Christopher M. Gould, Ulrich Grepel,
Peer <br>
Griebel, Jan Hajic, Charles Hemphill, NORO Hideo, Jarkko
Hietaniemi, Scott Hofmann, Jeff Honig, Dana Hudes, Eric
Hughes, John Interrante, Ceriel Jacobs, Michal Jaegermann,
Sakari <br>
Jalovaara, Jeffrey R. Jones, Henry Juengst, Klaus Kaempf,
Jonathan I. Kamens, Terrence O Kane, Amir Katz,
ken@ken.hilco.com, Kevin B. Kenny, Steve Kirsch, Winfried
Koenig, Marq <br>
Kole, Ronald Lamprecht, Greg Lee, Rohan Lenard, Craig Leres,
John Levine, Steve Liddle, David Loffredo, Mike Long,
Mohamed el Lozy, Brian Madsen, Malte, Joe Marshall, Bengt
<br>
Martensson, Chris Metcalf, Luke Mewburn, Jim Meyering, R.
Alexander Milowski, Erik Naggum, G.T. Nicol, Landon Noll,
James Nordby, Marc Nozell, Richard Ohnemus, Karsten Pahnke,
<br>
Sven Panne, Roland Pesch, Walter Pelissero, Gaumond Pierre,
Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha,
Frederic Raimbault, Pat Rankin, Rick Richardson, Kevin
Rodgers, <br>
Kai Uwe Rommel, Jim Roskind, Alberto Santini, Andreas
Scherer, Darrell Schiebel, Raf Schietekat, Doug Schmidt,
Philippe Schnoebelen, Andreas Schwab, Larry Schwimmer, Alex
Siegel, <br>
Eckehard Stolz, Jan-Erik Strvmquist, Mike Stump, Paul
Stuart, Dave Tallman, Ian Lance Taylor, Chris Thewalt,
Richard M. Timoney, Jodi Tsai, Paul Tuinenga, Gary Weik,
Frank Wha&acirc; <br>
ley, Gerhard Wilhelms, Kent Williams, Ken Yap, Ron Zellar,
Nathan Zelle, David Zuhn, and those whose names have slipped
my marginal mail-archiving skills but whose contributions
<br>
are appreciated all the same.</p>

<p style="margin-top: 1em">Thanks to Keith Bostic, Jon
Forrest, Noah Friedman, John Gilmore, Craig Leres, John
Levine, Bob Mulcahy, G.T. Nicol, Francois Pinard, Rich Salz,
and Richard Stallman for help <br>
with various distribution headaches.</p>

<p style="margin-top: 1em">Thanks to Esmond Pitt and Earle
Horton for 8-bit character support; to Benson Margulies and
Fred Burke for C++ support; to Kent Williams and Tom Epperly
for C++ class support; to <br>
Ove Ewerlid for support of NUL&rsquo;s; and to Eric Hughes
for support of multiple buffers.</p>

<p style="margin-top: 1em">This work was primarily done
when I was with the Real Time Systems Group at the Lawrence
Berkeley Laboratory in Berkeley, CA. Many thanks to all
there for the support I <br>
received.</p>

<p style="margin-top: 1em">Send comments to
vern@ee.lbl.gov.</p>

<p style="margin-top: 1em">Version 2.5 April 1995
FLEX(1)</p>
<hr>
</body>
</html>
