<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:39:45 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>tack(1M) tack(1M)</p>

<p style="margin-top: 1em">NAME <br>
tack - terminfo action checker</p>

<p style="margin-top: 1em">SYNOPSIS <br>
tack [-itV] [term]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The tack program has three purposes: (1) to help you build a
new terminfo entry describing an unknown terminal, (2) to
test the correctness of an existing entry, and (3) to <br>
develop the correct pad timings needed to ensure that screen
updates don&rsquo;t fall behind the incoming data
stream.</p>

<p style="margin-top: 1em">Tack presents a series of
screen-painting and interactive tests in ways which are
intended to make any mismatches between the terminfo entry
and reality visually obvious. Tack <br>
also provides tools that can help in understanding how the
terminal operates.</p>

<p style="margin-top: 1em">OPTIONS <br>
-i Usually tack will send the reset and init strings to the
terminal when the program starts up. The -i option will
inhibit the terminal initialization.</p>

<p style="margin-top: 1em">-t Tell tack to override the
terminfo settings for basic terminal functions. When this
option is set tack will, (cud1) to 0 (ind) to 0 (nel) to
translate (cr) to ( b e l <br>
0 (cub1) to ) (ff) to and (ht) to . t o 0 7</p>

<p style="margin-top: 1em">-V Display the version
information and exit.</p>

<p style="margin-top: 1em">term Terminfo terminal name to
be tested. If not present then the $TERM environment
variable will be used.</p>

<p style="margin-top: 1em">OVERVIEW <br>
Since tack is designed to test terminfo&rsquo;s it is not
possible to rely on the correctness of the terminfo data
base. Because of this the menuing system used with tack is
vary <br>
primitive. When a menu is printed it will scroll the entire
screen. To compensate for this verbose menu system tack
permits menu selection type ahead. If you already know what
<br>
action you would like tack to perform then you can enter
that value immediately and avoid the menu display. When in
doubt the question mark (?) is a good character to type. A
<br>
carriage return will execute the default action. These
default actions are designed to run all the standard
tests.</p>

<p style="margin-top: 1em">When tack first comes up it will
display some basic information about the terminal. Take some
time to verify this information. If it is wrong many of the
subsequent tests will <br>
fail. The most important item is the screen size. If the
screen size is wrong there is no point in proceeding. (home)
and (clear) are also critical to the success of subse&acirc;
<br>
quent tests. The values of (cr) (ind) (cub1) and (ht) may
effect the tests if they are defined incorrectly. If they
are undefined tack will set them to reasonable defaults.
<br>
The last two entries on the display are the enquire and
acknowledge strings. These strings are taken from the user
strings (u9) and (u8).</p>

<p style="margin-top: 1em">By now you must be wondering why
the terminfo names are enclosed in parenthesis. This has no
profound meaning other than it makes them stand out. The
tack program uses this <br>
convention any time it displays a terminfo name. Remember
tack is designed to rely on as little of the terminfo entry
as possible.</p>

<p style="margin-top: 1em">CREATING NEW ENTRIES <br>
Tack has a number of tools that are designed to help gather
information about the terminal. Although these functions are
not dependent on terminal type, you may wish to execute <br>
tack with options -it. This will turn off initialization and
default the standard entries.</p>

<p style="margin-top: 1em">These tools may be reached from
the main menu by selecting the &rsquo;tools&rsquo;
entry.</p>

<p style="margin-top: 1em">Echo tool: All data typed from
the keyboard will be echoed back to the terminal. Control
characters are not translated to the up arrow format but are
sent as control charac&acirc; <br>
ters. This allows you to test an escape sequence and see
what it actually does. You may also elect to enable hex
output on echo tool this will echo the characters in
hexadeci&acirc; <br>
mal. Once the test is running you may enter the
&rsquo;lines&rsquo; or &rsquo;columns&rsquo; keywords which
will display a pattern that will help you determine your
screen size. A complete list of <br>
keywords will be displayed when the test starts. Type
&rsquo;help&rsquo; to redisplay the list of available
commands.</p>

<p style="margin-top: 1em">Reply tool: This tool acts much
like the echo tool, but control characters that are sent
from the terminal more than one character after a carriage
return will be expanded to <br>
the up arrow format. For example on a standard ANSI terminal
you may type:</p>

<p style="margin-top: 1em">CR ESC [ c</p>

<p style="margin-top: 1em">and the response will be echoed
as something like:</p>

<p style="margin-top: 1em">^[ [ ? 6 c</p>

<p style="margin-top: 1em">ANSI sgr display: This test
assumes you have an ANSI terminal. It goes through attribute
numbers 0 to 79, displaying each in turn and using that SGR
number to write the text. <br>
This shows you which of the SGR modes are actually
implemented by the terminal. Note: some terminals (such as
Tektronix color) use the private use characters to augment
the <br>
functionality of the SGR command. These private use
characters may be interjected into the escape sequence by
typing the character ( &lt;, =, &gt;, ? ) after the original
display has <br>
been shown.</p>

<p style="margin-top: 1em">ANSI status reports: This test
queries the terminal in standard ANSI/VT-100 fashion. The
results of this test may help determine what options are
supported by your terminal.</p>

<p style="margin-top: 1em">ANSI character sets: This test
displays the character sets available on a ANSI/VT-100 style
terminal. Character sets on a real VT-100 terminal are
usually defined with <br>
smacs=and rmacs= The first character after the escape
defines the font bank. The second character defines the
character set. This test allows you to view any of the <br>
possible combinations. Private use character sets are
defined by the digits. Standard character sets are located
in the alphabetic range.</p>

<p style="margin-top: 1em">VERIFYING AN EXISTING ENTRY <br>
You can verify the correctness of an entry with the
&lsquo;begin testing&rsquo; function. This entry is the
default action and will be chosen if you hit carriage return
(or enter). This <br>
will bring up a secondary menu that allows you to select
more specific tests.</p>

<p style="margin-top: 1em">The general philosophy of the
program is, for each capability, to send an appropriate test
pattern to the terminal then send a description of what the
user should expect. Occa&acirc; <br>
sionally (as when checking function-key capabilities) the
program will ask you to enter input for it to check.</p>

<p style="margin-top: 1em">If the test fails then you have
the option of dynamically changing the terminfo entry and
re-running the test. This is done with the &rsquo;edit
terminfo&rsquo; menu item. The edit submenu <br>
allows you to change the offending terminfo entry and
immediately retest the capability. The edit menu lets you do
other things with the terminfo, such as; display the entire
<br>
terminfo entry, display which caps have been tested and
display which caps cannot be tested. This menu also allows
you to write the newly modified terminfo to disc. If you
have <br>
made any modifications to the terminfo tack will ask you if
you want to save the file to disc before it exits. The
filename will be the same as the terminal name. After the
<br>
program exits you can run the tic(1M) compiler on the new
terminfo to install it in the terminfo data base.</p>

<p style="margin-top: 1em">CORRECTING PAD TIMINGS <br>
Theory of Overruns and Padding <br>
Some terminals require significant amounts of time (that is,
more than one transmitted-character interval) to do screen
updates that change large portions of the screen, such as
<br>
screen clears, line insertions, line deletions, and scrolls
(including scrolls triggered by line feeds or a write to the
lowest, right-hand-most cell of the screen).</p>

<p style="margin-top: 1em">If the computer continues to
send characters to the terminal while one of these
time-consuming operations is going on, the screen may be
garbled. Since the length of a character <br>
transmission time varies inversely with transmission speed
in cps, entries which function at lower speeds may break at
higher speeds.</p>

<p style="margin-top: 1em">Similar problems result if the
host machine is simply sending characters at a sustained
rate faster than the terminal can buffer and process them.
In either case, when the ter&acirc; <br>
minal cannot process them and can&rsquo;t tell the host to
stop soon enough, it will just drop them. The dropped
characters could be text, escape sequences or the escape
character <br>
itself, causing some really strange-looking displays. This
kind of glitch is called an overrun.</p>

<p style="margin-top: 1em">In terminfo entries, you can
attach a pad time to each string capability that is a number
of milliseconds to delay after sending it. This will give
the terminal time to catch up <br>
and avoid overruns.</p>

<p style="margin-top: 1em">If you are running a software
terminal emulator, or you are on an X pseudo-tty, or your
terminal is on an RS-232C line which correctly handles
RTS/CTS hardware flow control, then <br>
pads are not strictly necessary. However, some display
packages (such as ncurses(3X)) use the pad counts to
calculate the fastest way to implement certain functions.
For exam&acirc; <br>
ple: scrolling the screen may be faster than deleting the
top line.</p>

<p style="margin-top: 1em">One common way to avoid overruns
is with XON/XOFF handshaking. But even this handshake may
have problems at high baud rates. This is a result of the
way XON/XOFF works. The <br>
terminal tells the host to stop with an XOFF. When the host
gets this character, it stops sending. However, there is a
small amount of time between the stop request and the <br>
actual stop. During this window, the terminal must continue
to accept characters even though it has told the host to
stop. If the terminal sends the stop request too late, then
<br>
its internal buffer will overflow. If it sends the stop
character too early, then the terminal is not getting the
most efficient use out of its internal buffers. In a real
<br>
application at high baud rates, a terminal could get a dozen
or more characters before the host gets around to suspending
transmission. Connecting the terminal over a network <br>
will make the problem much worse.</p>

<p style="margin-top: 1em">(RTS/CTS handshaking does not
have this problem because the UARTs are signal-connected and
the &quot;stop flow&quot; is done at the lowest level,
without software intervention).</p>

<p style="margin-top: 1em">Timing your terminal <br>
In order to get accurate timings from your terminal tack
needs to know when the terminal has finished processing all
the characters that were sent. This requires a different
<br>
type of handshaking than the XON/XOFF that is supported by
most terminals. Tack needs to send a request to the terminal
and wait for its reply. Many terminals will respond with
<br>
an ACK when they receive an ENQ. This is the preferred
method since the sequence is short. ANSI/VT-100 style
terminals can mimic this handshake with the escape sequence
that <br>
requests &rsquo;primary device attributes&rsquo;.</p>

<p style="margin-top: 1em">ESC [ c</p>

<p style="margin-top: 1em">The terminal will respond with a
sequence like:</p>

<p style="margin-top: 1em">ESC [ ? 1 ; 0 c</p>

<p style="margin-top: 1em">Tack assumes that (u9) is the
enquire sequence and that (u8) is the acknowledge string. A
VT-100 style terminal could set u9= two categories. 1)
Strings with a unique terminating character and, 2) strings
of fixed length. The acknowledge string for the VT-100 is of
the first type since it always ends <br>
with the letter &rsquo;c&rsquo;. Some Tektronics terminals
have fixed length acknowledge strings. Tack supports both
types of strings by scanning for the terminating character
until the <br>
length of the expected acknowledge string has arrived. (u8)
should be set to some typical acknowledge that will be
returned when (u9) is sent.</p>

<p style="margin-top: 1em">Tack will test this sequence
before running any of the pad tests or the function key
tests. Tack will ask you the following:</p>

<p style="margin-top: 1em">Hit lower case g to start
testing...</p>

<p style="margin-top: 1em">After it sends this message it
will send the enquire string. It will then read characters
from the terminal until it sees the letter g.</p>

<p style="margin-top: 1em">Testing and Repairing Pad
Timings <br>
The pad timings in distributed terminfo entries are often
incorrect. One major motivation for this program is to make
it relatively easy to tune these timings.</p>

<p style="margin-top: 1em">You can verify and edit the pad
timings for a terminal with the &lsquo;test string
capabilities&rsquo; function (this is also part of the
&lsquo;normal test sequence&rsquo; function).</p>

<p style="margin-top: 1em">The key to determining pad times
is to find out the effective baud rate of the terminal. The
effective baud rate determines the number of characters per
second that the terminal <br>
can accept without either handshaking or losing data. This
rate is frequently less than the nominal cps rate on the
RS-232 line.</p>

<p style="margin-top: 1em">Tack uses the effective baud
rate to judge the duration of the test and how much a
particular escape sequence will perturb the terminal.</p>

<p style="margin-top: 1em">Each pad test has two associated
variables that can be tweaked to help verify the correctness
of the pad timings. One is the pad test length. The other is
the pad multiplier, <br>
which is used if the pad prefix includes &lsquo;*&rsquo;. In
curses use, it is often the first parameter of the
capability (if there is one). For a capability like (dch) or
(il) this will <br>
be the number of character positions or lines affected,
respectively.</p>

<p style="margin-top: 1em">Tack will run the pad tests and
display the results to the terminal. On capabilities that
have multipliers tack will not tell you if the pad needs the
multiplier or not. You <br>
must make this decision yourself by rerunning the test with
a different multiplier. If the padding changes in proportion
to the multiplier than the multiplier is required. If <br>
the multiplier has little or no effect on the suggested
padding then the multiplier is not needed. Some capabilities
will take several runs to get a good feel for the correct
<br>
values. You may wish to make the test longer to get more
accurate results. System load will also effect the results
(a heavily loaded system will not stress the terminal as
<br>
much, possibly leading to pad timings that are too
short).</p>

<p style="margin-top: 1em">NOTE <br>
The tests done at the beginning of the program are assumed
to be correct later in the code. In particular, tack
displays the number of lines and columns indicated in the
ter&acirc; <br>
minfo entry as part of its initial output. If these values
are wrong a large number of tests will fail or give
incorrect results.</p>

<p style="margin-top: 1em">FILES <br>
tack.log If logging is enabled then all characters written
to the terminal will also be written to the log file. This
gives you the ability to see how the tests were per&acirc;
<br>
formed. This feature is disabled by default.</p>

<p style="margin-top: 1em">term If you make changes to the
terminfo entry tack will save the new terminfo to a file.
The file will have the same name as the terminal name.</p>

<p style="margin-top: 1em">SEE ALSO <br>
terminfo(5), ncurses(3X), tic(1M), infocmp(1M). You should
also have the documentation supplied by the terminal
manufacturer.</p>

<p style="margin-top: 1em">BUGS <br>
If the screen size is incorrect, many of the tests will
fail.</p>

<p style="margin-top: 1em">AUTHOR <br>
Concept, design, and original implementation by Daniel
Weaver &lt;dan.weaver@znyx.com&gt;. Portions of the code and
documentation are by Eric S. Raymond
&lt;esr@snark.thyrsus.com&gt;.</p>
 
<p style="margin-top: 1em">tack(1M)</p>
<hr>
</body>
</html>
