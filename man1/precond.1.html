<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:33:45 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>precond(1) User Commands precond(1)</p>

<p style="margin-top: 1em">NAME <br>
precond - precondensation of tensor products</p>

<p style="margin-top: 1em">SYNOPSIS <br>
precond [OPTIONS] &lt;Info&gt; &lt;M&gt; &lt;N&gt;</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This program performs two tasks:</p>

<p style="margin-top: 1em">&Acirc;&middot; It compares the
irreducible constituents of M_H and N_H, and finds all pairs
(S_i,T_j) of constituents where S_i&acirc;T_j^*.</p>

<p style="margin-top: 1em">&Acirc;&middot; For each pair
(S,T) of constituents found in step 1, the program
calculates the embedding of (S&acirc;T)e_H into S&acirc;T as
a direct summand, and the corresponding projection of
S&acirc;T onto <br>
(S&acirc;T)e_H.</p>

<p style="margin-top: 1em">If there is no peak word for a
constituent, precond will issue a warning but continue.
However, the P and Q matrices for this constituent are
zero.</p>

<p style="margin-top: 1em">OPTIONS <br>
-Q Quiet, no messages.</p>

<p style="margin-top: 1em">-V Verbose, more messages.</p>

<p style="margin-top: 1em">-T &lt;MaxTime&gt; <br>
Set CPU time limit</p>

<p style="margin-top: 1em">IMPLEMENTATION DETAILS <br>
Step 1, matching of constituents, is implemented in the same
way as in chop(1) and cfcomp(1), i.e., by using the standard
basis with respect to identifying words. Step 2 is <br>
based on two observations:</p>

<p style="margin-top: 1em">A V&acirc;V^*&acirc;Hom_k(V,V),
and (S&acirc;T)e_H&acirc;End_kH(V) as kH-Modules.</p>

<p style="margin-top: 1em">B There is a natural,
H-invariant non-degenerate scalar product on Hom_k(V,V),
given by &Icirc;(phi,phi)=Trace(phi&acirc;phi).</p>

<p style="margin-top: 1em">From (A) it is clear that
calculating the embedding of (S&acirc;T)e_H into S&acirc;T
is equivalent to computing a basis of End_kH(V). The latter
is easily accomplished using the peak word <br>
of V. As a consequence of the second observation, there is a
natural one-to-one correspondence between H-invariant linear
forms on Hom_k(V,V) and End_kH(V), which is used to <br>
calculate the projection from Hom_k(V,V) on End_kH(V).</p>

<p style="margin-top: 1em">More details on the algorithm
used in Step 2 can be found in M. Ringe, &quot;Bemerkungen
zur Kondensation von Tensorprodukten irreduzibler
Moduln&quot;, Nov. 1998, unpublished.</p>

<p style="margin-top: 1em">INPUT FILES <br>
M.cfinfo <br>
Info file for M, produced by chop(1)/pwkond(1).</p>

<p style="margin-top: 1em">N.cfinfo <br>
Info file for N, produced by chop(1)/pwkond(1).</p>

<p style="margin-top: 1em">M&lt;Cf&gt;.std.{1,2,...} <br>
Standard generators for each constituent.</p>

<p style="margin-top: 1em">N&lt;Cf&gt;.std.{1,2,...} <br>
Standard generators for each constituent.</p>

<p style="margin-top: 1em">OUTPUT FILES <br>
Info.tki <br>
Tensor condensation info file.</p>

<p style="margin-top: 1em">Info.q.{1,2,...} <br>
Embeddings for each constituent.</p>

<p style="margin-top: 1em">Info.p.{1,2,...} <br>
Projections for each constituent.</p>

<p style="margin-top: 1em">SEE ALSO <br>
cfcomp(1), chop(1), pwkond(1)</p>

<p style="margin-top: 1em">MeatAxe 2.4.24 precond(1)</p>
<hr>
</body>
</html>
