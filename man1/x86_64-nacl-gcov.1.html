<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:43:38 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GCOV(1) GNU GCOV(1)</p>

<p style="margin-top: 1em">NAME <br>
gcov - coverage testing tool</p>

<p style="margin-top: 1em">SYNOPSIS <br>
gcov [-v|--version] [-h|--help] <br>
[-a|--all-blocks] <br>
[-b|--branch-probabilities] <br>
[-c|--branch-counts] <br>
[-n|--no-output] <br>
[-l|--long-file-names] <br>
[-p|--preserve-paths] <br>
[-f|--function-summaries] <br>
[-o|--object-directory directory|file] sourcefiles <br>
[-u|--unconditional-branches]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
gcov is a test coverage program. Use it in concert with GCC
to analyze your programs to help create more efficient,
faster running code and to discover untested parts of your
<br>
program. You can use gcov as a profiling tool to help
discover where your optimization efforts will best affect
your code. You can also use gcov along with the other
profiling <br>
tool, gprof, to assess which parts of your code use the
greatest amount of computing time.</p>

<p style="margin-top: 1em">Profiling tools help you analyze
your code&rsquo;s performance. Using a profiler such as gcov
or gprof, you can find out some basic performance
statistics, such as:</p>

<p style="margin-top: 1em">&Acirc;&middot; how often each
line of code executes</p>

<p style="margin-top: 1em">&Acirc;&middot; what lines of
code are actually executed</p>

<p style="margin-top: 1em">&Acirc;&middot; how much
computing time each section of code uses</p>

<p style="margin-top: 1em">Once you know these things about
how your code works when compiled, you can look at each
module to see which modules should be optimized. gcov helps
you determine where to work <br>
on optimization.</p>

<p style="margin-top: 1em">Software developers also use
coverage testing in concert with testsuites, to make sure
software is actually good enough for a release. Testsuites
can verify that a program works <br>
as expected; a coverage program tests to see how much of the
program is exercised by the testsuite. Developers can then
determine what kinds of test cases need to be added to <br>
the testsuites to create both better testing and a better
final product.</p>

<p style="margin-top: 1em">You should compile your code
without optimization if you plan to use gcov because the
optimization, by combining some lines of code into one
function, may not give you as much <br>
information as you need to look for &lsquo;hot spots&rsquo;
where the code is using a great deal of computer time.
Likewise, because gcov accumulates statistics by line (at
the lowest <br>
resolution), it works best with a programming style that
places only one statement on each line. If you use
complicated macros that expand to loops or to other control
<br>
structures, the statistics are less helpful---they only
report on the line where the macro call appears. If your
complex macros behave like functions, you can replace them
with <br>
inline functions to solve this problem.</p>

<p style="margin-top: 1em">gcov creates a logfile called
sourcefile.gcov which indicates how many times each line of
a source file sourcefile.c has executed. You can use these
logfiles along with gprof to <br>
aid in fine-tuning the performance of your programs. gprof
gives timing information you can use along with the
information you get from gcov.</p>

<p style="margin-top: 1em">gcov works only on code compiled
with GCC. It is not compatible with any other profiling or
test coverage mechanism.</p>

<p style="margin-top: 1em">OPTIONS <br>
-h <br>
--help <br>
Display help about using gcov (on the standard output), and
exit without doing any further processing.</p>

<p style="margin-top: 1em">-v <br>
--version <br>
Display the gcov version number (on the standard output),
and exit without doing any further processing.</p>

<p style="margin-top: 1em">-a <br>
--all-blocks <br>
Write individual execution counts for every basic block.
Normally gcov outputs execution counts only for the main
blocks of a line. With this option you can determine if <br>
blocks within a single line are not being executed.</p>

<p style="margin-top: 1em">-b <br>
--branch-probabilities <br>
Write branch frequencies to the output file, and write
branch summary info to the standard output. This option
allows you to see how often each branch in your program was
<br>
taken. Unconditional branches will not be shown, unless the
-u option is given.</p>

<p style="margin-top: 1em">-c <br>
--branch-counts <br>
Write branch frequencies as the number of branches taken,
rather than the percentage of branches taken.</p>

<p style="margin-top: 1em">-n <br>
--no-output <br>
Do not create the gcov output file.</p>

<p style="margin-top: 1em">-l <br>
--long-file-names <br>
Create long file names for included source files. For
example, if the header file x.h contains code, and was
included in the file a.c, then running gcov on the file a.c
will <br>
produce an output file called a.c##x.h.gcov instead of
x.h.gcov. This can be useful if x.h is included in multiple
source files. If you use the -p option, both the <br>
including and included file names will be complete path
names.</p>

<p style="margin-top: 1em">-p <br>
--preserve-paths <br>
Preserve complete path information in the names of generated
.gcov files. Without this option, just the filename
component is used. With this option, all directories are
<br>
used, with / characters translated to # characters, .
directory components removed and .. components renamed to ^.
This is useful if sourcefiles are in several different <br>
directories. It also affects the -l option.</p>

<p style="margin-top: 1em">-f <br>
--function-summaries <br>
Output summaries for each function in addition to the file
level summary.</p>

<p style="margin-top: 1em">-o directory|file <br>
--object-directory directory <br>
--object-file file <br>
Specify either the directory containing the gcov data files,
or the object path name. The .gcno, and .gcda data files are
searched for using this option. If a directory is <br>
specified, the data files are in that directory and named
after the source file name, without its extension. If a file
is specified here, the data files are named after that <br>
file, without its extension. If this option is not supplied,
it defaults to the current directory.</p>

<p style="margin-top: 1em">-u <br>
--unconditional-branches <br>
When branch probabilities are given, include those of
unconditional branches. Unconditional branches are normally
not interesting.</p>

<p style="margin-top: 1em">gcov should be run with the
current directory the same as that when you invoked the
compiler. Otherwise it will not be able to locate the source
files. gcov produces files <br>
called mangledname.gcov in the current directory. These
contain the coverage information of the source file they
correspond to. One .gcov file is produced for each source
file <br>
containing code, which was compiled to produce the data
files. The mangledname part of the output file name is
usually simply the source file name, but can be something
more <br>
complicated if the -l or -p options are given. Refer to
those options for details.</p>

<p style="margin-top: 1em">The .gcov files contain the :
separated fields along with program source code. The format
is</p>


<p style="margin-top: 1em">&lt;execution_count&gt;:&lt;line_number&gt;:&lt;source
line text&gt;</p>

<p style="margin-top: 1em">Additional block information may
succeed each line, when requested by command line option.
The execution_count is - for lines containing no code and
##### for lines which were <br>
never executed. Some lines of information at the start have
line_number of zero.</p>

<p style="margin-top: 1em">The preamble lines are of the
form</p>


<p style="margin-top: 1em">-:0:&lt;tag&gt;:&lt;value&gt;</p>

<p style="margin-top: 1em">The ordering and number of these
preamble lines will be augmented as gcov development
progresses --- do not rely on them remaining unchanged. Use
tag to locate a particular <br>
preamble line.</p>

<p style="margin-top: 1em">The additional block information
is of the form</p>

<p style="margin-top: 1em">&lt;tag&gt;
&lt;information&gt;</p>

<p style="margin-top: 1em">The information is human
readable, but designed to be simple enough for machine
parsing too.</p>

<p style="margin-top: 1em">When printing percentages, 0%
and 100% are only printed when the values are exactly 0% and
100% respectively. Other values which would conventionally
be rounded to 0% or 100% <br>
are instead printed as the nearest non-boundary value.</p>

<p style="margin-top: 1em">When using gcov, you must first
compile your program with two special GCC options:
-fprofile-arcs -ftest-coverage. This tells the compiler to
generate additional information <br>
needed by gcov (basically a flow graph of the program) and
also includes additional code in the object files for
generating the extra profiling information needed by gcov.
These <br>
additional files are placed in the directory where the
object file is located.</p>

<p style="margin-top: 1em">Running the program will cause
profile output to be generated. For each source file
compiled with -fprofile-arcs, an accompanying .gcda file
will be placed in the object file <br>
directory.</p>

<p style="margin-top: 1em">Running gcov with your
program&rsquo;s source file names as arguments will now
produce a listing of the code along with frequency of
execution for each line. For example, if your <br>
program is called tmp.c, this is what you see when you use
the basic gcov facility:</p>

<p style="margin-top: 1em">$ gcc -fprofile-arcs
-ftest-coverage tmp.c <br>
$ a.out <br>
$ gcov tmp.c <br>
90.00% of 10 source lines executed in file tmp.c <br>
Creating tmp.c.gcov.</p>

<p style="margin-top: 1em">The file tmp.c.gcov contains
output from gcov. Here is a sample:</p>

<p style="margin-top: 1em">-: 0:Source:tmp.c <br>
-: 0:Graph:tmp.gcno <br>
-: 0:Data:tmp.gcda <br>
-: 0:Runs:1 <br>
-: 0:Programs:1 <br>
-: 1:#include &lt;stdio.h&gt; <br>
-: 2: <br>
-: 3:int main (void) <br>
1: 4:{ <br>
1: 5: int i, total; <br>
-: 6: <br>
1: 7: total = 0; <br>
-: 8: <br>
11: 9: for (i = 0; i &lt; 10; i++) <br>
10: 10: total += i; <br>
-: 11: <br>
1: 12: if (total != 45) <br>
#####: 13: printf (&quot;Failure0); <br>
-: 14: else <br>
1: 15: printf (&quot;Success0); <br>
1: 16: return 0; <br>
-: 17:}</p>

<p style="margin-top: 1em">When you use the -a option, you
will get individual block counts, and the output looks like
this:</p>

<p style="margin-top: 1em">-: 0:Source:tmp.c <br>
-: 0:Graph:tmp.gcno <br>
-: 0:Data:tmp.gcda <br>
-: 0:Runs:1 <br>
-: 0:Programs:1 <br>
-: 1:#include &lt;stdio.h&gt; <br>
-: 2: <br>
-: 3:int main (void) <br>
1: 4:{ <br>
1: 4-block 0 <br>
1: 5: int i, total; <br>
-: 6: <br>
1: 7: total = 0; <br>
-: 8: <br>
11: 9: for (i = 0; i &lt; 10; i++) <br>
11: 9-block 0 <br>
10: 10: total += i; <br>
10: 10-block 0 <br>
-: 11: <br>
1: 12: if (total != 45) <br>
1: 12-block 0 <br>
#####: 13: printf (&quot;Failure0); <br>
$$$$$: 13-block 0 <br>
-: 14: else <br>
1: 15: printf (&quot;Success0); <br>
1: 15-block 0 <br>
1: 16: return 0; <br>
1: 16-block 0 <br>
-: 17:}</p>

<p style="margin-top: 1em">In this mode, each basic block
is only shown on one line -- the last line of the block. A
multi-line block will only contribute to the execution count
of that last line, and <br>
other lines will not be shown to contain code, unless
previous blocks end on those lines. The total execution
count of a line is shown and subsequent lines show the
execution <br>
counts for individual blocks that end on that line. After
each block, the branch and call counts of the block will be
shown, if the -b option is given.</p>

<p style="margin-top: 1em">Because of the way GCC
instruments calls, a call count can be shown after a line
with no individual blocks. As you can see, line 13 contains
a basic block that was not executed.</p>

<p style="margin-top: 1em">When you use the -b option, your
output looks like this:</p>

<p style="margin-top: 1em">$ gcov -b tmp.c <br>
90.00% of 10 source lines executed in file tmp.c <br>
80.00% of 5 branches executed in file tmp.c <br>
80.00% of 5 branches taken at least once in file tmp.c <br>
50.00% of 2 calls executed in file tmp.c <br>
Creating tmp.c.gcov.</p>

<p style="margin-top: 1em">Here is a sample of a resulting
tmp.c.gcov file:</p>

<p style="margin-top: 1em">-: 0:Source:tmp.c <br>
-: 0:Graph:tmp.gcno <br>
-: 0:Data:tmp.gcda <br>
-: 0:Runs:1 <br>
-: 0:Programs:1 <br>
-: 1:#include &lt;stdio.h&gt; <br>
-: 2: <br>
-: 3:int main (void) <br>
function main called 1 returned 1 blocks executed 75% <br>
1: 4:{ <br>
1: 5: int i, total; <br>
-: 6: <br>
1: 7: total = 0; <br>
-: 8: <br>
11: 9: for (i = 0; i &lt; 10; i++) <br>
branch 0 taken 91% (fallthrough) <br>
branch 1 taken 9% <br>
10: 10: total += i; <br>
-: 11: <br>
1: 12: if (total != 45) <br>
branch 0 taken 0% (fallthrough) <br>
branch 1 taken 100% <br>
#####: 13: printf (&quot;Failure0); <br>
call 0 never executed <br>
-: 14: else <br>
1: 15: printf (&quot;Success0); <br>
call 0 called 1 returned 100% <br>
1: 16: return 0; <br>
-: 17:}</p>

<p style="margin-top: 1em">For each function, a line is
printed showing how many times the function is called, how
many times it returns and what percentage of the
function&rsquo;s blocks were executed.</p>

<p style="margin-top: 1em">For each basic block, a line is
printed after the last line of the basic block describing
the branch or call that ends the basic block. There can be
multiple branches and calls <br>
listed for a single source line if there are multiple basic
blocks that end on that line. In this case, the branches and
calls are each given a number. There is no simple way <br>
to map these branches and calls back to source constructs.
In general, though, the lowest numbered branch or call will
correspond to the leftmost construct on the source line.</p>

<p style="margin-top: 1em">For a branch, if it was executed
at least once, then a percentage indicating the number of
times the branch was taken divided by the number of times
the branch was executed will <br>
be printed. Otherwise, the message &quot;never
executed&quot; is printed.</p>

<p style="margin-top: 1em">For a call, if it was executed
at least once, then a percentage indicating the number of
times the call returned divided by the number of times the
call was executed will be <br>
printed. This will usually be 100%, but may be less for
functions that call &quot;exit&quot; or &quot;longjmp&quot;,
and thus may not return every time they are called.</p>

<p style="margin-top: 1em">The execution counts are
cumulative. If the example program were executed again
without removing the .gcda file, the count for the number of
times each line in the source was <br>
executed would be added to the results of the previous
run(s). This is potentially useful in several ways. For
example, it could be used to accumulate data over a number
of <br>
program runs as part of a test verification suite, or to
provide more accurate long-term information over a large
number of program runs.</p>

<p style="margin-top: 1em">The data in the .gcda files is
saved immediately before the program exits. For each source
file compiled with -fprofile-arcs, the profiling code first
attempts to read in an <br>
existing .gcda file; if the file doesn&rsquo;t match the
executable (differing number of basic block counts) it will
ignore the contents of the file. It then adds in the new
execution <br>
counts and finally writes the data to the file.</p>

<p style="margin-top: 1em">Using gcov with GCC
Optimization</p>

<p style="margin-top: 1em">If you plan to use gcov to help
optimize your code, you must first compile your program with
two special GCC options: -fprofile-arcs -ftest-coverage.
Aside from that, you can <br>
use any other GCC options; but if you want to prove that
every single line in your program was executed, you should
not compile with optimization at the same time. On some <br>
machines the optimizer can eliminate some simple code lines
by combining them with other lines. For example, code like
this:</p>

<p style="margin-top: 1em">if (a != b) <br>
c = 1; <br>
else <br>
c = 0;</p>

<p style="margin-top: 1em">can be compiled into one
instruction on some machines. In this case, there is no way
for gcov to calculate separate execution counts for each
line because there isn&rsquo;t separate <br>
code for each line. Hence the gcov output looks like this if
you compiled the program with optimization:</p>

<p style="margin-top: 1em">100: 12:if (a != b) <br>
100: 13: c = 1; <br>
100: 14:else <br>
100: 15: c = 0;</p>

<p style="margin-top: 1em">The output shows that this block
of code, combined by optimization, executed 100 times. In
one sense this result is correct, because there was only one
instruction representing <br>
all four of these lines. However, the output does not
indicate how many times the result was 0 and how many times
the result was 1.</p>

<p style="margin-top: 1em">Inlineable functions can create
unexpected line counts. Line counts are shown for the source
code of the inlineable function, but what is shown depends
on where the function is <br>
inlined, or if it is not inlined at all.</p>

<p style="margin-top: 1em">If the function is not inlined,
the compiler must emit an out of line copy of the function,
in any object file that needs it. If fileA.o and fileB.o
both contain out of line <br>
bodies of a particular inlineable function, they will also
both contain coverage counts for that function. When fileA.o
and fileB.o are linked together, the linker will, on many
<br>
systems, select one of those out of line bodies for all
calls to that function, and remove or ignore the other.
Unfortunately, it will not remove the coverage counters for
the <br>
unused function body. Hence when instrumented, all but one
use of that function will show zero counts.</p>

<p style="margin-top: 1em">If the function is inlined in
several places, the block structure in each location might
not be the same. For instance, a condition might now be
calculable at compile time in <br>
some instances. Because the coverage of all the uses of the
inline function will be shown for the same source lines, the
line counts themselves might seem inconsistent.</p>

<p style="margin-top: 1em">SEE ALSO <br>
gpl(7), gfdl(7), fsf-funding(7), gcc(1) and the Info entry
for gcc.</p>

<p style="margin-top: 1em">COPYRIGHT <br>
Copyright (c) 1996, 1997, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2008 Free Software Foundation, Inc.</p>

<p style="margin-top: 1em">Permission is granted to copy,
distribute and/or modify this document under the terms of
the GNU Free Documentation License, Version 1.2 or any later
version published by the <br>
Free Software Foundation; with the Invariant Sections being
&quot;GNU General Public License&quot; and &quot;Funding
Free Software&quot;, the Front-Cover texts being (a) (see
below), and with the <br>
Back-Cover Texts being (b) (see below). A copy of the
license is included in the gfdl(7) man page.</p>

<p style="margin-top: 1em">(a) The FSF&rsquo;s Front-Cover
Text is:</p>

<p style="margin-top: 1em">A GNU Manual</p>

<p style="margin-top: 1em">(b) The FSF&rsquo;s Back-Cover
Text is:</p>

<p style="margin-top: 1em">You have freedom to copy and
modify this GNU Manual, like GNU <br>
software. Copies published by the Free Software Foundation
raise <br>
funds for GNU development.</p>

<p style="margin-top: 1em">gcc-4.4.3 2010-01-21 GCOV(1)</p>
<hr>
</body>
</html>
