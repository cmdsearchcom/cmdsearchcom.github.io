<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:19:04 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>IRSIM(1) IRSIM Users&rsquo;s Manual IRSIM(1)</p>

<p style="margin-top: 1em">NAME <br>
irsim - An event-driven logic-level simulator for MOS
circuits</p>

<p style="margin-top: 1em">SYNOPSIS <br>
irsim [-s] prm_file sim_file ... [+hist_file] [-cmd_file
...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
IRSIM is an event-driven logic-level simulator for MOS (both
N and P) transistor circuits. Two simulation models are
available:</p>

<p style="margin-top: 1em">switch Each transistor is
modeled as a voltage-controlled switch. Useful for
initializing or determining the functionality of the
network.</p>

<p style="margin-top: 1em">linear Each transistor is
modeled as a resistor in series with a voltage-controlled
switch; each node has a capacitance. Node values and
transition times are computed from the <br>
resulting RC network, using Chorng-Yeoung Chu&rsquo;s model.
Chris Terman&rsquo;s original model is not supported any
more.</p>

<p style="margin-top: 1em">If the -s switch is specified, 2
or more transistors of the same type connected in series,
with no other connections to their common source/drain will
be stacked into a compound <br>
transistor with multiple gates.</p>

<p style="margin-top: 1em">The prm_file is the electrical
parameters file that configure the devices to be simulated.
It defines the capacitance of the various layers, transistor
resistances, threshold <br>
voltages, etc... (see presim(1)). <br>
If prm_file does not specify an absolute path then IRSIM
will search for the prm_file as follows (in that order):</p>

<p style="margin-top: 1em">1) ./&lt;prm_file&gt; (in the
current directory). <br>
2) ${CAD_ROOT}/irsim/&lt;prm_file&gt; <br>
3) ${CAD_ROOT}/irsim/&lt;prm_file&gt;.prm</p>

<p style="margin-top: 1em">The default search directory
(nominally /usr/local/lib) can be overriden by setting the
environment variable CAD_ROOT to the appropriate directory
prior to running IRSIM (i.e. <br>
setenv CAD_ROOT /cad/lib).</p>

<p style="margin-top: 1em">IRSIM first processes the files
named on the command line, then (assuming the exit command
has not been processed) accepts commands from the user,
executing each command before <br>
reading the next.</p>

<p style="margin-top: 1em">File names NOT beginning with a
&rsquo;-&rsquo; are assumed to be sim files (see sim(5)),
note that this version does not require to run the sim files
through presim. These files are read <br>
and added to the network database. There is only a single
name space for nodes, so references to node &quot;A&quot; in
different network files all refer to the same node. While
this fea&acirc; <br>
ture allows one to modularize a large circuit into several
network files, care must be taken to ensure that no unwanted
node merges happen due to an unfortunate clash in names.</p>

<p style="margin-top: 1em">File names prefaced with a
&rsquo;-&rsquo; are assumed to be command files: text files
which contain command lines to be processed in the normal
fashion. These files are processed line by <br>
line; when an end-of-file is encountered, processing
continues with the next file. After all the command files
have been processed, and if an &quot;exit&quot; command has
not terminated <br>
the simulation run, IRSIM will accept further commands from
the user, prompting for each one like so:</p>

<p style="margin-top: 1em">irsim&gt;</p>

<p style="margin-top: 1em">The hist_file is the name of a
file created with the dumph command (see below). If it is
present, IRSIM will initilize the network to the state saved
in that file. This file is <br>
different from the ones created with the &quot;&gt;&quot;
command since it saves the state of every node for all
times, including any pending events.</p>

<p style="margin-top: 1em">This version supports changes to
the network through the update command. Also, the capability
to incrementally re-simulate the network up to the current
time is provided by the <br>
isim command.</p>

<p style="margin-top: 1em">COMMAND SUMMARY <br>
@ filename take commands from command file <br>
? wnode... print info about node&rsquo;s source/drain
connections <br>
! wnode... print info about node&rsquo;s gate connections
<br>
&lt; filename restore network state from file <br>
&gt; filename write current network state to file <br>
&lt;&lt; filename same as &quot;&lt;&quot; but restores
inputs too <br>
| comment... comment line <br>
activity from [to] graph circuit activity in time interval
<br>
ana wnode... display nodes in analyzer window <br>
analyzer wnode... display nodes in analyzer window <br>
assert wnode [m] val assert that wnode equals value <br>
assertWhen nodeT valT node val <br>
assert when a condition is met <br>
back [time] move back to time <br>
c [n] simulate for n clock cycles (default:1) <br>
changes from [to] print nodes that changed in time interval
<br>
clock [node [val]] define value sequence for clock node <br>
clear clear analyzer window (remove signals) <br>
d [wnode]... print display list or specified node(s) <br>
debug [debug_level...] <br>
set debug level (default: off) <br>
decay [n] set charge decay time (0 =&gt; no decay) <br>
display [arg]... control what gets displayed when <br>
dumph filename... write net history to file <br>
hist [on|off] turn history on or off <br>
exit [status] return to system <br>
flush [time] flush out history up to time (default: now)
<br>
h wnode... make node logic high (1) input <br>
has_coords print YES if transistor coordinates are available
<br>
inputs print current list of input nodes <br>
ires [n] set incremental resolution to n ns <br>
isim [filename] incrementally resimulate changes form
filename <br>
l wnode... make node logic low (0) input <br>
logfile [filename] start/stop log file <br>
model [name] set simulation model to name <br>
p step clock one simulation step (phase) <br>
path wnode... display critical path for last transition of a
node <br>
powlogfile [filename] start/stop power logfile <br>
powtrace -[node]... start/stop power tracing of specified
node(s)/vector(s) <br>
powstep toggle the display of power estimate for each
timestep <br>
print comment... print specified text <br>
printp print a list of all pending events <br>
printx print all undefined (X) nodes <br>
q terminate input from current stream <br>
R [n] simulate for n cycles (default:longest sequence) <br>
readh filename read history from filename <br>
report[level] set/reset reporting of decay events <br>
s [n] simulate for n ns. (default: stepsize) <br>
stepsize [n] set simulation step size to n ns. <br>
set vector value assign value to vector <br>
setlog[file|off] log net changes to file (off -&gt; no log)
<br>
setpath [path...] set search path for cmd files <br>
stats print event statistics <br>
sumcap print out the sum of the capacitance of all nodes
<br>
t [-]wnode... start/stop tracing of specified nodes <br>
tcap print list of shorted transistors <br>
time [command] print resource utilization summary <br>
until wnode [mask] value count <br>
delayed assert based on the clock count. <br>
u wnode... make node undefined (X) input <br>
unitdelay [n] force transitions to take n ns. (0 disables)
<br>
update filename read net changes from file <br>
V [node [value...]] define sequence of inputs for a node
<br>
vector label node... define bit vector <br>
vsupply voltage set supply voltage for calculating power
(default 5V) <br>
w [-]wnode... add/delete nodes from display list <br>
wnet [filename] write network to file <br>
x wnode... remove node from input lists <br>
Xdisplay [host:n] set/show X display (for analyzer)</p>

<p style="margin-top: 1em">COMMAND DESCRIPTIONS</p>

<p style="margin-top: 1em">Commands have the following
simple syntax:</p>

<p style="margin-top: 1em">cmd arg1 arg2 ... argn
&lt;newline&gt;</p>

<p style="margin-top: 1em">where cmd specifies the command
to be performed and the argi are arguments to that command.
The arguments are separated by spaces (or tabs) and the
command is terminated by a <br>
&lt;newline&gt;.</p>

<p style="margin-top: 1em">If cmd is not one of the
built-in commands documented below, IRSIM appends
&quot;.cmd&quot; to the command name and tries to open that
file as a command file (see &quot;@&quot; command). Thus the
<br>
command &quot;foo&quot; has the same effect as &quot;@
foo.cmd&quot;.</p>

<p style="margin-top: 1em">Notation:</p>

<p style="margin-top: 1em">... indicates zero or more
repetitions</p>

<p style="margin-top: 1em">[ ] enclosed arguments are
optional</p>

<p style="margin-top: 1em">node name of node or vector in
network</p>

<p style="margin-top: 1em">wnode name of node or vector in
network, can include &rsquo;*&rsquo; wildcard which matches
any sequence of zero or more characters. The pair of
characters &rsquo;{&rsquo; and &rsquo;}&rsquo; denote
iteration <br>
over the limits enclosed by it, for example: name{1:10} will
expand into name1, name2 ... name10. A 3rd optional argument
sets the stride, for example: name{1:10:2} will <br>
expand into name1, name3, ... name7, name9.</p>

<p style="margin-top: 1em">| comment... <br>
Lines beginning with vertical bar are treated as comments
and ignored -- useful for comments or temporarily disabling
certain commands in a command file.</p>

<p style="margin-top: 1em">Most commands take one or more
node names as arguments. Whenever a node name is acceptible
in a command line, one can also use the name of a bit
vector. In this case, the com&acirc; <br>
mand will be applied to each node of the vector (the
&quot;t&quot; and &quot;d&quot; treat vectors specially, see
below).</p>

<p style="margin-top: 1em">vector label node... <br>
Define a bit vector named &quot;label&quot; which includes
the specified nodes. If you redefine a bit vector, any
special attributes of the old vector (e.g., being on the
display <br>
or trace list) are lost. Wild cards are not accepted in the
list of node names since you would have no control over the
order in which matching nodes would appear in the <br>
vector.</p>

<p style="margin-top: 1em">The simulator performs most
commands silently. To find out what&rsquo;s happened you can
use one of the following commands to examine the state of
the network and/or the simulator.</p>

<p style="margin-top: 1em">set vector value <br>
Assign value to vector. For example, the following sequence
of commands:</p>

<p style="margin-top: 1em">vector BUS bit.1 bit.2 bit.3
<br>
set BUS 01x</p>

<p style="margin-top: 1em">The first command will define
BUS to be a vector composed of nodes bit.1, bit.2, and
bit.3. The second command will assign the following
values:</p>

<p style="margin-top: 1em">bit.1 = 0 <br>
bit.2 = 1 <br>
bit.3 = X</p>

<p style="margin-top: 1em">Value can be any sequence of
[0,1,h,H,l,L,x,X], and must be of the same length as the bit
vector itself.</p>

<p style="margin-top: 1em">d [wnode]... <br>
Display. Without arguments displays the values all nodes and
bit vectors currently on the display list (see w command).
With arguments, only displays the nodes or bit <br>
vectors specified. See also the &quot;display&quot; command
if you wish to have the display list printed out
automatically at the end of certain simulation commands.</p>

<p style="margin-top: 1em">w [-]wnode... <br>
Watch/unwatch one or more nodes. Whenever a &quot;d&quot;
command is given, each watched node will displayed like
so:</p>

<p style="margin-top: 1em">node1=0 node2=X ...</p>

<p style="margin-top: 1em">To remove a node from the
watched list, preface its name with a &rsquo;-&rsquo;. If
wnode is the name of a bit vector, the values of the nodes
which make up the vector will be dis&acirc; <br>
played as follows:</p>

<p style="margin-top: 1em">label=010100</p>

<p style="margin-top: 1em">where the first 0 is the value
of first node in the list, the first 1 the value of the
second node, etc.</p>

<p style="margin-top: 1em">assert wnode [mask] value <br>
Assert that the boolean value of the node or vector wnode is
value. If the comparison fails, an error message is printed.
If mask is given then only those bits corre&acirc; <br>
sponding to zero bits in mask take part in the comparison,
any character other than 0 will skip that bit. The format of
the error message is the following:</p>

<p style="margin-top: 1em">(tty, 3): assertion failed on
&rsquo;name&rsquo; 10X10 (1010X)</p>

<p style="margin-top: 1em">Where name is the name of the
vector, followed by the actual value and the expected value
enclosed in parenthesis. If a mask is specified, then bits
that were not com&acirc; <br>
pared are printed as &rsquo;-&rsquo;.</p>

<p style="margin-top: 1em">until wnode [mask] value count
<br>
Acts just like the assert command except it requires an
additional argument &lt;count&gt; which is the max number of
clock cycles to run. Instead of just testing the current
<br>
state, like assert, until tests for true and if false it
runs clock cycles until condition becomes true or count runs
out.</p>

<p style="margin-top: 1em">ana wnode... <br>
This is a shorthand for the analyzer command (described
below).</p>

<p style="margin-top: 1em">analyzer wnode... <br>
Add the specified node(s)/vector(s) to the analyzer display
list (see irsim-analyzer(3) for a detailed explanation). If
the analyzer window does not exist, it will be <br>
created. If no arguments are given and the analyzer window
already exists, nothing happens.</p>

<p style="margin-top: 1em">Xdisplay [host:display] <br>
You must be able to connect to an X-server to start the
analyzer. If you haven&rsquo;t set up the DISPLAY
environment variable properly, the analyzer command may
fail. If this <br>
is the case you can use the Xdisplay command to set it from
within the simulator. With no arguments, the name of the
current X-server will be printed.</p>

<p style="margin-top: 1em">clear Removes all nodes and
vectors from the analyzer window. This command is most
useful in command scripts for switching between different
signals being displayed on the ana&acirc; <br>
lyzer.</p>

<p style="margin-top: 1em">&quot;?&quot; and &quot;!&quot;
allow the user to go both backwards and forwards through the
network. This is a useful debugging aid.</p>

<p style="margin-top: 1em">? wnode... <br>
Prints a synopsis of the named nodes including their current
values and the state of all transistors that affect the
value of these nodes. This is the most common way of <br>
wandering through the network in search of what went wrong.
<br>
The output from the command ? out looks like</p>

<p style="margin-top: 1em">out=0 (vl=0.3 vh=0.8) (0.100 pf)
is computed from: <br>
n-channel phi2=0 out=0 in=0 [1.0e+04, 1.3e+04, 8.7e+03] <br>
pulled down by (a=1 b=1) [1.0e+04, 1.3e+04, 8.8e+03] <br>
pulled up [4.0e+04, 7.4e+04, 4.0e+04]</p>

<p style="margin-top: 1em">The first line gives the
node&rsquo;s name and current value, its low and high logic
thresholds, user-specifed low-to-high and high-to-low
propagation delays if present, and its <br>
capacitance if nonzero. Succeeding lines list the transistor
whose sources or drains connect to this node: the transistor
type (&quot;pulled down&quot; is an n-channel transistor
<br>
connected to gnd, &quot;pulled up&quot; is a depletion
pullup or p-channel transistor connected to vdd), the values
of the gate, source, and drain nodes, and the modeling
resis&acirc; <br>
tances. Simple chains of transistors with the same implant
type are collapsed by the -s option into a single transistor
with a &quot;compound&quot; gate; compound gates appear as a
<br>
parenthesized list of nodes (e.g., the pulldown shown
above). The three resistance values -- static, dynamic high,
dynamic low -- are given in Kilo-ohms.</p>

<p style="margin-top: 1em">Finally, any pending events for
a node are listed after the electrical information.</p>

<p style="margin-top: 1em">! wnode... <br>
For each node in the argument list, print a list of
transistors controlled by that node.</p>

<p style="margin-top: 1em">tcap <br>
Prints a list of all transistors with their source/drain
shorted together or whose source/drain are connected to the
power supplies. These transistors will have no effect <br>
on the simulation other than their gate capacitance load.
Although transistors connected across the power supplies are
real design errors, the simulator does not complain <br>
about them.</p>

<p style="margin-top: 1em">Any node can be made an input --
the simulator will not change an input node&rsquo;s value
until it is released. Usually on specific nodes -- inputs to
the circuit -- are manipulated <br>
using the commands below, but you can fool with a subcircuit
by forcing values on internal nodes just as easily.</p>

<p style="margin-top: 1em">h wnode... <br>
Force each node on the argument list to be a high (1) input.
Overrides previous input commands if necessary.</p>

<p style="margin-top: 1em">l wnode... <br>
Like &quot;h&quot; except forces nodes to be a low (0)
input.</p>

<p style="margin-top: 1em">u wnode... <br>
Like &quot;h&quot; except forces nodes to be a undefined (X)
input.</p>

<p style="margin-top: 1em">x wnode... <br>
Removes nodes from whatever input list they happen to be on.
The next simulation step will determine the correct node
value from the surrounding circuit. This is the <br>
default state of most nodes. Note that this does not force
nodes to have an &quot;X&quot; value -- it simply removes
them from the input lists.</p>

<p style="margin-top: 1em">inputs prints the high, low, and
undefined input lists.</p>

<p style="margin-top: 1em">It is possible to define a
sequence of values for a node, and then cycle the circuit as
many times as necessary to input each value and simulate the
network. A similar mechanism <br>
is used to define the sequence of values each clock node
goes through during a single cycle.</p>

<p style="margin-top: 1em">Each value is a list of
characters (with no intervening blanks) chosen from the
following:</p>

<p style="margin-top: 1em">1, h, H logic high (1) <br>
0, l, L logic low (0) <br>
u, U undefined (X) <br>
x, X remove node from input lists</p>

<p style="margin-top: 1em">Presumably the length of the
character list is the same as the size of the node/vector to
which it will be assigned. Blanks (spaces and tabs) are used
to separate values in a <br>
sequence. The sequence is used one value at a time, left to
right. If more values are needed than supplied by the
sequence, IRSIM just restarts the sequence again.</p>

<p style="margin-top: 1em">V [node [value...]] <br>
Define a vector of inputs for a node. After each cycle of an
&quot;R&quot; command, the node is set to the next value
specified in the sequence.</p>

<p style="margin-top: 1em">With no arguments, clears all
input sequences (does not affect clock sequences however).
With one argument, &quot;node&quot;, clears any input
sequences for that node/vector.</p>

<p style="margin-top: 1em">clock [node [value...]] <br>
Define a phase of the clock. Each cycle, each node specified
by a clock command must run through its respective values.
For example,</p>

<p style="margin-top: 1em">clock phi1 1 0 0 0 <br>
clock phi2 0 0 1 0</p>

<p style="margin-top: 1em">defines a simple 4-phase clock
using nodes phi1 and phi2. Alternatively one could have
issued the following commands:</p>

<p style="margin-top: 1em">vector clk phi1 phi2 <br>
clock clk 10 00 01 00</p>

<p style="margin-top: 1em">With no arguments, clears all
clock sequences. With one argument, &quot;node&quot;, clears
any clock sequences for that node/vector.</p>

<p style="margin-top: 1em">After input values have been
established, their effect can be propagated through the
network with the following commands. The basic simulated
time unit is 0.1ns; all event times <br>
are quantized into basic time units. A simulation step
continues until stepsize ns. have elapsed, and any events
scheduled for that interval are processed. It is possible to
<br>
build circuits which oscillate -- if the period of
oscillation is zero, the simulation command will not return.
If this seems to be the case, you can hit &lt;ctrl-C&gt; to
return to <br>
the command interpreter. Note that if you do this while
input is being taken from a file, the simulator will bring
you to the top level interpreter, aborting all pending input
<br>
from any command files.</p>

<p style="margin-top: 1em">When using the linear model (see
the &quot;model&quot; command) transition times are
estimated using an RC time constant calculated from the
surrounding circuit. When using the switch <br>
model, transitions are scheduled with unit delay. These
calculations can be overridden for a node by setting its
tplh and tphl parameters which will then be used to
determine <br>
the time for a transition.</p>

<p style="margin-top: 1em">s [n] Simulation step.
Propogates new values for the inputs through the network,
returns when n (default: stepsize) ns. have passed. If n is
specified, it will temporarily <br>
override the stepsize value. Unlike previous versions, this
value is NOT remembered as the default value for the
stepsize parameter. If the display mode is
&quot;automatic&quot;, <br>
the current display list is printed out on the completion of
this command (see &quot;display&quot; command).</p>

<p style="margin-top: 1em">c [n] Cycle n times (default: 1)
through the clock, as defined by the &quot;clock&quot;
command. Each phase of the clock lasts stepsize ns. If the
display mode is &quot;automatic&quot;, the cur&acirc; <br>
rent display list is printed out on the completion of this
command (see &quot;display&quot; command).</p>

<p style="margin-top: 1em">p Step the clock through one
phase (or simulation step). For example, if the clock is
defined as above</p>

<p style="margin-top: 1em">clock phi1 1 0 0 0 <br>
clock phi2 0 0 1 0</p>

<p style="margin-top: 1em">then &quot;p&quot; will set phi1
to 1 and phi2 to 0, and then propagate the effects for one
simulation step. The next time &quot;p&quot; is issued, phi1
and phi2 will both be set to 0, and <br>
the effects propagated, and so on. If the &quot;c&quot;
command is issued after &quot;p&quot; has been used, the
effect will be to step through the next 4 phases from where
the &quot;p&quot; command <br>
left off.</p>

<p style="margin-top: 1em">R [n] Run the simulator through
n cycles (see the &quot;c&quot; command). If n is not
present make the run as long as the longest sequence. If
display mode is automatic (see &quot;display&quot; <br>
command) the display is printed at the end of each cycle.
Each &quot;R&quot; command starts over at the beginning of
the sequence defined for each node.</p>

<p style="margin-top: 1em">back time <br>
Move back to the specified time. This command restores
circuit state as of time, effectively undoing any changes in
between. Note that you can not move past any previ&acirc;
<br>
ously flushed out history (see flush command below) as the
history mechanism is used to restore the network state. This
command can be useful to undo a mistake in the <br>
input vectors or to re-simulate the circuit with a different
debug level.</p>

<p style="margin-top: 1em">path wnode... <br>
display critical path(s) for last transition of the
specified node(s). The critical path transistions are
reported using the following format:</p>

<p style="margin-top: 1em">node -&gt; value @ time
(delta)</p>

<p style="margin-top: 1em">where node is the name of the
node, value is the value to which the node transitioned,
time is the time at which the transistion occurred, and
delta is the delay through <br>
the node since the last transition. For example:</p>

<p style="margin-top: 1em">critical path for last
transition of Hit_v1: <br>
phi1-&gt; 1 @ 2900.0ns , node was an input <br>
PC_driver-&gt; 0 @ 2900.4ns (0.4ns) <br>
PC_b_q1-&gt; 1 @ 2904.0ns (3.6ns) <br>
tagDone_b_v1-&gt; 0 @ 2912.8ns (8.8ns) <br>
tagDone1_v1-&gt; 1 @ 2915.3ns (2.5ns) <br>
tagDone1_b_v1-&gt; 0 @ 2916.0ns (0.7ns) <br>
tagDone_v1-&gt; 1 @ 2918.4ns (2.4ns) <br>
tagCmp_b_v1-&gt; 0 @ 2922.1ns (3.7ns) <br>
tagCmp_v1-&gt; 1 @ 2923.0ns (0.9ns) <br>
Vbit_b_v1-&gt; 0 @ 2923.2ns (0.2ns) <br>
Hit_v1-&gt; 1 @ 2923.5ns (0.3ns)</p>

<p style="margin-top: 1em">activity from_time [to_time]
<br>
print histogram showing amount of circuit activity in the
specified time inteval. Actually only shows number of nodes
which had their most recent transition in the inter&acirc;
<br>
val.</p>

<p style="margin-top: 1em">changes from_time [to_time] <br>
print list of nodes which last changed value in the
specified time interval.</p>

<p style="margin-top: 1em">printp print list of all pending
events sorted in time. The node associated with each event
and the scheduled time is printed.</p>

<p style="margin-top: 1em">printx print a list of all nodes
with undefined (X) values.</p>

<p style="margin-top: 1em">Using the trace command, it is
possible to get more detail about what&rsquo;s happening to
a particular node. Much of what is said below is described
in much more detail in &quot;Logic- <br>
level Simulation for VLSI Circuits&quot; by Chris Terman,
available from Kluwer Academic Press. When a node is traced,
the simulator reports each change in the node&rsquo;s
value:</p>

<p style="margin-top: 1em">[event #100] node out.1: 0 -&gt;
1 @ 407.6ns</p>

<p style="margin-top: 1em">The event index is incremented
for each event that is processed. The transition is reported
as</p>

<p style="margin-top: 1em">old value -&gt; new value @
report time</p>

<p style="margin-top: 1em">Note that since the time the
event is processed may differ from the event&rsquo;s report
time, the report time for successive events may not be
strictly increasing.</p>

<p style="margin-top: 1em">Depending on the debug level
(see the &quot;debug&quot; command) each calculation of a
traced node&rsquo;s value is reported:</p>

<p style="margin-top: 1em">[event #99] node clk: 0 -&gt; 1
@ 400.2ns <br>
final_value( Load ) V=[0.00, 0.04] =&gt; 0 <br>
..compute_tau( Load ) <br>
{Rmin=2.2K Rdom=2.2K Rmax=2.2K} {Ca=0.06 Cd=0.17} <br>
tauA=0.1 tauD=0.4 ns <br>
[event #99: clk-&gt;1] transition for Load: 1 -&gt; 0
(tau=0.5ns, delay=0.6ns)</p>

<p style="margin-top: 1em">In this example, a calculation
for node Load is reported. The calculation was caused by
event 99 in which node clk went to 1. When using the linear
model (as in this example) <br>
the report shows</p>

<p style="margin-top: 1em">current value -&gt; final
value</p>

<p style="margin-top: 1em">The second line displays
information regarding the final value (or dc) analysis for
node &quot;Load&quot;; the minimun and maximum voltages as
well as the final logical value (0 in this <br>
case).</p>

<p style="margin-top: 1em">The next three lines display
timing analysis information used to estimate the delays. The
meaning of the variables displayed can be found Chu&rsquo;s
thesis: &quot;Improved Models for <br>
Switch-Level Simulation&quot;.</p>

<p style="margin-top: 1em">When the final value is reported
as &quot;D&quot;, the node is not connected to an input and
may be scheduled to decay from its current value to X at
some later time (see the &quot;decay&quot; com&acirc; <br>
mand).</p>

<p style="margin-top: 1em">&quot;tau&quot; is the
calculated transition time constant, &quot;delta&quot; is
when any consequences of the event will be computed; the
difference in the two times is how IRSIM accounts for the
<br>
shape of the transition waveform on subsequent stages (see
reference given above for more details). The middle lines of
the report indicate the Thevenin and capacitance
parame&acirc; <br>
ters of the surrounding networks, i.e., the parameters on
which the transition calculations are based.</p>

<p style="margin-top: 1em">debug [ev dc tau taup tw
spk][off][all] <br>
Set debugging level. Useful for debugging simulator and/or
circuit at various levels of the computation. The meaning of
the various debug levels is as follows:</p>

<p style="margin-top: 1em">ev display event enqueueing and
dequeueing.</p>

<p style="margin-top: 1em">dc display dc calculation
information.</p>

<p style="margin-top: 1em">tau display time constant
(timing) calculation.</p>

<p style="margin-top: 1em">taup display second time
constant (timing) calculation.</p>

<p style="margin-top: 1em">tw display network parameters
for each stage of the tree walk, this applies to dc, tau,
and taup. This level of debugging detail is usually needed
only when debug&acirc; <br>
ging the simulator.</p>

<p style="margin-top: 1em">spk displays spike analysis
information.</p>

<p style="margin-top: 1em">all This is a shorthand for
specifying all of the above.</p>

<p style="margin-top: 1em">off This turns off all debugging
information.</p>

<p style="margin-top: 1em">If a debug switch is on then
during a simulation step, each time a watched node is
encounted in some event, that fact is indicated to the user
along with some event info. <br>
If a node keeps appearing in this prinout, chances are that
its value is oscillating. Vice versa, if your circuit never
settles (ie., it oscillates) , you can use the <br>
&quot;debug&quot; and &quot;t&quot; commands to find the
node(s) that are causing the problem.</p>

<p style="margin-top: 1em">Without any arguments, the debug
command prints the current debug level.</p>

<p style="margin-top: 1em">t [-]wnode... <br>
set trace flag for node. Enables the various printouts
described above. Prefacing the node name with
&rsquo;-&rsquo; clear its trace flag. If &quot;wnode&quot;
is the name of a vector, when&acirc; <br>
ever any node of that vector changes value, the current time
and the values of all traced vectors is printed. This
feature is useful for watching the relative arrival <br>
times of values at nodes in an output vector.</p>

<p style="margin-top: 1em">System interface commands:</p>

<p style="margin-top: 1em">&gt; filename <br>
Write current state of each node into specified file. Useful
for making a breakpoint in your simulation run. Only stores
values so isn&rsquo;t really useful to &quot;dump&quot; a
run <br>
for later use, i.e., the current input lists, pending
events, etc. are NOT saved in the state file.</p>

<p style="margin-top: 1em">&lt; filename <br>
Read from specified file, reinitializing the value of each
node as directed. Note that network must already exist and
be identical to the network used to create the dump <br>
file with the &quot;&gt;&quot; command. These state saving
commands are really provided so that complicated
initializing sequences need only be simulated once.</p>

<p style="margin-top: 1em">&lt;&lt; filename <br>
Same as &quot;&lt;&quot; command, except that this command
will restore the input status of the nodes as well. It does
not, however, restore pending events.</p>

<p style="margin-top: 1em">dumph [filename] <br>
Write the history of the simulation to the specified file,
that is; all transistions since time = 0. The resulting file
is a machine-independent binary file, and contains <br>
all the required information to continue simulation at the
time the dump takes place. If the filename isn&rsquo;t
specified, it will be constructed by taking the name of the
<br>
sim_file (from the command line) and appending
&quot;.hist&quot; to it.</p>

<p style="margin-top: 1em">readh filename <br>
Read the specified history-dump file into the current
network. This command will restore the state of the circuit
to that of the dump file, overwriting the current state.</p>

<p style="margin-top: 1em">flush [time] <br>
If memory consumption due to history maintanance becomes
prohibitive, this command can be used to free the memory
consumed by the history up to the time specified. With <br>
no arguments, all history up to the current point in the
simulation is freed. Flushing out the history may invalidate
an incremental simulation and the portions flushed <br>
will no longer appear in the analyzer window.</p>

<p style="margin-top: 1em">setpath [path...] <br>
Set the search-path for command files. Path should be a
sequence of directories to be searched for &quot;.cmd&quot;
files, &quot;.&quot; meaning the current directory. For
eaxmple:</p>

<p style="margin-top: 1em">setpath . /usr/me/rsim/cmds
/cad/lib/cmds</p>

<p style="margin-top: 1em">With no arguments, it will print
the current search-path. Initially this is just
&quot;.&quot;.</p>

<p style="margin-top: 1em">print text... <br>
Simply prints the text on the user&rsquo;s console. Useful
for keeping user posted of progress through a long command
file.</p>

<p style="margin-top: 1em">logfile [filename] <br>
Create a logfile with the specified name, closing current
log file if any; if no argument, just close current logfile.
All output which appears on user&rsquo;s console will <br>
also be placed in the logfile. Output to the logfile is
cleverly formatted so that logfiles themselves can serve as
command files.</p>

<p style="margin-top: 1em">setlog [filename | off] <br>
Record all net changes, as well as resulting error messages,
to the specified file (see &quot;update&quot; command). Net
changes are always appended to the log-file, preceding each
<br>
sequence of changes by the current date. If the argument is
off then net-changes will not be logged. With no arguments,
the name of the current log-file is printed.</p>

<p style="margin-top: 1em">The default is to always record
net changes; if no filename is specified (using the
&quot;setlog&quot; command) the default filename
irsim_changes.log will be used. The log-files <br>
are formatted so that log-files may themselves be used as
net-change files.</p>

<p style="margin-top: 1em">wnet [filename] <br>
Write the current network to the specified file. If the
filename isn&rsquo;t specified, it will be constructed by
taking the name of the sim_file (from the command line) and
<br>
appending &quot;.inet&quot; to it. The resulting file can be
used in a future simulation run, as if it were a sim file.
The file produced is a machine independent binary file, <br>
which is typically about 1/3 the size of the sim file and
about 8 times faster to load.</p>

<p style="margin-top: 1em">time [command] <br>
With no argument, a summary of time used by the simulator is
printed. If arguments are given the specified command is
timed and a time summary is printed when the command <br>
completes. The format of the time summary is Uu Ss E P% M,
where:</p>

<p style="margin-top: 1em">U =&gt; User time in seconds
<br>
S =&gt; System time in seconds <br>
E =&gt; Elapsed time, minutes:seconds <br>
P =&gt; Percentage of CPU time (((U + S)/E) * 100) <br>
M =&gt; Median text, data, and stack size use</p>

<p style="margin-top: 1em">q <br>
Terminate current input stream. If this is typed at top
level, the simulator will exit back to the system;
otherwise, input reverts to the previous input stream.</p>

<p style="margin-top: 1em">exit [n] <br>
Exit to system, n is the reported status (default: 0).</p>

<p style="margin-top: 1em">Simulator parameters are set
with the following commands. With no arguments, each of the
commands simply prints the current value of the
parameter.</p>

<p style="margin-top: 1em">decay [n] <br>
Set decay parameter to n ns. (default: 0). If non-zero, it
tells the number of ns. it takes for charge on a node to
decay to X. A value of 0 implies no decay at all. <br>
You cannot specify this parameters separately for each node,
but this turns out not to be a problem. See
&quot;report&quot; command.</p>

<p style="margin-top: 1em">display [-][cmdfile][automatic]
<br>
set/reset the display modes, which are</p>

<p style="margin-top: 1em">cmdfile commands executed from
command files are displayed to user before executing. The
default is cmdfile = OFF.</p>

<p style="margin-top: 1em">automatic print out current
display list (see &quot;d&quot; command) after completion of
&quot;s&quot; or &quot;c&quot; command. The default is
automatic = ON.</p>

<p style="margin-top: 1em">Prefacing the previous commands
with a &quot;-&quot; turns off that display option.</p>

<p style="margin-top: 1em">model [name] <br>
Set simulation model to one of the following:</p>

<p style="margin-top: 1em">switch Model transistors as
voltage controlled switches. This model uses interval logic
levels, without accounting for transistor resistances, so
circuits with fighting <br>
transistors may not be accuratelly modelled. Delays may not
reflect the true speed of the circuit as well.</p>

<p style="margin-top: 1em">linear Model transistors as a
resistor in series with a voltage controlled switch. This
model uses a single-time-constant computed from the
resulting RC network and uses <br>
a two-time-constant model to analyze charge sharing and
spikes.</p>

<p style="margin-top: 1em">The default is the linear model.
You can change the simulation model at any time -- even with
events pending -- as only new calculations are affected.
Without arguments, <br>
this command prints the current model name.</p>

<p style="margin-top: 1em">report [level] <br>
When level is nonzero, report all nodes which are set to X
because of charge decay, regardless on whether they are
being traced. Setting level to zero disables reporting, <br>
but not the decay itself (see &quot;decay&quot;
command).</p>

<p style="margin-top: 1em">stepsize [n] <br>
Specify duration of simulation step or clock phase. n is
specified in ns. (nanoseconds). Floating point numbers with
up to 1 digit past the decimal point are allowed. <br>
Further decimals are trucated (i.e. 10.299 == 10.2).</p>

<p style="margin-top: 1em">unitdelay [n] <br>
When nonzero, force all transitions to take n ns. Setting
the parameter to zero disables this feature. The resolution
is the same as for the &quot;stepsize&quot; command.</p>

<p style="margin-top: 1em">stats Print event statitistics,
as follows:</p>

<p style="margin-top: 1em">changes = 26077 <br>
punts (cns) = 208 (34) <br>
punts = 0.79%, cons_punted = 16.35% <br>
nevents = 28012; evaluations = 27972</p>

<p style="margin-top: 1em">Where changes is the total
number of transistions recorded, punts is the number of
punted events, (cns) is the number of consecutive punted
events (a punted event that <br>
punted another event). The penultimate line shows the
percentage of punted events with respect to the total number
of events, and the percentage of consecutive punted <br>
events with respect to the number of punted events. The last
line shows the total number of events (nevents) and the
number of net evaluations.</p>

<p style="margin-top: 1em">Incremental simulation
commands:</p>

<p style="margin-top: 1em">Irsim supports incremental
changes to the network and resimulation of the resulting
network. This is done incrementally so that only the nodes
affected by the changes, either <br>
directly or indirectly, are re-evaluated.</p>

<p style="margin-top: 1em">update filename <br>
Read net-change tokens from the specified file. The
following net-change commands are available:</p>

<p style="margin-top: 1em">add type gate source drain
length width [area] <br>
delete type gate source drain length width [area] <br>
move type gate source drain length width [area] g s d <br>
cap node value <br>
N node metal-area poly-area diff-area diff-perim <br>
M node M2A M2P MA MP PA PP DA DP PDA PDP <br>
thresh node low high <br>
Delay node tplh tphl</p>

<p style="margin-top: 1em">For a detailed dscription of
this file see netchange(5). Note that this is an
experimental interface and is likely to change in the
future.</p>

<p style="margin-top: 1em">Note that this command
doesn&rsquo;t resimulate the circuit so that it may leave
the network in an inconsistent state. Usually this command
will be followed by an isim command <br>
(see below), if that is not the case then it&rsquo;s up to
the user to initilize the state of the circuit. This command
exists only for historical reasons and will probably <br>
disappear in the future. It&rsquo;s use is discouraged.</p>

<p style="margin-top: 1em">isim [filename] <br>
Read net-change tokens from the specified file (see
netchange(5)) and incrementally resimulate the circuit up to
the current simulation time (not supported yet).</p>

<p style="margin-top: 1em">ires n The incremental algorithm
keeps track of nodes deviating from their past behavior as
recorded in the network history. During resimulation, a node
is considered to deviate <br>
from its history if it&rsquo;s new state is found to be
different within n ns of its previous state. This command
allows for changing the incremental resolution. With no
argu&acirc; <br>
ments, it will print the current resolution. The default
resolution is 0 ns.</p>

<p style="margin-top: 1em">powlogfile [filename] <br>
Opens filename for writting nodal transition reports. The
format of the report is the same you get when you trace a
node normaly. With no arguments powlogfile just closes <br>
the opened logfile and prints out a power dissipation
summary. Nodal transitions in inputs are not included in the
transition count.</p>

<p style="margin-top: 1em">powtrace [[-]node...] <br>
The syntax of this command is the same as the normal t
(trace) command. If you want to trace and report power
dissipation for all the nodes just use powtrace *. Use
pow&acirc; <br>
trace -node if you want to exclude some nodes.</p>

<p style="margin-top: 1em">powstep <br>
Toggles whether dynamic power estimation is displayed after
each timestep. The ynamic power displayed will only be for
the nodes that have been selected using the powtrace <br>
command.</p>

<p style="margin-top: 1em">vsupply voltage <br>
Sets the V variable for use in the P=CV^2/(2t) expression
where C is capacitance switched, and t is the timestep. The
default value for vsupply is 5.0 Volts.</p>

<p style="margin-top: 1em">sumcap Gives a sum of all nodal
capcitances, not just those selected with the powtrace
command.</p>

<p style="margin-top: 1em">SEE ALSO <br>
presim(1) (now obsolete) <br>
rsim(1) <br>
irsim-analyzer(3) <br>
sim(5) <br>
netchange(5)</p>

<p style="margin-top: 1em">3rd Berkeley Distribution
IRSIM(1)</p>
<hr>
</body>
</html>
