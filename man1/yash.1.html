<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:44:41 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>YASH(1) YASH(1)</p>

<p style="margin-top: 1em">NAME <br>
yash - a POSIX-compliant command line shell</p>

<p style="margin-top: 1em">SYNOPSIS <br>
yash [options...] [--] [operands...]</p>

<p style="margin-top: 1em">INTRODUCTION <br>
Yet another shell (yash) is a command line shell for
UNIX-like operating systems. The shell conforms to the
POSIX.1-2008 standard (for the most parts), and actually is
more <br>
conforming than other POSIX-conforming shells. Moreover, it
has many features that are used for interactive use, such as
command history and command line editing.</p>

<p style="margin-top: 1em">This program can be freely
modified and redistributed under the terms of GNU General
Public License (Version 2). Use of this program is all at
your own risk. There is no warranty <br>
and the author is not responsible for any consequences
caused by use of this program.</p>

<p style="margin-top: 1em">This manual can be freely
modified and redistributed under the terms of Creative
Commons Attribution-ShareAlike 2.1 Japan.</p>

<p style="margin-top: 1em">Yash is developed and maintained
by
&aelig;&cedil;&iexcl;&eacute;&egrave;&pound;&egrave;&sup2;&acute;
(WATANABE Yuki) aka Magicant. Yash development project and
Yash&acirc;s homepage are hosted by OSDN.</p>

<p style="margin-top: 1em">INVOCATION <br>
When invoked as a program, yash performs the predefined
initialization steps and repeatedly reads and executed
commands. Command line arguments given in the invocation
determines <br>
how the shell initializes itself and executes commands.</p>

<p style="margin-top: 1em">Command line arguments <br>
The syntax of command line arguments for yash conforms to
POSIX. As defined in POSIX, arguments are separated into
options and operands. For more detailed explanation about
<br>
options and operands, see Command argument syntax. All
options must come before operands. The interpretation of
operands depends on options specified.</p>

<p style="margin-top: 1em">When you specify the -c
(--cmdline) option, you must give at least one operand. The
shell interprets and executes the first operand as a command
string. The second operand, if <br>
any, is used to initialize the 0 special parameter. The
other operands, if any, are used to initialize the
positional parameters. When the -c (--cmdline) option is
specified, the <br>
shell does not read any file or the standard input (unless
the dot built-in is used).</p>

<p style="margin-top: 1em">If you specify the -s (--stdin)
option, the shell reads the standard input, interprets the
input as commands, and executes them. All the operands given
are used to initialize the <br>
positional parameters. The 0 special parameter is
initialized to the name the shell is invoked as.</p>

<p style="margin-top: 1em">If you specify neither the -c
(--cmdline) nor -s (--stdin) option, the shell reads a file,
interprets the file contents as commands, and executes them.
The first operand <br>
specifies the pathname of the file. The remaining operands
are used to initialize the positional parameters. If you do
not give any operands, the shell reads the standard input
<br>
as if the -s (--stdin) option is specified.</p>

<p style="margin-top: 1em">You cannot use both the -c
(--cmdline) and -s (--stdin) options at a time.</p>

<p style="margin-top: 1em">If you specify either the --help
or -V (--version) option, the shell never performs the usual
initialization or command execution. Instead, it just prints
brief usage (for <br>
--help) or version information (for -V and --version). If
the -V (--version) option is accompanied by the -v
(--verbose) option, the shell prints a list of the available
optional <br>
features as well.</p>

<p style="margin-top: 1em">If you specify the -i
(--interactive) option, the shell goes into the interactive
mode. If you specify the +i (++interactive) option,
conversely, the shell never goes into the <br>
interactive mode.</p>

<p style="margin-top: 1em">If you specify the -l (--login)
option, the shell behaves as a login shell.</p>

<p style="margin-top: 1em">The --noprofile, --norcfile,
--profile, and --rcfile options determine how the shell is
initialized (see below for details).</p>

<p style="margin-top: 1em">In addition to the options
described above, you can specify options that can be
specified to the set built-in.</p>

<p style="margin-top: 1em">If the first operand is - and
the options and the operands are not separated by --, the
first operand is ignored.</p>

<p style="margin-top: 1em">Initialization of yash <br>
Yash initializes itself as follows:</p>

<p style="margin-top: 1em">1. Yash first parses the name it
was invoked as. If the name starts with -, the shell behaves
as a login shell. If the name is sh (including names such as
/bin/sh), the shell <br>
goes into the POSIXly-correct mode.</p>

<p style="margin-top: 1em">2. If no operands are given and
the standard input and standard error are both connected to
a terminal, the shell goes into the interactive mode unless
the +i (++interactive) <br>
option is specified.</p>

<p style="margin-top: 1em">3. Job control is automatically
enabled in an interactive shell unless the +m (++monitor)
option is specified.</p>

<p style="margin-top: 1em">4. Yash reads and executes
commands from the following files (unless the real and
effective user IDs of the shell process are different or the
real and effective group IDs of <br>
the shell process are different):</p>

<p style="margin-top: 1em">1. If it is behaving as a login
shell, the shell reads the file specified by the
--profile=filename option unless the --noprofile option is
specified or the shell is in the <br>
POSIXly-correct mode.</p>

<p style="margin-top: 1em">If the --profile=filename option
is not specified, the shell reads ~/.yash_profile as a
default.</p>

<p style="margin-top: 1em">2. If in the interactive mode,
the shell reads the file specified by the --rcfile=filename
option unless the --norcfile option is specified.</p>

<p style="margin-top: 1em">If the --rcfile=filename option
is not specified, the shell instead reads the following
files:</p>

<p style="margin-top: 1em">&Acirc;&middot; If not in the
POSIXly-correct mode, the shell reads ~/.yashrc. If it
cannot be read, the shell searches YASH_LOADPATH for a file
named initialization/default.</p>

<p style="margin-top: 1em">&Acirc;&middot; If in the
POSIXly-correct mode, the shell performs parameter expansion
on the value of the ENV environment variable and treats the
expansion result as the name of the <br>
file to read.</p>

<p style="margin-top: 1em">Note <br>
Yash never automatically reads /etc/profile, /etc/yashrc,
nor ~/.profile.</p>

<p style="margin-top: 1em">SYNTAX <br>
The shell reads, parses, and executes command line by line.
If there is more than one command on a line, all the
commands are parsed before executed. If a command is
continued to <br>
next lines, the shell reads more enough lines to complete
the command. On a syntax error, the shell neither reads nor
executes any more commands.</p>

<p style="margin-top: 1em">Tokens and keywords <br>
A command is composed of one or more tokens. In the shell
syntax, a token is a word that is part of a command.
Normally, tokens are separated by whitespaces, that is, the
space <br>
or tab character. Whitespaces inside a command substitution
or a parameter expansion, however, do not separate
tokens.</p>

<p style="margin-top: 1em">The following symbols have
special meanings in the shell syntax and in most cases
separate tokens:</p>

<p style="margin-top: 1em">; &amp; | &lt; &gt; ( )
[newline]</p>

<p style="margin-top: 1em">The following symbols do not
separate tokens, but have syntactic meanings:</p>

<p style="margin-top: 1em">$ &lsquo; &nbsp;&quot; &rsquo; *
? [ # ~ = %</p>

<p style="margin-top: 1em">The following tokens are treated
as keywords depending on the context in which they
appear:</p>

<p style="margin-top: 1em">! { } case do done elif else
esac fi <br>
for function if in then until while</p>

<p style="margin-top: 1em">A token is treated as a keyword
when:</p>

<p style="margin-top: 1em">&Acirc;&middot; it is the first
token of a command,</p>

<p style="margin-top: 1em">&Acirc;&middot; it follows
another keyword (except case, for, and in), or</p>

<p style="margin-top: 1em">&Acirc;&middot; it is a
non-first token of a command and is supposed to be a keyword
to compose a composite command.</p>

<p style="margin-top: 1em">If a token begins with #, then
the # and any following characters up to the end of the line
are treated as a comment, which is completely ignored in
syntax parsing.</p>

<p style="margin-top: 1em">Quotations <br>
If you want whitespaces, separator characters, or keywords
described above to be treated as a normal characters, you
must quote the characters using appropriate quotation marks.
<br>
Quotation marks are not treated as normal characters unless
they are themselves quoted. You can use the following three
quotation marks:</p>

<p style="margin-top: 1em">&Acirc;&middot; A backslash (
quotes a character that immediately follows.</p>

<p style="margin-top: 1em">The only exception about a
backslash is the case where a backslash is followed by a
newline. In this case, the two characters are treated as a
line continuation rather than a <br>
newline being quoted. The two characters are removed from
the input and the two lines surrounding the line
continuation are concatenated into a single line.</p>

<p style="margin-top: 1em">&Acirc;&middot; A pair of
single-quotation marks (&rsquo;) quote any characters
between them except another single-quotation. Note that
newlines can be quoted using single-quotations.</p>

<p style="margin-top: 1em">&Acirc;&middot; Double-quotation
marks (&quot;) are like single-quotations, but they have a
few exceptions: Parameter expansion, command substitution,
and arithmetic expansion are interpreted as <br>
usual even between double-quotations. A backslash between
double-quotations is treated as a quotation mark only when
it is followed by $, &lsquo;, &quot;, or a newline; other
<br>
backslashes are treated as normal characters.</p>

<p style="margin-top: 1em">Aliases <br>
Tokens that compose a command are subject to alias
substitution. A token that matches the name of an alias that
has already been defined is substituted with the value of
the <br>
alias before the command is parsed.</p>

<p style="margin-top: 1em">Tokens that contain quotations
are not alias-substituted since an alias name cannot contain
quotation marks. Keywords and command separator characters
are not alias-substituted <br>
either.</p>

<p style="margin-top: 1em">There are two kinds of aliases:
normal aliases and global aliases. A normal alias can only
substitute the first token of a command while a global alias
can substitute any part of <br>
a command. Global aliases are yash extension that is not
defined in POSIX.</p>

<p style="margin-top: 1em">If a token is alias-substituted
with the value of a normal alias that ends with a
whitespace, the next token is exceptionally subject to alias
substitution for normal aliases.</p>

<p style="margin-top: 1em">The results of alias
substitution are again subject to alias substitution for
other aliases (but not for the aliases that have been
already applied).</p>

<p style="margin-top: 1em">You can define aliases using the
alias built-in and remove using the unalias built-in.</p>

<p style="margin-top: 1em">Simple commands <br>
A command that does not start with a keyword token is a
simple command. Simple commands are executed as defined in
Execution of simple commands.</p>

<p style="margin-top: 1em">If the first and any number of
following tokens of a simple command have the form
name=value, they are interpreted as variable assignments. A
variable name must consist of one or <br>
more alphabets, digits and/or underlines (_) and must not
start with a digit. The first token that is not a variable
assignment is considered as a command name and all the <br>
following tokens (whether or not they have the form
name=value) as command arguments.</p>

<p style="margin-top: 1em">A variable assignment of the
form var=(tokens) is interpreted as assignment to an array.
You can write any number of tokens between a pair of
parentheses. Tokens can be separated <br>
by not only spaces and tabs but also newlines.</p>

<p style="margin-top: 1em">Pipelines <br>
A pipeline is a sequence of one or more simple commands,
compound commands, and/or function definitions that are
separated by |.</p>

<p style="margin-top: 1em">A pipeline that has more than
one subcommand is executed by executing each subcommand of
the pipeline in a subshell simultaneously. The standard
output of each subcommand except <br>
the last one is redirected to the standard input of the next
subcommand. The standard input of the first subcommand and
the standard output of the last subcommand are not <br>
redirected.</p>

<p style="margin-top: 1em">The exit status of the pipeline
is that of the last subcommand unless the pipe-fail option
is enabled, in which case the exit status of the pipeline is
that of the last <br>
subcommand that exits with a non-zero exit status. If all
the subcommands exit with an exit status of zero, the exit
status of the pipeline is also zero.</p>

<p style="margin-top: 1em">A pipeline can be prefixed by !,
in which case the exit status of the pipeline is reversed:
the exit status of the pipeline is 1 if that of the last
subcommand is 0, and 0 <br>
otherwise.</p>

<p style="margin-top: 1em">Korn shell treats a word of the
form !(...) as an extended pathname expansion pattern that
is not defined in POSIX. In the POSIXly-correct mode, the
tokens ! and ( must be <br>
separated by one or more white spaces.</p>

<p style="margin-top: 1em">Note <br>
When the execution of a pipeline finishes, at least the
execution of the last subcommand has finished since the exit
status of the last subcommand defines that of the whole <br>
pipeline. The execution of other subcommands, however, may
not have finished then. On the other hand, the execution of
the pipeline may not finish soon after that of the last <br>
subcommand finished because the shell may choose to wait for
the execution of other subcommands to finish.</p>

<p style="margin-top: 1em">Note <br>
The POSIX standard allows executing any of subcommands in
the current shell rather than subshells, though yash does
not do so.</p>

<p style="margin-top: 1em">And/or lists <br>
An and/or list is a sequence of one or more pipelines
separated by &amp;&amp; or ||.</p>

<p style="margin-top: 1em">An and/or list is executed by
executing some of the pipelines conditionally. The first
pipeline is always executed. The other pipelines are either
executed or not executed <br>
according to the exit status of the previous pipelines.</p>

<p style="margin-top: 1em">&Acirc;&middot; If two pipelines
are separated by &amp;&amp; and the exit status of the first
pipeline is zero, the second pipeline is executed.</p>

<p style="margin-top: 1em">&Acirc;&middot; If two pipelines
are separated by || and the exit status of the first
pipeline is not zero, the second pipeline is executed.</p>

<p style="margin-top: 1em">&Acirc;&middot; In other cases,
the execution of the and/or list ends: the second and any
remaining pipelines are not executed.</p>

<p style="margin-top: 1em">The exit status of an and/or
list is that of the last pipeline that was executed.</p>

<p style="margin-top: 1em">Normally, an and/or list must be
terminated by a semicolon, ampersand, or newline. See
Command separators and asynchronous commands.</p>

<p style="margin-top: 1em">Command separators and
asynchronous commands <br>
The whole input to the shell must be composed of any number
of and/or lists separated by a semicolon or ampersand. A
terminating semicolon can be omitted if it is followed by
;;, <br>
), or a newline. Otherwise, an and/or list must be
terminated by a semicolon or ampersand.</p>

<p style="margin-top: 1em">If an and/or list is terminated
by a semicolon, it is executed synchronously: the shell
waits for the and/or list to finish before executing the
next and/or list. If an and/or <br>
list is terminated by an ampersand, it is executed
asynchronously: after the execution of the and/or list is
started, the next and/or list is executed immediately. An
<br>
asynchronous and/or list is always executed in a subshell
and its exit status is zero.</p>

<p style="margin-top: 1em">If the shell is not doing job
control, the standard input of an asynchronous and/or list
is automatically redirected to /dev/null. Signal handlers of
the and/or list for the <br>
SIGINT and SIGQUIT signals are set to &acirc;ignore&acirc;
the signal so that the execution of the and/or list cannot
be stopped by those signals.</p>

<p style="margin-top: 1em">When the execution of an
asynchronous and/or list is started, the shell remembers its
process ID. You can obtain the ID by referencing the !
special parameter. You can obtain the <br>
current and exit status of the asynchronous list as well by
using the jobs and wait built-ins.</p>

<p style="margin-top: 1em">Compound commands <br>
Compound commands provide you with programmatic control of
shell command execution.</p>

<p style="margin-top: 1em">Grouping <br>
A grouping is a list of commands that is treated as a simple
command.</p>

<p style="margin-top: 1em">Normal grouping syntax <br>
{ command...; }</p>

<p style="margin-top: 1em">Subshell grouping syntax <br>
(command...)</p>

<p style="margin-top: 1em">The { and } tokens are keywords,
which must be separated from other tokens. The ( and )
tokens, however, are special separators that need not to be
separated.</p>

<p style="margin-top: 1em">In the normal grouping syntax,
the commands in a grouping are executed in the current
shell. In the subshell grouping syntax, the commands are
executed in a new subshell.</p>

<p style="margin-top: 1em">In the POSIXly-correct mode, a
grouping must contain at least one command. If the shell is
not in the POSIXly-correct mode, a grouping may contain no
commands.</p>

<p style="margin-top: 1em">The exit status of a grouping is
that of the last command in the grouping. If the grouping
contains no commands, its exit status is that of the last
executed command before <br>
the grouping.</p>

<p style="margin-top: 1em">If command <br>
The if command performs a conditional branch.</p>

<p style="margin-top: 1em">Basic if command syntax <br>
if condition...; then body...; fi</p>

<p style="margin-top: 1em">Syntax with the else clause <br>
if condition...; then body...; else body...; fi</p>

<p style="margin-top: 1em">Syntax with the elif clause <br>
if condition...; then body...; elif condition...; then
body...; fi</p>

<p style="margin-top: 1em">Syntax with the elif clause <br>
if condition...; then body...; elif condition...; then
body...; else body...; fi</p>

<p style="margin-top: 1em">For all the syntaxes, the
execution of an if command starts with the execution of the
condition commands that follows the if token. If the exit
status of the condition <br>
commands is zero, the condition is considered as
&acirc;true&acirc;. In this case, the body commands that
follows the then token are executed and the execution of the
if command <br>
finishes. If the exit status of the condition commands is
non-zero, the condition is considered as
&acirc;false&acirc;. In this case, the condition commands
for the next elif clause are <br>
executed and the exit status is tested in the same manner as
above. If there is no elif clause, the body commands that
follow the else token are executed and the execution of <br>
the if command finishes. If there is no else clause either,
the execution of the if command just ends.</p>

<p style="margin-top: 1em">An if command may have more than
one elif-then clause.</p>

<p style="margin-top: 1em">The exit status of an if command
is that of the body commands that were executed. The exit
status is zero if no body commands were executed, that is,
all the conditions were <br>
false and there was no else clause.</p>

<p style="margin-top: 1em">While and until loops <br>
The while loop and until loop are simple loops with
condition.</p>

<p style="margin-top: 1em">While loop syntax <br>
while condition...; do body...; done</p>

<p style="margin-top: 1em">Until loop syntax <br>
until condition...; do body...; done</p>

<p style="margin-top: 1em">If the shell is not in the
POSIXly-correct mode, you can omit the condition and/or body
commands of a while/until loop.</p>

<p style="margin-top: 1em">The execution of a while loop is
started by executing the condition commands. If the exit
status of the condition commands is zero, the shell executes
the body commands and <br>
returns to the execution of the condition commands. The
condition and body commands are repeatedly executed until
the exit status of the condition commands is non-zero.</p>

<p style="margin-top: 1em">Note <br>
The body commands are not executed at all if the first
execution of the condition commands yields a non-zero exit
status.</p>

<p style="margin-top: 1em">An until loop is executed in the
same manner as a while loop except that the condition to
repeat the loop is reversed: the body commands are executed
when the exit status of <br>
the condition commands is non-zero.</p>

<p style="margin-top: 1em">The exit status of a while/until
loop is that of the last executed body command. The exit
status is zero if the body commands are empty or were not
executed at all.</p>

<p style="margin-top: 1em">For loop <br>
The for loop repeats commands with a variable assigned one
of given values in each round.</p>

<p style="margin-top: 1em">For loop syntax <br>
for varname in word...; do command...; done</p>

<p style="margin-top: 1em">for varname do command...;
done</p>

<p style="margin-top: 1em">The word list after the in token
may be empty, but the semicolon (or newline) before the do
token is required even in that case. The words are not
treated as keywords, but <br>
you need to quote separator characters (such as &amp; and |)
to include them as part of a word. The command list may be
empty if not in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">The varname must be a portable
(ASCII-only) name in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">The execution of a for loop is
started by expanding the words in the same manner as in the
execution of a simple command. If the in and word tokens are
omitted, the shell <br>
assumes the word tokens to be &quot;$@&quot;. Next, the
following steps are taken for each word expanded (in the
order the words were expanded):</p>

<p style="margin-top: 1em">1. Assign the word to the
variable whose name is varname.</p>

<p style="margin-top: 1em">2. Execute the commands.</p>

<p style="margin-top: 1em">Each word is assigned as a local
variable except in the POSIXly-correct mode. If the
expansion of the words yielded no words as a result, the
commands are not executed at <br>
all.</p>

<p style="margin-top: 1em">The exit status of a for loop is
that of the last executed command. The exit status is zero
if the commands are not empty and not executed at all. If
the commands are empty, <br>
the exit status is that of the last executed command before
the for loop.</p>

<p style="margin-top: 1em">If the variable is read-only,
the execution of the for loop is interrupted and the exit
status will be non-zero.</p>

<p style="margin-top: 1em">Case command <br>
The case command performs a pattern matching to select
commands to execute.</p>

<p style="margin-top: 1em">Case command syntax <br>
case word in caseitem... esac</p>

<p style="margin-top: 1em">Case item syntax <br>
(patterns) command...;;</p>

<p style="margin-top: 1em">The word between the case and in
tokens must be exactly one word. The word is not treated as
a keyword, but you need to quote separator characters (such
as &amp; and |) to <br>
include them as part of the word. Between the in and esac
tokens you can put any number of case items (may be none).
You can omit the first ( token of a case item and the <br>
last ;; token before the esac token. If the last command of
a case item is terminated by a semicolon, you can omit the
semicolon as well. The commands in a case item may be <br>
empty.</p>

<p style="margin-top: 1em">The patterns in a case item are
one or more tokens each separated by a | token.</p>

<p style="margin-top: 1em">The execution of a case command
starts with subjecting the word to the four expansions.
Next, the following steps are taken for each case item (in
the order of appearance):</p>

<p style="margin-top: 1em">1. For each word in the
patterns, expand the word in the same manner as the word and
test if the expanded pattern matches the expanded word. (If
a pattern is found that <br>
matches the word, the remaining patterns are not expanded
nor tested, so some of the patterns may not be expanded.
Yash expands and tests the patterns in the order of <br>
appearance, but it may not be the case for other
shells.)</p>

<p style="margin-top: 1em">2. If one of the patterns was
found to match the word in the previous step, the commands
in this case item are executed and the execution of the
whole case item ends. <br>
Otherwise, proceed to the next case item.</p>

<p style="margin-top: 1em">The exit status of a case
command is that of the commands executed. The exit status is
zero if no commands were executed, that is, there were no
case items, no matching <br>
pattern was found, or no commands were associated with the
matching pattern.</p>

<p style="margin-top: 1em">In the POSIXly-correct mode, the
first pattern in a case item cannot be esac (even if you do
not omit the ( token).</p>

<p style="margin-top: 1em">Function definition <br>
The function definition command defines a function.</p>

<p style="margin-top: 1em">Function definition syntax <br>
funcname ( ) compound_command</p>

<p style="margin-top: 1em">function funcname
compound_command</p>

<p style="margin-top: 1em">function funcname ( )
compound_command</p>

<p style="margin-top: 1em">In the first syntax without the
function keyword, funcname cannot contain any special
characters such as semicolons and quotation marks. In the
second and third syntax, which <br>
cannot be used in the POSIXly-correct mode, funcname is
subjected to the four expansions when executed. In the
POSIXly-correct mode, funcname is limited to a portable <br>
(ASCII-only) name.</p>

<p style="margin-top: 1em">When a function definition
command is executed, a function whose name is funcname is
defined with its body being compound_command.</p>

<p style="margin-top: 1em">A function definition command
cannot be directly redirected. Any redirections that follow
a function definition are associated with compound_command
rather than the whole <br>
function definition command. In func() { cat; }
&gt;/dev/null, for example, it is not func() { cat; } but {
cat; } that is redirected.</p>

<p style="margin-top: 1em">The exit status of a function
definition is zero if the function was defined without
errors, and non-zero otherwise.</p>

<p style="margin-top: 1em">PARAMETERS AND VARIABLES <br>
Parameters are string values that are expanded in parameter
expansion. There are three types of parameters: positional
parameters, special parameters and variables.</p>

<p style="margin-top: 1em">Positional parameters <br>
Positional parameters are parameters that are identified by
natural numbers. If there are three positional parameters,
for example, they are identified as 1, 2, and 3. You can
<br>
obtain the number of positional parameters by the # special
parameter. The * and @ special parameters are expanded to
all positional parameters.</p>

<p style="margin-top: 1em">Positional parameters are
initialized from the shell&acirc;s command line arguments
when the shell is started (see Command line arguments). In
the initialization, the order of the <br>
operands are preserved as the order of the positional
parameters.</p>

<p style="margin-top: 1em">When the shell executes a
function call, positional parameters are changed to the
arguments to the function call so that you can access the
arguments while the function is being <br>
executed. Positional parameters are restored to the original
values when the execution of the function is finished.</p>

<p style="margin-top: 1em">Positional parameters can be
manipulated by built-in commands like set and shift.</p>

<p style="margin-top: 1em">Note that 0 is not a positional
parameter but a special parameter.</p>

<p style="margin-top: 1em">Special parameters <br>
Special parameters are parameters each identified by a
single symbol. They cannot be directly assigned to by the
user.</p>

<p style="margin-top: 1em">Yash provides the following
special parameters:</p>

<p style="margin-top: 1em">0 <br>
The name of the shell executable file or the script file
that was specified in the invocation of the shell.</p>

<p style="margin-top: 1em"># <br>
The number of current positional parameters. The value is a
non-negative integer.</p>

<p style="margin-top: 1em">$ <br>
The process ID of the shell. The value is a positive integer
and is never changed even in subshells.</p>

<p style="margin-top: 1em">- <br>
Currently enabled shell options. The value is a
concatenation of alphabet characters that are the names of
currently enabled single-character options that can be
specified in <br>
shell invocation. The value reflects changes of enabled
options when you enable or disable options using the set
built-in.</p>

<p style="margin-top: 1em">? <br>
The exit status of the last executed pipeline. The value is
a non-negative integer.</p>

<p style="margin-top: 1em">! <br>
The process ID of the last executed asynchronous list.</p>

<p style="margin-top: 1em">* <br>
This special parameter represents the whole positional
parameters. When there is no positional parameters, the
value of this special parameter is the empty string. When
there <br>
is more than one positional parameter, the value is a
concatenation of all the positional parameters, each of
which is separated as follows:</p>

<p style="margin-top: 1em">&Acirc;&middot; If the IFS
variable exists and its value is not empty, positional
parameters are each separated by the first character of the
value of the IFS variable.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the IFS
variable exists and has an empty value, positional
parameters are just concatenated without any separator.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the IFS
variable does not exist, positional parameters are each
separated by a space character.</p>

<p style="margin-top: 1em">If field-splitting is applied to
an expansion result of this parameter, the value is first
split into the original positional parameters and then
further split depending on <br>
the current IFS variable. The first splitting is performed
even if the IFS variable is empty.</p>

<p style="margin-top: 1em">@ <br>
This special parameter represents the whole positional
parameters like the * special parameter above. The
difference between the two is the results of expansion that
occurs <br>
between a pair of double-quotation marks. If the @ special
parameter is expanded inside double-quotations, the result
is field-split into the exact positional parameter <br>
values. If there are no positional parameters, the expansion
yields no word rather than an empty word. (Even if the
expansion is double-quoted, the result is not always a <br>
single word.)</p>

<p style="margin-top: 1em">&Acirc;&middot; When there are
no positional parameters, the command words echo 1
&quot;$@&quot; 2 are expanded to the three words echo, 1,
and 2.</p>

<p style="margin-top: 1em">&Acirc;&middot; When positional
parameters are the three words 1, 2 2, and 3, the command
words echo &quot;$@&quot; are expanded to the four words
echo, 1, 2 2, and 3, and the words echo &quot;a$@b&quot; to
<br>
the four words echo, a1, 2 2, and 3b.</p>

<p style="margin-top: 1em">Variables <br>
Variables are parameters the user can assign values to. Each
variable has a name that identifies it and a value that
defines the results of expansion.</p>

<p style="margin-top: 1em">A variable name is composed of
one or more alphanumeric characters and underscores (_). A
name cannot start with a digit. Other characters may be used
in a name depending on <br>
internationalization support of your environment.</p>

<p style="margin-top: 1em">Variables that are exported to
external commands are called environment variables. They are
passed to all external commands the shell invokes. Variables
passed to the shell in <br>
invocation will be automatically exported.</p>

<p style="margin-top: 1em">You can assign to variables by a
simple command as well as the typeset built-in. You can
remove variables by using the unset built-in.</p>

<p style="margin-top: 1em">Variables used by the shell <br>
The following variables are used by the shell for special
purposes.</p>

<p style="margin-top: 1em">CDPATH <br>
This variable is used by the cd built-in to find a
destination directory.</p>

<p style="margin-top: 1em">COLUMNS <br>
This variable specifies the width (the number of character
columns) of the terminal screen. The value affects the
display of line-editing.</p>

<p style="margin-top: 1em">COMMAND_NOT_FOUND_HANDLER <br>
When the shell cannot find a command to be executed, the
value of this variable is interpreted and executed instead.
You can override the shell&acirc;s error handling behavior
<br>
with this variable. See Execution of simple commands for
detail.</p>

<p style="margin-top: 1em">This feature is disabled in the
POSIXly-correct mode.</p>

<p style="margin-top: 1em">DIRSTACK <br>
This array variable is used by the shell to store the
directory stack contents. If you modify the value of this
variable, the directory stack may be corrupted.</p>

<p style="margin-top: 1em">ECHO_STYLE <br>
This variable specifies the behavior of the echo
built-in.</p>

<p style="margin-top: 1em">ENV <br>
When an interactive shell is started in the POSIXly-correct
mode, the value of this variable is used to find the
initialization file. See Initialization of yash.</p>

<p style="margin-top: 1em">FCEDIT <br>
This variable specifies an editor program used to edit
command lines during execution of the fc built-in.</p>

<p style="margin-top: 1em">HANDLED <br>
This variable can be set in the command-not-found handler to
tell the shell not to produce a further error message. See
Execution of simple commands for detail.</p>

<p style="margin-top: 1em">HISTFILE <br>
This variable specifies the pathname of the file to save the
command history in.</p>

<p style="margin-top: 1em">HISTRMDUP <br>
This variable specifies the number of command history items
to be checked for duplication. When the shell is adding a
new history item to the command history, if some of <br>
the most recent n items have the same contents as the new
one, then the duplicate existing items are removed from the
history before the new one is added, where n is the <br>
value of this variable.</p>

<p style="margin-top: 1em">If the value of this variable is
1, for example, the most recent item is removed when a new
item that have the same contents is added.</p>

<p style="margin-top: 1em">Items older than the nth recent
item are not removed. No items are removed if the value of
this variable is 0. All items are subject to removal if the
variable value is <br>
greater than or equal to the value of the HISTSIZE
variable.</p>

<p style="margin-top: 1em">HISTSIZE <br>
This variable specifies the maximum number of items in the
command history.</p>

<p style="margin-top: 1em">HOME <br>
This variable specifies the pathname of the user&acirc;s
home directory and affects results of tilde expansion and cd
built-in.</p>

<p style="margin-top: 1em">IFS <br>
This variable specifies separators used in field splitting.
The variable value is initialized to the three characters of
a space, a tab, and a newline when the shell is <br>
started.</p>

<p style="margin-top: 1em">LANG, LC_ALL, LC_COLLATE,
LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME <br>
These variables specify a locale in which the shell runs.
The shell chooses the file input/output encoding, the error
message language, etc. according to the locale <br>
specified.</p>

<p style="margin-top: 1em">Unless the shell is interactive
and not in the POSIXly-correct mode, the value of the
LC_CTYPE variable is considered only when the shell is
started. Once the shell has <br>
been initialized, changing the value of LC_CTYPE will have
no effect on the shell&acirc;s behavior.</p>

<p style="margin-top: 1em">LINENO <br>
The value of this variable is automatically set to the line
number in which the currently executed command appears in
the file.</p>

<p style="margin-top: 1em">In the interactive shell, the
line number is reset to 1 each time the shell reads and
executes a command.</p>

<p style="margin-top: 1em">If you assign to or remove this
variable, it will no longer provide line numbers.</p>

<p style="margin-top: 1em">LINES <br>
This variable specifies the height (the number of character
lines) of the terminal screen. The value affects the display
of line-editing.</p>

<p style="margin-top: 1em">MAIL <br>
This variable specifies the pathname of a file that is
checked in mail checking.</p>

<p style="margin-top: 1em">MAILCHECK <br>
This variable specifies how often the shell should do mail
checking. The value has to be specified as a positive
integer in seconds. The value is initialized to the <br>
default value of 600 when the shell is started.</p>

<p style="margin-top: 1em">MAILPATH <br>
This variable specifies the pathnames of files that are
checked in mail checking.</p>

<p style="margin-top: 1em">NLSPATH <br>
The POSIX standard prescribes that the value of this
variable specifies pathname templates of locale-dependent
message data files, but yash does not use it.</p>

<p style="margin-top: 1em">OLDPWD <br>
This variable is set to the previous working directory path
when you change the working directory by using the cd or
other built-ins. This variable is exported by <br>
default.</p>

<p style="margin-top: 1em">OPTARG <br>
When the getopts built-in parses an option that takes an
argument, the argument value is assigned to this
variable.</p>

<p style="margin-top: 1em">OPTIND <br>
The value of this variable specifies the index of an option
that is to be parsed by the next getopts built-in execution.
This variable is initialized to 1 when the shell <br>
is started.</p>

<p style="margin-top: 1em">PATH <br>
This variable specifies paths that are searched for a
command in command search.</p>

<p style="margin-top: 1em">PPID <br>
The value of this variable is the process ID of the
shell&acirc;s parent process, which is a positive integer.
This variable is initialized when the shell is started. The
value <br>
is not changed when the shell makes a new subshell.</p>

<p style="margin-top: 1em">PROMPT_COMMAND <br>
The shell interprets and executes the value of this variable
before printing each command prompt if the shell is
interactive and not in the POSIXly-correct mode. This <br>
behavior is equivalent to executing the command eval -i --
&quot;${PROMPT_COMMAND-}&quot; before each command prompt,
but its exit status does not affect the expansion of the ?
<br>
special parameter in the next command.</p>

<p style="margin-top: 1em">PS1 <br>
This variable specifies the main command prompt string
printed by an interactive shell. See Prompts for the format
of the variable value. The value is initialized to <br>
when the shell is started. (In the POSIXly-correct mode, the
initial value is either $ or # depending on whether the
effective user ID of the shell process is zero or <br>
not.)</p>

<p style="margin-top: 1em">PS1R <br>
This variable specifies the auxiliary prompt string printed
to the right of the cursor when you input a command line to
an interactive shell. See Prompts for the format <br>
of the variable value.</p>

<p style="margin-top: 1em">PS1S <br>
This variable specifies the font style of command strings
you enter to an interactive shell. See Prompts for the
format of the variable value.</p>

<p style="margin-top: 1em">PS2 <br>
This variable is like the PS1 variable, but it is used for
the second and following lines of a command that is longer
than one line. See Prompts for the format of the <br>
variable value. The value is initialized to &gt; when the
shell is started.</p>

<p style="margin-top: 1em">PS2R <br>
This variable is like the PS1R variable, but it is used when
PS2 is used. See Prompts for the format of the variable
value.</p>

<p style="margin-top: 1em">PS2S <br>
This variable is like the PS1S variable, but it is used when
PS2 is used. See Prompts for the format of the variable
value.</p>

<p style="margin-top: 1em">PS4 <br>
The value of this variable is printed before each command
trace output when the xtrace option is enabled. The value is
subject to parameter expansion, command <br>
substitution, arithmetic expansion. You can also use
backslash notations if the shell is not in the
POSIXly-correct mode. The value is initialized to + when the
shell is <br>
started.</p>

<p style="margin-top: 1em">PS4S <br>
This variable is like the PS1S variable, but it is used when
PS4 is used. You can use this variable to modify font style
of command trace output.</p>

<p style="margin-top: 1em">PWD <br>
The value of this variable is the pathname of the current
working directory. The value is set when the shell is
started and reset each time the working directory is <br>
changed by the cd or other built-ins. This variable is
exported by default.</p>

<p style="margin-top: 1em">RANDOM <br>
You can use this variable to get random numbers. The value
of this variable is a uniformly distributed random integer
between 0 and 32767 (inclusive). You will get a <br>
different number each time the variable is expanded.</p>

<p style="margin-top: 1em">You can set the
&acirc;seed&acirc; of random numbers by assigning a
non-negative integer to the variable.</p>

<p style="margin-top: 1em">If you remove this variable, it
will no longer work as a random number generator. If the
shell was invoked in the POSIXly-correct mode, this variable
does not work as a <br>
random number generator.</p>

<p style="margin-top: 1em">TERM <br>
This variable specifies the type of the terminal in which
the shell is running. The value affects the behavior of
line-editing.</p>

<p style="margin-top: 1em">YASH_AFTER_CD <br>
The shell interprets and executes the value of this variable
after each time the shell&acirc;s working directory is
changed by the cd or other built-ins. This behavior is <br>
equivalent to executing the command eval -i --
&quot;${YASH_AFTER_CD-}&quot; after the directory was
changed.</p>

<p style="margin-top: 1em">YASH_LOADPATH <br>
This variable specifies directories the dot built-in
searches for a script file. More than one directory can be
specified by separating them by colons like the PATH <br>
variable. When the shell is started, this variable is
initialized to the pathname of the directory where common
script files are installed.</p>

<p style="margin-top: 1em">YASH_LE_TIMEOUT <br>
This variable specifies how long the shell should wait for a
next possible input from the terminal when it encountered an
ambiguous control sequence while line-editing. <br>
The value must be specified in milliseconds. If you do not
define this variable, the default value of 100 milliseconds
is assumed.</p>

<p style="margin-top: 1em">YASH_VERSION <br>
The value is initialized to the version number of the shell
when the shell is started.</p>

<p style="margin-top: 1em">Arrays <br>
An array is a variable that contains zero or more strings.
The string values of an array are identified by natural
numbers (like positional parameters).</p>

<p style="margin-top: 1em">You can assign values to an
array by using a simple command as well as the array
built-in. You can use the unset built-in to remove
arrays.</p>

<p style="margin-top: 1em">Arrays cannot be exported as
arrays. When an array is exported, it is treated as a normal
variable whose value is a concatenation of all the array
values, each separated by a <br>
colon.</p>

<p style="margin-top: 1em">Arrays are not supported in the
POSIXly-correct mode.</p>

<p style="margin-top: 1em">WORD EXPANSIONS <br>
Word expansion is substitution of part of a word with
another particular string. There are seven types of word
expansions:</p>

<p style="margin-top: 1em">1. Tilde expansion</p>

<p style="margin-top: 1em">2. Parameter expansion</p>

<p style="margin-top: 1em">3. Command substitution</p>

<p style="margin-top: 1em">4. Arithmetic expansion</p>

<p style="margin-top: 1em">5. Brace expansion</p>

<p style="margin-top: 1em">6. Field splitting</p>

<p style="margin-top: 1em">7. Pathname expansion
(globbing)</p>

<p style="margin-top: 1em">These types of expansions are
performed in the order specified above.</p>

<p style="margin-top: 1em">Tilde expansion, parameter
expansion, command substitution, and arithmetic expansion
are called the four expansions.</p>

<p style="margin-top: 1em">Tilde expansion <br>
In tilde expansion, parts of words that start with a tilde
(~) are substituted with particular pathnames. The part of
each word that gets substituted is from the beginning of the
<br>
word, which is a tilde, up to (but not including) the first
slash (/) in the word. If the word does not contain a slash,
the whole word is substituted. If any character in the <br>
substituted part is quoted, tilde expansion is not performed
on the word.</p>

<p style="margin-top: 1em">The results of expansion are
determined by the format of the substituted part:</p>

<p style="margin-top: 1em">~ <br>
A single tilde is substituted with the value of the HOME
variable.</p>

<p style="margin-top: 1em">~username <br>
A tilde followed by a user name is substituted with the
pathname of the user&acirc;s home directory.</p>

<p style="margin-top: 1em">~+ <br>
~+ is substituted with the value of the PWD variable.</p>

<p style="margin-top: 1em">~- <br>
~- is substituted with the value of the OLDPWD variable.</p>

<p style="margin-top: 1em">~+n, ~-n <br>
where n is a non-negative integer. This type of tilde
expansion yields the pathname of a directory of which ~+n or
~-n is the index in the directory stack.</p>

<p style="margin-top: 1em">When tilde expansion is
performed on the value of a variable assignment that occurs
during execution of a simple command, the value is
considered as a colon-separated list of <br>
words and those words are each subject to tilde expansion.
For example, the variable assignment</p>

<p style="margin-top: 1em">VAR=~/a:~/b:~/c</p>

<p style="margin-top: 1em">is equivalent to</p>


<p style="margin-top: 1em">VAR=/home/foo/a:/home/foo/b:/home/foo/c</p>

<p style="margin-top: 1em">if the value of HOME variable is
/home/foo.</p>

<p style="margin-top: 1em">The POSIX standard does not
prescribe how the shell should behave when it encounters an
error during tilde expansion (e.g., when the HOME variable
is not defined). Yash silently <br>
ignores any errors during tilde expansion; the part of the
word that would be substituted is left intact.</p>

<p style="margin-top: 1em">In the POSIXly-correct mode,
tilde expansion supports the formats of ~ and ~username
only.</p>

<p style="margin-top: 1em">Parameter expansion <br>
Parameter expansion expands to the value of a parameter.</p>

<p style="margin-top: 1em">The syntax of typical, simple
parameter expansion is ${parameter}, which expands to the
value of the parameter whose name is parameter. You can omit
the braces (e.g., $parameter) <br>
if</p>

<p style="margin-top: 1em">&Acirc;&middot; parameter is a
special parameter,</p>

<p style="margin-top: 1em">&Acirc;&middot; parameter is a
positional parameter whose index is a one-digit integer,
or</p>

<p style="margin-top: 1em">&Acirc;&middot; parameter is a
variable and the parameter expansion is not followed by a
character that can be used as part of a variable name. For
example, ${path}-name is equivalent to <br>
$path-name, but ${path}name and $pathname are different.</p>

<p style="margin-top: 1em">If parameter is none of a
special parameter, positional parameter, and variable, it is
a syntax error. (Some shells other than yash may treat such
a case as an expansion error.)</p>

<p style="margin-top: 1em">If the unset option is disabled
and the parameter is an undefined variable, it is an
expansion error. If the unset option is enabled, an
undefined variable expands to the empty <br>
string.</p>

<p style="margin-top: 1em">More complex syntax of parameter
expansion allows modifying the value of a parameter.</p>

<p style="margin-top: 1em">Parameter expansion <br>
${ prefix parameter index modifier }</p>

<p style="margin-top: 1em">The spaces in the syntax
definition above are for readability only and must be
omitted. You can omit prefix, index, and/or modifier.</p>

<p style="margin-top: 1em">Prefix <br>
The prefix, if any, must be a hash sign (#). If a parameter
expansion has the prefix, the result of expansion is the
number of characters in the value this expansion would be
<br>
expanded to without the prefix.</p>

<p style="margin-top: 1em">Parameter name <br>
The parameter name (parameter) must be either</p>

<p style="margin-top: 1em">&Acirc;&middot; a name of a
special parameter, positional parameter, or variable; or</p>

<p style="margin-top: 1em">&Acirc;&middot; another
parameter expansion, command substitution, or arithmetic
expansion.</p>

<p style="margin-top: 1em">The parameter expansion is
expanded to the value of the parameter. If parameter is an
array variable, the values of the array are field-split like
the @ special parameter <br>
unless the index [*] is specified.</p>

<p style="margin-top: 1em">If parameter is another
expansion, it is called a nested expansion. Nested expansion
cannot be used in the POSIXly-correct mode. The braces ({ })
of a nested parameter <br>
expansion cannot be omitted. <br>
Index.sp An index allows extracting part of the parameter
value (or some of array values).</p>

<p style="margin-top: 1em">Index <br>
[word1]</p>

<p style="margin-top: 1em">[word1,word2]</p>

<p style="margin-top: 1em">where word1 and word2 are parsed
in the same manner as normal tokens except that they are
always delimited by , or ] and can contain whitespace
characters.</p>

<p style="margin-top: 1em">If there is an index in a
parameter expansion, it is interpreted as follows:</p>

<p style="margin-top: 1em">1. Words word1 and word2 are
subjected to parameter expansion, command substitution, and
arithmetic expansion.</p>

<p style="margin-top: 1em">2. If there is no word2 and if
word1 expands to one of *, @, and #, then that is the
interpretation of index and the next step is not taken.</p>

<p style="margin-top: 1em">3. The results of the previous
steps (the expanded word1 and word2) are interpreted and
evaluated as an arithmetic expression in the same manner as
in arithmetic expansion. The <br>
resulting integers are the interpretation of index. If the
results are not integers, it is an expansion error. If there
is no word2, it is assumed that word2 is equal to <br>
word1.</p>

<p style="margin-top: 1em">If parameter is an array
variable, the index specifies the part of the array. If
parameter is either the * or @ special parameter, the index
specifies the index range of <br>
positional parameters. In other cases, the index specifies
the index range of a substring of the parameter value that
is being expanded. In all cases, the specified range of the
<br>
array values, positional parameters, or parameter value
remains in the results of the expansion and other values are
dropped.</p>

<p style="margin-top: 1em">If the interpretation of index
is one or two integers, the following rules apply:</p>

<p style="margin-top: 1em">&Acirc;&middot; If the
interpreted index value is negative, it wraps around. For
example, the index value of -1 corresponds to the last
value/character.</p>

<p style="margin-top: 1em">&Acirc;&middot; It is not an
error when the index value is out of range. Existing
values/characters within the range are just selected.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the
interpretation of either word1 or word2 is 0, the range is
assumed empty and the expansion results in nothing.</p>

<p style="margin-top: 1em">If the interpretation of index
is one of *, @, and #, it is treated as follows:</p>

<p style="margin-top: 1em">* <br>
If parameter is an array, all the array values are
field-split or concatenated in the same manner as the *
special parameter. If parameter is the * or @ special
parameter, <br>
the positional parameters are likewise field-split or
concatenated. In other cases, the interpretation of index is
treated as if the interpretation is the two integers 1 and
<br>
-1.</p>

<p style="margin-top: 1em">@ <br>
The interpretation of index is treated as if the
interpretation is the two integers 1 and -1.</p>

<p style="margin-top: 1em"># <br>
The interpretation of the # index is special in that it does
not simply specify a range. Instead, the expanded values are
substituted with the count.</p>

<p style="margin-top: 1em">If parameter is an array, the
result of this parameter expansion will be the number of
values in the array being expanded. If parameter is the * or
@ special parameter, the <br>
result will be the number of current positional parameters.
Otherwise, the result will be the number of characters in
the value that is being expanded.</p>

<p style="margin-top: 1em">If a parameter expansion does
not contain an index, it is assumed to be [@]. In the
POSIXly-correct mode, index cannot be specified.</p>

<p style="margin-top: 1em">Example 1. Expansion of a normal
variable</p>

<p style="margin-top: 1em">The following commands will
print the string ABC:</p>

<p style="margin-top: 1em">var=&rsquo;123ABC789&rsquo; <br>
echo &quot;${var[4,6]}&quot;</p>

<p style="margin-top: 1em">Example 2. Expansion of
positional parameters</p>

<p style="margin-top: 1em">The following commands will
print the string 2 3 4:</p>

<p style="margin-top: 1em">set 1 2 3 4 5 <br>
echo &quot;${*[2,-2]}&quot;</p>

<p style="margin-top: 1em">Example 3. Expansion of an
array</p>

<p style="margin-top: 1em">The following commands will
print the string 2 3 4:</p>

<p style="margin-top: 1em">array=(1 2 3 4 5) <br>
echo &quot;${array[2,-2]}&quot;</p>

<p style="margin-top: 1em">Modifier <br>
You can modify the value to be expanded by using
modifiers:</p>

<p style="margin-top: 1em">-word <br>
If the parameter name (parameter) is an undefined variable,
the parameter expansion is expanded to word. It is not
treated as an error if the unset option is disabled.</p>

<p style="margin-top: 1em">+word <br>
If the parameter name (parameter) is an existing variable,
the parameter expansion is expanded to word. It is not
treated as an error if the unset option is disabled.</p>

<p style="margin-top: 1em">=word <br>
If the parameter name (parameter) is an undefined variable,
word is assigned to the variable and the parameter expansion
is expanded to word. It is not treated as an <br>
error if the unset option is disabled.</p>

<p style="margin-top: 1em">?word <br>
If the parameter name (parameter) is an undefined variable,
word is printed as an error message to the standard error.
If word is empty, the default error message is <br>
printed instead.</p>

<p style="margin-top: 1em">:-word, :+word, :=word, :?word
<br>
These are similar to the four types of modifiers above. The
only difference is that, if parameter exists and has an
empty value, it is also treated as an undefined <br>
variable.</p>

<p style="margin-top: 1em">#word <br>
The shell performs pattern matching against the value that
is being expanded, using word as a pattern. If word matches
the beginning of the value, the matching part is <br>
removed from the value and the other part remains as
expansion results. The shortest matching is used if more
than one matching is possible.</p>

<p style="margin-top: 1em">##word <br>
This is similar to #word above. The only difference is that
the longest matching is used if more than one matching is
possible.</p>

<p style="margin-top: 1em">%word <br>
This is similar to #word above. The only difference is that
matching is tried at the end of the value rather than at the
beginning: if word matches the end of the value, <br>
the matching part is removed from the value and the other
part remains as expansion results.</p>

<p style="margin-top: 1em">%%word <br>
This is similar to %word above. The only difference is that
the longest matching is used if more than one matching is
possible.</p>

<p style="margin-top: 1em">/word1/word2 <br>
The shell performs pattern matching against the value that
is being expanded, using word1 as a pattern. If word1
matches any part of the value, the matching part is <br>
replaced with word2 and the whole value after the
replacement remains as expansion results. If word1 matches
more than one part of the value, only the first part is <br>
replaced. The shortest matching is replaced if more than one
matching is possible for the same starting point in the
value.</p>

<p style="margin-top: 1em">This modifier cannot be used in
the POSIXly-correct mode.</p>

<p style="margin-top: 1em">/#word1/word2 <br>
This is similar to /word1/word2 above. The only difference
is that word1 matches only at the beginning of the value
being expanded.</p>

<p style="margin-top: 1em">/%word1/word2 <br>
This is similar to /word1/word2 above. The only difference
is that word1 matches only at the end of the value being
expanded.</p>

<p style="margin-top: 1em">//word1/word2 <br>
This is similar to /word1/word2 above. The only difference
is that all matched parts are replaced if word1 matches more
than one part of the value.</p>

<p style="margin-top: 1em">:/word1/word2 <br>
This is similar to /word1/word2 above. The only difference
is that the value is replaced only when word1 matches the
whole value.</p>

<p style="margin-top: 1em">In all types of modifiers above,
words are subjected to the four expansions when (and only
when) they are used.</p>

<p style="margin-top: 1em">If parameter is an array
variable or the @ or * special parameter, modifiers affect
each value of the array or all positional parameters.</p>

<p style="margin-top: 1em">Command substitution <br>
Command substitution expands to output of commands
specified.</p>

<p style="margin-top: 1em">Command substitution <br>
$(commands)</p>

<p style="margin-top: 1em">&lsquo;commands&lsquo;</p>

<p style="margin-top: 1em">When command substitution is
evaluated, commands are executed by a subshell with output
pipelined to the shell. When the commands finished, command
substitution is substituted <br>
with the output of the commands. Any trailing newline
characters in the output are ignored.</p>

<p style="margin-top: 1em">When command substitution of the
form $(commands) is parsed, the commands are parsed
carefully so that complex commands such as nested command
substitution are parsed correctly. <br>
If commands start with (, you should put a space before
commands so that the whole command substitution is not
confused with arithmetic expansion. If the shell is in the
<br>
POSIXly-correctly mode, the commands are parsed each time
the command substitution is expanded; otherwise, commands
are parsed only when the command substitution is parsed.</p>

<p style="margin-top: 1em">If command substitution is of
the form &lsquo;commands&lsquo;, the commands are not parsed
when the command substitution is parsed. The end of commands
is detected by the first backquote <br>
character (&lsquo;) after the beginning of commands that is
not quoted by a backslash. Backquotes that are part of
commands (typically used for nested command substitution)
must be <br>
quoted by backslashes. The commands are parsed each time the
command substitution is expanded.</p>

<p style="margin-top: 1em">Arithmetic expansion <br>
Arithmetic expansion evaluates an arithmetic expression and
expands to the value of the expression.</p>

<p style="margin-top: 1em">Arithmetic expansion <br>
$((expression))</p>

<p style="margin-top: 1em">When arithmetic expansion is
expanded, the expression is subject to parameter expansion,
command substitution, and (nested) arithmetic expansion. The
expression is parsed in <br>
(almost) same manner as an expression of the C programming
language.</p>

<p style="margin-top: 1em">Yash allows an expression to be
either an integer (of the long type in C) or a
floating-point number (of the double type in C). An
operation on integers yields an integer and an <br>
operation involving a floating-point number yields a
floating-point number. In the POSIXly-correct mode, you can
use integers only.</p>

<p style="margin-top: 1em">The following operators are
available (in the order of precedence):</p>

<p style="margin-top: 1em">1. ( )</p>

<p style="margin-top: 1em">2. ++ -- (postfix operators)</p>

<p style="margin-top: 1em">3. ++ -- + - ~ ! (prefix
operators)</p>

<p style="margin-top: 1em">4. * / %</p>

<p style="margin-top: 1em">5. + - (binary operators)</p>

<p style="margin-top: 1em">6. &lt;&lt; &gt;&gt;</p>

<p style="margin-top: 1em">7. &lt; &lt;= &gt; &gt;=</p>

<p style="margin-top: 1em">8. == !=</p>

<p style="margin-top: 1em">9. &amp;</p>

<p style="margin-top: 1em">10. ^</p>

<p style="margin-top: 1em">11. |</p>

<p style="margin-top: 1em">12. &amp;&amp;</p>

<p style="margin-top: 1em">13. ||</p>

<p style="margin-top: 1em">14. ? :</p>

<p style="margin-top: 1em">15. = *= /= %= += -= &lt;&lt;=
&gt;&gt;= &amp;= ^= |=</p>

<p style="margin-top: 1em">The ++ and -- operators cannot
be used in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">An atomic expression can be one
of an integer literal, a floating-point number literal, and
a variable. Literals are parsed in the same manner as in C.
An octal integer literal <br>
starts with 0, and hexadecimal with 0x. A floating-point
number literal may have an exponent (i.e. 1.23e+6). A
variable with a non-numeric value will result in an error
when <br>
parsed as a number. An unset variable is treated as a value
of zero.</p>

<p style="margin-top: 1em">In the POSIXly-correct mode,
variables are always parsed as numbers. Otherwise, variables
are parsed only when they are used as numbers in
computation. Unparsed variables are <br>
left intact.</p>

<p style="margin-top: 1em">set +o posixly-correct <br>
foo=bar <br>
echo $((0 ? foo : foo)) # prints &quot;bar&quot; <br>
echo $((foo + 0)) # error</p>

<p style="margin-top: 1em">Brace expansion <br>
Brace expansion expands to several split words with
preceding and succeeding portions duplicated to each split
words. Brace expansion is expanded only when the
brace-expand <br>
option is enabled.</p>

<p style="margin-top: 1em">Comma-separated brace expansion
<br>
{word1,word2,...,wordn}</p>

<p style="margin-top: 1em">Range brace expansion <br>
{start..end}</p>

<p style="margin-top: 1em">{start..end..delta}</p>

<p style="margin-top: 1em">Comma-separated brace expansion
is expanded to each comma-separated word. For example,
a{1,2,3}b is expanded to the three words a1b, a2b, and
a3b.</p>

<p style="margin-top: 1em">Range brace expansion is
expanded to integers in the range defined by start and end.
The difference between each integer can be defined by delta.
If start is larger than end, the <br>
results will be in descending order. When ..delta is
omitted, it defaults to 1 or -1. For example, a{1..3}b is
expanded to the three words a1b, a2b, and a3b; and
a{1..7..2}b to <br>
the four words a1b, a3b, a5b, and a7b.</p>

<p style="margin-top: 1em">Multiple brace expansions can be
used in one word. Brace expansions can also be nested. You
can quote braces and/or commas to prevent them from being
treated as brace expansion.</p>

<p style="margin-top: 1em">Any errors in brace expansion
are silently ignored.</p>

<p style="margin-top: 1em">Field splitting <br>
In field splitting, words are split at predefined
separators.</p>

<p style="margin-top: 1em">Field splitting can occur only
within parts of words that resulted from parameter
expansion, command substitution, and arithmetic expansion
that are not between double-quotation <br>
marks. Expansion results of the @ special parameter are
exceptionally split even between double-quotation marks.</p>

<p style="margin-top: 1em">Separators used in field
splitting are defined by the value of the IFS variable. If
the variable does not exist, the value is assumed to be the
three characters of space, tab, <br>
and newline.</p>

<p style="margin-top: 1em">Characters included in the value
of the IFS variable are called IFS characters. IFS
characters that are any of space, tab, and newline are
called IFS whitespace and other IFS <br>
characters are called IFS non-whitespace.</p>

<p style="margin-top: 1em">Field splitting is performed as
follows:</p>

<p style="margin-top: 1em">1. The shell searches words for
split points. A split point is one or more adjacent IFS
characters within the word portions where field splitting
can occur. The following steps <br>
are taken for each split point found.</p>

<p style="margin-top: 1em">2. If the split point includes
one or more IFS non-whitespaces, all the IFS whitespaces in
the split point are ignored and the word is split at each
IFS non-whitespace in the <br>
split point.</p>

<p style="margin-top: 1em">3. If the split point includes
no IFS non-whitespaces, the word is split at the split point
unless it is at the beginning or end of the word.</p>

<p style="margin-top: 1em">4. The split points are removed
from the results.</p>

<p style="margin-top: 1em">Finally, the last word is
removed from the results if:</p>

<p style="margin-top: 1em">&Acirc;&middot; the
empty-last-field option is not enabled;</p>

<p style="margin-top: 1em">&Acirc;&middot; the result is
more than one word; and</p>

<p style="margin-top: 1em">&Acirc;&middot; the last word is
empty.</p>

<p style="margin-top: 1em">Note <br>
Words are not split at all when the value of the IFS
variable is empty.</p>

<p style="margin-top: 1em">Pathname expansion <br>
Pathname expansion performs pattern matching and expands to
pathnames matched by the pattern.</p>

<p style="margin-top: 1em">A word subjected to pathname
expansion is treated as a pattern. If one or more pathnames
are found that are matched by the pattern, the pathnames
become the results of the <br>
pathname expansion.</p>

<p style="margin-top: 1em">Pathname expansion is not
performed when the glob option is disabled.</p>

<p style="margin-top: 1em">The shell searches readable
directories for matching pathnames. Unreadable directories
are silently ignored.</p>

<p style="margin-top: 1em">The following options affect the
behavior of pathname expansion:</p>

<p style="margin-top: 1em">null-glob <br>
This option affects the result of pathname expansion when no
matching pathnames are found. If enabled, the result is no
word. If disabled, the result is the original pattern <br>
word.</p>

<p style="margin-top: 1em">case-glob <br>
This option specifies case-sensitivity in matching. If
enabled, pattern matching is done case-sensitively.</p>

<p style="margin-top: 1em">dot-glob <br>
This option affects matching of filenames that start with a
period (.). If disabled, a period at the beginning of a
filename does not match wildcard patterns (? and *) or <br>
bracket expressions. If enabled, there is no such special
treatment of periods.</p>

<p style="margin-top: 1em">mark-dirs <br>
If enabled, each resulting pathname that is a directory name
is suffixed by a slash (/).</p>

<p style="margin-top: 1em">extended-glob <br>
This option enables the extension. (See below)</p>

<p style="margin-top: 1em">Any errors in pathname expansion
are silently ignored. If the word is an invalid pattern, it
just becomes the result. The results depend on the null-glob
option when no matching <br>
pathnames are found.</p>

<p style="margin-top: 1em">Pattern matching is done for
each filename (or pathname component) of pathnames. The
shell skips matching for literal patterns that contain no
wildcards or bracket expressions. <br>
As a result, the patterns /*/foo and /*/fo[o] may yield
different expansion results when the case-glob option is
disabled; for example, the pattern /*/fo[o] matches the
pathname <br>
/bar/FOO but the pattern /*/foo does not because matching is
skipped for foo.</p>

<p style="margin-top: 1em">Extension in pathname expansion
<br>
The following patterns can be used when the extended-glob
option is enabled.</p>

<p style="margin-top: 1em">** <br>
The directory is searched recursively and the pattern
matches any number of directory filenames (each separated by
a slash). Any directory whose name begins with a period <br>
is excluded from search. For example, the pattern
dir/**/file can match the pathnames dir/file, dir/foo/file,
dir/a/b/c/file, etc.</p>

<p style="margin-top: 1em">This pattern is not effective
when appearing at the end of the whole pattern (i.e.
foo/bar/**).</p>

<p style="margin-top: 1em">.** <br>
This pattern is like **, but all directories are searched
including ones with a name starting with a period.</p>

<p style="margin-top: 1em">*** <br>
This pattern is like **, but if a symbolic link to a
directory is found during recursive search, the directory is
searched recursively as well.</p>

<p style="margin-top: 1em">.*** <br>
This pattern is like ***, but all directories are searched
including ones with a name starting with a period.</p>

<p style="margin-top: 1em">PATTERN MATCHING NOTATION <br>
Pattern matching notation is a syntax of patterns that
represent particular sets of strings. When a string is
included in the set of strings a pattern represents, the
pattern is <br>
said to match the string. Whether a pattern matches a string
or not is defined as follows.</p>

<p style="margin-top: 1em">Normal characters <br>
A character that is not quoted or any of special characters
defined below is a normal character, which matches the
character itself.</p>

<p style="margin-top: 1em">For example, the pattern abc
matches the string abc, and not any other strings.</p>

<p style="margin-top: 1em">Single-character wildcard <br>
The character ? matches any single character.</p>

<p style="margin-top: 1em">For example, the pattern a?c
matches any three-character strings that starts with a and
ends with c, such as aac, abc, and a;c.</p>

<p style="margin-top: 1em">Multi-character wildcard <br>
The character * matches any strings (of any length,
including the empty string).</p>

<p style="margin-top: 1em">For example, the pattern a*c
matches any string that starts with a and ends with c, such
as ac, abc, and a;xyz;c.</p>

<p style="margin-top: 1em">Bracket expression <br>
A pattern that is enclosed by brackets ([ and ]) is a
bracket expression. A bracket expression must have at least
one character between the brackets. The characters between
the <br>
brackets are interpreted as a bracket expression pattern,
which is a below-defined special notation for bracket
expression. A bracket expression pattern represents a set of
<br>
characters. The bracket expression matches any one of the
characters in the set the bracket expression pattern
represents.</p>

<p style="margin-top: 1em">If the opening bracket ([) is
followed by an exclamation mark (!), the exclamation is not
treated as part of the bracket expression pattern and the
whole bracket expression <br>
instead matches a character that is not included in the set
the bracket expression pattern represents. If the opening
bracket is followed by a caret (^), it is treated like an
<br>
exclamation mark as above (but shells other than yash may
treat the caret differently).</p>

<p style="margin-top: 1em">If the opening bracket (or the
following exclamation or caret, if any) is followed by a
closing bracket (]), it is treated as part of the bracket
expression pattern rather than <br>
the end of the bracket expression. You cannot quote
characters in the bracket expression pattern because
quotation is treated before bracket expression.</p>

<p style="margin-top: 1em">An opening bracket in a pattern
is treated as a normal character if it is not the beginning
of a valid bracket expression.</p>

<p style="margin-top: 1em">Normal characters (in bracket
expression pattern) <br>
A character that is not any of special characters defined
below is a normal character, which represents the character
itself.</p>

<p style="margin-top: 1em">For example, the bracket
expression pattern abc represents the set of the three
characters a, b, and c. The bracket expression [abc]
therefore matches any of the three <br>
characters.</p>

<p style="margin-top: 1em">Range expressions <br>
A hyphen preceded and followed by a character (or collating
symbol) is a range expression, which represents the set of
the two characters and all characters between the two in
<br>
the collation order. A collation order is an order of
characters that is defined in the locale data.</p>

<p style="margin-top: 1em">If a hyphen is followed by a
closing bracket (]), the bracket is treated as the end of
the bracket expression and the hyphen as a normal
character.</p>

<p style="margin-top: 1em">For example, the range
expression 3-5 represents the set of the three characters 3,
4, and 5. The bracket expression [3-5-] therefore matches
one of the four characters 3, 4, 5, <br>
and -.</p>

<p style="margin-top: 1em">Collating symbols <br>
A collating symbol allows more than one character to be
treated as a single character in matching. A collating
symbol is made up of one or more characters enclosed by the
special <br>
brackets [. and .].</p>

<p style="margin-top: 1em">One or more characters that are
treated as a single character in matching are called a
collating element. Precisely, a bracket expression pattern
represents a set of collating <br>
elements and a bracket expression matches a collating
element rather than a character, but we do not differentiate
them for brevity here.</p>

<p style="margin-top: 1em">For example, the character
combination &acirc;ch&acirc; was treated as a single
character in the traditional Spanish language. If this
character combination is registered as a collating <br>
element in the locale data, the bracket expression
[[.ch.]df] matches one of ch, d, and f.</p>

<p style="margin-top: 1em">Equivalence classes <br>
An equivalence class represents a set of characters that are
considered equivalent. A equivalence class is made up of a
character (or more precisely, a collating element) <br>
enclosed by the special brackets [= and =].</p>

<p style="margin-top: 1em">An equivalence class represents
the set of characters that consists of the character
enclosed by the brackets and the characters that are in the
same primary equivalence class as <br>
the enclosed character. The shell consults the locale data
for the definition of equivalence classes in the current
locale.</p>

<p style="margin-top: 1em">For example, if the six
characters a, &Atilde;&nbsp;, &Atilde;&iexcl;,
&Atilde;&cent;, &Atilde;&pound;, &Atilde;&curren; are
defined to be in the same primary equivalence class, the
bracket expressions [[=a=]], [[=&Atilde;&nbsp;=]], and
[[=&Atilde;&iexcl;=]] match one of <br>
the six.</p>

<p style="margin-top: 1em">Character classes <br>
A character class represents a predefined set of characters.
A character class is made up of a class name enclosed by the
special brackets [: and :]. The shell consults the <br>
locale data for which class a character belongs to.</p>

<p style="margin-top: 1em">The following character classes
can be used in all locales:</p>

<p style="margin-top: 1em">[:lower:] <br>
set of lowercase letters</p>

<p style="margin-top: 1em">[:upper:] <br>
set of uppercase letters</p>

<p style="margin-top: 1em">[:alpha:] <br>
set of letters, including the [:lower:] and [:upper:]
classes.</p>

<p style="margin-top: 1em">[:digit:] <br>
set of decimal digits</p>

<p style="margin-top: 1em">[:xdigit:] <br>
set of hexadecimal digits</p>

<p style="margin-top: 1em">[:alnum:] <br>
set of letters and digits, including the [:alpha:] and
[:digit:] classes.</p>

<p style="margin-top: 1em">[:blank:] <br>
set of blank characters, not including the newline
character</p>

<p style="margin-top: 1em">[:space:] <br>
set of space characters, including the newline character</p>

<p style="margin-top: 1em">[:punct:] <br>
set of punctuations</p>

<p style="margin-top: 1em">[:print:] <br>
set of printable characters</p>

<p style="margin-top: 1em">[:cntrl:] <br>
set of control characters</p>

<p style="margin-top: 1em">For example, the bracket
expression [[:lower:][:upper:]] matches a lower or upper
case character. In addition to the classes listed above,
other classes may be used depending on <br>
the definition of the current locale.</p>

<p style="margin-top: 1em">REDIRECTION <br>
Redirection is a feature you can use to modify file
descriptors of commands. By using redirection, you can
execute commands with their standard input/output connected
with files <br>
or devices other than the terminal.</p>

<p style="margin-top: 1em">You can do redirection by adding
redirection operators to a command (simple command or
compound command) In a simple command, redirection operators
may appear anywhere in the <br>
command as long as operator tokens are separated from other
tokens. In a compound command, redirection operators must
appear at the end of the command.</p>

<p style="margin-top: 1em">Redirection operators are
processed before the command body is executed. More than one
redirection operator in a command are processed in the order
of appearance. Redirection <br>
operators affect only the command in which they appear,
except when they appear in an exec built-in without command
operands. That is, file descriptors modified by redirection
<br>
are restored after the command has finished.</p>

<p style="margin-top: 1em">A redirection operator starts
with &lt; or &gt;. Redirection operators starting with &lt;
affects the standard input (file descriptor 0) by default.
Redirection operators starting with &gt; <br>
affects the standard output (file descriptor 1) by default.
To affect another file descriptor, you can prefix a
redirection operator with a non-negative integer; the
operator <br>
will affect the file descriptor specified by the integer.
The integer must immediately precede the &lt; or &gt;
without any whitespaces in between. The integer must not be
quoted, <br>
either.</p>

<p style="margin-top: 1em">Redirection to files <br>
The most common type of redirection is redirection to
files.</p>

<p style="margin-top: 1em">Redirection of input <br>
&lt; token</p>

<p style="margin-top: 1em">Redirection of output <br>
&gt; token</p>

<p style="margin-top: 1em">&gt;| token</p>

<p style="margin-top: 1em">&gt;&gt; token</p>

<p style="margin-top: 1em">Redirection of input and output
<br>
&lt;&gt; token</p>

<p style="margin-top: 1em">The token is subject to the four
expansions. It is also subject to pathname expansion if the
shell is interactive. The expansion result is treated as the
pathname of the file to <br>
which redirection is performed. If the pathname expansion
does not result in a single pathname, it is an error.</p>

<p style="margin-top: 1em">In redirection of input, the
standard input is replaced with a file descriptor which is
open for read-only access to the target file. If the target
file cannot be opened for <br>
read-only access, it is an error.</p>

<p style="margin-top: 1em">In redirection of output, the
standard output is replaced with a file descriptor which is
open for write-only access to the target file. If the target
file cannot be opened for <br>
write-only access, it is an error. If the target file does
not exist, a new empty file is created and opened. If the
target file already exists, the file is opened as
follows:</p>

<p style="margin-top: 1em">&Acirc;&middot; For the &gt;|
operator, the file is emptied when opened if it is a regular
file.</p>

<p style="margin-top: 1em">&Acirc;&middot; For the &gt;
operator, the behavior is the same as the &gt;| operator if
the clobber option is enabled. If the option is disabled and
the file is a regular file, it is treated as <br>
an error.</p>

<p style="margin-top: 1em">&Acirc;&middot; For the &gt;&gt;
operator, the file is opened for appending; any output to
the file descriptor is appended to the end of the file.</p>

<p style="margin-top: 1em">In redirection of input and
output, the standard input is replaced with a file
descriptor which is open for read-and-write access to the
target file. If the file does not exist, <br>
a new empty file is created and opened.</p>

<p style="margin-top: 1em">Socket redirection <br>
If the pathname of the target file is of the form
/dev/tcp/host/port or /dev/udp/host/port and the file cannot
be opened in the usual manner, a new socket is opened for
<br>
communication with the port of the host. The redirection
replaces the standard input or output with the file
descriptor to the socket.</p>

<p style="margin-top: 1em">A stream socket is opened for
the form /dev/tcp/host/port and a datagram socket for the
form /dev/udp/host/port. The protocol actually used for
communication is determined by <br>
the socket library the shell uses. Typically, stream sockets
use TCP and datagram sockets UDP.</p>

<p style="margin-top: 1em">In socket redirection, the file
descriptor is both readable and writable regardless of the
type of the redirection operator used.</p>

<p style="margin-top: 1em">Socket redirection is
yash&acirc;s extension that is not defined in POSIX. Bash as
well has socket redirection as extension.</p>

<p style="margin-top: 1em">Duplication of file descriptors
<br>
Redirection allows duplicating or closing existing file
descriptors.</p>

<p style="margin-top: 1em">Duplication of file descriptor
<br>
&lt;&amp; token</p>

<p style="margin-top: 1em">&gt;&amp; token</p>

<p style="margin-top: 1em">The token is subject to
expansion as in redirection to files, but it is treated as a
file descriptor rather than a pathname. Thus the expanded
token must be a non-negative <br>
integer.</p>

<p style="margin-top: 1em">The &lt;&amp; and &gt;&amp;
operators duplicate the file descriptor specified by token
to the standard input and output, respectively. (The
operators can be prefixed with a non-negative <br>
integer so that the file descriptor is duplicated to a file
descriptor other than the standard input or output.)</p>

<p style="margin-top: 1em">If the expanded token is a
single hyphen rather than a non-negative integer, the file
descriptor is closed rather than duplicated. By default, the
&lt;&amp; and &gt;&amp; operators close the <br>
standard input and output, respectively, but the operators
can be prefixed with a non-negative integer so that another
file descriptor is closed.</p>

<p style="margin-top: 1em">In the POSIXly-correct mode, a
file descriptor must be readable when duplicated by the
&lt;&amp; operator and writable when duplicated by the
&gt;&amp; operator.</p>

<p style="margin-top: 1em">Here documents and here strings
<br>
Here document and here string allow redirection to file
descriptors that reads strings directly specified in shell
commands.</p>

<p style="margin-top: 1em">Here document <br>
&lt;&lt; token</p>

<p style="margin-top: 1em">&lt;&lt;- token</p>

<p style="margin-top: 1em">Here string <br>
&lt;&lt;&lt; token</p>

<p style="margin-top: 1em">In a here document or here
string, the standard input is replaced with a readable file
descriptor. When the command reads from the file descriptor,
it will read the contents of <br>
the here document/string, which is defined below.</p>

<p style="margin-top: 1em">When a here document operator
(&lt;&lt; or &lt;&lt;-) appears in a command, the shell
reads the contents of the here document starting from the
next line. The contents of here documents are <br>
not parsed nor executed as commands. The token after the
operand specifies a delimiter that indicates the end of the
contents. (The token is not subject to any expansion, but
<br>
quotation is processed.) The contents of the here document
is terminated just before the first line containing the
token only. When using the &lt;&lt;- operator, all tab
characters at <br>
the beginning of each line in the here document contents are
removed and the delimiter token may be preceded by tab
characters.</p>

<p style="margin-top: 1em">If there are more than one here
document operator on one line, the contents of the here
documents are parsed in order: The contents of the first
here document starts from the <br>
next line and ends before the first line containing the
token that followed the first operator. Just after that
line, the contents of the second here document starts, and
so on.</p>

<p style="margin-top: 1em">The contents of here documents
are treated literally: whitespaces, tabs, etc. remain as is.
The exception is that, when the token is not quoted at
all:</p>

<p style="margin-top: 1em">&Acirc;&middot; the contents are
subject to parameter expansion, command substitution,
arithmetic expansion.</p>

<p style="margin-top: 1em">&Acirc;&middot; a backslash in
the contents is treated as quotation if and only if it
precedes $, &lsquo;, &quot;, or another backslash.</p>

<p style="margin-top: 1em">&Acirc;&middot; a backslash
followed by a newline is treated as line continuation.</p>

<p style="margin-top: 1em">In here string, the token after
the operator is subject to expansion as in redirection to
files. The expansion result becomes the contents of the here
string. A newline character <br>
is automatically appended to the end of here string
contents.</p>

<p style="margin-top: 1em">Here string is yash&acirc;s
extension that is not defined in POSIX. Other shells like
bash, ksh, and zsh have the same feature.</p>

<p style="margin-top: 1em">Pipeline redirection <br>
Pipeline redirection allows opening pipelines that can be
used for arbitrary purposes.</p>

<p style="margin-top: 1em">Pipeline redirection <br>
&gt;&gt;| token</p>

<p style="margin-top: 1em">The token is subject to
expansion as in redirection to files, but it is treated as a
file descriptor rather than a pathname. Thus the expanded
token must be a non-negative <br>
integer.</p>

<p style="margin-top: 1em">Pipeline redirection opens a new
pipeline. The standard output (or the file descriptor
specified before the operator, if any) is replaced with the
file descriptor open for <br>
writing to the pipeline. The file descriptor specified by
token is replaced with the file descriptor open for reading
from the pipeline.</p>

<p style="margin-top: 1em">Pipeline redirection is
yash&acirc;s extension that is not defined in POSIX.</p>

<p style="margin-top: 1em">Process redirection <br>
Process redirection creates a pipeline connected to another
command.</p>

<p style="margin-top: 1em">Process redirection <br>
&lt;(command...)</p>

<p style="margin-top: 1em">&gt;(command...)</p>

<p style="margin-top: 1em">In process redirection, the
command specified is executed in a subshell. If the process
redirection is of the form &lt;(command...), the standard
output of command is connected with <br>
a pipeline to the standard input of the command the
redirection is associated with. If the process redirection
is of the form &gt;(command...), the standard input of
command is <br>
connected with a pipeline to the standard output of the
command the redirection is associated with.</p>

<p style="margin-top: 1em">Process redirection is
yash&acirc;s extension that is not defined in POSIX. Bash
and zsh have a feature called process substitution, which
uses the same syntax as yash&acirc;s process <br>
redirection, but incompatibly differs in behavior.</p>

<p style="margin-top: 1em">COMMAND EXECUTION <br>
This section describes how commands are executed.</p>

<p style="margin-top: 1em">Execution of simple commands
<br>
A simple command is executed as follows:</p>

<p style="margin-top: 1em">1. All tokens in the simple
command are expanded except for assignment and redirection
tokens. If an error occurs during expansion, the execution
of the simple command is <br>
aborted with a non-zero exit status.</p>

<p style="margin-top: 1em">In the following steps, the
first word of the expansion results is referred to as
command name, and the other words as command arguments. If
there is only one word of the <br>
expansion results, there are no command argument words. If
there are none of the expansion results, there is no command
name either.</p>

<p style="margin-top: 1em">2. Redirection specified in the
command, if any, is processed. The word token after each
redirection operator is expanded. If an error occurs during
processing redirection <br>
(including when expanding the word token), the execution of
this simple command is aborted with a non-zero exit
status.</p>

<p style="margin-top: 1em">3. Assignments specified in the
command, if any, are processed. For each assignment token,
the value is expanded and assigned to the specified
variable. If an error occurs <br>
during assignments (including when expanding the values to
be assigned), the execution of this simple command is
aborted with a non-zero exit status.</p>

<p style="margin-top: 1em">&Acirc;&middot; If there is no
command name or the name denotes a special built-in, the
assignments are permanent: the assigned values remain after
the command has finished (until the <br>
variable is reassigned).</p>

<p style="margin-top: 1em">&Acirc;&middot; Otherwise, the
assignments are temporary: the assigned values only last
during the execution of this simple command.</p>

<p style="margin-top: 1em">The assigned variables are
automatically exported when the command name is specified or
the all-export option is enabled.</p>

<p style="margin-top: 1em">Note <br>
In other shells, assignments may behave differently: For
special built-ins and functions, assigned variables may not
be exported. For functions, assigned variables may be <br>
persistent, that is, may remain even after the execution of
the simple command.</p>

<p style="margin-top: 1em">4. If there is no command name,
the command execution ends with the exit status of zero
(unless there are any command substitutions in the command,
in which case the exit status <br>
of the simple command is that of the last executed command
substitution).</p>

<p style="margin-top: 1em">5. A command to be executed is
determined using the command search algorithm and the
command is executed.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the command
is an external command, the command is executed by creating
a new subshell and calling the &acirc;exec&acirc; system
call in the subshell. The command name and <br>
arguments are passed to the executed command. Exported
variables are passed to the executed command as environment
variables.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the command
is a built-in, the built-in is executed with the command
arguments passed to the built-in.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the command
is a function, the contents of the function are executed
with the command arguments as function arguments.</p>

<p style="margin-top: 1em">If the command was executed, the
exit status of this simple command is that of the executed
command. If the algorithm failed to determine a command, no
command is executed <br>
and the exit status is 127. If the shell failed to execute
the determined command, the exit status is 126. If the
executed command was killed by a signal, the exit status is
<br>
the signal number plus 384.</p>

<p style="margin-top: 1em">Note <br>
In shells other than yash, the exit status may be different
when the command was killed by a signal, because the POSIX
standard only requires that the exit status be <br>
&quot;greater than 128.&quot; <br>
If the shell is not in the POSIXly-correct mode and the
algorithm failed to determine a command, the command eval -i
-- &quot;${COMMAND_NOT_FOUND_HANDLER-}&quot; is evaluated.
During <br>
the command execution, positional parameters are temporarily
set to the command name and arguments that resulted in the
first step. Any local variables defined during the <br>
execution are removed when the execution is finished. The
HANDLED local variable is automatically defined with the
initial value being the empty string. If the HANDLED <br>
variable has a non-empty value when the execution of the
command string is finished, the shell pretends that the
command was successfully determined and executed. The exit
<br>
status of the simple command is that of the command string
in this case.</p>

<p style="margin-top: 1em">Command search <br>
A command that is executed in a simple command is determined
by the command name using the following algorithm:</p>

<p style="margin-top: 1em">1. If the command name contains
a slash (/), the whole name is treated as the pathname of an
external command. The external command is determined as the
executed command.</p>

<p style="margin-top: 1em">2. If the command name is a
special built-in, the built-in is determined as the executed
command.</p>

<p style="margin-top: 1em">3. If the command name is the
name of an existing function, the function is determined as
the executed command.</p>

<p style="margin-top: 1em">4. If the command name is a
semi-special built-in, the built-in is determined as the
executed command.</p>

<p style="margin-top: 1em">5. If the command name is a
regular built-in, the built-in is determined as the executed
command unless the shell is in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">6. The shell searches the PATH
for a executed command:</p>

<p style="margin-top: 1em">The value of the PATH variable
is separated by colons. Each separated part is considered as
a directory pathname (an empty pathname denotes the current
working <br>
directory). The shell searches the directories (in the order
of appearance) and checks if any directory directly contains
an executable regular file whose name is equal <br>
to the command name. If such a file is found:</p>

<p style="margin-top: 1em">&Acirc;&middot; If the command
name is the name of a built-in, the built-in is determined
as the executed command.</p>

<p style="margin-top: 1em">&Acirc;&middot; Otherwise, the
file is determined as the executed command. (The file will
be executed as an external command.)</p>

<p style="margin-top: 1em">If no such file is found, no
command is determined as the executed command.</p>

<p style="margin-top: 1em">When the shell finds a file that
matches the command name during the search above, the shell
remembers the pathname of the file if it is an absolute
path. When the algorithm <br>
above is used for the same command name again, the shell
skips searching and directly determines the command to be
executed. If an executable regular file no longer exists at
<br>
the remembered pathname, however, the shell searches again
to update the remembered pathname. You can manage remembered
pathnames using the hash built-in.</p>

<p style="margin-top: 1em">Termination of the shell <br>
The shell exits when it reached the end of input and has
parsed and executed all input commands or when the exit
built-in is executed. The exit status of the shell is that
of the <br>
last command the shell executed (or zero if no commands were
executed). The exit status of the shell is always between 0
and 255 (inclusive). If the exit status of the last <br>
command is 256 or larger, the exit status of the shell will
be the remainder of the exit status divided by 256.</p>

<p style="margin-top: 1em">If an exit handler has been
registered by the trap built-in, the handler is executed
just before the shell exits. The exit status of the commands
executed in the handler does not <br>
affect the exit status of the shell.</p>

<p style="margin-top: 1em">If a non-interactive shell
encountered one of the following errors, the shell
immediately exits with a non-zero exit status:</p>

<p style="margin-top: 1em">&Acirc;&middot; A command cannot
be parsed due to an syntax error (except during shell
initialization).</p>

<p style="margin-top: 1em">&Acirc;&middot; An error occurs
during execution of a special built-in in the
POSIXly-correct mode.</p>

<p style="margin-top: 1em">&Acirc;&middot; A redirection
error occurs in a simple command whose command name is a
special built-in and the shell is in the POSIXly-correct
mode.</p>

<p style="margin-top: 1em">&Acirc;&middot; An assignment
error occurs in a simple command.</p>

<p style="margin-top: 1em">&Acirc;&middot; An error occurs
during expansion (except during shell initialization).</p>

<p style="margin-top: 1em">Note <br>
Some shells other than yash exit when they fail to find a
command to execute in command search.</p>

<p style="margin-top: 1em">Functions <br>
Functions allow executing a compound command as a simple
command. A function can be defined by the function
definition command and executed by a simple command. You can
use the <br>
unset built-in to remove function definitions.</p>

<p style="margin-top: 1em">There are no functions
predefined when yash is started.</p>

<p style="margin-top: 1em">A function is executed by
executing its body, which is a compound command. While the
function is being executed, positional parameters are set to
the arguments given to the <br>
function. The old positional parameters are restored when
the function execution finishes.</p>

<p style="margin-top: 1em">Local variables <br>
Local variables are temporary variables that are defined in
a function and exist during the function execution only.
They can be defined by the typeset built-in. They are <br>
removed when the function execution finishes.</p>

<p style="margin-top: 1em">Local variables may hide
variables that have already been defined before the function
execution had started. An existing variable becomes
inaccessible if a local variable of <br>
the same name is defined in a function. The old variable
becomes accessible again when the function execution
finishes.</p>

<p style="margin-top: 1em">You cannot create a local
variable when not executing a function. A normal variable is
created if you try to do so.</p>

<p style="margin-top: 1em">Command execution environment
<br>
The shell holds following properties during execution.</p>

<p style="margin-top: 1em">&Acirc;&middot; The working
directory</p>

<p style="margin-top: 1em">&Acirc;&middot; Open file
descriptors</p>

<p style="margin-top: 1em">&Acirc;&middot; The file
creation mask (umask)</p>

<p style="margin-top: 1em">&Acirc;&middot; The set of
signals whose handler is set to &acirc;ignore&acirc;
(trap)</p>

<p style="margin-top: 1em">&Acirc;&middot; Environment
variables</p>

<p style="margin-top: 1em">&Acirc;&middot; Resource limits
(ulimit)</p>

<p style="margin-top: 1em">Those properties are inherited
from the invoker of the shell to the shell, and from the
shell to each external command executed by the shell.</p>

<p style="margin-top: 1em">The properties can be changed
during the execution of the shell by built-in commands,
variable assignments, etc.</p>

<p style="margin-top: 1em">Subshells <br>
A subshell is a copy of the shell process. Subshells are
used in execution of groupings, pipelines, etc.</p>

<p style="margin-top: 1em">Subshells inherit functions,
aliases, etc. defined in the shell as well as the properties
above since subshells are copies of the shell process.
Notable exceptions are:</p>

<p style="margin-top: 1em">&Acirc;&middot; Traps registered
by the trap built-in are all reset in subshells except for
ones whose action is set to &acirc;ignore&acirc;. (See
below)</p>

<p style="margin-top: 1em">&Acirc;&middot; The interactive
mode and job control are disabled in subshells. Jobs are not
inherited by subshells.</p>

<p style="margin-top: 1em">Subshells are executed
independently of the original shell, so changes of any
properties above do not affect those of the original
shell.</p>

<p style="margin-top: 1em">Note <br>
If the subshell contains a single trap built-in, some shells
(but not yash) may not reset the traps on entry to the
subshell.</p>

<p style="margin-top: 1em">INTERACTIVE MODE <br>
The interactive mode is a mode of the shell intended for
direct interaction with a user. If yash is in the
interactive mode, it is called an interactive shell.</p>

<p style="margin-top: 1em">Whether a shell runs in the
interactive mode or not is determined in the invocation of
the shell. After the shell has started up, the interactive
mode cannot be switched on or <br>
off.</p>

<p style="margin-top: 1em">When the shell is
interactive:</p>

<p style="margin-top: 1em">&Acirc;&middot; Initialization
scripts are executed during invocation.</p>

<p style="margin-top: 1em">&Acirc;&middot; The shell checks
for mail and prints a command prompt when it reads a
command. Job status changes are also reported if job control
is active. Line-editing may be used <br>
depending on the capability of the terminal.</p>

<p style="margin-top: 1em">&Acirc;&middot; Commands
executed are automatically registered in command
history.</p>

<p style="margin-top: 1em">&Acirc;&middot; If a command
executed by the shell is killed by a signal other than
SIGINT and SIGPIPE, the shell reports the fact to the
standard error.</p>

<p style="margin-top: 1em">&Acirc;&middot; The filename
token is subject to pathname expansion in file
redirection.</p>

<p style="margin-top: 1em">&Acirc;&middot; The shell does
not exit when it encounters a syntax or expansion error
during command execution. (cf. Termination of the shell)</p>

<p style="margin-top: 1em">&Acirc;&middot; The shell does
not exit when it receives the SIGINT, SIGTERM, or SIGQUIT
signal.</p>

<p style="margin-top: 1em">&Acirc;&middot; A signal handler
can be changed by the trap built-in even if the handler had
been set to &acirc;ignore&acirc; when the shell was
invoked.</p>

<p style="margin-top: 1em">&Acirc;&middot; The value of the
- special parameter contains i.</p>

<p style="margin-top: 1em">&Acirc;&middot; The
shell&acirc;s locale reflects the value of the LC_CTYPE
variable whenever the value is changed (if the shell is not
in the POSIXly-correct mode).</p>

<p style="margin-top: 1em">&Acirc;&middot; Commands are
executed even when the exec option is off.</p>

<p style="margin-top: 1em">&Acirc;&middot; The ignore-eof
option takes effect when enabled.</p>

<p style="margin-top: 1em">&Acirc;&middot; When the shell
reaches the end of input or the exit built-in is executed,
the shell checks if there is any stopped job. If so, the
shell prints a warning and does not <br>
actually exit.</p>

<p style="margin-top: 1em">&Acirc;&middot; The suspend
built-in by default cannot stop the shell if it is a session
leader.</p>

<p style="margin-top: 1em">&Acirc;&middot; The shell does
not exit when the dot built-in fails to find a script file
to read.</p>

<p style="margin-top: 1em">&Acirc;&middot; The shell does
not exit when the exec built-in fails to execute a command
(if not in the POSIXly-correct mode).</p>

<p style="margin-top: 1em">&Acirc;&middot; When a job
finished for which the wait built-in has been waiting, the
fact is reported (only if job control is active and not in
the POSIXly-correct mode).</p>

<p style="margin-top: 1em">&Acirc;&middot; A prompt is
printed when the read built-in reads a second or following
line.</p>

<p style="margin-top: 1em">Prompts <br>
The interactive shell prints a prompt just before it reads a
command. The contents of the prompt is specified by the
value of the PS1 and PS2 variables. The former is used for
<br>
reading the first line of the command and the latter for
other lines.</p>

<p style="margin-top: 1em">When the prompt is printed, the
variable value is subjected to parameter expansion, command
substitution, and arithmetic expansion (but note that the
POSIX standard requires <br>
parameter expansion only). The result of the expansion is
parsed by the rules below to make the actual prompt string,
which is printed to the standard error.</p>

<p style="margin-top: 1em">In the POSIXly-correct mode,
each exclamation mark (!) in the string is substituted with
the command history number of the command that is being
input. Two adjacent exclamation <br>
marks (!!) are printed as a single exclamation. Other
characters are printed intact.</p>

<p style="margin-top: 1em">If the shell is not in the
POSIXly-command mode, the following notations can be used to
format the prompt string. Notations are replaced with the
strings designated in the list <br>
below. Characters that are not interpreted as notations are
printed intact.</p>

<p style="margin-top: 1em">Bell character (ASCII code:
7)</p>

<p style="margin-top: 1em">\ <br>
Escape character (ASCII code: 27)</p>

<p style="margin-top: 1em">j <br>
The number of jobs in the shell.</p>

<p style="margin-top: 1em">Newline character (ASCII code:
10)</p>

<p style="margin-top: 1em">Carriage return character (ASCII
code: 13)</p>

<p style="margin-top: 1em">The command history number of
the command that is being input</p>

<p style="margin-top: 1em"># if the shell&acirc;s effective
user ID is 0; $ otherwise.</p>

<p style="margin-top: 1em">\ <br>
Backslash</p>

<p style="margin-top: 1em">These two notations can surround
part of the prompt string that is not visible on the
terminal. The surrounded part is ignored when the shell
counts the number of characters <br>
that is displayed on the terminal, thus making characters
correctly aligned on the terminal when the prompt string
contains special invisible characters.</p>

<p style="margin-top: 1em">ontspecs. <br>
When line-editing is active, this notation is replaced with
special characters to change font styles on the terminal if
the terminal is capable of it. If line-editing is <br>
inactive or the terminal is incapable of changing font
styles, this notation is silently ignored. One or more of
the following can be used for fontspecs:</p>

<p style="margin-top: 1em">k <br>
Change font color to black</p>

<p style="margin-top: 1em">r <br>
Change font color to red</p>

<p style="margin-top: 1em">g <br>
Change font color to green</p>

<p style="margin-top: 1em">y <br>
Change font color to yellow</p>

<p style="margin-top: 1em">b <br>
Change font color to blue</p>

<p style="margin-top: 1em">m <br>
Change font color to magenta</p>

<p style="margin-top: 1em">c <br>
Change font color to cyan</p>

<p style="margin-top: 1em">w <br>
Change font color to white</p>

<p style="margin-top: 1em">K <br>
Change background color to black</p>

<p style="margin-top: 1em">R <br>
Change background color to red</p>

<p style="margin-top: 1em">G <br>
Change background color to green</p>

<p style="margin-top: 1em">Y <br>
Change background color to yellow</p>

<p style="margin-top: 1em">B <br>
Change background color to blue</p>

<p style="margin-top: 1em">M <br>
Change background color to magenta</p>

<p style="margin-top: 1em">C <br>
Change background color to cyan</p>

<p style="margin-top: 1em">W <br>
Change background color to white</p>

<p style="margin-top: 1em">t <br>
Make font color or background brighter (can only be used
just after one of the characters above)</p>

<p style="margin-top: 1em">d <br>
Change font and background colors to normal</p>

<p style="margin-top: 1em">s <br>
Make font standout</p>

<p style="margin-top: 1em">u <br>
Make font underlined</p>

<p style="margin-top: 1em">v <br>
Make font and background colors reversed</p>

<p style="margin-top: 1em">b <br>
Make font blink</p>

<p style="margin-top: 1em">i <br>
Make font dim</p>

<p style="margin-top: 1em">o <br>
Make font bold</p>

<p style="margin-top: 1em">x <br>
Make font invisible</p>

<p style="margin-top: 1em">D <br>
Make color and style normal</p>

<p style="margin-top: 1em">The actual colors of font and
background are defined by the terminal. Different terminals
may use different colors.</p>

<p style="margin-top: 1em">In addition to the normal
prompt, a prompt string can be displayed to the right of the
cursor if line-editing is active. Those prompts are called
right prompts. The contents of <br>
right prompts are defined by the value of the PS1R and PS2R
variables, each corresponding to the PS1 and PS2
variables.</p>

<p style="margin-top: 1em">Using the above-said notations,
the font style of command strings the user inputs can be
changed as well as that of prompts. The font style of
command strings is defined by the <br>
value of the PS1S and PS2S variables, each corresponding to
the PS1 and PS2 variables. The value can contain the
ontspecs. notation only.</p>

<p style="margin-top: 1em">When the shell is not in the
POSIXly-correct mode, the value of the PROMPT_COMMAND
variable is executed before each prompt.</p>

<p style="margin-top: 1em">Command history <br>
Command history is a feature of the shell that remembers
executed commands to allow re-executing them later. Commands
executed in the interactive mode are automatically saved in
<br>
the command history. Saved commands can be edited and
re-executed using line-editing and the fc and history
built-ins.</p>

<p style="margin-top: 1em">Commands are saved line by line.
Lines that do not contain any non-whitespace characters are
not saved in the history. Lines that start with whitespaces
are not saved when the <br>
hist-space option is on.</p>

<p style="margin-top: 1em">Command history is saved in a
file. When history is first used after an interactive shell
was started, the shell opens a file to save history in. The
filename is specified by the <br>
value of the HISTFILE variable. If the file contains history
data when opened, the data is restored to the shell&acirc;s
history. The file contents are updated in real time as the
user <br>
inputs commands into the shell. If the HISTFILE variable is
not set or the file cannot be opened successfully, history
is not saved in the file, but the history feature will be
<br>
functional in all other respects.</p>

<p style="margin-top: 1em">The number of commands saved in
history is specified by the value of the HISTSIZE variable.
The shell automatically removes old history data so that the
number of saved commands <br>
does not exceed the value. If the HISTSIZE variable is not
set or its value is not a natural number, 500 items will be
saved in history.</p>

<p style="margin-top: 1em">The shell looks at the value of
the HISTFILE and HISTSIZE variables only when the history
feature is first used after the shell was started.
&acirc;The history feature is used&acirc; when:</p>

<p style="margin-top: 1em">&Acirc;&middot; the fc or
history built-in is executed,</p>

<p style="margin-top: 1em">&Acirc;&middot; line-editing is
used (regardless of whether or not history data is recalled
in line-editing), or</p>

<p style="margin-top: 1em">&Acirc;&middot; a command is
input to the shell</p>

<p style="margin-top: 1em">Therefore, the variables should
be set in initialization scripts.</p>

<p style="margin-top: 1em">When more than one instance of
yash shares a single history file, all the shells use the
same history data. As a result, commands that have been
executed by a shell instance can <br>
be recalled on another shell instance. Shells sharing the
same history should have the same HISTSIZE value so that
they manipulate history data properly.</p>

<p style="margin-top: 1em">Yash&acirc;s history data file
has its own format that is incompatible with other kinds of
shells.</p>

<p style="margin-top: 1em">The HISTRMDUP variable can be
set to remove duplicate history items.</p>

<p style="margin-top: 1em">Mail checking <br>
An interactive shell can notify receipt of email. The shell
periodically checks the modification date/time of a file
specified by the user. If the file has been modified since
<br>
the previous check, the shell prints a notification message
(except when the shell is not in the POSIXly-correct mode
and the file is empty). By specifying a mailbox file to be
<br>
checked, the shell will print a message when the file has
been modified, that is, some mail has been received.</p>

<p style="margin-top: 1em">Check is done just before the
shell prints a command line prompt. The interval of checks
can be specified by the MAILCHECK variable in seconds. If
the variable value is 0, check <br>
is done before every prompt. If the variable value is not a
non-negative integer, no checks are done.</p>

<p style="margin-top: 1em">The file whose modification time
is checked is specified by the MAIL variable. The variable
value should be set to the pathname of the file.</p>

<p style="margin-top: 1em">If you want to check more than
one file or customize the notification message, you can set
the MAILPATH variable instead of the MAIL variable. When the
MAILPATH variable is set, <br>
the MAIL variable is ignored. The value of the MAILPATH
variable should be set to one or more colon-separated
pathnames of files to be checked. Each pathname can be
followed by a <br>
percent sign (%) and a custom notification message, which is
printed when the corresponding file has been modified. If
the pathname contains a percent sign, it should be quoted
<br>
by a backslash. The specified message is subject to
parameter expansion. For example, if the value of the
MAILPATH variable is /foo/mail%New
mail!:/bar/mailbox%You&rsquo;ve got <br>
mail:/baz/maildata, the shell will print</p>

<p style="margin-top: 1em">&Acirc;&middot; New mail! when
the file /foo/mail has been modified</p>

<p style="margin-top: 1em">&Acirc;&middot; You&rsquo;ve got
mail when the file /bar/mailbox has been modified</p>

<p style="margin-top: 1em">&Acirc;&middot; the default
message when the file /baz/mail%data has been modified.</p>

<p style="margin-top: 1em">JOB CONTROL <br>
Job control is a function of the shell that executes
multiple commands simultaneously and suspends/resumes the
commands.</p>

<p style="margin-top: 1em">When job control is active:</p>

<p style="margin-top: 1em">&Acirc;&middot; Every pipeline
executed by the shell becomes a job. A job has its unique
process group ID that is shared among all processes in the
job.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the processes
of a job are suspended while the shell is waiting for the
processes to finish, the shell continues to the next command
as if the process have finished. The <br>
shell remembers the job as suspended so that it can be
resumed later.</p>

<p style="margin-top: 1em">&Acirc;&middot; If a job is
executed synchronously, the shell sets the foreground
process group of the terminal to the process group of the
job. When the job is finished (or suspended), the <br>
shell gets back to the foreground.</p>

<p style="margin-top: 1em">&Acirc;&middot; The subshell
executing a command substitution has its own unique process
group ID like a job. However, the shell does not remember
the subshell as a job, so it cannot be <br>
suspended or resumed.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the shell is
interactive, job status is reported before every command
line prompt as if the command jobs -n is executed.</p>

<p style="margin-top: 1em">&Acirc;&middot; The standard
input of an asynchronous command is not automatically
redirected to /dev/null.</p>

<p style="margin-top: 1em">&Acirc;&middot; The shell does
not exit when it receives the SIGTSTP signal.</p>

<p style="margin-top: 1em">&Acirc;&middot; The value of the
- special parameter contains m.</p>

<p style="margin-top: 1em">&Acirc;&middot; When a job
finished for which the wait built-in has been waiting, the
fact is reported (only if the shell is interactive and not
in the POSIXly-correct mode).</p>

<p style="margin-top: 1em">When job control is inactive,
processes executed by the shell have the same process group
ID as the shell. The shell treats asynchronous commands as
an uncontrolled job.</p>

<p style="margin-top: 1em">You can use the following
built-ins to manipulate jobs:</p>

<p style="margin-top: 1em">jobs <br>
prints existing jobs</p>

<p style="margin-top: 1em">fg and bg <br>
run jobs in the foreground or background</p>

<p style="margin-top: 1em">wait <br>
waits for jobs to be finished (or suspended)</p>

<p style="margin-top: 1em">disown <br>
forgets jobs</p>

<p style="margin-top: 1em">kill <br>
sends a signal to jobs</p>

<p style="margin-top: 1em">An interactive job-controlling
shell reports jobs status before every prompt by default.
You can set the following options to make the shell report
status at other timings:</p>

<p style="margin-top: 1em">notify <br>
the shell reports immediately whenever job status
changes.</p>

<p style="margin-top: 1em">notify-le <br>
the shell reports immediately when job status changes while
line-editing.</p>

<p style="margin-top: 1em">A job is removed from the
shell&acirc;s job list when:</p>

<p style="margin-top: 1em">&Acirc;&middot; it has finished
and the jobs built-in reported it,</p>

<p style="margin-top: 1em">&Acirc;&middot; the wait
built-in successfully waited for the job to finish, or</p>

<p style="margin-top: 1em">&Acirc;&middot; the disown
built-in removed the job.</p>

<p style="margin-top: 1em">Jobs are not removed from the
list when an interactive shell automatically reports the
status of jobs.</p>

<p style="margin-top: 1em">Note <br>
The word &acirc;stop&acirc; is synonymous to
&acirc;suspend&acirc; in the context of job control.</p>

<p style="margin-top: 1em">Job ID <br>
Some built-ins use the following notation, which is called
job ID, to specify a job to operate on:</p>

<p style="margin-top: 1em">%, %%, %+ <br>
the current job</p>

<p style="margin-top: 1em">%- <br>
the previous job</p>

<p style="margin-top: 1em">%n <br>
the job that has job number n, where n is a positive
integer</p>

<p style="margin-top: 1em">%string <br>
the job whose name begins with string</p>

<p style="margin-top: 1em">%?string <br>
the job whose name contains string</p>

<p style="margin-top: 1em">The current job and previous job
are jobs selected by the shell according to the following
rules:</p>

<p style="margin-top: 1em">&Acirc;&middot; When there is
one or more suspended jobs, the current job is selected from
them.</p>

<p style="margin-top: 1em">&Acirc;&middot; When there is
one or more suspended jobs other than the current job, the
previous job is selected from them.</p>

<p style="margin-top: 1em">&Acirc;&middot; The current and
previous jobs are always different. When the shell has only
one job, it is the current job and there is no previous
job.</p>

<p style="margin-top: 1em">&Acirc;&middot; When the current
job finished, the previous job becomes the current job.</p>

<p style="margin-top: 1em">&Acirc;&middot; When the current
job is changed, the old current job becomes the previous job
except when the old job finished.</p>

<p style="margin-top: 1em">&Acirc;&middot; When the
foreground job is suspended, the job becomes the current
job.</p>

<p style="margin-top: 1em">Yash has some options to modify
the rules of the current/previous job selection. (The rules
above have priority over the options below.)</p>

<p style="margin-top: 1em">cur-async <br>
When a new asynchronous command is started, it becomes the
current job.</p>

<p style="margin-top: 1em">cur-bg <br>
When a job is resumed by the bg built-in, the job becomes
the current job.</p>

<p style="margin-top: 1em">cur-stop <br>
When a job is suspended, it becomes the current job.</p>

<p style="margin-top: 1em">The current and previous jobs
are not changed as long as the rules above are met.</p>

<p style="margin-top: 1em">The rules of the
current/previous job selection defined in the POSIX standard
are looser than yash&acirc;s rules above. Other
POSIX-compliant shells may select the current and previous
<br>
jobs differently.</p>

<p style="margin-top: 1em">BUILT-IN COMMANDS <br>
Built-in commands are commands that are implemented in the
shell and are executed by the shell without external
programs.</p>

<p style="margin-top: 1em">Types of built-in commands <br>
There are three types of built-in commands in yash: special
built-in commands, semi-special built-in commands and
regular built-in commands.</p>

<p style="margin-top: 1em">Special built-in commands are
much more important commands than others. They are executed
regardless of whether the corresponding external commands
exist or not. Results of <br>
variable assignments that occur in a simple command that
invokes a special built-in last after the command has
finished. Moreover, in the POSIXly-correct mode, a
non-interactive <br>
shell immediately exits with a non-zero exit status when a
redirect error, assignment error, or misuse of option or
operand occurs in a special built-in command.</p>

<p style="margin-top: 1em">Semi special built-in commands
are the second important built-in commands. They are
executed regardless of whether the corresponding external
commands exist or not. In other <br>
parts they are the same as regular built-in commands.</p>

<p style="margin-top: 1em">Regular built-in commands are
less important built-in commands including commands that can
be implemented as external commands or are not listed in
POSIX. In the POSIXly-correct <br>
mode, a regular built-in is executed only when a
corresponding external command is found in PATH.</p>

<p style="margin-top: 1em">Syntax of command arguments <br>
In this section we explain common rules about command
arguments. The built-in commands of yash follow the rules
unless otherwise stated.</p>

<p style="margin-top: 1em">There are two types of command
arguments. One is options and the other is operands. An
option is an argument that starts with a hyphen (-) and
changes the way the command <br>
behaves. Some options take arguments. An operand is an
argument that is not an option and specifies objects the
command operates on.</p>

<p style="margin-top: 1em">If you specify more than one
option to a command, the order of the options are normally
not significant. The order of operands, however, affects the
command behavior.</p>

<p style="margin-top: 1em">An option is either a
single-character option or a long option. A single-character
option is identified by one alphabetic character. A long
option is identified by multiple <br>
alphabetic characters. The POSIX standard only prescribes
single-character options, so in the POSIXly-correct mode you
cannot use long options.</p>

<p style="margin-top: 1em">A single-character option is
composed of a hyphen followed by a letter. For example, -a
is a single-character option. A single-character option that
takes an argument requires <br>
the argument to be just after the option name.</p>

<p style="margin-top: 1em">Example 4. The set built-in and
single-character options</p>

<p style="margin-top: 1em">For the set built-in, -m is a
single-character option that does not take an argument and
-o is one that takes an argument.</p>

<p style="margin-top: 1em">&Acirc;&middot; set -o errexit
-m</p>

<p style="margin-top: 1em">&Acirc;&middot; set -oerrexit
-m</p>

<p style="margin-top: 1em">In these two command lines,
errexit is the argument to the -o option.</p>

<p style="margin-top: 1em">In the second example above, the
-o option and its argument are combined into a single
command line argument. The POSIX standard deprecates that
style and any POSIX-conforming <br>
applications must specify options and their arguments as
separate command line arguments, although yash accepts both
styles.</p>

<p style="margin-top: 1em">You can combine single-character
options that do not take arguments into a single command
line argument. For example, the three options -a, -b and -c
can be combined into -abc.</p>

<p style="margin-top: 1em">A long option is composed of two
hyphens followed by an option name. For example,
--long-option is a long option. You can omit some last
characters of a long option name as long <br>
as it is not ambiguous. For example, you can use --long
instead of --long-option if there is no other options
beginning with --long. Like a single-character option, a
long option <br>
that takes an argument requires the argument to be a command
line argument just after the option name or to be specified
in the same command line argument as the option name, <br>
separated by an equal sign (=).</p>

<p style="margin-top: 1em">Example 5. The fc built-in and
long options</p>

<p style="margin-top: 1em">For the fc built-in, --quiet is
a long option that does not take an argument and --editor is
one that takes an argument.</p>

<p style="margin-top: 1em">&Acirc;&middot; fc --editor vi
--quiet</p>

<p style="margin-top: 1em">&Acirc;&middot; fc --editor=vi
--quiet</p>

<p style="margin-top: 1em">In these command lines, vi is
the argument to the --editor option.</p>

<p style="margin-top: 1em">Arguments that are not options
(nor arguments to them) are interpreted as operands. The
POSIX standard requires all options should be specified
before any operands. Therefore, in <br>
the POSIXly-correct mode, any arguments that come after the
first operand are interpreted as operands (even if they look
like options). If not in the POSIXly-correct mode, you <br>
can specify options after operand.</p>

<p style="margin-top: 1em">Regardless of whether the shell
is in the POSIXly-correct mode or not, an argument that is
just composed of two hyphens (--) can be used as a separator
between options and <br>
operands. All command line arguments after the -- separator
are interpreted as operands, so you can specify operands
that start with a hyphen correctly using the separator.</p>

<p style="margin-top: 1em">Example 6. Options and operands
to the set built-in</p>

<p style="margin-top: 1em">&Acirc;&middot; set -a -b -- -c
-d</p>

<p style="margin-top: 1em">In this example, -a and -b are
options and -c and -d are operands. The -- separator itself
is neither an option nor an operand.</p>

<p style="margin-top: 1em">Regardless of whether the shell
is in the POSIXly-correct mode or not, an argument that is
just composed of a single hyphen (-) is interpreted as an
operand.</p>

<p style="margin-top: 1em">LINE-EDITING <br>
With the line-editing feature, you can edit the command text
when you input a command to an interactive shell. It not
only works as a simple visual-interface editor, but also is
<br>
integrated with the command history. You can recall, edit,
and execute commands in the history with line-editing
instead of using the fc built-in.</p>

<p style="margin-top: 1em">Line-editing has two editing
modes, the vi and emacs modes, which each have their own key
binding settings. By switching editing modes, you can change
key bindings used in <br>
line-editing. Each mode has a corresponding shell option,
which determines whether the mode is currently active or
not. No more than one mode can be active at a time, so the
<br>
options for the other modes are automatically turned off
when you turn on the option for one mode. The whole
line-editing feature is deactivated when those options are
off.</p>

<p style="margin-top: 1em">When an interactive shell is
started, the vi mode is automatically activated if the
standard input and error are both connected to a
terminal.</p>

<p style="margin-top: 1em">Line-editing can be used only
when the standard input and error are both connected to a
terminal. If not, the shell silently falls back to the
normal input mechanism. While <br>
line-editing is being used, the shell uses the termios
interface to change I/O settings of the terminal and the
terminfo interface to parse input key sequences.</p>

<p style="margin-top: 1em">Shell options on line-editing
<br>
The following options can be set by the set built-in to
enable line-editing and choose an editing mode to
activate:</p>

<p style="margin-top: 1em">vi <br>
activates the vi mode.</p>

<p style="margin-top: 1em">emacs <br>
activates the emacs mode.</p>

<p style="margin-top: 1em">The other line-editing-related
options are:</p>

<p style="margin-top: 1em">le-always-rp <br>
When this options is enabled, the right prompt is always
visible: when the cursor reaches the right prompt, it moves
to the next line from the original position, which would
<br>
otherwise be overwritten by input text.</p>

<p style="margin-top: 1em">le-comp-debug <br>
When enabled, internal information is printed during
completion, which will help debugging completion
scripts.</p>

<p style="margin-top: 1em">le-conv-meta <br>
When enabled, the 8th bit of each input byte is always
treated as a meta-key flag, regardless of terminfo data.</p>

<p style="margin-top: 1em">le-no-conv-meta <br>
When enabled, the 8th bit of each input byte is never
treated as a meta-key flag, regardless of terminfo data.</p>

<p style="margin-top: 1em">The le-conv-meta and
le-no-conv-meta options cannot be both enabled at a time.
When either is enabled, the other is automatically disabled.
When neither is enabled, the 8th <br>
bit may be treated as a meta-key flag depending on terminfo
data.</p>

<p style="margin-top: 1em">le-predict <br>
activates command line prediction.</p>

<p style="margin-top: 1em">le-prompt-sp <br>
When enabled, the shell prints a special character sequence
before printing each prompt so that every prompt is printed
at the beginning of a line.</p>

<p style="margin-top: 1em">This option is enabled by
default.</p>

<p style="margin-top: 1em">le-visible-bell <br>
When enabled, the shell flashes the terminal instead of
sounding an alarm when an alert is required.</p>

<p style="margin-top: 1em">Editing modes <br>
The vi mode is an editing mode that offers key bindings
similar to that of the vi editor. The vi mode has two
sub-modes that are switched during editing: the insert and
command <br>
modes. The sub-mode is always reset to the insert mode when
line-editing is started for a new command line. In the
insert mode, most characters are inserted to the buffer as
<br>
typed. In the command mode, input characters are treated as
commands that move the cursor, insert/delete text, etc.</p>

<p style="margin-top: 1em">The emacs mode offers key
bindings similar to the emacs editor. Most characters are
inserted to the buffer as typed, but more characters are
treated as commands than the vi <br>
insert mode.</p>

<p style="margin-top: 1em">Another sub-mode is used while
you enter search keywords. The sub-mode is called the search
mode, which offers slightly different key bindings depending
on the active editing <br>
mode.</p>

<p style="margin-top: 1em">Line-editing commands <br>
All characters the user enters while line-editing is active
are treated as line-editing commands listed below. The
bindkey built-in allows customizing the key bindings of each
<br>
mode (except for the search mode).</p>

<p style="margin-top: 1em">The list below shows not only
the functions of commands but also the default key bindings.
The keywords &acirc;vi-insert&acirc;,
&acirc;vi-command&acirc;, &acirc;vi-search&acirc;,
&acirc;emacs&acirc;, &acirc;emacs-search&acirc; means the
<br>
vi insert mode, the vi command mode, the search mode for the
vi mode (the vi search mode), the emacs mode, and the search
mode for the emacs mode (the emacs search mode), <br>
respectively.</p>

<p style="margin-top: 1em">Some commands take an argument
that affects the function of the commands. For example, the
forward-char command moves the cursor by as many characters
as specified by the <br>
argument. To specify an argument, use the digit-argument
command just before another command that takes an
argument.</p>

<p style="margin-top: 1em">Basic editing commands <br>
noop <br>
Do nothing.</p>

<p style="margin-top: 1em">vi-command <br>
[</p>

<p style="margin-top: 1em">alert <br>
Alert.</p>

<p style="margin-top: 1em">self-insert <br>
Insert the input character at the current cursor position.
Characters escaped by escape sequences cannot be
inserted.</p>

<p style="margin-top: 1em">vi-insert, emacs <br>
\</p>

<p style="margin-top: 1em">insert-tab <br>
Insert a tab character at the current cursor position.</p>

<p style="margin-top: 1em">emacs <br>
[I</p>

<p style="margin-top: 1em">expect-verbatim <br>
Insert a character that is entered just after this command
at the current cursor position. This command can input a
character that cannot be input by the self-insert <br>
command, except a null character (&rsquo; &rsquo;).</p>

<p style="margin-top: 1em">vi-insert, vi-search,
emacs-search <br>
V</p>

<p style="margin-top: 1em">emacs <br>
Q, V</p>

<p style="margin-top: 1em">digit-argument <br>
Pass the input digit to the next command as an argument.</p>

<p style="margin-top: 1em">This command can be bound to a
digit or hyphen. To pass &acirc;12&acirc; as an argument to
the forward-char command in the vi mode, for example, enter
12l.</p>

<p style="margin-top: 1em">vi-command <br>
1, 2, 3, 4, 5, 6, 7, 8, 9</p>

<p style="margin-top: 1em">emacs <br>
[0, [1, [2, [3, [4, [5, [6, [7, [8, [9, [-,</p>

<p style="margin-top: 1em">bol-or-digit <br>
Like the beginning-of-line command if there is no argument;
like the digit-argument command otherwise.</p>

<p style="margin-top: 1em">vi-command <br>
0</p>

<p style="margin-top: 1em">accept-line <br>
Finish editing the current line. A newline is automatically
appended to the line. The line will be executed by the
shell.</p>

<p style="margin-top: 1em">If command line prediction is
active, the current prediction (if any) is ignored. See also
the accept-prediction command.</p>

<p style="margin-top: 1em">vi-insert, vi-command, emacs,
emacs-search <br>
J, M</p>

<p style="margin-top: 1em">abort-line <br>
Abandon the current buffer and finish editing as if an empty
line was input.</p>

<p style="margin-top: 1em">vi-insert, vi-command,
vi-search, emacs, emacs-search <br>
, C</p>

<p style="margin-top: 1em">eof <br>
Abandon the current buffer and finish editing as if the
shell reached the end of input. This normally makes the
shell exit.</p>

<p style="margin-top: 1em">eof-if-empty <br>
Like the eof command if the buffer is empty; like the alert
command otherwise.</p>

<p style="margin-top: 1em">vi-insert, vi-command</p>

<p style="margin-top: 1em">eof-or-delete <br>
Like the eof command if the buffer is empty; like the
delete-char command otherwise.</p>

<p style="margin-top: 1em">emacs</p>

<p style="margin-top: 1em">accept-with-hash <br>
If the current line does not begin with a hash sign (#) or
there is no argument specified for this command, a hash sign
is inserted at the beginning of the line. <br>
Otherwise, the beginning hash sign is removed from the line.
Finally, the line is accepted like the accept-line
command.</p>

<p style="margin-top: 1em">vi-command <br>
#</p>

<p style="margin-top: 1em">emacs <br>
[#</p>

<p style="margin-top: 1em">accept-prediction <br>
Like the accept-line command, but include the predicted
part.</p>

<p style="margin-top: 1em">setmode-viinsert <br>
Switch to the vi insert mode.</p>

<p style="margin-top: 1em">vi-command <br>
i, I</p>

<p style="margin-top: 1em">setmode-vicommand <br>
Switch to the vi command mode.</p>

<p style="margin-top: 1em">vi-insert <br>
[</p>

<p style="margin-top: 1em">setmode-emacs <br>
Switch to the emacs mode.</p>

<p style="margin-top: 1em">expect-char, abort-expect-char
<br>
These commands are not meant for use by the user. They are
used by the shell to implement some other commands.</p>

<p style="margin-top: 1em">redraw-all <br>
Reprint the prompt and the current line to the terminal.</p>

<p style="margin-top: 1em">vi-insert, vi-command,
vi-search, emacs, emacs-search <br>
L</p>

<p style="margin-top: 1em">clear-and-redraw-all <br>
Clear the terminal and reprint the prompt and the current
line.</p>

<p style="margin-top: 1em">Motion commands <br>
Motion commands move the cursor on the line. Most motion
commands accept an argument. When passed an argument, they
repeat the cursor motion as many times as specified by the
<br>
argument. Passing &acirc;4&acirc; as an argument to the
forward-char command, for example, advances the cursor by
four characters.</p>

<p style="margin-top: 1em">The shell has several
definitions of words as units of distance: A bigword is one
or more adjacent non-whitespace characters. A semiword is
one or more adjacent characters <br>
that contain no whitespaces or punctuations. An emacsword is
one or more adjacent alphanumeric characters. A viword is
either:</p>

<p style="margin-top: 1em">&Acirc;&middot; one or more
adjacent alphanumeric characters and/or underscores (_),
or</p>

<p style="margin-top: 1em">&Acirc;&middot; one or more
adjacent characters that contain none of alphanumeric
characters, underscores, and whitespaces.</p>

<p style="margin-top: 1em">forward-char <br>
Move the cursor to the next character.</p>

<p style="margin-top: 1em">vi-insert</p>

<p style="margin-top: 1em">vi-command <br>
l, (space), <br>
emacs <br>
F</p>

<p style="margin-top: 1em">backward-char <br>
Move the cursor to the previous character.</p>

<p style="margin-top: 1em">vi-insert</p>

<p style="margin-top: 1em">vi-command <br>
h, 0 <br>
B</p>

<p style="margin-top: 1em">forward-bigword <br>
Move the cursor to the next bigword.</p>

<p style="margin-top: 1em">vi-command <br>
W</p>

<p style="margin-top: 1em">end-of-bigword <br>
Move the cursor to the next end of a bigword.</p>

<p style="margin-top: 1em">vi-command <br>
E</p>

<p style="margin-top: 1em">backward-bigword <br>
Move the cursor to the previous bigword.</p>

<p style="margin-top: 1em">vi-command <br>
B</p>

<p style="margin-top: 1em">forward-semiword <br>
Move the cursor to the next semiword.</p>

<p style="margin-top: 1em">end-of-semiword <br>
Move the cursor to the next end of a semiword.</p>

<p style="margin-top: 1em">backward-semiword <br>
Move the cursor to the previous semiword.</p>

<p style="margin-top: 1em">forward-viword <br>
Move the cursor to the next viword.</p>

<p style="margin-top: 1em">vi-command <br>
w</p>

<p style="margin-top: 1em">end-of-viword <br>
Move the cursor to the next end of a viword.</p>

<p style="margin-top: 1em">vi-command <br>
e</p>

<p style="margin-top: 1em">backward-viword <br>
Move the cursor to the previous viword.</p>

<p style="margin-top: 1em">vi-command <br>
b</p>

<p style="margin-top: 1em">forward-emacsword <br>
Move the cursor to the next emacsword.</p>

<p style="margin-top: 1em">emacs <br>
[f, [F</p>

<p style="margin-top: 1em">backward-emacsword <br>
Move the cursor to the previous emacsword.</p>

<p style="margin-top: 1em">emacs <br>
[b, [B</p>

<p style="margin-top: 1em">beginning-of-line <br>
Move the cursor to the beginning of the line.</p>

<p style="margin-top: 1em">vi-insert, vi-command</p>

<p style="margin-top: 1em">emacs <br>
A</p>

<p style="margin-top: 1em">end-of-line <br>
Move the cursor to the end of the line.</p>

<p style="margin-top: 1em">vi-insert</p>

<p style="margin-top: 1em">vi-command <br>
$, <br>
emacs <br>
E</p>

<p style="margin-top: 1em">go-to-column <br>
Move the cursor to the nth character on the line, where n is
the argument. Assume n = 1 when no argument.</p>

<p style="margin-top: 1em">vi-command <br>
|</p>

<p style="margin-top: 1em">first-nonblank <br>
Move the cursor to the first non-blank character on the
line.</p>

<p style="margin-top: 1em">vi-command <br>
^</p>

<p style="margin-top: 1em">find-char <br>
Move the cursor to the first position where a character that
is entered just after this command appears after the current
cursor position.</p>

<p style="margin-top: 1em">vi-command <br>
f</p>

<p style="margin-top: 1em">emacs <br>
]</p>

<p style="margin-top: 1em">find-char-rev <br>
Move the cursor to the last position where a character that
is entered just after this command appears before the
current cursor position.</p>

<p style="margin-top: 1em">vi-command <br>
F</p>

<p style="margin-top: 1em">emacs <br>
[]</p>

<p style="margin-top: 1em">till-char <br>
Move the cursor to the first position just before a
character that is entered just after this command appears
after the current cursor position.</p>

<p style="margin-top: 1em">vi-command <br>
t</p>

<p style="margin-top: 1em">till-char-rev <br>
Move the cursor to the last position just after a character
that is entered just after this command appears before the
current cursor position.</p>

<p style="margin-top: 1em">vi-command <br>
T</p>

<p style="margin-top: 1em">refind-char <br>
Redo the last find-char, find-char-rev, till-char,
till-char-rev command.</p>

<p style="margin-top: 1em">vi-command <br>
;</p>

<p style="margin-top: 1em">refind-char-rev <br>
Redo the last find-char, find-char-rev, till-char,
till-char-rev command in the reverse direction.</p>

<p style="margin-top: 1em">vi-command <br>
,</p>

<p style="margin-top: 1em">Editing commands <br>
Editing commands modify contents of the buffer. Most editing
commands accept an argument. When passed an argument, they
repeat the modification as many times as specified by <br>
the argument.</p>

<p style="margin-top: 1em">Texts deleted by commands whose
name starts with &acirc;kill&acirc; are saved in kill ring,
from which deleted contents can be restored to the buffer.
The most recent 32 texts are kept <br>
in the kill ring.</p>

<p style="margin-top: 1em">delete-char <br>
Delete a character at the current cursor position if no
argument is passed; like the kill-char command
otherwise.</p>

<p style="margin-top: 1em">vi-insert, emacs <br>
delete-bigword <br>
Delete a bigword at the current cursor position if no
argument is passed; like the kill-bigword command
otherwise.</p>

<p style="margin-top: 1em">delete-semiword <br>
Delete a semiword at the current cursor position if no
argument is passed; like the kill-semiword command
otherwise.</p>

<p style="margin-top: 1em">delete-viword <br>
Delete a viword at the current cursor position if no
argument is passed; like the kill-viword command
otherwise.</p>

<p style="margin-top: 1em">delete-emacsword <br>
Delete a emacsword at the current cursor position if no
argument is passed; like the kill-emacsword command
otherwise.</p>

<p style="margin-top: 1em">backward-delete-char <br>
Delete a character just before the current cursor position
if no argument is passed; like the backward-kill-char
command otherwise.</p>

<p style="margin-top: 1em">vi-insert, emacs <br>
0 <br>
Delete a bigword just before the current cursor position if
no argument is passed; like the backward-kill-bigword
command otherwise.</p>

<p style="margin-top: 1em">backward-delete-semiword <br>
Delete a semiword just before the current cursor position if
no argument is passed; like the backward-kill-semiword
command otherwise.</p>

<p style="margin-top: 1em">vi-insert <br>
W</p>

<p style="margin-top: 1em">backward-delete-viword <br>
Delete a viword just before the current cursor position if
no argument is passed; like the backward-kill-viword command
otherwise.</p>

<p style="margin-top: 1em">backward-delete-emacsword <br>
Delete a emacsword just before the current cursor position
if no argument is passed; like the backward-kill-emacsword
command otherwise.</p>

<p style="margin-top: 1em">delete-line <br>
Delete the whole buffer contents.</p>

<p style="margin-top: 1em">forward-delete-line <br>
Delete all characters from the current cursor position to
the end of the buffer.</p>

<p style="margin-top: 1em">backward-delete-line <br>
Delete all characters before the current cursor
position.</p>

<p style="margin-top: 1em">vi-insert <br>
U</p>

<p style="margin-top: 1em">kill-char <br>
Delete a character at the current cursor position and add it
to the kill ring.</p>

<p style="margin-top: 1em">vi-command <br>
x, kill-bigword <br>
Delete a bigword at the current cursor position and add it
to the kill ring.</p>

<p style="margin-top: 1em">kill-semiword <br>
Delete a semiword at the current cursor position and add it
to the kill ring.</p>

<p style="margin-top: 1em">kill-viword <br>
Delete a viword at the current cursor position and add it to
the kill ring.</p>

<p style="margin-top: 1em">kill-emacsword <br>
Delete a emacsword at the current cursor position and add it
to the kill ring.</p>

<p style="margin-top: 1em">emacs <br>
[d, [D</p>

<p style="margin-top: 1em">backward-kill-char <br>
Delete a character just before the current cursor position
and add it to the kill ring.</p>

<p style="margin-top: 1em">vi-command <br>
X</p>

<p style="margin-top: 1em">backward-kill-bigword <br>
Delete a bigword just before the current cursor position and
add it to the kill ring.</p>

<p style="margin-top: 1em">emacs <br>
W</p>

<p style="margin-top: 1em">backward-kill-semiword <br>
Delete a semiword just before the current cursor position
and add it to the kill ring.</p>

<p style="margin-top: 1em">backward-kill-viword <br>
Delete a viword just before the current cursor position and
add it to the kill ring.</p>

<p style="margin-top: 1em">backward-kill-emacsword <br>
Delete a emacsword just before the current cursor position
and add it to the kill ring.</p>

<p style="margin-top: 1em">emacs <br>
[0 <br>
kill-line <br>
Delete the whole buffer contents and add it to the kill
ring.</p>

<p style="margin-top: 1em">forward-kill-line <br>
Delete all characters from the current cursor position to
the end of the buffer and add it to the kill ring.</p>

<p style="margin-top: 1em">emacs <br>
K</p>

<p style="margin-top: 1em">backward-kill-line <br>
Delete all characters before the current cursor position and
add it to the kill ring.</p>

<p style="margin-top: 1em">emacs <br>
U, X0 <br>
put-before <br>
Insert the last-killed text before the current cursor
position and move the cursor to the last character that was
inserted.</p>

<p style="margin-top: 1em">vi-command <br>
P</p>

<p style="margin-top: 1em">put <br>
Insert the last-killed text after the current cursor
position and move the cursor to the last character that was
inserted.</p>

<p style="margin-top: 1em">vi-command <br>
p</p>

<p style="margin-top: 1em">put-left <br>
Insert the last-killed text before the current cursor
position and move the cursor to the last character that was
inserted.</p>

<p style="margin-top: 1em">emacs <br>
Y</p>

<p style="margin-top: 1em">put-pop <br>
Replace the just put text with the next older killed
text.</p>

<p style="margin-top: 1em">This command can be used only
just after the put-before, put, put-left, or put-pop
command.</p>

<p style="margin-top: 1em">emacs <br>
[y, [Y</p>

<p style="margin-top: 1em">undo <br>
Cancel modification by the last editing command.</p>

<p style="margin-top: 1em">vi <br>
u</p>

<p style="margin-top: 1em">emacs <br>
_, X XU</p>

<p style="margin-top: 1em">undo-all <br>
Cancel all modification in the current buffer, restoring the
initial contents.</p>

<p style="margin-top: 1em">vi <br>
U</p>

<p style="margin-top: 1em">emacs <br>
[R, [r, [R</p>

<p style="margin-top: 1em">cancel-undo <br>
Cancel cancellation by the last undo or undo-all
command.</p>

<p style="margin-top: 1em">vi <br>
R</p>

<p style="margin-top: 1em">cancel-undo-all <br>
Cancel all cancellation by all most recent undo and undo-all
commands.</p>

<p style="margin-top: 1em">redo <br>
Repeat modification by the last editing command.</p>

<p style="margin-top: 1em">vi-command <br>
.</p>

<p style="margin-top: 1em">Completion commands <br>
complete <br>
Complete a word just before the cursor position and, if
there is more than one candidate, show a list of the
candidates.</p>

<p style="margin-top: 1em">complete-next-candidate <br>
Like the complete command when candidates are not being
listed; otherwise, select the next candidate in the
list.</p>

<p style="margin-top: 1em">vi-insert, emacs <br>
I</p>

<p style="margin-top: 1em">complete-prev-candidate <br>
Like the complete command when candidates are not being
listed; otherwise, select the previous candidate in the
list.</p>

<p style="margin-top: 1em">vi-insert, emacs</p>

<p style="margin-top: 1em">complete-next-column <br>
Like the complete command when candidates are not being
listed; otherwise, select the first candidate in the next
column in the list.</p>

<p style="margin-top: 1em">complete-prev-column <br>
Like the complete command when candidates are not being
listed; otherwise, select the first candidate in the
previous column in the list.</p>

<p style="margin-top: 1em">complete-next-page <br>
Like the complete command when candidates are not being
listed; otherwise, select the first candidate in the next
page in the list.</p>

<p style="margin-top: 1em">complete-prev-page <br>
Like the complete command when candidates are not being
listed; otherwise, select the first candidate in the
previous page in the list.</p>

<p style="margin-top: 1em">complete-list <br>
Complete a word just before the cursor position.</p>

<p style="margin-top: 1em">If you pass no argument, a list
of completion candidates is shown. Otherwise, the word is
completed with the nth candidate where n is the
argument.</p>

<p style="margin-top: 1em">emacs <br>
[?, [=</p>

<p style="margin-top: 1em">complete-all <br>
Replace a word just before the cursor position with all
possible completion candidates, each separated by a
space.</p>

<p style="margin-top: 1em">emacs <br>
[*</p>

<p style="margin-top: 1em">complete-max <br>
Complete a word just before the cursor position with the
longest prefix of all possible completion candidates.</p>

<p style="margin-top: 1em">complete-max-then-list <br>
Works like the complete-max command for the first use, then
like the complete command when used successively.</p>


<p style="margin-top: 1em">complete-max-then-next-candidate
<br>
Works like the complete-max command for the first use, then
like the complete-next-candidate command when used
successively.</p>


<p style="margin-top: 1em">complete-max-then-prev-candidate
<br>
Works like the complete-max command for the first use, then
like the complete-prev-candidate command when used
successively.</p>

<p style="margin-top: 1em">clear-candidates <br>
Clear the list of completion candidates.</p>

<p style="margin-top: 1em">Vi-specific commands <br>
vi-replace-char <br>
Replace the character at the cursor position with a
character that is entered just after this command.</p>

<p style="margin-top: 1em">vi-command <br>
r</p>

<p style="margin-top: 1em">vi-insert-beginning <br>
Move the cursor to the beginning of the line and switch to
the vi insert mode.</p>

<p style="margin-top: 1em">vi-command <br>
I</p>

<p style="margin-top: 1em">vi-append <br>
Move the cursor to the next character and switch to the vi
insert mode.</p>

<p style="margin-top: 1em">vi-command <br>
I</p>

<p style="margin-top: 1em">vi-append-to-eol <br>
Move the cursor to the end of the line and switch to the vi
insert mode.</p>

<p style="margin-top: 1em">vi-command <br>
A</p>

<p style="margin-top: 1em">vi-replace <br>
Switch to the vi insert mode and start overwriting. While
overwriting, the self-insert command replaces the character
at cursor position rather than inserting a <br>
character. Overwriting ends when the editing mode is
changed.</p>

<p style="margin-top: 1em">vi-command <br>
R</p>

<p style="margin-top: 1em">vi-switch-case <br>
Switch case of characters between the current and next
cursor positions. This command must be followed by a motion
command, which determines the next cursor position.</p>

<p style="margin-top: 1em">vi-switch-case-char <br>
Switch case of the character at the current cursor position
and move the cursor to the next character.</p>

<p style="margin-top: 1em">vi-command <br>
~</p>

<p style="margin-top: 1em">vi-yank <br>
Add to the kill ring the characters between the current and
next cursor positions. This command must be followed by a
motion command, which determines the next cursor <br>
position.</p>

<p style="margin-top: 1em">vi-command <br>
y</p>

<p style="margin-top: 1em">vi-yank-to-eol <br>
Add to the kill ring the characters from the current cursor
position to the end of the line.</p>

<p style="margin-top: 1em">vi-command <br>
Y</p>

<p style="margin-top: 1em">vi-delete <br>
Delete characters between the current and next cursor
positions and add it to the kill ring. This command must be
followed by a motion command, which determines the next <br>
cursor position.</p>

<p style="margin-top: 1em">vi-command <br>
d</p>

<p style="margin-top: 1em">vi-delete-to-eol <br>
Delete the characters from the current cursor position to
the end of the line and add it to the kill ring.</p>

<p style="margin-top: 1em">vi-command <br>
D</p>

<p style="margin-top: 1em">vi-change <br>
Delete characters between the current and next cursor
positions and switch to the vi insert mode. This command
must be followed by a motion command, which determines the
<br>
next cursor position.</p>

<p style="margin-top: 1em">vi-command <br>
c</p>

<p style="margin-top: 1em">vi-change-to-eol <br>
Delete the characters from the current cursor position to
the end of the line and switch to the vi insert mode.</p>

<p style="margin-top: 1em">vi-command <br>
C</p>

<p style="margin-top: 1em">vi-change-line <br>
Delete the whole buffer contents and switch to the vi insert
mode.</p>

<p style="margin-top: 1em">vi-command <br>
S</p>

<p style="margin-top: 1em">vi-yank-and-change <br>
Like the vi-change command, but the deleted text is added to
the kill ring.</p>

<p style="margin-top: 1em">vi-yank-and-change-to-eol <br>
Like the vi-change-to-eol command, but the deleted text is
added to the kill ring.</p>

<p style="margin-top: 1em">vi-yank-and-change-line <br>
Like the vi-change-line command, but the deleted text is
added to the kill ring.</p>

<p style="margin-top: 1em">vi-substitute <br>
Delete a character at the current cursor position, add it to
the kill ring, and switch to the vi insert mode.</p>

<p style="margin-top: 1em">vi-command <br>
s</p>

<p style="margin-top: 1em">vi-append-last-bigword <br>
Insert a space and the last bigword in the most recent
command history entry just after the current cursor position
and switch to the vi insert mode. If argument n is <br>
passed, the nth bigword in the entry is inserted instead of
the last.</p>

<p style="margin-top: 1em">vi-command <br>
_</p>

<p style="margin-top: 1em">vi-exec-alias <br>
Execute the value of an alias named _c as editing commands
where c is a character input just after this command.</p>

<p style="margin-top: 1em">vi-command <br>
@</p>

<p style="margin-top: 1em">vi-edit-and-accept <br>
Start the vi editor to edit the current buffer contents.
When the editor finished, the edited buffer contents is
accepted like the accept-line command unless the exit <br>
status of the editor is non-zero.</p>

<p style="margin-top: 1em">vi-command <br>
v</p>

<p style="margin-top: 1em">vi-complete-list <br>
Like the complete-list command, but also switch to the vi
insert mode.</p>

<p style="margin-top: 1em">vi-command <br>
=</p>

<p style="margin-top: 1em">vi-complete-all <br>
Like the complete-all command, but also switch to the vi
insert mode.</p>

<p style="margin-top: 1em">vi-command <br>
*</p>

<p style="margin-top: 1em">vi-complete-max <br>
Like the complete-max command, but also switch to the vi
insert mode.</p>

<p style="margin-top: 1em">vi-command <br>
\</p>

<p style="margin-top: 1em">vi-search-forward <br>
Switch to the vi search mode and start forward history
search.</p>

<p style="margin-top: 1em">vi-command <br>
?</p>

<p style="margin-top: 1em">vi-search-backward <br>
Switch to the vi search mode and start backward history
search.</p>

<p style="margin-top: 1em">vi-command <br>
/</p>

<p style="margin-top: 1em">Emacs-specific commands <br>
emacs-transpose-chars <br>
Move a character just before the cursor to the right.</p>

<p style="margin-top: 1em">emacs <br>
T</p>

<p style="margin-top: 1em">emacs-transpose-words <br>
Move an emacsword just before the cursor to the right.</p>

<p style="margin-top: 1em">emacs <br>
[t, [T</p>

<p style="margin-top: 1em">emacs-downcase-word <br>
Make an emacsword just after the cursor lowercase.</p>

<p style="margin-top: 1em">emacs <br>
[l, [L</p>

<p style="margin-top: 1em">emacs-upcase-word <br>
Make an emacsword just after the cursor uppercase.</p>

<p style="margin-top: 1em">emacs <br>
[u, [U</p>

<p style="margin-top: 1em">emacs-capitalize-word <br>
Capitalize the first letter of an emacsword just after the
cursor.</p>

<p style="margin-top: 1em">emacs <br>
[c, [u</p>

<p style="margin-top: 1em">emacs-delete-horizontal-space
<br>
Delete spaces around the cursor. If any argument was passed,
delete spaces just before the cursor only.</p>

<p style="margin-top: 1em">emacs <br>
[\</p>

<p style="margin-top: 1em">emacs-just-one-space <br>
Delete spaces around the cursor and leave one space. If an
argument is specified, leave as many spaces as the
argument.</p>

<p style="margin-top: 1em">emacs <br>
[ (Escape followed by a space)</p>

<p style="margin-top: 1em">emacs-search-forward <br>
Switch to the emacs search mode and start forward history
search.</p>

<p style="margin-top: 1em">emacs <br>
S</p>

<p style="margin-top: 1em">emacs-search-backward <br>
Switch to the emacs search mode and start backward history
search.</p>

<p style="margin-top: 1em">emacs <br>
R</p>

<p style="margin-top: 1em">History-related commands <br>
oldest-history <br>
Recall the oldest entry in the history. If argument n is
passed, the entry whose number is n is recalled instead. The
cursor position remains unchanged.</p>

<p style="margin-top: 1em">newest-history <br>
Recall the newest entry in the history. If argument n is
passed, the entry whose number is n is recalled instead. The
cursor position remains unchanged.</p>

<p style="margin-top: 1em">return-history <br>
Return to the initial buffer corresponding to none of
existing history entries. If argument n is passed, the entry
whose number is n is recalled instead. The cursor <br>
position remains unchanged.</p>

<p style="margin-top: 1em">oldest-history-bol <br>
Recall the oldest entry in the history and move the cursor
to the beginning of the line. If argument n is passed, the
entry whose number is n is recalled instead.</p>

<p style="margin-top: 1em">vi-command <br>
G</p>

<p style="margin-top: 1em">newest-history-bol <br>
Recall the newest entry in the history and move the cursor
to the beginning of the line. If argument n is passed, the
entry whose number is n is recalled instead.</p>

<p style="margin-top: 1em">return-history-bol <br>
Return to the initial buffer corresponding to none of
existing history entries and move the cursor to the
beginning of the line. If argument n is passed, the entry
whose <br>
number is n is recalled instead.</p>

<p style="margin-top: 1em">vi-command <br>
g</p>

<p style="margin-top: 1em">oldest-history-eol <br>
Recall the oldest entry in the history and move the cursor
to the end of the line. If argument n is passed, the entry
whose number is n is recalled instead.</p>

<p style="margin-top: 1em">emacs <br>
[&lt;</p>

<p style="margin-top: 1em">newest-history-eol <br>
Recall the newest entry in the history and move the cursor
to the end of the line. If argument n is passed, the entry
whose number is n is recalled instead.</p>

<p style="margin-top: 1em">return-history-eol <br>
Return to the initial buffer corresponding to none of
existing history entries and move the cursor to the end of
the line. If argument n is passed, the entry whose number
<br>
is n is recalled instead.</p>

<p style="margin-top: 1em">emacs <br>
[&gt;</p>

<p style="margin-top: 1em">next-history <br>
Recall the next history entry. The cursor position remains
unchanged.</p>

<p style="margin-top: 1em">prev-history <br>
Recall the previous history entry. The cursor position
remains unchanged.</p>

<p style="margin-top: 1em">next-history-bol <br>
Recall the next history entry and move the cursor to the
beginning of the line.</p>

<p style="margin-top: 1em">vi-command <br>
j, +, <br>
prev-history-bol <br>
Recall the previous history entry and move the cursor to the
beginning of the line.</p>

<p style="margin-top: 1em">vi-command <br>
k, -, U, P</p>

<p style="margin-top: 1em">next-history-eol <br>
Recall the next history entry and move the cursor to the end
of the line.</p>

<p style="margin-top: 1em">vi-insert, emacs</p>

<p style="margin-top: 1em">prev-history-eol <br>
Recall the previous history entry and move the cursor to the
end of the line.</p>

<p style="margin-top: 1em">vi-insert, emacs <br>
U, P</p>

<p style="margin-top: 1em">search-again <br>
Repeat the last command history search.</p>

<p style="margin-top: 1em">vi-command <br>
n</p>

<p style="margin-top: 1em">search-again-rev <br>
Repeat the last command history search in the reverse
direction.</p>

<p style="margin-top: 1em">vi-command <br>
N</p>

<p style="margin-top: 1em">search-again-forward <br>
Repeat the last command history search in the forward
direction.</p>

<p style="margin-top: 1em">search-again-backward <br>
Repeat the last command history search in the backward
direction.</p>

<p style="margin-top: 1em">beginning-search-forward <br>
Recall the next history entry that starts with the same text
as the text from the beginning of the line up to the current
cursor position. The cursor position remains <br>
unchanged.</p>

<p style="margin-top: 1em">beginning-search-backward <br>
Recall the previous history entry that starts with the same
text as the text from the beginning of the line up to the
current cursor position. The cursor position remains <br>
unchanged.</p>

<p style="margin-top: 1em">Search mode commands <br>
srch-self-insert <br>
Insert the input character at the current cursor position.
Characters escaped by escape sequences cannot be
inserted.</p>

<p style="margin-top: 1em">vi-search, emacs-search <br>
\</p>

<p style="margin-top: 1em">srch-backward-delete-char <br>
Delete the last character in the search text. If the text is
empty:</p>

<p style="margin-top: 1em">&Acirc;&middot; like the
srch-abort-search command when in the vi search mode, or</p>

<p style="margin-top: 1em">&Acirc;&middot; like the alert
command when in the emacs search mode.</p>

<p style="margin-top: 1em">vi-search, emacs-search <br>
0 <br>
Delete the whole search text.</p>

<p style="margin-top: 1em">vi-search, emacs-search <br>
U</p>

<p style="margin-top: 1em">srch-continue-forward <br>
Find the next matching history entry.</p>

<p style="margin-top: 1em">emacs-search <br>
S</p>

<p style="margin-top: 1em">srch-continue-backward <br>
Find the previous matching history entry.</p>

<p style="margin-top: 1em">emacs-search <br>
R</p>

<p style="margin-top: 1em">srch-accept-search <br>
Finish the search mode, accepting the result being
shown.</p>

<p style="margin-top: 1em">vi-search <br>
J, M</p>

<p style="margin-top: 1em">emacs-search <br>
J, [</p>

<p style="margin-top: 1em">srch-abort-search <br>
Abort search and restore the previous buffer contents.</p>

<p style="margin-top: 1em">vi-search <br>
[</p>

<p style="margin-top: 1em">emacs-search <br>
G</p>

<p style="margin-top: 1em">Escape sequences <br>
In the bindkey built-in, escape sequences are used to
represent special keys such as function keys and arrow keys.
Every escape sequence starts with a backslash ( and thus
<br>
there is also an escape sequence for a backslash itself.</p>

<p style="margin-top: 1em">Below are available escape
sequences:</p>

<p style="margin-top: 1em">\ <br>
Backslash (</p>

<p style="margin-top: 1em">0 Backspace</p>

<p style="margin-top: 1em">End</p>

<p style="margin-top: 1em">Home</p>

<p style="margin-top: 1em">I <br>
Insert (Insert-char, Enter-insert-mode)</p>

<p style="margin-top: 1em">Left arrow</p>

<p style="margin-top: 1em">Page-down (Next-page)</p>

<p style="margin-top: 1em">P <br>
Page-up (Previous-page)</p>

<p style="margin-top: 1em">Right arrow</p>

<p style="margin-top: 1em">U <br>
Up arrow</p>

<p style="margin-top: 1em">INTR</p>

<p style="margin-top: 1em">EOF</p>

<p style="margin-top: 1em">KILL</p>

<p style="margin-top: 1em">ERASE</p>

<p style="margin-top: 1em">@ <br>
Ctrl + @</p>

<p style="margin-top: 1em">A, B, ..., Z <br>
Ctrl + A, Ctrl + B, ..., Ctrl + Z</p>

<p style="margin-top: 1em">Note that Ctrl + I, Ctrl + J,
and Ctrl + M are tab, newline, and carriage return,
respectively.</p>

<p style="margin-top: 1em">[ <br>
Ctrl + [ (Escape)</p>

<p style="margin-top: 1em">Ctrl + <br>
] <br>
Ctrl + ]</p>

<p style="margin-top: 1em">^ <br>
Ctrl + ^</p>

<p style="margin-top: 1em">_ <br>
Ctrl + _</p>

<p style="margin-top: 1em">? <br>
Ctrl + ? (Delete)</p>

<p style="margin-top: 1em">0, 1, ..., 3 <br>
F0, F1, ..., F63</p>

<p style="margin-top: 1em">1 <br>
Top-left on keypad</p>

<p style="margin-top: 1em">3 <br>
Top-right on keypad</p>

<p style="margin-top: 1em">Center on keypad</p>

<p style="margin-top: 1em">Beginning</p>

<p style="margin-top: 1em">Back-tab</p>

<p style="margin-top: 1em">Bottom-left on keypad</p>

<p style="margin-top: 1em">Bottom-right on keypad</p>

<p style="margin-top: 1em">Clear-all-tabs</p>

<p style="margin-top: 1em">Close</p>

<p style="margin-top: 1em">Cancel</p>

<p style="margin-top: 1em">Command</p>

<p style="margin-top: 1em">Copy</p>

<p style="margin-top: 1em">Create</p>

<p style="margin-top: 1em">Clear-screen or erase</p>

<p style="margin-top: 1em">Clear-tab</p>

<p style="margin-top: 1em">l <br>
Delete-line</p>

<p style="margin-top: 1em">\i <br>
Exit-insert-mode</p>

<p style="margin-top: 1em">\l <br>
Clear-to-end-of-line</p>

<p style="margin-top: 1em">\s <br>
Clear-to-end-of-screen</p>

<p style="margin-top: 1em">\t <br>
Enter (Send)</p>

<p style="margin-top: 1em">\x <br>
Exit</p>

<p style="margin-top: 1em">Find</p>

<p style="margin-top: 1em">Help</p>

<p style="margin-top: 1em">il <br>
Insert-line</p>

<p style="margin-top: 1em">Home-down</p>

<p style="margin-top: 1em">Message</p>

<p style="margin-top: 1em">Mark</p>

<p style="margin-top: 1em">Mouse event</p>

<p style="margin-top: 1em">Move</p>

<p style="margin-top: 1em">0 <br>
Next-object</p>

<p style="margin-top: 1em">Open</p>

<p style="margin-top: 1em">Options</p>

<p style="margin-top: 1em">r <br>
Print (Copy)</p>

<p style="margin-top: 1em">v <br>
Previous-object</p>

<p style="margin-top: 1em">d <br>
Redo</p>

<p style="margin-top: 1em">e <br>
Resume</p>

<p style="margin-top: 1em">f <br>
Ref (Reference)</p>

<p style="margin-top: 1em">h <br>
Refresh</p>

<p style="margin-top: 1em">p <br>
Replace</p>

<p style="margin-top: 1em">s <br>
Restart</p>

<p style="margin-top: 1em">Scroll-forward (Scroll-down)</p>

<p style="margin-top: 1em">Select</p>

<p style="margin-top: 1em">Scroll-backward (Scroll-up)</p>

<p style="margin-top: 1em">Set-tab</p>

<p style="margin-top: 1em">Suspend</p>

<p style="margin-top: 1em">Save</p>

<p style="margin-top: 1em">d <br>
Undo</p>

<p style="margin-top: 1em">Shift + End</p>

<p style="margin-top: 1em">Shift + Home</p>

<p style="margin-top: 1em">Shift + Insert</p>

<p style="margin-top: 1em">Shift + Left arrow</p>

<p style="margin-top: 1em">Shift + Right arrow</p>

<p style="margin-top: 1em">Shift + Delete</p>

<p style="margin-top: 1em">Shift + Beginning</p>

<p style="margin-top: 1em">Shift + Cancel</p>

<p style="margin-top: 1em">Shift + Command</p>

<p style="margin-top: 1em">Shift + Copy</p>

<p style="margin-top: 1em">Shift + Create</p>

<p style="margin-top: 1em">Shift + Delete-line</p>

<p style="margin-top: 1em">Shift + End-of-line</p>

<p style="margin-top: 1em">Shift + Exit</p>

<p style="margin-top: 1em">Shift + Find</p>

<p style="margin-top: 1em">Shift + Help</p>

<p style="margin-top: 1em">Shift + Message</p>

<p style="margin-top: 1em">Shift + Move</p>

<p style="margin-top: 1em">Shift + Next</p>

<p style="margin-top: 1em">Shift + Options</p>

<p style="margin-top: 1em">Shift + Print</p>

<p style="margin-top: 1em">Shift + Previous</p>

<p style="margin-top: 1em">Shift + Redo</p>

<p style="margin-top: 1em">Shift + Resume</p>

<p style="margin-top: 1em">Shift + Replace</p>

<p style="margin-top: 1em">Shift + Suspend</p>

<p style="margin-top: 1em">Shift + Save</p>

<p style="margin-top: 1em">Shift + Undo</p>

<p style="margin-top: 1em">INTR, EOF, KILL, and ERASE are
special characters configured by the stty command. In a
typical configuration, they are sent by typing Ctrl+C,
Ctrl+D, Ctrl+U, and Ctrl+H, <br>
respectively, but some configuration uses Ctrl+? instead of
Ctrl+H for ERASE.</p>

<p style="margin-top: 1em">Command line completion <br>
By using the complete and complete-next-candidate commands,
etc., you can complete command names, options, and operands.
By default, the complete-next-candidate command is bound
<br>
with the Tab key in the vi insert and emacs modes.</p>

<p style="margin-top: 1em">Type a few first letters of a
command name or pathname and hit the Tab key, and a list of
matching names will be shown. You can choose a candidate
from the list to complete the <br>
name by hitting the Tab key again. If there is only one
matching name, no list will be shown and the name will
directly be completed.</p>

<p style="margin-top: 1em">If the name to be completed
contains characters like * and ?, it is treated as a
pattern. The name on the command line will be directly
substituted with all possible names <br>
matching the pattern (you cannot choose from a list).</p>

<p style="margin-top: 1em">Normally, command names are
completed with command names and command arguments with
pathnames. However, completion functions can be defined to
refine completion results.</p>

<p style="margin-top: 1em">Completion details <br>
When doing completion for the first time after the shell has
been started, the INIT file is loaded as if the command
string . -AL completion/INIT is executed. If the file is
<br>
not found, it is silently ignored. This automatic loading is
mainly intended for loading completion functions bundled
with the shell, but you can let the shell load your own <br>
functions by putting a file in the load path.</p>

<p style="margin-top: 1em">When completing a command name,
the shell executes the completion//command function and when
completing a command argument, the completion//argument
function. If those <br>
completion functions are not defined, the shell just
completes with command names or pathnames. When completing
other names, such as the user name in tilde expansion and
the <br>
parameter name in parameter expansion, completion functions
are never used: the shell just completes with user names,
parameter names, or whatever applicable.</p>

<p style="margin-top: 1em">Completion functions are
executed without any arguments. The following local
variables are automatically defined while executing
completion functions:</p>

<p style="margin-top: 1em">IFS <br>
The value is the three characters of a space, a tab, and a
newline, which are the default value of the variable.</p>

<p style="margin-top: 1em">WORDS <br>
This variable is an array whose elements are a command name
and arguments that have already been entered before the
argument being completed. When completing a command <br>
name, the array has no elements.</p>

<p style="margin-top: 1em">TARGETWORD <br>
The value is the partially entered command name or argument
that is being completed.</p>

<p style="margin-top: 1em">Completion candidates are
generated by executing the complete built-in during a
completion function.</p>

<p style="margin-top: 1em">Completion functions must not
perform I/O to the terminal, or displayed text will be
corrupted. Completion functions should run as quickly as
possible for better user <br>
experience.</p>

<p style="margin-top: 1em">While a completion function is
being executed:</p>

<p style="margin-top: 1em">&Acirc;&middot; the
POSIXly-correct mode is temporarily disabled,</p>

<p style="margin-top: 1em">&Acirc;&middot; the err-exit
option is temporarily disabled, and</p>

<p style="margin-top: 1em">&Acirc;&middot; traps are not
executed.</p>

<p style="margin-top: 1em">Command line prediction <br>
This is an experimental feature. When the le-predict option
is enabled, the shell automatically tries to predict a
command string fragment that follows the part of the command
<br>
you have already typed in line-editing.</p>

<p style="margin-top: 1em">For example, assume you have
once typed the command ls Documents. Next time you start
typing ls Doc, the shell will show uments just after the
cursor. If you are satisfied with <br>
this suggestion, you can move the cursor to the right by the
forward-char or any other motion commands instead of typing
the rest of the command. After moving the cursor after <br>
the last s, you can use the accept-line command to execute
the command. You can also use the accept-prediction command
to immediately execute the suggested command without moving
<br>
the cursor.</p>

<p style="margin-top: 1em">To distinguish the typed part
and the predicted part of a command string, you can change
the font style of the typed part by setting the PS1S
variable. Customizing the font style <br>
of the predicted part is not (yet) supported; it is always
shown in the default style.</p>

<p style="margin-top: 1em">When you move the cursor to the
right, the predicted part up to the cursor becomes the typed
part as if you actually typed it. Moving the cursor to the
left does not turn the <br>
typed part back to the prediction. Use deletion commands
such as backward-delete-char to delete typed command
fragment.</p>

<p style="margin-top: 1em">The predicted part of the
command is shown only when the cursor is at the end of the
typed part.</p>

<p style="margin-top: 1em">The prediction algorithm
suggests command fragments on the basis of the command
history. The algorithm considers recent history entries more
probable. It also takes command <br>
succession patterns into account. A predicted command
fragment is not always a complete valid command because less
probable part of the fragment is excluded from
prediction.</p>

<p style="margin-top: 1em">POSIXLY-CORRECT MODE <br>
Yash behaves as defined in POSIX.1-2008, Shell &amp;
Utilities for the most part, but some functionalities
disobey POSIX for usability. When full POSIX-conformance is
needed, you can <br>
enable the POSIXly-correct mode to make yash obey POSIX as
much as possible.</p>

<p style="margin-top: 1em">If yash is started with the name
&acirc;sh&acirc;, the POSIXly-correct mode is automatically
enabled. The -o posixly-correct command-line option also
enables the POSIXly-correct mode. After <br>
yash has been started, the POSIXly-correct mode can be
enabled by executing the command string set -o
posixly-correct.</p>

<p style="margin-top: 1em">When the POSIXly-correct mode is
on, yash not only tries to obey the requirements by POSIX,
but also treats as errors most conditions where the behavior
is undefined or <br>
unspecified by POSIX. As a result, most yash-specific
functionalities are disabled in the POSIXly-correct
mode.</p>

<p style="margin-top: 1em">Below is the complete list of
the behavioral differences between when yash is in the
POSIXly-correct mode and when not. When the POSIXly-correct
mode is enabled:</p>

<p style="margin-top: 1em">&Acirc;&middot; Different
initialization scripts are used.</p>

<p style="margin-top: 1em">&Acirc;&middot; Global aliases
are not substituted.</p>

<p style="margin-top: 1em">&Acirc;&middot; Nested commands
in a compound command must not be empty.</p>

<p style="margin-top: 1em">&Acirc;&middot; Words expanded
in a for loop are assigned as a global variable rather than
a local. The variable must have a portable (ASCII-only)
name.</p>

<p style="margin-top: 1em">&Acirc;&middot; The first
pattern in a case command cannot be esac.</p>

<p style="margin-top: 1em">&Acirc;&middot; The function
keyword cannot be used for function definition. The function
must have a portable (ASCII-only) name.</p>

<p style="margin-top: 1em">&Acirc;&middot; Simple commands
cannot assign to arrays.</p>

<p style="margin-top: 1em">&Acirc;&middot; Changing the
value of the LC_CTYPE variable after the shell has been
initialized does not affect the shell&acirc;s locale.</p>

<p style="margin-top: 1em">&Acirc;&middot; The RANDOM
variable cannot be used to generate random numbers.</p>

<p style="margin-top: 1em">&Acirc;&middot; Tilde expansion
only expands ~ and ~username.</p>

<p style="margin-top: 1em">&Acirc;&middot; Parameter
expansion cannot be nested. No indexes are allowed.</p>

<p style="margin-top: 1em">&Acirc;&middot; The commands in
a command substitution of the form $(commands) are parsed
every time the substitution is executed.</p>

<p style="margin-top: 1em">&Acirc;&middot; In arithmetic
expansion, fractional numbers and the ++ and -- operators
cannot be used. All variables must be numeric.</p>

<p style="margin-top: 1em">&Acirc;&middot; In a redirection
to a file, if the pathname expansion yielded more than one
or no pathname, it is not immediately treated as an error.
Instead, the shell tries to treat the <br>
word before the expansion as a pathname.</p>

<p style="margin-top: 1em">&Acirc;&middot; It is an error
if the contents of a here document is not terminated by an
end token.</p>

<p style="margin-top: 1em">&Acirc;&middot; Socket
redirection, here strings, pipe redirection, and process
redirection cannot be used.</p>

<p style="margin-top: 1em">&Acirc;&middot; When executing a
simple command, failure in command search does not trigger
execution of the COMMAND_NOT_FOUND_HANDLER variable.</p>

<p style="margin-top: 1em">&Acirc;&middot; In command
search, a regular built-in needs to have a corresponding
external command for the built-in to be found.</p>

<p style="margin-top: 1em">&Acirc;&middot; Some built-ins
behave differently. Especially, some command-line options
cannot be used.</p>

<p style="margin-top: 1em">&Acirc;&middot; A
non-interactive shell exits when a special built-in is given
a syntactically wrong arguments or when an error occurs in
assignment or redirection with a special built-in.</p>

<p style="margin-top: 1em">&Acirc;&middot; An interactive
shell does not execute the PROMPT_COMMAND variable before
printing a prompt. The values of the PS1, PS2, and PS4
variables are parsed differently.</p>

<p style="margin-top: 1em">&Acirc;&middot; In mail
checking, a notification message is printed if the file has
been modified, regardless of whether the file is empty.</p>

<p style="margin-top: 1em">FREQUENTLY ASKED QUESTIONS AND
TROUBLESHOOTING <br>
How can I use Unicode (non-ASCII) characters? <br>
You need to set locale environment variables to enable
Unicode character support.</p>

<p style="margin-top: 1em">If the variables have already
been configured for your preference, you probably
don&acirc;t have to do anything. To check the current locale
configurations, you can use the locale <br>
command:</p>

<p style="margin-top: 1em">$ locale <br>
LANG= <br>
LC_CTYPE=&quot;en_US.utf8&quot; <br>
LC_NUMERIC=&quot;en_US.utf8&quot; <br>
LC_TIME=&quot;en_US.utf8&quot; <br>
LC_COLLATE=&quot;en_US.utf8&quot; <br>
LC_MONETARY=&quot;en_US.utf8&quot; <br>
LC_MESSAGES=&quot;en_US.utf8&quot; <br>
LC_PAPER=&quot;en_US.utf8&quot; <br>
LC_NAME=&quot;en_US.utf8&quot; <br>
LC_ADDRESS=&quot;en_US.utf8&quot; <br>
LC_TELEPHONE=&quot;en_US.utf8&quot; <br>
LC_MEASUREMENT=&quot;en_US.utf8&quot; <br>
LC_IDENTIFICATION=&quot;en_US.utf8&quot; <br>
LC_ALL=en_US.utf8</p>

<p style="margin-top: 1em">In this example, the locale
command shows that all the locale setting categories are
configured for the English language, the United States
region, and the UTF-8 encoding.</p>

<p style="margin-top: 1em">If the current configuration
does not seem to match your preference, set the LC_ALL
variable like this:</p>

<p style="margin-top: 1em">export LC_ALL=en_US.utf8</p>

<p style="margin-top: 1em">If you want to use other
languages, regions, or encodings, you have to set the
variable to a different value. Please consult your
OS&acirc;s documentation to learn how to configure <br>
these variables in detail.</p>

<p style="margin-top: 1em">If you want to apply the same
configuration every time you start yash, write the command
in ~/.yashrc or ~/.yash_profile.</p>

<p style="margin-top: 1em">If yash still rejects Unicode
characters being entered, see the section below regarding
line-editing.</p>

<p style="margin-top: 1em">Line-editing does not work <br>
First, type echo $TERM and see if it prints a sane value.
xterm is the safest value that should work on any existing
environment. Colored versions like xterm-16color and other
<br>
terminal types like rxvt and vt100 may also work. All
possible values can be listed by the toe command. It&acirc;s
most desirable to choose a value that matches the actual
terminal <br>
type you are using, but it might not work if the terminal
type you chose is not supported on the system on which yash
is running. If so, try changing the TERM value by export
<br>
TERM=xterm, for example, to find a value that works.</p>

<p style="margin-top: 1em">If line-editing works but you
have trouble entering Unicode (non-ASCII) characters, try
enabling the le-no-conv-meta option by set -o
le-no-conv-meta.</p>

<p style="margin-top: 1em">FORMAL DEFINITION OF COMMAND
SYNTAX <br>
This chapter defines the syntax of shell commands as a
parsing expression grammar.</p>

<p style="margin-top: 1em">The set of terminals of the
grammar is the set of characters that can be handled on the
environment in which the shell is run (a.k.a. execution
character set), with the exception <br>
that the set does not contain the null character (&rsquo;
&rsquo;).</p>

<p style="margin-top: 1em">Below is a list of nonterminals
of the grammar with corresponding parsing expressions. The
list does not include rules for parsing contents and ends of
here documents. In the <br>
POSIXly-correct mode, the grammar varies from the list below
to disable non-POSIX functionalities.</p>

<p style="margin-top: 1em">CompleteCommand <br>
Sequence EOF</p>

<p style="margin-top: 1em">Sequence <br>
N* List*</p>

<p style="margin-top: 1em">List <br>
Pipeline ((&amp;&amp; / ||) N* Pipeline)* ListSeparator</p>

<p style="margin-top: 1em">Pipeline <br>
Bang? Command (| N* Command)*</p>

<p style="margin-top: 1em">Command <br>
CompoundCommand Redirection* /</p>

<p style="margin-top: 1em">!R FunctionDefinition /</p>

<p style="margin-top: 1em">!R SimpleCommand</p>

<p style="margin-top: 1em">CompoundCommand <br>
Subshell /</p>

<p style="margin-top: 1em">Grouping /</p>

<p style="margin-top: 1em">IfCommand /</p>

<p style="margin-top: 1em">ForCommand /</p>

<p style="margin-top: 1em">WhileCommand /</p>

<p style="margin-top: 1em">CaseCommand /</p>

<p style="margin-top: 1em">FunctionCommand</p>

<p style="margin-top: 1em">Subshell <br>
( Sequence ) S*</p>

<p style="margin-top: 1em">Grouping <br>
LeftBrace Sequence RightBrace</p>

<p style="margin-top: 1em">IfCommand <br>
If Sequence Then Sequence (Elif Sequence Then Sequence)*
(Else Sequence)? Fi</p>

<p style="margin-top: 1em">ForCommand <br>
For Name S* Separator? (In Word* Separator)? Do Sequence
Done</p>

<p style="margin-top: 1em">WhileCommand <br>
(While / Until) Sequence Do Sequence Done</p>

<p style="margin-top: 1em">CaseCommand <br>
Case Word N* In N* CaseItem* Esac</p>

<p style="margin-top: 1em">CaseItem <br>
!Esac (( S*)? Word (| S* Word)* ) Sequence (;; /
&amp;Esac)</p>

<p style="margin-top: 1em">FunctionCommand <br>
Function Word (( S* ))? N* CompoundCommand Redirection*</p>

<p style="margin-top: 1em">FunctionDefinition <br>
Name S* ( S* ) N* CompoundCommand Redirection*</p>

<p style="margin-top: 1em">SimpleCommand <br>
&amp;(Word / Redirection) (Assignment / Redirection)* (Word
/ Redirection)*</p>

<p style="margin-top: 1em">Assignment <br>
Name = Word /</p>

<p style="margin-top: 1em">Name =( N* (Word N*)* )</p>

<p style="margin-top: 1em">Name <br>
![[:digit:]] [[:alnum:] _]+</p>

<p style="margin-top: 1em">PortableName <br>
![0-9] [0-9
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_]+</p>

<p style="margin-top: 1em">Word <br>
(WordElement / !SpecialChar .)+ S*</p>

<p style="margin-top: 1em">WordElement &nbsp; <br>
. /</p>

<p style="margin-top: 1em">&rsquo; (!&rsquo; .)* &rsquo;
/</p>

<p style="margin-top: 1em">&quot; QuoteElement* &quot;
/</p>

<p style="margin-top: 1em">Parameter /</p>

<p style="margin-top: 1em">Arithmetic /</p>

<p style="margin-top: 1em">CommandSubstitution</p>

<p style="margin-top: 1em">QuoteElement &nbsp; <br>
([$&lsquo;&quot;] / NL) /</p>

<p style="margin-top: 1em">Parameter /</p>

<p style="margin-top: 1em">Arithmetic /</p>

<p style="margin-top: 1em">CommandSubstitution /</p>

<p style="margin-top: 1em">![&lsquo;&quot;] .</p>

<p style="margin-top: 1em">Parameter <br>
$ [@*#?-$! [:digit:]] /</p>

<p style="margin-top: 1em">$ PortableName /</p>

<p style="margin-top: 1em">$ ParameterBody</p>

<p style="margin-top: 1em">ParameterBody <br>
{ ParameterNumber? (ParameterName / ParameterBody /
Parameter) ParameterIndex? ParameterMatch? }</p>

<p style="margin-top: 1em">ParameterNumber <br>
# ![+=:/%] !([-?#] })</p>

<p style="margin-top: 1em">ParameterName <br>
[@*#?-$!] /</p>

<p style="margin-top: 1em">[[:alnum:] _]+</p>

<p style="margin-top: 1em">ParameterIndex <br>
[ ParameterIndexWord (, ParameterIndexWord)? ]</p>

<p style="margin-top: 1em">ParameterIndexWord <br>
(WordElement / ![&quot;&rsquo;],] .)+</p>

<p style="margin-top: 1em">ParameterMatch <br>
:? [-+=?] ParameterMatchWord /</p>

<p style="margin-top: 1em">(# / ## / % / %%)
ParameterMatchWord /</p>

<p style="margin-top: 1em">(:/ / / [#%/]?)
ParameterMatchWordNoSlash (/ ParameterMatchWord)?</p>

<p style="margin-top: 1em">ParameterMatchWord <br>
(WordElement / ![&quot;&rsquo;}] .)*</p>

<p style="margin-top: 1em">ParameterMatchWordNoSlash <br>
(WordElement / ![&quot;&rsquo;/}] .)*</p>

<p style="margin-top: 1em">Arithmetic <br>
$(( ArithmeticBody* ))</p>

<p style="margin-top: 1em">ArithmeticBody &nbsp; <br>
. /</p>

<p style="margin-top: 1em">Parameter /</p>

<p style="margin-top: 1em">Arithmetic /</p>

<p style="margin-top: 1em">CommandSubstitution /</p>

<p style="margin-top: 1em">( ArithmeticBody ) /</p>

<p style="margin-top: 1em">![&lsquo;()] .</p>

<p style="margin-top: 1em">CommandSubstitution <br>
$( Sequence ) /</p>

<p style="margin-top: 1em">&lsquo; CommandSubstitutionBody*
&lsquo;</p>

<p style="margin-top: 1em">CommandSubstitutionBody &nbsp;
<br>
[$&lsquo;] /</p>

<p style="margin-top: 1em">!&lsquo; .</p>

<p style="margin-top: 1em">Redirection <br>
RedirectionFD RedirectionOperator S* Word /</p>

<p style="margin-top: 1em">RedirectionFD &lt;( Sequence )
/</p>

<p style="margin-top: 1em">RedirectionFD &gt;( Sequence
)</p>

<p style="margin-top: 1em">RedirectionFD <br>
[[:digit:]]*</p>

<p style="margin-top: 1em">RedirectionOperator <br>
&lt; / &lt;&gt; / &gt; / &gt;| / &gt;&gt; / &gt;&gt;| /
&lt;&amp; / &gt;&amp; / &lt;&lt; / &lt;&lt;- /
&lt;&lt;&lt;</p>

<p style="margin-top: 1em">ListSeparator <br>
Separator /</p>

<p style="margin-top: 1em">&amp; N* /</p>

<p style="margin-top: 1em">&amp;) /</p>

<p style="margin-top: 1em">&amp;;;</p>

<p style="margin-top: 1em">Separator <br>
; N* /</p>

<p style="margin-top: 1em">N+ /</p>

<p style="margin-top: 1em">EOF</p>

<p style="margin-top: 1em">N <br>
S* NL</p>

<p style="margin-top: 1em">S <br>
[[:blank:]] /</p>

<p style="margin-top: 1em">Comment</p>

<p style="margin-top: 1em">Comment <br>
# (!NL .)*</p>

<p style="margin-top: 1em">R <br>
Bang / LeftBrace / RightBrace / Case / Do / Done / Elif /
Else / Esac / Fi / For / If / In / Then / Until / While</p>

<p style="margin-top: 1em">Bang <br>
! D</p>

<p style="margin-top: 1em">LeftBrace <br>
{ D</p>

<p style="margin-top: 1em">RightBrace <br>
} D</p>

<p style="margin-top: 1em">Case <br>
case D</p>

<p style="margin-top: 1em">Do <br>
do D</p>

<p style="margin-top: 1em">Done <br>
done D</p>

<p style="margin-top: 1em">Elif <br>
elif D</p>

<p style="margin-top: 1em">Else <br>
else D</p>

<p style="margin-top: 1em">Esac <br>
esac D</p>

<p style="margin-top: 1em">Fi <br>
fi D</p>

<p style="margin-top: 1em">For <br>
for D</p>

<p style="margin-top: 1em">Function <br>
function D</p>

<p style="margin-top: 1em">If <br>
if D</p>

<p style="margin-top: 1em">In <br>
in D</p>

<p style="margin-top: 1em">Then <br>
then D</p>

<p style="margin-top: 1em">Until <br>
until D</p>

<p style="margin-top: 1em">While <br>
while D</p>

<p style="margin-top: 1em">D <br>
!Word S*</p>

<p style="margin-top: 1em">SpecialChar <br>
[|&amp;;&lt;&gt;()&lsquo;</p>

<p style="margin-top: 1em">NL <br>
&lt;newline&gt;</p>

<p style="margin-top: 1em">EOF <br>
!.</p>

<p style="margin-top: 1em">ALIAS BUILT-IN <br>
The alias built-in defines and/or prints aliases.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; alias [-gp] [name[=value]...]</p>

<p style="margin-top: 1em">Description <br>
The alias built-in defines and/or prints aliases as
specified by operands. The printed aliases can be used as
(part of) shell commands. The built-in prints all currently
defined <br>
aliases when given no operands.</p>

<p style="margin-top: 1em">Options <br>
-g, --global <br>
With this option, aliases are defined as global aliases;
without this option, as normal aliases.</p>

<p style="margin-top: 1em">-p, --prefix <br>
With this option, aliases are printed in a full command form
like alias -g foo=&rsquo;bar&rsquo;. Without this option,
only command operands are printed like
foo=&rsquo;bar&rsquo;.</p>

<p style="margin-top: 1em">Operands <br>
name <br>
The name of an alias that should be printed.</p>

<p style="margin-top: 1em">name=value <br>
The name and value of an alias that is being defined.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the alias built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The characters that cannot be used in an alias name are the
space, tab, newline, and any of
=$&lt;&gt;&acute;&quot;&lsquo;;&amp;|()#. You can use any
characters in an alias value.</p>

<p style="margin-top: 1em">The alias built-in is a
semi-special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines no
options for the alias built-in, thus no options are
available in the POSIXly correct mode.</p>

<p style="margin-top: 1em">ARRAY BUILT-IN <br>
The array built-in prints or modifies arrays.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; array</p>

<p style="margin-top: 1em">&Acirc;&middot; array name
[value...]</p>

<p style="margin-top: 1em">&Acirc;&middot; array -d name
[index...]</p>

<p style="margin-top: 1em">&Acirc;&middot; array -i name
index [value...]</p>

<p style="margin-top: 1em">&Acirc;&middot; array -s name
index value</p>

<p style="margin-top: 1em">Description <br>
When executed without any option or operands, the built-in
prints all array definitions to the standard output in a
form that can be parsed as commands.</p>

<p style="margin-top: 1em">When executed with name and
values (but without an option), the built-in sets the values
as the values of the array named name.</p>

<p style="margin-top: 1em">With the -d (--delete) option,
the built-in removes the indexth values of the array named
name. The number of values in the array will be decreased by
the number of the indexes <br>
specified. If the indexth value does not exist, it is
silently ignored.</p>

<p style="margin-top: 1em">With the -i (--insert) option,
the built-in inserts values into the array named name. The
number of values in the array will be increased by the
number of the values specified. <br>
The values are inserted between the indexth and next values.
If index is zero, the values are inserted before the first
value. If index is larger than the number of values in the
<br>
array, the values are appended after the last element.</p>

<p style="margin-top: 1em">With the -s (--set) option, the
built-in sets value as the indexth value of the array named
name. The array must have at least index values.</p>

<p style="margin-top: 1em">Options <br>
-d, --delete <br>
Delete array values.</p>

<p style="margin-top: 1em">-i, --insert <br>
Insert array values.</p>

<p style="margin-top: 1em">-s, --set <br>
Set an array value.</p>

<p style="margin-top: 1em">Operands <br>
name <br>
The name of an array to operate on.</p>

<p style="margin-top: 1em">index <br>
The index to an array element. The first element has the
index of 1.</p>

<p style="margin-top: 1em">value <br>
A string to which the array element is set.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the array built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The array built-in is not defined in the POSIX standard.</p>

<p style="margin-top: 1em">The command array name value...
is equivalent to the assignment name=(value...).</p>

<p style="margin-top: 1em">BG BUILT-IN <br>
The bg built-in resumes a job in the background.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; bg [job...]</p>

<p style="margin-top: 1em">Description <br>
The bg built-in sends the SIGCONT signal to the specified
job. As a result, the job is resumed in the background (if
it has been suspended).</p>

<p style="margin-top: 1em">The name of the job is printed
when the job is resumed.</p>

<p style="margin-top: 1em">The built-in can be used only
when job control is enabled.</p>

<p style="margin-top: 1em">Operands <br>
job <br>
The job ID of the job to be resumed.</p>

<p style="margin-top: 1em">More than one job can be
specified at a time. The current job is resumed if none is
specified.</p>

<p style="margin-top: 1em">The percent sign (%) at the
beginning of a job ID can be omitted if the shell is not in
the POSIXly-correct mode.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the bg built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Notes <br>
The bg built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">The POSIX standard provides that
the built-in shall have no effect when the job is already
running. The bg built-in of yash, however, always sends the
SIGCONT signal to the job.</p>

<p style="margin-top: 1em">BINDKEY BUILT-IN <br>
The bindkey built-in prints or modifies key bindings used in
line-editing.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; bindkey -aev [key [command]]</p>

<p style="margin-top: 1em">&Acirc;&middot; bindkey -l</p>

<p style="margin-top: 1em">Description <br>
When executed with the -l (--list) option, the built-in
lists all available line-editing commands to the standard
output.</p>

<p style="margin-top: 1em">When executed with one of the
other options, the built-in prints or modifies key bindings
for the editing mode specified by the option:</p>

<p style="margin-top: 1em">&Acirc;&middot; Without key or
command, all currently defined bindings are printed to the
standard output in a form that can be parsed as commands
that restore the current bindings when <br>
executed.</p>

<p style="margin-top: 1em">&Acirc;&middot; With key but
without command, only the binding for the given key is
printed.</p>

<p style="margin-top: 1em">&Acirc;&middot; With key and
command, key is bound to command.</p>

<p style="margin-top: 1em">Options <br>
-a, --vi-command <br>
Print or modify bindings for the vi command mode.</p>

<p style="margin-top: 1em">-e, --emacs <br>
Print or modify bindings for the emacs mode.</p>

<p style="margin-top: 1em">-v, --vi-insert <br>
Print or modify bindings for the vi insert mode.</p>

<p style="margin-top: 1em">Operands <br>
key <br>
A character sequence of one or more keys that is bound to an
editing command. The sequence may include escape
sequences.</p>

<p style="margin-top: 1em">command <br>
A line-editing command to which key is bound. If command is
a single hyphen (-), key is unbound.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the bindkey built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The bindkey built-in is a semi-special built-in. In the
POSIX standard, it is defined as a command with unspecified
behavior.</p>

<p style="margin-top: 1em">BREAK BUILT-IN <br>
The break built-in aborts a loop being executed.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; break [nest]</p>

<p style="margin-top: 1em">&Acirc;&middot; break -i</p>

<p style="margin-top: 1em">Description <br>
When executed without the -i (--iteration) option, the
built-in aborts a currently executed for, while, or until
loop. When executed in nested loops, it aborts the nestth
<br>
innermost loop. The default nest is one. If the number of
currently executed nested loops is less than nest, the
built-in aborts the outermost loop.</p>

<p style="margin-top: 1em">When executed with the -i
(--iteration) option, the built-in aborts the currently
executed (innermost) iterative execution.</p>

<p style="margin-top: 1em">Options <br>
-i, --iteration <br>
Abort an iterative execution instead of a loop.</p>

<p style="margin-top: 1em">Operands <br>
nest <br>
The number of loops to abort, which must be a positive
integer.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the break built-in is:</p>

<p style="margin-top: 1em">&Acirc;&middot; zero if a loop
was successfully aborted.</p>

<p style="margin-top: 1em">&Acirc;&middot; that of the
command that was executed just before the break built-in if
an iterative execution was successfully aborted.</p>

<p style="margin-top: 1em">Notes <br>
The break built-in is a special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines no
options for the break built-in; the built-in accepts no
options in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">Treatment of currently executed
loops that are not lexically enclosing the break built-in is
unspecified in POSIX. Examples of such loops include:</p>

<p style="margin-top: 1em">&Acirc;&middot; A loop invoking
a function in which the break built-in is used.</p>

<p style="margin-top: 1em">&Acirc;&middot; A loop in which
a trap action is executed in which the break built-in is
used.</p>

<p style="margin-top: 1em">Yash does not allow breaking
such loops.</p>

<p style="margin-top: 1em">CD BUILT-IN <br>
The cd built-in changes the working directory.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; cd [-L|-P] [directory]</p>

<p style="margin-top: 1em">Description <br>
The cd built-in changes the working directory to the
directory specified by the operand. The pathname of the new
working directory is assigned to the PWD variable, whose
previous <br>
value is again assigned to the OLDPWD variable.</p>

<p style="margin-top: 1em">If directory is a relative path
that does not start with &acirc;.&acirc; or
&acirc;..&acirc;, paths in the CDPATH variable are searched
to find a new working directory. The search is done in a
manner <br>
similar to the last step of command search, but a directory
is sought instead of an executable regular file. If a new
working directory was found from CDPATH, its pathname is
<br>
printed to the standard output. If no applicable directory
was found in the search, directory is simply treated as a
pathname relative to the current working directory.</p>

<p style="margin-top: 1em">If the working directory was
successfully changed, the value of the YASH_AFTER_CD
variable is executed as a command unless the shell is in the
POSIXly-correct mode. If the <br>
variable is an array, its values are executed iteratively
(cf. eval built-in).</p>

<p style="margin-top: 1em">Options <br>
-L, --logical <br>
Symbolic links in the pathname of the new working directory
are not resolved. The new value of the PWD may include
pathname components that are symbolic links.</p>

<p style="margin-top: 1em">-P, --physical <br>
Symbolic links in the pathname of the new working directory
are resolved. The new value of the PWD variable never
includes pathname components that are symbolic links.</p>

<p style="margin-top: 1em">--default-directory=directory
<br>
If this option is specified and the directory operand is
omitted, the argument to this option is used for the
directory operand. If the directory operand is specified,
this <br>
option is ignored.</p>

<p style="margin-top: 1em">The -L (--logical) and -P
(--physical) options are mutually exclusive: only the last
specified one is effective. If neither is specified, -L is
assumed.</p>

<p style="margin-top: 1em">Operands <br>
directory <br>
The pathname of the new working directory.</p>

<p style="margin-top: 1em">If directory is a single hyphen
(&acirc;-&acirc;), the value of the OLDPWD variable is
assumed for the new directory pathname, which is printed to
the standard output.</p>

<p style="margin-top: 1em">If directory is omitted, the
working directory is changed to the directory specified by
the --default-directory=... option. If that option is not
specified either, the <br>
default is the home directory.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the cd built-in is zero if the working
directory was successfully changed and non-zero if there was
an error.</p>

<p style="margin-top: 1em">Notes <br>
The cd built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">The POSIX standard does not
define the use of the YASH_AFTER_CD variable or the
--default-directory=... option. The standard does not allow
using an option with a single hyphen <br>
operand.</p>

<p style="margin-top: 1em">The exit status of the commands
in the YASH_AFTER_CD variable does not affect that of the cd
built-in.</p>

<p style="margin-top: 1em">COLON BUILT-IN <br>
The colon built-in does nothing.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; : [argument...]</p>

<p style="margin-top: 1em">Description <br>
The colon built-in does nothing. Any command line arguments
are ignored.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the colon built-in is zero.</p>

<p style="margin-top: 1em">Notes <br>
The colon built-in is a special built-in.</p>

<p style="margin-top: 1em">Arguments are expanded and
redirections are performed as usual. The colon and true
built-ins have the same effect, but colon is a special
built-in while true is a semi-special.</p>

<p style="margin-top: 1em">COMMAND BUILT-IN <br>
The command built-in executes or identifies a command.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; command [-befp] command [argument...]</p>

<p style="margin-top: 1em">&Acirc;&middot; command -v|-V
[-abefkp] command...</p>

<p style="margin-top: 1em">Description <br>
Without the -v (--identify) or -V (--verbose-identify)
option, the built-in executes command with arguments in the
same manner as the last step of execution of simple
commands. <br>
The command is treated as a built-in or external command or
a function according to the options specified to the command
built-in. The shell does not exit on argument syntax <br>
error etc. even if the command is a special built-in</p>

<p style="margin-top: 1em">With the -v (--identify) option,
command is identified. If the command is found in $PATH, its
full pathname is printed. If it is a keyword, function, or
built-in that is not <br>
found in $PATH, the command name is simply printed. If it is
an alias, it is printed in the form like alias ll=&rsquo;ls
-l&rsquo;. If the command is not found, nothing is printed
and the <br>
exit status is non-zero.</p>

<p style="margin-top: 1em">The -V (--verbose-identify)
option is similar to the -v (--identify) option, but the
output format is more human-friendly.</p>

<p style="margin-top: 1em">Options <br>
-a, --alias <br>
Search for the command as an alias. Must be used with the -v
(--identify) or -V (--verbose-identify) option.</p>

<p style="margin-top: 1em">-b, --builtin-command <br>
Search for the command as a built-in.</p>

<p style="margin-top: 1em">-e, --external-command <br>
Search for the command as an external command.</p>

<p style="margin-top: 1em">-f, --function <br>
Search for the command as a function.</p>

<p style="margin-top: 1em">-k, --keyword <br>
Search for the command as a keyword. Must be used with the
-v (--identify) or -V (--verbose-identify) option.</p>

<p style="margin-top: 1em">-p, --standard-path <br>
Search the system&acirc;s default PATH instead of the
current $PATH.</p>

<p style="margin-top: 1em">-v, --identify <br>
Identify commands and print in the format defined in the
POSIX standard.</p>

<p style="margin-top: 1em">-V, --verbose-identify <br>
Identify commands and print in a human-friendly format.</p>

<p style="margin-top: 1em">If none of the -a (--alias), -b
(--builtin-command), -e (--external-command), -f
(--function), and -k (--keyword) options is specified, the
following defaults are assumed:</p>

<p style="margin-top: 1em">Without the -v (--identify) or
-V (--verbose-identify) option <br>
-b -e</p>

<p style="margin-top: 1em">With the -v (--identify) or -V
(--verbose-identify) option <br>
-a -b -e -f -k</p>

<p style="margin-top: 1em">Operands <br>
command <br>
A command to be executed or identified.</p>

<p style="margin-top: 1em">argument... <br>
Arguments passed to the executed command.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the command built-in is:</p>

<p style="margin-top: 1em">Without the -v (--identify) or
-V (--verbose-identify) option <br>
the exit status of the executed command.</p>

<p style="margin-top: 1em">With the -v (--identify) or -V
(--verbose-identify) option <br>
zero unless there is any error.</p>

<p style="margin-top: 1em">Notes <br>
The command built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">In the POSIXly-correct mode,
options other than -p, -v, and -V cannot be used and at most
one command can be specified. The POSIX standard does not
allow specifying both -v and <br>
-V together, but yash does (only the last specified one is
effective).</p>

<p style="margin-top: 1em">COMPLETE BUILT-IN <br>
The complete built-in generates completion candidates. This
built-in can only be executed from completion functions
during command line completion.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; complete [-A pattern] [-R pattern] [-T] [-P
prefix] [-S suffix] [-abcdfghjkuv] [[-O] [-D description]
word...]</p>

<p style="margin-top: 1em">Description <br>
The built-in generates completion candidates according to
the specified arguments. No matter how candidates are
generated, only candidates that match the word being
completed are <br>
generated.</p>

<p style="margin-top: 1em">Options <br>
-A pattern, --accept=pattern <br>
Only accept candidates that match the pattern specified by
this option. When more than one of this option is specified,
only candidates that match all of the patterns are <br>
generated.</p>

<p style="margin-top: 1em">-D description,
--description=description <br>
Give a description of the word candidates. The description
is shown beside the candidates in the candidate list.</p>

<p style="margin-top: 1em">-O, --option <br>
The candidates are treated as command line options. A hyphen
is prepended to each candidate that is treated as an
option.</p>

<p style="margin-top: 1em">-P prefix, --prefix=prefix <br>
Ignore prefix of the word being completed when generating
candidates. The specified prefix must be initial part of the
word.</p>

<p style="margin-top: 1em">If the word being completed is
file:///home/user/docume for example, the command line
complete -P file:// -f will generate pathname candidates
that complete <br>
/home/user/docume.</p>

<p style="margin-top: 1em">-R pattern, --reject=pattern
<br>
Reject candidates that match the pattern specified by this
option. When more than one of this option is specified, only
candidates that match none of the patterns are <br>
generated.</p>

<p style="margin-top: 1em">-S suffix, --suffix=suffix <br>
Append suffix to each generated candidate.</p>

<p style="margin-top: 1em">-T, --no-termination <br>
Do not append a space after the word is completed. Without
this option, a space is appended to the completed word so
that you do not have to enter a space before the next <br>
word.</p>

<p style="margin-top: 1em">Options that select candidate
types <br>
-a, --alias <br>
Aliases. (same as --normal-alias --global-alias)</p>

<p style="margin-top: 1em">--array-variable <br>
Arrays.</p>

<p style="margin-top: 1em">--bindkey <br>
Line-editing commands the bindkey built-in accepts.</p>

<p style="margin-top: 1em">-b, --builtin-command <br>
Built-in commands. (same as --special-builtin
--semi-special-builtin --regular-builtin)</p>

<p style="margin-top: 1em">-c, --command <br>
Commands. (same as --builtin-command --external-command
--function)</p>

<p style="margin-top: 1em">-d, --directory <br>
Directories.</p>

<p style="margin-top: 1em">--dirstack-index <br>
Valid indices of the directory stack.</p>

<p style="margin-top: 1em">--executable-file <br>
Executable regular files.</p>

<p style="margin-top: 1em">--external-command <br>
External commands.</p>

<p style="margin-top: 1em">-f, --file <br>
Files (including directories).</p>

<p style="margin-top: 1em">--finished-job <br>
Job IDs of finished jobs.</p>

<p style="margin-top: 1em">--function <br>
Functions.</p>

<p style="margin-top: 1em">--global-alias <br>
Global aliases.</p>

<p style="margin-top: 1em">-g, --group <br>
User groups.</p>

<p style="margin-top: 1em">-h, --hostname <br>
Host names.</p>

<p style="margin-top: 1em">-j, --job <br>
Job IDs.</p>

<p style="margin-top: 1em">-k, --keyword <br>
Keywords.</p>

<p style="margin-top: 1em">--normal-alias <br>
Normal aliases.</p>

<p style="margin-top: 1em">--regular-builtin <br>
Regular built-in commands.</p>

<p style="margin-top: 1em">--running-job <br>
Job IDs of jobs that are being executed.</p>

<p style="margin-top: 1em">--scalar-variable <br>
Variables that are not arrays.</p>

<p style="margin-top: 1em">--semi-special-builtin <br>
Semi-special built-in commands.</p>

<p style="margin-top: 1em">--signal <br>
Signals.</p>

<p style="margin-top: 1em">--special-builtin <br>
Special built-in commands.</p>

<p style="margin-top: 1em">--stopped-job <br>
Job IDs of jobs that are suspended.</p>

<p style="margin-top: 1em">-u, --username <br>
Users&rsquo; log-in names.</p>

<p style="margin-top: 1em">-v, --variable <br>
Variables.</p>

<p style="margin-top: 1em">If the -d (--directory) option
is specified without the -f (--file) option, the -S / -T
options are assumed.</p>

<p style="margin-top: 1em">Generated candidates for job IDs
do not have leading percent signs (%). If the word being
completed starts with a percent sign, the -P % option should
be specified.</p>

<p style="margin-top: 1em">Operands <br>
Operands are treated as completion candidates.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the built-in is zero if one or more
candidates were generated, one if no candidates were
generated, or larger than one if an error occurred.</p>

<p style="margin-top: 1em">Notes <br>
The complete built-in is a semi-special built-in. In the
POSIX standard, it is defined as a command with unspecified
behavior.</p>

<p style="margin-top: 1em">CONTINUE BUILT-IN <br>
The continue built-in skips an iteration of a loop being
executed.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; continue [nest]</p>

<p style="margin-top: 1em">&Acirc;&middot; continue -i</p>

<p style="margin-top: 1em">Description <br>
When executed without the -i (--iteration) option, the
built-in aborts the current iteration of for, while, or
until loop and starts the next iteration of the loop. When
executed <br>
in nested loops, it affects the nestth innermost loop. The
default nest is one. If the number of currently executed
nested loops is less than nest, the built-in affects the
<br>
outermost loop.</p>

<p style="margin-top: 1em">When executed with the -i
(--iteration) option, the built-in aborts the current
iteration of (innermost) iterative execution.</p>

<p style="margin-top: 1em">Options <br>
-i, --iteration <br>
Skip an iterative execution instead of a loop.</p>

<p style="margin-top: 1em">Operands <br>
nest <br>
The nestth innermost loop is affected. nest must be a
positive integer.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the continue built-in is:</p>

<p style="margin-top: 1em">&Acirc;&middot; zero if loop
iteration was successfully skipped.</p>

<p style="margin-top: 1em">&Acirc;&middot; that of the
command that was executed just before the continue built-in
if iterative execution was successfully skipped.</p>

<p style="margin-top: 1em">Notes <br>
The continue built-in is a special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines no
options for the continue built-in; the built-in accepts no
options in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">Treatment of currently executed
loops that are not lexically enclosing the continue built-in
is unspecified in POSIX. Examples of such loops include:</p>

<p style="margin-top: 1em">&Acirc;&middot; A loop invoking
a function in which the continue built-in is used</p>

<p style="margin-top: 1em">&Acirc;&middot; A loop in which
a trap action is executed in which the continue built-in is
used</p>

<p style="margin-top: 1em">Yash does not allow continuing
such loops.</p>

<p style="margin-top: 1em">DIRS BUILT-IN <br>
The dirs built-in prints the contents of the directory
stack.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; dirs [-cv] [index..]</p>

<p style="margin-top: 1em">Description <br>
The directory stack is a feature that records history of
working directories. You can use the pushd built-in to save
a working directory in the directory stack, the popd
built-in <br>
to recall the saved working directory, and the dirs built-in
to see the stack contents. Those built-ins use the DIRSTACK
array and the PWD variable to save the stack contents. <br>
Modifying the array means modifying the stack contents.</p>

<p style="margin-top: 1em">Directory stack entries are
indexed by signed integers. The entry of index +0 is the
current working directory, +1 is the last saved directory,
+2 is the second last, and so on. <br>
Negative indices are in the reverse order: the entry of
index -0 is the first saved directory, -1 is the second, and
-n is the current working directory if the stack has n <br>
entries,</p>

<p style="margin-top: 1em">When executed without the -c
(--clear) option, the dirs built-in prints the current
contents of the directory stack to the standard output. With
the -c (--clear) option, the <br>
built-in clears the directory stack.</p>

<p style="margin-top: 1em">Options <br>
-c, --clear <br>
Clear the directory stack contents except for the current
working directory, which has index +0.</p>

<p style="margin-top: 1em">-v, --verbose <br>
Print indices when printing stack contents.</p>

<p style="margin-top: 1em">Operands <br>
index <br>
The index of a stack entry to be printed.</p>

<p style="margin-top: 1em">You can specify more than one
index. If you do not specify any index, all the entries are
printed.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the dirs built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Notes <br>
The dirs built-in is a semi-special built-in. In the POSIX
standard, it is defined as a command with unspecified
behavior.</p>

<p style="margin-top: 1em">DISOWN BUILT-IN <br>
The disown built-in removes jobs.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; disown [-a] [job...}</p>

<p style="margin-top: 1em">Description <br>
The disown built-in removes the specified jobs from the job
list. The removed jobs will no longer be job-controlled, but
the job processes continue execution (unless they have <br>
been suspended).</p>

<p style="margin-top: 1em">Options <br>
-a, --all <br>
Removes all jobs.</p>

<p style="margin-top: 1em">Operands <br>
job <br>
The job ID of the job to be removed.</p>

<p style="margin-top: 1em">You can specify more than one
job ID. If you do not specify any job ID, the current job is
removed. If the shell is not in the POSIXly-correct mode,
the %-prefix of the job <br>
ID can be omitted.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the disown built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The disown built-in is a semi-special built-in. In the POSIX
standard, it is defined as a command with unspecified
behavior.</p>

<p style="margin-top: 1em">DOT BUILT-IN <br>
The dot built-in reads a file and executes commands in
it.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; . [-AL] file [argument...]</p>

<p style="margin-top: 1em">Description <br>
The dot built-in reads the specified file, parses its
contents as commands, and executes them in the current
command execution environment.</p>

<p style="margin-top: 1em">If arguments are specified,
positional parameters are temporarily set to them. The
positional parameters will be restored when the dot built-in
finishes. If no arguments are <br>
specified, the positional parameters are not changed.</p>

<p style="margin-top: 1em">If file does not contain any
slashes, the shell searches $PATH for a readable (but not
necessarily executable) shell script file whose name is file
in the same manner as command <br>
search. If no such file was found, the shell searches the
current working directory for a file unless in the
POSIXly-correct mode. To ensure that the file in the current
working <br>
directory is used, start file with &acirc;./&acirc;.</p>

<p style="margin-top: 1em">Options <br>
-A, --no-alias <br>
Disable alias substitution while parsing.</p>

<p style="margin-top: 1em">-L, --autoload <br>
Search $YASH_LOADPATH instead of $PATH, regardless of
whether file contains slashes. The file value is not
considered relative to the current working directory.</p>

<p style="margin-top: 1em">The dot built-in treats as
operands any command line arguments after the first
operand.</p>

<p style="margin-top: 1em">Operands <br>
file <br>
The pathname of a file to be read.</p>

<p style="margin-top: 1em">arguments... <br>
Strings to which positional parameters are set while
execution.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the dot built-in is that of the last
command executed. The exit status is zero if the file
contains no commands to execute and non-zero if a file was
not found <br>
or could not be opened.</p>

<p style="margin-top: 1em">Notes <br>
The dot built-in is a special built-in.</p>

<p style="margin-top: 1em">A non-interactive shell
immediately exits with a non-zero exit status if the dot
built-in fails to find or open a file to execute.</p>

<p style="margin-top: 1em">The POSIX standard defines no
options for the dot built-in; the built-in accepts no
options in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">The POSIX standard does not
define the arguments... operands. It is an error to specify
the arguments... operands in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">ECHO BUILT-IN <br>
The echo built-in prints its arguments.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; echo [string...]</p>

<p style="margin-top: 1em">The built-in treats all command
line arguments as operands except for the options described
below. Any word that cannot be parsed as an acceptable
option is treated as an <br>
operand. Options must precede all operands. Syntax errors
never happen in the echo built-in.</p>

<p style="margin-top: 1em">Description <br>
The echo built-in prints the operand strings followed by a
newline to the standard output. The strings are each
separated by a space.</p>

<p style="margin-top: 1em">Escape sequences <br>
The ECHO_STYLE variable and the -e option enable escape
sequences that are replaced with corresponding
characters:</p>

<p style="margin-top: 1em">Bell character (ASCII code: 7) B
a c k s p a c e ( A S C I I c o d e : 8 )</p>

<p style="margin-top: 1em">Nothing. After this escape
sequence, no characters are printed at all.</p>

<p style="margin-top: 1em">\ <br>
Escape character (ASCII code: 27)</p>

<p style="margin-top: 1em">Form feed character (ASCII code:
12)</p>

<p style="margin-top: 1em">Newline character (ASCII code:
10)</p>

<p style="margin-top: 1em">Carriage return character (ASCII
code: 13)</p>

<p style="margin-top: 1em">Horizontal tab character (ASCII
code: 9)</p>

<p style="margin-top: 1em">Vertical tab character (ASCII
code: 11)</p>

<p style="margin-top: 1em">\ <br>
Backslash</p>

<p style="margin-top: 1em">xxx <br>
Character whose code is xxx, where xxx is an octal number of
at most three digits.</p>

<p style="margin-top: 1em">When escape sequences are not
enabled, they are just printed intact.</p>

<p style="margin-top: 1em">ECHO_STYLE variable <br>
The ECHO_STYLE variable defines which options are accepted
and whether escape sequences are enabled by default. The
variable value should be set to one of the following:</p>

<p style="margin-top: 1em">SYSV, XSI <br>
No options are accepted. Escape sequences are always
enabled.</p>

<p style="margin-top: 1em">BSD <br>
The -n option is accepted. Escape sequences are never
enabled.</p>

<p style="margin-top: 1em">GNU <br>
The -n, -e, and -E options are accepted. Escape sequences
are not enabled by default, but can be enabled by the -e
option.</p>

<p style="margin-top: 1em">ZSH <br>
The -n, -e, and -E options are accepted. Escape sequences
are enabled by default, but can be disabled by the -E
option.</p>

<p style="margin-top: 1em">DASH <br>
The -n option is accepted. Escape sequences are always
enabled.</p>

<p style="margin-top: 1em">RAW <br>
No options are accepted. Escape sequences are never
enabled.</p>

<p style="margin-top: 1em">When the ECHO_STYLE variable is
not set, it defaults to SYSV.</p>

<p style="margin-top: 1em">Options <br>
-n <br>
Do not print a newline at the end.</p>

<p style="margin-top: 1em">-e <br>
Enable escape sequences.</p>

<p style="margin-top: 1em">-E <br>
Disable escape sequences.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the echo built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Notes <br>
The POSIX standard does not define the ECHO_STYLE variable
nor any options for the built-in. According to POSIX, the
behavior of the built-in is implementation-defined when the
<br>
first argument is -n or when any argument contains a
backslash. For maximum portability, the printf built-in
should be preferred over the echo built-in.</p>

<p style="margin-top: 1em">Although many values for the
ECHO_STYLE variable are defined on the basis of other
existing implementations, yash is not intended to exactly
imitate those originals. Zsh&acirc;s echo <br>
built-in interprets a single hyphen argument as a separator
between options and operands. Yash does not support such use
of hyphen.</p>

<p style="margin-top: 1em">EVAL BUILT-IN <br>
The eval built-in evaluates operands as commands.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; eval [-i] [command...]</p>

<p style="margin-top: 1em">The eval built-in requires that
all options precede operands. Any command line arguments
after the first operand are all treated as operands.</p>

<p style="margin-top: 1em">Description <br>
The eval parses operands as commands and executes them in
the current command execution environment.</p>

<p style="margin-top: 1em">When executed without the -i
(--iteration) option, all the operands are concatenated into
one string (with a space inserted between each operand) and
parsed/executed at once.</p>

<p style="margin-top: 1em">With the -i (--iteration)
option, the built-in performs iterative execution: operands
are parsed/executed one by one. If the continue built-in is
executed with the -i <br>
(--iteration) option during the iterative execution, the
execution of the current operand is aborted and the next
operand is parsed/executed immediately. The break built-in
with <br>
the -i (--iteration) option is similar but the remaining
operands are not parsed/executed. The value of the ? special
parameter is saved before the iterative execution is <br>
started. The parameter value is restored to the saved one
after each iteration.</p>

<p style="margin-top: 1em">Options <br>
-i, --iteration <br>
Perform iterative execution.</p>

<p style="margin-top: 1em">Operands <br>
command <br>
A string that is parsed and executed as commands.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status is zero if no command was specified or
command contained no actual command that can be executed.
Otherwise, that is, if the eval built-in executed one or
more <br>
commands, the exit status of the eval built-in is that of
the last executed command.</p>

<p style="margin-top: 1em">Notes <br>
The eval built-in is a special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines no
options for the eval built-in; the built-in accepts no
options in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">EXEC BUILT-IN <br>
The exec built-in replaces the shell process with another
external command.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; exec [-cf] [-a name] [command
[argument...]]</p>

<p style="margin-top: 1em">The exec built-in requires that
all options precede operands. It is important so that
options to the exec built-in are not confused with options
to command. Any command line <br>
arguments after command are treated as arguments.</p>

<p style="margin-top: 1em">Description <br>
When the exec built-in is executed with command, the shell
executes command with arguments in a manner similar to the
last step of execution of a simple command. The differences
<br>
are that command is always treated as an external command
ignoring any existing functions and built-ins and that the
exec system call that starts the external command is called
<br>
in the current command execution environment instead of a
subshell, replacing the shell process with the new command
process.</p>

<p style="margin-top: 1em">If the shell is in the
POSIXly-correct mode or not interactive, failure in
execution of command causes the shell to exit
immediately.</p>

<p style="margin-top: 1em">If an interactive shell that is
not in the POSIXly-correct mode has a stopped job, the shell
prints a warning message and refuses to execute command.
Once the shell process is <br>
replaced with an external command, information about the
shell&acirc;s jobs is lost, so you will have to resume or
kill the stopped jobs by sending signals by hand. To force
the shell <br>
to execute command regardless, specify the -f (--force)
option.</p>

<p style="margin-top: 1em">When executed without command,
the built-in does nothing. As a side effect, however,
redirection applied to the built-in remains in the current
command execution environment even <br>
after the built-in finished.</p>

<p style="margin-top: 1em">Options <br>
-a name, --as=name <br>
Pass name, instead of command, to the external command as
its name.</p>

<p style="margin-top: 1em">-c, --clear <br>
Pass to the external command only variables that are
assigned in the simple command in which the built-in is
being executed. Other environment variables are not passed
to the <br>
command.</p>

<p style="margin-top: 1em">-f, --force <br>
Suppress warnings that would prevent command execution.</p>

<p style="margin-top: 1em">Operands <br>
command <br>
An external command to be executed.</p>

<p style="margin-top: 1em">argument... <br>
Arguments to be passed to the command.</p>

<p style="margin-top: 1em">Exit status <br>
If the shell process was successfully replaced with the
external command, there is no exit status since the shell
process no longer exists.</p>

<p style="margin-top: 1em">The exit status is:</p>

<p style="margin-top: 1em">&Acirc;&middot; 127 if the
command was not found,</p>

<p style="margin-top: 1em">&Acirc;&middot; 126 if the
command was found but could not be executed, and</p>

<p style="margin-top: 1em">&Acirc;&middot; zero if no
command was specified.</p>

<p style="margin-top: 1em">Notes <br>
The exec built-in is a special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines no
options for the exec built-in; the built-in accepts no
options in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">EXIT BUILT-IN <br>
The exit built-in causes the shell process to exit.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; exit [-f] [exit_status]</p>

<p style="margin-top: 1em">Description <br>
The exit built-in causes the current shell (or subshell)
process to exit.</p>

<p style="margin-top: 1em">If an interactive shell has a
stopped job, the shell prints a warning message and refuses
to exit. To force the shell to exit regardless, specify the
-f (--force) option or <br>
execute the built-in twice in a row.</p>

<p style="margin-top: 1em">If an EXIT trap has been set,
the shell executes the trap before exiting.</p>

<p style="margin-top: 1em">Options <br>
-f, --force <br>
Suppress warnings that would prevent the shell from
exiting.</p>

<p style="margin-top: 1em">Operands <br>
exit_status <br>
A non-negative integer that will be the exit status of the
exiting shell.</p>

<p style="margin-top: 1em">If this operand is omitted, the
exit status of the shell will be that of the last command
executed before the exit built-in (but, if the built-in is
executed during a trap, <br>
the exit status will be that of the last command before the
trap is entered).</p>

<p style="margin-top: 1em">If exit_status is 256 or larger,
the actual exit status will be the remainder of exit_status
divided by 256.</p>

<p style="margin-top: 1em">Exit status <br>
Because the built-in causes the shell to exit, there is no
exit status of the built-in.</p>

<p style="margin-top: 1em">As an exception, if the shell
refused to exit, the exit status of the built-in is
non-zero.</p>

<p style="margin-top: 1em">Notes <br>
The exit built-in is a special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines no
options for the exit built-in; the built-in accepts no
options in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">The POSIX standard provides that
the exit_status operand should be between 0 and 255
(inclusive). Yash accepts integers larger than 255 as an
extension.</p>

<p style="margin-top: 1em">If the built-in is executed
during an EXIT trap, the shell just exits without executing
the trap again. If exit_status was not specified, the exit
status of the shell is what the <br>
exit status would be if the trap had not been set. See also
Termination of the shell.</p>

<p style="margin-top: 1em">EXPORT BUILT-IN <br>
The export built-in marks variables for export to child
processes.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; export [-prX] [name[=value]...]</p>

<p style="margin-top: 1em">Description <br>
The export built-in is equivalent to the typeset built-in
with the -gx option.</p>

<p style="margin-top: 1em">Notes <br>
The export built-in is a special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines the
-p option only; other options cannot be used in the
POSIXly-correct mode. The POSIX does not allow using the
option together with operands.</p>

<p style="margin-top: 1em">FALSE BUILT-IN <br>
The false built-in does nothing unsuccessfully.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; false</p>

<p style="margin-top: 1em">Description <br>
The false built-in does nothing. Any command line arguments
are ignored.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the false built-in is non-zero.</p>

<p style="margin-top: 1em">Notes <br>
The false built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">FC BUILT-IN <br>
The fc built-in re-executes or prints commands from command
history.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; fc [-qr] [-e editor] [start [end]]</p>

<p style="margin-top: 1em">&Acirc;&middot; fc -s[q]
[old=new] [start]</p>

<p style="margin-top: 1em">&Acirc;&middot; fc -l[nrv]
[start [end]]</p>

<p style="margin-top: 1em">Description <br>
When executed without the -l (--list) option, the built-in
executes the commands in the command history range specified
by the operands. If the -s (--silent) option is not <br>
specified, the shell invokes an editor which allows you to
edit the commands before they are executed. The commands are
executed when you quit the editor. If the -s (--silent) <br>
option is specified, the commands are immediately executed.
In either case, the executed commands are printed to the
standard output and added to the history.</p>

<p style="margin-top: 1em">When executed with the -l
(--list) option, the built-in prints the commands in the
command history range specified by the operands. By default,
commands are printed with their <br>
history entry numbers, but output format can be changed
using the -n (--no-numbers)) and -v (--verbose) options.</p>

<p style="margin-top: 1em">Options <br>
-e editor, --editor=editor <br>
Specify an editor that is used to edit commands.</p>

<p style="margin-top: 1em">If this option is not specified,
the value of the FCEDIT variable is used. If the variable is
not set either, ed is used.</p>

<p style="margin-top: 1em">-l, --list <br>
Print command history entries.</p>

<p style="margin-top: 1em">-n, --no-numbers <br>
Don&acirc;t print entry numbers when printing history
entries.</p>

<p style="margin-top: 1em">-q, --quiet <br>
Don&acirc;t print commands before executing.</p>

<p style="margin-top: 1em">-r, --reverse <br>
Reverse the order of command entries in the range.</p>

<p style="margin-top: 1em">-s, --silent <br>
Execute commands without editing them.</p>

<p style="margin-top: 1em">-v, --verbose <br>
Print execution time before each history entry when
printing.</p>

<p style="margin-top: 1em">Operands <br>
start and end <br>
The start and end operands specify a range of command
history entries that are executed or printed. If one of the
operands is an integer, it is treated as a history entry
<br>
number. A negative integer means the nth most recent entry
where n is the absolute value of the integer. If one of the
operands is not an integer, it is treated as part of a <br>
command string: the most recent entry that starts with the
string is selected as the start or end of the range.</p>

<p style="margin-top: 1em">If the first entry of the range
that is specified by start is newer than the last entry of
the range that is specified by end, the range is reversed as
if the -r (--reverse) <br>
option was specified. (If the option is already specified,
it is cancelled.)</p>

<p style="margin-top: 1em">The default values for start and
end are:</p>


<p style="margin-top: 1em">&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&not;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;
<br>
&acirc; &acirc; with -l &acirc; without -l &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;start &acirc; -16 &acirc; -1 &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&frac14;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&curren;
<br>
&acirc;end &acirc; -16 &acirc; same as start &acirc; <br>

&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acute;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;&acirc;</p>

<p style="margin-top: 1em">old=new <br>
An operand of this format replaces part of the command
string. If the command string contains old, it is replaced
with new and the new string is executed. Only the first <br>
occurrence of old is replaced.</p>

<p style="margin-top: 1em">Exit status <br>
If commands was executed, the exit status of the fc built-in
is that of the last executed command. Otherwise, the exit
status is zero unless there is any error.</p>

<p style="margin-top: 1em">Notes <br>
The fc built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">The POSIX standard does not
define the -q (--quiet) or -v (--verbose) options, so they
cannot be used in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">Command history cannot be
modified during line-editing.</p>

<p style="margin-top: 1em">FG BUILT-IN <br>
The fg built-in resumes a job in the foreground.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; fg [job...]</p>

<p style="margin-top: 1em">Description <br>
The fg built-in brings the specified job to the foreground
and sends the SIGCONT signal to the job. As a result, the
job is resumed in the foreground (if it has been suspended).
<br>
The built-in then waits for the job to finish and returns
the exit status of it.</p>

<p style="margin-top: 1em">The name of the job is printed
when the job is resumed.</p>

<p style="margin-top: 1em">The built-in can be used only
when job control is enabled.</p>

<p style="margin-top: 1em">Operands <br>
job <br>
The job ID of the job to be resumed.</p>

<p style="margin-top: 1em">If more than one job is
specified, they are resumed in order, one at a time. The
current job is resumed if none is specified.</p>

<p style="margin-top: 1em">The percent sign (%) at the
beginning of a job ID can be omitted if the shell is not in
the POSIXly-correct mode.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the fg built-in is that of the (last) job
resumed. The exit status is non-zero when there was some
error.</p>

<p style="margin-top: 1em">Notes <br>
The fg built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">You cannot specify more than one
job in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">GETOPTS BUILT-IN <br>
The getopts built-in parses command options.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; getopts optionlist variable
[argument...]</p>

<p style="margin-top: 1em">Description <br>
The getopts built-in parses single-character options that
appear in arguments. Each time the built-in is invoked, it
parses one option and assigns the option character to <br>
variable.</p>

<p style="margin-top: 1em">The optionlist operand is a list
of option characters that should be accepted by the parser.
In optionlist, an option that takes an argument should be
specified as the option <br>
character followed by a colon. For example, if you want the
-a, -b and -c options to be parsed and the -b option to take
an argument, then optionlist should be ab:c.</p>

<p style="margin-top: 1em">When an option that takes an
argument is parsed, the argument is assigned to the OPTARG
variable.</p>

<p style="margin-top: 1em">When an option that is not
specified in optionlist is found or when an option argument
is missing, the result depends on the first character of
optionlist:</p>

<p style="margin-top: 1em">&Acirc;&middot; If optionlist
starts with a colon, the option character is assigned to the
OPTARG variable and variable is set to either ? (when the
option is not in optionlist) or : (when <br>
the option argument is missing).</p>

<p style="margin-top: 1em">&Acirc;&middot; Otherwise,
variable is set to ?, the OPTARG variable is unset, and an
error message is printed.</p>

<p style="margin-top: 1em">The built-in parses one option
for each execution. For all options in a set of command line
arguments to be parsed, the built-in has to be executed
repeatedly with the same <br>
arguments. The built-in uses the OPTIND variable to remember
which argument should be parsed next. When the built-in is
invoked for the first time, the variable value must be 1,
<br>
which is the default value. You must not modify the variable
until all the options have been parsed, when the built-in
sets the variable to the index of the first operand in <br>
arguments. (If there are no operands, it will be set to the
number of arguments plus one.)</p>

<p style="margin-top: 1em">When you want to start parsing a
new set of arguments, you have to reset the OPTIND variable
to 1 beforehand.</p>

<p style="margin-top: 1em">Operands <br>
optionlist <br>
A list of options that should be accepted as valid options
in parsing.</p>

<p style="margin-top: 1em">variable <br>
The name of a variable the result is to be assigned to.</p>

<p style="margin-top: 1em">arguments <br>
Command line arguments that are to be parsed.</p>

<p style="margin-top: 1em">When no arguments are given, the
positional parameters are parsed.</p>

<p style="margin-top: 1em">Exit status <br>
If an option is found, whether or not it is specified in
optionlist, the exit status is zero. If there is no more
option to be parsed, the exit status is non-zero.</p>

<p style="margin-top: 1em">Example <br>
aopt=false bopt= copt=false <br>
while getopts ab:c opt <br>
do <br>
case $opt in <br>
a) aopt=true ;; <br>
b) bopt=$OPTARG ;; <br>
c) copt=true ;; <br>
esac <br>
done <br>
if $aopt; then echo Option -a specified; fi <br>
if [ -n &quot;$bopt&quot; ]; then echo Option -b $bopt
specified; fi <br>
if $copt; then echo Option -c specified; fi <br>
shift $((OPTIND - 1)) <br>
echo Operands are: $*</p>

<p style="margin-top: 1em">Notes <br>
In arguments that are parsed, options must precede operands.
The built-in ends parsing when it encounters the first
operand.</p>

<p style="margin-top: 1em">The getopts built-in is a
semi-special built-in.</p>

<p style="margin-top: 1em">The POSIX standard does not
specify what will happen when the OPTIND variable is
assigned a value other than 1.</p>

<p style="margin-top: 1em">HASH BUILT-IN <br>
The hash built-in remembers, forgets, or reports command
locations.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; hash command...</p>

<p style="margin-top: 1em">&Acirc;&middot; hash -r
[command...]</p>

<p style="margin-top: 1em">&Acirc;&middot; hash [-a]</p>

<p style="margin-top: 1em">&Acirc;&middot; hash -d
user...</p>

<p style="margin-top: 1em">&Acirc;&middot; hash -dr
[user...]</p>

<p style="margin-top: 1em">&Acirc;&middot; hash -d</p>

<p style="margin-top: 1em">Description <br>
When executed with commands but without options, the
built-in immediately performs command path search and caches
commands&rsquo; full paths.</p>

<p style="margin-top: 1em">When executed with the -r
(--remove) option, it removes the paths of commands (or all
cached paths if none specified) from the cache.</p>

<p style="margin-top: 1em">When executed without options or
commands, it prints the currently cached paths to the
standard output.</p>

<p style="margin-top: 1em">With the -d (--directory)
option, the built-in does the same things to the home
directory cache, rather than the command path cache. Cached
home directory paths are used in tilde <br>
expansion.</p>

<p style="margin-top: 1em">Options <br>
-a, --all <br>
Print all cached paths.</p>

<p style="margin-top: 1em">Without this option, paths for
built-ins are not printed.</p>

<p style="margin-top: 1em">-d, --directory <br>
Affect the home directory cache instead of the command path
cache.</p>

<p style="margin-top: 1em">-r, --remove <br>
Remove cached paths.</p>

<p style="margin-top: 1em">Operands <br>
command <br>
The name of an external command (that does not contain any
slash).</p>

<p style="margin-top: 1em">user <br>
A user name.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the hash built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Notes <br>
The shell automatically caches command and directory paths
when executing a command or performing tilde expansion, so
normally there is no need to use this built-in explicitly to
<br>
cache paths.</p>

<p style="margin-top: 1em">Assigning a value to the PATH
variable removes all command paths from the cache as if hash
-r was executed.</p>

<p style="margin-top: 1em">The POSIX standard defines the
-r option only: other options cannot be used in the
POSIXly-correct mode.</p>

<p style="margin-top: 1em">The hash built-in is a
semi-special built-in.</p>

<p style="margin-top: 1em">HELP BUILT-IN <br>
The help built-in prints usage of built-ins.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; help [built-in...]</p>

<p style="margin-top: 1em">Description <br>
The help built-in prints a description of built-ins.</p>

<p style="margin-top: 1em">Operands <br>
built-ins <br>
Names of built-ins.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the help built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Notes <br>
The help built-in is a semi-special built-in. In the POSIX
standard, it is defined as a command with unspecified
behavior.</p>

<p style="margin-top: 1em">Many built-ins of yash accept
the --help option that prints the same description.</p>

<p style="margin-top: 1em">HISTORY BUILT-IN <br>
The history built-in prints or edits command history.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; history [-cF] [-d entry] [-s command] [-r
file] [-w file] [count]</p>

<p style="margin-top: 1em">Description <br>
The history built-in prints or edits command history.</p>

<p style="margin-top: 1em">When executed with an option,
the built-in edits history according to the option. If more
than one option is specified, each option is processed in
order.</p>

<p style="margin-top: 1em">When executed with the count
operand, the built-in prints the most recent count history
entries to the standard output in the same manner as the fc
built-in.</p>

<p style="margin-top: 1em">When executed with neither
options nor operands, the built-in prints the whole
history.</p>

<p style="margin-top: 1em">Options <br>
-c, --clear <br>
Clear all history entries completely.</p>

<p style="margin-top: 1em">-d entry, --delete=entry <br>
Delete the specified entry. The entry should be specified in
the same manner as the start and end operands of the fc
built-in.</p>

<p style="margin-top: 1em">-F, --flush-file <br>
Rebuild the history file. This operation removes unused old
data from the file.</p>

<p style="margin-top: 1em">-r file, --read=file <br>
Read command lines from file and add them to the history.
The file contents are treated as lines of simple text.</p>

<p style="margin-top: 1em">-s command, --set=command <br>
Add command as a new history entry after removing the most
recent entry.</p>

<p style="margin-top: 1em">-w file, --write=file <br>
Write the whole history to file. Any existing data in the
file will be lost. The output format is lines of simple
text, each of which is a command string.</p>

<p style="margin-top: 1em">Operands <br>
count <br>
The number of entries to be printed.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the history built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The history built-in is a semi-special built-in. In the
POSIX standard, it is defined as a command with unspecified
behavior.</p>

<p style="margin-top: 1em">Command history cannot be
modified during line-editing.</p>

<p style="margin-top: 1em">JOBS BUILT-IN <br>
The jobs built-in reports job status.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; jobs [-lnprs] [job...]</p>

<p style="margin-top: 1em">Description <br>
The jobs built-in prints information of jobs the shell is
currently controlling.</p>

<p style="margin-top: 1em">By default, the following
information is printed for each job, line by line:</p>

<p style="margin-top: 1em">&Acirc;&middot; the job
number,</p>

<p style="margin-top: 1em">&Acirc;&middot; the + or -
symbol if the job is the current or previous job,
respectively,</p>

<p style="margin-top: 1em">&Acirc;&middot; the status,
and</p>

<p style="margin-top: 1em">&Acirc;&middot; the command
string.</p>

<p style="margin-top: 1em">Options <br>
-l, --verbose <br>
Print the process ID, status, and command string for each
process in the jobs.</p>

<p style="margin-top: 1em">-n, --new <br>
Print new jobs only: jobs whose status has never been
reported since the status changed.</p>

<p style="margin-top: 1em">-p, --pgid-only <br>
Print process group IDs of jobs only.</p>

<p style="margin-top: 1em">-r, --running-only <br>
Print running jobs only.</p>

<p style="margin-top: 1em">-s, --stopped-only <br>
Print stopped jobs only.</p>

<p style="margin-top: 1em">Operands <br>
jobs <br>
The job IDs of jobs to be reported. When no job is
specified, all jobs under the shell&acirc;s control are
reported.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the jobs built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Notes <br>
The jobs built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines the
-l and -p options only: other options cannot be used in the
POSIXly-correct mode. In the POSIXly-correct mode, the
effect of the -l option is <br>
different in that status is reported for each job rather
than for each process.</p>

<p style="margin-top: 1em">The process group ID of a job
executed by yash is equal to the process ID of the first
command of the pipeline that forms the job.</p>

<p style="margin-top: 1em">KILL BUILT-IN <br>
The kill built-in sends a signal to processes.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; kill [-signal|-s signal|-n signal]
process...</p>

<p style="margin-top: 1em">&Acirc;&middot; kill -l [-v]
[signal...]</p>

<p style="margin-top: 1em">The kill built-in requires that
all options precede operands. Any command line arguments
after the first operand are all treated as operands.</p>

<p style="margin-top: 1em">Description <br>
When executed without the -l option, the built-in sends a
signal to processes. The signal sent can be specified by
option. The SIGTERM signal is sent if no signal is
specified.</p>

<p style="margin-top: 1em">When executed with the -l
option, the built-in prints information of signals to the
standard output. If no signal is specified, information of
all signals is printed.</p>

<p style="margin-top: 1em">Options <br>
Signal-specifying options <br>
-signal, -s signal, -n signal <br>
A signal-specifying option specifies a signal to be sent to
processes. signal can be specified by name or number. If
number 0 is specified, the built-in checks if a <br>
signal could be sent to the processes but no signal is
actually sent. Signal names are case-insensitive.</p>

<p style="margin-top: 1em">You can specify at most one
signal-specifying option at a time.</p>

<p style="margin-top: 1em">Other options <br>
-l <br>
Print signal information instead of sending a signal.</p>

<p style="margin-top: 1em">-v <br>
Print more signal information.</p>

<p style="margin-top: 1em">Without this option, the
built-in prints the signal name only. This option adds the
signal number and a short description.</p>

<p style="margin-top: 1em">When the -v option is specified,
the -l option can be omitted.</p>

<p style="margin-top: 1em">Operands <br>
processes <br>
Specify processes to which a signal is sent.</p>

<p style="margin-top: 1em">Processes can be specified by
the process ID, the process group ID, or the job ID. The
process group ID must be prefixed with a hyphen (-) so that
it is not treated as a <br>
process ID.</p>

<p style="margin-top: 1em">When 0 is specified as process,
the signal is sent to the process group to which the shell
process belongs. When -1 is specified, the signal is sent to
all processes on the <br>
system.</p>

<p style="margin-top: 1em">signal <br>
Specify a signal of which information is printed.</p>

<p style="margin-top: 1em">The signal can be specified by
the name, the number, or the exit status of a command that
was killed by the signal.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the kill built-in is zero unless there is
any error. If the signal was sent to at least one process,
the exit status is zero even if the signal was not sent to
<br>
all of the specified processes.</p>

<p style="margin-top: 1em">Notes <br>
The kill built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">Command arguments that start
with a hyphen should be used with care. The command kill -1
-2, for example, sends signal 1 to process group 2 since -1
is treated as a <br>
signal-specifying option and -2 as an operand that specifies
a process group. The commands kill -- -1 -2 and kill -TERM
-1 -2, on the other hand, treats both -1 and -2 as <br>
operands.</p>

<p style="margin-top: 1em">The POSIX standard does not
define the -n or -v options, so they cannot be used in the
POSIXly-correct mode. The standard does not allow specifying
a signal number as the <br>
argument of the -s option or a signal name as the signal
operand.</p>

<p style="margin-top: 1em">The standard requires signal
names to be specified without the SIG prefix, like INT and
QUIT. If the shell is not in the POSIXly-correct mode, the
built-in accepts SIG-prefixed <br>
signal names as well.</p>

<p style="margin-top: 1em">POPD BUILT-IN <br>
The popd built-in pops a directory from the directory
stack.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; popd [index]</p>

<p style="margin-top: 1em">Description <br>
The popd built-in removes the last entry from the directory
stack, returning to the previous working directory. If index
is given, the entry specified by index is removed instead
<br>
of the last one.</p>

<p style="margin-top: 1em">Operands <br>
index <br>
The index of a directory stack entry you want to remove.</p>

<p style="margin-top: 1em">If omitted, +0 (the last entry)
is assumed.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the popd built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Notes <br>
It is an error to use this built-in when there is only one
directory stack entry.</p>

<p style="margin-top: 1em">The popd built-in is a
semi-special built-in. In the POSIX standard, it is defined
as a command with unspecified behavior.</p>

<p style="margin-top: 1em">PRINTF BUILT-IN <br>
The printf built-in prints formatted values.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; printf format [value...]</p>

<p style="margin-top: 1em">Description <br>
The printf built-in formats values according to format and
prints them to the standard output. Unlike the echo
built-in, the printf built-in does not print a newline <br>
automatically.</p>

<p style="margin-top: 1em">The formatting process is very
similar to that of the printf function in the C programming
language. You can use conversion specifications (which start
with %) and escape <br>
sequences (which start with in format. Any other characters
that are not part of a conversion specification or escape
sequence are printed literally.</p>

<p style="margin-top: 1em">Conversion specifications <br>
A conversion specification starts with a percent sign
(%).</p>

<p style="margin-top: 1em">A conversion specification
except %% consumes a value, which is formatted according to
the specification and printed. Each conversion specification
consumes one value in the <br>
order of appearance. If there are more values than
conversion specifications, the entire format is re-processed
until all the values are consumed. If a value to be consumed
<br>
is missing, it is assumed to be an empty string (if the
specification requires a string) or zero (if a number). If
no values are given, format is processed just once.</p>

<p style="margin-top: 1em">Available conversion
specifications are:</p>

<p style="margin-top: 1em">%d, %i <br>
prints a signed integer in decimal</p>

<p style="margin-top: 1em">%u <br>
prints an unsigned integer in decimal</p>

<p style="margin-top: 1em">%o <br>
prints an unsigned integer in octal</p>

<p style="margin-top: 1em">%x <br>
prints an unsigned integer in lowercase hexadecimal</p>

<p style="margin-top: 1em">%X <br>
prints an unsigned integer in uppercase hexadecimal</p>

<p style="margin-top: 1em">%f <br>
prints a floating-point number in lowercase</p>

<p style="margin-top: 1em">%F <br>
prints a floating-point number in uppercase</p>

<p style="margin-top: 1em">%e <br>
prints a floating-point number with exponent in
lowercase</p>

<p style="margin-top: 1em">%E <br>
prints a floating-point number with exponent in
uppercase</p>

<p style="margin-top: 1em">%g <br>
the same as %f or %e, automatically selected</p>

<p style="margin-top: 1em">%G <br>
the same as %F or %E, automatically selected</p>

<p style="margin-top: 1em">%c <br>
prints the first character of string</p>

<p style="margin-top: 1em">%s <br>
prints a string</p>

<p style="margin-top: 1em">%b <br>
prints a string (recognizing escape sequences like the echo
built-in)</p>

<p style="margin-top: 1em">%% <br>
prints a percent sign (%)</p>

<p style="margin-top: 1em">For %g and %G, the specification
that is actually used is %f or %F if the exponent part is
between -5 and the precision (exclusive); %e or %E
otherwise.</p>

<p style="margin-top: 1em">In a conversion specification
except %%, the leading percent sign may be followed by
flags, field width, and/or precision in this order.</p>

<p style="margin-top: 1em">The flags are a sequence of any
number of the following characters:</p>

<p style="margin-top: 1em">Minus sign (-) <br>
With this flag, spaces are appended to the formatted value
to fill up to the field width. Otherwise, spaces are
prepended.</p>

<p style="margin-top: 1em">Plus sign (+) <br>
A plus or minus sign is always prepended to a number.</p>

<p style="margin-top: 1em">Space ( ) <br>
A space is prepended to a formatted number if it has no plus
or minus sign.</p>

<p style="margin-top: 1em">Hash sign (#) <br>
The value is formatted in an alternative form: For %o, the
printed octal integer has at least one leading zero. For %x
and %X, a non-zero integer is formatted with 0x and <br>
0X prefixes, respectively. For %e, %E, %f, %F, %g, and %G, a
decimal mark (a.k.a. radix character) is always printed even
if the value is an exact integer. For %g and %G, <br>
the printed number has at least one digit in the fractional
part.</p>

<p style="margin-top: 1em">Zero (0) <br>
Zeros are prepended to a formatted number to fill up to the
field width. This flag is ignored if the minus flag is
specified or if the conversion specification is %d, %i, <br>
%u, %o, %x, or %X with a precision.</p>

<p style="margin-top: 1em">A field width is specified as a
decimal integer that has no leading zeros.</p>

<p style="margin-top: 1em">A field width defines a minimum
byte count of a formatted value. If the formatted value does
not reach the minimum byte count, so many spaces are
prepended that the printed <br>
value has the specified byte count.</p>

<p style="margin-top: 1em">A precision is specified as a
period (.) followed by a decimal integer. If the integer is
omitted after the period, the precision is assumed to be
zero.</p>

<p style="margin-top: 1em">For conversion specifications
%d, %i, %u, %o, %x, and %X, a precision defines a minimum
digit count. If the formatted integer does not reach the
minimum digit count, so many <br>
zeros are prepended that the printed integer has the
specified number of digits. The default precision is one for
these conversion specifications.</p>

<p style="margin-top: 1em">For conversion specifications
%e, %E, %f, and %F, a precision defines the number of digits
after the decimal mark. The default precision is six for
these conversion <br>
specifications.</p>

<p style="margin-top: 1em">For conversion specifications
%g, and %G, a precision defines a maximum number of
significant digits in the printed value. The default
precision is six for these conversion <br>
specifications.</p>

<p style="margin-top: 1em">For conversion specifications
%s, and %b, a precision defines a maximum byte count of the
printed string. The default precision is infinity for these
conversion <br>
specifications.</p>

<p style="margin-top: 1em">In the conversion specification
%08.3f, the zero flag is specified, the field width is 8,
and the precision is 3. If this specification is applied to
value 12.34, the output <br>
will be 0012.340.</p>

<p style="margin-top: 1em">Escape sequences <br>
The following escape sequences are recognized in format:</p>

<p style="margin-top: 1em">Bell character (ASCII code: 7) B
a c k s p a c e ( A S C I I c o d e : 8 )</p>

<p style="margin-top: 1em">Form feed character (ASCII code:
12)</p>

<p style="margin-top: 1em">Newline character (ASCII code:
10)</p>

<p style="margin-top: 1em">Carriage return character (ASCII
code: 13)</p>

<p style="margin-top: 1em">Horizontal tab character (ASCII
code: 9)</p>

<p style="margin-top: 1em">Vertical tab character (ASCII
code: 11)</p>

<p style="margin-top: 1em">\ <br>
Backslash</p>

<p style="margin-top: 1em">Double quotation</p>

<p style="margin-top: 1em">&acute; <br>
Single quotation (apostrophe)</p>

<p style="margin-top: 1em">Character whose code is xxx,
where xxx is an octal number of at most three digits.</p>

<p style="margin-top: 1em">Operands <br>
format <br>
A string that defines how values should be formatted.</p>

<p style="margin-top: 1em">values <br>
Values that are formatted according to format.</p>

<p style="margin-top: 1em">A value is either a number or a
string.</p>

<p style="margin-top: 1em">When a numeric value is
required, value can be a single or double quotation followed
by a character, instead of a normal number. For example, the
command printf &rsquo;%d&rsquo; &rsquo;&quot;3&rsquo; <br>
will print 51 on a typical environment where character 3 has
character code 51.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the printf built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The POSIX standard does not precisely define how multibyte
characters should be handled by the built-in. When you use
the %s conversion specification with precision or the %c
<br>
conversion specification, you may obtain unexpected results
if the formatted value contains a character that is
represented by more than one byte. Yash never prints only
part of <br>
the bytes that represent a single multibyte character
because all multibyte characters are converted to wide
characters when processed in the shell.</p>

<p style="margin-top: 1em">PUSHD BUILT-IN <br>
The pushd built-in pushes a directory into the directory
stack.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; pushd [-L|-P] [directory]</p>

<p style="margin-top: 1em">Description <br>
The pushd built-in changes the working directory to
directory in the same manner as the cd built-in and adds it
to the directory stack. If the working directory could not
be <br>
changed successfully, the stack is not modified.</p>

<p style="margin-top: 1em">Options <br>
The pushd built-in accepts the following option as well as
the options that can be used for the cd built-in:</p>

<p style="margin-top: 1em">--remove-duplicates <br>
If the new working directory has already been in the
directory stack, the existing entry is removed from the
stack before the new directory is pushed into the stack.</p>

<p style="margin-top: 1em">Operands <br>
directory <br>
The pathname of the new working directory.</p>

<p style="margin-top: 1em">If directory is a single hyphen
(&acirc;-&acirc;), the value of the OLDPWD variable is
assumed for the new directory pathname, which is printed to
the standard output.</p>

<p style="margin-top: 1em">If directory is an integer with
a plus or minus sign, it is considered as an entry index of
the directory stack. The entry is removed from the stack and
then pushed to the <br>
stack again.</p>

<p style="margin-top: 1em">If directory is omitted, the
working directory is changed to the directory specified by
the --default-directory=... option. If that option is not
specified either, the <br>
default is index +1.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the pushd built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The pushd built-in is a semi-special built-in. In the POSIX
standard, it is defined as a command with unspecified
behavior.</p>

<p style="margin-top: 1em">PWD BUILT-IN <br>
The pwd built-in prints the current working directory.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; pwd [-L|-P]</p>

<p style="margin-top: 1em">Description <br>
The pwd built-in prints an absolute path to the
shell&acirc;s current working directory to the standard
output.</p>

<p style="margin-top: 1em">Options <br>
-L, --logical <br>
If the value of the PWD variable is an absolute path to the
shell&acirc;s working directory and the path does not
contain any . or .. components, then the path is printed.
<br>
Otherwise, the printed path is the same as when the -P
option is specified.</p>

<p style="margin-top: 1em">-P, --physical <br>
The printed path does not contain any . or .. components,
symbolic link components, or redundant slashes.</p>

<p style="margin-top: 1em">The -L (--logical) and -P
(--physical) options are mutually exclusive: only the last
specified one is effective. If neither is specified, -L is
assumed.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the pwd built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Notes <br>
The pwd built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">READ BUILT-IN <br>
The read built-in reads a line from the standard input.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; read [-Aer] [-P|-p] variable...</p>

<p style="margin-top: 1em">Description <br>
The read built-in reads a line of string from the standard
input and assigns it to the specified variables.</p>

<p style="margin-top: 1em">If the -r (--raw-mode) option is
specified, all characters in the line are treated
literally.</p>

<p style="margin-top: 1em">If the -r (--raw-mode) option is
not specified, backslashes in the line are treated as
quotations. If a backslash is at the end of the line, it is
treated as a line continuation. <br>
When the built-in reads the next line, the PS2 variable is
used as a prompt if the shell is interactive and the
standard input is a terminal.</p>

<p style="margin-top: 1em">The input line is subject to
field splitting. The resulting words are assigned to
variables in order. If there are more words than variables,
the last variable is assigned all <br>
the remaining words (as if the words were not split). If the
words are fewer than variables, the remaining variables are
assigned empty strings.</p>

<p style="margin-top: 1em">Options <br>
-A, --array <br>
Make the last variable an array. Instead of assigning a
concatenation of the remaining words to a normal variable,
the words are assigned to an array.</p>

<p style="margin-top: 1em">-e, --line-editing <br>
Use line-editing to read the line.</p>

<p style="margin-top: 1em">To use line-editing, all of the
following conditions must also be met:</p>

<p style="margin-top: 1em">&Acirc;&middot; The shell is
interactive.</p>

<p style="margin-top: 1em">&Acirc;&middot; The vi or emacs
option is enabled.</p>

<p style="margin-top: 1em">&Acirc;&middot; The standard
input and standard error are connected to a terminal.</p>

<p style="margin-top: 1em">-P, --ps1 <br>
Print the PS1 variable as a prompt before reading the
(first) line if the shell is interactive and the standard
input is a terminal.</p>

<p style="margin-top: 1em">-p prompt, --prompt=prompt <br>
Print the specified prompt before reading the (first) line
if the shell is interactive and the standard input is a
terminal.</p>

<p style="margin-top: 1em">-r, --raw-mode <br>
Don&acirc;t treat backslashes as quotations.</p>

<p style="margin-top: 1em">Operands <br>
variables <br>
Names of variables to which input words are assigned.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the read built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Note that the exit status is
non-zero if an end of input is encountered before reading
the entire line.</p>

<p style="margin-top: 1em">Notes <br>
The read built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines the
-r option only: other options cannot be used in the
POSIXly-correct mode.</p>

<p style="margin-top: 1em">The PS1R and PS1S variables
affect the behavior of line-editing if the PS1 prompt is
used. The same for PS2.</p>

<p style="margin-top: 1em">READONLY BUILT-IN <br>
The readonly built-in makes variables and functions
read-only.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; readonly [-pxX] [name[=value]...]</p>

<p style="margin-top: 1em">&Acirc;&middot; readonly -f[p]
[name...]</p>

<p style="margin-top: 1em">Description <br>
The readonly built-in is equivalent to the typeset built-in
with the -gr option.</p>

<p style="margin-top: 1em">Notes <br>
The readonly built-in is a special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines the
-p option only; other options cannot be used in the
POSIXly-correct mode. The POSIX does not allow using the
option together with operands.</p>

<p style="margin-top: 1em">RETURN BUILT-IN <br>
The return built-in returns from a function or script.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; return [-n] [exit_status]</p>

<p style="margin-top: 1em">Description <br>
When executed without the -n (--no-return) option, one of
the following happens:</p>

<p style="margin-top: 1em">&Acirc;&middot; If the shell is
executing a function, the execution of the function is
terminated.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the dot
built-in is executing a script, the execution of the script
is terminated.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the shell is
executing a script during initialization, the execution of
the script is terminated.</p>

<p style="margin-top: 1em">&Acirc;&middot; If the shell is
executing a trap, the execution of the trap is terminated
for the currently handled signal.</p>

<p style="margin-top: 1em">&Acirc;&middot; Otherwise, the
shell exits unless it is interactive.</p>

<p style="margin-top: 1em">When executed with the -n
(--no-return) option, the built-in does nothing but return
the specified exit_status.</p>

<p style="margin-top: 1em">Options <br>
-n, --no-return <br>
Do not terminate a function, script, trap, or the shell.</p>

<p style="margin-top: 1em">Operands <br>
exit_status <br>
The exit status of the built-in.</p>

<p style="margin-top: 1em">The value must be a non-negative
integer.</p>

<p style="margin-top: 1em">If omitted, the exit status of
the last executed command is used. (But when the shell is
executing a trap, the exit status of the last command before
the trap is used.)</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the return built-in is defined by the
exit_status operand. The exit status is used also as the
exit status of the terminated function, script, or the
shell.</p>

<p style="margin-top: 1em">Notes <br>
The return built-in is a special built-in.</p>

<p style="margin-top: 1em">The POSIX standard provides that
the exit_status operand should be between 0 and 255
(inclusive). Yash accepts integers larger than 255 as an
extension.</p>

<p style="margin-top: 1em">In the POSIX standard, the
behavior of the return built-in is defined only when the
shell is executing a function or script.</p>

<p style="margin-top: 1em">The POSIX standard defines no
options for the return built-in; the built-in accepts no
options in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">SET BUILT-IN <br>
The set built-in sets shell options and positional
parameters.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; set [options] [operands]</p>

<p style="margin-top: 1em">&Acirc;&middot; set -o</p>

<p style="margin-top: 1em">&Acirc;&middot; set +o</p>

<p style="margin-top: 1em">The set built-in requires that
all options precede operands. Any command line arguments
after the first operand are all treated as operands.</p>

<p style="margin-top: 1em">Description <br>
When executed without any command arguments, the built-in
prints a list of all existing variables to the standard
input in a form that can be reused as commands that will
restore <br>
the variable definitions.</p>

<p style="margin-top: 1em">When -o is the only command
argument, the built-in prints a list of shell options with
their current settings. When +o is the only command
argument, the built-in prints commands <br>
that can be reused to restore the current shell option
settings.</p>

<p style="margin-top: 1em">In other cases, the built-in
changes shell option settings and/or positional
parameters.</p>

<p style="margin-top: 1em">Options <br>
When one or more options are specified, the built-in enables
or disables the shell options. A normal hyphen-prefixed
option enables a shell option. An option that is prefixed
<br>
with a plus (+) instead of a hyphen disables a shell option.
For example, options -m, -o monitor, and --monitor enable
the monitor option and options +m, +o monitor, ++monitor
<br>
disable it.</p>

<p style="margin-top: 1em">The name of a long option is
case-insensitive and may include irrelevant non-alphanumeric
characters, which are ignored. For example, options
--le-comp-debug and --LeCompDebug <br>
are equivalent. If no is prepended to the name of a long
option, the meaning is reversed. For example, --noallexport
is equivalent to ++allexport and ++nonotify to --notify.</p>

<p style="margin-top: 1em">An option can be specified in
one of the following forms:</p>

<p style="margin-top: 1em">&Acirc;&middot; a long option
e.g. --allexport</p>

<p style="margin-top: 1em">&Acirc;&middot; an -o option
with a option name specified as the argument e.g. -o
allexport</p>

<p style="margin-top: 1em">&Acirc;&middot; a
single-character option e.g. -a</p>

<p style="margin-top: 1em">Not all options can be specified
as single-character options.</p>

<p style="margin-top: 1em">The available options are:</p>

<p style="margin-top: 1em">all-export (-a) <br>
When enabled, all variables are automatically exported when
assigned.</p>

<p style="margin-top: 1em">brace-expand <br>
This option enables brace expansion.</p>

<p style="margin-top: 1em">case-glob <br>
(Enabled by default) When enabled, pattern matching is
case-sensitive in pathname expansion.</p>

<p style="margin-top: 1em">clobber (+C) <br>
(Enabled by default) When enabled, the &gt; redirection
behaves the same as the &gt;| redirection.</p>

<p style="margin-top: 1em">cur-async, cur-bg, cur-stop <br>
(Enabled by default) These options affect choice of the
current job (cf. job ID).</p>

<p style="margin-top: 1em">dot-glob <br>
When enabled, periods at the beginning of filenames are not
treated specially in pathname expansion.</p>

<p style="margin-top: 1em">emacs <br>
This option enables line-editing in the emacs mode.</p>

<p style="margin-top: 1em">empty-last-field <br>
When enabled, field splitting does not remove the last field
even if it is empty.</p>

<p style="margin-top: 1em">err-exit (-e) <br>
When enabled, if a pipeline ends with a non-zero exit
status, the shell immediately exits unless:</p>

<p style="margin-top: 1em">&Acirc;&middot; the pipeline is
a condition of an if command or while or until loop;</p>

<p style="margin-top: 1em">&Acirc;&middot; the pipeline is
prefixed by !; or</p>

<p style="margin-top: 1em">&Acirc;&middot; the pipeline is
a single compound command other than a subshell
grouping.</p>

<p style="margin-top: 1em">exec (+n) <br>
(Enabled by default) Commands are actually executed only
when this option is enabled. Otherwise, commands are just
parsed and not executed. Disabling this option may be <br>
useful for syntax checking. In an interactive shell, this
option is always assumed enabled.</p>

<p style="margin-top: 1em">extended-glob <br>
This option enables extension in pathname expansion.</p>

<p style="margin-top: 1em">glob (+f) <br>
(Enabled by default) This option enables pathname
expansion.</p>

<p style="margin-top: 1em">hash-on-def (-h) <br>
When a function is defined when this option is enabled, the
shell immediately performs command path search for each
command that appears in the function and caches the <br>
command&acirc;s full path.</p>

<p style="margin-top: 1em">hist-space <br>
When enabled, command lines that start with a whitespace are
not saved in command history.</p>

<p style="margin-top: 1em">ignore-eof <br>
When enabled, an interactive shell does not exit when EOF
(end of file) is input. This prevents the shell from exiting
when you accidentally hit Ctrl-D.</p>

<p style="margin-top: 1em">le-always-rp, le-comp-debug,
le-conv-meta, le-no-conv-meta, le-predict, le-prompt-sp,
le-visible-bell <br>
See shell options on line-editing.</p>

<p style="margin-top: 1em">mark-dirs <br>
When enabled, resulting directory names are suffixed by a
slash in pathname expansion.</p>

<p style="margin-top: 1em">monitor (-m) <br>
This option enables job control. This option is enabled by
default for an interactive shell.</p>

<p style="margin-top: 1em">notify (-b) <br>
When the status of a job changes when this option is
enabled, the shell immediately notifies at any time. This
option overrides the notify-le option.</p>

<p style="margin-top: 1em">notify-le <br>
This option is similar to the notify option, but the status
change is notified only while the shell is waiting for input
with line-editing.</p>

<p style="margin-top: 1em">null-glob <br>
When enabled, in pathname expansion, patterns that do not
match any pathname are removed from the command line rather
than left as is.</p>

<p style="margin-top: 1em">pipe-fail <br>
When enabled, the exit status of a pipeline is zero if and
only if all the subcommands of the pipeline exit with an
exit status of zero.</p>

<p style="margin-top: 1em">posixly-correct <br>
This option enables the POSIXly-correct mode.</p>

<p style="margin-top: 1em">trace-all <br>
(Enabled by default) When this option is disabled, the
x-trace option is temporarily disabled while the shell is
executing commands defined in the COMMAND_NOT_FOUND_HANDLER,
<br>
PROMPT_COMMAND, or YASH_AFTER_CD variable.</p>

<p style="margin-top: 1em">unset (+u) <br>
(Enabled by default) When enabled, undefined parameters are
expanded to empty strings in parameter expansion. When
disabled, expansion of undefined parameter results in an
<br>
error.</p>

<p style="margin-top: 1em">verbose (-v) <br>
When enabled, the shell prints each command line to the
standard error before parsing and executing it.</p>

<p style="margin-top: 1em">vi <br>
This option enables line-editing in the vi mode. This option
is enabled by default in an interactive shell if the
standard input and error are both terminals.</p>

<p style="margin-top: 1em">x-trace (-x) <br>
When enabled, the results of expansion are printed to the
standard error for each simple command being executed. When
printed, each line is prepended with an expansion result
<br>
of the PS4 variable. See also the trace-all option.</p>

<p style="margin-top: 1em">Operands <br>
If one or more operands are passed to the set built-in,
current positional parameters are all removed and the
operands are set as new positional parameters. If the --
separator <br>
(cf. syntax of command arguments) is passed, the positional
parameters are set even when there are no operands, in which
case new positional parameters will be nothing.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the set built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Notes <br>
The set built-in is a special built-in.</p>

<p style="margin-top: 1em">In the POSIX standard, available
shell options are much limited. The standard does not
define:</p>

<p style="margin-top: 1em">&Acirc;&middot; long options
such as --allexport,</p>

<p style="margin-top: 1em">&Acirc;&middot; prepending no to
negate an option,</p>

<p style="margin-top: 1em">&Acirc;&middot; using uppercase
letters and/or non-alphanumeric characters in option
names</p>

<p style="margin-top: 1em">The options defined in the
standard are:</p>

<p style="margin-top: 1em">&Acirc;&middot; -a, -o
allexport</p>

<p style="margin-top: 1em">&Acirc;&middot; -e, -o
errexit</p>

<p style="margin-top: 1em">&Acirc;&middot; -m, -o
monitor</p>

<p style="margin-top: 1em">&Acirc;&middot; -C, -o
noclobber</p>

<p style="margin-top: 1em">&Acirc;&middot; -n, -o
noexec</p>

<p style="margin-top: 1em">&Acirc;&middot; -f, -o
noglob</p>

<p style="margin-top: 1em">&Acirc;&middot; -b, -o
notify</p>

<p style="margin-top: 1em">&Acirc;&middot; -u, -o
nounset</p>

<p style="margin-top: 1em">&Acirc;&middot; -v, -o
verbose</p>

<p style="margin-top: 1em">&Acirc;&middot; -x, -o
xtrace</p>

<p style="margin-top: 1em">&Acirc;&middot; -h</p>

<p style="margin-top: 1em">&Acirc;&middot; -o ignoreeof</p>

<p style="margin-top: 1em">&Acirc;&middot; -o nolog</p>

<p style="margin-top: 1em">&Acirc;&middot; -o vi</p>

<p style="margin-top: 1em">Yash does not support the nolog
option, which prevents function definitions from being added
to command history.</p>

<p style="margin-top: 1em">SHIFT BUILT-IN <br>
The shift built-in removes some positional parameters or
array values.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; shift [-A array] [count]</p>

<p style="margin-top: 1em">Description <br>
The shift built-in removes the first count positional
parameters or array values, where count is specified by the
operand.</p>

<p style="margin-top: 1em">Options <br>
-A array, --array=array <br>
Remove first count values of array instead of positional
parameters.</p>

<p style="margin-top: 1em">Operands <br>
count <br>
The number of positional parameters or array values to be
removed.</p>

<p style="margin-top: 1em">It is an error if the actual
number of positional parameters or array values is less than
count. If omitted, the default value is one. If negative,
the last -count positional <br>
parameters or array values are removed instead of the first
ones.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the shift built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The shift built-in is a special built-in.</p>

<p style="margin-top: 1em">The number of positional
parameters can be obtained with the # special parameter. The
number of array values can be obtained with ${array[#]}.</p>

<p style="margin-top: 1em">The POSIX standard defines no
options for the shift built-in; the built-in accepts no
options in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">Negative operands are not
allowed in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">SUSPEND BUILT-IN <br>
The suspend built-in suspends the shell.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; suspend [-f]</p>

<p style="margin-top: 1em">Description <br>
The suspend built-in sends a SIGSTOP signal to all processes
in the process group to which the shell process belongs. The
signal suspends the processes (including the shell). The
<br>
suspended processes resume when they receive a SIGCONT
signal.</p>

<p style="margin-top: 1em">If the shell is interactive and
its process group ID is equal to the process ID of the
session leader, the shell prints a warning message and
refuses to send a signal unless the <br>
-f (--force) option is specified. (In such a case, there is
no other job-controlling shell that can send a SIGCONT
signal to resume the suspended shell, so the shell could
never <br>
be resumed.)</p>

<p style="margin-top: 1em">Options <br>
-f, --force <br>
Suppress warnings that would prevent the shell from sending
a signal.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status is zero if the signal was successfully sent
and non-zero otherwise.</p>

<p style="margin-top: 1em">Notes <br>
The suspend built-in is a semi-special built-in. In the
POSIX standard, it is defined as a command with unspecified
behavior.</p>

<p style="margin-top: 1em">TEST BUILT-IN <br>
The test built-in evaluates an expression.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; test expression</p>

<p style="margin-top: 1em">&Acirc;&middot; [ expression
]</p>

<p style="margin-top: 1em">The test built-in does not
distinguish options and operands; all command line arguments
are interpreted as expression. If the built-in is executed
with the name [, expression <br>
must be followed by ].</p>

<p style="margin-top: 1em">Description <br>
The test built-in evaluates expression as a conditional
expression that is made up of operators and operands
described below. The exit status is 0 if the condition is
true and 1 <br>
otherwise.</p>

<p style="margin-top: 1em">The unary operators below test a
file. If the operand file is a symbolic link, the file
referred to by the link is tested (except for the -h and -L
operators).</p>

<p style="margin-top: 1em">-b file <br>
file is a block special file</p>

<p style="margin-top: 1em">-c file <br>
file is a character special file</p>

<p style="margin-top: 1em">-d file <br>
file is a directory</p>

<p style="margin-top: 1em">-e file <br>
file exists</p>

<p style="margin-top: 1em">-f file <br>
file is a regular file</p>

<p style="margin-top: 1em">-G file <br>
file&rsquo;s group ID is same as the shell&acirc;s effective
group ID</p>

<p style="margin-top: 1em">-g file <br>
file&rsquo;s set-group-ID flag is set</p>

<p style="margin-top: 1em">-h file <br>
same as -L</p>

<p style="margin-top: 1em">-k file <br>
file&rsquo;s sticky bit is set</p>

<p style="margin-top: 1em">-L file <br>
file is a symbolic link</p>

<p style="margin-top: 1em">-N file <br>
file has not been accessed since last modified</p>

<p style="margin-top: 1em">-O file <br>
file&rsquo;s user ID is same as the shell&acirc;s effective
user ID</p>

<p style="margin-top: 1em">-p file <br>
file is a FIFO (named pipe)</p>

<p style="margin-top: 1em">-r file <br>
file is readable</p>

<p style="margin-top: 1em">-S file <br>
file is a socket</p>

<p style="margin-top: 1em">-s file <br>
file is not empty</p>

<p style="margin-top: 1em">-u file <br>
file&rsquo;s set-user-ID flag is set</p>

<p style="margin-top: 1em">-w file <br>
file is writable</p>

<p style="margin-top: 1em">-x file <br>
file is executable</p>

<p style="margin-top: 1em">The unary operator below tests a
file descriptor:</p>

<p style="margin-top: 1em">-t fd <br>
fd is associated with a terminal</p>

<p style="margin-top: 1em">The unary operators below test a
string:</p>

<p style="margin-top: 1em">-n string <br>
string is not empty</p>

<p style="margin-top: 1em">-z string <br>
string is empty</p>

<p style="margin-top: 1em">The unary operator below tests a
shell option:</p>

<p style="margin-top: 1em">-o ?option <br>
option is a valid shell option name</p>

<p style="margin-top: 1em">-o option <br>
option is a valid shell option name that is enabled</p>

<p style="margin-top: 1em">The binary operators below
compare files. Non-existing files are considered older than
any existing files.</p>

<p style="margin-top: 1em">file1 -nt file2 <br>
file1 is newer than file2</p>

<p style="margin-top: 1em">file1 -ot file2 <br>
file1 is older than file2</p>

<p style="margin-top: 1em">file1 -ef file2 <br>
file1 is a hard link to file2</p>

<p style="margin-top: 1em">The binary operators below
compare strings:</p>

<p style="margin-top: 1em">string1 = string2, string1 ==
string2 <br>
string1 is the same string as string2</p>

<p style="margin-top: 1em">string1 != string2 <br>
string1 is not the same string as string2</p>

<p style="margin-top: 1em">The binary operators below
compare strings according to the alphabetic order in the
current locale:</p>

<p style="margin-top: 1em">string1 === string2 <br>
string1 is equal to string2</p>

<p style="margin-top: 1em">string1 !== string2 <br>
string1 is not equal to string2</p>

<p style="margin-top: 1em">string1 &lt; string2 <br>
string1 is less than string2</p>

<p style="margin-top: 1em">string1 &lt;= string2 <br>
string1 is less than or equal to string2</p>

<p style="margin-top: 1em">string1 &gt; string2 <br>
string1 is greater than string2</p>

<p style="margin-top: 1em">string1 &gt;= string2 <br>
string1 is greater than or equal to string2</p>

<p style="margin-top: 1em">The binary operator below
performs pattern matching:</p>

<p style="margin-top: 1em">string =~ pattern <br>
extended regular expression pattern matches string</p>

<p style="margin-top: 1em">The binary operators below
compare integers:</p>

<p style="margin-top: 1em">v1 -eq v2 <br>
v1 is equal to v2</p>

<p style="margin-top: 1em">v1 -ne v2 <br>
v1 is not equal to v2</p>

<p style="margin-top: 1em">v1 -gt v2 <br>
v1 is greater than v2</p>

<p style="margin-top: 1em">v1 -ge v2 <br>
v1 is greater than or equal to v2</p>

<p style="margin-top: 1em">v1 -lt v2 <br>
v1 is less than v2</p>

<p style="margin-top: 1em">v1 -le v2 <br>
v1 is less than or equal to v2</p>

<p style="margin-top: 1em">The binary operators below
compare version numbers:</p>

<p style="margin-top: 1em">v1 -veq v2 <br>
v1 is equal to v2</p>

<p style="margin-top: 1em">v1 -vne v2 <br>
v1 is not equal to v2</p>

<p style="margin-top: 1em">v1 -vgt v2 <br>
v1 is greater than v2</p>

<p style="margin-top: 1em">v1 -vge v2 <br>
v1 is greater than or equal to v2</p>

<p style="margin-top: 1em">v1 -vlt v2 <br>
v1 is less than v2</p>

<p style="margin-top: 1em">v1 -vle v2 <br>
v1 is less than or equal to v2</p>

<p style="margin-top: 1em">The operators below can be used
to make complex expressions:</p>

<p style="margin-top: 1em">! expression <br>
negate (reverse) the result</p>

<p style="margin-top: 1em">( expression ) <br>
change operator precedence</p>

<p style="margin-top: 1em">expression1 -a expression2 <br>
logical conjunction (and)</p>

<p style="margin-top: 1em">expression1 -o expression2 <br>
logical disjunction (or)</p>

<p style="margin-top: 1em">If the expression is a single
word without operators, the -n operator is assumed. An empty
expression evaluates to false.</p>

<p style="margin-top: 1em">Comparison of version numbers
<br>
Comparison of version numbers is similar to comparison of
strings in alphabetic order. The differences are:</p>

<p style="margin-top: 1em">&Acirc;&middot; Adjacent digits
are treated as an integer. Integers are compared in
mathematical order rather than alphabetic order.</p>

<p style="margin-top: 1em">&Acirc;&middot; Digits are
considered larger than any non-digit characters.</p>

<p style="margin-top: 1em">For example, version numbers
0.1.2-3 and 00.001.02-3 are equal and 0.2.1 is smaller than
0.10.0.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the test built-in is 0 if expression is
true and 1 otherwise. The exit status is 2 if expression
cannot be evaluated because of a syntax error or any other
<br>
reasons.</p>

<p style="margin-top: 1em">Notes <br>
Complex expressions may cause confusion and should be
avoided. Use the shell&acirc;s compound commands. For
example, [ 1 -eq 1 ] &amp;&amp; [ -t = 1 ] &amp;&amp; ! [
foo ] is preferred over [ 1 -eq 1 <br>
-a -t = 1 -a ! foo ].</p>

<p style="margin-top: 1em">The POSIX standard provides that
the exit status should be larger than 1 on error. The POSIX
standard does not define the following operators: -G, -k,
-N, -O, -nt, -ot, -ef, ==, <br>
===, !==, &lt;, &lt;=, &gt;, &gt;=, =~, -veq, -vne, -vgt,
-vge, -vlt, and -vle. POSIX neither specifies -o as a unary
operator.</p>

<p style="margin-top: 1em">TIMES BUILT-IN <br>
The times built-in prints CPU time usage.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; times</p>

<p style="margin-top: 1em">Description <br>
The times built-in prints the CPU times consumed by the
shell process and its child processes to the standard
output.</p>

<p style="margin-top: 1em">The built-in prints two lines:
the first line shows the CPU time of the shell process and
the second one that of its child processes (not including
those which have not <br>
terminated). Each line shows the CPU times consumed in the
user and system mode.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the times built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The times built-in is a special built-in.</p>

<p style="margin-top: 1em">TRAP BUILT-IN <br>
The trap built-in sets or prints signal handlers.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; trap</p>

<p style="margin-top: 1em">&Acirc;&middot; trap action
signal...</p>

<p style="margin-top: 1em">&Acirc;&middot; trap
signal_number [signal...]</p>

<p style="margin-top: 1em">&Acirc;&middot; trap -p
[signal...]</p>

<p style="margin-top: 1em">Description <br>
The trap built-in sets or prints actions that are taken when
the shell receives signals. (Those actions are called
traps.)</p>

<p style="margin-top: 1em">When executed with action and
one or more signals, the built-in sets the traps for signals
to action. If the shell receives one of the signals, the
action will be taken.</p>

<p style="margin-top: 1em">If the first operand is
signal_number instead of action, the built-in resets the
traps for signal_number and signals as if action was -.</p>

<p style="margin-top: 1em">When executed with the -p
(--print) option or with no operands, the built-in prints
currently set traps to the standard output in a format that
can be executed as commands that <br>
restore the current traps. If one or more signals are
specified, only those signals are printed. Otherwise, all
signals with non-default actions are printed. (In some
situations, <br>
however, the built-in may print previous trap settings
instead of the current. See notes below.)</p>

<p style="margin-top: 1em">Options <br>
-p, --print <br>
Print current trap settings.</p>

<p style="margin-top: 1em">Operands <br>
action <br>
An action that will be taken when signal is received.</p>

<p style="margin-top: 1em">If action is a single hyphen
(-), the action is reset to the default action that is
defined by the operating system. If action is an empty
string, the signal is ignored on <br>
receipt. Otherwise, action is treated as a command string:
the string is parsed and executed as commands when the
signal is received. (If a signal is received while a command
<br>
is being executed, the action is taken just after the
command finishes.)</p>

<p style="margin-top: 1em">signal <br>
The number or name of a signal.</p>

<p style="margin-top: 1em">If signal is number 0 or name
EXIT, it is treated as a special imaginary signal that is
always received when the shell exits. The action set for
this signal is taken when the <br>
shell exits normally.</p>

<p style="margin-top: 1em">signal_number <br>
This is like signal, but must be a number.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the trap built-in is zero unless there is
any error.</p>

<p style="margin-top: 1em">Notes <br>
The trap built-in is a special built-in.</p>

<p style="margin-top: 1em">The POSIX standard defines no
options for the trap built-in; the built-in accepts no
options in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">The POSIX standard requires that
signal names must be specified without the SIG-prefix, like
INT and QUIT. As an extension, yash accepts SIG-prefixed
names like SIGINT and <br>
SIGQUIT and treats signal names case-insensitively.</p>

<p style="margin-top: 1em">Reusing output of the built-in
<br>
Output of the trap built-in can be saved in a variable,
which can be later executed by the eval built-in to restore
the traps.</p>

<p style="margin-top: 1em">saved_traps=$(trap) <br>
trap &rsquo;...&rsquo; INT <br>
eval &quot;$saved_traps&quot;</p>

<p style="margin-top: 1em">There are some tricks behind the
scenes to allow this idiom. You use a command substitution
to save the output of the trap built-in in the variable. The
command substitution <br>
is executed in a subshell. The subshell resets all traps
(except ignored ones) at the beginning of itself. This
seemingly would result in (almost) empty output from the
<br>
built-in that would fail to restore the traps as
expected.</p>

<p style="margin-top: 1em">To avoid that pitfall, POSIX
requires the shell to follow one of the two options
below:</p>

<p style="margin-top: 1em">&Acirc;&middot; If a command
substitution just contains a single trap built-in, traps
should not be reset when the subshell is started to execute
the built-in; or</p>

<p style="margin-top: 1em">&Acirc;&middot; A subshell
always resets the traps but remembers the previous traps. If
the trap built-in is executed in the subshell but no other
trap built-in has been executed to <br>
modify traps in the subshell, then the built-in should print
the remembered traps.</p>

<p style="margin-top: 1em">Yash obeys the second.</p>

<p style="margin-top: 1em">TRUE BUILT-IN <br>
The true built-in does nothing successfully.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; true</p>

<p style="margin-top: 1em">Description <br>
The true built-in does nothing. Any command line arguments
are ignored.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the true built-in is zero.</p>

<p style="margin-top: 1em">Notes <br>
The true built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">The true and colon built-ins
have the same effect, but true is a semi-special built-in
while colon is a special.</p>

<p style="margin-top: 1em">TYPE BUILT-IN <br>
The type built-in identifies a command.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; type [-abefkp] [command...]</p>

<p style="margin-top: 1em">Description <br>
The type built-in is equivalent to the command built-in with
the -V option.</p>

<p style="margin-top: 1em">Notes <br>
The POSIX standard does not define the relation between the
type and command built-ins. The standard does not define
options for the type built-in.</p>

<p style="margin-top: 1em">At least one command operand
must be specified in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">The type built-in is a
semi-special built-in.</p>

<p style="margin-top: 1em">TYPESET BUILT-IN <br>
The typeset built-in prints or sets variables or
functions.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; typeset [-gprxX] [variable[=value]...]</p>

<p style="margin-top: 1em">&Acirc;&middot; typeset -f[pr]
[function...]</p>

<p style="margin-top: 1em">Description <br>
If executed without the -f (--functions) option, the typeset
built-in prints or sets variables to the standard output.
Otherwise, it prints or sets functions.</p>

<p style="margin-top: 1em">If executed with the -p
(--print) option, the built-in prints the variables or
functions specified by operands. Without the option, it sets
variables or functions. If no operands <br>
are specified, it prints all existing variables or
functions, regardless of whether the -p (--print) option is
specified.</p>

<p style="margin-top: 1em">Options <br>
-f, --functions <br>
Print or set functions rather than variables.</p>

<p style="margin-top: 1em">-g, --global <br>
When setting a new variable, the variable will be a global
variable if this option is specified. Without this option,
the variable would be a local variable.</p>

<p style="margin-top: 1em">When printing variables, all
existing variables including global variables are printed if
this option is specified. Without this option, only local
variables are printed.</p>

<p style="margin-top: 1em">-p, --print <br>
Print variables or functions in a form that can be parsed
and executed as commands that will restore the currently set
variables or functions.</p>

<p style="margin-top: 1em">-r, --readonly <br>
When setting variables or functions, make them
read-only.</p>

<p style="margin-top: 1em">When printing variables or
functions, print read-only variables or functions only.</p>

<p style="margin-top: 1em">-x, --export <br>
When setting variables, mark them for export, so that they
will be exported to external commands.</p>

<p style="margin-top: 1em">When printing variables, print
exported variables only.</p>

<p style="margin-top: 1em">-X, --unexport <br>
When setting variables, cancel exportation of the
variables.</p>

<p style="margin-top: 1em">Operands <br>
variable (without value) <br>
The name of a variable that is to be set or printed.</p>

<p style="margin-top: 1em">Without the -p (--print) option,
the variable is defined (if not yet defined) but its value
is not set nor changed. Variables that are defined without
values are treated as <br>
unset in parameter expansion.</p>

<p style="margin-top: 1em">variable=value <br>
The name of a variable and its new value.</p>

<p style="margin-top: 1em">The value is assigned to the
variable (regardless of the -p (--print) option).</p>

<p style="margin-top: 1em">function <br>
The name of an existing function that is to be set or
printed.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the typeset built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
A global variable cannot be newly defined if a local
variable has already been defined with the same name. The
local variable will be set regardless of the -g (--global)
option.</p>

<p style="margin-top: 1em">The typeset built-in is a
semi-special built-in. In the POSIX standard, it is defined
as a command with unspecified behavior.</p>

<p style="margin-top: 1em">The export and readonly
built-ins are equivalent to the typeset built-in with the
-gx and -gr options, respectively.</p>

<p style="margin-top: 1em">ULIMIT BUILT-IN <br>
The ulimit built-in sets or prints a resource limit.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; ulimit -a [-H|-S]</p>

<p style="margin-top: 1em">&Acirc;&middot; ulimit [-H|-S]
[-efilnqrstuvx] [limit]</p>

<p style="margin-top: 1em">Description <br>
The ulimit built-in sets or prints a resource limit.</p>

<p style="margin-top: 1em">If executed with the -a (--all)
option, the built-in prints the current limits for all
resource types. Otherwise, it sets or prints the limit of a
single resource type. The <br>
resource type can be specified by the options listed below.
The resource limits will affect the current shell process
and all commands invoked from the shell.</p>

<p style="margin-top: 1em">Each resource type has two limit
values: the hard and soft limit. You can change a soft limit
freely as long as it does not exceed the hard limit. You can
decrease a hard limit <br>
but cannot increase it without a proper permission.</p>

<p style="margin-top: 1em">When the -H (--hard) or -S
(--soft) option is specified, the built-in sets or prints
the hard or soft limit, respectively. If neither of the
options is specified, the built-in <br>
sets both the hard and soft limit or prints the soft
limit.</p>

<p style="margin-top: 1em">Options <br>
-H, --hard <br>
Set or print a hard limit.</p>

<p style="margin-top: 1em">-S, --soft <br>
Set or print a soft limit.</p>

<p style="margin-top: 1em">-a, --all <br>
Print all current limit settings.</p>

<p style="margin-top: 1em">The following options specify
the type of resources. If none of them is specified, -f is
the default. The types of resources that can be set depend
on the operating system.</p>

<p style="margin-top: 1em">-c, --core <br>
Maximum size of core files created (in 512-byte blocks)</p>

<p style="margin-top: 1em">-d, --data <br>
Maximum size of a process&acirc;s data segment (in
kilobytes)</p>

<p style="margin-top: 1em">-e, --nice <br>
Maximum scheduling priority (&acirc;nice&acirc;)</p>

<p style="margin-top: 1em">-f, --fsize <br>
Maximum size of files created by a process (in 512-byte
blocks)</p>

<p style="margin-top: 1em">-i, --sigpending <br>
Maximum number of pending signals</p>

<p style="margin-top: 1em">-l, --memlock <br>
Maximum memory size that can be locked into RAM (in
kilobytes)</p>

<p style="margin-top: 1em">-m, --rss <br>
Maximum size of a process&acirc;s resident set (in
kilobytes)</p>

<p style="margin-top: 1em">-n, --nofile <br>
Maximum file descriptor + 1</p>

<p style="margin-top: 1em">-q, --msgqueue <br>
Maximum size of POSIX message queues</p>

<p style="margin-top: 1em">-r, --rtprio <br>
Maximum real-time scheduling priority</p>

<p style="margin-top: 1em">-s, --stack <br>
Maximum size of a process&acirc;s stack (in kilobytes)</p>

<p style="margin-top: 1em">-t, --cpu <br>
Maximum CPU time that can be used by a process (in
seconds)</p>

<p style="margin-top: 1em">-u, --nproc <br>
Maximum number of processes for a user</p>

<p style="margin-top: 1em">-v, --as <br>
Maximum size of memory used by a process (in kilobytes)</p>

<p style="margin-top: 1em">-x, --locks <br>
Maximum number of file locks</p>

<p style="margin-top: 1em">Operands <br>
limit <br>
A limit to be set.</p>

<p style="margin-top: 1em">The value must be a non-negative
integer or one of hard, soft, and unlimited. If value is
hard or soft, the new limit is set to the current hard or
soft limit. If limit is <br>
not specified, the current limit is printed.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the ulimit built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The POSIX standard defines no options other than -f. It
neither defines hard, soft, or unlimited for limit
values.</p>

<p style="margin-top: 1em">The ulimit built-in is a
semi-special built-in.</p>

<p style="margin-top: 1em">UMASK BUILT-IN <br>
The umask built-in sets or prints the file mode creation
mask.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; umask mask</p>

<p style="margin-top: 1em">&Acirc;&middot; umask [-S]</p>

<p style="margin-top: 1em">Description <br>
If executed without the mask operand, the built-in prints
the current file mode creation mask of the shell to the
standard output in a form that can later be used as mask to
<br>
restore the current mask.</p>

<p style="margin-top: 1em">Otherwise, the built-in sets the
file mode creation mask to mask.</p>

<p style="margin-top: 1em">Options <br>
-S, --symbolic <br>
Print in the symbolic form instead of the octal integer
form.</p>

<p style="margin-top: 1em">Operands <br>
mask <br>
The new file mode creation mask either in the symbolic or
octal integer form.</p>

<p style="margin-top: 1em">Octal integer form <br>
In the octal integer form, the mask is specified as a
non-negative octal integer that is the sum of the following
permissions:</p>

<p style="margin-top: 1em">0400 <br>
read by owner</p>

<p style="margin-top: 1em">0200 <br>
write by owner</p>

<p style="margin-top: 1em">0100 <br>
execute/search by owner</p>

<p style="margin-top: 1em">0040 <br>
read by group</p>

<p style="margin-top: 1em">0020 <br>
write by group</p>

<p style="margin-top: 1em">0010 <br>
execute/search by group</p>

<p style="margin-top: 1em">0004 <br>
read by others</p>

<p style="margin-top: 1em">0002 <br>
write by others</p>

<p style="margin-top: 1em">0001 <br>
execute/search by others</p>

<p style="margin-top: 1em">Symbolic form <br>
In the symbolic form, the mask is specified as a symbolic
expression that denotes permissions that are not included in
the mask.</p>

<p style="margin-top: 1em">The entire expression is one or
more clauses separated by comma. A clause is a sequence of
whos followed by one or more actions.</p>

<p style="margin-top: 1em">A who is one of:</p>

<p style="margin-top: 1em">u <br>
owner</p>

<p style="margin-top: 1em">g <br>
group</p>

<p style="margin-top: 1em">o <br>
others</p>

<p style="margin-top: 1em">a <br>
all of owner, group, and others</p>

<p style="margin-top: 1em">An empty sequence of whos is
equivalent to who a.</p>

<p style="margin-top: 1em">An action is an operator
followed by permission. An operator is one of:</p>

<p style="margin-top: 1em">= <br>
set who&rsquo;s permission to permission</p>

<p style="margin-top: 1em">+ <br>
add permission to who&rsquo;s permission</p>

<p style="margin-top: 1em">- <br>
remove permission from who&rsquo;s permission</p>

<p style="margin-top: 1em">and permission is one of:</p>

<p style="margin-top: 1em">r <br>
read</p>

<p style="margin-top: 1em">w <br>
write</p>

<p style="margin-top: 1em">x <br>
execute/search</p>

<p style="margin-top: 1em">X <br>
execute/search (only if some user already has execute/search
permission)</p>

<p style="margin-top: 1em">s <br>
set-user-ID and set-group-ID</p>

<p style="margin-top: 1em">u <br>
user&acirc;s current permissions</p>

<p style="margin-top: 1em">g <br>
group&acirc;s current permissions</p>

<p style="margin-top: 1em">o <br>
others&rsquo; current permissions</p>

<p style="margin-top: 1em">but more than one of r, w, x, X,
and s can be specified after a single operand.</p>

<p style="margin-top: 1em">For example, the command umask
u=rwx,go+r-w</p>

<p style="margin-top: 1em">&Acirc;&middot; unmasks the
user&acirc;s read, write, and execute/search
permissions;</p>

<p style="margin-top: 1em">&Acirc;&middot; unmasks the
group&acirc;s and others&rsquo; read permission; and</p>

<p style="margin-top: 1em">&Acirc;&middot; masks the
group&acirc;s and others&rsquo; write permission.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the umask built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The umask built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">The POSIX standard does not
require the default output format (used when the -S option
is not specified) to be the octal integer form.</p>

<p style="margin-top: 1em">UNALIAS BUILT-IN <br>
The unalias built-in undefines aliases.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; unalias name...</p>

<p style="margin-top: 1em">&Acirc;&middot; unalias -a</p>

<p style="margin-top: 1em">Description <br>
The unalias built-in removes the definition of the aliases
specified by operands.</p>

<p style="margin-top: 1em">Options <br>
-a, --all <br>
Undefine all aliases.</p>

<p style="margin-top: 1em">Operands <br>
name <br>
The name of an alias to be undefined.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the unalias built-in is zero unless there
is any error. It is an error to specify the name of a
non-existing alias as name.</p>

<p style="margin-top: 1em">Notes <br>
The unalias built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">UNSET BUILT-IN <br>
The unset built-in undefines variables or functions.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; unset [-fv] [name...]</p>

<p style="margin-top: 1em">Description <br>
The unset built-in removes the definition of the variables
or functions specified by operands.</p>

<p style="margin-top: 1em">It is not an error if any of the
specified variables or functions do not exist; they are
silently ignored.</p>

<p style="margin-top: 1em">Options <br>
-f, --functions <br>
Undefine functions.</p>

<p style="margin-top: 1em">-v, --variables <br>
Undefine variables.</p>

<p style="margin-top: 1em">These options are mutually
exclusive: only the last specified one is effective. If
neither is specified, -v is assumed.</p>

<p style="margin-top: 1em">Operands <br>
name <br>
The name of a variable or function to be undefined.</p>

<p style="margin-top: 1em">Exit status <br>
The exit status of the unset built-in is zero unless there
is any error.</p>

<p style="margin-top: 1em">Notes <br>
The unset built-in is a special built-in.</p>

<p style="margin-top: 1em">Although yash does not do so,
the POSIX standard allows removing a function if neither of
the -f and -v options is specified and the specified
variable does not exist.</p>

<p style="margin-top: 1em">At least one name operand must
be specified in the POSIXly-correct mode.</p>

<p style="margin-top: 1em">WAIT BUILT-IN <br>
The wait built-in waits for jobs to terminate.</p>

<p style="margin-top: 1em">Syntax <br>
&Acirc;&middot; wait [job...]</p>

<p style="margin-top: 1em">Description <br>
The wait built-in waits for background jobs to terminate. If
job control is enabled, stopped jobs are considered as
terminated.</p>

<p style="margin-top: 1em">The built-in can be used to wait
for asynchronous commands if job control is disabled.</p>

<p style="margin-top: 1em">If the shell receives a signal
while the built-in is waiting and if a trap has been set for
the signal, then the trap is executed and the built-in
immediately finishes (without <br>
waiting for the jobs). If the shell receives a SIGINT signal
when job control is enabled, the built-in aborts
waiting.</p>

<p style="margin-top: 1em">Operands <br>
job <br>
The job ID of the job or the process ID of a process in the
job.</p>

<p style="margin-top: 1em">If no jobs are specified, the
built-in waits for all existing jobs.</p>

<p style="margin-top: 1em">If the specified job does not
exist, the job is considered to have terminated with the
exit status of 127.</p>

<p style="margin-top: 1em">Exit status <br>
If no jobs were specified and the built-in successfully
waited for all the jobs, the exit status is zero. If one or
more jobs were specified, the exit status is that of the
last <br>
job.</p>

<p style="margin-top: 1em">If the built-in was aborted by a
signal, the exit status is an integer (&gt; 128) that
denotes the signal. If there was any other error, the exit
status is between 1 and 126 <br>
(inclusive).</p>

<p style="margin-top: 1em">Notes <br>
The wait built-in is a semi-special built-in.</p>

<p style="margin-top: 1em">The process ID of the last
process of a job can be obtained by the ! special parameter.
You can use the jobs built-in as well to obtain process IDs
of job processes.</p>

<p style="margin-top: 1em">AUTHOR <br>
Yuki Watanabe &lt;magicant@users.osdn.me&gt; <br>
Author.</p>

<p style="margin-top: 1em">2.45 2017-07-05 YASH(1)</p>
<hr>
</body>
</html>
